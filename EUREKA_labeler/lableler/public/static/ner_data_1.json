[{"text": "a single null key is allowed (as keys must be unique) but the HashMap can have any number of null values, and a null key need not have a null value", "label": {"api": {"HashMap": [[62, 68]]}}}, {"text": "HashMap] permits null values and [a] null key", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "It overrides the value at key null", "label": {"api": {"It overrides the value at key null": [[0, 33]]}}}, {"text": "If you need them to be in order you could use a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[48, 60]]}}}, {"text": "If you need to separate threads then you will want something like a BlockingQueue, have one thread read and push to the queue - the other read pull from the queue and write", "label": {"api": {"BlockingQueue": [[68, 80]]}}}, {"text": "To make sure the ArrayList is sent  a second time, you need to call reset() on the ObjectOutputStream", "label": {"api": {"reset()": [[68, 74]]}}}, {"text": "You can format the result from the Integer.toBinaryString(int i) method with the String.format(String pattern, Object ..", "label": {"api": {"Integer.toBinaryString(int i)": [[35, 63]]}}}, {"text": "To reverse the process, use a KeyFactory with a PKCS8EncodedKeySpec as follows", "label": {"api": {"KeyFactory": [[30, 39]], "PKCS8EncodedKeySpec": [[48, 66]]}}}, {"text": "The class BasicFileAttributes, for examining the properties of a file in the file system, has the method isRegularFile()", "label": {"api": {"BasicFileAttributes": [[10, 28]], "isRegularFile()": [[105, 119]]}}}, {"text": "However, there apparently is some type of \"irregular file\" because a method exists called isOther(), which returns true if it's not a directory, symbolic link, or \"regular file\"", "label": {"api": {"isOther()": [[90, 98]]}}}, {"text": "I found nothing helpful in http://docs.oracle.com/javase/7/docs/api/java/io/FileDescriptor.html#sync..", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/FileDescriptor.html#sync": [[27, 99]]}}}, {"text": "You can use the java.text.DecimalFormat class to format decimal numbers", "label": {"api": {"java.text.DecimalFormat": [[16, 38]]}}}, {"text": "To understand how to do this you should really read the documentation for regular expressions in the Java API - particularly at the section \"Special constructs (named-capturing and non-capturing)\"", "label": {"api": {"Java API": [[101, 108]]}}}, {"text": "In Addition, if you are not already aware of java has a Point2D class which has a distance(double px, double py) function", "label": {"api": {"Point2D": [[56, 62]], "distance(double px, double py)": [[82, 111]]}}}, {"text": "hasNext doesn't consume the input", "label": {"api": {"hasNext doesn't consume the input": [[0, 32]]}}}, {"text": "Have a look at CountDownLatch", "label": {"api": {"CountDownLatch": [[15, 28]]}}}, {"text": "The java.util.Calendar class has support for daylight savings", "label": {"api": {"java.util.Calendar": [[4, 21]]}}}, {"text": "When using String.replaceAll or any of the applicable Matcher replacers, pay attention to the replacement string and how it is handled", "label": {"api": {"String.replaceAll": [[11, 27]]}}}, {"text": "As pointed out by isnot2bad in a comment, Matcher.quoteReplacement may be useful here", "label": {"api": {"Matcher.quoteReplacement": [[42, 65]]}}}, {"text": "Or, if you are already on the JavaFX application thread, you could use a Service", "label": {"api": {"Service": [[73, 79]]}}}, {"text": "Usually, this is done using the java.beans.Introspector and getPropertyDescriptors()", "label": {"api": {"java.beans.Introspector": [[32, 54]], "getPropertyDescriptors()": [[60, 83]]}}}, {"text": "Date doesn't have a format at all", "label": {"api": {"Date": [[0, 3]]}}}, {"text": "You can only get a String representation of the Date in the format required using the SimpleDateFormat", "label": {"api": {"Date": [[48, 51], [92, 95]], "SimpleDateFormat": [[86, 101]]}}}, {"text": "Also, parse() method of SDF parses the String representation of the Date to a Date object", "label": {"api": {"Date": [[68, 71], [78, 81]]}}}, {"text": "format() is the method which gives the formatted String representation of the Date object", "label": {"api": {"Date": [[78, 81]]}}}, {"text": "You need to use setText() method of JTextField", "label": {"api": {"setText()": [[16, 24]]}}}, {"text": "Use split as shown below", "label": {"api": {"split": [[4, 8]]}}}, {"text": "If you opt for the first option, you can wrap a CipherInputStream around it", "label": {"api": {"CipherInputStream": [[48, 64]]}}}, {"text": "You can have a @Schedule annotation in an EJB, which instructs the application server to call it every N seconds/minutes/..", "label": {"api": {"@Schedule": [[15, 23]]}}}, {"text": "Take a look at the Socket's javadoc for instructions on how to set a timeout", "label": {"api": {"Socket's javadoc": [[19, 34]]}}}, {"text": "Otherwise use a CountDownLatch, Semaphore, .", "label": {"api": {"CountDownLatch": [[16, 29]], "Semaphore": [[32, 40]]}}}, {"text": "from the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[9, 28]]}}}, {"text": "You could also use containsKey() method", "label": {"api": {"containsKey()": [[19, 31]]}}}, {"text": "Use a ReentrantReadWriteLock to protect modification with the write lock and reading with the read lock", "label": {"api": {"ReentrantReadWriteLock": [[6, 27]]}}}, {"text": "there are set of methods implemented in API that created undecorated JButton, e.g", "label": {"api": {"there are set of methods implemented in API": [[0, 42]]}}}, {"text": "If your question is just how to create a temporary file without caring about how to name it and where to create it without overwriting existing files, then you can simply use File.createTempFile", "label": {"api": {"File.createTempFile": [[175, 193]]}}}, {"text": "You might also want to have a look at File.deleteOnExit", "label": {"api": {"File.deleteOnExit": [[38, 54]]}}}, {"text": "Later on, I would like to recover the selected value using JOptionPane#getValue() method", "label": {"api": {"JOptionPane#getValue()": [[59, 80]]}}}, {"text": "Your idea about interrupting the threads is pretty much the right thing to do, except I'd avoid interruption and instead post an event to, say, a LinkedBlockingQueue which you poll at the end of the test to see if it is empty or not", "label": {"api": {"a LinkedBlockingQueue which you poll at the end of the test to see if it is empty or not": [[144, 231]]}}}, {"text": "Use JEditorPane.read(InputStream,Object) - much easier", "label": {"api": {"JEditorPane.read(InputStream,Object)": [[4, 39]]}}}, {"text": "Use the String.split(String) method to split the sentence by spaces", "label": {"api": {"String.split(String)": [[8, 27]]}}}, {"text": "This is a result of the object's default toString() method which prints out the class name and the hash code", "label": {"api": {"toString()": [[41, 50]]}}}, {"text": "You can actually change this by overriding the toString() method in the class of the object that you want to print out", "label": {"api": {"toString()": [[47, 56]]}}}, {"text": "However, instead of printing the object itself, you'd have to call toString() on the object", "label": {"api": {"toString()": [[67, 76]]}}}, {"text": "What you are seeing output by your program is the String returned by the default implementation of toString()", "label": {"api": {"toString()": [[99, 108]]}}}, {"text": "When you call PrintStream.println(Object), which is what System.out.println(demo) is doing, the PrimeStream needs to convert the object passed, in this case your Demo object to a String, which it does by simply calling its toString() method", "label": {"api": {"toString()": [[223, 232]], "PrintStream.println(Object)": [[14, 40]], "PrimeStream": [[96, 106]]}}}, {"text": "If you haven't overridden toString() in you class then you get the default behavior", "label": {"api": {"toString()": [[26, 35]]}}}, {"text": "You can use String.indexOf(int) to check if a specific character is in your string or not (it will return -1 if it's not in it)", "label": {"api": {"String.indexOf(int)": [[12, 30]]}}}, {"text": "You can use String.toCharArray() to get an array of all the characters you don't want and iterate this array per character", "label": {"api": {"String.toCharArray()": [[12, 31]]}}}, {"text": "Supply a converter to the combo box, to convert from a string to your ListGroupsObj type and back", "label": {"api": {"converter": [[9, 17]]}}}, {"text": "Use an XMLOutputer with a FileOutputStream", "label": {"api": {"FileOutputStream": [[26, 41]]}}}, {"text": "Use Character.isWhitespace(ch), e.g", "label": {"api": {"Character.isWhitespace(ch)": [[4, 29]]}}}, {"text": "Arrays.toString(char[] a) will do that for you", "label": {"api": {"Arrays.toString(char[] a)": [[0, 24]]}}}, {"text": "Use an appropriate TreeCellRenderer", "label": {"api": {"TreeCellRenderer": [[19, 34]]}}}, {"text": "See Comparator#compare for a description of how that works but that's basically it to sort", "label": {"api": {"Comparator#compare": [[4, 21]]}}}, {"text": "You'd need to implement the built in interface java.util.List", "label": {"api": {"java.util.List": [[47, 60]]}}}, {"text": "It would need to define all the methods listed in the interface java.util.List", "label": {"api": {"java.util.List": [[64, 77]]}}}, {"text": "To answer the question in the comment, \"How would I go about writing my own Comparator for a Linked List?\"", "label": {"api": {"Comparator": [[76, 85]]}}}, {"text": "See the javadoc for Comparator, especially the text at the top", "label": {"api": {"Comparator": [[20, 29]]}}}, {"text": "You could define more than one class that implements Comparator<Person>", "label": {"api": {"Comparator": [[53, 62]]}}}, {"text": "StreamSource has a constructor taking a Reader as argument", "label": {"api": {"a constructor taking a Reader": [[17, 45]]}}}, {"text": "Similarly, the StreamResult constructor the example uses takes an OutputStream as argument", "label": {"api": {"the StreamResult constructor the example uses": [[11, 55]]}}}, {"text": "Then iterate on the created array and set the text", "label": {"api": {"set": [[38, 40]]}}}, {"text": "Rather than implement the interface, consider extending HttpServletRequestWrapper", "label": {"api": {"HttpServletRequestWrapper": [[56, 80]]}}}, {"text": "If you need to be able to implement different, incompatible interface versions, consider creating a proxy", "label": {"api": {"creating a proxy": [[89, 104]]}}}, {"text": "I suppose what you actually want to use is the WeakHashMap (http://docs.oracle.com/javase/6/docs/api/java/util/WeakHashMap.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/WeakHashMap.html": [[60, 126]]}}}, {"text": "Since you're attempting to see if a value is larger than, greater than, or equal to another, then consider using Comparable instead", "label": {"api": {"Comparable": [[113, 122]]}}}, {"text": "An Integer is a Comparable entity, so you can simply do this", "label": {"api": {"Comparable": [[16, 25]]}}}, {"text": "To achieve what you want, use Character.getNumericValue(char ch)", "label": {"api": {"Character.getNumericValue(char ch)": [[30, 63]]}}}, {"text": "If you use Java 8, you can set the WebView user agent string directly on the WebEngine, so you probably don't need a custom URLConnection if that is all you want to achieve", "label": {"api": {"URLConnection": [[124, 136]]}}}, {"text": "Read this javadoc", "label": {"api": {"this javadoc": [[5, 16]]}}}, {"text": "Use Desktop.browse(URI), which.", "label": {"api": {"Desktop.browse(URI)": [[4, 22]]}}}, {"text": "While I generally try not to mix model and view, your requirement has me thinking of a writeableraster", "label": {"api": {"writeableraster": [[87, 101]]}}}, {"text": "A writeableraster is a 1d array of pixels, but it starts at the upper left hand corner of the window and iterates rows and columns until it gets to the lower right hand corner", "label": {"api": {"writeableraster": [[2, 16]]}}}, {"text": "I would do something like this (note you can have as many digits of precision as you like) utilizing BigDecimal", "label": {"api": {"BigDecimal": [[101, 110]]}}}, {"text": "You could also make it threadsafe by using an java.util.concurrent.atomic.AtomicInteger with getAndIncrement()", "label": {"api": {"java.util.concurrent.atomic.AtomicInteger": [[46, 86]]}}}, {"text": "You can use Math.toRadians() to convert degrees to radians", "label": {"api": {"Math.toRadians()": [[12, 27]]}}}, {"text": "Starting with Java 7, you can do it in a single line of code", "label": {"api": {"you can do it in a single line of code": [[22, 59]]}}}, {"text": "The docs [MidiDevice.open()] for player.open()  says", "label": {"api": {"docs [MidiDevice.open()]": [[4, 27]]}}}, {"text": "When you create a TransferHandler using the constructor that takes a String, you create a TransferHandler that can only perform transfers within the same JVM", "label": {"api": {"the constructor that takes a String": [[40, 74]]}}}, {"text": "A java.awt.Image, represented by DataFlavor.imageFlavor", "label": {"api": {"DataFlavor.imageFlavor": [[33, 54]]}}}, {"text": "A List of Files (List<File>), represented by DataFlavor.javaFileListFlavor", "label": {"api": {"DataFlavor.javaFileListFlavor": [[45, 73]]}}}, {"text": "In order to add items to the map, you can use Map#put(K, V)", "label": {"api": {"Map#put(K, V)": [[46, 58]]}}}, {"text": "In order to get a value, you can use Map#get(Object)", "label": {"api": {"Map#get(Object)": [[37, 51]]}}}, {"text": "See JDK 1.7 Map documentation for more information about maps", "label": {"api": {"JDK 1.7 Map documentation": [[4, 28]]}}}, {"text": "You can use the java.util.Collections for that", "label": {"api": {"java.util.Collections": [[16, 36]]}}}, {"text": "By default, iterators of a LinkedHashMap will return its key and entries in insertion order", "label": {"api": {"LinkedHashMap": [[27, 39]]}}}, {"text": "I would really recommend ConcurrentHashMap, or making the entire method (or most of it) synchronized", "label": {"api": {"ConcurrentHashMap": [[25, 41]]}}}, {"text": "According to String.split(String) javadoc \"trailing empty strings are not included in the resulting array\"", "label": {"api": {"String.split(String) javadoc": [[13, 40]]}}}, {"text": "In your case, you may want to use a Timer, which handles a background thread for you automatically", "label": {"api": {"Timer": [[36, 40]]}}}, {"text": "If instead you want to retrieve a particular object at any time, look into a Map instead", "label": {"api": {"Map": [[77, 79]]}}}, {"text": "As mentioned, you have to use Math.pow in Java for exponentiation", "label": {"api": {"Math.pow": [[30, 37]]}}}, {"text": "You should use System.getenv(), for example", "label": {"api": {"System.getenv()": [[15, 29]]}}}, {"text": "In case anyone is coming here and wondering how to get a specific environment variable without looping through all of your system variables you can use getenv(String name)", "label": {"api": {"getenv(String name)": [[152, 170]]}}}, {"text": "You can use Process#waitFor()", "label": {"api": {"Process#waitFor()": [[12, 28]]}}}, {"text": "The above PrintStream will perform a (potentially lossy) transcoding operation", "label": {"api": {"PrintStream": [[10, 20]]}}}, {"text": "All characters printed by a PrintStream are converted into bytes using the platform's default character encoding", "label": {"api": {"PrintStream": [[28, 38]]}}}, {"text": "String.replace(CharSequence first, CharSequence second) returns a new String reference and this is why the output is different", "label": {"api": {"String.replace(CharSequence first, CharSequence second)": [[0, 54]]}}}, {"text": "Use replaceItem to change the item", "label": {"api": {"replaceItem": [[4, 14]]}}}, {"text": "Use Process.getOutputStream() and write your input data there", "label": {"api": {"Process.getOutputStream()": [[4, 28]]}}}, {"text": "I think you need ArrayList.addAll()", "label": {"api": {"ArrayList.addAll()": [[17, 34]]}}}, {"text": "I would go for a ExecutorService with a fixed thread pool size", "label": {"api": {"ExecutorService": [[17, 31]]}}}, {"text": "Your master thread can either feed directly to the executor service or you can disconnect them via a BlockingQueue", "label": {"api": {"BlockingQueue": [[101, 113]]}}}, {"text": "To go the other way and read the Blob from the database as a stream in chunks, you could call the Blob's getBinaryStream method, giving you the InputStream and allowing you to set the buffer size later if needed", "label": {"api": {"getBinaryStream": [[105, 119]]}}}, {"text": "You can use lastIndexOf(' ') with the substring method", "label": {"api": {"lastIndexOf(' ')": [[12, 27]], "substring": [[38, 46]]}}}, {"text": "Comparing the two docs for Java 6 and 7 I see no mention in the first one whether 0L might be returned \"because of an I/O exception\" (quite a broad description), as well", "label": {"api": {"Java 6": [[27, 32]]}}}, {"text": "Additionally, if Java 6 behaves the same, I expect there would be a way to check for this distinction (java.nio.file.Files), which again seems to lack", "label": {"api": {"Java 6": [[17, 22]], "java.nio.file.Files": [[103, 121]]}}}, {"text": "I am wondering about the intended usage of the Types.NULL  constant in the JDBC", "label": {"api": {"Types.NULL": [[47, 56]]}}}, {"text": "I am guessing from the javadoc that a literal value in a SQL statement can have the type Types.NULL", "label": {"api": {"Types.NULL": [[89, 98]]}}}, {"text": "For example, the null literal in this statement, could have the type Types.NULL", "label": {"api": {"Types.NULL": [[69, 78]]}}}, {"text": "I am also guessing that you cannot have a column that is the type Types.NULL because it is not a 'SQL Type'", "label": {"api": {"Types.NULL": [[66, 75]]}}}, {"text": "Use equalsIgnoreCase instead of equals", "label": {"api": {"equalsIgnoreCase": [[4, 19]]}}}, {"text": "The Java Executor framework offers the DefaultThreadFactory for creating threads", "label": {"api": {"DefaultThreadFactory": [[39, 58]]}}}, {"text": "Is DefaultThreadFactory itself safe for concurrent use by multiple threads", "label": {"api": {"DefaultThreadFactory": [[3, 22]]}}}, {"text": "Or must I take care to have only one DefaultThreadFactory per thread", "label": {"api": {"DefaultThreadFactory": [[37, 56]]}}}, {"text": "It would be great if the answer included a short explanation of why you are sure that DefaultThreadFactory is thread-safe or not", "label": {"api": {"DefaultThreadFactory": [[86, 105]]}}}, {"text": "I know the documentation http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html has an Iterator, but how is that actually implemented", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html": [[25, 87]]}}}, {"text": "Use Arrays#deepToString instead", "label": {"api": {"Arrays#deepToString": [[4, 22]]}}}, {"text": "Have a look at SimpleDateFormat, you should be able to figure out the rest on your own", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "If you can't count on java being run from the same location every time, you can use an environment variable to point to the location that your files are sitting in", "label": {"api": {"use an environment variable": [[80, 106]]}}}, {"text": "You can register the filter in the client via a Feature", "label": {"api": {"Feature": [[48, 54]]}}}, {"text": "the Feature (you can extract it in a class of its own)", "label": {"api": {"Feature": [[4, 10]]}}}, {"text": "You can use Timer as shown below", "label": {"api": {"Timer": [[12, 16]]}}}, {"text": "As per JPQL specification, there is no way to create new tables or entities", "label": {"api": {"JPQL specification": [[7, 24]]}}}, {"text": "From Java Docs", "label": {"api": {"From Java Docs": [[0, 13]]}}}, {"text": "If you want asynchronous I/O, you need to use an AsynchronousSocketChannel", "label": {"api": {"AsynchronousSocketChannel": [[49, 73]]}}}, {"text": "You can just give the relative or absolute file path when specifying the file name in the FileOutputStream", "label": {"api": {"FileOutputStream": [[90, 105]]}}}, {"text": "The java.beans package already provides such a feature", "label": {"api": {"java.beans": [[4, 13]]}}}, {"text": "Then I just added a @Timeout annotation to my method, and used the TimerService#createTimer() method to add a new trigger", "label": {"api": {"TimerService#createTimer()": [[67, 92]]}}}, {"text": "I never needed it, but I think the way to go is to get the JDBC connection and find in its properties that piece of information", "label": {"api": {"JDBC connection": [[59, 73]]}}}, {"text": "In particular getClientInfo() and getMetaData() might be interesting", "label": {"api": {"getClientInfo()": [[14, 28]], "getMetaData()": [[34, 46]]}}}, {"text": "I recommend you to use StringBuilder instead of +", "label": {"api": {"StringBuilder": [[23, 35]]}}}, {"text": "The value of an Element node is always null by design", "label": {"api": {"Element": [[16, 22]]}}}, {"text": "See the Node documentation for a list of expected values", "label": {"api": {"Node documentation": [[8, 25]]}}}, {"text": "FileHandler throws OverlappingFileLockException", "label": {"api": {"FileLock": [[30, 37]]}}}, {"text": "The FileHandler documentation doesn't declare that OverlappingFileLockException can be thrown from the constructor", "label": {"api": {"FileLock": [[62, 69]]}}}, {"text": "Reading the FileChannel.tryLock documentation it appears that failure to acquire a lock can be indicated by returning null or throwing an OverlappingFileLockException", "label": {"api": {"FileChannel.tryLock": [[12, 30]], "FileLock": [[149, 156]]}}}, {"text": "The FileHandler.openFiles method doesn't seem to handle the case of OverlappingFileLockException being thrown since it extends IllegalStateException", "label": {"api": {"FileLock": [[79, 86]]}}}, {"text": "Having said that, from the NIO FileLock documentation, \"In general, great care should be taken when locking files that reside on network filesystems.\"  So even if this bug is fixed it still may not be possible to what you are trying to do per contract of the Java API", "label": {"api": {"FileLock": [[31, 38]]}}}, {"text": "You want Math.round() or - if you always want to round up - Math.ceil()", "label": {"api": {"Math.round()": [[9, 20]]}}}, {"text": "Add a WindowListner to your JFrame and override windowClosing method and do a pop-up with JOptionPane warning user", "label": {"api": {"WindowListner": [[6, 18]], "windowClosing": [[48, 60]]}}}, {"text": "When you need a boxed type which is mutable, you can use the Atomic*-variants of them, like AtomicInteger", "label": {"api": {"AtomicInteger": [[92, 104]]}}}, {"text": "This is done by calling the FileWriter(File, boolean) constructor", "label": {"api": {"FileWriter(File, boolean)": [[28, 52]]}}}, {"text": "BTW, if all you want to do is delete a file upon JVM shut down, you can ask the runtime to do so using File.deleteOnExit", "label": {"api": {"File.deleteOnExit": [[103, 119]]}}}, {"text": "You can use System.setOut to install your own OutputStream", "label": {"api": {"System.setOut": [[12, 24]]}}}, {"text": "Wrap the OutputStream  with a ByteArrayOutputStream, then use toByteArray()", "label": {"api": {"toByteArray()": [[62, 74]]}}}, {"text": "You can use the Date#after(Date when) and Date#before(Date otherDate) methods to compare dates and achive some order", "label": {"api": {"Date#after(Date when)": [[16, 36]], "Date#before(Date otherDate)": [[42, 68]]}}}, {"text": "Use a Calendar object instead", "label": {"api": {"Calendar": [[6, 13]]}}}, {"text": "FacesContext.addMessage requires the component's clientId, not the message id", "label": {"api": {"FacesContext.addMessage": [[0, 22]]}}}, {"text": "If you want to use the IN JPQL operator, then use @EmbeddedId", "label": {"api": {"@EmbeddedId": [[50, 60]]}}}, {"text": "For more information, pay a visit to the java.text.NumberFormat documentation", "label": {"api": {"the java.text.NumberFormat": [[37, 62]]}}}, {"text": "You can get selected object(getSelectedItem() method) and convert it to Float like next", "label": {"api": {"getSelectedItem()": [[28, 44]]}}}, {"text": "If you look at the docs for AudioInputStream#read and SourceDataLine#write, you'll see that the number of bytes to read/write must be an integral number of sample frames", "label": {"api": {"AudioInputStream#read": [[28, 48]], "SourceDataLine#write": [[54, 73]]}}}, {"text": "The \"memory address\" printed is part of Object's toString() method, and you haven't overridden toString()", "label": {"api": {"Object's toString() method": [[40, 65]]}}}, {"text": "You must use this expression (+1) as the sole argument to the substring method", "label": {"api": {"substring": [[62, 70]]}}}, {"text": "You could use String.replaceAll(String, String) to find the = sign and replace everything afterwards", "label": {"api": {"String.replaceAll(String, String)": [[14, 46]]}}}, {"text": "Or you could use String.substring(int, int) to create a substring from the first character up to and including the = sign", "label": {"api": {"String.substring(int, int)": [[17, 42]]}}}, {"text": "Create a new Calendar object (GregorianCalendar is most probable) and use getTimeInMillis()", "label": {"api": {"Calendar": [[13, 20], [39, 46]], "GregorianCalendar": [[30, 46]], "getTimeInMillis()": [[74, 90]]}}}, {"text": "I see that addActionListener() implementation is using EventListenerList so I've tried to do something like in example but seems that example can't produce full working issue", "label": {"api": {"EventListenerList": [[55, 71]]}}}, {"text": "You should use StringBuilder instead of +=", "label": {"api": {"StringBuilder": [[15, 27]]}}}, {"text": "Since TreeMap is a NavigableMap, it is computationally cheap to iterate the map starting from a given key", "label": {"api": {"NavigableMap": [[19, 30]]}}}, {"text": "If not, you could/should use the Collections.sort(List) or Collections.sort(List, Comparator) method", "label": {"api": {"Collections.sort(List)": [[33, 54]], "Collections.sort(List, Comparator)": [[59, 92]]}}}, {"text": "What about using Arrays.toString()", "label": {"api": {"Arrays.toString()": [[17, 33]]}}}, {"text": "Seems like CyclicBarrier is what you need", "label": {"api": {"CyclicBarrier": [[11, 23]]}}}, {"text": "There is also Phaser which is an advanced version of CyclicBarrier and it requires JDK 7 to run", "label": {"api": {"CyclicBarrier": [[53, 65]], "Phaser": [[14, 19]]}}}, {"text": "Is it possible to get this constructor of A via the A.class.getDeclaredConstructor(...) method and how does the call look like", "label": {"api": {"A.class.getDeclaredConstructor(...)": [[52, 86]]}}}, {"text": "If you're looking for a different solution than Regexp you could use a StringTokenizer to separate them using the space/tab", "label": {"api": {"StringTokenizer": [[71, 85]]}}}, {"text": "In the substring method, the first index is inclusive, and the second index is exclusive", "label": {"api": {"substring": [[7, 15]]}}}, {"text": "Also, note that counting starts with 0, so to get GG from RRGGBB you have to call substring(2, 4)", "label": {"api": {"substring": [[82, 90]]}}}, {"text": "You might want to use String.format instead for formatting the hex string", "label": {"api": {"String.format": [[22, 34]], "formatting": [[48, 57]]}}}, {"text": "executeQuery() is for quires (usually SELECT) that return a ResultSet", "label": {"api": {"executeQuery()": [[0, 13]]}}}, {"text": "With DML (and DDL) queries you need to use executeUpdate() method", "label": {"api": {"executeUpdate()": [[43, 57]]}}}, {"text": "This mechanism is described -- albeit very briefly -- in the class documentation for RMISocketFactory", "label": {"api": {"RMISocketFactory": [[85, 100]]}}}, {"text": "However, if you don't add, then the println method that takes a char is called, and '2' is printed", "label": {"api": {"println method that takes a char": [[36, 67]]}}}, {"text": "The REST endpoint is essentially an implementation of StreamingOutput, wrapped it a Response object that is handed off to the container when a client requests", "label": {"api": {"StreamingOutput": [[54, 68]], "Response": [[84, 91]]}}}, {"text": "I would like the data to be sent to the client as soon as I invoke flush on the OutputStream which the container hands off to my implementation of StreamingOutput", "label": {"api": {"StreamingOutput": [[147, 161]]}}}, {"text": "In the filter I grabbed the HttpServletResponse and the OutputStream implementation that CXF used (the one that wouldn't let me flush) from the Message implementation, wrapping them in a FilteredOutputStream", "label": {"api": {"HttpServletResponse": [[28, 46]]}}}, {"text": "Whenever flush is invoked I explicitly invoke flush on the HttpServletResponse", "label": {"api": {"HttpServletResponse": [[59, 77]]}}}, {"text": "This sample relies heavily on the utils in the Arrays class, but you can certainly build your version with optimized hashCode() and equals() that better suite your needs", "label": {"api": {"Arrays": [[47, 52]]}}}, {"text": "If you simply want to add IDs to the end of the file, use the following FileWriter constructor", "label": {"api": {"FileWriter": [[72, 81]]}}}, {"text": "This opens the FileWriter in append mode, allowing you to write output to a pre-existing file", "label": {"api": {"FileWriter": [[15, 24]]}}}, {"text": "For more information, see the JavaDoc for FileWriter", "label": {"api": {"FileWriter": [[42, 51]]}}}, {"text": "@Deprecated is an annotation that is read by the compiler, used to mark a method as deprecated to the compiler and will generate a deprecation compile-time warning if the method is used", "label": {"api": {"@Deprecated": [[0, 10]]}}}, {"text": "It only makes sense to use this tag in conjunction to the @Deprecated annotation", "label": {"api": {"@Deprecated": [[58, 68]]}}}, {"text": "To answer your question more specifically, you should use either @Deprecated or both because it makes no sense that you would want this information to be restricted to the documentation while withholding it from the compiler", "label": {"api": {"@Deprecated": [[65, 75]]}}}, {"text": "@Deprecated marks your method as deprecated to any tool that cares about it (such as IDEs), as it is available at runtime and compile-time", "label": {"api": {"@Deprecated": [[0, 10]]}}}, {"text": "Additionally, the javadoc tool does take notice of @Deprecated even if you didn't add any information regarding the deprecation by using @deprecated", "label": {"api": {"@Deprecated": [[51, 61]]}}}, {"text": "In this case, findbugs is most likely referring to your call to File.renameTo()", "label": {"api": {"File.renameTo()": [[64, 78]]}}}, {"text": "You're using getAttribute, but I suspect you wanted getParameter (if you're trying to get information submitted as part of a GET or POST request)", "label": {"api": {"getAttribute": [[13, 24]], "getParameter": [[52, 63]]}}}, {"text": "Here's what getAttribute works with", "label": {"api": {"getAttribute": [[12, 23]]}}}, {"text": "Here's what getParameter works with", "label": {"api": {"getParameter": [[12, 23]]}}}, {"text": "It's good to have a look at Pattern#quote that returns a literal pattern String", "label": {"api": {"Pattern#quote": [[28, 40]]}}}, {"text": "You can use a combination of replaceAll() calls like this", "label": {"api": {"replaceAll()": [[29, 40]]}}}, {"text": "Well, as documentation for writeBytes states, it simply writes the sequence of bytes (in your case regular ASCII symbols", "label": {"api": {"writeBytes": [[27, 36]]}}}, {"text": "From the Java API URLDecoder", "label": {"api": {"URLDecoder": [[18, 27]]}}}, {"text": "You can use Collections#sort with a Comparator to sort the time intervals and use Interval#gap to check for gaps", "label": {"api": {"Collections#sort": [[12, 27]], "Comparator": [[36, 45]]}}}, {"text": "I think java.util.EnumMap may be what you're looking for", "label": {"api": {"java.util.EnumMap": [[8, 24]]}}}, {"text": "You can use Enum#valueOf to look up the enum value from the given String, like Sam Yonnou mentioned", "label": {"api": {"Enum#valueOf": [[12, 23]]}}}, {"text": "System#currentTimeMillis returns long and not double", "label": {"api": {"System#currentTimeMillis": [[0, 23]]}}}, {"text": "You want to do a precise measurements time, it's better to use System#nanoTime, since it gives time in nano seconds", "label": {"api": {"System#nanoTime": [[63, 77]]}}}, {"text": "By default JPanel has a FlowLayout as layout manager and this one doesn't honor the components preferred size", "label": {"api": {"JPanel": [[11, 16]]}}}, {"text": "There is one ServerSocket", "label": {"api": {"ServerSocket": [[13, 24]], "Socket": [[19, 24]]}}}, {"text": "It accepts incoming connections through the accept() method", "label": {"api": {"accept()": [[44, 51]]}}}, {"text": "This returns a Socket which you use on the server side to handle the connection to a particular client", "label": {"api": {"Socket": [[15, 20]]}}}, {"text": "By definition, they are all different to one another", "label": {"api": {"By definition,": [[0, 13]]}}}, {"text": "This AtomicEnum is simply a thin wrapper around an AtomicReference, which makes sense since a n enum value is simply an object (reference)", "label": {"api": {"AtomicReference": [[51, 65]]}}}, {"text": "So if AtomicReference works correctly (and I think we can assume that), the AtomicEnum will work as well", "label": {"api": {"AtomicReference": [[6, 20]]}}}, {"text": "You're using replaceAll(), which takes a regular expression", "label": {"api": {"replaceAll()": [[13, 24]]}}}, {"text": "Use replace() instead, which works with literal strings", "label": {"api": {"replace()": [[4, 12]]}}}, {"text": "The first parameter of replaceAll() is a REGEX, and '.' means any character in REGEX area", "label": {"api": {"replaceAll()": [[23, 34]]}}}, {"text": "Consider using a java.awt.TexturePaint, illustrated here and here, constructed using a BufferedImage containing your Logo.png", "label": {"api": {"java.awt.TexturePaint": [[17, 37]]}}}, {"text": "Get the model, and use the DefaultTableModel#getValueAt() method", "label": {"api": {"DefaultTableModel#getValueAt()": [[27, 56]]}}}, {"text": "hasNext() doesn't consume any input", "label": {"api": {"hasNext()": [[0, 8]]}}}, {"text": "Add a call to next() inside the while loop to consume the input", "label": {"api": {"next()": [[14, 19]]}}}, {"text": "You may be interested in the Java Tools API", "label": {"api": {"Java Tools API": [[29, 42]]}}}, {"text": "This API gives you programmatic control over the Java compiler and you can pretty much write a program to read and analyze a Java program", "label": {"api": {"Java compiler": [[49, 61]]}}}, {"text": "String API, consider using split() to split the name string", "label": {"api": {"String API": [[0, 9]]}}}, {"text": "see the WindowAdapter interface for methods that can be implemented", "label": {"api": {"WindowAdapter interface": [[8, 30]]}}}, {"text": "You can use CountDownLatch", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "A scenario where I have used Selector and IO multiplexing is", "label": {"api": {"Selector": [[29, 36]]}}}, {"text": "But as we want to support more secondary servers, I changed the design to use Selectors so that one thread does the IO multiplexing (selector.select()) and send the SelectionKey to the worker threadPool (Fixed thread pool of size 50)", "label": {"api": {"Selector": [[78, 85]]}}}, {"text": "ResultSet is an interface (not a class)", "label": {"api": {"ResultSet": [[0, 8]]}}}, {"text": "In DefaultTreeModel, you can insert a node using the insertNodeInto() methods", "label": {"api": {"DefaultTreeModel": [[3, 18]]}}}, {"text": "So could someone please explain if it is necessary to call nodesWereInserted() and similar methods in DefaultTreeModel", "label": {"api": {"DefaultTreeModel": [[102, 117]]}}}, {"text": "The set of supported CSS attributes for JavaFX is defined in the JavaFX CSS Reference Guide", "label": {"api": {"JavaFX CSS Reference Guide": [[65, 90]]}}}, {"text": "You can catch every uncaught exception via Thread.UncaughtExceptionHandler", "label": {"api": {"Thread.UncaughtExceptionHandler": [[43, 73]]}}}, {"text": "DateFormat.getDateInstance(int style, Locale aLocale)This displays the current date in a locale-specific way", "label": {"api": {"DateFormat.getDateInstance(int style, Locale aLocale)": [[0, 52]]}}}, {"text": "(You could replace it with System.arraycopy.) Note that the name is misleading, though; you're overwriting Arrlist, not adding to it", "label": {"api": {"System.arraycopy": [[27, 42]]}}}, {"text": "You can run Pattern.quote on the delimiter before feeding it in", "label": {"api": {"Pattern.quote": [[12, 24]]}}}, {"text": "Add that cell to a Stack", "label": {"api": {"Stack": [[19, 23]]}}}, {"text": "You can benefit from an AtomicReference in cases where multiple threads access (common) configuration data that can be refreshed at any given moment", "label": {"api": {"AtomicReference": [[24, 38]]}}}, {"text": "But you'll need that anyway to work with the AtomicReference", "label": {"api": {"AtomicReference": [[45, 59]]}}}, {"text": "The following code example should give you an idea about how to use an AtomicReference", "label": {"api": {"AtomicReference": [[71, 85]]}}}, {"text": "getGraphics will return null if the component is not visible", "label": {"api": {"getGraphics": [[0, 10]]}}}, {"text": "To make your Window visible you have to call setVisible(bool)", "label": {"api": {"setVisible(bool)": [[45, 60]]}}}, {"text": "You also have to be careful using threads with Swing", "label": {"api": {"using threads with Swing": [[28, 51]]}}}, {"text": "You can use containsKey method like this", "label": {"api": {"containsKey": [[12, 22]]}}}, {"text": "Does the canDisplay() method do what you're looking for", "label": {"api": {"canDisplay()": [[9, 20]]}}}, {"text": "If the canDisplay() method is not what you're looking for - you'll need to give a bit more info about what you're doing - platform, JDK version, font you've selected (or none?), example code (SSCCE would be best)", "label": {"api": {"canDisplay()": [[7, 18]]}}}, {"text": "String.replaceAll() is your friend", "label": {"api": {"String.replaceAll()": [[0, 18]]}}}, {"text": "Have a look at DateFormat, more specifically SimpleDateFormat", "label": {"api": {"DateFormat": [[15, 24], [51, 60]], "SimpleDateFormat": [[45, 60]]}}}, {"text": "Or you could use String#matches", "label": {"api": {"String#matches": [[17, 30]]}}}, {"text": "Wrap it in a DataInputStream and use readFully(byte[])", "label": {"api": {"readFully(byte[])": [[37, 53]]}}}, {"text": "See the method's Javadoc page", "label": {"api": {"the method's Javadoc page": [[4, 28]]}}}, {"text": "Have a look at the Timer class, specifically the schedule methods", "label": {"api": {"Timer": [[19, 23]]}}}, {"text": "One sensible approach might be to use a fixed thread pool to make sure the number of threads doesn't grow too ridiculously large, and then spawn threads off there as required", "label": {"api": {"fixed thread pool": [[40, 56]]}}}, {"text": "Replace subtraction with the implementation from Integer to fix this problem", "label": {"api": {"implementation from Integer": [[29, 55]]}}}, {"text": "In this case you can use  HashMap#containsKey(java.lang.Object) or if you want to find if the value is in the HashMap, you can use HashMap#containsValue(java.lang.Object)", "label": {"api": {"HashMap#containsKey(java.lang.Object)": [[26, 62]], "HashMap#containsValue(java.lang.Object)": [[131, 169]]}}}, {"text": "JTextField has built in callbacks for text changes with DocumentListener", "label": {"api": {"JTextField": [[0, 9]], "DocumentListener": [[56, 71]]}}}, {"text": "If you want to only respond on Enter presses, you can use an ActionListener which is called on Enter presses", "label": {"api": {"ActionListener": [[61, 74]]}}}, {"text": "The main difference is that System.out is a PrintStream and the other one is a PrintWriter", "label": {"api": {"System.out": [[28, 37]], "PrintStream": [[44, 54]], "PrintWriter": [[79, 89]]}}}, {"text": "Essentially, PrintStream should be used to write a stream of bytes, while PrintWriter should be used to write a stream of characters (and thus it deals with character encodings and such)", "label": {"api": {"PrintStream": [[13, 23]], "PrintWriter": [[74, 84]]}}}, {"text": "This process takes a while so I implemented Callable interface to do the task in another thread and get the result back", "label": {"api": {"Callable": [[44, 51]]}}}, {"text": "This approach can be seen in many java APIs, one example would be the java.util.Collections.unmodifiableList method that becomes one list as parameter and gives other as result", "label": {"api": {"java.util.Collections.unmodifiableList": [[70, 107]]}}}, {"text": "See String.format and Format String Syntax for more information", "label": {"api": {"String.format": [[4, 16]], "Format String Syntax": [[22, 41]]}}}, {"text": "What's wrong with using indexOf", "label": {"api": {"indexOf": [[24, 30]]}}}, {"text": "If you have no other @XmlElement annotated properties in your class, you can use @XmlValue", "label": {"api": {"@XmlValue": [[81, 89]]}}}, {"text": "Use a shutdown hook", "label": {"api": {"shutdown hook": [[6, 18]]}}}, {"text": "Use Integer.toString(), one of the options is able to use alphabetic characters as well as numerical to represent the String", "label": {"api": {"Integer.toString()": [[4, 21]]}}}, {"text": "You need to use some of the Map implementations", "label": {"api": {"Map": [[28, 30]]}}}, {"text": "Note that if performance matters, you'd use a StringBuffer", "label": {"api": {"StringBuffer": [[46, 57]]}}}, {"text": "In the case you don't actually want to learn how binary trees work and just use them, just use TreeSet which is an already working binary-tree implementation", "label": {"api": {"TreeSet": [[95, 101]]}}}, {"text": "Various docs (e.g.) refer to creating a customized CookieHandler and setting the default \"system wide\" but are ambiguous or non-committal about the consequences -- so while I  can create my own  CookieHandler or CookieManager, it seems this inevitably gets caught up in the \"system wide default\" which may be accessible by other processes", "label": {"api": {"ambiguous or non-committal": [[111, 136]]}}}, {"text": "Now take a look at IndexOutOfBoundsException documentation and you will see that it extends RuntimeException which means you don't need to (but you can) catch it", "label": {"api": {"IndexOutOfBoundsException documentation": [[19, 57]]}}}, {"text": "Also, you should use the String.trim() method, to ensure that there are no leading or trailing spaces in your strings", "label": {"api": {"String.trim()": [[25, 37]]}}}, {"text": "There are, however, special classes like BitSet that provide special functionality for big collections of booleans", "label": {"api": {"BitSet": [[41, 46]]}}}, {"text": "You need to implement a TableCellEditor as well", "label": {"api": {"TableCellEditor": [[24, 38]]}}}, {"text": "System.out is of type PrintStream", "label": {"api": {"System.out": [[0, 9]]}}}, {"text": "The javadoc of PrintStream.println(Object) says", "label": {"api": {"PrintStream.println(Object)": [[15, 41]]}}}, {"text": "The javadoc of String.valueOf(Object) says", "label": {"api": {"String.valueOf(Object)": [[15, 36]]}}}, {"text": "And the javadoc of Object.toString() says", "label": {"api": {"Object.toString()": [[19, 35]]}}}, {"text": "If you look at the JavaDoc for Integer you'll note that it implements the Comparable interface, so you are able to call your sort as", "label": {"api": {"JavaDoc for Integer": [[19, 37]]}}}, {"text": "You need to use a PreparedStatement - specifically, with its setBlob() method", "label": {"api": {"PreparedStatement": [[18, 34]], "setBlob()": [[61, 69]]}}}, {"text": "And really you should always use PreparedStatements", "label": {"api": {"PreparedStatement": [[33, 49]]}}}, {"text": "Collections gives you an easy way to do this", "label": {"api": {"Collections": [[0, 10]]}}}, {"text": "From the SimpleDateFormat documentation", "label": {"api": {"the SimpleDateFormat documentation": [[5, 38]]}}}, {"text": "Move scan.close(); to outside the while loop", "label": {"api": {"close": [[10, 14]]}}}, {"text": "When close the Scanner, this closes the System.in input stream", "label": {"api": {"close": [[5, 9], [29, 33]], "System.in": [[40, 48]]}}}, {"text": "Use StringBuilder instead", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "This is the expected exception when calling setLocationByPlatform(true) after having already called setVisible(true)", "label": {"api": {"expected exception": [[12, 29]]}}}, {"text": "Use Process#getErrorStream() and getOutputStream(), in a fashion like this", "label": {"api": {"Process": [[4, 10]]}}}, {"text": "Additionally, you may need to wait for the subprocess to terminate, using Process#waitFor, because otherwise your Java program might be finishing execution even though the spawned subprocess is still running in the background (unless this is what you want)", "label": {"api": {"Process": [[74, 80]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/io/Console.html#readPassword() instead of Scanner", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/Console.html#readPassword()": [[0, 75]]}}}, {"text": "Using a JScrollBar, you can add a class with myScrollBar.addAdjustmentListener(this) so it will call your AdjustmentListener's adjustmentValueChanged(AdjustmentEvent e) method", "label": {"api": {"JScrollBar": [[8, 17]], "AdjustmentListener": [[60, 77], [106, 123]]}}}, {"text": "For more, read up a tutorial on JScrollBar's", "label": {"api": {"JScrollBar": [[32, 41]]}}}, {"text": "You can use String replace() method", "label": {"api": {"String replace()": [[12, 27]]}}}, {"text": "You probably forgot to specify RUNTIME as the RetentionPolicy of your annotation", "label": {"api": {"RetentionPolicy": [[46, 60]]}}}, {"text": "You could write your own loop that check both at once using a compiled regex Pattern that looks for either name at the same time", "label": {"api": {"Pattern": [[77, 83]]}}}, {"text": "Please check the Java doc for resultset", "label": {"api": {"resultset": [[30, 38]]}}}, {"text": "To get just the name and not the package name, use Class.getSimpleName()", "label": {"api": {"Class.getSimpleName()": [[51, 71]]}}}, {"text": "If you want to do a background task and show progress you should use a SwingWorker", "label": {"api": {"SwingWorker": [[71, 81]]}}}, {"text": "The SwingWorker has a progress property that you can listen on", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "The complete example code is in the javadoc of SwingWorker", "label": {"api": {"SwingWorker": [[47, 57]]}}}, {"text": "One way to find out is to only reference the String using a WeakReference then force a garbage collection and see if the WeakReference has been cleared", "label": {"api": {"WeakReference": [[60, 72], [121, 133]]}}}, {"text": "You can use toString(radix) for that", "label": {"api": {"toString(radix)": [[12, 26]]}}}, {"text": "From your edit, there really isn't a reason as to why you would specifically need the file rather than just using the input stream available from the openRawResource(int id) method...just use an existing java class http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#Scanner%28java.io.InputStream,%20java.lang.String%29", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#Scanner%28java.io.InputStream,%20java.lang.String%29": [[215, 330]]}}}, {"text": "You can use List for unknown size of data (probably ArrayList will be the best solution for you)", "label": {"api": {"List": [[12, 15], [57, 60]], "ArrayList": [[52, 60]]}}}, {"text": "Try the API canDisplay() method for figuring out if a specific font \"knows\" how to display a specific character", "label": {"api": {"canDisplay()": [[12, 23]]}}}, {"text": "Luckily java.awt.Component has a getGraphicsConfiguration method that gives us the necessary information", "label": {"api": {"getGraphicsConfiguration method": [[33, 63]]}}}, {"text": "Java 9 exposes the necessary information directly via the graphics device’s default transform", "label": {"api": {"graphics device’s default transform": [[58, 92]]}}}, {"text": "You can combine a simple counter and Timer.scheduleAtFixedRate for this", "label": {"api": {"Timer.scheduleAtFixedRate": [[37, 61]]}}}, {"text": "Java does include such a container class with exactly the methods you want", "label": {"api": {"does include": [[5, 16]]}}}, {"text": "Also take a look at the thread-safe variant ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[44, 64]]}}}, {"text": "You should use a Java Queue A FIFO data container", "label": {"api": {"Java Queue": [[17, 26]]}}}, {"text": "According to my understanding of JavaCompiler.getTask(..) I'd suggest adding a DiagnosticListener", "label": {"api": {"JavaCompiler.getTask(..)": [[33, 56]], "DiagnosticListener": [[79, 96]]}}}, {"text": "You could confirm it by adding @Override annotation to f() method in derived class and see that it won't compile", "label": {"api": {"@Override": [[31, 39]]}}}, {"text": "Take a look at java BigInteger", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "Calling newInstace invokes the default constructor", "label": {"api": {"newInstace": [[8, 17]]}}}, {"text": "Double does not have one", "label": {"api": {"Double": [[0, 5]]}}}, {"text": "If you want to instantiate using reflection then you have to get one of the Contructors of the class using Class.#getConstructor by passing it the appropriate argument types and then call its method Constructor#newInstance by passing it the appropriate arguments", "label": {"api": {"Class.#getConstructor": [[107, 127]], "Constructor#newInstance": [[199, 221]]}}}, {"text": "use Sorted Set collection like TreeSet<E> with supporting cost of O(log n) for operations", "label": {"api": {"TreeSet<E>": [[31, 40]]}}}, {"text": "LinkedHashSet<E> But beware unlike HashSet<E>, LinkedHashSet can have O(1) expected performance for operations", "label": {"api": {"LinkedHashSet<E>": [[0, 15]]}}}, {"text": "Use library functions for this operation (in ByteBuffer class)", "label": {"api": {"ByteBuffer": [[45, 54]]}}}, {"text": "Wrap your input stream with an InputStreamReader to handle it as a character-based input stream", "label": {"api": {"InputStreamReader": [[31, 47]]}}}, {"text": "Then wrap this one in a BufferedReader", "label": {"api": {"BufferedReader": [[24, 37]]}}}, {"text": "Use the readLine method, which reads data until a newline is found", "label": {"api": {"readLine": [[8, 15]]}}}, {"text": "For text-based output of newline-terminated messages back to the client, you should use the output analogue of the BufferedReader, which is the PrintWriter", "label": {"api": {"BufferedReader": [[115, 128]], "PrintWriter": [[144, 154]]}}}, {"text": "Since you're using executor service you can call it's shutdownNow method that is going to actively shut down threads without waiting", "label": {"api": {"shutdownNow": [[54, 64]]}}}, {"text": "For custom paintings you need to use paintComponent(...) method of JComponent, for example of JPanel, instead of paint() method and custom update()", "label": {"api": {"paintComponent(...)": [[37, 55]]}}}, {"text": "Use next for your JFrame frame.setAlwaysOnTop(false);", "label": {"api": {"frame.setAlwaysOnTop(false);": [[25, 52]]}}}, {"text": "Use that format with a SimpleDateFormat to create a Date object out of it", "label": {"api": {"SimpleDateFormat": [[23, 38]]}}}, {"text": "If you don't want to deal with NIO you can use http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html instead", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html": [[47, 116]]}}}, {"text": "The algorithm for forming the client identifier is described by the javadoc of UIComponent.getClientId()", "label": {"api": {"UIComponent.getClientId()": [[79, 103]]}}}, {"text": "You seem to be looking for JComponent.setBorder(null)", "label": {"api": {"JComponent.setBorder(null)": [[27, 52]]}}}, {"text": "You could throw a subclass of IOException (as you're dealing with input), the (arguably) potential downside is that IOException is not a RuntimeException so anyone calling your code would be forced to either handle the exception or rethrow it", "label": {"api": {"IOException": [[30, 40], [116, 126]]}}}, {"text": "Use Color.getHSBColor() to find a gamut of saturations or values for a given hue, as shown here for saturation", "label": {"api": {"Color.getHSBColor()": [[4, 22]]}}}, {"text": "The library you're trying to use seems to rely heavily on java.beans reflection", "label": {"api": {"java.beans": [[58, 67]]}}}, {"text": "However, on Android only parts of java.beans package are available", "label": {"api": {"java.beans": [[34, 43]]}}}, {"text": "Following the example from the Oracle Nashorn Docs", "label": {"api": {"Oracle Nashorn Docs": [[31, 49]]}}}, {"text": "Added in 1.8u40, you can use the ClassFilter to restrict what classes the engine can use", "label": {"api": {"ClassFilter": [[33, 43]]}}}, {"text": "Here is an example from the Oracle documentation", "label": {"api": {"Oracle documentation": [[28, 47]]}}}, {"text": "The angle-bracket characters can technically be used for lookahead and lookbehind captures, so it can make sense to quote them defensively if the pattern is adding any segments that are provided at runtime", "label": {"api": {"The angle-bracket characters can technically be used for lookahead and lookbehind captures": [[0, 89]]}}}, {"text": "Since you are using Instrumentation, you already have access to an API that tells you the object sizes", "label": {"api": {"Instrumentation": [[20, 34]]}}}, {"text": "The very same Instrumentation class that you use to modify the byte code of the classes provides the method getObjectSize(Object)", "label": {"api": {"Instrumentation": [[14, 28]], "getObjectSize(Object)": [[108, 128]]}}}, {"text": "Just put the objects into WeakReferences", "label": {"api": {"WeakReference": [[26, 38]]}}}, {"text": "Then you can use a ReferenceQueue to learn when the object has been garbage collected which is an important feature when you want to track the heap usage", "label": {"api": {"ReferenceQueue": [[19, 32]]}}}, {"text": "This can be done using the MXBean with the name \"com.sun.management:type=HotSpotDiagnostic\" sending the method invocation dumpHeap(String outputFile, boolean live)", "label": {"api": {"MXBean with the name \"com.sun.management:type=HotSpotDiagnostic\"": [[27, 90]], "dumpHeap(String outputFile, boolean live)": [[122, 162]]}}}, {"text": "From the Javadocs for CountDownLatch.await()", "label": {"api": {"Javadocs for CountDownLatch.await()": [[9, 43]]}}}, {"text": "You can use CopyOnWriteArrayList and CopyOnWriteArraySet", "label": {"api": {"CopyOnWriteArrayList": [[12, 31]], "CopyOnWriteArraySet": [[37, 55]]}}}, {"text": "Seems you need to use JToggleButton", "label": {"api": {"JToggleButton": [[22, 34]]}}}, {"text": "More information on this service can be found in regular Javadocs and other Java tutorials", "label": {"api": {"regular Javadocs": [[49, 64]]}}}, {"text": "You can use a Calendar object", "label": {"api": {"Calendar": [[14, 21]]}}}, {"text": "Your values in binary are equals to (you can use Integer.toBinaryString(int i))", "label": {"api": {"Integer.toBinaryString(int i)": [[49, 77]]}}}, {"text": "However, you can change the way it's displayed, use String#format", "label": {"api": {"String#format": [[52, 64]]}}}, {"text": "You have to use Pattern#quote because \\ is a special character in RegEx", "label": {"api": {"Pattern#quote": [[16, 28]]}}}, {"text": "You can encounter the same kind of problems in the replacement String as well, in this case use Matcher#quoteReplacement", "label": {"api": {"Matcher#quoteReplacement": [[96, 119]]}}}, {"text": "For years there's been a consensus to use Joda-Time or at least to not use the JDK classes (Date, Calendar, etc.) when working with dates and times, because the JDK components are broken", "label": {"api": {"Date": [[92, 95]], "Calendar": [[98, 105]]}}}, {"text": "According to the Java 7 API, most of Date's constructors and methods are Deprecated.", "label": {"api": {"Java 7 API": [[17, 26]]}}}, {"text": "If you, for some obscure reason, need the coordinates in a situation when mouse events are not available (in which case, take a look at the other answers), you can use SwingUtilities.convertPointFromScreen() to convert the coordinates from MouseInfo to the coordinate system of a Component", "label": {"api": {"SwingUtilities.convertPointFromScreen()": [[168, 206]]}}}, {"text": "Read the documentation on matches", "label": {"api": {"documentation on matches": [[9, 32]]}}}, {"text": "MessageDigest.getInstance() takes a string parameter that is the algorithm you wish to use on that message digest, SHA-256 for example", "label": {"api": {"MessageDigest.getInstance()": [[0, 26]]}}}, {"text": "As of Java 9, the correct way to prevent the JIT from discarding unwrapped is to use Reference.reachabilityFence", "label": {"api": {"Reference.reachabilityFence": [[85, 111]]}}}, {"text": "The File class has built-in methods isFile() and isDirectory()", "label": {"api": {"File": [[4, 7], [38, 41]], "isFile()": [[36, 43]], "isDirectory()": [[49, 61]]}}}, {"text": "An example from the JDK is HttpServet, which has methods to handle each of the four http methods (get, post, put and delete) whose default implementations throw a ServletException , forcing the subclass to override those methods they want to implement, but only those", "label": {"api": {"HttpServet": [[27, 36]]}}}, {"text": "Beware that under the hood JAX-WS RI uses HttpURLConnection so please don't reply with something related to Apache's HttpClient", "label": {"api": {"HttpURLConnection": [[42, 58]]}}}, {"text": "Another thing (if you still want to use keyListeners) you may want to extends KeyAdapter that provide default implementation of KeyListener methods (empty methods) therefore you don't need to override methods that you don't use like keyReleased or keyTyped", "label": {"api": {"KeyAdapter": [[78, 87]]}}}, {"text": "Client.send() serializes the message and writes to the DataOutputStream", "label": {"api": {"DataOutputStream": [[55, 70]]}}}, {"text": "Profiling client and server with JVM Monitor, showed CPU time was dominated by reading from the InputStreamReader and writing to the DataOutputStream", "label": {"api": {"InputStreamReader": [[96, 112]], "DataOutputStream": [[133, 148]]}}}, {"text": "Instead of the suggested flag, I suggest you to use CompilationMXBean which allows you to check the amount of time a JVM still spends with compilation", "label": {"api": {"CompilationMXBean": [[52, 68]]}}}, {"text": "You get a java.io.NotSerializableException with the message java.util.WeakHashMap meaning that the WeakHashMap is not serializable", "label": {"api": {"java.io.NotSerializableException": [[10, 41]], "WeakHashMap": [[70, 80], [99, 109]]}}}, {"text": "That suggests that some attribute of your session is a WeakHashMap", "label": {"api": {"WeakHashMap": [[55, 65]]}}}, {"text": "Either turn of session serialization, if you don't need it, or find out which attribute is the WeakHashMap (simply iterate over all of them and print the names of all WeakHashMap values)", "label": {"api": {"WeakHashMap": [[95, 105], [167, 177]]}}}, {"text": "I would use Arrays's binarySearch(Object[] a, Object key) method in conjunction with its sort(Object[] a) method", "label": {"api": {"Arrays": [[12, 17]], "binarySearch(Object[] a, Object key)": [[21, 56]], "sort(Object[] a)": [[89, 104]]}}}, {"text": "Package java.util.concurrent has ready-made BlockingQueues and TransferQueues which are designed for exactly this", "label": {"api": {"java.util.concurrent": [[8, 27]]}}}, {"text": "Here's an example of how to write your program using an ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[56, 73]]}}}, {"text": "This is why it's probably always better to, when finished writing to a file, add a new line at the end of the file using BufferedWriter.newLine()", "label": {"api": {"BufferedWriter.newLine()": [[121, 144]]}}}, {"text": "As you said that you are using netbeans, when main method it's generated wraps object creation with SwingUtilities#invokeLater that means this code will happen after all pending AWT events have been processed", "label": {"api": {"SwingUtilities#invokeLater": [[100, 125]]}}}, {"text": "Using String comparison with equals() instead of switch on Strings (which is available in Java 7) could look like this", "label": {"api": {"equals()": [[29, 36]]}}}, {"text": "In Downloads class you grab references for read and write lock from two different ReentrantReadWriteLock objects", "label": {"api": {"ReadWriteLock": [[91, 103]]}}}, {"text": "You should create one ReentrantReadWriteLock instance for Download object and obtain references for readLock and writeLock lock from it", "label": {"api": {"ReadWriteLock": [[31, 43]]}}}, {"text": "Pleas read more about ReadWriteLock and you can look at example of using ReentrantReadWriteLock in mbassador EventBus", "label": {"api": {"ReadWriteLock": [[22, 34], [82, 94]]}}}, {"text": "You must implement toString() in your Student class", "label": {"api": {"toString()": [[19, 28]]}}}, {"text": "I urge you to use a java.util.Scanner, and to remember to check that there's a line to read with hasNextLine() before calling nextLine() (also, you should always clean up after yourself)", "label": {"api": {"java.util.Scanner": [[20, 36]], "hasNextLine()": [[97, 109]], "nextLine()": [[126, 135]]}}}, {"text": "To resolve this, you could use the javax.swing.Timer to schedule the updates so that they would be run in the same UI thread, but only when needed, i.e", "label": {"api": {"javax.swing.Timer": [[35, 51]]}}}, {"text": "The entry point of any Servlet is the service(ServletRequest, ServletResponse) method", "label": {"api": {"Servlet": [[23, 29], [46, 52], [62, 68]], "service(ServletRequest, ServletResponse)": [[38, 77]]}}}, {"text": "HttpServlet implements this method and delegates to one of its doGet, doPost, etc", "label": {"api": {"Servlet": [[4, 10]], "HttpServlet": [[0, 10]], "doGet": [[63, 67]], "doPost": [[70, 75]]}}}, {"text": "You can use .toArray(T[]) for this", "label": {"api": {".toArray(T[])": [[12, 24]]}}}, {"text": "A table model object must implement the TableModel interface", "label": {"api": {"TableModel": [[40, 49]]}}}, {"text": "If the programmer does not provide a table model object, JTable automatically creates an instance of DefaultTableModel", "label": {"api": {"TableModel": [[108, 117]]}}}, {"text": "Listeners are instances of TableModelListener", "label": {"api": {"TableModel": [[27, 36]], "TableModelListener": [[27, 44]]}}}, {"text": "Because you're using the legacy Dictionary interface, this gets a bit annoying, but it's possible to do this", "label": {"api": {"the legacy Dictionary interface": [[21, 51]]}}}, {"text": "Iterating over the elements of a Map becomes a call to Map#entrySet() with a little more work", "label": {"api": {"Map#entrySet()": [[55, 68]]}}}, {"text": "Construct an ArrayList<Integer>, iterate on the array of bits, as long as you have 1's, increment a counter and as soon as you have 0, add the counter to the ArrayList", "label": {"api": {"ArrayList<Integer>": [[13, 30]]}}}, {"text": "If you want to print it in a specific format, you need to use another SimpleDateFormat and call format method", "label": {"api": {"format": [[38, 43], [96, 101]]}}}, {"text": "You can use the same DateFormat and its SimpleDateFromat.format() to get the desired output", "label": {"api": {"SimpleDateFromat.format()": [[40, 64]]}}}, {"text": "Since Java 1.8, there is a setUseCipherSuitesOrder method on the SSLParameters class", "label": {"api": {"setUseCipherSuitesOrder": [[27, 49]]}}}, {"text": "The enhanced for-loop iterates over all elements of the the given iterator, since your twoArray is empty there's nothing to iterate", "label": {"api": {"iterator": [[66, 73]]}}}, {"text": "Just use single thread executor, it guarantees that the Runnable's you post to it will be executed sequentially", "label": {"api": {"single thread executor": [[9, 30]]}}}, {"text": "The new cookie can either be created in the backend using the servlet API addCookie method, on in the frontend using the Javascript cookie APIs", "label": {"api": {"servlet API addCookie": [[62, 82]]}}}, {"text": "What is the difference from Locale.ITALY and Locale.ITALIAN", "label": {"api": {"Locale.ITALY": [[28, 39]], "Locale.ITALIAN": [[45, 58]]}}}, {"text": "JFrame.EXIT_ON_CLOSE  is a Constant used to control the window-closing operation", "label": {"api": {"JFrame.EXIT_ON_CLOSE": [[0, 19]]}}}, {"text": "In Java 7 (using officially released java.lang.management.ManagementFactory) you may want to try the combination of getMemoryMXBean() with getHeapMemoryUsage() as following", "label": {"api": {"getMemoryMXBean()": [[116, 132]], "getHeapMemoryUsage()": [[139, 158]]}}}, {"text": "You could also use a Lock for that", "label": {"api": {"Lock": [[21, 24]]}}}, {"text": "In order to get milliseconds value you can use TimeUnit", "label": {"api": {"TimeUnit": [[47, 54]]}}}, {"text": "In the String#compare JavaDoc it states Returns true if and only if this string contains the specified sequence of char values", "label": {"api": {"String#compare JavaDoc": [[7, 28]]}}}, {"text": "You can use the newer ProcessBuilder class, which has more options than the Runtime.exec method", "label": {"api": {"ProcessBuilder": [[22, 35]]}}}, {"text": "You could use IdentityHashMap and just ignore the values (the keys will form a set)", "label": {"api": {"IdentityHashMap": [[14, 28]]}}}, {"text": "The class implements the KeyListener interface but does not provide an implementation for the keyReleased, keyPressed and keyTyped methods specified on the interface", "label": {"api": {"KeyListener": [[25, 35]]}}}, {"text": "according to the SocketChannel documentation you'll get a ClosedChannelException", "label": {"api": {"the SocketChannel documentation": [[13, 43]]}}}, {"text": "The unqualified use of Scanner will then point to the correct class", "label": {"api": {"correct class": [[54, 66]]}}}, {"text": "Given how the JDK documentation refers to Throwable.getSuppressed(), should this code be doing something akin to the following", "label": {"api": {"Throwable.getSuppressed()": [[42, 66]]}}}, {"text": "Here's a recursive solution using Class.isArray", "label": {"api": {"Class.isArray": [[34, 46]]}}}, {"text": "addAll elements, then removeAll elements that appears in a", "label": {"api": {"addAll": [[0, 5]], "removeAll": [[22, 30]]}}}, {"text": "getScreenResolution() return dots-per-inch (DPI)", "label": {"api": {"getScreenResolution()": [[0, 20]]}}}, {"text": "If you want the size of the screen, just use getScreenSize()", "label": {"api": {"getScreenSize()": [[45, 59]]}}}, {"text": "I think the database should use a class that extends the class java.util.prefs.Preferences", "label": {"api": {"java.util.prefs.Preferences": [[63, 89]]}}}, {"text": "Use keyboard.next(); or keyboard.nextLine() in the catch clause to consume invalid token that was left from nextInt", "label": {"api": {"nextInt": [[108, 114]]}}}, {"text": "Without it invalid token will not be consumed and in another iteration nextInt() will again try to handle same data throwing again InputMismatchException, causing the infinite loop", "label": {"api": {"nextInt": [[71, 77]]}}}, {"text": "You may want to use Runtime.addShutdownHook", "label": {"api": {"Runtime.addShutdownHook": [[20, 42]]}}}, {"text": "The Arrays class has many utility methods for creating string representations of arrays", "label": {"api": {"Arrays": [[4, 9]]}}}, {"text": "If you need a sorted map then you will have to look into a TreeMap which supplies the same interface as a HashMap but it's inherently sorted on keys according to their natural ordering (or a custom Comparator)", "label": {"api": {"TreeMap": [[59, 65]]}}}, {"text": "Mind that a TreeMap doesn't allow ordering on values, so if you need to sort your data by value then you will have to build your own sorted collection", "label": {"api": {"TreeMap": [[12, 18]]}}}, {"text": "I know that the String can be converted to a long using Long.parseLong(String) method and Long(String) constructor", "label": {"api": {"Long.parseLong(String)": [[56, 77]], "Long(String)": [[66, 77], [90, 101]]}}}, {"text": "Define a ColumnConstraints object, and use it in the grid pane", "label": {"api": {"ColumnConstraints": [[9, 25]]}}}, {"text": "Refer System.arrayCopy for more details", "label": {"api": {"System.arrayCopy": [[6, 21]]}}}, {"text": "Unfortunately the SpringJUnit4ClassRunner can't resolve the @Value expression, even though a default value is supplied (a NumberFormatException is thrown)", "label": {"api": {"NumberFormatException": [[122, 142]]}}}, {"text": "Character.isLetter determines if a character is a letter or not", "label": {"api": {"Character.isLetter": [[0, 17]]}}}, {"text": "createNamedQuery() expects the name of a named query as its first argument", "label": {"api": {"createNamedQuery()": [[0, 17]]}}}, {"text": "Use createQuery() instead", "label": {"api": {"createQuery()": [[4, 16]]}}}, {"text": "A DataSource has 2 methods to get a Connection", "label": {"api": {"DataSource": [[2, 11]]}}}, {"text": "It seems that your jpa implementation uses DataSource.getConnection(String username, String password) if you provide the credentials via properties", "label": {"api": {"DataSource": [[43, 52]]}}}, {"text": "In java, if you try to read from a stream that's at end-of-file, then you'll get an EOFException", "label": {"api": {"EOFException": [[84, 95]]}}}, {"text": "Having said that, if you're reading from a stream connected to a running program, then you won't get an EOFException just because the other program is idle", "label": {"api": {"EOFException": [[104, 115]]}}}, {"text": "You would only get an EOFException if the other program has exited, or if it explicitly closes its output stream (that you are reading from)", "label": {"api": {"EOFException": [[22, 33]]}}}, {"text": "You should consider using ScheduledExecutorService method schedule to delay execution of task to specific point in time", "label": {"api": {"ScheduledExecutorService": [[26, 49]]}}}, {"text": "You have a wrong format for a year in a SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[40, 55]]}}}, {"text": "Add a PreparedStatement.executeQuery() call", "label": {"api": {"PreparedStatement.executeQuery()": [[6, 37]]}}}, {"text": "And fetch the results from the returned ResultSet", "label": {"api": {"ResultSet": [[40, 48]]}}}, {"text": "As @Jon Skeet pointed out, the declaration of ResultSet in Java 7 is updated to", "label": {"api": {"ResultSet": [[46, 54]]}}}, {"text": "And this comes from the DatagramSocket.receive() JavaDoc", "label": {"api": {"DatagramSocket.receive()": [[24, 47]]}}}, {"text": "You need to create an instance of XPathVariableResolver and attach it to your XPath instance", "label": {"api": {"XPathVariableResolver": [[34, 54]]}}}, {"text": "Only Android1 and Javacard API use a blank IV, which is non-conforming to the Java Crypto spec, which states", "label": {"api": {"which states": [[96, 107]]}}}, {"text": "Look up the documentation of the AffineTransform class as well as any number of sources on Wolfram MathWorld or Wikipedia (e.g", "label": {"api": {"AffineTransform": [[33, 47]]}}}, {"text": "In Java, your sprite will probably be rendered in a rotated frame using the AffineTransform class, so if you apply your transformations carefully, you may not even have to do any extra math yourself to get the position of the trailing point", "label": {"api": {"AffineTransform": [[76, 90]]}}}, {"text": "According to this http://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html the PrintWriter method print(int i) prints an integer so I'm confused", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html": [[18, 82]]}}}, {"text": "In Java the SocketFactory creates Sockets (http://docs.oracle.com/javase/7/docs/api/javax/net/SocketFactory.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/net/SocketFactory.html": [[43, 111]]}}}, {"text": "Have a look at these characters", "label": {"api": {"these characters": [[15, 30]]}}}, {"text": "You need single quotes around a to make it a character constant, and charAt to get the specific character of the string, like this", "label": {"api": {"charAt": [[69, 74]]}}}, {"text": "Most of Date is actually deprecated, it has been superseded by Calendar", "label": {"api": {"Calendar": [[63, 70]]}}}, {"text": "Please read the renameTo java doc carefully", "label": {"api": {"renameTo": [[16, 23]]}}}, {"text": "It is just a indicator to the renameTo() method about the destination file on your system", "label": {"api": {"renameTo": [[30, 37]]}}}, {"text": "File documentation clearly says that the file object is abstract representation of the file or directory (the actual file may or may not exist)", "label": {"api": {"File documentation": [[0, 17]]}}}, {"text": "String.replaceFirst will do the job", "label": {"api": {"String.replaceFirst": [[0, 18]]}}}, {"text": "I would go for an ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[18, 41]]}}}, {"text": "See the Java docs for regular expression patterns", "label": {"api": {"the Java docs": [[4, 16]]}}}, {"text": "You can cast the component returned by getTableCellRendererComponent() call as JComponent and then set the border as you wish", "label": {"api": {"getTableCellRendererComponent()": [[39, 69]], "JComponent": [[79, 88]]}}}, {"text": "If you want to wait for the updater.jar process to finish (or kill it after a timeout), have a look at Process.waitFor()", "label": {"api": {"Process.waitFor()": [[103, 119]]}}}, {"text": "Note that now we are using String#contains", "label": {"api": {"String#contains": [[27, 41]]}}}, {"text": "You can send key events by using the Robot class", "label": {"api": {"Robot": [[37, 41]]}}}, {"text": "You could use a List in the first place, which provides an indexOf() method", "label": {"api": {"indexOf()": [[59, 67]]}}}, {"text": "You could keep the array sorted and use Arrays.binarySearch() (although perhaps this is overkill)", "label": {"api": {"Arrays.binarySearch()": [[40, 60]]}}}, {"text": "Guava, for example, has Chars.indexOf()", "label": {"api": {"indexOf()": [[30, 38]]}}}, {"text": "Apache has ArrayUtils.indexOf() (which apparently deals better with null inputs)", "label": {"api": {"indexOf()": [[22, 30]]}}}, {"text": "If you want to convert a byte array to an array of 16-bit values, use ByteBuffer to convert it to a short array", "label": {"api": {"ByteBuffer": [[70, 79]]}}}, {"text": "In general, if you want to append bytes to a byte array, you should use a ByteBuffer", "label": {"api": {"ByteBuffer": [[74, 83]]}}}, {"text": "launched using JWS, specifically the DownloadServiceListener", "label": {"api": {"DownloadServiceListener": [[37, 59]]}}}, {"text": "You can easily use String.contains method to check if a string contains the patter", "label": {"api": {"String.contains": [[19, 33]]}}}, {"text": "If I understand you correctly, you can use Integer.toHexString(i), or, for a more generic solution, Integer.toString(i, radix)", "label": {"api": {"Integer.toHexString(i)": [[43, 64]], "Integer.toString(i, radix)": [[100, 125]]}}}, {"text": "By using the class ObjectOutputStream, you can write objects to a file", "label": {"api": {"ObjectOutputStream": [[19, 36]]}}}, {"text": "It converts the objects into a format which can then later be read with the class ObjectInputStream", "label": {"api": {"ObjectInputStream": [[82, 98]]}}}, {"text": "You will want to use the FileInputStream.skip method to seek to the point you want and then begin reading from that point", "label": {"api": {"FileInputStream.skip": [[25, 44]]}}}, {"text": "If you do this in Java, you might consider composing your data points to a Path2D", "label": {"api": {"Path2D": [[75, 80]]}}}, {"text": "You might have to disable stroke control, though", "label": {"api": {"disable": [[18, 24]], "stroke control": [[26, 39]]}}}, {"text": "If you don't want to replace anything, you can use Number and NumberFormat with Locale#GERMAN", "label": {"api": {"Number": [[51, 56], [62, 67]], "NumberFormat": [[62, 73]], "Locale#GERMAN": [[80, 92]]}}}, {"text": "You should use the appropriate NumberFormat according to your locale", "label": {"api": {"NumberFormat": [[31, 42]]}}}, {"text": "You can send/receive any kind of object with the ObjectInputStream/ObjectOutputStream as long as it is serializable", "label": {"api": {"serializable": [[103, 114]]}}}, {"text": "Lists and Maps are already serializable", "label": {"api": {"serializable": [[27, 38]]}}}, {"text": "You could save the instance to file using ObjectOutputStream and then read and instatiate it with ObjectInputStream", "label": {"api": {"ObjectOutputStream": [[42, 59]]}}}, {"text": "I would choose the more general ObjectOutputStream which allows you to send objects implementing the Serializable interface (your scenario already satisfy this constraint)", "label": {"api": {"ObjectOutputStream": [[32, 49]]}}}, {"text": "Otherwise it will call the Object#toString() method", "label": {"api": {"Object#toString()": [[27, 43]]}}}, {"text": "You should consider using Calendar to parse such time strings", "label": {"api": {"Calendar": [[26, 33]]}}}, {"text": "If you worry about performance, ThreadLocal is your friend", "label": {"api": {"ThreadLocal": [[32, 42]]}}}, {"text": "Usually you would do that in a Filter and wrap the request in a HttpServletRequestWrapper", "label": {"api": {"Filter": [[31, 36]], "HttpServletRequestWrapper": [[64, 88]]}}}, {"text": "In particular, foreach syntax makes use of an iterator via ArrayList#iterator(), and the docs for ArrayList say", "label": {"api": {"ArrayList#iterator()": [[59, 78]], "docs for ArrayList": [[89, 106]], "iterator": [[46, 53], [69, 76]]}}}, {"text": "The iterators returned by this class's iterator and listIterator methods are fail-fast", "label": {"api": {"iterator": [[4, 11], [39, 46]], "listIterator": [[52, 63]]}}}, {"text": "if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException", "label": {"api": {"iterator": [[59, 66], [110, 117], [152, 159]], "remove": [[125, 130]], "add": [[135, 137]], "ConcurrentModificationException": [[174, 204]]}}}, {"text": "Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future", "label": {"api": {"iterator": [[50, 57]]}}}, {"text": "Instead of using a FlowLayout, which lays out items left to right and wraps appropriately, you can use a BoxLayout, which allows you to specify laying out items either horizontally or vertically", "label": {"api": {"BoxLayout": [[105, 113]]}}}, {"text": "You need compare String with help of method equals()", "label": {"api": {"equals()": [[44, 51]]}}}, {"text": "From the Serializable documentation", "label": {"api": {"Serializable": [[9, 20]]}}}, {"text": "When traversing a graph, an object may be encountered that does not support the Serializable interface", "label": {"api": {"Serializable": [[80, 91]]}}}, {"text": "In this case the NotSerializableException will be thrown and will identify the class of the non-serializable object", "label": {"api": {"Serializable": [[20, 31]]}}}, {"text": "So yes, all objects referenced by the vector, directly and indirectly, will need to be Serializable, unless of course they're marked as transient", "label": {"api": {"Serializable": [[87, 98]]}}}, {"text": "Anything being serialized, including all classes referred to by fields (instance variables), must implement Serializable, or the field must be transient", "label": {"api": {"Serializable": [[108, 119]]}}}, {"text": "In your case, the user defined class must implement Serializable, and have fields whose type is Serializable", "label": {"api": {"Serializable": [[52, 63], [96, 107]]}}}, {"text": "This applies recursively, so fields of the class of the fields must also be Serializable, etc", "label": {"api": {"Serializable": [[76, 87]]}}}, {"text": "From the documentation of LinkedList", "label": {"api": {"documentation of LinkedList": [[9, 35]]}}}, {"text": "The HashSet class has an add(Object o) method, which is not inherited from another class", "label": {"api": {"HashSet": [[4, 10]], "add(Object o)": [[25, 37]]}}}, {"text": "In other words, if two objects are equal, then the second object will not be added and the HashSet will remain the same", "label": {"api": {"HashSet": [[91, 97]]}}}, {"text": "As the example above clearly shows, HashSet was able to add two elements where e.equals(e2)", "label": {"api": {"HashSet": [[36, 42]]}}}, {"text": "getType returns a class so you must compare it with a Class", "label": {"api": {"getType": [[0, 6]]}}}, {"text": "If the HttpOnly cookies aren't there, you may have to read the contents of the URL directly (e.g., via URLConnection or similar) before passing them on to JSoup.parse, and look for the cookie headers in that stream", "label": {"api": {"URLConnection": [[103, 115]]}}}, {"text": "My guess is that you are running your executeScript call before your document is loaded", "label": {"api": {"executeScript": [[38, 50]]}}}, {"text": "To know when a document is loaded, you can add a listener on the document property or the WebEngine loadworker state property (for a SUCCEEDED state), you can see an example of the loadworker solution in the WebEngine javadoc", "label": {"api": {"document property": [[65, 81]], "SUCCEEDED": [[133, 141]], "WebEngine javadoc": [[208, 224]]}}}, {"text": "In this case, you can simply use Scanner with regular expressions that matches all the strings literals..", "label": {"api": {"Scanner": [[33, 39]]}}}, {"text": "String has a toCharArray() method that will give you what you want", "label": {"api": {"String": [[0, 5]], "toCharArray()": [[13, 25]]}}}, {"text": "If you don't mind to use 3rd party libraries, i recommend to use JXErrorPane by swingX otherwise you can use a simple JOptionPane that is very powerful and customizable", "label": {"api": {"JOptionPane": [[118, 128]]}}}, {"text": "See APIs for reference", "label": {"api": {"See APIs": [[0, 7]]}}}, {"text": "write writes the content only to the InputStream", "label": {"api": {"write": [[0, 4], [6, 10]]}}}, {"text": "Use println to send an additional newline character to correspond to the readLine statement on the server", "label": {"api": {"println": [[4, 10]]}}}, {"text": "The Thread class defines an interrupt method", "label": {"api": {"interrupt method": [[28, 43]]}}}, {"text": "You probably want to use a couple of BlockingQueues", "label": {"api": {"BlockingQueue": [[37, 49]]}}}, {"text": "In particular it seems like a BlockingQueue might be a good fit here", "label": {"api": {"BlockingQueue": [[30, 42]]}}}, {"text": "You can use BlockingQueue to create simple consumer-producer scenario, there is even a simple example in the documentation", "label": {"api": {"BlockingQueue": [[12, 24]]}}}, {"text": "Here is the Javadoc for this", "label": {"api": {"Here is the Javadoc for this": [[0, 27]]}}}, {"text": "As discussed here, you can use AffineTransformOp to rotate an image by Math.PI / 2; this is equivalent to rotating the image clockwise 90°, as shown here", "label": {"api": {"AffineTransformOp": [[31, 47]]}}}, {"text": "See also Handling 90-Degree Rotations", "label": {"api": {"Handling 90-Degree Rotations": [[9, 36]]}}}, {"text": "Java specifies a regular expression that can be used to validate strings being passed to Double.parseDouble or Double.valueOf in the Javadoc of Double.valueOf", "label": {"api": {"Double.valueOf": [[111, 124], [144, 157]]}}}, {"text": "The AWT gives you access to screen information, although \"external\" is subjective as you might have 2 built-in monitors or 2 external ones", "label": {"api": {"access to screen information": [[18, 45]]}}}, {"text": "Maybe an idea is to check from time to time getScreenDevices() and detect changes, but this is more a workaround than a real solution", "label": {"api": {"getScreenDevices()": [[44, 61]]}}}, {"text": "As per the String.getBytes() method's documentation, the string is encoded into a sequence of bytes using the platform's default charset", "label": {"api": {"String.getBytes() method's documentation": [[11, 50]]}}}, {"text": "If you want to specify the encoding, use the method String.getBytes(Charset) or String.getBytes(String)", "label": {"api": {"String.getBytes(Charset)": [[52, 75]], "String.getBytes(String)": [[80, 102]]}}}, {"text": "It is not documented in http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html, so can be considered as a spec or implementation bug", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html": [[24, 85]]}}}, {"text": "Taken from Oracle", "label": {"api": {"Oracle": [[11, 16]]}}}, {"text": "You will need to set an implementation of javax.xml.namespace.NamespaceContext on your XPath object", "label": {"api": {"javax.xml.namespace.NamespaceContext": [[42, 77]]}}}, {"text": "If you want to replace entire words only, you can use replaceAll(), which takes a regular expression instead of a normal string, and word boundaries (\\\\b) like this", "label": {"api": {"replaceAll()": [[54, 65]]}}}, {"text": "If I understood your problem correctly I would replace the BufferedOutputStream with a OutputputStreamWriter + BufferedWriterspecifically setting the encoding", "label": {"api": {"OutputputStreamWriter": [[87, 107]]}}}, {"text": "The last even have a handy newLine method", "label": {"api": {"newLine": [[27, 33]]}}}, {"text": "Also, since you are not doing anything concurrently, I guess it is safe to replace StringBuffer with StringBuilder", "label": {"api": {"StringBuilder": [[101, 113]]}}}, {"text": "You can use Objects.equals to safely equate null values to each other in Java 7", "label": {"api": {"Objects.equals": [[12, 25]]}}}, {"text": "One of my favorites is Atomic Reference", "label": {"api": {"Atomic Reference": [[23, 38]]}}}, {"text": "You can't just use new String(encrypted) either", "label": {"api": {"new String(encrypted)": [[19, 39]]}}}, {"text": "See Pattern and Matcher", "label": {"api": {"Pattern": [[4, 10]], "Matcher": [[16, 22]]}}}, {"text": "However, Collections.replaceAll doesn't search inside the string to replace the word \"this\"; it will just test if the entire line is equal to \"this\", which it certainly isn't", "label": {"api": {"Collections.replaceAll": [[9, 30]]}}}, {"text": "You can split your lines into words, and attempt Collections.replaceAll on the List of words", "label": {"api": {"Collections.replaceAll": [[49, 70]]}}}, {"text": "Or, you can use String's replace method, which will match the word within the line", "label": {"api": {"String's replace method": [[16, 38]]}}}, {"text": "The other modules should be able to access those resources via their classpaths, which should contain the CONFIG jar, using ClassLoader.getResource(String) or ClassLoader.getResourceAsStream(String)", "label": {"api": {"ClassLoader.getResource(String)": [[124, 154]], "ClassLoader.getResourceAsStream(String)": [[159, 197]]}}}, {"text": "You could use Matcher#start(group) and Matcher#end(group) to build a generic replacement method", "label": {"api": {"Matcher#start(group)": [[14, 33]], "Matcher#end(group)": [[39, 56]]}}}, {"text": "You should probably read up on what #revalidate() and #repaint() do", "label": {"api": {"#revalidate()": [[36, 48]], "#repaint()": [[54, 63]]}}}, {"text": "JFrame doesn't have an Icon property, it has an IconImage property as set by setIconImage", "label": {"api": {"setIconImage": [[77, 88]]}}}, {"text": " You can override JTable.editingStopped, which is invoked when editing is finished and apply your actions in that method", "label": {"api": {"JTable.editingStopped": [[18, 38]]}}}, {"text": "JTable.editingStopped was not designed for application extension", "label": {"api": {"JTable.editingStopped": [[0, 20]]}}}, {"text": "From the Oracle documentation", "label": {"api": {"Oracle documentation": [[9, 28]]}}}, {"text": "You first stop for questions like these should be the API", "label": {"api": {"API": [[54, 56]]}}}, {"text": "I recommend using the Text Shape", "label": {"api": {"Text": [[22, 25]]}}}, {"text": "See this answer for an example of collision detection using complex shapes, then look closely at the JavaDocs for Shape for other methods that might help for determining if a Point is inside a shape", "label": {"api": {"JavaDocs for Shape": [[101, 118]]}}}, {"text": "Get a Class instance with Class.forName()", "label": {"api": {"Class.forName()": [[26, 40]]}}}, {"text": "You can create a new object of that class with Class.newInstance()", "label": {"api": {"Class.newInstance()": [[47, 65]]}}}, {"text": "Check FileVisitor, very neat", "label": {"api": {"FileVisitor": [[6, 16]]}}}, {"text": "A Character is an object, and therefore null is an acceptable value for a Character reference", "label": {"api": {"Character": [[2, 10], [74, 82]]}}}, {"text": "If you allow \"other coders\" to implement a Runnable or a Callable, then you can use the Future class's get(long timeout, TimeUnit unit) method to cause the robot to timeout after a predetermined period of time", "label": {"api": {"get(long timeout, TimeUnit unit)": [[103, 134]]}}}, {"text": "But if memory churn is being an issue, there's a much more efficient way to implement removeElements, using System.arraycopy rather than a temporary LinkedList.", "label": {"api": {"System.arraycopy": [[108, 123]]}}}, {"text": "If this is the case, I suggest converting your array to a List and using Collections.shuffle", "label": {"api": {"Collections.shuffle": [[73, 91]]}}}, {"text": "According to the Java Docs for toHexString that is expected behaviour", "label": {"api": {"toHexString": [[31, 41]]}}}, {"text": "If you're sure your input isn't empty, a solution is to initialize lowest to a big enough value", "label": {"api": {"big enough value": [[79, 94]]}}}, {"text": "The matches() method (doc) tries to match the whole input", "label": {"api": {"(doc)": [[21, 25]]}}}, {"text": "The find() method (doc) tries to match something in the beginning but it does not need to match the whole input, so it does return true with the same pattern and same input", "label": {"api": {"(doc)": [[18, 22]]}}}, {"text": "Read more about it in this link", "label": {"api": {"this link": [[22, 30]]}}}, {"text": "You could use Iterator or ListIterator", "label": {"api": {"Iterator": [[14, 21], [30, 37]], "ListIterator": [[26, 37]]}}}, {"text": "CriteriaBuilder.size(Expression) returns an Expression<Integer> that you may use in the ORDER BY clause", "label": {"api": {"CriteriaBuilder.size(Expression)": [[0, 31]]}}}, {"text": "See Matcher for doc", "label": {"api": {"Matcher": [[4, 10]]}}}, {"text": "Sounds like you're looking for a BlockingDeque, and in particular an ArrayBlockingQueue", "label": {"api": {"BlockingDeque": [[33, 45]], "ArrayBlockingQueue": [[69, 86]]}}}, {"text": "You may also want a ConcurrentLinkedQueue, which uses a \"wait-free\" algorithm (aka non-blocking) and may therefore be faster in many circumstances", "label": {"api": {"ConcurrentLinkedQueue": [[20, 40]]}}}, {"text": "The InitialDirContext constructor's parameter type is Hashtable<?,?>", "label": {"api": {"InitialDirContext": [[4, 20]]}}}, {"text": "You should be able to use java.util.Properties here, since it extends java.util.Hashtable<Object,Object>", "label": {"api": {"java.util.Properties": [[26, 45]]}}}, {"text": "Then, use a custom Comparator to compare the Integers from least to greatest", "label": {"api": {"Comparator": [[19, 28]]}}}, {"text": "Because ArrayList's get(int index) method only takes int as an argument, according to Oracle's documentation(http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[109, 173]]}}}, {"text": "You can simply split() your string on whitespace", "label": {"api": {"split()": [[15, 21]]}}}, {"text": "You would have to use JDBC to get the DatabaseMetaData from the Connection, and then asking for the columns you're interested into, using getColumns()", "label": {"api": {"get the DatabaseMetaData from the Connection": [[30, 73]], "getColumns()": [[138, 149]]}}}, {"text": "The hashCode() method is based on the contents of the String which are the same, but that doesn't mean that they both refer to the same String object in the memory", "label": {"api": {"hashCode()": [[4, 13]]}}}, {"text": "Alternatively, you can ask the compiler to check and fetch the reference of a String with the same value already existing in the String pool by using the intern() method", "label": {"api": {"intern()": [[154, 161]]}}}, {"text": "If we were in pre-java8 era, even though -source 1.8 -target 1.7 is not supported by javac you could still use Compiler API to do the same", "label": {"api": {"Compiler API": [[111, 122]]}}}, {"text": "This doesn't seem to no longer be so straight forward, as using other compilers you'd need the implementations of features like lambdas as well, and Compiler API will throw the same \"javac", "label": {"api": {"Compiler API": [[149, 160]]}}}, {"text": "For rounding use either Math.ceil() for rounding up, Math.floor() for rounding down or Math.round() for general rounding", "label": {"api": {"Math.ceil()": [[24, 34]], "Math.floor()": [[53, 64]], "Math.round()": [[87, 98]]}}}, {"text": "If $pro.test is a standard implementation of the Set interface, then there's no sort or sortOrder method", "label": {"api": {"Set interface": [[49, 61]]}}}, {"text": "HttpServletRequest.getHeaderNames() returns Enumeration<String> and HttpServletResponse.getHeaderNames() returns a Collection<String>", "label": {"api": {"HttpServletRequest.getHeaderNames()": [[0, 34]], "HttpServletResponse.getHeaderNames()": [[68, 103]]}}}, {"text": "Use the DownloadService (or related services) of the JNLP API", "label": {"api": {"DownloadService": [[8, 22]], "JNLP API": [[53, 60]]}}}, {"text": "SimpleDateFormat is not thread safe", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "The cast you've shown is necessary because getContentPane returns a Container", "label": {"api": {"getContentPane": [[43, 56]]}}}, {"text": "This could probably be accomplished by creating a class of your own, extending the HttpServletRequestWrapper and then override the appropriate methods (getInputStream sounds like the way to go here, yes?)", "label": {"api": {"HttpServletRequestWrapper": [[83, 107]]}}}, {"text": "Chek this link", "label": {"api": {"this link": [[5, 13]]}}}, {"text": "From the Javadoc", "label": {"api": {"From the Javadoc": [[0, 15]]}}}, {"text": "As Alex said, .matches() will only return true if the regex matches the entire string", "label": {"api": {".matches()": [[14, 23]]}}}, {"text": "Using your regex, [.*\\\":\\\".*]*, .matches() will only return true for strings that look somewhat like this", "label": {"api": {".matches()": [[32, 41]]}}}, {"text": "If all you're trying to do is show a splash screen then maybe there's a simpler answer, by way of a workaround", "label": {"api": {"show a splash screen": [[30, 49]]}}}, {"text": "Apparently you can show a splash screen upon application load by doing", "label": {"api": {"show a splash screen": [[19, 38]]}}}, {"text": "Also see the documentation of toCharArray()", "label": {"api": {"documentation of toCharArray()": [[13, 42]]}}}, {"text": "We can see this in action in the HttpServlet class, which has implementations for each of the web methods (doGet(), doPost(), doPut() and doDelete()) that throw a ServletException and which a subclass must override if they want a class that does something useful for a particular web method", "label": {"api": {"HttpServlet": [[33, 43]]}}}, {"text": "Avoiding the use of additional, external libraries, you may wish to supply an interceptor that implements that standard J2EE servlet Filter interface", "label": {"api": {"Filter": [[133, 138]]}}}, {"text": "Read the JavaDoc for ConcurrentHashMap.values()", "label": {"api": {"ConcurrentHashMap.values()": [[21, 46]]}}}, {"text": "Random objects provide a source from which random numbers can be produced -- they are not the random numbers themselves", "label": {"api": {"Random": [[0, 5]]}}}, {"text": "You only need one Random instance", "label": {"api": {"Random": [[18, 23]]}}}, {"text": "The name() method belongs to the Enum class, so all enum values automatically have this method available", "label": {"api": {"the Enum class": [[29, 42]]}}}, {"text": "By default Enum#toString will return its name", "label": {"api": {"Enum#toString": [[11, 23]]}}}, {"text": "But I suspect that a practical instance when you'd see this would be if you call getReturnType() on a method that returns void", "label": {"api": {"getReturnType()": [[81, 95]]}}}, {"text": "I'm looking in the JavaDoc for both PrintWriter, and its underlying Writer (its out field), and I don't see any way to confirm that the PrintWriter is indeed open", "label": {"api": {"PrintWriter": [[36, 46], [136, 146]], "Writer": [[41, 46], [68, 73], [141, 146]], "out": [[80, 82]]}}}, {"text": "You can also checkError(), but is being closed really considered an error", "label": {"api": {"checkError()": [[13, 24]]}}}, {"text": "I would just use Lists and the removeAll method", "label": {"api": {"removeAll": [[31, 39]]}}}, {"text": "If you really need an array, you can always call the method toArray(T[]) on the resulting list", "label": {"api": {"toArray(T[])": [[60, 71]]}}}, {"text": "Stumbled over PlatformLoggingMXBean the other day", "label": {"api": {"PlatformLoggingMXBean": [[14, 34]]}}}, {"text": "Try the ImageIO class, which can take a byte array representing pixel data to build an image object and then writing it out in a particular format", "label": {"api": {"ImageIO": [[8, 14]]}}}, {"text": "Well the thing is I'm working on a IDateEditor interface implementation from JCalendar library and I've noticed that Component.firePropertyChange(String propertyName, Object oldValue, Object newValue) method is not public but protected", "label": {"api": {"Component.firePropertyChange(String propertyName, Object oldValue, Object newValue)": [[117, 199]]}}}, {"text": "Of course if I make my class extending from JFormattedTextfield instead of using a simple variable I could easily get rid of this problem", "label": {"api": {"JFormattedTextfield": [[44, 62]]}}}, {"text": "So, in order to fulfill the interface I've used PropertyChangeSupport to keep a list of property change listeners and notify them on a PropertyChangeEvent", "label": {"api": {"PropertyChangeSupport": [[48, 68]], "PropertyChangeEvent": [[135, 153]]}}}, {"text": "As you can see the task to add/remove PropertyChangeListeners and notify them on property change events is delegated to the PropertyChangeSupport class member, but the source of the event is this, that is the IDateEditor interface implementer", "label": {"api": {"PropertyChangeSupport": [[124, 144]]}}}, {"text": "You can of course use JAXP and parse the XML into a Document, but you'll be a lot more productive using a more Java friendly API like JDOM", "label": {"api": {"Document": [[52, 59]]}}}, {"text": "How to get the creation date of a file in Java, using BasicFileAttributes class, this is an example", "label": {"api": {"BasicFileAttributes": [[54, 72]]}}}, {"text": "Alternative are classes from java.io or Apache Commons IO, also Guava IO can help", "label": {"api": {"java.io": [[29, 35]]}}}, {"text": "I would get all the mappings using entrySet, and loop through them to take the first element of the array", "label": {"api": {"entrySet": [[35, 42]]}}}, {"text": "You might want to use a different Charset, depending on the charset of your text file", "label": {"api": {"Charset": [[34, 40]]}}}, {"text": "However your predecessor is not the first person to have encountered this and the standard way to deal with the need to concatenate many Strings in Java is to use a StringBuilder", "label": {"api": {"StringBuilder": [[165, 177]]}}}, {"text": "You may stop the timer this way or you may use a static timer and schedule/cancel the task each time", "label": {"api": {"schedule/cancel the task": [[66, 89]]}}}, {"text": "In order to get a corresponding value for a given key, you should use the get(Object key) method", "label": {"api": {"get(Object key)": [[74, 88]]}}}, {"text": "Depending on the size of the data set BigDecimal instantiated from an imported String representation might be an easy and accurate option", "label": {"api": {"instantiated": [[49, 60]]}}}, {"text": "You'll need to convert it to a double, then multiply it with Double.parseDouble", "label": {"api": {"Double.parseDouble": [[61, 78]]}}}, {"text": "You may prefer to explicitly override Object.finalize()", "label": {"api": {"Object.finalize()": [[38, 54]]}}}, {"text": "If you want to consider Unicode letters and digits, you may want to look at Unicode character classes", "label": {"api": {"Unicode character classes": [[76, 100]]}}}, {"text": "The Java Sound based Clip preloads the data, so it should be fine", "label": {"api": {"Clip": [[21, 24]]}}}, {"text": "The Clip interface represents a special kind of data line whose audio data can be loaded prior to playback, instead of being streamed in real time", "label": {"api": {"Clip": [[4, 7]]}}}, {"text": "In my code, I have a BufferedImage that was loaded with the ImageIO class like so", "label": {"api": {"BufferedImage": [[21, 33]], "ImageIO": [[60, 66]]}}}, {"text": "Later on, I want to save it to a byte array, but the ImageIO.write method requires me to pick either a GIF, PNG, or JPG format to write my image as (as described in the tutorial here)", "label": {"api": {"ImageIO": [[53, 59]]}}}, {"text": "Is there a way that I can determine from the BufferedImage what the original file format was", "label": {"api": {"BufferedImage": [[45, 57]]}}}, {"text": "I'm aware that I could simply parse the file path when I load the image to find the extension and just save it for later, but I'd ideally like a way to do it straight from the BufferedImage", "label": {"api": {"BufferedImage": [[176, 188]]}}}, {"text": "Another solution is to use a PreparedStatement and to bind the parameters (some prefer this second option because it usually scales better and has faster performance)", "label": {"api": {"PreparedStatement": [[29, 45]]}}}, {"text": "If the FileSystemView class you are using is from the javax.swing.filechooser package, don't expect too much", "label": {"api": {"javax.swing.filechooser": [[54, 76]]}}}, {"text": "You can use File#renameTo in Java to do the same thing, provided the OS can do so with the source and destination", "label": {"api": {"File#renameTo": [[12, 24]]}}}, {"text": "File#renameTo won't do that; the rename will fail (it'll return false) and you have to respond to that by doing the file copy (and then removal of the old file) yourself", "label": {"api": {"File#renameTo": [[0, 12]]}}}, {"text": "Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running", "label": {"api": {"Runtime": [[54, 60]]}}}, {"text": "The current runtime can be obtained from the getRuntime method", "label": {"api": {"Runtime": [[48, 54]]}}}, {"text": "That's what a BlockingQueue exists for", "label": {"api": {"BlockingQueue": [[14, 26]]}}}, {"text": "It has a take() method that forces a thread to block until an Object is avalaible", "label": {"api": {"take()": [[9, 14]]}}}, {"text": "ActionListener is an interface", "label": {"api": {"ActionListener": [[0, 13]]}}}, {"text": "For case insensitive string comparison, use the String method str1.equalsIgnoreCase(str2)", "label": {"api": {"String": [[48, 53]]}}}, {"text": "If the trim() method would do nothing (because the string is already trimmed), the same string object (ie this) is returned", "label": {"api": {"trim()": [[7, 12]]}}}, {"text": "These two facts together is why == is true for the comparison of \"String\".trim() == \"String\"", "label": {"api": {"trim()": [[74, 79]]}}}, {"text": "However, you may try using a TreeMap which has the method descendingMap", "label": {"api": {"TreeMap": [[29, 35]]}}}, {"text": "A TreeMap will help you with your goal because it is a Map ordered by the natural order of the keys", "label": {"api": {"TreeMap": [[2, 8]]}}}, {"text": "Since Integer class doesn't have a 0-arg constructor, you can't directly use Class#newInstance() method here", "label": {"api": {"Class#newInstance()": [[77, 95]]}}}, {"text": "Rather, you can get the appropriate constructor, taking String or int argument using Class#getConstructor() method", "label": {"api": {"Class#getConstructor()": [[85, 106]]}}}, {"text": "Chech this link, it has the solution", "label": {"api": {"link": [[11, 14]]}}}, {"text": "Cashier extends JFrame", "label": {"api": {"JFrame": [[16, 21]]}}}, {"text": "DBaccess extends Cashier (which extends from JFrame)", "label": {"api": {"JFrame": [[45, 50]]}}}, {"text": "a tipical Swing application should have only one JFrame", "label": {"api": {"JFrame": [[49, 54]]}}}, {"text": "You should use JDialog instead", "label": {"api": {"JDialog": [[15, 21]]}}}, {"text": "See The Use of Multiple JFrames, Good/Bad Practice", "label": {"api": {"JFrame": [[24, 29]]}}}, {"text": "Take a look to PreparedStatement to avoid this", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "If DBaccess class will display the query results using Swing components, then you may want to take a look to SwingWorker class to do the database call in a background thread and update Swing components in the Event Dispatch Thread", "label": {"api": {"SwingWorker": [[109, 119]]}}}, {"text": "You can do it using threads (java.lang.Thread)", "label": {"api": {"java.lang.Thread": [[29, 44]]}}}, {"text": "When a player presses a key you start a new thread which moves the circle for 1 pixel, 32 times, with delay (Thread#sleep)", "label": {"api": {"Thread#sleep": [[109, 120]]}}}, {"text": "I'm not sure what your exact intention is with the random string and the file scanner, but a basic way to do the string counting you asked about would be to use a regular expression (the Pattern class)", "label": {"api": {"Pattern class": [[187, 199]]}}}, {"text": "Please read the documentation for String.indexOf(String s, int fromIndex) to understand what I've done", "label": {"api": {"String.indexOf(String s, int fromIndex)": [[34, 72]]}}}, {"text": "I would recommend using Arrays.fill() instead", "label": {"api": {"Arrays.fill()": [[24, 36]]}}}, {"text": "Consider using a StringBuilder's append method instead", "label": {"api": {"StringBuilder": [[17, 29]]}}}, {"text": "An AtomicMarkableReference does exactly what you want and is also thread safe in case that is a concern", "label": {"api": {"AtomicMarkableReference": [[3, 25]]}}}, {"text": "The first call of the method invalidates at least one of those conditions; by using the AtomicMarkableReference instead of a plain AtomicReference, it covers the case of null being explicitly set", "label": {"api": {"AtomicMarkableReference": [[88, 110]]}}}, {"text": "Check out Path2D", "label": {"api": {"Path2D": [[10, 15]]}}}, {"text": "It is an implementation of the Shape interface, which will provide the intersects() and contains() methods mentioned by @trashgod in the comments above", "label": {"api": {"Shape": [[31, 35]]}}}, {"text": "String.toCharArray() does not remove or \"skip\" spaces", "label": {"api": {"String.toCharArray()": [[0, 19]]}}}, {"text": "You could use either a HashSet or a TreeSet since dublications there are not allowed", "label": {"api": {"HashSet": [[23, 29]], "TreeSet": [[36, 42]]}}}, {"text": "If you use the Stack, there is a pop() method that actually removes and returns the first element, you could simply store that element somewhere(another list) and access it again if needed", "label": {"api": {"Stack": [[15, 19]]}}}, {"text": "Or create this method in your Stack implementation", "label": {"api": {"Stack": [[30, 34]]}}}, {"text": "As it turns out, List specifies a remove(Object o) function that would allow you to remove things much more straightforwardly", "label": {"api": {"remove(Object o)": [[34, 49]]}}}, {"text": "You can interrupt your thread with Future.cancel(true)", "label": {"api": {"Future.cancel(true)": [[35, 53]]}}}, {"text": "It's in your responsibility to implement the Runnable in a manner that it obeys that wish by checking its Thread.interrupted() state", "label": {"api": {"Thread.interrupted()": [[106, 125]]}}}, {"text": "Java class TreeSet which is based on search tree of comparable objects instead of hash table has similar methods floor and ceiling", "label": {"api": {"TreeSet": [[11, 17]], "floor": [[113, 117]], "ceiling": [[123, 129]]}}}, {"text": "I think that you have been cheated by java.lang.Byte.toString() which by default print signed representation of bytes", "label": {"api": {"java.lang.Byte.toString()": [[38, 62]]}}}, {"text": "You must use the utility method Arrays.toString()", "label": {"api": {"Arrays.toString()": [[32, 48]]}}}, {"text": "In Java, each object has toString() method, the default is displaying the class name representation, then adding @ and then the hashcode", "label": {"api": {"toString()": [[25, 34]]}}}, {"text": "You should use Arrays#toString(), which is implemented this way (I advise you to go through it to better understand what's going on)", "label": {"api": {"toString()": [[22, 31]], "Arrays#toString()": [[15, 31]]}}}, {"text": "If you want to use regex in your match, you need to use replaceAll() instead of replace()", "label": {"api": {"replaceAll()": [[56, 67]], "replace()": [[80, 88]]}}}, {"text": "I'm looking for a method like GraphicsContext.setMode( GraphicsContextMode.XOR ) but I haven't found it", "label": {"api": {"GraphicsContext": [[30, 44], [55, 69]]}}}, {"text": "In addition to MouseListener, use a MouseMotionListener", "label": {"api": {"MouseMotionListener": [[36, 54]]}}}, {"text": "My guess is it's related to recordList.subList()", "label": {"api": {"recordList.subList()": [[28, 47]]}}}, {"text": "For a map where the values are basic types (or Embeddable types) like Boolean, you need to use the @ElementCollection annotation", "label": {"api": {"@ElementCollection annotation": [[99, 127]]}}}, {"text": "String#replaceAll accept a regex, not a regular String", "label": {"api": {"String#replaceAll": [[0, 16]], "String#replace": [[0, 13]]}}}, {"text": ") has a special meaning in regex, using quote will cause treating :) as the String :) and not the regex", "label": {"api": {"quote": [[40, 44]]}}}, {"text": "If you don't want to use Pattern#quote, you should escape the ) by \\\\", "label": {"api": {"quote": [[33, 37]], "Pattern#quote": [[25, 37]]}}}, {"text": "If you don't like any of the mentioned, use String#replace that doesn't accept a regex, and you're fine", "label": {"api": {"String#replace": [[44, 57]]}}}, {"text": "Don't use replaceAll(); use replace() when you want to replace literal strings", "label": {"api": {"replace()": [[28, 36]]}}}, {"text": "Since Java 7 you can also simply wrap a byte array in a BitSet for easy access to individual bits", "label": {"api": {"wrap a byte array in a BitSet": [[33, 61]]}}}, {"text": "Then use Collections.shuffle", "label": {"api": {"Collections.shuffle": [[9, 27]]}}}, {"text": "Or maybe consider using a DecimalFormat for more precise formatting", "label": {"api": {"DecimalFormat": [[26, 38]]}}}, {"text": "To round, you can use Math.round() instead", "label": {"api": {"Math.round()": [[22, 33]]}}}, {"text": "If so, Math.round() won't quite do what you want", "label": {"api": {"Math.round()": [[7, 18]]}}}, {"text": "You can instead use a LinkedHashMap, which guarantees an iteration order equal to the order of insertion", "label": {"api": {"LinkedHashMap": [[22, 34]]}}}, {"text": "If you want to use null here, you can use the wrapper class Integer instead", "label": {"api": {"Integer": [[60, 66]]}}}, {"text": "As @JBNizet points out, a nice alternative if you want to modify an array of Integer is to use an ArrayList instead", "label": {"api": {"Integer": [[77, 83]], "ArrayList": [[98, 106]]}}}, {"text": "According to http://docs.oracle.com/javase/7/docs/api/ URL represents an Uniform Resource Locator, which is merely an address", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/": [[13, 53]]}}}, {"text": "Object.clone() is protected, you can't call it from outside the class or its subclasses unless they explicitly change the access modifier to public thus there is no guarantee an object has a visible clone() method", "label": {"api": {"Object.clone()": [[0, 13]]}}}, {"text": "We could come up with more direct examples, but an easy one is the Iterator in DirectoryStream", "label": {"api": {"DirectoryStream": [[79, 93]]}}}, {"text": "While a DirectoryStream is technically Iterable, it only allows one Iterator to be constructed, so if you tried to do the following", "label": {"api": {"DirectoryStream": [[8, 22]]}}}, {"text": "The * tells the compiler to import all top-level classes in java.io on demand", "label": {"api": {"java.io": [[60, 66]]}}}, {"text": "So, for example, since you've included that import statement, you can use a class like java.io.File without having to prefix the type name with java.io; you can use the simple name File", "label": {"api": {"java.io": [[87, 93], [144, 150]]}}}, {"text": "This follows the general idea outlined by @Jabir, but uses a JOptionPane (which uses a modal dialog as the display component) because it has a number of convenience methods that do the heavy lifting we would otherwise need to implement in a plain modal dialog", "label": {"api": {"JOptionPane": [[61, 71]]}}}, {"text": "Null pointer Execption is thrown when an application attempts to use null in a case where an object is required", "label": {"api": {"Null pointer Execption": [[0, 21]]}}}, {"text": "That happens because when you use setDataVector() according to docs that recreates columns and your column width changes to default", "label": {"api": {"setDataVector()": [[34, 48]]}}}, {"text": "Try to use setAutoCreateColumnsFromModel() to prevent that behavior", "label": {"api": {"setAutoCreateColumnsFromModel()": [[11, 41]]}}}, {"text": "As @TimB points out, all the date and time patterns can be found in the JavaDoc for SimpleDateFormat", "label": {"api": {"the JavaDoc for SimpleDateFormat": [[68, 99]]}}}, {"text": "As the javadoc of JTable states", "label": {"api": {"javadoc of JTable": [[7, 23]]}}}, {"text": "In that case you can try to write a custom TableCellRenderer for JTableHeader", "label": {"api": {"TableCellRenderer": [[43, 59]]}}}, {"text": "I think reflections API may help you", "label": {"api": {"reflections API": [[8, 22]]}}}, {"text": "You can use your constructed regex together with the matches() method provided you escape all your \\ and allow repeated occurences with the + operator", "label": {"api": {"matches()": [[53, 61]]}}}, {"text": "You should include your properties file in the WEB-INF/classes directory of your war file and then use ClassLoader.getResourceAsStream(String) passing the name of the properties file", "label": {"api": {"ClassLoader.getResourceAsStream(String)": [[103, 141]]}}}, {"text": "If you need something like \"waiting threads\" that wait for the child threads to finish until they can complete their work, have a look at java.util.concurrent.ForkJoinPool", "label": {"api": {"java.util.concurrent.ForkJoinPool": [[138, 170]]}}}, {"text": "The tasks themselves are implemented by subclassing java.util.concurrent.RecursiveTask", "label": {"api": {"java.util.concurrent.RecursiveTask": [[52, 85]]}}}, {"text": "It is true that it will return a new String , but unless the call is part of some giant loop or recursive function, one need not worry too much", "label": {"api": {"will return a new String": [[19, 42]]}}}, {"text": "A class called StringBuilder, should be used when you perform lot of operations that involve characters manipulations like replace", "label": {"api": {"StringBuilder": [[15, 27]]}}}, {"text": "An example of this would be the DOM XML implementation provided in Java", "label": {"api": {"DOM XML implementation": [[32, 53]]}}}, {"text": "For instance, assume they provided a faulty Element public implementation named BuggedElement, and clients directly used it in their code", "label": {"api": {"Element": [[44, 50], [86, 92]]}}}, {"text": "From this point on, they would be forced to maintain this implementation, rather than just removing it and writing a new implementation, otherwise existing projects using this concrete implementation would be forced to re-write pieces of code referring to BuggedElement", "label": {"api": {"Element": [[262, 268]]}}}, {"text": "Because List<E> implements Iterable<T>, you can use a for-each loop to iterate over the List<Measurement> obtained from parsing and calculate the average", "label": {"api": {"List<E>": [[8, 14]], "Iterable<T>": [[27, 37]]}}}, {"text": "Send it over the Looback address (127.0.0.1) via sockets (C# & Java)", "label": {"api": {"Java": [[63, 66]]}}}, {"text": "With this, both the C# and Java applications can continue their process without interuption", "label": {"api": {"Java": [[27, 30]]}}}, {"text": "The output should be a list of binary class names", "label": {"api": {"binary class names": [[31, 48]]}}}, {"text": "Also, the list of guaranteed system properties does not include properties with this kind of classpath info (such as sun.boot.class.path)", "label": {"api": {"list of guaranteed system properties": [[10, 45]]}}}, {"text": "Just make sure to follow the contract of compare -- return an int less than 0, equal to 0, or greater than 0, if d1 is \"less than\" d2, if d1 is \"equal to\" d2, or d1 is \"greater than\" d2, respectively", "label": {"api": {"contract of compare": [[29, 47]]}}}, {"text": "You can use java.awt.Color's own static Color constants, e.g", "label": {"api": {"java.awt.Color's own static Color constants": [[12, 54]]}}}, {"text": "You could simply use File#toURI which will give you a URI, which could then use toString to generate a String representation of the URI which could then be added to the list..", "label": {"api": {"File#toURI": [[21, 30]], "URI": [[28, 30], [54, 56], [132, 134]]}}}, {"text": "Use Window.getWindows() to get reference to all windows, and check if they are visible with Window.isShowing()", "label": {"api": {"Window.getWindows()": [[4, 22]], "Window.isShowing()": [[92, 109]]}}}, {"text": "Worth to note that windows that have been hidden but not disposed will still prevent Java from exiting", "label": {"api": {"disposed": [[57, 64]]}}}, {"text": "Just change the code to use Double instead of double", "label": {"api": {"Double": [[28, 33]]}}}, {"text": "You could use the Scanner class in Java to read lines of the text files, and the PrintWriter class to create the updated.txt file", "label": {"api": {"Scanner class": [[18, 30]], "PrintWriter class": [[81, 97]]}}}, {"text": "Have you tried using @XmlValue instead of @XmlElement for the time field", "label": {"api": {"@XmlValue": [[21, 29]]}}}, {"text": "Use the Temporal annotation", "label": {"api": {"Temporal annotation": [[8, 26]]}}}, {"text": "Rather than getRequestParameterMap() (which is read-only) you should invoke getRequestMap() on the ExternalContext", "label": {"api": {"getRequestParameterMap()": [[12, 35]], "getRequestMap()": [[76, 90]]}}}, {"text": "You can use the static methods of class Thread to do something with the current thread", "label": {"api": {"the static methods of class Thread": [[12, 45]]}}}, {"text": "The standard API already has a binary search that allows doing this fine", "label": {"api": {"binary search": [[31, 43]]}}}, {"text": "You can use the ArrayList.toArray(T[]) method, like so", "label": {"api": {"ArrayList.toArray(T[])": [[16, 37]]}}}, {"text": "A simple way you can do this would be to make use of the valueOf method of the Enum class", "label": {"api": {"valueOf": [[57, 63]]}}}, {"text": "If they did not, you get an IllegalArgumentException, which you can catch with a try...catch block", "label": {"api": {"IllegalArgumentException": [[28, 51]]}}}, {"text": "One way of achieving this is calling Integer.compare (assuming that minute is an int in your myclass class)", "label": {"api": {"Integer.compare": [[37, 51]]}}}, {"text": "RandomAccessFile has writeDouble / readDouble methods that I think do exactly what you want - ie, dumping primitive values \"as such\" in a file and reading them back", "label": {"api": {"RandomAccessFile": [[0, 15]]}}}, {"text": "To make code less cluttered, one can use Stream-related functionality that is available starting from Java 1.8", "label": {"api": {"Stream": [[41, 46]]}}}, {"text": "Even changing the default Locale with Locale.setDefault(Locale.JAPANESE); won't help", "label": {"api": {"Locale": [[26, 31], [38, 43], [56, 61]]}}}, {"text": "You should also use a java.sql.PreparedStatement like this", "label": {"api": {"java.sql.PreparedStatement": [[22, 47]]}}}, {"text": "Are you looking for String.split(String regex)", "label": {"api": {"String.split(String regex)": [[20, 45]]}}}, {"text": "You should also look at the contains method", "label": {"api": {"contains": [[28, 35]]}}}, {"text": "You'll want to use a HashMap to avoid recalculating the same numbers multiple times", "label": {"api": {"HashMap": [[21, 27]]}}}, {"text": "Checking if the HashMap already contains the number is a quick process and can save you many steps", "label": {"api": {"HashMap": [[16, 22]]}}}, {"text": "You threw away your bind parameter when you passed the SQL to Statement#executeQuery - use this one from PreparedStatement..", "label": {"api": {"this one": [[91, 98]]}}}, {"text": "You can get all the getters using Introspector", "label": {"api": {"Introspector": [[34, 45]]}}}, {"text": "I have tried looking at How does Java Dispatch KeyEvents as well as the KeyboardFocusManager and KeyEventDispatcher APIs, but I haven't been able to figure it out, nor is it even clear that these were the correct places to be looking for an answer", "label": {"api": {"KeyboardFocusManager": [[72, 91]], "KeyEventDispatcher": [[97, 114]]}}}, {"text": "You should be able to achieve this by using indexOf and subList", "label": {"api": {"indexOf": [[44, 50]], "subList": [[56, 62]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html you could just use indexOf and lastIndexOf", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[0, 64]]}}}, {"text": "Read the documentation about String.format() and the format string syntax", "label": {"api": {"String.format()": [[29, 43]], "format string syntax": [[53, 72]]}}}, {"text": "You can use JDK ImageIO to do this (http://docs.oracle.com/javase/6/docs/api/javax/imageio/ImageIO.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/imageio/ImageIO.html": [[36, 102]]}}}, {"text": "By calling the setFileFilter method", "label": {"api": {"setFileFilter": [[15, 27]]}}}, {"text": "Rather than putting the call in every JSP I would register a ServletRequestListener, which gets notified both when the request starts and when it finishes", "label": {"api": {"ServletRequestListener": [[61, 82]]}}}, {"text": "String#replaceAll can take a regex", "label": {"api": {"String#replaceAll": [[0, 16]]}}}, {"text": "Querying the map using the ceilingEntry method and passing the random number will return the \"mapping associated with the least key greater than or equal to the given key\", so e.g", "label": {"api": {"\"mapping associated with the least key greater than or equal to the given key\"": [[93, 170]]}}}, {"text": "Actually the constructor needs a Writer and you could provide a StringWriter to create a String", "label": {"api": {"Writer": [[33, 38], [70, 75]], "a StringWriter": [[62, 75]]}}}, {"text": "To modify the example given here, just use a StringWriter instead of a FileWriter", "label": {"api": {"StringWriter": [[45, 56]]}}}, {"text": "I know XML schema is itself XML, so I can use Document, Element, Node and other classes/interfaces from org.w3c.dom, but I wonder is there something more convenient", "label": {"api": {"org.w3c.dom": [[104, 114]]}}}, {"text": "Have a look at the Scanner API and the Scanner tutorial (which are the first and second results for googling \"Java Scanner\") for more info", "label": {"api": {"Scanner API": [[19, 29]]}}}, {"text": "Have you try using 'Semaphore' at Oracle Docs", "label": {"api": {"Oracle Docs": [[34, 44]]}}}, {"text": "It's simple do get a Double from a double, using the Double.valueof(double d) method of the Double class", "label": {"api": {"Double.valueof(double d)": [[53, 76]]}}}, {"text": "If you look at the ArrayList api and take a look at the class declaration, you see it is declared like this", "label": {"api": {"ArrayList api": [[19, 31]]}}}, {"text": "java.util.concurrent.TimeUnit is your best friend when dealing with converting units of time", "label": {"api": {"java.util.concurrent.TimeUnit": [[0, 28]]}}}, {"text": "ExecutorService and Service are interfaces and so only have abstract methods, which means that their methods are not implemented", "label": {"api": {"ExecutorService": [[0, 14]]}}}, {"text": "NumberFormat is probably better than String.format for this purpose", "label": {"api": {"NumberFormat": [[0, 11]]}}}, {"text": "You can use a decimal formatter for the specified pattern", "label": {"api": {"decimal formatter": [[14, 30]]}}}, {"text": "Is there a way to make a HTMLEditor text wrap in JavaFX", "label": {"api": {"HTMLEditor": [[25, 34]]}}}, {"text": "TextArea has the method setWrapText", "label": {"api": {"TextArea": [[0, 7]], "setWrapText": [[24, 34]]}}}, {"text": "The JavaFX CSS documentation specifies -fx-wrap-text for Labeled nodes, but that doesn't seem to work", "label": {"api": {"JavaFX CSS documentation": [[4, 27]]}}}, {"text": "You could just do position + 1 or position - 1, or you can actually use a random spot using the Random class", "label": {"api": {"Random": [[96, 101]]}}}, {"text": "As others have mentioned, you can use the Random class to generate random values", "label": {"api": {"Random": [[42, 47]]}}}, {"text": "The shutdown hook part is in Runtime", "label": {"api": {"Runtime": [[29, 35]]}}}, {"text": "What you are looking for is javax.crypto.SealedObject or java.security.SignedObject", "label": {"api": {"javax.crypto.SealedObject": [[28, 52]], "java.security.SignedObject": [[57, 82]]}}}, {"text": "Alternatively you can use a ProcessBuilder", "label": {"api": {"a ProcessBuilder": [[26, 41]]}}}, {"text": "StringBuilder is an object not a wrapper", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "Note that if you had used @Override annotation, your compiler would have produced an error because this method does not override anything :) Using this annotation is a good habit IMO", "label": {"api": {"@Override": [[26, 34]]}}}, {"text": "And if you do not know the size before hand, then it is better to use an ArrayList instead of an array", "label": {"api": {"ArrayList": [[73, 81]]}}}, {"text": "You need to iterate your array element one by one, use String.startsWith(prefixText) function to check your string is start with search text, add your search element in one List and convert that list into array return that array", "label": {"api": {"String.startsWith(prefixText)": [[55, 83]]}}}, {"text": "String#replaceAll() method takes a regex as first parameter", "label": {"api": {"String#replaceAll()": [[0, 18]]}}}, {"text": "You can just use String#replace() instead", "label": {"api": {"String#replace()": [[17, 32]]}}}, {"text": "Consider to use NumberFormat.getCurrencyInstance or DecimalFormat", "label": {"api": {"NumberFormat.getCurrencyInstance": [[16, 47]], "DecimalFormat": [[52, 64]]}}}, {"text": "NumberFormat provides a parse method", "label": {"api": {"parse": [[24, 28]]}}}, {"text": "When you open a file using java.io.FileWriter, you can pass a second boolean argument to the constructor that indicates whether you want to append (true) or overwrite (false) existing data", "label": {"api": {"constructor": [[93, 103]]}}}, {"text": "You might want to read all of http://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html to see what it can do", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html": [[30, 101]]}}}, {"text": "As the manual says, the throwable is the 6th parameter of the method format", "label": {"api": {"manual says": [[7, 17]]}}}, {"text": "The default toString() implementation in Object returns a string that looks like \"fully.qualified.ClassName@objectID\"", "label": {"api": {"Object": [[41, 46]]}}}, {"text": "The documentation of RetentionPolicy.CLASS says", "label": {"api": {"documentation of RetentionPolicy.CLASS": [[4, 41]]}}}, {"text": "I don't know if there is an easier way, but you could create a ServletContextListener and run a test query from contextInitialized()", "label": {"api": {"ServletContextListener": [[63, 84]]}}}, {"text": "It is an error to declare a class Serializable if this is not the case", "label": {"api": {"Serializable": [[34, 45]]}}}, {"text": "And your case is that X509v3CertificateBuilder doesn't implements Serializable and X509v3CertificateBuilder has no accessible (public or protected) no-arg constructor", "label": {"api": {"Serializable": [[66, 77]]}}}, {"text": "What you need, you will easyly find at the String documentation", "label": {"api": {"String": [[43, 48]]}}}, {"text": "Otherwise, based on my understanding in the Timer class, it only waits one second, which might be too short of a timespan for what you're waiting to capture", "label": {"api": {"Timer class": [[44, 54]]}}}, {"text": "I can get the Field no problem, and then getGenericType, but that just returns a Type which has no methods on it", "label": {"api": {"Field": [[14, 18]], "getGenericType": [[41, 54]], "Type": [[51, 54], [81, 84]]}}}, {"text": "I can cast it to ParameterizedType, but getActualTypeArguments()", "label": {"api": {"Type": [[30, 33], [49, 52]], "ParameterizedType": [[17, 33]], "getActualTypeArguments()": [[40, 63]]}}}, {"text": "The toString() method on the ParameterizedType returns the expected value, there seems to be no way to access the information on the wildcard upper boud, and all the implementations of ParameterizedType seem to be in sun", "label": {"api": {"Type": [[42, 45], [198, 201]], "ParameterizedType": [[29, 45], [185, 201]]}}}, {"text": "Character.isWhitespace can help you solve your problem", "label": {"api": {"Character.isWhitespace": [[0, 21]]}}}, {"text": "Asusming the real problem ou're asking about is \"how to find an integer in an int[] array\", why not just use Arrays.html#binarySearch", "label": {"api": {"Arrays.html#binarySearch": [[109, 132]]}}}, {"text": "You can use the JavaCompiler to compile any java code to a class file", "label": {"api": {"JavaCompiler": [[16, 27]]}}}, {"text": "You can then load the resulting class with a URLClassLoader", "label": {"api": {"URLClassLoader": [[45, 58]]}}}, {"text": "You should create your own ClassLoader implementation, override its loadClass method and there call defineClass, providing it with the bytecode", "label": {"api": {"ClassLoader": [[27, 37]]}}}, {"text": "Then you instantiate you ClassLoader and get your class from it that way", "label": {"api": {"ClassLoader": [[25, 35]]}}}, {"text": "It's not really clear what you want to do with all these static methods in the Enum, but regarding the asked issue, have a look at EnumSet and its contains method", "label": {"api": {"EnumSet": [[131, 137]]}}}, {"text": "When you think \"polling\" or \"update at intervals\", use a ScheduledExecutorService to execute \"check for data update\" tasks at regular intervals", "label": {"api": {"ScheduledExecutorService": [[57, 80]]}}}, {"text": "You can decide to let the daemon thread do the work for the event, or create tasks for the event and let those tasks be executed by an ExecutorService like a CachedThreadPool", "label": {"api": {"CachedThreadPool": [[158, 173]]}}}, {"text": "Use an java.util.concurrent.ExecutorService", "label": {"api": {"java.util.concurrent.ExecutorService": [[7, 42]]}}}, {"text": "Creating java.lang.Threads in a loop, as other anwsers suggest, is a bad idea because threads are not limitless resources but your list of user names could be large", "label": {"api": {"java.lang.Thread": [[9, 24]]}}}, {"text": "Here's how the code would look with a java.util.concurrent.ExecutorService", "label": {"api": {"java.util.concurrent.ExecutorService": [[38, 73]]}}}, {"text": "Using a PauseTransition is simple because it keeps everything on the JavaFX Application thread and you don't need to worry about potential threading issues", "label": {"api": {"PauseTransition": [[8, 22]]}}}, {"text": "Your rs.absolute(index) moves the cursor back (to row 1) and the while(rs.next()) loop never ends", "label": {"api": {"rs.absolute(index)": [[5, 22]]}}}, {"text": "I'd like to test a universal view for a JavaFX-Task using Junit4", "label": {"api": {"Task": [[47, 50]]}}}, {"text": "The problem is that the test thread seems to \"run\" through the testDummyTask method and once it has reached the end of the test function, it immediately tears down everything", "label": {"api": {"Task": [[72, 75]]}}}, {"text": "The method TaskBarController.start() is defined as follows", "label": {"api": {"Task": [[11, 14]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html#stop(), method stop", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html#stop()": [[0, 69]]}}}, {"text": "compareTo doesn't always make sense, sometimes the objects cannot be logically ordered", "label": {"api": {"compareTo": [[0, 8]]}}}, {"text": "Also note that equals always exists, since it's defined in Object class", "label": {"api": {"equals": [[15, 20]]}}}, {"text": "It's a good practice to always haven equals method when you have compareTo, and they should be consistent", "label": {"api": {"compareTo": [[65, 73]], "equals": [[37, 42]]}}}, {"text": "You can create your own custom object serializer in Java with the Externalizable interface", "label": {"api": {"Externalizable": [[66, 79]]}}}, {"text": "See the API docs of class java.lang.Class and the package java.lang.reflect", "label": {"api": {"java.lang.Class": [[26, 40]]}}}, {"text": "Please have a look to the ScriptEngine class to understand how to handle return values and how to modify my eval function as per your needs", "label": {"api": {"ScriptEngine": [[26, 37]]}}}, {"text": "What you're describing, however, would best be implemented by either a Supplier or a Future, depending on the work involved in successfully constructing the object you need", "label": {"api": {"Future": [[85, 90]]}}}, {"text": "The difference is somewhat pedantic, but you'd generally use a Future to hold a reference that will take a long time to compute, while a Supplier generally returns quickly", "label": {"api": {"Future": [[63, 68]]}}}, {"text": "Future also has some nice hook-ins with Java's concurrency utilities, but by the sound of it you don't need that", "label": {"api": {"Future": [[0, 5]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html and http://www.codeproject.com/Tips/683614/10-Things-to-Know-about-Memory-Mapped-File-in-Java", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html": [[0, 70]]}}}, {"text": "If you're using JNDI you can use a NamingListener or one of its sub-interfaces, if the server supports notifications", "label": {"api": {"NamingListener": [[35, 48]]}}}, {"text": "You can call System.currentTimeMillis(), which returns a long", "label": {"api": {"System.currentTimeMillis()": [[13, 38]]}}}, {"text": "Number is also a super-class of AtomicInteger and AtomicLong", "label": {"api": {"Number": [[0, 5]], "AtomicInteger": [[32, 44]], "AtomicLong": [[50, 59]]}}}, {"text": "If Number had an add() method these sub-classes would have had to implement it as well, which is impossible to do while preserving the atomicity", "label": {"api": {"Number": [[3, 8]]}}}, {"text": "Java supports XSL transformations using the javax.xml.transform package", "label": {"api": {"javax.xml.transform": [[44, 62]]}}}, {"text": "Instead of using a RequestDispatcher you must build a redirect URL and perform HttpServletResponse.sendRedirect", "label": {"api": {"HttpServletResponse.sendRedirect": [[79, 110]]}}}, {"text": "If they are also Serializable then, yes otherwise you'll get a NotSerializableException", "label": {"api": {"Serializable": [[17, 28], [66, 77]], "NotSerializableException": [[63, 86]]}}}, {"text": "From the error alone it is apparent that a function or class cannot be found and that you therefore are missing libraries or are using the wrong ones", "label": {"api": {"it is apparent": [[21, 34]]}}}, {"text": "a HashMap of ArrayLists of some kind of pair or coordinate object", "label": {"api": {"HashMap": [[2, 8]], "ArrayLists": [[13, 22]]}}}, {"text": "HashMap can also accept a String (instead of Integer) as a key for the lists within", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "You can strip the hyphens with String.replace", "label": {"api": {"String.replace": [[31, 44]]}}}, {"text": "See JavaSound documentation for more information", "label": {"api": {"JavaSound documentation": [[4, 26]]}}}, {"text": "See also ExecutorService for another server example", "label": {"api": {"ExecutorService": [[9, 23]]}}}, {"text": "It turns out that the constructor of Media would throw MediaException - this is the exception that you need to catch", "label": {"api": {"constructor of Media": [[22, 41]], "MediaException": [[55, 68]]}}}, {"text": "If you read the HBox documentation, you will see the following", "label": {"api": {"HBox documentation": [[16, 33]]}}}, {"text": "HBox will resize children (if resizable) to their preferred widths and uses its fillHeight property to determine whether to resize their heights to fill its own height or keep their heights to their preferred (fillHeight defaults to true)..", "label": {"api": {"fillHeight": [[80, 89], [210, 219]]}}}, {"text": "As said, if for some reason you set the fillHeight property from HBox, you can make the nodes contained within to fill the vacant vertical space, But this will only occur for the nodes that are resizable", "label": {"api": {"fillHeight": [[40, 49]]}}}, {"text": "You can use EnumMap from JDK", "label": {"api": {"EnumMap": [[12, 18]]}}}, {"text": "You have to use Collections.sort() method", "label": {"api": {"Collections.sort()": [[16, 33]]}}}, {"text": "To print it directly, use PrintWriter.printf, e.g", "label": {"api": {"PrintWriter.printf": [[26, 43]]}}}, {"text": "The NumberFormat class has a pre-defined instance for currency formatting", "label": {"api": {"NumberFormat": [[4, 15]]}}}, {"text": "You need to url encode your URI or your files", "label": {"api": {"url encode": [[12, 21]]}}}, {"text": "Refer to http://docs.oracle.com/javase/7/docs/api/java/lang/String.html for the different ways to manipulate/parse strings", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[9, 70]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/io/PrintStream.html#println(java.lang.String) to understand what println does", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/PrintStream.html#println(java.lang.String)": [[4, 94]]}}}, {"text": "This will give you a value between [0, 255]", "label": {"api": {"give you a value between [0, 255]": [[10, 42]]}}}, {"text": "Check out Runtime", "label": {"api": {"Runtime": [[10, 16]]}}}, {"text": "You can use Futuretask (or just Future)", "label": {"api": {"Futuretask": [[12, 21]]}}}, {"text": "Use a Comparator, or have Website extend Comparable", "label": {"api": {"Comparator": [[6, 15]], "Comparable": [[41, 50]]}}}, {"text": "It is not (unless you implement it) :http://docs.oracle.com/javaee/6/api/javax/validation/constraints/package-summary.html shows all annotation constraints", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/validation/constraints/package-summary.html": [[37, 121]]}}}, {"text": "Instead use, Arrays.deepEquals(Object[] a, Object[] b)", "label": {"api": {"Arrays.deepEquals(Object[] a, Object[] b)": [[13, 53]]}}}, {"text": "Arrays.sort() uses the natural ordering of the objects, so that would imply that you need them to implement Comparable, or you're going to get unreliable sorting behavior", "label": {"api": {"Arrays.sort()": [[0, 12]]}}}, {"text": "Just use setLocationRelativeTo() method for your JDialog", "label": {"api": {"setLocationRelativeTo()": [[9, 31]]}}}, {"text": "Lookin at Oracle's documentation, I think you can compare PublicKey using its 3 getters", "label": {"api": {"Oracle's documentation": [[10, 31]]}}}, {"text": "You can use String#format()", "label": {"api": {"String#format()": [[12, 26]]}}}, {"text": "You can use java.text.MessageFormat for this", "label": {"api": {"java.text.MessageFormat": [[12, 34]]}}}, {"text": "The data type that can hold the highest value in Java is BigInteger", "label": {"api": {"BigInteger": [[57, 66]]}}}, {"text": "The most likely candidate ClassLoader that you will want to use is URLClassLoader", "label": {"api": {"URLClassLoader": [[67, 80]]}}}, {"text": "This link could be useful to understanding how to use SwingWorker", "label": {"api": {"link": [[5, 8]]}}}, {"text": "This attempt will fail if the task has already completed, has already been cancelled, or could not be cancelled for some other reason, like Oracle explains, and those \"some other reasons\" are discussed on the links I've posted", "label": {"api": {"link": [[209, 212]], "Oracle": [[140, 145]]}}}, {"text": "The VK_ values are static fields in the KeyEvent class", "label": {"api": {"KeyEvent class": [[40, 53]]}}}, {"text": "Here is a list of all the values", "label": {"api": {"a list of all the values": [[8, 31]]}}}, {"text": "If there isn't another string to read you'll get a NoSuchElementException as described in the JavaDoc  for Scanner.next()", "label": {"api": {"Scanner.next()": [[107, 120]]}}}, {"text": "It doesn't look like you use the second variable so either remove it or protect it with a Scanner.hasNext()", "label": {"api": {"Scanner.hasNext()": [[90, 106]]}}}, {"text": "In a situation where you have more complicated dependencies (or multiple schemas for the same namespace), you probably need to implement a custom LSResourceResolver and set it on the SchemaFactory", "label": {"api": {"LSResourceResolver": [[146, 163]]}}}, {"text": "A class extending Reader will have an underlying data source (see StringReader for example which, as you might guess, reads text from a String object)", "label": {"api": {"Reader": [[18, 23], [72, 77]], "StringReader": [[66, 77]]}}}, {"text": "In your assignment the objective is to create a reader that will strip all the whitespaces from that data source (implement, for example, a StringReader that never writes whitespaces into the target char[] array)", "label": {"api": {"Reader": [[146, 151]], "StringReader": [[140, 151]]}}}, {"text": "You can use String.replaceAll()", "label": {"api": {"String.replaceAll()": [[12, 30]]}}}, {"text": "I wouldn't recomend comparing strings, but in this case you may want to change the equals in your if to matches, since equals compares to another object so both dates may have the same value but they are completely different, on the other hand, matches compares to a regular expression", "label": {"api": {"equals": [[83, 88], [119, 124]], "matches": [[104, 110], [245, 251]]}}}, {"text": "Another way to do that is through the Calendar methods after, before or compareTo witch is the best way to do it", "label": {"api": {"Calendar": [[38, 45]], "after": [[55, 59]], "before": [[62, 67]], "compareTo": [[72, 80]]}}}, {"text": "In fact, the Javadocs for StringTokenizer states", "label": {"api": {"Javadocs for StringTokenizer": [[13, 40]]}}}, {"text": "The problem is that while the capacity of your Vector is 10 (as stated in the JavaDoc for the default constructor), it's actual size is 0", "label": {"api": {"JavaDoc for the default constructor": [[78, 112]]}}}, {"text": "Use a class with the Deque interface (such as an ArrayDeque) as recommended and you then have the descendingIterator() call", "label": {"api": {"ArrayDeque": [[49, 58]]}}}, {"text": "You may also wish to consider using the Scrollable interface to restrict the viewable area, for example..", "label": {"api": {"Scrollable": [[40, 49]]}}}, {"text": "You can't have an end value larger than your start value for String#substring()", "label": {"api": {"String#substring()": [[61, 78]]}}}, {"text": "From this documentation  by oracle, it is clear that subString() method will throw IndexOutOfBoundsException  if the beginIndex is negative, or endIndex is larger than the length of this String object, or beginIndex is larger than endIndex", "label": {"api": {"this documentation": [[5, 22]]}}}, {"text": "I suggest you to define a ServletContextListener, and to start a Quartz scheduler from its contextInitialized method", "label": {"api": {"ServletContextListener": [[26, 47]]}}}, {"text": "You're calling isPopupTrigger() like the example in Bringing Up a Popup Menu, but setComponentPopupMenu() may be easier", "label": {"api": {"setComponentPopupMenu()": [[82, 104]]}}}, {"text": "Use the Preferences class, it'll make sure that the settings are written to somewhere where it's allowed (such as user's home dir or the registry)", "label": {"api": {"Preferences": [[8, 18]]}}}, {"text": "You should use Thread.currentThread().getContextClassLoader() (javadoc) instead of the system class loader, which is \"the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application\" (reference)", "label": {"api": {"reference": [[245, 253]]}}}, {"text": "According to the javadoc for DefaultTableModel, the data must be a Vector<Vector<String>>", "label": {"api": {"the javadoc for DefaultTableModel": [[13, 45]]}}}, {"text": "Method close() of Closeable (and thus, of InputStream) is required to be idempotent", "label": {"api": {"Closeable": [[18, 26]]}}}, {"text": "However, more generic AutoCloseable interface does not require its close() method to idempotent, therefore it may be unsafe to do the same for resources other than Closeable", "label": {"api": {"Closeable": [[26, 34], [164, 172]], "AutoCloseable": [[22, 34]]}}}, {"text": "Note that unlike the close method of Closeable, this close method is not required to be idempotent", "label": {"api": {"Closeable": [[37, 45]]}}}, {"text": "In other words, calling this close method more than once may have some visible side effect, unlike Closeable.close which is required to have no effect if called more than once", "label": {"api": {"Closeable": [[99, 107]]}}}, {"text": "I'm using ListenableFuture from Guava, and one nice thing about them is that one pass Executor to the Futures.addCallback method, that is, ask to execute the callback on a given thread/executor", "label": {"api": {"Executor": [[86, 93]]}}}, {"text": "Have a look at ByteBuffer class", "label": {"api": {"ByteBuffer": [[15, 24]]}}}, {"text": "Both BigInteger and BigDecimal are subclasses of Number", "label": {"api": {"Number": [[49, 54]]}}}, {"text": "Finally, JPA has its own SqlResultSetMapping annotation", "label": {"api": {"SqlResultSetMapping": [[25, 43]]}}}, {"text": "Now you can rotate list1 whilst keeping list2 as is and pair {list1.get(1),list2.get(1)}, {list1.get(2),list2.get(2)}, etc", "label": {"api": {"rotate": [[12, 17]]}}}, {"text": "You can use String.format method", "label": {"api": {"String.format": [[12, 24]]}}}, {"text": "Since most of the methods in the Date class are deprecated, you can use java.util.Calendar", "label": {"api": {"java.util.Calendar": [[72, 89]]}}}, {"text": "Convert a java.util.Date to a org.joda.time.DateTime object is trivial, because DateTime has a constructor for this", "label": {"api": {"java.util.Date": [[10, 23]]}}}, {"text": "The Thread class constructor that takes a String argument creates a Thread with a specific name (as opposed to automatically generated names such as Thread-1)", "label": {"api": {"Thread": [[4, 9], [68, 73], [149, 154]]}}}, {"text": "When the start() method of a Thread instance is called the thread begins to execute (the run() method eventually gets called)", "label": {"api": {"Thread": [[29, 34]], "start()": [[9, 15]], "run()": [[89, 93]]}}}, {"text": "As you can see, in this case, the run() method of CustomThread1 class simply calls the show(String, int) method of its Shared instance, which prints whatever it is passed into the console", "label": {"api": {"Thread": [[56, 61]], "run()": [[34, 38]]}}}, {"text": "As others have pointed out, the super(str) method calls the constructor for Thread", "label": {"api": {"Thread": [[76, 81]]}}}, {"text": "As for what it does, the string passed to Thread will give the thread a name", "label": {"api": {"Thread": [[42, 47]]}}}, {"text": "This will allow you to easily identify the thread in debugging sessions and in Thread dumps", "label": {"api": {"Thread": [[79, 84]]}}}, {"text": "Without the string, it will have a boring name like, \"Thread-5\"", "label": {"api": {"Thread": [[54, 59]]}}}, {"text": "Here an example of the Date class", "label": {"api": {"example": [[8, 14]]}}}, {"text": "Using getValue() will tell you how the dialog was closed", "label": {"api": {"Using getValue()": [[0, 15]]}}}, {"text": "I decided to use a GridLayout LayoutManager for my Java Swing app because each cell within the grid is supposed to be exactly the same size", "label": {"api": {"GridLayout": [[19, 28]]}}}, {"text": "A GridLayout object places components in a grid of cells", "label": {"api": {"GridLayout": [[2, 11]]}}}, {"text": "And even in the description of the GridLayout class", "label": {"api": {"GridLayout": [[35, 44]]}}}, {"text": "The GridLayout class is a layout manager that lays out a container's components in a rectangular grid", "label": {"api": {"GridLayout": [[4, 13]]}}}, {"text": "I added 3 JPanels to a Container with GridLayout, and gave each JPanel a different background color", "label": {"api": {"GridLayout": [[38, 47]]}}}, {"text": "All I do is set the Container's layout to GridLayout with 1 row and any number of columns, and then add 3 JPanels to that", "label": {"api": {"GridLayout": [[42, 51]]}}}, {"text": "check out the Files class", "label": {"api": {"Files": [[14, 18]]}}}, {"text": "You should implement the actionperformed() method inside your atmGUI class to handle the clicked action", "label": {"api": {"actionperformed()": [[25, 41]]}}}, {"text": "A thread-safe version would be the AtomicReference", "label": {"api": {"AtomicReference": [[35, 49]]}}}, {"text": "Here is how you can lock your database using a ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[47, 68]]}}}, {"text": "Since you cannot get a TypedQuery from a Hibernate Session, you might consider using the EntityManager interface", "label": {"api": {"EntityManager interface": [[89, 111]]}}}, {"text": "Runtime.exec() gives you a Process", "label": {"api": {"Process": [[27, 33]]}}}, {"text": "you can read and write to that Process (using getOutputStream() and getInputStream(), which allows you to get what's output by your script and send it more information afterwards", "label": {"api": {"Process": [[31, 37]]}}}, {"text": "ServletContext.java has two APIs that you can use to manipulate resources", "label": {"api": {"ServletContext.java": [[0, 18]]}}}, {"text": "Serializable defines the following exceptions", "label": {"api": {"Serializable": [[0, 11]]}}}, {"text": "I think you're looking for Serializable, ObjectOutputStream, and ObjectInputStream", "label": {"api": {"Serializable": [[27, 38]], "ObjectOutputStream": [[41, 58]], "ObjectInputStream": [[65, 81]]}}}, {"text": "Does LargeInteger have an equivalent to BigInteger's testBit", "label": {"api": {"BigInteger's testBit": [[40, 59]]}}}, {"text": "To improve the performance, you should submit the tasks to an ExecutorService with a number of threads = number of processors (above that number, your threads will compete for CPU resources and it will be counterproductive)", "label": {"api": {"an ExecutorService": [[59, 76]]}}}, {"text": "Each call to br.readLine() will return the next line", "label": {"api": {"br.readLine()": [[13, 25]]}}}, {"text": "Or you can use equalsIgnoreCase()", "label": {"api": {"equalsIgnoreCase()": [[15, 32]]}}}, {"text": "another application modifies the corresponding row), you can use a @Version field", "label": {"api": {"@Version": [[67, 74]]}}}, {"text": "LargeInteger doesn't seem to have a pow function, or if it does, it cannot process pow(0) though BigInteger can", "label": {"api": {"BigInteger can": [[97, 110]]}}}, {"text": "You need to call scanner.nextLine() to get input (a String) from the user, and you need to convert the String to an integer (with Integer.parseInt) to compare it with other ints", "label": {"api": {"scanner.nextLine()": [[17, 34]], "Integer.parseInt": [[130, 145]]}}}, {"text": "You might want to read the documentation of the Scanner class", "label": {"api": {"the documentation of the Scanner class": [[23, 60]]}}}, {"text": "You could use a BigInteger to store very large numbers", "label": {"api": {"BigInteger": [[16, 25]]}}}, {"text": "A common example is Arrays.asList", "label": {"api": {"Arrays.asList": [[20, 32]]}}}, {"text": "For example, the snippet given in the Arrays.asList documentation omits the type", "label": {"api": {"Arrays.asList": [[38, 50]]}}}, {"text": "As stated in the API, ArrayList.toArray() returns an array of type Object", "label": {"api": {"API": [[17, 19]]}}}, {"text": "You can access the object returned by the original method using InvocationContext.proceed()", "label": {"api": {"InvocationContext.proceed()": [[64, 90]]}}}, {"text": "You should also be careful with ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[32, 61]]}}}, {"text": "A Number is a parent of both Double and Integer, so you would be able to add Doubles to your list and the Number.intValue() will convert (autoboxing) into Integer when required", "label": {"api": {"Number": [[2, 7], [106, 111]]}}}, {"text": "will TreeMap help you in this regard", "label": {"api": {"TreeMap": [[5, 11]]}}}, {"text": "TreeMap Keeps everything sorted", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "A Timer starts out repeating, by default", "label": {"api": {"starts out repeating": [[8, 27]]}}}, {"text": "You ought to call setRepeats(false)", "label": {"api": {"setRepeats(false)": [[18, 34]]}}}, {"text": "It's to use a DocumentFilter", "label": {"api": {"DocumentFilter": [[14, 27]]}}}, {"text": "Take a look in how to do it in Text Component Features implementing a DocumentFilter", "label": {"api": {"DocumentFilter": [[70, 83]]}}}, {"text": "Here you have an example using DocumentFilter", "label": {"api": {"DocumentFilter": [[31, 44]]}}}, {"text": "You can implement  DocumentListener and act as an observer of the document to listen for example when the text is inserted/removed", "label": {"api": {"DocumentListener": [[19, 34]]}}}, {"text": "Take a look in how to do it in How to Write a DocumentListener", "label": {"api": {"DocumentListener": [[46, 61]]}}}, {"text": "The JDK contains the JavaCompiler API", "label": {"api": {"JavaCompiler": [[21, 32]]}}}, {"text": "Timeline has a constructor for setting a target frame rate, and an empty one for (presumably) using some default value", "label": {"api": {"constructor for setting a target frame rate": [[15, 57]]}}}, {"text": "I just noticed the following phenomena when cancelling a Future returned by ForkJoinPool", "label": {"api": {"ForkJoinPool": [[76, 87]]}}}, {"text": "The docs of ForkJoinTask#cancel(boolean) say", "label": {"api": {"ForkJoinTask#cancel(boolean)": [[12, 39]]}}}, {"text": "If ForkJoinTasks ignore interrupts, how else are you supposed to check for cancellation inside Callables submitted to a ForkJoinPool", "label": {"api": {"ForkJoinPool": [[120, 131]]}}}, {"text": "I can launch it using Desktop.open() but I cannot pass any parameters this way", "label": {"api": {"Desktop.open()": [[22, 35]]}}}, {"text": "Have a look for example at TreeMap#floorEntry() which does something similar to your getObjectsAtTime method", "label": {"api": {"TreeMap#floorEntry()": [[27, 46]]}}}, {"text": "I agree with @Josh M, you should try using a JTextArea(http://docs.oracle.com/javase/7/docs/api/javax/swing/JTextArea.html) with a JScrollPane", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/JTextArea.html": [[55, 121]]}}}, {"text": "You can use StringTokenizer to perform this", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "You can reduce the complexity of the loop further if you use an Ordered Set like LinkedHashSet", "label": {"api": {"LinkedHashSet": [[81, 93]]}}}, {"text": "I can't find anything in the API docs that would state, that you shouldn't call executeQuery() on a given PreparedStatement instance more than once", "label": {"api": {"API docs": [[29, 36]]}}}, {"text": "A ResultSet is automatically closed, when you reexecute a PreparedStatement", "label": {"api": {"automatically closed": [[15, 34]]}}}, {"text": "This is using the List.get(int) method to access the item at a particular index in the list", "label": {"api": {"List.get(int)": [[18, 30]]}}}, {"text": "The BufferedInputStream takes an InputStream in the constructor, so you can do it with", "label": {"api": {"BufferedInputStream": [[4, 22]]}}}, {"text": "A BufferedInputStream adds functionality to another input stream-namely, the ability to buffer the input and to support the mark and reset methods", "label": {"api": {"BufferedInputStream": [[2, 20]]}}}, {"text": "When the BufferedInputStream is created, an internal buffer array is created", "label": {"api": {"BufferedInputStream": [[9, 27]]}}}, {"text": "Rather than using remove then add, use List.set(index, element)", "label": {"api": {"List.set(index, element)": [[39, 62]]}}}, {"text": "The easiest way to get an AttributedCharacterIterator is to create an AttributedString", "label": {"api": {"AttributedString": [[70, 85]]}}}, {"text": "You may also want to have a look at the SwingWorker class", "label": {"api": {"SwingWorker": [[40, 50]]}}}, {"text": "Use the rowHeader view", "label": {"api": {"rowHeader": [[8, 16]]}}}, {"text": "the Java String escaping, and the regular expression escaping", "label": {"api": {"regular expression escaping": [[34, 60]]}}}, {"text": "Here you can see the source code of the next() method from java Iterator", "label": {"api": {"next()": [[40, 45]], "Iterator": [[64, 71]]}}}, {"text": "As you can see, if you are out of the array a NoSuchElementException will be thrown", "label": {"api": {"NoSuchElementException": [[46, 67]]}}}, {"text": "So calling next() twice without checking before each call if elements are still available by using hasNext() will have the behaviour you described", "label": {"api": {"next()": [[11, 16]]}}}, {"text": "The Java String API doesn't offer a method to do that specifically", "label": {"api": {"Java String API": [[4, 18]]}}}, {"text": "Probably you want to implement Comparable interface", "label": {"api": {"Comparable": [[31, 40]]}}}, {"text": "If you really want to implement Comparator then you need to define compare(T, T) method", "label": {"api": {"Comparator": [[32, 41]]}}}, {"text": "Probably you want to use String#concat", "label": {"api": {"String#concat": [[25, 37]]}}}, {"text": "You can use String.valueOf()", "label": {"api": {"String.valueOf()": [[12, 27]]}}}, {"text": "Lastly, printf() is also an option", "label": {"api": {"printf()": [[8, 15]]}}}, {"text": "Then you can call isInstance", "label": {"api": {"isInstance": [[18, 27]]}}}, {"text": "In Java, the Collection.sort must be stable, so if you have use a comparator that says that all negative numbers are equal, but for positive numbers does what you'd expect, you'd have what you need", "label": {"api": {"Collection.sort": [[13, 27]]}}}, {"text": "You could try putting the data in a PriorityQueue, making sure to only deal with the positive values", "label": {"api": {"PriorityQueue": [[36, 48]]}}}, {"text": "You might want to consider using a Map", "label": {"api": {"Map": [[35, 37]]}}}, {"text": "A Map allows you to associate one piece of data with another, so if you can do something similar to", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "According to the docs for generateCertificate(), it expects that a \"certificate provided in inStream must be DER-encoded and may be supplied in binary or printable (Base64) encoding\"", "label": {"api": {"generateCertificate()": [[26, 46]]}}}, {"text": "They may instead be lazily computed, allowing infinite size", "label": {"api": {"lazily computed": [[20, 34]]}}}, {"text": "Collections might also be lazily computed", "label": {"api": {"lazily computed": [[26, 40]]}}}, {"text": "Thus the logical organization of the data (list, map, stream) is mostly orthogonal to the physical layout (stored in an array or tree, or lazily computed from a function)", "label": {"api": {"lazily computed": [[138, 152]]}}}, {"text": "A good example from the Java APIs is the LinkedList class", "label": {"api": {"LinkedList": [[41, 50]]}}}, {"text": "And especially since you are using a HashSet, you should override hashCode() too, so that it \"agrees\" with equals(), as per the javadoc of equals()", "label": {"api": {"javadoc of equals()": [[128, 146]]}}}, {"text": "Take a look at LinkedHashSet class", "label": {"api": {"LinkedHashSet": [[15, 27]]}}}, {"text": "Try using a ConcurrentLinkedQueue instead", "label": {"api": {"ConcurrentLinkedQueue": [[12, 32]]}}}, {"text": "In every piece of code you suspect, you may want to use SwingUtilities.isEventDispatchThread() to test if you are currently in EDT", "label": {"api": {"SwingUtilities.isEventDispatchThread()": [[56, 93]]}}}, {"text": "Instead of maintaining capLetters and comparing the first character with each of the characters in it, you can directly use Character.isUpperCase(char) method", "label": {"api": {"Character.isUpperCase(char)": [[124, 150]]}}}, {"text": "Please have a look at Component.getX() and Component.getY() for getting X and Y Co-ordinates", "label": {"api": {"Component.getX()": [[22, 37]], "Component.getY()": [[43, 58]]}}}, {"text": "Component.getWidth() and Component.getHeight(), for getting Width and Height of the said component", "label": {"api": {"Component.getWidth()": [[0, 19]], "Component.getHeight()": [[25, 45]]}}}, {"text": "A simple way of construct a regex when you have a long fixed string you want to find is to use Pattern.quote(String s)", "label": {"api": {"Pattern.quote(String s)": [[95, 117]]}}}, {"text": "The NodeList object has an item(int) method", "label": {"api": {"NodeList": [[4, 11]]}}}, {"text": "You can use that method to loop through the nodes in the NodeList", "label": {"api": {"NodeList": [[57, 64]]}}}, {"text": "The Math class fits your needs", "label": {"api": {"Math": [[4, 7]]}}}, {"text": "The setShape(Shape shape) lets you use any shape from the geom package", "label": {"api": {"setShape(Shape shape)": [[4, 24]]}}}, {"text": "Then if they do, iterate on each of them, and compare each pair of arrays using Arrays.equals()", "label": {"api": {"Arrays.equals()": [[80, 94]]}}}, {"text": "See the documentation for the allowed types of the Basic annotation", "label": {"api": {"allowed types of the Basic annotation": [[30, 66]]}}}, {"text": "JMenu inherits from AbstractButton, which has a setIcon() method allowing to set the icon of the menu", "label": {"api": {"JMenu": [[0, 4]], "setIcon() method": [[48, 63]]}}}, {"text": "BTW, JMenu also inherits from JMenuItem", "label": {"api": {"JMenu": [[5, 9], [30, 34]]}}}, {"text": "So if you managed to set an icon on a JMenuItem, you should be able to do it, the same way, on a JMenu", "label": {"api": {"JMenu": [[38, 42], [97, 101]]}}}, {"text": "Convert the array to a ArrayList using Arrays' asList method", "label": {"api": {"ArrayList": [[23, 31]], "Arrays' asList method": [[39, 59]]}}}, {"text": "remove() the element from tempList if it is null", "label": {"api": {"remove()": [[0, 7]]}}}, {"text": "Covert tempList back to an array using ArrayList's toArray() method", "label": {"api": {"ArrayList": [[39, 47]], "ArrayList's toArray() method": [[39, 66]]}}}, {"text": "In swing, you can create a compound border", "label": {"api": {"compound border": [[27, 41]]}}}, {"text": "Any List will retain insertion order and they all allow duplicated elements", "label": {"api": {"List": [[4, 7]]}}}, {"text": "There are no key-value structures with these properties in standard Java, but Guava's LinkedListMultiMap might have what you are looking for", "label": {"api": {"List": [[92, 95]]}}}, {"text": "An implementation of ListMultimap that supports deterministic iteration order for both keys and values", "label": {"api": {"List": [[21, 24]]}}}, {"text": "The easiest would of course to just use a Queue, Java's got some implementations for you (arrayblocking, concurrentlinked)", "label": {"api": {"arrayblocking": [[90, 102]], "concurrentlinked": [[105, 120]]}}}, {"text": "From the JavaDocs", "label": {"api": {"From the JavaDocs": [[0, 16]]}}}, {"text": "use a DateFormat or SimpleDateFormat to format dates as text", "label": {"api": {"DateFormat": [[6, 15], [26, 35]], "SimpleDateFormat": [[20, 35]]}}}, {"text": "That way, you simply don't have to worry about this and let the DateFormat take care of it", "label": {"api": {"DateFormat": [[64, 73]]}}}, {"text": "Have a look at the String API for the functionality you are trying to implement, the replace() method should suffice for you", "label": {"api": {"String API": [[19, 28]]}}}, {"text": "It's not very clear, but if you need to add/remove/replace elements in the list, you should use ListIterator", "label": {"api": {"ListIterator": [[96, 107]]}}}, {"text": "It has a set method, which allows to replace elements", "label": {"api": {"set": [[9, 11]]}}}]