[{"text": "It contains the sequence field of type JAXBElement", "label": {"api": {"JAXBElement": [[39, 49]]}}}, {"text": "JAXBElement is a third-party class (standard API, actually), which is in essence a pure value class, but it for some reason does not implement hashCode and equals methods", "label": {"api": {"JAXBElement": [[0, 10]]}}}, {"text": "But JAXBElement stands in the way", "label": {"api": {"JAXBElement": [[4, 14]]}}}, {"text": "Since I can't extend JAXBElement, my idea was to integrate hashCode and equals into the aggregating class (SingleElementRefType here)", "label": {"api": {"JAXBElement": [[21, 31]]}}}, {"text": "If so, you may want to use an ArrayList", "label": {"api": {"ArrayList": [[30, 38]]}}}, {"text": "For Java 7, you can call entrySet() to get a Set<Map.Entry<String,ArrayList<Integer>>> - which you can then use to populate something like an ArrayList<Map.Entry<String,ArrayList<Integer>>> which you can sort with a custom comparator", "label": {"api": {"entrySet()": [[25, 34]]}}}, {"text": "Create an implementation of Comparator that compares two players by comparing the scores present in the map", "label": {"api": {"Comparator": [[28, 37]]}}}, {"text": "(Integer.compare() might be helpful for this.) Then, create a new list of all the players you want to sort", "label": {"api": {"Integer.compare()": [[1, 17]]}}}, {"text": "Finally, use Collections.sort() to sort this list", "label": {"api": {"Collections.sort()": [[13, 30]]}}}, {"text": "Alternatively, use a mutable integer type, like AtomicInteger (or write your own)", "label": {"api": {"AtomicInteger": [[48, 60]]}}}, {"text": "Or you could use Scanner.hasNextInt() to detect whether valid int was entered instead of using try-catch", "label": {"api": {"Scanner.hasNextInt()": [[17, 36]]}}}, {"text": "Every Java class is a subclass of Object class", "label": {"api": {"Object": [[34, 39]]}}}, {"text": "Thus, by inheritance, all the operations available in Object class are available in every Java class", "label": {"api": {"Object": [[54, 59]]}}}, {"text": "You can use Robot.createScreenCapture() to take a screenshot", "label": {"api": {"Robot.createScreenCapture()": [[12, 38]]}}}, {"text": "First, your understanding is correct; no amount of Thread.sleep() (and by the way, since Java 5 you should really be using TimeUnit instead, as in TimeUnit.SECONDS.sleep(2L)) will guarantee in-order execution; you cannot guarantee when the OS will schedule this or that thread", "label": {"api": {"TimeUnit": [[123, 130], [147, 154]]}}}, {"text": "Another example is a Semaphore", "label": {"api": {"Semaphore": [[21, 29]]}}}, {"text": "The closest you can get is to use reflection; if your method takes an instance of type Field, it can both examine the declared type of the field, and set the field to a value of its choosing", "label": {"api": {"type Field": [[82, 91]]}}}, {"text": "According to the documentation of SafeVarargs, the @SafeVarargs annotation can be applied only to constructors or variable arity methods that are either static or final", "label": {"api": {"documentation of SafeVarargs": [[17, 44]]}}}, {"text": "The best way to do this is by implementing the Comparator interface", "label": {"api": {"Comparator": [[47, 56]]}}}, {"text": "When you decide how you plan to compare the strings, you can use the utility methods in Arrays class", "label": {"api": {"Arrays": [[88, 93]]}}}, {"text": "It's much easier to create a data type, say Player which holds the name and score and then implement the Comparable interface and sort based on that (or just use your custom sort to sort on the score values of the Player object)", "label": {"api": {"Comparable": [[105, 114]]}}}, {"text": "And this is a possible scenario, because as noted here https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html \"The exact details as to when and whether the rehash method is invoked are implementation-dependent\"", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html": [[55, 120]]}}}, {"text": "According to the documentation on polygon you create a polygon with Polygon(double..", "label": {"api": {"the documentation on polygon": [[13, 40]]}}}, {"text": "javax.ws.rs.core.UriBuilder or org.apache.http.client.utils.URIBuilder or something similar", "label": {"api": {"javax.ws.rs.core.UriBuilder": [[0, 26]]}}}, {"text": "java.net.URL provides a constructor wherein you can append a String to a URL", "label": {"api": {"constructor": [[24, 34]]}}}, {"text": "You can store the connection details using java.util.prefs.Preferences, as suggested here, or a javax.jnlp.PersistenceService, as suggested here", "label": {"api": {"java.util.prefs.Preferences": [[43, 69]], "javax.jnlp.PersistenceService": [[96, 124]]}}}, {"text": "The javadoc of the TreeMap.entrySet method states", "label": {"api": {"javadoc of the TreeMap.entrySet method": [[4, 41]]}}}, {"text": "NIO ByteBuffers have a limit and a capacity", "label": {"api": {"NIO ByteBuffers": [[0, 14]]}}}, {"text": "You can try with DecimalFormat", "label": {"api": {"DecimalFormat": [[17, 29]]}}}, {"text": "The method getRequestedSessionId (and isRequestedSessionIdValid) is declared on the HttpServletRequest interface", "label": {"api": {"HttpServletRequest interface": [[84, 111]], "ServletRequest": [[88, 101]]}}}, {"text": "You're trying to invoke the method on a reference of type ServletRequest", "label": {"api": {"ServletRequest": [[58, 71]]}}}, {"text": "If you know the referenced object will really be a HttpServletRequest, cast it in order to invoke the method", "label": {"api": {"ServletRequest": [[55, 68]]}}}, {"text": "( http://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameterMap() )", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameterMap()": [[2, 88]]}}}, {"text": "If you use a J2EE 7 compliant application server, then this should be relatively easy using the Java EE concurrency API, otherwise you should be able to use the \"traditional\" java.util.concurrent APIs, even though the J2EE spec doesn't encourage it", "label": {"api": {"Java EE concurrency API": [[96, 118]]}}}, {"text": "Or as a cleaner alternative, get an array of all characters with String.toCharArray()", "label": {"api": {"String.toCharArray()": [[65, 84]]}}}, {"text": "The clone method on Object, which creates an exact copy of an object, is declared as", "label": {"api": {"clone": [[4, 8]]}}}, {"text": "You should use BigInteger or BigDecimal for this purpose", "label": {"api": {"BigInteger": [[15, 24]], "BigDecimal": [[29, 38]]}}}, {"text": "Don't use Statement it can lead to SQLInjection, instead use PreparedStatement as follows", "label": {"api": {"Statement": [[10, 18], [69, 77]], "PreparedStatement": [[61, 77]]}}}, {"text": "Have a look at the declaration of the @Resource annotation", "label": {"api": {"@Resource": [[38, 46]]}}}, {"text": "It includes a shareable attribute that allows you to specify connection sharing behaviour", "label": {"api": {"shareable": [[14, 22]]}}}, {"text": "On Java 9 or later, Map.entry can be used, so long as you know that neither the key nor value will be null", "label": {"api": {"Map.entry": [[20, 28]]}}}, {"text": "If either value could legitimately be null, AbstractMap.SimpleEntry (as suggested in another answer) or AbstractMap.SimpleImmutableEntry would be the way to go", "label": {"api": {"AbstractMap.SimpleEntry": [[44, 66]], "AbstractMap.SimpleImmutableEntry": [[104, 135]]}}}, {"text": "You can use getHSBColor() instead and hard-code the saturation and brightness to keep them all the same, just randomizing the color", "label": {"api": {"getHSBColor()": [[12, 24]]}}}, {"text": "What you are looking for is java.lang.Class.isInstance", "label": {"api": {"java.lang.Class.isInstance": [[28, 53]]}}}, {"text": "An easy way to achieve what you want is to use a BufferedReader to read lines from a file", "label": {"api": {"BufferedReader": [[49, 62]]}}}, {"text": "You could also make a new random number generator, and call nextInt(52) on it", "label": {"api": {"nextInt(52)": [[60, 70]]}}}, {"text": "If you want to use one connection per message, effectively signalling the end of the message via close(), you should use setSoLinger() on that side which is closing the connection", "label": {"api": {"setSoLinger()": [[121, 133]]}}}, {"text": "If you just want your object lifetime to be managed to references to it other than as a listener then you could change your collection of listeners to be a 'Weak' collection like WeakHashMap", "label": {"api": {"WeakHashMap": [[179, 189]]}}}, {"text": "Such a collection uses Weak References to avoid keeping objects alive after all other references have been cleared", "label": {"api": {"Weak References": [[23, 37]]}}}, {"text": "A Vector  may contain objects of different types", "label": {"api": {"Vector ": [[2, 8]]}}}, {"text": "Does calling the toArray() method return an Object[] array or an array of specific objects (Eg", "label": {"api": {"toArray()": [[17, 25]]}}}, {"text": "I would then consider embedding the JavaFX aspects in Swing using a JFXPanel, and basically make it a Swing/AWT application with some JavaFX embedded", "label": {"api": {"JFXPanel": [[68, 75]]}}}, {"text": "Have you implemented Comparable interface in SortingUser class", "label": {"api": {"Comparable": [[21, 30]]}}}, {"text": "Collections.sort() will not sort the objects, if you haven't implemented Comparable in your class", "label": {"api": {"Comparable": [[73, 82]]}}}, {"text": "ListIterator<T> interface provides a set(T) method, but it locks you into using a List<T>, for which you already have a solution", "label": {"api": {"ListIterator<T> interface": [[0, 24]]}}}, {"text": "I think you can use Integer.parseInt(String)", "label": {"api": {"Integer.parseInt(String)": [[20, 43]]}}}, {"text": "You may be looking for replaceRange(), which \"Simply does a delete if the new string is null or empty.\" Then you can insert() the new text at position 0", "label": {"api": {"replaceRange()": [[23, 36]], "insert()": [[117, 124]]}}}, {"text": "Both replaceRange() and setText() correctly clear the text area when supplied with a null or empty String", "label": {"api": {"replaceRange()": [[5, 18]]}}}, {"text": "HH is the date format for 24-hour dates, and you haven't passed an am/pm marker placeholder in the date format string", "label": {"api": {"HH is the date format for 24-hour dates,": [[0, 39]]}}}, {"text": "Java String Class does have a contains method", "label": {"api": {"contains": [[30, 37]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html ) to assure that your float array sizes are BASED on your phone's cpu architecture(native order) and not on jvm fixed primitive sizes", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html": [[0, 61]]}}}, {"text": "Maybe here it becomes more obvious that you are returning the same stream instance each time you call get on your supplier (and hence the exception thrown on the second call because findFirst is a short-circuiting terminal operation)", "label": {"api": {"short-circuiting terminal operation": [[197, 231]]}}}, {"text": "Also, in Java you should use DatatypeConverter.parseHexBinary(), or similar, to convert hex into bytes", "label": {"api": {"DatatypeConverter.parseHexBinary()": [[29, 62]]}}}, {"text": "The ArrayList has a constructor to do this", "label": {"api": {"constructor": [[20, 30]]}}}, {"text": "Have a look at the ThreadLocalRandom class from Java", "label": {"api": {"ThreadLocalRandom": [[19, 35]]}}}, {"text": "This is what the Desktop class and the Runtime class are meant for", "label": {"api": {"Runtime class": [[39, 51]]}}}, {"text": "Runtime class is more to open an application and passing parameters to this application", "label": {"api": {"Runtime class": [[0, 12]]}}}, {"text": "You can use a @NamedNativeQuery to uniquely identify an SQLQuery", "label": {"api": {"@NamedNativeQuery": [[14, 30]]}}}, {"text": "There is a good chance that your Spring Data generated JPQL query is not working because your column definition is missing the @Temporal annotation", "label": {"api": {"@Temporal": [[127, 135]]}}}, {"text": "Alternatively, the column has been specified as a java.sql.Date", "label": {"api": {"java.sql.Date": [[50, 62]]}}}, {"text": "Should I implements Runnable and use Thread#sleep() in parallel with math based on System#nanoTime() or should I extends Thread and use an ScheduledExecutorService", "label": {"api": {"Runnable": [[20, 27]], "Thread#sleep()": [[37, 50]], "System#nanoTime()": [[83, 99]], "Thread": [[37, 42], [121, 126]], "ScheduledExecutorService": [[139, 162]]}}}, {"text": "This would mean that just using Thread#sleep() by itself would not be a proper solution, I know I can get pretty close to this effect by calculating the amount of milliseconds to sleep() using a start/end/elapsed variable and using nanoTime() for reference, but is this the \"Correct\" way to do it", "label": {"api": {"Thread#sleep()": [[32, 45]], "Thread": [[32, 37]]}}}, {"text": "new ArrayList(49) will only set the initial capacity of your ArrayList before it has to resize", "label": {"api": {"set the initial capacity": [[28, 51]]}}}, {"text": "The explanation is given by the class documentation for java.util.Scanner", "label": {"api": {"class documentation for java.util.Scanner": [[32, 72]]}}}, {"text": "The most recent IOException thrown by the underlying readable can be retrieved via the ioException() method", "label": {"api": {"ioException() method": [[87, 106]]}}}, {"text": "The ioException() method makes that exception available if you want/need it", "label": {"api": {"ioException() method": [[4, 23]]}}}, {"text": "The getClass() is a method defined in java.lang.Object, and methods can only be called on instances", "label": {"api": {"getClass()": [[4, 13]]}}}, {"text": "And finally qutoing from the javadoc of Class.forName()", "label": {"api": {"Class.forName()": [[40, 54]]}}}, {"text": "So Class.forName() only works for classes and interfaces and not for primitive types", "label": {"api": {"Class.forName()": [[3, 17]]}}}, {"text": "Using javax.ws.rs.core.UriBuilder from JAX-RS 2.0", "label": {"api": {"javax.ws.rs.core.UriBuilder": [[6, 32]]}}}, {"text": "See also Integer.numberOfLeadingZeros(int), which would reduce the code to a one-liner", "label": {"api": {"Integer.numberOfLeadingZeros(int)": [[9, 41]]}}}, {"text": "Check SimpleDateFormat JavaDoc for details", "label": {"api": {"SimpleDateFormat JavaDoc": [[6, 29]]}}}, {"text": "Thread.join can fit this", "label": {"api": {"Thread.join": [[0, 10]]}}}, {"text": "Javadoc of getDeclaredMethod (emphasis mine)", "label": {"api": {"Javadoc of getDeclaredMethod": [[0, 27]]}}}, {"text": "Javadoc of invoke", "label": {"api": {"Javadoc of invoke": [[0, 16]]}}}, {"text": "Javadoc of setAccessible (emphasis mine)", "label": {"api": {"Javadoc of setAccessible": [[0, 23]]}}}, {"text": "If you want to implement code for cleaning up a resource, when client code has forgotten to call close or dispose or whatever you provide for explicit resource management (which you should if there are associated native resources) can be done using a PhantomReference to the instance and a ReferenceQueue", "label": {"api": {"PhantomReference": [[251, 266]]}}}, {"text": "The advantage is that you have control over when to poll the queue and perform the cleanup and you may even opt-out the post-mortem cleanup by letting the PhantomReference go out of scope (it will be ordinarily collected and not enqueued) in the case that the client code did not forget to call close (it’s strongly recommended to implemented AutoClosable to allow using “try with resources”)", "label": {"api": {"PhantomReference": [[155, 170]], "AutoClosable": [[343, 354]]}}}, {"text": "There is a class called EntityManagerFactoryUtils from where you can obtain the current transaction's entity manager based on the EntityManagerFactory you configured in your JpaTransactionManager", "label": {"api": {"EntityManagerFactory": [[24, 43], [130, 149]]}}}, {"text": "If you use the overload of split that takes an int parameter and pass a negative value, trailing blank items would not be removed from the resultant array", "label": {"api": {"overload of split that takes an int parameter": [[15, 59]]}}}, {"text": "For a full reference of the modifiers that are allowed in the date pattern, have a look at this web site", "label": {"api": {"this web site": [[91, 103]]}}}, {"text": "If you want to get the JFrame, call getTopLevelAncestor", "label": {"api": {"getTopLevelAncestor": [[36, 54]]}}}, {"text": "If you wish to implement Future<V> you must implement the complete contract - including", "label": {"api": {"Future": [[25, 30]]}}}, {"text": "You can use Pattern#CASE_INSENSITIVE and implement your own method", "label": {"api": {"Pattern#CASE_INSENSITIVE": [[12, 35]]}}}, {"text": "The replaceFirst() method will let you do this if you use it in a loop", "label": {"api": {"replaceFirst()": [[4, 17]]}}}, {"text": "If you loop over the this statement, each invocation of replaceFirst() will replace the first group of digits with whatever you provide as a second argument", "label": {"api": {"replaceFirst()": [[56, 69]]}}}, {"text": "TreeMap has a constructor that takes a Comparator as an argument", "label": {"api": {"TreeMap has a constructor": [[0, 24]]}}}, {"text": "You could use a List", "label": {"api": {"List": [[16, 19]]}}}, {"text": "Use this Swing Timer instead", "label": {"api": {"Timer": [[15, 19]]}}}, {"text": "@XmlNS you already mentioned", "label": {"api": {"@XmlNS": [[0, 5]]}}}, {"text": "For example, Console and JPasswordField return character arrays from password input, and PBEKey and KeyStore require a char[] for password-based encryption", "label": {"api": {"Console": [[13, 19]], "JPasswordField": [[25, 38]], "PBEKey": [[89, 94]], "KeyStore": [[100, 107]]}}}, {"text": "Use a char[] to store passwords, and write '\\0' to the array as soon as the password is no longer necessary", "label": {"api": {"write '\\0' to the array": [[37, 59]]}}}, {"text": "java.util.List boolean add(E e)", "label": {"api": {"java.util.List boolean add(E e)": [[0, 30]]}}}, {"text": "Use Files.createTempFile() to create a temporary JAR file somewhere", "label": {"api": {"Files.createTempFile()": [[4, 25]]}}}, {"text": "Use Files.copy() to copy from the resource stream to the temporary file", "label": {"api": {"Files.copy()": [[4, 15]]}}}, {"text": "Use File.deleteOnExit() to make sure that the temporary file will get cleaned up when the main (host) application terminates", "label": {"api": {"File.deleteOnExit()": [[4, 22]]}}}, {"text": "params in your case is not a JSONObject, but it is a JSONArray", "label": {"api": {"JSONObject": [[29, 38]], "JSONArray": [[53, 61]]}}}, {"text": "So all you need to do is first fetch the JSONArray and then fetch the first element of that array as the JSONObject", "label": {"api": {"JSONObject": [[105, 114]], "JSONArray": [[41, 49]]}}}, {"text": "You should use the intValue() or method (or any of its other versions, if you want e.g", "label": {"api": {"intValue()": [[19, 28]]}}}, {"text": "JFileChooser will return you the selected File, which will the folder that the user selected, you need to use something like File#listFiles which will return an array of all the Files within the selected folder", "label": {"api": {"File#listFiles": [[125, 138]]}}}, {"text": "Oracle documentation says \"You must specify the parameter's SQL type.\" for setNull", "label": {"api": {"Oracle documentation": [[0, 19]]}}}, {"text": "The formatter has a withZone() method that can be called to provide the missing time-zone", "label": {"api": {"method": [[31, 36]]}}}, {"text": "String#replaceAll accepts a regex, if I understood you correctly, you can use", "label": {"api": {"String#replaceAll": [[0, 16]]}}}, {"text": "There are Charset constants in StandardCharsets, but only for those standard charsets that are available with every JavaSE installation (StandardCharsets.UTF_8 and ISO_8859_1 for instance)", "label": {"api": {"Charset": [[10, 16], [39, 45], [145, 151]]}}}, {"text": "But you can test the availability of a Charset", "label": {"api": {"Charset": [[39, 45]]}}}, {"text": "you might considering using the Calendar class, as most Date methods seem to be deprecated", "label": {"api": {"Calendar": [[32, 39]]}}}, {"text": "Ordering implements the java.util.Comparator interface so you can use it like", "label": {"api": {"java.util.Comparator": [[24, 43]]}}}, {"text": "Take a look at the docs for Pattern, in the section about escaping characters", "label": {"api": {"Pattern": [[28, 34]]}}}, {"text": "Behind the curtains, split uses Pattern", "label": {"api": {"Pattern": [[32, 38]]}}}, {"text": "The database layer worked just fine; the problem occured when the system attempted to re-insert the same value into the database by using a ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[140, 159]]}}}, {"text": "The ByteArrayInputStream was being populated by performing a getBytes() in the String that contained the foo_name", "label": {"api": {"ByteArrayInputStream": [[4, 23]], "getBytes()": [[61, 70]]}}}, {"text": "A PriorityQueue is always sorted, by the way", "label": {"api": {"PriorityQueue": [[2, 14]]}}}, {"text": "In Java write a document tree traversal routine to search for things", "label": {"api": {"document": [[16, 23]]}}}, {"text": "See if you can do something like inject some JQuery/JavaScript code into the document which makes the document text searchable, possibly communicating with the modified document over the WebView Java/JavaScript bridge (this is probably a fairly fragile solution)", "label": {"api": {"document": [[77, 84], [102, 109], [169, 176]]}}}, {"text": "If you use something like a StringBuilder, you can see all the output", "label": {"api": {"StringBuilder": [[28, 40]]}}}, {"text": "The usage of Connection#createClob method and similars should be used by your dao layer only", "label": {"api": {"Connection#createClob": [[13, 33]]}}}, {"text": "For the JComboBox, you've provided an Array of Strings", "label": {"api": {"JComboBox": [[8, 16]]}}}, {"text": "For the JSpinner, since you've stored it as a SpinnerDateModel, it's up to you whether you want a Date out or a String out", "label": {"api": {"JSpinner": [[8, 15]], "SpinnerDateModel": [[46, 61]]}}}, {"text": "Connection itself is an interface (javadoc) that all of the concrete connection classes implement", "label": {"api": {"connect": [[69, 75]]}}}, {"text": "The Driver classes register themselves with the Driver when they are loaded by the class loader", "label": {"api": {"register themselves": [[19, 37]]}}}, {"text": "When the driver goes through asking \"who responds to this URL\" it invokes the acceptsURL method in each driver and the one that responds gives it a connection back when called with connect", "label": {"api": {"acceptsURL": [[78, 87]], "connect": [[148, 154], [181, 187]]}}}, {"text": "All of the ResultSets and Statements and Connections (and Drivers) work the same way from your point of view, though how they connect to the cursor and database behind the scenes may be different", "label": {"api": {"connect": [[126, 132]]}}}, {"text": "If you're using Java 8, you can use the new Stream API", "label": {"api": {"Stream API": [[44, 53]]}}}, {"text": "You don't assign a Random to an int -- you need to call nextInt, passing a int that gives the range between 0 and that bound minus 1", "label": {"api": {"nextInt": [[56, 62]]}}}, {"text": "Automatic line flushing is disabled with the constructor you used, so you need to call out.flush() to flush the stream to the file", "label": {"api": {"the constructor you used": [[41, 64]]}}}, {"text": "The documentation of the SwingWorker.done() method seems to be a bit wrong", "label": {"api": {"SwingWorker.done()": [[25, 42]]}}}, {"text": "You can use CountDownLatch", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "You can call join method on your thread with this call no other thread can execute until this thread completes its execution refer join method doc, I have written a sample code, in your case Thread1 can be from calculation1 and Thread2 can be in calculation2 method", "label": {"api": {"join method doc": [[131, 145]]}}}, {"text": "Because hello() doesn't return a String, Object or any of the other types accepted by the various println methods defined in PrintStream", "label": {"api": {"PrintStream": [[125, 135]]}}}, {"text": "Now paintIcon has x, y parameters not width/height, which seems to be the error", "label": {"api": {"paintIcon": [[4, 12]]}}}, {"text": "In general I somewhat dislike the paintIcon method, and would store the Image and do", "label": {"api": {"paintIcon": [[34, 42]]}}}, {"text": "However, if you want to do anything with the output or to know that it has completed, you'll have to add more code to check its state (check out the Process.waitFor() API) or to capture its output in Java (e.g", "label": {"api": {"Process.waitFor() API": [[149, 169]]}}}, {"text": "by capturing Standard out in a BufferedReader) - check Process.getInputStream() API", "label": {"api": {"Process.getInputStream() API": [[55, 82]]}}}, {"text": "After querying the table (which you have done), you need to extract the data from the ResultSet", "label": {"api": {"ResultSet": [[86, 94]]}}}, {"text": "You can use Arrays.fill.Take a look at this response", "label": {"api": {"Arrays.fill": [[12, 22]]}}}, {"text": "Executors.newSceduledThreadPool(int) is a factory method that returns a class that implements the ScheduledExecutorService interface", "label": {"api": {"Executors.newSceduledThreadPool(int)": [[0, 35]]}}}, {"text": "nextInt() (or most other nextXYZ methods, for that matter), throw an InputMismatchException if they encounter input that doesn't match their call (e.g., a letter in a nextInt call)", "label": {"api": {"InputMismatchException": [[69, 90]]}}}, {"text": "You can use the Class object's isInstance method instead, for a runtime solution", "label": {"api": {"Class object's isInstance method": [[16, 47]]}}}, {"text": "You can do this with java.lang.System.arraycopy()", "label": {"api": {"java.lang.System.arraycopy()": [[21, 48]]}}}, {"text": "You should read up on the definition of deprecation", "label": {"api": {"the definition of deprecation": [[22, 50]]}}}, {"text": "Instead, loop through the character values and create the String with String#valueOf", "label": {"api": {"String#valueOf": [[70, 83]]}}}, {"text": "Implement Iterable<Map.Entry<K, V>>", "label": {"api": {"Iterable": [[10, 17]]}}}, {"text": "This works because implementing Iterable allows the type to be used in a for-each loop", "label": {"api": {"Iterable": [[32, 39]]}}}, {"text": "Try this using split api of String object as below", "label": {"api": {"split": [[15, 19]]}}}, {"text": "Basically doubles are signed and 0/-1 will be evaluated as -0.0 instead of 0.0 by x1 or x2", "label": {"api": {"doubles": [[10, 16]]}}}, {"text": "When using Collections.sort(List<T> list), the compiler requires that the type T must be comparable (<T extends Comparable<", "label": {"api": {"Comparable": [[112, 121]], "sort": [[23, 26]]}}}, {"text": "Either make the Person class be comparable (by implementing the Comparable interface), or provide a custom comparator using the overloaded sort method", "label": {"api": {"Comparable": [[64, 73]], "sort": [[139, 142]]}}}, {"text": "Use a Semaphore, they are very practical for these kind of things", "label": {"api": {"Semaphore": [[6, 14]]}}}, {"text": "The example below shows how you can limit the number of requests running at the same time using a Semaphore", "label": {"api": {"Semaphore": [[98, 106]]}}}, {"text": "For identifying characters you can use the following (Java Character)", "label": {"api": {"Java Character": [[54, 67]]}}}, {"text": "The queryForObject(String, Class) method takes Class instance as its second parameter", "label": {"api": {"Class": [[27, 31], [47, 51]]}}}, {"text": "One way to solve this is to reuse Character.compare to compare two chars", "label": {"api": {"Character.compare": [[34, 50]]}}}, {"text": "Use a LookupOp, as shown in the examples cited here", "label": {"api": {"LookupOp": [[6, 13]]}}}, {"text": "Use a PauseTransition", "label": {"api": {"PauseTransition": [[6, 20]]}}}, {"text": "You can use Semaphore for these purposes", "label": {"api": {"Semaphore": [[12, 20]]}}}, {"text": "JLabel has a setIcon method which you can use to set the image, pass it an ImageIcon, which can be created from an URL", "label": {"api": {"setIcon": [[13, 19]], "ImageIcon": [[75, 83]], "URL": [[115, 117]]}}}, {"text": "splitis a method in the String class, and inputs is an array of strings", "label": {"api": {"split": [[0, 4]]}}}, {"text": "Also, since you are splitting a string in a loop, you are creating a 2D array of strings, which means sep should be a String[][]", "label": {"api": {"split": [[20, 24]]}}}, {"text": "In more details, a Reader will use a CharsetDecoder; this decoder is configured so that unknown byte sequences are replaced; and the encoding used here likely replaces unknown byte sequences with character 0x00fd, hence your result", "label": {"api": {"CharsetDecoder": [[37, 50]], "replaced": [[115, 122]]}}}, {"text": "The Hash digest need to be done just once (see the doc)", "label": {"api": {"see the doc": [[43, 53]]}}}, {"text": "You may also want to take a look at the translate method of the Graphics object and see if that helps", "label": {"api": {"translate method": [[40, 55]]}}}, {"text": "When you use System.out.println(setScores);, you're calling the toString method of an array", "label": {"api": {"toString": [[64, 71]]}}}, {"text": "By default, toString returns a String formatted as class name @ hex hashcode", "label": {"api": {"toString": [[12, 19]]}}}, {"text": "If you want a more readable representation of the array, use Arrays#toString", "label": {"api": {"toString": [[68, 75]], "Arrays#toString": [[61, 75]]}}}, {"text": "You could also get integers using Scanner#nextInt", "label": {"api": {"Scanner#nextInt": [[34, 48]]}}}, {"text": "I'd use a Random object for this", "label": {"api": {"Random object": [[10, 22]]}}}, {"text": "You can call the refresh method of the entity manager in order to ensure the copy in the persistence context has the latest values from the database", "label": {"api": {"refresh": [[17, 23]]}}}, {"text": "it is a reference to garbage-collected instance of a class java.lang.String on the heap", "label": {"api": {"java.lang.String": [[59, 74]]}}}, {"text": "you are calling the method split on an instance of the class java.lang.String", "label": {"api": {"java.lang.String": [[61, 76]]}}}, {"text": "It returns to you array of java.lang.String objects which it allocates itself (both the array and the strings)", "label": {"api": {"java.lang.String": [[27, 42]]}}}, {"text": "Use Font.canDisplayUpTo(String) to check that the font of the text area can display all the characters in the given String", "label": {"api": {"Font.canDisplayUpTo(String)": [[4, 30]]}}}, {"text": "Based on the docs, this returns false as soon as \"ss\" is read (https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#hasNextInt%28%29)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#hasNextInt%28%29": [[63, 143]]}}}, {"text": "The Scanner API doc describes the functionality of the hasNextInt method as follows", "label": {"api": {"Scanner API doc": [[4, 18]]}}}, {"text": "join() is supposed to wait forever", "label": {"api": {"join()": [[0, 5]]}}}, {"text": "So, instead of PreparedStatement.executeUpdate you call Statement.executeUpdate(String sql) and pass insert statement with question marks", "label": {"api": {"PreparedStatement.executeUpdate": [[15, 45]], "Statement.executeUpdate(String sql)": [[56, 90]]}}}, {"text": "You need an instance of the ForkJoinPool to run your tasks", "label": {"api": {"ForkJoinPool": [[28, 39]]}}}, {"text": "Instead of trying to block until the variable changes, you should use a StringProperty and register listeners with it", "label": {"api": {"StringProperty": [[72, 85]]}}}, {"text": "You could use a LocalTime", "label": {"api": {"LocalTime": [[16, 24]]}}}, {"text": "they are just a help so fetch additional fields from a query (no matter if you use EntityManager.find() with the additional properties map parameter or Query.setHints())", "label": {"api": {"Query.setHints()": [[152, 167]]}}}, {"text": "Java's reflection does not guarantee ordering when using reflection - http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--": [[70, 150]]}}}, {"text": "Basically you should implement an ExceptionMapper", "label": {"api": {"ExceptionMapper": [[34, 48]]}}}, {"text": "You can use File.isDirectory() to test whether the file denoted by this abstract pathname is a directory", "label": {"api": {"File.isDirectory()": [[12, 29]]}}}, {"text": "You can also use File.isFile() to test whether the file denoted by this abstract pathname is a normal file", "label": {"api": {"File.isFile()": [[17, 29]]}}}, {"text": "You're calling Double.parseDouble, which always uses a dot as the decimal separator - it doesn't use the default locale at all", "label": {"api": {"Double.parseDouble": [[15, 32]]}}}, {"text": "Double.parseDouble is documented to behave like Double.valueOf(String), which has documentation including", "label": {"api": {"Double.parseDouble": [[0, 17]], "Double.valueOf(String)": [[48, 69]]}}}, {"text": "This works because you have the same amount of results and names (results.length == names.length), otherwise you would end up with an ArrayIndexOutOfBounds exception", "label": {"api": {"ArrayIndexOutOfBounds": [[134, 154]]}}}, {"text": "Annotate your Row.id property with @XmlID and your Table.rowID attribute with @XmlIDREF", "label": {"api": {"@XmlID": [[35, 40], [78, 83]], "@XmlIDREF": [[78, 86]]}}}, {"text": "From the Javadocs of System.currentTimeMillis()", "label": {"api": {"System.currentTimeMillis()": [[21, 46]]}}}, {"text": "With a List you need to use get and set methods", "label": {"api": {"get": [[28, 30]], "set": [[36, 38]]}}}, {"text": "and where you want to get an object from a position in the list, you use", "label": {"api": {"get": [[22, 24]]}}}, {"text": "You can control the log level through the console in Glassfish if you use java.util.logging as underlying logging framework in your web application", "label": {"api": {"java.util.logging": [[74, 90]]}}}, {"text": "You can also use SLF4J in your code and use java.util.logging as underlying logging framework (through slf4j-jdk14.jar)", "label": {"api": {"java.util.logging": [[44, 60]]}}}, {"text": "Or, by converting the array to a list and using the Collections utility class", "label": {"api": {"Collections": [[52, 62]]}}}, {"text": "I was using Multiset to have easy access to the freq of elements, but I realize there is Collections#frequency(Collection<?>, Object) that does the same for any collection", "label": {"api": {"Collections#frequency(Collection<?>, Object)": [[89, 132]]}}}, {"text": "Then I think the javax.json API and specifically  javax.json.JsonObject and javax.json.JsonArrayis a simplier solution to manage Json objects, and your code will be", "label": {"api": {"javax.json API": [[17, 30]], "javax.json.JsonObject": [[50, 70]], "javax.json.JsonArray": [[76, 95]]}}}, {"text": "To perform the replacement, I'm using Matcher's appendReplacement method", "label": {"api": {"appendReplacement": [[48, 64]]}}}, {"text": "The problem with appendReplacement is that it ignores all the backlashes it encounters in the replacement string", "label": {"api": {"appendReplacement": [[17, 33]]}}}, {"text": "So if I try replacing the substring \"match\" in the string \"one match\" with the replacement string \"a\\\\b\", then appendReplacement results in \"one ab\" instead of \"one a\\\\b\"*", "label": {"api": {"appendReplacement": [[111, 127]]}}}, {"text": "I have taken a look at appendReplacement's code, and found out that it skips any encountered backslash", "label": {"api": {"appendReplacement": [[23, 39]]}}}, {"text": "by using Arrays.equals", "label": {"api": {"Arrays.equals": [[9, 21]]}}}, {"text": "Since Java 12 there is method Files.mismatch which returns -1 if there is no mismatch in the content of the files", "label": {"api": {"Files.mismatch": [[30, 43]]}}}, {"text": "For more on such methods visit link", "label": {"api": {"link": [[31, 34]]}}}, {"text": "Refer to the relevant parts of the javadoc of Files.list", "label": {"api": {"Files.list": [[46, 55]]}}}, {"text": "I am reading the JavaDocs for Connection#prepareCall", "label": {"api": {"JavaDocs for Connection#prepareCall": [[17, 51]]}}}, {"text": "That doesn't work because Set is an interface and you can't instantiate interfaces", "label": {"api": {"Set": [[26, 28]]}}}, {"text": "You have to use one of the classes that implement the Set interface, for example, TreeSet", "label": {"api": {"Set": [[54, 56], [86, 88]]}}}, {"text": "Your piece doesnt implements MouseListener interface and to addMouseListener, you pass parameter of type MouseListener", "label": {"api": {"addMouseListener": [[60, 75]]}}}, {"text": "You can use java.lang.reflect.Constructor#isVarArgs to see if the constructor was defined with varags or not", "label": {"api": {"java.lang.reflect.Constructor#isVarArgs": [[12, 50]]}}}, {"text": "Assuming I've understood your question correctly, you just want to instantiate a BigDecimal from a String, in which case", "label": {"api": {"BigDecimal": [[81, 90]]}}}, {"text": "Use a LinkedList object, which allows removal of the element of the list via removeFist()", "label": {"api": {"removeFist()": [[77, 88]]}}}, {"text": "split() uses a regex to determine what part of the input is the delimiter", "label": {"api": {"split()": [[0, 6]]}}}, {"text": "If you read the Oracle documentation it says", "label": {"api": {"Oracle documentation": [[16, 35]]}}}, {"text": "I'm looking at java.lang.Class#isAssignableFrom from Java Reflection in Action", "label": {"api": {"java.lang.Class#isAssignableFrom": [[15, 46]]}}}, {"text": "The Java Virtual Machine runs until all threads that are not daemon threads have died", "label": {"api": {"The Java Virtual Machine runs until all threads that are not daemon threads have died": [[0, 84]]}}}, {"text": "Pattern.quote(String) creates a pattern which matches the specified string literally", "label": {"api": {"Pattern.quote(String)": [[0, 20]]}}}, {"text": "Matcher.quoteReplacement(String) creates a literal replacement string for the specified string", "label": {"api": {"Matcher.quoteReplacement(String)": [[0, 31]]}}}, {"text": "If you're using Java8, you can do it with the Collectors#groupingBy() collector", "label": {"api": {"Collectors#groupingBy()": [[46, 68]]}}}, {"text": "I'm not sure I got your explanation completely, but LinkedHashMap might be a good candidate for your requirements", "label": {"api": {"LinkedHashMap": [[52, 64]]}}}, {"text": "Some of them you can Look for is  LiveConnect and Robot", "label": {"api": {"Robot": [[50, 54]]}}}, {"text": "You can use System#arraycopy()", "label": {"api": {"System#arraycopy()": [[12, 29]]}}}, {"text": "The most reliable method is to use Files.probeContentType, but that requires an actual file, partly because not all operating systems rely on the extension to determine the file type", "label": {"api": {"Files.probeContentType": [[35, 56]]}}}, {"text": "Use @Convert and @Converter", "label": {"api": {"@Convert": [[4, 11], [17, 24]], "@Converter": [[17, 26]]}}}, {"text": "i just spotted this in DirectByteBuffer.slice()", "label": {"api": {"DirectByteBuffer.slice()": [[23, 46]]}}}, {"text": "I've been just playing with JOptionPane API to show a custom dialog and I've found a strange situation", "label": {"api": {"JOptionPane": [[28, 38]]}}}, {"text": "However, when I close the dialog my application keeps running, even if I set the default close operation to DISPOSE_ON_CLOSE, and it makes me suspect the dialog is not properly disposed", "label": {"api": {"DISPOSE_ON_CLOSE": [[108, 123]]}}}, {"text": "Well, inspecting JOptionPane#createDialog(String title) source code, it turns out the dialog is not closed nor disposed but hidden instead, and it's done on a PropertyChangeEvent when the option pane's value is set (to CANCEL_OPTION or NO_OPTION or CLOSED_OPTION I guess)", "label": {"api": {"JOptionPane#createDialog(String title)": [[17, 54]]}}}, {"text": "Despite the comment that states \"Otherwise, close the dialog\", no WindowEvent closing the dialog is even fired", "label": {"api": {"WindowEvent": [[66, 76]]}}}, {"text": "Please note on a WINDOW_CLOSING event the WindowListener attached to the dialog within initDialog(...) method will just set the option pane's value to null but still won't dispose the dialog", "label": {"api": {"WINDOW_CLOSING": [[17, 30]], "WindowListener": [[42, 55]]}}}, {"text": "That's why we still need to set the default close operation to DISPOSE_ON_CLOSE", "label": {"api": {"DISPOSE_ON_CLOSE": [[63, 78]]}}}, {"text": "If you're interested in real ways to restrict a HashMap's keys, you should use Guava's ForwardingMap and extend its .put*() and .putAll() methods, throwing an IllegalArgumentException \"if some property of the specified key or value prevents it from being stored in this map\"", "label": {"api": {"IllegalArgumentException": [[159, 182]], "if some property of the specified key or value prevents it from being stored in this map": [[185, 272]]}}}, {"text": "If I/O is truly the bottleneck and you don't need file rotation and file locking then create a Handler that queues the fully formatted output string/bytebuffer from your LogRecord + \"trace message\"", "label": {"api": {"Handler": [[95, 101]], "LogRecord": [[170, 178]]}}}, {"text": "Otherwise, if you need to use the FileHandler and want to pass a LogRecord + your trace to the publish method you can just subclass the FileHandler and then create a mapping between your LogRecord and trace that is visible to your custom formatter", "label": {"api": {"Handler": [[38, 44], [140, 146]], "FileHandler": [[34, 44], [136, 146]], "LogRecord": [[65, 73], [187, 195]]}}}, {"text": "Create a LogRecord subclass to hold the trace and convert each LogRecord to your new subclass and super.publish the LogRecord subclass", "label": {"api": {"LogRecord": [[9, 17], [63, 71], [116, 124]]}}}, {"text": "Then cast each LogRecord in your formatter to access the trace", "label": {"api": {"LogRecord": [[15, 23]]}}}, {"text": "Logger.log creates LogRecords and invokes handler.publish for the attached handlers and parent handlers by default", "label": {"api": {"LogRecord": [[19, 27]]}}}, {"text": "What you have to do is remove all handlers that perform I/O on publish and replace them with handlers that just queue LogRecords on publish", "label": {"api": {"LogRecord": [[118, 126]]}}}, {"text": "Here is an example of how to create an AsyncFileHandler", "label": {"api": {"Handler": [[48, 54]], "FileHandler": [[44, 54]]}}}, {"text": "There is advice in the LogRecord documentation which even the original authors fail to follow in the MemoryHandler", "label": {"api": {"Handler": [[107, 113]], "LogRecord": [[23, 31]], "MemoryHandler": [[101, 113]]}}}, {"text": "Therefore, if a logging Handler wants to pass off a LogRecord to another thread, or to transmit it over RMI, and if it wishes to subsequently obtain method name or class name information it should call one of getSourceClassName or getSourceMethodName to force the values to be filled in", "label": {"api": {"Handler": [[24, 30]], "LogRecord": [[52, 60]]}}}, {"text": "So if you are going to buffer LogRecords in a queue you have to call getSourceClassName or getSourceMethodName before you add the records to the queue", "label": {"api": {"LogRecord": [[30, 38]]}}}, {"text": "use javax.script.ScriptEngine to convert to a CompiledScript", "label": {"api": {"CompiledScript": [[46, 59]]}}}, {"text": "Then, we execute the CompiledScript via CompiledScript#eval(Bindings), where the Bindings argument gets mutated", "label": {"api": {"CompiledScript": [[21, 34], [40, 53]]}}}, {"text": "To output a file, you can use StringBuilder to hold the file contents", "label": {"api": {"StringBuilder": [[30, 42]]}}}, {"text": "My understanding from the documentation is that the reuse flag will ensure that the port can be bound to, even though the port may be in a TIME_WAIT state", "label": {"api": {"from the documentation": [[17, 38]]}}}, {"text": "The clip area of the Graphics2D (see getClip()) is set automatically to the visible portion, but at some moment \"Java\" will still \"take time\" to determine whether the generic shapes are inside this clip area", "label": {"api": {"getClip()": [[37, 45]]}}}, {"text": "The Java doc of the URL constructor explain how URLStreamHandle are discovered", "label": {"api": {"URL constructor": [[20, 34]]}}}, {"text": "Note, that Class.getResourceAsStream() might be easier to use", "label": {"api": {"Class.getResourceAsStream()": [[11, 37]]}}}, {"text": "To make computation simple I used retainAll", "label": {"api": {"retainAll": [[34, 42]]}}}, {"text": "Create a desired EventType", "label": {"api": {"EventType": [[17, 25]], "Event": [[17, 21]]}}}, {"text": "Create the corresponding Event", "label": {"api": {"Event": [[25, 29]]}}}, {"text": "Add Handlers and/or Filters for EventTypes of interest", "label": {"api": {"EventType": [[32, 40]], "Event": [[32, 36]], "Handlers": [[4, 11]], "Filters": [[20, 26]]}}}, {"text": "If you want to create an event cascade, start with an \"All\" or \"Any\" type, that will be the root of all of the EventTypes", "label": {"api": {"EventType": [[111, 119]], "Event": [[111, 115]]}}}, {"text": "Then write the MyEvent class (which extends Event)", "label": {"api": {"Event": [[17, 21], [44, 48]]}}}, {"text": "The EventTypes should be typed to this event class (as is my example)", "label": {"api": {"EventType": [[4, 12]], "Event": [[4, 8]]}}}, {"text": "It’s all about calling LambdaMetafactory.metafactory with the method handle, the desired interface and the name of the sole abstract method and required signature", "label": {"api": {"LambdaMetafactory.metafactory": [[23, 51]]}}}, {"text": "Both, the method’s documentation and it’s class documentation are very detailled", "label": {"api": {"method’s documentation": [[10, 31]], "it’s class documentation": [[37, 60]]}}}, {"text": "Since resources is a package, you can use getClass().getResourceAsStream(...) to access your file", "label": {"api": {"getClass().getResourceAsStream(...)": [[42, 76]]}}}, {"text": "If you are executing your code from a static context, you have to use MyClass.class.getResourceAsStream(...) instead of calling getClass().getResourceAsStream(...)", "label": {"api": {"getClass().getResourceAsStream(...)": [[128, 162]]}}}, {"text": "Instead of copy-pasting the code, I'll point you to the official documentation where you can find some examples", "label": {"api": {"official documentation": [[56, 77]]}}}, {"text": "Both Set and List extend Collection", "label": {"api": {"Collection": [[25, 34]]}}}, {"text": "Specific example from the API concerning the year field", "label": {"api": {"API": [[26, 28]]}}}, {"text": "To look up a CDI bean by name, one can use the BeanManager's getBeans method combined with the resolve method of the same class", "label": {"api": {"BeanManager's getBeans method": [[47, 75]]}}}, {"text": "An EnumSet has the bit properties you desire, though unfortunately does not exhibit them as long[] or such", "label": {"api": {"EnumSet": [[3, 9]]}}}, {"text": "In the code in the pastebin you do a check that is missing from this code and that's why you get a NullPointerException", "label": {"api": {"NullPointerException": [[99, 118]]}}}, {"text": "try to use String tokenizer and insert ',' as delimeters", "label": {"api": {"String tokenizer": [[11, 26]]}}}, {"text": "The method BigInteger.isProbablePrime() is quite strange; from the documentation, this will tell whether a number is prime with a probability of 1 - 1 / 2^arg, where arg is the integer argument", "label": {"api": {"The method BigInteger.isProbablePrime()": [[0, 38]]}}}, {"text": "Using the default Graphics object from the java.awt package, you can use the drawImage method with 10 parameters", "label": {"api": {"Graphics": [[18, 25]], "drawImage method with 10 parameters": [[77, 111]]}}}, {"text": "If you're concerned about resource management, a Scanner in Java 7 implements AutoCloseable, so you can use a try-with-resources to handle the closure of the stream (but please, not STDIN)", "label": {"api": {"AutoCloseable": [[78, 90]]}}}, {"text": "You can look up BigDecimal or BigInteger for use in this case", "label": {"api": {"BigDecimal": [[16, 25]], "BigInteger": [[30, 39]]}}}, {"text": "See too https://docs.oracle.com/javase/9/docs/api/java/awt/Desktop.html#setOpenURIHandler-java.awt.desktop.OpenURIHandler-", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/java/awt/Desktop.html#setOpenURIHandler-java.awt.desktop.OpenURIHandler-": [[8, 121]]}}}, {"text": "by using String.split(\"regex\") as show below", "label": {"api": {"String.split(\"regex\")": [[9, 29]]}}}, {"text": "For example if the first index of a is AFTER the first index of b, then the expression str.substring(str.indexOf(\"a\")+1, str.indexOf(\"b\")) will throw this exception, as described in the Javadoc for the substring method, which promises ..", "label": {"api": {"Javadoc for the substring method": [[186, 217]]}}}, {"text": "Fancy with NumberFormat", "label": {"api": {"NumberFormat": [[11, 22]]}}}, {"text": "$1 is equivalent to calling group(1), which is specified to return null when the group didn't get captured", "label": {"api": {"specified to return null": [[47, 70]]}}}, {"text": "The wording of the relevant parts of the Javadoc is on the whole surprisingly vague (emphasis mine)", "label": {"api": {"relevant parts of the Javadoc": [[19, 47]]}}}, {"text": "You should get the code working first with Collections.synchronizedList or a synchronized statement around the add call", "label": {"api": {"Collections.synchronizedList": [[43, 70]]}}}, {"text": "It's not subString but substring", "label": {"api": {"substring": [[23, 31]]}}}, {"text": "Besides, the substring method takes in 2 integer arguments so your code will definitely not compile", "label": {"api": {"substring": [[13, 21]]}}}, {"text": "You're passing integer values so the correct way should be to parse a String to int using Integer.parseInt() function", "label": {"api": {"Integer.parseInt()": [[90, 107]]}}}, {"text": "(You can get information about declared fields using getDeclaredFields, but I don't think you're looking for that)", "label": {"api": {"getDeclaredFields": [[53, 69]]}}}, {"text": "If you want to know how many declared constructors there are, use getDeclaredConstructors", "label": {"api": {"getDeclaredConstructors": [[66, 88]]}}}, {"text": "Check out setParameter", "label": {"api": {"setParameter": [[10, 21]]}}}, {"text": "The fact that you are using ht.remove(routerNum); to remove the router from the map suggests that you are using the routers' numbers as keys to the map", "label": {"api": {"ht.remove(routerNum);": [[28, 48]]}}}, {"text": "Just call ht.remove(routerNum); and that's it", "label": {"api": {"ht.remove(routerNum);": [[10, 30]]}}}, {"text": "Take a look into Java's documentation", "label": {"api": {"Java's documentation": [[17, 36]]}}}, {"text": "You could use a lock (https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html) and lock it manually", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html": [[22, 99]]}}}, {"text": "Void is a reference type", "label": {"api": {"Void": [[0, 3]]}}}, {"text": "You may need to increase the limit or  close() the FileReader explicitly", "label": {"api": {"close()": [[39, 45]], "FileReader": [[51, 60]]}}}, {"text": "Is it possible to create a TitledBorder with a RadioButton instead of the \"title\" string", "label": {"api": {"RadioButton": [[47, 57]], "TitledBorder": [[27, 38]]}}}, {"text": "It would be just like a standard TitledBorder, but rather than having a string represent the box encompassed by the border, I'd like to use a radio button instead", "label": {"api": {"TitledBorder": [[33, 44]]}}}, {"text": "When translating from bytes to chars, you have to decode", "label": {"api": {"decode": [[50, 55]]}}}, {"text": "When translating from chars to bytes, you have to encode", "label": {"api": {"encode": [[50, 55]]}}}, {"text": "Also note that by default, the encoding/decoding behaviour on failure it to replace unmappable char/byte sequences", "label": {"api": {"replace": [[76, 82]]}}}, {"text": "you need to decode from bytes and you need to encode to bytes; if either part fails you end with meaningless byte sequences/mutant carrier pigeons", "label": {"api": {"decode": [[12, 17]], "encode": [[46, 51]]}}}, {"text": "That behavior can be changed by explicitly creating your own CharsetDecoder and calling its onMalformedInput method, rather than just relying on new String(byte[])", "label": {"api": {"onMalformedInput": [[92, 107]]}}}, {"text": "According to the JavaDoc for the Resource Annotation, the annotation may be applied to a class, or fields or methods", "label": {"api": {"JavaDoc for the Resource Annotation": [[17, 51]]}}}, {"text": "The clone method is protected in Object", "label": {"api": {"protected in Object": [[20, 38]]}}}, {"text": "The Cloneable interface is a marker interface that doesn't guarantee the existence of a public clone method (or any method)", "label": {"api": {"Cloneable interface": [[4, 22]]}}}, {"text": "ScheduledExecutorService#scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) does as you ask, scheduling an activity in a separate thread with a specified delay and period", "label": {"api": {"ScheduledExecutorService#scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)": [[0, 108]]}}}, {"text": "But this doesn't sit well with the JDK API; I need to be able to implement FileSystemProvider#newInputStream()..", "label": {"api": {"FileSystemProvider#newInputStream()": [[75, 109]]}}}, {"text": "You could go the way of Javas LinkedHashMap class", "label": {"api": {"LinkedHashMap": [[30, 42]]}}}, {"text": "You can use the List#containsAll(Collection<?> c) method which returns true if the list contains all the elements of the given Collection", "label": {"api": {"List#containsAll(Collection<?> c)": [[16, 48]]}}}, {"text": "Quoting from FileChannel.truncate javadocs", "label": {"api": {"FileChannel.truncate javadocs": [[13, 41]]}}}, {"text": "The direct answer would be to use get(int index) instead of the array access using the brackets ([index]) for collections such as lists", "label": {"api": {"get(int index)": [[34, 47]]}}}, {"text": "If you have explicitely defined your custom uncaughtExceptionHandler and registered it, then it's that what's going to be called", "label": {"api": {"uncaughtExceptionHandler": [[44, 67]]}}}, {"text": "You can check https://blogs.oracle.com/sundararajan/entry/programmatically_dumping_heap_from_java which describes a way to programmatically create a heap dump for the HotSpot VM using a com.sun.management.HotSpotDiagnosticMXBean", "label": {"api": {"com.sun.management.HotSpotDiagnosticMXBean": [[186, 227]]}}}, {"text": "Integer is an object, so you'll be calling List.remove(Object) - i.e., remove the passed value", "label": {"api": {"List.remove(Object)": [[43, 61]]}}}, {"text": "To avoid iterating through the pixels, change the underlying ColorModel", "label": {"api": {"ColorModel": [[61, 70]]}}}, {"text": "While I haven't had a chance to test this thoroughly yet, using a LookupOp may well benefit from acceleration", "label": {"api": {"LookupOp": [[66, 73]]}}}, {"text": "Using it is as easy as creating a LookupOp", "label": {"api": {"LookupOp": [[34, 41]]}}}, {"text": "In order to accept user Input take a look on Scanner class E.g", "label": {"api": {"Scanner": [[45, 51]]}}}, {"text": "According to the Java documentation, String.valueOf() returns", "label": {"api": {"the Java documentation": [[13, 34]]}}}, {"text": "For more information on how to use the ArrayList class, see Class ArrayList<E>", "label": {"api": {"Class ArrayList<E>": [[60, 77]]}}}, {"text": "You can find more information about formatting at oracle", "label": {"api": {"oracle": [[50, 55]]}}}, {"text": "The input SimpleDateFormat pattern is wrong", "label": {"api": {"SimpleDateFormat": [[10, 25]]}}}, {"text": "See the Javadoc of SimpleDateFormat for how to define date patterns", "label": {"api": {"SimpleDateFormat": [[19, 34]]}}}, {"text": "The Graph class would be an Observable that the controller observes", "label": {"api": {"Observable": [[28, 37]]}}}, {"text": "As you can see in the documentation https://docs.oracle.com/javase/7/docs/api/javax/xml/xpath/XPath.html#evaluate%28java.lang.String,%20org.xml.sax.InputSource%29, that overload of the evaluate method evaluates the XPath and returns the result as string", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/xml/xpath/XPath.html#evaluate%28java.lang.String,%20org.xml.sax.InputSource%29": [[36, 161]]}}}, {"text": "Use the Calendar class instead", "label": {"api": {"Calendar": [[8, 15]]}}}, {"text": "To be able to use the single-argument version of Collection.sort() on an ArrayList of A, A should implement the Comparable interface", "label": {"api": {"Collection.sort()": [[49, 65]]}}}, {"text": "Use context.getRealPath to get absolute path and create a file object to access the file", "label": {"api": {"context.getRealPath": [[4, 22]]}}}, {"text": "See for example this link for more information", "label": {"api": {"this link": [[16, 24]]}}}, {"text": "In fact, in the real world one wouldn't be implementing a linked list at all -- one would use a java.util.LinkedList", "label": {"api": {"java.util.LinkedList": [[96, 115]]}}}, {"text": "However, you can do the next best thing, and use java.util.AbstractSequentialList", "label": {"api": {"java.util.AbstractSequentialList": [[49, 80]]}}}, {"text": "If that isn't allowed, then implement java.util.List yourself, or at least pattern your linkedlist implementation on that interface", "label": {"api": {"java.util.List": [[38, 51]]}}}, {"text": "You can use URLDecodor to decode the stream", "label": {"api": {"URLDecodor": [[12, 21]]}}}, {"text": "The problem is you are calling dispose(), Change your code like", "label": {"api": {"dispose()": [[31, 39]]}}}, {"text": "Consider ProcessBuilder class from java API to invoke external processes", "label": {"api": {"ProcessBuilder class": [[9, 28]]}}}, {"text": "HTTPServlet isn't an interface", "label": {"api": {"HTTPServlet": [[0, 10]], "Servlet": [[4, 10]]}}}, {"text": "If you want to use your own implementation of HTTPServlet class, then please create a replica of the original abstract class i.e", "label": {"api": {"HTTPServlet": [[46, 56]], "Servlet": [[50, 56]]}}}, {"text": "implement intefaces Servlet and ServletConfig as well as extend GenericServlet", "label": {"api": {"Servlet": [[20, 26], [32, 38], [71, 77]], "ServletConfig": [[32, 44]], "GenericServlet": [[64, 77]]}}}, {"text": "If you want to use SipServlet, you got to implement the same interfaces as in the SipServlet class", "label": {"api": {"Servlet": [[22, 28], [85, 91]]}}}, {"text": "Use indexOf and substring method of String class", "label": {"api": {"indexOf": [[4, 10]], "substring": [[16, 24]]}}}, {"text": "Use DecimalFormat in combination with DecimalFormatSymbols", "label": {"api": {"DecimalFormat": [[4, 16], [38, 50]]}}}, {"text": "Without using DecimalFormatSymbols you would end up with a comma as a decimal seperator instead", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "You could use setScale method and optinally you could choose rounding methodology of your own", "label": {"api": {"setScale": [[14, 21]]}}}, {"text": "A sax parser can read from an InputSource based on a Reader", "label": {"api": {"InputSource": [[30, 40]], "Reader": [[53, 58]]}}}, {"text": "To feed a string to it, just wrap that string up in a StringReader", "label": {"api": {"Reader": [[60, 65]], "StringReader": [[54, 65]]}}}, {"text": "You can do the same in StAX and DOM, though of course the details of where you connect the StringReader are different", "label": {"api": {"Reader": [[97, 102]], "StringReader": [[91, 102]]}}}, {"text": "Try opening the stream in append mode", "label": {"api": {"append mode": [[26, 36]]}}}, {"text": "You can also use the clone method to copy the current instance of the GameState", "label": {"api": {"clone": [[21, 25]]}}}, {"text": "If your instances (of the above classes) run on the same JVM but in different threads, use one of the blocking queues that come with Java", "label": {"api": {"blocking queues": [[102, 116]]}}}, {"text": "The H_ constants in the Opcodes class are no actual opcodes, they are used for building a MethodHandle (using ASMs Handle class) which can be used in InvokeDynamic instructions", "label": {"api": {"MethodHandle": [[90, 101]]}}}, {"text": "Run javac with proc, processor and processorpath option and implement a Processor that does all the checking you want", "label": {"api": {"Processor": [[72, 80]]}}}, {"text": "The InputStream.read(byte[]) method might or might not fill the array passed to it", "label": {"api": {"might or might not": [[36, 53]]}}}, {"text": "The other problem is that the contract of the InputStream.available() method specifically states", "label": {"api": {"the contract of the InputStream.available() method": [[26, 75]]}}}, {"text": "Please refer to the Java Platform documentation for the Graphics class", "label": {"api": {"Graphics class": [[56, 69]]}}}, {"text": "Specifically the documentation for the drawLine() method, and also the drawRect() method (although you don't strictly need drawRect() to accomplish the task)", "label": {"api": {"drawLine() method": [[39, 55]], "drawRect() method": [[71, 87]]}}}, {"text": "This page could help you", "label": {"api": {"This page": [[0, 8]]}}}, {"text": "To solve, instead of using nextInt(), use nextLong() and read the input into a variable of type long", "label": {"api": {"nextLong()": [[42, 51]]}}}, {"text": "The method java.util.regex.Matcher.group(String) returns the input subsequence captured by the given named-capturing group, but there's no example available on API documentations", "label": {"api": {"java.util.regex.Matcher.group(String)": [[11, 47]]}}}, {"text": "String.matches returns true if the entire string matches the pattern", "label": {"api": {"String.matches": [[0, 13]]}}}, {"text": "The LogManager supports arbitrary configuration code", "label": {"api": {"LogManager": [[4, 13]]}}}, {"text": "Instead of using HashTable, you should use TreeMap which will sort by key that you enter", "label": {"api": {"TreeMap": [[43, 49]]}}}, {"text": "See, for example, the documentation of Stream.forEachOrdered", "label": {"api": {"Stream.forEachOrdered": [[39, 59]]}}}, {"text": "Performing the action for one element happens-before performing the action for subsequent elements, but for any given element, the action may be performed in whatever thread the library chooses", "label": {"api": {"happens-before": [[38, 51]]}}}, {"text": "JEditorPane and JTextPane are far more suitable for styled text display and even support some HTML formatting", "label": {"api": {"JEditorPane": [[0, 10]], "JTextPane": [[16, 24]]}}}, {"text": "This function is from java.util.Random", "label": {"api": {"java.util.Random": [[22, 37]]}}}, {"text": "According to Desktop#open(File file) method documentation it takes a File object as argument, not a String, so I doubt your code even compiles", "label": {"api": {"Desktop#open(File file)": [[13, 35]], "File": [[26, 29], [69, 72]]}}}, {"text": "It also throws an IOException that has to be treated", "label": {"api": {"IOException": [[18, 28]]}}}, {"text": "An alternative to potentially modifying a functional interface method, since you are using a well known character set, is to use the overloaded String constructor which accepts a byte[] and a Charset, but which doesn't throw UnsupportedEncodingException", "label": {"api": {"the overloaded String constructor which accepts a byte[] and a Charset": [[129, 198]]}}}, {"text": "Use StandardCharsets.UTF_16LE as the Charset argument", "label": {"api": {"StandardCharsets.UTF_16LE": [[4, 28]]}}}, {"text": "Stream#filter(Predicate) expects a Predicate which provides a test(Object) method", "label": {"api": {"Stream#filter(Predicate)": [[0, 23]], "Predicate": [[14, 22], [35, 43]], "test(Object)": [[62, 73]]}}}, {"text": "ShutdownHook is similar to my thought but the only drawback i am seeing is it only runs on shutdown, is their any best practices available to this problem", "label": {"api": {"ShutdownHook": [[0, 11]]}}}, {"text": "Simply add a @PostConstruct annotation to your methods that you want to cache on server start up", "label": {"api": {"@PostConstruct": [[13, 26]]}}}, {"text": "You didn't show the code for the Person class, but it appears that you did not override Object's toString() method, which is responsible for the output you see", "label": {"api": {"Object's toString() method": [[88, 113]]}}}, {"text": "It uses equalsIgnoreCase(), which is equivalent to your method of getting the first character, uppercasing it, and comparing it to 'Y'", "label": {"api": {"equalsIgnoreCase()": [[8, 25]]}}}, {"text": "add a listener to onHidden", "label": {"api": {"onHidden": [[18, 25]]}}}, {"text": "It seems clear to me (based on the comments) and looking at the Writer class that the Writer class is only supposed to write single characters", "label": {"api": {"Writer": [[64, 69], [86, 91]]}}}, {"text": "The fact that l1 + \",\" works is because the compiler converts this to a String object (which the Writer then converts to a char array and writes the String value char by char)", "label": {"api": {"Writer": [[97, 102]]}}}, {"text": "Note that calling Writer.write((int)(l1 + ',')) would have \"unexpected\" results)", "label": {"api": {"Writer": [[18, 23]]}}}, {"text": "If you want to print string representations then you should wrap the BufferedWriter inside a PrintWriter, i.e.", "label": {"api": {"Writer": [[77, 82], [98, 103]], "PrintWriter": [[93, 103]]}}}, {"text": "I should also point out that if you want to be extremely careful, then you should use OutputStreamWriter and specify the character encoding or character set (this may actually be more important for reading files rather than writing to them, i.e", "label": {"api": {"Writer": [[98, 103]], "OutputStreamWriter": [[86, 103]]}}}, {"text": "you should use InputStreamReader to read text files)", "label": {"api": {"InputStreamReader": [[15, 31]]}}}, {"text": "See http://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html and http://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html": [[4, 68]]}}}, {"text": "I recently encountered with a Java 8 class StringJoiner which adds the String using the delimiters and adds prefix and suffix to it, but I can't understand the need of this class as it also uses StringBuilder at the backend and also performs very simple operation of appending the Strings", "label": {"api": {"StringJoiner": [[43, 54]], "StringBuilder": [[195, 207]]}}}, {"text": "The examples on the StringJoiner Javadoc are very good at covering this", "label": {"api": {"StringJoiner Javadoc": [[20, 39]]}}}, {"text": "From the Oracle Docs", "label": {"api": {"Oracle Docs": [[9, 19]]}}}, {"text": "You could use String's matches method with a regex like below to resolve both kind of your validation requirements", "label": {"api": {"matches": [[23, 29]]}}}, {"text": "Another solution is to use a java.io.StringWriter", "label": {"api": {"java.io.StringWriter": [[29, 48]]}}}, {"text": "Coalesce is supported by JPA 2.0 API", "label": {"api": {"supported by JPA 2.0 API": [[12, 35]]}}}, {"text": "OutOfMemoryError is an Error and it is not an Exception", "label": {"api": {"OutOfMemoryError is an Error": [[0, 27]]}}}, {"text": "Finally, when the web application shuts down, you can use ServletContextListener#contextDestroyed(..) to close to ApplicationContext", "label": {"api": {"ServletContextListener#contextDestroyed(..)": [[58, 100]]}}}, {"text": "You can also use a List interface", "label": {"api": {"List": [[19, 22]]}}}, {"text": "Both LinkedList and ArrayList support efficient iterating and appending", "label": {"api": {"List": [[11, 14], [25, 28]], "LinkedList": [[5, 14]], "ArrayList": [[20, 28]]}}}, {"text": "In the String.join method, the first parameter is the delimiter, and the rest of the arguments are the strings to join using the delimiter", "label": {"api": {"String.join": [[7, 17]]}}}, {"text": "IllegalArgumentException is, in fact, a subclass of RuntimeException", "label": {"api": {"IllegalArgumentException is, in fact, a subclass of RuntimeException": [[0, 67]]}}}, {"text": "Put the text areas in a scroll pane", "label": {"api": {"scroll pane": [[24, 34]]}}}, {"text": "It depends on the numbers involved, but on a modern computer I would not describe Math.pow(double, double) as particularly computationally intense", "label": {"api": {"Math.pow(double, double)": [[82, 105]]}}}, {"text": "Instead of that, you need to use either request.getPart()  method or libraries like apache-fileupload to retrieve the inputstream of the remote file", "label": {"api": {"request.getPart() ": [[40, 57]]}}}, {"text": "based on the Oracle documentation I tried to construct a URL and link it to a path on my HDD", "label": {"api": {"Oracle documentation": [[13, 32]]}}}, {"text": "but then ,though on the Oracle documentation it is said that file can be one of the protocols at first argument, but it giving me the following exception in the practical", "label": {"api": {"Oracle documentation": [[24, 43]]}}}, {"text": "The scheme associated with the default filesystem is always file", "label": {"api": {"default filesystem": [[31, 48]]}}}, {"text": "Then you can pass list of such objects to Collections.sort", "label": {"api": {"Collections.sort": [[42, 57]]}}}, {"text": "If you are using Java 8, you can use Comparator.comparing to specify what method to use for comparison, and thenComparing to specify what method to use in case of a tie, and so on", "label": {"api": {"Comparator.comparing": [[37, 56]], "thenComparing": [[108, 120]]}}}, {"text": "You're calling System.out.println(test), which is a call to PrintStream.println(Object)", "label": {"api": {"PrintStream.println(Object)": [[60, 86]]}}}, {"text": "Why not simply use the min and max methods of the Collection class", "label": {"api": {"min": [[23, 25]], "max": [[31, 33]]}}}, {"text": "There is Integer.parseInt(String s, int radix) and Integer.toString(int i, int radix)", "label": {"api": {"Integer.parseInt(String s, int radix)": [[9, 45]], "Integer.toString(int i, int radix)": [[51, 84]]}}}, {"text": "Use ProcessBuilder to create your process and call redirectOutput(File) to redirect and append output to a file", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "I'm not sure about the order and list of ProcessBuilder arguments so try to play with them to get your code working", "label": {"api": {"ProcessBuilder": [[41, 54]]}}}, {"text": "According to this example, the nashorn engine name is just nashorn and not nashorn-javascript", "label": {"api": {"this example": [[13, 24]]}}}, {"text": "With java-8, you could use Collectors.joining", "label": {"api": {"Collectors.joining": [[27, 44]]}}}, {"text": "It uses a StringJoiner behind the scenes, a new class that has been introduced", "label": {"api": {"StringJoiner": [[10, 21]]}}}, {"text": "If you know how many threads to wait on, then you can use a shared semaphore", "label": {"api": {"semaphore": [[67, 75]]}}}, {"text": "The worker threads each calls release on the semaphore when they're done; the main thread calls acquire(n) where n is the number of worker threads, which causes the main thread to wait until n permits are available (i.e", "label": {"api": {"semaphore": [[45, 53]]}}}, {"text": "The interface in question is FileVisitor, which defines this method", "label": {"api": {"FileVisitor": [[29, 39]]}}}, {"text": "And then I recalled that if you implemented Cloneable your were not required to throw CloneNotSupportedException, which is also a checked exception, for your code to compile (not that this is the canonical reommendation, of course)", "label": {"api": {"CloneNotSupportedException": [[86, 111]]}}}, {"text": "Even though Object's .clone() throws it", "label": {"api": {"Object's .clone() throws it": [[12, 38]]}}}, {"text": "You can do something similar when looking for a char in a String, by using the indexOf method to search the string", "label": {"api": {"indexOf method": [[79, 92]]}}}, {"text": "CriteriaBuilder also provides CriteriaBuilder#equal(Expression<?>, java.lang.Object) (javadoc here) which could take the Expression<String> as the first parameter, and then your String tmNumber as the second argument", "label": {"api": {"javadoc here": [[86, 97]]}}}, {"text": "I will give you a small example, although you should have a good read at JDBC adn specifically at ResultSet", "label": {"api": {"ResultSet": [[98, 106]]}}}, {"text": "The easiest way would be to keep the history as strings in ArrayList", "label": {"api": {"ArrayList": [[59, 67]]}}}, {"text": "I would use the Java 8 Optional object when modelling the objects", "label": {"api": {"Optional": [[23, 30]]}}}, {"text": "using the ifPresent-method", "label": {"api": {"ifPresent-method": [[10, 25]]}}}, {"text": "Use the overloaded SimpleDateFormat constructor which accepts a Locale and provide it with an appropriate instance", "label": {"api": {"overloaded SimpleDateFormat constructor": [[8, 46]]}}}, {"text": "I'm trying to run a native executable from Java using the Process API", "label": {"api": {"Process": [[58, 64]]}}}, {"text": "If it's available to you, you can declare a Servlet bean in your XML configuration file, use Spring's WebApplicationInitializer (or write your own ServletContainerInitializer) to load the XML file in a WebApplicationContext, retrieve the Servlet bean, and add it to the ServletContext with add(String, Servlet)", "label": {"api": {"ServletContainerInitializer": [[147, 173]], "add(String, Servlet)": [[290, 309]]}}}, {"text": "A good solution (because of library being included in JDK since Java 1.7) is to use the FXCanvas from JavaFX (http://docs.oracle.com/javafx/2/api/javafx/embed/swt/FXCanvas.html), which could be embedded in SWT components structure", "label": {"api": {"http://docs.oracle.com/javafx/2/api/javafx/embed/swt/FXCanvas.html": [[110, 175]]}}}, {"text": "I'm answering based on the assumption that your user interfaces(GameView, EndGameView) contain Swing components such as JTextPane, JTextField, JTable etc.", "label": {"api": {"JTable": [[143, 148]]}}}, {"text": "For example a JTable has a TableModel and a JComboBox will have its own ComboBoxModel", "label": {"api": {"JTable": [[14, 19]], "TableModel": [[27, 36]], "JComboBox": [[44, 52]], "ComboBoxModel": [[72, 84]]}}}, {"text": "Have you looked at MessageFormat (http://docs.oracle.com/javase/7/docs/api/java/text/MessageFormat.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/MessageFormat.html": [[34, 102]]}}}, {"text": "You can use System.lineSeparator() to get the correct line-ending for your system", "label": {"api": {"System.lineSeparator()": [[12, 33]]}}}, {"text": "If you take a look at the HashMap API", "label": {"api": {"HashMap API": [[26, 36]]}}}, {"text": "Swing apps also need to call applyComponentOrientation after building each window, usually right before calling pack()", "label": {"api": {"applyComponentOrientation": [[29, 53]]}}}, {"text": "No, you need to implement the generic form of the Comparable interface, so that you can take a RealNumber as a argument to the compareTo method", "label": {"api": {"Comparable interface": [[50, 69]]}}}, {"text": "However, these array objects don't override Object's toString() method, which is responsible for the output you see", "label": {"api": {"Object's toString() method": [[44, 69]]}}}, {"text": "Use Arrays.toString to obtain a String with the contents of the array, e.g", "label": {"api": {"Arrays.toString": [[4, 18]]}}}, {"text": "That said, you can cause the threads to wait for each other (for example by using synchronized or any Lock class)", "label": {"api": {"Lock": [[102, 105]]}}}, {"text": "Even though it's stored as an InputStream, it is a BufferedInputStream", "label": {"api": {"it's stored as an InputStream": [[12, 40]]}}}, {"text": "Does your class extend LinkedList", "label": {"api": {"LinkedList": [[23, 32]]}}}, {"text": "It isn't a great idea to extend LinkedList", "label": {"api": {"LinkedList": [[32, 41]]}}}, {"text": "If you want an easy way to create a new LinkedList with elements use the following method", "label": {"api": {"LinkedList": [[40, 49]]}}}, {"text": "The name is a value that can be given to a swing component (using setName(String)) to give it some meaningful name for the application", "label": {"api": {"setName(String)": [[66, 80]]}}}, {"text": "One memory leak scenario is that you've got a Big Collection Full Of Everything that is making objects reachable even after they're nulled out everywhere else in the program; in this case your options are to remove mostly-dead objects from these data structures, or if this isn't practical/feasible you can fill the collection with WeakReferences or SoftReferences - these tell the garbage collector \"it's fine to reclaim an object if the only references held to it are weak or soft\" (weak references are typically collected more eagerly than soft references)", "label": {"api": {"WeakReferences": [[332, 345]], "SoftReferences": [[350, 363]]}}}, {"text": "If the Big Collection is a map then Java provides a WeakHashMap that you can use instead", "label": {"api": {"WeakHashMap": [[52, 62]]}}}, {"text": "If you check out the Queue API, you will find that generally no queue will allow insertion of a null element", "label": {"api": {"Queue API": [[21, 29]]}}}, {"text": "The problem is clear when you read the javadoc of .getConstructor()", "label": {"api": {"javadoc of .getConstructor()": [[39, 66]]}}}, {"text": "You can schedule GUI updates outside the GUI Thread with Platform.runLater()", "label": {"api": {"Platform.runLater()": [[57, 75]]}}}, {"text": "You can retrieve the public key from the certificate instead", "label": {"api": {"retrieve the public key from the certificate instead": [[8, 59]]}}}, {"text": "Iterating a list and modifying it simultaneously causes a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[58, 88]]}}}, {"text": "A ConcurrentModificationException is the error, some collections are designed to stop you from doing that since if it was allowed it would likely cause unexpected output and could potentially be unsafe and the item you just added to would also get iterated", "label": {"api": {"ConcurrentModificationException": [[2, 32]]}}}, {"text": "But ConcurrentModificationExceptions do exist for a reason and to use code such as above would be bad practice", "label": {"api": {"ConcurrentModificationException": [[4, 34]]}}}, {"text": "Since Java 5, the new java.util.concurrent package should be used in most cases where you need multiple threads accessing the same collection", "label": {"api": {"java.util.concurrent": [[22, 41]]}}}, {"text": "Note that in most cases, you should use java.util.concurrent instead", "label": {"api": {"java.util.concurrent": [[40, 59]]}}}, {"text": "For example, ConcurrentHashMap provides a putIfAbsent() method that will ensure the atomicity of that operation", "label": {"api": {"putIfAbsent()": [[42, 54]]}}}, {"text": "You have an array of String in your Vector, hence you would need to use Arrays.equals method to compare two array's for equality as contains internally iterate over each element in vector and would check the references of two array element i.e", "label": {"api": {"method": [[86, 91]]}}}, {"text": "You could use Collections.unmodifiableSet, to make your set immutable once created", "label": {"api": {"Collections.unmodifiableSet": [[14, 40]]}}}, {"text": "You can even combine this with the @PreRemove annotation", "label": {"api": {"@PreRemove": [[35, 44]]}}}, {"text": "One of common solution here is to use CountDownLatch", "label": {"api": {"CountDownLatch": [[38, 51]]}}}, {"text": "If you don't know number of tasks You could try Phaser (and feel like cpt", "label": {"api": {"Phaser": [[48, 53]]}}}, {"text": "You can do this with a regular expression", "label": {"api": {"regular expression": [[23, 40]]}}}, {"text": "You should be using java.nio.file.Files.setFileAttribute() unless you're working with a version of Java older than 7", "label": {"api": {"java.nio.file.Files.setFileAttribute()": [[20, 57]]}}}, {"text": "See Consumer documentation", "label": {"api": {"Consumer": [[4, 11]]}}}, {"text": "The reason why IntelliJ cannot do that is because it's part of the Consumer interface, which is part of the JDK", "label": {"api": {"Consumer": [[67, 74]]}}}, {"text": "That string is guaranteed to be parseable by KeyStroke.getKeyStroke(String), which is what you should call when reading the saved preference", "label": {"api": {"KeyStroke.getKeyStroke(String)": [[45, 74]]}}}, {"text": "I think your problem with undefined key codes can be solved if you use getExtendedKeyCode() rather than getKeyCode()", "label": {"api": {"getExtendedKeyCode()": [[71, 90]]}}}, {"text": "When you want your game to repaint, simply call the panel's repaint method", "label": {"api": {"repaint": [[27, 33], [60, 66]]}}}, {"text": "Thus, your gameAction method should replace paintScreen() with repaint(), which will automatically call your panel's paintComponent method (and some other methods;  as that tutorial explains, painting isn't a simple thing)", "label": {"api": {"repaint": [[63, 69]]}}}, {"text": "You will need to put a short sleep call inside the loop in your run() method", "label": {"api": {"sleep": [[29, 33]]}}}, {"text": "If you try to update and repaint the game constantly, the program won't have time to actually draw anything", "label": {"api": {"repaint": [[25, 31]]}}}, {"text": "Look on how to implement equals() and hashCode() for Present", "label": {"api": {"equals()": [[25, 32]], "hashCode()": [[38, 47]]}}}, {"text": "List.remove(int index) and List.contains(Object)", "label": {"api": {"List.remove(int index)": [[0, 21]], "List.contains(Object)": [[27, 47]]}}}, {"text": "For more info, see Object.equals and List.remove", "label": {"api": {"Object.equals": [[19, 31]], "List.remove": [[37, 47]]}}}, {"text": "However, I believe the best way to do this would be to either use a Set which automatically handles the no repeats-problem or some kind of Queue", "label": {"api": {"Set": [[68, 70]], "Queue": [[139, 143]]}}}, {"text": "a HashSet) don't forget to implement the hashCode function (more info on hashCode here)", "label": {"api": {"Set": [[6, 8]], "HashSet": [[2, 8]]}}}, {"text": "Check out the JavaDocs", "label": {"api": {"the JavaDocs": [[10, 21]]}}}, {"text": "The prototype of Files.createSymbolicLink() is", "label": {"api": {"The prototype of Files.createSymbolicLink()": [[0, 42]]}}}, {"text": "A code point outside the BMP is two chars wide, not one (see Character.toChars()); you need to check that and advance your index if you encounter such a code point", "label": {"api": {"Character.toChars()": [[61, 79]]}}}, {"text": "There may be certain libraries that actually force your usage of float, but in general - unless you can guarantee that your result will be small enough to fit in float's prescribed range, then it's best to opt with double", "label": {"api": {"prescribed range": [[170, 185]]}}}, {"text": "You can use Long.valueOf(isbnString, 16)", "label": {"api": {"Long.valueOf(isbnString, 16)": [[12, 39]]}}}, {"text": "Starting from Java 7 you can use deleteIfExists that returns a boolean (or throw an Exception) depending on whether a file was deleted or not", "label": {"api": {"deleteIfExists": [[33, 46]]}}}, {"text": "As you can see in documentation for Java 5, schema attribute doesn't exist", "label": {"api": {"documentation for Java 5": [[18, 41]]}}}, {"text": "But, in documentation for Java 6 it is there", "label": {"api": {"documentation for Java 6": [[8, 31]]}}}, {"text": "This page is where the docs say to go for more information about how the methods actually work", "label": {"api": {"This page": [[0, 8]]}}}, {"text": "So, if your TreeModel contains only MyClass type of node (I'm asssuming your class implements at least TreeNode interface, better if MutableTreeNode) then you would have to down-cast the last path component to your class, accordingly", "label": {"api": {"TreeModel": [[12, 20]], "TreeNode": [[103, 110], [140, 147]], "MutableTreeNode": [[133, 147]]}}}, {"text": "As I've said, you would have to replace all the down-casts from DefaultMutableTreeNode to MyClass", "label": {"api": {"TreeNode": [[78, 85]], "MutableTreeNode": [[71, 85]]}}}, {"text": "The same thing can be achieved using the BigDecimal class and its setScale method", "label": {"api": {"setScale": [[66, 73]]}}}, {"text": "In my experience StringTokenizer performs better than calling split", "label": {"api": {"StringTokenizer": [[17, 31]]}}}, {"text": "You can either translate the whole graphics context with g2.translate, as answered by Andrew Thompson (and then reset the transform), or translate only the shape using the createTransformedShape method of AffineTransform", "label": {"api": {"createTransformedShape": [[172, 193]]}}}, {"text": "Other options include System.arraycopy", "label": {"api": {"System.arraycopy": [[22, 37]]}}}, {"text": "How can I test a generic class, like for example Stack.class from java.utils with junit?(http://docs.oracle.com/javase/6/docs/api/java/util/Stack.html) Is it enough to test it only for one Type, like Integer, because the class treats 2 different Types the same way", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Stack.html": [[89, 149]]}}}, {"text": "Try add method like", "label": {"api": {"add method": [[4, 13]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html at the next() function", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[0, 62]]}}}, {"text": "For reading huge files you would have to consider using a SeekableByteChannell and using the ByteBuffers", "label": {"api": {"SeekableByteChannell": [[58, 77]]}}}, {"text": "Yes, you can use Calendar.before() and Calendar.after()", "label": {"api": {"Calendar.before()": [[17, 33]], "Calendar.after()": [[39, 54]]}}}, {"text": "You should use an AtomicInteger", "label": {"api": {"AtomicInteger": [[18, 30]]}}}, {"text": "I would however consider AtomicInteger as a fairly low level primitive", "label": {"api": {"AtomicInteger": [[25, 37]]}}}, {"text": "You can use AtomicInteger", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "AtomicInteger does extend Number , so you can pass it to methods that operate on numerically based classes", "label": {"api": {"AtomicInteger": [[0, 12]]}}}, {"text": "Instead you can use SwingUtilities.invokeLater() (see invokeLater) to avoid hogging the UI thread while you're doing work", "label": {"api": {"invokeLater": [[35, 45], [54, 64]]}}}, {"text": "Further, I can't tell whether the compile argument, 'test' is a literal value or a variable, but the parameter requires a regular expression", "label": {"api": {"a regular expression": [[120, 139]]}}}, {"text": "Setting username in method getConnection fixed my problem", "label": {"api": {"getConnection": [[27, 39]]}}}, {"text": "You can use String.replace - note that you don't really need to check if the string contains the junk string - replace would just do nothing in this case", "label": {"api": {"String.replace": [[12, 25]]}}}, {"text": "You don't need all of these comparisons, you can simply use Character#toLowerCase", "label": {"api": {"Character#toLowerCase": [[60, 80]]}}}, {"text": "You can work with maps to get something close to what you're trying to do, visit the Map API", "label": {"api": {"Map": [[85, 87]]}}}, {"text": "You are looking for Map<String,T> - where T is your type of variable", "label": {"api": {"Map<String,T>": [[20, 32]]}}}, {"text": "BufferReader readLine Reads a line of text", "label": {"api": {"BufferReader readLine": [[0, 20]]}}}, {"text": "You can implement http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpSessionListener.html and register it in web.xml to receive notifications about session create/destroy etc", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpSessionListener.html": [[18, 96]]}}}, {"text": "The SWING label is javax.swing.JLabel, so fixing the imports as follows should solve your problem", "label": {"api": {"javax.swing.JLabel": [[19, 36]]}}}, {"text": "Use new SecureRandom() when you're not sure and let the system figure it out", "label": {"api": {"new SecureRandom()": [[4, 21]], "SecureRandom": [[8, 19]], "Random": [[14, 19]]}}}, {"text": "Possibly use SecureRandom.getInstanceStrong() for long term key generation", "label": {"api": {"SecureRandom.getInstanceStrong()": [[13, 44]], "SecureRandom": [[13, 24]], "Random": [[19, 24]]}}}, {"text": "This implements a list of Dynamic Random Bit Generators specified by NIST in SP-108", "label": {"api": {"Random": [[34, 39]]}}}, {"text": "The contract of SecureRandom doesn't change", "label": {"api": {"SecureRandom": [[16, 27]], "Random": [[22, 27]]}}}, {"text": "new SecureRandom() and let the system choose the best random number generator", "label": {"api": {"new SecureRandom()": [[0, 17]], "SecureRandom": [[4, 15]], "Random": [[10, 15]]}}}, {"text": "It is possible to use the new configurable SecureRandom.getInstanceStrong() in Java 8 and higher if you have any specific requirements for e.g", "label": {"api": {"SecureRandom.getInstanceStrong()": [[43, 74]], "SecureRandom": [[43, 54]], "Random": [[49, 54]]}}}, {"text": "Don't cache instances of SecureRandom, just let them seed themselves initially and let the VM handle them", "label": {"api": {"SecureRandom": [[25, 36]], "Random": [[31, 36]]}}}, {"text": "When not to use SecureRandom at all", "label": {"api": {"SecureRandom": [[16, 27]], "Random": [[22, 27]]}}}, {"text": "You may want to consider a different, non-secure random number generator instead of SecureRandom if the available RNG's deliver insufficient performance and if security is not an issue", "label": {"api": {"SecureRandom": [[84, 95]], "Random": [[90, 95]]}}}, {"text": "No SecureRandom implementation will be as fast as non secure random number generators such as the Mersenne Twister algorithm or the algorithm implemented by the Random class", "label": {"api": {"SecureRandom": [[3, 14]], "Random": [[9, 14], [161, 166]]}}}, {"text": "It is possible to extend the SecureRandom class and insert a deterministic, seeded random implementation into a library call", "label": {"api": {"SecureRandom": [[29, 40]], "Random": [[35, 40]]}}}, {"text": "I want to embed internal frames into JavaFX using Swing JDesktopPane", "label": {"api": {"JDesktopPane": [[56, 67]]}}}, {"text": "Java 8 introduces a parallel algorithm for multi-threaded sorting of arrays, in the form of the overloaded Arrays.sort() methods", "label": {"api": {"Arrays.sort()": [[107, 119]]}}}, {"text": "I see that Graphics.drawImage() with 8 int parameters says that it will draw an area of the image, which seems appropriate for drawing only the cropped area of the image, but when I tried image.getGraphics().drawImage(image, 0, 0, 500, 500, 100, 100, 400, 400, null); it didn't correctly crop the image", "label": {"api": {"Graphics.drawImage() with 8 int parameters": [[11, 52]]}}}, {"text": "It's a valid regular expression pattern, but \\s is not a valid String literal escape sequence", "label": {"api": {"It's a valid regular expression pattern": [[0, 38]]}}}, {"text": "For this purposes, you can use an ArrayList which is dynamic", "label": {"api": {"ArrayList": [[34, 42]]}}}, {"text": "I suggest you use a ScheduledExecutorService and scheduleWithFixedDelay(Runnable, long, long, TimeUnit)", "label": {"api": {"ScheduledExecutorService": [[20, 43]], "scheduleWithFixedDelay(Runnable, long, long, TimeUnit)": [[49, 102]]}}}, {"text": "please use SimpleDateFormat to parse String To Date", "label": {"api": {"SimpleDateFormat": [[11, 26]]}}}, {"text": "Now, the method of Path involved is this one", "label": {"api": {"this one": [[36, 43]]}}}, {"text": "I came across this link http://docs.oracle.com/javase/7/docs/api/java/awt/image/Raster.html specifically for this method createPackedRaster()(the second one)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/image/Raster.html": [[24, 90]]}}}, {"text": "First of all read Oracle docs on exists", "label": {"api": {"exists": [[33, 38]]}}}, {"text": "Answer yourself what does getAbsoluteFile do", "label": {"api": {"getAbsoluteFile": [[26, 40]]}}}, {"text": "If not, use simpliest easy to write easy to read method folder.exists()", "label": {"api": {"exists": [[63, 68]]}}}, {"text": "Use ListIterator to add or remove concurrently while iterating arrayList", "label": {"api": {"ListIterator": [[4, 15]]}}}, {"text": "By using ListIterator you can add remove object from the list", "label": {"api": {"ListIterator": [[9, 20]]}}}, {"text": "Basically you need to parse your date in the format provided and from one format (inputDateFormat) you need to convert it to the other format (done by outputDateFormat)", "label": {"api": {"parse": [[22, 26]], "format": [[45, 50], [74, 79], [135, 140]]}}}, {"text": "I read the Javadoc of IntStream::noneMatch", "label": {"api": {"IntStream::noneMatch": [[22, 41]]}}}, {"text": "Have you looked at Thread.setUncaughtExceptionHandler", "label": {"api": {"Thread.setUncaughtExceptionHandler": [[19, 52]]}}}, {"text": "You could install an UncaughtExceptionHandler or set the default UncaughtExceptionHandler and have it save the exception that the thread exited with", "label": {"api": {"UncaughtExceptionHandler": [[21, 44], [65, 88]], "default UncaughtExceptionHandler": [[57, 88]]}}}, {"text": "You can always implement your own FileFilter", "label": {"api": {"FileFilter": [[34, 43]]}}}, {"text": "There will probably be fewer elements actually in the temporary array than it can hold because some students won't continue, so then you can create a new array that's the right size (now that you know it) and use System.arraycopy() to copy all of the elements into the right-size array", "label": {"api": {"System.arraycopy()": [[213, 230]]}}}, {"text": "If you don't want to use the stage which is a parameter of the start() method, then don't call show() on that stage, just create your own stage and only call show() on your custom stage", "label": {"api": {"start()": [[63, 69]], "show()": [[95, 100], [158, 163]]}}}, {"text": "It doesn't look like that is supported by the official API", "label": {"api": {"official API": [[46, 57]]}}}, {"text": "The only built-in way of handling checked exceptions that can be thrown by a map operation is to encapsulate them within a CompletableFuture", "label": {"api": {"CompletableFuture": [[123, 139]]}}}, {"text": "(An Optional is a simpler alternative if you don't need to preserve the exception.)  These classes are intended to allow you to represent contingent operations in a functional way", "label": {"api": {"Optional": [[4, 11]]}}}, {"text": "The applyOrDie method takes a Function that throws an exception, and converts it into a Function that returns an already-completed CompletableFuture -- either completed normally with the original function's result, or completed exceptionally with the thrown exception", "label": {"api": {"CompletableFuture": [[131, 147]]}}}, {"text": "The second map operation illustrates that you've now got a Stream<CompletableFuture<T>> instead of just a Stream<T>", "label": {"api": {"CompletableFuture": [[66, 82]]}}}, {"text": "CompletableFuture takes care of only executing this operation if the upstream operation succeeded", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "We want to \"lift\" a normal collection operation (in this case, toList()) \"inside\" the CompletableFuture --  cfCollector() lets us do that using a supplier, accumulator, combiner, and finisher that don't need to know anything at all about CompletableFuture", "label": {"api": {"CompletableFuture": [[86, 102], [238, 254]]}}}, {"text": "A better solution would be to use PreparedStatement rather than plain string concatenation", "label": {"api": {"PreparedStatement": [[34, 50]]}}}, {"text": "Run the loop on a different thread, or (easier, safer) replace it with a Swing Timer", "label": {"api": {"Timer": [[79, 83]]}}}, {"text": "Thread in this function goes into WAITING state", "label": {"api": {"WAITING": [[34, 40]]}}}, {"text": "I think that the getOrDefault-method of the Map interface could work here", "label": {"api": {"getOrDefault": [[17, 28]]}}}, {"text": "Especially if you combine it with the Optional class as follows", "label": {"api": {"Optional": [[38, 45]]}}}, {"text": "This way you simply use getOrDefault to retrieve empty maps (which I personally like better than null values", "label": {"api": {"getOrDefault": [[24, 35]]}}}, {"text": "The Optional.ofNullable is a null-safe way of creating an Optional object and you can do what you want to do in the lambda expression", "label": {"api": {"Optional": [[4, 11], [58, 65]]}}}, {"text": "Both Optional and Map.getOrDefault are part of Java 8", "label": {"api": {"getOrDefault": [[22, 33]], "Optional": [[5, 12]]}}}, {"text": "You need to provide an override of toString() method for this", "label": {"api": {"toString()": [[35, 44]]}}}, {"text": "You can print any Object using System.out.println(Object)", "label": {"api": {"System.out.println(Object)": [[31, 56]]}}}, {"text": "If you want to customize what will be printed out, you must override the Object#toString() method, for example", "label": {"api": {"Object#toString()": [[73, 89]]}}}, {"text": "If you don't override the Object#toString() method, default implementation from Object class will be used, which has this form (class name and the hexidecimal representation of the instance hash code)", "label": {"api": {"Object#toString()": [[26, 42]]}}}, {"text": "b is of type Class, so it has the methods of the Class type, and not the methods of your Base class", "label": {"api": {"Class": [[13, 17], [49, 53]]}}}, {"text": "You can use instances of Class to invoke methods of the classes they refer to via reflection", "label": {"api": {"Class": [[25, 29]]}}}, {"text": "As explained in this article, you should use the referencedColumnName attribute of the @JoinColumn annotation to specify the referenced column of the foreign key relationship", "label": {"api": {"referencedColumnName": [[49, 68]]}}}, {"text": "This is a recursive algorithm, not to mention your task extends RecursiveTask", "label": {"api": {"RecursiveTask": [[64, 76]]}}}, {"text": "Use a BufferedImage, which does not require an observer for getWidth/getHeight", "label": {"api": {"BufferedImage": [[6, 18]]}}}, {"text": "You can implement it with a single class similar to the way java.util.PriorityQueue is implemented", "label": {"api": {"java.util.PriorityQueue": [[60, 82]]}}}, {"text": "Java offers a wide tool-set of non-blocking data exchange functionality that you can use instead, which you can find in the Concurrent Package", "label": {"api": {"Concurrent Package": [[124, 141]]}}}, {"text": "Read the JOptionPane API", "label": {"api": {"JOptionPane API": [[9, 23]]}}}, {"text": "Instead you could use startsWith method in String by iterating over the list and do something like", "label": {"api": {"startsWith": [[22, 31]]}}}, {"text": "The reporting is done to an instance of javax.xml.bind.ValidationEventHandler", "label": {"api": {"javax.xml.bind.ValidationEventHandler": [[40, 76]]}}}, {"text": "In Java documentation about TrayIcon's setImage method (http://docs.oracle.com/javase/7/docs/api/java/awt/TrayIcon.html#setImage(java.awt.Image) says", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/TrayIcon.html#setImage(java.awt.Image)": [[56, 143]]}}}, {"text": "DriverManager.getConnection() methdo returns you Connection Object and not JdbcOdbcConnection and hence you need to typecast here if you are sure, your driver is going to return an instance of JdbcOdbcConnection else you would get ClassCastException", "label": {"api": {"Object": [[60, 65]]}}}, {"text": "In order to create symmetric key, use helper class SecretKeySpec", "label": {"api": {"SecretKeySpec": [[51, 63]]}}}, {"text": "Now, in what seems like a serious design flaw, someone decided to make equals() asymmetric with java.sql.Timestamp - that is, timestamp.equals(date) could return false even if date.equals(timestamp) returns true", "label": {"api": {"equals() asymmetric with java.sql.Timestamp": [[71, 113]]}}}, {"text": "You need .hashCode()", "label": {"api": {".hashCode()": [[9, 19]]}}}, {"text": "And obey the contract; in particular, two instances of a same class which are .equals() must have the same .hashCode()", "label": {"api": {".hashCode()": [[107, 117]]}}}, {"text": "And in this case, on the result of .hashCode()", "label": {"api": {".hashCode()": [[35, 45]]}}}, {"text": "You could use String's trim() method as below", "label": {"api": {"method": [[30, 35]]}}}, {"text": "If I remember correctly, you need to start a new system Process when your launch configuration is launched (ILaunchConfigurationDelegate#launch) and then create a RuntimeProcess for this Process", "label": {"api": {"Process": [[56, 62], [170, 176], [187, 193]]}}}, {"text": "The RuntimeProcess will then generate the necessary DebugEvents and notify the corresponding ILaunch when it was terminated", "label": {"api": {"Process": [[11, 17]]}}}, {"text": "You will usually create the RuntimeProcess by calling DebugPlugin#newProcess(ILaunch, Process, String) but it is also possible to instantiate it directly (e.g", "label": {"api": {"Process": [[35, 41], [69, 75], [86, 92]]}}}, {"text": "if you want to extend the class RuntimeProcess)", "label": {"api": {"Process": [[39, 45]]}}}, {"text": "If you cannot use Java 8 so do not have the String.join method, or if you need to escape the words to prevent characters in them from being interpreted as regex metacharacters, you will need to build this regex with a manual loop", "label": {"api": {"String.join": [[44, 54]], "escape the words": [[82, 97]]}}}, {"text": "Try with keySet and values method which returns set of keys and values and then convert to arraylist with something like", "label": {"api": {"keySet": [[9, 14]]}}}, {"text": "Then you can write the byte array to a file with Files.write (or an OutputStream)", "label": {"api": {"Files.write": [[49, 59]]}}}, {"text": "For those wondering I had even harder times to get everything going when I had the result to be no-DB entity, but finally I found @SqlResultSetMapping annotation with @ConstructorResult classes subannotation to solve the issue (very hard to find solution though)", "label": {"api": {"@SqlResultSetMapping": [[130, 149]], "@ConstructorResult": [[167, 184]]}}}, {"text": "Whenever needed, you can make some modifications on your double, such as using the setRoundingMode method of DecimalFormat class, along with the RoundingMode enum", "label": {"api": {"DecimalFormat": [[109, 121]], "RoundingMode": [[86, 97], [145, 156]]}}}, {"text": "sleeping your thread isn't the best practice to take the desired result, use Timer instead", "label": {"api": {"Timer": [[77, 81]]}}}, {"text": "If the method is returning a boolean, then it's this overload", "label": {"api": {"this overload": [[48, 60]]}}}, {"text": "and not that one", "label": {"api": {"that one": [[8, 15]]}}}, {"text": "Sounds to me like you are looking for a Mutable Boolean, the simplest of which is an AtomicBoolean", "label": {"api": {"AtomicBoolean": [[85, 97]]}}}, {"text": "The reason it works this way, is that the RMI Registry is implemented itself using RMI", "label": {"api": {"Registry": [[46, 53]]}}}, {"text": "So when you call bind in one application, the actual implementation of Registry within the rmiregistry process will receive a stub object implementing all of your Remote interfaces just as with all RMI invocations passing references to remote objects", "label": {"api": {"Registry": [[71, 78]]}}}, {"text": "But note that, if you have only a single server, you can simplify everything by letting your server itself create the registry within its own JVM", "label": {"api": {"create the registry": [[107, 125]]}}}, {"text": "String.replace seems to fit the bill", "label": {"api": {"String.replace": [[0, 13]]}}}, {"text": "I already know Java's java.util.Properties", "label": {"api": {"java.util.Properties": [[22, 41]]}}}, {"text": "You don't have to use java.util.Properties;  if the data is not a flat structure, or even if it is, you may want to use XMLEncoder and XMLDecoder", "label": {"api": {"XMLEncoder": [[120, 129]], "XMLDecoder": [[135, 144]]}}}, {"text": "If the settings are non-critical (for example, window position and size), you can store them using the Preferences class", "label": {"api": {"Preferences": [[103, 113]]}}}, {"text": "You could also use Executors.newFixedThreadPool(5) to explicitly make a thread pool of size 5", "label": {"api": {"Executors.newFixedThreadPool(5)": [[19, 49]]}}}, {"text": "If the number of tasks can be really big then with thread pools you have to think about limiting the number of tasks that can be queued up, perhaps using a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[156, 173]]}}}, {"text": "To prevent subtle problems, you should ensure you migrate from the main thread to the event dispatch thread before you use Swing components, by calling SwingUtilities.invokeLater from main", "label": {"api": {"SwingUtilities.invokeLater": [[152, 177]]}}}, {"text": "The Set-implementation HashSet is expected to find values by O(1)", "label": {"api": {"HashSet": [[23, 29]]}}}, {"text": "If used properly the contains-method of HashSet should work as expected (that is really fast ;)", "label": {"api": {"HashSet": [[40, 46]]}}}, {"text": "Personally I would suggest using CopyOnWriteArrayList() as it's a bit faster than ConcurrentHashMap", "label": {"api": {"CopyOnWriteArrayList()": [[33, 54]]}}}, {"text": "The only thing I can tell from what you post, is that the Exception is a RunTimeExcpetion, because your method does not declare any Exception", "label": {"api": {"RunTimeExcpetion": [[73, 88]]}}}, {"text": "You should use the get() method instead because this one use the already collected result from your Future object (see Future#get() method)", "label": {"api": {"Future#get() method": [[119, 137]]}}}, {"text": "Check this for more", "label": {"api": {"Check this for more": [[0, 18]]}}}, {"text": "Have you looked at classes in the javax.imageio package (http://docs.oracle.com/javase/7/docs/api/javax/imageio/package-summary.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/imageio/package-summary.html": [[57, 131]]}}}, {"text": "The class ImageWriteParam (http://docs.oracle.com/javase/7/docs/api/javax/imageio/ImageWriteParam.html) lets you customize the compression settings", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/imageio/ImageWriteParam.html": [[27, 101]]}}}, {"text": "You can use Collections.frequency", "label": {"api": {"Collections.frequency": [[12, 32]]}}}, {"text": "Try printing the path", "label": {"api": {"path": [[17, 20]]}}}, {"text": "The ones I know so far is the InternalError, the OutOfMemoryError, the StackOverflowError, and the UnknownError", "label": {"api": {"InternalError": [[30, 42]], "OutOfMemoryError": [[49, 64]], "StackOverflowError": [[71, 88]], "UnknownError": [[99, 110]]}}}, {"text": "In this code, I'm using a  BufferedInputStream in java, and the setup looks like this", "label": {"api": {"BufferedInputStream": [[27, 45]]}}}, {"text": "The javadoc of KeyEvent says", "label": {"api": {"javadoc of KeyEvent": [[4, 22]]}}}, {"text": "However, all key press events have a consistent extended key code that can be found using the utility method KeyEvent.getExtendedKeyCodeForChar() and compared to the one from the key event", "label": {"api": {"KeyEvent.getExtendedKeyCodeForChar()": [[109, 144]]}}}, {"text": "Check the contract of Object#equals", "label": {"api": {"Object#equals": [[22, 34]]}}}, {"text": "The Set-implementation HashSet is expected to find values by using the hashCode", "label": {"api": {"HashSet": [[23, 29]]}}}, {"text": "If used properly the HashSet will work as expected", "label": {"api": {"HashSet": [[21, 27]]}}}, {"text": "You can use Arrays.toString for a readable result (make sure to import java.util.Arrays)", "label": {"api": {"Arrays.toString": [[12, 26]]}}}, {"text": "Collections is the name of a class", "label": {"api": {"Collections": [[0, 10]]}}}, {"text": "emptyList() is the name of a static method defined in the Collections class (Javadoc)", "label": {"api": {"Collections": [[58, 68]], "emptyList()": [[0, 10]]}}}, {"text": "It is a generic method, and the <String> in Collections.<String>emptyList() specifies the generic type argument", "label": {"api": {"Collections": [[44, 54]], "emptyList()": [[64, 74]]}}}, {"text": "You could use a second reader to read the stderr stream from the process, but generally it's easier to combine the streams using ProcessBuilder#redirectErrorStream, which redirect the stderr through the processes InputStream", "label": {"api": {"ProcessBuilder#redirectErrorStream": [[129, 162]]}}}, {"text": "The above solution will heavily rely on file access so take a look at java.nio for efficient access", "label": {"api": {"java.nio": [[70, 77]]}}}, {"text": "Try using replaceAll api of String like", "label": {"api": {"replaceAll": [[10, 19]]}}}, {"text": "YYYY is for week Year (see javadoc) which might, depending on your Locale, sometimes return the 53rd week of the past year when using early jan dates or the 1st week of the new year when using late december dates", "label": {"api": {"see javadoc": [[23, 33]]}}}, {"text": "\\G in Java was added in Java 6 to mimic the Perl construct", "label": {"api": {"\\G in Java was added in Java 6": [[0, 29]]}}}, {"text": "Math.ceil() only accepts type double, but that's not a problem because Java can perform the conversion automatically and turn the int 0 to a double 0.0", "label": {"api": {"Math.ceil()": [[0, 10]]}}}, {"text": "Using javafx.scene.web.WebEngine#setOnAlert, i'm able to access alert calls made in Javascript via Java", "label": {"api": {"javafx.scene.web.WebEngine#setOnAlert": [[6, 42]]}}}, {"text": "You're looking for a List implementation (LinkedList, ArrayList, etc)", "label": {"api": {"List": [[21, 24], [48, 51], [59, 62]]}}}, {"text": "In that case I'd keep the trades in a dequeue", "label": {"api": {"dequeue": [[38, 44]]}}}, {"text": "If you want several lines to be printed in edit use JTextArea", "label": {"api": {"JTextArea": [[52, 60]]}}}, {"text": "In your case you can use jTextArea.append(string) (note", "label": {"api": {"jTextArea.append(string)": [[25, 48]]}}}, {"text": "jTextArea is an object of class JTextArea, and string is an object of class String)", "label": {"api": {"JTextArea": [[32, 40]]}}}, {"text": "When you close your scanner it also closes System.in input stream, you are using it again, but it's closed, so   when you try to use Scanner again, no open System.in stream is found", "label": {"api": {"close": [[9, 13], [36, 40], [100, 104]], "System.in": [[43, 51], [156, 164]]}}}, {"text": "You can use a HashSet, to check for a word existence in O(1)", "label": {"api": {"HashSet": [[14, 20]]}}}, {"text": "You can use java.util.Locale", "label": {"api": {"java.util.Locale": [[12, 27]]}}}, {"text": "If by \"language\", you mean Locale, you can use the following code", "label": {"api": {"Locale": [[27, 32]]}}}, {"text": "Try using string's CASE_INSENSITIVE_ORDER", "label": {"api": {"CASE_INSENSITIVE_ORDER": [[19, 40]]}}}, {"text": "If what you mean to check are the metadata of the file, then use methods in the Files class dedicated to this, for instance", "label": {"api": {"Files": [[80, 84]]}}}, {"text": "That's because available() doesn't do what you think it does", "label": {"api": {"available()": [[15, 25]]}}}, {"text": "You should simply read until the number of bytes read, returned by read(), is -1", "label": {"api": {"read()": [[67, 72]]}}}, {"text": "Or even simpler, use Files.copy()", "label": {"api": {"Files.copy()": [[21, 32]]}}}, {"text": "Adding all the numbers and then using Collections.shuffle would probably be easiest", "label": {"api": {"Collections.shuffle": [[38, 56]]}}}, {"text": "From the InputStream javadoc you can read that the mark() method does nothing", "label": {"api": {"InputStream javadoc": [[9, 27]], "mark()": [[51, 56]]}}}, {"text": "And it is not being overloaded in FileInputStream, neither is markSupported() that returns false, also for FileInputStream", "label": {"api": {"markSupported()": [[62, 76]]}}}, {"text": "However, you can wrap it in a BufferedInputStream which does implement mark()", "label": {"api": {"mark()": [[71, 76]], "BufferedInputStream": [[30, 48]]}}}, {"text": "One way is via c.newInstance, which if this is a JavaBean should be all you need (it attempts to invoke the zero-args constructor for the class)", "label": {"api": {"c.newInstance": [[15, 27]]}}}, {"text": "Otherwise, you need to find an appropriate constructor via getDeclaredConstructor/getDeclaredConstructors or similar and then invoke them to get an instance", "label": {"api": {"getDeclaredConstructor": [[59, 80], [82, 103]], "getDeclaredConstructors": [[82, 104]]}}}, {"text": "If i use c.newInstance it won't \"kill\"/clear my Field's values", "label": {"api": {"c.newInstance": [[9, 21]]}}}, {"text": "Your Field instance doesn't have values; the instance you get from c.newInstance does", "label": {"api": {"c.newInstance": [[67, 79]]}}}, {"text": "In javax.script.ScriptEngineFactory there is a method getParameter(String key)", "label": {"api": {"getParameter(String key)": [[54, 77]]}}}, {"text": "In your servlet you can use a ThreadLocal to hold a seperate engine for each thread allowing to reuse the engine for subsequent requests served by the same thread", "label": {"api": {"ThreadLocal": [[30, 40]]}}}, {"text": "The easiest way to do so is to use the provided Arrays.deepToString() which searches for arrays within the array", "label": {"api": {"Arrays.deepToString()": [[48, 68]]}}}, {"text": "In addition, it works differently for infinite numbers and NaN", "label": {"api": {"NaN": [[59, 61]]}}}, {"text": "For example, the read() method of the InputStream class is an abstract method", "label": {"api": {"is an abstract method": [[56, 76]]}}}, {"text": "Read the javadoc", "label": {"api": {"Read the javadoc": [[0, 15]]}}}, {"text": "Alternatively if you are trying to keep multiple triangles on the screen, for example, to add a new one at every click, you should add them into a list of shapes which will be drawn whenever the component needs to be repainted", "label": {"api": {"list": [[147, 150]]}}}, {"text": "Then to control the set of shapes that is on screen, manipulate the contents of the list, and call repaint();", "label": {"api": {"list": [[84, 87]]}}}, {"text": "ArrayDeque is not thread safe", "label": {"api": {"ArrayDeque": [[0, 9]]}}}, {"text": "LinkedBlockingDeque), which will also allow you to avoid your busy wait for the queue to become non-empty", "label": {"api": {"LinkedBlockingDeque": [[0, 18]]}}}, {"text": "Check out the CompletableFuture JavaDocs for more info", "label": {"api": {"CompletableFuture JavaDocs": [[14, 39]]}}}, {"text": "If you are using a BufferedWriter I think it's ok to call write many times", "label": {"api": {"BufferedWriter": [[19, 32]]}}}, {"text": "The Map data structure is what you need", "label": {"api": {"Map": [[4, 6]]}}}, {"text": "Starting from Java7 you can use Files.move", "label": {"api": {"Files.move": [[32, 41]]}}}, {"text": "If you wish to start a job from within a Java process I suggest that you use a Timer and schedule a TimerTask that does the job for you", "label": {"api": {"Timer": [[79, 83], [100, 104]]}}}, {"text": "The problem is due to the method prototype", "label": {"api": {"the method prototype": [[22, 41]]}}}, {"text": "According to the documentation for InetAddress, it doesn't seem like this class cares about the port", "label": {"api": {"InetAddress": [[35, 45]]}}}, {"text": "You can put them into a List and then use Collections.shuffle method", "label": {"api": {"Collections.shuffle": [[42, 60]]}}}, {"text": "Read your numbers into an array, and java.util.Random to access your array and print as you wish (use a nested loop for printing 'x' number of times per access)", "label": {"api": {"java.util.Random": [[37, 52]]}}}, {"text": "If you just want to print randomly, you can use Collections.shuffle to shuffle and then simply iterate through the structure and print", "label": {"api": {"Collections.shuffle": [[48, 66]]}}}, {"text": "Java 8 proposes Optional<T> to explicitly handle in one expression what otherwise could be a null", "label": {"api": {"Optional<T>": [[16, 26]]}}}, {"text": "Math.random() produces a random number in the range [0,1)", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "A great example from the JDK is StringBuilder", "label": {"api": {"StringBuilder": [[32, 44]]}}}, {"text": "Collections.sort() expects a List as an argument; and a List is supposed to be able to produce a ListIterator", "label": {"api": {"Collections.sort() expects a List as an argument": [[0, 47]], "ListIterator": [[97, 108]]}}}, {"text": "Except that SetUniqueList returns a List whose ListIterator implementation does not support the .set() operation", "label": {"api": {"ListIterator": [[47, 58]], ".set()": [[96, 101]]}}}, {"text": "Try using lastModified method of file object like", "label": {"api": {"lastModified": [[10, 21]]}}}, {"text": "To be more general, SortedSet is the more general interface that offers uniqueness and ordering", "label": {"api": {"SortedSet": [[20, 28]]}}}, {"text": "However, if you use the right implementation (that is, TreeMap as spelled out by the docs), then you're guaranteed a natural ordering and no duplicate entries", "label": {"api": {"TreeMap": [[55, 61]]}}}, {"text": "But, like TreeMap, TreeSet is a set that can be used to store things in a natural order with no duplicates", "label": {"api": {"TreeMap": [[10, 16]], "TreeSet": [[19, 25]]}}}, {"text": "Consider using ThreadPoolExecutor instead", "label": {"api": {"ThreadPoolExecutor": [[15, 32]]}}}, {"text": "Specifically you may want to have custom RejectedExecutionHandler; as you are dealing with file system read there are good chances of long running / hung threads  which eventually may cause app irresponsive", "label": {"api": {"RejectedExecutionHandler": [[41, 64]]}}}, {"text": "Use Platform.runLater() for your second Label", "label": {"api": {"Platform.runLater()": [[4, 22]]}}}, {"text": "String.getBytes in Java uses the default encoding of the platform", "label": {"api": {"String.getBytes": [[0, 14]]}}}, {"text": "Try using replaceAll method of String so it removes all the characters or numbers from your String like", "label": {"api": {"replaceAll": [[10, 19]]}}}, {"text": "Java's String class has a startsWith method that allows you to test if the String starts with a given prefix or not", "label": {"api": {"String class has a startsWith": [[7, 35]]}}}, {"text": "Please take a look on method description in java docs in order to understand what's going wrong", "label": {"api": {"method description": [[22, 39]]}}}, {"text": "You seem to be expecting that InputStream.read() will return 1 when it's reached the end of its content - it won't, it'll return -1", "label": {"api": {"InputStream.read()": [[30, 47]]}}}, {"text": "You can configure whether redirects are automatically followed; see http://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html#setFollowRedirects%28boolean%29", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html#setFollowRedirects%28boolean%29": [[68, 171]]}}}, {"text": "Consider using a CountDownLatch", "label": {"api": {"CountDownLatch": [[17, 30]]}}}, {"text": "When your loading thread is done, it can call countDown", "label": {"api": {"countDown": [[46, 54]], "count": [[46, 50]]}}}, {"text": "Your monitor thread can either poll count or simply await completion", "label": {"api": {"count": [[36, 40]], "await": [[52, 56]]}}}, {"text": "What you want is @ElementCollection", "label": {"api": {"@ElementCollection": [[17, 34]]}}}, {"text": "You can use StringTokenizer in java to devide your string into words", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "Take a look at this Java StringTokenizer tutorial for further information", "label": {"api": {"StringTokenizer": [[25, 39]]}}}, {"text": "File has the static Strings separator and pathSeparator", "label": {"api": {"separator": [[28, 36]], "pathSeparator": [[42, 54]]}}}, {"text": "The separator is a \"default name-separator character\" and the pathSeparator is a \"path-separator character\"", "label": {"api": {"separator": [[4, 12], [33, 41], [87, 95]], "pathSeparator": [[62, 74]]}}}, {"text": "String.replace returns the new string", "label": {"api": {"String.replace": [[0, 13]]}}}, {"text": "Using Bindings.bindBidirectional may be a solution but I don't know how", "label": {"api": {"Bindings.bindBidirectional": [[6, 31]]}}}, {"text": "Create a Class which encapsulates all of your state variables, then use AtomicReference to refer to them", "label": {"api": {"AtomicReference": [[72, 86]]}}}, {"text": "I'm very well aware of when a ByteBuffer needs to be flipped", "label": {"api": {"ByteBuffer": [[30, 39]]}}}, {"text": "You can verify this by calling the Math.ulp method (unit in the last place)", "label": {"api": {"Math.ulp method": [[35, 49]]}}}, {"text": "Note that pow here takes an int, not another BigDecimal", "label": {"api": {"pow here takes an int": [[10, 30]]}}}, {"text": "You can reassign the streams using System.setIn and System.setOut", "label": {"api": {"System.setIn": [[35, 46]], "System.setOut": [[52, 64]]}}}, {"text": "I want to make the pieces fall a tad faster after every 60 seconds, and for this I'm using a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[93, 116]]}}}, {"text": "So, is there a way to pause and resume a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[41, 64]]}}}, {"text": "Try using replace api as you are not using regex with your pattern as below", "label": {"api": {"replace": [[10, 16]]}}}, {"text": "scheduleAtFixedRate should receive a Runnable, not a void value", "label": {"api": {"Runnable": [[37, 44]]}}}, {"text": "You could, for example, convert your ws1TI function to a Runnable like so", "label": {"api": {"Runnable": [[57, 64]]}}}, {"text": "The correct answer is getBusinessObject", "label": {"api": {"getBusinessObject": [[22, 38]]}}}, {"text": "I have a java.net.URL object in a Spring 4 @RestController", "label": {"api": {"java.net.URL": [[9, 20]]}}}, {"text": "I found out that java.net.URL does hostname resolution to compare to other URL object", "label": {"api": {"java.net.URL": [[17, 28]]}}}, {"text": "Do you use Serializable interface for the Map object", "label": {"api": {"Serializable": [[11, 22]]}}}, {"text": "use StringBuilder.deleteCharAt(int index) but beware that you either have to put it back or create a new StringBuilder from the string to test", "label": {"api": {"StringBuilder.deleteCharAt(int index)": [[4, 40]]}}}, {"text": "The Course class is implementing java.io.Serializable", "label": {"api": {"java.io.Serializable": [[33, 52]]}}}, {"text": "The difference between match() and find() is, that match() method attempts to match the entire region of the tested string against pattern, while find() attempts to find next subsequence of the tested string that matches the pattern (see https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html": [[238, 307]]}}}, {"text": "It just means that the documentation of DataInput.readBoolean contains more detail", "label": {"api": {"DataInput.readBoolean": [[40, 60]]}}}, {"text": "If you get the FileChannel associated with the FileInputStream you can set the position on the channel, which will affect the next read from the stream", "label": {"api": {"get the FileChannel": [[7, 25]], "position": [[79, 86]]}}}, {"text": "Similarly, if you use a RandomAccessFile, you can seek to a desired position in file", "label": {"api": {"position": [[68, 75]], "RandomAccessFile": [[24, 39]], "seek": [[50, 53]]}}}, {"text": "System#arraycopy gets around this by cheating, a little bit", "label": {"api": {"System#arraycopy": [[0, 15]]}}}, {"text": "In that case, the best match is to a BiConsumer", "label": {"api": {"BiConsumer": [[37, 46]]}}}, {"text": "Instead, use a JToggleButton, which will allow you to control each button's appearance based on its selected state using setSelected()", "label": {"api": {"JToggleButton": [[15, 27]]}}}, {"text": "Try using the Scanner class", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "There is a method in System.in called available() which you can use", "label": {"api": {"available()": [[38, 48]]}}}, {"text": "The javadoc for java.util.TreeSet says", "label": {"api": {"The javadoc for java.util.TreeSet": [[0, 32]]}}}, {"text": "v = (((g)^u1(y)^u2) mod p) mod q, where g, u1, y, u2, p and q are all BigInteger objects, I got stuck with g^u1 and y^u2, I want to use the pow method to do the calculation, but this method only accepts int parameter, so I'm not able to calculate g^u1 like this", "label": {"api": {"pow": [[140, 142]]}}}, {"text": "The closes data type is binary, but it's translated to a ByteBuffer in Java", "label": {"api": {"ByteBuffer": [[57, 66]]}}}, {"text": "The problem with a ByteBuffer is that the content must be preloaded into memory because it's backed by a byte array - not really streaming", "label": {"api": {"ByteBuffer": [[19, 28]]}}}, {"text": "You can also use PreparedStatement (An object that represents a precompiled SQL statement.) to execute batch updates, which enables you to reuse same sql statement with different parameters", "label": {"api": {"PreparedStatement": [[17, 33]]}}}, {"text": "Check out setOnMousePressed and setOnMouseReleased", "label": {"api": {"setOnMousePressed": [[10, 26]], "setOnMouseReleased": [[32, 49]]}}}, {"text": "Here are some of the methods available, including map, reduce, filter, min, max etc", "label": {"api": {"Here are some of the methods available": [[0, 37]]}}}, {"text": "Check out the docs for OneToOne.mappedBy()", "label": {"api": {"OneToOne.mappedBy()": [[23, 41]]}}}, {"text": "Multiple class loaders can result in more than one superMaleList", "label": {"api": {"class loaders": [[9, 21]]}}}, {"text": "You need to implement the equals and the hashCode method in your Item class", "label": {"api": {"equals": [[26, 31]], "hashCode": [[41, 48]]}}}, {"text": "You can use ByteBuffer similar to DataInputStream", "label": {"api": {"ByteBuffer": [[12, 21]]}}}, {"text": "You can schedule a Timer to keep the variable containing the desired value", "label": {"api": {"Timer": [[19, 23]]}}}, {"text": "Have a look to ExecutorService", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "The method BigDecimal.add(BigDecimal) returns a BigDecimal", "label": {"api": {"BigDecimal.add(BigDecimal)": [[11, 36]]}}}, {"text": "Instead of actively checking, use a ScheduledExecutorService that executes a Runnable in the future", "label": {"api": {"ScheduledExecutorService": [[36, 59]]}}}, {"text": "If the resources are things like images etc., that can be used by java classes that know how to access resource URLs (that is, get the data from the jar when they are given its location in the jar), you can use the ClassLoader.getResource(String) method to get the URL and pass it to the class that handles them", "label": {"api": {"Class": [[215, 219]], "ClassLoader": [[215, 225]]}}}, {"text": "If you have anything you want to do directly with the data in the resource, which you would usually do by reading it from a file, you can instead use the method ClassLoader.getResourceAsStream(String)", "label": {"api": {"Class": [[161, 165]], "ClassLoader": [[161, 171]]}}}, {"text": "Note that I used the getResourceAsStream() method from Class rather than ClassLoader", "label": {"api": {"Class": [[55, 59], [73, 77]], "ClassLoader": [[73, 83]]}}}, {"text": "Please read the relevant documentation for Class and ClassLoader", "label": {"api": {"Class": [[43, 47], [53, 57]], "ClassLoader": [[53, 63]]}}}, {"text": "readFully is not a documented function in the Java 8 Nashorn API", "label": {"api": {"Java 8 Nashorn API": [[46, 63]]}}}, {"text": "I think you need to use the String.format(Locale, String, ...) method with an English Locale instance, probably with Locale.ENGLISH", "label": {"api": {"String.format(Locale, String, ...)": [[28, 61]]}}}, {"text": "See more at ProcessBuilder", "label": {"api": {"ProcessBuilder": [[12, 25]]}}}, {"text": "The WeakHashMap will have its keys reclaimed by the garbage collector when they are no longer strongly reachable", "label": {"api": {"WeakHashMap": [[4, 14]]}}}, {"text": "The value objects in a WeakHashMap are held by ordinary strong references", "label": {"api": {"WeakHashMap": [[23, 33]]}}}, {"text": "Use Pattern.quote() to quote all the special characters and make them matches literal character", "label": {"api": {"Pattern.quote()": [[4, 18]]}}}, {"text": "Therefore, regardless of how the Pattern.quote() function works in ICU (adding escape \\ or using quoting \\Q...\\E construct), it should work similar to the reference implementation (Java 6) in this regard", "label": {"api": {"Pattern.quote()": [[33, 47]]}}}, {"text": "You should do connection.getResponseCode and read the Location header to know where to go next", "label": {"api": {"connection.getResponseCode": [[14, 39]]}}}, {"text": "You can get all headers with connection.getHeaderFields()", "label": {"api": {"connection.getHeaderFields()": [[29, 56]]}}}, {"text": "You're using a constructor of String which only takes a byte array (String(byte[] bytes)) which according to the javadocs", "label": {"api": {"String(byte[] bytes)": [[68, 87]]}}}, {"text": "Instead when converting a byte array to String, specify the encoding you wish to use explicitly with the String(byte[] bytes, Charset charset) constructor", "label": {"api": {"String(byte[] bytes, Charset charset)": [[105, 141]]}}}, {"text": "Maybe the answer with the CharsetDecoder of this question helps", "label": {"api": {"CharsetDecoder": [[26, 39]]}}}, {"text": "You could change the CodingErrorAction to REPLACE and set a replacement in my example \"?\"", "label": {"api": {"CodingErrorAction": [[21, 37]]}}}, {"text": "One class that was introduced was the DateTimeFormatter which has one big upside compared to e.g", "label": {"api": {"DateTimeFormatter": [[38, 54]]}}}, {"text": "SimpleDateFormatter - DateTimeFormatter it is thread-safe", "label": {"api": {"DateTimeFormatter": [[22, 38]]}}}, {"text": "Instead I would use the DateTimeFormatter to parse the string and then output it in the required format", "label": {"api": {"DateTimeFormatter": [[24, 40]]}}}, {"text": "You can use Class#newInstance", "label": {"api": {"Class#newInstance": [[12, 28]]}}}, {"text": "It may be clearer, however, to use ClassLoader.getResoucreAsStream rather than Class.getResourceAsStream", "label": {"api": {"ClassLoader.getResoucreAsStream": [[35, 65]], "Class.getResourceAsStream": [[79, 103]]}}}, {"text": "Reason why it works is that List implementations should implement equals comparing the contents, thus Stream.distinct() will work with lists", "label": {"api": {"should": [[49, 54]]}}}, {"text": "That's if getAmount() returns a float - that means you won't be able to call methods on it directly, but Float.compare is a handy workaround", "label": {"api": {"Float.compare": [[105, 117]]}}}, {"text": "According to the documentation, DTD validation always takes place, even when you tell it not to", "label": {"api": {"DTD validation always takes place": [[32, 64]]}}}, {"text": "Regarding your second point  request.getRemoteAddr() is always returning the same IP address from diffrent client machines, If you see the API Docs,it clearly specifies that this api call would return client address or address of last proxy that sent the request, and in your case it is load balancer(i assumed as per your description),which is why you are receiving same IP address", "label": {"api": {"API Docs": [[139, 146]]}}}, {"text": "Use an ExecutorService", "label": {"api": {"ExecutorService": [[7, 21]]}}}, {"text": "The range of Math.random() isn't 0.0 through 0.9, it's 0.0 through the greatest possible double less than 1.0, about 0.9999999999999999 or so", "label": {"api": {"Math.random()": [[13, 25]]}}}, {"text": "A final remark is that Java has a decent Random class, that provides some functionality to generate integer numbers", "label": {"api": {"Random": [[41, 46]]}}}, {"text": "For instance nextInt where you can give the maximum (exclusive) number", "label": {"api": {"nextInt": [[13, 19]]}}}, {"text": "as doc says at http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html#iterator%28%29", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html#iterator%28%29": [[15, 98]]}}}, {"text": "Can see http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor%28%29 for a quick single threaded pool to test this", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor%28%29": [[8, 113]]}}}, {"text": "In general List are easier to use because you have utility methods like List.contains(), but Lists cannot be used for primitive types", "label": {"api": {"List.contains()": [[72, 86]]}}}, {"text": "See the documentation for System.arraycopy for full details", "label": {"api": {"documentation for System.arraycopy": [[8, 41]]}}}, {"text": "The latter binds it to a Canvas instance with user32.SetParent via JNA, and the display works perfectly", "label": {"api": {"Canvas": [[25, 30]]}}}, {"text": "The applet reports Component#isFocusOwner as false, and requestFocusInWindow does not make it the focus owner, returning false", "label": {"api": {"Component#isFocusOwner": [[19, 40]], "requestFocusInWindow": [[56, 75]]}}}, {"text": "As of Java 8 the easiest thing to do is use getOrDefault() which lets you specify a default value at the get-site", "label": {"api": {"getOrDefault()": [[44, 57]]}}}, {"text": "you'll be reading values from the properties object more than once) you can use the built-in support for default values -notice the constructor that takes a default Properties object", "label": {"api": {"constructor": [[132, 142]]}}}, {"text": "Just notice that this isn't identical to how Map's constructor works - the defaults are left as a separate map, and only .getProperty() also queries the defaults; the methods defined in Map like .get() don't", "label": {"api": {"constructor": [[51, 61]]}}}, {"text": "Use the truncatedTo-method on the Instant object to only get the number of days", "label": {"api": {"truncatedTo": [[8, 18]]}}}, {"text": "Using the JAXB class the name of the root element should be irrelevant, you can change it and still unmarshal will succeed", "label": {"api": {"JAXB": [[10, 13]]}}}, {"text": "To go around this, what you could do would be to use the StringBuilder class, something like so", "label": {"api": {"StringBuilder": [[57, 69]]}}}, {"text": "BufferedReader.readLine() is declared to return a String which can be 1 GB long", "label": {"api": {"BufferedReader.readLine()": [[0, 24]]}}}, {"text": "The implementation of BufferedReader.readLine() uses a StringBuffer which also builds the String in a char array so that also doesn't prevent that the line to be 1GB long", "label": {"api": {"BufferedReader.readLine()": [[22, 46]], "StringBuffer": [[55, 66]]}}}, {"text": "The internal buffer of BufferedReader does not limit the maximum line size, it is just used to speed up certain operations and to support the Reader.mark() and Reader.reset() operations", "label": {"api": {"Reader.mark()": [[142, 154]], "Reader.reset()": [[160, 173]]}}}, {"text": "String.getBytes() will use the platform's default encoding (not necessarily UTF-8) to convert the characters of the String to bytes", "label": {"api": {"String.getBytes()": [[0, 16]]}}}, {"text": "Quoting from the javadoc of String.getBytes()", "label": {"api": {"String.getBytes()": [[28, 44]]}}}, {"text": "The Java java.sql.Timestamp and java.util.Date classes represent an instance of time regardless of the time zone (or rather in a fixed, UTC timezone)", "label": {"api": {"java.sql.Timestamp": [[9, 26]], "java.util.Date": [[32, 45]]}}}, {"text": "This is specified in PreparedStatement.setTimeStamp", "label": {"api": {"PreparedStatement.setTimeStamp": [[21, 50]]}}}, {"text": "This will invoke the Date(long date) constructor, resulting in a date near 1970/01/01", "label": {"api": {"Date(long date)": [[21, 35]]}}}, {"text": "You can create your own Comparator that ignores the \"SEC\" part and treats the rest of it as a Double", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "I implemented a program TreeScanner, to print information about all nodes in AST", "label": {"api": {"TreeScanner": [[24, 34]]}}}, {"text": "In class org.eclipse.jdt.core.dom we have FieldAccess which is called in both above cases for YYY, but seems TreeScanner in Javac has no similar method", "label": {"api": {"TreeScanner": [[109, 119]]}}}, {"text": "To set the timezone used by SimpleDateFormat (for instance, to GMT), use its setTimeZone method (or setCalendar if you already have a Calendar around you want to use)", "label": {"api": {"setTimeZone": [[77, 87]], "setCalendar": [[100, 110]]}}}, {"text": "You have to override getColumnClass() method in your table model implementation and return Icon.class for the appropriate column index in order to allow the table to apply the right TableCellRenderer", "label": {"api": {"TableCellRenderer": [[182, 198]]}}}, {"text": "No, the documentation (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html) states that a blocking queue needs to be used", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html": [[23, 107]]}}}, {"text": "You could use an Exchanger", "label": {"api": {"Exchanger": [[17, 25]]}}}, {"text": "You could use the MessageFormat class", "label": {"api": {"MessageFormat class": [[18, 36]]}}}, {"text": "You could look into MessageFormat you can create one instance for a pattern and use it like this", "label": {"api": {"MessageFormat": [[20, 32]]}}}, {"text": "Assuming that you're using Java's API for Processes, you should keep a reference to the Process object and write out to it's stdin via Process#getOutputStream", "label": {"api": {"Process#getOutputStream": [[135, 157]]}}}, {"text": "My bet is on the call to Character.isSpaceChar - suprisingly, GWT doesn't emulate it and this could lead to this class not being serializable", "label": {"api": {"Character.isSpace": [[25, 41]]}}}, {"text": "GWT does however emulate the deprecated Character.isSpace - maybe it can fill its shoes for your needs", "label": {"api": {"Character.isSpace": [[40, 56]]}}}, {"text": "You'll be wanting the String.endsWith() method", "label": {"api": {"String.endsWith()": [[22, 38]]}}}, {"text": "You can use the endsWith method instead of a multi-step approach, if that's all you want to know", "label": {"api": {"endsWith": [[16, 23]]}}}, {"text": "In Java, there are the Duration and Period classes for spans of time", "label": {"api": {"Duration": [[23, 30]], "Period": [[36, 41]]}}}, {"text": "You can read the JavaDoc for Formatter in order to understand all of the possibilities with number of decimal places, comma placement, etc", "label": {"api": {"read the JavaDoc for Formatter": [[8, 37]]}}}, {"text": "The correct solution to format something like this in Swing is to use either a JTable or a GridBagLayout", "label": {"api": {"JTable": [[79, 84]]}}}, {"text": "Instead get yourself familiar with Executor and the services that come along with it", "label": {"api": {"Executor": [[35, 42]]}}}, {"text": "A simple solution would be to make use of Java's ScheduledExecutorService and use the scheduleAtFixedRate method", "label": {"api": {"ScheduledExecutorService": [[49, 72]]}}}, {"text": "Map.put returns the previous value for the given key, not the value you're now assigning to it", "label": {"api": {"Map.put": [[0, 6]]}}}, {"text": "And the Javadoc of AutoCloseable#close()", "label": {"api": {"AutoCloseable#close()": [[19, 39]]}}}, {"text": "ReentrantLock has a constructor with a fairness parameter that should prevent starvation in your case", "label": {"api": {"constructor": [[20, 30]]}}}, {"text": "Java NIO.2 java.nio.channels.AsynchronousFileChannel can provide for such needs", "label": {"api": {"java.nio.channels.AsynchronousFileChannel": [[11, 51]]}}}, {"text": "Use this swap method", "label": {"api": {"swap": [[9, 12]]}}}, {"text": "You could convert the map to a TreeMap which can be sorted", "label": {"api": {"TreeMap": [[31, 37]]}}}, {"text": "If you use the FileWriter class it allows you to specify if you want to overwrite or append to the file in the constructor", "label": {"api": {"FileWriter": [[15, 24]]}}}, {"text": "the Executors JavaDoc or the concurrency trail from the Oracle website", "label": {"api": {"Executors JavaDoc": [[4, 20]]}}}, {"text": "You can't use ConcurrentHashMap if you need the keys sorted, but you can use ConcurrentSkipListMap, and it's likely better than trying to handle all the concurrency yourself", "label": {"api": {"ConcurrentSkipListMap": [[77, 97]]}}}, {"text": "In this exact case, use #entrySet, #keySet or #values as specified in the API docs", "label": {"api": {"API docs": [[74, 81]]}}}, {"text": "According to the getPrinterJob method description, Java uses the page settings for your default printer in your operating system", "label": {"api": {"getPrinterJob": [[17, 29]]}}}, {"text": "Have a look at LocalDate and LocalDateTime", "label": {"api": {"LocalDate": [[15, 23], [29, 37]], "LocalDateTime": [[29, 41]]}}}, {"text": "Since there's no overload for byte[] in String#valueOf method, it ends calling String#valueOf(Object obj) which will use Object#toString internally, and the string representation of an array by itself is meaningless", "label": {"api": {"String#valueOf(Object obj)": [[79, 104]]}}}, {"text": "Use new String(byte[] byteArray) instead", "label": {"api": {"new String(byte[] byteArray)": [[4, 31]]}}}, {"text": "Because both notifyAll and wait require the calling thread to own the monitor on the object the method was invoked on", "label": {"api": {"notifyAll": [[13, 21]], "wait": [[27, 30]]}}}, {"text": "Since you're invoking notifyAll and wait on this, you'll need the monitor of this object", "label": {"api": {"notifyAll": [[22, 30]], "wait": [[36, 39]]}}}, {"text": "See the docs here.", "label": {"api": {"See the docs here.": [[0, 17]]}}}, {"text": "Perhaps you could use a custom Comparator which orders Calendar or Time classes only by the fields you desire", "label": {"api": {"Comparator": [[31, 40]]}}}, {"text": "Are you looking for Array.newInstance(Class<?>, int)", "label": {"api": {"Array.newInstance(Class<?>, int)": [[20, 51]]}}}, {"text": "The mechanism is explained in the java.lang.instrument documentation", "label": {"api": {"java.lang.instrument documentation": [[34, 67]]}}}, {"text": "Use Collections.sort() to sort a collection by its natural order, or define a Comparator and pass it as the second argument", "label": {"api": {"Comparator": [[78, 87]]}}}, {"text": "You can provide your own custom Comparator", "label": {"api": {"Comparator": [[32, 41]]}}}, {"text": "The Java API for StringBuilder informs us there is a constructor available to create a StringBuffer from a String object", "label": {"api": {"StringBuilder": [[17, 29]]}}}, {"text": "You don't \"have\" to repaint the whole panel if you don't want to, you can use JPanel#repaint(int, int, int, int) which allows you to specify the area you want repainted", "label": {"api": {"JPanel#repaint(int, int, int, int)": [[78, 111]]}}}, {"text": "Basically all the resources which implements AutoCloseable interface, those resource can be closed automatically by JVM.you can check description of Close method in Java Docs as well", "label": {"api": {"Close method": [[149, 160]]}}}, {"text": "You want fullscreen, give it fullscreen with setFullScreen", "label": {"api": {"setFullScreen": [[45, 57]]}}}, {"text": "Also, if you really have to do it your way, you shouldn't use System.exit(0) but instead Platform.exit()", "label": {"api": {"Platform.exit()": [[89, 103]]}}}, {"text": "You should remove the colon from +00:00, as this format only works with the X pattern, which is not available in Java 5, only from Java SE 7", "label": {"api": {"Java 5": [[113, 118]], "Java SE 7": [[131, 139]]}}}, {"text": "Use Arrays.equals(), which actually compares the contents of both arrays", "label": {"api": {"Arrays.equals()": [[4, 18]]}}}, {"text": "Therefore use ArrayList.clone() before adding it to the master list", "label": {"api": {"ArrayList.clone()": [[14, 30]]}}}, {"text": "You'd probably be better off using a regular ThreadPoolExecutor that's shared by all of your requests", "label": {"api": {"ThreadPoolExecutor": [[45, 62]]}}}, {"text": "The invokeAll method will probably be especially helpful; You can submit all 3 requests at once, receive a List<Future<T>>, and even provide a timeout if you wish", "label": {"api": {"invokeAll": [[4, 12]]}}}, {"text": "Check out Java's BlockingQueue, it already supports this behavior", "label": {"api": {"Java's BlockingQueue": [[10, 29]]}}}, {"text": "For you structure you'll probably want to use a GridPane", "label": {"api": {"GridPane": [[48, 55]]}}}, {"text": "Because you didn't override toString(), Employee inherited Object's toString() method, which is responsible for the output you see", "label": {"api": {"Object's toString() method": [[59, 84]]}}}, {"text": "You could easily implement a solution for this with the help of filters or there may be some Java web authentication framework which already provides this functionality but I guess this would be overkill", "label": {"api": {"filters": [[64, 70]]}}}, {"text": "You should use the HBox.setHgrow method on each of the children of controlBox", "label": {"api": {"HBox.setHgrow": [[19, 31]]}}}, {"text": "Here I store the columns as an array of Strings and I store the record set as an ArrayList of String arrays", "label": {"api": {"ArrayList": [[81, 89]]}}}, {"text": "Otherwise I add the split to the ArrayList", "label": {"api": {"ArrayList": [[33, 41]]}}}, {"text": "an ArrayList) with objects of QuizEntry", "label": {"api": {"ArrayList": [[3, 11]]}}}, {"text": "If you don't like the idea of defining a seperate class just to keep an entry's question and possible answers, you can consider using a HashMap and using it in a similar manner as suggested above", "label": {"api": {"HashMap": [[136, 142]]}}}, {"text": "Read the Javadoc of Scanner#hasNext()", "label": {"api": {"Scanner#hasNext()": [[20, 36]]}}}, {"text": "Scanner#hasNext() is more convenient when reading from files where the input size is known and the end of the file marks the end of the stream", "label": {"api": {"Scanner#hasNext()": [[0, 16]]}}}, {"text": "If that doesn't work, you'll have to switch to BigInteger which allow for larger sizes", "label": {"api": {"BigInteger": [[47, 56]]}}}, {"text": "The BigInteger-based code below worked for an input of 3057", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "Or you can use the slightly less clunky BigDecimal", "label": {"api": {"BigDecimal": [[40, 49]]}}}, {"text": "In Java this can be done relatively easily by using the String.split", "label": {"api": {"String.split": [[56, 67]]}}}, {"text": "Therefore it tries to read the indices 1 till 3 (the endIndex 4 is exclusive)", "label": {"api": {"the endIndex 4 is exclusive": [[49, 75]]}}}, {"text": "ReloadableResourceBundleMessageSource is an alternative to ResourceBundleMessageSource that is capable of refreshing the messages while the application is running", "label": {"api": {"ResourceBundle": [[10, 23], [59, 72]]}}}, {"text": "When using a ResourceBundleMessageSource you need to restart your application when making changes as ResourceBundleMessageSource doesn't reload your bundles when you change them", "label": {"api": {"ResourceBundle": [[13, 26], [101, 114]]}}}, {"text": "The ResourceBundleMessageSource uses a JDK class to do its thing", "label": {"api": {"ResourceBundle": [[4, 17]]}}}, {"text": "Basically, the bundle you give to ResourceBundleMessageSource must conform to what ResourceBundle expects and processes", "label": {"api": {"ResourceBundle": [[34, 47], [83, 96]]}}}, {"text": "ResourceBundle does not know how to handle the classpath", "label": {"api": {"ResourceBundle": [[0, 13]]}}}, {"text": "ReloadableResourceBundleMessageSource on the other hand is \"smarter\" and knows how to load bundles from other places, not just the classpath", "label": {"api": {"ResourceBundle": [[10, 23]]}}}, {"text": "When you give a bundle to ReloadableResourceBundleMessageSource, since it can load files from various places, you have to be explicit with the location and say \"My file is on the classpath\"", "label": {"api": {"ResourceBundle": [[36, 49]]}}}, {"text": "Note that this uses Java 8 lambdas but the same can be implemented with Java 7 or lower by using your own interface (similar to Function) or the ones provided by Guava or Apache Commons", "label": {"api": {"Function": [[128, 135]]}}}, {"text": "Try using a Calendar instance", "label": {"api": {"Calendar": [[12, 19]]}}}, {"text": "In DataOutputStream, in reference to the oracle documentation (http://docs.oracle.com/javase/7/docs/api/java/io/DataOutputStream.html) there isn't any method named write(String) but only write(byte[]), write(byte[] b, int off, int len) and write(int b)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/DataOutputStream.html": [[63, 132]]}}}, {"text": "Alternatively, you can use 'Files.readAllBytes(..)' to read content of file", "label": {"api": {"Files.readAllBytes": [[28, 45]]}}}, {"text": "Create a subclass ofAbstractTableModel and return Boolean.class in the Method getColumnClass() for the column you want", "label": {"api": {"AbstractTableModel": [[20, 37]]}}}, {"text": "ArrayList, on the other hand, can be appended to", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "The ArrayList class is backed by an array, and the class is smart enough to create a new list and copy all of the elements into it when it needs to grow", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "You could implement this yourself, or you could take advantage of well tested and understood code and use one of the library classes (either ArrayList or LinkedList, depending on your needs)", "label": {"api": {"ArrayList": [[141, 149]], "LinkedList": [[154, 163]]}}}, {"text": "If you did stick with translation rather than relocating the center as I suggest, then read up on the bounding rectangle information in the Node documentation, especially try to understand boundsInParent", "label": {"api": {"Node": [[140, 143]], "boundsInParent": [[189, 202]]}}}, {"text": "You could use Float.parseFloat() to convert a string into a float", "label": {"api": {"Float.parseFloat()": [[14, 31]]}}}, {"text": "Collections sort is a void", "label": {"api": {"sort": [[12, 15]]}}}, {"text": "I've looked at the code and found that the most important part for handling of the locales and filenames is ResourceBundle.Control", "label": {"api": {"ResourceBundle.Control": [[108, 129]]}}}, {"text": "Try to use getDeclaredMethods and getDeclaredConstructors", "label": {"api": {"getDeclaredMethods": [[11, 28]], "getDeclaredConstructors": [[34, 56]]}}}, {"text": "Th* will return private, public, protected and package-protected methods, while getMethods and getConstructors will return only public methods", "label": {"api": {"getMethods": [[80, 89]], "getConstructors": [[95, 109]]}}}, {"text": "Change the declaration of Chart chart to XYChart chart", "label": {"api": {"XYChart": [[41, 47]]}}}, {"text": "The common superclass of LineChart and AreaChart is XYChart", "label": {"api": {"LineChart": [[25, 33]], "AreaChart": [[39, 47]], "XYChart": [[52, 58]]}}}, {"text": "You will then be able to cast it to XYChart and use the getData method on it", "label": {"api": {"XYChart": [[36, 42]]}}}, {"text": "You should use @Size to validate string length", "label": {"api": {"@Size": [[15, 19]]}}}, {"text": "You can make a HashMap<Character, Integer>", "label": {"api": {"HashMap<Character, Integer>": [[15, 41]]}}}, {"text": "I would go with MappedByteBuffer", "label": {"api": {"MappedByteBuffer": [[16, 31]]}}}, {"text": "Instead of this I would add a shutdown hook into the JVM and write the state of my program at that point", "label": {"api": {"shutdown hook": [[30, 42]]}}}, {"text": "Did you try fireTableDataChanged() on the ((DefaultTableModel)[JTable].getModel())", "label": {"api": {"fireTableDataChanged()": [[12, 33]]}}}, {"text": "Read this doc about SimpleDateFormat and parsing Date Time", "label": {"api": {"SimpleDateFormat": [[20, 35]]}}}, {"text": "Supplier#get() does not declare to throw any (checked) exceptions", "label": {"api": {"Supplier#get()": [[0, 13]]}}}, {"text": "And don't do the add while iterating over the addchck, you would only get a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[76, 106]]}}}, {"text": "But if you really want to do otherwise, the desktop application should create a ServerSocket and listen for incoming connections, or start an embedded web server", "label": {"api": {"ServerSocket": [[80, 91]]}}}, {"text": "It’s what such an audit tool has to do with a lot of methods like these declared in Lock and Condition which have similar threading-related semantics but there are also a lot of other well-known concurrency tools nowadays which have to be handled", "label": {"api": {"Lock": [[84, 87]], "Condition": [[93, 101]]}}}, {"text": "Put the files into some kind of Collection, then loop through them with, e.g., a for-loop", "label": {"api": {"Collection": [[32, 41]]}}}, {"text": "Use awaitTermination after calling shutdown(), which blocks the main thread until all threads finished", "label": {"api": {"awaitTermination": [[4, 19]]}}}, {"text": "Note that by iterating over the entries we can also set other entries having non-null keys to arbitrary maps then", "label": {"api": {"iterating over the entries": [[13, 38]], "set other entries": [[52, 68]]}}}, {"text": "Furthermore you should implement the comparable interface in your customer object; according to what you say if the customer name is the same, then they are the same customer", "label": {"api": {"comparable interface": [[37, 56]]}}}, {"text": "or implement a comparator", "label": {"api": {"comparator": [[15, 24]]}}}, {"text": "fileChooser.showOpenMultipleDialog() does not hang and is not too slow when I use it", "label": {"api": {"fileChooser.showOpenMultipleDialog()": [[0, 35]]}}}, {"text": "Choosing a few thousand files and displaying their names in a ListView took less than a second", "label": {"api": {"ListView": [[62, 69]]}}}, {"text": "Strings can be added to the String constants pool during runtime by calling intern() on them", "label": {"api": {"intern()": [[76, 83]]}}}, {"text": "Object.getClass() is final", "label": {"api": {"Object.getClass()": [[0, 16]]}}}, {"text": "You should make yourself familiar with the methods relocate, setTranslateX (Y and Z) and setLayoutX (Y and Z) of the Node class", "label": {"api": {"relocate": [[51, 58]], "setTranslateX": [[61, 73]], "setLayoutX": [[89, 98]], "Node": [[117, 120]]}}}, {"text": "getBoundsInParent and getBoundsInLocal", "label": {"api": {"getBoundsInParent": [[0, 16]], "getBoundsInLocal": [[22, 37]]}}}, {"text": "Just clear the ArrayList to remove all the elements", "label": {"api": {"clear the ArrayList": [[5, 23]]}}}, {"text": "Or use its Iterator and remove those you want", "label": {"api": {"its Iterator": [[7, 18]]}}}, {"text": "You could also just lookup the HttpServletRequest javadoc to figure which methods are all available to obtain information from the request", "label": {"api": {"HttpServletRequest javadoc": [[31, 56]]}}}, {"text": "But in order to implement the Strategy, I have to set the type of the column from the class java.sql.Types (http://docs.oracle.com/javase/6/docs/api/java/sql/Types.html?is-external=true) and there is no inet type in this column", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/sql/Types.html?is-external=true": [[108, 184]]}}}, {"text": "According to the SimpleDateFormat javadocs, if you use capital DD, which means \"day of year\", then it makes sense that adding 100 days yields day 113", "label": {"api": {"SimpleDateFormat javadocs": [[17, 41]]}}}, {"text": "I'm trying to understand how the distinct() method works", "label": {"api": {"distinct()": [[33, 42]]}}}, {"text": "HBox), and then to use CSS to set a background image on the pane", "label": {"api": {"use CSS to set a background image": [[19, 51]]}}}, {"text": "Also, in Comparator, the method is compare, not compareTo", "label": {"api": {"Comparator, the method is compare": [[9, 41]]}}}, {"text": "Use the BigInteger(String val) constructor to create the number, that is", "label": {"api": {"BigInteger(String val)": [[8, 29]]}}}, {"text": "The method getGenericType() has the return type Type which, amongst others, can be Class or ParameterizedType", "label": {"api": {"getGenericType()": [[11, 26]], "Type": [[21, 24], [48, 51], [105, 108]]}}}, {"text": "It makes sense to me that it wouldn't return ParameterizedType if invoked on a field which has no parameterized type", "label": {"api": {"Type": [[58, 61]]}}}, {"text": "what about SecureRandom", "label": {"api": {"SecureRandom": [[11, 22]]}}}, {"text": "Just use a ByteArrayInputStream to wrap the byte array which containes the data you want to upload, and then use this stream in place of the FileInputStream", "label": {"api": {"ByteArrayInputStream": [[11, 30]]}}}, {"text": "Java has a default character encoding, which it uses in contexts where a character encoding is not explicitly supplied", "label": {"api": {"default character encoding": [[11, 36]]}}}, {"text": "Using the default character encoding is often a bad idea; it is better to use an explicitly indicated encoding, or to always use the same encoding for some I/O", "label": {"api": {"default character encoding": [[10, 35]]}}}, {"text": "But one unavoidable use of the default character encoding would seem to be the character encoding used for command-line arguments", "label": {"api": {"default character encoding": [[31, 56]]}}}, {"text": "I assume the JVM uses the default character encoding for this", "label": {"api": {"default character encoding": [[26, 51]]}}}, {"text": "For example, for a producer/consumer scenario, you may well want to use BlockingQueue rather than implement it all yourself", "label": {"api": {"BlockingQueue": [[72, 84]]}}}, {"text": "You can achive that with help of CountDownLatch, simple example", "label": {"api": {"CountDownLatch": [[33, 46]]}}}, {"text": "From the documentation of setMargin", "label": {"api": {"documentation of setMargin": [[9, 34]]}}}, {"text": "You can use refresh() method from Entity Manager", "label": {"api": {"Entity Manager": [[34, 47]]}}}, {"text": "In the above code, Tuple.collectors() combines several java.util.stream.Collector instances into a single Collector that collects individual values into a Tuple", "label": {"api": {"java.util.stream.Collector": [[55, 80]]}}}, {"text": "You might as well use AbstractMap.SimpleImmutableEntry or something similar", "label": {"api": {"AbstractMap.SimpleImmutableEntry": [[22, 53]]}}}, {"text": "In IntelliJ IDEA's form designer each tab is a JPanel hence you can use the following method to set the title from within Java code", "label": {"api": {"JPanel": [[47, 52]]}}}, {"text": "The contains operation in the TreeSet, as the documentation says, \"provides guaranteed log(n) time cost\"", "label": {"api": {"as the documentation says": [[39, 63]]}}}, {"text": "You need to call request.getRequestURL()", "label": {"api": {"request.getRequestURL()": [[17, 39]]}}}, {"text": "Per the JTable API the getValueAt(...) method takes two int parameters, the first of which is the row index and the second is the column index", "label": {"api": {"JTable API": [[8, 17]]}}}, {"text": "The predefined formatter for week-dates requires the missing day-of-week", "label": {"api": {"formatter for week-dates": [[15, 38]]}}}, {"text": "From the Javadoc of ResultSet.updateRow", "label": {"api": {"Javadoc of ResultSet.updateRow": [[9, 38]]}}}, {"text": "Also look at the Javadoc of ResultSet.moveToInsertRow which you're calling in the method", "label": {"api": {"ResultSet.moveToInsertRow": [[28, 52]]}}}, {"text": "Just for completeness, when using Java 8, you can use Comparator.comparing to create a simple comparator for some attribute, e.g", "label": {"api": {"Comparator.comparing": [[54, 73]]}}}, {"text": "Comparator.comparing(Person::getAge), or using lambda, like Comparator.comparing(p -> p.age), if there is not getter method for the age", "label": {"api": {"Comparator.comparing": [[0, 19], [60, 79]]}}}, {"text": "This makes it particularly easy to chain comparators for different attributes, using thenComparing, e.g", "label": {"api": {"thenComparing": [[85, 97]]}}}, {"text": "Combine that with Arrays.sort, and you are done", "label": {"api": {"Arrays.sort": [[18, 28]]}}}, {"text": "You can try to override afterExecute method in ThreadPoolExecutor", "label": {"api": {"afterExecute": [[24, 35]]}}}, {"text": "Update the UI calling SwingUtilities.invokeLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[22, 49]]}}}, {"text": "I looked into RandomAccessFile with which I would get the pointer position and later seek to that location but I am not sure if I can read word by word", "label": {"api": {"RandomAccessFile": [[14, 29]]}}}, {"text": "The readUTF going on till it reaches the end of stream so I cannot stop where ever I want to either", "label": {"api": {"readUTF": [[4, 10]]}}}, {"text": "I looked into scanner as well but couldn't find a functionality that would let me mark positions of pointer", "label": {"api": {"scanner": [[14, 20]]}}}, {"text": "You can construct a new char array using String#toCharArray, then you'll have each char from each String that you can easily create a String from it and insert it to the new array", "label": {"api": {"String#toCharArray": [[41, 58]]}}}, {"text": "In java 8+ you can simply use Files.move from nio", "label": {"api": {"Files.move": [[30, 39]]}}}, {"text": "The problem is that the newInstance method doesn't take any arguments", "label": {"api": {"the newInstance method": [[20, 41]], "newInstance method": [[24, 41]]}}}, {"text": "On the Class object, call the getConstructors() method and loop over the returned array of Constructor objects to find the appropriate one, or call the getConstructor method, passing the Class objects representing the types of the parameters to get a specific constructor", "label": {"api": {"the getConstructors() method": [[26, 53]], "the getConstructor method": [[148, 172]]}}}, {"text": "When you have the appropriate Constructor, call its newInstance method, which does take constructor arguments in its parameters", "label": {"api": {"newInstance method": [[52, 69]]}}}, {"text": "The documentation DatatypeConverter says its supposed to throw an IllegalArgumentException if string parameter does not conform to the lexical value space defined in XML Schema Part 2", "label": {"api": {"DatatypeConverter": [[18, 34]]}}}, {"text": "Per Tom Blodget's comment below, it appears that Java actually uses UTF-16 for String literals, as detailed in the String documentation and JLS 3", "label": {"api": {"the String documentation": [[111, 134]]}}}, {"text": "For double, use Double.TYPE", "label": {"api": {"Double.TYPE": [[16, 26]]}}}, {"text": "And then there is Spliterator, and in particular its .characteristics(), one of them being that it can be CONCURRENT, or even IMMUTABLE", "label": {"api": {".characteristics()": [[53, 70]], "CONCURRENT": [[106, 115]], "IMMUTABLE": [[126, 134]]}}}, {"text": "Firstly, you're using an array of big B Byte (which is the wrapper object), rather than an array of primitive bytes", "label": {"api": {"wrapper object": [[59, 72]]}}}, {"text": "A more sophisticated way to do it would be to have the GUI pass in an instance of SwingPropertyChangeSupport", "label": {"api": {"SwingPropertyChangeSupport": [[82, 107]]}}}, {"text": "I'm using the java class Pattern to filter a search query", "label": {"api": {"java class Pattern": [[14, 31]]}}}, {"text": "Now, with regard to the output size, you could compress the output by decorating the ObjectOutputStream with Java's GZIPOutputStream", "label": {"api": {"GZIPOutputStream": [[116, 131]]}}}, {"text": "Keep in mind that you should also use Java's GZIPInputStream in order to read the serialized data", "label": {"api": {"GZIPInputStream": [[45, 59]]}}}, {"text": "For a producer/consumer problem with threads you could look at the BlockingQueue interface and its derived classes that java offers", "label": {"api": {"BlockingQueue": [[67, 79]]}}}, {"text": "You're going to need to use java.text.SimpleDateFormat", "label": {"api": {"java.text.SimpleDateFormat": [[28, 53]]}}}, {"text": "Many Java libraries are relying on the Provider.getService method, for example MessageDigest, Cipher and many others", "label": {"api": {"Provider.getService": [[39, 57]]}}}, {"text": "We solve this issue by adding Aspect which intercepts methods that eventually call to Provider.getService and cache the instances of these objects in a ThreadLocal", "label": {"api": {"Provider.getService": [[86, 104]]}}}, {"text": "Could someone explain please, why in first place the developers of the Provider.getService decided to put 'synchronized' on that method?", "label": {"api": {"Provider.getService": [[71, 89]]}}}, {"text": "You should use Arrays.toString to print the array", "label": {"api": {"Arrays.toString": [[15, 29]]}}}, {"text": "If you are interacting with JDBC and you want to insert the date into the database in the UTC time zone, you must provide a Calendar with the TimeZone of UTC on your setTimestamp and getTimestamp calls", "label": {"api": {"Calendar": [[124, 131]], "TimeZone": [[142, 149]], "setTimestamp": [[166, 177]], "getTimestamp": [[183, 194]]}}}, {"text": "If you want this to work you have to set the fixedCellSize", "label": {"api": {"fixedCellSize": [[45, 57]]}}}, {"text": "I multiplied fixedCellSize * (data size + 1.01) to include the header row", "label": {"api": {"fixedCellSize": [[13, 25]]}}}, {"text": "But you can use Instrumentation", "label": {"api": {"Instrumentation": [[16, 30]]}}}, {"text": "You can use Stream.of which returns a sequential Stream containing a single element", "label": {"api": {"Stream.of": [[12, 20]]}}}, {"text": "Use the compareToIgnoreCase method to compare your strings alphabetically", "label": {"api": {"the compareToIgnoreCase method": [[4, 33]]}}}, {"text": "The default behaviour for toString is to print the type name (as L followed by the type name), followed by @ and the hexString of the hashCode (which by default is the memory address for the object)", "label": {"api": {"default behaviour for toString": [[4, 33]]}}}, {"text": "The format portion \"EEE\" means \"Day name in week\", according to the SimpleDateFormat javadocs, but there is no day of week in the string \"11 Jan 2015 15:56:00\"", "label": {"api": {"the SimpleDateFormat javadocs": [[64, 92]]}}}, {"text": "As you can see from the javadoc, the scheduleAtFixedRate method accepts a TimerTask as a first argument", "label": {"api": {"TimerTask": [[74, 82]]}}}, {"text": "If you need to execute some code at a fixed rate, then you need to create a TimerTask object with an appropriate run implementation and pass that to scheduleAtFixedRate", "label": {"api": {"TimerTask": [[76, 84]]}}}, {"text": "Use Collections.shuffle after initializing your ArrayList with the numbers", "label": {"api": {"Collections.shuffle": [[4, 22]]}}}, {"text": "The method Arrays.asList returns a List, but it's not java.util.ArrayList", "label": {"api": {"Arrays.asList returns a List": [[11, 38]]}}}, {"text": "To make an actual java.util.ArrayList, pass the List to the proper ArrayList constructor, that takes a Collection, e.g", "label": {"api": {"ArrayList constructor": [[67, 87]]}}}, {"text": "Instead of using the annotation, your processor can implement getSupportedAnnotationTypes() to provide supported annotation type names at runtime", "label": {"api": {"getSupportedAnnotationTypes()": [[62, 90]]}}}, {"text": "@SupportedAnnotationTypes isn't really anything special, it is only used automatically when you are extending AbstractProcessor anyway", "label": {"api": {"@SupportedAnnotationTypes": [[0, 24]]}}}, {"text": "Take a look at the source code of AbstractProcessor.getSupportedAnnotationTypes()", "label": {"api": {"getSupportedAnnotationTypes()": [[52, 80]]}}}, {"text": "I think both TilePane and FlowPane come close to what you describe; the resize behavior might be slightly different to what you are looking for", "label": {"api": {"TilePane": [[13, 20]], "FlowPane": [[26, 33]]}}}, {"text": "Using a TilePane should fit your needs", "label": {"api": {"TilePane": [[8, 15]]}}}, {"text": "The implentation of a TilePane guarantees the same number of tiles on each row (excepting the last row)", "label": {"api": {"TilePane": [[22, 29]]}}}, {"text": "You must know that if a checkbox contains a very long text (relatively to your windows width), it could reduce dramatically the number of columns of your TilePane", "label": {"api": {"TilePane": [[154, 161]]}}}, {"text": "Also, it is a good practice to wrap your TilePane into a ScrollPane (allowing only vertical scrollbar) to avoid unreachable elements when the TilePane's width comes smaller", "label": {"api": {"TilePane": [[41, 48], [142, 149]]}}}, {"text": "If you just want to have access to start or end elements (Exceptions) you can use a LinkedList mostly in form of stack or queue", "label": {"api": {"LinkedList": [[84, 93]]}}}, {"text": "By default, if you don't redirect any descriptor (stdin, stdout or stderr; or whatever their equivalent on Windows is), they share it with the process which created them -- in your case, Tomcat", "label": {"api": {"stdout": [[57, 62]], "stderr": [[67, 72]]}}}, {"text": "It may be that the process tries and writes to stdout, stderr or both and that it blocks trying to write to it/them", "label": {"api": {"stdout": [[47, 52]], "stderr": [[55, 60]]}}}, {"text": "Try and redirect either to a file, for example, since with ProcessBuilder you can do so (stdout, stderr)", "label": {"api": {"stdout": [[89, 94]], "stderr": [[97, 102]]}}}, {"text": "if this is not enough you can do it programmatically inside the program to check the maximum amount of memory that the Java virtual machine will attempt to use", "label": {"api": {"maximum amount of memory that the Java virtual machine will attempt to use": [[85, 158]]}}}, {"text": "and you can also use use the class MemoryUsage to get the initial, used and max ammount that can be used for memory management", "label": {"api": {"MemoryUsage": [[35, 45]]}}}, {"text": "ServletContext.getAttribute(String name) can return a null if there if there is no such attribute of specified name", "label": {"api": {"ServletContext.getAttribute(String name)": [[0, 39]]}}}, {"text": "I don't know what that looks like in Spring-LDAP but I've done it in JNDI via LdapContext.getResponseControls()", "label": {"api": {"LdapContext.getResponseControls()": [[78, 110]]}}}, {"text": "you can do use Pattern.quote to get the literal string", "label": {"api": {"Pattern.quote": [[15, 27]]}}}, {"text": "Instead you just let Java escape all special characters using Pattern.quote in the searched string like that", "label": {"api": {"Pattern.quote": [[62, 74]]}}}, {"text": "<h:outputFormat> uses under the covers standard java.text.MessageFormat API", "label": {"api": {"java.text.MessageFormat API": [[48, 74]]}}}, {"text": "<f:convertNumber> uses under the covers the standard java.text.NumberFormat API which happens to be supported by MessageFormat as well", "label": {"api": {"java.text.NumberFormat API": [[53, 78]]}}}, {"text": "But if you want a Collection of something that contains unique references, don't use a List or an Array, use a  HashSet", "label": {"api": {"HashSet": [[112, 118]]}}}, {"text": "I have two instances of the Instant class from java.time such as this", "label": {"api": {"Instant": [[28, 34]], "from": [[42, 45]]}}}, {"text": "Now I would like to check if the two instances of Instant are actually on the same date (day, month and year match)", "label": {"api": {"Instant": [[50, 56]]}}}, {"text": "Easy I thought, let's just use the shiny new LocalDate and the universal from static method", "label": {"api": {"LocalDate": [[45, 53]], "from": [[73, 76]]}}}, {"text": "Except that universal from method is not so universal and Java complains at runtime with an exception", "label": {"api": {"from": [[22, 25]]}}}, {"text": "What is the recommended/fastest way check if two instances of Instant actually have the same date (have the same day, month, and year)", "label": {"api": {"Instant": [[62, 68]]}}}, {"text": "You need to use a a ThreadLocal storage to cache the first retrieved EntityManager", "label": {"api": {"ThreadLocal": [[20, 30]]}}}]