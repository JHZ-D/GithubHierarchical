[{"text":"The format portion \"EEE\" means \"Day name in week\", according to the SimpleDateFormat javadocs, but there is no day of week in the string \"11 Jan 2015 15:56:00\"","label":{"api":{"SimpleDateFormat":[[68,83]]}}},{"text":"As you can see from the javadoc, the scheduleAtFixedRate method accepts a TimerTask as a first argument","label":{"api":{"scheduleAtFixedRate":[[37,55]],"TimerTask":[[74,82]]}}},{"text":"If you need to execute some code at a fixed rate, then you need to create a TimerTask object with an appropriate run implementation and pass that to scheduleAtFixedRate","label":{"api":{"TimerTask":[[76,84]],"scheduleAtFixedRate":[[149,167]]}}},{"text":"Use Collections.shuffle after initializing your ArrayList with the numbers","label":{"api":{"Collections.shuffle":[[4,22]],"ArrayList":[[48,56]]}}},{"text":"The method Arrays.asList returns a List, but it's not java.util.ArrayList","label":{"api":{"Arrays.asList":[[11,23]],"java.util.ArrayList":[[54,72]]}}},{"text":"To make an actual java.util.ArrayList, pass the List to the proper ArrayList constructor, that takes a Collection, e.g","label":{"api":{"java.util.ArrayList":[[18,36]],"ArrayList":[[67,75]],"Collection":[[103,112]]}}},{"text":"Instead of using the annotation, your processor can implement getSupportedAnnotationTypes() to provide supported annotation type names at runtime","label":{"api":{"getSupportedAnnotationTypes()":[[62,90]]}}},{"text":"@SupportedAnnotationTypes isn't really anything special, it is only used automatically when you are extending AbstractProcessor anyway","label":{"api":{"@SupportedAnnotationTypes":[[0,24]],"AbstractProcessor":[[110,126]]}}},{"text":"Take a look at the source code of AbstractProcessor.getSupportedAnnotationTypes()","label":{"api":{"AbstractProcessor.getSupportedAnnotationTypes()":[[34,80]]}}},{"text":"I think both TilePane and FlowPane come close to what you describe; the resize behavior might be slightly different to what you are looking for","label":{"api":{"TilePane":[[13,20]],"FlowPane":[[26,33]]}}},{"text":"Using a TilePane should fit your needs","label":{"api":{"TilePane":[[8,15]]}}},{"text":"The implentation of a TilePane guarantees the same number of tiles on each row (excepting the last row)","label":{"api":{"TilePane":[[22,29]]}}},{"text":"You must know that if a checkbox contains a very long text (relatively to your windows width), it could reduce dramatically the number of columns of your TilePane","label":{"api":{"checkbox":[[24,31]],"TilePane":[[154,161]]}}},{"text":"Also, it is a good practice to wrap your TilePane into a ScrollPane (allowing only vertical scrollbar) to avoid unreachable elements when the TilePane's width comes smaller","label":{"api":{"TilePane":[[41,48],[142,149]],"ScrollPane":[[57,66]]}}},{"text":"If you just want to have access to start or end elements (Exceptions) you can use a LinkedList mostly in form of stack or queue","label":{"api":{"LinkedList":[[84,93]]}}},{"text":"By default, if you don't redirect any descriptor (stdin, stdout or stderr; or whatever their equivalent on Windows is), they share it with the process which created them -- in your case, Tomcat","label":{"api":{}}},{"text":"It may be that the process tries and writes to stdout, stderr or both and that it blocks trying to write to it/them","label":{"api":{}}},{"text":"Try and redirect either to a file, for example, since with ProcessBuilder you can do so (stdout, stderr)","label":{"api":{"ProcessBuilder":[[59,72]]}}},{"text":"if this is not enough you can do it programmatically inside the program to check the maximum amount of memory that the Java virtual machine will attempt to use","label":{"api":{}}},{"text":"and you can also use use the class MemoryUsage to get the initial, used and max ammount that can be used for memory management","label":{"api":{"MemoryUsage":[[35,45]]}}},{"text":"ServletContext.getAttribute(String name) can return a null if there if there is no such attribute of specified name","label":{"api":{"ServletContext.getAttribute(String name)":[[0,39]]}}},{"text":"I don't know what that looks like in Spring-LDAP but I've done it in JNDI via LdapContext.getResponseControls()","label":{"api":{"LdapContext.getResponseControls()":[[78,110]]}}},{"text":"you can do use Pattern.quote to get the literal string","label":{"api":{"Pattern.quote":[[15,27]]}}},{"text":"Instead you just let Java escape all special characters using Pattern.quote in the searched string like that","label":{"api":{"Pattern.quote":[[62,74]]}}},{"text":"<h:outputFormat> uses under the covers standard java.text.MessageFormat API","label":{"api":{"java.text.MessageFormat API":[[48,74]]}}},{"text":"<f:convertNumber> uses under the covers the standard java.text.NumberFormat API which happens to be supported by MessageFormat as well","label":{"api":{"java.text.NumberFormat API":[[53,78]],"MessageFormat":[[113,125]]}}},{"text":"But if you want a Collection of something that contains unique references, don't use a List or an Array, use a  HashSet","label":{"api":{"Collection":[[18,27]],"List":[[87,90]],"Array":[[98,102]],"HashSet":[[112,118]]}}},{"text":"I have two instances of the Instant class from java.time such as this","label":{"api":{"Instant":[[28,34]],"java.time":[[47,55]]}}},{"text":"Now I would like to check if the two instances of Instant are actually on the same date (day, month and year match)","label":{"api":{"Instant":[[50,56]]}}},{"text":"Easy I thought, let's just use the shiny new LocalDate and the universal from static method","label":{"api":{"LocalDate":[[45,53]]}}},{"text":"Except that universal from method is not so universal and Java complains at runtime with an exception","label":{"api":{"from":[[22,25]]}}},{"text":"What is the recommended/fastest way check if two instances of Instant actually have the same date (have the same day, month, and year)","label":{"api":{"Instant":[[62,68]]}}},{"text":"You need to use a a ThreadLocal storage to cache the first retrieved EntityManager","label":{"api":{"ThreadLocal":[[20,30]],"EntityManager":[[69,81]]}}}]