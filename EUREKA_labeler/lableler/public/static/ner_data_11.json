[{"text":"In particular it seems like a BlockingQueue might be a good fit here","label":{"api":{"BlockingQueue":[[30,42]]}}},{"text":"You can use BlockingQueue to create simple consumer-producer scenario, there is even a simple example in the documentation","label":{"api":{"BlockingQueue":[[12,24]]}}},{"text":"Here is the Javadoc for this","label":{"api":{}}},{"text":"As discussed here, you can use AffineTransformOp to rotate an image by Math.PI / 2; this is equivalent to rotating the image clockwise 90Â°, as shown here","label":{"api":{"AffineTransformOp":[[31,47]]}}},{"text":"See also Handling 90-Degree Rotations","label":{"api":{}}},{"text":"Java specifies a regular expression that can be used to validate strings being passed to Double.parseDouble or Double.valueOf in the Javadoc of Double.valueOf","label":{"api":{"Double.parseDouble":[[89,106]],"Double.valueOf":[[111,124],[144,157]]}}},{"text":"The AWT gives you access to screen information, although \"external\" is subjective as you might have 2 built-in monitors or 2 external ones","label":{"api":{"AWT":[[4,6]]}}},{"text":"Maybe an idea is to check from time to time getScreenDevices() and detect changes, but this is more a workaround than a real solution","label":{"api":{"getScreenDevices()":[[44,61]]}}},{"text":"As per the String.getBytes() method's documentation, the string is encoded into a sequence of bytes using the platform's default charset","label":{"api":{"String.getBytes()":[[11,27]]}}},{"text":"If you want to specify the encoding, use the method String.getBytes(Charset) or String.getBytes(String)","label":{"api":{"String.getBytes(Charset)":[[52,75]],"String.getBytes(String)":[[80,102]]}}},{"text":"It is not documented in http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html, so can be considered as a spec or implementation bug","label":{"api":{}}},{"text":"Taken from Oracle","label":{"api":{}}},{"text":"You will need to set an implementation of javax.xml.namespace.NamespaceContext on your XPath object","label":{"api":{"javax.xml.namespace.NamespaceContext":[[42,77]],"XPath":[[87,91]]}}},{"text":"If you want to replace entire words only, you can use replaceAll(), which takes a regular expression instead of a normal string, and word boundaries (\\\\b) like this","label":{"api":{"replaceAll()":[[54,65]]}}},{"text":"If I understood your problem correctly I would replace the BufferedOutputStream with a OutputputStreamWriter + BufferedWriterspecifically setting the encoding","label":{"api":{"BufferedOutputStream":[[59,78]],"OutputputStreamWriter":[[87,107]],"BufferedWriterspecifically":[[111,136]]}}},{"text":"The last even have a handy newLine method","label":{"api":{"newLine":[[27,33]]}}},{"text":"Also, since you are not doing anything concurrently, I guess it is safe to replace StringBuffer with StringBuilder","label":{"api":{"StringBuffer":[[83,94]],"StringBuilder":[[101,113]]}}},{"text":"You can use Objects.equals to safely equate null values to each other in Java 7","label":{"api":{"Objects.equals":[[12,25]]}}},{"text":"One of my favorites is Atomic Reference","label":{"api":{"Atomic Reference":[[23,38]]}}},{"text":"You can't just use new String(encrypted) either","label":{"api":{"String(encrypted)":[[23,39]]}}},{"text":"See Pattern and Matcher","label":{"api":{"Pattern":[[4,10]],"Matcher":[[16,22]]}}},{"text":"However, Collections.replaceAll doesn't search inside the string to replace the word \"this\"; it will just test if the entire line is equal to \"this\", which it certainly isn't","label":{"api":{"Collections.replaceAll":[[9,30]]}}},{"text":"You can split your lines into words, and attempt Collections.replaceAll on the List of words","label":{"api":{"Collections.replaceAll":[[49,70]]}}},{"text":"Or, you can use String's replace method, which will match the word within the line","label":{"api":{"String":[[16,21]],"replace":[[25,31]]}}},{"text":"The other modules should be able to access those resources via their classpaths, which should contain the CONFIG jar, using ClassLoader.getResource(String) or ClassLoader.getResourceAsStream(String)","label":{"api":{"ClassLoader.getResource(String)":[[124,154]],"ClassLoader.getResourceAsStream(String)":[[159,197]]}}},{"text":"You could use Matcher#start(group) and Matcher#end(group) to build a generic replacement method","label":{"api":{"Matcher#start(group)":[[14,33]],"Matcher#end(group)":[[39,56]]}}},{"text":"You should probably read up on what #revalidate() and #repaint() do","label":{"api":{"#revalidate()":[[36,48]],"#repaint()":[[54,63]]}}},{"text":"JFrame doesn't have an Icon property, it has an IconImage property as set by setIconImage","label":{"api":{"JFrame":[[0,5]],"Icon":[[23,26]],"IconImage":[[48,56]],"setIconImage":[[77,88]]}}},{"text":" You can override JTable.editingStopped, which is invoked when editing is finished and apply your actions in that method","label":{"api":{"JTable.editingStopped":[[18,38]]}}},{"text":"JTable.editingStopped was not designed for application extension","label":{"api":{"JTable.editingStopped":[[0,20]]}}},{"text":"From the Oracle documentation","label":{"api":{}}},{"text":"You first stop for questions like these should be the API","label":{"api":{}}},{"text":"I recommend using the Text Shape","label":{"api":{"Text":[[22,25]],"Shape":[[27,31]]}}},{"text":"See this answer for an example of collision detection using complex shapes, then look closely at the JavaDocs for Shape for other methods that might help for determining if a Point is inside a shape","label":{"api":{"Shape":[[114,118]],"Point":[[175,179]],"shape":[[193,197]]}}},{"text":"Get a Class instance with Class.forName()","label":{"api":{"Class":[[6,10]],"Class.forName()":[[26,40]]}}},{"text":"You can create a new object of that class with Class.newInstance()","label":{"api":{"Class.newInstance()":[[47,65]]}}},{"text":"Check FileVisitor, very neat","label":{"api":{"FileVisitor":[[6,16]]}}},{"text":"A Character is an object, and therefore null is an acceptable value for a Character reference","label":{"api":{"Character":[[2,10],[74,82]]}}},{"text":"If you allow \"other coders\" to implement a Runnable or a Callable, then you can use the Future class's get(long timeout, TimeUnit unit) method to cause the robot to timeout after a predetermined period of time","label":{"api":{"Runnable":[[43,50]],"Callable":[[57,64]],"Future":[[88,93]],"get(long timeout, TimeUnit unit)":[[103,134]]}}},{"text":"But if memory churn is being an issue, there's a much more efficient way to implement removeElements, using System.arraycopy rather than a temporary LinkedList.","label":{"api":{"removeElements":[[86,99]],"System.arraycopy":[[108,123]],"LinkedList":[[149,158]]}}},{"text":"If this is the case, I suggest converting your array to a List and using Collections.shuffle","label":{"api":{"List":[[58,61]],"Collections.shuffle":[[73,91]]}}},{"text":"According to the Java Docs for toHexString that is expected behaviour","label":{"api":{"toHexString":[[31,41]]}}},{"text":"If you're sure your input isn't empty, a solution is to initialize lowest to a big enough value","label":{"api":{}}},{"text":"The matches() method (doc) tries to match the whole input","label":{"api":{"matches()":[[4,12]]}}},{"text":"The find() method (doc) tries to match something in the beginning but it does not need to match the whole input, so it does return true with the same pattern and same input","label":{"api":{"find()":[[4,9]]}}},{"text":"Read more about it in this link","label":{"api":{}}},{"text":"You could use Iterator or ListIterator","label":{"api":{"Iterator":[[14,21]],"ListIterator":[[26,37]]}}},{"text":"CriteriaBuilder.size(Expression) returns an Expression<Integer> that you may use in the ORDER BY clause","label":{"api":{"CriteriaBuilder.size(Expression)":[[0,31]],"Expression<Integer>":[[44,62]]}}},{"text":"See Matcher for doc","label":{"api":{"Matcher":[[4,10]]}}},{"text":"Sounds like you're looking for a BlockingDeque, and in particular an ArrayBlockingQueue","label":{"api":{"BlockingDeque":[[33,45]],"ArrayBlockingQueue":[[69,86]]}}},{"text":"You may also want a ConcurrentLinkedQueue, which uses a \"wait-free\" algorithm (aka non-blocking) and may therefore be faster in many circumstances","label":{"api":{"ConcurrentLinkedQueue":[[20,40]]}}},{"text":"The InitialDirContext constructor's parameter type is Hashtable<?,?>","label":{"api":{"InitialDirContext":[[4,20]],"Hashtable<?,?>":[[54,67]]}}},{"text":"You should be able to use java.util.Properties here, since it extends java.util.Hashtable<Object,Object>","label":{"api":{"java.util.Properties":[[26,45]],"java.util.Hashtable<Object,Object>":[[70,103]]}}},{"text":"Then, use a custom Comparator to compare the Integers from least to greatest","label":{"api":{"Comparator":[[19,28]],"Integers":[[45,52]]}}},{"text":"Because ArrayList's get(int index) method only takes int as an argument, according to Oracle's documentation(http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html)","label":{"api":{"ArrayList":[[8,16]],"get(int index)":[[20,33]]}}},{"text":"You can simply split() your string on whitespace","label":{"api":{"split()":[[15,21]]}}},{"text":"You would have to use JDBC to get the DatabaseMetaData from the Connection, and then asking for the columns you're interested into, using getColumns()","label":{"api":{"DatabaseMetaData":[[38,53]],"Connection":[[64,73]],"getColumns()":[[138,149]]}}},{"text":"The hashCode() method is based on the contents of the String which are the same, but that doesn't mean that they both refer to the same String object in the memory","label":{"api":{"hashCode()":[[4,13]],"String":[[54,59],[136,141]]}}},{"text":"Alternatively, you can ask the compiler to check and fetch the reference of a String with the same value already existing in the String pool by using the intern() method","label":{"api":{"String":[[78,83]],"intern()":[[154,161]]}}},{"text":"If we were in pre-java8 era, even though -source 1.8 -target 1.7 is not supported by javac you could still use Compiler API to do the same","label":{"api":{"Compiler":[[111,118]]}}},{"text":"This doesn't seem to no longer be so straight forward, as using other compilers you'd need the implementations of features like lambdas as well, and Compiler API will throw the same \"javac","label":{"api":{"Compiler":[[149,156]]}}},{"text":"For rounding use either Math.ceil() for rounding up, Math.floor() for rounding down or Math.round() for general rounding","label":{"api":{"Math.ceil()":[[24,34]],"Math.floor()":[[53,64]],"Math.round()":[[87,98]]}}},{"text":"If $pro.test is a standard implementation of the Set interface, then there's no sort or sortOrder method","label":{"api":{"$pro.test":[[3,11]],"Set":[[49,51]],"sort":[[80,83]],"sortOrder":[[88,96]]}}},{"text":"HttpServletRequest.getHeaderNames() returns Enumeration<String> and HttpServletResponse.getHeaderNames() returns a Collection<String>","label":{"api":{"HttpServletRequest.getHeaderNames()":[[0,34]],"Enumeration<String>":[[44,62]],"HttpServletResponse.getHeaderNames()":[[68,103]],"Collection<String>":[[115,132]]}}},{"text":"Use the DownloadService (or related services) of the JNLP API","label":{"api":{"DownloadService":[[8,22]],"JNLP":[[53,56]]}}},{"text":"SimpleDateFormat is not thread safe","label":{"api":{"SimpleDateFormat":[[0,15]]}}},{"text":"The cast you've shown is necessary because getContentPane returns a Container","label":{"api":{"getContentPane":[[43,56]],"Container":[[68,76]]}}},{"text":"This could probably be accomplished by creating a class of your own, extending the HttpServletRequestWrapper and then override the appropriate methods (getInputStream sounds like the way to go here, yes?)","label":{"api":{"HttpServletRequestWrapper":[[83,107]],"getInputStream":[[152,165]]}}},{"text":"Chek this link","label":{"api":{}}},{"text":"From the Javadoc","label":{"api":{"From the J":[[0,9]]}}},{"text":"As Alex said, .matches() will only return true if the regex matches the entire string","label":{"api":{".matches()":[[14,23]]}}},{"text":"Using your regex, [.*\\\":\\\".*]*, .matches() will only return true for strings that look somewhat like this","label":{"api":{".matches()":[[32,41]]}}},{"text":"If all you're trying to do is show a splash screen then maybe there's a simpler answer, by way of a workaround","label":{"api":{}}},{"text":"Apparently you can show a splash screen upon application load by doing","label":{"api":{}}},{"text":"Also see the documentation of toCharArray()","label":{"api":{"toCharArray()":[[30,42]]}}},{"text":"We can see this in action in the HttpServlet class, which has implementations for each of the web methods (doGet(), doPost(), doPut() and doDelete()) that throw a ServletException and which a subclass must override if they want a class that does something useful for a particular web method","label":{"api":{"HttpServlet":[[33,43]],"doGet()":[[107,113]],"doPost()":[[116,123]],"doPut()":[[126,132]],"doDelete()":[[138,147]],"ServletException":[[163,178]]}}},{"text":"Avoiding the use of additional, external libraries, you may wish to supply an interceptor that implements that standard J2EE servlet Filter interface","label":{"api":{"Filter":[[133,138]]}}},{"text":"Read the JavaDoc for ConcurrentHashMap.values()","label":{"api":{"ConcurrentHashMap.values()":[[21,46]]}}},{"text":"Random objects provide a source from which random numbers can be produced -- they are not the random numbers themselves","label":{"api":{"Random":[[0,5]]}}},{"text":"You only need one Random instance","label":{"api":{"Random":[[18,23]]}}},{"text":"The name() method belongs to the Enum class, so all enum values automatically have this method available","label":{"api":{"name()":[[4,9]],"Enum":[[33,36]]}}},{"text":"By default Enum#toString will return its name","label":{"api":{"Enum#toString":[[11,23]]}}},{"text":"But I suspect that a practical instance when you'd see this would be if you call getReturnType() on a method that returns void","label":{"api":{"getReturnType()":[[81,95]]}}},{"text":"I'm looking in the JavaDoc for both PrintWriter, and its underlying Writer (its out field), and I don't see any way to confirm that the PrintWriter is indeed open","label":{"api":{"PrintWriter":[[36,46],[136,146]],"Writer":[[68,73]],"out":[[80,82]]}}},{"text":"You can also checkError(), but is being closed really considered an error","label":{"api":{"checkError()":[[13,24]]}}},{"text":"I would just use Lists and the removeAll method","label":{"api":{"List":[[17,20]],"removeAll":[[31,39]]}}},{"text":"If you really need an array, you can always call the method toArray(T[]) on the resulting list","label":{"api":{"toArray(T[])":[[60,71]]}}},{"text":"Stumbled over PlatformLoggingMXBean the other day","label":{"api":{"PlatformLoggingMXBean":[[14,34]]}}},{"text":"Try the ImageIO class, which can take a byte array representing pixel data to build an image object and then writing it out in a particular format","label":{"api":{"ImageIO":[[8,14]],"image":[[87,91]]}}},{"text":"Well the thing is I'm working on a IDateEditor interface implementation from JCalendar library and I've noticed that Component.firePropertyChange(String propertyName, Object oldValue, Object newValue) method is not public but protected","label":{"api":{"IDateEditor":[[35,45]],"JCalendar":[[77,85]],"Component.firePropertyChange(String propertyName, Object oldValue, Object newValue)":[[117,199]]}}},{"text":"Of course if I make my class extending from JFormattedTextfield instead of using a simple variable I could easily get rid of this problem","label":{"api":{"JFormattedTextfield":[[44,62]]}}},{"text":"So, in order to fulfill the interface I've used PropertyChangeSupport to keep a list of property change listeners and notify them on a PropertyChangeEvent","label":{"api":{"PropertyChangeSupport":[[48,68]],"PropertyChangeEvent":[[135,153]]}}},{"text":"As you can see the task to add/remove PropertyChangeListeners and notify them on property change events is delegated to the PropertyChangeSupport class member, but the source of the event is this, that is the IDateEditor interface implementer","label":{"api":{"PropertyChangeListeners":[[38,60]],"PropertyChangeSupport":[[124,144]],"IDateEditor":[[209,219]]}}},{"text":"You can of course use JAXP and parse the XML into a Document, but you'll be a lot more productive using a more Java friendly API like JDOM","label":{"api":{"JAXP":[[22,25]],"Document":[[52,59]],"JDOM":[[134,137]]}}},{"text":"How to get the creation date of a file in Java, using BasicFileAttributes class, this is an example","label":{"api":{"BasicFileAttributes":[[54,72]]}}},{"text":"Alternative are classes from java.io or Apache Commons IO, also Guava IO can help","label":{"api":{"java.io":[[29,35]],"Apache Commons IO":[[40,56]],"Guava IO":[[64,71]]}}},{"text":"I would get all the mappings using entrySet, and loop through them to take the first element of the array","label":{"api":{"entrySet":[[35,42]]}}},{"text":"You might want to use a different Charset, depending on the charset of your text file","label":{"api":{"Charset":[[34,40]]}}},{"text":"However your predecessor is not the first person to have encountered this and the standard way to deal with the need to concatenate many Strings in Java is to use a StringBuilder","label":{"api":{"String":[[137,142]],"StringBuilder":[[165,177]]}}},{"text":"You may stop the timer this way or you may use a static timer and schedule/cancel the task each time","label":{"api":{}}},{"text":"In order to get a corresponding value for a given key, you should use the get(Object key) method","label":{"api":{"get(Object key)":[[74,88]]}}},{"text":"Depending on the size of the data set BigDecimal instantiated from an imported String representation might be an easy and accurate option","label":{"api":{"BigDecimal":[[38,47]],"String":[[79,84]]}}},{"text":"You'll need to convert it to a double, then multiply it with Double.parseDouble","label":{"api":{"Double.parseDouble":[[61,78]]}}},{"text":"You may prefer to explicitly override Object.finalize()","label":{"api":{"Object.finalize()":[[38,54]]}}},{"text":"If you want to consider Unicode letters and digits, you may want to look at Unicode character classes","label":{"api":{"Unicode character":[[76,92]]}}},{"text":"The Java Sound based Clip preloads the data, so it should be fine","label":{"api":{"Clip":[[21,24]]}}},{"text":"The Clip interface represents a special kind of data line whose audio data can be loaded prior to playback, instead of being streamed in real time","label":{"api":{"Clip":[[4,7]]}}},{"text":"In my code, I have a BufferedImage that was loaded with the ImageIO class like so","label":{"api":{"BufferedImage":[[21,33]],"ImageIO":[[60,66]]}}},{"text":"Later on, I want to save it to a byte array, but the ImageIO.write method requires me to pick either a GIF, PNG, or JPG format to write my image as (as described in the tutorial here)","label":{"api":{"ImageIO.write":[[53,65]]}}},{"text":"Is there a way that I can determine from the BufferedImage what the original file format was","label":{"api":{"BufferedImage":[[45,57]]}}},{"text":"I'm aware that I could simply parse the file path when I load the image to find the extension and just save it for later, but I'd ideally like a way to do it straight from the BufferedImage","label":{"api":{"BufferedImage":[[176,188]]}}},{"text":"Another solution is to use a PreparedStatement and to bind the parameters (some prefer this second option because it usually scales better and has faster performance)","label":{"api":{"PreparedStatement":[[29,45]]}}},{"text":"If the FileSystemView class you are using is from the javax.swing.filechooser package, don't expect too much","label":{"api":{"FileSystemView":[[7,20]],"javax.swing.filechooser":[[54,76]]}}},{"text":"You can use File#renameTo in Java to do the same thing, provided the OS can do so with the source and destination","label":{"api":{"File#renameTo":[[12,24]]}}},{"text":"File#renameTo won't do that; the rename will fail (it'll return false) and you have to respond to that by doing the file copy (and then removal of the old file) yourself","label":{"api":{"File#renameTo":[[0,12]]}}},{"text":"Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running","label":{"api":{"Runtime":[[54,60]]}}},{"text":"The current runtime can be obtained from the getRuntime method","label":{"api":{"getRuntime":[[45,54]]}}},{"text":"That's what a BlockingQueue exists for","label":{"api":{"BlockingQueue":[[14,26]]}}},{"text":"It has a take() method that forces a thread to block until an Object is avalaible","label":{"api":{"take()":[[9,14]],"Object":[[62,67]]}}},{"text":"ActionListener is an interface","label":{"api":{"ActionListener":[[0,13]]}}},{"text":"For case insensitive string comparison, use the String method str1.equalsIgnoreCase(str2)","label":{"api":{"String":[[48,53]],"str1.equalsIgnoreCase(str2)":[[62,88]]}}},{"text":"If the trim() method would do nothing (because the string is already trimmed), the same string object (ie this) is returned","label":{"api":{"trim()":[[7,12]],"string":[[88,93]]}}},{"text":"These two facts together is why == is true for the comparison of \"String\".trim() == \"String\"","label":{"api":{"trim()":[[74,79]]}}},{"text":"However, you may try using a TreeMap which has the method descendingMap","label":{"api":{"TreeMap":[[29,35]],"descendingMap":[[58,70]]}}},{"text":"A TreeMap will help you with your goal because it is a Map ordered by the natural order of the keys","label":{"api":{"TreeMap":[[2,8]],"Map":[[55,57]]}}},{"text":"Since Integer class doesn't have a 0-arg constructor, you can't directly use Class#newInstance() method here","label":{"api":{"Integer":[[6,12]],"Class#newInstance()":[[77,95]]}}},{"text":"Rather, you can get the appropriate constructor, taking String or int argument using Class#getConstructor() method","label":{"api":{"String":[[56,61]],"int":[[66,68]],"Class#getConstructor()":[[85,106]]}}},{"text":"Chech this link, it has the solution","label":{"api":{}}},{"text":"Cashier extends JFrame","label":{"api":{"Cashier":[[0,6]],"JFrame":[[16,21]]}}},{"text":"DBaccess extends Cashier (which extends from JFrame)","label":{"api":{"DBaccess":[[0,7]],"Cashier":[[17,23]],"JFrame":[[45,50]]}}},{"text":"a tipical Swing application should have only one JFrame","label":{"api":{"JFrame":[[49,54]]}}},{"text":"You should use JDialog instead","label":{"api":{"JDialog":[[15,21]]}}},{"text":"See The Use of Multiple JFrames, Good/Bad Practice","label":{"api":{"JFrame":[[24,29]]}}},{"text":"Take a look to PreparedStatement to avoid this","label":{"api":{"PreparedStatement":[[15,31]]}}},{"text":"If DBaccess class will display the query results using Swing components, then you may want to take a look to SwingWorker class to do the database call in a background thread and update Swing components in the Event Dispatch Thread","label":{"api":{"DBaccess":[[3,10]],"Swing components":[[55,70],[185,200]],"SwingWorker":[[109,119]]}}},{"text":"You can do it using threads (java.lang.Thread)","label":{"api":{"java.lang.Thread":[[29,44]]}}},{"text":"When a player presses a key you start a new thread which moves the circle for 1 pixel, 32 times, with delay (Thread#sleep)","label":{"api":{"Thread#sleep":[[109,120]]}}},{"text":"I'm not sure what your exact intention is with the random string and the file scanner, but a basic way to do the string counting you asked about would be to use a regular expression (the Pattern class)","label":{"api":{"Pattern":[[187,193]]}}},{"text":"Please read the documentation for String.indexOf(String s, int fromIndex) to understand what I've done","label":{"api":{"String.indexOf(String s, int fromIndex)":[[34,72]]}}},{"text":"I would recommend using Arrays.fill() instead","label":{"api":{"Arrays.fill()":[[24,36]]}}},{"text":"Consider using a StringBuilder's append method instead","label":{"api":{"StringBuilder":[[17,29]]}}},{"text":"An AtomicMarkableReference does exactly what you want and is also thread safe in case that is a concern","label":{"api":{"AtomicMarkableReference":[[3,25]]}}},{"text":"The first call of the method invalidates at least one of those conditions; by using the AtomicMarkableReference instead of a plain AtomicReference, it covers the case of null being explicitly set","label":{"api":{"AtomicMarkableReference":[[88,110]],"AtomicReference":[[131,145]]}}},{"text":"Check out Path2D","label":{"api":{"Path2D":[[10,15]]}}},{"text":"It is an implementation of the Shape interface, which will provide the intersects() and contains() methods mentioned by @trashgod in the comments above","label":{"api":{"Shape":[[31,35]],"intersects()":[[71,82]],"contains()":[[88,97]]}}},{"text":"String.toCharArray() does not remove or \"skip\" spaces","label":{"api":{"String.toCharArray()":[[0,19]]}}},{"text":"You could use either a HashSet or a TreeSet since dublications there are not allowed","label":{"api":{"HashSet":[[23,29]],"TreeSet":[[36,42]]}}},{"text":"If you use the Stack, there is a pop() method that actually removes and returns the first element, you could simply store that element somewhere(another list) and access it again if needed","label":{"api":{"Stack":[[15,19]],"pop()":[[33,37]]}}},{"text":"Or create this method in your Stack implementation","label":{"api":{"Stack":[[30,34]]}}},{"text":"As it turns out, List specifies a remove(Object o) function that would allow you to remove things much more straightforwardly","label":{"api":{"remove(Object o)":[[34,49]]}}},{"text":"You can interrupt your thread with Future.cancel(true)","label":{"api":{"Future.cancel(true)":[[35,53]]}}},{"text":"It's in your responsibility to implement the Runnable in a manner that it obeys that wish by checking its Thread.interrupted() state","label":{"api":{"Runnable":[[45,52]],"Thread.interrupted()":[[106,125]]}}},{"text":"Java class TreeSet which is based on search tree of comparable objects instead of hash table has similar methods floor and ceiling","label":{"api":{"TreeSet":[[11,17]],"floor":[[113,117]],"ceiling":[[123,129]]}}},{"text":"I think that you have been cheated by java.lang.Byte.toString() which by default print signed representation of bytes","label":{"api":{"java.lang.Byte.toString()":[[38,62]]}}},{"text":"You must use the utility method Arrays.toString()","label":{"api":{"Arrays.toString()":[[32,48]]}}},{"text":"In Java, each object has toString() method, the default is displaying the class name representation, then adding @ and then the hashcode","label":{"api":{"object":[[14,19]],"toString()":[[25,34]]}}},{"text":"You should use Arrays#toString(), which is implemented this way (I advise you to go through it to better understand what's going on)","label":{"api":{"Arrays#toString()":[[15,31]]}}},{"text":"If you want to use regex in your match, you need to use replaceAll() instead of replace()","label":{"api":{"replaceAll()":[[56,67]],"replace()":[[80,88]]}}},{"text":"I'm looking for a method like GraphicsContext.setMode( GraphicsContextMode.XOR ) but I haven't found it","label":{"api":{"GraphicsContext.setMode( GraphicsContextMode.XOR )":[[30,79]]}}},{"text":"In addition to MouseListener, use a MouseMotionListener","label":{"api":{"MouseListener":[[15,27]],"MouseMotionListener":[[36,54]]}}},{"text":"My guess is it's related to recordList.subList()","label":{"api":{"recordList.subList()":[[28,47]]}}},{"text":"For a map where the values are basic types (or Embeddable types) like Boolean, you need to use the @ElementCollection annotation","label":{"api":{"Boolean":[[70,76]],"@ElementCollection":[[99,116]]}}},{"text":"String#replaceAll accept a regex, not a regular String","label":{"api":{"String#replaceAll":[[0,16]]}}},{"text":") has a special meaning in regex, using quote will cause treating :) as the String :) and not the regex","label":{"api":{"quote":[[40,44]],"String":[[76,81]]}}},{"text":"If you don't want to use Pattern#quote, you should escape the ) by \\\\","label":{"api":{"Pattern#quote":[[25,37]]}}},{"text":"If you don't like any of the mentioned, use String#replace that doesn't accept a regex, and you're fine","label":{"api":{"String#replace":[[44,57]]}}},{"text":"Don't use replaceAll(); use replace() when you want to replace literal strings","label":{"api":{"replaceAll()":[[10,21]],"replace()":[[28,36]]}}},{"text":"Since Java 7 you can also simply wrap a byte array in a BitSet for easy access to individual bits","label":{"api":{"BitSet":[[56,61]]}}},{"text":"Then use Collections.shuffle","label":{"api":{"Collections.shuffle":[[9,27]]}}},{"text":"Or maybe consider using a DecimalFormat for more precise formatting","label":{"api":{"DecimalFormat":[[26,38]]}}},{"text":"To round, you can use Math.round() instead","label":{"api":{"Math.round()":[[22,33]]}}},{"text":"If so, Math.round() won't quite do what you want","label":{"api":{"Math.round()":[[7,18]]}}},{"text":"You can instead use a LinkedHashMap, which guarantees an iteration order equal to the order of insertion","label":{"api":{"LinkedHashMap":[[22,34]]}}},{"text":"If you want to use null here, you can use the wrapper class Integer instead","label":{"api":{"Integer":[[60,66]]}}},{"text":"As @JBNizet points out, a nice alternative if you want to modify an array of Integer is to use an ArrayList instead","label":{"api":{"Integer":[[77,83]],"ArrayList":[[98,106]]}}},{"text":"According to http://docs.oracle.com/javase/7/docs/api/ URL represents an Uniform Resource Locator, which is merely an address","label":{"api":{"URL":[[55,57]]}}},{"text":"Object.clone() is protected, you can't call it from outside the class or its subclasses unless they explicitly change the access modifier to public thus there is no guarantee an object has a visible clone() method","label":{"api":{"Object.clone()":[[0,13]],"clone()":[[199,205]]}}},{"text":"We could come up with more direct examples, but an easy one is the Iterator in DirectoryStream","label":{"api":{"DirectoryStream":[[79,93]]}}},{"text":"While a DirectoryStream is technically Iterable, it only allows one Iterator to be constructed, so if you tried to do the following","label":{"api":{"DirectoryStream":[[8,22]],"Iterator":[[68,75]]}}},{"text":"The * tells the compiler to import all top-level classes in java.io on demand","label":{"api":{"java.io":[[60,66]]}}},{"text":"So, for example, since you've included that import statement, you can use a class like java.io.File without having to prefix the type name with java.io; you can use the simple name File","label":{"api":{"java.io.File":[[87,98]],"java.io":[[144,150]],"File":[[181,184]]}}},{"text":"This follows the general idea outlined by @Jabir, but uses a JOptionPane (which uses a modal dialog as the display component) because it has a number of convenience methods that do the heavy lifting we would otherwise need to implement in a plain modal dialog","label":{"api":{"JOptionPane":[[61,71]]}}},{"text":"Null pointer Execption is thrown when an application attempts to use null in a case where an object is required","label":{"api":{"Null pointer Execption":[[0,21]]}}},{"text":"That happens because when you use setDataVector() according to docs that recreates columns and your column width changes to default","label":{"api":{"setDataVector()":[[34,48]]}}},{"text":"Try to use setAutoCreateColumnsFromModel() to prevent that behavior","label":{"api":{"setAutoCreateColumnsFromModel()":[[11,41]]}}},{"text":"As @TimB points out, all the date and time patterns can be found in the JavaDoc for SimpleDateFormat","label":{"api":{"SimpleDateFormat":[[84,99]]}}},{"text":"As the javadoc of JTable states","label":{"api":{"JTable":[[18,23]]}}},{"text":"In that case you can try to write a custom TableCellRenderer for JTableHeader","label":{"api":{"TableCellRenderer":[[43,59]],"JTableHeader":[[65,76]]}}},{"text":"I think reflections API may help you","label":{"api":{"reflections":[[8,18]]}}},{"text":"You can use your constructed regex together with the matches() method provided you escape all your \\ and allow repeated occurences with the + operator","label":{"api":{"matches()":[[53,61]]}}},{"text":"You should include your properties file in the WEB-INF/classes directory of your war file and then use ClassLoader.getResourceAsStream(String) passing the name of the properties file","label":{"api":{"ClassLoader.getResourceAsStream(String)":[[103,141]]}}},{"text":"If you need something like \"waiting threads\" that wait for the child threads to finish until they can complete their work, have a look at java.util.concurrent.ForkJoinPool","label":{"api":{"java.util.concurrent.ForkJoinPool":[[138,170]]}}},{"text":"The tasks themselves are implemented by subclassing java.util.concurrent.RecursiveTask","label":{"api":{"java.util.concurrent.RecursiveTask":[[52,85]]}}},{"text":"It is true that it will return a new String , but unless the call is part of some giant loop or recursive function, one need not worry too much","label":{"api":{"String":[[37,42]]}}},{"text":"A class called StringBuilder, should be used when you perform lot of operations that involve characters manipulations like replace","label":{"api":{"StringBuilder":[[15,27]]}}},{"text":"An example of this would be the DOM XML implementation provided in Java","label":{"api":{"DOM XML":[[32,38]]}}},{"text":"For instance, assume they provided a faulty Element public implementation named BuggedElement, and clients directly used it in their code","label":{"api":{"Element":[[44,50]],"BuggedElement":[[80,92]]}}},{"text":"From this point on, they would be forced to maintain this implementation, rather than just removing it and writing a new implementation, otherwise existing projects using this concrete implementation would be forced to re-write pieces of code referring to BuggedElement","label":{"api":{"BuggedElement":[[256,268]]}}},{"text":"Because List<E> implements Iterable<T>, you can use a for-each loop to iterate over the List<Measurement> obtained from parsing and calculate the average","label":{"api":{"List<E>":[[8,14]],"Iterable<T>":[[27,37]],"List<Measurement>":[[88,104]]}}},{"text":"Send it over the Looback address (127.0.0.1) via sockets (C# & Java)","label":{"api":{}}},{"text":"With this, both the C# and Java applications can continue their process without interuption","label":{"api":{}}},{"text":"The output should be a list of binary class names","label":{"api":{}}},{"text":"Also, the list of guaranteed system properties does not include properties with this kind of classpath info (such as sun.boot.class.path)","label":{"api":{}}},{"text":"Just make sure to follow the contract of compare -- return an int less than 0, equal to 0, or greater than 0, if d1 is \"less than\" d2, if d1 is \"equal to\" d2, or d1 is \"greater than\" d2, respectively","label":{"api":{"compare":[[41,47]]}}},{"text":"You can use java.awt.Color's own static Color constants, e.g","label":{"api":{"java.awt.Color":[[12,25]],"Color":[[40,44]]}}}]