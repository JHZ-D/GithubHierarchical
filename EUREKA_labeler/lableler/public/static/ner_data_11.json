[{"text": "If your input is in human readable strings rather than binary, you can compute their sum in binary using the standard BigInteger class", "label": {"api": {"BigInteger": [[118, 127]]}}}, {"text": "This expression matches any amount of white spaces if there is at least one", "label": {"api": {"This expression matches": [[0, 22]]}}}, {"text": "You're then reading RandomAccessFile.readChar which always reads two bytes", "label": {"api": {"RandomAccessFile.readChar": [[20, 44]]}}}, {"text": "See \"Memory Consistency Properties\" in the Package description", "label": {"api": {"Memory Consistency Properties": [[5, 33]]}}}, {"text": "Use a custom TableRow factory", "label": {"api": {"TableRow": [[13, 20]]}}}, {"text": "You can access the rows item with TableRow.getItem()", "label": {"api": {"TableRow": [[34, 41]]}}}, {"text": "You should use Enum.getDeclaringClass() method instead", "label": {"api": {"Enum.getDeclaringClass()": [[15, 38]]}}}, {"text": "LocalTime otherwise maybe OffsetTime", "label": {"api": {"LocalTime": [[0, 8]], "OffsetTime": [[26, 35]]}}}, {"text": "When you need to track the indices which are unknown beforehand, you need mutable state and hence the operation called “mutable reduction”", "label": {"api": {"“mutable reduction”": [[119, 137]]}}}, {"text": "JavaFX8 supports public constructors for KeyEvents", "label": {"api": {"KeyEvents": [[41, 49]]}}}, {"text": "BigInteger(for integers) and BigDecimal(for exact floating point numbers) is what you need", "label": {"api": {"BigInteger": [[0, 9]], "BigDecimal": [[29, 38]]}}}, {"text": "The latter could be implemented using AtomicInteger", "label": {"api": {"AtomicInteger": [[38, 50]]}}}, {"text": "I think you're looking for an ArrayList, or is there some reason why you can't use it", "label": {"api": {"ArrayList": [[30, 38]]}}}, {"text": "You should be able to use a SortedSet", "label": {"api": {"SortedSet": [[28, 36]]}}}, {"text": "It provides a tailSet method that should do what you need", "label": {"api": {"tailSet": [[14, 20]]}}}, {"text": "Yes - you can call Class.getGenericInterfaces(), which returns a Type[]", "label": {"api": {"Class.getGenericInterfaces()": [[19, 46]]}}}, {"text": "There is a built-in for this using DatatypeConverter, so you may not have to do it yourself", "label": {"api": {"DatatypeConverter": [[35, 51]]}}}, {"text": "In this case, you should use flatMap", "label": {"api": {"flatMap": [[29, 35]]}}}, {"text": "I know that a FileChannel supports concurrency so I was wondering if something similar can be done with a memory-mapped file in Java", "label": {"api": {"FileChannel": [[14, 24]]}}}, {"text": "Alternatively, you may use duplicate to create one buffer per thread to have independent, thread-local positions and limits", "label": {"api": {"duplicate": [[27, 35]]}}}, {"text": "You can also use combinations of position, limit and slice to create buffers which are enforced to cover different regions of the original buffer", "label": {"api": {"slice": [[53, 57]]}}}, {"text": "Therefore, Java Proxy will not work since it only works for interfaces", "label": {"api": {"Proxy": [[16, 20]]}}}, {"text": "From the Javadocs", "label": {"api": {"the Javadocs": [[5, 16]]}}}, {"text": "Or, you can use Pattern.CASE_INSENSITIVE when you compile the pattern", "label": {"api": {"Pattern.CASE_INSENSITIVE": [[16, 39]]}}}, {"text": "The documentation for ArrayList.get says that you can only use an int as an index, and that's why you're getting a compiler error", "label": {"api": {"documentation for ArrayList.get": [[4, 34]]}}}, {"text": "While you can override the embeddable column names, you can't specify the column order", "label": {"api": {"override the embeddable column names": [[14, 49]]}}}, {"text": "If you want to get the maximum element, you should use Collections.max method", "label": {"api": {"Collections.max": [[55, 69]]}}}, {"text": "You need to have your Score object implement Comparable and then call Collections.max on your ArrayList", "label": {"api": {"Collections.max": [[70, 84]]}}}, {"text": "From the JavaDoc for Arrays.asList()", "label": {"api": {"Arrays.asList()": [[21, 35]]}}}, {"text": "For more information, see CharsetEncoder and CharsetDecoder", "label": {"api": {"CharsetEncoder": [[26, 39]], "CharsetDecoder": [[45, 58]]}}}, {"text": "The Duplicator is not available anymore in the current version", "label": {"api": {"Duplicator": [[4, 13]]}}}, {"text": "There is a Java library method, exactly for this", "label": {"api": {"method": [[24, 29]]}}}, {"text": "Yes, you can use reflection", "label": {"api": {"reflection": [[17, 26]]}}}, {"text": "In case of using Java 8 java.time package, the property should be of type LocalDate (or LocalDateTime is the time portion is needed)", "label": {"api": {"java.time package": [[24, 40]], "LocalDate": [[74, 82], [88, 96]], "LocalDateTime": [[88, 100]]}}}, {"text": "For more advanced features of printf, see the documentation of java.util.Formatter", "label": {"api": {"java.util.Formatter": [[63, 81]]}}}, {"text": "The link regex-Pattern made me more confused", "label": {"api": {"regex-Pattern": [[9, 21]]}}}, {"text": "JPanel is double buffered by default", "label": {"api": {"JPanel": [[0, 5]]}}}, {"text": "The documentation for the Scanner.nextInt method says", "label": {"api": {"documentation for the Scanner.nextInt": [[4, 40]]}}}, {"text": "So, if we take that documentation's advice and look at the documentation for Scanner.nextInt(int), we see", "label": {"api": {"documentation for Scanner.nextInt(int)": [[59, 96]]}}}, {"text": "When you create a Scanner, the delimiter is whitespace (as stated in the documentation for the Scanner class)", "label": {"api": {"documentation for the Scanner class": [[73, 107]]}}}, {"text": "I would base it on Arrays.copyOf()", "label": {"api": {"Arrays.copyOf()": [[19, 33]]}}}, {"text": "The forEach method may not be appropriate for structurally modifying the collection being iterated over", "label": {"api": {"forEach": [[4, 10]]}}}, {"text": "This is a case where using the traditional Iterator and remove is likely still the best solution", "label": {"api": {"remove": [[56, 61]]}}}, {"text": "You may want to check out the removeIf()-method, it removes all elements that fulfill a given condition", "label": {"api": {"removeIf()-method": [[30, 46]]}}}, {"text": "event-based) or synchronize bodies, manually or via Collections.synchronizedList()", "label": {"api": {"Collections.synchronizedList()": [[52, 81]]}}}, {"text": "You can also try out ListIterator which has support for a remove/add method during the iteration itself", "label": {"api": {"ListIterator": [[21, 32]]}}}, {"text": "Instead you could always use charAt api of String and convert individual characters to a number as give below", "label": {"api": {"charAt": [[29, 34]]}}}, {"text": "If you run a Java 8 JVM, yes; if you run a Java 7 JVM, no (you'll get an UnsupportedClassVersionError if you try)", "label": {"api": {"UnsupportedClassVersionError": [[73, 100]]}}}, {"text": "Use the Collections.synchronizedList method", "label": {"api": {"Collections.synchronizedList": [[8, 35]]}}}, {"text": "Those threads that operate without iterating can just use the \"atomic\" methods on the return object from Collections.synchronizedList, such as add", "label": {"api": {"Collections.synchronizedList": [[105, 132]]}}}, {"text": "Yet another would be to use a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[30, 42]]}}}, {"text": "You could use the Byte.parseByte(String, int) method to simply parse your \"26\" into a hex value used to create a byte primitive", "label": {"api": {"Byte.parseByte(String, int)": [[18, 44]]}}}, {"text": "If you want a Byte object you can use valueOf instead", "label": {"api": {"valueOf": [[38, 44]]}}}, {"text": "I would use a ready method StringBuilder#reverse", "label": {"api": {"StringBuilder#reverse": [[27, 47]]}}}, {"text": "Float, Integer, etc", "label": {"api": {"Float": [[0, 4]], "Integer": [[7, 13]]}}}, {"text": "This is because of string interning", "label": {"api": {"string interning": [[19, 34]]}}}, {"text": "I found something called a ByteArrayInputStream however that takes the entire Array[Byte] in its constructor, which I'm not sure would work in this scenario as I'm working with chunks", "label": {"api": {"ByteArrayInputStream": [[27, 46]]}}}, {"text": "You can use BigInteger to satisfy your requirement", "label": {"api": {"BigInteger": [[12, 21]]}}}, {"text": "From the JavaDoc for File.listFiles(FileFilter)", "label": {"api": {"JavaDoc for File.listFiles(FileFilter)": [[9, 46]]}}}, {"text": "The JavaDoc for SimpleDateFormat fully explains the various formatting options", "label": {"api": {"JavaDoc for SimpleDateFormat": [[4, 31]]}}}, {"text": "See the documentation for Calendar.MONTH", "label": {"api": {"Calendar.MONTH": [[26, 39]]}}}, {"text": "Try changing the Calendar.MONTH value to 0 instead of 1", "label": {"api": {"Calendar.MONTH": [[17, 30]]}}}, {"text": "Probably the easiest way to do this is to use a Timeline with a single KeyFrame at one minute with an event handler", "label": {"api": {"Timeline": [[48, 55]], "an event handler": [[99, 114]]}}}, {"text": "In the event handler, decrement the counter, and set the Timeline's cycle count to the number of minutes", "label": {"api": {"Timeline": [[57, 64]], "Timeline's cycle count": [[57, 78]]}}}, {"text": "Use the JDK utility methods Double.compare() and Integer.compare() to help compare", "label": {"api": {"Double.compare()": [[28, 43]], "Integer.compare()": [[49, 65]]}}}, {"text": "By the way, a very close example of such an exception is precisely the standard ConstraintValidationException, thrown by the standard Bean Validation framework, which contains a set of constraint violations", "label": {"api": {"ConstraintValidationException": [[80, 108]]}}}, {"text": "In Java 1.7.0+, you can use the JLayer", "label": {"api": {"JLayer": [[32, 37]]}}}, {"text": "If you would like to increment an int from multiple threads, use AtomicInteger", "label": {"api": {"AtomicInteger": [[65, 77]]}}}, {"text": "So, encode your video to a format understood by JavaFX (e.g", "label": {"api": {"format understood by JavaFX": [[27, 53]]}}}, {"text": "In addition to Erans answer I'd like to point you to the Java API documentation for Integer, which states", "label": {"api": {"Integer": [[84, 90]]}}}, {"text": "Scanner#next(), as per javadoc, Finds and returns the next complete token from this scanner i.e", "label": {"api": {"Scanner#next()": [[0, 13]]}}}, {"text": "Scanner#nextLine() instead Advances this scanner past the current line and returns the input that was skipped meaning that gets all the line written (in your case until Enter is pressed)", "label": {"api": {"Scanner#nextLine()": [[0, 17]]}}}, {"text": "Notice the use of TypedQuery instead of Query", "label": {"api": {"TypedQuery": [[18, 27]]}}}, {"text": "There already is a Point class in Java, that does exactly what your Class MyPoint does, try to not reinvent the wheel when you can use what the standard API does for you", "label": {"api": {"Point": [[19, 23], [76, 80]]}}}, {"text": "There is a Shape class in Java, take a look at it", "label": {"api": {"Shape": [[11, 15]]}}}, {"text": "I'm having problems with Types.isAssignable() from annotations processing API", "label": {"api": {"Types.isAssignable()": [[25, 44]]}}}, {"text": "You could also use a timer, as someone mentionned in the comments", "label": {"api": {"timer": [[21, 25]]}}}, {"text": "It might be overkill, but you could make Textbook implement Comparable or write a Comparator", "label": {"api": {"Comparable": [[60, 69]], "Comparator": [[82, 91]]}}}, {"text": "You should use a SwingWorker for that", "label": {"api": {"SwingWorker": [[17, 27]]}}}, {"text": "You may want to try the BoxLayout if you want to align the components vertically", "label": {"api": {"BoxLayout": [[24, 32]]}}}, {"text": "you should probably use the ScrollPane instead", "label": {"api": {"ScrollPane": [[28, 37]]}}}, {"text": "This little example shows how to create a horizontally scrollable HBox with the ScrollPane class", "label": {"api": {"ScrollPane": [[80, 89]]}}}, {"text": "Comapre the String you are passing using equals(Object anObject)", "label": {"api": {"equals(Object anObject)": [[41, 63]]}}}, {"text": "According to the API S refers to milliseconds and X to the timezone", "label": {"api": {"the API": [[13, 19]]}}}, {"text": "In pure Java, you are limited to what NetworkInterface provides", "label": {"api": {"NetworkInterface": [[38, 53]]}}}, {"text": "You can use a Calendar to do that", "label": {"api": {"Calendar": [[14, 21]]}}}, {"text": "cal.getActualMaximum(Calendar.DAY_OF_YEAR) will return the number of the last day of the year the Calendar is set to (2014 in this code)", "label": {"api": {"Calendar": [[21, 28], [98, 105]]}}}, {"text": "You have to add 1 because the field Calendar.DAY_OF_YEAR starts at 1", "label": {"api": {"Calendar": [[36, 43]]}}}, {"text": "cal.set() will set the given field of the Calendar to the value given as the second argument", "label": {"api": {"Calendar": [[42, 49]]}}}, {"text": "SimpleDateFormat is used to print the date in the required format", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Also, I need more good examples on how to utilize the different options, mentioned in split.regex,  and how to combine them in one regex", "label": {"api": {"split.regex": [[86, 96]]}}}, {"text": "When you draw in your paint method, you can add more parameters to stretch and scale image, see g.drawImage at this link", "label": {"api": {"link": [[116, 119]]}}}, {"text": "In HashMap, insertion and lookup operations have time complexity of O(1), they'll have almost the same performance, but the first code is much more readable, don't waste your time about performance, go with the first", "label": {"api": {"HashMap": [[3, 9]]}}}, {"text": "Please click here for more information", "label": {"api": {"click": [[7, 11]]}}}, {"text": "So you don’t need to think about how to benchmark correctly here, not that it matters when the operation takes seconds, but I recommend learning the difference between System.currentTimeMillis() and System.nanoTime() as the latter is the right tool for measuring elapsed time", "label": {"api": {"System.nanoTime()": [[199, 215]]}}}, {"text": "NumberFormatException is what Integer.parseInt throws when you pass it invalid input", "label": {"api": {"NumberFormatException": [[0, 20]]}}}, {"text": "Through System.getProperty(String key) you can get the value of some java system properties, however my question is about how java fill these values, more exactly where is the source of this information", "label": {"api": {"System.getProperty(String key)": [[8, 37]]}}}, {"text": "My problem is that I'm trying to test some behaviours of my code, and I want to change the system property for os.name value outside of java (I know that I can set the value with System.setProperty(String key, String value) however I want to do it outside), so anybody knows what I've to change in order to get the new value through System.getProperty('os.name')", "label": {"api": {"System.setProperty(String key, String value)": [[179, 222]]}}}, {"text": "From InterruptibleChannel documentation", "label": {"api": {"InterruptibleChannel": [[5, 24]]}}}, {"text": "If your array is a simple array you probably want a TilePane and not a GridPane", "label": {"api": {"TilePane": [[52, 59]]}}}, {"text": "According to the API for Unmarshaller, you can call u.unmarshal(strSource, Foo.class) and this will return a JAXBElement<Foo>, on which you can call getValue() to get the actual Foo", "label": {"api": {"Unmarshaller": [[25, 36]]}}}, {"text": "Also, read up on the usage of JAXBContext while you're at it", "label": {"api": {"JAXBContext": [[30, 40]]}}}, {"text": "You have to loop, calling getInterfaces on A, then use getSuperclass to get its super class, and then do that again, etc., until getSuperclass returns null", "label": {"api": {"getSuperclass": [[55, 67], [129, 141]]}}}, {"text": "While the Java Date library is notoriously bad (which is pretty much why everyone uses the Joda-Time library, and why Oracle released the new java.time package with Java 8 (see article), there are a couple things to be aware of", "label": {"api": {"java.time package": [[142, 158]]}}}, {"text": "I think you are asking for something as simple as alternating calls to Character.toLowerCase(char) and Character.toUpperCase(char) on the result of modulo (remainder of division) 2", "label": {"api": {"Character.toLowerCase(char)": [[71, 97]], "Character.toUpperCase(char)": [[103, 129]]}}}, {"text": "Use the FileWriter constructor that takes a boolean to turn on append mode, and close your PrintWriter", "label": {"api": {"the FileWriter constructor that takes a boolean": [[4, 50]]}}}, {"text": "To do this properly I suggest you use the URI class", "label": {"api": {"URI": [[42, 44]]}}}, {"text": "CopyOnWriteArrayList that supports concurrency and is better than the options described above", "label": {"api": {"CopyOnWriteArrayList": [[0, 19]]}}}, {"text": "Still, I would recommend using another collection like a concurrent Queue through BlockingQueue and implemented by LinkedBlockingQueue", "label": {"api": {"BlockingQueue": [[82, 94], [121, 133]], "LinkedBlockingQueue": [[115, 133]]}}}, {"text": "The documentation for the formatting symbols can be found at the JavaDoc Page for SimpleDateFormat, you can use that to configure the exact string produced to meet your needs", "label": {"api": {"found at the JavaDoc Page for SimpleDateFormat": [[52, 97]]}}}, {"text": "You could have a separate thread watch for changes to the file's access time and generate a jvm thread dump when that happens", "label": {"api": {"access time": [[65, 75]]}}}, {"text": "java.lang.Math class provides a max method to find maximum of two double inputs", "label": {"api": {"java.lang.Math": [[0, 13]], "max": [[32, 34], [51, 53]]}}}, {"text": "Assuming j_spring_security_check refers to a Servlet, here is an example of what the code would look like in your servlet class", "label": {"api": {"Servlet": [[45, 51]]}}}, {"text": "Thread.stop() is deprecated", "label": {"api": {"Thread.stop()": [[0, 12]]}}}, {"text": "Use a regex (see Pattern and matcher)", "label": {"api": {"Pattern": [[17, 23]], "matcher": [[29, 35]]}}}, {"text": "You can use String.split()", "label": {"api": {"String.split()": [[12, 25]]}}}, {"text": "there is a Math.round() method", "label": {"api": {"Math.round()": [[11, 22]]}}}, {"text": "Assuming that with save you mean write to disk, then I would suggest that you use the flush method of BufferedWriter", "label": {"api": {"flush": [[86, 90]]}}}, {"text": "Because Scanner#nextInt reads only the int value, then nextLine in the first iteration will consume the remaining \\n (the enter you hit after you entered the integer value)", "label": {"api": {"Scanner#nextInt": [[8, 22]]}}}, {"text": "Additionally, the documentation of AnnotatedElement specifies", "label": {"api": {"AnnotatedElement": [[35, 50]]}}}, {"text": "But there is another conclusion we can draw from the documentation of AnnotatedElement", "label": {"api": {"AnnotatedElement": [[70, 85]]}}}, {"text": "It’s interesting, how that is achieved", "label": {"api": {"how that is achieved": [[18, 37]]}}}, {"text": "Then you would use Throwable's .getStackTrace() which returns an array of StackTraceElements", "label": {"api": {"Throwable's .getStackTrace()": [[19, 46]], "StackTraceElements": [[74, 91]]}}}, {"text": "Most likely you set the icon of your window with Window.setIconImage(Image image) method", "label": {"api": {"Window.setIconImage(Image image)": [[49, 80]]}}}, {"text": "The common practice in these situations is to use some sort of connection pool; the database driver needs to implement this feature", "label": {"api": {"connection pool": [[63, 77]]}}}, {"text": "Unfortunately, a Swing Component can only have a single parent", "label": {"api": {"single parent": [[49, 61]]}}}, {"text": "For this simple program to increment index number for each Thread invocation, AtomicInteger variable would be suffice", "label": {"api": {"AtomicInteger": [[78, 90]]}}}, {"text": "An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer", "label": {"api": {"AtomicInteger": [[3, 15]]}}}, {"text": "Use the split() and substring() methods of the String class, for one approach", "label": {"api": {"split": [[8, 12]], "substring": [[20, 28]]}}}, {"text": "Please see the Javadocs for split and substring", "label": {"api": {"split": [[28, 32]], "substring": [[38, 46]]}}}, {"text": "From the logger documentation", "label": {"api": {"logger documentation": [[9, 28]]}}}, {"text": "You should check that a ConsoleHandler is installed and that the level is set to INFO or lower", "label": {"api": {"ConsoleHandler": [[24, 37]]}}}, {"text": "You should also check that writing to System.err shows up in the log file as that is the stream that is used for the ConsoleHandler", "label": {"api": {"ConsoleHandler": [[117, 130]]}}}, {"text": "Yes just use system.exit(), it's the cleanest way of doing it", "label": {"api": {"system.exit()": [[13, 25]]}}}, {"text": "Use a StackPane rather than a BorderPane", "label": {"api": {"StackPane": [[6, 14]], "BorderPane": [[30, 39]]}}}, {"text": "By default a StackPane will center any node you put in it", "label": {"api": {"StackPane": [[13, 21]]}}}, {"text": "One means to do so is to ensure that the writeReplace method returns an instance of SerializedLambda, rather than allowing default serialization to proceed", "label": {"api": {"SerializedLambda": [[84, 99]]}}}, {"text": "SerializedLambda has a readResolve method that looks for a (possibly private) static method called $deserializeLambda$(SerializedLambda) in the capturing class, invokes that with itself as the first argument, and returns the result", "label": {"api": {"SerializedLambda": [[0, 15], [119, 134]]}}}, {"text": "Lambda classes implementing $deserializeLambda$ are responsible for validating that the properties of the SerializedLambda are consistent with a lambda actually captured by that class", "label": {"api": {"SerializedLambda": [[106, 121]]}}}, {"text": "It has added forEachRemaining() on Iterator", "label": {"api": {"forEachRemaining()": [[13, 30]]}}}, {"text": "Nothing too fancy, just something better that calling Random which scatters points all over (of course, as it should)", "label": {"api": {"Random": [[54, 59]]}}}, {"text": "Version 3 of the Servlet API has SessionCookieConfig#getName", "label": {"api": {"SessionCookieConfig#getName": [[33, 59]]}}}, {"text": "You can get this object from the ServletContext", "label": {"api": {"ServletContext": [[33, 46]]}}}, {"text": "There are better classes for parsing dates", "label": {"api": {"better classes": [[10, 23]]}}}, {"text": "As described in the javadocs for java.util.Scanner at http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html, you can use any custom expression to be used as delimiter, (space is considered the default, hence your entry with parenthesis was taken as one string)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[54, 116]]}}}, {"text": "Look at the Scanner Docs", "label": {"api": {"Scanner Docs": [[12, 23]]}}}, {"text": "If not, start a thread (Runnable or Thread) that runs your method m (which checks the date and time, and does the needful if time has changed from am to pm)", "label": {"api": {"Runnable": [[24, 31]], "Thread": [[36, 41]]}}}, {"text": "[EDIT] You should preferably be using BlockingQueue for such producer consumer scenario", "label": {"api": {"BlockingQueue": [[38, 50]]}}}, {"text": "ConcurrentModificationException actually means that you are breaking the rules  of iteration by somehow modifying the list while iterating it", "label": {"api": {"ConcurrentModificationException": [[0, 30]]}}}, {"text": "Remove your table the UI using Container.remove(yourTable) and ensure you have no references to the table or the TableModel", "label": {"api": {"Container.remove(yourTable)": [[31, 57]]}}}, {"text": "How do I obtain a java.sql.Timestamp that represents 24 hours ago", "label": {"api": {"java.sql.Timestamp": [[18, 35]]}}}, {"text": "If that does not work for you, you would need to use setLocation(int x, int y) and combine it with this.setLayoutManager(null) (or something like that)", "label": {"api": {"setLocation(int x, int y)": [[53, 77]]}}}, {"text": "The critical part of this is using the Enum.getDeclaringClass() method", "label": {"api": {"Enum.getDeclaringClass()": [[39, 62]]}}}, {"text": "The imports should direct you to the appropriate Java API pages such as Class SAXParser to begin with", "label": {"api": {"Class SAXParser": [[72, 86]]}}}, {"text": "when creating a Stream for an array or an IntStream via IntStream.range", "label": {"api": {"Stream for an array": [[16, 34]], "IntStream.range": [[56, 70]]}}}, {"text": "In contrast, when using IntStream.range(0, n).mapToObj(i -> new MyClass()), the entire Stream operation, including the constructor calls, can run in parallel", "label": {"api": {"IntStream.range": [[24, 38]]}}}, {"text": "I'm mainly talking about spliterator characteristics, in particular the SIZED characteristic", "label": {"api": {"spliterator characteristics": [[25, 51]]}}}, {"text": "at least in terms of spliterator characteristics", "label": {"api": {"spliterator characteristics": [[21, 47]]}}}, {"text": "as described here) to the flavor used by Java's Pattern class", "label": {"api": {"Pattern": [[48, 54]]}}}, {"text": "The documentation for BufferedReader#readLine says", "label": {"api": {"BufferedReader#readLine": [[22, 44]]}}}, {"text": "The getSource() method returns the object from which the Event initially occurred", "label": {"api": {"getSource()": [[4, 14]]}}}, {"text": "This is where getActionCommand() might come in handy", "label": {"api": {"getActionCommand()": [[14, 31]]}}}, {"text": "I am using a portable solution which refers to a combination of BMT and setting the timeout with the setTransactionTimeout method", "label": {"api": {"setTransactionTimeout": [[101, 121]]}}}, {"text": "If you just need to store a small to medium amount of data, use java.util.prefs.Preferences", "label": {"api": {"java.util.prefs.Preferences": [[64, 90]]}}}, {"text": "Use of the @FunctionalInterface annotation will warn you of this, similar to how the @Override annotation works", "label": {"api": {"@FunctionalInterface": [[11, 30]], "@Override": [[85, 93]]}}}, {"text": "JSE supplies a binary int operation, java.util.function.IntBinaryOperator, but not a ternary operation, so we need to define our own", "label": {"api": {"java.util.function.IntBinaryOperator": [[37, 72]]}}}, {"text": "First, let's look at the documentation for AudioSystem", "label": {"api": {"documentation for AudioSystem": [[25, 53]]}}}, {"text": "Since you already have a byte array, the best choice is to wrap the bytes in a ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[79, 98]]}}}, {"text": "If you go to the documentation for Clip, and look at the very top of the page, you'll see a navigation row with several links, including a \"USE\" link", "label": {"api": {"documentation for Clip": [[17, 38]]}}}, {"text": "The documentation for AudioSystem.getClip() states", "label": {"api": {"documentation for AudioSystem": [[4, 32]], "documentation for AudioSystem.getClip()": [[4, 42]]}}}, {"text": "So if we return to the Clip documentation again, we see two open methods (as of Java 8)", "label": {"api": {"Clip documentation": [[23, 40]]}}}, {"text": "Finally, as you seem to already know, you must start the clip by calling its inherited start() method", "label": {"api": {"start()": [[87, 93]]}}}, {"text": "The HOUR field is documented as", "label": {"api": {"documented": [[18, 27]]}}}, {"text": "You could use the StringTokenizer", "label": {"api": {"StringTokenizer": [[18, 32]]}}}, {"text": "Another, maybe more lengthy approach would be to iterate over the string and use the methods provided by the Character class (Character.isWhiteSpace(char c)) and break the string accordingly", "label": {"api": {"Character.isWhiteSpace(char c)": [[126, 155]]}}}, {"text": "Use ExecutorService with fixed thread pool size and keep posting / executing runnables", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "Here's the page describing the API of Future", "label": {"api": {"Future": [[38, 43]]}}}, {"text": "As Steffen notes, Files.copy is a simpler approach if that's available to you", "label": {"api": {"Files.copy": [[18, 27]]}}}, {"text": "If your string is potentially null, you might want to use StringUtils.trim() - the null-safe version of String.trim()", "label": {"api": {"String.trim()": [[104, 116]]}}}, {"text": "xml is clearly a namespace prefix", "label": {"api": {"namespace prefix": [[17, 32]]}}}, {"text": "Using java.nio available since Java 7", "label": {"api": {"java.nio": [[6, 13]]}}}, {"text": "Have you looked at java.lang.reflect.Proxy for interfaces or cglib for classes", "label": {"api": {"java.lang.reflect.Proxy": [[19, 41]]}}}, {"text": "You can store it as an attribute in the ServletContext of the application", "label": {"api": {"ServletContext": [[40, 53]]}}}, {"text": "Per its docs, InputStream.read() returns -1 when the end of the file has been reached", "label": {"api": {"its docs": [[4, 11]]}}}, {"text": "again, either use Hibernate-specific stuff, OR use the @MappedSuperclass annotation on the superclass (which is extended by every FlowDataPer* classes), without using on it the @Entity and @Inheritance annotations", "label": {"api": {"@MappedSuperclass": [[55, 71]]}}}, {"text": "different classes (FlowDataPer10s, FlowDataPer20s, ..)  extending a base entity class, anntoated with @Entity and @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS), but I find it more elegant with the @MappedSuperclass annotation", "label": {"api": {"@MappedSuperclass": [[206, 222]]}}}, {"text": "You have the right idea, but implement the interfaces in the java.sql package", "label": {"api": {"java.sql": [[61, 68]]}}}, {"text": "Throw UnsupportedOperationException from any methods your simple driver doesn't support", "label": {"api": {"UnsupportedOperationException": [[6, 34]]}}}, {"text": "Object has a method finalize, which is called by the garbage collector when an Object is disposed", "label": {"api": {"finalize": [[20, 27]]}}}, {"text": "FWIW, there are much more smarter ways to do this, such as using a HashMap, but I'm assuming you haven't covered more advanced data structures in your Java course yet, and you probably need a solution with arrays", "label": {"api": {"HashMap": [[67, 73]]}}}, {"text": "However, I completely recommend using HashMap", "label": {"api": {"HashMap": [[38, 44]]}}}, {"text": "Try adding VGap and HGap to the Gridpane, instead of adding Padding to every node in it", "label": {"api": {"VGap": [[11, 14]], "HGap": [[20, 23]]}}}, {"text": "Why not to use Collections.sort() method", "label": {"api": {"Collections.sort()": [[15, 32]]}}}, {"text": "Or you can use Arrays.sort() as well, but it does not use merge sort", "label": {"api": {"Arrays.sort()": [[15, 27]]}}}, {"text": "But keep in mind that will you need it to implement Comparable interface for your Klant class", "label": {"api": {"Comparable": [[52, 61]]}}}, {"text": "If you would like to use the list you can do as Jens suggested, but use add() method of List and not assign the value via =", "label": {"api": {"add()": [[72, 76]]}}}, {"text": "You first shuffled the list, which invalidates the prerequisite of Collections.binarySearch", "label": {"api": {"Collections.binarySearch": [[67, 90]]}}}, {"text": "During the Tomcat startup, the Service Provider mechanism scans for database drivers in the $CATALINA_BASE/lib  folder to register them", "label": {"api": {"Service Provider mechanism": [[31, 56]]}}}, {"text": "You can do this via the SwingUtilities.invokeLater(Runnable) method", "label": {"api": {"SwingUtilities.invokeLater(Runnable)": [[24, 59]]}}}, {"text": "Finally, in the bottom for loop, use Class's getEnumConstants method to loop through all the enum constants", "label": {"api": {"Class's getEnumConstants method": [[37, 67]]}}}, {"text": "Because the no-arg split method discards trailing empty strings, but not leading empty strings", "label": {"api": {"no-arg split method": [[12, 30]]}}}, {"text": "From the Oracle docs (Throwable)", "label": {"api": {"Oracle docs (Throwable)": [[9, 31]]}}}, {"text": "From the API of ResultSet (http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html": [[27, 90]]}}}, {"text": "Java's synchronized code block makes no guarantee about the sequence in which threads waiting to enter the synchronized block are allowed to enter, and notifyAll() doesn't present itself as a special case", "label": {"api": {"notifyAll()": [[152, 162]]}}}, {"text": "As you have seen in notifyAll() javadoc (emphasis mine)", "label": {"api": {"notifyAll()": [[20, 30]]}}}, {"text": "Please see this link in the doucmentation - Create a file object then  call 'createNewFile()' method on the newly created object", "label": {"api": {"this link": [[11, 19]]}}}, {"text": "You can use javax.xml.bind.DatatypeConverter to convert byte arrays to strings and vice versa (see parseBase64Binary and printBase64Binary)", "label": {"api": {"javax.xml.bind.DatatypeConverter": [[12, 43]], "parseBase64Binary": [[99, 115]], "printBase64Binary": [[121, 137]]}}}, {"text": "This can be done very easily using the Files utility class", "label": {"api": {"Files": [[39, 43]]}}}, {"text": "To solve your immediate problem, you could Base64 encode your binary data", "label": {"api": {"Base64": [[43, 48]]}}}, {"text": "You can use the Base64 class available in the JDK", "label": {"api": {"Base64": [[16, 21]]}}}, {"text": "Unless this is an exercise consider using Collections.reverse", "label": {"api": {"Collections.reverse": [[42, 60]]}}}, {"text": "You are trying to add components to an already displayed container and component's hierarchy is invalidated", "label": {"api": {"invalidated": [[96, 106]]}}}, {"text": "On tree selection change, switch the panels using CardLayout method show(cardPanel, constraint), where constraint is the constraint used to add the panel to the cardPanel", "label": {"api": {"show(cardPanel, constraint)": [[68, 94]]}}}, {"text": "Try using the BasicStroke(float width, int cap, int join) constructor", "label": {"api": {"BasicStroke(float width, int cap, int join)": [[14, 56]]}}}, {"text": "You will get even better behavior of you use a java.awt.geom.Path2D for the duration of the entire mouse down...mouse up sequence", "label": {"api": {"java.awt.geom.Path2D": [[47, 66]]}}}, {"text": "Seems like a perfect place to use JavaFX Bindings", "label": {"api": {"Bindings": [[41, 48]]}}}, {"text": "Classpath scanners assume the only classloader used to load classes is URLClassLoader which allows to retrieve source URLs for scanning using getURLs() method", "label": {"api": {"getURLs() method": [[142, 157]]}}}, {"text": "First, convert your UUID to a byte buffer for consumption by a Base64 encoder", "label": {"api": {"Base64 encoder": [[63, 76]]}}}, {"text": "This could be accomplished by using a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[38, 50]]}}}, {"text": "CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "Phaser is definitively unnecessary in this case", "label": {"api": {"Phaser": [[0, 5]]}}}, {"text": "Look all the networking properties in Java", "label": {"api": {"networking properties": [[13, 33]]}}}, {"text": "I know how to call UI::access from a background thread to schedule a Runnable to be run on the user-interface thread", "label": {"api": {"Runnable": [[69, 76]]}}}, {"text": "notifyObservers() acts only after a change occurs (as verified by hasChanged() method)", "label": {"api": {"notifyObservers()": [[0, 16]], "hasChanged()": [[66, 77]]}}}, {"text": "In your code you need to add setChanged() in order to set the change indicator before calling notify", "label": {"api": {"setChanged()": [[29, 40]]}}}, {"text": "You do not need to call clearChanged() afterwards since this method is called automatically by the notifyObservers methods", "label": {"api": {"clearChanged()": [[24, 37]]}}}, {"text": "You could use entrySet method to get each and every entry holding key and value and can iterate over the set as below", "label": {"api": {"entrySet": [[14, 21]]}}}, {"text": "Alternatively, if you want to iterate just over keys, you could use keySet method (just like you iterating over values) and iterate over the keys of a hashmap like", "label": {"api": {"keySet": [[68, 73]]}}}, {"text": "bindingName is not a legal element of the javax.jws.WebService annotation", "label": {"api": {"javax.jws.WebService": [[42, 61]]}}}, {"text": "Instead you could use Arrays.sort method to sort each word in a sentence by splitting the sentence by space and by providing String's inbuilt comparator CASE_INSENSITIVE_ORDER which will say how exactly you want to sort the data (Comparing two strings lexicographically, ignoring case) by comparating one String with the other", "label": {"api": {"Arrays.sort": [[22, 32]], "CASE_INSENSITIVE_ORDER": [[153, 174]]}}}, {"text": "You'll want to use the String's toCharArray() method", "label": {"api": {"toCharArray()": [[32, 44]]}}}, {"text": "Yes, you can provide a compratator for the sort method", "label": {"api": {"for the sort method": [[35, 53]]}}}, {"text": "First, Field's getGenericType() method returns the Type information needed", "label": {"api": {"Field's getGenericType() method": [[7, 37]]}}}, {"text": "This is retrieved with Field's getDeclaringClass method", "label": {"api": {"Field's getDeclaringClass method": [[23, 54]]}}}, {"text": "The extends clause data can be retrieved by calling Class's getGenericSuperclass() method, which returns a Type that can be a simple Class, e.g Object, or it could be a ParameterizedType, e.g", "label": {"api": {"Class's getGenericSuperclass() method": [[52, 88]]}}}, {"text": "A class's own type parameters can be retrieved with Class's getTypeParameters() method, which returns an array of TypeVariables", "label": {"api": {"Class's getTypeParameters() method": [[52, 85]]}}}, {"text": "You could use a really simple recursive descent parser that utilizes CharacterIterator, and a builder", "label": {"api": {"CharacterIterator": [[69, 85]]}}}, {"text": "The actual way to get the context-param's param-value is to pass the param-name on the getInitParameter method", "label": {"api": {"getInitParameter": [[87, 102]]}}}, {"text": "See Java Queues for more details", "label": {"api": {"Java Queues": [[4, 14]]}}}, {"text": "As it was already said, Java 1.7 Watch Service is also a solution that could work", "label": {"api": {"Watch Service": [[33, 45]]}}}, {"text": "I haven't used this yet, but it appears you could use Duration.parse()", "label": {"api": {"Duration.parse()": [[54, 69]]}}}, {"text": "You should always use a PreparedStatement to insert/ update data and not use String concatenation", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "This will not only help you with formatting the data correctly but also protect you against SQL injection attacks", "label": {"api": {"formatting the data": [[33, 51]]}}}, {"text": "I think you first have to set a mnemonic key", "label": {"api": {"mnemonic key": [[32, 43]]}}}, {"text": "With \"Alt+mnemonic key\" the related menu should get the focus", "label": {"api": {"mnemonic key": [[10, 21]]}}}, {"text": ") you have to extract an interface annotated by @Local in order to expose your business methods", "label": {"api": {"@Local": [[48, 53]]}}}, {"text": "Use Files.delete(Path) or Files.deleteIfExists(Path) to delete a file (denoted by a Path, see Paths.get(String…) and File.toPath()) as these methods will throw a meaningful IOException on failure whereas only the latter returns a boolean which will indicate success or non-existence but all other conditions are flagged with an exception", "label": {"api": {"Files.delete(Path)": [[4, 21]], "Files.deleteIfExists(Path)": [[26, 51]], "Paths.get(String…)": [[94, 111]], "File.toPath()": [[117, 129]]}}}, {"text": "You should always use the separator as indicated by File.separatorChar or FileSystems.getDefault().getSeparator() when using the nio API", "label": {"api": {"File.separatorChar": [[52, 69]], "FileSystems.getDefault()": [[74, 97]], ".getSeparator()": [[98, 112]]}}}, {"text": "The simplest to emulate would be Observer, a single-method interface, and Observable, a class that holds (in effect) a List<Observer>", "label": {"api": {"Observer": [[33, 40], [124, 131]], "Observable": [[74, 83]]}}}, {"text": "Invoking notifyObservers() traverses the List, calling the update() method of each Observer in the list", "label": {"api": {"Observer": [[15, 22], [83, 90]]}}}, {"text": "The easiest way is to provide a ToolTip", "label": {"api": {"ToolTip": [[32, 38]]}}}, {"text": "setToolTipText is a method of JControl, so this work with other controls as well", "label": {"api": {"ToolTip": [[3, 9]]}}}, {"text": "There are a couple of APIs that work with images that you may want to look at, including at least one that is part of the standard extension library (javax.imageio)", "label": {"api": {"javax.imageio": [[150, 162]]}}}, {"text": "Use BufferedImage.setRGB(x, y, rgb) , where rgb is int that you can get by using Color class like Color(data[x][y],data[x][y],data[x][y]).getRGB()", "label": {"api": {"BufferedImage.setRGB(x, y, rgb)": [[4, 34]], "Color(data[x][y],data[x][y],data[x][y]).getRGB()": [[98, 145]]}}}, {"text": "When you end filling pixels just save with ImageIO.write(bufferedImage, \"bmp\", file)", "label": {"api": {"ImageIO.write(bufferedImage, \"bmp\", file)": [[43, 83]]}}}, {"text": "Have a look at ClassLoader.getClassLoadingLock", "label": {"api": {"ClassLoader.getClassLoadingLock": [[15, 45]]}}}, {"text": "As per http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#substring%28int,%20int%29, if the endIndex is before the startIndex you will get an exception", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#substring%28int,%20int%29": [[7, 94]]}}}, {"text": "You must call the startmethod on the Thread to have run execute in a different Thread", "label": {"api": {"the startmethod": [[14, 28]]}}}, {"text": "You should look into using ArrayLists", "label": {"api": {"ArrayLists": [[27, 36]]}}}, {"text": "You can find out more about the ScheduledExecutorService in the JavaDocs", "label": {"api": {"ScheduledExecutorService in the JavaDocs": [[32, 71]]}}}, {"text": "Annotate it with @XmlTransient", "label": {"api": {"@XmlTransient": [[17, 29]]}}}, {"text": "That constructor doesn't accept an initial element, it accepts the initial size", "label": {"api": {"That constructor": [[0, 15]]}}}, {"text": "Another option would be to put your rawBytes into a DataBuffer, then create a WritableRaster, and finally create a BufferedImage", "label": {"api": {"DataBuffer": [[52, 61]], "create a WritableRaster": [[69, 91]], "BufferedImage": [[115, 127]]}}}, {"text": "Just use the string.contains(s) method", "label": {"api": {"string.contains(s)": [[13, 30]]}}}, {"text": "For compareAndSet, you do have the blurb from the package javadoc", "label": {"api": {"package javadoc": [[50, 64]]}}}, {"text": "Make use of CountDownLatch", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "The sentence as it appears in the documentation of ClassLoader is", "label": {"api": {"Class": [[51, 55]]}}}, {"text": "Every Class object contains a reference to the ClassLoader that defined it", "label": {"api": {"Class": [[6, 10], [47, 51]], "reference": [[30, 38]]}}}, {"text": "What they tell you is that the documentation refers to the Class object, not to the plain object of class ClassA", "label": {"api": {"Class": [[59, 63], [106, 110]]}}}, {"text": "Every class that you define in Java has a Class object associated with it, which allows you to look at that class in the meta level", "label": {"api": {"Class": [[42, 46]]}}}, {"text": "As you have noticed, one way to access the Class object is use ClassA.class", "label": {"api": {"Class": [[43, 47], [63, 67]]}}}, {"text": "If you have a reference to an object of type ClassA", "label": {"api": {"Class": [[45, 49]], "reference": [[14, 22]]}}}, {"text": "Then you can get the Class object using myObj.getClass()", "label": {"api": {"Class": [[21, 25], [49, 53]]}}}, {"text": "So there is no reference to the ClassLoader in the myObj object, Only in its associated Class object", "label": {"api": {"Class": [[32, 36], [88, 92]], "reference": [[15, 23]]}}}, {"text": "Now, the other link tells you how to get the reference to the ClassLoader object once you have a Class object - through the getClassLoader() method", "label": {"api": {"Class": [[62, 66], [97, 101], [127, 131]], "reference": [[45, 53]]}}}, {"text": "Now, if you look at the source code of the Class class, you will see", "label": {"api": {"Class": [[43, 47]]}}}, {"text": "So it calls getClassLoader0() to get the class loader", "label": {"api": {"Class": [[15, 19]]}}}, {"text": "That is, the class loader reference is actually part of the native structure of this Java class, and it is not available to see using Java language tools", "label": {"api": {"reference": [[26, 34]]}}}, {"text": "You have to retrieve the bodystructure first, then loop across the message structure, check the mime type of each part, and download the parts you want", "label": {"api": {"retrieve the bodystructure": [[12, 37]]}}}, {"text": "You could use DatatypeConverter's parseBase64Binary, as follows", "label": {"api": {"DatatypeConverter": [[14, 30]]}}}, {"text": "If you're on Java 8, use java.util.Base64.Encoder to do it for you", "label": {"api": {"java.util.Base64.Encoder": [[25, 48]]}}}, {"text": "You can use ArrayList.add(E) - it will append an element to the array list and allocate the space for it if needed, no need to pre-allocate the desired space for the ArrayList - that's the point of Dynamic Arrays", "label": {"api": {"ArrayList.add(E)": [[12, 27]]}}}, {"text": "If you wish to use loops, you can use a for-each loop, assuming you have your elements in some other array/Iterable", "label": {"api": {"Iterable": [[107, 114]]}}}, {"text": "I am implementing TreeModel interface and have implemented all methods except for the valueForPathChanged", "label": {"api": {"TreeModel interface": [[18, 36]]}}}, {"text": "Why TreeModel interface contains this method", "label": {"api": {"TreeModel interface": [[4, 22]]}}}, {"text": "see Collections.sort() method docs", "label": {"api": {"Collections.sort()": [[4, 21]]}}}, {"text": "The MessageDigest class supports SHA-256", "label": {"api": {"MessageDigest": [[4, 16]]}}}, {"text": "Look into the documentation of the method Matcher.appendReplacement", "label": {"api": {"Matcher.appendReplacement": [[42, 66]]}}}, {"text": "Yet the Java Reflection API only supports reading annotations, not adding them", "label": {"api": {"reading annotations": [[42, 60]]}}}, {"text": "The API doc itself is available online at http://docs.oracle.com/javase/8/docs/api/index.html, but I rather recommend using an IDE where you have Javadoc support", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/index.html": [[42, 92]]}}}, {"text": "You might find it better to defer the processing of the resize event using a ScheduledFuture and a ScheduledExecutorService", "label": {"api": {"ScheduledFuture": [[77, 91]], "ScheduledExecutorService": [[99, 122]]}}}, {"text": "fromDate must be of the type Date not the String representation", "label": {"api": {"Date": [[4, 7], [29, 32]]}}}, {"text": "An ISODate in the MongoDB storage Engine is not equal to the String representation of the same date and so they do not match", "label": {"api": {"Date": [[6, 9]]}}}, {"text": "Moreover, you should use an Iterator when iterating to avoid a ConcurrentModificationException when removing an element from a collection while looping over it", "label": {"api": {"ConcurrentModificationException": [[63, 93]]}}}, {"text": "The iterator has the remove() method, no parameters, that removes the current item from the collection", "label": {"api": {"remove() method": [[21, 35]]}}}, {"text": "For more reading on Java 8 Streams, checkout this excellent tutorial from Oracle or the great JavaDocs", "label": {"api": {"great JavaDocs": [[88, 101]]}}}, {"text": "Java 8 has introduced Collection.removeIf(), which allows you to do", "label": {"api": {"Collection.removeIf()": [[22, 42]]}}}, {"text": "Alternatively, if you did have logic where this was not possible, you could query the size of the insets of the frame, and subtract the left and right inset values from the width, and pass that as the width, and do the same for the height with the top and bottom inset values", "label": {"api": {"insets of the frame": [[98, 116]]}}}, {"text": "You need to use the Double.isNan(double) method", "label": {"api": {"Double.isNan(double) method": [[20, 46]]}}}, {"text": "Yes, you're looking for the java.security and javax.security.auth packages", "label": {"api": {"java.security": [[28, 40]], "javax.security.auth": [[46, 64]]}}}, {"text": "IMO the only worthwhile convenience it provides is attaching security context to a thread using Subject.doAs()", "label": {"api": {"Subject.doAs()": [[96, 109]]}}}, {"text": "The proper solution would be to use a PreparedStatement, in order to avoid having to mess with quoting and enhance security", "label": {"api": {"PreparedStatement": [[38, 54]]}}}, {"text": "ArrayList is a specific (array based) implementation of the List interface", "label": {"api": {"ArrayList": [[0, 8]], "List": [[5, 8], [60, 63]]}}}, {"text": "Since you should only rarely care about the underlying implementation, and this doesn't seem to be one of those rare cases, just change your method signatures to use List in both the argument list and the return value", "label": {"api": {"List": [[166, 169]]}}}, {"text": "As stated in the Deque's javadoc, the Last-methods (addLast, removeLast, etc...) are totally equivalent to the Queue methods", "label": {"api": {"Deque's javadoc": [[17, 31]]}}}, {"text": "Consider using a graphical user interface like Swing (definition on wikipedia), where you can fulfill your input requirements by hooking up a KeyListener to a text box", "label": {"api": {"Swing": [[47, 51]], "KeyListener": [[142, 152]]}}}, {"text": "You forgot to override among others the size() and isEmpty() methods", "label": {"api": {"size()": [[40, 45]], "isEmpty()": [[51, 59]]}}}, {"text": "Moreover, you're never delegating to ArrayList superclass, but keeping an internal ArrayList instance", "label": {"api": {"List": [[42, 45], [88, 91]]}}}, {"text": "One would wonder why you extend from ArrayList at all instead of AbstractList or even List, which would in turn automatically force you to implement the right methods", "label": {"api": {"AbstractList": [[65, 76]], "List": [[42, 45], [73, 76], [86, 89]]}}}, {"text": "An alternative would thus be to delegate to the ArrayList superclass instead of having an internal instance, so that the size() and isEmpty() calls would \"automagically\" return the right values", "label": {"api": {"size()": [[121, 126]], "isEmpty()": [[132, 140]], "List": [[53, 56]]}}}, {"text": "This constructor of File takes 2 arguments", "label": {"api": {"constructor of File": [[5, 23]]}}}, {"text": "You will have to write your own Comparator that splits up the strings into lexical parts and numerical parts and then compare them with the appropriate operator", "label": {"api": {"Comparator": [[32, 41]]}}}, {"text": "The following is a pseudo-code implementation of Comparator's only method compareTo to illustrate what I'm suggesting", "label": {"api": {"Comparator": [[49, 58]]}}}, {"text": "Use pagination + entityManager.clear() after each page", "label": {"api": {"pagination": [[4, 13]]}}}, {"text": "System.err is a PrintStream you can write to that will be output to the standard error stream of the console, for apps running in a console", "label": {"api": {"System.err": [[0, 9]]}}}, {"text": "Error is an error class, which is a Throwable for serious errors that the program probably can't recover from", "label": {"api": {"Error": [[0, 4]]}}}, {"text": "In the normal course of things, you might output error messages to System.err if your program is a command-line program", "label": {"api": {"System.err": [[67, 76]]}}}, {"text": "You are unlikely to directly throw Error or subclass it; instead, for exceptional conditions, you're likely to use one of the Exception classes and/or derive your own", "label": {"api": {"Error": [[35, 39]]}}}, {"text": "See the documentation for ELResolver for details", "label": {"api": {"documentation for ELResolver": [[8, 35]]}}}, {"text": "Use a data structure such as a Set (which does not allow duplicates) and place your KamerType objects in it", "label": {"api": {"Set": [[31, 33]]}}}, {"text": "Make your KamerType class implement the Comparable interface", "label": {"api": {"Comparable": [[40, 49]]}}}, {"text": "If your distribution is likely to change, so you don't want to hard-code your distribution in the way Kevin's answer does, you can use a NavigableMap with the ceilingEntry method", "label": {"api": {"NavigableMap": [[137, 148]], "ceilingEntry": [[159, 170]]}}}, {"text": "You can make it a capturing group ((.*)), and use the Pattern API to get the group from the found match", "label": {"api": {"Pattern API": [[54, 64]]}}}, {"text": "Add the @XmlTransient annotation to your message map property as follows", "label": {"api": {"@XmlTransient": [[8, 20]]}}}, {"text": "If you just need the number of duplicates, an EnumMap with Integer values is probably your best bet", "label": {"api": {"EnumMap": [[46, 52]]}}}, {"text": "LinkedList - Best when there will be many inserts/removals from the beginning of the List", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "Indexing into a LinkedList is very expensive, and should be avoided whenever possible", "label": {"api": {"LinkedList": [[16, 25]]}}}, {"text": "If a List is built by shifting data onto the front of the list, but any later additions are at the end, conversion to an ArrayList once the initial List is built is a good idea - especially if indexing into the List is anticipated at any point", "label": {"api": {"ArrayList": [[121, 129]]}}}, {"text": "ArrayList - When in doubt, this is a good place to start", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "Take out add(panel1) and remove(panel1), and use setContentPane(panel1) instead", "label": {"api": {"setContentPane(panel1)": [[49, 70]]}}}, {"text": "In Java 7, Comparator has just the method compare, while in Java 8 in has a whole lot more methods, all of which have a default implementation directly in the interface and need not to be implemented in a subclass", "label": {"api": {"In Java 7": [[0, 8]], "in Java 8": [[57, 65]]}}}, {"text": "For every method you don't wish to implement (support) just throw UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[66, 94]]}}}, {"text": "If an unsupported operation is invoked, a collection throws an UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[63, 91]]}}}, {"text": "Use the directory(File directory) method on p to give it a working directory and then set the command with the command(String..", "label": {"api": {"directory(File directory)": [[8, 32]]}}}, {"text": "Then, you can do something simple like use the split() function", "label": {"api": {"split()": [[47, 53]]}}}, {"text": "I suggest you read up on the split() method", "label": {"api": {"split()": [[29, 35]]}}}, {"text": "You need a RandomAccessFile", "label": {"api": {"RandomAccessFile": [[11, 26]]}}}, {"text": "As the name says a RandomAccessFile allows positioning anywhere, and read and write", "label": {"api": {"RandomAccessFile": [[19, 34]]}}}, {"text": "Double.doubleToLongBits is how you get this out, and longBitsToDouble is the reverse conversion", "label": {"api": {"Double.doubleToLongBits": [[0, 22]], "longBitsToDouble": [[53, 68]]}}}, {"text": "The Javadoc of longBitsToDouble discusses the details of the conversion", "label": {"api": {"longBitsToDouble": [[15, 30]]}}}, {"text": "Take a look at the URLConnection class, you can use it to open a connection to an URL get the connection's input stream and read only as much bytes as you need, this will work and you won't have to download the entire document, but unfortunately you won't be able to download the document starting from an offset", "label": {"api": {"URLConnection": [[19, 31]]}}}, {"text": "Try closing the EntityManagerFactory instance", "label": {"api": {"closing": [[4, 10]]}}}, {"text": "Make the OneToMany relationship FetchType.LAZY and then simply use JPA queries with Query.setMaxResults()", "label": {"api": {"Query.setMaxResults()": [[84, 104]]}}}, {"text": "You can implement a Comparator that uses the length and use Arrays.sort with your Comparator", "label": {"api": {"Comparator": [[20, 29], [82, 91]], "Arrays.sort": [[60, 70]]}}}, {"text": "The Comparator could look like this", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "Arrays are represented as Strings similarly to what the Object.toString method prints out, that is, with a type and a hash code", "label": {"api": {"Arrays": [[0, 5]]}}}, {"text": "To print your array, you must use the static utility methods of the Arrays class", "label": {"api": {"Arrays": [[68, 73]]}}}, {"text": "In your case, Arrays.deepToString(yourArray) since it has multiple dimensions", "label": {"api": {"Arrays": [[14, 19]]}}}, {"text": "I'd also urge you to use StandardCharsets.UTF_8 if you're using Java 7+", "label": {"api": {"StandardCharsets.UTF_8": [[25, 46]]}}}, {"text": "An easy way of doing it would be to use the contains method of the String Class", "label": {"api": {"String Class": [[67, 78]]}}}, {"text": "Use the javax.json.JsonObject, try the following code", "label": {"api": {"javax.json.JsonObject": [[8, 28]]}}}, {"text": "Try using a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "You'll have to figure out how far in the future the \"go\" time is, and then schedule your task (everything that you do when ok == true) for that many seconds in the future with one of the ScheduledExecutorService.schedule() tasks", "label": {"api": {"ScheduledExecutorService": [[187, 210]]}}}, {"text": "You don't need to use Class.forName(\"com.mysql.jdbc.Driver\"); from the DriverManager Javadoc Applications no longer need to explictly load JDBC drivers using Class.forName()", "label": {"api": {"DriverManager Javadoc": [[71, 91]]}}}, {"text": "From the Javadocs for String.split(String)", "label": {"api": {"Javadocs for String.split(String)": [[9, 41]]}}}, {"text": "There is another mechanism through which drivers are automatically loaded, which relies on service loading since Java 6", "label": {"api": {"service loading": [[91, 105]]}}}, {"text": "You can use the overloaded String#split(String,int) method, and set the limit to a negative number", "label": {"api": {"String#split(String,int)": [[27, 50]]}}}, {"text": "You could use Function.identity() but if you want short then I don't think you'll beat your existing p -> p", "label": {"api": {"Function.identity()": [[14, 32]]}}}, {"text": "Logically a SecretKey represents a symmetric key where as a PrivateKey is part of a PublicKey and Private-Key Pair", "label": {"api": {"SecretKey": [[12, 20]], "PrivateKey": [[60, 69]]}}}, {"text": "You are not accumulating replacements, but instead assign just the last replacement to newText", "label": {"api": {"replace": [[25, 31], [72, 78]]}}}, {"text": "Also, as noted in a comment, be aware that replaceAll actually expects a regular expression, so this might fail, if the strings to be replaced contain any regular expression control characters", "label": {"api": {"replaceAll": [[43, 52]], "replace": [[43, 49], [134, 140]]}}}, {"text": "Instead, you should just use replace, which will also replace all the matching substrings", "label": {"api": {"replace": [[29, 35], [54, 60]]}}}, {"text": "Speaking of regular expressions, you could in fact also use replaceAll with a regular expression covering all your forbidden words, by replacing the , with a | (provided that those words contain no regex control characters)", "label": {"api": {"replaceAll": [[60, 69]], "replace": [[60, 66]]}}}, {"text": "In principle it is easy to remove an element from ConcurrentLinkedQueue or similar implementation", "label": {"api": {"ConcurrentLinkedQueue": [[50, 70]]}}}, {"text": "Save a reference to the object and call ConcurrentLinkedQueue.remove(Object o) with the object - but this forces a traversal of the whole queue in the worst case (and half on average with a random add and removal pattern)", "label": {"api": {"ConcurrentLinkedQueue": [[40, 60]]}}}, {"text": "If you just want to compare occurrences, you can use a map such as a HashMap, TreeMap, or any other implementation", "label": {"api": {"HashMap": [[69, 75]], "TreeMap": [[78, 84]], "other implementation": [[94, 113]]}}}, {"text": "You have to add the Locale when you create the SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[47, 62]]}}}, {"text": "If you check the API for the sort Method it states", "label": {"api": {"API for the sort Method": [[17, 39]]}}}, {"text": "You need to change your List to implement Comparable or you need to use a custom Comparator", "label": {"api": {"Comparator": [[81, 90]]}}}, {"text": "As stated by javadoc CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[21, 40]]}}}, {"text": "TableCellRenderer set to whole column, to change just some rows, you need to implement validation of row numbers inside getTableCellRendererComponent() method", "label": {"api": {"TableCellRenderer": [[0, 16], [123, 139]]}}}, {"text": "Read doc for TableCellRenderer", "label": {"api": {"TableCellRenderer": [[13, 29]]}}}, {"text": "The difference is that a ConcurrentLinkedDeque implements a Deque, which supports addition and removal of elements at both ends (e.g", "label": {"api": {"Deque": [[41, 45], [60, 64]]}}}, {"text": "addFirst and addLast), whereas ConcurrentLinkedQueue implements a Queue which allows insertion at one end called the tail of the queue and removal at the other end, called the head of the queue", "label": {"api": {"Queue": [[47, 51], [66, 70]]}}}, {"text": "Is there any way to apply Predicate#negate() for replacing v -> !v.isEmpty() part", "label": {"api": {"Predicate#negate()": [[26, 43]]}}}, {"text": "In the blocking queue documentation said that the method which examine and block the queue until it becomes non-empty is not applicable", "label": {"api": {"queue documentation": [[16, 34]]}}}, {"text": "Pass it as an argument to String#replace", "label": {"api": {"String#replace": [[26, 39]]}}}, {"text": "You could get month name using DateFormatSymbols.getMonths method as below", "label": {"api": {"DateFormatSymbols.getMonths": [[31, 57]]}}}, {"text": "First, what you most probably need is @XmlMixed", "label": {"api": {"@XmlMixed": [[38, 46]]}}}, {"text": "If you want to get the return value of your thread and throw/catch possible exception, consider use Callable rather than Runnable, and it can be used along with ExecutorService which provide more functionality", "label": {"api": {"Callable": [[100, 107]], "ExecutorService": [[161, 175]]}}}, {"text": "I heard using System.gc() is bad practice, but what else would you recommend in my case", "label": {"api": {"System.gc()": [[14, 24]]}}}, {"text": "No System.gc() needed", "label": {"api": {"System.gc()": [[3, 13]]}}}, {"text": "Without a Character wrapper, the single char would not have any methods associated with it", "label": {"api": {"Character": [[10, 18]]}}}, {"text": "See the documentation for String#length", "label": {"api": {"String#length": [[26, 38]]}}}, {"text": "See the relevant documentation for more information", "label": {"api": {"the relevant documentation": [[4, 29]]}}}, {"text": "You are callig the readLine() method twice", "label": {"api": {"readLine()": [[19, 28]]}}}, {"text": "Use a variable to store the result of readLine(), check whether this variable is null, and then access it", "label": {"api": {"readLine()": [[38, 47]]}}}, {"text": "This lets you assign a weight to an item, and select items randomly based on their weight using the ceilingEntry method", "label": {"api": {"ceilingEntry": [[100, 111]]}}}, {"text": "NoSuchElementException occurs when you try to read input from scanner and when input does not exists", "label": {"api": {"NoSuchElementException": [[0, 21]]}}}, {"text": "These methods would be much simpler if they could simply return a java.awt.Color and let FreeMarker object wrappers take care of the conversion", "label": {"api": {"java.awt.Color": [[66, 79]]}}}, {"text": "In pure Java, you can use a Map<T, Integer> and the new merge method", "label": {"api": {"merge": [[56, 60]]}}}, {"text": "String.concat does not change the String it's called on, it returns a new String which is the concatination of the object it's called on and the parameter", "label": {"api": {"String.concat": [[0, 12]]}}}, {"text": "If you want to accumulate strings, you'd be better served to use a StringBuilder", "label": {"api": {"StringBuilder": [[67, 79]]}}}, {"text": "You can use Math.abs to remove the sign on the subtraction result", "label": {"api": {"Math.abs": [[12, 19]]}}}, {"text": "You could use java.awt.Dimension for this", "label": {"api": {"java.awt.Dimension": [[14, 31]]}}}, {"text": "Since you probably would be waiting for either a read or a write at any given time you can use the read/write methods that accept an attachment + completion handler at any given time", "label": {"api": {"read/write methods": [[99, 116]]}}}, {"text": "From oracle docs getResponseBody() to get a OutputStream to send the response body", "label": {"api": {"From oracle docs": [[0, 15]]}}}, {"text": "Scanner.next blocks on IO to get data from standard input and hence it doesn't terminate", "label": {"api": {"blocks": [[13, 18]]}}}, {"text": "Would an Exchanger help", "label": {"api": {"Exchanger": [[9, 17]]}}}, {"text": "I'm not sure who is swapping what, but an Exchanger would help you do a swap atomically", "label": {"api": {"Exchanger": [[42, 50]]}}}, {"text": "From the documentation of TableRowSorter", "label": {"api": {"documentation of TableRowSorter": [[9, 39]]}}}, {"text": "You are returning Number.class, which does not implement Comparable", "label": {"api": {"Number.class": [[18, 29]]}}}, {"text": "Instead of returning Number.class, you need to return something which actually implements Comparable, such as Integer.class, Double.class, or BigDecimal.class", "label": {"api": {"Number.class": [[21, 32]]}}}, {"text": "After some reading about the difference between validate() , revalidate() and invalidate()(That is not useful) here, I decided that validate() is the one i needed", "label": {"api": {"validate()": [[48, 57], [63, 72], [80, 89], [132, 141]]}}}, {"text": "From what i understood, validate() ask all the child their size and stuff like that and validate that they are ok to proceed", "label": {"api": {"validate()": [[24, 33]]}}}, {"text": "You will need to check for certain input and break from the loop as hasNextInt will wait for input from keyboard", "label": {"api": {"hasNextInt": [[68, 77]]}}}, {"text": "In any event, this functionality could be acheieved by calling BigInteger.add", "label": {"api": {"BigInteger.add": [[63, 76]]}}}, {"text": "One way to do it is by using RequestDispatcher to call a .jsp (JavaServer Pages) clone of your index.html with the parameters posted by your form", "label": {"api": {"RequestDispatcher": [[29, 45]]}}}, {"text": "You need to import RequestDispatcher  (import javax.servlet.RequestDispatcher;) and then you can do something like this in your doPost method", "label": {"api": {"RequestDispatcher": [[19, 35], [60, 76]]}}}, {"text": "Use the Calendar version of truncate", "label": {"api": {"Calendar": [[8, 15]]}}}, {"text": "You want to use a CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[18, 37]]}}}, {"text": "When iterating over a CopyOnWriteArrayList you will not get ConcurrentModificationExceptions as any changes create a new array internally and do not affect the one being iterated over", "label": {"api": {"CopyOnWriteArrayList": [[22, 41]]}}}, {"text": "In order to get desired output, I think you should move the sleep logic into a separate thread or to a SwingWorker", "label": {"api": {"SwingWorker": [[103, 113]]}}}, {"text": "showSaveDialog, from the docs, returns", "label": {"api": {"from the docs": [[16, 28]]}}}, {"text": "Seems you need to call setShowsRootHandles(true), to see them", "label": {"api": {"setShowsRootHandles(true)": [[23, 47]]}}}, {"text": "If you want to iterator in the order that you add the elements, you should use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[81, 93]]}}}, {"text": "This implies that it uses the Comparable or Comparator interface to sort the elements", "label": {"api": {"Comparable": [[30, 39]], "Comparator": [[44, 53]]}}}, {"text": "The LinkedHashMap will sort based on the order that you insert the elements", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "You can register the launcher as a shutdown hook and this will make it execute when the main app will exit (unless it is killed with the actual KILL signal)", "label": {"api": {"shutdown hook": [[35, 47]]}}}, {"text": "To access this information from your code, use the java.util.jar.Manifest class, and specifically the getMainAttributes() method", "label": {"api": {"java.util.jar.Manifest": [[51, 72]]}}}, {"text": "I need to use my own ScheduledExecutorService implementation (in fact it's going to be inherited from the ScheduledThreadPoolExecutor class)", "label": {"api": {"ScheduledExecutorService": [[21, 44]]}}}, {"text": "and I use that method wherever I need to get an implementation of the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[70, 93]]}}}, {"text": "The documentation on Closeable interface states that close method", "label": {"api": {"Closeable": [[21, 29]]}}}, {"text": "You can inspect the last modified time of the file", "label": {"api": {"last modified time": [[20, 37]]}}}, {"text": "You can wrap your canvas in a ScrollPane", "label": {"api": {"ScrollPane": [[30, 39]]}}}, {"text": "Use g.translate(-world.x,world.y) before any other rendering command to do this", "label": {"api": {"g.translate(-world.x,world.y)": [[4, 32]]}}}, {"text": "See the Javadoc for Timer.cancel() (emphasis mine)", "label": {"api": {"Javadoc for Timer.cancel()": [[8, 33]]}}}, {"text": "You can use toArray(), then the String(int[], int, int) constructor", "label": {"api": {"String(int[], int, int)": [[32, 54]]}}}, {"text": "Using codePoints() instead would be more in-keeping with this constructor, which expects code points rather than UTF-16 code units", "label": {"api": {"codePoints()": [[6, 17]]}}}, {"text": "Use a TreeSet instead", "label": {"api": {"TreeSet": [[6, 12]]}}}, {"text": "It orders elements according to their natural ordering, or using an explicit comparator", "label": {"api": {"natural ordering": [[38, 53]], "comparator": [[77, 86]]}}}, {"text": "If you don't supply a Comparator to the TreeSet, then it will rely on its elements being Comparable to sort them", "label": {"api": {"Comparator": [[22, 31]]}}}, {"text": "The TreeSet javadocs explain", "label": {"api": {"TreeSet javadocs": [[4, 19]]}}}, {"text": "The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used", "label": {"api": {"natural ordering": [[37, 52]], "Comparator": [[63, 72]]}}}, {"text": "But the HashMap class is not Comparable, so you must supply a custom Comparator so the TreeSet knows how you want to sort them", "label": {"api": {"Comparator": [[69, 78]]}}}, {"text": "You cannot sort your HashMaps without a Comparator, whether they're in a TreeSet or any other collection", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "More from TreeSet javadocs", "label": {"api": {"TreeSet javadocs": [[10, 25]]}}}, {"text": "What about using Arrays.sort() with a Comparator", "label": {"api": {"Arrays.sort() with a Comparator": [[17, 47]]}}}, {"text": "Note that there is a suitable comparator defined in String, so", "label": {"api": {"suitable comparator defined in String": [[21, 57]]}}}, {"text": "You want to look into the System.arrayCopy() method to create a new copied instance of some array", "label": {"api": {"System.arrayCopy()": [[26, 43]]}}}, {"text": "This can only be done while the frame is not displayable", "label": {"api": {"displayable": [[45, 55]]}}}, {"text": "I guess you are trying to change it while it's displayable", "label": {"api": {"displayable": [[47, 57]]}}}, {"text": "A component is made displayable either when it is added to a displayable containment hierarchy or when its containment hierarchy is made displayable", "label": {"api": {"displayable": [[20, 30], [61, 71], [137, 147]]}}}, {"text": "A containment hierarchy is made displayable when its ancestor window is either packed or made visible", "label": {"api": {"displayable": [[32, 42]]}}}, {"text": "A component is made undisplayable either when it is removed from a displayable containment hierarchy or when its containment hierarchy is made undisplayable", "label": {"api": {"displayable": [[22, 32], [67, 77], [145, 155]]}}}, {"text": "A containment hierarchy is made undisplayable when its ancestor window is disposed", "label": {"api": {"displayable": [[34, 44]]}}}, {"text": "This is also explained in the JavaDoc of DefaultTreeModel.getListener(...)", "label": {"api": {"DefaultTreeModel.getListener(...)": [[41, 73]]}}}, {"text": "You can use Calendar and SimpleDateFormat and do something like this", "label": {"api": {"Calendar": [[12, 19]], "SimpleDateFormat": [[25, 40]]}}}, {"text": "If Java 7, do the equivalent with Files.newDirectoryStream()", "label": {"api": {"Files.newDirectoryStream()": [[34, 59]]}}}, {"text": "I don't see anything in the documentation that provides for checking the status on a TimerTask object (http://docs.oracle.com/javase/1.5.0/docs/api/java/util/TimerTask.html) so one option would be to extend TimerTask and create your own class", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/TimerTask.html": [[103, 171]]}}}, {"text": "The definition of \\s (according to documentation of Pattern class) is [ \\t\\n\\x0B\\f\\r], so the bracket expression is actually barreling through the CRLF line terminator and everything else in its path, until it gets to the end of the whole string", "label": {"api": {"Pattern": [[52, 58]]}}}, {"text": "Split the string into an array (call it labelsIn) of strings using String.split(\",\")", "label": {"api": {"String.split(\",\")": [[67, 83]]}}}, {"text": "If it matches the pattern [A-Z][0-9]+, append it to the labelsOut list", "label": {"api": {"matches the pattern": [[6, 24]]}}}, {"text": "Else, if it matches the pattern ([A-Z])([0-9]+)-\\1([0-9]+) (call the Matcher object match), extract the numbers low and high (using Integer.valueOf(match.group(2)) and Integer.valueOf(match.group(3))) and for all numbers n from low to high, add String.format(\"%s%d\", match.group(1), n) to the labelsOut list", "label": {"api": {"matches the pattern": [[12, 30]], "Matcher": [[69, 75]], "String.format(\"%s%d\", match.group(1), n)": [[245, 284]]}}}, {"text": "The method JOptionPane.showInputDialog(...) you used returns a String object, containing the entered text - so your result have to be a String too", "label": {"api": {"JOptionPane.showInputDialog(...)": [[11, 42]]}}}, {"text": "If you look at the constructors of InputStreamReader, you will notice that you can't instantiate a new one with a String", "label": {"api": {"constructors of InputStreamReader": [[19, 51]]}}}, {"text": "I have tried String.trim() but it doesn't trim U+00A0", "label": {"api": {"String.trim()": [[13, 25]]}}}, {"text": "There are three non-breaking whitespace characters that are excluded from the Character.isWhitespace() method", "label": {"api": {"three non-breaking whitespace": [[10, 38]]}}}, {"text": "If you don't want to limit the user for a size, use an ArrayList instead", "label": {"api": {"ArrayList": [[55, 63]]}}}, {"text": "The  ReadWriteLock javadoc at Oracle and its implementation describe what the lock does and how to use it but doesn't say anything about whether to use the volatile keyword", "label": {"api": {"ReadWriteLock javadoc at Oracle": [[5, 35]], "its implementation": [[41, 58]]}}}, {"text": "For knowing the original card position you should use the setTranslateX (and Y) instead of setLayoutX in your mouse handler", "label": {"api": {"setTranslateX": [[58, 70]]}}}, {"text": "If the user releases the card on a valid place, you set the translate coordinates to 0 and change the layout position or use relocate", "label": {"api": {"relocate": [[125, 132]]}}}, {"text": "change the opacity or apply CSS", "label": {"api": {"opacity": [[11, 17]]}}}, {"text": "It simply relocates the card, i", "label": {"api": {"relocate": [[10, 17]]}}}, {"text": "Try String.getBytes(Charset charset) using StandardCharsets.UTF_16LE instead", "label": {"api": {"String.getBytes(Charset charset)": [[4, 35]], "StandardCharsets.UTF_16LE": [[43, 67]]}}}, {"text": "InetAddress.getLocalHost() is a public static method of InetAddress", "label": {"api": {"InetAddress.getLocalHost()": [[0, 25]]}}}, {"text": "Just split the input on one or more whitespaces (\\\\s+)", "label": {"api": {"split": [[5, 9]]}}}, {"text": "The reason why \"\\.\" is treated differently than \"\\p\" is somewhat evident when you read the summary section of the regular expression constructs, http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#sum, that show all the character classes have letters that follow the '\\', implying that implementors might consider \"\\p\" an error rather than just simply \"p\"", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#sum": [[145, 217]]}}}, {"text": "Or, if you don't want to get told off by people worried about performance, use a StringBuilder", "label": {"api": {"StringBuilder": [[81, 93]]}}}, {"text": "Or just use Arrays.toString(arr) to do the whole thing", "label": {"api": {"Arrays.toString(arr)": [[12, 31]]}}}, {"text": "One solution is to pass a PrintStream to your method", "label": {"api": {"PrintStream": [[26, 36]]}}}, {"text": "When you call the method from your unit test code, pass it a subclass of PrintStream, which collects the output in memory, and compares it to the expected output", "label": {"api": {"PrintStream": [[73, 83]]}}}, {"text": "Just get the milliseconds since epoch from the FileTime", "label": {"api": {"get the milliseconds since epoch": [[5, 36]]}}}, {"text": "See the Java documentation on Patterns", "label": {"api": {"Java documentation on Patterns": [[8, 37]]}}}, {"text": "You need however to make Your class (Note if I am right) implement Comparable or to create a comparator", "label": {"api": {"Comparable": [[67, 76]], "comparator": [[93, 102]]}}}, {"text": "There's Integer#sum(int, int) which is used as you suggest in the package private IntPipeline, but no similar methods for other numerical operators", "label": {"api": {"Integer#sum(int, int)": [[8, 28]]}}}, {"text": "You could use a DecimalFormat to force the number to be formatted as you'd like it", "label": {"api": {"DecimalFormat": [[16, 28]]}}}, {"text": "While sprinter’s answer provides a solution which works in a sequential context, the provided function violates the associativity contract which the specification of reduce mandates", "label": {"api": {"associativity contract": [[116, 137]], "specification of reduce": [[149, 171]]}}}, {"text": "This will fail as soon as you start using parallel streams", "label": {"api": {"parallel": [[42, 49]]}}}, {"text": "This would imply possible instance creations for every operation, therefore I prefer the alternative, using Mutable Reduction where we use a mutable container holding the current value and number of digits", "label": {"api": {"Mutable Reduction": [[108, 124]]}}}, {"text": "Try using Class.getResourceAsStream, as illustrated below", "label": {"api": {"Class.getResourceAsStream": [[10, 34]]}}}, {"text": "See the FileWriter constructor documentation", "label": {"api": {"FileWriter constructor documentation": [[8, 43]]}}}, {"text": "Along with the above, I'm also placing a jar in the classpath to register a listener programmatically, by implementing the ServletContainerInitializer interface", "label": {"api": {"ServletContainerInitializer": [[123, 149]]}}}, {"text": "I would use Math.atan2(dy,dx) to compute angle between current point and target", "label": {"api": {"Math.atan2": [[12, 21]]}}}, {"text": "String provides a constructor designed specifically for this task", "label": {"api": {"constructor": [[18, 28]]}}}, {"text": "DateFormat.parse() returns a java.util.Date, and you're trying to illegally cast it to a java.sql.Date", "label": {"api": {"DateFormat.parse()": [[0, 17]]}}}, {"text": "The line root.setPrefWrapLength(5000); is the important one, as FlowPane.setPrefWrapLength() determines how large (in pixels) the FlowPane will grow", "label": {"api": {"FlowPane.setPrefWrapLength()": [[64, 91]]}}}, {"text": "The maximum width of your FlowPane you should switch from VERTICAL to HORIZONTAL as FlowPane.setPrefWrapLength() will then limit the width of your pane", "label": {"api": {"FlowPane.setPrefWrapLength()": [[84, 111]]}}}, {"text": "If you want to run a native SQL query, you have to use @NamedNativeQuery instead", "label": {"api": {"@NamedNativeQuery": [[55, 71]]}}}, {"text": "If you wish to have a reference to an object without preventing that object from being garbage collected then you must use a a WeakReference", "label": {"api": {"WeakReference": [[127, 139]]}}}, {"text": "LambdaMetafactory creates efficient implementation but currently supports direct method handles only, thus you can’t use a combining handle here", "label": {"api": {"LambdaMetafactory": [[0, 16]]}}}, {"text": "MethodHandleProxies supports arbitrary handles but currently utilizes the Reflection Proxy features whose overhead you wanted to avoid", "label": {"api": {"MethodHandleProxies": [[0, 18]], "Reflection Proxy": [[74, 89]]}}}, {"text": "You can use the DateFormat class to take a Date object and format it so it can be used as part of the filename", "label": {"api": {"DateFormat": [[16, 25]]}}}, {"text": "You can read about the format that the SimpleDateFormat on the API page", "label": {"api": {"DateFormat": [[45, 54]], "the API page": [[59, 70]]}}}, {"text": "Put the copying code into a Task and let it run in a thread", "label": {"api": {"Task": [[28, 31]]}}}, {"text": "Take a look at the Task and Concurrency documentation", "label": {"api": {"Task": [[19, 22]]}}}, {"text": "SelectionKey JavaDoc says this", "label": {"api": {"SelectionKey JavaDoc": [[0, 19]]}}}, {"text": "Use ProcessBuilder instead", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "We have a utility class using HttpURLConnection to get GET response codes, but you could use that same approach to get other methods using the setRequestMethod method", "label": {"api": {"HttpURLConnection": [[30, 46]]}}}, {"text": "Note that in either case, I'd convert the string to text using a fixed encoding via StandardCharsets", "label": {"api": {"StandardCharsets": [[84, 99]]}}}, {"text": "Don't use the platform default (as per your first snippet) and prefer StandardCharsets over magic string values (as per your second snippet)", "label": {"api": {"StandardCharsets": [[70, 85]]}}}, {"text": "If you are referring to the java.sql.Array interface, the documentation for free() states", "label": {"api": {"java.sql.Array": [[28, 41]]}}}, {"text": "java.utils.Arrays does not have a method called free", "label": {"api": {"java.utils.Arrays": [[0, 16]]}}}, {"text": "I think you've stumbled across java.sql.Array instead - this has a free() method", "label": {"api": {"java.sql.Array": [[31, 44]], "free()": [[67, 72]]}}}, {"text": "You can't just write post stream, you have to encode it, for example using URLEncoder", "label": {"api": {"URLEncoder": [[75, 84]]}}}, {"text": "javax.ws.rs.core.MediaType but it does not define values for example like image/jpg etc", "label": {"api": {"javax.ws.rs.core.MediaType": [[0, 25]]}}}, {"text": "You ought to use NumberFormat class.It allows you to parse Strings into a locale aware number", "label": {"api": {"NumberFormat": [[17, 28]]}}}, {"text": "As an alternative, you can use ReentrantLock", "label": {"api": {"ReentrantLock": [[31, 43]]}}}, {"text": "Since you have SwingWorker<Void, Integer>, you have defined Integer as a type to carry out intermediate results by publish and process methods", "label": {"api": {"SwingWorker": [[15, 25]]}}}, {"text": "See SwingWorker for more details", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "You can use the inputStream that you have as the source and use a ByteBuffer to correct the endianess when creating the Strings as needed", "label": {"api": {"ByteBuffer": [[66, 75]]}}}, {"text": "The abort, getNetworkTimeout and getSchema methods were added in Java 7", "label": {"api": {"abort": [[4, 8]], "getNetworkTimeout": [[11, 27]], "getSchema": [[33, 41]]}}}, {"text": "what is the conceptual difference between File in java.io and FileObject in org.apache.commons.vfs2", "label": {"api": {"File": [[42, 45], [62, 65]]}}}, {"text": "I've read the docs at FileObject and File and what I'm really looking for is a conceptual distinction of these two classes", "label": {"api": {"File": [[22, 25], [37, 40]]}}}, {"text": "is FileObject some kind of wrapper around File", "label": {"api": {"File": [[3, 6], [42, 45]]}}}, {"text": "I don't see much in common in their inheritance trees so it doesn't seem to me like FileObject is using File anywhere", "label": {"api": {"File": [[84, 87], [104, 107]]}}}, {"text": "Your \"more callbackish\" answer seems like it'd mostly be solved for you via the CompletionStage API in Java 8 - the lack of a \"runAfterAllAsync\" method means you may have to do some external work to get something to happen after your group of 3 subtasks, but this is where I'd start to look", "label": {"api": {"CompletionStage": [[80, 94]]}}}, {"text": "From the flatMap JavaDocs", "label": {"api": {"flatMap JavaDocs": [[9, 24]]}}}, {"text": "Check out the Optional JavaDocs for more info", "label": {"api": {"Optional JavaDocs": [[14, 30]]}}}, {"text": "Does the ThreadLocal#remove() method actually make the value subject to garbage collection", "label": {"api": {"ThreadLocal#remove()": [[9, 28]]}}}, {"text": "The Java documention (public static double parseDouble(String s) throws NumberFormatException) writes that NumberFormatException is thrown \"if the string does not contain a parsable double\"", "label": {"api": {"public static double parseDouble(String s) throws NumberFormatException": [[22, 92]]}}}, {"text": "It's got nothing to do with Ant - this is just the documented behaviour of Properties.store", "label": {"api": {"Properties.store": [[75, 90]]}}}, {"text": "You can use Class's getEnumConstants() method, which returns an array of all the enum types, if the Class represents an enum, or null if not", "label": {"api": {"Class's getEnumConstants() method": [[12, 44]]}}}, {"text": "You don't need to read next line, nextInt is a better fit here", "label": {"api": {"nextInt": [[34, 40]]}}}, {"text": "public String replace(char oldChar, char newChar) will replace  all occurrences of oldChar in this string with newChar", "label": {"api": {"public String replace(char oldChar, char newChar)": [[0, 48]]}}}, {"text": "You should consider using public String replaceFirst(String regex,String replacement) which replaces the first substring of this string that matches the given regular expression with the given replacement", "label": {"api": {"public String replaceFirst(String regex,String replacement)": [[26, 84]]}}}, {"text": "You can use the String#format() method, where you can specify the length of the output and denote you want it with leading zeros", "label": {"api": {"String#format()": [[16, 30]]}}}, {"text": "In Statement#executeUpdate, we can only execute MySql query but GRANT ALL PRIVILEGES ON 'createtest2'.* TO 'testuser'@'localhost'; is not mysql query", "label": {"api": {"Statement#executeUpdate": [[3, 25]]}}}, {"text": "In case, if you want to do it in java, then you should look at Runtime api of java", "label": {"api": {"Runtime": [[63, 69]]}}}, {"text": "I would suggest making use of the columnResizePolicy", "label": {"api": {"columnResizePolicy": [[34, 51]]}}}, {"text": "To read the file, you can use the Files class", "label": {"api": {"Files": [[34, 38]]}}}, {"text": "Favor the StringBuilder class to StringBuffer", "label": {"api": {"StringBuilder": [[10, 22]], "StringBuffer": [[33, 44]]}}}, {"text": "StringBuilder is faster because its methods are not synchronized (which you don't need in most cases)", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "append() returns StringBuffer for chaining", "label": {"api": {"StringBuffer": [[17, 28]]}}}, {"text": "The java.util.Date only maintains millisecond precision", "label": {"api": {"java.util.Date": [[4, 17]]}}}, {"text": "The java.sql.TimeStamp has nanosecond precision", "label": {"api": {"java.sql.TimeStamp": [[4, 21]]}}}, {"text": "I do not see an automated way to convert between the XMLGregorianCalendar and a TimeStamp, but the getFractionalSeconds should provide access to the level of precision you desire", "label": {"api": {"getFractionalSeconds": [[99, 118]]}}}, {"text": "Java's ParseInt method will happily parse decimal values supplied with a leading zero without throwing an exception, stripping the zero", "label": {"api": {"ParseInt": [[7, 14]]}}}, {"text": "Even better, as @blgt suggested, the HashSet class has a constructor with a Collection parameter, so you can just do", "label": {"api": {"has a constructor": [[51, 67]]}}}, {"text": "You can use the Enum#ordinal method to obtain an int, and the (implicit) Enum#values method to obtain an array of the constants that can be accessed using an int as the index", "label": {"api": {"Enum#ordinal": [[16, 27]]}}}, {"text": "From the documentation for the Preferences class", "label": {"api": {"documentation for the Preferences class": [[9, 47]]}}}, {"text": "The enhanced for-loop uses an Iterator (as returned by the iterator method of any collection) to do its iteration", "label": {"api": {"Iterator": [[30, 37]], "iterator": [[59, 66]]}}}, {"text": "An Iterator is an object that is able to give you the elements of some collection one by one through its next method", "label": {"api": {"Iterator": [[3, 10]], "next": [[105, 108]]}}}, {"text": "The BlockingQueue javadoc states", "label": {"api": {"BlockingQueue javadoc": [[4, 24]]}}}, {"text": "From the File javadoc, a File is", "label": {"api": {"File javadoc": [[9, 20]]}}}, {"text": "The issue here is that the file you try to open does not exists", "label": {"api": {"exists": [[57, 62]]}}}, {"text": "If your file is packed in your JAR, you can try to access it through your ClassLoader getRessource method", "label": {"api": {"getRessource": [[86, 97]]}}}, {"text": "There are a number of ways to get instances of TemporalField", "label": {"api": {"TemporalField": [[47, 59]]}}}, {"text": "Firstly, the enum ChronoField implements TemporalField and contains various constants", "label": {"api": {"TemporalField": [[41, 53]], "ChronoField": [[18, 28]]}}}, {"text": "Secondly, the classes IsoFields and JulianFields contain static TemporalField objects", "label": {"api": {"TemporalField": [[64, 76]], "IsoFields": [[22, 30]], "JulianFields": [[36, 47]]}}}, {"text": "Thirdly, the class WeekFields contains static TemporalField objects and methods to create TemporalField objects based off WeekFields", "label": {"api": {"TemporalField": [[46, 58], [90, 102]], "WeekFields": [[19, 28], [122, 131]]}}}, {"text": "Since Java 8 you can use Duration class", "label": {"api": {"Duration": [[25, 32]]}}}, {"text": "Method.getGenericParameterTypes() will return a ParameterizedType for generic arguments, which can be inspected to extract its type arguments", "label": {"api": {"Method.getGenericParameterTypes()": [[0, 32]], "ParameterizedType": [[48, 64]]}}}, {"text": "So Test.class.getMethod(\"chooseRandom\", List.class).getGenericParameterTypes() should return a single-element array containing a ParameterizedType", "label": {"api": {"ParameterizedType": [[129, 145]]}}}, {"text": "Use the getGenericParameterTypes and getActualTypeArguments methods", "label": {"api": {"getGenericParameterTypes": [[8, 31]], "getActualTypeArguments": [[37, 58]]}}}, {"text": "You may find it easier if you use the Integer.toBinaryString method combined with the String.format and String.replace methods", "label": {"api": {"Integer.toBinaryString": [[38, 59]], "String.format": [[86, 98]], "String.replace": [[104, 117]]}}}, {"text": "Also, you might prefer to use System.nanoTime() if you find yourself needing extra accuracy in your time windows or TimeUnit.SECONDS methods to convert seconds to milliseconds, which can improve readability when dealing with larger windows", "label": {"api": {"System.nanoTime()": [[30, 46]], "TimeUnit": [[116, 123]]}}}, {"text": "The reason why you are seeing that output is because indexOf will return 0 for i = 0 and 6 for i = 1 to 7", "label": {"api": {"indexOf": [[53, 59]]}}}, {"text": "Consider using charAt, in the same way suggested by @ppuskar", "label": {"api": {"charAt": [[15, 20]]}}}, {"text": "You should add a listener to the TableModel", "label": {"api": {"TableModel": [[33, 42]]}}}, {"text": "TableModelEvent contains row and column number and type of modification", "label": {"api": {"TableModel": [[0, 9]], "TableModelEvent": [[0, 14]]}}}, {"text": "TableModelEvent is used to notify listeners that a table model has changed", "label": {"api": {"TableModel": [[0, 9]], "TableModelEvent": [[0, 14]]}}}, {"text": "List is an interface", "label": {"api": {"List": [[0, 3]]}}}, {"text": "ArrayList is an implementation of that interface", "label": {"api": {"List": [[5, 8]], "ArrayList": [[0, 8]]}}}, {"text": "That way you could switch to a LinkedList and not change a return type or other code later on", "label": {"api": {"List": [[37, 40]], "LinkedList": [[31, 40]]}}}, {"text": "The documentation of Integer.parseInt()  clearly states", "label": {"api": {"Integer.parseInt()": [[21, 38]]}}}, {"text": "Look at parseInt(String s, int radix) and toString(int i, int radix), that should help you", "label": {"api": {"parseInt(String s, int radix)": [[8, 36]], "toString(int i, int radix)": [[42, 67]]}}}, {"text": "You can implement a Step class containing all the attributes and store all your steps in a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[91, 103]]}}}, {"text": "And then make a LinkedHashSet of Steps and they will be linked one to an other in the order you inserted them", "label": {"api": {"LinkedHashSet": [[16, 28]]}}}, {"text": "The @MapsId allows you to share the same SQL column with the entity identifier property", "label": {"api": {"@MapsId": [[4, 10]]}}}, {"text": "My bet is that you are using the constructor for Rectangle which accepts point coordinates and dimensions, and you are passing in two points coordinates", "label": {"api": {"which accepts point coordinates and dimensions": [[59, 104]]}}}, {"text": "Well use DefaultListModel and its addElement() method in your while loop to add each result, like the following", "label": {"api": {"DefaultListModel": [[9, 24]]}}}, {"text": "Specifically note this sentence in the documentation of InterruptibleChannel", "label": {"api": {"InterruptibleChannel": [[56, 75]]}}}, {"text": "To do this, one usually reverts to using the SwingUtilities.invokeLater(Runnable runnable)", "label": {"api": {"SwingUtilities.invokeLater(Runnable runnable)": [[45, 89]]}}}, {"text": "I'm using Java's DelayQueue to dispatch events after a second delay", "label": {"api": {"DelayQueue": [[17, 26]]}}}, {"text": "But the problem is that, under heavy load, my consumers on DelayQueue block until considerable bulk of offer() operations from another threads are gone", "label": {"api": {"DelayQueue": [[59, 68]]}}}, {"text": "To make it simpler and faster you could implement the interface Comparable and use sort, i this case you access the List elements by the index in ListElement (assuming you assure the indices are complete from 1..n)", "label": {"api": {"sort": [[83, 86]]}}}, {"text": "My favored solution would be to use some kind of maps to store the index as key, and the ListElement as value, then it's just MapA.get(i).setData(MapB.get(i).getData()) This is fool-prove, as long as for every item in MapA there is an according item in MapB with the same index", "label": {"api": {"maps": [[49, 52]]}}}, {"text": "Use a HashSet in order to ensure uniqueness of the values you're storing", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "You can then check whether the insert was successful by checking what add returns", "label": {"api": {"add": [[70, 72]]}}}, {"text": "If the values have to be 'randomised' you can use your own algorithm, or check out SecureRandom", "label": {"api": {"SecureRandom": [[83, 94]]}}}, {"text": "LinkedHashMap is your best bet", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "What about using StringBuilder#reverse", "label": {"api": {"StringBuilder#reverse": [[17, 37]]}}}, {"text": "Consider using Comparator#comparingInt to create your comparators", "label": {"api": {"Comparator#comparingInt": [[15, 37]]}}}, {"text": "If you'd rather not care about formatting the stack trace yourself, you can also use the printStackTrace(PrintStream) or printStackTrace(PrintWriter) method, which will print the exception details and stack trace to a PrintWriter or PrintStream of your choosing, in the same format that exceptions are normally printed to the console", "label": {"api": {"printStackTrace(PrintStream)": [[89, 116]], "printStackTrace(PrintWriter)": [[121, 148]]}}}, {"text": "if they should be able to type \"stop\" after the last number) then you should consider using a List instead", "label": {"api": {"List": [[94, 97]]}}}, {"text": "You would loop through your string and read the character with `String.charAt(index)'", "label": {"api": {"String.charAt(index)'": [[64, 84]]}}}, {"text": "If you know the number of tasks for T1 and T2, you can use a CountDownLatch", "label": {"api": {"CountDownLatch": [[61, 74]]}}}, {"text": "http://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html#iterator-- I did not find any clarification following up on the links, either", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html#iterator--": [[0, 73]]}}}, {"text": "replaceAll replaces a regex", "label": {"api": {"replaceAll": [[0, 9]], "replace": [[0, 6], [11, 17]]}}}, {"text": "You should use replace instead", "label": {"api": {"replace": [[15, 21]]}}}, {"text": "Instead of replaceAll use replace method of String", "label": {"api": {"replace": [[11, 17], [26, 32]]}}}, {"text": "As \".\" has a special meaning in regex and replaceAll treats source string i.e", "label": {"api": {"replace": [[42, 48]]}}}, {"text": "For desktop programs, you might give a look to the createScreenCapture(Rectangle) method from the java.awt.Robot class to get a BufferedImage with the contents of the screen, and then it is up to you to try to make sense of the image, which would not be easy", "label": {"api": {"createScreenCapture(Rectangle)": [[51, 80]], "java.awt.Robot": [[98, 111]], "BufferedImage": [[128, 140]]}}}, {"text": "From IntSummaryStatistics you can query the average", "label": {"api": {"IntSummaryStatistics": [[5, 24]]}}}, {"text": "I would suggest you use preparedStatement where you wont have to take care of quotes and your SQL will be safe and not vulnerable to SQL injection as it is now in its current form", "label": {"api": {"preparedStatement": [[24, 40]]}}}, {"text": "A URLClassLoader can load class files (optionally packaged in JAR files) from remote servers", "label": {"api": {"URLClassLoader": [[2, 15]]}}}, {"text": "Use a LinkedHashSet to preserve insertion order of elements in a set", "label": {"api": {"LinkedHashSet": [[6, 18]]}}}, {"text": "According to the Java doc of Cell updateItem method, there is slightly different recomended usage than the accepted one", "label": {"api": {"Cell updateItem": [[29, 43]]}}}, {"text": "Use public static void sort(char[] a, int fromIndex, int toIndex) in Arrays class", "label": {"api": {"public static void sort(char[] a, int fromIndex, int toIndex)": [[4, 64]]}}}, {"text": "Check out Arrays.sort()", "label": {"api": {"Arrays.sort()": [[10, 22]]}}}, {"text": "Use Arrays.sort([], int startIndex, int endIndex)", "label": {"api": {"Arrays.sort([], int startIndex, int endIndex)": [[4, 48]]}}}, {"text": "Assuming you're using Servlet 3.0+, just use HttpServletRequest#getParts()", "label": {"api": {"HttpServletRequest#getParts()": [[45, 73]]}}}, {"text": "Then use Collections.sort(List<Float[]>,Comparator<Float>) to sort your array", "label": {"api": {"Collections.sort(List<Float[]>,Comparator<Float>)": [[9, 57]]}}}, {"text": "If you have a javax.net.ssl.SSLSocket class reference in your code, you can set the enabled TLS protocols by a call to SSLSocket.setEnabledProtocols()", "label": {"api": {"javax.net.ssl.SSLSocket": [[14, 36]], "SSLSocket.setEnabledProtocols()": [[119, 149]]}}}, {"text": "Date#getTime returns the \"number of milliseconds since January 1, 1970, 00:00:00 GMT\", you cannot use equals on it since it's a long, see its signature", "label": {"api": {"Date#getTime": [[0, 11]]}}}, {"text": "The equals method defined in Date just checks if the getTime() returns the same for both object", "label": {"api": {"Date": [[29, 32]]}}}, {"text": "However, at least one subclass of Date (java.sql.Timestamp) overrides equals and changes its meaning to be inconsistent with its baseclass", "label": {"api": {"Date": [[34, 37]], "java.sql.Timestamp": [[40, 57]]}}}, {"text": "So if one of your Date objects happened to be a Timestamp, then its equals method could produce a different result", "label": {"api": {"Date": [[18, 21]]}}}, {"text": "Did you read its Javadoc", "label": {"api": {"its Javadoc": [[13, 23]]}}}, {"text": "I'm pretty sure you instead want to use a JMS BytesMessage", "label": {"api": {"BytesMessage": [[46, 57]]}}}, {"text": "A good example from the JDK itself is the flags set when compiling a Pattern", "label": {"api": {"Pattern": [[69, 75]]}}}, {"text": "To properly print it, you could use Arrays.toString(Object[])", "label": {"api": {"Arrays.toString(Object[])": [[36, 60]]}}}, {"text": "Second approach is quite easy with Files class and its copy(source, target, copyOptions...) method", "label": {"api": {"copy(source, target, copyOptions...)": [[55, 90]]}}}, {"text": "In comparison, an ArrayList is built upon an array and therefore allows very quick access to arbitrary indexes", "label": {"api": {"ArrayList": [[18, 26]]}}}, {"text": "Let's look at the documentation for LinkedList", "label": {"api": {"LinkedList": [[36, 45]]}}}, {"text": "And for ArrayList", "label": {"api": {"ArrayList": [[8, 16]]}}}, {"text": "So, because of the way Linked Lists work, this code will take more time with a Linked List compared to an ArrayList", "label": {"api": {"ArrayList": [[106, 114]]}}}, {"text": "The PreparedStatement.setCharacterStream() method was added to JDBC 4 and according to C3P0 release notes", "label": {"api": {"PreparedStatement.setCharacterStream()": [[4, 41]]}}}, {"text": "Java possesses the function Math.random() which returns a number that varies between 0 and 1", "label": {"api": {"a number that varies between 0 and 1": [[56, 91]]}}}, {"text": "hashCode() is just a \"short cut\" for equals()", "label": {"api": {"equals()": [[37, 44]]}}}, {"text": "This violates the general contract of Object.equals()", "label": {"api": {"equals()": [[45, 52]]}}}, {"text": "If you're interested in plugging in different sorting schemes, you're much better off working with different Comparator<Car>s that each implement your scheme", "label": {"api": {"Comparator<Car>": [[109, 123]]}}}, {"text": "While the same restriction applies in the Comparator API1, it lets you represent less than and greater than, which it sounds like you're really after and which can't be done via Object.equals()", "label": {"api": {"equals()": [[185, 192]]}}}, {"text": "I am not sure this is exactly what you want, but you can look at the current Thread's stack trace", "label": {"api": {"stack trace": [[86, 96]]}}}, {"text": "The problem is that the class name may be a super class of the actual class calling you", "label": {"api": {"class name": [[24, 33]]}}}, {"text": "I'm writing my own Java GUI component, which will extend javax.swing.JComponent and use its #paint(Graphics) method to paint text on itself with the java.awt.Graphics#drawString(String, int, int) method", "label": {"api": {"javax.swing.JComponent": [[57, 78]], "#paint(Graphics)": [[92, 107]], "java.awt.Graphics#drawString(String, int, int)": [[149, 194]]}}}, {"text": "As a general approach, you can use Arrays.sort to sort an array in place, i.e., the order of the elements in the array will change", "label": {"api": {"Arrays.sort": [[35, 45]]}}}, {"text": "As you want the array in an object to be sorted, its better to do in-place sort of the array using Arrays.sort", "label": {"api": {"Arrays.sort": [[99, 109]]}}}, {"text": "You can do this by adding a PropertyChangeListener to the JFileChooser", "label": {"api": {"PropertyChangeListener": [[28, 49]]}}}, {"text": "Inside the propertyChange() method check if the property name is JFileChooser.DIRECTORY_CHANGED_PROPERTY", "label": {"api": {"propertyChange()": [[11, 26]], "JFileChooser.DIRECTORY_CHANGED_PROPERTY": [[65, 103]]}}}, {"text": "If it is, just call the JFileChooser.approveSelection() method which will close the file chooser dialog", "label": {"api": {"JFileChooser.approveSelection()": [[24, 54]]}}}, {"text": "For this purpose use the constructor of JFileChooser to set the initial/current folder (you can pass the folder either as a File or String), or you can set it after the constructor by calling JFileChooser.setCurrentDirectory()", "label": {"api": {"JFileChooser.setCurrentDirectory()": [[192, 225]]}}}, {"text": "With Java 9, you can now use the static factory method List::of to create an immutable empty list", "label": {"api": {"List::of": [[55, 62]]}}}, {"text": "When you change the folder in the \"Look in:\" combo box, only one PropertyChangeEvent is fired with the property name", "label": {"api": {"PropertyChangeEvent": [[65, 83]]}}}, {"text": "Note though that changing the current folder in the \"Look in:\" combo box is not the only event that generates a PropertyChangeEvent with property name DIRECTORY_CHANGED_PROPERTY, for example if you double click on a folder in the file list, that also generates this event (amongst other events like SELECTED_FILE_CHANGED_PROPERTY)", "label": {"api": {"PropertyChangeEvent": [[112, 130]], "SELECTED_FILE_CHANGED_PROPERTY": [[299, 328]]}}}, {"text": "After some experimentation I was able to correct the problem using ProcessBuilder and an answer for ProcessBuilder OpenFiles problem", "label": {"api": {"ProcessBuilder": [[67, 80], [100, 113]]}}}, {"text": "I can't find an Immutable version of EnumSet", "label": {"api": {"EnumSet": [[37, 43]]}}}, {"text": "If I can, what are some benefits/drawbacks of using an ImmutableSet instead of the EnumSet", "label": {"api": {"EnumSet": [[83, 89]]}}}, {"text": "Or more easily using Arrays.copyOf()", "label": {"api": {"Arrays.copyOf()": [[21, 35]]}}}, {"text": "None of the constructors or behaviours on the JMenuItem seem to allow for String formatting", "label": {"api": {"constructors": [[12, 23]]}}}, {"text": "You should consider using a JDialog box or something similar to bring up a screen where you can display your formatted rules", "label": {"api": {"JDialog": [[28, 34]]}}}, {"text": "After you're done iterating the original map, you can call the putAll method on it, passing your new map, to apply all of the modifications you want", "label": {"api": {"the putAll method": [[59, 75]]}}}, {"text": "See the documentation here", "label": {"api": {"documentation here": [[8, 25]]}}}, {"text": "See documentation of java.lang.Object for a list of methods what every class supports \"out of the box\"", "label": {"api": {"java.lang.Object": [[21, 36]]}}}, {"text": "The \"right\" way to do this would be with a Set, but it sounds like you can't use those yet", "label": {"api": {"Set": [[43, 45]]}}}, {"text": "For example, you could use the FileChannel.transferFrom method to transfer the content", "label": {"api": {"FileChannel.transferFrom": [[31, 54]]}}}, {"text": "Another example would be to use a direct ByteBuffer to transfer the content", "label": {"api": {"direct": [[34, 39]]}}}, {"text": "Use the DecimalFormat class to ensure that only the right number of decimals show up", "label": {"api": {"DecimalFormat": [[8, 20]]}}}, {"text": "The interface to zlib's inflate in Java is the Inflater class (unfortunately spelled wrong -- it should be Inflator)", "label": {"api": {"Inflater class": [[47, 60]]}}}, {"text": "You're better off with the TreeMap", "label": {"api": {"TreeMap": [[27, 33]]}}}, {"text": "Use the JDK, especially java.lang.String.parseInt(String s) and java.lang.Integer.toHexString(int i)", "label": {"api": {"java.lang.String.parseInt(String s)": [[24, 58]], "java.lang.Integer.toHexString(int i)": [[64, 99]]}}}, {"text": "Use java.lang.String.split(String regex)", "label": {"api": {"java.lang.String.split(String regex)": [[4, 39]]}}}, {"text": "I followed this example for signing and verification", "label": {"api": {"this example": [[11, 22]]}}}, {"text": "Use JavaFX's DirectoryChooser", "label": {"api": {"JavaFX's DirectoryChooser": [[4, 28]]}}}, {"text": "A Socket can only be used to 1 active connection at the most", "label": {"api": {"Socket": [[2, 7]]}}}, {"text": "And since you connect at the beginning of your port scan (and only close it at the end), any further attempt to connect (by calling the connect() method) will throw a SocketException", "label": {"api": {"Socket": [[167, 172]]}}}, {"text": "Print the message of your SocketException to verify this which will be", "label": {"api": {"Socket": [[26, 31]]}}}, {"text": "Create a new Socket before each attempt", "label": {"api": {"Socket": [[13, 18]]}}}, {"text": "Note that a Socket cannot be reused for multiple/new connections", "label": {"api": {"Socket": [[12, 17]]}}}, {"text": "Quoting from the Javadoc of Socket.close()", "label": {"api": {"Socket": [[28, 33]], "Socket.close()": [[28, 41]]}}}, {"text": "The method JList.getSelectedIndices returns an array of currently selected indexes, and getSelectedValuesList() returns the actual items depending on what you want...", "label": {"api": {"JList.getSelectedIndices": [[11, 34]]}}}, {"text": "Using the Scanner can make things a bit easier, since it provides more methods you can use to retrieve input, such as nextFloat and nextInt and also methods such as hasNextDouble that can be used to verify the input", "label": {"api": {"Scanner": [[10, 16]]}}}, {"text": "The InputStream (System.in) is more limited in functionality and only provide a few read methods, meaning it might require extra manual work", "label": {"api": {"InputStream": [[4, 14]]}}}, {"text": "To read standard input from the console (such as doubles, ints, etc) I would use the new Scanner(System.in) approach", "label": {"api": {"Scanner": [[89, 95]]}}}, {"text": "The Thread documentation provides examples of usage", "label": {"api": {"Thread documentation": [[4, 23]]}}}, {"text": "This code creates a set of enums using optimized EnumSet class", "label": {"api": {"EnumSet": [[49, 55]]}}}, {"text": "A good place might be to start with the Class documentation", "label": {"api": {"the Class documentation": [[36, 58]]}}}, {"text": "You should use the Class.getInterfaces() and Class.getSuperclass() methods", "label": {"api": {"Class.getInterfaces()": [[19, 39]], "Class.getSuperclass()": [[45, 65]]}}}, {"text": "This will probably not help you understanding the low-level threading mechanics, but for your case it would make sense to use a CyclicBarrier with a barrierAction", "label": {"api": {"CyclicBarrier": [[128, 140]]}}}, {"text": "The declaration of the EntityManager methods are the following", "label": {"api": {"EntityManager": [[23, 35]]}}}, {"text": "Some annotations (specifically @SafeVarargs) only exist on some of these compiler versions and generate errors in others", "label": {"api": {"@SafeVarargs": [[31, 42]]}}}, {"text": "Especially for something like @SafeVarargs, which serves mostly as a marker to suppress warnings rather than actually changing the output of the compiler, I would like to be able to use these annotations and simply provide a dummy-implementation if an earlier compiler is missing them", "label": {"api": {"@SafeVarargs": [[30, 41]]}}}, {"text": "If you want to use an unbounded concurrent queue I would recommend taking a look at thread-safe implementations of Deque, for instance LinkedBlockingDeque", "label": {"api": {"LinkedBlockingDeque": [[135, 153]]}}}, {"text": "LinkedBlockingDeque can be unbounded and take() will block the calling thread if the queue is empty", "label": {"api": {"LinkedBlockingDeque": [[0, 18]]}}}, {"text": "If you want to use the JTextField, it has the method JTextArea#setTabSize(int), with which you can reduce the tabwidth", "label": {"api": {"JTextArea#setTabSize(int)": [[53, 77]]}}}, {"text": "For complete date and time patterns, please refer to this java.text.SimpleDateFormat JavaDoc", "label": {"api": {"java.text.SimpleDateFormat": [[58, 83]]}}}, {"text": "Maybe another approach could be implementing the Comparable interface, and this would force you to implement the compareTo method", "label": {"api": {"Comparable interface": [[49, 68]]}}}, {"text": "String.contains does not use regular expressions", "label": {"api": {"String.contains": [[0, 14]]}}}, {"text": "But let's back up a few steps, it's easier to understand what an Observable is if you compare it to an Iterator (push vs", "label": {"api": {"Iterator": [[103, 110]]}}}, {"text": "Iterator.next() is equivalent to Observable.onNext() - when the next item/event occurs - consume it", "label": {"api": {"Iterator": [[0, 7]]}}}, {"text": "Iterator.hasNext() is equivalent to Observable.onComplete() - it allows the publisher to notify the subscriber that there are no more events to consume (one thing that was missing in the EventListener model)", "label": {"api": {"Iterator": [[0, 7]]}}}, {"text": "For the third, Observable.onError() there is no equivalent, because with Iterator, when you try to get next() or remove() you know that you might get NoSuchElementException, UnsupportedOperationException or IllegalStateException and you can catch and handle any of them since you're doing it synchronously", "label": {"api": {"Iterator": [[73, 80]]}}}, {"text": "Here is further reference", "label": {"api": {"reference": [[16, 24]]}}}, {"text": "There I use a Map to store the file content and print it later", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "Use the PrintStream class to print the OutputStream", "label": {"api": {"PrintStream": [[8, 18]]}}}, {"text": "In case you need to address these concerns, it is better to use the localized field WeekFields.dayOfWeek()", "label": {"api": {"WeekFields.dayOfWeek()": [[84, 105]]}}}, {"text": "In this case simply List.isEmpty() will tell you if the list is empty", "label": {"api": {"List.isEmpty()": [[20, 33]]}}}, {"text": "You can generalize your code to something like this which works for not just ArrayLists but for all Collections (lists, sets, etc.) and with any element type not just your custom SubjectListStructure type", "label": {"api": {"Collection": [[100, 109]]}}}, {"text": "Note that the enhanced for uses the Collection.iterator() to obtain an Iterator to walk over elements of the collection", "label": {"api": {"Collection": [[36, 45]], "Collection.iterator()": [[36, 56]], "Iterator": [[71, 78]]}}}, {"text": "Normally you annotate the Java class attributes with @XmlElement to indicate that they are from a value of an XML tag, you can use @XmlAttribute to indicate that the Java attribute is in an attribute of an XML tag", "label": {"api": {"@XmlElement": [[53, 63]], "@XmlAttribute": [[131, 143]]}}}, {"text": "And you can unmarshal the result XML using the JAXB class like this (here I assumed the XML data is in file \"result.txt\")", "label": {"api": {"JAXB": [[47, 50]]}}}, {"text": "If your XML is present in a StringBuffer, StringBuilder or as a String, you can unmarshal it by creating a StringReader as the source instead of a File", "label": {"api": {"StringReader": [[107, 118]]}}}, {"text": "Please look at http://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#parse%28java.lang.String,%20java.text.ParsePosition%29 before telling me that I should use a pattern or anything else", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#parse%28java.lang.String,%20java.text.ParsePosition%29": [[15, 135]]}}}, {"text": "I would suggest you try encoding you url", "label": {"api": {"encoding": [[24, 31]]}}}, {"text": "How about using System.arraycopy()", "label": {"api": {"System.arraycopy()": [[16, 33]]}}}, {"text": "You can use a ByteBuffer", "label": {"api": {"ByteBuffer": [[14, 23]]}}}, {"text": "JColorChooser is probably what you want in most instances it's easy to implement and easy to use", "label": {"api": {"JColorChooser": [[0, 12]]}}}, {"text": "A WindowListener is probably what you need", "label": {"api": {"WindowListener": [[2, 15]]}}}, {"text": "You can serialize the object in its windowClosing method", "label": {"api": {"windowClosing": [[36, 48]]}}}, {"text": "First, from the documentation of Stream", "label": {"api": {"Stream": [[33, 38]]}}}, {"text": "If Collection would implement Stream every collection would be a stream, which it is conceptually not", "label": {"api": {"Stream": [[30, 35]]}}}, {"text": "If every class that implements Collection had to implement the operations of Stream as well, it would have two (kind of) different purposes and might become too long", "label": {"api": {"Stream": [[77, 82]]}}}, {"text": "here's BufferedReader.readLine()'s documentation, which clearly states it removes your trailing line break", "label": {"api": {"BufferedReader.readLine()'s documentation": [[7, 47]]}}}, {"text": "Since you don't care about the rest, you can just use String.charAt(int) with Character.isSpaceChar(char), or String.codePointAt(int) with Character.isSpaceChar(int)", "label": {"api": {"String.charAt(int)": [[54, 71]], "Character.isSpaceChar(char)": [[78, 104]], "String.codePointAt(int)": [[110, 132]], "Character.isSpaceChar(int)": [[139, 164]]}}}, {"text": "At the root cause of your problem is within the constructor ObjectInputStream", "label": {"api": {"constructor ObjectInputStream": [[48, 76]]}}}, {"text": "in java 8+ ConcurrentHashMap as a compute() function that allows you to do atomic read-modify-write operation on a single key, so you could do something like", "label": {"api": {"compute() function": [[34, 51]]}}}, {"text": "Look - for example - at a WindowAdapter", "label": {"api": {"WindowAdapter": [[26, 38]]}}}, {"text": "It implements the WindowListener interface (among others), but provides empty not-doing-anything method implementations", "label": {"api": {"WindowListener": [[18, 31]]}}}, {"text": "Then your own class simply extends WindowAdapter instead of implementing WindowListener", "label": {"api": {"WindowAdapter": [[35, 47]], "WindowListener": [[73, 86]]}}}, {"text": "For example, HttpServlet class, an example of template method design pattern where each method already has a behaviour defined", "label": {"api": {"HttpServlet": [[13, 23]]}}}, {"text": "Once you have understood and mastered prepared statements you perhaps want to move to a more elaborate data model whit object to relational mapping as available in javax.persistence and its famous Hibernate implementation", "label": {"api": {"javax.persistence": [[164, 180]]}}}, {"text": "To show the dialog on a display that is not your default, you have to get the bounds (Rectangle) of the desired display, and you can position your dialog to be inside that area", "label": {"api": {"Rectangle": [[86, 94]]}}}, {"text": "Code taken from the Javadoc of GraphicsConfiguration)", "label": {"api": {"GraphicsConfiguration": [[31, 51]]}}}, {"text": "You could try using ArrayLists - http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[33, 97]]}}}, {"text": "Having compareTo is not enough; you also need to implement the Comparable<Card> interface, e.g.", "label": {"api": {"Comparable<Card>": [[63, 78]]}}}, {"text": "Understanding the error message Card cannot be cast to java.lang.Comparable is important", "label": {"api": {"Comparable": [[65, 74]]}}}, {"text": "It pretty much tells you your objects are not of type Comparable", "label": {"api": {"Comparable": [[54, 63]]}}}, {"text": "If you look at the implementation of Arrays.sort(Object[]) you will notice a cast of your objects to the Comparable type", "label": {"api": {"Comparable": [[105, 114]]}}}, {"text": "If your class does not implement Comparable interface, you will get that error", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "You can use a ConcurrentSkipListSet for this task, the Set will be based on a Comparator that first checks the tags and then defines which is bigger", "label": {"api": {"ConcurrentSkipListSet": [[14, 34]], "Comparator": [[78, 87]]}}}, {"text": "When I try to execute it from a Java process, I get an ImportError", "label": {"api": {"process": [[37, 43]]}}}, {"text": "But the method returns false and I suspect that \"yyyy-MM-dd HH-mm:ss\" is incorrect but I didn't found any solution (SimpleDateFormat java doc)", "label": {"api": {"SimpleDateFormat java doc": [[116, 140]]}}}, {"text": "From the Image javadoc", "label": {"api": {"Image javadoc": [[9, 21]]}}}, {"text": "Take a look at JSlider#updateLabelUIs() (Java Platform SE 8 )", "label": {"api": {"JSlider#updateLabelUIs() (Java Platform SE 8 )": [[15, 60]]}}}, {"text": "A Map.Entry is a key-value pair, as returned in the view Map.entrySet()", "label": {"api": {"Map.entrySet()": [[57, 70]]}}}, {"text": "Double.valueOf(String) does not take the default locale into account", "label": {"api": {"Double.valueOf(String)": [[0, 21]]}}}, {"text": "Use, for example, DecimalFormat instead to parse the string", "label": {"api": {"DecimalFormat": [[18, 30]]}}}, {"text": "Use DateFormat for that issue", "label": {"api": {"DateFormat": [[4, 13]]}}}, {"text": "You can use management bean notifications and subscribe to GARBAGE_COLLECTION_NOTIFICATION events which in turn provide GcInfo objects with the stats you want", "label": {"api": {"notifications": [[28, 40]], "GARBAGE_COLLECTION_NOTIFICATION": [[59, 89]]}}}, {"text": "The javax.management package javadocs have a high level overview how to use those services", "label": {"api": {"javax.management package javadocs": [[4, 36]]}}}, {"text": "You can use the Node's methods setUserData and getUserData to store various information like whether you clicked a button or not", "label": {"api": {"setUserData": [[31, 41]], "getUserData": [[47, 57]]}}}, {"text": "As an alternative you could use a BitSet to store a boolean state", "label": {"api": {"BitSet": [[34, 39]]}}}, {"text": "However, if all you want is a random port that Jetty can startup and listen on, just set the port that Jetty should use to 0, and that will tell TCP to randomly assign an available port when binding for listening", "label": {"api": {"TCP to randomly assign an available port when binding for listening": [[145, 211]]}}}, {"text": "Marker Interfaces were the only way to declare metadata about a class in early versions of Java e.g Serializable says the implementing class will behave correctly when serialize/deserialize will be called", "label": {"api": {"Serializable": [[100, 111]]}}}, {"text": "Take a look at the JarFile class", "label": {"api": {"JarFile": [[19, 25]]}}}, {"text": "This will NOT work while running the application in Eclipse though (since there is no JarFile there to be scanned)", "label": {"api": {"JarFile": [[86, 92]]}}}, {"text": "You could try the method .toArray() to convert it to a true 2-D array", "label": {"api": {".toArray()": [[25, 34]]}}}, {"text": "I highly recommend you to go though the String API, there are many methods that can help you with your problem", "label": {"api": {"String API": [[40, 49]]}}}, {"text": "I already know that Cookie.setMaxAge() would do that, but when I tried this inside the OnClose() method on the server, the server threw a NullPointerException", "label": {"api": {"Cookie.setMaxAge()": [[20, 37]]}}}, {"text": "Use the getParentFile method from standard Java", "label": {"api": {"getParentFile": [[8, 20]]}}}, {"text": "HttpServletRequest#getProtocol() will return an empty String for HTTP/0.9 requests in Jetty 8", "label": {"api": {"HttpServletRequest#getProtocol()": [[0, 31]]}}}, {"text": "See parse method in documentation", "label": {"api": {"parse method in documentation": [[4, 32]]}}}, {"text": "You can set the whole workspace to UTF-8, it will still treat properties files as ISO 8859-1 - because that's the default/expected encoding", "label": {"api": {"that's the default/expected encoding": [[103, 138]]}}}, {"text": "You can use the Random class to generate a random number between 0 (inclusive) and your list's length (exclusive), and print the value at that index", "label": {"api": {"Random": [[16, 21]]}}}, {"text": "Math.sqrt(num) returns a value, it does not set the value", "label": {"api": {"Math.sqrt(num)": [[0, 13]]}}}, {"text": "The common fork join pool will be used by default for parallel stream processing", "label": {"api": {"common": [[4, 9]]}}}, {"text": "I checked the SimpleDateFormat javadoc, but I am not able to find a way to parse the ordinal indicator in a date format like this", "label": {"api": {"SimpleDateFormat javadoc": [[14, 37]]}}}, {"text": "You can make use of the Collections.sort(List) method which will perform a merge sort for you", "label": {"api": {"Collections.sort(List)": [[24, 45]]}}}, {"text": "But before you can use it you should make your custom class implement Comparable", "label": {"api": {"Comparable": [[70, 79]]}}}, {"text": "When implementing Comparable, you will need to implement the compareTo(myClass o) method and perform the comparison inside that method on whatever member you desire", "label": {"api": {"Comparable": [[18, 27]]}}}, {"text": "Use the Collections.sort method with a provided Comparator, or make your object implement Comparable", "label": {"api": {"Collections.sort": [[8, 23]]}}}, {"text": "Arrays cannot be converted to strings natively, so the default toString() implementation is invoked on the array", "label": {"api": {"default toString() implementation": [[55, 87]]}}}, {"text": "Use System.arrayCopy to copy the contents from the original array to the newly created (larger) array", "label": {"api": {"System.arrayCopy": [[4, 19]]}}}, {"text": "If you call the Scanner function next() when there is nothing left to read, it will throw a NoSuchElementException", "label": {"api": {"next()": [[33, 38]]}}}, {"text": "See the API documentation for SimpleDateFormat to see what the different pattern letters mean", "label": {"api": {"the API documentation for SimpleDateFormat": [[4, 45]]}}}, {"text": "The Raster method getSamples() extracts the values of each color band from the BufferedImage", "label": {"api": {"Raster": [[4, 9]]}}}, {"text": "A ColorConvertOp is used to convert the sample image to grayscale, as shown here and here", "label": {"api": {"ColorConvertOp": [[2, 15]]}}}, {"text": "I'd treat the string as an array of chars, and use Character.digit(int, int) to convert each character to the corresponsing int", "label": {"api": {"Character.digit(int, int)": [[51, 75]]}}}, {"text": "The ConcurrentLinkedDequeue and ConcurrentLinkedQueue in the jre provide behavior similar to what is described", "label": {"api": {"ConcurrentLinkedDequeue": [[4, 26]], "ConcurrentLinkedQueue": [[32, 52]]}}}, {"text": "As the example in the Java API docs for javax.swing.Timer shows", "label": {"api": {"Java API docs": [[22, 34]]}}}, {"text": "Use the Java API docs if you're unsure how something works", "label": {"api": {"Java API docs": [[8, 20]]}}}, {"text": "You can split the content of your html file with regex look-ahead (?=subexpr) and look-behind (?<=subexpr) (effectively describing zero-length delimiters) into tags and non-tags, distinguishing between both groups with another regex <.*>", "label": {"api": {"split": [[8, 12]]}}}, {"text": "split uses Pattern and Matcher behind the covers, but for very simple cases (which yours might be)", "label": {"api": {"Pattern": [[11, 17]]}}}, {"text": "Unless you're doing this as an exercise, you might want to look at the Files class in the Java API", "label": {"api": {"Files": [[71, 75]]}}}, {"text": "I have searched how to convert string \"4+5\" to math expression and i only found that i should use ScriptEngine but when i import the library in android studio it doesn't seem to work", "label": {"api": {"ScriptEngine": [[98, 109]]}}}, {"text": "Instead of using a debugger and attaching one remotely, why don't you create an uncaught exception handler using Thread.UncaughtExceptionHandler", "label": {"api": {"uncaught exception handler": [[80, 105]]}}}, {"text": "it eventually calls Double.toString(double) which mentions that the result is approximate", "label": {"api": {"Double.toString(double)": [[20, 42]]}}}, {"text": "If you must write each character, use the append flag to tell the writer not to overwrite the file", "label": {"api": {"append": [[42, 47]]}}}, {"text": "You can reverse a list in-place using Collections.reverse(list)", "label": {"api": {"Collections.reverse(list)": [[38, 62]]}}}, {"text": "You could use a Scanner to iterate through each file, and then increment an integer for every line that there is", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "Next time you are stuck, the Java API pages are very helpful for finding new methods", "label": {"api": {"Java API pages": [[29, 42]]}}}, {"text": "If you just need to know the implementors in Java standard edition, they're listed in the Externalizable javadoc", "label": {"api": {"Externalizable javadoc": [[90, 111]]}}}, {"text": "This is a wheel that's already been invented", "label": {"api": {"already been invented": [[23, 43]]}}}, {"text": "It extends Vector, and therefore supports operations such as get(int) and add(int,E)", "label": {"api": {"extends Vector": [[3, 16]]}}}, {"text": "The Comparator<T> interface is a generic interface", "label": {"api": {"Comparator<T>": [[4, 16]]}}}, {"text": "If you are using Java8 you can use a SwingNode to host swing components such as a ChartPanel", "label": {"api": {"SwingNode": [[37, 45]]}}}, {"text": "SwingNode is a JavaFX component that allows you to set a swing component that will be displayed in the JavaFX scene", "label": {"api": {"SwingNode": [[0, 8]]}}}, {"text": "This means the ChartPanel must always be created and updated on the Swing EDT and the SwingNode must always be updated on the JavaFX application thread", "label": {"api": {"SwingNode": [[86, 94]]}}}, {"text": "I think, in your situation, it's best to use the Classloader your Class provides", "label": {"api": {"Classloader": [[49, 59]]}}}, {"text": "Also note that because String#replaceAll accepts a regex as the first parameter, you can improve the regex by having \\\\s+ which will work on strings that have more than one or more spaces", "label": {"api": {"String#replaceAll": [[23, 39]]}}}, {"text": "After you posted your code, the problem is not with replaceAll, you should use nextLine instead of next because next reads only the first complete token", "label": {"api": {"nextLine": [[79, 86]], "next": [[79, 82], [99, 102], [112, 115]]}}}, {"text": "I am confused about Arrays.binarySearch(Object[], Object)", "label": {"api": {"Arrays.binarySearch(Object[], Object)": [[20, 56]]}}}, {"text": "The hash table can be a simple array if you can afford the memory (if your values are small enough) or an actual Hashtable", "label": {"api": {"Hashtable": [[113, 121]]}}}, {"text": "Collections.copy is defined as", "label": {"api": {"Collections.copy": [[0, 15]]}}}, {"text": "But is there any flaw with above when compared to actual Collections.copy", "label": {"api": {"Collections.copy": [[57, 72]]}}}, {"text": "You can do exact floating point arithmetic in Java using BigDecimal", "label": {"api": {"BigDecimal": [[57, 66]]}}}, {"text": "Also note that BigDecimal and BigInteger (the same for integers) are immutable", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "Use the plain and simple and public get(key) method instead", "label": {"api": {"get(key)": [[36, 43]]}}}, {"text": "You could use Arrays.asList", "label": {"api": {"Arrays.asList": [[14, 26]]}}}, {"text": "As of Java 8, you could also use Arrays.stream to get an iterator out of the box (and make this code compiling also if items is an int[], double[] or long[])", "label": {"api": {"Arrays.stream": [[33, 45]]}}}, {"text": "Since you mention abstract in your problem description, how about follow a model similar to Java's Enum class, where the generic type is in the class definition", "label": {"api": {"Enum": [[99, 102]]}}}, {"text": "From the Javadocs for Error", "label": {"api": {"the Javadocs for Error": [[5, 26]]}}}, {"text": "Stream is an interface so whenever one gets hold of a Stream object there are lots of implementation specific details hidden", "label": {"api": {"Stream": [[0, 5], [54, 59]]}}}, {"text": "You could use a Map for relation between one key to many objects", "label": {"api": {"Map": [[16, 18]]}}}, {"text": "A simple solution would be to start a Timer with the timeout task, and every time a new datagram is received, cancel the currently running timer and start a new one", "label": {"api": {"Timer": [[38, 42]]}}}, {"text": "If you use a TreeMap, yes (see the NavigableMap interface which it implements)", "label": {"api": {"the NavigableMap": [[31, 46]]}}}, {"text": "From ListView javadoc", "label": {"api": {"ListView": [[5, 12]]}}}, {"text": "The elements of the ListView are contained within the items ObservableList", "label": {"api": {"ListView": [[20, 27]]}}}, {"text": "This ObservableList is automatically observed by the ListView, such that any changes that occur inside the ObservableList will be automatically shown in the ListView itself", "label": {"api": {"ListView": [[53, 60], [157, 164]]}}}, {"text": "You use an observable list with an extractor for that", "label": {"api": {"extractor": [[35, 43]]}}}, {"text": "To copy the content of an array, you can use the System.arraycopy() method", "label": {"api": {"System.arraycopy": [[49, 64]]}}}, {"text": "However, you could build a new array from the existing one using Arrays.copyOf(array, size)", "label": {"api": {"Arrays.copyOf(array, size)": [[65, 90]]}}}, {"text": "I would still recommend to drop working with an array and use a List", "label": {"api": {"List": [[64, 67]]}}}, {"text": "Assuming scan is a Scanner and you're not doing additional input processing before the lines you pasted, the unused called to scan.next(), which advances the scanner past the first token of input, is what's muddling your input", "label": {"api": {"Scanner": [[19, 25]], "scan.next()": [[126, 136]]}}}, {"text": "The path given to Class.getResourceAsStream(name) is relative to the location of the class in the package hierarchy", "label": {"api": {"Class.getResourceAsStream(name)": [[18, 48]]}}}, {"text": "If you check out Array from the Java website, you'll notice that this is a utilitarian class for creating Arrays using static methods, primarily meant for reflection tasks", "label": {"api": {"Array": [[17, 21], [106, 110]]}}}, {"text": "See SimpleDateFormat javadoc", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "You can create a HashSet from each array, then use set1.equals(set2)", "label": {"api": {"HashSet": [[17, 23]]}}}, {"text": "For java, the TransferQueue class looks like a good choice", "label": {"api": {"TransferQueue": [[14, 26]]}}}, {"text": "If you don't need some of its features you can also just use the ConcurrentLinkedList", "label": {"api": {"ConcurrentLinkedList": [[65, 84]]}}}, {"text": "The Javadoc for Object.wait( timeout ) recommends calling wait in a loop which checks the predicate in order to handle spurious wakeups", "label": {"api": {"The Javadoc for Object.wait( timeout )": [[0, 37]]}}}, {"text": "Taking a look at the documentation for the HeadlessException, we see that it is", "label": {"api": {"HeadlessException": [[43, 59]]}}}, {"text": "I'm not too sure on what you're trying to accomplish here but all you need to do is implement Map", "label": {"api": {"Map": [[94, 96]]}}}, {"text": "This TreeMap considers all keys equal but will otherwise maintain pretty good Map semantics", "label": {"api": {"TreeMap": [[5, 11]]}}}, {"text": "The return value is of type int and is described like this in the JavaDoc", "label": {"api": {"like this in the JavaDoc": [[49, 72]]}}}, {"text": "You can get more information on this at http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-": [[40, 125]]}}}, {"text": "You can simply use the map function to do exactly that", "label": {"api": {"map": [[23, 25]]}}}, {"text": "map \"maps\" each element of the stream to its result of the given function, so that after that call all of the elements in the stream are of the type that the mapping function returned (in this case Object[])", "label": {"api": {"map": [[0, 2], [5, 7], [158, 160]]}}}, {"text": "Use a TreeMap instead of HashMap, which automatically sorts according to the key's natural order", "label": {"api": {"TreeMap": [[6, 12]]}}}, {"text": "Alternatively, consider putting the Events elements in a TreeSet instead of an ArrayList, and have the Events class implements the Comparable interface", "label": {"api": {"TreeSet": [[57, 63]]}}}, {"text": "Maybe the Executor Interface is what you're after", "label": {"api": {"Executor Interface": [[10, 27]]}}}, {"text": "FFMpeg aside, which I don't know much about, it looks like there is a problem with the way you are constructing the AudioFormat", "label": {"api": {"AudioFormat": [[116, 126]]}}}, {"text": "You should use a constructor that takes an AudioFormat.Encoding", "label": {"api": {"AudioFormat": [[43, 53]]}}}, {"text": "If you know it's going to be float, you should be using AudioFormat.Encoding.PCM_FLOAT", "label": {"api": {"AudioFormat": [[56, 66]], "AudioFormat.Encoding.PCM_FLOAT": [[56, 85]]}}}, {"text": "First of all, you need to change annotation retention to RUNTIME (default is CLASS), so they may be read reflectively", "label": {"api": {"so they may be read reflectively": [[85, 116]]}}}, {"text": "See the FXML documentation for details", "label": {"api": {"FXML documentation": [[8, 25]]}}}, {"text": "Use the Scanner#nextLine() method to read a line of text from console", "label": {"api": {"Scanner#nextLine()": [[8, 25]]}}}, {"text": "You may use the the Properties class for that", "label": {"api": {"Properties": [[20, 29]]}}}, {"text": "According to the documentation for Clip open", "label": {"api": {"Clip": [[35, 38]]}}}, {"text": "Clip is a line, so its referring to the clip object and not the stream object", "label": {"api": {"Clip": [[0, 3]]}}}, {"text": "java.awt.Desktop.browse(URI) has this facility", "label": {"api": {"java.awt.Desktop.browse(URI)": [[0, 27]]}}}, {"text": "ThreadDeath is an Error that you cannot recover from", "label": {"api": {"ThreadDeath": [[0, 10]]}}}, {"text": "This probably won't work if you have code points which aren't on the BMP (http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html": [[74, 138]]}}}, {"text": "Annotate this class with MappedSuperClass", "label": {"api": {"MappedSuperClass": [[25, 40]]}}}, {"text": "You can massage your data into JSON form using the javax.json library, specifically the JsonObjectBuilder and the JsonArrayBuilder", "label": {"api": {"JsonObjectBuilder": [[88, 104]], "JsonArrayBuilder": [[114, 129]]}}}, {"text": "The method you are looking for is java.nio.files.File.exists(Path,LinkOption)", "label": {"api": {"java.nio.files.File.exists(Path,LinkOption)": [[34, 76]]}}}, {"text": "If you want a more pure Java approach you can model your data in classes implementing the Serializable interface and read/write them using Java's ObjectOutput- and ObjectInputStream", "label": {"api": {"Serializable": [[90, 101]], "ObjectOutput-": [[146, 158]], "ObjectInputStream": [[164, 180]]}}}, {"text": "You could use classes from the package com.sun.net.httpserver", "label": {"api": {"com.sun.net.httpserver": [[39, 60]]}}}, {"text": "The point is moot for PhantomReference because the referent cannot be retrieved from it (get always returns null)", "label": {"api": {"PhantomReference": [[22, 37]]}}}, {"text": "Since Java 8 you can use a StringJoiner", "label": {"api": {"StringJoiner": [[27, 38]]}}}, {"text": "If your data is already available as collection (or something else that can produce a Stream), you can also use the new stream API instead of writing another loop", "label": {"api": {"Stream": [[86, 91]]}}}, {"text": "My two cents is that since in Java 7 Objects.requireNonNull was added and it throws a NullPointerException, that is the way I go", "label": {"api": {"Objects.requireNonNull": [[37, 58]]}}}, {"text": "You have to specify on your class that it implements Cloneable interface and you have to override clone method inside that class", "label": {"api": {"Cloneable": [[53, 61]]}}}, {"text": "To achieve this the Stream.min() method is your friend", "label": {"api": {"Stream.min()": [[20, 31]]}}}, {"text": "You should definitely use the types chosen by JNAerator, and use Java primitives that deal with unsigned types such as the ones introduced in Java 8 (for instance, Integer.divideUnsigned)", "label": {"api": {"Integer.divideUnsigned": [[164, 185]]}}}, {"text": "Use String.length() to check the length of the number", "label": {"api": {"String.length()": [[4, 18]]}}}, {"text": "Then, let DecimalFormat do the formatting job for you", "label": {"api": {"DecimalFormat": [[10, 22]]}}}, {"text": "Using Collections.shuffle and List.subList will do the job", "label": {"api": {"Collections.shuffle": [[6, 24]], "List.subList": [[30, 41]]}}}, {"text": "From the documentation of ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[26, 43]]}}}, {"text": "Primitive data, excluding serializable fields and externalizable data, is written to the ObjectOutputStream in block-data records", "label": {"api": {"ObjectOutputStream": [[89, 106]]}}}, {"text": "Calls to the ObjectOutputStream methods writeObject, defaultWriteObject and writeFields initially terminate any existing block-data record", "label": {"api": {"ObjectOutputStream": [[13, 30]]}}}, {"text": "If you only want to write bytes, use a FileOutputStream", "label": {"api": {"FileOutputStream": [[39, 54]]}}}, {"text": "You can use BindingProvider to set username password for basic authentication", "label": {"api": {"BindingProvider": [[12, 26]]}}}, {"text": "If you want a smooth animation, you need to use Timer.scheduleAtFixedRate() to account for the time that your rendering commands take", "label": {"api": {"Timer.scheduleAtFixedRate()": [[48, 74]]}}}, {"text": "Use Scanner.nextInt() and avoid to parse the String", "label": {"api": {"Scanner.nextInt()": [[4, 20]]}}}, {"text": "Also it's useful the method Scanner.hasNextInt()", "label": {"api": {"Scanner.hasNextInt()": [[28, 47]]}}}, {"text": "Because is not clear what you mean by saying 'compare', I suppose you need to override equals method in your Employee class", "label": {"api": {"equals": [[87, 92]]}}}, {"text": "What issues should be considered when overriding equals and hashCode in Java", "label": {"api": {"equals": [[49, 54]]}}}, {"text": "Then, according to equals method contract for List interface", "label": {"api": {"equals": [[19, 24]]}}}, {"text": "This definition ensures that the equals method works properly across different implementations of the List interface", "label": {"api": {"equals": [[33, 38]]}}}, {"text": "To reuse a controller between multiple FXML loads, you can use fxmlLoader.setController() or fxmlLoader.setControllerFactory()", "label": {"api": {"fxmlLoader.setController()": [[63, 88]]}}}, {"text": "You can actually do it without casting, but it will need parsing with java.text.DecimalFormat#parse, with \"#\\u2030\" pattern, where \\u2030 is the ‰ (per-mille) character", "label": {"api": {"java.text.DecimalFormat#parse": [[70, 98]]}}}, {"text": "However, you'd actually be better off using an ArrayList<Integer> which allows for dynamic resizing, rather than a fixed size array", "label": {"api": {"ArrayList<Integer>": [[47, 64]]}}}, {"text": "Have you checked the Java API", "label": {"api": {"Java API": [[21, 28]]}}}, {"text": "You'll need to use a structure that preserves order, such as a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[63, 75]]}}}, {"text": "Note that LinkedHashMap does not provide a method that gets keys by position, so this is only appropriate if you are going to be using an iterator", "label": {"api": {"LinkedHashMap": [[10, 22]]}}}, {"text": "You can use Integer.parseInt(String, int) to convert a String representing binary data to an int", "label": {"api": {"Integer.parseInt(String, int)": [[12, 40]]}}}, {"text": "The sort modifies the list - you can have more details in the java doc Collections.sort", "label": {"api": {"Collections.sort": [[71, 86]]}}}, {"text": "Do note that Arrays.sort does sorting in-place and returns nothing", "label": {"api": {"in-place and returns nothing": [[38, 65]]}}}, {"text": "Regarding the initial call of window.getGraphicsConfiguration(), it can return null", "label": {"api": {"it can return null": [[65, 82]]}}}, {"text": "If you are using Java 7+ you can use the handy Files.size operation", "label": {"api": {"Files.size": [[47, 56]]}}}, {"text": "ResultSet has method, absolute() which takes the row no", "label": {"api": {"absolute()": [[22, 31]]}}}, {"text": "To count only unique values we usually use a Set as they are specified as only containing unique values", "label": {"api": {"Set": [[45, 47]]}}}, {"text": "Essentially - put all of your values in a Set (generally a HashSet is the most efficient but if you want concurrency there are better options) and then take the Set.size() as the number of unique values you put in", "label": {"api": {"Set": [[42, 44], [63, 65], [161, 163]]}}}, {"text": "Invoking contains() on a List will compare each element in the list to the argument, so in your example it would be comparing hello, I am new to Java and so on to each one of the search characters", "label": {"api": {"contains()": [[9, 18]]}}}, {"text": "Note that String.contains() needs a CharSequence as an argument, and charAt returns a char", "label": {"api": {"contains()": [[17, 26]], "String.contains()": [[10, 26]]}}}, {"text": "You could use indexOf instead and test if it returns a positive number", "label": {"api": {"indexOf": [[14, 20]]}}}, {"text": "This can easily be done using Java 8 and the use of a reversed Comparator", "label": {"api": {"Comparator": [[63, 72]]}}}, {"text": "I have created a list of files from a directory, which I display unsorted, sorted and reverse sorted using a simple Comparator for the sort and then calling reversed() on it to get the reversed version of that Comparator", "label": {"api": {"Comparator": [[116, 125], [210, 219]]}}}, {"text": "Use a regular expression for your split like s.split(\"[ ]+\")", "label": {"api": {"split": [[34, 38], [47, 51]]}}}, {"text": "If you want to skip the spaces at the beginning or end of string, use trim", "label": {"api": {"trim": [[70, 73]]}}}, {"text": "Here is a summary of Java regular expression constructs", "label": {"api": {"summary of Java regular expression constructs": [[10, 54]]}}}, {"text": "While 1.6 has ConcurrentLinkedQueue and implements the fast non-blocking algorithm, any 3rd party data structure that gives similar functionality", "label": {"api": {"ConcurrentLinkedQueue": [[14, 34]]}}}, {"text": "Take a look at PrintService", "label": {"api": {"PrintService": [[15, 26]]}}}, {"text": "See ProcessBuilder documentation", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "The java.net.URL constructor declares MalformedURLException as a possible exception", "label": {"api": {"The java.net.URL constructor declares MalformedURLException as a possible exception": [[0, 82]]}}}, {"text": "I think AncestorListener is what your looking for", "label": {"api": {"AncestorListener": [[8, 23]]}}}, {"text": "You can use an AncestorListener on the panel, instead of ComponentListener to be notified when such events happen on any parent components", "label": {"api": {"AncestorListener": [[15, 30]]}}}, {"text": "The Graphics class considers a raster with the size the width and the height of the image/frame you are writing to", "label": {"api": {"Graphics": [[4, 11]]}}}, {"text": "You can use the Normalizer class to convert between the two forms", "label": {"api": {"Normalizer": [[16, 25]]}}}, {"text": "You could use SimpleDateFormat to first parse the string to a java.util.Date, and then format it to the format you want", "label": {"api": {"SimpleDateFormat": [[14, 29]]}}}, {"text": "You can however open then as Stream", "label": {"api": {"Stream": [[29, 34]]}}}, {"text": "Another method is to use a Scanner", "label": {"api": {"Scanner": [[27, 33]]}}}, {"text": "There are even some counterintuitive facts such as a HashSet being more memory hungry than a HashMap, since a HashSet contains a HashMap inside (http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html": [[145, 207]]}}}, {"text": "Since Java 7 there's Watchable (and related classes and interfaces in the package java.nio.file) which you can use to monitor file system events, using the underlying operating system's features instead of directly polling for these events", "label": {"api": {"Watchable": [[21, 29]]}}}, {"text": "I hope this will be self-explanatory (using String.indexOf)", "label": {"api": {"String.indexOf": [[44, 57]]}}}, {"text": "While not necessarily the best idea, you can use Thread#getState() to view the current state of the thread", "label": {"api": {"Thread#getState()": [[49, 65]]}}}, {"text": "BLOCKED, WAITING, or TIMED_WAITING", "label": {"api": {"BLOCKED": [[0, 6]], "WAITING": [[9, 15], [27, 33]], "TIMED_WAITING": [[21, 33]]}}}, {"text": "Try using replace method of String like", "label": {"api": {"replace": [[10, 16]]}}}, {"text": "You could split the string and check each part for an uppercase first letter", "label": {"api": {"split": [[10, 14]]}}}, {"text": "However when I run a very simple test on my Raspberry Pi running oracle-java8-jdk (just try to create a Media object) I get an error showing the class isn't found", "label": {"api": {"Media": [[104, 108]]}}}, {"text": "Try using String's replace method like below", "label": {"api": {"replace": [[19, 25]]}}}, {"text": "If you are using Java 7 or later, both classes implement Closeable", "label": {"api": {"Closeable": [[57, 65]]}}}, {"text": "It doesn't work because Runnable.run() is not declared to throw Exception", "label": {"api": {"Runnable.run()": [[24, 37]]}}}, {"text": "To compare two String ignoring case, you should use String.equalsIgnoreCase(another)", "label": {"api": {"String.equalsIgnoreCase(another)": [[52, 83]]}}}, {"text": "Or you can use Character.getNumericValue to achieve this", "label": {"api": {"Character.getNumericValue": [[15, 39]]}}}, {"text": "The Oracle Thread.State documentation specifies that a thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling", "label": {"api": {"Oracle Thread.State documentation": [[4, 36]]}}}, {"text": "Co-primality of integers a and b refers to the question of whether the gcd(a,b) = 1 or not", "label": {"api": {"gcd": [[71, 73]]}}}, {"text": "Java's BigInteger class provides the gcd method to compute this", "label": {"api": {"gcd": [[37, 39]]}}}, {"text": "With Java 8+, you can easily find all elements of a collection that match a Predicate", "label": {"api": {"Predicate": [[76, 84]]}}}, {"text": "The problem with this, though, is that it runs the Predicate against all the elements", "label": {"api": {"Predicate": [[51, 59]]}}}, {"text": "Is there a clean way to only run the Predicate against elements until the first match is found, and then return it, like anyMatch does (but returns a boolean telling if one was found)", "label": {"api": {"Predicate": [[37, 45]]}}}, {"text": "I would use a ReadWriteLock as the synchronization primitive for this purpose", "label": {"api": {"ReadWriteLock": [[14, 26]]}}}, {"text": "You can use the \"E\" DecimalFormat formatting specifier to specify scientific notation, with a \"0\" on the end", "label": {"api": {"\"E\" DecimalFormat formatting specifier": [[16, 53]]}}}, {"text": "Beware that the equals method in Java takes an Object as argument", "label": {"api": {"equals": [[16, 21]]}}}, {"text": "This is also true for the compareTo method", "label": {"api": {"compareTo": [[26, 34]]}}}, {"text": "In your equals method, you cast the argument other to Item", "label": {"api": {"equals": [[8, 13]]}}}, {"text": "With this in mind, you should also review your compareTo method", "label": {"api": {"compareTo": [[47, 55]]}}}, {"text": "The method ClassLoader.getResource(name) needs an absolute path to look for a resource", "label": {"api": {"ClassLoader.getResource(name)": [[11, 39]]}}}, {"text": "The general contract of Comparable.compareTo(o) is to return a positive integer if this is greater than the other object", "label": {"api": {"Comparable.compareTo(o)": [[24, 46]]}}}, {"text": "getName returns null by default so you need to set it explicitly", "label": {"api": {"getName": [[0, 6]]}}}, {"text": "You need to use a SortedMap for this, like TreeMap", "label": {"api": {"SortedMap": [[18, 26]], "TreeMap": [[43, 49]]}}}, {"text": "In fact, for this case, you would just use public boolean contains(O o) from Lists implementation of Collection and avoid writing your own method", "label": {"api": {"public boolean contains(O o)": [[43, 70]], "Lists implementation": [[77, 96]]}}}, {"text": "To turn a sine wave in to a square wave, take the signum of the sin", "label": {"api": {"signum": [[50, 55]]}}}, {"text": "To fix this problem, add synchronized around the increment, or use AtomicInteger", "label": {"api": {"AtomicInteger": [[67, 79]]}}}, {"text": "There is no point in analyzing the code of class java.lang.Thread as its documentation already tells you what it will do, i.e", "label": {"api": {"its documentation": [[69, 85]]}}}, {"text": "The bsmArgs parameter depends on the actual bootstrap method of the invokedynamic instruction, so you have to look up its documentation to understand its meaning", "label": {"api": {"its documentation": [[118, 134]]}}}, {"text": "Don't use Hashtable", "label": {"api": {"Hashtable": [[10, 18]]}}}, {"text": "Instead, you can use HashMap", "label": {"api": {"HashMap": [[21, 27]]}}}, {"text": "You can control how often this will happen by initializing the loadFactor in the appropriate constructor", "label": {"api": {"appropriate constructor": [[81, 103]]}}}, {"text": "Take a look at LinkedHashMap", "label": {"api": {"LinkedHashMap": [[15, 27]]}}}, {"text": "You can either add the two hour adjustment yourself or you can use a library like Calendar or Joda-Time", "label": {"api": {"Calendar": [[82, 89]]}}}, {"text": "Use a java.util.set for your dictionary", "label": {"api": {"java.util.set": [[6, 18]]}}}, {"text": "Check if an entry exists using the method .contains(..) of the java.util.collection interface implemented by List and Sets", "label": {"api": {"java.util.collection": [[63, 82]]}}}, {"text": "Look at link Class String Oracle", "label": {"api": {"Class String Oracle": [[13, 31]]}}}, {"text": "You may use Exchanger shared between two threads", "label": {"api": {"Exchanger": [[12, 20]]}}}, {"text": "In this case a SynchronousQueue - which has no internal capacity to store objects - would be a good candidate because you only need to exchange one object", "label": {"api": {"SynchronousQueue": [[15, 30]]}}}, {"text": "It's Javadoc even mentions that \"An Exchanger may be viewed as a bidirectional form of a SynchronousQueue\"", "label": {"api": {"SynchronousQueue": [[89, 104]]}}}, {"text": "The RotateTransition works by changing the rotate property, which - as you have observed - defines a rotation around the center of the Node", "label": {"api": {"rotate property": [[43, 57]]}}}, {"text": "If you want to rotate around a different point, define a Rotate transform, set its pivot, add it to the line's list of transforms, and use a Timeline to manipulate its angle", "label": {"api": {"Rotate transform": [[57, 72]], "list of transforms": [[111, 128]]}}}, {"text": "Please see Proxy javadocs and this tutorial for further reference on Java's proxies", "label": {"api": {"Proxy javadocs": [[11, 24]]}}}, {"text": "You should also use System.arrayCopy rather than copying content by hand", "label": {"api": {"System.arrayCopy": [[20, 35]]}}}, {"text": "You need to perform the lookup using String#charAt(int)", "label": {"api": {"String#charAt(int)": [[37, 54]]}}}, {"text": "There's actually a standard way to do this in Java - using the JavaCompiler class", "label": {"api": {"JavaCompiler": [[63, 74]]}}}, {"text": "replaceAll actually allows you to use a regular experssion", "label": {"api": {"replaceAll": [[0, 9]]}}}, {"text": "Furthermore the javadoc of ThreadGroup.uncaughtException reads as follows", "label": {"api": {"ThreadGroup.uncaughtException": [[27, 55]]}}}, {"text": "As it is an ArrayList, you can use it's toString if your satiesfied with its behaviour", "label": {"api": {"toString": [[40, 47]]}}}, {"text": "Elements are converted to strings as by String.valueOf(Object)", "label": {"api": {"String.valueOf(Object)": [[40, 61]]}}}, {"text": "in the above example toString is not need to be called explicitly", "label": {"api": {"toString": [[21, 28]]}}}, {"text": "get the URL with getClass().getResource() and read from the URL with something like Toolkit.getDefaultToolkit().getImage()", "label": {"api": {"getClass().getResource()": [[17, 40]], "Toolkit.getDefaultToolkit().getImage()": [[84, 121]]}}}, {"text": "Override the paintDeterminate() method in a custom BasicProgressBarUI to render your indicator; a related example is seen here", "label": {"api": {"paintDeterminate()": [[13, 30]], "BasicProgressBarUI": [[51, 68]]}}}, {"text": "I've just read the javadoc about Phaser there and have a question about usage that class", "label": {"api": {"there": [[40, 44]]}}}, {"text": "You might want to take a look at the String documentation", "label": {"api": {"String documentation": [[37, 56]]}}}, {"text": "The constructor for FileInputStream takes in a path to a file", "label": {"api": {"The constructor for FileInputStream": [[0, 34]]}}}, {"text": "Try using Collections.shuffle method like", "label": {"api": {"Collections.shuffle": [[10, 28]]}}}, {"text": "Try using replaceAll api of String like", "label": {"api": {"replaceAll": [[10, 19]]}}}, {"text": "You could consider adding the objects to cache into a BlockingQueue and have a separate thread taking from the queue and storing into cache", "label": {"api": {"adding": [[19, 24]], "BlockingQueue": [[54, 66]], "taking": [[95, 100]]}}}, {"text": "One way is with a Queue, as suggested in another answer, though I'd use a ConcurrentLinkedQueue instead, since it's unbounded and you have mentioned that adding objects to the cache would happen as much as twice a second", "label": {"api": {"ConcurrentLinkedQueue": [[74, 94]]}}}, {"text": "I have a Java class where I am using the parallelism provided by the Stream API", "label": {"api": {"Stream": [[69, 74]]}}}, {"text": "Is there a way to use the Stream API to these run in parallel", "label": {"api": {"Stream": [[26, 31]]}}}, {"text": "I suggest you use Java's Arrays utility class to efficiently calculate an array-based hash value and check for array equality", "label": {"api": {"Java's Arrays": [[18, 30]]}}}, {"text": "Use an undecorated JFrame instead", "label": {"api": {"undecorated": [[7, 17]]}}}, {"text": "If Java 8 is an option for you, you could use the Stream API to accomplish what you want in one line", "label": {"api": {"Stream API": [[50, 59]]}}}, {"text": "In java 8 this is a candidate for Stream and a map call", "label": {"api": {"map": [[47, 49]]}}}, {"text": "StringBuilder or StringBuffer are more what you're looking for if you want the ability to alter things about the string", "label": {"api": {"StringBuilder": [[0, 12]], "StringBuffer": [[17, 28]]}}}, {"text": "These do not use language keywords, but are used as classes, such as ReentrantLock", "label": {"api": {"ReentrantLock": [[69, 81]]}}}, {"text": "For your specific case, from the KeyListener javadoc, we can see that you will be required to implement", "label": {"api": {"KeyListener": [[33, 43]]}}}, {"text": "You can avoid this by calling the substring variant that accepts an endIndex, and just get the year's four digits", "label": {"api": {"substring variant that accepts an endIndex": [[34, 75]]}}}, {"text": "Read about java.util.concurrent.BlockingQueue", "label": {"api": {"java.util.concurrent.BlockingQueue": [[11, 44]]}}}, {"text": "After all, we’ve got Set<T>.removeAll to help us, right", "label": {"api": {"Set<T>.removeAll": [[21, 36]]}}}, {"text": "Why is the HashSet<T>.removeAll method so slow", "label": {"api": {"Set<T>.removeAll": [[15, 30]]}}}, {"text": "Now you can easily implement toString() by invoking Arrays.toString(), which will in its turn invoke the toString() of each Card object, resulting in the required representation of your deck", "label": {"api": {"Arrays.toString()": [[52, 68]]}}}, {"text": "Another solution that comes to mind is to perform the DNS lookups in a separate thread, and wait for that thread to finish its business using Thread.join() or Future.get() with a timeout value", "label": {"api": {"Thread.join()": [[142, 154]], "Future.get()": [[159, 170]]}}}, {"text": "You can count the number of keycodes yourself from the doc of java.lang.Enum.KeyCode", "label": {"api": {"java.lang.Enum.KeyCode": [[62, 83]]}}}, {"text": "If you wanted to monitor this at the thread level, you could call getState()the Thread object, to see how long each Thread has the BLOCKED state, compared to the RUNNABLE state", "label": {"api": {"getState()": [[66, 75]]}}}, {"text": "If you don't want to save zipfile contents to a temporary file, you can read it by using ZipInputStream", "label": {"api": {"ZipInputStream": [[89, 102]]}}}, {"text": "A SwingWorker object can help with this", "label": {"api": {"SwingWorker": [[2, 12]]}}}, {"text": "StringUtils uses Java's standard Pattern class under the hood", "label": {"api": {"Pattern": [[33, 39]]}}}, {"text": "You can list the interface that an object implements with Class.getInterfaces()", "label": {"api": {"Class.getInterfaces()": [[58, 78]]}}}, {"text": "You are looking for LinkedHashMap which retains insertion order", "label": {"api": {"LinkedHashMap": [[20, 32]]}}}, {"text": "So, HashMap makes no guarantee about it's iteration order", "label": {"api": {"HashMap": [[4, 10]]}}}, {"text": "From what you described a LinkedHashMap might be what you need", "label": {"api": {"HashMap": [[32, 38]], "LinkedHashMap": [[26, 38]]}}}, {"text": "You can express bindings in FXML, and technically you can include Javascript for event handling, though I don't think anyone uses that for any real applications", "label": {"api": {"express bindings": [[8, 23]], "Javascript for event handling": [[66, 94]]}}}, {"text": "The dynamic aspects of the application are typically managed in a controller, which is a Java class", "label": {"api": {"controller": [[66, 75]]}}}, {"text": "The FXML file can inject elements into the controller and nominate controller methods to be used as event handlers", "label": {"api": {"controller": [[43, 52], [67, 76]]}}}, {"text": "See the introduction to FMXL for details", "label": {"api": {"introduction to FMXL": [[8, 27]]}}}, {"text": "Two elements seems to be equal but method containsAll from java.util.collection returns false", "label": {"api": {"containsAll": [[42, 52]]}}}, {"text": "This is the easiest way to do this, though you could have a look at Scanner for something more complicated", "label": {"api": {"Scanner": [[68, 74]]}}}, {"text": "Per the File.getCanonicalPath() javadoc, A canonical pathname is both absolute and unique", "label": {"api": {"File.getCanonicalPath()": [[8, 30]]}}}, {"text": "I want to remove the Selected page label (see image below) of the Pagination control", "label": {"api": {"Pagination": [[66, 75]]}}}, {"text": "If you are using java 8 you can use the method Math.floorMod(int x, int y)", "label": {"api": {"Math.floorMod(int x, int y)": [[47, 73]]}}}, {"text": "You could use System class's getenv method like", "label": {"api": {"getenv": [[29, 34]]}}}, {"text": "There a built-in method, System.getenv() which returns a Map with all the environment variables, from which you can get the one you need", "label": {"api": {"System.getenv()": [[25, 39]]}}}, {"text": "Use instead BufferedWriter.newLine() which", "label": {"api": {"BufferedWriter.newLine()": [[12, 35]]}}}, {"text": "See FileChannel.open() and FileChannel.map()", "label": {"api": {"FileChannel.open()": [[4, 21]], "FileChannel.map()": [[27, 43]]}}}, {"text": "You should either declare your methods as throws UserException - or make your exception extend RuntimeException", "label": {"api": {"RuntimeException": [[95, 110]]}}}, {"text": "And the reason why it is not called automatically, is suggested in the documentation for Container.validate()", "label": {"api": {"Container.validate()": [[89, 108]]}}}, {"text": "In Java 8 a mechanism for this is provided, see for instance LocalDate.now()", "label": {"api": {"LocalDate.now()": [[61, 75]]}}}, {"text": "I think Path and Paths from java.nio.file can be useful here (if you have at least Java 7)", "label": {"api": {"Path": [[8, 11], [17, 20]], "Paths": [[17, 21]]}}}]