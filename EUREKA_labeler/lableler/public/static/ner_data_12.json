[{"text": "You might consider using toAbsolutePath() or toRealPath() on the paths before the check depending on your needs", "label": {"api": {"Path": [[35, 38], [51, 54]]}}}, {"text": "Here's the the official Java tutorial for Path Operations", "label": {"api": {"Path": [[42, 45]]}}}, {"text": "Either use updateDate() where you presently use rs.updateString(2,podate)", "label": {"api": {"updateDate()": [[11, 22]]}}}, {"text": "Pass a Date object to updateDate()", "label": {"api": {"updateDate()": [[22, 33]]}}}, {"text": "Try with Random.nextInt which will give random number between 0 and n-1", "label": {"api": {"Random.nextInt": [[9, 22]]}}}, {"text": "The getInstance method doesn't return your signature class directly, it returns a proxy object which will eventually delegate all calls to your implementation", "label": {"api": {"getInstance": [[4, 14]]}}}, {"text": "File constructor does accept URI, so try something like", "label": {"api": {"URI": [[29, 31]]}}}, {"text": "You can use a PushbackReader to add text back into the stream", "label": {"api": {"PushbackReader": [[14, 27]]}}}, {"text": "Here is an example of using a StringReader", "label": {"api": {"StringReader": [[30, 41]]}}}, {"text": "Note that once you have created the cupReader, you use it just like you did before, regardless of the fact that it's based on a StringReader", "label": {"api": {"StringReader": [[128, 139]]}}}, {"text": "The heart of the problem lies with your usage of the substring method", "label": {"api": {"substring": [[53, 61]]}}}, {"text": "As an example, dissecting your usage, String aSub=a.substring(i,i+1); in the first iteration of the loop i = 0 so this line is then String aSub=a.substring(0,1);  From the javadocs, and my explanation above, this would result in a substring from the first character to the first character or String aSub=\"x\";  Changing this to i+2 and u+2 will get you the desired behavior but beware of index out of bounds errors with the way your loops are currently written", "label": {"api": {"substring": [[52, 60], [146, 154], [231, 239]]}}}, {"text": "You forgot the call to next(), which will advance the cursor to the first row, if present", "label": {"api": {"next()": [[23, 28]]}}}, {"text": "You can use the existing library function sort from Arrays", "label": {"api": {"Arrays": [[52, 57]]}}}, {"text": "Here is the Arrays documentation", "label": {"api": {"Arrays": [[12, 17]]}}}, {"text": "This works, but since Java has a concept of radix, as used in the Integer", "label": {"api": {"Integer": [[66, 72]]}}}, {"text": "This seems to be the explicit purpose as defined in Character", "label": {"api": {"Character": [[52, 60]]}}}, {"text": "Shouldn't there be a better way of doing this rather than to first convert the byte array to a BigInteger", "label": {"api": {"Integer": [[98, 104]]}}}, {"text": "It seems like you're looking for Base64 encoding", "label": {"api": {"Base64": [[33, 38]]}}}, {"text": "If you're using Java 8, there's the Base64 class", "label": {"api": {"Base64": [[36, 41]]}}}, {"text": "Otherwise, Apache Commons has a Base64 class too", "label": {"api": {"Base64": [[32, 37]]}}}, {"text": "The signature of IntStream.forEach is forEach(IntConsumer action), where IntConsumer has a void accept(int value) method", "label": {"api": {"forEach(IntConsumer action)": [[38, 64]]}}}, {"text": "The platform you are running on also plays a role when it comes to the implementation of FileLock used by the FileHandler", "label": {"api": {"FileLock": [[89, 96]]}}}, {"text": "The FileLock documentation comes with the following warning", "label": {"api": {"FileLock": [[4, 11]]}}}, {"text": "Check the Java API for ImageIcon and you'll see that if you call the constructor with a String, it will try to create an ImageIcon with the file represented by the String path", "label": {"api": {"Java API for ImageIcon": [[10, 31]]}}}, {"text": "I have an HashMap", "label": {"api": {"HashMap": [[10, 16]]}}}, {"text": "Double implements Comparable<Double>", "label": {"api": {"Double implements Comparable<Double>": [[0, 35]]}}}, {"text": "Given your restrictions the only command line argument of use is java.util.logging.manager system property", "label": {"api": {"java.util.logging.manager": [[65, 89]]}}}, {"text": "Use the JTextArea append(String str) method", "label": {"api": {"JTextArea append(String str) method": [[8, 42]]}}}, {"text": "in the case of linked-list, you can optimize it to run in-place and modify one of the lists instead of creating a new list, if needed, using the ListIterator interface and the add() method", "label": {"api": {"ListIterator": [[145, 156]]}}}, {"text": "You could make use of StringBuilder like so", "label": {"api": {"StringBuilder": [[22, 34]]}}}, {"text": "However, concatenating long strings is usually considered bad practice, which is where the StringBuilder comes in", "label": {"api": {"StringBuilder": [[91, 103]]}}}, {"text": "I try to bind the items of a SWT List to a List< String> property via Databinding", "label": {"api": {"List": [[33, 36], [43, 46]]}}}, {"text": "It doesn´t work either but at least I could see that if I use tagList.add(x) or tagList.setItems(x) on the tagList Widget nothing is triggered (the convert method isn´t even called)", "label": {"api": {"List": [[65, 68], [83, 86], [110, 113]]}}}, {"text": "How do I bind the SWT List to the List Property in my model", "label": {"api": {"List": [[22, 25], [34, 37]]}}}, {"text": "It's possible that what you're looking for is @Qualifier", "label": {"api": {"@Qualifier": [[46, 55]]}}}, {"text": "However, the upper limit is excluded, so you always end up with one by doing diceRoller.nextInt(1) + 1", "label": {"api": {"the upper limit is excluded": [[9, 35]]}}}, {"text": "Timers are not recommended for new code, you should take a look at ScheduledExecutorServices", "label": {"api": {"ScheduledExecutorServices": [[67, 91]]}}}, {"text": "I'd use Arrays.sort(T[] a, Comparator c), supplying your own Comparator that puts -1 at the end of the output", "label": {"api": {"Arrays.sort(T[] a, Comparator c)": [[8, 39]]}}}, {"text": "If the JDBC timeout settings aren't working you could always just wrap the DB check in a Future and limit how long it can run", "label": {"api": {"Future": [[89, 94]]}}}, {"text": "Due to http://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html it shouldn't matter whether the stream is executed sequentially or parallel", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html": [[7, 79]]}}}, {"text": "When you specify exponential format in the constructor that takes a String, the scale may be negative", "label": {"api": {"constructor that takes a String": [[43, 73]]}}}, {"text": "Using the constructor that takes an int yields a scale of 0", "label": {"api": {"constructor that takes an int": [[10, 38]]}}}, {"text": "When you divide BigDecimals, the quotient takes the scale of the object on which divide is called", "label": {"api": {"divide BigDecimals": [[9, 26]]}}}, {"text": "When you subtract BigDecimals, the difference takes the maximum of the scales of the numbers being subtracted", "label": {"api": {"subtract BigDecimals": [[9, 28]]}}}, {"text": "As an aside, you can use divide(BigDecimal, RoundingMode) to divide specifying a RoundingMode enum instead of the older int constants", "label": {"api": {"divide(BigDecimal, RoundingMode)": [[25, 56]]}}}, {"text": "Try a SortedSet like TreeSet if you want to use a Comparator or implement Comparable<T> on your data models to keep them in some specified order", "label": {"api": {"SortedSet": [[6, 14]], "TreeSet": [[21, 27]]}}}, {"text": "Otherwise, try a LinkedHashSet, which will keep your objects in the order they were inserted", "label": {"api": {"LinkedHashSet": [[17, 29]]}}}, {"text": "class objects (like A.class) are of the type Class, which is used in Java to represent the class and its capabilities from one level up", "label": {"api": {"Class": [[45, 49]]}}}, {"text": "See the documentation here", "label": {"api": {"documentation here": [[8, 25]]}}}, {"text": "And more generally, I can't figure out why both methods exist, because Oracle's doc says, An invocation of this method of the form out.append(c) behaves in exactly the same way as the invocation out.write(c)", "label": {"api": {"Oracle's doc": [[71, 82]]}}}, {"text": "Because its authors decided to make Writer implement the interface Appendable", "label": {"api": {"Writer": [[36, 41]], "Appendable": [[67, 76]]}}}, {"text": "Create a BigInteger from the String and call toByteArray", "label": {"api": {"BigInteger": [[9, 18]], "toByteArray": [[45, 55]]}}}, {"text": "However, in Java 8 the Map interface now has putIfAbsent(), so this casting would not be necessary if you can upgrade your JDK", "label": {"api": {"Map interface now has putIfAbsent()": [[23, 57]]}}}, {"text": "There is no support defined for injection into javax.xml.bind.annotation.adapters.XmlAdapter objects", "label": {"api": {"javax.xml.bind.annotation.adapters.XmlAdapter": [[47, 91]]}}}, {"text": "FileSystem.getPathMatcher(String) supports glob syntax", "label": {"api": {"FileSystem.getPathMatcher(String)": [[0, 32]]}}}, {"text": "Now you are trying to access 1st index from string (indirectly char array) using charAt method like", "label": {"api": {"charAt": [[81, 86]]}}}, {"text": "Try using an ArrayList or LinkedList", "label": {"api": {"ArrayList": [[13, 21]], "LinkedList": [[26, 35]]}}}, {"text": "If you want to store them in reverse order, use this add method which allows you to add an element at every position of the list, so you can do", "label": {"api": {"add method": [[53, 62]]}}}, {"text": "It looks like you're just looking for Stream.flatMap, e.g", "label": {"api": {"Stream.flatMap": [[38, 51]]}}}, {"text": "Dropping another alternative here that is available since Java 9", "label": {"api": {"Java 9": [[58, 63]]}}}, {"text": "java.security.SecureRandom seems to provide the range 0..2^n", "label": {"api": {"java.security.SecureRandom": [[0, 25]]}}}, {"text": "Also you're not shutting down your ExecutorService", "label": {"api": {"shutting down": [[16, 28]], "ExecutorService": [[35, 49]]}}}, {"text": "Add a call to shutdown() after your task submission loop", "label": {"api": {"shutdown()": [[14, 23]]}}}, {"text": "You can add JPA's @Transient", "label": {"api": {"@Transient": [[18, 27]]}}}, {"text": "One option is adding @Transient annotation if on the other hand you use transient keyword that means the field won't be serialized", "label": {"api": {"@Transient": [[21, 30]]}}}, {"text": "More on Why does JPA have a @Transient annotation", "label": {"api": {"@Transient": [[28, 37]]}}}, {"text": "Those methods return FileTime values", "label": {"api": {"FileTime": [[21, 28]]}}}, {"text": "FileTime has a toMillis method which returns its value in milliseconds as a long", "label": {"api": {"FileTime": [[0, 7]], "toMillis": [[15, 22]]}}}, {"text": "You can/should use DecimalFormat for that", "label": {"api": {"DecimalFormat": [[19, 31]]}}}, {"text": "But I cannot manage to retrieve the returned type of a Method", "label": {"api": {"Method": [[55, 60]]}}}, {"text": "At its heart, it relies on a CyclicBarrier to coordinate between the worker and the timer", "label": {"api": {"CyclicBarrier": [[29, 41]]}}}, {"text": "You could also schedule messages to the synthesizer using a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[60, 83]]}}}, {"text": "Java IO has File.deleteOnExit(), which is a method that deletes the file it is called on during normal termination of the JVM", "label": {"api": {"File.deleteOnExit()": [[12, 30]]}}}, {"text": "However, I don't see a method by the same name in Java NIO's Files class", "label": {"api": {"Files": [[61, 65]]}}}, {"text": "I would not suggest shoe-horning StandardOpenOption.DELETE_ON_CLOSE into a replacement for File.deleteOnExit()", "label": {"api": {"StandardOpenOption.DELETE_ON_CLOSE": [[33, 66]]}}}, {"text": "The documentation for Files.createTempFile() is similarly clear on this point, DELETE_ON_CLOSE can be used for \"work files\" only needed while the file is open", "label": {"api": {"Files.createTempFile()": [[22, 43]]}}}, {"text": "The Files.createTempFile() docs suggest directly either writing your own shutdown hook or simply continuing to use File.deleteOnExit()", "label": {"api": {"Files.createTempFile()": [[4, 25]]}}}, {"text": "One way to handle this is to use Files.probeContentType(Path) (JDK 7) to try to get the content type", "label": {"api": {"Files.probeContentType(Path)": [[33, 60]]}}}, {"text": "Keep in mind, though, that probeContentType is entirely dependent on the installed FileTypeDetectors, if any, for its behavior", "label": {"api": {"FileTypeDetector": [[83, 98]]}}}, {"text": "The usual practice in this case is to use a PreparedStatement rather than building a statement dynamically from scratch", "label": {"api": {"PreparedStatement": [[44, 60]]}}}, {"text": "In a PreparedStatement, you put question marks where the values should go, and then you use various setXXX methods to fill them up with values", "label": {"api": {"PreparedStatement": [[5, 21]]}}}, {"text": "But again, I would recommend trusting the authors of your JDBC driver for this and using a PreparedStatement", "label": {"api": {"PreparedStatement": [[91, 107]]}}}, {"text": "What you're looking for is the replace method", "label": {"api": {"replace": [[31, 37]]}}}, {"text": "Which replaces all instances of the first string with the second string", "label": {"api": {"replace": [[6, 12]]}}}, {"text": "The replaceAll method, on the other hand, uses regular expressions, and \"*\" by itself is not a regular expression since the asterisk character is a modifier that means \"the previous thing, repeated zero or more times\"", "label": {"api": {"replace": [[4, 10]], "replaceAll": [[4, 13]]}}}, {"text": "Read about Interface Map<K,V>,Check this out Java MAP Documentation", "label": {"api": {"Java MAP Documentation": [[45, 66]]}}}, {"text": "Also don't forget about ReadWriteLock, another useful tool depending on your access patterns and performance requirements", "label": {"api": {"ReadWriteLock": [[24, 36]]}}}, {"text": "I found Class FileChannel  and now i'm developing this code", "label": {"api": {"Class FileChannel": [[8, 24]]}}}, {"text": "MouseListener is an interface - it doesn't have any method implementations, so if you're going to use that as the basis of your anonymous inner class, you need to provide implementations for everything", "label": {"api": {"MouseListener": [[0, 12]]}}}, {"text": "If you just want to provide implementations for some of the methods, you should extend MouseAdapter instead - that provides no-op implementations, so you can just override the ones you want", "label": {"api": {"MouseAdapter": [[87, 98]]}}}, {"text": "I'm really surprised this is not in the documentation or at least google", "label": {"api": {"this is not in the documentation": [[21, 52]]}}}, {"text": "You can use replace() in StringBuilder", "label": {"api": {"replace()": [[12, 20]]}}}, {"text": "Check out the method SimpleDateFormat#setDateFormatSymbols()", "label": {"api": {"SimpleDateFormat#setDateFormatSymbols()": [[21, 59]]}}}, {"text": "For even wider localization support you should check out the extensive documentation on the Locale class", "label": {"api": {"Locale": [[92, 97]]}}}, {"text": "Try using String's split method like", "label": {"api": {"split": [[19, 23]]}}}, {"text": "Try out isNan method of Double wrapper class like", "label": {"api": {"isNan": [[8, 12]]}}}, {"text": "Assuming there is a result List R, and an expected List E", "label": {"api": {"List": [[27, 30], [51, 54]]}}}, {"text": "Try containsAll method of List like", "label": {"api": {"containsAll": [[4, 14]]}}}, {"text": "You can use java.util.Calendar class", "label": {"api": {"java.util.Calendar": [[12, 29]]}}}, {"text": "In the JavaDoc for Socket.getOutputStream, it says", "label": {"api": {"JavaDoc for Socket.getOutputStream": [[7, 40]]}}}, {"text": "Your second solution could be improved to use a BlockingQueue", "label": {"api": {"BlockingQueue": [[48, 60]]}}}, {"text": "Do not import java.awt.List but java.util.List", "label": {"api": {"java.awt.List": [[14, 26]], "java.util.List": [[32, 45]]}}}, {"text": "The specs say in short", "label": {"api": {"specs": [[4, 8]]}}}, {"text": "Use String#charAt(int index) to get the character at the desired index after retrieving the string element, e.g.", "label": {"api": {"String#charAt(int index)": [[4, 27]]}}}, {"text": "If you want to (and if you really have to), you can concatenate all elements using a StringBuilder so that the result is AAABBBCCC, and use StringBuilder#charAt(int index)", "label": {"api": {"StringBuilder": [[85, 97], [140, 152]], "StringBuilder#charAt(int index)": [[140, 170]]}}}, {"text": "You can use Iterator#remove() if you iterate over the map's entrySet() or values()", "label": {"api": {"Iterator#remove()": [[12, 28]]}}}, {"text": "Furthermore, the code that uses Iterator#remove() will use less memory, because it doesn't have to make a copy of the map", "label": {"api": {"Iterator#remove()": [[32, 48]]}}}, {"text": "Quoting to the javadoc of getMethod from Class found here", "label": {"api": {"Class": [[41, 45]]}}}, {"text": "Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object", "label": {"api": {"Class": [[119, 123]]}}}, {"text": "The parameterTypes parameter is an array of Class objects that identify the method's formal parameter types, in declared order", "label": {"api": {"Class": [[44, 48]]}}}, {"text": "\"an array of Class objects\"", "label": {"api": {"Class": [[13, 17]]}}}, {"text": "Then you can use the Class.forName(String) to get the actual Class object defined from each parameter type String", "label": {"api": {"Class": [[21, 25], [61, 65]], "Class.forName(String)": [[21, 41]]}}}, {"text": "before executing a heavy computation, \"internalize\" your Strings (intern()) and use only == for comparisons", "label": {"api": {"intern()": [[66, 73]]}}}, {"text": "You should use anchor property to receive position of caret instead of using text length value", "label": {"api": {"anchor": [[15, 20]]}}}, {"text": "\".\" is a special character in regex and String's split method accepts regex, which you need to escape like", "label": {"api": {"split": [[49, 53]]}}}, {"text": "One alternate way to construct that regex is to use Pattern#quote", "label": {"api": {"Pattern#quote": [[52, 64]]}}}, {"text": "Getting a Calendar instant from ZonedDateTime is pretty straight-forward, provided you know that there exists a GregorianCalendar#from(ZonedDateTime) method", "label": {"api": {"GregorianCalendar#from(ZonedDateTime)": [[112, 148]]}}}, {"text": "(2) You should probably use the new Java 8 time API (if you are able to use Java 8)", "label": {"api": {"Java 8 time API": [[36, 50]]}}}, {"text": "This option is never going to be \"stable\" nor recommended for production, since its behavior obviously violates the ClassLoader API specification", "label": {"api": {"ClassLoader API specification": [[116, 144]]}}}, {"text": "Try to disable fixed cell size for your table", "label": {"api": {"disable fixed cell size": [[7, 29]]}}}, {"text": "Java provides Collections.binarySearch()", "label": {"api": {"Collections.binarySearch()": [[14, 39]]}}}, {"text": "Try using matches method of String with regex like", "label": {"api": {"matches": [[10, 16]]}}}, {"text": "In the first example, the termination of the thread calls notifyAll() on it, which causes the wait() to complete", "label": {"api": {"calls notifyAll() on it": [[52, 74]]}}}, {"text": "Look at the documentation for ArrayIndexOutOfBoundsException", "label": {"api": {"the documentation for ArrayIndexOutOfBoundsException": [[8, 59]]}}}, {"text": "For future reference, please notice that the exception tells you what line it occurs at (26), and has a name ArrayIndexOutOfBoundsException which at face value describes the error, but can be used with Javadoc to get even more information about that error", "label": {"api": {"ArrayIndexOutOfBoundsException": [[109, 138]]}}}, {"text": "On the other hand, by natural order they mean that the elements of your structure must implement Comparable, and given the O(1) requeriments, the internal array holding the data should be already ordered according this natural order", "label": {"api": {"Comparable": [[97, 106]]}}}, {"text": "Otherwise a ConcurrentModificationException is thrown", "label": {"api": {"ConcurrentModificationException": [[12, 42]]}}}, {"text": "If you want to access packaged files, you can use getResourceAsStream(String)", "label": {"api": {"getResourceAsStream(String)": [[50, 76]]}}}, {"text": "If filePathInputField contains a path to a file in your filesystem, that call will return null", "label": {"api": {"Path": [[7, 10]]}}}, {"text": "You can access it using an instance of File or Path", "label": {"api": {"File": [[39, 42]], "Path": [[47, 50]]}}}, {"text": "But somehow, if you're working with some legacy code, you can use Class#isAssignableFrom() method across each list element", "label": {"api": {"Class#isAssignableFrom()": [[66, 89]]}}}, {"text": "SAXParser is a push parser", "label": {"api": {"SAXParser": [[0, 8]]}}}, {"text": "For example ThreadPoolExecutor With that you can just throw lots of work at it (Runnables) and it will queue work up, and execution can be scaled to suit the hardware it's running on by customizing the number of worker threads", "label": {"api": {"ThreadPoolExecutor": [[12, 29]]}}}, {"text": "Or if you're using Swing, then SwingWorker", "label": {"api": {"SwingWorker": [[31, 41]]}}}, {"text": "<project>/src/Resources/character.png), load it as resource", "label": {"api": {"resource": [[51, 58]]}}}, {"text": "I'm running unto a problem with the ResultSet.next() method in Java", "label": {"api": {"ResultSet.next()": [[36, 51]]}}}, {"text": "As per Holgers suggestions (see comments for question) I switched to the API method getTables() instead", "label": {"api": {"getTables()": [[84, 94]]}}}, {"text": "Once you have a Map, you can call Map.values() to get a Collection of the map's values (which you can then put into a List if you need)", "label": {"api": {"Map.values()": [[34, 45]]}}}, {"text": "In Java, like many other programming languages, an error is thrown when an integer is divided by zero", "label": {"api": {"an error": [[48, 55]]}}}, {"text": "Try using Calendar's get method like", "label": {"api": {"get": [[21, 23]]}}}, {"text": "gets executed inside of the spawnPlayer(Player) method, which therefor causes the method to run infinitely, causing the StackOverflowError", "label": {"api": {"StackOverflowError": [[120, 137]]}}}, {"text": "Another fix would to make it so s.hasPlayer() is not always true, for example, by using an ArrayList to make sure the player wasn't already spawned", "label": {"api": {"ArrayList": [[91, 99]]}}}, {"text": "The documentation is a little confusing, but by looking at the source code for method _convertPublicKey($n, $e) starting at line 950 it appears that if $publicKeyFormat == PUBLIC_FORMAT_PKCS8 then the output format should be one that is compatible with Java's X509EncodedKeySpec class", "label": {"api": {"X509EncodedKeySpec": [[260, 277]]}}}, {"text": "This means that your mysql jdbc driver does not implement the jdbc methods added in jre 6, such as isValid", "label": {"api": {"isValid": [[99, 105]]}}}, {"text": "From the Java 7 API (http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) the method you want is getMessage()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html": [[21, 85]]}}}, {"text": "Path class has resolve() method to join two paths together", "label": {"api": {"resolve()": [[15, 23]]}}}, {"text": "This implements the Collection interface and will internally maintain the elements natural order (in this case Integers) when adding new values", "label": {"api": {"Collection": [[20, 29]]}}}, {"text": "optObj refers to your Optional instance", "label": {"api": {"Optional": [[22, 29]]}}}, {"text": "Optional does not contain a getMessage method", "label": {"api": {"Optional": [[0, 7]]}}}, {"text": "If you use a TreeSet instead of a LinkedHashSet, you could use the method tailSet()", "label": {"api": {"tailSet()": [[74, 82]]}}}, {"text": "The Arrays.sort mergesort is stable", "label": {"api": {"Arrays.sort": [[4, 14]]}}}, {"text": "Using Java Attach API I have been able to load my java agent (e.g", "label": {"api": {"Java Attach API": [[6, 20]]}}}, {"text": "I've read about Semaphore class there and now what I'd like to understand is how can I use that class in a real code", "label": {"api": {"there": [[32, 36]]}}}, {"text": "See documentation on ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[21, 51]]}}}, {"text": "When reading the API for DirectoryStream I miss a lot of functions", "label": {"api": {"DirectoryStream": [[25, 39]]}}}, {"text": "And I miss the fact that it a DirectoryStream is not a Stream", "label": {"api": {"DirectoryStream": [[30, 44]]}}}, {"text": "How can I make a Stream<Path> from a DirectoryStream in Java 8", "label": {"api": {"Stream<Path>": [[17, 28]], "DirectoryStream": [[37, 51]]}}}, {"text": "Assuming you want the supported cipher suites you could use SSLSocketFactory.getSupportedCipherSuites()", "label": {"api": {"SSLSocketFactory.getSupportedCipherSuites()": [[60, 102]]}}}, {"text": "BTW StringBuffer is supplemented by StringBuilder", "label": {"api": {"StringBuffer": [[4, 15]], "StringBuilder": [[36, 48]]}}}, {"text": "This class is designed for use as a drop-in replacement for StringBuffer in places where the string buffer was being used by a single thread (as is generally the case)", "label": {"api": {"StringBuffer": [[60, 71]]}}}, {"text": "Where possible, it is recommended that this class be used in preference to StringBuffer as it will be faster under most implementations", "label": {"api": {"StringBuffer": [[75, 86]]}}}, {"text": "If you're using Java 7 or higher, Files.newBufferedWriter is your friend - and with Java 8, there's an overload without a Charset parameter, in which case UTF-8 is used automatically", "label": {"api": {"Files.newBufferedWriter": [[34, 56]]}}}, {"text": "In Java, both of these are available from a Charset", "label": {"api": {"Charset": [[44, 50]]}}}, {"text": "String.getBytes() just happens to use an encoder with the default platform character coding (obtained using Charset.defaultCharset()), and it happens that for your input string \"ABC\" and your JRE implementation, the sequence of bytes generated is 65, 66, 67", "label": {"api": {"Charset": [[108, 114], [123, 129]]}}}, {"text": "Now, try and String.getBytes(Charset.forName(\"UTF-32LE\")), and you'll get a different result", "label": {"api": {"Charset": [[29, 35]]}}}, {"text": "You are asking Java to encode the string in the platform's default-charset, and that's not the internal charset", "label": {"api": {"You are asking Java to encode the string in the platform's default-charset": [[0, 73]]}}}, {"text": "Use the pathIterator to traverse the shape and obtain the line segments that makes your shapes and its vertex", "label": {"api": {"pathIterator": [[8, 19]]}}}, {"text": "like fge mentioned forEach returns void", "label": {"api": {"forEach": [[19, 25]]}}}, {"text": "To achive what you are looking for use map", "label": {"api": {"map": [[39, 41]]}}}, {"text": "Why doesn't the Java 8 library take care of closing streams itself after each terminal operation (without having to wrap the stream instantiation in a try-with-resources)", "label": {"api": {"terminal operation": [[78, 95]]}}}, {"text": "You can also disable Nagle's algorithm by setting TCP_NODELAY in the java socket options", "label": {"api": {"java socket options": [[69, 87]]}}}, {"text": "You should check out the intersects() method provided by the Java2D API", "label": {"api": {"intersects()": [[25, 36]]}}}, {"text": "The method to invoke is equals(Object)", "label": {"api": {"equals(Object)": [[24, 37]]}}}, {"text": "Each time you call .submit(Runnable) or .submit(Callable) you get a Future object back that represents the eventual completion of the task", "label": {"api": {".submit(Runnable)": [[19, 35]], ".submit(Callable)": [[40, 56]], "Future": [[68, 73]]}}}, {"text": "The Future object has a .get() method that will return the result of the task when it is complete", "label": {"api": {"Future": [[4, 9]], ".get()": [[24, 29]]}}}, {"text": "Also, if the task throws an exception that is not otherwise handled by your task code, the call to .get() will throw an ExecutionException which will wrap the actual thrown exception", "label": {"api": {".get()": [[99, 104]]}}}, {"text": "If your code is exiting prematurely due to an unhandled exception, call .get() on each Future object you get when you submit the task for execution (after you have submitted all the tasks you wish to) and catch any ExecutionExceptions that happen to be thrown to figure out what the actual underlying problem is", "label": {"api": {"Future": [[87, 92]], ".get()": [[72, 77]]}}}, {"text": "Well, precisely because it has an ellipsis)", "label": {"api": {"precisely because it has an ellipsis": [[6, 41]]}}}, {"text": "If you want to preserve the order in which the values were entered, use a LinkedHashSet, otherwise use just a HashSet", "label": {"api": {"LinkedHashSet": [[74, 86]], "HashSet": [[80, 86], [110, 116]]}}}, {"text": "see Java String Formatter Doc for details", "label": {"api": {"Java String Formatter Doc": [[4, 28]]}}}, {"text": "Being called by a thread means you have a reference to that thread via Thread.currentThread()", "label": {"api": {"Thread.currentThread()": [[71, 92]]}}}, {"text": "Unfortunately the File.delete() method provides very little information as to why; it's pretty much up to you to poke around and figure it out", "label": {"api": {"File.delete()": [[18, 30]]}}}, {"text": "Java 7 introduced the new java.nio.file package which is a much more robust file access API", "label": {"api": {"java.nio.file": [[26, 38]]}}}, {"text": "It provides the concept of an abstract Path and separates concrete operations into the Files class, in particular it provides Files.delete() which is documented to raise clear exceptions describing the reasons deletion might fail", "label": {"api": {"Path": [[39, 42]], "Files": [[87, 91], [126, 130]], "Files.delete()": [[126, 139]]}}}, {"text": "Use Path and Files; you'll be glad you did", "label": {"api": {"Path": [[4, 7]], "Files": [[13, 17]]}}}, {"text": "You can use a Proxy but as the comments suggest - this is almost always not the best option", "label": {"api": {"Proxy": [[14, 18]]}}}, {"text": "The API documentation states", "label": {"api": {"API documentation": [[4, 20]]}}}, {"text": "ConcurrentHashMap is fail safe meaning you will not encounter ConcurrentModificationException", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "I would suggest, you don't try locking on whole map operation, but instead look out for making thread safe access to list may be using Vector or SynchronizedList", "label": {"api": {"Vector": [[135, 140]], "SynchronizedList": [[145, 160]]}}}, {"text": "Answers from @predrag-maric and @pL4Gu33 are both correct but if you use JPA in your project (for example, Hibernate) you might consider using  @NamedNativeQuery annotation as well", "label": {"api": {"@NamedNativeQuery": [[144, 160]]}}}, {"text": "Use Stage.initModality to make one of your Stages modal (blocking)", "label": {"api": {"Stage.initModality": [[4, 21]]}}}, {"text": "Take a look at java.util.concurrent package, specifically the CountDownLatch", "label": {"api": {"CountDownLatch": [[62, 75]]}}}, {"text": "You can get the screen coordinates of a Swing/AWT Component using", "label": {"api": {"Component": [[50, 58]]}}}, {"text": "The contract of the MimeMessage.getAllHeaders() method is clear", "label": {"api": {"contract of the MimeMessage.getAllHeaders() method": [[4, 53]]}}}, {"text": "That documentation is referring to the javax.mail.Header class", "label": {"api": {"javax.mail.Header": [[39, 55]]}}}, {"text": "So when you call MimeMessage.getAllHeaders(), it is only safe to assume that the Enumeration will return instances of javax.mail.Header", "label": {"api": {"javax.mail.Header": [[118, 134]]}}}, {"text": "the correct way to loop through an Enumeration is with its hasMoreElements() method", "label": {"api": {"hasMoreElements()": [[59, 75]]}}}, {"text": "or the implementation of compareTo (where T is defined as Long)", "label": {"api": {"implementation of compareTo": [[7, 33]]}}}, {"text": "You could provide a readObject method as described in the Serializable documentation", "label": {"api": {"the Serializable documentation": [[54, 83]]}}}, {"text": "Really, though, you can instead of Person use an associative array, for example mapping enum types for properties to strings", "label": {"api": {"associative array": [[49, 65]]}}}, {"text": "The ConcurrentHashMap.computeIfAbsent() Javadoc reads", "label": {"api": {"ConcurrentHashMap.computeIfAbsent()": [[4, 38]], "HashMap.computeIfAbsent()": [[14, 38]], "Map.computeIfAbsent()": [[18, 38]]}}}, {"text": "The HashMap.computeIfAbsent() or Map.computeIfAbsent() Javadoc don't forbid such recursive computation, which is of course ridiculous as the type of the cache is Map<Integer, Integer>, not ConcurrentHashMap<Integer, Integer>", "label": {"api": {"HashMap.computeIfAbsent()": [[4, 28]], "Map.computeIfAbsent()": [[8, 28], [33, 53]]}}}, {"text": "Its replacement is ProcessBuilder", "label": {"api": {"ProcessBuilder": [[19, 32]]}}}, {"text": "Looking at the statement c1= new Clock();, the only thing one can say is that a new instance of class Clock is created, using its no-arguments constructor, and the reference to the created instance is assigned to a variable named c1, which must have been declared previously (the variable may or may not have already been initialized)", "label": {"api": {"class Clock": [[96, 106]]}}}, {"text": "There's also class Clock in Java since 1.8", "label": {"api": {"class Clock": [[13, 23]]}}}, {"text": "Instead of using an ArrayList, a Queue might be better suited for managing the customers", "label": {"api": {"Queue": [[33, 37]]}}}, {"text": "There's a method, though, Arrays.equals(), that can compare them", "label": {"api": {"Arrays.equals()": [[26, 40]]}}}, {"text": "This is available since Java 1.4 according to the API", "label": {"api": {"API": [[50, 52]]}}}, {"text": "Thus what you could do is follow the same pattern as the Number interface and create individual methods for each numeric type", "label": {"api": {"Number interface": [[57, 72]]}}}, {"text": "See [http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html] for more details", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html]": [[5, 67]]}}}, {"text": "You can't make StringTokenizer work the way you want it to (it never returns blanks), but you can use String#split() instead", "label": {"api": {"String#split()": [[102, 115]]}}}, {"text": "Read more about Java SimleDateFormat", "label": {"api": {"SimleDateFormat": [[21, 35]]}}}, {"text": "Use a shared LinkedBlockingQueue<Integer> (among the readers and all writers) to let every writer signal the reader that the commitIndex variable has been modified", "label": {"api": {"LinkedBlockingQueue<Integer>": [[13, 40]]}}}, {"text": "Referring to NoSuchMethodError Oracle Documentation", "label": {"api": {"NoSuchMethodError Oracle Documentation": [[13, 50]]}}}, {"text": "My advice when building filenames is to use the File class or Path that will automatically make sure to get path separators right", "label": {"api": {"File": [[48, 51]], "Path": [[62, 65]]}}}, {"text": "Use Java's Random class instead of defining your own private static class", "label": {"api": {"Random": [[11, 16]]}}}, {"text": "According to https://docs.oracle.com/javase/7/docs/api/java/nio/file/SimpleFileVisitor.html the default behavior of the visitFileFailed method is to re-throw the exception", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/nio/file/SimpleFileVisitor.html": [[13, 90]]}}}, {"text": "Or, also as noted from comments, you can use newly added String.join(CharSequence, Iterable) method", "label": {"api": {"String.join(CharSequence, Iterable)": [[57, 91]]}}}, {"text": "You can simply do it by implementing Serializable", "label": {"api": {"Serializable": [[37, 48]]}}}, {"text": "In the case of unix and java, this is midnight Jan 1, 1970 UTC", "label": {"api": {"java": [[24, 27]]}}}, {"text": "You can save them to properties or fields", "label": {"api": {"properties": [[21, 30]]}}}, {"text": "Here's the documentation about properties", "label": {"api": {"properties": [[31, 40]]}}}, {"text": "java.math.BigInteger has a modInverse method that can be used", "label": {"api": {"modInverse": [[27, 36]]}}}, {"text": "If you are using Java 8, you can use the new merge method of Map", "label": {"api": {"merge": [[45, 49]]}}}, {"text": "One way to create a Stream source is to implement your own Spliterator and pass it to StreamSupport.stream", "label": {"api": {"StreamSupport.stream": [[86, 105]]}}}, {"text": "As a variation of the theme presented by alfasin, you can specialise the Stream as a DoubleStream and utilise the sum method on it", "label": {"api": {"DoubleStream": [[85, 96]], "sum": [[114, 116]]}}}, {"text": "I found Random.nextGaussian() and was just wondering if there's any other built in support for distributions other than normal", "label": {"api": {"Random.nextGaussian()": [[8, 28]]}}}, {"text": "You are looking for BigInteger", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "Compare DateTimeZone.getAvailableIDs() to ZoneId.getAvailableZoneIds() to determine the mismatch", "label": {"api": {"ZoneId.getAvailableZoneIds()": [[42, 69]]}}}, {"text": "Additional identifiers can be mapped using ZoneId.of(String, Map)", "label": {"api": {"ZoneId.of(String, Map)": [[43, 64]]}}}, {"text": "Use Collections#shuffle() to shuffle your array", "label": {"api": {"Collections#shuffle()": [[4, 24]]}}}, {"text": "Here is where Character comes in hand, since we need to convert the array in a List with Arrays#asList()", "label": {"api": {"Arrays#asList()": [[89, 103]]}}}, {"text": "Especially the Files utility class can help you to create IO Streams", "label": {"api": {"Files": [[15, 19]]}}}, {"text": "For modern (shortened!) usage see Path, Paths and especially Files", "label": {"api": {"Files": [[61, 65]]}}}, {"text": "You need to use setOpaque(true); on your TreeCellRenderer to change background color", "label": {"api": {"setOpaque(true);": [[16, 31]]}}}, {"text": "It's because push takes an argument of type EventQueue but you've called it with the result of EventQueue.invokeLater(), which is a void method", "label": {"api": {"push": [[13, 16]]}}}, {"text": "Here is a tested implementation using this paradigm, plus generating the sublists using List.subList()", "label": {"api": {"List.subList()": [[88, 101]]}}}, {"text": "When the bundle is deactivated, send an interrupt to that thread using Thread.interrupt().Your code would actually work already, but probably don't want to print the stack trace though", "label": {"api": {"Thread.interrupt()": [[71, 88]]}}}, {"text": "You're aren't passing it the string argument it needs", "label": {"api": {"string": [[29, 34]]}}}, {"text": "You need to pass it a string", "label": {"api": {"string": [[22, 27]]}}}, {"text": "You can use a string literal by surrounding text with quotes like this", "label": {"api": {"string": [[14, 19]]}}}, {"text": "For example, Java EE has an interface called ServletContextListener that is purely meant to make setup and shut down", "label": {"api": {"ServletContextListener": [[45, 66]]}}}, {"text": "It's even sometimes acceptable to make interfaces with methods you should actually never directly call such as the Runnable or the Callable interface", "label": {"api": {"Runnable": [[115, 122]], "Callable": [[131, 138]]}}}, {"text": "From the docs for mark(), the parameter you pass to it is", "label": {"api": {"mark()": [[18, 23]]}}}, {"text": "Use a FileChanneland its position methods instead", "label": {"api": {"FileChannel": [[6, 16]]}}}, {"text": "Use a RandomAccessFile and its seek methods instead", "label": {"api": {"RandomAccessFile": [[6, 21]]}}}, {"text": "The next...() methods of a Scanner allways first scan the next token, and then aim to convert it to the correct type (for instance int in the case of nextInt())", "label": {"api": {"next...()": [[4, 12]]}}}, {"text": "You can use Objects#isNull if you don't want to ignore or fix sonar", "label": {"api": {"Objects#isNull": [[12, 25]]}}}, {"text": "You can use CountDownLatch for that purposes, as example", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "Read the documentation for substring carefully to see what each of the parameters means (and why you want i + 1 rather than i)", "label": {"api": {"documentation for substring": [[9, 35]]}}}, {"text": "You should read the API carefully", "label": {"api": {"API": [[20, 22]]}}}, {"text": "Your RSA key is in the SubjectPublicKeyInfo format, which is what Java returns when you use the RSAPublicKey.getEncoded() method", "label": {"api": {"RSAPublicKey.getEncoded()": [[96, 120]]}}}, {"text": "Java calls this format an X509EncodeKeySpec for historical reasons", "label": {"api": {"X509EncodeKeySpec": [[26, 42]]}}}, {"text": "No, but it's overridden in AbstractCollection, which ArrayList is an indirect subclass of", "label": {"api": {"AbstractCollection": [[27, 44]]}}}, {"text": "In the documentation for ArrayList, it shows that toString() is inherited from AbstractCollection", "label": {"api": {"AbstractCollection": [[79, 96]], "documentation for ArrayList": [[7, 33]]}}}, {"text": "Java's Enum actually already has a method to handle this; valueOf", "label": {"api": {"valueOf": [[58, 64]]}}}, {"text": "Please see MappedByteBuffer and FileChannel.map() javadocs", "label": {"api": {"MappedByteBuffer": [[11, 26]], "FileChannel.map()": [[32, 48]]}}}, {"text": "I'm not an expert in Java NIO, so I'm not sure if the byte buffer handles chunks automatically or if you have to use multiple MappedByteBuffers", "label": {"api": {"MappedByteBuffer": [[126, 141]]}}}, {"text": "The other issue is the limitation of Java's implementation of memory mapping which is handled via a MappedByteBuffer", "label": {"api": {"MappedByteBuffer": [[100, 115]]}}}, {"text": "Even though the method FileChannel.map() takes longs for offset and size, it returns a MappedByteBuffer which can only use ints for its limit and position", "label": {"api": {"MappedByteBuffer": [[87, 102]], "FileChannel.map()": [[23, 39]]}}}, {"text": "Use String.matches to match a regexp", "label": {"api": {"String.matches": [[4, 17]]}}}, {"text": "Shouldn't matter if using Scala's or Java's implementation", "label": {"api": {"Java's": [[37, 42]]}}}, {"text": "For example, the @Deprecated annotation type is annotated with @Documented", "label": {"api": {"@Deprecated": [[17, 27]]}}}, {"text": "It's pretty important to know if something is deprecated, so @Deprecated is considered part of the public API and should be included in the documentation", "label": {"api": {"@Deprecated": [[61, 71]]}}}, {"text": "On the other hand, @SuppressWarnings is just a hint for the compiler and not important for the API, so it is not annotated by @Documented", "label": {"api": {"@SuppressWarnings": [[19, 35]]}}}, {"text": "Use the setDefaultCloseOperation(int) command on the JFrame", "label": {"api": {"setDefaultCloseOperation(int)": [[8, 36]]}}}, {"text": "Your class doesn't override Object's toString() method, which is responsible for the Value@15db9742 output you see", "label": {"api": {"Object's toString() method": [[28, 53]]}}}, {"text": "You may also want to consult the documentation on ObjectInputStreams", "label": {"api": {"ObjectInputStreams": [[50, 67]]}}}, {"text": "You'd want to use an SSLSocket (via SSLSocketFactory, see also example) instead of a Socket in that case", "label": {"api": {"SSLSocket": [[21, 29], [36, 44]], "SSLSocketFactory": [[36, 51]]}}}, {"text": "Note that clientSocket will be an instance of SSLSocket (which is derived from Socket) in this case", "label": {"api": {"SSLSocket": [[46, 54]]}}}, {"text": "However, if you're doing this as part of a larger application (as opposed to just a learning experience), consider existing libraries, such as Apache's HttpClient (which supports HTTPS as well) or the built-in HttpURLConnection and HttpsURLConnection if you need something more basic", "label": {"api": {"HttpURLConnection": [[210, 226]], "HttpsURLConnection": [[232, 249]]}}}, {"text": "If you need to embed a server in an application you can use the built-in HttpServer or HttpsServer", "label": {"api": {"HttpServer": [[73, 82]], "HttpsServer": [[87, 97]]}}}, {"text": "Yes you can loop over, java.util.Scanner offer hasNextLine method", "label": {"api": {"java.util.Scanner": [[23, 39]], "hasNextLine": [[47, 57]]}}}, {"text": "I would suggest you use CountDownLatch (assuming this is one time activity) where in your constructor, you can specify how many threads you want to wait for and you share that instance accross the threads and you wait on all the threads to complete using await api (using timeout or complete blocking) and your thread's calling countdown api when they are done", "label": {"api": {"CountDownLatch": [[24, 37]]}}}, {"text": "Another option would be, to call join method in thread to wait for their completion if you have access to each and every thread that you wish to complete", "label": {"api": {"join": [[33, 36]]}}}, {"text": "The missing class, EJBHome, is in the libray for the project", "label": {"api": {"EJBHome": [[19, 25]]}}}, {"text": "Your forgot to call start method (example at the top of article about ProcessBuilder class)", "label": {"api": {"method": [[26, 31]]}}}, {"text": "Difference of prepareCall and prepareStatement methods described in documentation", "label": {"api": {"prepareCall": [[14, 24]], "prepareStatement": [[30, 45]]}}}, {"text": "I've been using ReadWriteLock`s to implement/maintain a locking idioms", "label": {"api": {"ReadWriteLock": [[16, 28]]}}}, {"text": "Since JDK8 StampedLock has been introduced", "label": {"api": {"StampedLock": [[11, 21]]}}}, {"text": "And as RWLocks are known with their slowness and bad performance, StampedLock's look like an alternative (they are not reentrant, so much faster)", "label": {"api": {"StampedLock": [[66, 76]]}}}, {"text": "However except the performance, it looks to me that StampedLock's are much harder and complex to maintain and use - e.g", "label": {"api": {"StampedLock": [[52, 62]]}}}, {"text": "What are the benefits of StampedLock over RWLock", "label": {"api": {"StampedLock": [[25, 35]]}}}, {"text": "I'm guessing you wanted to print the range of 0 to 35, which could be done with Arrays.toString", "label": {"api": {"Arrays.toString": [[80, 94]]}}}, {"text": "A CheckBoxTreeItem provides a selected property", "label": {"api": {"selected property": [[30, 46]]}}}, {"text": "However, in your application, the CheckBoxTreeItem's selected property is not the property represented by the item, because you set the cell value factory to map to the selected property of the Model instance represented by the item", "label": {"api": {"selected property": [[53, 69], [169, 185]]}}}, {"text": "Just use split method inside loop to get all your data in array", "label": {"api": {"split": [[9, 13]]}}}, {"text": "You have to modify those examples to create directories since the FileHandler will not create directories", "label": {"api": {"create directories": [[37, 54], [87, 104]]}}}, {"text": "Integer objects are cached as mentioned by the Javadocs of Integer#valueOf(int)", "label": {"api": {"Integer#valueOf(int)": [[59, 78]]}}}, {"text": "The statement Integer i4 = (args.length + 1) * 6; calls Integer#valueOf(int) which returns the cached instance", "label": {"api": {"Integer#valueOf(int)": [[56, 75]]}}}, {"text": "When you autobox an int, you're internally calling Integer.valueOf(int), which according to the documentation may return cached values", "label": {"api": {"Integer.valueOf(int)": [[51, 70]]}}}, {"text": "And for the record, string interning is available at runtime as well, through the String.intern() method", "label": {"api": {"String.intern()": [[82, 96]]}}}, {"text": "To add leading zeros you can use String.format or System.out.format", "label": {"api": {"String.format": [[33, 45]]}}}, {"text": "Also refer to the docs and see PrintStream#println(char[] x)", "label": {"api": {"PrintStream#println(char[] x)": [[31, 59]]}}}, {"text": "You need to extract user from the iterator using Iterator.next()", "label": {"api": {"Iterator.next()": [[49, 63]]}}}, {"text": "System.out isn't a class or a method, it's a static field on the System class that is a reference to an instance of a class (PrintStream)", "label": {"api": {"System class": [[65, 76]], "PrintStream": [[125, 135]]}}}, {"text": "println is an instance method of PrintStream (or more completely, println is the common name shared by a group of instance methods that are overloaded with different arguments)", "label": {"api": {"PrintStream": [[33, 43]], "println": [[0, 6], [66, 72]]}}}, {"text": "Java's reflection API uses interfaces that are subinterfaces of Type as a runtime representation of generic types, but these are unsuited for your purpose because they do not provide any compile-time type information", "label": {"api": {"Type": [[64, 67]]}}}, {"text": "You can at runtime retrieve the information that MyClass inherits from List<String> (using the method Class.getGenericSuperclass())", "label": {"api": {"Class.getGenericSuperclass()": [[102, 129]]}}}, {"text": "Thus we create a special class (often called TypeToken) from which we can inherit", "label": {"api": {"Type": [[45, 48]]}}}, {"text": "The TypeToken class has a generic parameter, and in the subclass we specify the type we want to pass as this parameter", "label": {"api": {"Type": [[4, 7]]}}}, {"text": "Even better would be to use an existing class as the type token, for example the class TypeToken of the great Guava library (if you do not know this library yet, also look at what else it offers and consider using it!)", "label": {"api": {"Type": [[87, 90]]}}}, {"text": "This class also provides additional helper methods that make it easer to use the token in the as method (directly using Type instances can be difficult)", "label": {"api": {"Type": [[120, 123]]}}}, {"text": "The Guava wiki has more information on its TypeToken class", "label": {"api": {"Type": [[43, 46]]}}}, {"text": "If you are worried about creating too many classes, you can of course easily provide a few default instances for common cases like TypeToken<List<String>> etc", "label": {"api": {"Type": [[131, 134]]}}}, {"text": "Guava's TypeToken also has an of(Class<T>) method that can be used for non-generic types, so the subclasses would be restricted to cases where it is actually necesary", "label": {"api": {"Type": [[8, 11]]}}}, {"text": "Other projects also use this trick, for example Guice with class TypeLiteral (explanation), Gson (TypeToken), and Jackson (TypeReference)", "label": {"api": {"Type": [[65, 68], [98, 101], [123, 126]]}}}, {"text": "You can try using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[18, 31]]}}}, {"text": "You are adding to the frame the result of the addActionListener method, which is void", "label": {"api": {"void": [[81, 84]]}}}, {"text": "The best way to deal with tables is to create a TableModel class that extends AbstractTableModel", "label": {"api": {"AbstractTableModel": [[78, 95]]}}}, {"text": "It's probably easiest to extend Spliterators.AbstractSpliterator", "label": {"api": {"Spliterators.AbstractSpliterator": [[32, 63]]}}}, {"text": "See the Spliterator class documentation at the paragraph beginning \"Despite...\" for details", "label": {"api": {"Spliterator class documentation": [[8, 38]]}}}, {"text": "A better solution using Calendar class", "label": {"api": {"Calendar": [[24, 31]]}}}, {"text": "new Random() creates a new Random instance, which is very likely different, but not guaranteed to be, from any other instance of Random created", "label": {"api": {"very likely different": [[53, 73]]}}}, {"text": "new Random(long seed) creates a new Random instance, which will initialize the random number generator at that value, thus ensuring that two Random instances with the same seed will generate the same sequence", "label": {"api": {"initialize the random number generator": [[64, 101]]}}}, {"text": "Since Random is just a pseudorandom number generator, it is ill-advised to use it for applications that require a truly random number generator", "label": {"api": {"pseudorandom number generator": [[23, 51]]}}}, {"text": "You can use String.subString method as following", "label": {"api": {"String.subString": [[12, 27]]}}}, {"text": "Maybe you could work around this be mapping Jersey to /rest and writing an own Servlet mapped to /* which dispatches to one of the other servlets", "label": {"api": {"dispatches": [[106, 115]]}}}, {"text": "I fail to see much of a difference between your approach and that of a standard ConcurrentHashMap - asides from the fact that ConcurrentHashMap has been heavily tested, and can be configured for minimal overhead with the exact number of threads you want to run the code with", "label": {"api": {"ConcurrentHashMap": [[80, 96], [126, 142]]}}}, {"text": "In a ConcurrentHashMap, you would use the replace(K key, V old, V new) method to atomically update key to new only when the old value has not changed", "label": {"api": {"ConcurrentHashMap": [[5, 21]], "replace": [[42, 48]]}}}, {"text": "The space savings due to removing all those AtomicIntegers and the time savings due to lower synchronization overhead will probably compensate having to wrap the replace(k, old, new) calls within while-loops", "label": {"api": {"replace": [[162, 168]]}}}, {"text": "com.sun.management - Oracle's platform extension to the java.lang.management API and the management interface for some other components of the platform", "label": {"api": {"com.sun.management": [[0, 17]]}}}, {"text": "You'll be much better off either not worrying about this, or using a FileNameExtensionFilter to limit your user's choices, like JoopEggen suggested", "label": {"api": {"FileNameExtensionFilter": [[69, 91]]}}}, {"text": "This might be sufficient for simple tasks, however, you should study the documentation of BreakIterator to understand the difference between this simple approach and a real, sophisticated word boundary splitting", "label": {"api": {"the documentation of BreakIterator": [[69, 102]]}}}, {"text": "Here is a Java 8 Solution using Stream's filter,sorted, and map methods", "label": {"api": {"Stream's": [[32, 39]]}}}, {"text": "I think you'd be OK with a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[27, 43]]}}}, {"text": "ConcurrentHashMap is a highly optimized Map which avoids thread contention as much as possible, especially for reads (I believe this matches your case)", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "I'd go first with the ConcurrentHashMap and test it, and would only change the implementation if behavior differs from expected results", "label": {"api": {"ConcurrentHashMap": [[22, 38]]}}}, {"text": "As per your edit, I must insist on recommending you use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[58, 74]]}}}, {"text": "I have an AudioFormat object (returned from audioInputStream.getFormat())", "label": {"api": {"AudioFormat": [[10, 20]]}}}, {"text": "All You need is a JDialog which is here for short user interactions", "label": {"api": {"JDialog": [[18, 24]]}}}, {"text": "The easier way out is JOptionPane which one overload lets you show a component", "label": {"api": {"JOptionPane": [[22, 32]]}}}, {"text": "As an aside, consider using a Map, http://docs.oracle.com/javase/7/docs/api/java/util/Map.html, to store the candidates instead of an ArrayList", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Map.html": [[35, 93]]}}}, {"text": "You can read it by either using the FileInputStream to read the four bytes yourself and use them to construct your int, or use a higher level utility, such as Scanner", "label": {"api": {"Scanner": [[159, 165]]}}}, {"text": "The Scanner#next() method return type is String", "label": {"api": {"Scanner#next()": [[4, 17]]}}}, {"text": "For example, you could use a VBox", "label": {"api": {"VBox": [[29, 32]]}}}, {"text": "Use SimpleDateFormat as a date parser, not a regex", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "You are confused about the meaning of capacity", "label": {"api": {"capacity": [[38, 45]]}}}, {"text": "The ExecutorService seems to provide methods which execute tasks until they are either completed or else a timeout occurs (such as the invokeAll)", "label": {"api": {"ExecutorService": [[4, 18]], "invokeAll": [[135, 143]]}}}, {"text": "I need to parse Durations from strings", "label": {"api": {"Durations": [[16, 24]]}}}, {"text": "As the standard states that \"it is permitted to omit the 'T' character by mutual agreement\" some of the Javadoc examples of Durations.parse() leave out the T", "label": {"api": {"Durations": [[124, 132]], "Durations.parse()": [[124, 140]]}}}, {"text": "You could use Path::getNameCount (Java 7+)", "label": {"api": {"Path::getNameCount": [[14, 31]]}}}, {"text": "If you need a List of colors for your index you can use a Map", "label": {"api": {"Map": [[58, 60]]}}}, {"text": "Many examples, including Oracle's own tutorial refers to some classes in the package jdk.hashorn.api.scripting", "label": {"api": {"Oracle's own tutorial": [[25, 45]]}}}, {"text": "If you read the SwingWorker javadocs you'll see you should not be making direct changes to the Swing components in your doInBackground() method", "label": {"api": {"SwingWorker javadocs": [[16, 35]]}}}, {"text": "For specifics, look at the publish method", "label": {"api": {"publish method": [[27, 40]]}}}, {"text": "If you use an ExecutorService to start the threads, then you can use shutdownNow followed by awaitTermination", "label": {"api": {"ExecutorService": [[14, 28]]}}}, {"text": "You should look at Executors.newSingleThreadScheduledExecutor (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newSingleThreadScheduledExecutor())", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newSingleThreadScheduledExecutor()": [[63, 173]]}}}, {"text": "A Scanner seems more appropriate", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "Assuming you want to calculate the expression all at once upon pressing the '=' button, I would suggest using a Stack like structure(java.util.Stack) for evaluating an infix operation as follows", "label": {"api": {"Stack": [[112, 116], [143, 147]]}}}, {"text": "The JFrame javadocs state that the default layout manager used is BorderLayout", "label": {"api": {"JFrame": [[4, 9]], "BorderLayout": [[66, 77]]}}}, {"text": "By default it's BorderLayout.CENTER if not specified, which is why you only see the last one added", "label": {"api": {"BorderLayout": [[16, 27]]}}}, {"text": "See the official API documentation for these classes at http://docs.oracle.com/javase/8/docs/api/java/io/package-frame.html for the specifics", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/io/package-frame.html": [[56, 122]]}}}, {"text": "Then, if you need to expand the size of your array, set sum =Arrays.copyOf(sum, sum.length+1);, which will expand the size of your array to the necessary size", "label": {"api": {"Arrays.copyOf(sum, sum.length+1);": [[61, 93]]}}}, {"text": "I attempted to replicate this behavior in JavaFX, but Stage#setTitle is final", "label": {"api": {"Stage#setTitle is final": [[54, 76]]}}}, {"text": "From JavaDoc of HttpURLConnection (which HttpsURLConnection extends)", "label": {"api": {"JavaDoc of HttpURLConnection": [[5, 32]]}}}, {"text": "You could use a TreeMap instead, which is ordered on its keys", "label": {"api": {"TreeMap": [[16, 22]]}}}, {"text": "Use Files.readAllLines() to consume the file into memory, as a list of strings", "label": {"api": {"Files.readAllLines()": [[4, 23]]}}}, {"text": "Make as many changes as you want before writing those back out to the file, using Files.write()", "label": {"api": {"Files.write()": [[82, 94]]}}}, {"text": "You could use EntityManager#getReference()", "label": {"api": {"EntityManager#getReference()": [[14, 41]]}}}, {"text": "The easiest way to achieve that is to use a concurrent collection like BlockingQueue to store the shared integer", "label": {"api": {"BlockingQueue": [[71, 83]]}}}, {"text": "executeBatch returns int[] to return the counts of each update", "label": {"api": {"executeBatch": [[0, 11]]}}}, {"text": "executeLargeBatch returns long[] to return the counts of each update", "label": {"api": {"executeLargeBatch": [[0, 16]]}}}, {"text": "E.g., they're the batch equivalents of executeUpdate (returns int) and executeLargeUpdate (returns long)", "label": {"api": {"executeUpdate": [[39, 51]], "executeLargeUpdate": [[71, 88]]}}}, {"text": "Use String.replace to eliminate the file suffix", "label": {"api": {"String.replace": [[4, 17]]}}}, {"text": "You can do this with MessageFormat", "label": {"api": {"MessageFormat": [[21, 33]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "The fetch() method returns a Fetch object that could be used as \"root\" of a new fetch()", "label": {"api": {"Fetch": [[29, 33]]}}}, {"text": "If you need something more complex, I would suggest you to take a look at java.time (Java Platform SE 8) or Joda-Time", "label": {"api": {"java.time": [[74, 82]]}}}, {"text": "I think DecimalFormat.parse is the Java 7 API way to go", "label": {"api": {"DecimalFormat.parse": [[8, 26]]}}}, {"text": "After that, you go and be happy with the Number you just got", "label": {"api": {"Number": [[41, 46]]}}}, {"text": "You need a toString() method in your Sensor class", "label": {"api": {"toString()": [[11, 20]]}}}, {"text": "Arrays.toString(Object[] a) will call each of your Sensor object's toString() method", "label": {"api": {"toString()": [[67, 76]], "Arrays.toString(Object[] a)": [[0, 26]]}}}, {"text": "According to http://docs.oracle.com/javase/6/docs/api/java/util/AbstractList.html#modCount and various SO questions modCount is used to track modifications that may be done concurrently to an iteration process", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/AbstractList.html#modCount": [[13, 89]]}}}, {"text": "Look at the doc of public static Boolean valueOf(String s)", "label": {"api": {"public static Boolean valueOf(String s)": [[19, 57]]}}}, {"text": "The getMethods method returns an array of all Methods, and you are only checking the name", "label": {"api": {"getMethods method": [[4, 20]]}}}, {"text": "When you call the getMethod method with only the method name as a parameter, you are asking for a Method that takes no parameters", "label": {"api": {"getMethod method": [[18, 33]]}}}, {"text": "Use the parse() method that takes a ParsePosition, as that one doesn't fail when it doesn't read the entire text", "label": {"api": {"parse()": [[8, 14]]}}}, {"text": "This returns a Map<String,Item> but, of course, you may call values() on it to get a collection of items", "label": {"api": {"values()": [[61, 68]]}}}, {"text": "In Go use the compression level gzip.NoCompression and in Java use the Deflater.NO_COPMRESSION", "label": {"api": {"Deflater.NO_COPMRESSION": [[71, 93]]}}}, {"text": "I think readAllLines method will useful for you", "label": {"api": {"readAllLines": [[8, 19]]}}}, {"text": "NoSuchElementException might be good enough", "label": {"api": {"NoSuchElementException": [[0, 21]]}}}, {"text": "If you don't have a generic \"not found\" exception on your class path (javax.ws.rs.NotFoundException, or javax.persistence.EntityNotFoundException for instance), I'd say the best option is to roll your own", "label": {"api": {"javax.persistence.EntityNotFoundException": [[104, 144]]}}}, {"text": "Use Scanner to get the user input, and search using this input", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "You should probably iterate over the Collection using an Iterator", "label": {"api": {"iterate": [[20, 26]], "Iterator": [[57, 64]]}}}, {"text": "Take a look at the Collection interface", "label": {"api": {"Collection": [[19, 28]]}}}, {"text": "There's iterator() which will allow you to step through all of the elements in the collection in some sequence and there's toArray() which would allow you to access the elements by an index", "label": {"api": {"iterator()": [[8, 17]], "toArray()": [[123, 131]]}}}, {"text": "Below is a solution copied from http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#valueOf(java.lang.String)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#valueOf(java.lang.String)": [[32, 119]]}}}, {"text": "Your problem will go away if you move all of your code into a Runnable and pass that Runnable to EventQueue.invokeLater (or SwingUtilities.invokeLater, which is a synonym for EventQueue.invokeLater)", "label": {"api": {"EventQueue.invokeLater": [[97, 118], [175, 196]], "SwingUtilities.invokeLater": [[124, 149]]}}}, {"text": "Otherwise, if you really want the main thread to do something each time the directory watcher finds a new image, your main thread would have to first create a blocking collection, like ArrayBlockingQueue, pass it to the DirectoryWatcher thread before starting it", "label": {"api": {"ArrayBlockingQueue": [[185, 202]]}}}, {"text": "The DirectoryWatcher thread would then add file names to the queue whenever it needs to, and the main thread could loop forever, calling the take() method of the blocking queue", "label": {"api": {"take()": [[141, 146]]}}}, {"text": "To keep your code JPA vendor-agnostic, you should have used only JPA interfaces, entity manager instead of Hibernate session, etc", "label": {"api": {"entity manager": [[81, 94]]}}}, {"text": "What you want, is a Pattern and Matcher", "label": {"api": {"Pattern": [[20, 26]], "Matcher": [[32, 38]]}}}, {"text": "I'm currently studying Java Collections Framework, and one of the fascinating questions that I keep asking myself is \"How do all these collections implement the generic version of Collection#toArray method\"", "label": {"api": {"Collection#toArray": [[180, 197]]}}}, {"text": "From what I've read in other SO questions, it most probably uses Array#newInstance", "label": {"api": {"Array#newInstance": [[65, 81]]}}}, {"text": "Just for the reference, that's how Array#newInstance is declared", "label": {"api": {"Array#newInstance": [[35, 51]]}}}, {"text": "Thread#interrupt is more or less implemented with a flag", "label": {"api": {"Thread#interrupt": [[0, 15]]}}}, {"text": "Your code needs to check for that status with Thread#interrupted() or Thread#isInterrupted() (or handle the InterruptedException)", "label": {"api": {"Thread#interrupt": [[46, 61]], "Thread#interrupted()": [[46, 65]], "Thread#isInterrupted()": [[70, 91]]}}}, {"text": "Note that in order to update a Swing component in a thread other than the Swing thread, you'll need to use a SwingWorker (see Swing Concurrency Tutorial), or user a Swing Timer instead", "label": {"api": {"Swing Timer": [[165, 175]]}}}, {"text": "An alternative can be to use ConcurrentHashMap instead of HashMap", "label": {"api": {"ConcurrentHashMap": [[29, 45]]}}}, {"text": "You do not need to have synchronized blocks when accessing ConcurrentHashMap in multithreaded application", "label": {"api": {"ConcurrentHashMap": [[59, 75]]}}}, {"text": "RuntimeException or Unchecked Exception instances like NPE do not require throwing/catching", "label": {"api": {"RuntimeException": [[0, 15]]}}}, {"text": "In general, if there is no possibility to proceed then it will terminate as a RuntimeException", "label": {"api": {"RuntimeException": [[78, 93]]}}}, {"text": "With the Date object you can then use  http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html to get the date in the required format", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[39, 110]]}}}, {"text": "The Javadocs for the relevant collections and ConcurrentModificationException are clear", "label": {"api": {"ConcurrentModificationException": [[46, 76]]}}}, {"text": "Instead of using Scanner, I suggest using java.io.BufferedReader, which will let you read an entire line at once", "label": {"api": {"read an entire line at once": [[85, 111]]}}}, {"text": "Use Matcher.matches() rather than Matcher.find(), in order to match the regexp against the entire string", "label": {"api": {"Matcher.matches()": [[4, 20]], "Matcher.find()": [[34, 47]]}}}, {"text": "Now because you're using a method with a declaration of", "label": {"api": {"a method": [[25, 32]]}}}, {"text": "See the Java Regex Pattern for further information about the use of regex", "label": {"api": {"Java Regex Pattern": [[8, 25]]}}}, {"text": "I think the answer is simple Calendar is an Abstract class, so we cant create an instance of it", "label": {"api": {"Calendar": [[29, 36]]}}}, {"text": "Now when you call Calendar.getInstance then GregorianCalendar instance is created", "label": {"api": {"Calendar": [[18, 25], [53, 60]]}}}, {"text": "At run-time, we can use Font.canDisplayUpTo(String) to determine which of the installed fonts can display a given text", "label": {"api": {"Font.canDisplayUpTo(String)": [[24, 50]]}}}, {"text": "So you need to call mapToObj instead of just map, when mapping an int to an object", "label": {"api": {"mapToObj": [[20, 27]]}}}, {"text": "If you're using Java SE 8 or later (recommended), try using the java.time classes", "label": {"api": {"java.time": [[64, 72]]}}}, {"text": "You will need to create a custom Comparator which performs the operation you want and pass it to the sort method along with your list, for example..", "label": {"api": {"Comparator": [[33, 42]]}}}, {"text": "If you're running on a platform that has ssh installed you could invoke command line processes using ProcessBuilder methods to perform whatever operations you need", "label": {"api": {"ProcessBuilder": [[101, 114]]}}}, {"text": "It seems to me that if objectToInputStreamConverter created the ByteArrayInputStream using ByteArrayInputStream(byte[] buf) then it could just return the byte[] argument and save you from the need to read anything more, not to mention all that error handling", "label": {"api": {"ByteArrayInputStream(byte[] buf)": [[91, 122]]}}}, {"text": "Note that the service will continue to execute already submitted tasks, but it will not accept new tasks", "label": {"api": {"continue to execute already submitted tasks, but it will not accept new tasks": [[27, 103]]}}}, {"text": "Now, we wait for the service to terminate by calling awaitTermination with a timeout of 5 minutes", "label": {"api": {"awaitTermination": [[53, 68]]}}}, {"text": "When another thread interrupts the thread that is calling our method while it is waiting in method awaitTermination, an InterruptedException is thrown", "label": {"api": {"awaitTermination": [[99, 114]]}}}, {"text": "Since java can't transform the type of 'xyz' into a double a ClassCastException is throw", "label": {"api": {"ClassCastException": [[61, 78]]}}}, {"text": "One thing about the Scanner class is that calling Scanner.close() on the Scanner will also close the input stream it's reading from", "label": {"api": {"Scanner.close()": [[50, 64]]}}}, {"text": "I started investigating this, led by a gut feeling caused by method comments like that of JTree#setRowHeight(int)", "label": {"api": {"JTree#setRowHeight(int)": [[90, 112]]}}}, {"text": "To accomplish this, you could use Google Guava Iterables or Java 8 Stream.flatMap(), depending on your Java version", "label": {"api": {"Java 8 Stream.flatMap()": [[60, 82]]}}}, {"text": "URLClassLoader makes a good starting point", "label": {"api": {"URLClassLoader": [[0, 13]]}}}, {"text": "Since you said maze, one thing you can do is define a java.awt.Rectangle for each wall segment and for your object moving through the maze", "label": {"api": {"java.awt.Rectangle": [[54, 71]]}}}, {"text": "You can peek at the stream", "label": {"api": {"peek": [[8, 11]]}}}, {"text": "The package java.util.function defines a lot of them, but any interface with a single method can be used", "label": {"api": {"java.util.function": [[12, 29]]}}}, {"text": "It's even better if you use one of the existing interfaces in the java.util.function package", "label": {"api": {"java.util.function": [[66, 83]]}}}, {"text": "The documentation of the Document interface describes the interface as", "label": {"api": {"documentation of the Document interface": [[4, 42]]}}}, {"text": "Perhaps you want to use an InputVerifier attached to a JTextField", "label": {"api": {"InputVerifier": [[27, 39]]}}}, {"text": "A good way to catch this mistake is to put @Override before your method;  that tells the compiler that you meant to override a method that exists with the same signature in an inherited class", "label": {"api": {"@Override": [[43, 51]]}}}, {"text": "Files which do not start with a file separator (or drive letter followed by a file separator) are relative files, assumed to be found by prepending the current directory to their paths", "label": {"api": {"file separator": [[32, 45], [78, 91]]}}}, {"text": "Looks like you are mixing java.util.logging.FileHandler properties with org.apache.juli.FileHandler properties", "label": {"api": {"java.util.logging.FileHandler": [[26, 54]]}}}, {"text": "The BigInteger#bitLength() function has the necessary documentation", "label": {"api": {"BigInteger#bitLength()": [[4, 25]]}}}, {"text": "It is best to use existing APIs such as Java's Cipher class which also provides proper padding to be used with RSA such as OAEP (PKCS#1 v1.5 is not good anymore)", "label": {"api": {"Cipher": [[47, 52]]}}}, {"text": "You can store your DisplayObjects in a WeakHashMap", "label": {"api": {"WeakHashMap": [[39, 49]]}}}, {"text": "An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use", "label": {"api": {"WeakHashMap": [[14, 24]]}}}, {"text": "They're in the java.util package (along with a bunch of other things that aren't part of the Collections framework)", "label": {"api": {"java.util package": [[15, 31]]}}}, {"text": "For example, http://docs.oracle.com/javase/7/docs/api/index.html?java/util/List.html provides a full description of the List interface methods, but if it is only an interface then those methods should not provide any functionality, so what is described in these docs, then", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/index.html?java/util/List.html": [[13, 83]]}}}, {"text": "ToolProvider.getSystemJavaCompiler() returns null if there isn't any compiler", "label": {"api": {"ToolProvider.getSystemJavaCompiler()": [[0, 35]]}}}, {"text": "ToolProvider.getSystemJavaCompiler() returns null - usable with only JRE installed", "label": {"api": {"ToolProvider.getSystemJavaCompiler()": [[0, 35]]}}}, {"text": "You can use the method parseHexBinary from the class DatatypeConverter to get the keys as byte array", "label": {"api": {"parseHexBinary from the class DatatypeConverter": [[23, 69]]}}}, {"text": "Read more about SwingWorker and also read this Java tutorial", "label": {"api": {"SwingWorker": [[16, 26]]}}}, {"text": "Worker Threads and SwingWorker", "label": {"api": {"SwingWorker": [[19, 29]]}}}, {"text": "The usual and clean solution is to use a List, which is a resizeable collection", "label": {"api": {"List": [[41, 44]]}}}, {"text": "ArrayList, the most commonly used List implementation is backed by an array but is efficient as the array isn't changed every time you resize the collection", "label": {"api": {"List": [[5, 8], [34, 37]], "ArrayList": [[0, 8]]}}}, {"text": "This solution relies on Java's TreeMap, which is a map that keeps its entries ordered by its keys natural order", "label": {"api": {"TreeMap": [[31, 37]]}}}, {"text": "Two TreeMaps are needed to accomplish what you want", "label": {"api": {"TreeMap": [[4, 10]]}}}, {"text": "If you want the user to input data to your program from the console, the easiest way to achieve this is to use the Scanner class", "label": {"api": {"Scanner": [[115, 121]]}}}, {"text": "Here's a example using Scanner and Joda time", "label": {"api": {"Scanner": [[23, 29]]}}}, {"text": "Not sure if there is built in functionality for this already, but you could always have a ActionListener which listens for selection changes and then programmatically set the width of the JComboBox to the length of the selected content (getSelectedItem()) when it changes", "label": {"api": {"getSelectedItem()": [[237, 253]]}}}, {"text": "JComboBox appears to have a setPrototypeDisplayValue(Object) method that is used to calculate component's preferred width based on the length of the parameter", "label": {"api": {"setPrototypeDisplayValue(Object)": [[28, 59]]}}}, {"text": "So your class is a JPanel; it's inheritance; a fundamental part of OOP", "label": {"api": {"JPanel": [[19, 24]]}}}, {"text": "Since your class is a JPanel, if you want to set it's background color somewhere inside the class you'd just do setBackground(yourColor) from outside would be ui.setBackground(yourColor) assuming of course that you named the instance ui", "label": {"api": {"JPanel": [[22, 27]]}}}, {"text": "JFrames are not the same as JPanels if that's what you were getting at", "label": {"api": {"JFrame": [[0, 5]], "JPanel": [[28, 33]]}}}, {"text": "The documentation of appendChild() shows that it takes a Node as argument", "label": {"api": {"documentation of appendChild()": [[4, 33]]}}}, {"text": "About the case of in-order traversal, you should keep a stack (note that the implementation of Stack is array-based and synchronized, probebly it is better to use a Dequeue such as LinkedList, which also supports push and pop as of Java 6), and auxiliary state for knowing how to resume the iteration each time that findNext is called", "label": {"api": {"Dequeue": [[165, 171]]}}}, {"text": "Now you want that to be done when you click on a JButton", "label": {"api": {"JButton": [[49, 55]]}}}, {"text": "To do so you need to add an ActionListener, using an anonyous class, to the JButton with the previous code", "label": {"api": {"JButton": [[76, 82]], "ActionListener": [[28, 41]]}}}, {"text": "See the addActionListener() method of JButton and the ActionListener", "label": {"api": {"JButton": [[38, 44]], "ActionListener": [[11, 24], [54, 67]]}}}, {"text": "Use LocalDate#of(int, int, int) method that takes year, month and dayOfMonth", "label": {"api": {"LocalDate#of(int, int, int)": [[4, 30]]}}}, {"text": "Call Integer.parseInt(str, 16) in a try-catch if you get a NumberFormatException it wasn't a valid hex encoded int", "label": {"api": {"NumberFormatException": [[59, 79]]}}}, {"text": "Use JTextArea#write(Writer) instead", "label": {"api": {"JTextArea#write(Writer)": [[4, 26]]}}}, {"text": "This will give you a set of Map.Entry, which you can then dump into a new LinkedList<Map.Entry>(entrySet)", "label": {"api": {"Map.Entry": [[28, 36], [85, 93]]}}}, {"text": "If you are on Java 8u40 you can use a TextFormatter, i", "label": {"api": {"TextFormatter": [[38, 50]]}}}, {"text": "I have been working to find an efficient way to serialize a specific class to pass between my server and client and have been using ByteOutputArrayStream to pass around a byte array", "label": {"api": {"ByteOutputArrayStream": [[132, 152]]}}}, {"text": "However, this article makes me wonder if I should be using ByteOutputArrayStream at all", "label": {"api": {"ByteOutputArrayStream": [[59, 79]]}}}, {"text": "If you have your custom data structure then you could make it implement the List<T> interface to be able to use the Collections methods (which includes sort and many others)", "label": {"api": {"List<T>": [[76, 82]]}}}, {"text": "But, I'm pretty sure that you're talking about a HashMap when you say that you would like to store a list of friends for players", "label": {"api": {"HashMap": [[49, 55]]}}}, {"text": "A HashMap is like a collection of variables based on a key", "label": {"api": {"HashMap": [[2, 8]]}}}, {"text": "Make sure to NEVER use the Player object as a type parameter in an ArrayList, HashMap, HashSet, or anything like that", "label": {"api": {"HashMap": [[78, 84]]}}}, {"text": "Then, whenever you want to get the list of a player's friends, you could use HashMap.get()", "label": {"api": {"HashMap": [[77, 83]], "HashMap.get()": [[77, 89]]}}}, {"text": "Then, if you wanted to set the player's friend list to a new value, you could use HashMap.put()", "label": {"api": {"HashMap": [[82, 88]], "HashMap.put()": [[82, 94]]}}}, {"text": "Use java.math.BigInteger variables instead of longs", "label": {"api": {"java.math.BigInteger": [[4, 23]]}}}, {"text": "When you select data, then it is enough the measure the time of Query.getResultList() (and calls alike)", "label": {"api": {"Query.getResultList()": [[64, 84]]}}}, {"text": "For the other operations (EntityManager.persist() or merge() or remove()) there is a mechanism of flushing, which basically forces the queue of queries (or a single query) from the cache to hit the database", "label": {"api": {"flushing": [[98, 105]]}}}, {"text": "usually you do not connect directly to any database, as that is done by a pool (even if you work with a DataSource), which simply gives you a already established connection, but that again depends on your setup", "label": {"api": {"DataSource": [[104, 113]]}}}, {"text": "You can use Strings Split method", "label": {"api": {"Strings Split": [[12, 24]]}}}, {"text": "Together with Pattern.UNICODE_CHARACTER_CLASS it should match ‘special characters’", "label": {"api": {"Pattern.UNICODE_CHARACTER_CLASS": [[14, 44]]}}}, {"text": "You can use NumberFormat here, with appropriate Locale", "label": {"api": {"NumberFormat": [[12, 23]], "Locale": [[48, 53]]}}}, {"text": "You can even use DecimalFormat which is slightly more powerful", "label": {"api": {"DecimalFormat": [[17, 29]]}}}, {"text": "There's actually already a data structure which does exactly what you're looking for, which is the TreeMap", "label": {"api": {"TreeMap": [[99, 105]]}}}, {"text": "Though the Matcher#group(String) will return the text matched in that group, the Matcher#start() will give the start index of the complete match", "label": {"api": {"Matcher#group(String)": [[11, 31]], "Matcher#start()": [[81, 95]]}}}, {"text": "Alternatively, you could move the logic into a subclass of ZipOutputStream and use the same Deflater so it will automatically have the same configuration", "label": {"api": {"Deflater": [[92, 99]]}}}, {"text": "Note that starting with Java-8 you can call sort as a default method implementation on List<T>, making the implementation even easier to locate", "label": {"api": {"default method implementation on List<T>": [[54, 93]]}}}, {"text": "I speculate that an accurate return type tells the compiler which FunctionalInterface it being used", "label": {"api": {"FunctionalInterface": [[66, 84]]}}}, {"text": "The \"dumb\" approach would be to use a ProcessBuilder to interact with the jar via the command-line programatically", "label": {"api": {"ProcessBuilder": [[38, 51]]}}}, {"text": "Because Random does not implement Comparable", "label": {"api": {"Random": [[8, 13]]}}}, {"text": "Use the get(long timeout, TimeUnit unit) method on your futures, and if you get TimeoutException, then call cancel on them", "label": {"api": {"get(long timeout, TimeUnit unit)": [[8, 39]]}}}, {"text": "Use split() method", "label": {"api": {"split()": [[4, 10]]}}}, {"text": "I've been browsing around quite a bit and I'm wondering if there's anything similar to the HttpServer class in the com.sun.net.httpserver.HttpServer package", "label": {"api": {"HttpServer": [[91, 100], [138, 147]]}}}, {"text": "This is a good reason to use the Java concurrent classes", "label": {"api": {"Java concurrent": [[33, 47]]}}}, {"text": "In your case, the SynchronousQueue looks like a good replacement", "label": {"api": {"SynchronousQueue": [[18, 33]]}}}, {"text": "With the SynchronousQueue there is no need to use the empty variable, the this.frameWithMotionData variable or the wait/notifyAll mechanics", "label": {"api": {"SynchronousQueue": [[9, 24]]}}}, {"text": "The 2-parameter version of Collectors.toMap() uses a HashMap", "label": {"api": {"2-parameter version of Collectors.toMap()": [[4, 44]]}}}, {"text": "To use the 4-parameter version, you can replace", "label": {"api": {"4-parameter version": [[11, 29]]}}}, {"text": "While perhaps unexpected, the JavaDoc does say so", "label": {"api": {"does say so": [[38, 48]]}}}, {"text": "According to the String.split() documentation the method returns array, so how come the following code compiles", "label": {"api": {"String.split() documentation": [[17, 44]]}}}, {"text": "String.split() returns an array", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "The java.nio.file.Files API is a really nice improvement over the old java.io.File class, but one detail strikes me as odd; with the exception of delete() no methods document that they may throw NoSuchFileException, and even delete() says this is optional", "label": {"api": {"java.nio.file.Files": [[4, 22]], "delete()": [[146, 153], [225, 232]]}}}, {"text": "On Windows 7 with Java 7.0.02 the Files.readAllLines() method does raise a NoSuchFileException, though it's not explicitly documented to do so", "label": {"api": {"Files.readAllLines()": [[34, 53]]}}}, {"text": "As you can see from the stacktrace, Files uses the FileSystemProvider to perform the file operations", "label": {"api": {"FileSystemProvider": [[51, 68]]}}}, {"text": "The FileSystemProvider implementations are restricted (like the WindowsFileSystemProvider) and in turn use a lot of native (C) code", "label": {"api": {"FileSystemProvider": [[4, 21], [71, 88]]}}}, {"text": "The Queue documentation does a fairly good job of explaining the difference", "label": {"api": {"Queue documentation": [[4, 22]]}}}, {"text": "The reason that they both exist is that the java.util.Queue interface specifies both", "label": {"api": {"the java.util.Queue interface": [[40, 68]]}}}, {"text": "Just use a Task Class as it was meant to, no need to reinvent the wheel.", "label": {"api": {"Task Class": [[11, 20]]}}}, {"text": "Use, for instance, a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[21, 44]]}}}, {"text": "The Executors class is probably what you want to create one", "label": {"api": {"Executors": [[4, 12]]}}}, {"text": "You would be better off using a Deque which is a double-ended queue so you can add/remove at either end and it will grow to fit your needs", "label": {"api": {"Deque": [[32, 36]]}}}, {"text": "According to the javadoc, Map.values() returns a Collection<V>, which means that there is no guarantee that it will be List", "label": {"api": {"Map.values()": [[26, 37]]}}}, {"text": "Map.values() is supposed return a Collection", "label": {"api": {"Map.values()": [[0, 11]]}}}, {"text": "You could for example use an implementation of javax.ws.rs.core.UriInfo", "label": {"api": {"javax.ws.rs.core.UriInfo": [[47, 70]]}}}, {"text": "There are useful methods Math.nextUp() and Math.nextDown() which can help you to investigate this issue", "label": {"api": {"Math.nextUp()": [[25, 37]], "Math.nextDown()": [[43, 57]]}}}, {"text": "Ensure you access the database only via a javax.sql.DataSource definition from JNDI, and you are golden, as both sides, both the Application and the WebApp will have the same access patterns, techniques, rules, etc ..", "label": {"api": {"javax.sql.DataSource": [[42, 61]]}}}, {"text": "Your best option is probably to split your list into three sublists, iterate over the middle one, and merge the lists after you're done", "label": {"api": {"sublists": [[59, 66]]}}}, {"text": "For a Hashtable (and HashMap) to store and retrieve keys properly, the key type must override hashCode and equals properly", "label": {"api": {"Hashtable": [[6, 14]]}}}, {"text": "You haven't overridden those methods, so the Hashtable can't find your keys", "label": {"api": {"Hashtable": [[45, 53]]}}}, {"text": "As long as you match the requirements of the Comparator interface (http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html) your array will come out sorted correctly", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html": [[67, 132]]}}}, {"text": "The Predicate interface was introduced in Java 8, so you need to re-create it yourself", "label": {"api": {"Predicate interface": [[4, 22]]}}}, {"text": "Such a thing doesn't exist in Java, but Java does contain the Void class", "label": {"api": {"the Void class": [[58, 71]]}}}, {"text": "To compare minutes, though, you should use Calendar.MINUTE, too", "label": {"api": {"Calendar.MINUTE": [[43, 57]]}}}, {"text": "You can use Class.asSubclass to do this", "label": {"api": {"Class.asSubclass": [[12, 27]]}}}, {"text": "You can use JInternalFrame in place of jframe", "label": {"api": {"JInternalFrame": [[12, 25]]}}}, {"text": "Why do not you use the Manifest class to process a MANIFEST file", "label": {"api": {"Manifest": [[23, 30]]}}}, {"text": "After the Manifest is parsed, you can get the specific attributes you need (I guess Export-Package in your case)", "label": {"api": {"Manifest": [[10, 17]]}}}, {"text": "Consider using BigDecimal class, if you need precision", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "I have a problem with Polygon#contains(Point)", "label": {"api": {"Polygon#contains(Point)": [[22, 44]]}}}, {"text": "Instead try directly getting the bytes with URL.openStream and then just convert the downloaded bytes to base64", "label": {"api": {"URL.openStream": [[44, 57]]}}}, {"text": "As a side note, you can utilize existing Line2D class to draw lines", "label": {"api": {"Line2D": [[41, 46]]}}}, {"text": "Why don't the treeMap.entrySet() and treeMap.keySet() methods return SortedSet", "label": {"api": {"treeMap.entrySet()": [[14, 31]], "treeMap.keySet()": [[37, 52]], "SortedSet": [[69, 77]], "Set": [[27, 29], [48, 50], [75, 77]]}}}, {"text": "As per the API, a Set is defined as not having a particular ordering", "label": {"api": {"Set": [[18, 20]]}}}, {"text": "You need to use a @MapKeyJoinColumn for that", "label": {"api": {"@MapKeyJoinColumn": [[18, 34]]}}}, {"text": "The gist of what I am trying to do is, am trying to write tests for a class which down the stack makes a database call by creating a java Connection object", "label": {"api": {"Connection": [[138, 147]]}}}, {"text": "I was wondering if I could use Guice or something else to somehow trick Class Four's method getConnection() to return a different connection (am creating an in-memory database using H2 just for testing)", "label": {"api": {"Connection": [[95, 104]]}}}, {"text": "The getConnection() is a private method", "label": {"api": {"Connection": [[7, 16]]}}}, {"text": "The sorted list requirement is in order to feed the data into UI components (JSF) which take List as input and the values always need to be displayed in the same order (alphabetical order of description)", "label": {"api": {"List": [[93, 96]]}}}, {"text": "The first thing that came to mind was a TreeMap", "label": {"api": {"TreeMap": [[40, 46]]}}}, {"text": "The map is declared as a SortedMap and implemented as a TreeMap", "label": {"api": {"TreeMap": [[56, 62]]}}}, {"text": "I used to use just a List and that work fine with respect to ordering but a List does not provide an efficient interface for looking up a value by key and I now do have that requirement", "label": {"api": {"List": [[21, 24], [76, 79]]}}}, {"text": "If TreeMap is supposed to be a map in the ordered of item addition, why isn's TreeMap.values() in the same order", "label": {"api": {"TreeMap": [[3, 9], [78, 84]]}}}, {"text": "Will TreeMap do it for me if I use it differently or do I need an altogether different approach", "label": {"api": {"TreeMap": [[5, 11]]}}}, {"text": "If you want insertion order, as davide said, you can use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[57, 69]]}}}, {"text": "Inside of EJBs you have to use the EJBContext (or the SessionContext)", "label": {"api": {"EJBContext": [[35, 44]], "SessionContext": [[54, 67]]}}}, {"text": "Take a look at java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[15, 32]]}}}, {"text": "Follow the Scanner approach", "label": {"api": {"Scanner": [[11, 17]]}}}, {"text": "An example of how Scanner works (applied to your question)", "label": {"api": {"Scanner": [[18, 24]]}}}, {"text": "If in doubt, read the javadocs of the class in question", "label": {"api": {"read the javadocs": [[13, 29]]}}}, {"text": "The API documentation is very clear about this", "label": {"api": {"API documentation": [[4, 20]]}}}, {"text": "But if for a x/y raison you really want to use a JTextField you could use Integer's method to obtain the numeric value and then check (value > 0 && value <= 100) this value", "label": {"api": {"Integer": [[74, 80]]}}}, {"text": "According to the javadocs, truncatedTo() will try to preserve the time zone in the case of overlap, but atStartOfDay() will find the first occurrence of midnight", "label": {"api": {"truncatedTo()": [[27, 39]], "atStartOfDay()": [[104, 117]]}}}, {"text": "If you begin with a time after that transition, atStartOfDay() will return the first occurence of 12am, while truncatedTo() will return the second occurence", "label": {"api": {"truncatedTo()": [[110, 122]], "atStartOfDay()": [[48, 61]]}}}, {"text": "java.net.URI is a type in Java SE7", "label": {"api": {"java.net.URI": [[0, 11]]}}}, {"text": "See also the Thread javadoc javadoc", "label": {"api": {"javadoc ": [[20, 27]]}}}, {"text": "Using withoutPadding yields a new Encoder not writing = pad chars at the end of file", "label": {"api": {"Encoder": [[34, 40]]}}}, {"text": "A ScheduledExecutorService can help you with this", "label": {"api": {"ScheduledExecutorService": [[2, 25]]}}}, {"text": "Java provides something similar which is not able to provide progress per se but is able to manage an asynchronous task which is the Future<T> class", "label": {"api": {"Future<T>": [[133, 141]]}}}, {"text": "Since you need to provide to the user a feedback of the current operating task you would need at least two threads (the Future<T> thread and the reporting one), something like", "label": {"api": {"Future<T>": [[120, 128]]}}}, {"text": "It should be possible to use a ScheduledExecutorService to schedule either your computing operation (with a delay of 0 and no fixed rate) either your reporting task (with a initial delay and a fixed rate) so that you can wait while getting the result of the first to then cancel the second", "label": {"api": {"ScheduledExecutorService": [[31, 54]]}}}, {"text": "The closest thing I found was the Location class...but it still does not contain the information I'm after", "label": {"api": {"Location": [[34, 41]]}}}, {"text": "If you needed to do something more complicated, you might want to look at Lock and it's subclasses", "label": {"api": {"Lock": [[74, 77]]}}}, {"text": "For example, with a ReadWriteLock, multiple readers can hold the lock at the same time, but only one writer can", "label": {"api": {"Lock": [[29, 32]], "ReadWriteLock": [[20, 32]]}}}, {"text": "If possible, I would create an unmodifiable view of a map EnumMap<Test, String>", "label": {"api": {"unmodifiable view of a map": [[31, 56]]}}}, {"text": "In order to have another thread modify a Swing component like a JFrame it needs to submit the change on the event dispatch thread, for example having the worker thread use SwingUtilities#invokeLater", "label": {"api": {"SwingUtilities#invokeLater": [[172, 197]]}}}, {"text": "The API does not provide a way to do that", "label": {"api": {"The API": [[0, 6]]}}}, {"text": "You could use a GridBagLayout for your hBox2 to better adjust with GridBagConstraints and use constraints to force the 1/3rd feel", "label": {"api": {"GridBagConstraints": [[67, 84]]}}}, {"text": "If you can use Java 8, a clean way to do it is to use the new Collection's removeIf method", "label": {"api": {"removeIf": [[75, 82]]}}}, {"text": "After reading Locale's JavaDoc carefully, I was able to produce the required locale", "label": {"api": {"Locale's JavaDoc": [[14, 29]]}}}, {"text": "There is that peculiar interface which is documented as such (extracts only)", "label": {"api": {"documented as such": [[42, 59]]}}}, {"text": "Please see Files.lines(), Multimaps.index() and Multimaps.transformValues() docs for further reference", "label": {"api": {"Files.lines()": [[11, 23]]}}}, {"text": "Take a look at BigInteger", "label": {"api": {"BigInteger": [[15, 24]]}}}, {"text": "A simple example is FileNotFoundException, which means that the method that invoked this particular exception could not find a file", "label": {"api": {"FileNotFoundException": [[20, 40]]}}}, {"text": "With synchronized in Java this is not possible, so you need something like ReentrantLock.tryLock()", "label": {"api": {"ReentrantLock.tryLock()": [[75, 97]]}}}, {"text": "You also need to be able to directly access the transaction queue from each thread, so I guess you cannot use ExecutorService here but need to implement transaction handling yourself (using a LinkedBlockingQueue)", "label": {"api": {"LinkedBlockingQueue": [[192, 210]]}}}, {"text": "The Map returned from Collections.unmodifiableMap(Map) will be a thin proxy to the real underlying map with some methods disabled (put etc.)", "label": {"api": {"Collections.unmodifiableMap(Map)": [[22, 53]]}}}, {"text": "See Character.toLowerCase() for how to convert a character into a lowercase one, because the correct answer would probably treat \"T\" and \"t\" as the same", "label": {"api": {"Character.toLowerCase()": [[4, 26]]}}}, {"text": "To obtain real path to a resource you can use ServletContext.getRealPath(String path)", "label": {"api": {"ServletContext.getRealPath(String path)": [[46, 84]]}}}, {"text": "You could consider to submit a Runnable to an ExecutorService to start the find operation in another thread and use the returned Future object to specify the maximum time to wait", "label": {"api": {"ExecutorService": [[46, 60]], "Future": [[129, 134]]}}}, {"text": "You can use the Executors class to create an ExecutorService", "label": {"api": {"ExecutorService": [[45, 59]], "Executors": [[16, 24]]}}}, {"text": "Group and Pane", "label": {"api": {"Group": [[0, 4]], "Pane": [[10, 13]]}}}, {"text": "No, the close() method, which is called when leaving the try-with-resources block, calls finish(), so you do not need to do this manually", "label": {"api": {"finish()": [[89, 96]]}}}, {"text": "Also the JavaDoc of close() states that it \"Writes remaining compressed data to the output stream\", which is the same as finish() is documented to do", "label": {"api": {"JavaDoc of close()": [[9, 26]], "finish()": [[121, 128]]}}}, {"text": "Construct a Shape that encloses the image, and use the AffineTransform method createTransformedShape() to rotate the Shape along with the image", "label": {"api": {"Shape": [[12, 16], [95, 99], [117, 121]], "AffineTransform": [[55, 69]]}}}, {"text": "The Shape method contains() will allow for position testing in Component relative coordinates", "label": {"api": {"Shape": [[4, 8]]}}}, {"text": "Have a look at HttpSessionBindingListener and the HttpSessionAttributeListener", "label": {"api": {"HttpSessionBindingListener": [[15, 40]], "HttpSessionAttributeListener": [[50, 77]]}}}, {"text": "If SomeObject is a class that you control, you can implement HttpSessionBindingListener otherwise you will likely need HttpSessionAttributeListener", "label": {"api": {"HttpSessionBindingListener": [[61, 86]], "HttpSessionAttributeListener": [[119, 146]]}}}, {"text": "In fact, my initial guess from the comments (or things like JTable#setFillsViewportHeight) don't help here", "label": {"api": {"JTable#setFillsViewportHeight": [[60, 88]]}}}, {"text": "You can use a KeyEvent listener to listen to when key is pressed, release, typed or any of them", "label": {"api": {"KeyEvent": [[14, 21]], "pressed": [[57, 63]], "release": [[66, 72]], "typed": [[75, 79]], "any": [[84, 86]], "listener": [[23, 30]]}}}, {"text": "It does matter whether you have some infinite loop running on another thread, if the user presses a button, the listener will be called", "label": {"api": {"listener": [[112, 119]]}}}, {"text": "You just need to add a listener to the scene and the key event which you want to listen to", "label": {"api": {"listener": [[23, 30]]}}}, {"text": "Using Comparable.compareTo(T) is the only option (or Comparator)", "label": {"api": {"Comparable.compareTo(T)": [[6, 28]], "Comparator": [[53, 62]]}}}, {"text": "The interface only defines that one method (while Comparator adds equals), and it compares this object with the specified object for order", "label": {"api": {"Comparator": [[50, 59]]}}}, {"text": "You need to pass your Runnable object to the constructor of the Thread class (java.lang.Thread), as described in the official docs", "label": {"api": {"java.lang.Thread": [[78, 93]]}}}, {"text": "The easiest way is to use a PauseTransition", "label": {"api": {"PauseTransition": [[28, 42]]}}}, {"text": "You can do this using just the String.replaceAll(String regex, String replacement) method but if you're going to do this more than once then it's worth creating a Pattern object just once and then using that each time", "label": {"api": {"String.replaceAll(String regex, String replacement) method": [[31, 88]]}}}, {"text": "For non-String columns, you'd use setNull; you may need a branch if setString isn't happy to do it, e.g.", "label": {"api": {"setNull": [[34, 40]]}}}, {"text": "The enhanced for statement can loop through arrays and any kind of Iterable object, so the answer depends on whether getMinions returns an array or an Iterable object", "label": {"api": {"Iterable": [[67, 74], [151, 158]]}}}, {"text": "If it returns an Iterable, then", "label": {"api": {"Iterable": [[17, 24]]}}}, {"text": "Collection.sort does not exist, while Collections.sort does", "label": {"api": {"Collections.sort": [[38, 53]]}}}, {"text": "Then before adding to the file you can check if the list of strings contains the string you want to add (just make sure that the strings share the same format such that a match will be found)", "label": {"api": {"contains": [[68, 75]]}}}, {"text": "You can make use of the contains method", "label": {"api": {"contains": [[24, 31]]}}}, {"text": "You can use Class.getResourceAsStream(...) to get an InputStream for that resource (which can be inside a .jar on the classpath or outside) and then write it to somewhere else", "label": {"api": {"Class.getResourceAsStream(...": [[12, 40]]}}}, {"text": "You might want to look into the Timer class", "label": {"api": {"Timer": [[32, 36]]}}}, {"text": "Then use the Timer(String name) constructor to create a Timer for the thread", "label": {"api": {"Timer": [[13, 17], [56, 60]]}}}, {"text": "CellRendererPane is not a subclass of JComponent but you can still attach a swing event listener to it", "label": {"api": {"swing event listener": [[76, 95]]}}}, {"text": "If you want to do it manually, you can use the snapshot function to create a snapshot image, blur it and apply it to the child every time the parent is resized", "label": {"api": {"snapshot": [[47, 54], [77, 84]]}}}, {"text": "However, invoking snapshot all the time will cause performance loss", "label": {"api": {"snapshot": [[18, 25]]}}}, {"text": "I rather suggest you create 2 images, one normal and one blurred, and display a viewport of the blurred one", "label": {"api": {"viewport": [[80, 87]]}}}, {"text": "Here's a more \"complex\" example with a circle where the viewport isn't sufficient", "label": {"api": {"viewport": [[56, 63]]}}}, {"text": "You could simply read the file linewise and starting from the third line apply string.split() using \"$\" as delimiter", "label": {"api": {"string.split()": [[79, 92]]}}}, {"text": "The WatchService API allows you to detect when your .txt file is changed, but detecting which line is changed is something that you'll need to implement yourself", "label": {"api": {"WatchService API": [[4, 19]]}}}, {"text": "You need to use BigInteger to have arbitrary-precision integers http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html": [[64, 129]]}}}, {"text": "You are using  == to compare registration value, you should use .equalsIgnoreCase(str)reference to be sure that user's input will be positively compared if he/she uses small letters instead of capital", "label": {"api": {"reference": [[86, 94]]}}}, {"text": "However, calling toFile() should not cause this, as the documentation says", "label": {"api": {"toFile()": [[17, 24]]}}}, {"text": "Otherwise, this is a misunderstanding, and the toFile() method is correctly returning a File object referring to C:", "label": {"api": {"toFile()": [[47, 54]]}}}, {"text": "In multi Threaded environment while multiple threads are accessing same List it is safe to use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[95, 114]]}}}, {"text": "Java 5 improves on the synchronized collections by providing several concurrent collection classes in java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[102, 121]]}}}, {"text": "I have never seen a case when an IOError is thrown", "label": {"api": {"IOError": [[33, 39]]}}}, {"text": "The only thing that the docs say about IOError it this", "label": {"api": {"IOError": [[39, 45]]}}}, {"text": "Is there ever a case when IOError would be thrown in java", "label": {"api": {"IOError": [[26, 32]]}}}, {"text": "(This is not to be confused with IOException -- IOException is thrown in a wide range of cases, and is commonly used; I know that", "label": {"api": {"IOException": [[33, 43], [48, 58]]}}}, {"text": "I'm wondering about the less common IOError)", "label": {"api": {"IOError": [[36, 42]]}}}, {"text": "Console,  Path#toAbsolutePath, and Path#toUri declare this particular exception to be thrown", "label": {"api": {"Console": [[0, 6]], "Path#toAbsolutePath": [[10, 28]], "Path#toUri": [[35, 44]]}}}, {"text": "From what it looks like in code, Console#readLine and Console#readPassword catch an IOException that results through its normal operation, then propagate that to an IOError", "label": {"api": {"Console": [[33, 39], [54, 60]]}}}, {"text": "If you have the file in you web root (I assume that you are) then you have to use ServletContext.html#getRealPath(java.lang.String) this will give you the actual path of the file", "label": {"api": {"ServletContext.html#getRealPath(java.lang.String)": [[82, 130]]}}}, {"text": "Should main not exist, a runtime error ensues - specifically, NoSuchMethodError (and it will complain about not finding main)", "label": {"api": {"NoSuchMethodError": [[62, 78]]}}}, {"text": "The Javadoc for java.lang.Double#valueOf(String) gives a detailed but well-documented regular expression for how it parses numbers", "label": {"api": {"java.lang.Double#valueOf(String)": [[16, 47]]}}}, {"text": "We use MM for month while mm for minutes in Java simpelDateFormat", "label": {"api": {"simpelDateFormat": [[49, 64]]}}}, {"text": "You probably want the getPart method", "label": {"api": {"getPart": [[22, 28]]}}}, {"text": "Yes, use java.io.Console.readPassword()", "label": {"api": {"java.io.Console.readPassword()": [[9, 38]]}}}, {"text": "the javadoc of ByteBuffer.allocateDirect() states that", "label": {"api": {"the javadoc of ByteBuffer.allocateDirect()": [[0, 41]]}}}, {"text": "Is the only way to accomplish the task is to enumerate all constructor manually with getConstructors()", "label": {"api": {"getConstructors()": [[85, 101]]}}}, {"text": "Another comment is that I'd recommend to avoid polling for available task, but rather use a BlockingQueue instead of ArrayList and sleeping", "label": {"api": {"BlockingQueue": [[92, 104]]}}}, {"text": "If your thread is waiting for a BlockingQueue, it won't be scheduled until there's something in the queue, so you don't have the unpredictable wake-up checks", "label": {"api": {"BlockingQueue": [[32, 44]]}}}, {"text": "As for the range operations there is a method more suited for your needs - subMap", "label": {"api": {"subMap": [[75, 80]]}}}, {"text": "An alternative custom-class approach which tries to avoid multiple boolean flags by using an EnumSet (or Guava's Sets.immutableEnumSet())", "label": {"api": {"EnumSet": [[93, 99], [127, 133]]}}}, {"text": "Socket, PrintWriter, BufferedReader, implement AutoCloseable and based on the fact, that you want to close socket right after you invoke sendContentOverSocket(String content) try to use the following code", "label": {"api": {"Socket": [[0, 5], [152, 157]], "PrintWriter": [[8, 18]], "BufferedReader": [[21, 34]], "AutoCloseable": [[47, 59]]}}}, {"text": "Then you can just use the standard TextFieldListCell which has exactly the functionality you describe", "label": {"api": {"TextFieldListCell": [[35, 51]]}}}, {"text": "Since you want a graphic in the standard cell display, just subclass TextFieldListCell and override the appropriate methods to include the graphic when the text field is not displayed", "label": {"api": {"TextFieldListCell": [[69, 85]]}}}, {"text": "This can be done using an AtomicInteger", "label": {"api": {"AtomicInteger": [[26, 38]]}}}, {"text": "You should also look at File.mkdirs()", "label": {"api": {"File.mkdirs()": [[24, 36]]}}}, {"text": "You should use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[17, 33]]}}}, {"text": "But rather than use an Integer type as the value stored in the map, you should use an AtomicInteger, which will ensure that multiple threads attempting to modify the value associated with the same key will be thread safe", "label": {"api": {"AtomicInteger": [[86, 98]]}}}, {"text": "java.util.Date objects are not IN a time zone", "label": {"api": {"java.util.Date": [[0, 13]]}}}, {"text": "Use an AnimationTimer as your (game) loop", "label": {"api": {"AnimationTimer": [[7, 20]]}}}, {"text": "You can try making MyBean an Embeddable to use that as an EmbeddedId, something like this", "label": {"api": {"Embeddable": [[29, 38]], "EmbeddedId": [[58, 67]]}}}, {"text": "In your entity, MyBean will be an EmbeddedId and will look like this", "label": {"api": {"EmbeddedId": [[34, 43]]}}}, {"text": "If so I recommend using HashSet instead or ArrayList", "label": {"api": {"HashSet": [[24, 30]]}}}, {"text": "trimToSize() is a method of the ArrayList class, not the List interface", "label": {"api": {"List": [[37, 40], [57, 60]]}}}, {"text": "Since you're storing your variables as List<Integer>, you can only use methods that are part of the List interface", "label": {"api": {"List": [[39, 42], [100, 103]]}}}, {"text": "You can't trim linked at all, because it's nonsensical to trim a LinkedList; they do not allocate additional buffer space past their capacity as appending to a LinkedList is always O(1), where as appending to a full ArrayList is O(n)", "label": {"api": {"List": [[71, 74], [166, 169], [221, 224]]}}}, {"text": "Use format like this", "label": {"api": {"format": [[4, 9]]}}}, {"text": "java.util.Base64 was added in Java 8", "label": {"api": {"java.util.Base64": [[0, 15]]}}}, {"text": "One way of doing this is to use WatchService then act when the file is being written and the size is greater than the threshold", "label": {"api": {"WatchService": [[32, 43]]}}}, {"text": "You rarely need to specify the capacity of an ArrayList, it can improve the performance only if you know how many elements your ArrayList will hold", "label": {"api": {"ArrayList": [[46, 54], [128, 136]], "List": [[51, 54], [133, 136]]}}}, {"text": "ArrayList is simply a List that can automatically be grown or shrink", "label": {"api": {"ArrayList": [[0, 8]], "List": [[5, 8], [22, 25]]}}}, {"text": "Using List, you never need to add an element in the place n if the list is empty, you simply link it to the previous node (unless it's the head of course) - that's the idea of ArrayList except the fact that it can be grown/shrink automatically", "label": {"api": {"ArrayList": [[176, 184]], "List": [[6, 9], [181, 184]]}}}, {"text": "One option can be to use the afterExecute method and change the behavior of the shutdown method", "label": {"api": {"afterExecute": [[29, 40]]}}}, {"text": "What does Part stand for", "label": {"api": {"Part": [[10, 13]]}}}, {"text": "And which http request will reduce Parts that can be fetched by HttpServletRequest#getParts() method", "label": {"api": {"Part": [[35, 38], [86, 89]], "HttpServletRequest#getParts()": [[64, 92]]}}}, {"text": "It uses the default encoding which on Windows will be an obsolete \"ANSI\" encoding", "label": {"api": {"default encoding": [[12, 27]]}}}, {"text": "You can also call System.setOut to provide your own mechanism", "label": {"api": {"System.setOut": [[18, 30]]}}}, {"text": "You need Optional.isPresent() and orElse()", "label": {"api": {"Optional.isPresent()": [[9, 28]], "orElse()": [[34, 41]]}}}, {"text": "With Java 9 or higher, ifPresentOrElse is most likely what you want", "label": {"api": {"ifPresentOrElse": [[23, 37]]}}}, {"text": "First, all Objects in that array must implement the Comparable interface, which they do, but they themselves are not comparable with respect to each other", "label": {"api": {"all Objects in that array must implement the Comparable interface": [[7, 71]]}}}, {"text": "In Java HashMap breaks when used concurrently without sufficient locking", "label": {"api": {"HashMap": [[8, 14]]}}}, {"text": "See Is a HashMap thread-safe for different keys", "label": {"api": {"HashMap": [[9, 15]]}}}, {"text": "In Java a ConcurrentSkipListSet uses the Skip List data structure and so can be updated and iterated by multiple threads concurrently without breaking without using locks", "label": {"api": {"ConcurrentSkipListSet": [[10, 30]]}}}, {"text": "notifyAll() isn't remotely close to notifyDataSetChanged()", "label": {"api": {"notifyAll()": [[0, 10]]}}}, {"text": "A good option is a TreeSet, which is likely functionally equivalent to how you were using an array, if you simply need to keep track of a set of sorted numbers", "label": {"api": {"TreeSet": [[19, 25]]}}}, {"text": "You could use something like ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[29, 49]]}}}, {"text": "Take advantage of Java's Executor implementations and use a producer/consumer model", "label": {"api": {"Executor": [[25, 32]]}}}, {"text": "If you need the ability to stop a pending costly operation, the thread that removes Things can use an ExecutorService instead of Executor", "label": {"api": {"Executor": [[102, 109], [129, 136]]}}}, {"text": "You are falling for a very common trap with the Thread API", "label": {"api": {"Thread": [[48, 53]]}}}, {"text": "the failure to distinguish a thread from an instance of the Thread class", "label": {"api": {"Thread": [[60, 65]]}}}, {"text": "A Thread, on the other hand, is just a plain Java object, which happens to have some magic methods, the most magical being start()", "label": {"api": {"Thread": [[2, 7]], "start()": [[123, 129]]}}}, {"text": "Many others are just plain old Java methods, and they pertain to that particular Thread instance", "label": {"api": {"Thread": [[81, 86]]}}}, {"text": "getName() is just such a method and it returns the name of this instance on which it was called", "label": {"api": {"getName()": [[0, 8]]}}}, {"text": "currentThread(), on the other hand, is a static method which returns the instance of Thread responsible for the current thread", "label": {"api": {"Thread": [[7, 12], [85, 90]], "currentThread()": [[0, 14]]}}}, {"text": "This is the instance on which you want to invoke getName()", "label": {"api": {"getName()": [[49, 57]]}}}, {"text": "The easiest way is to return a StreamingOutput object", "label": {"api": {"StreamingOutput": [[31, 45]]}}}, {"text": "use the class Random (http://docs.oracle.com/javase/7/docs/api/java/util/Random.html) to generate randomnumbers", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Random.html": [[22, 83]]}}}, {"text": "I am now reading the documentation and see there is a function called Collectors.toConcurrentMap()", "label": {"api": {"Collectors.toConcurrentMap()": [[70, 97]]}}}, {"text": "There was once a time where I needed to hook a custom properties file and ask Maven to filter it with project properties then read input that file content within the source code as a java.util.Properties", "label": {"api": {"java.util.Properties": [[183, 202]]}}}, {"text": "Assuming yours is a Swing GUI (you don't tell us), JFrame has a setLocation(...) method, a method that JFrame API will readily show you", "label": {"api": {"JFrame API": [[103, 112]]}}}, {"text": "It turns out that although TransformerFactory lets you use a Source implementation for your stylesheet, if you happen (unknowingly, of course) to use a DOMSource that was constructed by a caller who did not declare his associated DocumentBuilderFactory as namespace-aware then you'll get the output of the stylesheet as your transformation (!)", "label": {"api": {"Source": [[61, 66], [155, 160]], "stylesheet": [[92, 101], [306, 315]], "DOMSource": [[152, 160]], "did not declare his associated DocumentBuilderFactory as namespace-aware": [[199, 270]]}}}, {"text": "tell your callers what to do (?!) or—if you have any control over the transformation process itself—make sure you don't ever accept a Source that is in fact a DOMSource", "label": {"api": {"Source": [[134, 139], [162, 167]], "DOMSource": [[159, 167]]}}}, {"text": "The concurrent collections are quite performant", "label": {"api": {"performant": [[37, 46]]}}}, {"text": "you can catch PrivilegedActionException, and call getCause to get SocketTimeoutException", "label": {"api": {"getCause": [[50, 57]]}}}, {"text": "is too big to fit in a long you will encounter the following behaviour, quoting the BigInteger#longValue method in the JDK", "label": {"api": {"BigInteger#longValue": [[84, 103]]}}}, {"text": "You can use .flatMap() the nested nodes", "label": {"api": {".flatMap()": [[12, 21]]}}}, {"text": "Not to use inheritance, reflection through ServerEndpointConfig.Configurator.getEndpointInstance might work", "label": {"api": {"ServerEndpointConfig.Configurator.getEndpointInstance": [[43, 95]]}}}, {"text": "If the fields are limited, for example if you only need various combinations of fields, you could create an interface for each field (getter and setter) and then creaty a Proxy object for all of them, handling the data, for example, with an internal HashMap", "label": {"api": {"Proxy": [[171, 175]]}}}, {"text": "ColorAdjust based sample which converts a color image to monochrome by desaturating it when you mouse-over the image", "label": {"api": {"ColorAdjust": [[0, 10]]}}}, {"text": "Given appropriate hardware (which is available to most systems JavaFX runs on), the JavaFX runtime may perform some of the implementation of the color adjustment in hardware, which might lead to a more efficient implementation than manipulating pixels using a PixelWriter", "label": {"api": {"PixelWriter": [[260, 270]]}}}, {"text": "For this type of requirements, I'd ditch the JFormattedTextField (you don't want to format but to filter) and use a normal JTextField, with a custom DocumentFilter on its document", "label": {"api": {"DocumentFilter": [[149, 162]]}}}, {"text": "The 'Person:' output shows the hash code for the Map.Entry object (entry.hashCode()), and has no bearing on p1/p2", "label": {"api": {"Map.Entry": [[49, 57]]}}}, {"text": "You can use toString() method of Arrays class, like this", "label": {"api": {"toString()": [[12, 21]]}}}, {"text": "a ThreadPoolExecutor as an argument, whereas for sequential processing you could pass in a fake Executor, i.e", "label": {"api": {"ThreadPoolExecutor": [[2, 19]]}}}, {"text": "You can use the KeyFrame constructor that takes an event handler to perform an action at that key frame (in this case, establishing the additional binding)", "label": {"api": {"KeyFrame constructor that takes an event handler": [[16, 63]]}}}, {"text": "I would recommend using a CountDownLatch initialized with a count of 1, instead of a condition", "label": {"api": {"CountDownLatch": [[26, 39]]}}}, {"text": "Given the y axis parameter, it will naturally flow in the direction you require, and not expand the child components to fit the parent", "label": {"api": {"y axis": [[10, 15]]}}}, {"text": "Use SwingUtilites.invokeLater() and pass it a Runnable that will make the necessary UI changes", "label": {"api": {"SwingUtilites.invokeLater()": [[4, 30]]}}}, {"text": "This is also mentioned in the Javadocs of DriverManager", "label": {"api": {"DriverManager": [[42, 54]]}}}, {"text": "When the method getConnection is called, the DriverManager will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same classloader as the current applet or application", "label": {"api": {"DriverManager": [[45, 57]]}}}, {"text": "One aspect of the behavior of the one-argument split method can be surprising -- trailing nulls are discarded from the returned array", "label": {"api": {"one-argument split method": [[34, 58]]}}}, {"text": "To get a length of 2 for each case, you can pass in a negative second argument to the two-argument split method, which means that the length is unrestricted and no trailing empty strings are discarded", "label": {"api": {"two-argument split method": [[86, 110]]}}}, {"text": "You can set the thickness of the rectangle by creating a Graphics2D object and setting its stroke", "label": {"api": {"stroke": [[91, 96]]}}}, {"text": "Somewhat surprisingly, PrintWriter methods don't throw exceptions", "label": {"api": {"PrintWriter methods don't throw exceptions": [[23, 64]]}}}, {"text": "You can use java.math.BigInteger", "label": {"api": {"java.math.BigInteger": [[12, 31]]}}}, {"text": "Use the Collections.sort(List, Comparator) method", "label": {"api": {"Collections.sort(List, Comparator)": [[8, 41]], "Comparator": [[31, 40]]}}}, {"text": "Create Comparator like below", "label": {"api": {"Comparator": [[7, 16]]}}}, {"text": "This comparator will decide, logic that you want to use to sort the list", "label": {"api": {"sort": [[59, 62]]}}}, {"text": "And then sort list after you populated using", "label": {"api": {"sort": [[9, 12]]}}}, {"text": "You can use the listIterator like this", "label": {"api": {"listIterator": [[16, 27]]}}}, {"text": "I am recently wondering how functions like the InputStream int read(byte[] b) method are working", "label": {"api": {"InputStream int read(byte[] b)": [[47, 76]]}}}, {"text": "I would personally prefer using the Random class, and its Random#nextInt(int) method", "label": {"api": {"Random#nextInt(int)": [[58, 76]]}}}, {"text": "Not only I find it more elegant (and avoids casting), I also find it extremely useful to be able to use the same Random object that I created and planted its seed (with the constructor Random(long)), since it makes life much easier when trying to reproduce some unexpected behavior later on", "label": {"api": {"Random(long)": [[185, 196]]}}}, {"text": "Use ImageIO.write to save the image in compressed format", "label": {"api": {"ImageIO.write": [[4, 16]]}}}, {"text": "I think what you are looking for is Collections.sort(java.util.List, java.util.Comparator)", "label": {"api": {"Collections.sort(java.util.List, java.util.Comparator)": [[36, 89]]}}}, {"text": "This can be done using String.intern()", "label": {"api": {"String.intern()": [[23, 37]]}}}, {"text": "The ProcessBuilder class can be used to start a process, and it returns a Process instance that you can use to stop that process", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "Look at the Arrays utility class", "label": {"api": {"Arrays": [[12, 17]]}}}, {"text": "If you know that the InputStream can be interpreted as text, you can wrap it in a InputStreamReader and use BufferedReader#lines() to consume it line by line", "label": {"api": {"BufferedReader#lines()": [[108, 129]]}}}, {"text": "Instead you can use Reader.ready to first test if the stream can be read without blocking (i.e", "label": {"api": {"Reader.ready": [[20, 31]]}}}, {"text": "Use java.math.BigInteger that provides arbitrary long integers and methods to operate on them", "label": {"api": {"java.math.BigInteger": [[4, 23]]}}}, {"text": "Your MyArrayList class must implement Iterable<T> interface", "label": {"api": {"Iterable<T>": [[38, 48]]}}}, {"text": "As per explanation given for PreparedStatement in the JDBC docs, I see that it improves the performance compared to Statement", "label": {"api": {"PreparedStatement": [[29, 45]], "Statement": [[37, 45], [116, 124]]}}}, {"text": "So why we still use Statement and it is not deprecated", "label": {"api": {"Statement": [[20, 28]]}}}, {"text": "This makes it easy to read out whole variables in one go via the System.arraycopy method", "label": {"api": {"System.arraycopy": [[65, 80]]}}}, {"text": "I am able to create servlets and filters in my ServletContainerInitializer, but is it possible to translate this last remaining piece of an old web.xml into Servlet 3.0 programmatic configuration", "label": {"api": {"ServletContainerInitializer": [[47, 73]]}}}, {"text": "In your example code, you're calling String.contains() which does not use regular expressions", "label": {"api": {"String.contains()": [[37, 53]]}}}, {"text": "Certain methods of String - namely String.matches(), String.replaceAll(), String.replaceFirst(), and String.split() - are convenient wrappers around the regular expression behaviour Pattern provides", "label": {"api": {"String.matches()": [[35, 50]], "String.replaceAll()": [[53, 71]], "String.replaceFirst()": [[74, 94]], "String.split()": [[101, 114]], "Pattern": [[182, 188]]}}}, {"text": "For example, String.split() simply* calls", "label": {"api": {"String.split()": [[13, 26]]}}}, {"text": "This the JButton API", "label": {"api": {"JButton API": [[9, 19]]}}}, {"text": "To use URL-safe base 64 it is possible to use the new Base64 class in java.util (since Java 8)", "label": {"api": {"the new Base64 class in java.util": [[46, 78]]}}}, {"text": "The API documentation says", "label": {"api": {"API documentation": [[4, 20]]}}}, {"text": "What you want is the options from the JAI equivalent (ConvolveDescriptor), which is EDGE_REFLECT (or EDGE_WRAP, if you want repeating patterns)", "label": {"api": {"ConvolveDescriptor": [[54, 71]]}}}, {"text": "The thing that jumps out is that replaceAll returns a string with the changes made in it, it doesn't change the string you call it on (it can't, strings are immutable)", "label": {"api": {"replaceAll": [[33, 42]]}}}, {"text": "I don't think so, and there's no mention of it I could see in the Formatter docs, but you can always use something like", "label": {"api": {"the Formatter docs": [[62, 79]]}}}, {"text": "You can use the Calendar.getDisplayName(int field, int style, Locale locale) method", "label": {"api": {"Calendar.getDisplayName(int field, int style, Locale locale)": [[16, 75]]}}}, {"text": "Is correct that HTMLEditorKit ignores tags such as seen below (used to emulate IE7 in a IE7+ browser) when rendering HTML content", "label": {"api": {"HTMLEditorKit": [[16, 28]]}}}, {"text": "Documentation on HTMLEditorKit mentions that it", "label": {"api": {"HTMLEditorKit": [[17, 29]]}}}, {"text": "Ideally, you should make SavingsAccount implement the Comparable (see docs) interface, like this", "label": {"api": {"see docs": [[66, 73]]}}}, {"text": "Iterator#remove doesn't receive any parameter", "label": {"api": {"Iterator#remove": [[0, 14]]}}}, {"text": "The accept method expects two arguments", "label": {"api": {"The accept method expects two arguments": [[0, 38]]}}}, {"text": "Here is the list of supported formats", "label": {"api": {"Here is the list": [[0, 15]]}}}, {"text": "Use Simple Date Format", "label": {"api": {"Simple Date Format": [[4, 21]]}}}, {"text": "Simple Date Format also works for parsing dates; just call .parse(stringRepresentation), and get a Date instance back", "label": {"api": {"Simple Date Format": [[0, 17]]}}}, {"text": "It has the ability to pass in an Appendable for the sake of optional extra information (listing each file, giving statistics, etcetera)", "label": {"api": {"Appendable": [[33, 42]]}}}, {"text": "Can I safely stick with an Appendable or should I be considering something else", "label": {"api": {"Appendable": [[27, 36]]}}}, {"text": "The problem with using Appendable from multiple threads is that it is not specified as thread safe", "label": {"api": {"Appendable": [[23, 32]]}}}, {"text": "This one uses a BlockingQueue and a thread that pulls data out of it and forwards it to their Appendable", "label": {"api": {"Appendable": [[94, 103]]}}}, {"text": "If it's not feasible to you, you can intercept instantiation process of the class annotated with ServerEndpoint by using a your own version of ServerEndpointConfig.Configurator", "label": {"api": {"ServerEndpointConfig.Configurator": [[143, 175]]}}}, {"text": "See the Java Docs on KeyGenerator init methods", "label": {"api": {"Java Docs on KeyGenerator init methods": [[8, 45]]}}}, {"text": "Pass a Comparator<Long[]> to the constructor that takes one, so the TreeSet knows how you want the Long[]s compared", "label": {"api": {"the constructor that takes one": [[29, 58]]}}}, {"text": "When you need to compose a String like this, you should use a StringBuilder instead", "label": {"api": {"StringBuilder": [[62, 74]]}}}, {"text": "You should also implement equals and make your class implement Comparable<T> and implement compareTo", "label": {"api": {"Comparable<T>": [[63, 75]]}}}, {"text": "Once you have done that, you can sort a collection of Tuple instances (using Collections.sort) and they will be sorted according to the ordering specified by your compareTo method", "label": {"api": {"Collections.sort": [[77, 92]]}}}, {"text": "If you don't care so much about defining implicit ordering for your class by implementing Comparable<T>, you can specify an ad-hoc comparator using Comparator#comparingInt and use it with an array of your objects", "label": {"api": {"Comparable<T>": [[90, 102]], "Comparator#comparingInt": [[148, 170]]}}}, {"text": "In EJB 3.0, the default transaction attribute for all EJB 3.0 applications is REQUIRED", "label": {"api": {"transaction attribute": [[24, 44]], "REQUIRED": [[78, 85]]}}}, {"text": "You'll need to change this to public class Treasure implements Comparable<Treasure> -- see the Comparable docs for more details", "label": {"api": {"the Comparable docs": [[91, 109]]}}}, {"text": "Object.equals() takes an object of type Object, so the second example is wrong because it takes an Animal object instead", "label": {"api": {"Object.equals()": [[0, 14]]}}}, {"text": "Change it to a TreeMap and use the headMap() method", "label": {"api": {"headMap() method": [[35, 50]]}}}, {"text": "BufferedImage, BufferStrategy, Image) provides a custom implementation that makes sense in their respective context", "label": {"api": {"BufferedImage": [[0, 12]], "BufferStrategy": [[15, 28]], "Image": [[8, 12], [31, 35]]}}}, {"text": "A BufferedImage for example, as the name implies, could draw upon a raster maintained in main memory whilst a VolatileImage could draw directly into VRAM (implementation-specific)", "label": {"api": {"BufferedImage": [[2, 14]], "Image": [[10, 14], [118, 122]]}}}, {"text": "And in fact your example has a specific method built into Files that takes a Glob", "label": {"api": {"takes a Glob": [[69, 80]]}}}, {"text": "Or, using the more modern Files.list", "label": {"api": {"Files.list": [[26, 35]]}}}, {"text": "You should go read this article here so you understand formatting in Java and don't fail your test", "label": {"api": {"read this article here": [[14, 35]]}}}, {"text": "The javadoc for Scanner describes this behaviour, the summary on top usually gives you all the information you need to use that class", "label": {"api": {"javadoc for Scanner": [[4, 22]]}}}, {"text": "If this is for a real application and not just for practice, use Collections.shuffle() instead of implementing this yourself", "label": {"api": {"Collections.shuffle()": [[65, 85]]}}}, {"text": "You need to invoke Platform.setImplicitExit(false), otherwise the JavaFX runtime will shut down when you close the last stage", "label": {"api": {"Platform.setImplicitExit(false)": [[19, 49]], "shut down when you close the last stage": [[86, 124]]}}}, {"text": "See the API documentation of Field.get(Object o)", "label": {"api": {"Field.get(Object o)": [[29, 47]]}}}, {"text": "Or you could use Java's BigDecimal class", "label": {"api": {"BigDecimal": [[24, 33]]}}}, {"text": "Then, to see if the regex matches the filename, use String#matches()", "label": {"api": {"String#matches()": [[52, 67]]}}}, {"text": "More info about ArrayLists", "label": {"api": {"ArrayLists": [[16, 25]]}}}, {"text": "Most often, the @JoinColumn is use for mapping FK", "label": {"api": {"@JoinColumn": [[16, 26]]}}}, {"text": "If you have a link table, you need to use @JoinTable instead", "label": {"api": {"@JoinTable": [[42, 51]]}}}, {"text": "Better way to pool for the result should be using CompletionService", "label": {"api": {"CompletionService": [[50, 66]]}}}, {"text": "You can call Class#newInstance()", "label": {"api": {"Class#newInstance()": [[13, 31]]}}}, {"text": "You can use an ArrayBlockingQueue from the java.util.concurrent package, in place of the iRobotBuffer class", "label": {"api": {"ArrayBlockingQueue": [[15, 32]]}}}, {"text": "You may also use    fill(int[] a, int fromIndex, int toIndex, int val) method too if you want to fill the array with a specific value", "label": {"api": {"fill(int[] a, int fromIndex, int toIndex, int val)": [[20, 69]]}}}, {"text": "With Java 8 you can create a WatchService", "label": {"api": {"WatchService": [[29, 40]]}}}, {"text": "Use a java.util.Map", "label": {"api": {"java.util.Map": [[6, 18]]}}}, {"text": "You can use Map#values() to get a collection view of the values, that is a collections of languages", "label": {"api": {"Map#values()": [[12, 23]]}}}, {"text": "You can listen to the localToSceneTransformProperty()", "label": {"api": {"localToSceneTransformProperty()": [[22, 52]]}}}, {"text": "You could use Object.getClass()", "label": {"api": {"Object.getClass()": [[14, 30]]}}}, {"text": "Java has the BigInteger class which may work for your scenario", "label": {"api": {"BigInteger": [[13, 22]]}}}, {"text": "See Timer for better information", "label": {"api": {"Timer": [[4, 8]]}}}, {"text": "See java's comparator documentation", "label": {"api": {"comparator": [[11, 20]]}}}, {"text": "The properties you want can be obtained from RuntimeMXBean", "label": {"api": {"RuntimeMXBean": [[45, 57]]}}}, {"text": "(You should return 0 only if the two objects equal each other)", "label": {"api": {"if the two objects equal each other": [[26, 60]]}}}, {"text": "The Comparable interface also defines more requirements (results need to be transitive, ...)", "label": {"api": {"Comparable": [[4, 13]]}}}, {"text": "For example, keep track of your TimerTasks properly and cancel those as necessary", "label": {"api": {"cancel those": [[56, 67]]}}}, {"text": "a ScheduledExecutorService, so that you just have to keep track of Runnables (with just one central ExecutorService to manage) rather than having to track individual timers and tasks (at the cost of not having the handy TimerTask.cancel() available) -- this may or may not ease design", "label": {"api": {"ScheduledExecutorService": [[2, 25]]}}}, {"text": "A better approach would be to use a proper String constructor", "label": {"api": {"proper String constructor": [[36, 60]]}}}, {"text": "Also in case if there's a possibility that data encoding is different from your platform's default one you have to use a constructor which takes a Charset as an additional parameter", "label": {"api": {"a constructor": [[119, 131]]}}}, {"text": "This can be done with a CompletableFuture (or if not available, Guava's SettableFuture)", "label": {"api": {"CompletableFuture": [[24, 40]]}}}, {"text": "Luckily, you can tell Scanner what CharSet you want it to use by using one of the 2 argument constructors like this one", "label": {"api": {"this one": [[111, 118]]}}}, {"text": "What is the color model", "label": {"api": {"color model": [[12, 22]]}}}, {"text": "What is the data type of the sample model", "label": {"api": {"data type": [[12, 20]], "sample model": [[29, 40]]}}}, {"text": "Using an image type of TYPE_4BYTE_ABGR would lead to a minimum size of 256MB (8K * 8K * 4)", "label": {"api": {"TYPE_4BYTE_ABGR": [[23, 37]]}}}, {"text": "Using a data type of int (instead of byte) could increase that 4x", "label": {"api": {"data type": [[8, 16]]}}}, {"text": "At the very least, use Collections.synchronizedList()as described in the LinkedList JavaDocs", "label": {"api": {"the LinkedList JavaDocs": [[69, 91]]}}}, {"text": "use a thread safe, concurrent data structure such as ConcurrentLinkedQueue, ArrayBlockingQueue or LinkedBlockingQueue", "label": {"api": {"ConcurrentLinkedQueue": [[53, 73]], "ArrayBlockingQueue": [[76, 93]], "LinkedBlockingQueue": [[98, 116]]}}}, {"text": "You can call the method Scanner#useDelimiter(Pattern)", "label": {"api": {"Scanner#useDelimiter(Pattern)": [[24, 52]]}}}, {"text": "For NumberFormat, use the getNumberInstance method that takes a Locale as a parameter", "label": {"api": {"the getNumberInstance method that takes a Locale as a parameter": [[22, 84]]}}}, {"text": "For DateFormat, use the getDateInstance method that takes a Locale as a parameter", "label": {"api": {"the getDateInstance method that takes a Locale as a parameter": [[20, 80]]}}}, {"text": "Since you said, I want to have a list that's always sorted, use a java.util.TreeSet<E> or a java.util.PriorityQueue<E>", "label": {"api": {"java.util.TreeSet<E>": [[66, 85]], "java.util.PriorityQueue<E>": [[92, 117]]}}}, {"text": "implement Comparable<T> or you have to provide a Comparator<T>", "label": {"api": {"Comparable<T>": [[10, 22]], "Comparator<T>": [[49, 61]]}}}, {"text": "You could use a TreeSet to maintain a sorted set and, if you need to, can wrap it in a thread safe wrapper using Collections.synchronizedSortedSet()", "label": {"api": {"TreeSet": [[16, 22]], "Collections.synchronizedSortedSet()": [[113, 147]]}}}, {"text": "Iterate through all your children and calculate the total bounds in parent, relocate the children so that the top/left position is 0/0, calculate a scale factor depending on the total bounds and the view and then apply setScaleX and setScaleY", "label": {"api": {"bounds in parent": [[58, 73]], "setScaleX": [[219, 227]], "setScaleY": [[233, 241]]}}}, {"text": "Assuming you are working with Strings, the method lastIndexOf() seems to suit your needs", "label": {"api": {"lastIndexOf()": [[50, 62]]}}}, {"text": "Have a look at the Java UUID Class", "label": {"api": {"Java UUID Class": [[19, 33]]}}}, {"text": "If you are using Java 8 I recommend instead looking at DateTimeFormatter which can handle nanoseconds or if pre Java 8 use Joda Time", "label": {"api": {"DateTimeFormatter": [[55, 71]]}}}, {"text": "I'm using the InputStream Java class for managing incoming data from bluetooth RFCOMM channel, with Android device", "label": {"api": {"InputStream": [[14, 24]]}}}, {"text": "You should use a StringBuilder (docs here) instead of String concatenation to fill the contents of the text variable", "label": {"api": {"docs here": [[32, 40]]}}}, {"text": "In this case you should use appendReplacement and appendTail methods, which work in tandem", "label": {"api": {"appendReplacement": [[28, 44]], "appendTail": [[50, 59]]}}}, {"text": "One possible approach is to use the arbitrary properties map on Node to store a reference from Menu to MenuBar as this example shows", "label": {"api": {"arbitrary properties map": [[36, 59]]}}}, {"text": "Under the hood ThreadPoolTaskExecutor uses LinkedBlockingQueue which does not provide uniqueness", "label": {"api": {"LinkedBlockingQueue": [[43, 61]]}}}, {"text": "Using ThreadPoolExecutor instead of ThreadPoolTaskExecutor", "label": {"api": {"ThreadPoolExecutor": [[6, 23]]}}}, {"text": "The ThreadPoolExecutor provides a constructor which lets me determine the thread pool queue type, but it needs to implement the BlockingQueue interface", "label": {"api": {"ThreadPoolExecutor": [[4, 21]]}}}, {"text": "This led me to try and extend LinkedBlockingQueue and override add", "label": {"api": {"LinkedBlockingQueue": [[30, 48]]}}}, {"text": "Check the Arrays.sort() (docs here) method", "label": {"api": {"docs here": [[25, 33]]}}}, {"text": "Use Arrays.fill(array, fromIndex, toIndex, val) (docs here) to fill the array with -1, from array.length - start to array.length", "label": {"api": {"docs here": [[49, 57]]}}}, {"text": "From the Object JavaDoc", "label": {"api": {"Object": [[9, 14]]}}}, {"text": "Class Object is the root of the class hierarchy", "label": {"api": {"Object": [[6, 11]]}}}, {"text": "Every class has Object as a superclass", "label": {"api": {"Object": [[16, 21]]}}}, {"text": "If you had several properties to monitor, with different outcomes, you could even use addPropertChangeListener(String propertyName, PropertyChangeListener listener) instead, and make one listener per emitter, per property", "label": {"api": {"addPropertChangeListener(String propertyName, PropertyChangeListener listener)": [[86, 163]]}}}, {"text": "Second, the Class.getResource and Class.getResourceAsStream methods (and their ClassLoader equivalents) require a String argument containing forward slashes (/), on all platforms, even Windows", "label": {"api": {"a String argument containing forward slashes (/)": [[112, 159]]}}}, {"text": "The Float.parseFloat method parses the number the same as Float.valueOf(String), whose javadocs state", "label": {"api": {"javadocs state": [[87, 100]]}}}, {"text": "The correct way is to make use of javax.servlet.ServletContext.getResourceAsStream(java.lang.String)", "label": {"api": {"javax.servlet.ServletContext.getResourceAsStream(java.lang.String)": [[34, 99]]}}}, {"text": "The JavaDoc for the ArrayList constructor being invoked says", "label": {"api": {"JavaDoc for the ArrayList constructor being invoked": [[4, 54]]}}}, {"text": "The JavaDoc for Collections.synchronizedMap() includes this very important note", "label": {"api": {"JavaDoc for Collections.synchronizedMap()": [[4, 44]]}}}, {"text": "Or use StandardCharsets.UTF_8 instead to avoid any ambiguity", "label": {"api": {"StandardCharsets.UTF_8": [[7, 28]]}}}, {"text": "The Scanner(String) constructor points the Scanner at the contents of that string -- the string doesn't represent a filename", "label": {"api": {"Scanner(String)": [[4, 18]]}}}, {"text": "The most natural choice would be CharBuffer", "label": {"api": {"CharBuffer": [[33, 42]]}}}, {"text": "Like String and StringBuilder it implements the CharSequence interface, therefore it can be used with a lot of text oriented APIs, most notably the regex engine which is the back-end for most search, split, and replacing operations", "label": {"api": {"regex engine": [[148, 159]]}}}, {"text": "What makes CharBuffer the natural choice is that it is also the type that is used by the charset package which provides the necessary operations for converting characters from and to bytes", "label": {"api": {"CharBuffer": [[11, 20]], "charset package": [[89, 103]]}}}, {"text": "By dealing with this API you can do the conversion directly from and to CharBuffers without additional data copying steps", "label": {"api": {"CharBuffer": [[72, 81]]}}}, {"text": "Note that Java’s regex API is prepared for processing buffers containing partially read files and can report whether reading more data might change the result (see hitEnd() and requireEnd())", "label": {"api": {"hitEnd()": [[164, 171]], "requireEnd()": [[177, 188]]}}}, {"text": "Try using a HBox wrapped inside a ScrollPane", "label": {"api": {"HBox": [[12, 15]], "ScrollPane": [[34, 43]]}}}, {"text": "You can add elements to HBox using getChildren.add(node)", "label": {"api": {"HBox": [[24, 27]]}}}, {"text": "The elements will be automatically shown on the scene and the ScrollPane will adjust the ScrollBar for you", "label": {"api": {"ScrollPane": [[62, 71]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html?is-external=true is a wonderful resource to get you started (and way beyond started) with regular expressions in Java", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html?is-external=true": [[0, 86]]}}}, {"text": "Using a BitSet in place of int[] might reduce the memory footprint", "label": {"api": {"BitSet": [[8, 13]]}}}, {"text": "In the case of a JButton, its superclass AbstractButton calls the actionPerformed method through the method fireActionPerformed which is a protected method", "label": {"api": {"fireActionPerformed": [[108, 126]]}}}, {"text": "The java.sql.Date type is used to store only date (no time) information, as it maps to the SQL DATE type, which doesn't store time", "label": {"api": {"java.sql.Date": [[4, 16]]}}}, {"text": "What its toString() method does is", "label": {"api": {"toString()": [[9, 18]]}}}, {"text": "To achieve the desired output you can use java.sql.Timestamp, which stores date and time information, mapping to the SQL TIMESTAMP type", "label": {"api": {"java.sql.Timestamp": [[42, 59]]}}}, {"text": "Its toString() method outputs what you need", "label": {"api": {"toString()": [[4, 13]]}}}, {"text": "You could also change the code to create a new ConsoleHandler and add it to the root logger after you have remapped the error stream", "label": {"api": {"ConsoleHandler": [[47, 60]]}}}, {"text": "The javadoc of Spliterator (which is basically what is really behind a Stream if I understand things correctly) defines many characeristics which make sense such as SIZED, CONCURRENT, IMMUTABLE etc", "label": {"api": {"javadoc of Spliterator": [[4, 25]]}}}, {"text": "But it also defines NONNULL; why", "label": {"api": {"NONNULL": [[20, 26]]}}}, {"text": "The javadoc of Spliterator itself doesn't mention any real usage of it, and neither does the package-info.java of the java.util.stream package..", "label": {"api": {"javadoc of Spliterator": [[4, 25]]}}}, {"text": "Scanner input = new Scanner (\"Grades.txt\"); uses Scanner(String) which means it will use the String parameter as the source to read the data", "label": {"api": {"Scanner(String)": [[49, 63]]}}}, {"text": "In case you want/need to append data to the end of the output, then use FileWriter(String, boolean) and pass the second parameter as true", "label": {"api": {"FileWriter(String, boolean)": [[72, 98]]}}}, {"text": "Note that this is no different from Java, it is, in fact, exactly equivalent to java.lang.Iterable.forEach", "label": {"api": {"java.lang.Iterable.forEach": [[80, 105]]}}}, {"text": "One of the option to try is to use http://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html and obtain the source of the page", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html": [[35, 102]]}}}, {"text": "Java 9 added the static factory method Stream.<T>ofNullable(T), which returns the empty stream given a null argument, otherwise a stream with the argument as its only element", "label": {"api": {"Stream.<T>ofNullable(T)": [[39, 61]]}}}, {"text": "If the argument is a collection, we can then flatMap to turn it into a stream", "label": {"api": {"flatMap": [[45, 51]]}}}, {"text": "It also works with an upper-bounded wildcard without needing SuppressWarnings(\"unchecked\") thanks to the signature of flatMap, so you can get a Stream<T> from a collection of elements of any subtype of T", "label": {"api": {"flatMap": [[118, 124]]}}}, {"text": "You can use DecimalFormat class", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "You can do it in O(n), if you use some data structure that supports O(1) get operations - for example HashMap", "label": {"api": {"HashMap": [[102, 108]]}}}, {"text": "One of those methods is the Object.equals() method - here is its documentation", "label": {"api": {"its documentation": [[61, 77]]}}}, {"text": "From the Properties.store documentation", "label": {"api": {"Properties.store": [[9, 24]]}}}, {"text": "println(char[] s) does somewhat confuse me in the Oracle Doc - In C you would generally iterate through every element within the array and print each element follow by a \\n to break the line", "label": {"api": {"Oracle Doc": [[50, 59]]}}}, {"text": "Another option would be to use Document", "label": {"api": {"Document": [[31, 38]]}}}, {"text": "Since Java 8, you can use the Stream API for things like that", "label": {"api": {"Stream API": [[30, 39]]}}}, {"text": "You can search for objects that satisfy a certain condition using filter()", "label": {"api": {"filter()": [[66, 73]]}}}, {"text": "You can sort the list using a custom Comparator", "label": {"api": {"Comparator": [[37, 46]]}}}, {"text": "If you are using Java 7 and below, you should use Collections.sort() and create an explicit Comparator", "label": {"api": {"Comparator": [[92, 101]]}}}, {"text": "You should use the Thread#start() method instead of Thread#run()", "label": {"api": {"Thread#start()": [[19, 32]]}}}, {"text": "Although the documentation isn't as clear as it could be, GridBagConstraints is a lot easier to use when you make use of GridBagConstraints.RELATIVE and GridBagConstraints.REMAINDER", "label": {"api": {"GridBagConstraints.RELATIVE": [[121, 147]], "GridBagConstraints.REMAINDER": [[153, 180]]}}}, {"text": "It sounds like you want to pass in the class (rather than an instance of the class) and use Class.isInstance", "label": {"api": {"Class.isInstance": [[92, 107]]}}}, {"text": "You can use global exception handler for UI thread", "label": {"api": {"global exception handler": [[12, 35]]}}}, {"text": "Class Scanner associated with class File allows you to read easily this kind of file", "label": {"api": {"Scanner": [[6, 12]], "File": [[36, 39]]}}}, {"text": "Example from Scanner doc", "label": {"api": {"Scanner": [[13, 19]]}}}, {"text": "Use a BufferedImage", "label": {"api": {"BufferedImage": [[6, 18]]}}}, {"text": "You can even draw on them if it matters for your test", "label": {"api": {"draw on them": [[13, 24]]}}}, {"text": "Also I think you want to use Comparable instead of your own Comparator", "label": {"api": {"Comparable": [[29, 38]]}}}, {"text": "Math.signum() provides what you ask for", "label": {"api": {"Math.signum()": [[0, 12]]}}}, {"text": "You want to use the matches() method instead of equals()", "label": {"api": {"matches()": [[20, 28]]}}}, {"text": "You could write the file to a string and iterate over the keys in your dictionary and check if they are present in the paragraph with contains", "label": {"api": {"contains": [[134, 141]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html as there is a good example in the description", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html": [[4, 73]]}}}, {"text": "If I understand correctly, System.currentTimeMillis() is faster, and System.nanoTime() is more accurate", "label": {"api": {"System.currentTimeMillis()": [[27, 52]], "System.nanoTime()": [[69, 85]]}}}, {"text": "If I am pinging a server, which in worst case I expect to take...lets go extreme...one minute, is System.currentTimeMillis() still going to be accurate within 1-2 milliseconds", "label": {"api": {"System.currentTimeMillis()": [[98, 123]]}}}, {"text": "Or should I go with System.nanoTime()", "label": {"api": {"System.nanoTime()": [[20, 36]]}}}, {"text": "As you can see, I am currently using System.nanoTime(), but am unsure if I should be using System.currentTimeMillis()", "label": {"api": {"System.currentTimeMillis()": [[91, 116]], "System.nanoTime()": [[37, 53]]}}}, {"text": "System.currentTimeMillis vs System.nanoTime has a lot of great information on the subject, but not specifics on accuracy of System.currentTimeMillis()", "label": {"api": {"System.currentTimeMillis()": [[124, 149]]}}}, {"text": "In java, rectangles are defined by upper-left corner coordinates, width and height", "label": {"api": {"rectangles": [[9, 18]]}}}, {"text": "Look at JComboBox's constructors", "label": {"api": {"constructors": [[20, 31]]}}}, {"text": "The getYear() method returns the date \"minus 1900\", so that 1999 is 99, 2000 is 100, etc", "label": {"api": {"getYear() method": [[4, 19]]}}}, {"text": "Instead, use a SimpleDateFormat object to control your formatting", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "Concrete implementations of Graphics2D on each supported platform direct painting to a heavyweight peer component provided by the host, e.g", "label": {"api": {"Graphics2D": [[28, 37]]}}}, {"text": "Use a PauseTransition instead", "label": {"api": {"PauseTransition": [[6, 20]]}}}, {"text": "Yes, but use javax.json - http://docs.oracle.com/javaee/7/api/javax/json/package-summary.html", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/json/package-summary.html": [[26, 92]]}}}, {"text": "Use Enum.valueOf(Class<T>, String) or rather implicitly defined valueOf(String) method, which returns the constant with the given name", "label": {"api": {"Enum.valueOf(Class<T>, String)": [[4, 33]]}}}, {"text": "In Scanner, if you take nextDouble() method, it throws various exceptions depending on the status of the scanner", "label": {"api": {"nextDouble()": [[24, 35]]}}}, {"text": "If you are using Java 8 you can use filter()", "label": {"api": {"filter()": [[36, 43]]}}}, {"text": "Try to use Socket.setTcpNoDelay(boolean)", "label": {"api": {"Socket.setTcpNoDelay(boolean)": [[11, 39]]}}}, {"text": "You can use setName(String name) from Thread class to identify the producer threads accordingly", "label": {"api": {"setName(String name)": [[12, 31]]}}}, {"text": "From the Javadocs of Thread#start()", "label": {"api": {"Thread#start()": [[21, 34]]}}}, {"text": "quoting the javadoc of PrintStream.print(String)", "label": {"api": {"PrintStream.print(String)": [[23, 47]]}}}, {"text": "Work with Future rather than with Runnable", "label": {"api": {"Future": [[10, 15]]}}}, {"text": "There's this Future#isDone method that may help you", "label": {"api": {"Future": [[13, 18]], "Future#isDone": [[13, 25]]}}}, {"text": "In case you don't have anything meaningful to return from the Callable, use Callable<Void> and Future<Void>", "label": {"api": {"Future": [[95, 100]]}}}, {"text": "According to the documentation for Java agents the agent class is loaded by the system classloader", "label": {"api": {"the documentation for Java agents": [[13, 45]]}}}, {"text": "From the Set interface documentation", "label": {"api": {"Set interface documentation": [[9, 35]]}}}, {"text": "The same thing applies to Map keys, and you will find an equivalent statement in the Map interface documentation", "label": {"api": {"Map interface documentation": [[85, 111]]}}}, {"text": "From the Java Semaphore documentation", "label": {"api": {"Semaphore documentation": [[14, 36]]}}}, {"text": "The Scanner(String) variant gives you a scanner which reads the string, not the file that the string refers to", "label": {"api": {"Scanner(String)": [[4, 18]]}}}, {"text": "You're using the method in the Writer class that takes an int as an argument, with the lower 16 bits of the int representing the Unicode code point, and the corresponding character being printed to the file as shown by this table", "label": {"api": {"the method in the Writer class that takes an int as an argument": [[13, 75]]}}}, {"text": "Given a StyledDocument, as shown here, you can invoke setCharacterAttributes() with whatever style you want", "label": {"api": {"StyledDocument": [[8, 21]]}}}, {"text": "You could use a Pattern regular expression to achieve that", "label": {"api": {"Pattern regular expression": [[16, 41]]}}}, {"text": "To listen ObservableList I am using the following code in listener", "label": {"api": {"ObservableList": [[10, 23]]}}}, {"text": "But this contradicts the statement from ListChangeListener javadoc saying getList() should work at any time, and that getAddedSubList() is just a shortcut of getList() expression", "label": {"api": {"ListChangeListener javadoc": [[40, 65]]}}}, {"text": "Next, use a Set which will prevent duplicates (a LinkedHashSet, for example, preserves insertion order)", "label": {"api": {"LinkedHashSet": [[49, 61]]}}}, {"text": "by a Comparator", "label": {"api": {"Comparator": [[5, 14]]}}}, {"text": "But at a more fundamental level, if the program is intended to work with that file always (i.e., if the file is a resource for the program), you might want to turn to Class#getResourceAsStream()", "label": {"api": {"Class#getResourceAsStream()": [[167, 193]]}}}, {"text": "In that case, the existing TimeUnit enum is definitely your friend", "label": {"api": {"TimeUnit": [[27, 34]]}}}, {"text": "As @Louis Wasserman suggests, for these purposes, classes in the java.util.concurrent.atomic package provide reliable and easy to use methods, such as compareAndSet(...) and incrementAndGet()", "label": {"api": {"java.util.concurrent.atomic": [[65, 91]]}}}, {"text": "For example, actions taken by a thread before it calls countDown() on a CountDownLatch are visible to threads that return from a call to await() on that latch", "label": {"api": {"CountDownLatch": [[72, 85]]}}}, {"text": "The method Random.nextInt(int n) gives you back a number such that 0 ≤ number < n", "label": {"api": {"Random.nextInt(int n)": [[11, 31]]}}}, {"text": "There is a set of predefined layout panes, subclassing Pane, which lay the child nodes out in different ways", "label": {"api": {"Pane": [[55, 58]]}}}, {"text": "The Pane class does no layout, so using it is the closest equivalent to using a null layout manager in Swing", "label": {"api": {"Pane": [[4, 7]]}}}, {"text": "Check out the String#split method", "label": {"api": {"String#split": [[14, 25]]}}}, {"text": "UDP is done with the DatagramSocket", "label": {"api": {"DatagramSocket": [[21, 34]]}}}, {"text": "The nio functionality can be achieved by getting the associated channel", "label": {"api": {"getting the associated channel": [[41, 70]]}}}, {"text": "Yes, you can create different Predicate and use them based on condition", "label": {"api": {"Predicate": [[30, 38]]}}}, {"text": "A possibility would be to get rid of local and use compareAndSet on an AtomicBoolean which would play the role of shared_var at the moment", "label": {"api": {"compareAndSet": [[51, 63]], "AtomicBoolean": [[71, 83]]}}}, {"text": "This way, every thread should get a reference (excuse my loose nomenclature) to the AtomicBoolean used for signaling and use compareAndSet to atomically update the value of the variable in a way that is visible immediately to the other threads", "label": {"api": {"compareAndSet": [[125, 137]], "AtomicBoolean": [[84, 96]]}}}, {"text": "You can use a custom Comparator to compare the arrays by the third element", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "you assign to \"fields\" the Field[] object (returned from Class.getDeclaredFields()), not a Class[]", "label": {"api": {"Class.getDeclaredFields()": [[57, 81]], "Field": [[27, 31], [74, 78]]}}}, {"text": "As the Field class does not have a 'superclass' getter, your code in .ftl causes an exception", "label": {"api": {"Field": [[7, 11]]}}}, {"text": "but Field class has a method getDeclaringClass(), which gives a Class reference", "label": {"api": {"Field": [[4, 8]], "getDeclaringClass()": [[29, 47]]}}}, {"text": "DelayQueue is similar to what you want, except that it is time oriented", "label": {"api": {"DelayQueue": [[0, 9]]}}}, {"text": "Try calling inheritIO", "label": {"api": {"inheritIO": [[12, 20]]}}}, {"text": "I was testing a piece of our date management framework which is supposed to reset some Calendar fields (using actual minimum)", "label": {"api": {"Calendar": [[87, 94]], "actual minimum": [[110, 123]]}}}, {"text": "However, when changing first day of week, Calendar always return SUNDAY (1) as actual minimum for day of weeks", "label": {"api": {"Calendar": [[42, 49]], "actual minimum": [[79, 92]], "changing first day of week": [[14, 39]], "SUNDAY": [[65, 70]], "day of weeks": [[98, 109]]}}}, {"text": "Date class documentation, (see link for extra info)", "label": {"api": {"Date class": [[0, 9]]}}}, {"text": "Servlet 3.0 specification introduced standard way for servlet containers to handle multipart/form-data with introduction of MultipartConfigElement for configuration and Part interface and Spring MVC integrates with these with no problems", "label": {"api": {"MultipartConfigElement": [[124, 145]], "Part": [[169, 172]]}}}, {"text": "I want to get full path to file that is being output by Part.write() method, skipping unnecessary InputStream reading", "label": {"api": {"Part": [[56, 59]]}}}, {"text": "The files uploaded to my controller, due to their size, will most probably end up as temporary files output to disk by servlet container, therefore Part.write() will move the file into target name instead of misusing RAM resources", "label": {"api": {"Part": [[148, 151]]}}}, {"text": "I create the path to written file using autowired MultipartConfigElement that Spring happens to have as a bean", "label": {"api": {"MultipartConfigElement": [[50, 71]]}}}, {"text": "What about application that does not use Spring and doesn't have access to injected MultipartConfigElement bean", "label": {"api": {"MultipartConfigElement": [[84, 105]]}}}, {"text": "The method contains() is valid for Collections, not for Array", "label": {"api": {"Collections": [[35, 45]]}}}, {"text": "In order to use this method, you need to convert your arrays into Collections first", "label": {"api": {"Collections": [[66, 76]]}}}, {"text": "3.) If you need some form of notifcation once your thread has finised, you should use Callable in conjuction with Futures instead", "label": {"api": {"Callable": [[86, 93]], "Futures": [[114, 120]]}}}, {"text": "Simply said, you need a verifiable condition which is checked before and after calling wait() as explained in the documentation of wait()", "label": {"api": {"documentation of wait()": [[114, 136]]}}}, {"text": "There is in this case however little use to do so, especially because String objects are immutable, as you can read in the manual", "label": {"api": {"manual": [[123, 128]]}}}, {"text": "Take a look at Java's Runtime.exec(), or ProcessBuilder if you need something fancier", "label": {"api": {"Runtime.exec()": [[22, 35]], "ProcessBuilder": [[41, 54]]}}}, {"text": "If you want to model the case where next may or may point to another Node object you could use Optional (docs here)", "label": {"api": {"docs here": [[105, 113]]}}}, {"text": "When you start a thread, its run() method is executed (in a separate thread)", "label": {"api": {"run()": [[29, 33]]}}}, {"text": "By default, the run() method does nothing", "label": {"api": {"run()": [[16, 20]]}}}, {"text": "In fact, this is what the getElementText() method does for you - accumulates the data in a StringBuffer while going through CHARACTERS events until it hits the END_ELEMENT", "label": {"api": {"getElementText() method": [[26, 48]]}}}, {"text": "As a reminder, from the Object documentation", "label": {"api": {"Object documentation": [[24, 43]]}}}, {"text": "Try adding @Stateless annotation to your SecurityInterceptor class", "label": {"api": {"@Stateless": [[11, 20]]}}}, {"text": "You can try to use isPressed() method to check if the JButton is pressed", "label": {"api": {"isPressed()": [[19, 29]]}}}, {"text": "The documentation  (http://docs.oracle.com/javase/7/docs/api/java/io/IOException.html) contains a long list of direct subclasses", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/IOException.html": [[20, 84]]}}}, {"text": "From the javadoc of Class.getMethods()", "label": {"api": {"Class.getMethods()": [[20, 37]]}}}, {"text": "You can use Collections.sort to sort the array and then use your own Comparator to specify how you want to sort the values", "label": {"api": {"Collections.sort": [[12, 27]], "Comparator": [[69, 78]]}}}, {"text": "You've to actually invoke the method to get the result back using Method#invoke() method", "label": {"api": {"Method#invoke()": [[66, 80]]}}}, {"text": "Then you can try isEmpty() method", "label": {"api": {"isEmpty()": [[17, 25]]}}}, {"text": "Neither can String#split", "label": {"api": {"String#split": [[12, 23]]}}}, {"text": "If what you want is to remove FIRST ELEMENT only, use LinkedList::remove()", "label": {"api": {"LinkedList::remove()": [[54, 73]]}}}, {"text": "In this version of gwt the RemoteServiceRelativePath annotation doesn't have @Retention(RetentionPolicy.RUNTIME) on it, so the RemoteServiceRelativePath annotation is not available at the runtime", "label": {"api": {"@Retention(RetentionPolicy.RUNTIME)": [[77, 111]]}}}, {"text": "Apart from the methods already mentioned, you can also use map.forEach() to iterate across your map entries in insertion order", "label": {"api": {"map.forEach()": [[59, 71]]}}}, {"text": "Use a DataOutputStream to write an integer at the start that represents the amount of bytes that are written afterwards", "label": {"api": {"DataOutputStream": [[6, 21]]}}}, {"text": "I noticed you are using the Cipher class in a wrong way", "label": {"api": {"Cipher": [[28, 33]]}}}, {"text": "This will make sure, that the Cipher is only using the bytes it should", "label": {"api": {"Cipher": [[30, 35]]}}}, {"text": "This kind of thing will be far easier if you use the purpose-built concurrency tools like LinkedBlockingQueue rather than a plain HashSet", "label": {"api": {"LinkedBlockingQueue": [[90, 108]]}}}, {"text": "Have the producer add elements to the queue, and the consumer can use drainTo to extract elements from the queue in batches as it requires them", "label": {"api": {"drainTo": [[70, 76]]}}}, {"text": "If I understood correctly the detach you should do something like that", "label": {"api": {"detach": [[30, 35]]}}}, {"text": "Try using executeUpdate() method on the Statement", "label": {"api": {"executeUpdate()": [[10, 24]]}}}, {"text": "Since you are inside the Solution class, and it implements Comparator<Integer>, you probably mean", "label": {"api": {"Comparator<Integer>": [[59, 77]]}}}, {"text": "And in Java, arrays are objects too, but they don't override Object's toString method, which is responsible for the [LDog;@55f96302 output", "label": {"api": {"Object's toString method": [[61, 84]]}}}, {"text": "As an aside, you can use Arrays.toString if you want to print the contents of the array", "label": {"api": {"Arrays.toString": [[25, 39]]}}}, {"text": "With these changes (and mentionded System.arraycopy), the algorithm should work as intended", "label": {"api": {"System.arraycopy": [[35, 50]]}}}, {"text": "readLine() actually reads the line", "label": {"api": {"readLine()": [[0, 9]]}}}, {"text": "When you do pr.println(collection[i]); as you didn't override it, you print Object::toString which represents the object in this way by default", "label": {"api": {"Object::toString": [[76, 91]]}}}, {"text": "By the way, if you are only interested in the bit indices, you may use BigInteger#testBit instead", "label": {"api": {"BigInteger#testBit": [[71, 88]]}}}, {"text": "The first parameter of String.split is a regular expression, so you can write", "label": {"api": {"String.split": [[23, 34]]}}}, {"text": "Looking at the docs of Comparator, you will notice that it's a Java interface, which means you can create a class that implements both the Comparator.compare(T o1, T o2) and Comparator.equals(Object obj) methods", "label": {"api": {"Comparator": [[23, 32], [139, 148], [174, 183]]}}}, {"text": "So suppose you encapsulate all your string attributes in a Movie object (which I highly recommend), you can implement a MovieNameComparator class like this", "label": {"api": {"Comparator": [[129, 138]]}}}, {"text": "If you want to sort by other movie attributes, you can follow the same approach and create more comparator classes, like MovieDateComparator, MovieProductionStudioComparator etc", "label": {"api": {"Comparator": [[130, 139], [163, 172]]}}}, {"text": "Use String's equals(Object anObject) for your job", "label": {"api": {"equals(Object anObject)": [[13, 35]]}}}, {"text": "You you use Java-8, you can elegantly solve this problem using BufferedReader#lines", "label": {"api": {"BufferedReader#lines": [[63, 82]]}}}, {"text": "You can use GZIPInputStream and GZIPOutputStream to decorate the input respectivly output stream", "label": {"api": {"GZIPInputStream": [[12, 26]], "GZIPOutputStream": [[32, 47]]}}}, {"text": "How about doing it like this, using String.format()", "label": {"api": {"String.format()": [[36, 50]]}}}, {"text": "The OffsetDateTime is a date-time object that has a precision of nanoseconds, and includes the offset from UTC", "label": {"api": {"OffsetDateTime": [[4, 17]]}}}, {"text": "And the ISO_OFFSET_DATE_TIME is a standard DateTimeFormatter format, that understands the Z designation and sets it as offset 0 from UTC", "label": {"api": {"ISO_OFFSET_DATE_TIME": [[8, 27]]}}}, {"text": "There certainly is, the LinkedBlockingDeque", "label": {"api": {"LinkedBlockingDeque": [[24, 42]]}}}, {"text": "One of the options you have is to use String.split method", "label": {"api": {"String.split": [[38, 49]]}}}, {"text": "Maybe, the easier way would be using Scanner", "label": {"api": {"Scanner": [[37, 43]]}}}, {"text": "Look at the Exception javadoc for more Information", "label": {"api": {"Exception": [[12, 20]]}}}, {"text": "As @martin-prikryl's answer states, certain characters can't appear in their raw form in the username and password fields, or else they will make the URI invalid", "label": {"api": {"URI": [[150, 152]]}}}, {"text": "The root cause here is that you're using simple string concatenation to construct the URI", "label": {"api": {"URI": [[86, 88]]}}}, {"text": "Java has URI and URL classes which can be used to construct URIs and URLs from individual fields", "label": {"api": {"URI": [[9, 11], [60, 62]], "URL": [[17, 19], [69, 71]]}}}]