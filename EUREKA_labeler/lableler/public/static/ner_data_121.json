[{"text":"You might consider using toAbsolutePath() or toRealPath() on the paths before the check depending on your needs","label":{"api":{"toAbsolutePath()":[[25,40]],"toRealPath()":[[45,56]]}}},{"text":"Here's the the official Java tutorial for Path Operations","label":{"api":{"Path":[[42,45]]}}},{"text":"Either use updateDate() where you presently use rs.updateString(2,podate)","label":{"api":{"updateDate()":[[11,22]],"rs.updateString(2,podate)":[[48,72]]}}},{"text":"Pass a Date object to updateDate()","label":{"api":{"Date":[[7,10]],"updateDate()":[[22,33]]}}},{"text":"Try with Random.nextInt which will give random number between 0 and n-1","label":{"api":{"Random.nextInt":[[9,22]]}}},{"text":"The getInstance method doesn't return your signature class directly, it returns a proxy object which will eventually delegate all calls to your implementation","label":{"api":{"getInstance":[[4,14]],"signature":[[43,51]],"proxy":[[82,86]]}}},{"text":"File constructor does accept URI, so try something like","label":{"api":{"URI":[[29,31]]}}},{"text":"You can use a PushbackReader to add text back into the stream","label":{"api":{"PushbackReader":[[14,27]]}}},{"text":"Here is an example of using a StringReader","label":{"api":{"StringReader":[[30,41]]}}},{"text":"Note that once you have created the cupReader, you use it just like you did before, regardless of the fact that it's based on a StringReader","label":{"api":{"cupReader":[[36,44]],"StringReader":[[128,139]]}}},{"text":"The heart of the problem lies with your usage of the substring method","label":{"api":{"substring":[[53,61]]}}},{"text":"As an example, dissecting your usage, String aSub=a.substring(i,i+1); in the first iteration of the loop i = 0 so this line is then String aSub=a.substring(0,1);  From the javadocs, and my explanation above, this would result in a substring from the first character to the first character or String aSub=\"x\";  Changing this to i+2 and u+2 will get you the desired behavior but beware of index out of bounds errors with the way your loops are currently written","label":{"api":{"substring":[[231,239]]}}},{"text":"You forgot the call to next(), which will advance the cursor to the first row, if present","label":{"api":{"next()":[[23,28]]}}},{"text":"You can use the existing library function sort from Arrays","label":{"api":{"Arrays":[[52,57]]}}},{"text":"Here is the Arrays documentation","label":{"api":{"Arrays":[[12,17]]}}},{"text":"This works, but since Java has a concept of radix, as used in the Integer","label":{"api":{"Integer":[[66,72]]}}},{"text":"This seems to be the explicit purpose as defined in Character","label":{"api":{"Character":[[52,60]]}}},{"text":"Shouldn't there be a better way of doing this rather than to first convert the byte array to a BigInteger","label":{"api":{"BigInteger":[[95,104]]}}},{"text":"It seems like you're looking for Base64 encoding","label":{"api":{}}},{"text":"If you're using Java 8, there's the Base64 class","label":{"api":{"Base64":[[36,41]]}}},{"text":"Otherwise, Apache Commons has a Base64 class too","label":{"api":{"Base64":[[32,37]]}}},{"text":"The signature of IntStream.forEach is forEach(IntConsumer action), where IntConsumer has a void accept(int value) method","label":{"api":{"IntStream.forEach":[[17,33]],"forEach(IntConsumer action)":[[38,64]],"IntConsumer":[[73,83]],"accept(int value)":[[96,112]]}}},{"text":"The platform you are running on also plays a role when it comes to the implementation of FileLock used by the FileHandler","label":{"api":{"FileLock":[[89,96]],"FileHandler":[[110,120]]}}},{"text":"The FileLock documentation comes with the following warning","label":{"api":{"FileLock":[[4,11]]}}},{"text":"Check the Java API for ImageIcon and you'll see that if you call the constructor with a String, it will try to create an ImageIcon with the file represented by the String path","label":{"api":{"ImageIcon":[[23,31],[121,129]],"String":[[88,93],[164,169]]}}},{"text":"I have an HashMap","label":{"api":{"HashMap":[[10,16]]}}},{"text":"Double implements Comparable<Double>","label":{"api":{"Double":[[0,5]],"Comparable<Double>":[[18,35]]}}},{"text":"Given your restrictions the only command line argument of use is java.util.logging.manager system property","label":{"api":{"java.util.logging.manager":[[65,89]]}}},{"text":"Use the JTextArea append(String str) method","label":{"api":{"JTextArea append(String str)":[[8,35]]}}},{"text":"in the case of linked-list, you can optimize it to run in-place and modify one of the lists instead of creating a new list, if needed, using the ListIterator interface and the add() method","label":{"api":{"linked-list":[[15,25]],"ListIterator":[[145,156]],"add()":[[176,180]]}}},{"text":"You could make use of StringBuilder like so","label":{"api":{"StringBuilder":[[22,34]]}}},{"text":"However, concatenating long strings is usually considered bad practice, which is where the StringBuilder comes in","label":{"api":{"StringBuilder":[[91,103]]}}},{"text":"I try to bind the items of a SWT List to a List< String> property via Databinding","label":{"api":{"List":[[33,36]],"List< String>":[[43,55]],"Databinding":[[70,80]]}}},{"text":"It doesn´t work either but at least I could see that if I use tagList.add(x) or tagList.setItems(x) on the tagList Widget nothing is triggered (the convert method isn´t even called)","label":{"api":{"tagList.add(x)":[[62,75]],"tagList.setItems(x)":[[80,98]],"tagList Widget":[[107,120]],"convert":[[148,154]]}}},{"text":"How do I bind the SWT List to the List Property in my model","label":{"api":{"List":[[22,25],[34,37]]}}},{"text":"It's possible that what you're looking for is @Qualifier","label":{"api":{"@Qualifier":[[46,55]]}}},{"text":"However, the upper limit is excluded, so you always end up with one by doing diceRoller.nextInt(1) + 1","label":{"api":{"diceRoller.nextInt(1)":[[77,97]]}}},{"text":"Timers are not recommended for new code, you should take a look at ScheduledExecutorServices","label":{"api":{"ScheduledExecutorServices":[[67,91]]}}},{"text":"I'd use Arrays.sort(T[] a, Comparator c), supplying your own Comparator that puts -1 at the end of the output","label":{"api":{"Arrays.sort(T[] a, Comparator c)":[[8,39]],"Comparator":[[61,70]]}}},{"text":"If the JDBC timeout settings aren't working you could always just wrap the DB check in a Future and limit how long it can run","label":{"api":{"Future":[[89,94]]}}},{"text":"Due to http://docs.oracle.com/javase/8/docs/api/index.html?overview-summary.html it shouldn't matter whether the stream is executed sequentially or parallel","label":{"api":{}}},{"text":"When you specify exponential format in the constructor that takes a String, the scale may be negative","label":{"api":{"String":[[68,73]]}}},{"text":"Using the constructor that takes an int yields a scale of 0","label":{"api":{"int":[[36,38]]}}},{"text":"When you divide BigDecimals, the quotient takes the scale of the object on which divide is called","label":{"api":{"BigDecimals":[[16,26]]}}},{"text":"When you subtract BigDecimals, the difference takes the maximum of the scales of the numbers being subtracted","label":{"api":{"BigDecimals":[[18,28]]}}},{"text":"As an aside, you can use divide(BigDecimal, RoundingMode) to divide specifying a RoundingMode enum instead of the older int constants","label":{"api":{"divide(BigDecimal, RoundingMode)":[[25,56]],"RoundingMode":[[81,92]]}}},{"text":"Try a SortedSet like TreeSet if you want to use a Comparator or implement Comparable<T> on your data models to keep them in some specified order","label":{"api":{"SortedSet":[[6,14]],"TreeSet":[[21,27]],"Comparator":[[50,59]],"Comparable<T>":[[74,86]]}}},{"text":"Otherwise, try a LinkedHashSet, which will keep your objects in the order they were inserted","label":{"api":{"LinkedHashSet":[[17,29]]}}},{"text":"class objects (like A.class) are of the type Class, which is used in Java to represent the class and its capabilities from one level up","label":{"api":{"class":[[0,4]],"A.class":[[20,26]],"Class":[[45,49]]}}},{"text":"See the documentation here","label":{"api":{}}},{"text":"And more generally, I can't figure out why both methods exist, because Oracle's doc says, An invocation of this method of the form out.append(c) behaves in exactly the same way as the invocation out.write(c)","label":{"api":{"out.append(c)":[[131,143]],"out.write(c)":[[195,206]]}}},{"text":"Because its authors decided to make Writer implement the interface Appendable","label":{"api":{"Writer":[[36,41]],"Appendable":[[67,76]]}}},{"text":"Create a BigInteger from the String and call toByteArray","label":{"api":{"BigInteger":[[9,18]],"String":[[29,34]],"toByteArray":[[45,55]]}}},{"text":"However, in Java 8 the Map interface now has putIfAbsent(), so this casting would not be necessary if you can upgrade your JDK","label":{"api":{"Map":[[23,25]],"putIfAbsent()":[[45,57]]}}},{"text":"There is no support defined for injection into javax.xml.bind.annotation.adapters.XmlAdapter objects","label":{"api":{"javax.xml.bind.annotation.adapters.XmlAdapter":[[47,91]]}}},{"text":"FileSystem.getPathMatcher(String) supports glob syntax","label":{"api":{"FileSystem.getPathMatcher(String)":[[0,32]]}}},{"text":"Now you are trying to access 1st index from string (indirectly char array) using charAt method like","label":{"api":{"string":[[44,49]],"charAt":[[81,86]]}}},{"text":"Try using an ArrayList or LinkedList","label":{"api":{"ArrayList":[[13,21]],"LinkedList":[[26,35]]}}},{"text":"If you want to store them in reverse order, use this add method which allows you to add an element at every position of the list, so you can do","label":{"api":{"add":[[53,55]]}}},{"text":"It looks like you're just looking for Stream.flatMap, e.g","label":{"api":{"Stream.flatMap":[[38,51]]}}},{"text":"Dropping another alternative here that is available since Java 9","label":{"api":{}}},{"text":"java.security.SecureRandom seems to provide the range 0..2^n","label":{"api":{"java.security.SecureRandom":[[0,25]]}}},{"text":"Also you're not shutting down your ExecutorService","label":{"api":{"ExecutorService":[[35,49]]}}},{"text":"Add a call to shutdown() after your task submission loop","label":{"api":{"shutdown()":[[14,23]]}}},{"text":"You can add JPA's @Transient","label":{"api":{"@Transient":[[18,27]]}}},{"text":"One option is adding @Transient annotation if on the other hand you use transient keyword that means the field won't be serialized","label":{"api":{"@Transient":[[21,30]]}}},{"text":"More on Why does JPA have a @Transient annotation","label":{"api":{"@Transient":[[28,37]]}}},{"text":"Those methods return FileTime values","label":{"api":{"FileTime":[[21,28]]}}},{"text":"FileTime has a toMillis method which returns its value in milliseconds as a long","label":{"api":{"FileTime":[[0,7]],"toMillis":[[15,22]]}}},{"text":"You can/should use DecimalFormat for that","label":{"api":{"DecimalFormat":[[19,31]]}}},{"text":"But I cannot manage to retrieve the returned type of a Method","label":{"api":{"Method":[[55,60]]}}},{"text":"At its heart, it relies on a CyclicBarrier to coordinate between the worker and the timer","label":{"api":{"CyclicBarrier":[[29,41]]}}},{"text":"You could also schedule messages to the synthesizer using a ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[60,83]]}}},{"text":"Java IO has File.deleteOnExit(), which is a method that deletes the file it is called on during normal termination of the JVM","label":{"api":{"File.deleteOnExit()":[[12,30]]}}},{"text":"However, I don't see a method by the same name in Java NIO's Files class","label":{"api":{"Files":[[61,65]]}}},{"text":"I would not suggest shoe-horning StandardOpenOption.DELETE_ON_CLOSE into a replacement for File.deleteOnExit()","label":{"api":{"StandardOpenOption.DELETE_ON_CLOSE":[[33,66]],"File.deleteOnExit()":[[91,109]]}}},{"text":"The documentation for Files.createTempFile() is similarly clear on this point, DELETE_ON_CLOSE can be used for \"work files\" only needed while the file is open","label":{"api":{"Files.createTempFile()":[[22,43]],"DELETE_ON_CLOSE":[[79,93]]}}},{"text":"The Files.createTempFile() docs suggest directly either writing your own shutdown hook or simply continuing to use File.deleteOnExit()","label":{"api":{"Files.createTempFile()":[[4,25]],"File.deleteOnExit()":[[115,133]]}}},{"text":"One way to handle this is to use Files.probeContentType(Path) (JDK 7) to try to get the content type","label":{"api":{"Files.probeContentType(Path)":[[33,60]]}}},{"text":"Keep in mind, though, that probeContentType is entirely dependent on the installed FileTypeDetectors, if any, for its behavior","label":{"api":{"probeContentType":[[27,42]],"FileTypeDetector":[[83,98]]}}},{"text":"The usual practice in this case is to use a PreparedStatement rather than building a statement dynamically from scratch","label":{"api":{"PreparedStatement":[[44,60]]}}},{"text":"In a PreparedStatement, you put question marks where the values should go, and then you use various setXXX methods to fill them up with values","label":{"api":{"PreparedStatement":[[5,21]]}}},{"text":"But again, I would recommend trusting the authors of your JDBC driver for this and using a PreparedStatement","label":{"api":{"PreparedStatement":[[91,107]]}}},{"text":"What you're looking for is the replace method","label":{"api":{"replace":[[31,37]]}}},{"text":"Which replaces all instances of the first string with the second string","label":{"api":{}}},{"text":"The replaceAll method, on the other hand, uses regular expressions, and \"*\" by itself is not a regular expression since the asterisk character is a modifier that means \"the previous thing, repeated zero or more times\"","label":{"api":{"replaceAll":[[4,13]]}}},{"text":"Read about Interface Map<K,V>,Check this out Java MAP Documentation","label":{"api":{"Map<K,V>":[[21,28]],"MAP":[[50,52]]}}},{"text":"Also don't forget about ReadWriteLock, another useful tool depending on your access patterns and performance requirements","label":{"api":{"ReadWriteLock":[[24,36]]}}},{"text":"I found Class FileChannel  and now i'm developing this code","label":{"api":{"FileChannel":[[14,24]]}}},{"text":"MouseListener is an interface - it doesn't have any method implementations, so if you're going to use that as the basis of your anonymous inner class, you need to provide implementations for everything","label":{"api":{"MouseListener":[[0,12]]}}},{"text":"If you just want to provide implementations for some of the methods, you should extend MouseAdapter instead - that provides no-op implementations, so you can just override the ones you want","label":{"api":{"MouseAdapter":[[87,98]]}}},{"text":"I'm really surprised this is not in the documentation or at least google","label":{"api":{}}},{"text":"You can use replace() in StringBuilder","label":{"api":{"replace()":[[12,20]],"StringBuilder":[[25,37]]}}},{"text":"Check out the method SimpleDateFormat#setDateFormatSymbols()","label":{"api":{"SimpleDateFormat#setDateFormatSymbols()":[[21,59]]}}},{"text":"For even wider localization support you should check out the extensive documentation on the Locale class","label":{"api":{"Locale":[[92,97]]}}},{"text":"Try using String's split method like","label":{"api":{"String":[[10,15]],"split":[[19,23]]}}},{"text":"Try out isNan method of Double wrapper class like","label":{"api":{"isNan":[[8,12]],"Double":[[24,29]]}}},{"text":"Assuming there is a result List R, and an expected List E","label":{"api":{"List":[[27,30],[51,54]]}}},{"text":"Try containsAll method of List like","label":{"api":{"containsAll":[[4,14]]}}},{"text":"You can use java.util.Calendar class","label":{"api":{"java.util.Calendar":[[12,29]]}}},{"text":"In the JavaDoc for Socket.getOutputStream, it says","label":{"api":{"Socket.getOutputStream":[[19,40]]}}},{"text":"Your second solution could be improved to use a BlockingQueue","label":{"api":{"BlockingQueue":[[48,60]]}}},{"text":"Do not import java.awt.List but java.util.List","label":{"api":{"java.awt.List":[[14,26]],"java.util.List":[[32,45]]}}},{"text":"The specs say in short","label":{"api":{}}},{"text":"Use String#charAt(int index) to get the character at the desired index after retrieving the string element, e.g.","label":{"api":{"String#charAt(int index)":[[4,27]]}}},{"text":"If you want to (and if you really have to), you can concatenate all elements using a StringBuilder so that the result is AAABBBCCC, and use StringBuilder#charAt(int index)","label":{"api":{"StringBuilder":[[85,97]],"StringBuilder#charAt(int index)":[[140,170]]}}},{"text":"You can use Iterator#remove() if you iterate over the map's entrySet() or values()","label":{"api":{"Iterator#remove()":[[12,28]],"entrySet()":[[60,69]],"values()":[[74,81]]}}},{"text":"Furthermore, the code that uses Iterator#remove() will use less memory, because it doesn't have to make a copy of the map","label":{"api":{"Iterator#remove()":[[32,48]]}}},{"text":"Quoting to the javadoc of getMethod from Class found here","label":{"api":{"getMethod":[[26,34]],"Class":[[41,45]]}}},{"text":"Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object","label":{"api":{"Method":[[10,15]],"Class":[[119,123]]}}},{"text":"The parameterTypes parameter is an array of Class objects that identify the method's formal parameter types, in declared order","label":{"api":{"Class":[[44,48]]}}},{"text":"\"an array of Class objects\"","label":{"api":{"Class":[[13,17]]}}},{"text":"Then you can use the Class.forName(String) to get the actual Class object defined from each parameter type String","label":{"api":{"Class.forName(String)":[[21,41]],"Class":[[61,65]],"String":[[107,112]]}}},{"text":"before executing a heavy computation, \"internalize\" your Strings (intern()) and use only == for comparisons","label":{"api":{"String":[[57,62]],"intern()":[[66,73]]}}},{"text":"You should use anchor property to receive position of caret instead of using text length value","label":{"api":{"anchor":[[15,20]]}}},{"text":"\".\" is a special character in regex and String's split method accepts regex, which you need to escape like","label":{"api":{"String":[[40,45]],"split":[[49,53]]}}},{"text":"One alternate way to construct that regex is to use Pattern#quote","label":{"api":{"Pattern#quote":[[52,64]]}}},{"text":"Getting a Calendar instant from ZonedDateTime is pretty straight-forward, provided you know that there exists a GregorianCalendar#from(ZonedDateTime) method","label":{"api":{"Calendar":[[10,17]],"ZonedDateTime":[[32,44]],"GregorianCalendar#from(ZonedDateTime)":[[112,148]]}}},{"text":"(2) You should probably use the new Java 8 time API (if you are able to use Java 8)","label":{"api":{"time":[[43,46]]}}},{"text":"This option is never going to be \"stable\" nor recommended for production, since its behavior obviously violates the ClassLoader API specification","label":{"api":{"ClassLoader":[[116,126]]}}},{"text":"Try to disable fixed cell size for your table","label":{"api":{"table":[[40,44]]}}},{"text":"Java provides Collections.binarySearch()","label":{"api":{"Collections.binarySearch()":[[14,39]]}}},{"text":"Try using matches method of String with regex like","label":{"api":{"matches":[[10,16]],"String":[[28,33]]}}},{"text":"In the first example, the termination of the thread calls notifyAll() on it, which causes the wait() to complete","label":{"api":{"notifyAll()":[[58,68]],"wait()":[[94,99]]}}},{"text":"Look at the documentation for ArrayIndexOutOfBoundsException","label":{"api":{"ArrayIndexOutOfBoundsException":[[30,59]]}}},{"text":"For future reference, please notice that the exception tells you what line it occurs at (26), and has a name ArrayIndexOutOfBoundsException which at face value describes the error, but can be used with Javadoc to get even more information about that error","label":{"api":{"ArrayIndexOutOfBoundsException":[[109,138]]}}},{"text":"On the other hand, by natural order they mean that the elements of your structure must implement Comparable, and given the O(1) requeriments, the internal array holding the data should be already ordered according this natural order","label":{"api":{"Comparable":[[97,106]]}}},{"text":"Otherwise a ConcurrentModificationException is thrown","label":{"api":{"ConcurrentModificationException":[[12,42]]}}},{"text":"If you want to access packaged files, you can use getResourceAsStream(String)","label":{"api":{"getResourceAsStream(String)":[[50,76]]}}},{"text":"If filePathInputField contains a path to a file in your filesystem, that call will return null","label":{"api":{"filePathInputField":[[3,20]]}}},{"text":"You can access it using an instance of File or Path","label":{"api":{"File":[[39,42]],"Path":[[47,50]]}}},{"text":"But somehow, if you're working with some legacy code, you can use Class#isAssignableFrom() method across each list element","label":{"api":{"Class#isAssignableFrom()":[[66,89]]}}},{"text":"SAXParser is a push parser","label":{"api":{"SAXParser":[[0,8]]}}},{"text":"For example ThreadPoolExecutor With that you can just throw lots of work at it (Runnables) and it will queue work up, and execution can be scaled to suit the hardware it's running on by customizing the number of worker threads","label":{"api":{"ThreadPoolExecutor":[[12,29]],"Runnable":[[80,87]]}}},{"text":"Or if you're using Swing, then SwingWorker","label":{"api":{"Swing":[[19,23]],"SwingWorker":[[31,41]]}}},{"text":"<project>/src/Resources/character.png), load it as resource","label":{"api":{"resource":[[51,58]]}}},{"text":"I'm running unto a problem with the ResultSet.next() method in Java","label":{"api":{"ResultSet.next()":[[36,51]]}}},{"text":"As per Holgers suggestions (see comments for question) I switched to the API method getTables() instead","label":{"api":{"getTables()":[[84,94]]}}},{"text":"Once you have a Map, you can call Map.values() to get a Collection of the map's values (which you can then put into a List if you need)","label":{"api":{"Map":[[16,18]],"Map.values()":[[34,45]]}}},{"text":"In Java, like many other programming languages, an error is thrown when an integer is divided by zero","label":{"api":{}}},{"text":"Try using Calendar's get method like","label":{"api":{"Calendar":[[10,17]],"get":[[21,23]]}}},{"text":"gets executed inside of the spawnPlayer(Player) method, which therefor causes the method to run infinitely, causing the StackOverflowError","label":{"api":{"spawnPlayer(Player)":[[28,46]],"StackOverflowError":[[120,137]]}}},{"text":"Another fix would to make it so s.hasPlayer() is not always true, for example, by using an ArrayList to make sure the player wasn't already spawned","label":{"api":{"s.hasPlayer()":[[32,44]],"ArrayList":[[91,99]]}}},{"text":"The documentation is a little confusing, but by looking at the source code for method _convertPublicKey($n, $e) starting at line 950 it appears that if $publicKeyFormat == PUBLIC_FORMAT_PKCS8 then the output format should be one that is compatible with Java's X509EncodedKeySpec class","label":{"api":{"_convertPublicKey($n, $e)":[[86,110]],"X509EncodedKeySpec":[[260,277]]}}},{"text":"This means that your mysql jdbc driver does not implement the jdbc methods added in jre 6, such as isValid","label":{"api":{"isValid":[[99,105]]}}},{"text":"From the Java 7 API (http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) the method you want is getMessage()","label":{"api":{"getMessage()":[[111,122]]}}},{"text":"Path class has resolve() method to join two paths together","label":{"api":{"resolve()":[[15,23]]}}},{"text":"This implements the Collection interface and will internally maintain the elements natural order (in this case Integers) when adding new values","label":{"api":{"Collection":[[20,29]]}}},{"text":"optObj refers to your Optional instance","label":{"api":{"optObj":[[0,5]],"Optional":[[22,29]]}}},{"text":"Optional does not contain a getMessage method","label":{"api":{"Optional":[[0,7]],"getMessage":[[28,37]]}}},{"text":"If you use a TreeSet instead of a LinkedHashSet, you could use the method tailSet()","label":{"api":{"TreeSet":[[13,19]],"LinkedHashSet":[[34,46]],"tailSet()":[[74,82]]}}},{"text":"The Arrays.sort mergesort is stable","label":{"api":{"Arrays.sort":[[4,14]]}}},{"text":"Using Java Attach API I have been able to load my java agent (e.g","label":{"api":{"Attach":[[11,16]]}}},{"text":"I've read about Semaphore class there and now what I'd like to understand is how can I use that class in a real code","label":{"api":{"Semaphore":[[16,24]]}}},{"text":"See documentation on ConcurrentModificationException","label":{"api":{"ConcurrentModificationException":[[21,51]]}}},{"text":"When reading the API for DirectoryStream I miss a lot of functions","label":{"api":{"DirectoryStream":[[25,39]]}}},{"text":"And I miss the fact that it a DirectoryStream is not a Stream","label":{"api":{"DirectoryStream":[[30,44]],"Stream":[[55,60]]}}},{"text":"How can I make a Stream<Path> from a DirectoryStream in Java 8","label":{"api":{"Stream<Path>":[[17,28]],"DirectoryStream":[[37,51]]}}},{"text":"Assuming you want the supported cipher suites you could use SSLSocketFactory.getSupportedCipherSuites()","label":{"api":{"SSLSocketFactory.getSupportedCipherSuites()":[[60,102]]}}},{"text":"BTW StringBuffer is supplemented by StringBuilder","label":{"api":{"StringBuffer":[[4,15]],"StringBuilder":[[36,48]]}}},{"text":"This class is designed for use as a drop-in replacement for StringBuffer in places where the string buffer was being used by a single thread (as is generally the case)","label":{"api":{"StringBuffer":[[60,71]]}}},{"text":"Where possible, it is recommended that this class be used in preference to StringBuffer as it will be faster under most implementations","label":{"api":{"StringBuffer":[[75,86]]}}},{"text":"If you're using Java 7 or higher, Files.newBufferedWriter is your friend - and with Java 8, there's an overload without a Charset parameter, in which case UTF-8 is used automatically","label":{"api":{"Files.newBufferedWriter":[[34,56]],"Charset":[[122,128]]}}},{"text":"In Java, both of these are available from a Charset","label":{"api":{"Charset":[[44,50]]}}},{"text":"String.getBytes() just happens to use an encoder with the default platform character coding (obtained using Charset.defaultCharset()), and it happens that for your input string \"ABC\" and your JRE implementation, the sequence of bytes generated is 65, 66, 67","label":{"api":{"String.getBytes()":[[0,16]],"Charset.defaultCharset()":[[108,131]]}}},{"text":"Now, try and String.getBytes(Charset.forName(\"UTF-32LE\")), and you'll get a different result","label":{"api":{"String.getBytes(Charset.forName(\"UTF-32LE\"))":[[13,56]]}}},{"text":"You are asking Java to encode the string in the platform's default-charset, and that's not the internal charset","label":{"api":{}}},{"text":"Use the pathIterator to traverse the shape and obtain the line segments that makes your shapes and its vertex","label":{"api":{"pathIterator":[[8,19]]}}},{"text":"like fge mentioned forEach returns void","label":{"api":{"forEach":[[19,25]]}}},{"text":"To achive what you are looking for use map","label":{"api":{"map":[[39,41]]}}},{"text":"Why doesn't the Java 8 library take care of closing streams itself after each terminal operation (without having to wrap the stream instantiation in a try-with-resources)","label":{"api":{}}},{"text":"You can also disable Nagle's algorithm by setting TCP_NODELAY in the java socket options","label":{"api":{"TCP_NODELAY":[[50,60]],"socket options":[[74,87]]}}},{"text":"You should check out the intersects() method provided by the Java2D API","label":{"api":{"intersects()":[[25,36]],"Java2D":[[61,66]]}}},{"text":"The method to invoke is equals(Object)","label":{"api":{"equals(Object)":[[24,37]]}}},{"text":"Each time you call .submit(Runnable) or .submit(Callable) you get a Future object back that represents the eventual completion of the task","label":{"api":{".submit(Runnable)":[[19,35]],".submit(Callable)":[[40,56]],"Future":[[68,73]]}}},{"text":"The Future object has a .get() method that will return the result of the task when it is complete","label":{"api":{"Future":[[4,9]],".get()":[[24,29]]}}},{"text":"Also, if the task throws an exception that is not otherwise handled by your task code, the call to .get() will throw an ExecutionException which will wrap the actual thrown exception","label":{"api":{".get()":[[99,104]],"ExecutionException":[[120,137]]}}},{"text":"If your code is exiting prematurely due to an unhandled exception, call .get() on each Future object you get when you submit the task for execution (after you have submitted all the tasks you wish to) and catch any ExecutionExceptions that happen to be thrown to figure out what the actual underlying problem is","label":{"api":{".get()":[[72,77]],"Future":[[87,92]],"ExecutionException":[[215,232]]}}},{"text":"Well, precisely because it has an ellipsis)","label":{"api":{}}},{"text":"If you want to preserve the order in which the values were entered, use a LinkedHashSet, otherwise use just a HashSet","label":{"api":{"LinkedHashSet":[[74,86]],"HashSet":[[110,116]]}}},{"text":"see Java String Formatter Doc for details","label":{"api":{"String Formatter":[[9,24]]}}},{"text":"Being called by a thread means you have a reference to that thread via Thread.currentThread()","label":{"api":{"Thread.currentThread()":[[71,92]]}}},{"text":"Unfortunately the File.delete() method provides very little information as to why; it's pretty much up to you to poke around and figure it out","label":{"api":{"File.delete()":[[18,30]]}}},{"text":"Java 7 introduced the new java.nio.file package which is a much more robust file access API","label":{"api":{"java.nio.file":[[26,38]],"robust file access":[[69,86]]}}},{"text":"It provides the concept of an abstract Path and separates concrete operations into the Files class, in particular it provides Files.delete() which is documented to raise clear exceptions describing the reasons deletion might fail","label":{"api":{"Path":[[39,42]],"Files":[[87,91]],"Files.delete()":[[126,139]]}}},{"text":"Use Path and Files; you'll be glad you did","label":{"api":{"Path":[[4,7]],"Files":[[13,17]]}}},{"text":"You can use a Proxy but as the comments suggest - this is almost always not the best option","label":{"api":{"Proxy":[[14,18]]}}},{"text":"The API documentation states","label":{"api":{}}},{"text":"ConcurrentHashMap is fail safe meaning you will not encounter ConcurrentModificationException","label":{"api":{"ConcurrentHashMap":[[0,16]],"ConcurrentModificationException":[[62,92]]}}},{"text":"I would suggest, you don't try locking on whole map operation, but instead look out for making thread safe access to list may be using Vector or SynchronizedList","label":{"api":{"Vector":[[135,140]],"SynchronizedList":[[145,160]]}}},{"text":"Answers from @predrag-maric and @pL4Gu33 are both correct but if you use JPA in your project (for example, Hibernate) you might consider using  @NamedNativeQuery annotation as well","label":{"api":{"@NamedNativeQuery":[[144,160]]}}},{"text":"Use Stage.initModality to make one of your Stages modal (blocking)","label":{"api":{"Stage.initModality":[[4,21]],"Stages":[[43,48]]}}},{"text":"Take a look at java.util.concurrent package, specifically the CountDownLatch","label":{"api":{"java.util.concurrent":[[15,34]],"CountDownLatch":[[62,75]]}}},{"text":"You can get the screen coordinates of a Swing/AWT Component using","label":{"api":{"Component":[[50,58]]}}},{"text":"The contract of the MimeMessage.getAllHeaders() method is clear","label":{"api":{"MimeMessage.getAllHeaders()":[[20,46]]}}},{"text":"That documentation is referring to the javax.mail.Header class","label":{"api":{"javax.mail.Header":[[39,55]]}}},{"text":"So when you call MimeMessage.getAllHeaders(), it is only safe to assume that the Enumeration will return instances of javax.mail.Header","label":{"api":{"MimeMessage.getAllHeaders()":[[17,43]],"Enumeration":[[81,91]],"javax.mail.Header":[[118,134]]}}},{"text":"the correct way to loop through an Enumeration is with its hasMoreElements() method","label":{"api":{"Enumeration":[[35,45]],"hasMoreElements()":[[59,75]]}}},{"text":"or the implementation of compareTo (where T is defined as Long)","label":{"api":{"compareTo":[[25,33]]}}},{"text":"You could provide a readObject method as described in the Serializable documentation","label":{"api":{"readObject":[[20,29]],"Serializable":[[58,69]]}}},{"text":"Really, though, you can instead of Person use an associative array, for example mapping enum types for properties to strings","label":{"api":{"Person":[[35,40]]}}},{"text":"The ConcurrentHashMap.computeIfAbsent() Javadoc reads","label":{"api":{"ConcurrentHashMap.computeIfAbsent()":[[4,38]]}}},{"text":"The HashMap.computeIfAbsent() or Map.computeIfAbsent() Javadoc don't forbid such recursive computation, which is of course ridiculous as the type of the cache is Map<Integer, Integer>, not ConcurrentHashMap<Integer, Integer>","label":{"api":{"HashMap.computeIfAbsent()":[[4,28]],"Map.computeIfAbsent()":[[33,53]],"Map<Integer, Integer>":[[162,182]],"ConcurrentHashMap<Integer, Integer>":[[189,223]]}}},{"text":"Its replacement is ProcessBuilder","label":{"api":{"ProcessBuilder":[[19,32]]}}},{"text":"Looking at the statement c1= new Clock();, the only thing one can say is that a new instance of class Clock is created, using its no-arguments constructor, and the reference to the created instance is assigned to a variable named c1, which must have been declared previously (the variable may or may not have already been initialized)","label":{"api":{"Clock":[[102,106]]}}},{"text":"There's also class Clock in Java since 1.8","label":{"api":{"Clock":[[19,23]]}}},{"text":"Instead of using an ArrayList, a Queue might be better suited for managing the customers","label":{"api":{"ArrayList":[[20,28]],"Queue":[[33,37]]}}},{"text":"There's a method, though, Arrays.equals(), that can compare them","label":{"api":{"Arrays.equals()":[[26,40]]}}},{"text":"This is available since Java 1.4 according to the API","label":{"api":{}}},{"text":"Thus what you could do is follow the same pattern as the Number interface and create individual methods for each numeric type","label":{"api":{"Number":[[57,62]]}}},{"text":"See [http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html] for more details","label":{"api":{}}},{"text":"You can't make StringTokenizer work the way you want it to (it never returns blanks), but you can use String#split() instead","label":{"api":{"StringTokenizer":[[15,29]],"String#split()":[[102,115]]}}},{"text":"Read more about Java SimleDateFormat","label":{"api":{"SimleDateFormat":[[21,35]]}}},{"text":"Use a shared LinkedBlockingQueue<Integer> (among the readers and all writers) to let every writer signal the reader that the commitIndex variable has been modified","label":{"api":{"LinkedBlockingQueue<Integer>":[[13,40]]}}},{"text":"Referring to NoSuchMethodError Oracle Documentation","label":{"api":{"NoSuchMethodError":[[13,29]]}}},{"text":"My advice when building filenames is to use the File class or Path that will automatically make sure to get path separators right","label":{"api":{"File":[[48,51]],"Path":[[62,65]]}}},{"text":"Use Java's Random class instead of defining your own private static class","label":{"api":{"Random":[[11,16]]}}},{"text":"According to https://docs.oracle.com/javase/7/docs/api/java/nio/file/SimpleFileVisitor.html the default behavior of the visitFileFailed method is to re-throw the exception","label":{"api":{"visitFileFailed":[[120,134]]}}},{"text":"Or, also as noted from comments, you can use newly added String.join(CharSequence, Iterable) method","label":{"api":{"String.join(CharSequence, Iterable)":[[57,91]]}}},{"text":"You can simply do it by implementing Serializable","label":{"api":{"Serializable":[[37,48]]}}},{"text":"In the case of unix and java, this is midnight Jan 1, 1970 UTC","label":{"api":{}}},{"text":"You can save them to properties or fields","label":{"api":{}}},{"text":"Here's the documentation about properties","label":{"api":{"properties":[[31,40]]}}},{"text":"java.math.BigInteger has a modInverse method that can be used","label":{"api":{"java.math.BigInteger":[[0,19]],"modInverse":[[27,36]]}}},{"text":"If you are using Java 8, you can use the new merge method of Map","label":{"api":{"merge":[[45,49]],"Map":[[61,63]]}}},{"text":"One way to create a Stream source is to implement your own Spliterator and pass it to StreamSupport.stream","label":{"api":{"Stream":[[20,25]],"Spliterator":[[59,69]],"StreamSupport.stream":[[86,105]]}}},{"text":"As a variation of the theme presented by alfasin, you can specialise the Stream as a DoubleStream and utilise the sum method on it","label":{"api":{"Stream":[[73,78]],"DoubleStream":[[85,96]],"sum":[[114,116]]}}},{"text":"I found Random.nextGaussian() and was just wondering if there's any other built in support for distributions other than normal","label":{"api":{"Random.nextGaussian()":[[8,28]]}}},{"text":"You are looking for BigInteger","label":{"api":{"BigInteger":[[20,29]]}}},{"text":"Compare DateTimeZone.getAvailableIDs() to ZoneId.getAvailableZoneIds() to determine the mismatch","label":{"api":{"DateTimeZone.getAvailableIDs()":[[8,37]],"ZoneId.getAvailableZoneIds()":[[42,69]]}}},{"text":"Additional identifiers can be mapped using ZoneId.of(String, Map)","label":{"api":{"ZoneId.of(String, Map)":[[43,64]]}}},{"text":"Use Collections#shuffle() to shuffle your array","label":{"api":{"Collections#shuffle()":[[4,24]]}}},{"text":"Here is where Character comes in hand, since we need to convert the array in a List with Arrays#asList()","label":{"api":{"Character":[[14,22]],"List":[[79,82]],"Arrays#asList()":[[89,103]]}}},{"text":"Especially the Files utility class can help you to create IO Streams","label":{"api":{"Files":[[15,19]],"IO Streams":[[58,67]]}}},{"text":"For modern (shortened!) usage see Path, Paths and especially Files","label":{"api":{"Path":[[34,37]],"Paths":[[40,44]],"Files":[[61,65]]}}},{"text":"You need to use setOpaque(true); on your TreeCellRenderer to change background color","label":{"api":{"setOpaque(true);":[[16,31]],"TreeCellRenderer":[[41,56]]}}},{"text":"It's because push takes an argument of type EventQueue but you've called it with the result of EventQueue.invokeLater(), which is a void method","label":{"api":{"push":[[13,16]],"EventQueue":[[44,53]],"EventQueue.invokeLater()":[[95,118]]}}},{"text":"Here is a tested implementation using this paradigm, plus generating the sublists using List.subList()","label":{"api":{"List.subList()":[[88,101]]}}},{"text":"When the bundle is deactivated, send an interrupt to that thread using Thread.interrupt().Your code would actually work already, but probably don't want to print the stack trace though","label":{"api":{"Thread.interrupt()":[[71,88]]}}},{"text":"You're aren't passing it the string argument it needs","label":{"api":{"string":[[29,34]]}}},{"text":"You need to pass it a string","label":{"api":{"string":[[22,27]]}}},{"text":"You can use a string literal by surrounding text with quotes like this","label":{"api":{}}},{"text":"For example, Java EE has an interface called ServletContextListener that is purely meant to make setup and shut down","label":{"api":{"ServletContextListener":[[45,66]]}}},{"text":"It's even sometimes acceptable to make interfaces with methods you should actually never directly call such as the Runnable or the Callable interface","label":{"api":{"Runnable":[[115,122]],"Callable":[[131,138]]}}},{"text":"From the docs for mark(), the parameter you pass to it is","label":{"api":{"mark()":[[18,23]]}}},{"text":"Use a FileChanneland its position methods instead","label":{"api":{"FileChannel":[[6,16]],"position":[[25,32]]}}},{"text":"Use a RandomAccessFile and its seek methods instead","label":{"api":{"RandomAccessFile":[[6,21]],"seek":[[31,34]]}}},{"text":"The next...() methods of a Scanner allways first scan the next token, and then aim to convert it to the correct type (for instance int in the case of nextInt())","label":{"api":{"next...()":[[4,12]],"Scanner":[[27,33]],"nextInt()":[[150,158]]}}},{"text":"You can use Objects#isNull if you don't want to ignore or fix sonar","label":{"api":{"Objects#isNull":[[12,25]]}}},{"text":"You can use CountDownLatch for that purposes, as example","label":{"api":{"CountDownLatch":[[12,25]]}}},{"text":"Read the documentation for substring carefully to see what each of the parameters means (and why you want i + 1 rather than i)","label":{"api":{"substring":[[27,35]]}}},{"text":"You should read the API carefully","label":{"api":{}}},{"text":"Your RSA key is in the SubjectPublicKeyInfo format, which is what Java returns when you use the RSAPublicKey.getEncoded() method","label":{"api":{"SubjectPublicKeyInfo":[[23,42]],"RSAPublicKey.getEncoded()":[[96,120]]}}},{"text":"Java calls this format an X509EncodeKeySpec for historical reasons","label":{"api":{"X509EncodeKeySpec":[[26,42]]}}},{"text":"No, but it's overridden in AbstractCollection, which ArrayList is an indirect subclass of","label":{"api":{"AbstractCollection":[[27,44]],"ArrayList":[[53,61]]}}},{"text":"In the documentation for ArrayList, it shows that toString() is inherited from AbstractCollection","label":{"api":{"ArrayList":[[25,33]],"toString()":[[50,59]],"AbstractCollection":[[79,96]]}}}]