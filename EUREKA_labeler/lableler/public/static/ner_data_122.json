[{"text":"Please see MappedByteBuffer and FileChannel.map() javadocs","label":{"api":{"MappedByteBuffer":[[11,26]],"FileChannel.map()":[[32,48]]}}},{"text":"I'm not an expert in Java NIO, so I'm not sure if the byte buffer handles chunks automatically or if you have to use multiple MappedByteBuffers","label":{"api":{"NIO":[[26,28]],"MappedByteBuffer":[[126,141]]}}},{"text":"The other issue is the limitation of Java's implementation of memory mapping which is handled via a MappedByteBuffer","label":{"api":{"MappedByteBuffer":[[100,115]]}}},{"text":"Even though the method FileChannel.map() takes longs for offset and size, it returns a MappedByteBuffer which can only use ints for its limit and position","label":{"api":{"FileChannel.map()":[[23,39]],"MappedByteBuffer":[[87,102]]}}},{"text":"Use String.matches to match a regexp","label":{"api":{"String.matches":[[4,17]]}}},{"text":"Shouldn't matter if using Scala's or Java's implementation","label":{"api":{}}},{"text":"For example, the @Deprecated annotation type is annotated with @Documented","label":{"api":{"@Deprecated":[[17,27]],"@Documented":[[63,73]]}}},{"text":"It's pretty important to know if something is deprecated, so @Deprecated is considered part of the public API and should be included in the documentation","label":{"api":{"@Deprecated":[[61,71]]}}},{"text":"On the other hand, @SuppressWarnings is just a hint for the compiler and not important for the API, so it is not annotated by @Documented","label":{"api":{"@SuppressWarnings":[[19,35]],"@Documented":[[126,136]]}}},{"text":"Use the setDefaultCloseOperation(int) command on the JFrame","label":{"api":{"setDefaultCloseOperation(int)":[[8,36]],"JFrame":[[53,58]]}}},{"text":"Your class doesn't override Object's toString() method, which is responsible for the Value@15db9742 output you see","label":{"api":{"Object":[[28,33]],"toString()":[[37,46]]}}},{"text":"You may also want to consult the documentation on ObjectInputStreams","label":{"api":{"ObjectInputStreams":[[50,67]]}}},{"text":"You'd want to use an SSLSocket (via SSLSocketFactory, see also example) instead of a Socket in that case","label":{"api":{"SSLSocket":[[21,29]],"SSLSocketFactory":[[36,51]],"Socket":[[85,90]]}}},{"text":"Note that clientSocket will be an instance of SSLSocket (which is derived from Socket) in this case","label":{"api":{"clientSocket":[[10,21]],"SSLSocket":[[46,54]],"Socket":[[79,84]]}}},{"text":"However, if you're doing this as part of a larger application (as opposed to just a learning experience), consider existing libraries, such as Apache's HttpClient (which supports HTTPS as well) or the built-in HttpURLConnection and HttpsURLConnection if you need something more basic","label":{"api":{"HttpClient":[[152,161]],"HttpURLConnection":[[210,226]],"HttpsURLConnection":[[232,249]]}}},{"text":"If you need to embed a server in an application you can use the built-in HttpServer or HttpsServer","label":{"api":{"HttpServer":[[73,82]],"HttpsServer":[[87,97]]}}},{"text":"Yes you can loop over, java.util.Scanner offer hasNextLine method","label":{"api":{"java.util.Scanner":[[23,39]],"hasNextLine":[[47,57]]}}},{"text":"I would suggest you use CountDownLatch (assuming this is one time activity) where in your constructor, you can specify how many threads you want to wait for and you share that instance accross the threads and you wait on all the threads to complete using await api (using timeout or complete blocking) and your thread's calling countdown api when they are done","label":{"api":{"CountDownLatch":[[24,37]],"await":[[255,259]],"timeout":[[272,278]],"complete blocking":[[283,299]],"countdown":[[328,336]]}}},{"text":"Another option would be, to call join method in thread to wait for their completion if you have access to each and every thread that you wish to complete","label":{"api":{"join":[[33,36]]}}},{"text":"The missing class, EJBHome, is in the libray for the project","label":{"api":{"EJBHome":[[19,25]]}}},{"text":"Your forgot to call start method (example at the top of article about ProcessBuilder class)","label":{"api":{"start":[[20,24]],"ProcessBuilder":[[70,83]]}}},{"text":"Difference of prepareCall and prepareStatement methods described in documentation","label":{"api":{"prepareCall":[[14,24]],"prepareStatement":[[30,45]]}}},{"text":"I've been using ReadWriteLock`s to implement/maintain a locking idioms","label":{"api":{"ReadWriteLock":[[16,28]]}}},{"text":"Since JDK8 StampedLock has been introduced","label":{"api":{"StampedLock":[[11,21]]}}},{"text":"And as RWLocks are known with their slowness and bad performance, StampedLock's look like an alternative (they are not reentrant, so much faster)","label":{"api":{"RWLocks":[[7,13]],"StampedLock":[[66,76]]}}},{"text":"However except the performance, it looks to me that StampedLock's are much harder and complex to maintain and use - e.g","label":{"api":{"StampedLock":[[52,62]]}}},{"text":"What are the benefits of StampedLock over RWLock","label":{"api":{"StampedLock":[[25,35]],"RWLock":[[42,47]]}}},{"text":"I'm guessing you wanted to print the range of 0 to 35, which could be done with Arrays.toString","label":{"api":{"Arrays.toString":[[80,94]]}}},{"text":"A CheckBoxTreeItem provides a selected property","label":{"api":{"CheckBoxTreeItem":[[2,17]],"selected":[[30,37]]}}},{"text":"However, in your application, the CheckBoxTreeItem's selected property is not the property represented by the item, because you set the cell value factory to map to the selected property of the Model instance represented by the item","label":{"api":{"CheckBoxTreeItem":[[34,49]],"selected":[[53,60],[169,176]]}}},{"text":"Just use split method inside loop to get all your data in array","label":{"api":{"split":[[9,13]]}}},{"text":"You have to modify those examples to create directories since the FileHandler will not create directories","label":{"api":{"FileHandler":[[66,76]]}}},{"text":"Integer objects are cached as mentioned by the Javadocs of Integer#valueOf(int)","label":{"api":{"Integer":[[0,6]],"Integer#valueOf(int)":[[59,78]]}}},{"text":"The statement Integer i4 = (args.length + 1) * 6; calls Integer#valueOf(int) which returns the cached instance","label":{"api":{"Integer#valueOf(int)":[[56,75]]}}},{"text":"When you autobox an int, you're internally calling Integer.valueOf(int), which according to the documentation may return cached values","label":{"api":{"Integer.valueOf(int)":[[51,70]]}}},{"text":"And for the record, string interning is available at runtime as well, through the String.intern() method","label":{"api":{"String.intern()":[[82,96]]}}},{"text":"To add leading zeros you can use String.format or System.out.format","label":{"api":{"String.format":[[33,45]],"System.out.format":[[50,66]]}}},{"text":"Also refer to the docs and see PrintStream#println(char[] x)","label":{"api":{"PrintStream#println(char[] x)":[[31,59]]}}},{"text":"You need to extract user from the iterator using Iterator.next()","label":{"api":{"Iterator.next()":[[49,63]]}}},{"text":"System.out isn't a class or a method, it's a static field on the System class that is a reference to an instance of a class (PrintStream)","label":{"api":{"System.out":[[0,9]],"System":[[65,70]],"PrintStream":[[125,135]]}}},{"text":"println is an instance method of PrintStream (or more completely, println is the common name shared by a group of instance methods that are overloaded with different arguments)","label":{"api":{"println":[[0,6],[66,72]],"PrintStream":[[33,43]]}}},{"text":"Java's reflection API uses interfaces that are subinterfaces of Type as a runtime representation of generic types, but these are unsuited for your purpose because they do not provide any compile-time type information","label":{"api":{"reflection":[[7,16]],"Type":[[64,67]]}}},{"text":"You can at runtime retrieve the information that MyClass inherits from List<String> (using the method Class.getGenericSuperclass())","label":{"api":{"MyClass":[[49,55]],"List<String>":[[71,82]],"Class.getGenericSuperclass()":[[102,129]]}}},{"text":"Thus we create a special class (often called TypeToken) from which we can inherit","label":{"api":{"TypeToken":[[45,53]]}}},{"text":"The TypeToken class has a generic parameter, and in the subclass we specify the type we want to pass as this parameter","label":{"api":{"TypeToken":[[4,12]]}}},{"text":"Even better would be to use an existing class as the type token, for example the class TypeToken of the great Guava library (if you do not know this library yet, also look at what else it offers and consider using it!)","label":{"api":{"type token":[[53,62]],"TypeToken":[[87,95]],"Guava":[[110,114]]}}},{"text":"This class also provides additional helper methods that make it easer to use the token in the as method (directly using Type instances can be difficult)","label":{"api":{"Type":[[120,123]]}}},{"text":"The Guava wiki has more information on its TypeToken class","label":{"api":{"Guava":[[4,8]],"TypeToken":[[43,51]]}}},{"text":"If you are worried about creating too many classes, you can of course easily provide a few default instances for common cases like TypeToken<List<String>> etc","label":{"api":{"TypeToken<List<String>>":[[131,153]]}}},{"text":"Guava's TypeToken also has an of(Class<T>) method that can be used for non-generic types, so the subclasses would be restricted to cases where it is actually necesary","label":{"api":{"Guava":[[0,4]],"TypeToken":[[8,16]],"of(Class<T>)":[[30,41]]}}},{"text":"Other projects also use this trick, for example Guice with class TypeLiteral (explanation), Gson (TypeToken), and Jackson (TypeReference)","label":{"api":{"Guice":[[48,52]],"TypeLiteral":[[65,75]],"Gson":[[92,95]],"TypeToken":[[98,106]],"Jackson":[[114,120]],"TypeReference":[[123,135]]}}},{"text":"You can try using ProcessBuilder","label":{"api":{"ProcessBuilder":[[18,31]]}}},{"text":"You are adding to the frame the result of the addActionListener method, which is void","label":{"api":{"addActionListener":[[46,62]],"void":[[81,84]]}}},{"text":"The best way to deal with tables is to create a TableModel class that extends AbstractTableModel","label":{"api":{"TableModel":[[48,57]],"AbstractTableModel":[[78,95]]}}},{"text":"It's probably easiest to extend Spliterators.AbstractSpliterator","label":{"api":{"Spliterators.AbstractSpliterator":[[32,63]]}}},{"text":"See the Spliterator class documentation at the paragraph beginning \"Despite...\" for details","label":{"api":{"Spliterator":[[8,18]]}}},{"text":"A better solution using Calendar class","label":{"api":{"Calendar":[[24,31]]}}},{"text":"new Random() creates a new Random instance, which is very likely different, but not guaranteed to be, from any other instance of Random created","label":{"api":{"Random()":[[4,11]],"Random":[[27,32],[129,134]]}}},{"text":"new Random(long seed) creates a new Random instance, which will initialize the random number generator at that value, thus ensuring that two Random instances with the same seed will generate the same sequence","label":{"api":{"Random(long seed)":[[4,20]],"Random":[[36,41],[141,146]]}}},{"text":"Since Random is just a pseudorandom number generator, it is ill-advised to use it for applications that require a truly random number generator","label":{"api":{"Random":[[6,11]]}}},{"text":"You can use String.subString method as following","label":{"api":{"String.subString":[[12,27]]}}},{"text":"Maybe you could work around this be mapping Jersey to /rest and writing an own Servlet mapped to /* which dispatches to one of the other servlets","label":{"api":{"Servlet":[[79,85]],"dispatches":[[106,115]]}}},{"text":"I fail to see much of a difference between your approach and that of a standard ConcurrentHashMap - asides from the fact that ConcurrentHashMap has been heavily tested, and can be configured for minimal overhead with the exact number of threads you want to run the code with","label":{"api":{"ConcurrentHashMap":[[80,96],[126,142]]}}},{"text":"In a ConcurrentHashMap, you would use the replace(K key, V old, V new) method to atomically update key to new only when the old value has not changed","label":{"api":{"ConcurrentHashMap":[[5,21]],"replace(K key, V old, V new)":[[42,69]]}}},{"text":"The space savings due to removing all those AtomicIntegers and the time savings due to lower synchronization overhead will probably compensate having to wrap the replace(k, old, new) calls within while-loops","label":{"api":{"AtomicIntegers":[[44,57]],"replace(k, old, new)":[[162,181]]}}},{"text":"com.sun.management - Oracle's platform extension to the java.lang.management API and the management interface for some other components of the platform","label":{"api":{"com.sun.management":[[0,17]],"java.lang.management":[[56,75]]}}},{"text":"You'll be much better off either not worrying about this, or using a FileNameExtensionFilter to limit your user's choices, like JoopEggen suggested","label":{"api":{"FileNameExtensionFilter":[[69,91]]}}},{"text":"This might be sufficient for simple tasks, however, you should study the documentation of BreakIterator to understand the difference between this simple approach and a real, sophisticated word boundary splitting","label":{"api":{"BreakIterator":[[90,102]]}}},{"text":"Here is a Java 8 Solution using Stream's filter,sorted, and map methods","label":{"api":{"Stream":[[32,37]],"filter":[[41,46]],"sorted":[[48,53]],"map":[[60,62]]}}},{"text":"I think you'd be OK with a ConcurrentHashMap","label":{"api":{"ConcurrentHashMap":[[27,43]]}}},{"text":"ConcurrentHashMap is a highly optimized Map which avoids thread contention as much as possible, especially for reads (I believe this matches your case)","label":{"api":{"ConcurrentHashMap":[[0,16]],"Map":[[40,42]]}}},{"text":"I'd go first with the ConcurrentHashMap and test it, and would only change the implementation if behavior differs from expected results","label":{"api":{"ConcurrentHashMap":[[22,38]]}}},{"text":"As per your edit, I must insist on recommending you use a ConcurrentHashMap","label":{"api":{"ConcurrentHashMap":[[58,74]]}}},{"text":"I have an AudioFormat object (returned from audioInputStream.getFormat())","label":{"api":{"AudioFormat":[[10,20]],"audioInputStream.getFormat()":[[44,71]]}}},{"text":"All You need is a JDialog which is here for short user interactions","label":{"api":{"JDialog":[[18,24]]}}},{"text":"The easier way out is JOptionPane which one overload lets you show a component","label":{"api":{"JOptionPane":[[22,32]]}}},{"text":"As an aside, consider using a Map, http://docs.oracle.com/javase/7/docs/api/java/util/Map.html, to store the candidates instead of an ArrayList","label":{"api":{"Map":[[30,32]],"ArrayList":[[134,142]]}}},{"text":"You can read it by either using the FileInputStream to read the four bytes yourself and use them to construct your int, or use a higher level utility, such as Scanner","label":{"api":{"FileInputStream":[[36,50]],"Scanner":[[159,165]]}}},{"text":"The Scanner#next() method return type is String","label":{"api":{"Scanner#next()":[[4,17]],"String":[[41,46]]}}},{"text":"For example, you could use a VBox","label":{"api":{"VBox":[[29,32]]}}},{"text":"Use SimpleDateFormat as a date parser, not a regex","label":{"api":{"SimpleDateFormat":[[4,19]]}}},{"text":"You are confused about the meaning of capacity","label":{"api":{"capacity":[[38,45]]}}},{"text":"The ExecutorService seems to provide methods which execute tasks until they are either completed or else a timeout occurs (such as the invokeAll)","label":{"api":{"ExecutorService":[[4,18]],"invokeAll":[[135,143]]}}},{"text":"I need to parse Durations from strings","label":{"api":{"Durations":[[16,24]]}}},{"text":"As the standard states that \"it is permitted to omit the 'T' character by mutual agreement\" some of the Javadoc examples of Durations.parse() leave out the T","label":{"api":{"Durations.parse()":[[124,140]]}}},{"text":"You could use Path::getNameCount (Java 7+)","label":{"api":{"Path::getNameCount":[[14,31]]}}},{"text":"If you need a List of colors for your index you can use a Map","label":{"api":{"Map":[[58,60]]}}},{"text":"Many examples, including Oracle's own tutorial refers to some classes in the package jdk.hashorn.api.scripting","label":{"api":{"jdk.hashorn.api.scripting":[[85,109]]}}},{"text":"If you read the SwingWorker javadocs you'll see you should not be making direct changes to the Swing components in your doInBackground() method","label":{"api":{"SwingWorker":[[16,26]],"doInBackground()":[[120,135]]}}},{"text":"For specifics, look at the publish method","label":{"api":{"publish":[[27,33]]}}},{"text":"If you use an ExecutorService to start the threads, then you can use shutdownNow followed by awaitTermination","label":{"api":{"ExecutorService":[[14,28]],"shutdownNow":[[69,79]],"awaitTermination":[[93,108]]}}},{"text":"You should look at Executors.newSingleThreadScheduledExecutor (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newSingleThreadScheduledExecutor())","label":{"api":{"Executors.newSingleThreadScheduledExecutor":[[19,60]]}}},{"text":"A Scanner seems more appropriate","label":{"api":{"Scanner":[[2,8]]}}},{"text":"Assuming you want to calculate the expression all at once upon pressing the '=' button, I would suggest using a Stack like structure(java.util.Stack) for evaluating an infix operation as follows","label":{"api":{"Stack":[[112,116]],"java.util.Stack":[[133,147]]}}},{"text":"The JFrame javadocs state that the default layout manager used is BorderLayout","label":{"api":{"JFrame":[[4,9]],"BorderLayout":[[66,77]]}}},{"text":"By default it's BorderLayout.CENTER if not specified, which is why you only see the last one added","label":{"api":{"BorderLayout.CENTER":[[16,34]]}}},{"text":"See the official API documentation for these classes at http://docs.oracle.com/javase/8/docs/api/java/io/package-frame.html for the specifics","label":{"api":{}}},{"text":"Then, if you need to expand the size of your array, set sum =Arrays.copyOf(sum, sum.length+1);, which will expand the size of your array to the necessary size","label":{"api":{}}},{"text":"I attempted to replicate this behavior in JavaFX, but Stage#setTitle is final","label":{"api":{"JavaFX":[[42,47]],"Stage#setTitle":[[54,67]]}}},{"text":"From JavaDoc of HttpURLConnection (which HttpsURLConnection extends)","label":{"api":{"HttpURLConnection":[[16,32]],"HttpsURLConnection":[[41,58]]}}},{"text":"You could use a TreeMap instead, which is ordered on its keys","label":{"api":{"TreeMap":[[16,22]]}}},{"text":"Use Files.readAllLines() to consume the file into memory, as a list of strings","label":{"api":{"Files.readAllLines()":[[4,23]]}}},{"text":"Make as many changes as you want before writing those back out to the file, using Files.write()","label":{"api":{"Files.write()":[[82,94]]}}},{"text":"You could use EntityManager#getReference()","label":{"api":{"EntityManager#getReference()":[[14,41]]}}},{"text":"The easiest way to achieve that is to use a concurrent collection like BlockingQueue to store the shared integer","label":{"api":{"BlockingQueue":[[71,83]]}}},{"text":"executeBatch returns int[] to return the counts of each update","label":{"api":{"executeBatch":[[0,11]]}}},{"text":"executeLargeBatch returns long[] to return the counts of each update","label":{"api":{"executeLargeBatch":[[0,16]]}}},{"text":"E.g., they're the batch equivalents of executeUpdate (returns int) and executeLargeUpdate (returns long)","label":{"api":{"executeUpdate":[[39,51]],"executeLargeUpdate":[[71,88]]}}},{"text":"Use String.replace to eliminate the file suffix","label":{"api":{"String.replace":[[4,17]]}}},{"text":"You can do this with MessageFormat","label":{"api":{"MessageFormat":[[21,33]]}}},{"text":"Use a ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[6,29]]}}},{"text":"The fetch() method returns a Fetch object that could be used as \"root\" of a new fetch()","label":{"api":{"fetch()":[[4,10],[80,86]],"Fetch":[[29,33]]}}},{"text":"If you need something more complex, I would suggest you to take a look at java.time (Java Platform SE 8) or Joda-Time","label":{"api":{"java.time":[[74,82]]}}},{"text":"I think DecimalFormat.parse is the Java 7 API way to go","label":{"api":{"DecimalFormat.parse":[[8,26]]}}},{"text":"After that, you go and be happy with the Number you just got","label":{"api":{"Number":[[41,46]]}}},{"text":"You need a toString() method in your Sensor class","label":{"api":{"toString()":[[11,20]],"Sensor":[[37,42]]}}},{"text":"Arrays.toString(Object[] a) will call each of your Sensor object's toString() method","label":{"api":{"Arrays.toString(Object[] a)":[[0,26]],"Sensor":[[51,56]],"toString()":[[67,76]]}}},{"text":"According to http://docs.oracle.com/javase/6/docs/api/java/util/AbstractList.html#modCount and various SO questions modCount is used to track modifications that may be done concurrently to an iteration process","label":{"api":{"modCount":[[116,123]]}}},{"text":"Look at the doc of public static Boolean valueOf(String s)","label":{"api":{"valueOf(String s)":[[41,57]]}}},{"text":"The getMethods method returns an array of all Methods, and you are only checking the name","label":{"api":{"getMethods":[[4,13]],"Methods":[[46,52]]}}},{"text":"When you call the getMethod method with only the method name as a parameter, you are asking for a Method that takes no parameters","label":{"api":{"getMethod":[[18,26]],"Method":[[98,103]]}}},{"text":"Use the parse() method that takes a ParsePosition, as that one doesn't fail when it doesn't read the entire text","label":{"api":{"parse()":[[8,14]],"ParsePosition":[[36,48]]}}},{"text":"This returns a Map<String,Item> but, of course, you may call values() on it to get a collection of items","label":{"api":{"Map<String,Item>":[[15,30]],"values()":[[61,68]]}}},{"text":"In Go use the compression level gzip.NoCompression and in Java use the Deflater.NO_COPMRESSION","label":{"api":{"gzip.NoCompression":[[32,49]],"Deflater.NO_COPMRESSION":[[71,93]]}}},{"text":"I think readAllLines method will useful for you","label":{"api":{"readAllLines":[[8,19]]}}},{"text":"NoSuchElementException might be good enough","label":{"api":{"NoSuchElementException":[[0,21]]}}},{"text":"If you don't have a generic \"not found\" exception on your class path (javax.ws.rs.NotFoundException, or javax.persistence.EntityNotFoundException for instance), I'd say the best option is to roll your own","label":{"api":{"javax.ws.rs.NotFoundException":[[70,98]],"javax.persistence.EntityNotFoundException":[[104,144]]}}},{"text":"Use Scanner to get the user input, and search using this input","label":{"api":{"Scanner":[[4,10]]}}},{"text":"You should probably iterate over the Collection using an Iterator","label":{"api":{"Collection":[[37,46]],"Iterator":[[57,64]]}}},{"text":"Take a look at the Collection interface","label":{"api":{"Collection":[[19,28]]}}},{"text":"There's iterator() which will allow you to step through all of the elements in the collection in some sequence and there's toArray() which would allow you to access the elements by an index","label":{"api":{"iterator()":[[8,17]],"toArray()":[[123,131]]}}},{"text":"Below is a solution copied from http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html#valueOf(java.lang.String)","label":{"api":{}}},{"text":"Your problem will go away if you move all of your code into a Runnable and pass that Runnable to EventQueue.invokeLater (or SwingUtilities.invokeLater, which is a synonym for EventQueue.invokeLater)","label":{"api":{"Runnable":[[62,69],[85,92]],"EventQueue.invokeLater":[[97,118],[175,196]],"SwingUtilities.invokeLater":[[124,149]]}}},{"text":"Otherwise, if you really want the main thread to do something each time the directory watcher finds a new image, your main thread would have to first create a blocking collection, like ArrayBlockingQueue, pass it to the DirectoryWatcher thread before starting it","label":{"api":{"ArrayBlockingQueue":[[185,202]],"DirectoryWatcher":[[220,235]]}}},{"text":"The DirectoryWatcher thread would then add file names to the queue whenever it needs to, and the main thread could loop forever, calling the take() method of the blocking queue","label":{"api":{"DirectoryWatcher":[[4,19]],"take()":[[141,146]]}}},{"text":"To keep your code JPA vendor-agnostic, you should have used only JPA interfaces, entity manager instead of Hibernate session, etc","label":{"api":{"entity manager":[[81,94]],"session":[[117,123]]}}},{"text":"What you want, is a Pattern and Matcher","label":{"api":{"Pattern":[[20,26]],"Matcher":[[32,38]]}}},{"text":"I'm currently studying Java Collections Framework, and one of the fascinating questions that I keep asking myself is \"How do all these collections implement the generic version of Collection#toArray method\"","label":{"api":{"Collections":[[28,38]],"Collection#toArray":[[180,197]]}}},{"text":"From what I've read in other SO questions, it most probably uses Array#newInstance","label":{"api":{"Array#newInstance":[[65,81]]}}},{"text":"Just for the reference, that's how Array#newInstance is declared","label":{"api":{"Array#newInstance":[[35,51]]}}},{"text":"Thread#interrupt is more or less implemented with a flag","label":{"api":{"Thread#interrupt":[[0,15]]}}},{"text":"Your code needs to check for that status with Thread#interrupted() or Thread#isInterrupted() (or handle the InterruptedException)","label":{"api":{"Thread#interrupted()":[[46,65]],"Thread#isInterrupted()":[[70,91]]}}},{"text":"Note that in order to update a Swing component in a thread other than the Swing thread, you'll need to use a SwingWorker (see Swing Concurrency Tutorial), or user a Swing Timer instead","label":{"api":{"SwingWorker":[[109,119]],"Swing Timer":[[165,175]]}}},{"text":"An alternative can be to use ConcurrentHashMap instead of HashMap","label":{"api":{"ConcurrentHashMap":[[29,45]],"HashMap":[[58,64]]}}},{"text":"You do not need to have synchronized blocks when accessing ConcurrentHashMap in multithreaded application","label":{"api":{"ConcurrentHashMap":[[59,75]]}}},{"text":"RuntimeException or Unchecked Exception instances like NPE do not require throwing/catching","label":{"api":{"RuntimeException":[[0,15]],"Unchecked Exception":[[20,38]],"NPE":[[55,57]]}}},{"text":"In general, if there is no possibility to proceed then it will terminate as a RuntimeException","label":{"api":{"RuntimeException":[[78,93]]}}},{"text":"With the Date object you can then use  http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html to get the date in the required format","label":{"api":{"Date":[[9,12]]}}},{"text":"The Javadocs for the relevant collections and ConcurrentModificationException are clear","label":{"api":{"ConcurrentModificationException":[[46,76]]}}},{"text":"Instead of using Scanner, I suggest using java.io.BufferedReader, which will let you read an entire line at once","label":{"api":{"Scanner":[[17,23]],"java.io.BufferedReader":[[42,63]]}}},{"text":"Use Matcher.matches() rather than Matcher.find(), in order to match the regexp against the entire string","label":{"api":{"Matcher.matches()":[[4,20]],"Matcher.find()":[[34,47]]}}},{"text":"Now because you're using a method with a declaration of","label":{"api":{}}},{"text":"See the Java Regex Pattern for further information about the use of regex","label":{"api":{"Regex Pattern":[[13,25]],"regex":[[68,72]]}}},{"text":"I think the answer is simple Calendar is an Abstract class, so we cant create an instance of it","label":{"api":{"Calendar":[[29,36]]}}},{"text":"Now when you call Calendar.getInstance then GregorianCalendar instance is created","label":{"api":{"Calendar.getInstance":[[18,37]],"GregorianCalendar":[[44,60]]}}},{"text":"At run-time, we can use Font.canDisplayUpTo(String) to determine which of the installed fonts can display a given text","label":{"api":{"Font.canDisplayUpTo(String)":[[24,50]]}}},{"text":"So you need to call mapToObj instead of just map, when mapping an int to an object","label":{"api":{"mapToObj":[[20,27]]}}},{"text":"If you're using Java SE 8 or later (recommended), try using the java.time classes","label":{"api":{"java.time":[[64,72]]}}},{"text":"You will need to create a custom Comparator which performs the operation you want and pass it to the sort method along with your list, for example..","label":{"api":{"Comparator":[[33,42]],"sort":[[101,104]],"list":[[129,132]]}}},{"text":"If you're running on a platform that has ssh installed you could invoke command line processes using ProcessBuilder methods to perform whatever operations you need","label":{"api":{"ProcessBuilder":[[101,114]]}}},{"text":"It seems to me that if objectToInputStreamConverter created the ByteArrayInputStream using ByteArrayInputStream(byte[] buf) then it could just return the byte[] argument and save you from the need to read anything more, not to mention all that error handling","label":{"api":{"objectToInputStreamConverter":[[23,50]],"ByteArrayInputStream":[[64,83]],"ByteArrayInputStream(byte[] buf)":[[91,122]]}}},{"text":"Note that the service will continue to execute already submitted tasks, but it will not accept new tasks","label":{"api":{}}},{"text":"Now, we wait for the service to terminate by calling awaitTermination with a timeout of 5 minutes","label":{"api":{"awaitTermination":[[53,68]]}}},{"text":"When another thread interrupts the thread that is calling our method while it is waiting in method awaitTermination, an InterruptedException is thrown","label":{"api":{"awaitTermination":[[99,114]],"InterruptedException":[[120,139]]}}},{"text":"Since java can't transform the type of 'xyz' into a double a ClassCastException is throw","label":{"api":{"ClassCastException":[[61,78]]}}},{"text":"One thing about the Scanner class is that calling Scanner.close() on the Scanner will also close the input stream it's reading from","label":{"api":{"Scanner":[[20,26],[73,79]],"Scanner.close()":[[50,64]],"input stream":[[101,112]]}}},{"text":"I started investigating this, led by a gut feeling caused by method comments like that of JTree#setRowHeight(int)","label":{"api":{"JTree#setRowHeight(int)":[[90,112]]}}},{"text":"To accomplish this, you could use Google Guava Iterables or Java 8 Stream.flatMap(), depending on your Java version","label":{"api":{"Google Guava Iterables":[[34,55]],"Stream.flatMap()":[[67,82]]}}},{"text":"URLClassLoader makes a good starting point","label":{"api":{"URLClassLoader":[[0,13]]}}},{"text":"Since you said maze, one thing you can do is define a java.awt.Rectangle for each wall segment and for your object moving through the maze","label":{"api":{"java.awt.Rectangle":[[54,71]]}}},{"text":"You can peek at the stream","label":{"api":{}}},{"text":"The package java.util.function defines a lot of them, but any interface with a single method can be used","label":{"api":{"java.util.function":[[12,29]]}}},{"text":"It's even better if you use one of the existing interfaces in the java.util.function package","label":{"api":{"java.util.function":[[66,83]]}}},{"text":"The documentation of the Document interface describes the interface as","label":{"api":{"Document":[[25,32]]}}},{"text":"Perhaps you want to use an InputVerifier attached to a JTextField","label":{"api":{"InputVerifier":[[27,39]],"JTextField":[[55,64]]}}},{"text":"A good way to catch this mistake is to put @Override before your method;  that tells the compiler that you meant to override a method that exists with the same signature in an inherited class","label":{"api":{"@Override":[[43,51]]}}},{"text":"Files which do not start with a file separator (or drive letter followed by a file separator) are relative files, assumed to be found by prepending the current directory to their paths","label":{"api":{"Files":[[0,4]]}}},{"text":"Looks like you are mixing java.util.logging.FileHandler properties with org.apache.juli.FileHandler properties","label":{"api":{"java.util.logging.FileHandler":[[26,54]],"org.apache.juli.FileHandler":[[72,98]]}}},{"text":"The BigInteger#bitLength() function has the necessary documentation","label":{"api":{"BigInteger#bitLength()":[[4,25]]}}},{"text":"It is best to use existing APIs such as Java's Cipher class which also provides proper padding to be used with RSA such as OAEP (PKCS#1 v1.5 is not good anymore)","label":{"api":{"Cipher":[[47,52]]}}},{"text":"You can store your DisplayObjects in a WeakHashMap","label":{"api":{"DisplayObjects":[[19,32]],"WeakHashMap":[[39,49]]}}},{"text":"An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use","label":{"api":{"WeakHashMap":[[14,24]]}}},{"text":"They're in the java.util package (along with a bunch of other things that aren't part of the Collections framework)","label":{"api":{"java.util package":[[15,31]],"Collections":[[93,103]]}}},{"text":"For example, http://docs.oracle.com/javase/7/docs/api/index.html?java/util/List.html provides a full description of the List interface methods, but if it is only an interface then those methods should not provide any functionality, so what is described in these docs, then","label":{"api":{"List":[[120,123]]}}},{"text":"ToolProvider.getSystemJavaCompiler() returns null if there isn't any compiler","label":{"api":{"ToolProvider.getSystemJavaCompiler()":[[0,35]]}}},{"text":"ToolProvider.getSystemJavaCompiler() returns null - usable with only JRE installed","label":{"api":{"ToolProvider.getSystemJavaCompiler()":[[0,35]]}}},{"text":"You can use the method parseHexBinary from the class DatatypeConverter to get the keys as byte array","label":{"api":{"parseHexBinary":[[23,36]],"DatatypeConverter":[[53,69]]}}},{"text":"Read more about SwingWorker and also read this Java tutorial","label":{"api":{"SwingWorker":[[16,26]]}}},{"text":"Worker Threads and SwingWorker","label":{"api":{"Worker Thread":[[0,12]],"SwingWorker":[[19,29]]}}},{"text":"The usual and clean solution is to use a List, which is a resizeable collection","label":{"api":{"List":[[41,44]]}}},{"text":"ArrayList, the most commonly used List implementation is backed by an array but is efficient as the array isn't changed every time you resize the collection","label":{"api":{"ArrayList":[[0,8]],"List":[[34,37]]}}},{"text":"This solution relies on Java's TreeMap, which is a map that keeps its entries ordered by its keys natural order","label":{"api":{"TreeMap":[[31,37]]}}},{"text":"Two TreeMaps are needed to accomplish what you want","label":{"api":{"TreeMap":[[4,10]]}}},{"text":"If you want the user to input data to your program from the console, the easiest way to achieve this is to use the Scanner class","label":{"api":{"Scanner":[[115,121]]}}},{"text":"Here's a example using Scanner and Joda time","label":{"api":{"Scanner":[[23,29]]}}},{"text":"Not sure if there is built in functionality for this already, but you could always have a ActionListener which listens for selection changes and then programmatically set the width of the JComboBox to the length of the selected content (getSelectedItem()) when it changes","label":{"api":{"ActionListener":[[90,103]],"JComboBox":[[188,196]],"getSelectedItem()":[[237,253]]}}},{"text":"JComboBox appears to have a setPrototypeDisplayValue(Object) method that is used to calculate component's preferred width based on the length of the parameter","label":{"api":{"JComboBox":[[0,8]],"setPrototypeDisplayValue(Object)":[[28,59]]}}},{"text":"So your class is a JPanel; it's inheritance; a fundamental part of OOP","label":{"api":{"JPanel":[[19,24]]}}},{"text":"Since your class is a JPanel, if you want to set it's background color somewhere inside the class you'd just do setBackground(yourColor) from outside would be ui.setBackground(yourColor) assuming of course that you named the instance ui","label":{"api":{"JPanel":[[22,27]],"setBackground(yourColor)":[[112,135]],"ui.setBackground(yourColor)":[[159,185]]}}},{"text":"JFrames are not the same as JPanels if that's what you were getting at","label":{"api":{"JFrame":[[0,5]],"JPanel":[[28,33]]}}},{"text":"The documentation of appendChild() shows that it takes a Node as argument","label":{"api":{"appendChild()":[[21,33]],"Node":[[57,60]]}}},{"text":"About the case of in-order traversal, you should keep a stack (note that the implementation of Stack is array-based and synchronized, probebly it is better to use a Dequeue such as LinkedList, which also supports push and pop as of Java 6), and auxiliary state for knowing how to resume the iteration each time that findNext is called","label":{"api":{"Stack":[[95,99]],"Dequeue":[[165,171]],"LinkedList":[[181,190]],"findNext":[[316,323]]}}},{"text":"Now you want that to be done when you click on a JButton","label":{"api":{"JButton":[[49,55]]}}},{"text":"To do so you need to add an ActionListener, using an anonyous class, to the JButton with the previous code","label":{"api":{"ActionListener":[[28,41]],"JButton":[[76,82]]}}},{"text":"See the addActionListener() method of JButton and the ActionListener","label":{"api":{"ActionListener()":[[11,26]],"JButton":[[38,44]],"ActionListener":[[54,67]]}}},{"text":"Use LocalDate#of(int, int, int) method that takes year, month and dayOfMonth","label":{"api":{"LocalDate#of(int, int, int)":[[4,30]]}}},{"text":"Call Integer.parseInt(str, 16) in a try-catch if you get a NumberFormatException it wasn't a valid hex encoded int","label":{"api":{"Integer.parseInt(str, 16)":[[5,29]],"NumberFormatException":[[59,79]]}}},{"text":"Use JTextArea#write(Writer) instead","label":{"api":{"JTextArea#write(Writer)":[[4,26]]}}},{"text":"This will give you a set of Map.Entry, which you can then dump into a new LinkedList<Map.Entry>(entrySet)","label":{"api":{"Map.Entry":[[28,36]],"LinkedList<Map.Entry>(entrySet)":[[74,104]]}}},{"text":"If you are on Java 8u40 you can use a TextFormatter, i","label":{"api":{"TextFormatter":[[38,50]]}}},{"text":"I have been working to find an efficient way to serialize a specific class to pass between my server and client and have been using ByteOutputArrayStream to pass around a byte array","label":{"api":{"ByteOutputArrayStream":[[132,152]]}}},{"text":"However, this article makes me wonder if I should be using ByteOutputArrayStream at all","label":{"api":{"ByteOutputArrayStream":[[59,79]]}}},{"text":"If you have your custom data structure then you could make it implement the List<T> interface to be able to use the Collections methods (which includes sort and many others)","label":{"api":{"List<T>":[[76,82]],"Collections":[[116,126]]}}},{"text":"But, I'm pretty sure that you're talking about a HashMap when you say that you would like to store a list of friends for players","label":{"api":{"HashMap":[[49,55]]}}},{"text":"A HashMap is like a collection of variables based on a key","label":{"api":{"HashMap":[[2,8]]}}},{"text":"Make sure to NEVER use the Player object as a type parameter in an ArrayList, HashMap, HashSet, or anything like that","label":{"api":{"Player":[[27,32]],"ArrayList":[[67,75]],"HashMap":[[78,84]],"HashSet":[[87,93]]}}},{"text":"Then, whenever you want to get the list of a player's friends, you could use HashMap.get()","label":{"api":{"HashMap.get()":[[77,89]]}}},{"text":"Then, if you wanted to set the player's friend list to a new value, you could use HashMap.put()","label":{"api":{"HashMap.put()":[[82,94]]}}},{"text":"Use java.math.BigInteger variables instead of longs","label":{"api":{"java.math.BigInteger":[[4,23]]}}},{"text":"When you select data, then it is enough the measure the time of Query.getResultList() (and calls alike)","label":{"api":{"Query.getResultList()":[[64,84]]}}},{"text":"For the other operations (EntityManager.persist() or merge() or remove()) there is a mechanism of flushing, which basically forces the queue of queries (or a single query) from the cache to hit the database","label":{"api":{"EntityManager.persist()":[[26,48]],"merge()":[[53,59]],"remove()":[[64,71]],"flushing":[[98,105]]}}},{"text":"usually you do not connect directly to any database, as that is done by a pool (even if you work with a DataSource), which simply gives you a already established connection, but that again depends on your setup","label":{"api":{"DataSource":[[104,113]]}}},{"text":"You can use Strings Split method","label":{"api":{"String":[[12,17]],"Split":[[20,24]]}}},{"text":"Together with Pattern.UNICODE_CHARACTER_CLASS it should match ‘special characters’","label":{"api":{"Pattern.UNICODE_CHARACTER_CLASS":[[14,44]]}}},{"text":"You can use NumberFormat here, with appropriate Locale","label":{"api":{"NumberFormat":[[12,23]],"Locale":[[48,53]]}}},{"text":"You can even use DecimalFormat which is slightly more powerful","label":{"api":{"DecimalFormat":[[17,29]]}}},{"text":"There's actually already a data structure which does exactly what you're looking for, which is the TreeMap","label":{"api":{"TreeMap":[[99,105]]}}},{"text":"Though the Matcher#group(String) will return the text matched in that group, the Matcher#start() will give the start index of the complete match","label":{"api":{"Matcher#group(String)":[[11,31]],"Matcher#start()":[[81,95]]}}},{"text":"Alternatively, you could move the logic into a subclass of ZipOutputStream and use the same Deflater so it will automatically have the same configuration","label":{"api":{"ZipOutputStream":[[59,73]],"Deflater":[[92,99]]}}},{"text":"Note that starting with Java-8 you can call sort as a default method implementation on List<T>, making the implementation even easier to locate","label":{"api":{"List<T>":[[87,93]]}}},{"text":"I speculate that an accurate return type tells the compiler which FunctionalInterface it being used","label":{"api":{"FunctionalInterface":[[66,84]]}}},{"text":"The \"dumb\" approach would be to use a ProcessBuilder to interact with the jar via the command-line programatically","label":{"api":{"ProcessBuilder":[[38,51]]}}},{"text":"Because Random does not implement Comparable","label":{"api":{"Random":[[8,13]],"Comparable":[[34,43]]}}},{"text":"Use the get(long timeout, TimeUnit unit) method on your futures, and if you get TimeoutException, then call cancel on them","label":{"api":{"get(long timeout, TimeUnit unit)":[[8,39]],"future":[[56,61]],"TimeoutException":[[80,95]]}}},{"text":"Use split() method","label":{"api":{"split()":[[4,10]]}}},{"text":"I've been browsing around quite a bit and I'm wondering if there's anything similar to the HttpServer class in the com.sun.net.httpserver.HttpServer package","label":{"api":{"HttpServer":[[91,100]],"com.sun.net.httpserver.HttpServer":[[115,147]]}}},{"text":"This is a good reason to use the Java concurrent classes","label":{"api":{"concurrent":[[38,47]]}}},{"text":"In your case, the SynchronousQueue looks like a good replacement","label":{"api":{"SynchronousQueue":[[18,33]]}}},{"text":"With the SynchronousQueue there is no need to use the empty variable, the this.frameWithMotionData variable or the wait/notifyAll mechanics","label":{"api":{"SynchronousQueue":[[9,24]],"this.frameWithMotionData":[[74,97]],"wait":[[115,118]],"notifyAll":[[120,128]]}}},{"text":"The 2-parameter version of Collectors.toMap() uses a HashMap","label":{"api":{"Collectors.toMap()":[[27,44]],"HashMap":[[53,59]]}}},{"text":"To use the 4-parameter version, you can replace","label":{"api":{}}},{"text":"While perhaps unexpected, the JavaDoc does say so","label":{"api":{}}},{"text":"According to the String.split() documentation the method returns array, so how come the following code compiles","label":{"api":{"String.split()":[[17,30]]}}},{"text":"String.split() returns an array","label":{"api":{"String.split()":[[0,13]]}}},{"text":"The java.nio.file.Files API is a really nice improvement over the old java.io.File class, but one detail strikes me as odd; with the exception of delete() no methods document that they may throw NoSuchFileException, and even delete() says this is optional","label":{"api":{"java.nio.file.Files":[[4,22]],"java.io.File":[[70,81]],"delete()":[[146,153],[225,232]],"NoSuchFileException":[[195,213]]}}},{"text":"On Windows 7 with Java 7.0.02 the Files.readAllLines() method does raise a NoSuchFileException, though it's not explicitly documented to do so","label":{"api":{"Files.readAllLines()":[[34,53]],"NoSuchFileException":[[75,93]]}}},{"text":"As you can see from the stacktrace, Files uses the FileSystemProvider to perform the file operations","label":{"api":{"Files":[[36,40]],"FileSystemProvider":[[51,68]]}}},{"text":"The FileSystemProvider implementations are restricted (like the WindowsFileSystemProvider) and in turn use a lot of native (C) code","label":{"api":{"FileSystemProvider":[[4,21]],"WindowsFileSystemProvider":[[64,88]]}}},{"text":"The Queue documentation does a fairly good job of explaining the difference","label":{"api":{"Queue":[[4,8]]}}}]