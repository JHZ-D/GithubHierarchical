[{"text": "You can also use Objects.equals that does the null check for you", "label": {"api": {"Objects.equals": [[17, 30]]}}}, {"text": "Just use java.lang.Classloader.getResourceAsStream(String name)", "label": {"api": {"java.lang.Classloader.getResourceAsStream(String name)": [[9, 62]]}}}, {"text": "Use a CountDownLatch with a count of 1, like startSignal in the example", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "You can do this quite straightforward with an URLConnection", "label": {"api": {"URLConnection": [[46, 58]]}}}, {"text": "java.text.DateFormat objects are not thread safe", "label": {"api": {"java.text.DateFormat": [[0, 19]]}}}, {"text": "Basically, the Jython engine (which I assume you are using for scripting python) allows you to use its ScriptEngine as an Invocable", "label": {"api": {"Invocable": [[122, 130]]}}}, {"text": "In Swing, the GradientPaint class can be used to draw a gradient", "label": {"api": {"GradientPaint": [[14, 26]]}}}, {"text": "Assuming that the input string will always be in that format, with 4 integers between each bracket, I think the best way to do it would simply be to use a Scanner object and it's nextInt() method which will ignore the brackets and comma's and just find the numbers", "label": {"api": {"Scanner": [[155, 161]]}}}, {"text": "I'm not sure I understand your problem, but maybe the method you're looking for is getName()", "label": {"api": {"getName()": [[83, 91]]}}}, {"text": "A quick search on the page reveals the method getName(), which does what you want", "label": {"api": {"getName()": [[46, 54]]}}}, {"text": "If you're using Java 8, you can pass a method reference to Comparator.comparing to construct a Comparator based on a getter method", "label": {"api": {"Comparator.comparing": [[59, 78]]}}}, {"text": "To make a descending sort, you can call reversed", "label": {"api": {"reversed": [[40, 47]]}}}, {"text": "I am using an HttpSessionListener implementation to populate that Hashtable and eliminate the expired sessions on its sessionCreated and sessionDestroyed methods", "label": {"api": {"HttpSessionListener": [[14, 32]]}}}, {"text": "Different drivers may behave differently and different ResultSet settings may behave differently", "label": {"api": {"ResultSet settings": [[55, 72]]}}}, {"text": "But you can call Double.compare, which will compare two primitive doubles for you", "label": {"api": {"Double.compare": [[17, 30]]}}}, {"text": "The best approach would be to add a MediaView to the fxml if you want to create a videoplayer, or do not add anything if you just want to play audio", "label": {"api": {"MediaView": [[36, 44]]}}}, {"text": "Inside your controller, create instances of MediaPlayer and Media, load media and add them to MediaView, if required", "label": {"api": {"MediaView": [[94, 102]]}}}, {"text": "First of all, as @user2357112 points out, Random implements Serializable, and does so by writing the seed field (along with the nextNextGaussian and haveNextNextGaussian fields)", "label": {"api": {"Random": [[42, 47]], "Serializable": [[60, 71]]}}}, {"text": "gson.fromJson(gson.toJson(r), Random.class); returns an identical object", "label": {"api": {"Random": [[30, 35]]}}}, {"text": "You don't necessarily need the same Random instance, just a consistent one", "label": {"api": {"Random": [[36, 41]]}}}, {"text": "Then just initialize a Random instance with that seed, and now all runs loaded from that file will behave the same", "label": {"api": {"Random": [[23, 28]]}}}, {"text": "If you wanted, you could even reset the Random instance in your currently running game to the same seed too", "label": {"api": {"Random": [[40, 45]]}}}, {"text": "On the other hand if you're generating maps or other seemingly-constant content randomly and want it to persist between loads, I'd think you'd do better to simply seed your Random at the start, and save that value like you describe", "label": {"api": {"Random": [[173, 178]]}}}, {"text": "I would consider just leaving your game's Random unseeded and let each game be slightly unique", "label": {"api": {"Random": [[42, 47]]}}}, {"text": "Files inside JARs and WARs are located as Java Resources, which can be handled by the Java class loader using the getResourceAsStream() method, which returns an InputStream to the resource", "label": {"api": {"getResourceAsStream()": [[114, 134]]}}}, {"text": "Simply you can use ExecutorService to create a thread pool", "label": {"api": {"ExecutorService": [[19, 33]]}}}, {"text": "You can use Files class", "label": {"api": {"Files": [[12, 16]]}}}, {"text": "You can account for this using convertRowIndexToModel and convertColumnIndexToModel", "label": {"api": {"convertRowIndexToModel": [[31, 52]], "convertColumnIndexToModel": [[58, 82]]}}}, {"text": "The method decode(ByteBuffer, CharBuffer, boolean) returns a result, but you are ignoring the result", "label": {"api": {"decode(ByteBuffer, CharBuffer, boolean)": [[11, 49]]}}}, {"text": "You can override prepareRenderer(), like they show here, and add a MatteBorder to the bottom when the row matches the one you want", "label": {"api": {"prepareRenderer()": [[17, 33]], "MatteBorder": [[67, 77]]}}}, {"text": "To ensure there is data available before calling the read(byte[]) method, you can call the available() method, documented here", "label": {"api": {"documented here": [[111, 125]]}}}, {"text": "Key methods from JMS spec are getJMSCorrelationID and setJMSCorrelationID", "label": {"api": {"getJMSCorrelationID": [[30, 48]], "setJMSCorrelationID": [[54, 72]]}}}, {"text": "While you can't re-run a Thread directly, you can use a ScheduledExecutorService to execute a Thread (or anything else that implements Runnable) periodically", "label": {"api": {"ScheduledExecutorService": [[56, 79]]}}}, {"text": "The package java.awt.geom allows testing if a point lies within a rectangle and similar questions", "label": {"api": {"java.awt.geom": [[12, 24]]}}}, {"text": "If you want, you may provide similar functionality by implementing CharSequence - all these classes implement this interface", "label": {"api": {"CharSequence": [[67, 78]]}}}, {"text": "There are Appendable and CharSequence filling this gap and offering much more flexibility", "label": {"api": {"Appendable": [[10, 19]], "CharSequence": [[25, 36]]}}}, {"text": "And since keys like (BaseRate|Rate|tk_rate) are in fact valid regular expressions, you can just use replaceAll to replace them in all their variants", "label": {"api": {"replaceAll": [[100, 109]]}}}, {"text": "If they are not contained in the string, replaceAll will just do nothing, so the contains check is not really necessary", "label": {"api": {"replaceAll": [[41, 50]]}}}, {"text": "When the nextInt method is called with 6 as a parameter, it will return a random number between 0 and 5", "label": {"api": {"nextInt method": [[9, 22]]}}}, {"text": "If you are using a SimpleDateFormat, you will need to create an instance with the target Locale", "label": {"api": {"SimpleDateFormat": [[19, 34]], "create an instance with the target Locale": [[54, 94]], "DateFormat": [[25, 34]]}}}, {"text": "If you are using a DateFormat style, you would need to get an instance for the target locale", "label": {"api": {"DateFormat": [[19, 28]], "get an instance for the target locale": [[55, 91]]}}}, {"text": "In both cases, it appears you want to change the timezone also", "label": {"api": {"change the timezone": [[38, 56]]}}}, {"text": "Depending on what you're trying to accomplish, you may want to look at the StringTokenizer class", "label": {"api": {"StringTokenizer": [[75, 89]]}}}, {"text": "You can use String.join StringBuilder and String.split", "label": {"api": {"String.join": [[12, 22]], "StringBuilder": [[24, 36]], "String.split": [[42, 53]]}}}, {"text": "This link also provides some documentation on the same", "label": {"api": {"link": [[5, 8]]}}}, {"text": "You need to import time class", "label": {"api": {"time": [[19, 22]]}}}, {"text": "With reference to this answer, it's possible to catch all uncaught Exceptions in Java", "label": {"api": {"Java": [[81, 84]]}}}, {"text": "Swing Threading Policy states", "label": {"api": {"Swing Threading Policy": [[0, 21]]}}}, {"text": "Now, it so happens that the Integer class has an inline cache which covers all values from -128 up to 127 at least, as the javadoc of Integer.valueOf() explains", "label": {"api": {"javadoc of Integer.valueOf()": [[123, 150]]}}}, {"text": "To your actual question, to load an image from a file as a BufferedImage object, call javax.imageio.ImageIO.read with the File object", "label": {"api": {"javax.imageio.ImageIO.read": [[86, 111]]}}}, {"text": "Extend AbstractTableModel as shown here", "label": {"api": {"AbstractTableModel": [[7, 24]]}}}, {"text": "If your concern is that you want A instances with equal but distinct b members to hash differently, rather than making sure A and B instances hash differently, you can use System.identityHashCode", "label": {"api": {"System.identityHashCode": [[172, 194]]}}}, {"text": "by overriding getPreferredSize() or setting it with setPreferredSize(…)) or do setSize(…)", "label": {"api": {"getPreferredSize()": [[14, 31]], "setPreferredSize(…)": [[52, 70]]}}}, {"text": "Have a look at the java.util.Scanner class, it can help to read separate tokens from a Reader", "label": {"api": {"java.util.Scanner": [[19, 35]]}}}, {"text": "In fact, the LinkedList collection standard API in Java has such a method", "label": {"api": {"LinkedList": [[13, 22]]}}}, {"text": "This creates a Scanner, that scans only on the String \"System.in\"", "label": {"api": {"Scanner, that scans only on the String \"System.in\"": [[15, 64]]}}}, {"text": "You might want to check the documentation of move and delete", "label": {"api": {"move": [[45, 48]], "delete": [[54, 59]]}}}, {"text": "Also, use System.nanoTime() for nano timings", "label": {"api": {"System.nanoTime()": [[10, 26]]}}}, {"text": "Is there a specific reason why people don't always use \"Object\" as their data type to pass values", "label": {"api": {"Object": [[56, 61]]}}}, {"text": "Since Java is strongly typed, you cannot do a whole lot with Object", "label": {"api": {"Object": [[61, 66]]}}}, {"text": "println can accept Object because it only needs to call the toString method", "label": {"api": {"Object": [[19, 24]]}}}, {"text": "If you only need the limited functionality provided by the methods in Object, then sure, you can use it as a type", "label": {"api": {"Object": [[70, 75]]}}}, {"text": "This is working as specified", "label": {"api": {"spec": [[19, 22]]}}}, {"text": "From the spec", "label": {"api": {"spec": [[9, 12]]}}}, {"text": "From the docs on Stream for the peek method", "label": {"api": {"Stream": [[17, 22]]}}}, {"text": "An AtomicInteger fits your need", "label": {"api": {"AtomicInteger": [[3, 15]]}}}, {"text": "AtomicInteger#incrementAndGet is an atomic operation", "label": {"api": {"AtomicInteger": [[0, 12]], "AtomicInteger#incrementAndGet": [[0, 28]]}}}, {"text": "split takes a regular expression as an argument", "label": {"api": {"split": [[0, 4]], "regular expression": [[14, 31]]}}}, {"text": "Or better, use Class#isArray()", "label": {"api": {"Class#isArray()": [[15, 29]]}}}, {"text": "Please refer to the documentation of DateTimeFormatter, where there is a list of all formatting and parsing formats", "label": {"api": {"DateTimeFormatter": [[37, 53]]}}}, {"text": "If the values in the array are non-negative and reasonably small, you can use a BitSet to store whether or not you have seen a value previously", "label": {"api": {"BitSet": [[80, 85]]}}}, {"text": "Here's a sample Comparator I wrote to sort multi-dimensional arrays by their first element", "label": {"api": {"Comparator": [[16, 25]]}}}, {"text": "Usually you will only write a comparator if you are going to pass it into a static method that compares two instances (passing a Comparator is essentially like passing a function in other languages)", "label": {"api": {"Comparator": [[129, 138]]}}}, {"text": "If you want to compare one instance to another instance, then you would implement the interface Comparable on the class itself (rather than create a new class, as I did)", "label": {"api": {"Comparable": [[96, 105]]}}}, {"text": "The best place for initialization code in a web application is inside a ServletContextListener's contextInitialized method", "label": {"api": {"ServletContextListener": [[72, 93]], "contextInitialized": [[97, 114]]}}}, {"text": "The solution then is to create a ListSelectionListener that iterates over all of the lists and calls list.clearSelection() on each one, except for the list that triggered the selection event (which can be determined by ListSelectionEvent.getSource()", "label": {"api": {"ListSelectionListener": [[33, 53]], "list.clearSelection()": [[101, 121]]}}}, {"text": "Here is roughly what the ListSelectionListener implementation should look like", "label": {"api": {"ListSelectionListener": [[25, 45]]}}}, {"text": "Since the lists can change dynamically, you'll need to call JList.addListSelectionListener() whenever a new list is added to the frame", "label": {"api": {"ListSelectionListener": [[69, 89]], "JList.addListSelectionListener()": [[60, 91]]}}}, {"text": "Hopefully you have some sort of addSection method that you can tack on to, but if all else fails, you can always add a ComponentListener to whatever container the sections are placed into, and search for the lists in the component hierarchy whenever a new section is added to the container", "label": {"api": {"ComponentListener": [[119, 135]]}}}, {"text": "String implements a Comparable<String> which is implemented as a lexicographical comparison, in other words, by default \"Apple\".compareTo(\"Orange\") < 0", "label": {"api": {"String": [[0, 5], [31, 36]]}}}, {"text": "Now Collections.sort has a variant that takes this comparator into account, you can thus simply use", "label": {"api": {"Collections.sort": [[4, 19]]}}}, {"text": "You shouldn't use String.valueof to cast back to a string", "label": {"api": {"String": [[18, 23]]}}}, {"text": "you can compare chars with the <, but you can't use this operator on Strings", "label": {"api": {"String": [[69, 74]]}}}, {"text": "if the two first characters are equal, that doesn't mean the String's are equal per se, for instance \"Apple\" and \"Ambiguous\"", "label": {"api": {"String": [[61, 66]]}}}, {"text": "You use the values given in the Font class, for example", "label": {"api": {"in the Font class": [[25, 41]]}}}, {"text": "You should also check whether you are expecting normal List#add behaviour which appends to the end of a list not the beginning", "label": {"api": {"List#add": [[55, 62]]}}}, {"text": "You are using a Queue specifically designed to be non-blocking as a BlockingQueue", "label": {"api": {"BlockingQueue": [[68, 80]]}}}, {"text": "The BlockingQueue is bounded at 8 elements", "label": {"api": {"BlockingQueue": [[4, 16]]}}}, {"text": "Use Collections.shuffle() on your set of quarters and pennies, and check the first three elements after each shuffle", "label": {"api": {"Collections.shuffle()": [[4, 24]]}}}, {"text": "When the user is inputting numbers, you should use sc.nextInt()", "label": {"api": {"sc.nextInt()": [[51, 62]]}}}, {"text": "If you're expecting strings of characters and want to convert them into ints, you can use Character.getNumericValue(myChar) on each character of the input string individually", "label": {"api": {"Character.getNumericValue(myChar)": [[90, 122]]}}}, {"text": "Don't use replaceAll(String regex, String replacement) since it accepts a regular expression as first argument (which you don't need it), use replace(CharSequence target, CharSequence replacement) instead", "label": {"api": {"replaceAll(String regex, String replacement)": [[10, 53]], "replace(CharSequence target, CharSequence replacement)": [[142, 195]]}}}, {"text": "You have to mark desired elements as mandatory ones with a required annotation property", "label": {"api": {"required annotation property": [[59, 86]], "required": [[59, 66]]}}}, {"text": "As for attributes it works the same way, you have to mark them as required", "label": {"api": {"required": [[66, 73]]}}}, {"text": "Do not call close() on the BufferedReader, because it will close all system handles and files underneath it (see Javadoc for BufferedReader close() method)", "label": {"api": {"Javadoc for BufferedReader close() method": [[113, 153]]}}}, {"text": "Quoted from String.split(String regex) documentation", "label": {"api": {"String.split(String regex)": [[12, 37]]}}}, {"text": "The Java Stack class throws an EmptyStackException in those cases", "label": {"api": {"Stack": [[9, 13], [36, 40]]}}}, {"text": "In Java 8, you can use Optional<T>", "label": {"api": {"Optional<T>": [[23, 33]]}}}, {"text": "Either you use the Optional<T> class stated in comments and in the other answer or if you want to avoid returning null you could return a list of your object which would be empty if you don't have any result to return", "label": {"api": {"Optional<T> class": [[19, 35]]}}}, {"text": "Couldn't it be achieved with a proper value to setResizeWeight()", "label": {"api": {"setResizeWeight()": [[47, 63]]}}}, {"text": "Where the 'XXX', according to SimpleDateFormat API docs, means ISO 8601 time zone", "label": {"api": {"SimpleDateFormat API docs": [[30, 54]]}}}, {"text": "You can do non-blocking sockets with ServerSocketChannel", "label": {"api": {"ServerSocketChannel": [[37, 55]]}}}, {"text": "call configureBlocking(false) to do non-blocking", "label": {"api": {"configureBlocking(false)": [[5, 28]]}}}, {"text": "You can also use a Predicate<Pojo> and a filter", "label": {"api": {"filter": [[41, 46]]}}}, {"text": "The key to this is creating a class that implements the Icon interface", "label": {"api": {"Icon": [[56, 59]]}}}, {"text": "Override the icon's paintIcon() method, which receives the suitable graphics context, and do your rendering there", "label": {"api": {"Icon": [[25, 28]], "paintIcon()": [[20, 30]]}}}, {"text": "A Java short is 16 bit, and the DataBufferUShort is made for storing unsigned 16 bit values", "label": {"api": {"DataBufferUShort": [[32, 47]]}}}, {"text": "It looks like you want to look at https://docs.oracle.com/javase/7/docs/api/java/io/ByteArrayInputStream.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/ByteArrayInputStream.html": [[34, 108]]}}}, {"text": "The serialVersionUID is only relevant to classes which generate a stream identifier", "label": {"api": {"stream identifier": [[66, 82]]}}}, {"text": "This is not the case if the serializable class has a writeReplace() method (also described in the Serializable documentation) that returns a substitute object of a different class, as such a representation is fully decoupled from the original class", "label": {"api": {"Serializable documentation": [[98, 123]]}}}, {"text": "This is what happens with serializable lambda instances, see SerializedLambda", "label": {"api": {"SerializedLambda": [[61, 76]]}}}, {"text": "One means to do so is to ensure that the writeReplace method returns an instance of SerializedLambda, rather than allowing default serialization to proceed", "label": {"api": {"SerializedLambda": [[84, 99]]}}}, {"text": "So it’s an instance of SerializedLambda that ends up on the stream and thus the responsibility of that class to have a stable serialized representation", "label": {"api": {"SerializedLambda": [[23, 38]]}}}, {"text": "Specifically in your example this is further compounded by the fact that List.subList is a view on the underlying list", "label": {"api": {"List.subList": [[73, 84]]}}}, {"text": "If insertion order from the names array is important, keep adding the objects to a LinkedHashSet<String>, then with either a for loop or enhanced for loop or iterator, go over your list of names and add each of them to the LinkedHashSet", "label": {"api": {"LinkedHashSet<String>": [[83, 103]]}}}, {"text": "You can do this with java.nio.channels.AsychronousSocketChannel and friends", "label": {"api": {"java.nio.channels.AsychronousSocketChannel": [[21, 62]]}}}, {"text": "As pointed out in the comments, I missed out on the redirectErrorStream(boolean) method that allows me to pipe stderr to stdout internally, so there's only one stream to deal with", "label": {"api": {"redirectErrorStream(boolean)": [[52, 79]]}}}, {"text": "You can use jdk.nashorn.api.scripting.URLReader ( https://docs.oracle.com/javase/8/docs/jdk/api/nashorn/jdk/nashorn/api/scripting/URLReader.html ) which wraps a URL as a Reader", "label": {"api": {"https://docs.oracle.com/javase/8/docs/jdk/api/nashorn/jdk/nashorn/api/scripting/URLReader.html": [[50, 143]]}}}, {"text": "One solution, using getHours, getMinutes on the timestamps", "label": {"api": {"getHours": [[20, 27]], "getMinutes": [[30, 39]]}}}, {"text": "I'm not going to solve this for you since it sounds like a learning assignment, so instead I suggest you look closer at FileOutputStream and DataOutputStream", "label": {"api": {"FileOutputStream": [[120, 135]], "DataOutputStream": [[141, 156]]}}}, {"text": "Have you had a look at the methods that HttpURLConnection offers", "label": {"api": {"HttpURLConnection": [[40, 56]]}}}, {"text": "class RSAPublicKeySpec supports at least a part of the implementation that you're looking for", "label": {"api": {"class RSAPublicKeySpec": [[0, 21]]}}}, {"text": "Use a CustomMenuItem, setHideOnClick and a CheckBox in the constructor", "label": {"api": {"CustomMenuItem": [[6, 19]], "setHideOnClick": [[22, 35]]}}}, {"text": "The javadoc states that File.pathSeparatorChar is", "label": {"api": {"File.pathSeparatorChar": [[24, 45]]}}}, {"text": "You can simplify this and solve the problem using computeIfAbsent from Java 8", "label": {"api": {"computeIfAbsent": [[50, 64]]}}}, {"text": "this code assumes that there is a value; otherwise, use .orElse(); see the javadoc of Optional for more details)", "label": {"api": {"javadoc of Optional": [[75, 93]]}}}, {"text": "Use Thread.currentThread().getStackTrace() to get stack trace - there you can find all function calls in current thread", "label": {"api": {"Thread.currentThread().getStackTrace()": [[4, 41]]}}}, {"text": "Your best bet here is to \"do it yourself\" by implementing instances of FileTypeDetectors", "label": {"api": {"FileTypeDetectors": [[71, 87]]}}}, {"text": "When you have this, you can then just use Files.probeContentType() to have a string returned which describes the file contents as a MIME type", "label": {"api": {"Files.probeContentType()": [[42, 65]]}}}, {"text": "If you're using Java 8, you can directly use Map#merge() method to avoid that extra testing", "label": {"api": {"Map#merge()": [[45, 55]]}}}, {"text": "A Task represents a one-off task that is intended to run in a background thread", "label": {"api": {"Task": [[2, 5]]}}}, {"text": "Each Task instance can only be executed once", "label": {"api": {"Task": [[5, 8]]}}}, {"text": "A Service has similar functionality to a Task but is intended to be reusable", "label": {"api": {"Task": [[41, 44]], "Service": [[2, 8]]}}}, {"text": "It works by creating and managing Task instances (via a createTask() method, which you need to implement) and executing them on one or more background threads", "label": {"api": {"Task": [[34, 37], [62, 65]]}}}, {"text": "A ScheduledService is a Service which can generate its Tasks at specified time intervals", "label": {"api": {"Task": [[55, 58]], "Service": [[11, 17], [24, 30]]}}}, {"text": "since this is a single thread running for the duration of your application, it is ill-suited to a Task (which is designed to execute and return a value) or Service (which is effectively just a collection of Tasks)", "label": {"api": {"Task": [[98, 101], [207, 210]], "Service": [[156, 162]]}}}, {"text": "For this, you might consider using a ScheduledService to poll the devices at regular intervals, or you might simply create a thread and execute it in the background", "label": {"api": {"Service": [[46, 52]]}}}, {"text": "If you use a ScheduledService, you can do this using the callback methods on the service, or on the tasks it creates", "label": {"api": {"Service": [[22, 28]]}}}, {"text": "Create an Executor suitable for your needs (or more than one if appropriate)", "label": {"api": {"Create an Executor": [[0, 17]]}}}, {"text": "I think for web apps you can use web.xml.And for other you should use Properties class to read and write settings", "label": {"api": {"Properties": [[70, 79]]}}}, {"text": "If you use a ServerSocket, you have to use the three-argument constructor to do that; the third argument is then the listening address for this socket", "label": {"api": {"three-argument constructor": [[47, 72]]}}}, {"text": "As an alternative, you may make your global variable an AtomicInteger, which handles atomic updates for you", "label": {"api": {"AtomicInteger": [[56, 68]]}}}, {"text": "For this case, i will use Optimistic lock in your bids objects..", "label": {"api": {"Optimistic lock": [[26, 40]]}}}, {"text": "See the docs for usage example and more", "label": {"api": {"the docs for usage example and more": [[4, 38]]}}}, {"text": "For the following cases, assume that the dispatch() method calls Dispatch.invokeAsync(T msg, AsyncHandler handler) and returns a Future", "label": {"api": {"Dispatch.invokeAsync(T msg, AsyncHandler handler)": [[65, 113]], "Future": [[129, 134]]}}}, {"text": "You can either make User Comparable and have it's natural ordering by age", "label": {"api": {"Comparable": [[25, 34]]}}}, {"text": "Or explicitly specify a Comparator when you're sorting", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "This is working as designed - only the segment i am is replaced with she is because this is how the String.replace works", "label": {"api": {"String.replace": [[100, 113]]}}}, {"text": "The ManagedExecutorService exists in JEE7 to handle the execution of asynchronous tasks", "label": {"api": {"ManagedExecutorService": [[4, 25]]}}}, {"text": "By leveraging a Future interface implementation (see FutureTask) a task can be made cancellable as well", "label": {"api": {"Future": [[16, 21], [53, 58]], "FutureTask": [[53, 62]]}}}, {"text": "For example the ManagedTask interface provides access to some of these behaviors", "label": {"api": {"ManagedTask": [[16, 26]]}}}, {"text": "The ManagedExecutorService is leveraged for the @Asynchronous EJB method annotation as mentioned in the answer by MGolovanov", "label": {"api": {"ManagedExecutorService": [[4, 25]]}}}, {"text": "The task creation and Future instance creation is handled by the EJB framework", "label": {"api": {"Future": [[22, 27]]}}}, {"text": "Seemingly, you can use Class.cast(Object) since you have the Class<T> already", "label": {"api": {"Class.cast(Object)": [[23, 40]]}}}, {"text": "See the ImageWriter.write API doc for further information", "label": {"api": {"ImageWriter.write API doc": [[8, 32]]}}}, {"text": "Unfortunately oracle docs also has used the same terminology and called it \"rehashing\"", "label": {"api": {"oracle docs": [[14, 24]]}}}, {"text": "To split the file in several \"line sub files\", use the read method of the BufferedReader class", "label": {"api": {"read": [[55, 58]]}}}, {"text": "To merge them, open all the files and keep a separate buffer (a small one, like 2 mb each) for every one of them, read the first chunk of every file and there you'll have enough information to start rearranging the index of the files", "label": {"api": {"read": [[114, 117]]}}}, {"text": "Keep reading chunks if some of the files have ties", "label": {"api": {"read": [[5, 8]]}}}, {"text": "For Java 6 and earlier, there is no X (J6 doc), and since the result of X may or may not do what you want, I strongly recommend you just insert that colon yourself", "label": {"api": {"J6 doc": [[39, 44]]}}}, {"text": "split the String according to space(s), iterate over the resulted array  and increment the counter when you match the String you're looking for", "label": {"api": {"split": [[0, 4]]}}}, {"text": "use a regex that matches exactly the word you're looking for, there are many useful methods in the Matcher and Pattern classes, go through them", "label": {"api": {"Matcher": [[99, 105]], "Pattern": [[111, 117]]}}}, {"text": "Use that and .set() the content you want at the correct index", "label": {"api": {".set()": [[13, 18]]}}}, {"text": "The solution is to wrap the content inside a ScrollPane which automatically manages the scrolling if the content inside grows or shrinks", "label": {"api": {"ScrollPane": [[45, 54]]}}}, {"text": "If you want other sprites to move in sync with your sprite you can create a TimerTask and use scheduleAtFixedRate()", "label": {"api": {"scheduleAtFixedRate()": [[94, 114]]}}}, {"text": "I suggest you to take a look at how to animate a JComponent using Swing Timer class, instead of for loop", "label": {"api": {"Swing Timer class": [[66, 82]]}}}, {"text": "Probably the easiest way to accomplish this is to use Thread#sleep(long)", "label": {"api": {"Thread#sleep(long)": [[54, 71]]}}}, {"text": "You can take a look at the indexOf(String string), which returns an integer denoting the position of the substring, or -1 if not found", "label": {"api": {"indexOf(String string)": [[27, 48]]}}}, {"text": "For more information, see String.getBytes()", "label": {"api": {"String.getBytes()": [[26, 42]]}}}, {"text": "You should be using java.beans.Introspector API to introspect the bean and invoke getters/setters on bean instances", "label": {"api": {"java.beans.Introspector API": [[20, 46]]}}}, {"text": "Check this out Why not try checking if orderBy == null if it does then add your default values to orderBy", "label": {"api": {"Check this out": [[0, 13]]}}}, {"text": "The JDK subclasses EnumSet, HashSet, and TreeSet use these implementations of equals and hashCode, the API documentation lists them under Methods inherited from class java.util.AbstractSet", "label": {"api": {"EnumSet": [[19, 25]], "HashSet": [[28, 34]], "TreeSet": [[41, 47]]}}}, {"text": "You can do this using the SequenceInputStream constructor overload that accepts an Enumeration", "label": {"api": {"SequenceInputStream constructor overload": [[26, 65]]}}}, {"text": "I have used hashCode() method from String API and it is generating value as 99162322 for the below code", "label": {"api": {"hashCode()": [[12, 21]]}}}, {"text": "Take a look at the ArrayList API for other methods that may help you", "label": {"api": {"ArrayList API": [[19, 31]]}}}, {"text": "The best idea I have is to have SystemA/SystemB/SystemC call TransactionSynchronizationRegistry.registerInterposedSynchronization, and then you can be notified when the transaction is rolling back (since the EJB container will roll back transactions automatically if a system exception or application with rollback=true is thrown), and then you can try to undo whatever", "label": {"api": {"TransactionSynchronizationRegistry.registerInterposedSynchronization": [[61, 128]]}}}, {"text": "You can solve this with @XmlID/@XmlIDREF", "label": {"api": {"@XmlID": [[24, 29], [31, 36]], "@XmlIDREF": [[31, 39]]}}}, {"text": "instead of getting all <transaction> elements from the root DOM node,  use the getChildNodes() method on each <client> Element node--this will return only the transactions that pertain to that client", "label": {"api": {"getChildNodes()": [[79, 93]]}}}, {"text": "You can addAll of the ObservableList", "label": {"api": {"addAll": [[8, 13]]}}}, {"text": "The method argument should have type Object (not Cellphone) in order to properly override Object.equals(), which is what you should be doing", "label": {"api": {"Object.equals()": [[90, 104]]}}}, {"text": "Finally, if you override equals, you should also override Object.hashCode(), so that the hash code is calculated from the same fields that are used for equality comparison", "label": {"api": {"Object.hashCode()": [[58, 74]]}}}, {"text": "You're trying to pass grandTotal as the message type of showMessageDialog", "label": {"api": {"showMessageDialog": [[56, 72]]}}}, {"text": "One approach is to use Hue-Saturation-Brightness color values using getHSBColor(), and change the hue based on the number of iterations before it escapes, e.g", "label": {"api": {"getHSBColor()": [[68, 80]]}}}, {"text": "If you are creating a plug-in mechanism, providing metadata in a well-known location is more efficient, reliable, and works with any valid class loader", "label": {"api": {"providing metadata in a well-known location": [[41, 83]]}}}, {"text": "The serialVersionUID can be overriden, but only with static final long serialVersionUID value which would require me to remember to change it when I change class's properties", "label": {"api": {"serialVersionUID can be overriden": [[4, 36]]}}}, {"text": "BigInteger is designed for this", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "Note that, although BigIntegers can be built from byte[] two's complement, and can be converted to those byte[]s again, internally they are using a more-efficient int[] representation", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "Use Swing Timer component for repetitive tasks with Swing GUI toolkit", "label": {"api": {"Swing Timer": [[4, 14]]}}}, {"text": "You must parse the String to an Integer using Integer.valueOf(String s)", "label": {"api": {"Integer.valueOf(String s)": [[46, 70]]}}}, {"text": "The Timer class provided by the Swing package should do what you need", "label": {"api": {"Timer": [[4, 8]]}}}, {"text": "Here is another solution using java.lang.Thread", "label": {"api": {"java.lang.Thread": [[31, 46]]}}}, {"text": "If you do not want the table itself to be wider than 4 x 100px, can you not set the maximum size of the table as well (http://docs.oracle.com/javase/7/docs/api/javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension))", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension)": [[119, 221]]}}}, {"text": "an option would be not to disable the validation with set-jaxb-validation-handler, and rather subclass ValidationEventHandler", "label": {"api": {"ValidationEventHandler": [[103, 124]]}}}, {"text": "first, this webservice is configured with annotations, and I can't seem to find a way to apply a ValidationEventHandler with annotations (same question as", "label": {"api": {"ValidationEventHandler": [[97, 118]]}}}, {"text": "How to set custom ValidationEventHandler on JAXB unmarshaller when using annotations)", "label": {"api": {"ValidationEventHandler": [[18, 39]]}}}, {"text": "Other possible solution is to use KeyStore, which allows you to store sensitive information in publicly accessible format", "label": {"api": {"KeyStore": [[34, 41]]}}}, {"text": "A StackOverflowError is pretty undramatic to catch - it's thrown when the maximum stack depth is exceeded, and since it then starts popping the call stack, it's no longer a problem (unless you try calling the offending method again)", "label": {"api": {"StackOverflowError": [[2, 19]]}}}, {"text": "Other errors, like OutOfMemoryError, are somewhat more problematic - there will still be too much memory used after it's been thrown", "label": {"api": {"OutOfMemoryError": [[19, 34]]}}}, {"text": "Some are directly fatal, like ClassFormatError, which means that you're trying to load a broken class file (and it's usually thrown in places where you can't catch it)", "label": {"api": {"ClassFormatError": [[30, 45]]}}}, {"text": "AssertionError, for example, is thrown when a programmer-defined condition (like assert answer == 42;) isn't met, but only if you've enabled assertions", "label": {"api": {"AssertionError": [[0, 13]]}}}, {"text": "URLConnection treats the value of Content-Length as an int in Java 1.6 and earlier or a long in Java 1.7 and later, which would suggest that the maximum supported number of bytes in the body would be 2^31-1 bytes or 2^63-1 bytes, respectively, so long as Content-Length is being set", "label": {"api": {"Java 1.6": [[62, 69]], "Java 1.7": [[96, 103]]}}}, {"text": "You can use SwingUtilities.invokeLater(Runnable) to execute a Runnable in the EDT", "label": {"api": {"SwingUtilities.invokeLater(Runnable)": [[12, 47]]}}}, {"text": "Yeah, you can do this pretty easily you just need to use boundaries, which is what you're trying to describe with", "label": {"api": {"boundaries": [[57, 66]]}}}, {"text": "If you want to compare to an external entity, use a Comparator implementation and pass it to Collections.sort(List, Comparator)", "label": {"api": {"Collections.sort(List, Comparator)": [[93, 126]]}}}, {"text": "You should look into KeyListener, or the much better solution KeyBindings", "label": {"api": {"KeyListener": [[21, 31]]}}}, {"text": "I have more experience using KeyListener so that is what I used in my example", "label": {"api": {"KeyListener": [[29, 39]]}}}, {"text": "This KeyListener should be added to your component that is currently in focus, like this", "label": {"api": {"KeyListener": [[5, 15]]}}}, {"text": "Remember that the KeyListener must be added to the component that is currently in focus", "label": {"api": {"KeyListener": [[18, 28]]}}}, {"text": "using the .read()", "label": {"api": {".read()": [[10, 16]]}}}, {"text": "Refer to OutputStreamWriter for an idea of how to change the directory to your liking", "label": {"api": {"OutputStreamWriter": [[9, 26]]}}}, {"text": "Java Strings are encoded in UTF-16 by default", "label": {"api": {"Strings": [[5, 11]]}}}, {"text": "As suggested in the comments, you'd do better to just store the encrypted bytes as bytes, and not convert them to Strings until they're decrypted", "label": {"api": {"Strings": [[114, 120]]}}}, {"text": "AtomicLong might interest you too given that you aint using it in an entity class", "label": {"api": {"AtomicLong": [[0, 9]]}}}, {"text": "You can't do that for a number of reasons, not the least of which is that javax.sql.DataSource does not extend java.io.Serializable", "label": {"api": {"javax.sql.DataSource": [[74, 93]], "java.io.Serializable": [[111, 130]]}}}, {"text": "Use a blocking queue to wait for messages", "label": {"api": {"blocking queue": [[6, 19]]}}}, {"text": "When you need to send a message to the server, you can use the blocking queue to send the message", "label": {"api": {"blocking queue": [[63, 76]]}}}, {"text": "For maintaining the connection, use a timer task", "label": {"api": {"timer task": [[38, 47]]}}}, {"text": "For processing the received message, you could have another thread, waiting for messages on another blocking queue (receiver queue)", "label": {"api": {"blocking queue": [[100, 113]]}}}, {"text": "Also, let me remind you of the definition of the substring methods", "label": {"api": {"substring methods": [[49, 65]]}}}, {"text": "Use Stream#max() providing a function for the relevant attribute", "label": {"api": {"Stream#max()": [[4, 15]]}}}, {"text": "Can only iterate over array of java.lang.Iterable", "label": {"api": {"Iterable": [[41, 48]]}}}, {"text": "This means that your class must implement the Iterable interface", "label": {"api": {"Iterable": [[46, 53]]}}}, {"text": "Map offers a get method which take the key as parameter", "label": {"api": {"Map": [[0, 2]], "get": [[13, 15]]}}}, {"text": "So you can simply do rate.get(year)", "label": {"api": {"get": [[26, 28]]}}}, {"text": "If you are using Java 8, then use class java.util.Base64 for Base 64 encoding and decoding", "label": {"api": {"java.util.Base64": [[40, 55]]}}}, {"text": "If the application is installed, you can try Desktop.print()", "label": {"api": {"Desktop.print()": [[45, 59]]}}}, {"text": "I found this http://docs.oracle.com/javaee/5/api/javax/xml/bind/JAXBContext.html, so I presume that is compatibile with Java5, but when I try to look for this class in Eclipse I can't find it", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/xml/bind/JAXBContext.html": [[13, 79]]}}}, {"text": "And before passing it to the Graph API convert it back to Numbers[] array with toArray()", "label": {"api": {"toArray()": [[79, 87]]}}}, {"text": "Reading OneToMany.ophanRemoval, you can try this", "label": {"api": {"OneToMany.ophanRemoval": [[8, 29]]}}}, {"text": "I would suggest you to use a TimeLine where you can specify the cycleCount which you can set to INDEFINITE", "label": {"api": {"TimeLine": [[29, 36]], "INDEFINITE": [[96, 105]]}}}, {"text": "I am using a servlet to store the AsyncContexts in a Hashmap", "label": {"api": {"AsyncContexts": [[34, 46]], "Hashmap": [[53, 59]]}}}, {"text": "You could use the @javax.persistence.OrderBy annotation", "label": {"api": {"@javax.persistence.OrderBy": [[18, 43]]}}}, {"text": "Using a loop is how you can fill each of the inner arrays separately, but Arrays.fill handles the inner loop for you", "label": {"api": {"Arrays.fill": [[74, 84]]}}}, {"text": "Make sure to validate there's a line to be read before using Scanner#nextLine", "label": {"api": {"Scanner#nextLine": [[61, 76]]}}}, {"text": "Use static sort method of Arrays class like", "label": {"api": {"sort": [[11, 14]]}}}, {"text": "if you look in the java documentation at Scanner.Next() you'll notice that next only returns the next token", "label": {"api": {"Scanner.Next()": [[41, 54]]}}}, {"text": "One kind is encounter order, which is defined in the streams documentation", "label": {"api": {"streams documentation": [[53, 73]]}}}, {"text": "The following version is based on the API docs, but it is untested", "label": {"api": {"API docs": [[38, 45]]}}}, {"text": "I am trying to get the UTC milliseconds to convert a Joda DateTime instance to a SQL Timestamp, however it is converting it to my local time instead", "label": {"api": {"SQL Timestamp": [[81, 93]]}}}, {"text": "Yes you can set a drag view (arbitrary image) for a drag and drop operation", "label": {"api": {"set a drag view": [[12, 26]]}}}, {"text": "AudioFormat.Encoding lists the encodings supported by javax.sound.sampled", "label": {"api": {"AudioFormat.Encoding": [[0, 19]]}}}, {"text": "But for better performance I'd advice you to use PreparedStatement", "label": {"api": {"PreparedStatement": [[49, 65]]}}}, {"text": "Also you would benefit if сarry out PreparedStatement constructor, too", "label": {"api": {"PreparedStatement": [[36, 52]]}}}, {"text": "Otherwise, have a look at Scanner", "label": {"api": {"Scanner": [[26, 32]]}}}, {"text": "It looks like you are storing the Blocks in a list, in that case the idiomatic way would be to use the Stream API", "label": {"api": {"Stream API": [[103, 112]]}}}, {"text": "Just before using scanner.next(), try to test if you have things to read next string token using hasNext api like", "label": {"api": {"hasNext": [[97, 103]]}}}, {"text": "As described in Map interface documentation Map contains a set of keys, so it is not capable of containing multiple non-unique keys", "label": {"api": {"Map interface documentation": [[16, 42]]}}}, {"text": "You should probably check if you have data to consumer using hasNextInt like", "label": {"api": {"hasNextInt": [[61, 70]]}}}, {"text": "Get the ServletContext", "label": {"api": {"Get the ServletContext": [[0, 21]]}}}, {"text": "Then get the resource as a stream", "label": {"api": {"get the resource as a stream": [[5, 32]]}}}, {"text": "The java SE apidoc describes all the classes in java SE", "label": {"api": {"apidoc": [[12, 17]]}}}, {"text": "You can use Scanner, reading lines with nextLine(), splitting them with split(\" \"), and using Integer.parseInt() to parse to an integer", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "For example, what's the quickest way to determine whether Math.abs() will generally be converted directly to a few native instructions wherever it is used", "label": {"api": {"Math.abs()": [[58, 67]]}}}, {"text": "If you are adding elements to a List, you can use the contains() method; if not, you should write a comparable method that traverses your Node data structure", "label": {"api": {"List": [[32, 35]]}}}, {"text": "Alternatively, you might want to consider adding elements to a Set, which precludes duplicates", "label": {"api": {"Set": [[63, 65]]}}}, {"text": "TreeSet may a good concrete implementation, as it remains ordered", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "You could use Runtime.totalMemory() which (per the Javadoc) returns the total amount of memory in the Java virtual machine", "label": {"api": {"Runtime.totalMemory()": [[14, 34]]}}}, {"text": "The number that you are trying to parse is larger than the maximum value an Integer can hold.", "label": {"api": {"maximum value an Integer can hold.": [[59, 92]]}}}, {"text": "You can convert your String to a long using the Long#parseLong() method", "label": {"api": {"Long#parseLong()": [[48, 63]]}}}, {"text": "equals() should take Object as argument, to match the super method it overrides", "label": {"api": {"equals()": [[0, 7]]}}}, {"text": "You are using the FlexiCore specific RC5ParameterSpec, try and use the Java JCA one instead", "label": {"api": {"Java JCA one instead": [[71, 90]]}}}, {"text": "Using String.format you can achieve what you need", "label": {"api": {"String.format": [[6, 18]]}}}, {"text": "Since replaceAll expects the string to define a regular expression, and + is special in regular expressions, your \"0+1\" means \"The digit 0 one or more times, followed by the digit 1\" and would match \"01\", \"001\", \"00001\", etc", "label": {"api": {"replaceAll": [[6, 15]], "replace": [[6, 12]]}}}, {"text": "To just specify a string meant to be used literally, use replace, not replaceAll", "label": {"api": {"replaceAll": [[70, 79]], "replace": [[57, 63], [70, 76]]}}}, {"text": "ImageIcon has a constructor that allows the user to create an ImageIcon straight from the file", "label": {"api": {"constructor": [[16, 26]]}}}, {"text": "In my case, I'm invoking a JavaFX dialogue from a Swing component; more specifically a FileChooser", "label": {"api": {"FileChooser": [[87, 97]]}}}, {"text": "I tried using setEnabled(false) and setEnabled(true), but this has a strange side effect", "label": {"api": {"setEnabled(false)": [[14, 30]]}}}, {"text": "JavaFX has a javafx.concurrent API; in particular, the Task class fits your use case very nicely", "label": {"api": {"Task": [[55, 58]]}}}, {"text": "For example, Task is an implementation of FutureTask, so it can be submitted to an Executor", "label": {"api": {"Task": [[13, 16], [48, 51]], "FutureTask": [[42, 51]], "Executor": [[83, 90]]}}}, {"text": "As you want to use a thread pool, you can create an Executor that implements a thread pool for you, and submit your tasks to it", "label": {"api": {"Executor": [[52, 59]]}}}, {"text": "To implement the actual Task, there are a few things to bear in mind", "label": {"api": {"Task": [[24, 27]]}}}, {"text": "Since your Task is submitted to the executor above, it's call() method will be invoked on a background thread", "label": {"api": {"Task": [[11, 14]]}}}, {"text": "In particular, the Task has a set of updateXXX(...) methods that change the values of corresponding Task properties on the FX Application thread", "label": {"api": {"Task": [[19, 22], [100, 103]]}}}, {"text": "Instantiate your Task subclass setting only final variables, have the call() method compute a value, and return the value", "label": {"api": {"Task": [[17, 20]]}}}, {"text": "For canceling the Task, the Task class defines a built-in cancel() method", "label": {"api": {"Task": [[18, 21], [28, 31]]}}}, {"text": "Note that the Optional.empty() and Optional.of(....) are factory methods that create appropriate instances of the Optional", "label": {"api": {"Optional.empty()": [[14, 29]], "Optional.of(....)": [[35, 51]]}}}, {"text": "In java 8, you can obtain an IntStream and get the summary statistics", "label": {"api": {"summary statistics": [[51, 68]]}}}, {"text": "Something like ConcurrentSkipListMap does have an ordering, it's sorted by the order of the keys as defined by a Comparator", "label": {"api": {"ConcurrentSkipListMap": [[15, 35]]}}}, {"text": "The easiest way, using Thread.sleep()", "label": {"api": {"Thread.sleep()": [[23, 36]]}}}, {"text": "And, more formally the output buffer isn't fully flushed until you OutputStream.close() actually releases any system resources associated with this stream", "label": {"api": {"flush": [[49, 53]], "OutputStream.close()": [[67, 86]]}}}, {"text": "I think you're looking for Integer.parseInt", "label": {"api": {"Integer.parseInt": [[27, 42]]}}}, {"text": "...or possibly Long.parseLong (with long Value) if there's a possibility that the value will exceed the capacity of an int", "label": {"api": {"Long.parseLong": [[15, 28]]}}}, {"text": "From the docs", "label": {"api": {"From the docs": [[0, 12]]}}}, {"text": "But I would use nextInt and hasNextInt instead, and ignore any character that's not a digit", "label": {"api": {"nextInt": [[16, 22]], "hasNextInt": [[28, 37]]}}}, {"text": "You should use public String(byte[] bytes) constructor", "label": {"api": {"public String(byte[] bytes)": [[15, 41]]}}}, {"text": "Note that I'm applying the String#equalsIgnoreCase() method on \"test\", but not on the user variable, in order to avoid a possible NullPointerException", "label": {"api": {"String#equalsIgnoreCase()": [[27, 51]]}}}, {"text": "If you have your own implementation, make sure you followed the Object.equals()-Contract", "label": {"api": {"Object.equals()-Contract": [[64, 87]]}}}, {"text": "Assuming the task is scheduled at a fixed rate via the ScheduledExecutorService, change the task to a self-scheduling task", "label": {"api": {"ScheduledExecutorService": [[55, 78]]}}}, {"text": "Check out ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[10, 27]]}}}, {"text": "In some cases, operations on a component are done under a tree lock (Swing makes sure they are thread-safe on their own), but in some cases they are not", "label": {"api": {"tree lock": [[58, 66]]}}}, {"text": "I am executing an .exe-file from java, using the ProcessBuilder class and the Process class", "label": {"api": {"ProcessBuilder": [[49, 62]], "Process": [[49, 55], [78, 84]]}}}, {"text": "Yet you can use Collections.addAll, that takes an array as second argument", "label": {"api": {"Collections.addAll": [[16, 33]]}}}, {"text": "Collections#emptyXyz, in this case Collections#emptySet, returns an immutable empty collection for the determined interface", "label": {"api": {"Collections#emptySet": [[35, 54]]}}}, {"text": "You could use a Pattern to apply a regular expression", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "The contract for the containsKey method states that it may throw a ClassCastException \"if the key is of an inappropriate type for this map.\"  So my answer is not viable", "label": {"api": {"contract for the containsKey method": [[4, 38]]}}}, {"text": "You should never use FileReader", "label": {"api": {"FileReader": [[21, 30]]}}}, {"text": "That link is also present in the documentation for the Charset class", "label": {"api": {"Charset": [[55, 61]]}}}, {"text": "You need the set method, which takes an index and the new value for that index", "label": {"api": {"set method": [[13, 22]]}}}, {"text": "Use the DataOutputStream::write() method to make it a binary protocol without encoding it", "label": {"api": {"DataOutputStream::write()": [[8, 32]]}}}, {"text": "Please read the documentation for System.exit()", "label": {"api": {"System.exit()": [[34, 46]]}}}, {"text": "If you want to get uniformly distributed random integers, check out Random.nextInt()", "label": {"api": {"Random.nextInt()": [[68, 83]]}}}, {"text": "If you wish to convert an array into a String, use the Arrays class", "label": {"api": {"Arrays": [[55, 60]]}}}, {"text": "If using Arrays.toString, you can parse the returned String using the methods provided in the String class", "label": {"api": {"Arrays": [[9, 14]]}}}, {"text": "In Java 8, you could do this using Stream.flatMap()", "label": {"api": {"Stream.flatMap()": [[35, 50]]}}}, {"text": "If you can't use Java 8, you could use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[39, 56]]}}}, {"text": "We should distinguish between javax.persistence.Transient and java.beans.Transient", "label": {"api": {"javax.persistence.Transient": [[30, 56]], "java.beans.Transient": [[62, 81]]}}}, {"text": "where Java7SupportImpl#findTransient(Annotated) is looking for java.beans.Transient", "label": {"api": {"java.beans.Transient": [[63, 82]]}}}, {"text": "You can have a look at Arrays.copyOf method", "label": {"api": {"Arrays.copyOf": [[23, 35]]}}}, {"text": "As Collections.shuffle(..) (in java.util) has return type void - the passed in list becomes shuffled, a new list is not created", "label": {"api": {"Collections.shuffle(..) (in java.util) has return type void": [[3, 61]]}}}, {"text": "You should use LinkedHashMap in place of HashMap(where the order of inserts is not guaranteed to be preserved)if you want the order of your inserts", "label": {"api": {"LinkedHashMap": [[15, 27]], "HashMap": [[21, 27], [41, 47]]}}}, {"text": "Since you are fetching the records in an order and inserting that in a HashMap, the records are inserted in a random order, since it is passed through a hashfunction", "label": {"api": {"HashMap": [[71, 77]]}}}, {"text": "You could throw an IllegalStateException", "label": {"api": {"IllegalStateException": [[19, 39]]}}}, {"text": "The more modern approach would be to return an Optional<Integer> which is the recommended way in Java 8 to avoud null returns", "label": {"api": {"Optional<Integer>": [[47, 63]]}}}, {"text": "According to the Java API, attempting to pop an element from an empty stack should yield an exception", "label": {"api": {"Java API": [[17, 24]]}}}, {"text": "Assuming that you have the String you posted, you can use String#replace", "label": {"api": {"String#replace": [[58, 71]]}}}, {"text": "Both Joda-Time and the new java.time package in Java 8 largely use immutable objects", "label": {"api": {"java.time": [[27, 35]]}}}, {"text": "If it is no longer attached, you can re-attach it using merge", "label": {"api": {"merge": [[56, 60]]}}}, {"text": "Assuming you're using the MimeMessage getSentDate or getReceivedDate methods, you'll get a Date object that's already properly converted", "label": {"api": {"Date": [[45, 48], [64, 67], [91, 94]]}}}, {"text": "You just need to format and display the date however you want, e.g., using SimpleDateFormat", "label": {"api": {"Date": [[81, 84]], "SimpleDateFormat": [[75, 90]]}}}, {"text": "More info on that in the API", "label": {"api": {"the API": [[21, 27]]}}}, {"text": "I would first use Java API", "label": {"api": {"Java API": [[18, 25]]}}}, {"text": "The closest fit may be an IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[26, 49]]}}}, {"text": "The S format character for SimpleDateFormat means milliseconds, not microseconds", "label": {"api": {"S format character for SimpleDateFormat": [[4, 42]]}}}, {"text": "Parse the numbers currently contained in strings", "label": {"api": {"Parse": [[0, 4]]}}}, {"text": "The @DefaultProperty annotation is a class-level annotation (@Target(value=TYPE) in the documentation) with a required value attribute specifying the name of the property", "label": {"api": {"@DefaultProperty": [[4, 19]]}}}, {"text": "So even with the @DefaultProperty annotation, I don't think you can make this work without making the getChildren() method public, as above", "label": {"api": {"@DefaultProperty": [[17, 32]]}}}, {"text": "The documentation for KeyPairGenerator says that the initialize(int, SecureRandom) does this", "label": {"api": {"documentation for KeyPairGenerator": [[4, 37]]}}}, {"text": "new Random() returns a random number generator, which is a Java object (this is why you get java.util.Random@15db9742 if you try to convert it to a string)", "label": {"api": {"java.util.Random": [[92, 107]]}}}, {"text": "See java.util.Random on the API spec (linked version is Java 8)", "label": {"api": {"java.util.Random": [[4, 19]]}}}, {"text": "If you need to do this through Java then you could invoke the above command using Java's Runtime class", "label": {"api": {"Runtime": [[89, 95]]}}}, {"text": "However, I would consider using a BlockingQueue so that your threads do not run amock", "label": {"api": {"BlockingQueue": [[34, 46]]}}}, {"text": "In particular, see the concurrent package documentation", "label": {"api": {"concurrent package documentation": [[23, 54]]}}}, {"text": "This is documented in the API documentation for SimpleDateFormat under the heading Synchronization", "label": {"api": {"API documentation for SimpleDateFormat": [[26, 63]]}}}, {"text": "Using the approach shown here, you can specify an AttributedString for the desired axis label", "label": {"api": {"AttributedString": [[50, 65]]}}}, {"text": "Given a NumberAxis named domain, the example below uses TextAttribute values to alter the SIZE and WEIGHT of some characters, subscripts the second character and superscripts the exponent", "label": {"api": {"TextAttribute": [[56, 68]]}}}, {"text": "First, notice that Collections.sort(List<T>) simply delegates to Arrays.sort(Object[]) (source)", "label": {"api": {"Collections.sort(List<T>)": [[19, 43]], "Arrays.sort(Object[])": [[65, 85]]}}}, {"text": "You'll notice the documentation for the primitive sort methods, like Arrays.sort(int[]), says nothing about the stability of these sorting methods, because such a detail is meaningless", "label": {"api": {"Arrays.sort(int[])": [[69, 86]]}}}, {"text": "Java has ScheduledExecutorService that does this for you", "label": {"api": {"ScheduledExecutorService": [[9, 32]]}}}, {"text": "ByteArrayOutputStream.toByteArray just copies what it has in the buffer; it's not reading anything more from the stream", "label": {"api": {"ByteArrayOutputStream.toByteArray": [[0, 32]]}}}, {"text": "Once the Server is started, and the SslContextFactory has been started (via its lifecycle), then the SSLEngine is used for the source of this information", "label": {"api": {"SSLEngine": [[101, 109]]}}}, {"text": "You might consider moving from a ThreadPoolExecutor to a ScheduledThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[33, 50], [66, 83]], "ScheduledThreadPoolExecutor": [[57, 83]]}}}, {"text": "The difference is, that for all the tasks you enqueue, you'll get a Future<T>", "label": {"api": {"Future<T>": [[68, 76]]}}}, {"text": "See the API", "label": {"api": {"API": [[8, 10]]}}}, {"text": "This uses the Car constructor as a method reference to the new Map.computeIfAbsent method, which calls it if a Car of that colour is not already present in the Map", "label": {"api": {"Map.computeIfAbsent": [[63, 81]]}}}, {"text": "Have a look at the Integer class and its factory method valueOf", "label": {"api": {"Integer": [[19, 25]], "valueOf": [[56, 62]]}}}, {"text": "JFrame has BorderLayout by default, which makes add(Component) method to add component always to center part of frame by default, replacing any components already put there", "label": {"api": {"BorderLayout": [[11, 22]]}}}, {"text": "Put your items into JList and put the JList inside a scrollbar", "label": {"api": {"JList": [[20, 24], [38, 42]]}}}, {"text": "Rather use NumberFormat for parsing", "label": {"api": {"NumberFormat": [[11, 22]]}}}, {"text": "I fixed a similar problem using BlockingDeque(Link, first in, first out)", "label": {"api": {"Link": [[46, 49]]}}}, {"text": "If so, you can use Timer class, just create TimerTask and schedule it at fixed rate", "label": {"api": {"Timer": [[19, 23], [44, 48]], "TimerTask": [[44, 52]], "schedule it at fixed rate": [[58, 82]]}}}, {"text": "I have an application which uses java.util.zip library to unzip the file", "label": {"api": {"java.util.zip": [[33, 45]]}}}, {"text": "Since you are using Java 8 I suggest using the new date/time API, java.time, specifically its YearMonth class", "label": {"api": {"YearMonth": [[94, 102]]}}}, {"text": "Check the canonical path location for the file", "label": {"api": {"canonical path": [[10, 23]]}}}, {"text": "Instead of using byte[], you could use java.nio.ByteBuffer which does allow you to slice a buffer in the way you want to", "label": {"api": {"java.nio.ByteBuffer": [[39, 57]]}}}, {"text": "The method you're trying to use is a member of java.nio.file.Files - but that class (and indeed that package) doesn't exist on Android", "label": {"api": {"method you're trying to use": [[4, 30]], "java.nio.file.Files": [[47, 65]]}}}, {"text": "For this to happen you need a ActionListener", "label": {"api": {"ActionListener": [[30, 43]]}}}, {"text": "Create a custom ActionListener like below (Note I did it for one die)", "label": {"api": {"ActionListener": [[16, 29]]}}}, {"text": "To add your custom ActionListener to the button", "label": {"api": {"ActionListener": [[19, 32]]}}}, {"text": "The ActionListener needs to modify the Jlabels representing the dice, so don't forget to add it as a parameter to the constructor of you listener", "label": {"api": {"ActionListener": [[4, 17]]}}}, {"text": "You can try to use DocumentFilter, for example", "label": {"api": {"DocumentFilter": [[19, 32]]}}}, {"text": "Check the fetchSize of the PreparedStatement", "label": {"api": {"fetchSize": [[10, 18]]}}}, {"text": "According to the Javadocs for UrlInfo.getQueryParameters only \"sequences of escaped octets in parameter names and values are decoded\"", "label": {"api": {"UrlInfo.getQueryParameters": [[30, 55]], "QueryParam": [[41, 50]]}}}, {"text": "On the other hand, QueryParam Javadocs states that \"Values are URL decoded unless this is disabled using the Encoded annotation\"", "label": {"api": {"QueryParam": [[19, 28]], "Encoded": [[109, 115]]}}}, {"text": "The value 677862 is being interpreted as milliseconds, as per the SimpleDateFormat javadocs, not as microseconds", "label": {"api": {"SimpleDateFormat javadocs": [[66, 90]]}}}, {"text": "Using a Scanner would make the code considerably cleaner", "label": {"api": {"Scanner": [[8, 14]]}}}, {"text": "To append a line use this constructor of the java.util.FileWriter", "label": {"api": {"this constructor": [[21, 36]]}}}, {"text": "java.io.File.length() gets you the length of the file denoted by the abstract pathname", "label": {"api": {"length of the file denoted by the abstract pathname": [[35, 85]]}}}, {"text": "A better approach, as my erroneous assumption was pointed out in @Tilo's comment would be to first read the file into a String, and use it's getChars().length method", "label": {"api": {"getChars().length method": [[141, 164]]}}}, {"text": "Try this, using System.arraycopy", "label": {"api": {"System.arraycopy": [[16, 31]]}}}, {"text": "But, you can wrap a Java object by a JSObject implementation (https://docs.oracle.com/javase/8/docs/jdk/api/nashorn/jdk/nashorn/api/scripting/JSObject.html) and filter out specific methods and/or fields", "label": {"api": {"https://docs.oracle.com/javase/8/docs/jdk/api/nashorn/jdk/nashorn/api/scripting/JSObject.html": [[62, 154]]}}}, {"text": "The color of the bars in BarChart are specified with the -fx-bar-fill attribute (which is undocumented in the JavaFX CSS Reference Guide) but furthermore I can not find anywhere in the OpenJFX source where this attribute is specified and looked for, how does this actually work", "label": {"api": {"JavaFX CSS Reference Guide": [[110, 135]]}}}, {"text": "The only method you need to define is the compare method, which compares 2 Items", "label": {"api": {"the compare method": [[38, 55]]}}}, {"text": "Arrays.sort is for arrays, but Collections.sort does the same thing for collections (and it uses Arrays.sort internally anyway)", "label": {"api": {"Collections.sort": [[31, 46]]}}}, {"text": "Pass an instance of your Comparator to a call to Collections.sort, and it will sort your list for you", "label": {"api": {"Collections.sort": [[49, 64]]}}}, {"text": "You can use DecimalFormat (docs here)", "label": {"api": {"docs here": [[27, 35]]}}}, {"text": "Instead of using an explicit for loop, you could use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[53, 70]]}}}, {"text": "We can also call drain to wait for this data to get played back", "label": {"api": {"drain": [[17, 21]]}}}, {"text": "You can use a JScrollPane for that purpose", "label": {"api": {"JScrollPane": [[14, 24]]}}}, {"text": "Files.write will write all lines of an Iterable (which includes Collections) and that’s it", "label": {"api": {"Files.write": [[0, 10]]}}}, {"text": "Otherwise, Files.write will append line-feeds to every string", "label": {"api": {"Files.write": [[11, 21]]}}}, {"text": "Regardless of whether you create your own Writer or use Files.write, these implementations will already report failures regarding existence/non-existence or failed attempts of creating the target file via IOExceptions, so you don’t need to do it yourself", "label": {"api": {"Files.write": [[56, 66]]}}}, {"text": "And use map.get(Object key) method to fetch specific person by id", "label": {"api": {"map.get(Object key)": [[8, 26]]}}}, {"text": "As the file size is very big, ConcurrentHashMap should be a good collection to use", "label": {"api": {"ConcurrentHashMap": [[30, 46]]}}}, {"text": "I checked Krb5LoginModule and it allows for such configuration, but I could not find anything related to Sasl clients", "label": {"api": {"Krb5LoginModule": [[10, 24]]}}}, {"text": "You could also use Files.walkFileTree", "label": {"api": {"Files.walkFileTree": [[19, 36]]}}}, {"text": "Many possibilities such as CountDownLatch, or you can put the join() calls into the run() method of Thread E", "label": {"api": {"CountDownLatch": [[27, 40]]}}}, {"text": "Replace 1000 with Double.MAX_VALUE", "label": {"api": {"Double.MAX_VALUE": [[18, 33]]}}}, {"text": "Essentially, if your class is supposed to implement ActionListener, it should have an actionPerformed(ActionEvent) method", "label": {"api": {"actionPerformed(ActionEvent)": [[86, 113]]}}}, {"text": "The SimpleDateFormat  provides the underlying conventions, as stated in the GsonDoc", "label": {"api": {"SimpleDateFormat ": [[4, 20]]}}}, {"text": "You probably want fillRect", "label": {"api": {"fillRect": [[18, 25]]}}}, {"text": "The jComboBox class provides an addItem method for you", "label": {"api": {"addItem": [[32, 38]]}}}, {"text": "In JavaFX a common way to run code in the background is to use a Task", "label": {"api": {"Task": [[65, 68]]}}}, {"text": "Assuming that the only issue you have with indexOf(String str) is that it returns an integer, and not a boolean, note that as per the Javadoc, if the string is not found, a -1 is returned", "label": {"api": {"indexOf(String str)": [[43, 61]]}}}, {"text": "This can be achieved very simply using String.replaceAll()", "label": {"api": {"String.replaceAll()": [[39, 57]]}}}, {"text": "The answer is in the docs of BufferedWriter#close", "label": {"api": {"BufferedWriter#close": [[29, 48]]}}}, {"text": "It sounds like you are looking for a jSpinner", "label": {"api": {"jSpinner": [[37, 44]]}}}, {"text": "CallableStatement.getInt() doesn't relate to a ResultSet, it relates to an output parameter of a stored procedure", "label": {"api": {"CallableStatement.getInt()": [[0, 25]]}}}, {"text": "The interface java.util.function.Supplier is what you are looking for", "label": {"api": {"java.util.function.Supplier": [[14, 40]]}}}, {"text": "You're looking for a Supplier<T> (docs here)", "label": {"api": {"docs here": [[34, 42]]}}}, {"text": "You can find the default suppliers for primitives in java.util.function", "label": {"api": {"java.util.function": [[53, 70]]}}}, {"text": "From the Javadoc on Integer.parseInt(String s)", "label": {"api": {"Javadoc on Integer.parseInt(String s)": [[9, 45]]}}}, {"text": "Overriding the stop() method from the Application class will allow you to close your console app", "label": {"api": {"stop()": [[15, 20]], "Application": [[38, 48]]}}}, {"text": "There is also a description of what parameter mean on Java EE page", "label": {"api": {"Java EE page": [[54, 65]]}}}, {"text": "Could Function.identity() fit your needs", "label": {"api": {"Function.identity()": [[6, 24]]}}}, {"text": "You should also consider checking out ImageIO to help prevent this problem in your future, it's more robust than the basic constructors", "label": {"api": {"checking out ImageIO": [[25, 44]]}}}, {"text": "Use a DecimalFormat", "label": {"api": {"DecimalFormat": [[6, 18]]}}}, {"text": "Based on the java.util.logging.Logger API and this article, the main reason for getLogger() is to ensure the same Logger and Handler set are used independently between subsystems", "label": {"api": {"java.util.logging.Logger API": [[13, 40]]}}}, {"text": "Why does the below implementation using Iterable.forEach() not compile", "label": {"api": {"Iterable": [[40, 47]]}}}, {"text": "I've checked the Consumer and Iterable documentation, and neither of them seem to suggest how to solve this", "label": {"api": {"Consumer": [[17, 24]], "Iterable": [[30, 37]]}}}, {"text": "I didn't want to modify too much your code so I provide you a sample that replaces the do while loop you were using (it's from the official Timer's javadoc)", "label": {"api": {"Timer's javadoc": [[140, 154]]}}}, {"text": "You can set the delimiter with useDelimiter(String)", "label": {"api": {"useDelimiter(String)": [[31, 50]]}}}, {"text": "To get the right width and height, you have to call Region.prefWidth(-1) and Region.prefHeight(-1)respectively", "label": {"api": {"Region.prefWidth(-1)": [[52, 71]], "Region.prefHeight(-1)": [[77, 97]]}}}, {"text": "JOptionPanes are modal, so you can't do this directly", "label": {"api": {"modal": [[17, 21]]}}}, {"text": "All dialogs are modal", "label": {"api": {"modal": [[16, 20]]}}}, {"text": "The most simple way is to use indexOf to do check operation, it returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element", "label": {"api": {"indexOf": [[30, 36]]}}}, {"text": "But, the most efficient way is not to use indexOf method to do check", "label": {"api": {"indexOf": [[42, 48]]}}}, {"text": "Most I/O and locking operations will interrupt when the thread the run on is interrupted and an InterruptedException is raised in that thread (however, not all operations do so, for example see https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html#acquireUninterruptibly())", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html#acquireUninterruptibly()": [[194, 295]]}}}, {"text": "I recommend to use the Math.atan2 method and shift the range of its angle", "label": {"api": {"Math.atan2": [[23, 32]]}}}, {"text": "The parameter to your constructor is the capacity", "label": {"api": {"constructor": [[22, 32]]}}}, {"text": "Take, for example, Integer", "label": {"api": {"Integer": [[19, 25]]}}}, {"text": "Since both of these fields contain fixed information that would not change between instantiations, it would not make sense to have to instantiate an Integer to get this information", "label": {"api": {"Integer": [[149, 155]]}}}, {"text": "Integer also has the useful operation parseInt, which takes a String and turns it into an int", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "We shouldn't require an instance of Integer to convert from String to int, especially if we're not placing it into an instance of Integer", "label": {"api": {"Integer": [[36, 42], [130, 136]]}}}, {"text": "You can see clearer examples of this in certain Java library classes, like Integer", "label": {"api": {"Integer": [[75, 81]]}}}, {"text": "You can get the rows with String.split and split each row into a character array with String.toCharArray", "label": {"api": {"String.split": [[26, 37]], "String.toCharArray": [[86, 103]]}}}, {"text": "If you need sophisticated mathematics typesetting, you could use something like MathJax in a WebView", "label": {"api": {"WebView": [[93, 99]]}}}, {"text": "To do the bare minimum, AbstractTableModel only requires that getRowCount, getColumnCount and getValueAt are implemented", "label": {"api": {"AbstractTableModel": [[24, 41]]}}}, {"text": "What this does is create a Matcher for your line and the URL-matching Pattern from before", "label": {"api": {"Matcher": [[27, 33]]}}}, {"text": "Then, it loops until #find() returns false (i.e., there are no more matches) and adds the match (with #group()) to the list, urlsFound", "label": {"api": {"#find()": [[21, 27]], "#group()": [[102, 109]]}}}, {"text": "Note that this can get quite memory-intensive if you've got a lot of text, as urlsFound will get quite big, and you'll be creating and ditching a lot of Matchers", "label": {"api": {"Matcher": [[153, 159]]}}}, {"text": "The JDK has ZipOutputStream which can help you there; basically you can use it as such (code to set the HTTP headers not shown)", "label": {"api": {"ZipOutputStream": [[12, 26]]}}}, {"text": "While you may be tempted to just pass one string with quotes as the shell does, the String version of Runtime.exec uses a default StringTokenizer to break up the string, which does not recognize quoted strings", "label": {"api": {"uses a default StringTokenizer to break up the string": [[115, 167]]}}}, {"text": "See also the documentation of CallableStatement", "label": {"api": {"CallableStatement": [[30, 46]]}}}, {"text": "Use a CountDownLatch for that", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "Map is an interface", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "There are several others, such as HashMap, SortedMap, etc", "label": {"api": {"Map": [[38, 40], [49, 51]]}}}, {"text": "implementations, you may find my answer to Java - HashMap vs Map objects here helpful", "label": {"api": {"Map": [[54, 56], [61, 63]]}}}, {"text": "The class java.awt.Robot will be useful for this", "label": {"api": {"java.awt.Robot": [[10, 23]]}}}, {"text": "Swing provides a timer for this sort of thing, have a look at the documentation", "label": {"api": {"timer": [[17, 21]]}}}, {"text": "As others have pointed out, when you're inputting parameters into the query, you should use a PreparedStatement instead of a simple statement with concatenated inputs", "label": {"api": {"PreparedStatement": [[94, 110]]}}}, {"text": "Moreover you should read the Javadoc of Set", "label": {"api": {"Javadoc of Set": [[29, 42]]}}}, {"text": "Regarding your code, I rather suggest that instead of using Random all the time you invoke a shuffle on the cards", "label": {"api": {"shuffle": [[93, 99]]}}}, {"text": "The JavFX way of doing this would be an array of ImageView", "label": {"api": {"ImageView": [[49, 57]]}}}, {"text": "Those you can add to and remove from any Parent how you like (just note that you can't draw the same ImageView twice, but that case shouldn't occur in your card game)", "label": {"api": {"ImageView": [[101, 109]]}}}, {"text": "Again, the most straightforward way is probably to add as many Canvas to your HBox as you need to draw cards", "label": {"api": {"Canvas": [[63, 68]]}}}, {"text": "After the current cards have changed, for each visible card you need to get the right image from your Image array and draw it on the GraphicsContext of the right canvas using canvas.getGraphicsContext2D().drawImage()", "label": {"api": {"GraphicsContext": [[133, 147], [185, 199]], ".getGraphicsContext2D()": [[181, 203]], ".drawImage()": [[204, 215]]}}}, {"text": "For this package, one of my next steps is to write a series of FileTypeDetector to have the method Files.probeContentType() be smarter than what is is by default (the default provided file type detector relies on \"file name extensions\" only)", "label": {"api": {"FileTypeDetector": [[63, 78]], "Files.probeContentType()": [[99, 122]]}}}, {"text": "As the javadoc of the aforementioned method mentions, this method relies on instances of FileTypeDetectors be declared in a META-INF/services file", "label": {"api": {"FileTypeDetector": [[89, 104]]}}}, {"text": "The content of META-INF/services/java.nio.file.spi.FileTypeDetector was this", "label": {"api": {"FileTypeDetector": [[51, 66]]}}}, {"text": "Here's the toString method documentation from AbstractCollection.java", "label": {"api": {"AbstractCollection.java": [[46, 68]]}}}, {"text": "StringBuilder is preferred performance-wise", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "The solution is to use StringBuilder or StringBuffer", "label": {"api": {"StringBuilder": [[23, 35]], "StringBuffer": [[40, 51]]}}}, {"text": "The difference between the two is that StringBuffer is thread-safe, which makes StringBuilder faster", "label": {"api": {"StringBuilder": [[80, 92]], "StringBuffer": [[39, 50]]}}}, {"text": "After the line where you parse the date, add t.schedule(task, date), where 't' is a Timer, and 'task' is a TimerTask that represents the method you want to be executed at the given date", "label": {"api": {"Timer": [[84, 88], [107, 111]], "TimerTask": [[107, 115]]}}}, {"text": "You can pass the given string in the constructor parameter of StringBuilder class and use the codePointAt(int) method", "label": {"api": {"codePointAt(int)": [[94, 109]]}}}, {"text": "There are other useful methods also in StringBuilder like codePointBefore(int) and appendCodePoint(int), which allow you to see the codepoint of the character before and append the character with the specified codepoint to the StringBuilder, respectively", "label": {"api": {"codePointBefore(int)": [[58, 77]], "appendCodePoint(int)": [[83, 102]]}}}, {"text": "However for that, you may want to look at Graphics2D (http://docs.oracle.com/javase/7/docs/api/java/awt/Graphics2D.html) and in particular at setTransform and the AffineTransform class", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/Graphics2D.html": [[54, 118]]}}}, {"text": "You can create a Line2D object for your original line", "label": {"api": {"Line2D": [[17, 22]]}}}, {"text": "Then you can use AffineTransform#getRotateInstance to obtain an AffineTransform that does the rotation about a certain angle, around a certain point", "label": {"api": {"AffineTransform#getRotateInstance": [[17, 49]]}}}, {"text": "Using this AffineTransform, you can create a rotated Line2D object to paint", "label": {"api": {"Line2D": [[53, 58]]}}}, {"text": "To quote the package's documentation", "label": {"api": {"the package's documentation": [[9, 35]]}}}, {"text": "You should always use a PreparedStatement and bind variables when dealing with SQL that takes input parameters", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "Perhaps you are looking for peek", "label": {"api": {"peek": [[28, 31]]}}}, {"text": "You can use an InputVerifier for the text fields instead of checking the value after it is entered", "label": {"api": {"InputVerifier": [[15, 27]]}}}, {"text": "Semaphores, Locks, CountDownLatches, ConcurrentHashMaps etc..", "label": {"api": {"CountDownLatch": [[19, 32]], "Semaphores": [[0, 9]]}}}, {"text": "What I do recommend since sleeping is often about synchronization is having a look specifically at CountDownLatch and Semaphores which have examples in their Java doc", "label": {"api": {"CountDownLatch": [[99, 112]], "Semaphores": [[118, 127]]}}}, {"text": "You're catching an IOException, but Class.getResourceAsStream doesn't throw an IOException if the resource is not found; it just returns null", "label": {"api": {"Class.getResourceAsStream": [[36, 60]]}}}, {"text": "And ImageIO.read doesn't throw an IOException if the argument is null; it throws an IllegalArgumentException", "label": {"api": {"ImageIO.read": [[4, 15]]}}}, {"text": "This will ensure you handle the error, and the use of the try-with-resources statement makes sure the stream is always closed after use (which ImageIO.read does not do)", "label": {"api": {"ImageIO.read": [[143, 154]]}}}, {"text": "You should also consider, rather than returning null on error, to throw (or rethrow) some exception to the caller, such as an UncheckedIOException, since a null return value will only cause errors elsewhere once you try to make use of it, and an exception thrown directly from the point of the problem will be more meaningful than some NullPointerException thrown later", "label": {"api": {"UncheckedIOException": [[126, 145]]}}}, {"text": "I think the best way to approach this is to also use the URL class, as there are a lot of gotchas if you just do simple string parsing", "label": {"api": {"the URL class": [[53, 65]]}}}, {"text": "Check out the Base64 javadocs for more info", "label": {"api": {"the Base64 javadocs": [[10, 28]]}}}, {"text": "From the Javadocs", "label": {"api": {"the Javadocs": [[5, 16]]}}}, {"text": "The Javadocs say", "label": {"api": {"Javadocs say": [[4, 15]]}}}, {"text": "So far I only found a blocking queue but since we don't need FIFO, LIFO but random access a queue doesn't really work", "label": {"api": {"blocking queue": [[22, 35]]}}}, {"text": "You can call Class.forName(\"SomeClass$5\"), then call one of Class.getEnclosingMethod or Class.getEnclosingConstructor or Class.getEnclosingClass to find its immediately enclosing definition", "label": {"api": {"Class.getEnclosingMethod": [[60, 83]], "Class.getEnclosingConstructor": [[88, 116]], "Class.getEnclosingClass": [[121, 143]]}}}, {"text": "The problem is that the split(String str) method expects str to be a valid regular expression", "label": {"api": {"split(String str)": [[24, 40]]}}}, {"text": "$ has a special meaning in regex, and since String#split takes a regex as an argument, the $ is not interpreted as the string \"$\", but as the special meta character $", "label": {"api": {"String#split": [[44, 55]]}}}, {"text": "When you do splitedArray1[0], you could get ArrayIndexOutOfBoundsException if there's no $ symbol", "label": {"api": {"ArrayIndexOutOfBoundsException": [[44, 73]]}}}, {"text": "The problem is compare needs to return an integer to comply with that Comparator interface", "label": {"api": {"compare": [[15, 21]]}}}, {"text": "You could cast down to an int in your comparison, or perhaps better, just use Double.compare()", "label": {"api": {"compare": [[85, 91]], "Double.compare()": [[78, 93]]}}}, {"text": "You could store them in a TreeMap which is already sorted", "label": {"api": {"TreeMap": [[26, 32]]}}}, {"text": "An example for this design is the java.time package", "label": {"api": {"java.time": [[34, 42]]}}}, {"text": "It seems like you create an absolute filename with loadImage.getAbsolutePath(), but then you try to use this as a class path resource with new ImageIcon(getClass().getResource(S))", "label": {"api": {"class path resource": [[114, 132]]}}}, {"text": "Read the file one line at a time and then consider using the replaceAll(String string) method which takes a regular expression on the line you have just read", "label": {"api": {"replaceAll(String string)": [[61, 85]]}}}, {"text": "Investigating Thymeleaf's source code, I noticed that it uses Introspector to get information about the properties, so we can hide some properties by implementing a BeanInfo", "label": {"api": {"Introspector": [[62, 73]]}}}, {"text": "You can take a look at the Introspector's source code to see how they extract this information and improve this solution", "label": {"api": {"Introspector": [[27, 38]]}}}, {"text": "You could use a StringBuilder instead", "label": {"api": {"StringBuilder": [[16, 28]]}}}, {"text": "The ErrorEntity has two ErrorEntity.ENV_ID mappings, which unless you use @MapsId then it's a configuration issue", "label": {"api": {"@MapsId": [[74, 80]]}}}, {"text": "Create a custom Shape", "label": {"api": {"Shape": [[16, 20]]}}}, {"text": "Yet, subclassing Shape doesn't seem to be a simple task, and I can't find any indication on how to do this", "label": {"api": {"Shape": [[17, 21]]}}}, {"text": "I've been looking at Rectangle and other shapes, but I don't know the Shape Architecture..", "label": {"api": {"Shape": [[70, 74]]}}}, {"text": "Subclass Control, define a Skin with SkinBase and Behavior with BehaviorBase", "label": {"api": {"Control": [[9, 15]]}}}, {"text": "Subclassing Control seems to be considered overkill if they're only going to be used by one application", "label": {"api": {"Control": [[12, 18]]}}}, {"text": "If you genuinely only want to pull elements from the front of your list and you want to be sure that they're there, then you should look into a ConcurrentLinkedQueue instead", "label": {"api": {"ConcurrentLinkedQueue": [[144, 164]]}}}, {"text": "Now that you have there's a the length() method if you want to find the length of a String", "label": {"api": {"length()": [[32, 39]]}}}, {"text": "Consider the core loop from the JDK 8 String.hashCode() implementation", "label": {"api": {"String.hashCode()": [[38, 54]]}}}, {"text": "See javadoc documentation (http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html)", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html": [[27, 105]]}}}, {"text": "If that's the case, try switching to a concurrent structure, probably a ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[72, 92]]}}}, {"text": "Call String.trim() on each read line which removes leading and trailing spaces", "label": {"api": {"String.trim()": [[5, 17]]}}}, {"text": "You can also use Files.readAllLines() to read all lines into a List", "label": {"api": {"Files.readAllLines()": [[17, 36]]}}}, {"text": "Or, if you're using Java 8, you can use Comparator.comparing", "label": {"api": {"Comparator.comparing": [[40, 59]]}}}, {"text": "I think hailin suggested you create a raw Socket and connect it to the server instead of using URLConnection", "label": {"api": {"Socket": [[42, 47]]}}}, {"text": "Anyway, here's the version using a Socket (add exception handling as needed)", "label": {"api": {"Socket": [[35, 40]]}}}, {"text": "If you don't want the time for the DNS resolution in there, you can create an InetAddress with InetAddress.getByName(\"hostname\") before you start the timer and pass that to the InetSocketAddress constructor", "label": {"api": {"Socket": [[181, 186]], "InetAddress": [[78, 88], [95, 105]], "InetAddress.getByName(\"hostname\")": [[95, 127]]}}}, {"text": "InetSocketAddress's constructor also resolves the host name right away, so constructing it from a resolved ip address shouldn't make a difference", "label": {"api": {"Socket": [[4, 9]]}}}, {"text": "In accordance with the documentation Play uses the MessageFormat class for formatting and it generates its output based on the provided Locale object", "label": {"api": {"MessageFormat": [[51, 63]], "Locale": [[136, 141]]}}}, {"text": "Use q.startsWith(\"The\") instead", "label": {"api": {"q.startsWith(\"The\")": [[4, 22]]}}}, {"text": "The \"natural ordering\" that Collections.sort refers to is the one specified by Comparable -- which String implements, and which defines only one method, compareTo", "label": {"api": {"Comparable": [[79, 88]]}}}, {"text": "So, the answer is in the definition of String.compareTo", "label": {"api": {"String.compareTo": [[39, 54]]}}}, {"text": "String class implements the Comparable interface", "label": {"api": {"Comparable": [[28, 37]]}}}, {"text": "When sort happens, compareTo(String) method is called", "label": {"api": {"compareTo(String)": [[19, 35]]}}}, {"text": "For more look at the implementation of compareTo(String) method in String class", "label": {"api": {"compareTo(String)": [[39, 55]]}}}, {"text": "Use a RNG for each thread, for example with ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[44, 60]]}}}, {"text": "You can convert from char to hex String with String.format()", "label": {"api": {"String.format()": [[45, 59]]}}}, {"text": "The Byte.decode() javadoc specifies that hex numbers should be on the form \"0x4C\"", "label": {"api": {"Byte.decode() javadoc": [[4, 24]]}}}, {"text": "You can retrieve a result without looping using the getString(int columnIndex) or getString(String columnLabel) methods, for example", "label": {"api": {"getString(int columnIndex)": [[52, 77]], "getString(String columnLabel)": [[82, 110]]}}}, {"text": "Have a look at Duration (part of the new Date & Time API introduced in Java SE 8)", "label": {"api": {"Duration": [[15, 22]]}}}, {"text": "A NoClassDefFoundError occurs when you're using a class that is unknown at runtime hence you probably don't have a dependency to it", "label": {"api": {"NoClassDefFoundError": [[2, 21]]}}}, {"text": "If it does, see SwingWorker", "label": {"api": {"SwingWorker": [[16, 26]]}}}, {"text": "You can use a custom Comparator", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "From the documentation of KeyEvent the getKeyChar() method states", "label": {"api": {"getKeyChar()": [[39, 50]]}}}, {"text": "I'd go for EnumSet", "label": {"api": {"EnumSet": [[11, 17]]}}}, {"text": "This is explained in the following quote from the Statement API docs", "label": {"api": {"Statement API docs": [[50, 67]]}}}, {"text": "The java.util.Formatter class has a zero-argument constructor which automatically wraps a StringBuilder", "label": {"api": {"java.util.Formatter": [[4, 22]], "zero-argument constructor": [[36, 60]]}}}, {"text": "Literal strings, coming from your code, are interned", "label": {"api": {"Literal strings, coming from your code, are interned": [[0, 51]]}}}, {"text": "A simplistic approach would be to use a Filter and wrap it around all your API calls in web.xml", "label": {"api": {"Filter": [[40, 45]]}}}, {"text": "You could use Java 8 streams to filter your data", "label": {"api": {"Java 8 streams": [[14, 27]]}}}, {"text": "Perhaps you want to ignore the whitespaces", "label": {"api": {"ignore the whitespaces": [[20, 41]]}}}, {"text": "In the list of HashSet's implemented interfaces, you do not find SortedSet", "label": {"api": {"the list of HashSet's implemented interfaces": [[3, 46]]}}}, {"text": "Files.lines by default uses the UTF-8 encoding, whereas instantiating a new String from bytes will use the default system encoding", "label": {"api": {"UTF-8 encoding": [[32, 45]]}}}, {"text": "To complement Jesper's answer, what happens here (and is undocumented!) is that Files.lines() creates a CharsetDecoder whose policy is to reject invalid byte sequences; that is, its CodingErrorAction is set to REPORT", "label": {"api": {"CharsetDecoder": [[104, 117]], "CodingErrorAction": [[182, 198]]}}}, {"text": "Consider to use ExecutionService if you want a multi-thread program", "label": {"api": {"ExecutionService": [[16, 31]]}}}, {"text": "Better yet, Java EE docs say that a stream is returned if it doesn't know what to do with the data type, so maybe that's your final else", "label": {"api": {"Java EE docs": [[12, 23]]}}}, {"text": "What you need is FileOutputStream", "label": {"api": {"FileOutputStream": [[17, 32]]}}}, {"text": "One convenient way to bind Enter to an Action is via the root pane's setDefaultButton() method", "label": {"api": {"setDefaultButton()": [[69, 86]]}}}, {"text": "You're searching for the finalize() method", "label": {"api": {"finalize()": [[25, 34]]}}}, {"text": "Please note that creating a finalize() method is not as easy as it looks like (as explained in these answers)", "label": {"api": {"finalize()": [[28, 37]]}}}, {"text": "Using Collectors.joining from Java 8", "label": {"api": {"Collectors.joining": [[6, 23]]}}}, {"text": "Another Java 8 solution using String.join", "label": {"api": {"String.join": [[30, 40]]}}}, {"text": "The best way to achieve this would be to use a AnimationTimer which will be called in each frame while it is active", "label": {"api": {"AnimationTimer": [[47, 60]]}}}, {"text": "This can be accomplished by allowing core threads to timeout", "label": {"api": {"allowing core threads to timeout": [[28, 59]]}}}, {"text": "You should Override toString method in your class", "label": {"api": {"toString": [[20, 27]]}}}, {"text": "The output you're getting is the default implementation of toString which displays the class's name followed by @ and then the hashcode", "label": {"api": {"toString": [[59, 66]]}}}, {"text": "The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character '@', and the unsigned hexadecimal representation of the hash code of the object", "label": {"api": {"toString": [[4, 11]]}}}, {"text": "You can solve this with synchronization or use of AtomicInteger", "label": {"api": {"AtomicInteger": [[50, 62]]}}}, {"text": "You can always save this T-SQL code as MSSQL stored procedure and execute it using JDBC CallableStatement", "label": {"api": {"CallableStatement": [[88, 104]]}}}, {"text": "Use Supplier if it takes nothing, but returns something", "label": {"api": {"Supplier": [[4, 11]]}}}, {"text": "Use Consumer if it takes something, but returns nothing", "label": {"api": {"Consumer": [[4, 11]]}}}, {"text": "Use Callable if it returns a result and might throw (most akin to Thunk in general CS terms)", "label": {"api": {"Callable": [[4, 11]]}}}, {"text": "Use Runnable if it does neither and cannot throw", "label": {"api": {"Runnable": [[4, 11]]}}}, {"text": "The easiest way is to create a DecimalFormat object, supplying the pattern yourself", "label": {"api": {"DecimalFormat object": [[31, 50]]}}}, {"text": "The Arrays class is a util class, not the type you'd use for an array", "label": {"api": {"Arrays": [[4, 9]]}}}, {"text": "The Arrays class never takes a generic argument, which is what your error is telling you", "label": {"api": {"Arrays": [[4, 9]]}}}, {"text": "In your specific case, you should use Set, which inherently removes duplicates", "label": {"api": {"Set": [[38, 40]]}}}, {"text": "So you would just add everything to it with the add() method, and duplicates would be automatically ignored", "label": {"api": {"add()": [[48, 52]]}}}, {"text": "Your VersionComparator class is implementing the raw form of the Comparator interface, where the compare method will take 2 Objects instead of 2 Strings", "label": {"api": {"compare method": [[97, 110]]}}}, {"text": "Then the compiler will recognize your compare method taking Strings as parameters as the proper implementation of the interface", "label": {"api": {"compare method": [[38, 51]]}}}, {"text": "You don't need a compare method taking Objects", "label": {"api": {"compare method": [[17, 30]]}}}, {"text": "You will of course need to implement the comparison logic in your compare method, returning an int less than 0, 0, or greater than 0 if str1 compares less than, equal to, or greater then str2 according to your custom sort order", "label": {"api": {"compare method": [[66, 79]]}}}, {"text": "Have a look at official FileWriter Javadoc", "label": {"api": {"FileWriter Javadoc": [[24, 41]]}}}, {"text": "Instead, you should call the executeUpdate method", "label": {"api": {"the executeUpdate method": [[25, 48]]}}}, {"text": "This is called concurrent modification, thus the exception ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[59, 89]]}}}, {"text": "Your Matcher's three captured group references will then have the values you want", "label": {"api": {"Matcher": [[5, 11]], "group": [[30, 34]]}}}, {"text": "In Java 8, you can use the new streaming syntax", "label": {"api": {"streaming syntax": [[31, 46]]}}}, {"text": "The contract for hashCode does not guarantee equality, so you probably need to call equals all the way down the tree to make sure everything balances out", "label": {"api": {"contract": [[4, 11]]}}}, {"text": "JLayeredPane.remove(int) refers to the child's absolute index, not its layer position", "label": {"api": {"JLayeredPane.remove(int)": [[0, 23]]}}}, {"text": "If you want to just overwrite existing elements in the stringArray, without touching those at farther indexes, use System#arraycopy(Object, int, Object, int, int)", "label": {"api": {"System#arraycopy(Object, int, Object, int, int)": [[115, 161]]}}}, {"text": "Also, make sure the stringList is not longer than stringArray or you'll get IndexOutOfBoundsExceptions", "label": {"api": {"IndexOutOfBoundsExceptions": [[76, 101]]}}}, {"text": "Check Java String API", "label": {"api": {"Java String API": [[6, 20]]}}}, {"text": "To know postion of last letter of java use last index plus \"java\".length", "label": {"api": {"last index": [[43, 52]]}}}, {"text": "You should encode your URL using URLEncoder", "label": {"api": {"URLEncoder": [[33, 42]]}}}, {"text": "You can have a main dispatcher, that creates Threads that will invoke each client main method", "label": {"api": {"Threads": [[45, 51]]}}}, {"text": "Thread.join() is used to wait for the Threads to finish, if you want to do some later actions (prompt something for example)", "label": {"api": {"Threads": [[38, 44]], "join()": [[7, 12]]}}}, {"text": "I was getting the same ClassCastException with concurrent calls to HashMap.computeIfAbsent", "label": {"api": {"HashMap.computeIfAbsent": [[67, 89]]}}}, {"text": "I fixed by changing the implmentation to use ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[45, 61]]}}}, {"text": "You can see about the DefaultListModel definition", "label": {"api": {"definition": [[39, 48]]}}}, {"text": "If you need something at the complete other end of the spectrum (something simple), simply stick to a ConcurrentQueue", "label": {"api": {"ConcurrentQueue": [[102, 116]]}}}, {"text": "While BigDecimal is much more powerful and flexible than double it does still have limits; namely its scale is an int", "label": {"api": {"its scale is an int": [[98, 116]]}}}, {"text": "I'm not sure how loadLibrary handles full paths, but System.load can do it", "label": {"api": {"System.load": [[53, 63]]}}}, {"text": "Or you can use SwingUtilities.convertPoint(...) method to convert point from one component to another, like next", "label": {"api": {"SwingUtilities.convertPoint(...)": [[15, 46]]}}}, {"text": "Why not just set the default values via config.set() if !file.exists()", "label": {"api": {"!file.exists()": [[56, 69]]}}}, {"text": "To make sure the updated objects are sent instead of references, you need to call reset() on the stream", "label": {"api": {"reset()": [[82, 88]]}}}, {"text": "you try to instantiate interface directly, which is not allowed", "label": {"api": {"interface": [[23, 31]]}}}, {"text": "Since Frame itself is Container and Component (see API) you can add it to another container and so to another Frame or Panel or any other containers", "label": {"api": {"API": [[51, 53]]}}}, {"text": "You need to either iterate over the array you are given in a for loop and write to it, or use System.arraycopy if you have constructed another buffer that contains the result", "label": {"api": {"System.arraycopy": [[94, 109]]}}}, {"text": "Use a Collator to do alphabetical ordering", "label": {"api": {"Collator": [[6, 13]]}}}, {"text": "The Collections.sort method sorts the List in place; it returns void, and you can't assign the result of a void-returning method to anything", "label": {"api": {"Collections.sort method": [[4, 26]]}}}, {"text": "According to the TreeMap documentation, the tree will be sorted according to the compareTo method, so any changes that are not reflected in the sign of a.compareTo(b) are allowed", "label": {"api": {"TreeMap documentation": [[17, 37]]}}}, {"text": "As pointed out by @Rod_Algonquin, 1000*16777216 exceeds the range of int (int takes value between -231 to 231 - 1 ), so it causes overflow", "label": {"api": {"range": [[60, 64]]}}}, {"text": "You have to use executeUpdate() instead of executeQuery() for data manipulation like Insert,Update or Delete", "label": {"api": {"executeUpdate()": [[16, 30]]}}}, {"text": "It is important to note that if the timezone of your database is different from the JVM's, you should use the setDate overload that takes the TZ into account", "label": {"api": {"setDate": [[110, 116]]}}}, {"text": "You might also take a look at ExecutorCompletionService, it might make your code simpler", "label": {"api": {"ExecutorCompletionService": [[30, 54]]}}}, {"text": "If you don't want to include more sophisticated libraries you might use javax.swing.Timer (as mentioned by @VGR), java.util.concurrent.ScheduledExecutorService or java.util.Timer", "label": {"api": {"javax.swing.Timer": [[72, 88]], "java.util.concurrent.ScheduledExecutorService": [[114, 158]], "java.util.Timer": [[163, 177]]}}}, {"text": "Example using javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[14, 30]]}}}, {"text": "Example using ScheduledExecutorService (remember that the actual logic touching UI components probably must be run from the GUI thread (AWT event dispatch thread in case of Swing), not executor's thread)", "label": {"api": {"AWT event dispatch thread in case of Swing": [[136, 177]]}}}, {"text": "Place a JPanel that uses a CardLayout in the center of your window", "label": {"api": {"CardLayout": [[27, 36]]}}}, {"text": "CardLayout shows only one of its children at a time, and will always have a preferred size that accommodates all of the children, both visible and invisible", "label": {"api": {"CardLayout": [[0, 9]]}}}, {"text": "Display long text using a JTextArea (if it's all in the same font), a JEditorPane (if it's predefined HTML that you are packaging with your application), or a JTextPane (if the text is dynamic, and has images and/or uses multiple fonts)", "label": {"api": {"JTextArea": [[26, 34]], "JEditorPane": [[70, 80]], "JTextPane": [[159, 167]]}}}, {"text": "All of those should have setEditable(false) called on them, and should be placed in a JScrollPane", "label": {"api": {"setEditable(false)": [[25, 42]]}}}, {"text": "Yes, Starting from Java-8 you can use the new Exact method, it will throw an exception(java.lang.ArithmeticException", "label": {"api": {"Exact": [[46, 50]]}}}, {"text": "You want to write a Java agent", "label": {"api": {"Java agent": [[20, 29]]}}}, {"text": "The above built agent can than be installed on an instance of the instrumentation interface which is provided to any Java agent", "label": {"api": {"Java agent": [[117, 126]]}}}, {"text": "There are plenty of similar examples, DocumentBuilderFactory or TransformerFactory are both abstract but their newInstance() method will return a subclass, usually packaged separately (e.g", "label": {"api": {"DocumentBuilderFactory": [[38, 59]], "TransformerFactory": [[64, 81]]}}}, {"text": "If you're on Java 7/8, you can get this information from BasicFileAttributes", "label": {"api": {"BasicFileAttributes": [[57, 75]]}}}, {"text": "If you also need the owner of the file you can get it trough FileOwnerAttributeView like this", "label": {"api": {"FileOwnerAttributeView": [[61, 82]]}}}, {"text": "See Java's Executors for that", "label": {"api": {"Executors": [[11, 19]]}}}, {"text": "You need to configure an instance of DateFormat, with your locale, (take a look at https://docs.oracle.com/javase/7/docs/api/java/util/Locale.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Locale.html": [[83, 145]]}}}, {"text": "You should use a PreparedStatement with bind variables to eliminate the chance of SQL injection (and to enable the DB to cache the query)", "label": {"api": {"PreparedStatement": [[17, 33]]}}}, {"text": "The default capacity for ArrayList is 10, while the initial capacity of ArrayDeque is 16", "label": {"api": {"default capacity for ArrayList is 10": [[4, 39]], "initial capacity of ArrayDeque is 16": [[52, 87]]}}}, {"text": "String.concat returns a different String object and does not modify the original String", "label": {"api": {"String.concat": [[0, 12]]}}}, {"text": "To fix this, use List.set to replace the old value in the list with a new one", "label": {"api": {"List.set": [[17, 24]]}}}, {"text": "Instead, use the set method", "label": {"api": {"the set method": [[13, 26]]}}}, {"text": "If you have not overridden this method to provide custom behavior, it will use the parent method (in this case, the default Object.toString())", "label": {"api": {"Object.toString()": [[124, 140]]}}}, {"text": "You should use the replaceAll method instead of replace when you want to pass a regex string as the pattern to be replaced", "label": {"api": {"replaceAll": [[19, 28]]}}}, {"text": "I am trying to find a way to convert Document to String and found this XML Document to String", "label": {"api": {"Document": [[37, 44], [75, 82]]}}}, {"text": "But, I want to do the conversion without using TransformerFactory because of XXE Vulnerabilities and by using DocumentBuilderFactory only", "label": {"api": {"Document": [[110, 117]]}}}, {"text": "If you want to convert a String to a char[] array, use the toCharArray method", "label": {"api": {"toCharArray": [[59, 69]]}}}, {"text": "The Java 8 java.time.LocalDate class has no public constructors, but it does have a private constructor that takes three int values", "label": {"api": {"java.time.LocalDate": [[11, 29]]}}}, {"text": "You're setting a session attribute on the name of a reserved EL variable referring the HTTP request header", "label": {"api": {"HTTP request header": [[87, 105]]}}}, {"text": "This is supposed to be used to access a HTTP request header in EL such as ${header['User-Agent']}", "label": {"api": {"HTTP request header": [[40, 58]]}}}, {"text": "Note that I also renamed the Java variable for clarity, because this definitely doesn't represent a \"response header\"", "label": {"api": {"response header": [[101, 115]]}}}, {"text": "According to Thread javadoc", "label": {"api": {"Thread javadoc": [[13, 26]]}}}, {"text": "see ThreadPoolExecutor doc, especially keepalive configuration) it might keep the threads running forever or terminate when they are unused for some time", "label": {"api": {"ThreadPoolExecutor doc, especially keepalive configuration": [[4, 61]]}}}, {"text": "You must either call shutdown on your executor or create it with a custom ThreadFactory (e.g", "label": {"api": {"ThreadFactory": [[74, 86]]}}}, {"text": "using Executors.newFixedThreadPool(int, ThreadFactory)) where that thread factory will configure new threads as daemon ones", "label": {"api": {"ThreadFactory": [[40, 52]], "Executors.newFixedThreadPool(int, ThreadFactory)": [[6, 53]]}}}, {"text": "To solve the problem, query ListSelectionEvent.getValueIsAdjusting() & only progress if it is false", "label": {"api": {"ListSelectionEvent.getValueIsAdjusting()": [[28, 67]]}}}, {"text": "What you should use is an array, List or a Map", "label": {"api": {"Map": [[43, 45]]}}}, {"text": "A Map is probably the closest to what you want", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "The first sentence of WeakHashMap's javadoc says", "label": {"api": {"says": [[44, 47]]}}}, {"text": "Make your thread a daemon thread", "label": {"api": {"daemon thread": [[19, 31]]}}}, {"text": "The Java Virtual Machine exits when the only threads running are all daemon threads", "label": {"api": {"daemon thread": [[69, 81]]}}}, {"text": "You may find it more convenient to use a JavaFX Task", "label": {"api": {"Task": [[48, 51]]}}}, {"text": "Instead, use a timer", "label": {"api": {"timer": [[15, 19]]}}}, {"text": "Have you considered using a Map", "label": {"api": {"Map": [[28, 30]]}}}, {"text": "This means if you give the Map a time, it will return the actions related to it", "label": {"api": {"Map": [[27, 29]]}}}, {"text": "Assuming you use Date for representing time, and a class called Action for the actions, the implementation would look like this", "label": {"api": {"Date": [[17, 20]]}}}, {"text": "Map is an interface, so we have to use one of its implementations, in this case a HashMap", "label": {"api": {"Map": [[0, 2], [86, 88]], "HashMap": [[82, 88]]}}}, {"text": "See the API documentation", "label": {"api": {"API documentation": [[8, 24]]}}}, {"text": "Shooting in the dark, because you haven't disclosed all relevant code, but you could try adding the missing parameter for valueOf here", "label": {"api": {"valueOf": [[122, 128]]}}}, {"text": "You need to use the setNull method for the code to work", "label": {"api": {"setNull": [[20, 26]]}}}, {"text": "Instead, use a timer", "label": {"api": {"timer": [[15, 19]]}}}, {"text": "About find() from http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#find%28%29", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#find%28%29": [[18, 97]]}}}, {"text": "The documentation for Matcher.lookingAt clearly explains the region lookingAt tries to match", "label": {"api": {"documentation for Matcher.lookingAt": [[4, 38]]}}}, {"text": "From the Matcher Javadoc overview", "label": {"api": {"Matcher Javadoc overview": [[9, 32]]}}}, {"text": "The server uses a BufferedReader, whose readLine method requires an end of line delimiter, but the Client is not sending it - rather, it reads the line (with end of line delimiter stripped) and attempts to echo this message", "label": {"api": {"BufferedReader": [[18, 31]]}}}, {"text": "So an ArrayList may be helpful", "label": {"api": {"ArrayList": [[6, 14]]}}}, {"text": "Yes when your thread finishes and is capable of say accepting request or a particular task, it call countDown method on latch", "label": {"api": {"countDown": [[100, 108]]}}}, {"text": "Now whenever 'x' slave threads completes their task and calls countDown, master knows about the same and comes out of await and does further processing", "label": {"api": {"countDown": [[62, 70]]}}}, {"text": "Solution is to use AtomicInteger instead of int", "label": {"api": {"AtomicInteger": [[19, 31]]}}}, {"text": "setLocationRelativeTo(null) will place the window in the center of the screen (http://docs.oracle.com/javase/7/docs/api/java/awt/Window.html#setLocationRelativeTo%28java.awt.Component%29)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/Window.html#setLocationRelativeTo%28java.awt.Component%29": [[79, 185]]}}}, {"text": "The correct thing to do is use setLocationByPlatform(true), which will allow the desktop to place your window as it sees fit", "label": {"api": {"setLocationByPlatform(true)": [[31, 57]]}}}, {"text": "If you feel your application is so much more important than all others that it absolutely has to be placed in the center of the screen, you can use setLocationRelativeTo(null), which is guaranteed to center the window", "label": {"api": {"setLocationRelativeTo(null)": [[148, 174]]}}}, {"text": "Look at the documentation for Integer.valueOf(int)", "label": {"api": {"Integer.valueOf(int)": [[30, 49]]}}}, {"text": "This likely means the objects in the List implement Comparable", "label": {"api": {"Comparable": [[52, 61]]}}}, {"text": "That is, read from a config file or take it in as command-line parameters", "label": {"api": {"read from a config file": [[9, 31]]}}}, {"text": "One way to get a list of unique products would be to use Map::merge with the Product name as key and the Product::merge method from this example as the remapping function", "label": {"api": {"Map::merge": [[57, 66]]}}}, {"text": "You could wrap your while loop inside an AnimationTimer like this", "label": {"api": {"AnimationTimer": [[41, 54]]}}}, {"text": "Currently, I just Locale.getDefault(), but I'd rather like to work with List<Locale.LanguageRange> (from Java 8) that comes from the browser via Accept-Language", "label": {"api": {"from Java 8": [[100, 110]]}}}, {"text": "Also for a better way to randomly distribute cards, look at Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[60, 80]]}}}, {"text": "A PathTransition works by updating the translateX and translateY properties of the node that is being animated", "label": {"api": {"PathTransition": [[2, 15]]}}}, {"text": "I believe you should look into objects where you have key/value pairs like HashMap for example", "label": {"api": {"HashMap": [[75, 81]]}}}, {"text": "What you have is a reduction", "label": {"api": {"reduction": [[19, 27]]}}}, {"text": "You can use BigDecimal", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "It is done when obtaining the Connection from the DataSource with dataSource.getConnection(username, password)", "label": {"api": {"dataSource.getConnection(username, password)": [[66, 109]]}}}, {"text": "But after all, there is no method like retainAll() for arrays", "label": {"api": {"method": [[27, 32]]}}}, {"text": "You may want to invoke a Collection method on a simple array", "label": {"api": {"method": [[36, 41]]}}}, {"text": "You should work with collections instead of simple arrays, if you want to use their methods", "label": {"api": {"method": [[84, 89]]}}}, {"text": "I currently have a simple instant messaging program which is utilizing Java's Socket and ServerSocket classes", "label": {"api": {"Socket": [[78, 83], [95, 100]], "ServerSocket": [[89, 100]]}}}, {"text": "I then use the ServerSocket.close() method on the server and the Socket.close() method on the client", "label": {"api": {"Socket": [[21, 26], [65, 70]], "ServerSocket": [[15, 26]]}}}, {"text": "One way to handle the \"sliding window\" would be to use a RandomAccessFile, and seek to the current offset", "label": {"api": {"RandomAccessFile": [[57, 72]]}}}, {"text": "The uniqueness can be handled by a Set", "label": {"api": {"Set": [[35, 37]]}}}, {"text": "The best solution I have found so far is to add a method to my configuration class and annotate it with the @PostConstruct annotation", "label": {"api": {"@PostConstruct": [[108, 121]]}}}, {"text": "This is a call to java.util.Timer.schedule(TimerTask task, long delay, long period)", "label": {"api": {"java.util.Timer.schedule(TimerTask task, long delay, long period)": [[18, 82]]}}}, {"text": "You could use Java 8 streams for this and Collectors.groupingBy", "label": {"api": {"Collectors.groupingBy": [[42, 62]]}}}, {"text": "For more details see ResultSetMetaData documentation", "label": {"api": {"ResultSetMetaData documentation": [[21, 51]]}}}, {"text": "I would suggest working with the start of the next day and using before", "label": {"api": {"before": [[65, 70]]}}}, {"text": "Make your custom exceptions extend the RuntimeException class", "label": {"api": {"RuntimeException": [[39, 54]]}}}, {"text": "See the Javadocs RuntimeException", "label": {"api": {"RuntimeException": [[17, 32]]}}}, {"text": "As Java doc says, PrintWriter is used for writing to the file", "label": {"api": {"PrintWriter": [[18, 28]]}}}, {"text": "In your case, I would suggest you to use BufferedReader class", "label": {"api": {"BufferedReader": [[41, 54]]}}}, {"text": "I have a JavaFX window (subclass of Application) which lets JOptionPane dialog boxes be opened from it", "label": {"api": {"Application": [[36, 46]], "JOptionPane": [[60, 70]]}}}, {"text": "Could the window thread be paused until the JOptionPane method returns", "label": {"api": {"JOptionPane": [[44, 54]]}}}, {"text": "You can also use the properties to initialize the default values in an instance of java.util.prefs.Preferences, as shown in the game cited here", "label": {"api": {"java.util.prefs.Preferences": [[83, 109]]}}}, {"text": "I wrote a small application using xuggler which combines BufferedImages into a video (slideshow)", "label": {"api": {"BufferedImage": [[57, 69]]}}}, {"text": "You can use a combination of weak references and reference queues", "label": {"api": {"weak references": [[29, 43]], "reference queue": [[49, 63]]}}}, {"text": "This old but valid article has a good description of weak, soft, and phantom references and reference queues", "label": {"api": {"reference queue": [[92, 106]]}}}, {"text": "The basic idea is to create a large array (to reserve memory) create a weak or soft reference to it and when doing so, add it to a reference queue", "label": {"api": {"reference queue": [[131, 145]]}}}, {"text": "Have a thread polling the reference queue to determine when your reserve has been collected", "label": {"api": {"reference queue": [[26, 40]]}}}, {"text": "For example, one can create a Set from the list and iterate over all items in the set, calling Collections.frequency(list, item), where list is the List<String> collection and item is each string of the set iteration", "label": {"api": {"Collections.frequency(list, item)": [[95, 127]]}}}, {"text": "If you want to rotate in multiples of 90 degrees left or right, you could use the AffineTransform.getQuadrantRotateInstance(int) methods instead", "label": {"api": {"AffineTransform.getQuadrantRotateInstance(int)": [[82, 127]]}}}, {"text": "Collections.removeIf() unfortunately simply returns a boolean (not even a count of the number of removed elements", "label": {"api": {"Collections.removeIf()": [[0, 21]]}}}, {"text": "The documentation of PrintWriter says it all", "label": {"api": {"PrintWriter": [[21, 31]]}}}, {"text": "The PrintWriter(Writer) constructor creates a writer which is not automatically flushed", "label": {"api": {"PrintWriter": [[4, 14]]}}}, {"text": "and as a good practice you have to close all your PrintWriter instances to avoid memory leak", "label": {"api": {"PrintWriter": [[50, 60]]}}}, {"text": "See for example the documentation for the enum Locale.Category", "label": {"api": {"documentation for the enum Locale.Category": [[20, 61]]}}}, {"text": "This is one of the reasons, why we have Executors.newWorkStealingPool() in JDK 8 onward -- currently delegating to ForkJoinPool, but open for providing a simpler implementation", "label": {"api": {"Executors.newWorkStealingPool()": [[40, 70]]}}}, {"text": "In this case the @Override comes to the rescue as at compile time, it will fail or give a warning when the override does not happen", "label": {"api": {"@Override": [[17, 25]]}}}, {"text": "Also many IDE's recognize the @Override and give you enough support to flag and correct those situations before you even compile", "label": {"api": {"@Override": [[30, 38]]}}}, {"text": "So the @Override in essence declares your intention that this method overrides something", "label": {"api": {"@Override": [[7, 15]]}}}, {"text": "The Retention of the @Override annotation is set to SOURCE", "label": {"api": {"@Override": [[21, 29]], "Retention": [[4, 12]], "SOURCE": [[52, 57]]}}}, {"text": "Which means the @Override flag is discarded when compiled into a class file", "label": {"api": {"@Override": [[16, 24]]}}}, {"text": "You have to use SwingWorker to execute graphical user interface operations and calculations otherwise the event dispatch thread won't be able to repaint", "label": {"api": {"SwingWorker": [[16, 26]]}}}, {"text": "The Java 8 rewrite, Caffeine, supports adding that functionality through ConcurrentHashMap's atomic compute methods", "label": {"api": {"ConcurrentHashMap's": [[73, 91]]}}}, {"text": "You could then insert the new elements where you would like and use something like System.arrayCopy(Object src, int srcPos, Object dest, int destPos, int length) to move in your previous elements", "label": {"api": {"System.arrayCopy(Object src, int srcPos, Object dest, int destPos, int length)": [[83, 160]], "insert": [[15, 20]]}}}, {"text": "That being said, an easier approach would be to use an ArrayList, which provides a means to insert, in a particular location of the array list", "label": {"api": {"insert": [[92, 97]]}}}, {"text": "You can override getPreferredScrollableViewportSize() like they show here and here", "label": {"api": {"getPreferredScrollableViewportSize()": [[17, 52]]}}}, {"text": "If you are concerned about authenticity of the downloaded file, then consider data signing", "label": {"api": {"data signing": [[78, 89]]}}}, {"text": "To be safe, be sure to wrap your ArrayList in a call to Collections.unmodifiableList() and pass that List to your Runnables", "label": {"api": {"Collections.unmodifiableList()": [[56, 85]]}}}, {"text": "Alternatively, you can construct sublists in your main thread (with List.subList()) so that you don't need to pass the startIndex to each thread", "label": {"api": {"List.subList()": [[68, 81]]}}}, {"text": "As per API, the disk-drive specifier - \"/\" for the UNIX root directory, and \"\\\\\" for a Microsoft Windows UNC pathname", "label": {"api": {"API": [[7, 9]]}}}, {"text": "consider using the classes in the java.nio package to your file IO if you can (not sure which version of Java you're running with) because the error handling is improved and you should be able to find a more specific reason for the failure based on the type of exception thrown and the exception message", "label": {"api": {"java.nio": [[34, 41]]}}}, {"text": "Is there any equivalent implementation of (Java 8) streams* in Java 7", "label": {"api": {"streams": [[51, 57]]}}}, {"text": "I am familiar with (Java 8) streams but my project requirement is to use Java 7", "label": {"api": {"streams": [[28, 34]]}}}, {"text": "*Not to be confused with inputStream and outputStream", "label": {"api": {"inputStream": [[25, 35]], "outputStream": [[41, 52]]}}}, {"text": "If you store Car.engine in AtomicReference, you could swap them using the CAS operations", "label": {"api": {"AtomicReference": [[27, 41]]}}}, {"text": "Don't forget to shutdown the thread pool when not needed anymore, as mentioned in the documentation", "label": {"api": {"in the documentation": [[79, 98]]}}}, {"text": "See the official documentation for more details", "label": {"api": {"official documentation": [[8, 29]]}}}, {"text": "If you are interested in parallelising some of your logic you might take a look at Java 8 Stream API and its support for parallel streams", "label": {"api": {"Java 8 Stream API": [[83, 99]]}}}, {"text": "Another approach is serialization  All your data - String, double and ArrayList are serializable", "label": {"api": {"serialization": [[20, 32]]}}}, {"text": "There a lot of examples or tutorials how to do simple serialization", "label": {"api": {"serialization": [[54, 66]]}}}, {"text": "You can however use toArray(T) method to easily turn your ArrayList into an array", "label": {"api": {"toArray(T)": [[20, 29]]}}}, {"text": "Note that the parameter to split() is a regular expression, so if you aren't familiar with them see the docs here (or google for a tutorial)", "label": {"api": {"see the docs here": [[96, 112]]}}}, {"text": "Collections.sort does an in-place sort and does not return a value", "label": {"api": {"Collections.sort": [[0, 15]]}}}, {"text": "For that, we can use Random#nextInt()", "label": {"api": {"Random#nextInt()": [[21, 36]]}}}, {"text": "There are other operations provided by AtomicReference that you can't implement with normal references", "label": {"api": {"AtomicReference": [[39, 53]]}}}, {"text": "With AtomicReference you can do those operations safely even when multiple threads are trying to access the same references", "label": {"api": {"AtomicReference": [[5, 19]]}}}, {"text": "You get an ArithmeticException as described in BigDecimal.divide(BigDecimal) - \"if the exact quotient does not have a terminating decimal expansion\" because to properly represent the result of 1/3 would take infinite memory", "label": {"api": {"BigDecimal.divide(BigDecimal)": [[47, 75]]}}}, {"text": "By using BigDecimal.divide(BigDecimal,int,RoundingMode) you explicitly set what precision you'll tolerate, meaning any division can be approximated in-memory", "label": {"api": {"BigDecimal.divide(BigDecimal,int,RoundingMode)": [[9, 54]]}}}, {"text": "To reduce your precision use .stripTrailingZeros(); this effectively reduces the scale to the minimum possible", "label": {"api": {".stripTrailingZeros()": [[29, 49]]}}}, {"text": "You may also want .toPlainString() if you're trying to display these values nicely, since .stripTrailingZeros() on its own will display 100 as 1E+2", "label": {"api": {".stripTrailingZeros()": [[90, 110]], ".toPlainString()": [[18, 33]]}}}, {"text": "The getResource(String) method called in your first snippet simply isn't declared on ConfigurationManagerUtils - it's declared on the Class class, as an instance method", "label": {"api": {"getResource(String)": [[4, 22]]}}}, {"text": "If the second code snippet works as well, that's because there's a static getResource(String) method declared in ConfigurationManagerUtils (or a superclass)", "label": {"api": {"getResource(String)": [[74, 92]]}}}, {"text": "The first snippet is just using a class literal (ConfigurationManagerUtils.class) to obtain a reference to a Class instance on which it can call the getResource(String) instance method", "label": {"api": {"getResource(String)": [[149, 167]]}}}, {"text": "on the top of your canvas you should use StackPane", "label": {"api": {"StackPane": [[41, 49]]}}}, {"text": "As you see in the documentation, Java 6 allows - and Java 7 allows + or -", "label": {"api": {"Java 6": [[33, 38]], "Java 7": [[53, 58]]}}}, {"text": "With Android Version 19 (KitKat) Java 7 is supported, so you don't get this error", "label": {"api": {"Java 7": [[33, 38]]}}}, {"text": "To enhance your code, you could consider using Joda-Time (Java <= 7) or Java 8 java.time classes", "label": {"api": {"java.time": [[79, 87]]}}}, {"text": "DateTimeFormat/DateTimeFormatter with LocalDateTime(joda)/LocalDateTime(java8) that provide an enhanced API over the standard/old ones", "label": {"api": {"DateTimeFormatter": [[15, 31]], "LocalDateTime(java8)": [[58, 77]]}}}, {"text": "Using Java 8 java.time classes", "label": {"api": {"java.time": [[13, 21]]}}}, {"text": "I also added some Optional to handle the emptyness of the result if the dateInString cannot be parsed instead of null which is bad", "label": {"api": {"Optional": [[18, 25]]}}}, {"text": "You must specify the correct encoding when creating your Scanner", "label": {"api": {"Scanner": [[57, 63]]}}}, {"text": "Constructs a new Scanner that produces values scanned from the specified input stream", "label": {"api": {"Scanner": [[17, 23]]}}}, {"text": "Find here your charset, i guess UTF-16 but not an expert in foreign characters :)", "label": {"api": {"Find here your charset": [[0, 21]], "UTF-16": [[32, 37]]}}}, {"text": "There is even a happens-before commitment (from your link)", "label": {"api": {"your link": [[48, 56]]}}}, {"text": "To delay any task and \"restart\" the delay, you can use Swing timer and if it is running, use its method restart", "label": {"api": {"Swing timer": [[55, 65]]}}}, {"text": "Set#add returns boolean, depending essentially on whether the value has been added - see API", "label": {"api": {"API": [[89, 91]]}}}, {"text": "I'm implementing pipe and filter architecture in java, i'm stuck in scenario in which my in my FilterWriter class i want to send an object over java io's PipedWriter, and on the other hand FilterReader class (PipedReader) will read this object and extract info out of it", "label": {"api": {"PipedWriter": [[154, 164]], "PipedReader": [[209, 219]]}}}, {"text": "Use the ServletContext.setAttribute(String,Object) to store your object", "label": {"api": {"ServletContext.setAttribute(String,Object)": [[8, 49]]}}}, {"text": "Then use ServletContext.getAttribute(String) to access that singleton from your Servlets and Filters", "label": {"api": {"ServletContext.getAttribute(String)": [[9, 43]]}}}, {"text": "If Java 7+, use Objects.equals(); its documentation explicitly specifies that", "label": {"api": {"Objects.equals()": [[16, 31]]}}}, {"text": "You can use an ArrayBlockingQueue with size 1 instead of an ArrayList", "label": {"api": {"ArrayBlockingQueue": [[15, 32]]}}}, {"text": "The ArrayBlockingQueue class provides two blocking calls namely put and take", "label": {"api": {"ArrayBlockingQueue": [[4, 21]], "put": [[64, 66]], "take": [[72, 75]]}}}, {"text": "The ideal way to do this would be to call the put method in your Producer thread and the take method in your Consumer thread in a while loop", "label": {"api": {"put": [[46, 48]], "take": [[89, 92]]}}}, {"text": "Since the queue is initialized with a size of 1, any thread that tries to insert a new element in the queue when it is full will wait when put is called in the while loop", "label": {"api": {"put": [[139, 141]]}}}, {"text": "Similarly, any thread trying to get an element from the queue when it is empty will have to wait when take is called in the while loop", "label": {"api": {"take": [[102, 105]]}}}, {"text": "List#remove() will help", "label": {"api": {"List#remove()": [[0, 12]]}}}, {"text": "If you want a guaranteed HashSet, use Collectors.toCollection(HashSet::new)", "label": {"api": {"Collectors.toCollection(HashSet::new)": [[38, 74]]}}}, {"text": "For Java 8, this is built in to the new java.time package", "label": {"api": {"java.time": [[40, 48]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "You can have the method throw an IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[33, 56]]}}}, {"text": "from empty to non-empty), then IllegalStateException would be a good option", "label": {"api": {"IllegalStateException": [[31, 51]]}}}, {"text": "UnsupportedOperationException is \"part of collections\" but both AWT and NIO subclass it", "label": {"api": {"UnsupportedOperationException": [[0, 28]]}}}, {"text": "This can be done with the getNumericValue(char ch) method from the Character class", "label": {"api": {"Character class": [[67, 81]]}}}, {"text": "You could use a directory stream with a glob like", "label": {"api": {"directory stream": [[16, 31]], "glob": [[40, 43]]}}}, {"text": "You should use executeQuery instead of executeUpdate", "label": {"api": {"executeUpdate": [[39, 51]], "executeQuery": [[15, 26]]}}}, {"text": "executeUpdate is used for a INSERT, UPDATE, or DELETE statement, and will throw an exception if a ResultSet is returned", "label": {"api": {"executeUpdate": [[0, 12]]}}}, {"text": "executeQuery should be used for SELECT statements", "label": {"api": {"executeQuery": [[0, 11]]}}}, {"text": "DefaultListModel will fire the appropriate ListDataEvents when you modify it", "label": {"api": {"ListDataEvents": [[43, 56]]}}}, {"text": "You'll probably be able to make use of java's BlockingQueue for your data structure behind flasherQueue", "label": {"api": {"BlockingQueue": [[46, 58]]}}}, {"text": "Based on the Matrix4f documentation, the numbering of the matrix elements is row major", "label": {"api": {"Matrix4f documentation": [[13, 34]]}}}, {"text": "When you use System.out.print you will invoke PrintStream.print(int) with the integer value of 65 which will in turn print the characters 6 and 5 to the terminal", "label": {"api": {"PrintStream.print(int)": [[46, 67]]}}}, {"text": "When you use out.write you will invoke FileOutputStream.write(byte[]) which will write the bits 01000001 to the file", "label": {"api": {"FileOutputStream.write(byte[])": [[39, 68]]}}}, {"text": "Moreover ArrayList.add can be used to add your Students to your list and you better not add students in constructor use different method to write this scenario", "label": {"api": {"ArrayList.add": [[9, 21]]}}}, {"text": "I am trying to test the parsing of a date-time String with optional fractional seconds of varying significance using DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[117, 133]]}}}, {"text": "Changing the ResolverStyle to LENIENT does not help here as it fails at the parsing stage, not the resolution", "label": {"api": {"LENIENT": [[30, 36]]}}}, {"text": "Should I be using DateTimeFormatterBuilder to optionally specify each fractional digit (9 times), or is there a 'smarter' way with my pattern", "label": {"api": {"DateTimeFormatter": [[18, 34]], "DateTimeFormatterBuilder": [[18, 41]]}}}, {"text": "You can do it by passing a type token, which can then be used to create an instance of a typed using the JDK's Array.newInstance(Class<?> componentType, int length) factory method", "label": {"api": {"Array.newInstance(Class<?> componentType, int length)": [[111, 163]]}}}, {"text": "What you may be able to do, which is quite a bit more verbose, is use the cast method on the class you have from the enum while you iterate over the list, but even then you wouldn't be able to do any dynamic generic assignment", "label": {"api": {"cast": [[74, 77]]}}}, {"text": "This is the toString() implementation of array object, you are looking for Arrays#toString(), which is implemented to actually show you the elements in the array", "label": {"api": {"Arrays#toString()": [[75, 91]]}}}, {"text": "ifPresent requires a Consumer interface to work", "label": {"api": {"Consumer": [[21, 28]]}}}, {"text": "You can use the Pattern.MULTILINE option when compiling your regex", "label": {"api": {"Pattern.MULTILINE": [[16, 32]]}}}, {"text": "In this case one might use HTMLDocument and either construct it with a CSS Stylesheet (body { width", "label": {"api": {"HTMLDocument": [[27, 38]]}}}, {"text": "Another easy way to achieve this is using XPath expressions", "label": {"api": {"XPath": [[42, 46]]}}}, {"text": "You are using TreeSet.addAll() inside the forEach of parallel stream", "label": {"api": {"TreeSet": [[14, 20]]}}}, {"text": "The forEach body can be executed simultaneously several times in different threads for different elements and TreeSet is not thread-safe", "label": {"api": {"TreeSet": [[110, 116]]}}}, {"text": "To fix the problem quickly you can either synchronize modification of result or use forEachOrdered", "label": {"api": {"forEachOrdered": [[84, 97]]}}}, {"text": "However it would be cleaner and more performant to flatMap your stream and collect it at once without forEach", "label": {"api": {"flatMap": [[51, 57]]}}}, {"text": "If you just sequentially as a single InputStream, you can construct a SequenceInputStream", "label": {"api": {"SequenceInputStream": [[70, 88]]}}}, {"text": "A TreeMap is an OrderedMap and a NavigableMap and will allow you to iterate forward and backward, allowing you to access previous and next keys with lowerKey() and higherKey() respectively", "label": {"api": {"TreeMap": [[2, 8]]}}}, {"text": "You can use NavigableMap for this, which entrySet()'s iterator return entries in ascending key order", "label": {"api": {"NavigableMap": [[12, 23]], "in ascending key order": [[78, 99]]}}}, {"text": "When you need to show/print it use SimpleDateFormat for example if you want to show 2015-07-05 16:00:00 you must do like this", "label": {"api": {"SimpleDateFormat": [[35, 50]]}}}, {"text": "The documentation of Stream.flatMap says", "label": {"api": {"documentation of Stream.flatMap": [[4, 34]]}}}, {"text": "The answer by JiriS is incorrect, as it uses appendValue whereas the correct way is to use DateTimeFormatterBuilder.appendFraction (which also handles the decimal point)", "label": {"api": {"DateTimeFormatterBuilder.appendFraction": [[91, 129]], "appendValue": [[45, 55]]}}}, {"text": "The difference can be seen in the second system out, where appendValue incorrectly parses \"2015-05-07T13:20:22.000276\"", "label": {"api": {"appendValue": [[59, 69]]}}}, {"text": "When parsing, LocalDateTime.parse(str, formatter) is a neater approach than using the formatter directly in most cases", "label": {"api": {"LocalDateTime.parse(str, formatter)": [[14, 48]]}}}, {"text": "When using the builder, take advantage of appendPattern() and optionalStart() to keep things neat", "label": {"api": {"builder": [[15, 21]], "appendPattern()": [[42, 56]], "optionalStart()": [[62, 76]]}}}, {"text": "This allows any instance of Float, including new Float(\"NaN\"), to be equal to itself, which is part of the general contract of equals, and new Float(\"-0\") to be different from new Float(\"0\") which might be useful (and is consistent with hashCode)", "label": {"api": {"the general contract of equals": [[103, 132]]}}}, {"text": "Since you're using a plain toString() it should be coverable using a SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[69, 84]]}}}, {"text": "Use a FileDialog or JFileChooser to get the File (name and path) the user selects", "label": {"api": {"File": [[6, 9], [21, 24], [44, 47]]}}}, {"text": "Then use this File to save the image using ImageIO", "label": {"api": {"File": [[14, 17]], "ImageIO": [[43, 49]]}}}, {"text": "When I tried to load the object using ObjectInputStream, it gives an ClassNotFoundException", "label": {"api": {"ObjectInputStream": [[38, 54]], "ClassNotFoundException": [[69, 90]]}}}, {"text": "When you instantiate your class for the first time, the class itself is loaded by java.lang.ClassLoader first, so your debugger is likely trying to step in ClassLoader's code, which you don't have", "label": {"api": {"java.lang.ClassLoader": [[82, 102]]}}}, {"text": "There are two ways you can use a TreeMap", "label": {"api": {"TreeMap": [[33, 39]]}}}, {"text": "either the type that you use for the keys must implement interface Comparable, or you use the constructor of TreeMap that takes a Comparator, and you'll have to pass it an implementation of Comparator that can compare the keys", "label": {"api": {"TreeMap": [[109, 115]], "Comparable": [[67, 76]], "Comparator": [[130, 139], [190, 199]]}}}, {"text": "This is necessary because TreeMap needs to know how to compare the keys so that it can sort the entries in the map by key", "label": {"api": {"TreeMap": [[26, 32]]}}}, {"text": "You get a ClassCastException because the CustomInterfaceImplemenationObject that you are using does not implement Comparable, and you are also not using the constructor of TreeMap that takes a Comparator", "label": {"api": {"TreeMap": [[172, 178]], "Comparable": [[114, 123]], "Comparator": [[193, 202]]}}}, {"text": "First possible solution - make CustomInterfaceImplemenationObject implement Comparable<CustomInterfaceImplemenationObject>", "label": {"api": {"Comparable": [[76, 85]]}}}, {"text": "Second possible solution - pass a Comparator<CustomInterfaceImplemenationObject> to the constructor of TreeMap", "label": {"api": {"TreeMap": [[103, 109]], "Comparator": [[34, 43]]}}}, {"text": "A ConcurrentMap is not a synchronized map", "label": {"api": {"ConcurrentMap": [[2, 14]], "synchronized map": [[25, 40]]}}}, {"text": "In contrast, a ConcurrentMap is designed to allow concurrent updates of different keys and does not synchronizes on itself, so if other code synchronizes on the Map instance, it has no effect", "label": {"api": {"ConcurrentMap": [[15, 27]]}}}, {"text": "On the other hand, if all threads would use the mutex for all accesses to the maps, you wouldn’t need a ConcurrentMap anymore", "label": {"api": {"ConcurrentMap": [[104, 116]]}}}, {"text": "The question is what you actually want to achieve, either, you don’t really need the atomicity or you shouldn’t use ConcurrentMaps", "label": {"api": {"ConcurrentMap": [[116, 128]]}}}, {"text": "Anyway, you can supress the warning by using @SupressWarnings like this", "label": {"api": {"@SupressWarnings": [[45, 60]]}}}, {"text": "You could use a Pattern to strip undesirable characters, but (as demonstrated by the confusion here) it's more hassle than using Guava's out of the box solution", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "Otherwise, you can try to have a look at the endsWith method of the String class", "label": {"api": {"endsWith": [[45, 52]]}}}, {"text": "The RoundingMode documentation for Java (introduced in 1.5) should give you a brief introduction to the different methods people use", "label": {"api": {"RoundingMode": [[4, 15]]}}}, {"text": "Now, take a look at the Semaphore class, be sure to read the description in the beginning of that page, it is really helpful to understand the concept", "label": {"api": {"Semaphore class": [[24, 38]]}}}, {"text": "As per documentation, if you don't specify your own override of the toString method, the parent's (in this case, Object's) method is invoked, and this results in", "label": {"api": {"As per documentation": [[0, 19]]}}}, {"text": "Personally, I would make the method throw an IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[45, 68]]}}}, {"text": "You can safely throw your queue in the garbage, and use a correct ready made version of BlockingQueue instead", "label": {"api": {"BlockingQueue": [[88, 100]]}}}, {"text": "The behaviour you get is the standard one, if you want to have different one, create your own SelectionListener that considers also getValueIsAdjusting()", "label": {"api": {"getValueIsAdjusting()": [[132, 152]]}}}, {"text": "In order to support retries on InputStream uploads, the AmazonS3Client uses the mark and reset methods of the InputStream interface, marking the stream at the beginning of each upload and reseting to the mark if it needs to retry", "label": {"api": {"mark": [[80, 83], [133, 136], [204, 207]], "reset": [[89, 93], [188, 192]]}}}, {"text": "Notice that the mark method takes a readlimit parameter, and is only obligated to \"remember\" as many bytes from the InputStream as you ask it for in advance", "label": {"api": {"mark": [[16, 19]]}}}, {"text": "Some InputStreams implement mark by allocating a new byte[readlimit] to buffer the underlying data in memory so it can be replayed if reset is called, which makes it dangerous to blindly mark using the length of the object to be uploaded (which might be several gigabytes)", "label": {"api": {"mark": [[28, 31], [187, 190]], "reset": [[134, 138]]}}}, {"text": "Instead, the AmazonS3Client defaults to calling mark with a value of 128KB - if your InputStream cares about the readlimit, this means the AmazonS3Client won't be able to retry requests that fail after it has sent more than the first 128KB", "label": {"api": {"mark": [[48, 51]]}}}, {"text": "Use SwingUtilities.getWindowAncestor, if inside the JWindow class, refer it as this, if no, simply put object inside", "label": {"api": {"SwingUtilities.getWindowAncestor": [[4, 35]]}}}, {"text": "Try like this using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[20, 35]]}}}, {"text": "Then you have to convert the Hibernate properties to a Map, so you can pass them to the  createEntityManagerFactory method", "label": {"api": {"createEntityManagerFactory": [[89, 114]]}}}, {"text": "The second one uses Collectors.summingInt() collector, there is also a summingLong() collector which you would use with mapToLong", "label": {"api": {"Collectors.summingInt()": [[20, 42]]}}}, {"text": "Java 8 introduces a very effective LongAdder accumulator designed to speed-up summarizing in parallel streams and multi-thread environments", "label": {"api": {"LongAdder": [[35, 43]]}}}, {"text": "Then execute using Runtime#exec(String[] cmdarray)", "label": {"api": {"Runtime#exec(String[] cmdarray)": [[19, 49]]}}}, {"text": "The JPA EntityManager is not the object to create new databases or users", "label": {"api": {"JPA EntityManager": [[4, 20]]}}}, {"text": "The Servlet container is in charge of the lifecycle of the object reference and will call the destroy method before freeing the object reference", "label": {"api": {"Servlet": [[4, 10]]}}}, {"text": "The Servlet API doesn't provide a method to unregister servlets", "label": {"api": {"Servlet": [[4, 10]]}}}, {"text": "The javadoc of Servlet states it", "label": {"api": {"Servlet": [[15, 21]]}}}, {"text": "That method, as its documentation indicates, takes a regex as first argument, and not a literal substring", "label": {"api": {"its documentation": [[16, 32]]}}}, {"text": "However, streams do have such function, and arrays are convertible to streams", "label": {"api": {"streams do have such function": [[9, 37]], "arrays are convertible to streams": [[44, 76]]}}}, {"text": "That's how the pointers in the list look internally, to actually add it to the list you need to do this", "label": {"api": {"add": [[65, 67]]}}}, {"text": "For this example I will assume you've bound a java.util.Properties for your runtime parameters", "label": {"api": {"java.util.Properties": [[46, 65]]}}}, {"text": "Your questions are answered by the javadoc of setLoginTimeout (emphasis mine)", "label": {"api": {"setLoginTimeout": [[46, 60]]}}}, {"text": "In any Java version I can find, none of these are unique to FileWriter", "label": {"api": {"FileWriter": [[60, 69]]}}}, {"text": "In fact, FileWriter doesn't implement flush(), but OutputStreamWriter does", "label": {"api": {"FileWriter": [[9, 18]], "OutputStreamWriter": [[51, 68]]}}}, {"text": "Aside from direct use or direct subclassing, I can't think of anything builtin besides FileWriter that extends OutputStreamWriter, so that should point you in the right direction", "label": {"api": {"FileWriter": [[87, 96]], "OutputStreamWriter": [[111, 128]]}}}, {"text": "A quick look into the Scanner docs tells me, that nextLine returns exactly what we want", "label": {"api": {"Scanner docs": [[22, 33]]}}}, {"text": "I would suggest reading a bit about MouseEvents in JavaFX", "label": {"api": {"MouseEvents in JavaFX": [[36, 56]]}}}, {"text": "According to http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html isDone returns true if cancel(boolean mayInterruptIfRunning) was called", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html": [[13, 85]]}}}, {"text": "Actually you should implement Comparable but you should also override the equals", "label": {"api": {"Comparable": [[30, 39]]}}}, {"text": "Implementing hashCode is necessary if you wanted to use a HashMap instead", "label": {"api": {"HashMap": [[58, 64]]}}}, {"text": "For those who wonder about Comparator", "label": {"api": {"Comparator": [[27, 36]]}}}, {"text": "This class then needs to implement the Comparator interface", "label": {"api": {"Comparator": [[39, 48]]}}}, {"text": "Properties for those classes can be created by using adapters in javafx.beans.property.adapter package", "label": {"api": {"javafx.beans.property.adapter": [[65, 93]]}}}, {"text": "Use String.replaceAll instead", "label": {"api": {"String.replaceAll": [[4, 20]]}}}, {"text": "In Java, there is the class java.util.zip.ZipFile which you can use in combination with other classes of this package to manipulate the contents of the JAR", "label": {"api": {"java.util.zip.ZipFile": [[28, 48]]}}}, {"text": "To get the String form of an array, use the Arrays class toString method", "label": {"api": {"Arrays": [[44, 49]]}}}, {"text": "See the Scanner docs", "label": {"api": {"Scanner": [[8, 14]]}}}, {"text": "Regarding the last part of your question, you can simply use java.lang.Math.pow(2,exponent), there is no specific operator for that if that was what you were wondering", "label": {"api": {"java.lang.Math.pow(2,exponent)": [[61, 90]]}}}, {"text": "Here in oracle documentation on path's relativize method http://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html#relativize(java.nio.file.Path) For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\"", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html#relativize(java.nio.file.Path)": [[57, 151]]}}}, {"text": "You should use AtomicInteger to hold results", "label": {"api": {"AtomicInteger": [[15, 27]]}}}, {"text": "Also the notify() within the run() method seems to be redundant in this case since its at the end of the method and the lock on the monitor would be relinquished any how", "label": {"api": {"notify()": [[9, 16]]}}}, {"text": "If you're just looking for a sorted (unique) container, there's no reason to use a TreeMap - a TreeSet would seem to fit the bill perfectly", "label": {"api": {"TreeSet": [[95, 101]]}}}, {"text": "If you are looking for performance, consider using the java.util.concurrent.atomic.AtomicLong class", "label": {"api": {"java.util.concurrent.atomic.AtomicLong": [[55, 92]]}}}, {"text": "Furthermore, consider the underlying charset during conversion (see String-Doc)", "label": {"api": {"String-Doc": [[68, 77]]}}}, {"text": "If your file is rather big, read the buffer not at once and use a StringBuilder to concatenate the readings", "label": {"api": {"StringBuilder": [[66, 78]]}}}, {"text": "Use WindowListener windowClosed() method", "label": {"api": {"WindowListener": [[4, 17]], "windowClosed()": [[19, 32]]}}}, {"text": "For arbitrary paths, including arcs, Swing provides the GeneralPath object with has methods for working with a sequence of points connected either by lines or Quadratic/Bezier curves", "label": {"api": {"GeneralPath": [[56, 66]]}}}, {"text": "To model a GeneralPath you can provide a list of points, a winding rule, and the necessary parameters of either a Quadratic curve or a Bezier curve", "label": {"api": {"GeneralPath": [[11, 21]]}}}, {"text": "Path.getFileName() returns a Path containing just the file name", "label": {"api": {"Path.getFileName()": [[0, 17]]}}}, {"text": "Path.startsWith checks if the path starts with the same sequence of path components -- a logical, not textual, operation", "label": {"api": {"Path.startsWith": [[0, 14]]}}}, {"text": "It seems like you actually want Callable, which computes a result, instead of Runnable", "label": {"api": {"Callable": [[32, 39]]}}}, {"text": "submit(Callable) returns a Future which you can call get on and retrieve the result", "label": {"api": {"Callable": [[7, 14]], "submit(Callable)": [[0, 15]], "Future": [[27, 32]]}}}, {"text": "You can even use the @OneToMany(mappedBy = \"employee\", cascade = CascadeType.DETACH) and EntityManager.detach() to detach your phone class and subsequently detach your employee class or vice versa", "label": {"api": {"EntityManager.detach()": [[89, 110]]}}}, {"text": "You can use the @Index JPA annotation", "label": {"api": {"@Index": [[16, 21]]}}}, {"text": "FYI ByteArrayOutputStream is an in-memory output stream you can use to capture and retrieve what was written to it", "label": {"api": {"ByteArrayOutputStream": [[4, 24]]}}}, {"text": "Instead of forming command using + operator you can use ProcessBuilder", "label": {"api": {"ProcessBuilder": [[56, 69]]}}}, {"text": "You can try BigDecimal, or you can simply create your own object that implements the Comparable interface for sorting and has a toString() method that outputs the value formatted to two decimal places", "label": {"api": {"BigDecimal": [[12, 21]], "Comparable": [[85, 94]]}}}, {"text": "According to Javadoc (https://docs.oracle.com/javase/7/docs/api/java/lang/ExceptionInInitializerError.html) is thrown, when an Exception occurs in an static initializer Block", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/ExceptionInInitializerError.html": [[22, 105]]}}}, {"text": "a LinkedBlockingQueue) - you can then have multiple threads servicing that queue as consumers", "label": {"api": {"LinkedBlockingQueue": [[2, 20]]}}}, {"text": "When you use a composite-key, mapped as an Embeddable you need to use @EmbeddedId", "label": {"api": {"@EmbeddedId": [[70, 80]]}}}, {"text": "forEach terminates the stream and is exectued because of the side effect of the called Cosumer", "label": {"api": {"forEach": [[0, 6]], "Cosumer": [[87, 93]]}}}, {"text": "map maps each stream element to a different value/object using a provided Function", "label": {"api": {"map": [[0, 2], [4, 6]], "Function": [[74, 81]]}}}, {"text": "May be you can try adding a listener as shown below and when an item is selected you can use invokeLater and keep the popup open", "label": {"api": {"invokeLater": [[93, 103]]}}}, {"text": "Add an ItemListener to your combo and override itemStateChanged to call showPopup() (but don't call it on the Event Dispatch Thread, use SwingUtilities.InvokeLater())", "label": {"api": {"ItemListener": [[7, 18]], "showPopup()": [[72, 82]], "SwingUtilities.InvokeLater()": [[137, 164]]}}}, {"text": "You can either show the Button first or try to use Node.prefWidth(-1)", "label": {"api": {"Node.prefWidth(-1)": [[51, 68]]}}}, {"text": "Top hit algorithms use a min-heap (PriorityQueue in Java), but there should be some size checking in your algorithm", "label": {"api": {"PriorityQueue": [[35, 47]]}}}, {"text": "PriorityQueue efficiently exposes the item with the lowest score", "label": {"api": {"PriorityQueue": [[0, 12]]}}}, {"text": "This looks like a job for Stack", "label": {"api": {"Stack": [[26, 30]]}}}, {"text": "I'm using FreeMarker which uses java.text.DecimalFormat for its numeric formatting", "label": {"api": {"java.text.DecimalFormat": [[32, 54]]}}}, {"text": "Is there any way to get an equivalent using java.text.DecimalFormat", "label": {"api": {"java.text.DecimalFormat": [[44, 66]]}}}, {"text": "Is there any possibility you could use a java.util.Formatter instead", "label": {"api": {"java.util.Formatter": [[41, 59]]}}}, {"text": "The default appearance of a ProgressBar is a blue bar that moves across the control as the progress increases", "label": {"api": {"ProgressBar": [[28, 38]]}}}, {"text": "You can just use JButton class from Swing package", "label": {"api": {"JButton": [[17, 23]]}}}, {"text": "Without any Layout's Manager, buttons will be placed according to a FlowLayout, i.e", "label": {"api": {"FlowLayout": [[68, 77]]}}}, {"text": "It looks like you're trying to map groups of three characters to single characters, a Map<String, String> can do this easily in roughly three lines", "label": {"api": {"String": [[90, 95], [98, 103]]}}}, {"text": "In that vein, look closely at the functionality provided by String, particularly String.substring() - you can get each three-letter substring easily, without manually extracting each character", "label": {"api": {"String": [[60, 65], [81, 86]], "String.substring()": [[81, 98]]}}}, {"text": "I think you should use @OrderColumn and not @OrderBy", "label": {"api": {"@OrderColumn": [[23, 34]], "@OrderBy": [[44, 51]]}}}, {"text": "The @OrderBy annotation is used when fetching Collection elements but the order is not maintained by Hibernate", "label": {"api": {"@OrderBy": [[4, 11]]}}}, {"text": "The @OrderColumn allows Hibernate to persist the element Collection index into the designated order column, which is then used when fetching the collection", "label": {"api": {"@OrderColumn": [[4, 15]]}}}, {"text": "s1.concat(\"def\"); and s2.concat(\"def\"); are happening at runtime, they won't be part of the constant pool, they goes to the heap", "label": {"api": {"s1.concat(\"def\");": [[0, 16]]}}}, {"text": "Sounds like you want to read up on anyMatch", "label": {"api": {"anyMatch": [[35, 42]]}}}, {"text": "Inversely, there's also noneMatch", "label": {"api": {"noneMatch": [[24, 32]]}}}, {"text": "Use a StringJoiner", "label": {"api": {"StringJoiner": [[6, 17]]}}}, {"text": "You can also create a java class C that uses the ProcessBuilder to start the two other programs (apparently an overkill for you problem)", "label": {"api": {"ProcessBuilder": [[49, 62]]}}}, {"text": "You can read about that in the javadoc for Class.getEnclosingConstructor", "label": {"api": {"javadoc for Class.getEnclosingConstructor": [[31, 71]]}}}, {"text": "That would require you to use ServerSocketChannel and related classes", "label": {"api": {"ServerSocketChannel": [[30, 48]]}}}, {"text": "replaceAll takes a regular expression, and /** isn't a valid regular expression", "label": {"api": {"replaceAll": [[0, 9]], "replace": [[0, 6]]}}}, {"text": "If you just want to remove /**, use replace instead", "label": {"api": {"replace": [[36, 42]]}}}, {"text": "replaceAll takes a regular expression argument, and $1 is a special way of telling the java regex engine to use group-one as the replacement", "label": {"api": {"replaceAll": [[0, 9]], "replace": [[0, 6], [129, 135]]}}}, {"text": "You need to use replace which matches/replaces the string literally", "label": {"api": {"replace": [[16, 22], [38, 44]]}}}, {"text": "You could also escape the $ character if you still need to use replaceAll", "label": {"api": {"replaceAll": [[63, 72]], "replace": [[63, 69]]}}}, {"text": "You need to make the part that matches the file name reluctant, i.e", "label": {"api": {"reluctant": [[53, 61]]}}}, {"text": "If you want to jump on the Java 8 wagon, returning a Stream probably is a more \"modern\" approach", "label": {"api": {"Stream": [[53, 58]]}}}, {"text": "I assume that according to the Jersey JAXRS Client API the client will redirect automatically to the new specified URL, but I'm getting a RedirectionException instead", "label": {"api": {"RedirectionException": [[138, 157]]}}}, {"text": "In browser it works fine, but Jersey client seems to be ignoring FOLLOW_REDIRECTS property and throws an RedirectionException instead", "label": {"api": {"RedirectionException": [[105, 124]]}}}, {"text": "It will be trivial to implement multithreading if they don't need to share any information, you can just implement Runnable interface, create new thread passing the implementation of Runnable, and wait them to end with Thread.join()", "label": {"api": {"Runnable": [[115, 122], [183, 190]], "Thread.join()": [[219, 231]]}}}, {"text": "Alternatively, the Instrumentation interface would allow you to change a loaded class at runtime", "label": {"api": {"Instrumentation interface": [[19, 43]]}}}, {"text": "You can use a DecimalFormat to convert the number directly to a String", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "Alternatively, you can call String.format with a 0 to indicate leading zeros and a 12 for the length", "label": {"api": {"String.format": [[28, 40]], "0 to indicate leading zeros and a 12 for the length": [[49, 99]]}}}, {"text": "Read the section on Requesting Focus", "label": {"api": {"Requesting Focus": [[20, 35]]}}}, {"text": "To fix this, you should use a different variable for each player, for example \"kills.playerUUIDHere\" and \"deaths.playerUUIDHere\"", "label": {"api": {"UUID": [[91, 94], [119, 122]]}}}, {"text": "To get a player's UUID, you can use player.getUniqueId(), then to get the String representation of the UUID, you could use uuid.toString()", "label": {"api": {"UUID": [[18, 21], [103, 106]], "uuid.toString()": [[123, 137]]}}}, {"text": "read about patterns in java", "label": {"api": {"read about patterns in java": [[0, 26]]}}}, {"text": "For purposes of generating random numbers in a game, java.util.Random is perfectly fine", "label": {"api": {"java.util.Random": [[53, 68]]}}}, {"text": "There is also java.security.SecureRandom but you don't need that for a game, and also it is significantly slower", "label": {"api": {"java.security.SecureRandom": [[14, 39]]}}}, {"text": "The Collection.retainAll method exists for exactly that purpose", "label": {"api": {"Collection.retainAll": [[4, 23]]}}}, {"text": "This might be a very large number, so I suggest using a BigInteger object for it", "label": {"api": {"BigInteger": [[56, 65]]}}}, {"text": "You should use SwingUtilities.invokeLater for this", "label": {"api": {"SwingUtilities.invokeLater": [[15, 40]]}}}, {"text": "For example ArrayList<AddressBook> should have been named listOfAddressBook etc", "label": {"api": {"ArrayList": [[12, 20]]}}}, {"text": "There are methods to remove an item or modify an item in ArrayList and it is better to read about them to improve your learning rather than asking for help", "label": {"api": {"ArrayList": [[57, 65]]}}}, {"text": "List<AddressBook> person = new ArrayList<>(); so go and find out why this ie better than your approach", "label": {"api": {"ArrayList": [[31, 39]]}}}, {"text": "You have to use AtomicInteger  to achieve Thread safety", "label": {"api": {"AtomicInteger": [[16, 28]]}}}, {"text": "Thread safe using AtomicInteger", "label": {"api": {"AtomicInteger": [[18, 30]]}}}, {"text": "For this purpose, Java provides a SwingWorker class which allows code to queue items on the EDT", "label": {"api": {"SwingWorker": [[34, 44]]}}}, {"text": "You can specifically use a ArrayList", "label": {"api": {"ArrayList": [[27, 35]]}}}, {"text": "See the reference for more information", "label": {"api": {"the reference": [[4, 16]]}}}, {"text": "Check out Formatter class to know more about formatting a String", "label": {"api": {"Formatter": [[10, 18]]}}}, {"text": "The issue with Point.getX() is that it returns a double instead of an int", "label": {"api": {"Point.getX()": [[15, 26]]}}}, {"text": "The getX() and getY() functions of the Point class return a double because that's what its parent class (Point2D) requires", "label": {"api": {"Point2D": [[105, 111]]}}}, {"text": "This is so all of its subclasses (Point2D.Double and Point2D.Float) will all work in the same places", "label": {"api": {"Point2D": [[34, 40], [53, 59]], "Point2D.Double": [[34, 47]], "Point2D.Float": [[53, 65]]}}}, {"text": "To vertically align text on adjacent lines, a fixed width Font (such as Courier) can be used", "label": {"api": {"Font": [[58, 61]]}}}, {"text": "If using Swing, you can can set the Font of a JTextComponent using the appropriate method", "label": {"api": {"Font": [[36, 39]]}}}, {"text": "The fixed width Font will let the nth character on one line be aligned with the nth character on all other lines", "label": {"api": {"Font": [[16, 19]]}}}, {"text": "I used SwingNode and wrapped JTextField inside", "label": {"api": {"SwingNode": [[7, 15]], "JTextField": [[29, 38]]}}}, {"text": "JTextField offers possibility of setting Font from AWT", "label": {"api": {"JTextField": [[0, 9]], "setting Font from AWT": [[33, 53]]}}}, {"text": "To do so use Font's attributes and set TRACKING according to your needs", "label": {"api": {"attributes": [[20, 29]], "TRACKING": [[39, 46]]}}}, {"text": "For instance, I am facing huge problems with dynamic rendering of given JTextField in my app", "label": {"api": {"JTextField": [[72, 81]]}}}, {"text": "Use Pattern#quote(String regex)", "label": {"api": {"Pattern#quote(String regex)": [[4, 30]]}}}, {"text": "We can do comparisons generically through the Comparable interface", "label": {"api": {"Comparable": [[46, 55]]}}}, {"text": "Both Float and Integer implement Comparable", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "A line-for-line copy of your code using Comparable would be", "label": {"api": {"Comparable": [[40, 49]]}}}, {"text": "You can use String.valueOf  to convert any primitive type (int, double, boolean, etc.) to a String", "label": {"api": {"String.valueOf ": [[12, 26]]}}}, {"text": "You can also use Integer.toString or Double.toString, which convert their respective types to String", "label": {"api": {"Integer.toString": [[17, 32]], "Double.toString": [[37, 51]]}}}, {"text": "charAt() is a method that only works on Strings, as described in the documentation", "label": {"api": {"charAt()": [[0, 7]]}}}, {"text": "So the part where you're going wrong is that you're not specifying on which String you want to call the charAt() method", "label": {"api": {"charAt()": [[104, 111]]}}}, {"text": "Instead of using the toString method, you can try String.valueOf", "label": {"api": {"String.valueOf": [[50, 63]]}}}, {"text": "If I kill an Android app with System.exit(...), does it matter what status code I pass", "label": {"api": {"System.exit(...)": [[30, 45]]}}}, {"text": "The Javadoc of CopyOnWriteArrayList states the following", "label": {"api": {"Javadoc of CopyOnWriteArrayList": [[4, 34]]}}}, {"text": "Specifically, it's not transitive, which the contract for .equals() requires", "label": {"api": {".equals()": [[58, 66]]}}}, {"text": "However what you can do is define a custom Comparator (or Ordering, if you're using Guava)", "label": {"api": {"Comparator": [[43, 52]]}}}, {"text": "For most use cases (like sorting, searching, or filtering) you should be able to use a separate Comparator instance just like you would the .equals() method", "label": {"api": {".equals()": [[140, 148]], "Comparator": [[96, 105]]}}}, {"text": "If you can't use a separate Comparator for whatever reason, your Employee object will be fundamentally inconsistent, and will prove problematic even if you should get a \"workable\" .hashCode() implemented", "label": {"api": {"Comparator": [[28, 37]]}}}, {"text": "I guess, you cannot write a consistent hashCode in your case, because your equals breaks the contract of Object.equals method, namely transitivity", "label": {"api": {"Object.equals": [[105, 117]]}}}, {"text": "Java, luckily, has a built it mechanism for such sorting - you just need to implement a Comparator", "label": {"api": {"Comparator": [[88, 97]]}}}, {"text": "PriorityQueue needs the data structure that implements Comparable interface unless you pass in a Comparator as a constructor", "label": {"api": {"constructor": [[113, 123]]}}}, {"text": "In order to draw a point use fillOval(x, y, r, r) method from Graphics class", "label": {"api": {"Graphics class": [[62, 75]]}}}, {"text": "Btw, if you use mouseClicked() event, sometimes you will see how your clicks appear to not have effect (to click doesn't draw or store anything), this is because the program is detecting the mouseDragged() event from MouseMotionListener Interface", "label": {"api": {"MouseMotionListener Interface": [[217, 245]]}}}, {"text": "To solve this you can change the current event mouseClicked() for mousePressed() event from MouseListener Interface as I already did in the code", "label": {"api": {"MouseListener Interface": [[92, 114]]}}}, {"text": "You can use peek", "label": {"api": {"peek": [[12, 15]]}}}, {"text": "this way not all the elements might be passed to peek", "label": {"api": {"peek": [[49, 52]]}}}, {"text": "You can create a List (and other kinds of Collections) from any other Collection simply by passing it in the list constructor", "label": {"api": {"constructor": [[114, 124]]}}}, {"text": "There is also the addAll() method if you have to, for example, build a list then copy it", "label": {"api": {"addAll()": [[18, 25]]}}}, {"text": "Finally, you can create an unmodifiableList copy of the a list to ensure it never gets changed", "label": {"api": {"unmodifiableList": [[27, 42]]}}}, {"text": "The Mnemonic in JavaFX fires an ActionEvent targeted at the registered Node", "label": {"api": {"ActionEvent": [[32, 42]]}}}, {"text": "In the case of RadioButton, the ActionEvent doesn't toggle selection", "label": {"api": {"ActionEvent": [[32, 42]]}}}, {"text": "You can add a generic handler to the RadioButton to toggle on the ActionEvent like this (assuming this is JavaFX 8)", "label": {"api": {"ActionEvent": [[66, 76]]}}}, {"text": "And you should use a BlockingQueue rather than a List to avoid this scenario", "label": {"api": {"BlockingQueue": [[21, 33]]}}}, {"text": "Private keys can be encoded using the getEncoded() method and read in using PKCS8EncodedKeySpec supplied to an \"RSA\" KeyFactory instance", "label": {"api": {"getEncoded()": [[38, 49]], "PKCS8EncodedKeySpec": [[76, 94]], "KeyFactory": [[117, 126]]}}}, {"text": "The item in the list will need to implement Comparable", "label": {"api": {"Comparable": [[44, 53]]}}}, {"text": "Here's an example https://www.javatpoint.com/Comparable-interface-in-collection-framework", "label": {"api": {"Comparable": [[45, 54]]}}}, {"text": "an ArrayBlockingQueue, which has the advantage of being bounded); you can then have any number of threads removing and processing emails from this queue", "label": {"api": {"ArrayBlockingQueue": [[3, 20]]}}}, {"text": "The synchronization overhead on the ArrayBlockingQueue is fairly lightweight, and this way you don't need to use database transactions or anything like that", "label": {"api": {"ArrayBlockingQueue": [[36, 53]]}}}, {"text": "Note that by using Matcher#matches() (not find) and leaving the trailing .*, it will cater for your syntax that is anchored at the start only", "label": {"api": {"Matcher#matches()": [[19, 35]]}}}, {"text": "Assuming you're using an HttpsURLConnection, getServerCertificates() should give you what you want (index 0 being the server certificate itself)", "label": {"api": {"getServerCertificates()": [[45, 67]]}}}, {"text": "You'll get one of its instance when using URL.openConnection(), but you'll need to cast the result explicitly to be able to use getServerCertificates()", "label": {"api": {"getServerCertificates()": [[128, 150]], "URL.openConnection()": [[42, 61]]}}}, {"text": "If you have an SSLSocket or an SSLEngine instead, use their getSSLSession() method to get the SSLSession, and then getPeerCertificates() on the session", "label": {"api": {"getPeerCertificates() on the session": [[115, 150]]}}}, {"text": "java.lang.AssertionError doesn't have the constructor mentioned in the error message", "label": {"api": {"doesn't have the constructor": [[25, 52]]}}}, {"text": "You'd make use of Number's methods", "label": {"api": {"Number's methods": [[18, 33]]}}}, {"text": "Given your constraints, however, one optimization you could try is using a DoubleAccumulator, which was intended for cases like these, instead of your one-element array and synchronization", "label": {"api": {"DoubleAccumulator": [[75, 91]]}}}, {"text": "You can use a DatePicker and then use the getters from that to either make a Calendar object or to get the time in millis", "label": {"api": {"Calendar": [[77, 84]]}}}, {"text": "I use this function in my projects to get the Calendar from the DatePicker, you may want to extend it to set the hours/ minutes as well", "label": {"api": {"Calendar": [[46, 53]]}}}, {"text": "Once you have the Calendar you can use myCalendar.getTimeInMillis() which returns a long of the time in millis since the epoch", "label": {"api": {"Calendar": [[18, 25], [41, 48]]}}}, {"text": "Consider java.util.Calendar class and the following code", "label": {"api": {"java.util.Calendar": [[9, 26]]}}}, {"text": "You can use the DatabaseMetadata interface", "label": {"api": {"DatabaseMetadata": [[16, 31]]}}}, {"text": "Use EntityManager.detach(), to detach the entity from the persistence context", "label": {"api": {"EntityManager.detach()": [[4, 25]]}}}, {"text": "Use mousePressed() from MouseListener Interface instead", "label": {"api": {"MouseListener Interface": [[24, 46]]}}}, {"text": "The File#createTempFile() indeed immediately creates an empty file", "label": {"api": {"File#createTempFile()": [[4, 24]]}}}, {"text": "This can be done in many ways, for example by using shared Semaphore", "label": {"api": {"Semaphore": [[59, 67]]}}}, {"text": "In main code, use shared Semaphore to synchronize", "label": {"api": {"Semaphore": [[25, 33]]}}}, {"text": "As for NPE, you could use Optional from guava or JDK8 to avoid it", "label": {"api": {"Optional": [[26, 33]]}}}, {"text": "Use a tickLabelFormatter on the axis", "label": {"api": {"tickLabelFormatter": [[6, 23]]}}}]