[{"text":"You can also use Objects.equals that does the null check for you","label":{"api":{"Objects.equals":[[17,30]]}}},{"text":"Just use java.lang.Classloader.getResourceAsStream(String name)","label":{"api":{"java.lang.Classloader.getResourceAsStream(String name)":[[9,62]]}}},{"text":"Use a CountDownLatch with a count of 1, like startSignal in the example","label":{"api":{"CountDownLatch":[[6,19]],"startSignal":[[45,55]]}}},{"text":"You can do this quite straightforward with an URLConnection","label":{"api":{"URLConnection":[[46,58]]}}},{"text":"java.text.DateFormat objects are not thread safe","label":{"api":{"java.text.DateFormat":[[0,19]]}}},{"text":"Basically, the Jython engine (which I assume you are using for scripting python) allows you to use its ScriptEngine as an Invocable","label":{"api":{"ScriptEngine":[[103,114]],"Invocable":[[122,130]]}}},{"text":"In Swing, the GradientPaint class can be used to draw a gradient","label":{"api":{"Swing":[[3,7]],"GradientPaint":[[14,26]]}}},{"text":"Assuming that the input string will always be in that format, with 4 integers between each bracket, I think the best way to do it would simply be to use a Scanner object and it's nextInt() method which will ignore the brackets and comma's and just find the numbers","label":{"api":{"Scanner":[[155,161]],"nextInt()":[[179,187]]}}},{"text":"I'm not sure I understand your problem, but maybe the method you're looking for is getName()","label":{"api":{"getName()":[[83,91]]}}},{"text":"A quick search on the page reveals the method getName(), which does what you want","label":{"api":{"getName()":[[46,54]]}}},{"text":"If you're using Java 8, you can pass a method reference to Comparator.comparing to construct a Comparator based on a getter method","label":{"api":{"Comparator.comparing":[[59,78]],"Comparator":[[95,104]],"getter":[[117,122]]}}},{"text":"To make a descending sort, you can call reversed","label":{"api":{"reversed":[[40,47]]}}},{"text":"I am using an HttpSessionListener implementation to populate that Hashtable and eliminate the expired sessions on its sessionCreated and sessionDestroyed methods","label":{"api":{"HttpSessionListener":[[14,32]],"Hashtable":[[66,74]],"sessionCreated":[[118,131]],"sessionDestroyed":[[137,152]]}}},{"text":"Different drivers may behave differently and different ResultSet settings may behave differently","label":{"api":{"ResultSet":[[55,63]]}}},{"text":"But you can call Double.compare, which will compare two primitive doubles for you","label":{"api":{"Double.compare":[[17,30]]}}},{"text":"The best approach would be to add a MediaView to the fxml if you want to create a videoplayer, or do not add anything if you just want to play audio","label":{"api":{"MediaView":[[36,44]]}}},{"text":"Inside your controller, create instances of MediaPlayer and Media, load media and add them to MediaView, if required","label":{"api":{"MediaPlayer":[[44,54]],"Media":[[60,64]],"MediaView":[[94,102]]}}},{"text":"First of all, as @user2357112 points out, Random implements Serializable, and does so by writing the seed field (along with the nextNextGaussian and haveNextNextGaussian fields)","label":{"api":{"Random":[[42,47]],"Serializable":[[60,71]],"nextNextGaussian":[[128,143]],"haveNextNextGaussian":[[149,168]]}}},{"text":"gson.fromJson(gson.toJson(r), Random.class); returns an identical object","label":{"api":{"gson.fromJson(gson.toJson(r), Random.class)":[[0,42]]}}},{"text":"You don't necessarily need the same Random instance, just a consistent one","label":{"api":{"Random":[[36,41]]}}},{"text":"Then just initialize a Random instance with that seed, and now all runs loaded from that file will behave the same","label":{"api":{"Random":[[23,28]]}}},{"text":"If you wanted, you could even reset the Random instance in your currently running game to the same seed too","label":{"api":{"Random":[[40,45]]}}},{"text":"On the other hand if you're generating maps or other seemingly-constant content randomly and want it to persist between loads, I'd think you'd do better to simply seed your Random at the start, and save that value like you describe","label":{"api":{"Random":[[173,178]]}}},{"text":"I would consider just leaving your game's Random unseeded and let each game be slightly unique","label":{"api":{"Random":[[42,47]]}}},{"text":"Files inside JARs and WARs are located as Java Resources, which can be handled by the Java class loader using the getResourceAsStream() method, which returns an InputStream to the resource","label":{"api":{"Resources":[[47,55]],"class loader":[[91,102]],"getResourceAsStream()":[[114,134]],"InputStream":[[161,171]]}}},{"text":"Simply you can use ExecutorService to create a thread pool","label":{"api":{"ExecutorService":[[19,33]]}}},{"text":"You can use Files class","label":{"api":{"Files":[[12,16]]}}},{"text":"You can account for this using convertRowIndexToModel and convertColumnIndexToModel","label":{"api":{"convertRowIndexToModel":[[31,52]],"convertColumnIndexToModel":[[58,82]]}}},{"text":"The method decode(ByteBuffer, CharBuffer, boolean) returns a result, but you are ignoring the result","label":{"api":{"decode(ByteBuffer, CharBuffer, boolean)":[[11,49]]}}},{"text":"You can override prepareRenderer(), like they show here, and add a MatteBorder to the bottom when the row matches the one you want","label":{"api":{"prepareRenderer()":[[17,33]],"MatteBorder":[[67,77]]}}},{"text":"To ensure there is data available before calling the read(byte[]) method, you can call the available() method, documented here","label":{"api":{"read(byte[])":[[53,64]],"available()":[[91,101]]}}},{"text":"Key methods from JMS spec are getJMSCorrelationID and setJMSCorrelationID","label":{"api":{"getJMSCorrelationID":[[30,48]],"setJMSCorrelationID":[[54,72]]}}},{"text":"While you can't re-run a Thread directly, you can use a ScheduledExecutorService to execute a Thread (or anything else that implements Runnable) periodically","label":{"api":{"Thread":[[25,30],[94,99]],"ScheduledExecutorService":[[56,79]],"Runnable":[[135,142]]}}},{"text":"The package java.awt.geom allows testing if a point lies within a rectangle and similar questions","label":{"api":{"java.awt.geom":[[12,24]]}}},{"text":"If you want, you may provide similar functionality by implementing CharSequence - all these classes implement this interface","label":{"api":{"CharSequence":[[67,78]]}}},{"text":"There are Appendable and CharSequence filling this gap and offering much more flexibility","label":{"api":{"Appendable":[[10,19]],"CharSequence":[[25,36]]}}},{"text":"And since keys like (BaseRate|Rate|tk_rate) are in fact valid regular expressions, you can just use replaceAll to replace them in all their variants","label":{"api":{"BaseRate|Rate|tk_rate":[[21,41]],"replaceAll":[[100,109]]}}},{"text":"If they are not contained in the string, replaceAll will just do nothing, so the contains check is not really necessary","label":{"api":{"replaceAll":[[41,50]]}}},{"text":"When the nextInt method is called with 6 as a parameter, it will return a random number between 0 and 5","label":{"api":{"nextInt":[[9,15]]}}},{"text":"If you are using a SimpleDateFormat, you will need to create an instance with the target Locale","label":{"api":{"SimpleDateFormat":[[19,34]],"Locale":[[89,94]]}}},{"text":"If you are using a DateFormat style, you would need to get an instance for the target locale","label":{"api":{"DateFormat":[[19,28]],"locale":[[86,91]]}}},{"text":"In both cases, it appears you want to change the timezone also","label":{"api":{}}},{"text":"Depending on what you're trying to accomplish, you may want to look at the StringTokenizer class","label":{"api":{"StringTokenizer":[[75,89]]}}},{"text":"You can use String.join StringBuilder and String.split","label":{"api":{"String.join":[[12,22]],"StringBuilder":[[24,36]],"String.split":[[42,53]]}}},{"text":"This link also provides some documentation on the same","label":{"api":{}}},{"text":"You need to import time class","label":{"api":{"time":[[19,22]]}}},{"text":"With reference to this answer, it's possible to catch all uncaught Exceptions in Java","label":{"api":{}}},{"text":"Swing Threading Policy states","label":{"api":{"Swing Threading Policy":[[0,21]]}}},{"text":"Now, it so happens that the Integer class has an inline cache which covers all values from -128 up to 127 at least, as the javadoc of Integer.valueOf() explains","label":{"api":{"Integer":[[28,34]],"Integer.valueOf()":[[134,150]]}}},{"text":"To your actual question, to load an image from a file as a BufferedImage object, call javax.imageio.ImageIO.read with the File object","label":{"api":{"BufferedImage":[[59,71]],"javax.imageio.ImageIO.read":[[86,111]],"File":[[122,125]]}}},{"text":"Extend AbstractTableModel as shown here","label":{"api":{"AbstractTableModel":[[7,24]]}}},{"text":"If your concern is that you want A instances with equal but distinct b members to hash differently, rather than making sure A and B instances hash differently, you can use System.identityHashCode","label":{"api":{"System.identityHashCode":[[172,194]]}}},{"text":"by overriding getPreferredSize() or setting it with setPreferredSize(…)) or do setSize(…)","label":{"api":{"getPreferredSize()":[[14,31]],"setPreferredSize(…)":[[52,70]],"setSize(…)":[[79,88]]}}},{"text":"Have a look at the java.util.Scanner class, it can help to read separate tokens from a Reader","label":{"api":{"java.util.Scanner":[[19,35]]}}},{"text":"In fact, the LinkedList collection standard API in Java has such a method","label":{"api":{"LinkedList":[[13,22]]}}},{"text":"This creates a Scanner, that scans only on the String \"System.in\"","label":{"api":{"Scanner":[[15,21]]}}},{"text":"You might want to check the documentation of move and delete","label":{"api":{"move":[[45,48]],"delete":[[54,59]]}}},{"text":"Also, use System.nanoTime() for nano timings","label":{"api":{"System.nanoTime()":[[10,26]]}}},{"text":"Is there a specific reason why people don't always use \"Object\" as their data type to pass values","label":{"api":{"Object":[[56,61]]}}},{"text":"Since Java is strongly typed, you cannot do a whole lot with Object","label":{"api":{"Object":[[61,66]]}}}]