[{"text":"If you only need the limited functionality provided by the methods in Object, then sure, you can use it as a type","label":{"api":{"Object":[[70,75]]}}},{"text":"This is working as specified","label":{"api":{}}},{"text":"From the spec","label":{"api":{}}},{"text":"From the docs on Stream for the peek method","label":{"api":{"Stream":[[17,22]],"peek":[[32,35]]}}},{"text":"An AtomicInteger fits your need","label":{"api":{"AtomicInteger":[[3,15]]}}},{"text":"AtomicInteger#incrementAndGet is an atomic operation","label":{"api":{"AtomicInteger#incrementAndGet":[[0,28]]}}},{"text":"split takes a regular expression as an argument","label":{"api":{"split":[[0,4]]}}},{"text":"Or better, use Class#isArray()","label":{"api":{"Class#isArray()":[[15,29]]}}},{"text":"Please refer to the documentation of DateTimeFormatter, where there is a list of all formatting and parsing formats","label":{"api":{"DateTimeFormatter":[[37,53]]}}},{"text":"If the values in the array are non-negative and reasonably small, you can use a BitSet to store whether or not you have seen a value previously","label":{"api":{"BitSet":[[80,85]]}}},{"text":"Here's a sample Comparator I wrote to sort multi-dimensional arrays by their first element","label":{"api":{"Comparator":[[16,25]]}}},{"text":"Usually you will only write a comparator if you are going to pass it into a static method that compares two instances (passing a Comparator is essentially like passing a function in other languages)","label":{"api":{"comparator":[[30,39]],"Comparator":[[129,138]]}}},{"text":"If you want to compare one instance to another instance, then you would implement the interface Comparable on the class itself (rather than create a new class, as I did)","label":{"api":{"Comparable":[[96,105]]}}},{"text":"The best place for initialization code in a web application is inside a ServletContextListener's contextInitialized method","label":{"api":{"ServletContextListener":[[72,93]],"contextInitialized":[[97,114]]}}},{"text":"The solution then is to create a ListSelectionListener that iterates over all of the lists and calls list.clearSelection() on each one, except for the list that triggered the selection event (which can be determined by ListSelectionEvent.getSource()","label":{"api":{"ListSelectionListener":[[33,53]],"list.clearSelection()":[[101,121]],"ListSelectionEvent.getSource()":[[219,248]]}}},{"text":"Here is roughly what the ListSelectionListener implementation should look like","label":{"api":{"ListSelectionListener":[[25,45]]}}},{"text":"Since the lists can change dynamically, you'll need to call JList.addListSelectionListener() whenever a new list is added to the frame","label":{"api":{"JList.addListSelectionListener()":[[60,91]]}}},{"text":"Hopefully you have some sort of addSection method that you can tack on to, but if all else fails, you can always add a ComponentListener to whatever container the sections are placed into, and search for the lists in the component hierarchy whenever a new section is added to the container","label":{"api":{"addSection":[[32,41]],"ComponentListener":[[119,135]]}}},{"text":"String implements a Comparable<String> which is implemented as a lexicographical comparison, in other words, by default \"Apple\".compareTo(\"Orange\") < 0","label":{"api":{"String":[[0,5]],"Comparable<String>":[[20,37]]}}},{"text":"Now Collections.sort has a variant that takes this comparator into account, you can thus simply use","label":{"api":{"Collections.sort":[[4,19]]}}},{"text":"You shouldn't use String.valueof to cast back to a string","label":{"api":{"String.valueof":[[18,31]]}}},{"text":"you can compare chars with the <, but you can't use this operator on Strings","label":{"api":{"String":[[69,74]]}}},{"text":"if the two first characters are equal, that doesn't mean the String's are equal per se, for instance \"Apple\" and \"Ambiguous\"","label":{"api":{"String":[[61,66]]}}},{"text":"You use the values given in the Font class, for example","label":{"api":{"Font":[[32,35]]}}},{"text":"You should also check whether you are expecting normal List#add behaviour which appends to the end of a list not the beginning","label":{"api":{"List#add":[[55,62]]}}},{"text":"You are using a Queue specifically designed to be non-blocking as a BlockingQueue","label":{"api":{"Queue":[[16,20]],"BlockingQueue":[[68,80]]}}},{"text":"The BlockingQueue is bounded at 8 elements","label":{"api":{"BlockingQueue":[[4,16]]}}},{"text":"Use Collections.shuffle() on your set of quarters and pennies, and check the first three elements after each shuffle","label":{"api":{"Collections.shuffle()":[[4,24]]}}},{"text":"When the user is inputting numbers, you should use sc.nextInt()","label":{"api":{"sc.nextInt()":[[51,62]]}}},{"text":"If you're expecting strings of characters and want to convert them into ints, you can use Character.getNumericValue(myChar) on each character of the input string individually","label":{"api":{"Character.getNumericValue(myChar)":[[90,122]]}}},{"text":"Don't use replaceAll(String regex, String replacement) since it accepts a regular expression as first argument (which you don't need it), use replace(CharSequence target, CharSequence replacement) instead","label":{"api":{"replaceAll(String regex, String replacement)":[[10,53]],"replace(CharSequence target, CharSequence replacement)":[[142,195]]}}},{"text":"You have to mark desired elements as mandatory ones with a required annotation property","label":{"api":{}}},{"text":"As for attributes it works the same way, you have to mark them as required","label":{"api":{}}},{"text":"Do not call close() on the BufferedReader, because it will close all system handles and files underneath it (see Javadoc for BufferedReader close() method)","label":{"api":{"close()":[[12,18],[140,146]],"BufferedReader":[[27,40],[125,138]]}}},{"text":"Quoted from String.split(String regex) documentation","label":{"api":{"String.split(String regex)":[[12,37]]}}},{"text":"The Java Stack class throws an EmptyStackException in those cases","label":{"api":{"Stack":[[9,13]],"EmptyStackException":[[31,49]]}}},{"text":"In Java 8, you can use Optional<T>","label":{"api":{"Optional<T>":[[23,33]]}}},{"text":"Either you use the Optional<T> class stated in comments and in the other answer or if you want to avoid returning null you could return a list of your object which would be empty if you don't have any result to return","label":{"api":{"Optional<T>":[[19,29]]}}},{"text":"Couldn't it be achieved with a proper value to setResizeWeight()","label":{"api":{"setResizeWeight()":[[47,63]]}}},{"text":"Where the 'XXX', according to SimpleDateFormat API docs, means ISO 8601 time zone","label":{"api":{"SimpleDateFormat":[[30,45]]}}},{"text":"You can do non-blocking sockets with ServerSocketChannel","label":{"api":{"ServerSocketChannel":[[37,55]]}}},{"text":"call configureBlocking(false) to do non-blocking","label":{"api":{"configureBlocking(false)":[[5,28]]}}},{"text":"You can also use a Predicate<Pojo> and a filter","label":{"api":{"Predicate<Pojo>":[[19,33]],"filter":[[41,46]]}}},{"text":"The key to this is creating a class that implements the Icon interface","label":{"api":{"Icon":[[56,59]]}}},{"text":"Override the icon's paintIcon() method, which receives the suitable graphics context, and do your rendering there","label":{"api":{"paintIcon()":[[20,30]]}}},{"text":"A Java short is 16 bit, and the DataBufferUShort is made for storing unsigned 16 bit values","label":{"api":{"DataBufferUShort":[[32,47]]}}},{"text":"It looks like you want to look at https://docs.oracle.com/javase/7/docs/api/java/io/ByteArrayInputStream.html","label":{"api":{}}},{"text":"The serialVersionUID is only relevant to classes which generate a stream identifier","label":{"api":{"serialVersionUID":[[4,19]]}}},{"text":"This is not the case if the serializable class has a writeReplace() method (also described in the Serializable documentation) that returns a substitute object of a different class, as such a representation is fully decoupled from the original class","label":{"api":{"serializable":[[28,39]],"writeReplace()":[[53,66]],"Serializable":[[98,109]]}}},{"text":"This is what happens with serializable lambda instances, see SerializedLambda","label":{"api":{"SerializedLambda":[[61,76]]}}},{"text":"One means to do so is to ensure that the writeReplace method returns an instance of SerializedLambda, rather than allowing default serialization to proceed","label":{"api":{"writeReplace":[[41,52]],"SerializedLambda":[[84,99]]}}},{"text":"So it’s an instance of SerializedLambda that ends up on the stream and thus the responsibility of that class to have a stable serialized representation","label":{"api":{"SerializedLambda":[[23,38]]}}},{"text":"Specifically in your example this is further compounded by the fact that List.subList is a view on the underlying list","label":{"api":{"List.subList":[[73,84]]}}},{"text":"If insertion order from the names array is important, keep adding the objects to a LinkedHashSet<String>, then with either a for loop or enhanced for loop or iterator, go over your list of names and add each of them to the LinkedHashSet","label":{"api":{"LinkedHashSet<String>":[[83,103]],"LinkedHashSet":[[223,235]]}}},{"text":"You can do this with java.nio.channels.AsychronousSocketChannel and friends","label":{"api":{"java.nio.channels.AsychronousSocketChannel":[[21,62]]}}},{"text":"As pointed out in the comments, I missed out on the redirectErrorStream(boolean) method that allows me to pipe stderr to stdout internally, so there's only one stream to deal with","label":{"api":{"redirectErrorStream(boolean)":[[52,79]]}}},{"text":"You can use jdk.nashorn.api.scripting.URLReader ( https://docs.oracle.com/javase/8/docs/jdk/api/nashorn/jdk/nashorn/api/scripting/URLReader.html ) which wraps a URL as a Reader","label":{"api":{"jdk.nashorn.api.scripting.URLReader":[[12,46]]}}},{"text":"One solution, using getHours, getMinutes on the timestamps","label":{"api":{"getHours":[[20,27]],"getMinutes":[[30,39]]}}},{"text":"I'm not going to solve this for you since it sounds like a learning assignment, so instead I suggest you look closer at FileOutputStream and DataOutputStream","label":{"api":{"FileOutputStream":[[120,135]],"DataOutputStream":[[141,156]]}}},{"text":"Have you had a look at the methods that HttpURLConnection offers","label":{"api":{"HttpURLConnection":[[40,56]]}}},{"text":"class RSAPublicKeySpec supports at least a part of the implementation that you're looking for","label":{"api":{"RSAPublicKeySpec":[[6,21]]}}},{"text":"Use a CustomMenuItem, setHideOnClick and a CheckBox in the constructor","label":{"api":{"CustomMenuItem":[[6,19]],"setHideOnClick":[[22,35]],"CheckBox":[[43,50]]}}},{"text":"The javadoc states that File.pathSeparatorChar is","label":{"api":{"File.pathSeparatorChar":[[24,45]]}}},{"text":"You can simplify this and solve the problem using computeIfAbsent from Java 8","label":{"api":{"computeIfAbsent":[[50,64]]}}},{"text":"this code assumes that there is a value; otherwise, use .orElse(); see the javadoc of Optional for more details)","label":{"api":{".orElse()":[[56,64]],"Optional":[[86,93]]}}},{"text":"Use Thread.currentThread().getStackTrace() to get stack trace - there you can find all function calls in current thread","label":{"api":{"Thread.currentThread().getStackTrace()":[[4,41]]}}},{"text":"Your best bet here is to \"do it yourself\" by implementing instances of FileTypeDetectors","label":{"api":{"FileTypeDetectors":[[71,87]]}}},{"text":"When you have this, you can then just use Files.probeContentType() to have a string returned which describes the file contents as a MIME type","label":{"api":{"Files.probeContentType()":[[42,65]]}}},{"text":"If you're using Java 8, you can directly use Map#merge() method to avoid that extra testing","label":{"api":{"Map#merge()":[[45,55]]}}},{"text":"A Task represents a one-off task that is intended to run in a background thread","label":{"api":{"Task":[[2,5]]}}},{"text":"Each Task instance can only be executed once","label":{"api":{"Task":[[5,8]]}}},{"text":"A Service has similar functionality to a Task but is intended to be reusable","label":{"api":{"Service":[[2,8]],"Task":[[41,44]]}}},{"text":"It works by creating and managing Task instances (via a createTask() method, which you need to implement) and executing them on one or more background threads","label":{"api":{"Task":[[34,37]],"createTask()":[[56,67]]}}},{"text":"A ScheduledService is a Service which can generate its Tasks at specified time intervals","label":{"api":{"ScheduledService":[[2,17]],"Service":[[24,30]],"Task":[[55,58]]}}},{"text":"since this is a single thread running for the duration of your application, it is ill-suited to a Task (which is designed to execute and return a value) or Service (which is effectively just a collection of Tasks)","label":{"api":{"Task":[[98,101],[207,210]],"Service":[[156,162]]}}},{"text":"For this, you might consider using a ScheduledService to poll the devices at regular intervals, or you might simply create a thread and execute it in the background","label":{"api":{"ScheduledService":[[37,52]]}}},{"text":"If you use a ScheduledService, you can do this using the callback methods on the service, or on the tasks it creates","label":{"api":{"ScheduledService":[[13,28]]}}},{"text":"Create an Executor suitable for your needs (or more than one if appropriate)","label":{"api":{"Executor":[[10,17]]}}},{"text":"I think for web apps you can use web.xml.And for other you should use Properties class to read and write settings","label":{"api":{"Properties":[[70,79]]}}},{"text":"If you use a ServerSocket, you have to use the three-argument constructor to do that; the third argument is then the listening address for this socket","label":{"api":{"ServerSocket":[[13,24]]}}},{"text":"As an alternative, you may make your global variable an AtomicInteger, which handles atomic updates for you","label":{"api":{"AtomicInteger":[[56,68]]}}},{"text":"For this case, i will use Optimistic lock in your bids objects..","label":{"api":{"Optimistic lock":[[26,40]],"bids":[[50,53]]}}},{"text":"See the docs for usage example and more","label":{"api":{}}},{"text":"For the following cases, assume that the dispatch() method calls Dispatch.invokeAsync(T msg, AsyncHandler handler) and returns a Future","label":{"api":{"dispatch()":[[41,50]],"Dispatch.invokeAsync(T msg, AsyncHandler handler)":[[65,113]],"Future":[[129,134]]}}},{"text":"You can either make User Comparable and have it's natural ordering by age","label":{"api":{"Comparable":[[25,34]]}}},{"text":"Or explicitly specify a Comparator when you're sorting","label":{"api":{"Comparator":[[24,33]]}}},{"text":"This is working as designed - only the segment i am is replaced with she is because this is how the String.replace works","label":{"api":{"String.replace":[[100,113]]}}},{"text":"The ManagedExecutorService exists in JEE7 to handle the execution of asynchronous tasks","label":{"api":{"ManagedExecutorService":[[4,25]]}}},{"text":"By leveraging a Future interface implementation (see FutureTask) a task can be made cancellable as well","label":{"api":{"Future":[[16,21]],"FutureTask":[[53,62]]}}},{"text":"For example the ManagedTask interface provides access to some of these behaviors","label":{"api":{"ManagedTask":[[16,26]]}}},{"text":"The ManagedExecutorService is leveraged for the @Asynchronous EJB method annotation as mentioned in the answer by MGolovanov","label":{"api":{"ManagedExecutorService":[[4,25]],"@Asynchronous":[[48,60]]}}},{"text":"The task creation and Future instance creation is handled by the EJB framework","label":{"api":{"Future":[[22,27]]}}},{"text":"Seemingly, you can use Class.cast(Object) since you have the Class<T> already","label":{"api":{"Class.cast(Object)":[[23,40]],"Class<T>":[[61,68]]}}},{"text":"See the ImageWriter.write API doc for further information","label":{"api":{"ImageWriter.write":[[8,24]]}}},{"text":"Unfortunately oracle docs also has used the same terminology and called it \"rehashing\"","label":{"api":{}}},{"text":"To split the file in several \"line sub files\", use the read method of the BufferedReader class","label":{"api":{"read":[[55,58]],"BufferedReader":[[74,87]]}}},{"text":"To merge them, open all the files and keep a separate buffer (a small one, like 2 mb each) for every one of them, read the first chunk of every file and there you'll have enough information to start rearranging the index of the files","label":{"api":{}}},{"text":"Keep reading chunks if some of the files have ties","label":{"api":{}}},{"text":"For Java 6 and earlier, there is no X (J6 doc), and since the result of X may or may not do what you want, I strongly recommend you just insert that colon yourself","label":{"api":{}}},{"text":"split the String according to space(s), iterate over the resulted array  and increment the counter when you match the String you're looking for","label":{"api":{"split":[[0,4]],"String":[[10,15],[118,123]]}}},{"text":"use a regex that matches exactly the word you're looking for, there are many useful methods in the Matcher and Pattern classes, go through them","label":{"api":{"Matcher":[[99,105]],"Pattern":[[111,117]]}}},{"text":"Use that and .set() the content you want at the correct index","label":{"api":{".set()":[[13,18]]}}},{"text":"The solution is to wrap the content inside a ScrollPane which automatically manages the scrolling if the content inside grows or shrinks","label":{"api":{"ScrollPane":[[45,54]]}}},{"text":"If you want other sprites to move in sync with your sprite you can create a TimerTask and use scheduleAtFixedRate()","label":{"api":{"TimerTask":[[76,84]],"scheduleAtFixedRate()":[[94,114]]}}},{"text":"I suggest you to take a look at how to animate a JComponent using Swing Timer class, instead of for loop","label":{"api":{"JComponent":[[49,58]],"Swing Timer":[[66,76]]}}},{"text":"Probably the easiest way to accomplish this is to use Thread#sleep(long)","label":{"api":{"Thread#sleep(long)":[[54,71]]}}},{"text":"You can take a look at the indexOf(String string), which returns an integer denoting the position of the substring, or -1 if not found","label":{"api":{"indexOf(String string)":[[27,48]]}}},{"text":"For more information, see String.getBytes()","label":{"api":{"String.getBytes()":[[26,42]]}}},{"text":"You should be using java.beans.Introspector API to introspect the bean and invoke getters/setters on bean instances","label":{"api":{"java.beans.Introspector":[[20,42]]}}},{"text":"Check this out Why not try checking if orderBy == null if it does then add your default values to orderBy","label":{"api":{}}},{"text":"The JDK subclasses EnumSet, HashSet, and TreeSet use these implementations of equals and hashCode, the API documentation lists them under Methods inherited from class java.util.AbstractSet","label":{"api":{"EnumSet":[[19,25]],"HashSet":[[28,34]],"TreeSet":[[41,47]],"equals":[[78,83]],"hashCode":[[89,96]],"java.util.AbstractSet":[[167,187]]}}},{"text":"You can do this using the SequenceInputStream constructor overload that accepts an Enumeration","label":{"api":{"SequenceInputStream":[[26,44]],"Enumeration":[[83,93]]}}},{"text":"I have used hashCode() method from String API and it is generating value as 99162322 for the below code","label":{"api":{"hashCode()":[[12,21]],"String":[[35,40]]}}},{"text":"Take a look at the ArrayList API for other methods that may help you","label":{"api":{"ArrayList":[[19,27]]}}},{"text":"The best idea I have is to have SystemA/SystemB/SystemC call TransactionSynchronizationRegistry.registerInterposedSynchronization, and then you can be notified when the transaction is rolling back (since the EJB container will roll back transactions automatically if a system exception or application with rollback=true is thrown), and then you can try to undo whatever","label":{"api":{"TransactionSynchronizationRegistry.registerInterposedSynchronization":[[61,128]]}}},{"text":"You can solve this with @XmlID/@XmlIDREF","label":{"api":{"@XmlID":[[24,29]],"@XmlIDREF":[[31,39]]}}},{"text":"instead of getting all <transaction> elements from the root DOM node,  use the getChildNodes() method on each <client> Element node--this will return only the transactions that pertain to that client","label":{"api":{"getChildNodes()":[[79,93]]}}},{"text":"You can addAll of the ObservableList","label":{"api":{"addAll":[[8,13]],"ObservableList":[[22,35]]}}},{"text":"The method argument should have type Object (not Cellphone) in order to properly override Object.equals(), which is what you should be doing","label":{"api":{"Object":[[37,42]],"Cellphone":[[49,57]],"Object.equals()":[[90,104]]}}},{"text":"Finally, if you override equals, you should also override Object.hashCode(), so that the hash code is calculated from the same fields that are used for equality comparison","label":{"api":{"Object.hashCode()":[[58,74]]}}},{"text":"You're trying to pass grandTotal as the message type of showMessageDialog","label":{"api":{"grandTotal":[[22,31]],"showMessageDialog":[[56,72]]}}},{"text":"One approach is to use Hue-Saturation-Brightness color values using getHSBColor(), and change the hue based on the number of iterations before it escapes, e.g","label":{"api":{"getHSBColor()":[[68,80]]}}},{"text":"If you are creating a plug-in mechanism, providing metadata in a well-known location is more efficient, reliable, and works with any valid class loader","label":{"api":{}}},{"text":"The serialVersionUID can be overriden, but only with static final long serialVersionUID value which would require me to remember to change it when I change class's properties","label":{"api":{"serialVersionUID":[[4,19],[71,86]]}}},{"text":"BigInteger is designed for this","label":{"api":{"BigInteger":[[0,9]]}}},{"text":"Note that, although BigIntegers can be built from byte[] two's complement, and can be converted to those byte[]s again, internally they are using a more-efficient int[] representation","label":{"api":{"BigInteger":[[20,29]],"byte[]":[[50,55],[105,110]],"int[]":[[163,167]]}}},{"text":"Use Swing Timer component for repetitive tasks with Swing GUI toolkit","label":{"api":{"Swing Timer":[[4,14]],"Swing":[[52,56]]}}},{"text":"You must parse the String to an Integer using Integer.valueOf(String s)","label":{"api":{"String":[[19,24]],"Integer":[[32,38]],"Integer.valueOf(String s)":[[46,70]]}}},{"text":"The Timer class provided by the Swing package should do what you need","label":{"api":{"Timer":[[4,8]],"Swing":[[32,36]]}}},{"text":"Here is another solution using java.lang.Thread","label":{"api":{"java.lang.Thread":[[31,46]]}}},{"text":"If you do not want the table itself to be wider than 4 x 100px, can you not set the maximum size of the table as well (http://docs.oracle.com/javase/7/docs/api/javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension))","label":{"api":{}}},{"text":"an option would be not to disable the validation with set-jaxb-validation-handler, and rather subclass ValidationEventHandler","label":{"api":{"ValidationEventHandler":[[103,124]]}}},{"text":"first, this webservice is configured with annotations, and I can't seem to find a way to apply a ValidationEventHandler with annotations (same question as","label":{"api":{"webservice":[[12,21]],"ValidationEventHandler":[[97,118]]}}},{"text":"How to set custom ValidationEventHandler on JAXB unmarshaller when using annotations)","label":{"api":{"ValidationEventHandler":[[18,39]]}}},{"text":"Other possible solution is to use KeyStore, which allows you to store sensitive information in publicly accessible format","label":{"api":{"KeyStore":[[34,41]]}}},{"text":"A StackOverflowError is pretty undramatic to catch - it's thrown when the maximum stack depth is exceeded, and since it then starts popping the call stack, it's no longer a problem (unless you try calling the offending method again)","label":{"api":{"StackOverflowError":[[2,19]]}}},{"text":"Other errors, like OutOfMemoryError, are somewhat more problematic - there will still be too much memory used after it's been thrown","label":{"api":{"OutOfMemoryError":[[19,34]]}}},{"text":"Some are directly fatal, like ClassFormatError, which means that you're trying to load a broken class file (and it's usually thrown in places where you can't catch it)","label":{"api":{"ClassFormatError":[[30,45]]}}},{"text":"AssertionError, for example, is thrown when a programmer-defined condition (like assert answer == 42;) isn't met, but only if you've enabled assertions","label":{"api":{"AssertionError":[[0,13]]}}},{"text":"URLConnection treats the value of Content-Length as an int in Java 1.6 and earlier or a long in Java 1.7 and later, which would suggest that the maximum supported number of bytes in the body would be 2^31-1 bytes or 2^63-1 bytes, respectively, so long as Content-Length is being set","label":{"api":{"URLConnection":[[0,12]]}}},{"text":"You can use SwingUtilities.invokeLater(Runnable) to execute a Runnable in the EDT","label":{"api":{"SwingUtilities.invokeLater(Runnable)":[[12,47]],"Runnable":[[62,69]]}}},{"text":"Yeah, you can do this pretty easily you just need to use boundaries, which is what you're trying to describe with","label":{"api":{"boundaries":[[57,66]]}}},{"text":"If you want to compare to an external entity, use a Comparator implementation and pass it to Collections.sort(List, Comparator)","label":{"api":{"Comparator":[[52,61]],"Collections.sort(List, Comparator)":[[93,126]]}}},{"text":"You should look into KeyListener, or the much better solution KeyBindings","label":{"api":{"KeyListener":[[21,31]],"KeyBindings":[[62,72]]}}},{"text":"I have more experience using KeyListener so that is what I used in my example","label":{"api":{"KeyListener":[[29,39]]}}},{"text":"This KeyListener should be added to your component that is currently in focus, like this","label":{"api":{"KeyListener":[[5,15]]}}},{"text":"Remember that the KeyListener must be added to the component that is currently in focus","label":{"api":{"KeyListener":[[18,28]]}}},{"text":"using the .read()","label":{"api":{".read()":[[10,16]]}}},{"text":"Refer to OutputStreamWriter for an idea of how to change the directory to your liking","label":{"api":{"OutputStreamWriter":[[9,26]]}}},{"text":"Java Strings are encoded in UTF-16 by default","label":{"api":{"Strings":[[5,11]]}}},{"text":"As suggested in the comments, you'd do better to just store the encrypted bytes as bytes, and not convert them to Strings until they're decrypted","label":{"api":{"Strings":[[114,120]]}}},{"text":"AtomicLong might interest you too given that you aint using it in an entity class","label":{"api":{"AtomicLong":[[0,9]],"entity":[[69,74]]}}},{"text":"You can't do that for a number of reasons, not the least of which is that javax.sql.DataSource does not extend java.io.Serializable","label":{"api":{"javax.sql.DataSource":[[74,93]],"java.io.Serializable":[[111,130]]}}},{"text":"Use a blocking queue to wait for messages","label":{"api":{"blocking queue":[[6,19]]}}},{"text":"When you need to send a message to the server, you can use the blocking queue to send the message","label":{"api":{"blocking queue":[[63,76]]}}},{"text":"For maintaining the connection, use a timer task","label":{"api":{"timer task":[[38,47]]}}},{"text":"For processing the received message, you could have another thread, waiting for messages on another blocking queue (receiver queue)","label":{"api":{"blocking queue":[[100,113]]}}},{"text":"Also, let me remind you of the definition of the substring methods","label":{"api":{"substring":[[49,57]]}}},{"text":"Use Stream#max() providing a function for the relevant attribute","label":{"api":{"Stream#max()":[[4,15]]}}},{"text":"Can only iterate over array of java.lang.Iterable","label":{"api":{"java.lang.Iterable":[[31,48]]}}},{"text":"This means that your class must implement the Iterable interface","label":{"api":{"Iterable":[[46,53]]}}},{"text":"Map offers a get method which take the key as parameter","label":{"api":{"Map":[[0,2]],"get":[[13,15]]}}},{"text":"So you can simply do rate.get(year)","label":{"api":{"rate.get(year)":[[21,34]]}}},{"text":"If you are using Java 8, then use class java.util.Base64 for Base 64 encoding and decoding","label":{"api":{"java.util.Base64":[[40,55]]}}},{"text":"If the application is installed, you can try Desktop.print()","label":{"api":{"Desktop.print()":[[45,59]]}}},{"text":"I found this http://docs.oracle.com/javaee/5/api/javax/xml/bind/JAXBContext.html, so I presume that is compatibile with Java5, but when I try to look for this class in Eclipse I can't find it","label":{"api":{}}},{"text":"And before passing it to the Graph API convert it back to Numbers[] array with toArray()","label":{"api":{"Graph":[[29,33]],"Numbers[]":[[58,66]],"toArray()":[[79,87]]}}},{"text":"Reading OneToMany.ophanRemoval, you can try this","label":{"api":{"OneToMany.ophanRemoval":[[8,29]]}}},{"text":"I would suggest you to use a TimeLine where you can specify the cycleCount which you can set to INDEFINITE","label":{"api":{"TimeLine":[[29,36]],"cycleCount":[[64,73]],"INDEFINITE":[[96,105]]}}},{"text":"I am using a servlet to store the AsyncContexts in a Hashmap","label":{"api":{"servlet":[[13,19]],"AsyncContexts":[[34,46]],"Hashmap":[[53,59]]}}},{"text":"You could use the @javax.persistence.OrderBy annotation","label":{"api":{"@javax.persistence.OrderBy":[[18,43]]}}},{"text":"Using a loop is how you can fill each of the inner arrays separately, but Arrays.fill handles the inner loop for you","label":{"api":{"Arrays.fill":[[74,84]]}}},{"text":"Make sure to validate there's a line to be read before using Scanner#nextLine","label":{"api":{"Scanner#nextLine":[[61,76]]}}},{"text":"Use static sort method of Arrays class like","label":{"api":{"sort":[[11,14]],"Arrays":[[26,31]]}}},{"text":"if you look in the java documentation at Scanner.Next() you'll notice that next only returns the next token","label":{"api":{"Scanner.Next()":[[41,54]]}}},{"text":"One kind is encounter order, which is defined in the streams documentation","label":{"api":{"streams":[[53,59]]}}},{"text":"The following version is based on the API docs, but it is untested","label":{"api":{}}},{"text":"I am trying to get the UTC milliseconds to convert a Joda DateTime instance to a SQL Timestamp, however it is converting it to my local time instead","label":{"api":{"DateTime":[[58,65]]}}},{"text":"Yes you can set a drag view (arbitrary image) for a drag and drop operation","label":{"api":{"drag view":[[18,26]]}}},{"text":"AudioFormat.Encoding lists the encodings supported by javax.sound.sampled","label":{"api":{"AudioFormat.Encoding":[[0,19]],"javax.sound.sampled":[[54,72]]}}},{"text":"But for better performance I'd advice you to use PreparedStatement","label":{"api":{"PreparedStatement":[[49,65]]}}},{"text":"Also you would benefit if сarry out PreparedStatement constructor, too","label":{"api":{"PreparedStatement":[[36,52]]}}},{"text":"Otherwise, have a look at Scanner","label":{"api":{"Scanner":[[26,32]]}}},{"text":"It looks like you are storing the Blocks in a list, in that case the idiomatic way would be to use the Stream API","label":{"api":{"Blocks":[[34,39]],"Stream":[[103,108]]}}},{"text":"Just before using scanner.next(), try to test if you have things to read next string token using hasNext api like","label":{"api":{"scanner.next()":[[18,31]],"hasNext":[[97,103]]}}},{"text":"As described in Map interface documentation Map contains a set of keys, so it is not capable of containing multiple non-unique keys","label":{"api":{"Map":[[16,18],[44,46]]}}},{"text":"You should probably check if you have data to consumer using hasNextInt like","label":{"api":{"hasNextInt":[[61,70]]}}},{"text":"Get the ServletContext","label":{"api":{"ServletContext":[[8,21]]}}},{"text":"Then get the resource as a stream","label":{"api":{}}},{"text":"The java SE apidoc describes all the classes in java SE","label":{"api":{}}},{"text":"You can use Scanner, reading lines with nextLine(), splitting them with split(\" \"), and using Integer.parseInt() to parse to an integer","label":{"api":{"Scanner":[[12,18]],"nextLine()":[[40,49]],"split(\" \")":[[72,81]],"Integer.parseInt()":[[94,111]]}}},{"text":"For example, what's the quickest way to determine whether Math.abs() will generally be converted directly to a few native instructions wherever it is used","label":{"api":{"Math.abs()":[[58,67]]}}},{"text":"If you are adding elements to a List, you can use the contains() method; if not, you should write a comparable method that traverses your Node data structure","label":{"api":{"List":[[32,35]],"contains()":[[54,63]],"Node":[[138,141]]}}},{"text":"Alternatively, you might want to consider adding elements to a Set, which precludes duplicates","label":{"api":{"Set":[[63,65]]}}},{"text":"TreeSet may a good concrete implementation, as it remains ordered","label":{"api":{"TreeSet":[[0,6]]}}},{"text":"You could use Runtime.totalMemory() which (per the Javadoc) returns the total amount of memory in the Java virtual machine","label":{"api":{"Runtime.totalMemory()":[[14,34]]}}},{"text":"The number that you are trying to parse is larger than the maximum value an Integer can hold.","label":{"api":{"Integer":[[76,82]]}}},{"text":"You can convert your String to a long using the Long#parseLong() method","label":{"api":{"String":[[21,26]],"Long#parseLong()":[[48,63]]}}},{"text":"equals() should take Object as argument, to match the super method it overrides","label":{"api":{"equals()":[[0,7]],"Object":[[21,26]]}}},{"text":"You are using the FlexiCore specific RC5ParameterSpec, try and use the Java JCA one instead","label":{"api":{"FlexiCore":[[18,26]],"RC5ParameterSpec":[[37,52]],"JCA":[[76,78]]}}},{"text":"Using String.format you can achieve what you need","label":{"api":{"String.format":[[6,18]]}}},{"text":"Since replaceAll expects the string to define a regular expression, and + is special in regular expressions, your \"0+1\" means \"The digit 0 one or more times, followed by the digit 1\" and would match \"01\", \"001\", \"00001\", etc","label":{"api":{"replaceAll":[[6,15]]}}},{"text":"To just specify a string meant to be used literally, use replace, not replaceAll","label":{"api":{"replace":[[57,63]],"replaceAll":[[70,79]]}}},{"text":"ImageIcon has a constructor that allows the user to create an ImageIcon straight from the file","label":{"api":{"ImageIcon":[[0,8],[62,70]]}}},{"text":"In my case, I'm invoking a JavaFX dialogue from a Swing component; more specifically a FileChooser","label":{"api":{"JavaFX dialogue":[[27,41]],"Swing":[[50,54]],"FileChooser":[[87,97]]}}},{"text":"I tried using setEnabled(false) and setEnabled(true), but this has a strange side effect","label":{"api":{"setEnabled(false)":[[14,30]],"setEnabled(true)":[[36,51]]}}},{"text":"JavaFX has a javafx.concurrent API; in particular, the Task class fits your use case very nicely","label":{"api":{"JavaFX":[[0,5]],"javafx.concurrent":[[13,29]],"Task":[[55,58]]}}},{"text":"For example, Task is an implementation of FutureTask, so it can be submitted to an Executor","label":{"api":{"Task":[[13,16]],"FutureTask":[[42,51]],"Executor":[[83,90]]}}},{"text":"As you want to use a thread pool, you can create an Executor that implements a thread pool for you, and submit your tasks to it","label":{"api":{"Executor":[[52,59]]}}},{"text":"To implement the actual Task, there are a few things to bear in mind","label":{"api":{"Task":[[24,27]]}}},{"text":"Since your Task is submitted to the executor above, it's call() method will be invoked on a background thread","label":{"api":{"Task":[[11,14]],"executor":[[36,43]],"call()":[[57,62]]}}},{"text":"In particular, the Task has a set of updateXXX(...) methods that change the values of corresponding Task properties on the FX Application thread","label":{"api":{"Task":[[19,22],[100,103]]}}},{"text":"Instantiate your Task subclass setting only final variables, have the call() method compute a value, and return the value","label":{"api":{"Task":[[17,20]],"call()":[[70,75]]}}},{"text":"For canceling the Task, the Task class defines a built-in cancel() method","label":{"api":{"Task":[[18,21],[28,31]],"cancel()":[[58,65]]}}},{"text":"Note that the Optional.empty() and Optional.of(....) are factory methods that create appropriate instances of the Optional","label":{"api":{"Optional.empty()":[[14,29]],"Optional.of(....)":[[35,51]],"Optional":[[114,121]]}}},{"text":"In java 8, you can obtain an IntStream and get the summary statistics","label":{"api":{"IntStream":[[29,37]]}}},{"text":"Something like ConcurrentSkipListMap does have an ordering, it's sorted by the order of the keys as defined by a Comparator","label":{"api":{"ConcurrentSkipListMap":[[15,35]],"Comparator":[[113,122]]}}},{"text":"The easiest way, using Thread.sleep()","label":{"api":{"Thread.sleep()":[[23,36]]}}},{"text":"And, more formally the output buffer isn't fully flushed until you OutputStream.close() actually releases any system resources associated with this stream","label":{"api":{"OutputStream.close()":[[67,86]]}}},{"text":"I think you're looking for Integer.parseInt","label":{"api":{"Integer.parseInt":[[27,42]]}}},{"text":"...or possibly Long.parseLong (with long Value) if there's a possibility that the value will exceed the capacity of an int","label":{"api":{"Long.parseLong":[[15,28]]}}},{"text":"From the docs","label":{"api":{}}},{"text":"But I would use nextInt and hasNextInt instead, and ignore any character that's not a digit","label":{"api":{"nextInt":[[16,22]],"hasNextInt":[[28,37]]}}},{"text":"You should use public String(byte[] bytes) constructor","label":{"api":{"String(byte[] bytes)":[[22,41]]}}},{"text":"Note that I'm applying the String#equalsIgnoreCase() method on \"test\", but not on the user variable, in order to avoid a possible NullPointerException","label":{"api":{"String#equalsIgnoreCase()":[[27,51]],"NullPointerException":[[130,149]]}}},{"text":"If you have your own implementation, make sure you followed the Object.equals()-Contract","label":{"api":{"Object.equals()":[[64,78]]}}},{"text":"Assuming the task is scheduled at a fixed rate via the ScheduledExecutorService, change the task to a self-scheduling task","label":{"api":{"ScheduledExecutorService":[[55,78]]}}},{"text":"Check out ArrayBlockingQueue","label":{"api":{"ArrayBlockingQueue":[[10,27]]}}},{"text":"In some cases, operations on a component are done under a tree lock (Swing makes sure they are thread-safe on their own), but in some cases they are not","label":{"api":{"tree lock":[[58,66]],"Swing":[[69,73]]}}},{"text":"I am executing an .exe-file from java, using the ProcessBuilder class and the Process class","label":{"api":{"ProcessBuilder":[[49,62]],"Process":[[78,84]]}}},{"text":"Yet you can use Collections.addAll, that takes an array as second argument","label":{"api":{"Collections.addAll":[[16,33]]}}},{"text":"Collections#emptyXyz, in this case Collections#emptySet, returns an immutable empty collection for the determined interface","label":{"api":{"Collections#emptySet":[[35,54]]}}},{"text":"You could use a Pattern to apply a regular expression","label":{"api":{"Pattern":[[16,22]]}}},{"text":"The contract for the containsKey method states that it may throw a ClassCastException \"if the key is of an inappropriate type for this map.\"  So my answer is not viable","label":{"api":{"containsKey":[[21,31]],"ClassCastException":[[67,84]]}}},{"text":"You should never use FileReader","label":{"api":{"FileReader":[[21,30]]}}},{"text":"That link is also present in the documentation for the Charset class","label":{"api":{"Charset":[[55,61]]}}},{"text":"You need the set method, which takes an index and the new value for that index","label":{"api":{"set":[[13,15]]}}},{"text":"Use the DataOutputStream::write() method to make it a binary protocol without encoding it","label":{"api":{"DataOutputStream::write()":[[8,32]]}}},{"text":"Please read the documentation for System.exit()","label":{"api":{"System.exit()":[[34,46]]}}},{"text":"If you want to get uniformly distributed random integers, check out Random.nextInt()","label":{"api":{"Random.nextInt()":[[68,83]]}}},{"text":"If you wish to convert an array into a String, use the Arrays class","label":{"api":{"String":[[39,44]],"Arrays":[[55,60]]}}},{"text":"If using Arrays.toString, you can parse the returned String using the methods provided in the String class","label":{"api":{"Arrays.toString":[[9,23]],"String":[[53,58],[94,99]]}}},{"text":"In Java 8, you could do this using Stream.flatMap()","label":{"api":{"Stream.flatMap()":[[35,50]]}}},{"text":"If you can't use Java 8, you could use System.arraycopy()","label":{"api":{"System.arraycopy()":[[39,56]]}}},{"text":"We should distinguish between javax.persistence.Transient and java.beans.Transient","label":{"api":{"javax.persistence.Transient":[[30,56]],"java.beans.Transient":[[62,81]]}}},{"text":"where Java7SupportImpl#findTransient(Annotated) is looking for java.beans.Transient","label":{"api":{"Java7SupportImpl#findTransient(Annotated)":[[6,46]],"java.beans.Transient":[[63,82]]}}},{"text":"You can have a look at Arrays.copyOf method","label":{"api":{"Arrays.copyOf":[[23,35]]}}},{"text":"As Collections.shuffle(..) (in java.util) has return type void - the passed in list becomes shuffled, a new list is not created","label":{"api":{"Collections.shuffle(..)":[[3,25]],"java.util":[[31,39]],"void":[[58,61]]}}},{"text":"You should use LinkedHashMap in place of HashMap(where the order of inserts is not guaranteed to be preserved)if you want the order of your inserts","label":{"api":{"LinkedHashMap":[[15,27]],"HashMap":[[41,47]]}}},{"text":"Since you are fetching the records in an order and inserting that in a HashMap, the records are inserted in a random order, since it is passed through a hashfunction","label":{"api":{"HashMap":[[71,77]]}}},{"text":"You could throw an IllegalStateException","label":{"api":{"IllegalStateException":[[19,39]]}}},{"text":"The more modern approach would be to return an Optional<Integer> which is the recommended way in Java 8 to avoud null returns","label":{"api":{"Optional<Integer>":[[47,63]]}}},{"text":"According to the Java API, attempting to pop an element from an empty stack should yield an exception","label":{"api":{}}},{"text":"Assuming that you have the String you posted, you can use String#replace","label":{"api":{"String":[[27,32]],"String#replace":[[58,71]]}}},{"text":"Both Joda-Time and the new java.time package in Java 8 largely use immutable objects","label":{"api":{"java.time":[[27,35]]}}},{"text":"If it is no longer attached, you can re-attach it using merge","label":{"api":{"merge":[[56,60]]}}},{"text":"Assuming you're using the MimeMessage getSentDate or getReceivedDate methods, you'll get a Date object that's already properly converted","label":{"api":{"MimeMessage":[[26,36]],"getSentDate":[[38,48]],"getReceivedDate":[[53,67]],"Date":[[91,94]]}}},{"text":"You just need to format and display the date however you want, e.g., using SimpleDateFormat","label":{"api":{"SimpleDateFormat":[[75,90]]}}},{"text":"More info on that in the API","label":{"api":{}}},{"text":"I would first use Java API","label":{"api":{}}},{"text":"The closest fit may be an IllegalArgumentException","label":{"api":{"IllegalArgumentException":[[26,49]]}}},{"text":"The S format character for SimpleDateFormat means milliseconds, not microseconds","label":{"api":{"SimpleDateFormat":[[27,42]]}}},{"text":"Parse the numbers currently contained in strings","label":{"api":{}}},{"text":"The @DefaultProperty annotation is a class-level annotation (@Target(value=TYPE) in the documentation) with a required value attribute specifying the name of the property","label":{"api":{"@DefaultProperty":[[4,19]],"@Target(value=TYPE)":[[61,79]]}}},{"text":"So even with the @DefaultProperty annotation, I don't think you can make this work without making the getChildren() method public, as above","label":{"api":{"@DefaultProperty":[[17,32]],"getChildren()":[[102,114]]}}},{"text":"The documentation for KeyPairGenerator says that the initialize(int, SecureRandom) does this","label":{"api":{"KeyPairGenerator":[[22,37]],"initialize(int, SecureRandom)":[[53,81]]}}},{"text":"new Random() returns a random number generator, which is a Java object (this is why you get java.util.Random@15db9742 if you try to convert it to a string)","label":{"api":{"Random()":[[4,11]],"java.util.Random":[[92,107]]}}},{"text":"See java.util.Random on the API spec (linked version is Java 8)","label":{"api":{"java.util.Random":[[4,19]]}}},{"text":"If you need to do this through Java then you could invoke the above command using Java's Runtime class","label":{"api":{"Runtime":[[89,95]]}}},{"text":"However, I would consider using a BlockingQueue so that your threads do not run amock","label":{"api":{"BlockingQueue":[[34,46]]}}},{"text":"In particular, see the concurrent package documentation","label":{"api":{"concurrent":[[23,32]]}}},{"text":"This is documented in the API documentation for SimpleDateFormat under the heading Synchronization","label":{"api":{"API documentation for SimpleDateFormat":[[26,63]]}}},{"text":"Using the approach shown here, you can specify an AttributedString for the desired axis label","label":{"api":{"AttributedString":[[50,65]]}}},{"text":"Given a NumberAxis named domain, the example below uses TextAttribute values to alter the SIZE and WEIGHT of some characters, subscripts the second character and superscripts the exponent","label":{"api":{"NumberAxis":[[8,17]],"TextAttribute":[[56,68]],"SIZE":[[90,93]],"WEIGHT":[[99,104]]}}},{"text":"First, notice that Collections.sort(List<T>) simply delegates to Arrays.sort(Object[]) (source)","label":{"api":{"Collections.sort(List<T>)":[[19,43]],"Arrays.sort(Object[])":[[65,85]]}}},{"text":"You'll notice the documentation for the primitive sort methods, like Arrays.sort(int[]), says nothing about the stability of these sorting methods, because such a detail is meaningless","label":{"api":{"Arrays.sort(int[])":[[69,86]]}}},{"text":"Java has ScheduledExecutorService that does this for you","label":{"api":{"ScheduledExecutorService":[[9,32]]}}},{"text":"ByteArrayOutputStream.toByteArray just copies what it has in the buffer; it's not reading anything more from the stream","label":{"api":{"ByteArrayOutputStream.toByteArray":[[0,32]]}}},{"text":"Once the Server is started, and the SslContextFactory has been started (via its lifecycle), then the SSLEngine is used for the source of this information","label":{"api":{"SslContextFactory":[[36,52]],"SSLEngine":[[101,109]]}}},{"text":"You might consider moving from a ThreadPoolExecutor to a ScheduledThreadPoolExecutor","label":{"api":{"ThreadPoolExecutor":[[33,50]],"ScheduledThreadPoolExecutor":[[57,83]]}}},{"text":"The difference is, that for all the tasks you enqueue, you'll get a Future<T>","label":{"api":{"Future<T>":[[68,76]]}}},{"text":"See the API","label":{"api":{}}},{"text":"This uses the Car constructor as a method reference to the new Map.computeIfAbsent method, which calls it if a Car of that colour is not already present in the Map","label":{"api":{"Car":[[14,16],[111,113]],"Map.computeIfAbsent":[[63,81]],"Map":[[160,162]]}}}]