[{"text":"JFrame has BorderLayout by default, which makes add(Component) method to add component always to center part of frame by default, replacing any components already put there","label":{"api":{"JFrame":[[0,5]],"BorderLayout":[[11,22]],"add(Component)":[[48,61]]}}},{"text":"Put your items into JList and put the JList inside a scrollbar","label":{"api":{"JList":[[20,24],[38,42]],"scrollbar":[[53,61]]}}},{"text":"Rather use NumberFormat for parsing","label":{"api":{"NumberFormat":[[11,22]]}}},{"text":"I fixed a similar problem using BlockingDeque(Link, first in, first out)","label":{"api":{"BlockingDeque(Link, first in, first out)":[[32,71]]}}},{"text":"If so, you can use Timer class, just create TimerTask and schedule it at fixed rate","label":{"api":{"Timer":[[19,23]],"TimerTask":[[44,52]]}}},{"text":"I have an application which uses java.util.zip library to unzip the file","label":{"api":{"java.util.zip":[[33,45]]}}},{"text":"Since you are using Java 8 I suggest using the new date/time API, java.time, specifically its YearMonth class","label":{"api":{"java.time":[[66,74]],"YearMonth":[[94,102]]}}},{"text":"Check the canonical path location for the file","label":{"api":{}}},{"text":"Instead of using byte[], you could use java.nio.ByteBuffer which does allow you to slice a buffer in the way you want to","label":{"api":{"byte[]":[[17,22]],"java.nio.ByteBuffer":[[39,57]]}}},{"text":"The method you're trying to use is a member of java.nio.file.Files - but that class (and indeed that package) doesn't exist on Android","label":{"api":{"java.nio.file.Files":[[47,65]]}}},{"text":"For this to happen you need a ActionListener","label":{"api":{"ActionListener":[[30,43]]}}},{"text":"Create a custom ActionListener like below (Note I did it for one die)","label":{"api":{"ActionListener":[[16,29]]}}},{"text":"To add your custom ActionListener to the button","label":{"api":{"ActionListener":[[19,32]]}}},{"text":"The ActionListener needs to modify the Jlabels representing the dice, so don't forget to add it as a parameter to the constructor of you listener","label":{"api":{"ActionListener":[[4,17]],"Jlabels":[[39,45]]}}},{"text":"You can try to use DocumentFilter, for example","label":{"api":{"DocumentFilter":[[19,32]]}}},{"text":"Check the fetchSize of the PreparedStatement","label":{"api":{"fetchSize":[[10,18]],"PreparedStatement":[[27,43]]}}},{"text":"According to the Javadocs for UrlInfo.getQueryParameters only \"sequences of escaped octets in parameter names and values are decoded\"","label":{"api":{"UrlInfo.getQueryParameters":[[30,55]]}}},{"text":"On the other hand, QueryParam Javadocs states that \"Values are URL decoded unless this is disabled using the Encoded annotation\"","label":{"api":{"QueryParam":[[19,28]],"Encoded":[[109,115]]}}},{"text":"The value 677862 is being interpreted as milliseconds, as per the SimpleDateFormat javadocs, not as microseconds","label":{"api":{"SimpleDateFormat":[[66,81]]}}},{"text":"Using a Scanner would make the code considerably cleaner","label":{"api":{"Scanner":[[8,14]]}}},{"text":"To append a line use this constructor of the java.util.FileWriter","label":{"api":{"java.util.FileWriter":[[45,64]]}}},{"text":"java.io.File.length() gets you the length of the file denoted by the abstract pathname","label":{"api":{"java.io.File.length()":[[0,20]]}}},{"text":"A better approach, as my erroneous assumption was pointed out in @Tilo's comment would be to first read the file into a String, and use it's getChars().length method","label":{"api":{"String":[[120,125]],"getChars().length":[[141,157]]}}},{"text":"Try this, using System.arraycopy","label":{"api":{"System.arraycopy":[[16,31]]}}},{"text":"But, you can wrap a Java object by a JSObject implementation (https://docs.oracle.com/javase/8/docs/jdk/api/nashorn/jdk/nashorn/api/scripting/JSObject.html) and filter out specific methods and/or fields","label":{"api":{"JSObject":[[37,44]]}}},{"text":"The color of the bars in BarChart are specified with the -fx-bar-fill attribute (which is undocumented in the JavaFX CSS Reference Guide) but furthermore I can not find anywhere in the OpenJFX source where this attribute is specified and looked for, how does this actually work","label":{"api":{"BarChart":[[25,32]],"JavaFX CSS":[[110,119]],"OpenJFX":[[185,191]]}}},{"text":"The only method you need to define is the compare method, which compares 2 Items","label":{"api":{"compare":[[42,48]]}}},{"text":"Arrays.sort is for arrays, but Collections.sort does the same thing for collections (and it uses Arrays.sort internally anyway)","label":{"api":{"Arrays.sort":[[0,10],[97,107]],"Collections.sort":[[31,46]]}}},{"text":"Pass an instance of your Comparator to a call to Collections.sort, and it will sort your list for you","label":{"api":{"Comparator":[[25,34]],"Collections.sort":[[49,64]]}}},{"text":"You can use DecimalFormat (docs here)","label":{"api":{"DecimalFormat":[[12,24]]}}},{"text":"Instead of using an explicit for loop, you could use System.arraycopy()","label":{"api":{"System.arraycopy()":[[53,70]]}}},{"text":"We can also call drain to wait for this data to get played back","label":{"api":{"drain":[[17,21]]}}},{"text":"You can use a JScrollPane for that purpose","label":{"api":{"JScrollPane":[[14,24]]}}},{"text":"Files.write will write all lines of an Iterable (which includes Collections) and that’s it","label":{"api":{"Files.write":[[0,10]],"Iterable":[[39,46]],"Collections":[[64,74]]}}},{"text":"Otherwise, Files.write will append line-feeds to every string","label":{"api":{"Files.write":[[11,21]]}}},{"text":"Regardless of whether you create your own Writer or use Files.write, these implementations will already report failures regarding existence/non-existence or failed attempts of creating the target file via IOExceptions, so you don’t need to do it yourself","label":{"api":{"Writer":[[42,47]],"Files.write":[[56,66]],"IOException":[[205,215]]}}},{"text":"And use map.get(Object key) method to fetch specific person by id","label":{"api":{"map.get(Object key)":[[8,26]]}}},{"text":"As the file size is very big, ConcurrentHashMap should be a good collection to use","label":{"api":{"ConcurrentHashMap":[[30,46]]}}},{"text":"I checked Krb5LoginModule and it allows for such configuration, but I could not find anything related to Sasl clients","label":{"api":{"Krb5LoginModule":[[10,24]]}}},{"text":"You could also use Files.walkFileTree","label":{"api":{"Files.walkFileTree":[[19,36]]}}},{"text":"Many possibilities such as CountDownLatch, or you can put the join() calls into the run() method of Thread E","label":{"api":{"CountDownLatch":[[27,40]],"join()":[[62,67]],"run()":[[84,88]],"Thread":[[100,105]]}}},{"text":"Replace 1000 with Double.MAX_VALUE","label":{"api":{"Double.MAX_VALUE":[[18,33]]}}},{"text":"Essentially, if your class is supposed to implement ActionListener, it should have an actionPerformed(ActionEvent) method","label":{"api":{"ActionListener":[[52,65]],"actionPerformed(ActionEvent)":[[86,113]]}}},{"text":"The SimpleDateFormat  provides the underlying conventions, as stated in the GsonDoc","label":{"api":{"SimpleDateFormat":[[4,19]]}}},{"text":"You probably want fillRect","label":{"api":{"fillRect":[[18,25]]}}},{"text":"The jComboBox class provides an addItem method for you","label":{"api":{"jComboBox":[[4,12]],"addItem":[[32,38]]}}},{"text":"In JavaFX a common way to run code in the background is to use a Task","label":{"api":{"JavaFX":[[3,8]],"Task":[[65,68]]}}},{"text":"Assuming that the only issue you have with indexOf(String str) is that it returns an integer, and not a boolean, note that as per the Javadoc, if the string is not found, a -1 is returned","label":{"api":{"indexOf(String str)":[[43,61]]}}},{"text":"This can be achieved very simply using String.replaceAll()","label":{"api":{"String.replaceAll()":[[39,57]]}}},{"text":"The answer is in the docs of BufferedWriter#close","label":{"api":{"BufferedWriter#close":[[29,48]]}}},{"text":"It sounds like you are looking for a jSpinner","label":{"api":{"jSpinner":[[37,44]]}}},{"text":"CallableStatement.getInt() doesn't relate to a ResultSet, it relates to an output parameter of a stored procedure","label":{"api":{"CallableStatement.getInt()":[[0,25]],"ResultSet":[[47,55]]}}},{"text":"The interface java.util.function.Supplier is what you are looking for","label":{"api":{"java.util.function.Supplier":[[14,40]]}}},{"text":"You're looking for a Supplier<T> (docs here)","label":{"api":{"Supplier<T>":[[21,31]]}}},{"text":"You can find the default suppliers for primitives in java.util.function","label":{"api":{"java.util.function":[[53,70]]}}},{"text":"From the Javadoc on Integer.parseInt(String s)","label":{"api":{"Integer.parseInt(String s)":[[20,45]]}}},{"text":"Overriding the stop() method from the Application class will allow you to close your console app","label":{"api":{"stop()":[[15,20]],"Application":[[38,48]]}}},{"text":"There is also a description of what parameter mean on Java EE page","label":{"api":{}}},{"text":"Could Function.identity() fit your needs","label":{"api":{"Function.identity()":[[6,24]]}}},{"text":"You should also consider checking out ImageIO to help prevent this problem in your future, it's more robust than the basic constructors","label":{"api":{"ImageIO":[[38,44]]}}},{"text":"Use a DecimalFormat","label":{"api":{"DecimalFormat":[[6,18]]}}},{"text":"Based on the java.util.logging.Logger API and this article, the main reason for getLogger() is to ensure the same Logger and Handler set are used independently between subsystems","label":{"api":{"java.util.logging.Logger API":[[13,40]],"getLogger()":[[80,90]],"Logger":[[114,119]],"Handler":[[125,131]]}}},{"text":"Why does the below implementation using Iterable.forEach() not compile","label":{"api":{"Iterable.forEach()":[[40,57]]}}},{"text":"I've checked the Consumer and Iterable documentation, and neither of them seem to suggest how to solve this","label":{"api":{"Consumer":[[17,24]],"Iterable":[[30,37]]}}},{"text":"I didn't want to modify too much your code so I provide you a sample that replaces the do while loop you were using (it's from the official Timer's javadoc)","label":{"api":{"Timer":[[140,144]]}}},{"text":"You can set the delimiter with useDelimiter(String)","label":{"api":{"useDelimiter(String)":[[31,50]]}}},{"text":"To get the right width and height, you have to call Region.prefWidth(-1) and Region.prefHeight(-1)respectively","label":{"api":{"Region.prefWidth(-1)":[[52,71]],"Region.prefHeight(-1)":[[77,97]]}}},{"text":"JOptionPanes are modal, so you can't do this directly","label":{"api":{"JOptionPanes":[[0,11]],"modal":[[17,21]]}}},{"text":"All dialogs are modal","label":{"api":{}}},{"text":"The most simple way is to use indexOf to do check operation, it returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element","label":{"api":{"indexOf":[[30,36]]}}},{"text":"But, the most efficient way is not to use indexOf method to do check","label":{"api":{"indexOf":[[42,48]]}}},{"text":"Most I/O and locking operations will interrupt when the thread the run on is interrupted and an InterruptedException is raised in that thread (however, not all operations do so, for example see https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html#acquireUninterruptibly())","label":{"api":{"InterruptedException":[[96,115]]}}},{"text":"I recommend to use the Math.atan2 method and shift the range of its angle","label":{"api":{"Math.atan2":[[23,32]]}}},{"text":"The parameter to your constructor is the capacity","label":{"api":{}}},{"text":"Take, for example, Integer","label":{"api":{"Integer":[[19,25]]}}},{"text":"Since both of these fields contain fixed information that would not change between instantiations, it would not make sense to have to instantiate an Integer to get this information","label":{"api":{"Integer":[[149,155]]}}},{"text":"Integer also has the useful operation parseInt, which takes a String and turns it into an int","label":{"api":{"Integer":[[0,6]],"parseInt":[[38,45]],"String":[[62,67]],"int":[[90,92]]}}},{"text":"We shouldn't require an instance of Integer to convert from String to int, especially if we're not placing it into an instance of Integer","label":{"api":{"Integer":[[36,42],[130,136]],"String":[[60,65]],"int":[[70,72]]}}},{"text":"You can see clearer examples of this in certain Java library classes, like Integer","label":{"api":{"Integer":[[75,81]]}}},{"text":"You can get the rows with String.split and split each row into a character array with String.toCharArray","label":{"api":{"String.split":[[26,37]],"String.toCharArray":[[86,103]]}}},{"text":"If you need sophisticated mathematics typesetting, you could use something like MathJax in a WebView","label":{"api":{"MathJax":[[80,86]],"WebView":[[93,99]]}}},{"text":"To do the bare minimum, AbstractTableModel only requires that getRowCount, getColumnCount and getValueAt are implemented","label":{"api":{"AbstractTableModel":[[24,41]],"getRowCount":[[62,72]],"getColumnCount":[[75,88]],"getValueAt":[[94,103]]}}},{"text":"What this does is create a Matcher for your line and the URL-matching Pattern from before","label":{"api":{"Matcher":[[27,33]]}}},{"text":"Then, it loops until #find() returns false (i.e., there are no more matches) and adds the match (with #group()) to the list, urlsFound","label":{"api":{"#find()":[[21,27]],"#group()":[[102,109]]}}},{"text":"Note that this can get quite memory-intensive if you've got a lot of text, as urlsFound will get quite big, and you'll be creating and ditching a lot of Matchers","label":{"api":{"Matcher":[[153,159]]}}},{"text":"The JDK has ZipOutputStream which can help you there; basically you can use it as such (code to set the HTTP headers not shown)","label":{"api":{"ZipOutputStream":[[12,26]]}}},{"text":"While you may be tempted to just pass one string with quotes as the shell does, the String version of Runtime.exec uses a default StringTokenizer to break up the string, which does not recognize quoted strings","label":{"api":{"Runtime.exec":[[102,113]],"StringTokenizer":[[130,144]]}}},{"text":"See also the documentation of CallableStatement","label":{"api":{"CallableStatement":[[30,46]]}}},{"text":"Use a CountDownLatch for that","label":{"api":{"CountDownLatch":[[6,19]]}}},{"text":"Map is an interface","label":{"api":{"Map":[[0,2]]}}},{"text":"There are several others, such as HashMap, SortedMap, etc","label":{"api":{"HashMap":[[34,40]],"SortedMap":[[43,51]]}}},{"text":"implementations, you may find my answer to Java - HashMap vs Map objects here helpful","label":{"api":{"HashMap":[[50,56]],"Map":[[61,63]]}}},{"text":"The class java.awt.Robot will be useful for this","label":{"api":{"java.awt.Robot":[[10,23]]}}},{"text":"Swing provides a timer for this sort of thing, have a look at the documentation","label":{"api":{"Swing":[[0,4]],"timer":[[17,21]]}}},{"text":"As others have pointed out, when you're inputting parameters into the query, you should use a PreparedStatement instead of a simple statement with concatenated inputs","label":{"api":{"PreparedStatement":[[94,110]]}}},{"text":"Moreover you should read the Javadoc of Set","label":{"api":{"Set":[[40,42]]}}},{"text":"Regarding your code, I rather suggest that instead of using Random all the time you invoke a shuffle on the cards","label":{"api":{"Random":[[60,65]],"shuffle":[[93,99]]}}},{"text":"The JavFX way of doing this would be an array of ImageView","label":{"api":{"JavFX":[[4,8]],"ImageView":[[49,57]]}}},{"text":"Those you can add to and remove from any Parent how you like (just note that you can't draw the same ImageView twice, but that case shouldn't occur in your card game)","label":{"api":{"ImageView":[[101,109]]}}},{"text":"Again, the most straightforward way is probably to add as many Canvas to your HBox as you need to draw cards","label":{"api":{"Canvas":[[63,68]],"HBox":[[78,81]]}}},{"text":"After the current cards have changed, for each visible card you need to get the right image from your Image array and draw it on the GraphicsContext of the right canvas using canvas.getGraphicsContext2D().drawImage()","label":{"api":{"GraphicsContext":[[133,147]],"canvas.getGraphicsContext2D().drawImage()":[[175,215]]}}},{"text":"For this package, one of my next steps is to write a series of FileTypeDetector to have the method Files.probeContentType() be smarter than what is is by default (the default provided file type detector relies on \"file name extensions\" only)","label":{"api":{"FileTypeDetector":[[63,78]],"Files.probeContentType()":[[99,122]]}}},{"text":"As the javadoc of the aforementioned method mentions, this method relies on instances of FileTypeDetectors be declared in a META-INF/services file","label":{"api":{"FileTypeDetector":[[89,104]]}}},{"text":"The content of META-INF/services/java.nio.file.spi.FileTypeDetector was this","label":{"api":{"META-INF/services/java.nio.file.spi.FileTypeDetector":[[15,66]]}}}]