[{"text":"Shooting in the dark, because you haven't disclosed all relevant code, but you could try adding the missing parameter for valueOf here","label":{"api":{"valueO":[[122,127]]}}},{"text":"You need to use the setNull method for the code to work","label":{"api":{"setNull":[[20,26]]}}},{"text":"Instead, use a timer","label":{"api":{"timer":[[15,19]]}}},{"text":"About find() from http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#find%28%29","label":{"api":{"find()":[[6,11]]}}},{"text":"The documentation for Matcher.lookingAt clearly explains the region lookingAt tries to match","label":{"api":{"Matcher.lookingAt":[[22,38]],"lookingAt":[[68,76]]}}},{"text":"From the Matcher Javadoc overview","label":{"api":{"Matcher":[[9,15]]}}},{"text":"The server uses a BufferedReader, whose readLine method requires an end of line delimiter, but the Client is not sending it - rather, it reads the line (with end of line delimiter stripped) and attempts to echo this message","label":{"api":{"BufferedReader":[[18,31]],"readLine":[[40,47]],"Client":[[99,104]]}}},{"text":"So an ArrayList may be helpful","label":{"api":{"ArrayList":[[6,14]]}}},{"text":"Yes when your thread finishes and is capable of say accepting request or a particular task, it call countDown method on latch","label":{"api":{"countDown":[[100,108]]}}},{"text":"Now whenever 'x' slave threads completes their task and calls countDown, master knows about the same and comes out of await and does further processing","label":{"api":{"countDown":[[62,70]],"await":[[118,122]]}}},{"text":"Solution is to use AtomicInteger instead of int","label":{"api":{"AtomicInteger":[[19,31]]}}},{"text":"setLocationRelativeTo(null) will place the window in the center of the screen (http://docs.oracle.com/javase/7/docs/api/java/awt/Window.html#setLocationRelativeTo%28java.awt.Component%29)","label":{"api":{"setLocationRelativeTo(null)":[[0,26]]}}},{"text":"The correct thing to do is use setLocationByPlatform(true), which will allow the desktop to place your window as it sees fit","label":{"api":{"setLocationByPlatform(true)":[[31,57]]}}},{"text":"If you feel your application is so much more important than all others that it absolutely has to be placed in the center of the screen, you can use setLocationRelativeTo(null), which is guaranteed to center the window","label":{"api":{"setLocationRelativeTo(null)":[[148,174]]}}},{"text":"Look at the documentation for Integer.valueOf(int)","label":{"api":{"Integer.valueOf(int)":[[30,49]]}}},{"text":"This likely means the objects in the List implement Comparable","label":{"api":{"List":[[37,40]],"Comparable":[[52,61]]}}},{"text":"That is, read from a config file or take it in as command-line parameters","label":{"api":{}}},{"text":"One way to get a list of unique products would be to use Map::merge with the Product name as key and the Product::merge method from this example as the remapping function","label":{"api":{"Map::merge":[[57,66]],"Product":[[77,83]],"Product::merge":[[105,118]]}}},{"text":"You could wrap your while loop inside an AnimationTimer like this","label":{"api":{"AnimationTimer":[[41,54]]}}},{"text":"Currently, I just Locale.getDefault(), but I'd rather like to work with List<Locale.LanguageRange> (from Java 8) that comes from the browser via Accept-Language","label":{"api":{"Locale.getDefault()":[[18,36]],"List<Locale.LanguageRange>":[[72,97]]}}},{"text":"Also for a better way to randomly distribute cards, look at Collections.shuffle()","label":{"api":{"Collections.shuffle()":[[60,80]]}}},{"text":"A PathTransition works by updating the translateX and translateY properties of the node that is being animated","label":{"api":{"PathTransition":[[2,15]],"translateX":[[39,48]],"translateY":[[54,63]]}}},{"text":"I believe you should look into objects where you have key/value pairs like HashMap for example","label":{"api":{"HashMap":[[75,81]]}}},{"text":"What you have is a reduction","label":{"api":{}}},{"text":"You can use BigDecimal","label":{"api":{"BigDecimal":[[12,21]]}}},{"text":"It is done when obtaining the Connection from the DataSource with dataSource.getConnection(username, password)","label":{"api":{"Connection":[[30,39]],"DataSource":[[50,59]],"dataSource.getConnection(username, password)":[[66,109]]}}},{"text":"But after all, there is no method like retainAll() for arrays","label":{"api":{"retainAll()":[[39,49]]}}},{"text":"You may want to invoke a Collection method on a simple array","label":{"api":{"method":[[36,41]]}}},{"text":"You should work with collections instead of simple arrays, if you want to use their methods","label":{"api":{}}},{"text":"I currently have a simple instant messaging program which is utilizing Java's Socket and ServerSocket classes","label":{"api":{"Socket":[[78,83]],"ServerSocket":[[89,100]]}}},{"text":"I then use the ServerSocket.close() method on the server and the Socket.close() method on the client","label":{"api":{"ServerSocket.close()":[[15,34]],"Socket.close()":[[65,78]]}}},{"text":"One way to handle the \"sliding window\" would be to use a RandomAccessFile, and seek to the current offset","label":{"api":{"RandomAccessFile":[[57,72]]}}},{"text":"The uniqueness can be handled by a Set","label":{"api":{"Set":[[35,37]]}}},{"text":"The best solution I have found so far is to add a method to my configuration class and annotate it with the @PostConstruct annotation","label":{"api":{"@PostConstruct":[[108,121]]}}},{"text":"This is a call to java.util.Timer.schedule(TimerTask task, long delay, long period)","label":{"api":{"java.util.Timer.schedule(TimerTask task, long delay, long period)":[[18,82]]}}},{"text":"You could use Java 8 streams for this and Collectors.groupingBy","label":{"api":{"streams":[[21,27]],"Collectors.groupingBy":[[42,62]]}}},{"text":"For more details see ResultSetMetaData documentation","label":{"api":{"ResultSetMetaData":[[21,37]]}}},{"text":"I would suggest working with the start of the next day and using before","label":{"api":{}}},{"text":"Make your custom exceptions extend the RuntimeException class","label":{"api":{"RuntimeException":[[39,54]]}}},{"text":"See the Javadocs RuntimeException","label":{"api":{"RuntimeException":[[17,32]]}}},{"text":"As Java doc says, PrintWriter is used for writing to the file","label":{"api":{"PrintWriter":[[18,28]]}}},{"text":"In your case, I would suggest you to use BufferedReader class","label":{"api":{"BufferedReader":[[41,54]]}}},{"text":"I have a JavaFX window (subclass of Application) which lets JOptionPane dialog boxes be opened from it","label":{"api":{"Application":[[36,46]],"JOptionPane":[[60,70]]}}},{"text":"Could the window thread be paused until the JOptionPane method returns","label":{"api":{"JOptionPane":[[44,54]]}}},{"text":"You can also use the properties to initialize the default values in an instance of java.util.prefs.Preferences, as shown in the game cited here","label":{"api":{"properties":[[21,30]],"java.util.prefs.Preferences":[[83,109]]}}},{"text":"I wrote a small application using xuggler which combines BufferedImages into a video (slideshow)","label":{"api":{"BufferedImage":[[57,69]]}}},{"text":"You can use a combination of weak references and reference queues","label":{"api":{"weak references":[[29,43]],"reference queue":[[49,63]]}}},{"text":"This old but valid article has a good description of weak, soft, and phantom references and reference queues","label":{"api":{"reference queue":[[92,106]]}}},{"text":"The basic idea is to create a large array (to reserve memory) create a weak or soft reference to it and when doing so, add it to a reference queue","label":{"api":{"reference queue":[[131,145]]}}},{"text":"Have a thread polling the reference queue to determine when your reserve has been collected","label":{"api":{"reference queue":[[26,40]]}}},{"text":"For example, one can create a Set from the list and iterate over all items in the set, calling Collections.frequency(list, item), where list is the List<String> collection and item is each string of the set iteration","label":{"api":{"Set":[[30,32]],"Collections.frequency(list, item)":[[95,127]],"List<String>":[[148,159]]}}},{"text":"If you want to rotate in multiples of 90 degrees left or right, you could use the AffineTransform.getQuadrantRotateInstance(int) methods instead","label":{"api":{"AffineTransform.getQuadrantRotateInstance(int)":[[82,127]]}}},{"text":"Collections.removeIf() unfortunately simply returns a boolean (not even a count of the number of removed elements","label":{"api":{"Collections.removeIf()":[[0,21]]}}},{"text":"The documentation of PrintWriter says it all","label":{"api":{"PrintWriter":[[21,31]]}}},{"text":"The PrintWriter(Writer) constructor creates a writer which is not automatically flushed","label":{"api":{"PrintWriter(Writer)":[[4,22]]}}},{"text":"and as a good practice you have to close all your PrintWriter instances to avoid memory leak","label":{"api":{"PrintWriter":[[50,60]]}}},{"text":"See for example the documentation for the enum Locale.Category","label":{"api":{"Locale.Category":[[47,61]]}}},{"text":"This is one of the reasons, why we have Executors.newWorkStealingPool() in JDK 8 onward -- currently delegating to ForkJoinPool, but open for providing a simpler implementation","label":{"api":{"Executors.newWorkStealingPool()":[[40,70]],"ForkJoinPool":[[115,126]]}}},{"text":"In this case the @Override comes to the rescue as at compile time, it will fail or give a warning when the override does not happen","label":{"api":{"@Override":[[17,25]]}}},{"text":"Also many IDE's recognize the @Override and give you enough support to flag and correct those situations before you even compile","label":{"api":{"@Override":[[30,38]]}}},{"text":"So the @Override in essence declares your intention that this method overrides something","label":{"api":{"@Override":[[7,15]]}}},{"text":"The Retention of the @Override annotation is set to SOURCE","label":{"api":{"Retention":[[4,12]],"@Override":[[21,29]],"SOURCE":[[52,57]]}}},{"text":"Which means the @Override flag is discarded when compiled into a class file","label":{"api":{"@Override":[[16,24]]}}},{"text":"You have to use SwingWorker to execute graphical user interface operations and calculations otherwise the event dispatch thread won't be able to repaint","label":{"api":{"SwingWorker":[[16,26]]}}},{"text":"The Java 8 rewrite, Caffeine, supports adding that functionality through ConcurrentHashMap's atomic compute methods","label":{"api":{"ConcurrentHashMap":[[73,89]]}}},{"text":"You could then insert the new elements where you would like and use something like System.arrayCopy(Object src, int srcPos, Object dest, int destPos, int length) to move in your previous elements","label":{"api":{"insert":[[15,20]],"System.arrayCopy(Object src, int srcPos, Object dest, int destPos, int length)":[[83,160]]}}},{"text":"That being said, an easier approach would be to use an ArrayList, which provides a means to insert, in a particular location of the array list","label":{"api":{"ArrayList":[[55,63]],"insert":[[92,97]],"array list":[[132,141]]}}},{"text":"You can override getPreferredScrollableViewportSize() like they show here and here","label":{"api":{"getPreferredScrollableViewportSize()":[[17,52]]}}},{"text":"If you are concerned about authenticity of the downloaded file, then consider data signing","label":{"api":{}}},{"text":"To be safe, be sure to wrap your ArrayList in a call to Collections.unmodifiableList() and pass that List to your Runnables","label":{"api":{"ArrayList":[[33,41]],"Collections.unmodifiableList()":[[56,85]],"List":[[101,104]],"Runnable":[[114,121]]}}},{"text":"Alternatively, you can construct sublists in your main thread (with List.subList()) so that you don't need to pass the startIndex to each thread","label":{"api":{"List.subList()":[[68,81]]}}},{"text":"As per API, the disk-drive specifier - \"/\" for the UNIX root directory, and \"\\\\\" for a Microsoft Windows UNC pathname","label":{"api":{}}},{"text":"consider using the classes in the java.nio package to your file IO if you can (not sure which version of Java you're running with) because the error handling is improved and you should be able to find a more specific reason for the failure based on the type of exception thrown and the exception message","label":{"api":{"java.nio":[[34,41]]}}},{"text":"Is there any equivalent implementation of (Java 8) streams* in Java 7","label":{"api":{"streams":[[51,57]]}}},{"text":"I am familiar with (Java 8) streams but my project requirement is to use Java 7","label":{"api":{"streams":[[28,34]]}}},{"text":"*Not to be confused with inputStream and outputStream","label":{"api":{"inputStream":[[25,35]],"outputStream":[[41,52]]}}},{"text":"If you store Car.engine in AtomicReference, you could swap them using the CAS operations","label":{"api":{"Car.engine":[[13,22]],"AtomicReference":[[27,41]]}}},{"text":"Don't forget to shutdown the thread pool when not needed anymore, as mentioned in the documentation","label":{"api":{}}},{"text":"See the official documentation for more details","label":{"api":{}}},{"text":"If you are interested in parallelising some of your logic you might take a look at Java 8 Stream API and its support for parallel streams","label":{"api":{"Stream":[[90,95]]}}},{"text":"Another approach is serialization  All your data - String, double and ArrayList are serializable","label":{"api":{"serialization":[[20,32]],"String":[[51,56]],"double":[[59,64]],"ArrayList":[[70,78]]}}},{"text":"There a lot of examples or tutorials how to do simple serialization","label":{"api":{"serialization":[[54,66]]}}},{"text":"You can however use toArray(T) method to easily turn your ArrayList into an array","label":{"api":{"toArray(T)":[[20,29]],"ArrayList":[[58,66]]}}},{"text":"Note that the parameter to split() is a regular expression, so if you aren't familiar with them see the docs here (or google for a tutorial)","label":{"api":{"split()":[[27,33]]}}},{"text":"Collections.sort does an in-place sort and does not return a value","label":{"api":{"Collections.sort":[[0,15]]}}},{"text":"For that, we can use Random#nextInt()","label":{"api":{"Random#nextInt()":[[21,36]]}}},{"text":"There are other operations provided by AtomicReference that you can't implement with normal references","label":{"api":{"AtomicReference":[[39,53]]}}},{"text":"With AtomicReference you can do those operations safely even when multiple threads are trying to access the same references","label":{"api":{"AtomicReference":[[5,19]]}}},{"text":"You get an ArithmeticException as described in BigDecimal.divide(BigDecimal) - \"if the exact quotient does not have a terminating decimal expansion\" because to properly represent the result of 1/3 would take infinite memory","label":{"api":{"ArithmeticException":[[11,29]],"BigDecimal.divide(BigDecimal)":[[47,75]]}}},{"text":"By using BigDecimal.divide(BigDecimal,int,RoundingMode) you explicitly set what precision you'll tolerate, meaning any division can be approximated in-memory","label":{"api":{"BigDecimal.divide(BigDecimal,int,RoundingMode)":[[9,54]]}}},{"text":"To reduce your precision use .stripTrailingZeros(); this effectively reduces the scale to the minimum possible","label":{"api":{".stripTrailingZeros()":[[29,49]]}}},{"text":"You may also want .toPlainString() if you're trying to display these values nicely, since .stripTrailingZeros() on its own will display 100 as 1E+2","label":{"api":{".toPlainString()":[[18,33]],".stripTrailingZeros()":[[90,110]]}}},{"text":"The getResource(String) method called in your first snippet simply isn't declared on ConfigurationManagerUtils - it's declared on the Class class, as an instance method","label":{"api":{"getResource(String)":[[4,22]],"ConfigurationManagerUtils":[[85,109]],"Class":[[134,138]]}}},{"text":"If the second code snippet works as well, that's because there's a static getResource(String) method declared in ConfigurationManagerUtils (or a superclass)","label":{"api":{"getResource(String)":[[74,92]],"ConfigurationManagerUtils":[[113,137]]}}},{"text":"The first snippet is just using a class literal (ConfigurationManagerUtils.class) to obtain a reference to a Class instance on which it can call the getResource(String) instance method","label":{"api":{"ConfigurationManagerUtils.class":[[49,79]],"Class":[[109,113]],"getResource(String)":[[149,167]]}}},{"text":"on the top of your canvas you should use StackPane","label":{"api":{"StackPane":[[41,49]]}}},{"text":"As you see in the documentation, Java 6 allows - and Java 7 allows + or -","label":{"api":{}}},{"text":"With Android Version 19 (KitKat) Java 7 is supported, so you don't get this error","label":{"api":{}}},{"text":"To enhance your code, you could consider using Joda-Time (Java <= 7) or Java 8 java.time classes","label":{"api":{"Joda-Time":[[47,55]],"java.time":[[79,87]]}}},{"text":"DateTimeFormat/DateTimeFormatter with LocalDateTime(joda)/LocalDateTime(java8) that provide an enhanced API over the standard/old ones","label":{"api":{"DateTimeFormat":[[0,13]],"DateTimeFormatter":[[15,31]],"LocalDateTime":[[38,50],[58,70]]}}},{"text":"Using Java 8 java.time classes","label":{"api":{"java.time":[[13,21]]}}},{"text":"I also added some Optional to handle the emptyness of the result if the dateInString cannot be parsed instead of null which is bad","label":{"api":{"Optional":[[18,25]],"dateInString":[[72,83]]}}},{"text":"You must specify the correct encoding when creating your Scanner","label":{"api":{"Scanner":[[57,63]]}}},{"text":"Constructs a new Scanner that produces values scanned from the specified input stream","label":{"api":{"Scanner":[[17,23]],"input stream":[[73,84]]}}},{"text":"Find here your charset, i guess UTF-16 but not an expert in foreign characters :)","label":{"api":{}}},{"text":"There is even a happens-before commitment (from your link)","label":{"api":{}}},{"text":"To delay any task and \"restart\" the delay, you can use Swing timer and if it is running, use its method restart","label":{"api":{"Swing timer":[[55,65]]}}},{"text":"Set#add returns boolean, depending essentially on whether the value has been added - see API","label":{"api":{"Set#add":[[0,6]]}}},{"text":"I'm implementing pipe and filter architecture in java, i'm stuck in scenario in which my in my FilterWriter class i want to send an object over java io's PipedWriter, and on the other hand FilterReader class (PipedReader) will read this object and extract info out of it","label":{"api":{"FilterWriter":[[95,106]],"io":[[149,150]],"PipedWriter":[[154,164]],"FilterReader":[[189,200]],"PipedReader":[[209,219]]}}},{"text":"Use the ServletContext.setAttribute(String,Object) to store your object","label":{"api":{"ServletContext.setAttribute(String,Object)":[[8,49]]}}},{"text":"Then use ServletContext.getAttribute(String) to access that singleton from your Servlets and Filters","label":{"api":{"ServletContext.getAttribute(String)":[[9,43]],"Servlets":[[80,87]],"Filters":[[93,99]]}}},{"text":"If Java 7+, use Objects.equals(); its documentation explicitly specifies that","label":{"api":{"Objects.equals()":[[16,31]]}}},{"text":"You can use an ArrayBlockingQueue with size 1 instead of an ArrayList","label":{"api":{"ArrayBlockingQueue":[[15,32]],"ArrayList":[[60,68]]}}},{"text":"The ArrayBlockingQueue class provides two blocking calls namely put and take","label":{"api":{"ArrayBlockingQueue":[[4,21]],"put":[[64,66]],"take":[[72,75]]}}},{"text":"The ideal way to do this would be to call the put method in your Producer thread and the take method in your Consumer thread in a while loop","label":{"api":{"put":[[46,48]],"Producer":[[65,72]],"take":[[89,92]],"Consumer":[[109,116]]}}},{"text":"Since the queue is initialized with a size of 1, any thread that tries to insert a new element in the queue when it is full will wait when put is called in the while loop","label":{"api":{"put":[[139,141]]}}},{"text":"Similarly, any thread trying to get an element from the queue when it is empty will have to wait when take is called in the while loop","label":{"api":{"take":[[102,105]]}}},{"text":"List#remove() will help","label":{"api":{"List#remove()":[[0,12]]}}},{"text":"If you want a guaranteed HashSet, use Collectors.toCollection(HashSet::new)","label":{"api":{"HashSet":[[25,31]],"Collectors.toCollection(HashSet::new)":[[38,74]]}}},{"text":"For Java 8, this is built in to the new java.time package","label":{"api":{"java.time":[[40,48]]}}},{"text":"From the API","label":{"api":{}}},{"text":"You can have the method throw an IllegalArgumentException","label":{"api":{"IllegalArgumentException":[[33,56]]}}},{"text":"from empty to non-empty), then IllegalStateException would be a good option","label":{"api":{"IllegalStateException":[[31,51]]}}},{"text":"UnsupportedOperationException is \"part of collections\" but both AWT and NIO subclass it","label":{"api":{"UnsupportedOperationException":[[0,28]],"AWT":[[64,66]],"NIO":[[72,74]]}}},{"text":"This can be done with the getNumericValue(char ch) method from the Character class","label":{"api":{"getNumericValue(char ch)":[[26,49]],"Character":[[67,75]]}}},{"text":"You could use a directory stream with a glob like","label":{"api":{"directory stream":[[16,31]],"glob":[[40,43]]}}},{"text":"You should use executeQuery instead of executeUpdate","label":{"api":{"executeQuery":[[15,26]],"executeUpdate":[[39,51]]}}},{"text":"executeUpdate is used for a INSERT, UPDATE, or DELETE statement, and will throw an exception if a ResultSet is returned","label":{"api":{"executeUpdate":[[0,12]],"ResultSet":[[98,106]]}}},{"text":"executeQuery should be used for SELECT statements","label":{"api":{"executeQuery":[[0,11]]}}},{"text":"DefaultListModel will fire the appropriate ListDataEvents when you modify it","label":{"api":{"DefaultListModel":[[0,15]],"ListDataEvents":[[43,56]]}}},{"text":"You'll probably be able to make use of java's BlockingQueue for your data structure behind flasherQueue","label":{"api":{"BlockingQueue":[[46,58]],"flasherQueue":[[91,102]]}}},{"text":"Based on the Matrix4f documentation, the numbering of the matrix elements is row major","label":{"api":{"Matrix4f":[[13,20]]}}},{"text":"When you use System.out.print you will invoke PrintStream.print(int) with the integer value of 65 which will in turn print the characters 6 and 5 to the terminal","label":{"api":{"System.out.print":[[13,28]],"PrintStream.print(int)":[[46,67]]}}},{"text":"When you use out.write you will invoke FileOutputStream.write(byte[]) which will write the bits 01000001 to the file","label":{"api":{"out.write":[[13,21]],"FileOutputStream.write(byte[])":[[39,68]]}}},{"text":"Moreover ArrayList.add can be used to add your Students to your list and you better not add students in constructor use different method to write this scenario","label":{"api":{"ArrayList.add":[[9,21]]}}},{"text":"I am trying to test the parsing of a date-time String with optional fractional seconds of varying significance using DateTimeFormatter","label":{"api":{"DateTimeFormatter":[[117,133]]}}},{"text":"Changing the ResolverStyle to LENIENT does not help here as it fails at the parsing stage, not the resolution","label":{"api":{"ResolverStyle":[[13,25]],"LENIENT":[[30,36]]}}},{"text":"Should I be using DateTimeFormatterBuilder to optionally specify each fractional digit (9 times), or is there a 'smarter' way with my pattern","label":{"api":{"DateTimeFormatterBuilder":[[18,41]]}}},{"text":"You can do it by passing a type token, which can then be used to create an instance of a typed using the JDK's Array.newInstance(Class<?> componentType, int length) factory method","label":{"api":{"Array.newInstance(Class<?> componentType, int length)":[[111,163]]}}},{"text":"What you may be able to do, which is quite a bit more verbose, is use the cast method on the class you have from the enum while you iterate over the list, but even then you wouldn't be able to do any dynamic generic assignment","label":{"api":{"cast":[[74,77]]}}},{"text":"This is the toString() implementation of array object, you are looking for Arrays#toString(), which is implemented to actually show you the elements in the array","label":{"api":{"toString()":[[12,21]],"Arrays#toString()":[[75,91]]}}},{"text":"ifPresent requires a Consumer interface to work","label":{"api":{"ifPresent":[[0,8]],"Consumer":[[21,28]]}}},{"text":"You can use the Pattern.MULTILINE option when compiling your regex","label":{"api":{"Pattern.MULTILINE":[[16,32]]}}},{"text":"In this case one might use HTMLDocument and either construct it with a CSS Stylesheet (body { width","label":{"api":{"HTMLDocument":[[27,38]]}}},{"text":"Another easy way to achieve this is using XPath expressions","label":{"api":{"XPath":[[42,46]]}}},{"text":"You are using TreeSet.addAll() inside the forEach of parallel stream","label":{"api":{"TreeSet.addAll()":[[14,29]],"forEach":[[42,48]]}}},{"text":"The forEach body can be executed simultaneously several times in different threads for different elements and TreeSet is not thread-safe","label":{"api":{"forEach":[[4,10]],"TreeSet":[[110,116]]}}},{"text":"To fix the problem quickly you can either synchronize modification of result or use forEachOrdered","label":{"api":{"forEachOrdered":[[84,97]]}}},{"text":"However it would be cleaner and more performant to flatMap your stream and collect it at once without forEach","label":{"api":{"flatMap":[[51,57]],"forEach":[[102,108]]}}},{"text":"If you just sequentially as a single InputStream, you can construct a SequenceInputStream","label":{"api":{"InputStream":[[37,47]],"SequenceInputStream":[[70,88]]}}},{"text":"A TreeMap is an OrderedMap and a NavigableMap and will allow you to iterate forward and backward, allowing you to access previous and next keys with lowerKey() and higherKey() respectively","label":{"api":{"TreeMap":[[2,8]],"OrderedMap":[[16,25]],"NavigableMap":[[33,44]],"lowerKey()":[[149,158]],"higherKey()":[[164,174]]}}},{"text":"You can use NavigableMap for this, which entrySet()'s iterator return entries in ascending key order","label":{"api":{"NavigableMap":[[12,23]],"entrySet()":[[41,50]]}}},{"text":"When you need to show/print it use SimpleDateFormat for example if you want to show 2015-07-05 16:00:00 you must do like this","label":{"api":{"SimpleDateFormat":[[35,50]]}}},{"text":"The documentation of Stream.flatMap says","label":{"api":{"Stream.flatMap":[[21,34]]}}},{"text":"The answer by JiriS is incorrect, as it uses appendValue whereas the correct way is to use DateTimeFormatterBuilder.appendFraction (which also handles the decimal point)","label":{"api":{"appendValue":[[45,55]],"DateTimeFormatterBuilder.appendFraction":[[91,129]]}}},{"text":"The difference can be seen in the second system out, where appendValue incorrectly parses \"2015-05-07T13:20:22.000276\"","label":{"api":{"appendValue":[[59,69]]}}},{"text":"When parsing, LocalDateTime.parse(str, formatter) is a neater approach than using the formatter directly in most cases","label":{"api":{"LocalDateTime.parse(str, formatter)":[[14,48]]}}},{"text":"When using the builder, take advantage of appendPattern() and optionalStart() to keep things neat","label":{"api":{"builder":[[15,21]],"appendPattern()":[[42,56]],"optionalStart()":[[62,76]]}}},{"text":"This allows any instance of Float, including new Float(\"NaN\"), to be equal to itself, which is part of the general contract of equals, and new Float(\"-0\") to be different from new Float(\"0\") which might be useful (and is consistent with hashCode)","label":{"api":{"Float":[[28,32]],"Float(\"NaN\")":[[49,60]],"Float(\"-0\")":[[143,153]],"Float(\"0\")":[[180,189]],"hashCode":[[237,244]]}}},{"text":"Since you're using a plain toString() it should be coverable using a SimpleDateFormat","label":{"api":{"toString()":[[27,36]],"SimpleDateFormat":[[69,84]]}}},{"text":"Use a FileDialog or JFileChooser to get the File (name and path) the user selects","label":{"api":{"FileDialog":[[6,15]],"JFileChooser":[[20,31]],"File":[[44,47]]}}},{"text":"Then use this File to save the image using ImageIO","label":{"api":{"File":[[14,17]],"ImageIO":[[43,49]]}}},{"text":"When I tried to load the object using ObjectInputStream, it gives an ClassNotFoundException","label":{"api":{"ObjectInputStream":[[38,54]],"ClassNotFoundException":[[69,90]]}}},{"text":"When you instantiate your class for the first time, the class itself is loaded by java.lang.ClassLoader first, so your debugger is likely trying to step in ClassLoader's code, which you don't have","label":{"api":{"java.lang.ClassLoader":[[82,102]],"ClassLoader":[[156,166]]}}},{"text":"There are two ways you can use a TreeMap","label":{"api":{"TreeMap":[[33,39]]}}},{"text":"either the type that you use for the keys must implement interface Comparable, or you use the constructor of TreeMap that takes a Comparator, and you'll have to pass it an implementation of Comparator that can compare the keys","label":{"api":{"Comparable":[[67,76]],"TreeMap":[[109,115]],"Comparator":[[130,139],[190,199]]}}},{"text":"This is necessary because TreeMap needs to know how to compare the keys so that it can sort the entries in the map by key","label":{"api":{"TreeMap":[[26,32]]}}},{"text":"You get a ClassCastException because the CustomInterfaceImplemenationObject that you are using does not implement Comparable, and you are also not using the constructor of TreeMap that takes a Comparator","label":{"api":{"ClassCastException":[[10,27]],"CustomInterfaceImplemenationObject":[[41,74]],"Comparable":[[114,123]],"TreeMap":[[172,178]],"Comparator":[[193,202]]}}},{"text":"First possible solution - make CustomInterfaceImplemenationObject implement Comparable<CustomInterfaceImplemenationObject>","label":{"api":{"CustomInterfaceImplemenationObject":[[31,64]],"Comparable<CustomInterfaceImplemenationObject>":[[76,121]]}}},{"text":"Second possible solution - pass a Comparator<CustomInterfaceImplemenationObject> to the constructor of TreeMap","label":{"api":{"Comparator<CustomInterfaceImplemenationObject>":[[34,79]],"TreeMap":[[103,109]]}}},{"text":"A ConcurrentMap is not a synchronized map","label":{"api":{"ConcurrentMap":[[2,14]]}}},{"text":"In contrast, a ConcurrentMap is designed to allow concurrent updates of different keys and does not synchronizes on itself, so if other code synchronizes on the Map instance, it has no effect","label":{"api":{"ConcurrentMap":[[15,27]],"Map":[[161,163]]}}},{"text":"On the other hand, if all threads would use the mutex for all accesses to the maps, you wouldn’t need a ConcurrentMap anymore","label":{"api":{"ConcurrentMap":[[104,116]]}}},{"text":"The question is what you actually want to achieve, either, you don’t really need the atomicity or you shouldn’t use ConcurrentMaps","label":{"api":{"ConcurrentMap":[[116,128]]}}},{"text":"Anyway, you can supress the warning by using @SupressWarnings like this","label":{"api":{"@SupressWarnings":[[45,60]]}}},{"text":"You could use a Pattern to strip undesirable characters, but (as demonstrated by the confusion here) it's more hassle than using Guava's out of the box solution","label":{"api":{"Pattern":[[16,22]],"Guava":[[129,133]]}}},{"text":"Otherwise, you can try to have a look at the endsWith method of the String class","label":{"api":{"endsWith":[[45,52]],"String":[[68,73]]}}},{"text":"The RoundingMode documentation for Java (introduced in 1.5) should give you a brief introduction to the different methods people use","label":{"api":{"RoundingMode":[[4,15]]}}},{"text":"Now, take a look at the Semaphore class, be sure to read the description in the beginning of that page, it is really helpful to understand the concept","label":{"api":{"Semaphore":[[24,32]]}}},{"text":"As per documentation, if you don't specify your own override of the toString method, the parent's (in this case, Object's) method is invoked, and this results in","label":{"api":{"toStrin":[[68,74]]}}},{"text":"Personally, I would make the method throw an IllegalArgumentException","label":{"api":{"IllegalArgumentException":[[45,68]]}}},{"text":"You can safely throw your queue in the garbage, and use a correct ready made version of BlockingQueue instead","label":{"api":{"BlockingQueue":[[88,100]]}}},{"text":"The behaviour you get is the standard one, if you want to have different one, create your own SelectionListener that considers also getValueIsAdjusting()","label":{"api":{"SelectionListener":[[94,110]],"getValueIsAdjusting()":[[132,152]]}}},{"text":"In order to support retries on InputStream uploads, the AmazonS3Client uses the mark and reset methods of the InputStream interface, marking the stream at the beginning of each upload and reseting to the mark if it needs to retry","label":{"api":{"InputStream":[[31,41],[110,120]],"AmazonS3Client":[[56,69]],"mark":[[80,83]],"reset":[[89,93]]}}},{"text":"Notice that the mark method takes a readlimit parameter, and is only obligated to \"remember\" as many bytes from the InputStream as you ask it for in advance","label":{"api":{"mark":[[16,19]],"InputStream":[[116,126]]}}},{"text":"Some InputStreams implement mark by allocating a new byte[readlimit] to buffer the underlying data in memory so it can be replayed if reset is called, which makes it dangerous to blindly mark using the length of the object to be uploaded (which might be several gigabytes)","label":{"api":{"InputStream":[[5,15]],"mark":[[28,31]],"byte[readlimit]":[[53,67]],"reset":[[134,138]]}}},{"text":"Instead, the AmazonS3Client defaults to calling mark with a value of 128KB - if your InputStream cares about the readlimit, this means the AmazonS3Client won't be able to retry requests that fail after it has sent more than the first 128KB","label":{"api":{"AmazonS3Client":[[13,26],[139,152]],"mark":[[48,51]],"InputStream":[[85,95]]}}},{"text":"Use SwingUtilities.getWindowAncestor, if inside the JWindow class, refer it as this, if no, simply put object inside","label":{"api":{"SwingUtilities.getWindowAncestor":[[4,35]],"JWindow":[[52,58]]}}},{"text":"Try like this using SimpleDateFormat","label":{"api":{"SimpleDateFormat":[[20,35]]}}},{"text":"Then you have to convert the Hibernate properties to a Map, so you can pass them to the  createEntityManagerFactory method","label":{"api":{"properties":[[39,48]],"Map":[[55,57]],"createEntityManagerFactory":[[89,114]]}}},{"text":"The second one uses Collectors.summingInt() collector, there is also a summingLong() collector which you would use with mapToLong","label":{"api":{"Collectors.summingInt()":[[20,42]],"summingLong()":[[71,83]],"mapToLong":[[120,128]]}}},{"text":"Java 8 introduces a very effective LongAdder accumulator designed to speed-up summarizing in parallel streams and multi-thread environments","label":{"api":{"LongAdder":[[35,43]]}}},{"text":"Then execute using Runtime#exec(String[] cmdarray)","label":{"api":{"Runtime#exec(String[] cmdarray)":[[19,49]]}}},{"text":"The JPA EntityManager is not the object to create new databases or users","label":{"api":{"JPA EntityManager":[[4,20]]}}},{"text":"The Servlet container is in charge of the lifecycle of the object reference and will call the destroy method before freeing the object reference","label":{"api":{"Servlet":[[4,10]]}}},{"text":"The Servlet API doesn't provide a method to unregister servlets","label":{"api":{"Servlet":[[4,10]]}}},{"text":"The javadoc of Servlet states it","label":{"api":{"Servlet":[[15,21]]}}},{"text":"That method, as its documentation indicates, takes a regex as first argument, and not a literal substring","label":{"api":{}}},{"text":"However, streams do have such function, and arrays are convertible to streams","label":{"api":{"streams":[[9,15],[70,76]]}}},{"text":"That's how the pointers in the list look internally, to actually add it to the list you need to do this","label":{"api":{}}},{"text":"For this example I will assume you've bound a java.util.Properties for your runtime parameters","label":{"api":{"java.util.Properties":[[46,65]]}}},{"text":"Your questions are answered by the javadoc of setLoginTimeout (emphasis mine)","label":{"api":{"setLoginTimeout":[[46,60]]}}},{"text":"In any Java version I can find, none of these are unique to FileWriter","label":{"api":{"FileWriter":[[60,69]]}}},{"text":"In fact, FileWriter doesn't implement flush(), but OutputStreamWriter does","label":{"api":{"FileWriter":[[9,18]],"flush()":[[38,44]],"OutputStreamWriter":[[51,68]]}}},{"text":"Aside from direct use or direct subclassing, I can't think of anything builtin besides FileWriter that extends OutputStreamWriter, so that should point you in the right direction","label":{"api":{"FileWriter":[[87,96]],"OutputStreamWriter":[[111,128]]}}},{"text":"A quick look into the Scanner docs tells me, that nextLine returns exactly what we want","label":{"api":{"Scanner":[[22,28]],"nextLine":[[50,57]]}}},{"text":"I would suggest reading a bit about MouseEvents in JavaFX","label":{"api":{"MouseEvents":[[36,46]],"JavaFX":[[51,56]]}}},{"text":"According to http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html isDone returns true if cancel(boolean mayInterruptIfRunning) was called","label":{"api":{}}},{"text":"Actually you should implement Comparable but you should also override the equals","label":{"api":{"Comparable":[[30,39]],"equals":[[74,79]]}}},{"text":"Implementing hashCode is necessary if you wanted to use a HashMap instead","label":{"api":{"hashCode":[[13,20]],"HashMap":[[58,64]]}}},{"text":"For those who wonder about Comparator","label":{"api":{"Comparator":[[27,36]]}}},{"text":"This class then needs to implement the Comparator interface","label":{"api":{"Comparator":[[39,48]]}}},{"text":"Properties for those classes can be created by using adapters in javafx.beans.property.adapter package","label":{"api":{"Properties":[[0,9]],"javafx.beans.property.adapter":[[65,93]]}}},{"text":"Use String.replaceAll instead","label":{"api":{"String.replaceAll":[[4,20]]}}},{"text":"In Java, there is the class java.util.zip.ZipFile which you can use in combination with other classes of this package to manipulate the contents of the JAR","label":{"api":{"java.util.zip.ZipFile":[[28,48]]}}},{"text":"To get the String form of an array, use the Arrays class toString method","label":{"api":{"String":[[11,16]],"Arrays":[[44,49]],"toStrin":[[57,63]]}}},{"text":"See the Scanner docs","label":{"api":{"Scanner":[[8,14]]}}},{"text":"Regarding the last part of your question, you can simply use java.lang.Math.pow(2,exponent), there is no specific operator for that if that was what you were wondering","label":{"api":{"java.lang.Math.pow(2,exponent)":[[61,90]]}}},{"text":"Here in oracle documentation on path's relativize method http://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html#relativize(java.nio.file.Path) For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\"","label":{"api":{"relativize":[[39,48]],"java.nio.file.Path":[[133,150]]}}},{"text":"You should use AtomicInteger to hold results","label":{"api":{"AtomicInteger":[[15,27]]}}},{"text":"Also the notify() within the run() method seems to be redundant in this case since its at the end of the method and the lock on the monitor would be relinquished any how","label":{"api":{"notify()":[[9,16]],"run()":[[29,33]]}}},{"text":"If you're just looking for a sorted (unique) container, there's no reason to use a TreeMap - a TreeSet would seem to fit the bill perfectly","label":{"api":{"TreeMap":[[83,89]],"TreeSet":[[95,101]]}}},{"text":"If you are looking for performance, consider using the java.util.concurrent.atomic.AtomicLong class","label":{"api":{"java.util.concurrent.atomic.AtomicLong":[[55,92]]}}},{"text":"Furthermore, consider the underlying charset during conversion (see String-Doc)","label":{"api":{"String":[[68,73]]}}},{"text":"If your file is rather big, read the buffer not at once and use a StringBuilder to concatenate the readings","label":{"api":{"StringBuilder":[[66,78]]}}},{"text":"Use WindowListener windowClosed() method","label":{"api":{"WindowListener":[[4,17]],"windowClosed()":[[19,32]]}}},{"text":"For arbitrary paths, including arcs, Swing provides the GeneralPath object with has methods for working with a sequence of points connected either by lines or Quadratic/Bezier curves","label":{"api":{"Swing":[[37,41]],"GeneralPath":[[56,66]],"has":[[80,82]]}}},{"text":"To model a GeneralPath you can provide a list of points, a winding rule, and the necessary parameters of either a Quadratic curve or a Bezier curve","label":{"api":{}}},{"text":"Path.getFileName() returns a Path containing just the file name","label":{"api":{"Path.getFileName()":[[0,17]],"Path":[[29,32]]}}},{"text":"Path.startsWith checks if the path starts with the same sequence of path components -- a logical, not textual, operation","label":{"api":{"Path.startsWith":[[0,14]]}}},{"text":"It seems like you actually want Callable, which computes a result, instead of Runnable","label":{"api":{"Callable":[[32,39]],"Runnable":[[78,85]]}}},{"text":"submit(Callable) returns a Future which you can call get on and retrieve the result","label":{"api":{"submit(Callable)":[[0,15]],"Future":[[27,32]]}}},{"text":"You can even use the @OneToMany(mappedBy = \"employee\", cascade = CascadeType.DETACH) and EntityManager.detach() to detach your phone class and subsequently detach your employee class or vice versa","label":{"api":{"@OneToMany(mappedBy = \"employee\", cascade = CascadeType.DETACH)":[[21,83]],"EntityManager.detach()":[[89,110]],"employee":[[168,175]]}}},{"text":"You can use the @Index JPA annotation","label":{"api":{"@Index":[[16,21]]}}},{"text":"FYI ByteArrayOutputStream is an in-memory output stream you can use to capture and retrieve what was written to it","label":{"api":{"ByteArrayOutputStream":[[4,24]]}}},{"text":"Instead of forming command using + operator you can use ProcessBuilder","label":{"api":{"ProcessBuilder":[[56,69]]}}},{"text":"You can try BigDecimal, or you can simply create your own object that implements the Comparable interface for sorting and has a toString() method that outputs the value formatted to two decimal places","label":{"api":{"BigDecimal":[[12,21]],"Comparable":[[85,94]],"toString()":[[128,137]]}}},{"text":"According to Javadoc (https://docs.oracle.com/javase/7/docs/api/java/lang/ExceptionInInitializerError.html) is thrown, when an Exception occurs in an static initializer Block","label":{"api":{"Exception":[[127,135]]}}},{"text":"a LinkedBlockingQueue) - you can then have multiple threads servicing that queue as consumers","label":{"api":{"LinkedBlockingQueue":[[2,20]]}}},{"text":"When you use a composite-key, mapped as an Embeddable you need to use @EmbeddedId","label":{"api":{"Embeddable":[[43,52]],"@EmbeddedId":[[70,80]]}}},{"text":"forEach terminates the stream and is exectued because of the side effect of the called Cosumer","label":{"api":{"forEach":[[0,6]],"Cosumer":[[87,93]]}}},{"text":"map maps each stream element to a different value/object using a provided Function","label":{"api":{"map":[[0,2]],"Function":[[74,81]]}}},{"text":"May be you can try adding a listener as shown below and when an item is selected you can use invokeLater and keep the popup open","label":{"api":{"invokeLater":[[93,103]]}}},{"text":"Add an ItemListener to your combo and override itemStateChanged to call showPopup() (but don't call it on the Event Dispatch Thread, use SwingUtilities.InvokeLater())","label":{"api":{"ItemListener":[[7,18]],"itemStateChanged":[[47,62]],"showPopup()":[[72,82]],"SwingUtilities.InvokeLater()":[[137,164]]}}},{"text":"You can either show the Button first or try to use Node.prefWidth(-1)","label":{"api":{"Node.prefWidth(-1)":[[51,68]]}}},{"text":"Top hit algorithms use a min-heap (PriorityQueue in Java), but there should be some size checking in your algorithm","label":{"api":{"PriorityQueue":[[35,47]]}}},{"text":"PriorityQueue efficiently exposes the item with the lowest score","label":{"api":{"PriorityQueue":[[0,12]]}}},{"text":"This looks like a job for Stack","label":{"api":{"Stack":[[26,30]]}}},{"text":"I'm using FreeMarker which uses java.text.DecimalFormat for its numeric formatting","label":{"api":{"FreeMarker":[[10,19]],"java.text.DecimalFormat":[[32,54]]}}},{"text":"Is there any way to get an equivalent using java.text.DecimalFormat","label":{"api":{"java.text.DecimalFormat":[[44,66]]}}},{"text":"Is there any possibility you could use a java.util.Formatter instead","label":{"api":{"java.util.Formatter":[[41,59]]}}},{"text":"The default appearance of a ProgressBar is a blue bar that moves across the control as the progress increases","label":{"api":{"ProgressBar":[[28,38]]}}},{"text":"You can just use JButton class from Swing package","label":{"api":{"JButton":[[17,23]],"Swing":[[36,40]]}}},{"text":"Without any Layout's Manager, buttons will be placed according to a FlowLayout, i.e","label":{"api":{"Layout's Manager":[[12,27]],"FlowLayout":[[68,77]]}}},{"text":"It looks like you're trying to map groups of three characters to single characters, a Map<String, String> can do this easily in roughly three lines","label":{"api":{"Map<String, String>":[[86,104]]}}},{"text":"In that vein, look closely at the functionality provided by String, particularly String.substring() - you can get each three-letter substring easily, without manually extracting each character","label":{"api":{"String":[[60,65]],"String.substring()":[[81,98]]}}},{"text":"I think you should use @OrderColumn and not @OrderBy","label":{"api":{"@OrderColumn":[[23,34]],"@OrderBy":[[44,51]]}}},{"text":"The @OrderBy annotation is used when fetching Collection elements but the order is not maintained by Hibernate","label":{"api":{"@OrderBy":[[4,11]],"Collection":[[46,55]]}}},{"text":"The @OrderColumn allows Hibernate to persist the element Collection index into the designated order column, which is then used when fetching the collection","label":{"api":{"@OrderColumn":[[4,15]],"Collection":[[57,66]]}}},{"text":"s1.concat(\"def\"); and s2.concat(\"def\"); are happening at runtime, they won't be part of the constant pool, they goes to the heap","label":{"api":{"s1.concat(\"def\");":[[0,16]],"s2.concat(\"def\")":[[22,37]]}}},{"text":"Sounds like you want to read up on anyMatch","label":{"api":{"anyMatch":[[35,42]]}}},{"text":"Inversely, there's also noneMatch","label":{"api":{"noneMatch":[[24,32]]}}},{"text":"Use a StringJoiner","label":{"api":{"StringJoiner":[[6,17]]}}},{"text":"You can also create a java class C that uses the ProcessBuilder to start the two other programs (apparently an overkill for you problem)","label":{"api":{"ProcessBuilder":[[49,62]]}}},{"text":"You can read about that in the javadoc for Class.getEnclosingConstructor","label":{"api":{"Class.getEnclosingConstructor":[[43,71]]}}},{"text":"That would require you to use ServerSocketChannel and related classes","label":{"api":{"ServerSocketChannel":[[30,48]]}}},{"text":"replaceAll takes a regular expression, and /** isn't a valid regular expression","label":{"api":{"replaceAll":[[0,9]]}}},{"text":"If you just want to remove /**, use replace instead","label":{"api":{"replace":[[36,42]]}}},{"text":"replaceAll takes a regular expression argument, and $1 is a special way of telling the java regex engine to use group-one as the replacement","label":{"api":{"replaceAll":[[0,9]]}}},{"text":"You need to use replace which matches/replaces the string literally","label":{"api":{"replace":[[16,22]]}}},{"text":"You could also escape the $ character if you still need to use replaceAll","label":{"api":{"replaceAll":[[63,72]]}}},{"text":"You need to make the part that matches the file name reluctant, i.e","label":{"api":{}}},{"text":"If you want to jump on the Java 8 wagon, returning a Stream probably is a more \"modern\" approach","label":{"api":{"Stream":[[53,58]]}}},{"text":"I assume that according to the Jersey JAXRS Client API the client will redirect automatically to the new specified URL, but I'm getting a RedirectionException instead","label":{"api":{"Jersey JAXRS Client":[[31,49]],"RedirectionException":[[138,157]]}}},{"text":"In browser it works fine, but Jersey client seems to be ignoring FOLLOW_REDIRECTS property and throws an RedirectionException instead","label":{"api":{"Jersey":[[30,35]],"RedirectionException":[[105,124]]}}},{"text":"It will be trivial to implement multithreading if they don't need to share any information, you can just implement Runnable interface, create new thread passing the implementation of Runnable, and wait them to end with Thread.join()","label":{"api":{"Runnable":[[115,122],[183,190]],"Thread.join()":[[219,231]]}}},{"text":"Alternatively, the Instrumentation interface would allow you to change a loaded class at runtime","label":{"api":{"Instrumentation":[[19,33]]}}},{"text":"You can use a DecimalFormat to convert the number directly to a String","label":{"api":{"DecimalFormat":[[14,26]],"String":[[64,69]]}}},{"text":"Alternatively, you can call String.format with a 0 to indicate leading zeros and a 12 for the length","label":{"api":{"String.format":[[28,40]]}}},{"text":"Read the section on Requesting Focus","label":{"api":{"Requesting Focus":[[20,35]]}}},{"text":"To fix this, you should use a different variable for each player, for example \"kills.playerUUIDHere\" and \"deaths.playerUUIDHere\"","label":{"api":{"kills.playerUUIDHere":[[79,98]],"deaths.playerUUIDHere":[[106,126]]}}},{"text":"To get a player's UUID, you can use player.getUniqueId(), then to get the String representation of the UUID, you could use uuid.toString()","label":{"api":{"UUID":[[18,21],[103,106]],"player.getUniqueId()":[[36,55]],"uuid.toString()":[[123,137]]}}},{"text":"read about patterns in java","label":{"api":{"patterns":[[11,18]]}}},{"text":"For purposes of generating random numbers in a game, java.util.Random is perfectly fine","label":{"api":{"java.util.Random":[[53,68]]}}},{"text":"There is also java.security.SecureRandom but you don't need that for a game, and also it is significantly slower","label":{"api":{"java.security.SecureRandom":[[14,39]]}}},{"text":"The Collection.retainAll method exists for exactly that purpose","label":{"api":{"Collection.retainAll":[[4,23]]}}},{"text":"This might be a very large number, so I suggest using a BigInteger object for it","label":{"api":{"BigInteger":[[56,65]]}}},{"text":"You should use SwingUtilities.invokeLater for this","label":{"api":{"SwingUtilities.invokeLater":[[15,40]]}}},{"text":"For example ArrayList<AddressBook> should have been named listOfAddressBook etc","label":{"api":{"ArrayList<AddressBook>":[[12,33]],"listOfAddressBook":[[58,74]]}}},{"text":"There are methods to remove an item or modify an item in ArrayList and it is better to read about them to improve your learning rather than asking for help","label":{"api":{"ArrayList":[[57,65]]}}},{"text":"List<AddressBook> person = new ArrayList<>(); so go and find out why this ie better than your approach","label":{"api":{}}},{"text":"You have to use AtomicInteger  to achieve Thread safety","label":{"api":{"AtomicInteger":[[16,28]],"Thread":[[42,47]]}}},{"text":"Thread safe using AtomicInteger","label":{"api":{"AtomicInteger":[[18,30]]}}},{"text":"For this purpose, Java provides a SwingWorker class which allows code to queue items on the EDT","label":{"api":{"SwingWorker":[[34,44]]}}},{"text":"You can specifically use a ArrayList","label":{"api":{"ArrayList":[[27,35]]}}},{"text":"See the reference for more information","label":{"api":{}}},{"text":"Check out Formatter class to know more about formatting a String","label":{"api":{"Formatter":[[10,18]],"String":[[58,63]]}}},{"text":"The issue with Point.getX() is that it returns a double instead of an int","label":{"api":{"Point.getX()":[[15,26]]}}},{"text":"The getX() and getY() functions of the Point class return a double because that's what its parent class (Point2D) requires","label":{"api":{"getX()":[[4,9]],"getY()":[[15,20]],"Point":[[39,43]],"Point2D":[[105,111]]}}},{"text":"This is so all of its subclasses (Point2D.Double and Point2D.Float) will all work in the same places","label":{"api":{"Point2D.Double":[[34,47]],"Point2D.Float":[[53,65]]}}},{"text":"To vertically align text on adjacent lines, a fixed width Font (such as Courier) can be used","label":{"api":{"Font":[[58,61]],"Courier":[[72,78]]}}},{"text":"If using Swing, you can can set the Font of a JTextComponent using the appropriate method","label":{"api":{"Swing":[[9,13]],"Font":[[36,39]],"JTextComponent":[[46,59]]}}},{"text":"The fixed width Font will let the nth character on one line be aligned with the nth character on all other lines","label":{"api":{"Font":[[16,19]]}}},{"text":"I used SwingNode and wrapped JTextField inside","label":{"api":{"SwingNode":[[7,15]],"JTextField":[[29,38]]}}},{"text":"JTextField offers possibility of setting Font from AWT","label":{"api":{"JTextField":[[0,9]],"Font":[[41,44]],"AWT":[[51,53]]}}},{"text":"To do so use Font's attributes and set TRACKING according to your needs","label":{"api":{"Font":[[13,16]],"TRACKING":[[39,46]]}}},{"text":"For instance, I am facing huge problems with dynamic rendering of given JTextField in my app","label":{"api":{"JTextField":[[72,81]]}}},{"text":"Use Pattern#quote(String regex)","label":{"api":{"Pattern#quote(String regex)":[[4,30]]}}},{"text":"We can do comparisons generically through the Comparable interface","label":{"api":{"Comparable":[[46,55]]}}},{"text":"Both Float and Integer implement Comparable","label":{"api":{"Float":[[5,9]],"Integer":[[15,21]],"Comparable":[[33,42]]}}},{"text":"A line-for-line copy of your code using Comparable would be","label":{"api":{"Comparable":[[40,49]]}}},{"text":"You can use String.valueOf  to convert any primitive type (int, double, boolean, etc.) to a String","label":{"api":{"String.valueOf":[[12,25]],"String":[[92,97]]}}},{"text":"You can also use Integer.toString or Double.toString, which convert their respective types to String","label":{"api":{"Integer.toString":[[17,32]],"Double.toString":[[37,51]],"String":[[94,99]]}}},{"text":"charAt() is a method that only works on Strings, as described in the documentation","label":{"api":{"charAt()":[[0,7]],"Strings":[[40,46]]}}},{"text":"So the part where you're going wrong is that you're not specifying on which String you want to call the charAt() method","label":{"api":{"String":[[76,81]],"charAt()":[[104,111]]}}},{"text":"Instead of using the toString method, you can try String.valueOf","label":{"api":{"toStrin":[[21,27]],"String.valueOf":[[50,63]]}}},{"text":"If I kill an Android app with System.exit(...), does it matter what status code I pass","label":{"api":{"System.exit(...)":[[30,45]]}}},{"text":"The Javadoc of CopyOnWriteArrayList states the following","label":{"api":{"CopyOnWriteArrayList":[[15,34]]}}},{"text":"Specifically, it's not transitive, which the contract for .equals() requires","label":{"api":{".equals()":[[58,66]]}}},{"text":"However what you can do is define a custom Comparator (or Ordering, if you're using Guava)","label":{"api":{"Comparator":[[43,52]],"Guava":[[84,88]]}}},{"text":"For most use cases (like sorting, searching, or filtering) you should be able to use a separate Comparator instance just like you would the .equals() method","label":{"api":{"Comparator":[[96,105]],".equals()":[[140,148]]}}},{"text":"If you can't use a separate Comparator for whatever reason, your Employee object will be fundamentally inconsistent, and will prove problematic even if you should get a \"workable\" .hashCode() implemented","label":{"api":{"Comparator":[[28,37]],"Employee":[[65,72]],".hashCode()":[[180,190]]}}},{"text":"I guess, you cannot write a consistent hashCode in your case, because your equals breaks the contract of Object.equals method, namely transitivity","label":{"api":{"hashCode":[[39,46]],"Object.equals":[[105,117]]}}},{"text":"Java, luckily, has a built it mechanism for such sorting - you just need to implement a Comparator","label":{"api":{"Comparator":[[88,97]]}}},{"text":"PriorityQueue needs the data structure that implements Comparable interface unless you pass in a Comparator as a constructor","label":{"api":{"PriorityQueue":[[0,12]],"Comparable":[[55,64]],"Comparator":[[97,106]]}}},{"text":"In order to draw a point use fillOval(x, y, r, r) method from Graphics class","label":{"api":{"fillOval(x, y, r, r)":[[29,48]],"Graphics":[[62,69]]}}},{"text":"Btw, if you use mouseClicked() event, sometimes you will see how your clicks appear to not have effect (to click doesn't draw or store anything), this is because the program is detecting the mouseDragged() event from MouseMotionListener Interface","label":{"api":{"mouseClicked()":[[16,29]],"mouseDragged()":[[191,204]],"MouseMotionListener":[[217,235]]}}},{"text":"To solve this you can change the current event mouseClicked() for mousePressed() event from MouseListener Interface as I already did in the code","label":{"api":{"mouseClicked()":[[47,60]],"mousePressed()":[[66,79]],"MouseListener":[[92,104]]}}},{"text":"You can use peek","label":{"api":{"peek":[[12,15]]}}},{"text":"this way not all the elements might be passed to peek","label":{"api":{"peek":[[49,52]]}}},{"text":"You can create a List (and other kinds of Collections) from any other Collection simply by passing it in the list constructor","label":{"api":{"List":[[17,20]],"Collections":[[42,52]],"Collection":[[70,79]],"list":[[109,112]]}}},{"text":"There is also the addAll() method if you have to, for example, build a list then copy it","label":{"api":{"addAll()":[[18,25]]}}},{"text":"Finally, you can create an unmodifiableList copy of the a list to ensure it never gets changed","label":{"api":{"unmodifiableList":[[27,42]]}}},{"text":"The Mnemonic in JavaFX fires an ActionEvent targeted at the registered Node","label":{"api":{"JavaFX":[[16,21]],"ActionEvent":[[32,42]]}}},{"text":"In the case of RadioButton, the ActionEvent doesn't toggle selection","label":{"api":{"RadioButton":[[15,25]],"ActionEvent":[[32,42]]}}},{"text":"You can add a generic handler to the RadioButton to toggle on the ActionEvent like this (assuming this is JavaFX 8)","label":{"api":{"RadioButton":[[37,47]],"ActionEvent":[[66,76]]}}},{"text":"And you should use a BlockingQueue rather than a List to avoid this scenario","label":{"api":{"BlockingQueue":[[21,33]],"List":[[49,52]]}}},{"text":"Private keys can be encoded using the getEncoded() method and read in using PKCS8EncodedKeySpec supplied to an \"RSA\" KeyFactory instance","label":{"api":{"getEncoded()":[[38,49]],"PKCS8EncodedKeySpec":[[76,94]],"KeyFactory":[[117,126]]}}},{"text":"The item in the list will need to implement Comparable","label":{"api":{"Comparable":[[44,53]]}}},{"text":"Here's an example https://www.javatpoint.com/Comparable-interface-in-collection-framework","label":{"api":{}}},{"text":"an ArrayBlockingQueue, which has the advantage of being bounded); you can then have any number of threads removing and processing emails from this queue","label":{"api":{"ArrayBlockingQueue":[[3,20]]}}},{"text":"The synchronization overhead on the ArrayBlockingQueue is fairly lightweight, and this way you don't need to use database transactions or anything like that","label":{"api":{"ArrayBlockingQueue":[[36,53]]}}},{"text":"Note that by using Matcher#matches() (not find) and leaving the trailing .*, it will cater for your syntax that is anchored at the start only","label":{"api":{"Matcher#matches()":[[19,35]]}}},{"text":"Assuming you're using an HttpsURLConnection, getServerCertificates() should give you what you want (index 0 being the server certificate itself)","label":{"api":{"HttpsURLConnection":[[25,42]],"getServerCertificates()":[[45,67]]}}},{"text":"You'll get one of its instance when using URL.openConnection(), but you'll need to cast the result explicitly to be able to use getServerCertificates()","label":{"api":{"URL.openConnection()":[[42,61]],"getServerCertificates()":[[128,150]]}}},{"text":"If you have an SSLSocket or an SSLEngine instead, use their getSSLSession() method to get the SSLSession, and then getPeerCertificates() on the session","label":{"api":{"SSLSocket":[[15,23]],"SSLEngine":[[31,39]],"getSSLSession()":[[60,74]],"SSLSession":[[94,103]],"getPeerCertificates()":[[115,135]]}}},{"text":"java.lang.AssertionError doesn't have the constructor mentioned in the error message","label":{"api":{"java.lang.AssertionError":[[0,23]]}}},{"text":"You'd make use of Number's methods","label":{"api":{"Number":[[18,23]]}}},{"text":"Given your constraints, however, one optimization you could try is using a DoubleAccumulator, which was intended for cases like these, instead of your one-element array and synchronization","label":{"api":{"DoubleAccumulator":[[75,91]]}}},{"text":"You can use a DatePicker and then use the getters from that to either make a Calendar object or to get the time in millis","label":{"api":{"DatePicker":[[14,23]],"Calendar":[[77,84]]}}},{"text":"I use this function in my projects to get the Calendar from the DatePicker, you may want to extend it to set the hours/ minutes as well","label":{"api":{"Calendar":[[46,53]],"DatePicker":[[64,73]]}}},{"text":"Once you have the Calendar you can use myCalendar.getTimeInMillis() which returns a long of the time in millis since the epoch","label":{"api":{"Calendar":[[18,25]],"myCalendar.getTimeInMillis()":[[39,66]]}}},{"text":"Consider java.util.Calendar class and the following code","label":{"api":{"java.util.Calendar":[[9,26]]}}},{"text":"You can use the DatabaseMetadata interface","label":{"api":{"DatabaseMetadata":[[16,31]]}}},{"text":"Use EntityManager.detach(), to detach the entity from the persistence context","label":{"api":{"EntityManager.detach()":[[4,25]]}}},{"text":"Use mousePressed() from MouseListener Interface instead","label":{"api":{"mousePressed()":[[4,17]],"MouseListener":[[24,36]]}}},{"text":"The File#createTempFile() indeed immediately creates an empty file","label":{"api":{"File#createTempFile()":[[4,24]]}}},{"text":"This can be done in many ways, for example by using shared Semaphore","label":{"api":{"Semaphore":[[59,67]]}}},{"text":"In main code, use shared Semaphore to synchronize","label":{"api":{"Semaphore":[[25,33]]}}},{"text":"As for NPE, you could use Optional from guava or JDK8 to avoid it","label":{"api":{"Optional":[[26,33]]}}},{"text":"Use a tickLabelFormatter on the axis","label":{"api":{"tickLabelFormatter":[[6,23]]}}}]