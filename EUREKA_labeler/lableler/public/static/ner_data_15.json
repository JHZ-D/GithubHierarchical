[{"text": "A much more efficient approach is to use the Collections utility class, this provides a way to return an immutable view", "label": {"api": {"Collections": [[45, 55]]}}}, {"text": "To get a ByteBuffer that points to an existing byte array, you can use the wrap function", "label": {"api": {"wrap": [[75, 78]], "array": [[52, 56]]}}}, {"text": "To get a byte array that points to an existing ByteBuffer, you can use the array method", "label": {"api": {"array": [[14, 18], [75, 79]]}}}, {"text": "However, note that the latter only works when the ByteBuffer is backed by an array (i.e", "label": {"api": {"array": [[77, 81]]}}}, {"text": "if hasArray returns true)", "label": {"api": {"hasArray": [[3, 10]]}}}, {"text": "Sometimes it is implemented as just an array in memory, but it's quite possible that it could read data from the disk or from the network or from some other source when queried", "label": {"api": {"array": [[39, 43]]}}}, {"text": "In this case, you can't just access the underlying array because there is none", "label": {"api": {"array": [[51, 55]]}}}, {"text": "Use find() of the Matcher class", "label": {"api": {"Matcher class": [[18, 30]]}}}, {"text": "String split method returns an array and you cannot assign an array to string", "label": {"api": {"split": [[7, 11]]}}}, {"text": "Your understanding of read(byte[]) is incorrect", "label": {"api": {"read(byte[])": [[22, 33]]}}}, {"text": "You should take a look at readFully() which does read fully, and throws an EOFException for end of stream", "label": {"api": {"readFully()": [[26, 36]]}}}, {"text": "Arrays.sort()), will do it more efficiently and more easily", "label": {"api": {"Arrays.sort()": [[0, 12]]}}}, {"text": "you can chain two Functions via Function.andThen(…) but the available combinations are far away from being complete", "label": {"api": {"Function.andThen(…)": [[32, 50]]}}}, {"text": "In the Oracle documentation of the Runtime class you can see the acceptable inputs in exec()", "label": {"api": {"Runtime class": [[35, 47]]}}}, {"text": "Sounds like String.format() is what you're looking for", "label": {"api": {"String.format()": [[12, 26]]}}}, {"text": "It first replaces {} with %s, then replace each %s with the corresponding value from the String array you provide as an argument for format method", "label": {"api": {"format": [[133, 138]]}}}, {"text": "Note that since format accepts Object..", "label": {"api": {"format": [[16, 21]]}}}, {"text": "Experiment with Box(BoxLayout.Y_AXIS) as an alternative", "label": {"api": {"Box(BoxLayout.Y_AXIS)": [[16, 36]]}}}, {"text": "As the documentation says, if the input string does not contain a parseable integer, a NumberFormatException will be thrown", "label": {"api": {"As the documentation says": [[0, 24]], "NumberFormatException": [[87, 107]]}}}, {"text": "Use substring(startIndex) form of substring method", "label": {"api": {"substring(startIndex)": [[4, 24]]}}}, {"text": "The documentation of Collectors.toMap says that the merge function is treated “as supplied to Map.merge(Object, Object, BiFunction)” and we can learn from there, that simply mapping the duplicate pair to null will remove the entry", "label": {"api": {"documentation of Collectors.toMap": [[4, 36]], "Map.merge(Object, Object, BiFunction)": [[94, 130]]}}}, {"text": "The API documentation of java.util.Random specifies the exact algorithm being used", "label": {"api": {"java.util.Random": [[25, 40]]}}}, {"text": "When using a subclass InputStreamReader, you should rely on ready() to check if you have reached the end of the stream", "label": {"api": {"ready()": [[60, 66]]}}}, {"text": "Take a look here how they override TableModelListener#tableChanged method", "label": {"api": {"TableModelListener#tableChanged": [[35, 65]]}}}, {"text": "See the Node documentation", "label": {"api": {"Node documentation": [[8, 25]]}}}, {"text": "You can use == to check memory identity and java.lang.System#identityHashCode(Object) to get the non-overriden hash code", "label": {"api": {"java.lang.System#identityHashCode(Object)": [[44, 84]]}}}, {"text": "The AlphaComposite class", "label": {"api": {"AlphaComposite": [[4, 17]]}}}, {"text": "You can read input by using a Scanner", "label": {"api": {"Scanner": [[30, 36]]}}}, {"text": "However, if it's some other type that doesn't share an inheritance with MyObject types, then you will get a ClassCastException at runtime (which you can catch and react to)", "label": {"api": {"ClassCastException": [[108, 125]]}}}, {"text": "This is explicitly because BlockingQueue#put(E) will block if it needs to while placing values inside of it", "label": {"api": {"BlockingQueue#put(E) will block": [[27, 57]]}}}, {"text": "But if you want to avoid re-searching the first part of the string, or if you want to allow the replacement to contain the string it's replacing (without then looping infinitely), then once you've done each replacement, use String#indexOf(String str, int fromIndex), which lets you continue from the middle of the string", "label": {"api": {"String#indexOf(String str, int fromIndex)": [[224, 264]]}}}, {"text": "BufferedWriter#write(int) takes a single character (represented by an int)", "label": {"api": {"BufferedWriter#write(int)": [[0, 24]]}}}, {"text": "You could use the Arrays.fill function", "label": {"api": {"Arrays.fill": [[18, 28]]}}}, {"text": "Use a Map", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "There are limitations on what contains can do", "label": {"api": {"contains": [[30, 37]]}}}, {"text": "An Instant is \"[a]n instantaneous point on the time-line\"", "label": {"api": {"\"[a]n instantaneous point on the time-line\"": [[14, 56]]}}}, {"text": "A LocalTime is \"a description of the local time as seen on a wall clock\"", "label": {"api": {"\"a description of the local time as seen on a wall clock\"": [[15, 71]]}}}, {"text": "From the Java 7 API docs", "label": {"api": {"Java 7 API": [[9, 18]]}}}, {"text": "Since you've got an ArrayList, you can use its ListIterator", "label": {"api": {"ListIterator": [[47, 58]]}}}, {"text": "As you can't add a new value to something you're iterating over with a plain Iterator (which is what the enhanced-for is using under the hood), using the ListIterator will give you access to an add method", "label": {"api": {"ListIterator": [[154, 165]]}}}, {"text": "Use Collection#toArray(T[]) to get an array of the elements of type T[]", "label": {"api": {"Collection#toArray(T[])": [[4, 26]]}}}, {"text": "However, you can easily force them into the string pool using the intern() method, which would guarantee it's the same instance being used", "label": {"api": {"intern()": [[66, 73]]}}}, {"text": "The correct way to check for (content) equality is equals(Object that)", "label": {"api": {"equals(Object that)": [[51, 69]]}}}, {"text": "You should use ArrayList#set", "label": {"api": {"ArrayList#set": [[15, 27]]}}}, {"text": "Use ProcessBuilder instead", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "In the Friendship class try specifying the @JoinColumn as well", "label": {"api": {"@JoinColumn": [[43, 53]]}}}, {"text": "You can use the contains method to determine whether a String contains a given character sequence, like so", "label": {"api": {"contains": [[16, 23], [62, 69]]}}}, {"text": "The constructor BigInteger(String val) of class BigInteger throws NumberFormatException if the provided string is not a valid decimal number", "label": {"api": {"BigInteger(String val)": [[16, 37]], "NumberFormatException": [[66, 86]]}}}, {"text": "Now obviously the method ResultSetMetaData.getColumnClassName returns the name of the class for that column", "label": {"api": {"ResultSetMetaData.getColumnClassName": [[25, 60]]}}}, {"text": "Try to use ResultSetMetaData.getColumnName instead to get the name of the column", "label": {"api": {"ResultSetMetaData.getColumnName": [[11, 41]]}}}, {"text": "You can access them using reflection (Method.<T>getAnnotation(Class<T>))", "label": {"api": {"Method.<T>getAnnotation(Class<T>)": [[38, 70]]}}}, {"text": "Note that you have to annotate your custom annotation with @Retention(value=RUNTIME) to be able to read it via reflection", "label": {"api": {"@Retention(value=RUNTIME)": [[59, 83]]}}}, {"text": "If the requirement is to create a Map that contains all values of a given enum, I would use a mapping of String keys into EnumSet values", "label": {"api": {"EnumSet": [[122, 128]]}}}, {"text": "EnumSet is a specialized Set implementation, which is represented internally as a bit vector", "label": {"api": {"EnumSet": [[0, 6]]}}}, {"text": "If you have the full page as String instance then you can use region to select regions of the page", "label": {"api": {"region": [[62, 67], [79, 84]]}}}, {"text": "You can use this to scan these regions in sequence", "label": {"api": {"region": [[31, 36]]}}}, {"text": "You may have to backtrack a bit to allow overlap of the regions", "label": {"api": {"region": [[56, 61]]}}}, {"text": "You could optimize if you backtrack by using hitEnd to check if a match was ongoing", "label": {"api": {"hitEnd": [[45, 50]]}}}, {"text": "You can use a LinkedList and use its set() method", "label": {"api": {"LinkedList": [[14, 23]]}}}, {"text": "Try to use ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[11, 27]]}}}, {"text": "As mentioned by @ControlAltDel, Collection does not support remove(int) only remove(Object) and the int is being auto-boxed to Integer and that Integer is not in the collection; so nothing is removed", "label": {"api": {"Collection": [[32, 41]], "remove(Object)": [[77, 90]]}}}, {"text": "If you want to keep c as a collection then you can remove the first two items using Iterator.remove(); like this", "label": {"api": {"Iterator.remove()": [[84, 100]]}}}, {"text": "Instead, you may use LinkedHashMap which supports such capability", "label": {"api": {"LinkedHashMap": [[21, 33]]}}}, {"text": "The best thing you can do here is using parseExcessDays() applied on the raw parsed data of DateTimeFormatter", "label": {"api": {"parseExcessDays()": [[40, 56]]}}}, {"text": "It is perfectly possible to parse it using the standard formatting techniques, however it is necessary to use SMART or LENIENT mode, see ResolverStyle", "label": {"api": {"ResolverStyle": [[137, 149]]}}}, {"text": "Any formatter can be converted to SMART or LENIENT mode using withResolverStyle() as follows", "label": {"api": {"ResolverStyle": [[66, 78]], "withResolverStyle()": [[62, 80]]}}}, {"text": "The second element of support is parseExcessDays()", "label": {"api": {"parseExcessDays()": [[33, 49]]}}}, {"text": "Java provides the AffineTransform class exactly for this purpose", "label": {"api": {"AffineTransform": [[18, 32]]}}}, {"text": "Use a HashSet to eliminate duplicates", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "Map is an interface, so the answer depends on the implementation you're using", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "Generally speaking, the simpler implementations of this interface, such as HashMap and TreeMap are not thread safe", "label": {"api": {"Map": [[79, 81], [91, 93]], "HashMap": [[75, 81]], "TreeMap": [[87, 93]]}}}, {"text": "If you want to handle the same Map from different threads, either use one of the implementations of a ConcurrentMap (e.g., a ConcurrentHashMap), which guarantees a happens-before-sequence (i.e., if the get was fired before the put, you'd get the old value, even if the put is ongoing, and vise-versa), or synchronize the Map's access (e.g., by calling Collections#synchronizedMap(Map)", "label": {"api": {"Map": [[31, 33], [112, 114], [139, 141], [321, 323], [376, 378], [380, 382]], "HashMap": [[135, 141]], "ConcurrentMap": [[102, 114]], "ConcurrentHashMap": [[125, 141]], "Collections#synchronizedMap(Map)": [[352, 383]]}}}, {"text": "For example, when AbstractList.addAll calls AbstractList.add", "label": {"api": {"AbstractList.addAll": [[18, 36]]}}}, {"text": "Then iterate over the the file with readLine()", "label": {"api": {"readLine()": [[36, 45]]}}}, {"text": "From JFrame#getBounds() (or rather, Component#getBounds())' API", "label": {"api": {"API": [[60, 62]]}}}, {"text": "You may use create the stream of ints directly from Random object using ints(...), box them using boxed() and use the collector to store the result", "label": {"api": {"ints(...)": [[72, 80]], "boxed()": [[98, 104]]}}}, {"text": "This shouldn't be an issue, since the maximum value of a long is 2^63 - 1, but if your BigInteger is user input, you need to check for this", "label": {"api": {"the maximum value of a long is 2^63 - 1": [[34, 72]]}}}, {"text": "Alternatively, you could try myClassloader.findClass()", "label": {"api": {"myClassloader.findClass()": [[29, 53]]}}}, {"text": "Java 8 can use, what is called a Clock, to fake a time other than the real time", "label": {"api": {"Clock": [[33, 37]]}}}, {"text": "now(Clock) instead of simply LocalDateTime.now()", "label": {"api": {"Clock": [[4, 8]], "now(Clock)": [[0, 9]]}}}, {"text": "The toMap collector does not make any guarantee about the map implementation returned (although it's currently a HashMap), but you can always use the overloaded variant if you need more control, providing a throwing merger as parameter", "label": {"api": {"overloaded": [[150, 159]]}}}, {"text": "How about using ChronoUnit#between to work this out, e.g.", "label": {"api": {"ChronoUnit#between": [[16, 33]]}}}, {"text": "You may notice that most classes of the JRE, even ObjectOutputStream.writeObject do not enforce Serializable in their signature", "label": {"api": {"ObjectOutputStream.writeObject": [[50, 79]]}}}, {"text": "ClientEndpointConfig.Configurator.beforeRequest(Map<String,List<String>> headers) may be usable", "label": {"api": {"ClientEndpointConfig": [[0, 19]], "Configurator": [[21, 32]], "beforeRequest": [[34, 46]]}}}, {"text": "So, why don't you override beforeRequest method like below", "label": {"api": {"beforeRequest": [[27, 39]]}}}, {"text": "You can pass ClientEndpointConfig to connectToServer(Class<", "label": {"api": {"ClientEndpointConfig": [[13, 32]], "connectToServer": [[37, 51]]}}}, {"text": "extends Endpoint> endpointClass, ClientEndpointConfig cec, URI path)", "label": {"api": {"ClientEndpointConfig": [[33, 52]]}}}, {"text": "The Java documentation for Integer states", "label": {"api": {"The Java documentation for Integer": [[0, 33]]}}}, {"text": "Another way to count number of occurrences of string is to use splitmethod(http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#split%28java.lang.String%29)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#split%28java.lang.String%29": [[75, 164]]}}}, {"text": "The example provided in the Official Documentation seems to be stopping the currently executed tasks as well (though I am wondering how it does that without interrupting the thread)", "label": {"api": {"Official Documentation": [[28, 49]]}}}, {"text": "inheritIO() is shorthand for redirecting all of the Process's input and output to those of the parent Java process", "label": {"api": {"inheritIO() is shorthand": [[0, 23]]}}}, {"text": "You're trying to use the JDBC GetDate() method to retrieve a text string", "label": {"api": {"JDBC GetDate() method": [[25, 45]]}}}, {"text": "You probably should use GetString() instead", "label": {"api": {"GetString()": [[24, 34]]}}}, {"text": "The first form, toArray(), will return an Object[] back", "label": {"api": {"toArray()": [[16, 24]]}}}, {"text": "The second form, toArray(T[] a) will return an array back that is typed with whatever array you pass into it", "label": {"api": {"toArray(T[] a)": [[17, 30]]}}}, {"text": "Permgen in Java8 ( so not applicable in your case),  JIT optimization, and direct buffers that may reside outside of the normal garbage-collected heap", "label": {"api": {"direct buffers": [[75, 88]]}}}, {"text": "String already has a compareTo", "label": {"api": {"compareTo": [[21, 29]]}}}, {"text": "call thread.interrupt() to ask it to stop, and check for Thread.currentThread().isInterrupted() in the loop to check if the thread must stop", "label": {"api": {"thread.interrupt()": [[5, 22]], "Thread.currentThread().isInterrupted()": [[57, 94]]}}}, {"text": "Alternatively, you can use an ItemListener attached to each JCheckBox to track the count of checked boxes", "label": {"api": {"ItemListener": [[30, 41]]}}}, {"text": "(Note that if this is all that the ItemListener is doing, a single instance can be attached to all the boxes.) The selectionCount should be initialized to the number of boxes initially checked", "label": {"api": {"ItemListener": [[35, 46]]}}}, {"text": "What you want to do is an ArrayList, you can get that done like that", "label": {"api": {"ArrayList": [[26, 34]]}}}, {"text": "The Collector interface in Java 8 is implemented in similar way", "label": {"api": {"Collector": [[4, 12]]}}}, {"text": "All you need to do is override the toString method in each different class that you want to be displayable, then when you want to display an object (even if you don't know exactly what type it is), just call toString on it and print the result", "label": {"api": {"toString": [[35, 42], [208, 215]]}}}, {"text": "Polymorphism will do the job of picking which toString method implementation to call", "label": {"api": {"toString": [[46, 53]]}}}, {"text": "Note that toString is called automatically when you pass any Object to System.out.println", "label": {"api": {"toString": [[10, 17]]}}}, {"text": "Also, see JavaDoc of Parameter#getName()", "label": {"api": {"Parameter#getName()": [[21, 39]]}}}, {"text": "You can use getState() on your Service, which will return you the current state of the Worker", "label": {"api": {"getState()": [[12, 21]], "current state of the Worker": [[66, 92]]}}}, {"text": "Use Scanner#nextInt() and Scanner.nextDouble()", "label": {"api": {"Scanner#nextInt()": [[4, 20]], "Scanner.nextDouble()": [[26, 45]]}}}, {"text": "NullPointerException is a sub-class of RuntimeException, which makes it an unchecked exception, which doesn't have to be handled or declared in a throws clause", "label": {"api": {"NullPointerException": [[0, 19]], "RuntimeException": [[39, 54]]}}}, {"text": "IllegalAccessException is a checked exception, so it must either be caught or be declared in the throws clause of any method that may throw it", "label": {"api": {"IllegalAccessException": [[0, 21]]}}}, {"text": "or to use the @Pattern annotation with a regular expression that requires a non-whitespace character to be present (as the Pattern annotation accepts nulls and does not match them against the pattern)", "label": {"api": {"accepts nulls and does not match them against the pattern": [[142, 198]]}}}, {"text": "The better solution is to use the computeIfAbsent method of ConcurrentHashMap", "label": {"api": {"computeIfAbsent": [[34, 48]]}}}, {"text": "Thus instead of having two get and set methods in your cache implementation I'd suggest to have single computeIfAbsent method", "label": {"api": {"computeIfAbsent": [[103, 117]]}}}, {"text": "Java SE 8 makes this easy, as you can define 3 Comparators and chain them with one of the thenComparing methods", "label": {"api": {"Comparator": [[47, 56]]}}}, {"text": "If you don't need to deal with leap second (which is not supported in Sun/Oracle JDK), use SimpleDateFormat with setLenient to false to disable lenient parsing", "label": {"api": {"SimpleDateFormat": [[91, 106]], "setLenient": [[113, 122]]}}}, {"text": "Formatting the Integer is then a small thing", "label": {"api": {"Formatting the Integer": [[0, 21]]}}}, {"text": "try to use prompt text instead setting value", "label": {"api": {"prompt text": [[11, 21]]}}}, {"text": "Maybe you will have to setValue(null) just to see prompt text again", "label": {"api": {"prompt text": [[50, 60]]}}}, {"text": "You use a BlockingQueue to hold the writer data while you're reading it", "label": {"api": {"BlockingQueue": [[10, 22]]}}}, {"text": "You have the means through the BlockingQueue methods to detect either situation", "label": {"api": {"BlockingQueue": [[31, 43]]}}}, {"text": "So instead of == compare with equals() and fill your boolean like this", "label": {"api": {"equals()": [[30, 37]]}}}, {"text": "Here JAVA7 and JAVA8 API's", "label": {"api": {"JAVA7": [[5, 9]], "JAVA8": [[15, 19]]}}}, {"text": "According to the oracle docs Collection.sort should be implemented at least since 1.6", "label": {"api": {"the oracle docs": [[13, 27]]}}}, {"text": "At a minimum, consider using deriveFont()", "label": {"api": {"deriveFont()": [[29, 40]]}}}, {"text": "Check out these Graphics Java Docs for more information on drawing images", "label": {"api": {"Graphics Java Docs": [[16, 33]]}}}, {"text": "How about using a HashSet and comparing the size of the Hashset with the length of the original array", "label": {"api": {"HashSet": [[18, 24]]}}}, {"text": "HashSet gets rid of duplicates, so if the size is the same as the array length, it will mean that all array elements are different", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "According to the Java8 documentation for the Date class, calling Date during the leap second will/did correctly return :60 or :61", "label": {"api": {"Java8 documentation for the Date class": [[17, 54]]}}}, {"text": "How it does that is a bit of mystery though, since the underlying Instant class spreads the leap second out over the last 1000 seconds of the day - so each of those last seconds will actually be 1.001 seconds long - and your application wont know whether it's in the leap second or not", "label": {"api": {"Instant class": [[66, 78]]}}}, {"text": "I was just wondering why java.util.Scanner implements java.util.Iterator", "label": {"api": {"java.util.Scanner": [[25, 41]], "java.util.Iterator": [[54, 71]]}}}, {"text": "Scanner implements the remove method and throws an UnsupportedOperationException", "label": {"api": {"remove": [[23, 28]], "UnsupportedOperationException": [[51, 79]]}}}, {"text": "What is the use of implementing iterator and adding a method that throws an exception", "label": {"api": {"add": [[45, 47]]}}}, {"text": "One can argue that it is defined so that the class which might extend Scanner could implement the method, like AbstractList has an add method that throws an UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[157, 185]], "AbstractList": [[111, 122]], "add": [[131, 133]]}}}, {"text": "But AbstractList is an abstract class, whereas Scanner is a final class", "label": {"api": {"AbstractList": [[4, 15]]}}}, {"text": "Use String.split() to split your arguments into fields, you can then iterate over these to grab the values", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "According to the documentatiom mathematical operators can be used in fxml bindings", "label": {"api": {"documentatiom": [[17, 29]]}}}, {"text": "But some provided resources need to be released for example a CloseableHttpClient needs to be closed or an ExecutorService needs to be shutdown", "label": {"api": {"closed": [[94, 99]], "ExecutorService": [[107, 121]], "shutdown": [[135, 142]]}}}, {"text": "Since your input is not a date but rather a month/year combination, I would suggest using the YearMonth class", "label": {"api": {"YearMonth": [[94, 102]]}}}, {"text": "Look at InterruptedIOException API", "label": {"api": {"InterruptedIOException": [[8, 29]]}}}, {"text": "InterruptedIOException Signals that an I/O operation has been interrupted", "label": {"api": {"InterruptedIOException": [[0, 21]]}}}, {"text": "An InterruptedIOException is thrown to indicate that an input or output transfer has been terminated because the thread performing it was interrupted", "label": {"api": {"InterruptedIOException": [[3, 24]]}}}, {"text": "There is however an option (StandardSocketOptions.SO_REUSEADDR) which can tell for the Java socket, that an old socket in TIMED_WAIT state can be reused", "label": {"api": {"StandardSocketOptions.SO_REUSEADDR": [[28, 61]]}}}, {"text": "You can use String.replaceFirst(String, String) to remove processedInput from processedTarget", "label": {"api": {"String.replaceFirst(String, String)": [[12, 46]]}}}, {"text": "For example, ArrayList for index based retrieval and TreeMap (or priority queue) for sorting", "label": {"api": {"ArrayList": [[13, 21]], "TreeMap": [[53, 59]]}}}, {"text": "Wrap your Callable in a java.util.concurrent.FutureTask..", "label": {"api": {"java.util.concurrent.FutureTask": [[24, 54]]}}}, {"text": "call task.cancel(true) when you want to cancel things", "label": {"api": {"task.cancel(true)": [[5, 21]]}}}, {"text": "Otherwise, your thread will need to check using Thread.isInterrupted() periodically to see if it should continue or abort", "label": {"api": {"Thread.isInterrupted()": [[48, 69]]}}}, {"text": "Depends on how you're printing it but the general answer is going to be, use the DecimalFormat", "label": {"api": {"DecimalFormat": [[81, 93]]}}}, {"text": "You construct a java.net.URL object that represents the path to your RESTful resource", "label": {"api": {"java.net.URL": [[16, 27]]}}}, {"text": "Then you call openConnection() on that, which gives you a URLConnection which you can safely cast to an HttpURLConnection if your URL started with http:// or https://", "label": {"api": {"openConnection()": [[14, 29]]}}}, {"text": "You will have to convert your object to XML yourself; maybe JAXB and related classes will help", "label": {"api": {"JAXB": [[60, 63]]}}}, {"text": "Java Licensees may want to provide a different implementation of FileSystemView to better handle a given operating system", "label": {"api": {"FileSystemView": [[65, 78]]}}}, {"text": "The important part is to change the behavior of the isTraversable(File) method", "label": {"api": {"isTraversable(File)": [[52, 70]]}}}, {"text": "I try to use stream from java 8, but without result", "label": {"api": {"stream": [[13, 18]]}}}, {"text": "If you feel fancy, you can upgrade to JavaFX, and use a Grid Pane instead", "label": {"api": {"Grid Pane": [[56, 64]]}}}, {"text": "You can write things into JAR files with the plain JarFile constructor, but it looks like you want plain text files", "label": {"api": {"JarFile constructor": [[51, 69]]}}}, {"text": "Note the Statement documentation says", "label": {"api": {"Statement documentation": [[9, 31]]}}}, {"text": "Then with Java 8, you can use Integer.compareUnsigned, otherwise you can use this identity", "label": {"api": {"Integer.compareUnsigned": [[30, 52]]}}}, {"text": "The input stream is in a simple line-oriented format as specified in load(Reader) and is assumed to use the ISO 8859-1 character encoding; that is each byte is one Latin1 character", "label": {"api": {"load(Reader)": [[69, 80]]}}}, {"text": "You need to encode your URL using URLEncoder", "label": {"api": {"URLEncoder": [[34, 43]]}}}, {"text": "Just use URLEncoder.encode method, something like this", "label": {"api": {"URLEncoder": [[9, 18]]}}}, {"text": "To get perhaps a more useful output for your purposes, you can use Arrays.toString", "label": {"api": {"Arrays.toString": [[67, 81]]}}}, {"text": "To avoid the problem of creating an array of generic type Item, we can take a look at Java's ArrayList implementation", "label": {"api": {"ArrayList": [[93, 101]]}}}, {"text": "From javadocs (https://docs.oracle.com/javase/8/javafx/api/javafx/application/Application.html#launch-java.lang.String...-)", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/application/Application.html#launch-java.lang.String...-": [[15, 121]]}}}, {"text": "You should override ClassLoader(ClassLoader parent) constructor in your CustomClassLoader and pass your URLClassLoader there", "label": {"api": {"ClassLoader(ClassLoader parent)": [[20, 50]]}}}, {"text": "You should use BigInteger for this.", "label": {"api": {"BigInteger": [[15, 24]]}}}, {"text": "By default, each SQL command is put into an automatic transaction, so you get the overhead for all of them", "label": {"api": {"automatic transaction": [[44, 64]]}}}, {"text": "System.getenv() and System.getenv(String) were introduced in the very early days of java, and then deprecated in Java 1.2(!)", "label": {"api": {"System.getenv()": [[0, 14]], "System.getenv(String)": [[20, 40]]}}}, {"text": "You could use a simple Map<Integer, Integer> where the key is the item value, and the value is the count of that item", "label": {"api": {"Map<Integer, Integer>": [[23, 43]]}}}, {"text": "You could now use something like Collections.max to find the maximum Integer value on count.values() - or even write a Comparator<Entry<Integer, Integer>> for the entries to find the maximal Map.Entry<Integer, Integer> from count.entrySet() (preferable, can be used with Collections.max)", "label": {"api": {"Collections.max": [[33, 47], [271, 285]], "count.values()": [[86, 99]], "Map.Entry<Integer, Integer>": [[191, 217]], "count.entrySet()": [[224, 239]]}}}, {"text": "You could use something like MutableInt (Apache commons) or even AtomicInt for mutable map values", "label": {"api": {"AtomicInt": [[65, 73]]}}}, {"text": "You could try using a RuleBasedCollator like this", "label": {"api": {"RuleBasedCollator": [[22, 38]]}}}, {"text": "When you write, you write back numBytes of data, but the read function has usefully returned", "label": {"api": {"usefully returned": [[75, 91]]}}}, {"text": "Therefore, your fix is to use a different write", "label": {"api": {"use a different write": [[26, 46]]}}}, {"text": "Note that the behavior of the ConcurretMap.compute is well-documented (even the equivalent code is provided), so it's unlikely that such implementation will break in future", "label": {"api": {"ConcurretMap.compute": [[30, 49]]}}}, {"text": "The JSR 203 API has all the tools you need for that; and in this case, the Files class", "label": {"api": {"the Files class": [[71, 85]]}}}, {"text": "The Javadocs for TreeItem show an example that basically does this", "label": {"api": {"Javadocs for TreeItem": [[4, 24]]}}}, {"text": "This Swing based Launcher uses ProcessBuilder to run programs in a separate JVM", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "You can implement a callback method in the Request class and perform the validation programmatically", "label": {"api": {"callback method": [[20, 34]]}}}, {"text": "Create a class that implements ServletContextListener and in method contextInitialized create your instance of Uber", "label": {"api": {"ServletContextListener": [[31, 52]]}}}, {"text": "The method to obtain these, ServletContext#getServlet, is deprecated", "label": {"api": {"ServletContext#getServlet": [[28, 52]]}}}, {"text": "Still, in point 1, since you create the instance of Uber, you can store it as an attribute in ServletContext, and then retrieve it in each servlet using HttpServletRequest#getServletContext", "label": {"api": {"HttpServletRequest#getServletContext": [[153, 188]]}}}, {"text": "Personally, I would just go with the \"old school\" solution, maybe making it a bit more compact using the new getOrDefault", "label": {"api": {"getOrDefault": [[109, 120]]}}}, {"text": "it is not implemented in Java -- see StrictMath.log10)", "label": {"api": {"StrictMath.log10": [[37, 52]]}}}, {"text": "To retrieve a uniformly distributed random long, use the Random class and its method nextLong()", "label": {"api": {"method nextLong()": [[78, 94]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html for more info", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html": [[0, 66]]}}}, {"text": "From Comparator API", "label": {"api": {"Comparator API": [[5, 18]]}}}, {"text": "AFAIK you can't override it inside your class because if you take a look at the @Where documentation you will see that this interface is annotated @Retention(value=RUNTIME) so it has RUNTIME as a RetentionPolicy and you can see in the RetentionPolicy documentation that", "label": {"api": {"RetentionPolicy documentation": [[235, 263]]}}}, {"text": "If you want concurrent access to it use a CopyOnWriteArrayList which is essentially what you are trying to implement in your code", "label": {"api": {"CopyOnWriteArrayList": [[42, 61]]}}}, {"text": "ConcurrentLinkedQueue should be suitable", "label": {"api": {"ConcurrentLinkedQueue": [[0, 20]]}}}, {"text": "Consequently, a Class instance describing the class Example is create when the class is loaded", "label": {"api": {"when the class is loaded": [[70, 93]]}}}, {"text": "Instead of getFields use getDeclaredFields", "label": {"api": {"getFields": [[11, 19]], "getDeclaredFields": [[25, 41]]}}}, {"text": "The effect shown is characteristic of AffineTransformOp#filter()", "label": {"api": {"AffineTransformOp#filter()": [[38, 63]]}}}, {"text": "Use RenderingHints, such as VALUE_ANTIALIAS_ON and VALUE_INTERPOLATION_BILINEAR, as needed", "label": {"api": {"RenderingHints": [[4, 17]]}}}, {"text": "The gist of it is to be found in the documentation for java.sql.Driver and java.sql.DriverManager", "label": {"api": {"java.sql.Driver": [[55, 69], [75, 89]], "java.sql.DriverManager": [[75, 96]]}}}, {"text": "Basically, starting with JDBC 4, all you have to do is create a META-INF/services/java.sql.Driver file for your SQL driver implementation and the JRE will load it automatically", "label": {"api": {"java.sql.Driver": [[82, 96]]}}}, {"text": "Ignoring the CountDownLatch factor, the ConcurrentHashMap does not synchronize on a retrieval of a key but retrieves the most recent value corresponding to a key", "label": {"api": {"ConcurrentHashMap": [[40, 56]]}}}, {"text": "As for the ConcurrentHashMap, the api documentation reads", "label": {"api": {"the api documentation": [[30, 50]]}}}, {"text": "If you want to sort based on a different field, you can supply a custom Comparator to the sort method", "label": {"api": {"custom Comparator": [[65, 81]]}}}, {"text": "Read them in and you can then determine the order they're printed by supplying a custom Comparator", "label": {"api": {"custom Comparator": [[81, 97]]}}}, {"text": "Note that the class java.util.Objects (Java 8) already contains similar helper methods", "label": {"api": {"java.util.Objects": [[20, 36]]}}}, {"text": "The Synthesizer interface will be particularly important to this task", "label": {"api": {"Synthesizer interface": [[4, 24]]}}}, {"text": "To redirect actions, that change the GUI, back to the FX User Thread, call  Platform.runLater(Runnable r)", "label": {"api": {"Platform.runLater(Runnable r)": [[76, 104]]}}}, {"text": "See the Javadocs of getDate()", "label": {"api": {"Javadocs of getDate()": [[8, 28]]}}}, {"text": "These specific functions are deprecated because the newer Calendar is a better option", "label": {"api": {"Calendar": [[58, 65]]}}}, {"text": "And JPQL spec use this variant", "label": {"api": {"JPQL spec": [[4, 12]]}}}, {"text": "The exception java.lang.IllegalArgumentException is thrown because you are passing String as a parameter to the Date constructor, that is deprecated and replaced by DateFormat.parse(String s)", "label": {"api": {"Date constructor": [[112, 127]]}}}, {"text": "You need to first create your Scanner, then call nextLine on it to get input from the user", "label": {"api": {"nextLine": [[49, 56]]}}}, {"text": "The only situation in which you should not use Arrays.sort is if you've almost entirely finished your system, profiled it carefully, and determined that the part of the code that sorts your array is the bottleneck", "label": {"api": {"Arrays.sort": [[47, 57]]}}}, {"text": "random#nextInt(int n) gives you a value between 0 (inclusive) and the specified value (exclusive), i.e", "label": {"api": {"random#nextInt(int n)": [[0, 20]]}}}, {"text": "According to the documentation for ForkJoinTask", "label": {"api": {"the documentation for ForkJoinTask": [[13, 46]]}}}, {"text": "Method invoke() is semantically equivalent to fork(); join() but always attempts to begin execution in the current thread", "label": {"api": {"invoke()": [[7, 14]]}}}, {"text": "So the version with invoke() is doing the same thing as your version, but instead of passing both jobs off to two different threads, it's passing t2 off to another thread and trying to handle t1 itself", "label": {"api": {"invoke()": [[20, 27]]}}}, {"text": "Another approach for what you want using String#toCharArray()", "label": {"api": {"String#toCharArray()": [[41, 60]]}}}, {"text": "Because InputStream.read() returns an int instead of a byte", "label": {"api": {"InputStream.read()": [[8, 25]]}}}, {"text": "You can increase or decrease the given time.Also look at MouseAdapter", "label": {"api": {"MouseAdapter": [[57, 68]]}}}, {"text": "Use a Screen method, e.g", "label": {"api": {"Screen": [[6, 11]]}}}, {"text": "one of the getScreensForRectangle(), to find the screen of interest", "label": {"api": {"Screen": [[14, 19]]}}}, {"text": "In the GraphicsEnvironment obtained from getLocalGraphicsEnvironment(), iterate though each GraphicsConfiguration of each GraphicsDevice to find those devices whose bounds intersect the bounds obtained from screen.getBounds()", "label": {"api": {"GraphicsEnvironment": [[7, 25], [49, 67]], "GraphicsConfiguration": [[92, 112]], "GraphicsDevice": [[122, 135]]}}}, {"text": "extends works, but your list wants Class objects", "label": {"api": {"Class": [[35, 39]]}}}, {"text": "extends Foo>> can contain Class objects that represent subtypes of Foo (Foo.class, Bla.class, Blub.class)", "label": {"api": {"Class": [[26, 30]]}}}, {"text": "You're also using poll which doesn't block", "label": {"api": {"poll": [[18, 21]]}}}, {"text": "You may want to use PriorityBlockingQueue", "label": {"api": {"PriorityBlockingQueue": [[20, 40]]}}}, {"text": "Instead, use the thread-safe PriorityBlockingQueue class", "label": {"api": {"PriorityBlockingQueue": [[29, 49]]}}}, {"text": "You can utilize the take method to avoid busy-wait", "label": {"api": {"take": [[20, 23]]}}}, {"text": "Moreover, the class PriorityQueue is not threadsafe according to http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html": [[65, 133]]}}}, {"text": "The ThreadLocal class can make this happen for you", "label": {"api": {"ThreadLocal": [[4, 14]]}}}, {"text": "For those using 1.7, there is indeed a way to use ThreadLocal without the lambda expression", "label": {"api": {"ThreadLocal": [[50, 60]]}}}, {"text": "If speed is an issue you could put the names in a HashMap instead of an array", "label": {"api": {"HashMap": [[50, 56]]}}}, {"text": "I would suggest, that you use the java.util.Collections.sort method, and provide a custom comperator", "label": {"api": {"java.util.Collections.sort": [[34, 59]]}}}, {"text": "You can use a ScheduledThreadPoolExecutor instead", "label": {"api": {"ScheduledThreadPoolExecutor": [[14, 40]]}}}, {"text": "In your case myStringList is an Iterable", "label": {"api": {"Iterable": [[32, 39]]}}}, {"text": "The returned list may be a read only wrapper which provides optimal performance as it is provided by the JRE itself and takes care to override the default methods where feasible", "label": {"api": {"read only wrapper": [[27, 43]]}}}, {"text": "The documentation for isDefined() states that a character \"is defined\" if it has an entry or is in a range in the UnicodeData file", "label": {"api": {"documentation for isDefined()": [[4, 32]]}}}, {"text": "MyComparator needs to implement Comparator so that Java knows how to compare the elements on your list", "label": {"api": {"Comparator": [[2, 11], [32, 41]]}}}, {"text": "It can be done in two forms Comparator or Comparable", "label": {"api": {"Comparator": [[28, 37]], "Comparable": [[42, 51]]}}}, {"text": "As you already have a component type, use Array.newInstance", "label": {"api": {"Array.newInstance": [[42, 58]]}}}, {"text": "I think you should use the indexOf(String str) method of the String class to get the location of the \"src=\" string, then use the substring(int,int) method to get the substrings containing the string parts you want, then you can use the equals method", "label": {"api": {"indexOf(String str)": [[27, 45]], "substring(int,int)": [[129, 146]]}}}, {"text": "Maybe you're looking for something like FileReader", "label": {"api": {"FileReader": [[40, 49]]}}}, {"text": "You're probably looking for FileReader", "label": {"api": {"FileReader": [[28, 37]]}}}, {"text": "A good example of the Adapter pattern in Java is the Arrays.asList() method", "label": {"api": {"Arrays.asList()": [[53, 67]]}}}, {"text": "I think using the StreamSupport.intStream overload taking a Supplier with IntStream.concat (which \"creates a lazily concatenated stream\") should be lazy enough to only create the second spliterator when elements are demanded from it, but even creating the stream (not evaluating it) overflows the stack", "label": {"api": {"StreamSupport.intStream overload taking a Supplier": [[18, 67]], "\"creates a lazily concatenated stream\"": [[98, 135]]}}}, {"text": "According to the first paragraph of the JavaDocs for @ManyToOne", "label": {"api": {"first paragraph of the JavaDocs for @ManyToOne": [[17, 62]]}}}, {"text": "The Java Number class is the base class for the classes that wrap primitive types (Byte, Short, Integer, Long, Float, Double) and also other classes like BigInteger and BigDecimal and has 6 accessor (aka getter) methods", "label": {"api": {"Java Number class": [[4, 20]]}}}, {"text": "The documentation at least says that much; here's the source of those two functions to prove it", "label": {"api": {"says that much": [[27, 40]]}}}, {"text": "Using StackTraceElement, you might get the line number from which you can figure out whether abc() is called from catch block of main() or not", "label": {"api": {"StackTraceElement": [[6, 22]]}}}, {"text": "This exception can be thrown by the API used to read annotations reflectively", "label": {"api": {"API used to read annotations reflectively": [[36, 76]]}}}, {"text": "Create temporary directory using Files.createTempDirectory, then move the file to the directory and manipulate it", "label": {"api": {"Files.createTempDirectory": [[33, 57]]}}}, {"text": "If an exception inherits from RuntimeException then it is unchecked", "label": {"api": {"RuntimeException": [[30, 45]]}}}, {"text": "You can use BigDecimal to handle large number", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "The BigDecimal class provides operations for arithmetic, scale manipulation, rounding, comparison, hashing, and format conversion", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "The toString() method provides a canonical representation of a BigDecimal", "label": {"api": {"BigDecimal": [[63, 72]]}}}, {"text": "If you want to store very large integers like this one, you should use the BigInteger class - a double only has enough precision to store about 15-16 significant figures accurately", "label": {"api": {"BigInteger class": [[75, 90]]}}}, {"text": "I strongly recommend reading the JavaDoc for the SimpleDateFormat class", "label": {"api": {"JavaDoc for the SimpleDateFormat class": [[33, 70]]}}}, {"text": "I think you are looking for CountDownLatch", "label": {"api": {"CountDownLatch": [[28, 41]]}}}, {"text": "Take a look at string replace", "label": {"api": {"string replace": [[15, 28]]}}}, {"text": "You want to use find instead", "label": {"api": {"find": [[16, 19]]}}}, {"text": "You could use BigInteger or BigDecimal if you really need big numbers", "label": {"api": {"BigInteger": [[14, 23]], "BigDecimal": [[28, 37]]}}}, {"text": "One option is to wrap your existing List in a synchronized version with Collections.synchronizedList(List<T> list)", "label": {"api": {"Collections.synchronizedList(List<T> list)": [[72, 113]]}}}, {"text": "After reviewing the JDBC APIs and oracle.jdbc.OracleDatabaseMetaData, I'm pretty certain that there is no way to retrieve this information directly through DatabaseMetaData when using stock Oracle JDBC drivers", "label": {"api": {"DatabaseMetaData": [[52, 67], [156, 171]]}}}, {"text": "As a cheat, you can getConnection() from the DatabaseMetaData object and run the database-specific queries to retrieve the information you need, as follows", "label": {"api": {"DatabaseMetaData": [[45, 60]]}}}, {"text": "There is no built-in target pseudoclass, but there is an API for creating your own CSS PseudoClass objects", "label": {"api": {"CSS PseudoClass objects": [[83, 105]]}}}, {"text": "I think what you are looking for is Java's ThreadLocal", "label": {"api": {"ThreadLocal": [[43, 53]]}}}, {"text": "Here is a tutorial on using ThreadLocal", "label": {"api": {"ThreadLocal": [[28, 38]]}}}, {"text": "If you want your variable to be unique per thread, you may want to use ThreadLocal", "label": {"api": {"ThreadLocal": [[71, 81]]}}}, {"text": "Class<T> is not valid, since that's like saying realm.where(Class<List<String>>) or realm.where(Class<String>)", "label": {"api": {"Class<T>": [[0, 7]]}}}, {"text": "What you need is an actual Class<T> instance", "label": {"api": {"Class<T>": [[27, 34]]}}}, {"text": "At runtime, the method basically needs a Class<T> instance to work properly", "label": {"api": {"Class<T>": [[41, 48]]}}}, {"text": "Since you cannot get that from T, you will have to explicitly supply an argument of type Class<T>", "label": {"api": {"Class<T>": [[89, 96]]}}}, {"text": "For more flexibility in folding words together, you could use a Collator to index with a CollationKey rather than lowercase words", "label": {"api": {"Collator": [[64, 71]]}}}, {"text": "A similar enhancement could be made for tokenizing the text, rather than simply splitting on spaces", "label": {"api": {"tokenizing": [[40, 49]]}}}, {"text": "That way, you can use a long to store the number in your database, and when you need to format the date, you can either use Joda Time's DateTime(long) constructor or just the built-in Date(long) constructor", "label": {"api": {"Date(long)": [[184, 193]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/text/Collator.html for more information", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/Collator.html": [[4, 68]]}}}, {"text": "Here's the Java docs for the DriverManager class that I'm using", "label": {"api": {"Here's the Java docs for the DriverManager class": [[0, 47]]}}}, {"text": "The problem is simply that HashMaps are not thread safe as you can read in the linked docs", "label": {"api": {"HashMaps": [[27, 34]]}}}, {"text": "You should try changing them to ConcurrentHashMaps", "label": {"api": {"HashMaps": [[42, 49]], "ConcurrentHashMaps": [[32, 49]]}}}, {"text": "Instead of declaring your variables as HashMaps you should just declare them as Maps", "label": {"api": {"HashMaps": [[39, 46]]}}}, {"text": "Just use Collections.sort(), I have an short implement for you, this is sort by ascending price, you can change compareTo() for another way to sort list", "label": {"api": {"Collections.sort()": [[9, 26]]}}}, {"text": "had look this link  [http://docs.oracle.com/javase/7/docs/api/java/lang/NoSuchMethodError.html][1] , I even do not know the error occur", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/NoSuchMethodError.html][1]": [[21, 97]]}}}, {"text": "System.in is of type BufferedInputStream", "label": {"api": {"BufferedInputStream": [[21, 39]]}}}, {"text": "As for the way to do it in Java, read the Java Mail API Tutorial and study the javax.mail JavaDoc (and sub-packages)", "label": {"api": {"javax.mail JavaDoc": [[79, 96]]}}}, {"text": "You can invoke scalac with ProcessBuilder", "label": {"api": {"ProcessBuilder": [[27, 40]]}}}, {"text": "See JAXBResult Javadoc", "label": {"api": {"JAXBResult Javadoc": [[4, 21]]}}}, {"text": "Arrays.sort doesn't use the classical textbook version of merge sort, but rather a far more sophisticated version based on TimSort as you can read here", "label": {"api": {"as you can read here": [[131, 150]]}}}, {"text": "A robust way to perform massively parallel writes using Java would be to use the ExecutorService class", "label": {"api": {"ExecutorService": [[81, 95]]}}}, {"text": "As you say, it is the nature of CopyOnWriteArraySet to behave this way", "label": {"api": {"CopyOnWriteArraySet": [[32, 50]]}}}, {"text": "By returning you a CopyOnWriteArraySet ActiveMQ is giving you a data structure that is safe to use in your thread (no change of ConcurrentModificationException) and one that will remain up-to-date", "label": {"api": {"CopyOnWriteArraySet": [[19, 37]]}}}, {"text": "The built-in API you are trying to use only handles its clear-text payload, PrivateKeyInfo (as described in its documentation)", "label": {"api": {"its documentation": [[108, 124]]}}}, {"text": "In order to call this from Java, you will have to create a Process (Look at ProcessBuilder) to open a terminal and execute a \"mvn clean install\"", "label": {"api": {"ProcessBuilder": [[76, 89]]}}}, {"text": "The first call to split is the two-arg overload of split, with a limit", "label": {"api": {"two-arg overload of split": [[31, 55]]}}}, {"text": "The second call to split is the one-arg overload of split", "label": {"api": {"one-arg overload of split": [[32, 56]]}}}, {"text": "Use a Map", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "Maps are useful when it's more convenient to access things using arbitrary objects rather than simple integers as keys", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "Once you have that, you can simply call shutdown() and then awaitTermination() on that executor service instance (probably from within some @PreDestroy method)", "label": {"api": {"shutdown()": [[40, 49]], "awaitTermination()": [[60, 77]]}}}, {"text": "Use Scanner nextDouble to read double input instead of an int", "label": {"api": {"nextDouble": [[12, 21]]}}}, {"text": "One option would be to use a BlockingQueue", "label": {"api": {"BlockingQueue": [[29, 41]]}}}, {"text": "Your cleanup thread could poll for an event, with a timeout, with the method BlockingQueue.poll( long timeout, TimeUnit unit )", "label": {"api": {"BlockingQueue": [[77, 89]], "BlockingQueue.poll( long timeout, TimeUnit unit )": [[77, 125]]}}}, {"text": "Found MXBeans, but I have to write some code to retrieve the numbers", "label": {"api": {"MXBeans": [[6, 12]]}}}, {"text": "I ended up implementing my own profiler using ThreadMXBean right inside the class", "label": {"api": {"ThreadMXBean": [[46, 57]]}}}, {"text": "(See \"zero-width positive lookbehind\" in Class Pattern) The length of ELEMENT_NAME is limited between 1 to 100 in this code", "label": {"api": {"Class Pattern": [[41, 53]]}}}, {"text": "However, you can use the static method Arrays.hashCode(yourArray)", "label": {"api": {"Arrays.hashCode(yourArray)": [[39, 64]]}}}, {"text": "The documentation for this says that the return value is equal to Arrays.asList(yourArray).hashCode(), and all lists are guaranteed to use the same hash algorithm", "label": {"api": {"all lists are guaranteed to use the same hash algorithm": [[107, 161]]}}}, {"text": "Note that Arrays.hashCode() is not the same as calling hashCode() on an array directly", "label": {"api": {"Arrays.hashCode()": [[10, 26]]}}}, {"text": "Sounds like a Map", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "Specifically, if the order of the names is important, you can use a TreeMap", "label": {"api": {"Map": [[72, 74]], "TreeMap": [[68, 74]]}}}, {"text": "If the order is not important, as noted in later edits to the OP, a HashMap would do just fine", "label": {"api": {"Map": [[72, 74]], "HashMap": [[68, 74]]}}}, {"text": "For these kind of requirements, I would advice you to use Infinite ProgressIndicator", "label": {"api": {"Infinite ProgressIndicator": [[58, 83]]}}}, {"text": "I find it hard to see a use case in which the task blocks but you somehow know how long it would take (at least one that wouldn't be easier implemented with the animation API)", "label": {"api": {"animation API": [[161, 173]]}}}, {"text": "the AnimationTimer class is designed exactly for this", "label": {"api": {"AnimationTimer class": [[4, 23]]}}}, {"text": "You could use BufferedReader.readLine() to read a large file line by line", "label": {"api": {"BufferedReader.readLine()": [[14, 38]]}}}, {"text": "Use SimpleDateFormat and Period of Joda-Time library, example below", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "I advise you to read an official documentation and some guides about ExecutorService", "label": {"api": {"official documentation": [[24, 45]]}}}, {"text": "Your best bet is to just map on /* and compare the HttpServletRequest#getRequestURI() against the set of allowed paths", "label": {"api": {"HttpServletRequest#getRequestURI()": [[51, 84]]}}}, {"text": "Don't create a class called 'System', I see that you have a \"System.java\"", "label": {"api": {"System": [[29, 34], [61, 66]]}}}, {"text": "System is a built-in Java class", "label": {"api": {"System": [[0, 5]]}}}, {"text": "System.in is a generic InputStream, whose read method returns the next byte, without assuming anything about the type of input", "label": {"api": {"System.in": [[0, 8]], "read method": [[42, 52]]}}}, {"text": "And as you can see by this docs https://docs.oracle.com/javaee/6/api/javax/servlet/annotation/WebServlet.html the value is just the case when urlPatterns is one string instead of an array of them", "label": {"api": {"https://docs.oracle.com/javaee/6/api/javax/servlet/annotation/WebServlet.html": [[32, 108]]}}}, {"text": "However, since you're using BigDecimal, these comparators (<, <=, etc.) won't work, so you'll have to make use of compareTo", "label": {"api": {"compareTo": [[114, 122]]}}}, {"text": "you need to use equals instead of ==", "label": {"api": {"equals": [[16, 21]]}}}, {"text": "This is because == just checks whether the backwards and word variables point to the same object, whereas equals checks whether the objects pointed to by the two variables have the same contents", "label": {"api": {"equals": [[106, 111]]}}}, {"text": "How about using Paths", "label": {"api": {"Paths": [[16, 20]]}}}, {"text": "The File class has been replaced with Path", "label": {"api": {"Path": [[38, 41]]}}}, {"text": "You can obtain a Path instance with Paths.get or File.toPath", "label": {"api": {"Path": [[17, 20], [36, 39], [56, 59]], "Paths.get": [[36, 44]], "File.toPath": [[49, 59]]}}}, {"text": "Once you have a Path, most operations on it are performed with the Files class", "label": {"api": {"Path": [[16, 19]], "Files": [[67, 71]]}}}, {"text": "In particular, you probably want either Files.exists or Files.isDirectory", "label": {"api": {"Files": [[40, 44], [56, 60]], "Files.exists": [[40, 51]], "Files.isDirectory": [[56, 72]]}}}, {"text": "You may also want to consider deleting that directory yourself, using Files.walkFileTree, so if it fails, you'll get a useful and informative exception", "label": {"api": {"Files": [[70, 74]], "Files.walkFileTree": [[70, 87]]}}}, {"text": "The documentation tells you, what's going on if the load factor get's too high", "label": {"api": {"documentation tells you": [[4, 26]]}}}, {"text": "use DocumentFilter to add validation", "label": {"api": {"DocumentFilter": [[4, 17]]}}}, {"text": "You should take a look at the String.split() method", "label": {"api": {"String.split()": [[30, 43]]}}}, {"text": "It's not new in Java 8, but you can use Collections.nCopies to create a List that you can pass to String.join", "label": {"api": {"Collections.nCopies": [[40, 58]]}}}, {"text": "no Java Object compares equal to null - Java classes need to satisfy this requirement", "label": {"api": {"requirement": [[74, 84]]}}}, {"text": "The java.lang.NoSuchMethod error suggests that the expected method is not found in the dependent class", "label": {"api": {"java.lang.NoSuchMethod": [[4, 25]]}}}, {"text": "Make sure that \"dates\" are of type java.util.Date returned from something like jodatime to be valid for serialization as well", "label": {"api": {"java.util.Date": [[35, 48]]}}}, {"text": "You can use the predefined character class \\W in order to catch a non-word character", "label": {"api": {"character class": [[27, 41]]}}}, {"text": "Providing a timeout during your connection from App Engine will allow your application to wait for the SQL instance to start", "label": {"api": {"timeout": [[12, 18]]}}}, {"text": "The exceptionally method states", "label": {"api": {"exceptionally": [[4, 16]]}}}, {"text": "Returns a new CompletableFuture that is completed when this CompletableFuture completes, with the result of the given function of the exception triggering this CompletableFuture's completion when it completes exceptionally; otherwise, if this CompletableFuture completes normally, then the returned CompletableFuture also completes normally with the same value", "label": {"api": {"exceptionally": [[209, 221]]}}}, {"text": "This is not, IMHO written in the clearest english but I would say that means that if an exception is thrown then only the exceptionally action will be triggered", "label": {"api": {"exceptionally": [[122, 134]]}}}, {"text": "You can use request.getParameter(String param) method to get your parameters values from your POST request", "label": {"api": {"request.getParameter(String param)": [[12, 45]]}}}, {"text": "For what you're doing here you'd be better off with an AtomicLong", "label": {"api": {"AtomicLong": [[55, 64]]}}}, {"text": "Even though the question was about the use of the ternary operator, I must say that personally, I'd just use java.util.Math.ceil(double)", "label": {"api": {"java.util.Math.ceil(double)": [[109, 135]]}}}, {"text": "Math.round(double) is documented as", "label": {"api": {"Math.round(double)": [[0, 17]]}}}, {"text": "You can take help from the utility Arrays Java has", "label": {"api": {"Arrays": [[35, 40]]}}}, {"text": "Poke around with URLClassLoader; once you've amended the classpath appropriately, you can get a Class out of findClass and pass it into the JUnitCore methods you've found", "label": {"api": {"URLClassLoader": [[17, 30]]}}}, {"text": "The method DatePicker.getValue returns java.time.LocalDate, the method PreparedStatement.setDate expects a java.sql.Date", "label": {"api": {"DatePicker.getValue": [[11, 29]], "PreparedStatement.setDate": [[71, 95]]}}}, {"text": "To do this you can use the method java.sql.Date.valueOf(LocalDate)", "label": {"api": {"java.sql.Date.valueOf(LocalDate)": [[34, 65]]}}}, {"text": "Method is Double.parseDouble(String) not Double.ParseDouble(String)", "label": {"api": {"Double.parseDouble(String)": [[10, 35]]}}}, {"text": "Lookup the button and invoke setDisable on it", "label": {"api": {"setDisable": [[29, 38]]}}}, {"text": "disable is a property, so you could bind the value to some condition if you wish (rather than explicitly calling setters to disable and re-enable it)", "label": {"api": {"disable": [[0, 6], [124, 130]]}}}, {"text": "Relative to other number types, BigDecimal offers greater control to the programmer over scale and rounding through numerous constructors such as 'BigDecimal(long val, MathContext mc)' and rounding modes (e.g., 'ROUND_UP') [see Java 7 API- http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html]", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html]": [[240, 306]]}}}, {"text": "Here are the details of compareTo", "label": {"api": {"compareTo": [[24, 32]]}}}, {"text": "String#join is available in Java 8", "label": {"api": {"String#join": [[0, 10]]}}}, {"text": "Instead of using AlphaComposite directly, as shown here, try RescaleOp to alter the image's color/alpha bands, as shown in this example", "label": {"api": {"AlphaComposite": [[17, 30]], "RescaleOp": [[61, 69]]}}}, {"text": "All the streaming classes (InputStream, OutputStream and friends), implement the Closable interface (which actually defines the .close() method they all implement), so you can do", "label": {"api": {"Closable": [[81, 88]]}}}, {"text": "The base class for this is javax.annotation.processing.Processor, which is a good place to start looking for help", "label": {"api": {"javax.annotation.processing.Processor": [[27, 63]]}}}, {"text": "Seii should implement Iterable<Integer>, which will allow it to support the enhanced for loop syntax", "label": {"api": {"Iterable<Integer>": [[22, 38]]}}}, {"text": "The easiest way of doing that, IMHO, is just to have an inner Iterator class which implements your logic", "label": {"api": {"Iterator": [[62, 69]]}}}, {"text": "JAXBIntrospector), but your code will still just be a giant switch on element name, which isn't really all that different from a giant switch on instanceof", "label": {"api": {"JAXBIntrospector": [[0, 15]]}}}, {"text": "Use TextAttribute.WEIGHT to specify bold", "label": {"api": {"TextAttribute.WEIGHT": [[4, 23]]}}}, {"text": "Use TextAttribute.SIZE to specify font size", "label": {"api": {"TextAttribute.SIZE": [[4, 21]]}}}, {"text": "Use TextLayout to calculate the preferred size, as shown here", "label": {"api": {"TextLayout": [[4, 13]]}}}, {"text": "I suggest you read the JavaDocs for Semaphor", "label": {"api": {"Semaphor": [[36, 43]]}}}, {"text": "Use the containsKey() method to check if the given key is already in the hashtable", "label": {"api": {"containsKey()": [[8, 20]]}}}, {"text": "For string comparison, either use the equals(Object) or equalsIgnoreCase(String) method", "label": {"api": {"equals(Object)": [[38, 51]], "equalsIgnoreCase(String)": [[56, 79]]}}}, {"text": "If searched on Google and found this http://docs.oracle.com/cd/E17802_01/j2se/javase/technologies/desktop/java3d/forDevelopers/J3D_1_3_API/j3dapi/, but there is only all the stuff of the \"core\" listed and not the \"utils\"", "label": {"api": {"http://docs.oracle.com/cd/E17802_01/j2se/javase/technologies/desktop/java3d/forDevelopers/J3D_1_3_API/j3dapi/": [[37, 145]]}}}, {"text": "Use stage.sizeToScene() to resize the stage to whatever the current preferred size of it's root is", "label": {"api": {"stage.sizeToScene()": [[4, 22]]}}}, {"text": "You can also just call stage.setWidth() or stage.setHeight() if you don't need the automatic sizing behavior of sizeToScene()", "label": {"api": {"stage.setWidth()": [[23, 38]]}}}, {"text": "You can use a Timeline to animate the stage size change if you need to do that", "label": {"api": {"Timeline": [[14, 21]]}}}, {"text": "Is Enum.valueOf() not sufficient", "label": {"api": {"Enum.valueOf()": [[3, 16]]}}}, {"text": "You can use the Class.getResourceAsStream(String name)", "label": {"api": {"getResourceAsStream(String name)": [[22, 53]]}}}, {"text": "Instead of String.replaceAll, you can use replaceAll(String replacement) from Matcher, then you can construct a pattern using Pattern.DOTALL", "label": {"api": {"replaceAll(String replacement)": [[42, 71]], "Matcher": [[78, 84]]}}}, {"text": "Look into Map (http://docs.oracle.com/javase/7/docs/api/java/util/Map.html), which is also known as a dictionary or associative array", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Map.html": [[15, 73]]}}}, {"text": "Rather than trying to coerce this to a date suitable for SimpleDateFormat, consider using a suitable Formatter", "label": {"api": {"Formatter": [[101, 109]]}}}, {"text": "Use ByteArrayInputStream instead of FileInputStream", "label": {"api": {"ByteArrayInputStream": [[4, 23]]}}}, {"text": "Your containing object could have an AtomicReference that holds a CompleteableFuture for the computation of iAmAllowedToDoIt()", "label": {"api": {"AtomicReference": [[37, 51]], "CompleteableFuture": [[66, 83]]}}}, {"text": "Yes, LinkedList is a doubly linked list, as the Javadoc mentions", "label": {"api": {"LinkedList": [[5, 14]]}}}, {"text": "Use javax.tools.ToolProvider.getSystemJavaCompiler() to get the JavaCompiler object, then you may run it suppling the arguments like this", "label": {"api": {"javax.tools.ToolProvider.getSystemJavaCompiler()": [[4, 51]]}}}, {"text": "Upon successful compilation you can load the compiled class using URLClassLoader and launch anything you want from it via reflection", "label": {"api": {"URLClassLoader": [[66, 79]]}}}, {"text": "In Java 9 and later there is a standard API to solve this problem called ProcessHandle.Here's an example", "label": {"api": {"ProcessHandle": [[73, 85]]}}}, {"text": "Usually java.util.concurrent.CopyOnWriteArrayList fits the needs", "label": {"api": {"java.util.concurrent.CopyOnWriteArrayList": [[8, 48]]}}}, {"text": "I'm using Eclipse to develop Java Desktop applications", "label": {"api": {"Desktop": [[34, 40]]}}}, {"text": "The Desktop class has a useful method called browse() which opens an URI in the system's default browser", "label": {"api": {"Desktop": [[4, 10]], "browse()": [[45, 52]]}}}, {"text": "After that, decorate your field using @Column(unique=true), that will indicate to Hibernate that this field has a unique key", "label": {"api": {"@Column(unique=true)": [[38, 57]]}}}, {"text": "To chunk a line into individual words, you can use String.split", "label": {"api": {"String.split": [[51, 62]]}}}, {"text": "String.indexOf aswell provides an overload that allows searching from a specific point (link to the API)", "label": {"api": {"API": [[100, 102]]}}}, {"text": "From a TreeSet (a SortedSet) in Java 8", "label": {"api": {"TreeSet": [[7, 13]], "SortedSet": [[18, 26]]}}}, {"text": "I call the ::headSet method to get a SortedSet of the objects at the front of the sorted collection", "label": {"api": {"SortedSet": [[37, 45]], "::headSet": [[11, 19]]}}}, {"text": "I call ::removeAll to delete those frontmost objects.BAM, throws a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[67, 97]]}}}, {"text": "Yet if I make another SortedSet from the headSet and pass that derived set to the ::removeAll, no problem", "label": {"api": {"SortedSet": [[22, 30]]}}}, {"text": "You can have a threadlocal webdriver instance instantiated in ITestListener's onStart method, which you can use in your test methods", "label": {"api": {"threadlocal": [[15, 25]]}}}, {"text": "The documentation states that LinkedList is a \"Doubly-linked list implementation of the List and Deque interfaces\"", "label": {"api": {"LinkedList": [[30, 39]]}}}, {"text": "LinkedList implements interface Deque which provides Deque.descendingIterator", "label": {"api": {"Deque": [[32, 36], [53, 57]], "Deque.descendingIterator": [[53, 76]]}}}, {"text": "In the first case it's because the Deque implementation keeps a reference to both the beginning and the end of the queue, in the second because LinkedList is a doubly-linked list, in which every element keeps a reference to both its successor and his predecessor", "label": {"api": {"Deque": [[35, 39]]}}}, {"text": "The cost depends on the specific implementation, but for constructing a HashSet from a collection, the cost of construction is O(n), assuming that hashCode() and equals() are O(1) and assuming that the iteration cost of the source collection is O(n)", "label": {"api": {"HashSet": [[72, 78]]}}}, {"text": "Use List#contains() method to check whether the element is present or not", "label": {"api": {"List#contains()": [[4, 18]]}}}, {"text": "On the opening this dialog I set values to fields, few of which are ChoiceBoxes", "label": {"api": {"ChoiceBox": [[68, 76]]}}}, {"text": "The type of ChoiceBox's field is a custom object, not a string", "label": {"api": {"ChoiceBox": [[12, 20]]}}}, {"text": "The code that creates the ChoiceBox follows", "label": {"api": {"ChoiceBox": [[26, 34]]}}}, {"text": "trade_point is a ChoiceBox", "label": {"api": {"ChoiceBox": [[17, 25]]}}}, {"text": "In java 11 there is a new method Predicate::not", "label": {"api": {"Predicate::not": [[33, 46]]}}}, {"text": "See the documents for PropertyValueFactory; this is going to look at your row data (a String[]) and try to find a method of the form C1 \\tProperty(), which of course doesn't exist", "label": {"api": {"PropertyValueFactory": [[22, 41]]}}}, {"text": "The patterm SSS stands for Millisecond - which means that your input needs to have 3 decimal places after the second - see here", "label": {"api": {"see here": [[119, 126]]}}}, {"text": "In your method speak, the concat method returns a new String, the original object it was called on is unchanged (strings are immutable)", "label": {"api": {"concat": [[26, 31]]}}}, {"text": "Otherwise, a String object is returned that represents a character sequence that is the concatenation of the character sequence represented by this String object and the character sequence represented by the argument string", "label": {"api": {"concat": [[88, 93]]}}}, {"text": "Calling name.concat(\"4\") is the equivalent of name + \"4\"", "label": {"api": {"concat": [[13, 18]]}}}, {"text": "In your test method the append method modifies the content of the StringBuilder", "label": {"api": {"append": [[24, 29]]}}}, {"text": "The principal operations on a StringBuilder are the append and insert methods, which are overloaded so as to accept data of any type", "label": {"api": {"append": [[52, 57]]}}}, {"text": "Each effectively converts a given datum to a string and then appends or inserts the characters of that string to the string builder", "label": {"api": {"append": [[61, 66]]}}}, {"text": "The append method always adds these characters at the end of the builder; the insert method adds the characters at a specified point", "label": {"api": {"append": [[4, 9]]}}}, {"text": "You might want to use the LocalDateTime API (added in Java 8)", "label": {"api": {"LocalDateTime API": [[26, 42]]}}}, {"text": "My final solution was to introduce a Blocking Queue in the @Service and add all incoming requests to it", "label": {"api": {"Blocking Queue": [[37, 50]]}}}, {"text": "A seperate thread is then taking an element from the queue as soon as one was added and processing it", "label": {"api": {"taking": [[26, 31]]}}}, {"text": "I think this is the cleanest solution, as adding an ReentrantLock would block the request processing", "label": {"api": {"ReentrantLock": [[52, 64]]}}}, {"text": "In particular see the divide method", "label": {"api": {"divide": [[22, 27]]}}}, {"text": "JSoup uses the java.net.HttpURLConnection class to create web connections", "label": {"api": {"java.net.HttpURLConnection": [[15, 40]]}}}, {"text": "That class uses system properties to configure proxy connections", "label": {"api": {"system properties to configure proxy connections": [[16, 63]]}}}, {"text": "It'd be a little cleaner to use .resolveSibling(), e.g", "label": {"api": {".resolveSibling()": [[32, 48]]}}}, {"text": "The function getTime() returns a Date object, and Date objects, when when converted to a string, are represented using your default time zone", "label": {"api": {"Date object": [[33, 43], [50, 60]]}}}, {"text": "So by using getTime() you're getting a Date object that no longer contains the timezone data (a Date is just a specific point in time)", "label": {"api": {"Date object": [[39, 49]]}}}, {"text": "Then that Date object gets implicitly converted to a string when it's printed", "label": {"api": {"Date object": [[10, 20]]}}}, {"text": "Take a look at the BigDecimal class", "label": {"api": {"BigDecimal": [[19, 28]]}}}, {"text": "The BigDecimal class gives its user complete control over rounding behavior", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "Instead, use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[13, 28]]}}}, {"text": "Using List#toArray(T[] arr), this is straightforward", "label": {"api": {"List#toArray(T[] arr)": [[6, 26]]}}}, {"text": "Use WeakReference to hold your object instead", "label": {"api": {"WeakReference": [[4, 16]]}}}, {"text": "Sounds like you need to setup a KeyListener", "label": {"api": {"KeyListener": [[32, 42]]}}}, {"text": "However, the alphabet used by the java.util.Base64 class is [A-Za-z0-9+/] (compliant with RFC 4648, as mentioned on the JavaDoc page for the Base64 class)", "label": {"api": {"JavaDoc page for the Base64 class": [[120, 152]]}}}, {"text": "You can use retainAll()", "label": {"api": {"retainAll()": [[12, 22]]}}}, {"text": "I used the java.util.concurrent.atomic package", "label": {"api": {"java.util.concurrent.atomic": [[11, 37]]}}}, {"text": "via org.w3c.dom classes)", "label": {"api": {"org.w3c.dom": [[4, 14]]}}}, {"text": "Write output DOM to file (combination of java.io and org.w3c.dom)", "label": {"api": {"org.w3c.dom": [[53, 63]], "java.io": [[41, 47]]}}}, {"text": "a separate SchedledExecutorService or a Timer)", "label": {"api": {"SchedledExecutorService": [[11, 33]]}}}, {"text": "SwingFXUtils.fromFXImage() returns a BufferedImage which can be easily converted to a Base64-String using BASE64.Encoder introduced in Java 8", "label": {"api": {"BASE64.Encoder": [[106, 119]]}}}, {"text": "I tried using Inet6Address but I ended up with an IPv4 address", "label": {"api": {"Inet6Address": [[14, 25]]}}}, {"text": "Examples in the standard library include Files, Collections, and Executors", "label": {"api": {"Files": [[41, 45]], "Collections": [[48, 58]], "Executors": [[65, 73]]}}}, {"text": "void is not a real value that can be passed around", "label": {"api": {"void is not a real value that can be passed around": [[0, 49]]}}}, {"text": "As other people suggested I'd go with a LinkedBlockingQueue, with the producers that are the threads querying the sensors and storing the data within the queue, and the consumer the thread who sends the records to database", "label": {"api": {"LinkedBlockingQueue": [[40, 58]]}}}, {"text": "If you're using java 7 or 8, you could check for nulls with Objects.requireNonNull() method", "label": {"api": {"Objects.requireNonNull()": [[60, 83]]}}}, {"text": "If it's not valid for a material or an elastic modulus to be null, then throw NullPointerException by using Objects.requireNonNull()", "label": {"api": {"Objects.requireNonNull()": [[108, 131]]}}}, {"text": "Use Java 8 Optional (no filter needed)", "label": {"api": {"Optional": [[11, 18]]}}}, {"text": "As discussed here, many event sources maintain an EventListenerList", "label": {"api": {"EventListenerList": [[50, 66]]}}}, {"text": "What you probably want to do is get the message of the exception instead via ex.getMessage()", "label": {"api": {"ex.getMessage()": [[77, 91]]}}}, {"text": "You can use the getStackTrace() method to get an array of StackTraceElements, and generate a String from there", "label": {"api": {"getStackTrace()": [[16, 30]]}}}, {"text": "In Oracle Javadocs for Java 8 it is specified that InterfaceType has a method named invokeMethod", "label": {"api": {"InterfaceType": [[51, 63]]}}}, {"text": "However, you call test() in the body of a lambda expression as the parameter to the Thread constructor that takes a Runnable, whose run() method is not declared to throw any checked exceptions", "label": {"api": {"the Thread constructor that takes a Runnable": [[80, 123]], "run() method is not declared to throw any checked exceptions": [[132, 191]]}}}, {"text": "Incidentally, it may be confusing to name your own interface Predicate, because of the built-in functional interface java.util.function.Predicate whose functional method returns a boolean", "label": {"api": {"built-in functional interface java.util.function.Predicate": [[87, 144]]}}}, {"text": "To solve this, you must use something that supports larger numbers, like BigInteger or BigDecimal", "label": {"api": {"BigInteger": [[73, 82]], "BigDecimal": [[87, 96]]}}}, {"text": "Using the Lookup to resolve and call the System.load() method should preserve NeedsJni as the caller", "label": {"api": {"should preserve NeedsJni as the caller": [[62, 99]]}}}, {"text": "That means we can simplify the signature (which is pretty similar to Stream.reduce)", "label": {"api": {"Stream.reduce": [[69, 81]]}}}, {"text": "Also, the type BiFunction<A, A, A>, is already present in Java 8 under the name BinaryOperator<A>", "label": {"api": {"BinaryOperator<A>": [[80, 96]]}}}, {"text": "The built-in formats are BMP, GIF, JPEG, PNG and WBMP", "label": {"api": {"built-in formats": [[4, 19]]}}}, {"text": "According to the documentation of BufferedReader#readLine, a null is returned if the end of stream has been reached", "label": {"api": {"BufferedReader#readLine": [[34, 56]]}}}, {"text": "Have a look at ReadWriteLocks, which is the optimal solution for files when you have multiple threads reading at the same time", "label": {"api": {"ReadWriteLock": [[15, 27]]}}}, {"text": "From the Task docs", "label": {"api": {"Task docs": [[9, 17]]}}}, {"text": "Use a CustomMenuItem and set its content property to display the VBox with all its content", "label": {"api": {"CustomMenuItem": [[6, 19]]}}}, {"text": "LinkedList implement queue, collection, and list", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "You could poll for the head, or get a sublist for the first 15 elements, and then also removeRange to remove them", "label": {"api": {"poll": [[10, 13]], "sublist": [[38, 44]], "removeRange": [[87, 97]]}}}, {"text": "I'd probably just poll 15 times as the sublist/removeRange are going to need to iterate over the elements somehow anyway, therefore the perfromance will be similar", "label": {"api": {"poll": [[18, 21]], "sublist": [[39, 45]], "removeRange": [[47, 57]]}}}, {"text": "The Regular Expression API offers the required logic, which you can use to replace an arbitrary number of variables in a string efficiently, see appendReplacement and appendTail", "label": {"api": {"Regular Expression API": [[4, 25]], "appendReplacement": [[145, 161]], "appendTail": [[167, 176]]}}}, {"text": "Note that appendReplacement assigns a special meaning to $ and \\ characters if they occur in the replacement string", "label": {"api": {"appendReplacement": [[10, 26]]}}}, {"text": "If you suspect them to appear in a replacement string but want to insert the string literally, quoteReplacement can be used, i.e", "label": {"api": {"quoteReplacement": [[95, 110]]}}}, {"text": "m.appendReplacement(sb, Matcher.quoteReplacement( replacement));", "label": {"api": {"appendReplacement": [[2, 18]], "quoteReplacement": [[32, 47]]}}}, {"text": "Try using a Matcher with a regex", "label": {"api": {"Matcher": [[12, 18]]}}}, {"text": "The structure is (partly) defined in the EncryptedPrivateKeyInfo documentation, and I assume you can use the constructor to generate it", "label": {"api": {"EncryptedPrivateKeyInfo": [[41, 63]], "the constructor": [[105, 119]]}}}, {"text": "Then you can call ByteArrayOutputStream.toByteArray() to get the bytes, and construct a ByteArrayInputStream wrapping that", "label": {"api": {"ByteArrayOutputStream.toByteArray()": [[18, 52]]}}}, {"text": "The EntityTransaction is used for programmatic transaction management", "label": {"api": {"EntityTransaction": [[4, 20]]}}}, {"text": "Use an enum, and then plug the appropriate enum instances using methods instead of checking state", "label": {"api": {"enum": [[7, 10], [43, 46]]}}}, {"text": "The enum is at the top", "label": {"api": {"enum": [[4, 7]]}}}, {"text": "Notice in the first example that we used the perfectly ordinary Java method, java.lang.String.length()", "label": {"api": {"java.lang.String.length()": [[77, 101]]}}}, {"text": "You could use a StringBuilder instead, which should be faster than using an ArrayList", "label": {"api": {"StringBuilder": [[16, 28]]}}}, {"text": "The toString() method on java.sql.Date prints the date in \"yyyy-mm-dd\" format", "label": {"api": {"toString() method on java.sql.Date": [[4, 37]]}}}, {"text": "I am referencing this JavaDoc https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#split(java.lang.String, int)", "label": {"api": {"https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#split(java.lang.String": [[30, 115]]}}}, {"text": "The easiest way would be to use Runtime.getRuntime.exec()", "label": {"api": {"Runtime.getRuntime.exec()": [[32, 56]]}}}, {"text": "Annotation inheritance only works from classes onto subclasses, but only if the annotation type used in the superclass bears the meta annotation @Inherited", "label": {"api": {"@Inherited": [[145, 154]]}}}, {"text": "You can find simple-but-working shutdown code in the ExecutorService documentation", "label": {"api": {"shutdown code in the ExecutorService documentation": [[32, 81]]}}}, {"text": "I think the best solution is to use jumpTo(Duration duration) right before you stop the Animation", "label": {"api": {"jumpTo(Duration duration)": [[36, 60]]}}}, {"text": "CharSequence is an interface, and so String#contains can accept anything that implements that interface", "label": {"api": {"CharSequence": [[0, 11]]}}}, {"text": "CharSequence defines a method, toString, which converts the character sequence to a String", "label": {"api": {"CharSequence": [[0, 11]]}}}, {"text": "String defines an indexOf method that accepts a String substring and tells you whether it's in the string by returning the index at which it appears in the string", "label": {"api": {"indexOf method": [[18, 31]]}}}, {"text": "So indexOf(s.toString()) > -1 tells you whether the string contains the substring defined by the CharSequence s", "label": {"api": {"CharSequence": [[97, 108]]}}}, {"text": "However, there are List implementations that support this, such as CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[67, 86]]}}}, {"text": "I have a Spark 1.4.0 project where I'm trying to parse several JSON records containing a timestamp field and store it in a ZonedDateTime object, using Jackson and the JSR-310 module", "label": {"api": {"ZonedDateTime": [[123, 135]]}}}, {"text": "I suggest to change your cubeRoot method to accept a Number (the base class of both Integer and Double)", "label": {"api": {"Number": [[53, 58]]}}}, {"text": "First of all, do not name it Object", "label": {"api": {"Object": [[29, 34]]}}}, {"text": "Object is Java's implicit base class for all other classes", "label": {"api": {"Object": [[0, 5]]}}}, {"text": "Technically, you could name your interface Object as long as you do not place it in the package java.lang, but that would be highly misleading", "label": {"api": {"Object": [[43, 48]]}}}, {"text": "To provide different return types for getId() in ObjectA and ObjectB, use generics", "label": {"api": {"Object": [[49, 54], [61, 66]]}}}, {"text": "If getId() always returns a number, you could also define MyObject as MyObject<T extends Number>", "label": {"api": {"Object": [[60, 65], [72, 77]]}}}, {"text": "The contract for the InputStream.read method describes this in detail", "label": {"api": {"contract for the InputStream.read method": [[4, 43]]}}}, {"text": "Be aware that both approaches assume the InputStream's bytes represent characters using your computer's default charset", "label": {"api": {"charset": [[112, 118]]}}}, {"text": "If the characters were sent from a source which encoded them with a different charset, expect the characters to be corrupted in your String", "label": {"api": {"charset": [[78, 84]]}}}, {"text": "So when you are accessing arry2[6]; It will give you the java.lang.ArrayIndexOutOfBoundsException", "label": {"api": {"java.lang.ArrayIndexOutOfBoundsException": [[57, 96]]}}}, {"text": "Assuming you call toString() on the StringBuilder afterwards, I think you're just looking for Collectors.joining(), after mapping each string to a single-character substring", "label": {"api": {"Collectors.joining()": [[94, 113]]}}}, {"text": "If you look at TableModel, you'll notice the method setValueAt(...)", "label": {"api": {"setValueAt": [[52, 61]]}}}, {"text": "The JFileChooser docs", "label": {"api": {"The JFileChooser docs": [[0, 20]]}}}, {"text": "The volatile keyword does not only guarantee non-stale reads and atomic access (preventing word-tearing, especially on 32bit platforms) but also provides ordering guarantees, establishing a happens-before relationship", "label": {"api": {"happens-before": [[190, 203]]}}}, {"text": "String#replaceAll takes a regular expression as the first argument - try using replace", "label": {"api": {"String#replaceAll": [[0, 16]], "replace": [[7, 13], [79, 85]]}}}, {"text": "And then, call the Arrays.binarySearch() method, which returns the index of the value that is immediately greater than the given value", "label": {"api": {"Arrays.binarySearch()": [[19, 39]]}}}, {"text": "From the documentation of TreeMap", "label": {"api": {"TreeMap": [[26, 32]]}}}, {"text": "Number exists since JDK 1.0, Generics were only introduced in Java 1.5", "label": {"api": {"Number": [[0, 5]]}}}, {"text": "You can use Thread.sleep(1000) here", "label": {"api": {"Thread.sleep(1000)": [[12, 29]]}}}, {"text": "The most efficient way of dealing with stream encryption would be to use JCE's CipherOutputStream and CipherInputStream (http://docs.oracle.com/javase/7/docs/api/javax/crypto/CipherInputStream.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/crypto/CipherInputStream.html": [[121, 196]]}}}, {"text": "If you have a problem with large amounts of Strings (you'll read approx 2.5 million entries according to your estimates, so you probably will), read up on String interning and set -XX:StringTableSize=N accordingly", "label": {"api": {"read up on String interning": [[144, 170]]}}}, {"text": "I don't understand why you would like to use a HashMap effectively as an array, but if you really want to do that, make sure you initialize it with approximately the right initialCapacity and loadFactor", "label": {"api": {"initialCapacity and loadFactor": [[172, 201]]}}}, {"text": "The error isn't org/bouncycastle/asn1/ASN1OctetString, it's NoClassDefFoundError", "label": {"api": {"NoClassDefFoundError": [[60, 79]]}}}, {"text": "Also check the Java API (Patterns) for more information on how to process strings", "label": {"api": {"Java API (Patterns)": [[15, 33]]}}}, {"text": "The javadoc for Comparable  recommend to implement compareTo in a consistent way with equals()", "label": {"api": {"Comparable ": [[16, 26]]}}}, {"text": "While Tynamo's tapestry-security does not invoke new threads, apparently it's not allowed to invoke Callable.call() in GAE", "label": {"api": {"Callable": [[100, 107]]}}}, {"text": "Callable is just an interface so it's unnecessary for GAE to prohibit an invocation to it but I suspect it was easier for them to do that than try to block executions of various Executor services that may or may not spawn threads", "label": {"api": {"Callable": [[0, 7]]}}}, {"text": "However, SecurityConfiguration does not need to use Callable at all", "label": {"api": {"Callable": [[52, 59]]}}}, {"text": "See https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html for documentation", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html": [[4, 67]]}}}, {"text": "The documentation for .setBorder() mentions this issue", "label": {"api": {".setBorder()": [[22, 33]]}}}, {"text": "This is achieved through Java's proxies and InvocationHandlers", "label": {"api": {"proxies": [[32, 38]], "InvocationHandlers": [[44, 61]]}}}, {"text": "More so considering that, at least in the past, it used to be hard (if not impossible) to put proxies around some of Android's classes such as Views and Contexts", "label": {"api": {"proxies": [[94, 100]]}}}, {"text": "You haven't specified what exactly you need to do with the list, but assuming you're looking for a collection with a predictable order, consider using a LinkedHashSet - it retains the order of insertion while stile allowing operations like add, remove or contains in O(1)", "label": {"api": {"LinkedHashSet": [[153, 165]]}}}, {"text": "That's a job for groupingBycollector", "label": {"api": {"groupingBy": [[17, 26]]}}}, {"text": "However, since the property is a boolean value, it is more efficient algorithm-wise to use a Set and store players with the property, checking the property with Set#contains", "label": {"api": {"Set#contains": [[161, 172]]}}}, {"text": "If it is important for you to get notified as soon as possible when the time elapses, I would simply use a ScheduledExecutorService and submit tasks to it instead of relying on a cache and its removal notifications", "label": {"api": {"ScheduledExecutorService": [[107, 130]]}}}, {"text": "You can do this with a DataHandler", "label": {"api": {"DataHandler": [[23, 33]]}}}, {"text": "DataHandler is even capable of handling input streams, so you might not need the byte array at all", "label": {"api": {"DataHandler": [[0, 10]]}}}, {"text": "The properties object will still be printed empty (that's what the new Properties(Properties defaults) constructor is supposed to do!) but if you use", "label": {"api": {"is supposed to do": [[115, 131]]}}}, {"text": "Don't confuse the containment hierarchy with the class hierarchy", "label": {"api": {"class hierarchy": [[49, 63]]}}}, {"text": "Regarding single responsibility, the JFrame API shows a coherent derivation, despite Swing's history and cross-platform abstraction", "label": {"api": {"API": [[44, 46]]}}}, {"text": "See ConcurrentLinkedQueue javadoc", "label": {"api": {"ConcurrentLinkedQueue javadoc": [[4, 32]]}}}, {"text": "See String.substring doc", "label": {"api": {"String.substring doc": [[4, 23]]}}}, {"text": "Instead of making substrings, you could also use Character.digit; although that returns -1 for invalid input rather than throwing an exception, so to catch errors (and for neatness) it would be better to wrap it into a method", "label": {"api": {"Character.digit": [[49, 63]]}}}, {"text": "You probably should look at the summaries of all the ProcessBuilder methods available to you", "label": {"api": {"ProcessBuilder methods": [[53, 74]]}}}, {"text": "Comparators need to implement the compare method, not a compareTo method", "label": {"api": {"Comparator": [[0, 9]], "compare": [[34, 40], [56, 62]]}}}, {"text": "So, e.g., your FirstNameComparator should look like this", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "Note that since this Comparator is used to compare Person instances, it would be a better practice to use generics syntax and define it as such", "label": {"api": {"Comparator": [[21, 30]], "compare": [[43, 49]]}}}, {"text": "Instead of regex you can use String.lastIndexOf() with String.substring()", "label": {"api": {"String.lastIndexOf()": [[29, 48]], "String.substring()": [[55, 72]]}}}, {"text": "Are the KeyCodes listed on the javadoc for KeyEvent (VK_?) the only KeyCodes that can be returned, or are there more", "label": {"api": {"javadoc for KeyEvent": [[31, 50]]}}}, {"text": "A ScheduledExecutorService could be what you looking for", "label": {"api": {"ScheduledExecutorService": [[2, 25]]}}}, {"text": "You need use addShutdownhook to listen the program exit and you can restart your program in there", "label": {"api": {"addShutdownhook": [[13, 27]]}}}, {"text": "But, if you really had to access private fields or methods, you can do it via java.lang.reflect", "label": {"api": {"java.lang.reflect": [[78, 94]]}}}, {"text": "A better solution, however, would be to use a ReadWriteLock where the load oparations use the ReadLock and the save operation uses the WriteLock", "label": {"api": {"ReadWriteLock": [[46, 58]]}}}, {"text": "Java, differently from other languages like C#, does not keep track of the cause of the IOException, but it uses subclasses to better specify the motivation of the exception, for example FileNotFoundException is a subclass of IOException", "label": {"api": {"FileNotFoundException": [[187, 207]]}}}, {"text": "In fact, even Collectors.toList() makes no guarantee", "label": {"api": {"even Collectors.toList() makes no guarantee": [[9, 51]]}}}, {"text": "If you are using Java7, there is a default implementation for getting MIME types :-  Files.probeContentType(path)", "label": {"api": {"Files.probeContentType(path)": [[85, 112]]}}}, {"text": "Both System.out and System.err are PrintStream objects which may be passed buffered streams that do not automatically flush data to their destinations", "label": {"api": {"PrintStream": [[35, 45]]}}}, {"text": "The docs page from oracle does some good explaining", "label": {"api": {"docs page": [[4, 12]]}}}, {"text": "Instead you can use a List", "label": {"api": {"List": [[22, 25]]}}}, {"text": "Then you can use numList.add(int index, E element); to insert values at specific positions", "label": {"api": {"List": [[20, 23]]}}}, {"text": "Something like a java.util.concurrent.CountDownLatch will help with this", "label": {"api": {"java.util.concurrent.CountDownLatch": [[17, 51]]}}}, {"text": "The Javadoc for AWTEvent says", "label": {"api": {"Javadoc for AWTEvent": [[4, 23]]}}}, {"text": "This value is 1999", "label": {"api": {"This value is 1999": [[0, 17]]}}}, {"text": "For example, the MouseEvent event types use values from 500-507", "label": {"api": {"500-507": [[56, 62]]}}}, {"text": "Finally, I would consider subclassing ComponentEvent over AWTEvent as the source of your event is a Component, not an Object", "label": {"api": {"ComponentEvent": [[38, 51]], "Component": [[38, 46], [100, 108]]}}}, {"text": "Your progress variable can be replaced with a Task, whose observable progressProperty can be bound to your ProgressBar's value", "label": {"api": {"Task": [[46, 49]]}}}, {"text": "If you need floating-point coordinates, the best way would be to use a Shape object with Graphics2D", "label": {"api": {"Shape": [[71, 75]]}}}, {"text": "Unfortunately, Java does not seem to provide a polyline Shape implementation, but you can easily use Path2D", "label": {"api": {"Shape": [[56, 60]], "Path2D": [[101, 106]]}}}, {"text": "See TimeUnit documentation for more info", "label": {"api": {"TimeUnit": [[4, 11]]}}}, {"text": "This has already been written for you, in the JDK's File class", "label": {"api": {"File class": [[52, 61]]}}}, {"text": "Class.cast and Class.isAssignableFrom methods may be used as dynamic counterparts of cast and instanceof operators respectively", "label": {"api": {"Class.cast": [[0, 9]], "Class.isAssignableFrom": [[15, 36]]}}}, {"text": "If you want to check if an integer matches a given regular expression, you can just convert it to a String", "label": {"api": {"convert it to a String": [[84, 105]]}}}, {"text": "Just check the precondition or catch the exception and set the desired response status via HttpServletResponse#setStatus() or HttpServletResponse#sendError(), depending on the nature of the status code (4nn/5nn == error)", "label": {"api": {"HttpServletResponse#setStatus()": [[91, 121]], "HttpServletResponse#sendError()": [[126, 156]]}}}, {"text": "I have 3 FutureTask<T> Objects", "label": {"api": {"FutureTask<T>": [[9, 21]]}}}, {"text": "It seems to serialize results imself and has all appropriate examples", "label": {"api": {"has all appropriate examples": [[41, 68]]}}}, {"text": "To avoid this keep your list sorted and use binarySearch", "label": {"api": {"binarySearch": [[44, 55]]}}}, {"text": "To keep it sorted use binarySearch on each word to work out where to insert it", "label": {"api": {"binarySearch": [[22, 33]]}}}, {"text": "The void type is represented by javax.lang.model.type.NoType", "label": {"api": {"javax.lang.model.type.NoType": [[32, 59]]}}}, {"text": "But even in Java 7, PrimitiveType only includes boolean, byte, short, int, long, char, float, and double", "label": {"api": {"PrimitiveType": [[20, 32]]}}}, {"text": "You should use javax.lang.model.type.NoType according to the docs for both java 7 and java 8", "label": {"api": {"java 7": [[75, 80]], "java 8": [[86, 91]]}}}, {"text": "There's a method tailMap in NavigableMap interface which can help you to do this (map.tailMap(key).iterator()), but this interface is not implemented by LinkedHashMap If TreeMap (possibly with custom comparator) is an appropriate replacement in your case, consider using it", "label": {"api": {"tailMap": [[17, 23], [86, 92]]}}}, {"text": "If you don't want to get duplicates entries use java.util.Set", "label": {"api": {"java.util.Set": [[48, 60]]}}}, {"text": "With Java 8 you could use the groupingBy collector", "label": {"api": {"the groupingBy collector": [[26, 49]]}}}, {"text": "System.in is an InputStream for accessing Standard Input", "label": {"api": {"System.in": [[0, 8]], "InputStream": [[16, 26]]}}}, {"text": "Since all standard input uses System.in, I don't think it's possible to do what you're asking", "label": {"api": {"System.in": [[30, 38]]}}}, {"text": "Use SimpleDateFormat and parse the date from there", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "That being said, if you really need the relative path of a certain file, you can use the relativize(Path) method", "label": {"api": {"relativize(Path)": [[89, 104]]}}}, {"text": "Milliseconds since 1970 is known as \"epoch time\", and Instant has the static method Instant.ofEpochMilli(long) to support creation from a long number of milliseconds", "label": {"api": {"Instant.ofEpochMilli(long)": [[84, 109]]}}}, {"text": "FileTime also has a fromMillis(long) static method for the same purpose", "label": {"api": {"fromMillis(long)": [[20, 35]]}}}, {"text": "I just want to add that the arraylist add method returns a boolean (https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#add-E-)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#add-E-": [[68, 140]]}}}, {"text": "Such an example is the Collections.toArray method", "label": {"api": {"Collections.toArray": [[23, 41]]}}}, {"text": "You should be able do that with Runtime.exec(String command) by using the same type of commands that you would normally use to kill a process using Command Prompt", "label": {"api": {"Runtime.exec(String command)": [[32, 59]]}}}, {"text": "I've tried forcing garbage collection as per here, but it continues to operate successfully", "label": {"api": {"as per here": [[38, 48]]}}}, {"text": "According to http://docs.oracle.com/javase/7/docs/api/index.html?javax/annotation/package-summary.html the classes you expect are not part of JDK 7", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/index.html?javax/annotation/package-summary.html": [[13, 101]]}}}, {"text": "According to the API of Integer.valueOf(),this method is likely to yield significantly better space and time performance by caching frequently requested values", "label": {"api": {"Integer.valueOf()": [[24, 40]]}}}, {"text": "Have a look at the File class, especially the File.listFiles() (lists all the files in a directory) and isDirectory method", "label": {"api": {"File": [[19, 22], [46, 49], [55, 58]]}}}, {"text": "Recursively go into folders by checking File.isDirectory() and use File.getName() to get the name, and an FileReader to read the content", "label": {"api": {"File": [[40, 43], [67, 70], [106, 109]]}}}, {"text": "You need to extract the modulus and the public exponent from the XML and then generate a key using an \"RSA\" KeyFactory instance and a RSAPublicKeySpec", "label": {"api": {"RSAPublicKeySpec": [[134, 149]]}}}, {"text": "So if WrappedPreparedStatementJDK6 inherits the method from JBossWrapper or some other class in the class hierarchy instead of declaring it itself, the lookup will fail", "label": {"api": {"Wrapper": [[65, 71]]}}}, {"text": "Nevertheless, since it’s defined in standard Java API Wrapper interface, there is no need to use Reflection at all", "label": {"api": {"Wrapper": [[54, 60]]}}}, {"text": "If the compile-time type of st is not already PreparedStatement, you can simply invoke ((Wrapper)st).unwrap(PreparedStatement.class)", "label": {"api": {"Wrapper": [[89, 95]]}}}, {"text": "When you invoke UIManager.setLookAndFeel(…) in your application, existing components are not automatically updated as there is no global registry of all existing component", "label": {"api": {"UIManager.setLookAndFeel(…)": [[16, 42]]}}}, {"text": "You may invoke updateUI() on a component to update it to the current look and feel", "label": {"api": {"updateUI()": [[15, 24]]}}}, {"text": "There is also the utility method SwingUtilities.updateComponentTreeUI(…) which will call updateUI() on an entire component tree, recursively", "label": {"api": {"updateUI()": [[89, 98]], "SwingUtilities.updateComponentTreeUI(…)": [[33, 71]]}}}, {"text": "openConnection() will not perform the call to the server", "label": {"api": {"openConnection()": [[0, 15]]}}}, {"text": "To do this, you need the connect() method", "label": {"api": {"connect()": [[25, 33]]}}}, {"text": "It is the javadoc for the Node type", "label": {"api": {"Node": [[26, 29]]}}}, {"text": "As geert3 said in his/her answer getNodeValue() returns the value of the node, which in this case is the value of the element, not the attributes (for example", "label": {"api": {"Node": [[36, 39]]}}}, {"text": "Try calling Node#getAttributes() and then iterating across the NamedNodeMap with NamedNodeMap#item(int) to get the Nodes", "label": {"api": {"Node": [[12, 15], [68, 71], [86, 89], [115, 118]], "Node#getAttributes()": [[12, 31]], "NamedNodeMap": [[63, 74], [81, 92]], "NamedNodeMap#item(int)": [[81, 102]]}}}, {"text": "getNodeName() should be the name of the attribute (e.g., pantone) and getNodeValue() should be the value of the attribute (e.g., 100)", "label": {"api": {"Node": [[3, 6], [73, 76]]}}}, {"text": "Check out the API documentation for the java.no.file.Files class, which has a variety of utility methods for setting attributes, permissions, and performing other actions not found in the java.io.File class", "label": {"api": {"API documentation": [[14, 30]]}}}, {"text": "The paramethers for String.substring method cannot be negative", "label": {"api": {"String.substring": [[20, 35]]}}}, {"text": "It sounds like you could let your TableModel manage a SortedMap, such as TreeMap<Double, …>, which \"provides guaranteed log(n) time cost for the containsKey, get, put and remove operations.\" This related example manages a Map<String, String>", "label": {"api": {"TreeMap<Double, …>": [[73, 90]]}}}, {"text": "ConcurrentModificationException occurs when Collection will be changed while some thread is traversing over it using iterator, which can happen in case of multithreaded as well as single threaded environment", "label": {"api": {"ConcurrentModificationException": [[0, 30]]}}}, {"text": "You could collect the categories into a Set", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "Using s TreeSet has a nice bonus in this case, as it will also sort the categories alphabetically, which is probably appropriate for a GUI that needs to display them", "label": {"api": {"Set": [[12, 14]], "TreeSet": [[8, 14]]}}}, {"text": "Or, if you want to collect it into a TreeSet and get the result sorted off the bat", "label": {"api": {"Set": [[41, 43]], "TreeSet": [[37, 43]]}}}, {"text": "Your number is larger than Integer.MAX_VALUE (2^31 - 1, or 2147483647), so it can't be parsed into an int", "label": {"api": {"Integer.MAX_VALUE": [[27, 43]]}}}, {"text": "You can use a Long.parseLong to convert to a long, or Long.valueOf to get a Long (object instead of primative) in this case, but why are you converting from string in the first place", "label": {"api": {"Long.parseLong": [[14, 27]], "Long.valueOf": [[54, 65]]}}}, {"text": "According to this other answer, you could try FileSystem.getPathMatcher", "label": {"api": {"FileSystem.getPathMatcher": [[46, 70]]}}}, {"text": "You can use Java FilenameFilter to filter files in a directory by any criteria you'd like", "label": {"api": {"FilenameFilter": [[17, 30]]}}}, {"text": "If you want to prevent duplicates, use a Set, if you also want to maintain the order, use a LinkedHashSet", "label": {"api": {"Set": [[41, 43], [102, 104]], "LinkedHashSet": [[92, 104]]}}}, {"text": "Your code can never throw IllegalArgumentException because ArrayList#addAll cannot throw such exception", "label": {"api": {"ArrayList#addAll": [[59, 74]]}}}, {"text": "The documentation for ReeantrantLock.newCondition states", "label": {"api": {"documentation for ReeantrantLock.newCondition": [[4, 48]]}}}, {"text": "This uses the same principle proposed by talex in his answer, except that for what you are looking for, I believe that what you want is to use the Consumer<T> functional interface (or some other similar interface) using a ResultSet as input", "label": {"api": {"Consumer<T>": [[147, 157]]}}}, {"text": "The annoying thing with the Consumer<T> functional interface is that the method signature doesn't allow for any checked exceptions, so the SQLExceptions need to be handled explicitly (in the code above, you can see that I'm forced to wrap the SQLException in a RuntimeException)", "label": {"api": {"Consumer<T>": [[28, 38]]}}}, {"text": "To avoid this annoyance, you could choose not to use the built-in Consumer<T> functional interface, and instead, create your own that does include throws SQLException as part of the method signature", "label": {"api": {"Consumer<T>": [[66, 76]]}}}, {"text": "There seems to be a difference between the Annotation.equals(Object) and  Object.equals(Object) definitions which need to be respected in that case (same applies for hashCode())", "label": {"api": {"Annotation.equals(Object)": [[43, 67]], "Object.equals(Object)": [[74, 94]], "hashCode()": [[166, 175]]}}}, {"text": "What side-effects can occur when using the Object.equals(Object) definition for annotation classes instead", "label": {"api": {"Object.equals(Object)": [[43, 63]]}}}, {"text": "What about the Annotation.hashCode() definition", "label": {"api": {"hashCode()": [[26, 35]], "Annotation.hashCode()": [[15, 35]]}}}, {"text": "Is it really required to implement it that way, especially the \"(...)127 times the hash code of the member-name as computed by String.hashCode()) XOR the hash code(...)\"-part", "label": {"api": {"hashCode()": [[134, 143]]}}}, {"text": "What happens if a hashCode() method is implemented to be consistent to equals() but doesn't match the exact definition of Annotation.hashCode() (e.g", "label": {"api": {"hashCode()": [[18, 27], [133, 142]], "Annotation.hashCode()": [[122, 142]]}}}, {"text": "You can use the Files.delete() method, which throws an IOException, in case something goes wrong, to see what the real problem is", "label": {"api": {"Files.delete()": [[16, 29]]}}}, {"text": "It involves using the HostnameVerifier mechanism of HttpsUrlConnection", "label": {"api": {"HostnameVerifier": [[22, 37]], "HttpsUrlConnection": [[52, 69]]}}}, {"text": "For the rules that return boolean value it is natural to implement Java's Predicate interface", "label": {"api": {"Predicate": [[74, 82]]}}}, {"text": "The Predicate rules can then be combined with logical operators and and or", "label": {"api": {"Predicate": [[4, 12]]}}}, {"text": "According to docs, no operation are cascaded by default", "label": {"api": {"According to docs": [[0, 16]]}}}, {"text": "I would maintain a list, and use a ListIterator for this", "label": {"api": {"ListIterator": [[35, 46]]}}}, {"text": "You need to provide a Locale if your default locale has different names for month, weekdays and so on", "label": {"api": {"Locale": [[22, 27]]}}}, {"text": "Since you can simply add it to the constructor you can use something like this", "label": {"api": {"constructor": [[35, 45]]}}}, {"text": "you don't need to use four M if you just like to parse the String", "label": {"api": {"parse": [[49, 53]]}}}, {"text": "But you need to add the additional M if you like to format a given Date object to a String", "label": {"api": {"format": [[52, 57]]}}}, {"text": "One approach is to add the WebView to a StackPane, which \"will attempt to resize each child to fill its content area.\" I've given the enclosing JFXPanel to an arbitrary preferred size of 640 x 480; resize the frame to see how the StackPane reflows the WebView content based on the default Pos.CENTER", "label": {"api": {"StackPane": [[40, 48], [230, 238]]}}}, {"text": "A common solution is to use Optional (for pre-Java 8, use Guava's Optional) to represent the absence of a value", "label": {"api": {"Optional": [[28, 35], [66, 73]]}}}, {"text": "So your map would have a type ConcurrentHashMap<Key, Optional<Value>>", "label": {"api": {"Optional": [[53, 60]]}}}, {"text": "You could go through file lines by nextLine (and his has* part), check for emptiness and split the string by your delimiter", "label": {"api": {"nextLine": [[35, 42]], "emptiness": [[75, 83]], "split": [[89, 93]]}}}, {"text": "If you check out interface Iterable it has only one method that is Iterator<T> iterator();", "label": {"api": {"Iterator": [[67, 74]], "Iterable": [[27, 34]]}}}, {"text": "So there is no other possible use case for implementing Iterable interface other than providing iterator method", "label": {"api": {"Iterable": [[56, 63]]}}}, {"text": "If you see the documentation of Iterator interface, in See Also section you will find Collection, ListIterator, Iterable", "label": {"api": {"Iterator": [[32, 39], [102, 109]], "Collection": [[86, 95]], "ListIterator": [[98, 109]], "Iterable": [[112, 119]]}}}, {"text": "Collection and ListIterator are by default Iterable as they internally extend Iterable", "label": {"api": {"Iterator": [[19, 26]], "Collection": [[0, 9]], "ListIterator": [[15, 26]], "Iterable": [[43, 50], [78, 85]]}}}, {"text": "So Iterable is used in conjunction with Iterator", "label": {"api": {"Iterator": [[40, 47]], "Iterable": [[3, 10]]}}}, {"text": "Refer Java API to see the description from language designers", "label": {"api": {"Java API": [[6, 13]]}}}, {"text": "A Set<K> would usually extend AbstractSet<K> and implement", "label": {"api": {"AbstractSet<K>": [[30, 43]]}}}, {"text": "In Java 8, you could use Stream.allMatch to check whether all of the values match a certain condition, such as being null", "label": {"api": {"Stream.allMatch": [[25, 39]]}}}, {"text": "'As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects.', and this applies to System.identityHashcode() as well", "label": {"api": {"'As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects.'": [[0, 132]]}}}, {"text": "Why is there any need of the setChanged() method in its current implementation", "label": {"api": {"setChanged()": [[29, 40]]}}}, {"text": "I understand that it is here so that we only have to call notifyObservers() once, at the end of our treatment", "label": {"api": {"notifyObservers()": [[58, 74]]}}}, {"text": "But still, we could do all the checking in our own implementation, and only call notifyObservers() when we absolutely want to update the Observers", "label": {"api": {"notifyObservers()": [[81, 97]]}}}, {"text": "My guess is that you're using JDK 8 on your machine, but JDK 7 where the error is happening as java.util.Base64 is only available since Java SE 8", "label": {"api": {"java.util.Base64": [[95, 110]]}}}, {"text": "Using Java 8, you can just create a Comparator using the respective column as the key for comparing and then reverse that comparator", "label": {"api": {"create a Comparator": [[27, 45]]}}}, {"text": "BigInteger has many useful methods - including getLowestSetBit()", "label": {"api": {"getLowestSetBit()": [[47, 63]]}}}, {"text": "Thread.dumpStack() prints the current stack to standard error", "label": {"api": {"Thread.dumpStack()": [[0, 17]]}}}, {"text": "Because of certain reasons, I must modify the GraphicsContext transform, not the canvas directly (in other words, to translate, I must use transform.setTx(...) instead of canvas.setTranslateX(...)", "label": {"api": {"GraphicsContext": [[46, 60]]}}}, {"text": "From the isDone documentation", "label": {"api": {"isDone documentation": [[9, 28]]}}}, {"text": "The Properties class would be a good option for that", "label": {"api": {"Properties": [[4, 13]]}}}, {"text": "The Collections.singleton() method returns a Set with that single argument instead of a Collection", "label": {"api": {"Collections.singleton() method": [[4, 33]]}}}, {"text": "And yes, there is also Collections.singletonList() but this is another matter since you can access random elements from a List with .get()..", "label": {"api": {"Collections.singletonList()": [[23, 49]]}}}, {"text": "Check the class's Javadoc", "label": {"api": {"the class's Javadoc": [[6, 24]]}}}, {"text": "I am facing some memory heap issues and in the heap dump I can see that ObjectOutputStream objects are consuming more memory", "label": {"api": {"ObjectOutputStream": [[72, 89]]}}}, {"text": "In my application at some places, I have used ObjectOutputStream but missed to close the stream in some of the methods", "label": {"api": {"ObjectOutputStream": [[46, 63]]}}}, {"text": "Will Java close the stream when the method is finished where ObjectOutputStream is used but stream is not closed ?", "label": {"api": {"ObjectOutputStream": [[61, 78]]}}}, {"text": "Just use the append method instead of setText", "label": {"api": {"append": [[13, 18]]}}}, {"text": "Everything's behaving exactly as I'd expect it to - I would have been really surprised if setText had appended", "label": {"api": {"append": [[102, 107]]}}}, {"text": "If you don't want to use append for some reason, you can call getText and concatenate the text yourself", "label": {"api": {"append": [[25, 30]]}}}, {"text": "but using append is cleaner and may be more efficient", "label": {"api": {"append": [[10, 15]]}}}, {"text": "See the javadoc of DateTimeFormatter for more details", "label": {"api": {"javadoc of DateTimeFormatter": [[8, 35]]}}}, {"text": "You can put the intermediate results in a Blocking Queue so that the results are available to consumer threads as and when they are made available", "label": {"api": {"Blocking Queue": [[42, 55]]}}}, {"text": "The advantage of using a Blocking Queue is that you don't have to reinvent the wheel since this looks like a typical producer-consumer scenario that can be solved using a blocking data structure", "label": {"api": {"Blocking Queue": [[25, 38]]}}}, {"text": "From the documentation of KeyManagerFactory.getDefaultAlgorithm", "label": {"api": {"KeyManagerFactory.getDefaultAlgorithm": [[26, 62]]}}}, {"text": "Reading the Java Doc for printStackTrace will tell why is this designed this way", "label": {"api": {"Java Doc for printStackTrace": [[12, 39]]}}}, {"text": "See the api documentation of Pattern for a starter on the regular expressions", "label": {"api": {"Pattern": [[29, 35]]}}}, {"text": "You can then use this Ordering instance as argument to Collections.sort(List, Comparator), or use methods like Ordering.sortedCopy(Iterable)", "label": {"api": {"Collections.sort(List, Comparator)": [[55, 88]]}}}, {"text": "Note that MyException should not extend third.party.library.ThirdPartyException, because that won't help your problem; it should use the Exception(Throwable cause) constructor and remove it from the org.sikuli.script class hierarchy", "label": {"api": {"Exception(Throwable cause)": [[137, 162]]}}}, {"text": "ResultSet#getDate returns only the date part", "label": {"api": {"ResultSet#getDate": [[0, 16]]}}}, {"text": "If you want to get the full timestamp including hours, minutes, etc, you should user ResultSet#getTimestamp instead", "label": {"api": {"ResultSet#getTimestamp": [[85, 106]]}}}, {"text": "To be relative sure that noone else change the contents (or delete the file) while you read the file, you can use a file-lock in java", "label": {"api": {"file-lock": [[116, 124]]}}}, {"text": "Have the subprocess write to a file (with ProcessBuilder.redirectOutput(File), and then call .readLine() on the file, which will guarantee that you are not late", "label": {"api": {"ProcessBuilder.redirectOutput(File)": [[42, 76]]}}}, {"text": "In Java 8 you can use Collection.removeIf()", "label": {"api": {"Collection.removeIf()": [[22, 42]]}}}, {"text": "The method you are looking for is defined for a Collection, but you are using an array with an array initializer", "label": {"api": {"Collection": [[48, 57]]}}}, {"text": "You could use two SimpleDateFormats - one to parse the string into a Date instance and the other to format it to your desired output", "label": {"api": {"SimpleDateFormat": [[18, 33]]}}}, {"text": "Of course, you could also use a CountDownLatch, but that means you want to trigger an action after exactly N subproblems have been processed (e.g you know your big problem may be split in N smaller problems, check the second example here)", "label": {"api": {"the second example here": [[214, 236]]}}}, {"text": "The entrySet() will return all key-value pairs in the map", "label": {"api": {"entrySet()": [[4, 13]]}}}, {"text": "Graphics.fillRect() accepts a width and height parameter, not the largest x and y position of the rectangle to draw", "label": {"api": {"Graphics.fillRect()": [[0, 18]]}}}, {"text": "The third and fourth parameters to fillRect should be Rectangle2D's getWidth() and getHeight()", "label": {"api": {"getWidth()": [[68, 77]], "getHeight()": [[83, 93]]}}}, {"text": "As a reference, a link to what getMaxX() would give you", "label": {"api": {"link to what getMaxX() would give you": [[18, 54]]}}}, {"text": "A) Call the method through a mutable CallSite and updating it with a new method handle pointing to the same method and then calling syncAll() should trigger recompilation of the calling methods", "label": {"api": {"mutable CallSite": [[29, 44]], "syncAll()": [[132, 140]]}}}, {"text": "A SwitchPoint provides similar functionality", "label": {"api": {"SwitchPoint": [[2, 12]]}}}, {"text": "There's nothing specifically for that in the JDK, but you can use ArrayList#removeIf passing it a predicate that matches everything except the entry you want to keep", "label": {"api": {"ArrayList#removeIf": [[66, 83]]}}}, {"text": "Or of course List#indexOf to get the index of the entry, then remove all other entries (first the ones after it, then the ones before) via removeRange", "label": {"api": {"List#indexOf": [[13, 24]], "removeRange": [[139, 149]]}}}, {"text": "or, equivalenty, with charAt", "label": {"api": {"charAt": [[22, 27]]}}}, {"text": "Since your array is sorted, you can use Arrays.binarySearch which returns index of the element if it is present in the array, otherwise returns -1", "label": {"api": {"Arrays.binarySearch": [[40, 58]]}}}, {"text": "If the underlying model of the RowSorter remains the same, you should be able apply the old TableRowSorter to the new JTable using setRowSorter()", "label": {"api": {"setRowSorter()": [[131, 144]]}}}, {"text": "You can change the gap of the space between the icon and text with setIconTextGap(int)", "label": {"api": {"setIconTextGap(int)": [[67, 85]]}}}, {"text": "In addition, aligning the contents of the JButton towards the left may help with setHorizontalAlignment(SwingConstants.LEFT)", "label": {"api": {"setHorizontalAlignment(SwingConstants.LEFT)": [[81, 123]]}}}, {"text": "System.out.println will still print to standard out, unless you change it with setOut and write some additional code to then put or draw the text in a GUI component somewhere in your Window", "label": {"api": {"setOut": [[79, 84]]}}}, {"text": "Then, if you need to know whether you've gotten a double or not, you can check it using Math.floor", "label": {"api": {"Math.floor": [[88, 97]]}}}, {"text": "Don't mess with catching NumberFormatException, don't search the string for a period (which might not even be correct, for example if the input is 1e-3 it's a double (0.001) but doesn't have a period", "label": {"api": {"NumberFormatException": [[25, 45]]}}}, {"text": "Instead of doing equals, you can do retainAll()", "label": {"api": {"retainAll()": [[36, 46]]}}}, {"text": "You can also use the NIO to copy files via Files#copy(Path, Path)", "label": {"api": {"Files#copy(Path, Path)": [[43, 64]]}}}, {"text": "In case you use the JPA API, you should call the EntityManager.close() method", "label": {"api": {"EntityManager.close()": [[49, 69]]}}}, {"text": "If you are learning how to write multithreaded code then you are encouraged not to work with threads directly but to learn about better abstractions that are provided as part of the Executor framework (the link is to version 8 but the framework has been around since the  Tiger release 1.5)", "label": {"api": {"Executor framework": [[182, 199]]}}}, {"text": "You must use the prepareStatement variant that takes a String[] of returned column names", "label": {"api": {"the prepareStatement variant that takes a String[] of returned column names": [[13, 87]]}}}, {"text": "What you want to do is a Mutable reduction and Collectors.reducing is not appropriate for that", "label": {"api": {"Mutable reduction": [[25, 41]], "Collectors.reducing": [[47, 65]]}}}, {"text": "You may create an appropriate collector using the method Collector.of(…)", "label": {"api": {"Collector.of(…)": [[57, 71]]}}}, {"text": "See Enabled Locales for java.util and java.text Functionality for a list of all supported locales by Oracle's JDK 8 and the JRE 8", "label": {"api": {"Locale": [[12, 17]]}}}, {"text": "That's because the string given as the country code (\"EN\") is not an assigned ISO 3166 alpha-2 country code (see Locale, \"country (region)\")", "label": {"api": {"Locale": [[113, 118]]}}}, {"text": "A list of all 2-letter country codes defined in ISO 3166 can be retrieved with Locale.getISOCountries()", "label": {"api": {"Locale": [[79, 84]]}}}, {"text": "By default a TreeMap guarantees that its elements will be sorted in ascending key order", "label": {"api": {"TreeMap": [[13, 19]]}}}, {"text": "You can use File.listFiles() to get all files in a given directory (including sub-directories)", "label": {"api": {"File.listFiles()": [[12, 27]]}}}, {"text": "So, I came up with using TableCellRenderer for Place and Points columns as Manu suggested by sharing this link", "label": {"api": {"TableCellRenderer": [[25, 41]]}}}, {"text": "Firstly, I created CustomTableCellRenderer and used this method to set values", "label": {"api": {"TableCellRenderer": [[25, 41]]}}}, {"text": "You can use XPath , and other Java XML standard libraries within Android", "label": {"api": {"XPath": [[12, 16]]}}}, {"text": "Remember that one of the key aspects of the equals contract is symmetry", "label": {"api": {"the equals contract": [[40, 58]]}}}, {"text": "From the documentation of PropertyValueFactory", "label": {"api": {"PropertyValueFactory": [[26, 45]]}}}, {"text": "You can see that the ROW_HEADER accessible role is mapped to AXRow", "label": {"api": {"ROW_HEADER accessible role": [[21, 46]]}}}, {"text": "Thus, you could expose AXRow children of the AXTable by using the ROW_HEADER accessible role", "label": {"api": {"ROW_HEADER accessible role": [[66, 91]]}}}, {"text": "As discussed here, and illustrated here, subclasses of TextAction are installed as key bindings by the text component's UI delegate, typically a subclass of BasicTextUI", "label": {"api": {"TextAction": [[55, 64]], "BasicTextUI": [[157, 167]]}}}, {"text": "For example, DefaultEditorKit includes several public actions, as well as a larger number of package-private actions used internally", "label": {"api": {"DefaultEditorKit": [[13, 28]]}}}, {"text": "The handler for the Action named \"cancel\" may be found, among others, in the JTable UI delegate, typically a subclass of BasicTableUI", "label": {"api": {"BasicTableUI": [[121, 132]]}}}, {"text": "Normally when you remove an element from a collection while looping over the collection, you'll get a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[102, 132]]}}}, {"text": "This is partially why the Iterator interface has a remove() method", "label": {"api": {"Iterator": [[26, 33]]}}}, {"text": "You can also use LinkedHashMap (as suggested by Peter Lawrey), but note", "label": {"api": {"LinkedHashMap": [[17, 29]]}}}, {"text": "Iteration over the collection-views of a LinkedHashMap requires time proportional to the size of the map, regardless of its capacity", "label": {"api": {"LinkedHashMap": [[41, 53]]}}}, {"text": "in that order, you would have to use other techniques using classes that are in the concurrent package", "label": {"api": {"concurrent package": [[84, 101]]}}}, {"text": "A very cool one that may work for a countdown (or count up) system like this is the CyclicBarrier, where t-1 and t-2 can each increment a volatile integer, then wait for the CyclicBarrier to let them continue", "label": {"api": {"CyclicBarrier": [[84, 96], [174, 186]]}}}, {"text": "You can now have optional path variables via support for Java 8 Optional", "label": {"api": {"Optional": [[64, 71]]}}}, {"text": "this doesn't work with the optional primitives (OptionalInt, etc.)", "label": {"api": {"Optional": [[48, 55]]}}}, {"text": "I created the HTTP server with a few lines of code, by using sun.net.HttpServer", "label": {"api": {"sun.net.HttpServer": [[61, 78]]}}}, {"text": "SelectionModels are responsible for handling selection events, see ListSelectionModel Example", "label": {"api": {"ListSelectionModel": [[67, 84]]}}}, {"text": "With the Thread object in hand, you can start() it, run() it, get its state, its stack trace, join() it, interrupt() and much more", "label": {"api": {"Thread object": [[9, 21]], "and much more": [[117, 129]]}}}, {"text": "Yes it is possible; this is the .getUserInfo() method from the URI class", "label": {"api": {".getUserInfo() method from the URI class": [[32, 71]]}}}, {"text": "The height can be fixed by calling JList.setVisibleRowCount(int)", "label": {"api": {"JList.setVisibleRowCount(int)": [[35, 63]]}}}, {"text": "To really know if a button was pressed, you can use a filter as noted in the Dialog javadoc section \"Dialog Validation / Intercepting Button Actions\"", "label": {"api": {"Dialog javadoc": [[77, 90]]}}}, {"text": "Get the page element, then use Element.getElementsByTagName (not Document.getElementsByTagName)", "label": {"api": {"Element.getElementsByTagName": [[31, 58]]}}}, {"text": "Use a SimpleDateFormat to parse your original string and then another one to format it into the desired format", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "The Executor can only cancel threads that respond to interruption, see the API documentation for ExecutorService.shutdownNow", "label": {"api": {"the API documentation for ExecutorService.shutdownNow": [[71, 123]]}}}, {"text": "alone in combination with Pattern.DOTALL flag", "label": {"api": {"Pattern.DOTALL": [[26, 39]]}}}, {"text": "You can pass the flag to Pattern.compile(String regex, int flags) method to turn on the flag for the whole expression", "label": {"api": {"Pattern.compile(String regex, int flags)": [[25, 64]]}}}, {"text": "I use AtomicBoolean to ensure there are no multithreading issues by the different events getting fired", "label": {"api": {"AtomicBoolean": [[6, 18]]}}}, {"text": "If you want other rotation centers, AffineTransform provides an overloaded variant of getRotateInstace() which allows you to specify the rotation center (called \"anchor\" in the API documentation)", "label": {"api": {"getRotateInstace()": [[86, 103]]}}}, {"text": "Use nio FileChannel position(long newPosition) method", "label": {"api": {"FileChannel": [[8, 18]]}}}, {"text": "Using FileChannel and ByteBuffer", "label": {"api": {"FileChannel": [[6, 16]], "ByteBuffer": [[22, 31]]}}}, {"text": "Also a WeakReference may seem to weak for this use case, maybe a SoftReference is better", "label": {"api": {"SoftReference": [[65, 77]]}}}, {"text": "You use EventQueue.invokeLater() to tell Java to move the work onto the Swing drawing thread", "label": {"api": {"EventQueue.invokeLater()": [[8, 31]]}}}, {"text": "You can put the messages in a ConcurrentSkipListSet, which is thread-safe and will keep the elements ordered according to their natural order or else according to a comparator (e.g", "label": {"api": {"ConcurrentSkipListSet": [[30, 50]]}}}, {"text": "There's also a ConcurrentSkipListMap that orders according to they keys' natural ordering", "label": {"api": {"ConcurrentSkipListMap": [[15, 35]]}}}, {"text": "It will most likely have scalability requirements and using simple Blocking Queue for async processing will not be a good idea", "label": {"api": {"Blocking Queue": [[67, 80]]}}}, {"text": "JVM based Blocking Queue is in-memory queue and requires producers and consumers to be running in same JVM process", "label": {"api": {"Blocking Queue": [[10, 23]]}}}, {"text": "For sending emails whenver a customer places a new order, you need to ensure that email was really sent and application restarts does not result in loss of data present in Blocking Queue", "label": {"api": {"Blocking Queue": [[172, 185]]}}}, {"text": "The documentation states that readLine() returns null if the end of the stream is reached", "label": {"api": {"documentation states": [[4, 23]]}}}, {"text": ".split() takes regex as a parameter", "label": {"api": {".split()": [[0, 7]]}}}, {"text": "From the documentation of shutdown()", "label": {"api": {"the documentation of shutdown()": [[5, 35]]}}}, {"text": "Once you generate an MD5 key, you can set it in ThreadLocal to reach afterwards", "label": {"api": {"ThreadLocal": [[48, 58]]}}}, {"text": "Alternatively, wrap it in a Proxy", "label": {"api": {"Proxy": [[28, 32]]}}}, {"text": "I think the problem is that lambda functions in Java are really a \"class\" which implements an interface inside the package java.util.function, for example Interface Function (https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html": [[175, 248]]}}}, {"text": "You could use exactly the same code except reverse the order of the Comparator using Collections.reverseOrder(Comparator c)", "label": {"api": {"Collections.reverseOrder(Comparator c)": [[85, 122]]}}}, {"text": "I came up with a solution that doesn't need to have two inner loops by using Collections.sort(List list), which sorts a List in place, and List.containsAll(java.util.Collection), which compares two Lists for their elements", "label": {"api": {"Collections.sort(List list)": [[77, 103]], "List.containsAll(java.util.Collection)": [[139, 176]]}}}, {"text": "You can use an iterator to iterate the List<TopUsers> and check for the List of List<Subscribe> for each one, here's the code you need", "label": {"api": {"iterator": [[15, 22]]}}}, {"text": "Date#getTime() in Java returns the time in milliseconds", "label": {"api": {"Date#getTime()": [[0, 13]]}}}, {"text": "It has a BigInteger(byte[]) constructor and has an effective comparison system", "label": {"api": {"BigInteger(byte[])": [[9, 26]]}}}, {"text": "Check out the documentation for File here", "label": {"api": {"File here": [[32, 40]]}}}, {"text": "Use a java.text.Collator with strength PRIMARY to filter a java.nio.file.DirectoryStream", "label": {"api": {"java.text.Collator": [[6, 23]], "PRIMARY": [[39, 45]], "java.nio.file.DirectoryStream": [[59, 87]]}}}, {"text": "One way would be a regular expression (\"\\d*\"), see the Pattern class", "label": {"api": {"Pattern": [[55, 61]]}}}, {"text": "How about using javafx.scene.text.TextFlow", "label": {"api": {"javafx.scene.text.TextFlow": [[16, 41]]}}}, {"text": "I believe you're want to use a Matcher (and match.group() specifically) to extract the captured group", "label": {"api": {"Matcher": [[31, 37]], "match.group()": [[44, 56]]}}}, {"text": "I've used the old, obsolete java.io.File.listFiles() for too long", "label": {"api": {"java.io.File.listFiles()": [[28, 51]], "File": [[36, 39], [45, 48]]}}}, {"text": "Expensive, since it creates a new File object for each entry", "label": {"api": {"File": [[34, 37]]}}}, {"text": "This functionality can be achieved with a call to the flatMap method on the stream, which takes a Function that maps the Stream item to another Stream on which you can collect", "label": {"api": {"the flatMap method": [[50, 67]]}}}, {"text": "Here, the flatMap method converts the Stream<Collection<Long>> to a Stream<Long>, and collect collects them into a Collection<Long>", "label": {"api": {"the flatMap method": [[6, 23]]}}}, {"text": "You could do this by using collect and providing a supplier (the ArrayList::new part)", "label": {"api": {"collect": [[27, 33]]}}}, {"text": "ConcurrentLinkedQueue is not a List but it is thread safe while accessing  to its elements", "label": {"api": {"ConcurrentLinkedQueue": [[0, 20]]}}}, {"text": "DocumentImpl is a subclass of NodeImpl, whose toString() implementation reads", "label": {"api": {"Node": [[30, 33]]}}}, {"text": "getNodeName() returns #document (which makes sense) - this is defined in CoreDocumentImpl", "label": {"api": {"Node": [[3, 6]]}}}, {"text": "getNodeValue() returns null because it is not overridden", "label": {"api": {"Node": [[3, 6]]}}}, {"text": "This behaviour is even mentioned in the Node documentation", "label": {"api": {"Node": [[40, 43]]}}}, {"text": "Because your root element is not included in either getNodeName() or getNodeValue(), it might look empty", "label": {"api": {"Node": [[55, 58], [72, 75]]}}}, {"text": "The easiest way I can think of from the perspective of a Java developer would be to convert your .Net DateTime to Unix time (see DateTimeOffset.ToUnixTimeMilliseconds) and then use that value for the java.util.Date constructor that accepts that value", "label": {"api": {"constructor": [[215, 225]]}}}, {"text": "I have a JFormattedTextField which I want to accept numbers in the 5 digit range", "label": {"api": {"JFormattedTextField": [[9, 27]]}}}, {"text": "That text from Java EE 5 Javadocs is confusing, and it was improved in recent versions", "label": {"api": {"recent versions": [[71, 85]]}}}, {"text": "Provided you are using Java 8, you can use Collectors#groupingBy", "label": {"api": {"Collectors#groupingBy": [[43, 63]]}}}, {"text": "You could use http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#setIn(java.io.InputStream) to modify System.in and read from a file or a ByteArrayInputStream", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#setIn(java.io.InputStream)": [[14, 102]]}}}, {"text": "In the same way, use http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#setOut(java.io.PrintStream) to redirect the output stream", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#setOut(java.io.PrintStream)": [[21, 110]]}}}, {"text": "TreeSet(SortedSet<E>) constructs a new set \"using the same ordering as the specified sorted set,\" whereas TreeSet(Collection<", "label": {"api": {"TreeSet(SortedSet<E>)": [[0, 20]]}}}, {"text": "Calendar.add can be used to add (or subtract) an arbitrary unit of time", "label": {"api": {"Calendar.add": [[0, 11]]}}}, {"text": "As far as Java's ConcurrentLinkedQueue goes, I've noticed that they utilize AtomicReferenceUpdater and that really seems to be the only way to go", "label": {"api": {"AtomicReferenceUpdater": [[76, 97]]}}}, {"text": "Is AtomicReferenceUpdater the only way for me to move forward, or are there other things I can do", "label": {"api": {"AtomicReferenceUpdater": [[3, 24]]}}}, {"text": "For more informations read the official documentation", "label": {"api": {"official documentation": [[31, 52]]}}}, {"text": "See String.trim() for more information!", "label": {"api": {"String.trim()": [[4, 16]]}}}, {"text": "One approach would be to substitute a WebView and use the loadContent() method of WebEngine", "label": {"api": {"WebView": [[38, 44]], "WebEngine": [[82, 90]]}}}, {"text": "You are probably calling System.out.println to print the list", "label": {"api": {"System.out.println": [[25, 42]]}}}, {"text": "To create an array from a list you can use list.toArray()", "label": {"api": {"list.toArray()": [[43, 56]]}}}, {"text": "Don't use a List, use a java.util.Set instead", "label": {"api": {"java.util.Set": [[24, 36]]}}}, {"text": "If the iteration order is important or if you want to use a custom Comparator, the TreeSet implementation can be used", "label": {"api": {"Comparator": [[67, 76]], "TreeSet": [[83, 89]]}}}, {"text": "The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used", "label": {"api": {"Comparator": [[63, 72]]}}}, {"text": "Example of a Set using a Comparator", "label": {"api": {"Comparator": [[25, 34]]}}}, {"text": "You can check the maximum value with getActualMaximum", "label": {"api": {"getActualMaximum": [[37, 52]]}}}, {"text": "You have to annotate your class with @XmlAccessorType(FIELD) to instruct JAXB to use annotations specified on fields", "label": {"api": {"@XmlAccessorType(FIELD)": [[37, 59]]}}}, {"text": "If you really need to analyze the parameters of the method, you can cast jointPoint.getSignature() to a MethodSignature to access the Method", "label": {"api": {"Method": [[104, 109], [134, 139]]}}}, {"text": "Your PrintWriter has a print(char[] s) method (see doc)", "label": {"api": {"(see doc)": [[46, 54]]}}}, {"text": "A look into the doc tells us we get an OutputStream from our socket", "label": {"api": {"the doc": [[12, 18]]}}}, {"text": "We could wrap that into a BufferedOutputStream, like this", "label": {"api": {"BufferedOutputStream": [[26, 45]]}}}, {"text": "I'm using ThreadLocal in a servlet under the assumption that any reference to the ThreadLocal value won't outlive the request", "label": {"api": {"ThreadLocal": [[10, 20], [82, 92]]}}}, {"text": "One thing I'm unsure of is what happens when the thread goes into a thread pool -- If this happens, can a ThreadLocal value set during a previous request be present in a subsequent request if the same thread is used to service it", "label": {"api": {"ThreadLocal": [[106, 116]]}}}, {"text": "Your Long is initialized to 2^32-1, which wouldn't fit your example number, whereas Long.MAX_VALUE has a value of 2^63-1", "label": {"api": {"Long.MAX_VALUE": [[84, 97]], "Long": [[5, 8], [84, 87]]}}}, {"text": "Also naming a variable Long is a pretty bad idea", "label": {"api": {"Long": [[23, 26]]}}}, {"text": "It shadows the class Long which is a standard part of the JDK, and it violates conventions, which suggest using something like variableName", "label": {"api": {"Long": [[21, 24]]}}}, {"text": "The fact that your ContentHandler.endElement method is being called at all, indicates you must be passing your ContentHandler object to a parse or unmarshal operation", "label": {"api": {"ContentHandler.endElement": [[19, 43]]}}}, {"text": "The Java File object has a built in method called setReadOnly() that could be used in theory, but the issue is that I'm never able to create a File object directly", "label": {"api": {"File": [[9, 12], [143, 146]]}}}, {"text": "Does anybody know how to set a File to be persistently read-only directly through an InputStream or some derived object using core Java, Apache Commons Imaging, or a useful third party library", "label": {"api": {"File": [[31, 34]]}}}, {"text": "I would suggest you use an ArrayList instead", "label": {"api": {"ArrayList": [[27, 35]]}}}, {"text": "That way you will not need a counter, just add to the ArrayList", "label": {"api": {"ArrayList": [[54, 62]]}}}, {"text": "I notice you are having an AbstractMethodError", "label": {"api": {"AbstractMethodError": [[27, 45]]}}}, {"text": "Maybe your runtime is using an older version which does not implement Node#setTextContent(String) (since DOM level 3)", "label": {"api": {"Node#setTextContent(String)": [[70, 96]]}}}, {"text": "Again, it's just as HashMap interface", "label": {"api": {"HashMap": [[20, 26]]}}}, {"text": "If you are using Java 8 or later, you could try this using the java.time package", "label": {"api": {"java.time package": [[63, 79]]}}}, {"text": "Maybe java.io.File.createNewFile() will throw a IOException when there is not enough free space", "label": {"api": {"java.io.File.createNewFile()": [[6, 33]]}}}, {"text": "Call java.util.Date::getTime to extract the count of milliseconds from epoch", "label": {"api": {"java.util.Date::getTime": [[5, 27]]}}}, {"text": "The simplest way to de-duplicate data is to use a Set, because sets only allow each object in them to appear once", "label": {"api": {"Set": [[50, 52]]}}}, {"text": "The Java Tutorial on Creating and Drawing to an Image, along with the ImageIO API reference might be helpful should you require more information", "label": {"api": {"ImageIO API reference": [[70, 90]]}}}, {"text": "Have a look at java.util.Properties", "label": {"api": {"java.util.Properties": [[15, 34]]}}}, {"text": "And even with the version field, you will have to force the version update on the parent if you want to protect collection modifications; see LockModeType.OPTIMISTIC_FORCE_INCREMENT", "label": {"api": {"LockModeType.OPTIMISTIC_FORCE_INCREMENT": [[142, 180]]}}}, {"text": "Then, in your main method, create an array, or better an ArrayList of Students (since you do not know in advance how many Student instances the user will create)", "label": {"api": {"ArrayList": [[57, 65]]}}}, {"text": "After that, add the new Student instance to the ArrayList, by calling", "label": {"api": {"ArrayList": [[48, 56]]}}}, {"text": "The only thing you can do is to pass such element to the isAnnotated method (it's called AnnotatedElement)", "label": {"api": {"AnnotatedElement": [[89, 104]]}}}, {"text": "Use the computeIfAbsent method added in jre 8", "label": {"api": {"computeIfAbsent": [[8, 22]]}}}, {"text": "Use a StringTokenizer (http://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html) to convert user input into a string of byte code and feed the latter one to your MIPS exactly how you propose in your question", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html": [[23, 93]]}}}, {"text": "The Collection interface contract states that a collection may place any restrictions on its elements as long as it is properly documented, so I'm unable to see why a guarded collection would be discouraged", "label": {"api": {"Collection interface contract": [[4, 32]]}}}, {"text": "You should only fill the ByteBuffer using any of the put methods (that do not take an index) such as put(byte[])", "label": {"api": {"put(byte[])": [[101, 111]]}}}, {"text": "You could also solve this without CharBuffer and ByteBuffer using a byte[] buffer and a StringReader wrapped by a ReaderInputStream", "label": {"api": {"StringReader": [[88, 99]]}}}, {"text": "All objects contain a reference to their Class internally that is accessible via Object#getClass()", "label": {"api": {"Object#getClass()": [[81, 97]]}}}, {"text": "It appears as though the data format of the image is not recognized(This is the only time ImageIO returns null)", "label": {"api": {"This is the only time ImageIO returns null": [[68, 109]]}}}, {"text": "You can transform a point in a node's local coordinate system to its parent's coordinate system by calling Node.localToParent(...)", "label": {"api": {"Node.localToParent(...)": [[107, 129]]}}}, {"text": "This SSCCE demonstrates this technique (though you can use a TranslateTransition instead and get the mouse coordinates in exactly the same way)", "label": {"api": {"TranslateTransition": [[61, 79]]}}}, {"text": "Assuming this is java.lang.String, there is no method addActionListener()", "label": {"api": {"java.lang.String": [[17, 32]]}}}, {"text": "How do I detect if a transaction remains open, still pending on a COMMIT or ROLLBACK on a JDBC Connection", "label": {"api": {"Connection": [[95, 104]]}}}, {"text": "I'm getting my Connection objects via a connection pool", "label": {"api": {"Connection": [[15, 24]]}}}, {"text": "The child process might fill up the buffer and cause a deadlock - see Oracle docs regarding Process", "label": {"api": {"Oracle docs regarding Process": [[70, 98]]}}}, {"text": "The Color(int rgb) constructor you are using \"creates an opaque sRGB color ...\"  The Color(int rgba, boolean hasalpha) constructor will create a new Color with transparency", "label": {"api": {"Color(int rgb)": [[4, 17]], "Color(int rgba, boolean hasalpha)": [[85, 117]]}}}, {"text": "if you using the Color(int rgb) constructor in other related code (such as your replace method, you'll probably need to change those as well", "label": {"api": {"Color(int rgb)": [[17, 30]]}}}, {"text": "In code, how do I get a hold of these files using the java.io.File APIs", "label": {"api": {"java.io.File": [[54, 65]]}}}, {"text": "On SO, I found all theoretical difference between Callable and Runnable and all are almost similar", "label": {"api": {"Callable": [[50, 57]]}}}, {"text": "But, I didn't understand why was Callable introduced in later version", "label": {"api": {"Callable": [[33, 40]]}}}, {"text": "What was the gap/flaws in Runnable, which Callable is capable of doing", "label": {"api": {"Callable": [[42, 49]]}}}, {"text": "Anyone can explain with scenario where Callable is only solution", "label": {"api": {"Callable": [[39, 46]]}}}, {"text": "You can use the length() method to count the number of characters in a string (word)", "label": {"api": {"length()": [[16, 23]]}}}, {"text": "I used a Canvas on which to draw, as shown in Working with the Canvas API, and an AnimationTimer for the drawing loop, as shown in Animation Basics", "label": {"api": {"Canvas": [[9, 14], [63, 68]], "AnimationTimer": [[82, 95]]}}}, {"text": "Unfortunately, I'm not sure how to resize the Canvas automatically as the enclosing Stage is resized", "label": {"api": {"Canvas": [[46, 51]]}}}, {"text": "In the example below, the static nested class CanvasPane wraps an instance of Canvas in a Pane and overrides layoutChildren() to make the canvas dimensions match the enclosing Pane", "label": {"api": {"Canvas": [[46, 51], [78, 83]], "Pane": [[52, 55], [90, 93], [176, 179]]}}}, {"text": "Note that Canvas returns false from isResizable(), so \"the parent cannot resize it during layout,\" and Pane \"does not perform layout beyond resizing resizable children to their preferred sizes.\" The width and height used to construct the canvas become its initial size", "label": {"api": {"Canvas": [[10, 15]], "Pane": [[103, 106]], "isResizable()": [[36, 48]]}}}, {"text": "To get the file extensions, you need to use String.split()", "label": {"api": {"String.split()": [[44, 57]]}}}, {"text": "To check to see if the string ends with the extensions, we need to loop through the extensions, and use String.endsWith() to check to see if it ends with the extension", "label": {"api": {"String.endsWith()": [[104, 120]]}}}, {"text": "You can remove it using String.trim(), but the ideal way to do it is to pass an array of strings into the function in the first place", "label": {"api": {"String.trim()": [[24, 36]]}}}, {"text": "Use the Document interface", "label": {"api": {"Document": [[8, 15]]}}}, {"text": "You can get it from JTextArea with getDocument or you can use one of the classes that already implement Document", "label": {"api": {"Document": [[38, 45], [104, 111]]}}}, {"text": "AbstractDocument, DefaultStyledDocument, HTMLDocument, PlainDocument", "label": {"api": {"Document": [[8, 15], [31, 38], [45, 52], [60, 67]]}}}, {"text": "Then add your Document of choice to JTextArea with setDocument", "label": {"api": {"Document": [[14, 21], [54, 61]]}}}, {"text": "You can use insertString(int offset, String str, AttributeSet a) to add content to the Document", "label": {"api": {"Document": [[87, 94]]}}}, {"text": "Integer is a bad name choice - it induces way too much confusion with the built-in java.lang.Integer", "label": {"api": {"java.lang.Integer": [[83, 99]]}}}, {"text": "Look for an IMG tag in the response using a regular expression", "label": {"api": {"regular expression": [[44, 61]]}}}, {"text": "Try using the Robot class", "label": {"api": {"Robot": [[14, 18]]}}}, {"text": "Instead, you should use a PreparedStatement, e.g", "label": {"api": {"PreparedStatement": [[26, 42]]}}}, {"text": "Check the remove(int index) function", "label": {"api": {"remove(int index)": [[10, 26]]}}}, {"text": "If you want to implement your own comparator to lexicographically compare strings (and after that you could order lists of strings), Java has the Collator class", "label": {"api": {"Collator": [[146, 153]]}}}, {"text": "The Collator class performs locale-sensitive String comparison", "label": {"api": {"Collator": [[4, 11]]}}}, {"text": "If that's not enough you could use RuleBasedCollator, it works as Collator but you can personalize it a lot more", "label": {"api": {"Collator": [[44, 51], [66, 73]], "RuleBasedCollator": [[35, 51]]}}}, {"text": "Alternatively, use the connect with an InetSocketAddress", "label": {"api": {"InetSocketAddress": [[39, 55]]}}}, {"text": "If you want to Write out values with in a specific format, the easiest way is not to use DecimalFormat directly, but rather use the format() methods of the PrintStream or Formatter classes", "label": {"api": {"PrintStream": [[156, 166]], "Formatter": [[171, 179]]}}}, {"text": "If you want to pass just the information about this class, then your method would need to take a Class an an argument, for example..", "label": {"api": {"Class": [[97, 101]]}}}, {"text": "It's a simple case of reading a line and using the String.split method", "label": {"api": {"String.split": [[51, 62]]}}}, {"text": "The \"\\\\s+\" represents any whitespace character or characters These can be 'parsed' to int values using the Integer.parseInt method, like this", "label": {"api": {"Integer.parseInt": [[107, 122]]}}}, {"text": "Check Character classes in Java Pattern reference", "label": {"api": {"Java Pattern reference": [[27, 48]]}}}, {"text": "Have each enum be initialized not with its color, but an IntSupplier<Color>", "label": {"api": {"IntSupplier<Color>": [[57, 74]]}}}, {"text": "You need the Java XML digital signature library", "label": {"api": {"XML digital signature library": [[18, 46]]}}}, {"text": "You can batch DML statements using Statement.addBatch(String) (i.e", "label": {"api": {"Statement.addBatch(String)": [[35, 60]]}}}, {"text": "select, insert, update and delete statements) and then call Statement.executeBatch()", "label": {"api": {"Statement.executeBatch()": [[60, 83]]}}}, {"text": "You can Implement the List interface and provide your own implementation for the List.add(int index, E element) method and check if the element is instanceof the parent Class and not an instanceof the child Class in your implementation", "label": {"api": {"List": [[22, 25], [81, 84]], "List.add(int index, E element)": [[81, 110]]}}}, {"text": "You can also extend the ArrayList Class and Override all the methods that add elements to the ArrayList and check if the element is instanceof the parent Class and not an instanceof the child Class in your implementation and call the Super method for process of adding the element(s)", "label": {"api": {"List": [[29, 32], [99, 102]], "ArrayList": [[24, 32], [94, 102]]}}}, {"text": "Simply split on [a-z], with limit 2", "label": {"api": {"split": [[7, 11]]}}}, {"text": "Take a look at the java.util.concurrent package for a complete list", "label": {"api": {"java.util.concurrent": [[19, 38]]}}}, {"text": "But please take a look at the various classes provided in the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[62, 81]]}}}, {"text": "Use event.getSource(), by this can write a common event handler for multiple cicrles without worrying which exact one was clicked", "label": {"api": {"event.getSource()": [[4, 20]]}}}, {"text": "The ImageIcon(String) constructor uses Toolkit.getImage internally, which is a hold-over from the 1990s, when many home Internet connections were so slow that it made sense to always load images in a background thread", "label": {"api": {"Toolkit.getImage": [[39, 54]]}}}, {"text": "To guarantee that an image is fully loaded immediately, you can replace the use of ImageIcon with ImageIO.read", "label": {"api": {"ImageIO.read": [[98, 109]]}}}, {"text": "Draw your image into a new image, and let the drawImage method handle the scaling, using the Graphics2D object's RenderingHints", "label": {"api": {"drawImage": [[46, 54]], "RenderingHints": [[113, 126]]}}}, {"text": "Use an AffineTransformOp on your image to create a new, scaled image", "label": {"api": {"AffineTransformOp": [[7, 23]]}}}, {"text": "You may want to alter the RenderingHints values, based on your own preferred trade-off of speed versus quality", "label": {"api": {"RenderingHints": [[26, 39]]}}}, {"text": "They're all documented in the RenderingHints class", "label": {"api": {"RenderingHints": [[30, 43]]}}}, {"text": "Check the JavaDoc for Java EE 7 or Java EE 6", "label": {"api": {"Java EE 7": [[22, 30]], "Java EE 6": [[35, 43]]}}}, {"text": "So, just specify the @JoinColumn for the @OneToMany mapping", "label": {"api": {"@JoinColumn": [[21, 31]]}}}, {"text": "Regarding your questions (according to java 7 doc)", "label": {"api": {"java 7 doc": [[39, 48]]}}}, {"text": "So, what you need to do is include your own SLF4J implementation in your own pom, such as Log4J or Logback, OR configure it to use the slf4j-jdk14 implementation by using Logger.addHandler", "label": {"api": {"Logger.addHandler": [[171, 187]]}}}, {"text": ".getType() returns a java.lang.reflect.Type which Gson uses to identify which TypeAdapter it's going to use to serialize and deserialize your Object / JSON String", "label": {"api": {"java.lang.reflect.Type": [[21, 42]]}}}, {"text": "Graphics.drawImage returns a boolean, which you are then trying to add to the ArrayList, and that's what's causing your problem", "label": {"api": {"Graphics.drawImage": [[0, 17]]}}}, {"text": "I would just map the identity function", "label": {"api": {"map": [[13, 15]], "identity function": [[21, 37]]}}}, {"text": "In such a case I would use a ExecutorService and create a newFixedThreadPool to limit the number of threads that could be span up simultaneously", "label": {"api": {"ExecutorService": [[29, 43]]}}}, {"text": "It's a lot better to use the Files class, more specifically its delete method", "label": {"api": {"delete": [[64, 69]]}}}, {"text": "As for what exactly is deleted", "label": {"api": {"delete": [[23, 28]]}}}, {"text": "When you delete a file, the usual thing that happens is that the particular link to that file from that directory is removed", "label": {"api": {"delete": [[9, 14]]}}}, {"text": "So your File object tells the system where the file is, but the delete operation ultimately tells the system both to unlink the file from the directory (the penultimate part of the path), and if that's the last link, it also tells the system to go to the file contents and mark it as free", "label": {"api": {"delete": [[64, 69]]}}}, {"text": "AudioInputStream.read() returns -1 when it's out of data, so you can break your loop when that happens", "label": {"api": {"returns -1 when it's out of data": [[24, 55]]}}}, {"text": "Your best bet is probably to implement using BigInteger objects", "label": {"api": {"BigInteger": [[45, 54]]}}}, {"text": "BigInteger has pow and mod functions that you can use for your calculations", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "I'm looking at a listener that extends WindowAdapter and I notice that they're doing the exact same thing in both methods", "label": {"api": {"WindowAdapter": [[39, 51]]}}}, {"text": "The regex pattern, in the replaceAll(), means to match any character that is not a lower/upper case vowel (Regex Pattern Reference) and replace it with and empty string (remove it)", "label": {"api": {"Regex Pattern Reference": [[107, 129]]}}}, {"text": "In Java you can always use Matcher method start(int group) and end(int group), to get indices of part you are interested in", "label": {"api": {"start(int group)": [[42, 57]], "end(int group)": [[63, 76]]}}}, {"text": "The Condition JavaDoc has the following code sample", "label": {"api": {"Condition JavaDoc": [[4, 20]]}}}, {"text": "This could be mitigated using signalAll, but you'll still have a couple issues", "label": {"api": {"signalAll": [[30, 38]]}}}, {"text": "You have to use Task class", "label": {"api": {"Task": [[16, 19]]}}}, {"text": "By using Task class, your time consuming task runs on background thread leaving JavaFX thread responsive", "label": {"api": {"Task": [[9, 12]]}}}, {"text": "You need to include the DispatcherType in your @WebFilter declaration", "label": {"api": {"DispatcherType": [[24, 37]]}}}, {"text": "For Desktop integration", "label": {"api": {"Desktop": [[4, 10]]}}}, {"text": "However, it has a method called getOutputStream and a method getWriter() that give you resp", "label": {"api": {"getOutputStream": [[32, 46]], "getWriter()": [[61, 71]]}}}, {"text": "How to use java.net.Socket setKeepAlive(boolean b) API", "label": {"api": {"java.net.Socket setKeepAlive(boolean b)": [[11, 49]]}}}, {"text": "Look at the javadoc of javax.xml.stream.events.Attributes", "label": {"api": {"javax.xml.stream.events.Attributes": [[23, 56]]}}}, {"text": "Make use of HashMap<K,V> class, This document will provide you with the required API", "label": {"api": {"document": [[37, 44]]}}}, {"text": "You will either have to call its overload read(byte[] b, int off, int len) in a loop until the stream is closed, or wrap the stream into a DataInputStream and use readFully", "label": {"api": {"DataInputStream": [[139, 153]], "readFully": [[163, 171]]}}}, {"text": "The addAll method will perform the loop for you", "label": {"api": {"addAll method": [[4, 16]]}}}, {"text": "I don't know if its the original reason, but the current implementation enqueues Finalizer instances (internal subclass of Reference) for  objects overriding the finalize method with an internal ReferenceQueue that gets polled by a dedicated FinalizerThread", "label": {"api": {"Reference": [[123, 131], [195, 203]], "ReferenceQueue": [[195, 208]]}}}, {"text": "If you want a fixed-offset time zone, just use SimpleTimeZone", "label": {"api": {"SimpleTimeZone": [[47, 60]]}}}, {"text": "I have quickly read over the Java8 String api documentation", "label": {"api": {"String api": [[35, 44]]}}}, {"text": "String.join relies on the class StringJoiner which itself relies on an internal StringBuilder to build the joined string", "label": {"api": {"StringJoiner": [[32, 43]]}}}, {"text": "That is, to build an output like \"a/b/c/d\" or \"(a+b+c+d)\" when you have a,b,c and d in an array or a list, String.join or a StringJoiner would make the operation clear and readable", "label": {"api": {"StringJoiner": [[124, 135]]}}}, {"text": "The best way to do so would be to use a Regular Expression, or Regex, or Pattern", "label": {"api": {"Pattern": [[73, 79]]}}}, {"text": "Assuming these are your classes, use the AutoCloseable interface and put them in a try-with-resource", "label": {"api": {"AutoCloseable": [[41, 53]]}}}, {"text": "Throwable.getCause was not added until Java 1.4", "label": {"api": {"Throwable.getCause": [[0, 17]]}}}, {"text": "Some implementations of EJBException do retrofit the getCausedByException method to use the getCause method (similar to how the RemoteException.getCause method was retrofitted), but it sounds like your application server does not do this", "label": {"api": {"RemoteException.getCause": [[128, 151]]}}}, {"text": "Alternatively to user158037's idea, you can implement your own ThreadPoolExecutor subclass, with afterExecute method overriden", "label": {"api": {"afterExecute method": [[97, 115]]}}}, {"text": "You're likely going to be better off using a HashSet instead of an ArrayList as both add and contains are constant time operations in a HashSet", "label": {"api": {"HashSet": [[45, 51], [136, 142]]}}}, {"text": "The main module will, when a user launches the application, include these other plugins in the final item, so that, for example, a Stage will have buttons from both the main module and plugin modules on the same scene", "label": {"api": {"Stage": [[131, 135]], "scene": [[212, 216]]}}}, {"text": "Probably the most suitable standard datastructure for Sieve of Eratosthenes is the BitSet", "label": {"api": {"BitSet": [[83, 88]]}}}, {"text": "The boolean-based version may work faster for small n values, but if you need, for example, a million of prime numbers, BitSet will outperform it in several times and actually works correctly", "label": {"api": {"BitSet": [[120, 125]]}}}, {"text": "Take a look at javax.management.RuntimeErrorException", "label": {"api": {"javax.management.RuntimeErrorException": [[15, 52]]}}}, {"text": "If you're using Metro, the JAX-WS reference implementation, the documentation says it utilizes the JDK's HttpsURLConnection to make the client HTTPS request, but offers this tip for providing your own SSLSocketFactory by setting a custom property on the RequestContext of the BindingProvider", "label": {"api": {"HttpsURLConnection": [[105, 122]], "SSLSocketFactory": [[201, 216]]}}}, {"text": "Nevertheless, the Type is actually one of the null arguments you're passing into the newReference call", "label": {"api": {"newReference call": [[85, 101]]}}}, {"text": "ServletRequest getParameterNames() or getParameterMap() would give you all of the parameters that were passed in", "label": {"api": {"getParameterNames()": [[15, 33]], "getParameterMap()": [[38, 54]]}}}, {"text": "Each thread should be sharing a QueueConnectionFactory rather than a QueueConnection", "label": {"api": {"QueueConnectionFactory": [[32, 53]]}}}, {"text": "If you can change that list to a Set then you can use the contains(Element) method to check if the Set already contains a given element", "label": {"api": {"contains(Element)": [[58, 74]]}}}, {"text": "You can use comparator for this", "label": {"api": {"comparator": [[12, 21]]}}}, {"text": "As already stated in comments, if you don't need to store the truncated date (no unicity constraint, etc), you can also just store a date with time and format it when you need to display it (see SimpleDateFormat)", "label": {"api": {"SimpleDateFormat": [[195, 210]]}}}, {"text": "Servlet.destroy()'s javadoc says", "label": {"api": {"Servlet.destroy()": [[0, 16]]}}}, {"text": "From the AsynchronousFileChannel API", "label": {"api": {"AsynchronousFileChannel": [[9, 31]]}}}, {"text": "When an AsynchronousFileChannel is created without specifying a thread pool then the channel is associated with a system-dependent default thread pool that may be shared with other channels", "label": {"api": {"AsynchronousFileChannel": [[8, 30]]}}}, {"text": "You will want to use a Comparator", "label": {"api": {"Comparator": [[23, 32]]}}}, {"text": "A Comparator is a class that defines a custom sorting algorithm for a class", "label": {"api": {"Comparator": [[2, 11]]}}}, {"text": "In Java a collection that contains no duplicate elements is Set", "label": {"api": {"Set": [[60, 62]]}}}, {"text": "The common Implementing Classes are HashSet and TreeSet", "label": {"api": {"Set": [[40, 42], [52, 54]], "HashSet": [[36, 42]], "TreeSet": [[48, 54]]}}}, {"text": "For example the method addof the java.util.Set interface throws an UnsupportedOperationException, if the add operation is not supported by the concrete type that implents the Set interface", "label": {"api": {"java.util.Set": [[33, 45]], "UnsupportedOperationException": [[67, 95]]}}}, {"text": "Assuming you have implemented the long-running computation as a Task or Service (and if you haven't, you should probably consider doing so), you can just do something along the following lines", "label": {"api": {"Task": [[64, 67]], "Service": [[72, 78]]}}}, {"text": "The Java runtime uses UncheckedIOException for this kind of situation", "label": {"api": {"UncheckedIOException": [[22, 41]]}}}, {"text": "Another option may be to fork your write tasks to background threads (maintaining proper synchronization; see also java.util.concurrent.ExecutorService) and then send notifications when writes are complete that can be executed asynchronously in the display thread", "label": {"api": {"java.util.concurrent.ExecutorService": [[115, 150]]}}}, {"text": "You can use the ImageIO class, and use it to write to a ByteArrayOutputStream", "label": {"api": {"ImageIO": [[16, 22]], "ByteArrayOutputStream": [[56, 76]]}}}, {"text": "As the documentation for Class.getClassLoader() states", "label": {"api": {"Class.getClassLoader()": [[25, 46]]}}}, {"text": "If you remove that you can use just put all the employees in a java.util.Set - which doesn't allow duplicates by definition", "label": {"api": {"java.util.Set": [[63, 75]]}}}, {"text": "Or you can create your own implementation of compareTo, returning a negative number when this object is \"less than\" the object argument, 0 when this object is \"equal to\" the object argument, and a positive number when this object is \"greater than\" the object argument, per the compareTo contract", "label": {"api": {"compareTo contract": [[277, 294]]}}}, {"text": "Implementing deaths counter can be done correspondingly by following this model, and completing the save / load process is trivial par following the documentation for Map and inserting and iterating through records", "label": {"api": {"the documentation for Map": [[145, 169]]}}}, {"text": "If you call .recordStats() this is replaced with SimpleStatsCounter which has six LongAddable fields (which is usually a LongAdder but falls back to an AtomicLong if it can't use LongAdder) for each of the statistics it tracks", "label": {"api": {"AtomicLong": [[152, 161]]}}}, {"text": "LongAdder is documented to be significantly faster than AtomicLong, so like you say this should be hardly noticeable", "label": {"api": {"AtomicLong": [[56, 65]]}}}, {"text": "Reading http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html didn't help", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html": [[8, 72]]}}}, {"text": "For alert, register an onAlert handler with the web engine", "label": {"api": {"onAlert handler": [[23, 37]]}}}, {"text": "For confirm, register a confirmHandler with the web engine", "label": {"api": {"confirmHandler": [[24, 37]]}}}, {"text": "See the \"User interface callbacks\" section of the WebEngine documentation", "label": {"api": {"WebEngine documentation": [[50, 72]]}}}, {"text": "Simply call List.size() for the count", "label": {"api": {"List.size()": [[12, 22]]}}}, {"text": "Try using a LinkedBlockingQueue instead", "label": {"api": {"LinkedBlockingQueue": [[12, 30]]}}}, {"text": "As explained in the docs, you must add a HyperlinkListener to the editor pane to open the corresponding media", "label": {"api": {"As explained in the docs": [[0, 23]]}}}, {"text": "You can use the Collections.enumeration(Collection<T>) method to convert a collection, such as a List<Fruit>, to Enumeration<Fruit>", "label": {"api": {"Collections.enumeration(Collection<T>)": [[16, 53]]}}}, {"text": "This can be accomplished quite efficiently by adding your String array members to a Set, and then checking whether the set contains() the current line", "label": {"api": {"Set": [[84, 86]], "contains()": [[123, 132]]}}}, {"text": "As the Oracle Documentation for Scanner.hasNextLine() states, this method does not advance the Scanner", "label": {"api": {"Oracle Documentation": [[7, 26]]}}}, {"text": "You can read more about how threads are actually created in the ThreadPoolExecutor documentation", "label": {"api": {"ThreadPoolExecutor": [[64, 81]]}}}, {"text": "One way to do that for a one-dimensional array is to use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[57, 74]]}}}, {"text": "Your two dimensional array is constructed from multiple one-dimensional arrays, so you could use multiple calls to System.arraycopy() to copy it", "label": {"api": {"System.arraycopy()": [[115, 132]]}}}, {"text": "This is the specified behavior of the getNumericValue method", "label": {"api": {"the getNumericValue method": [[34, 59]]}}}, {"text": "Use subList to get a view of the range you want as a List", "label": {"api": {"subList": [[4, 10]]}}}, {"text": "Then use replaceAll to transform the elements in place", "label": {"api": {"replaceAll": [[9, 18]]}}}, {"text": "Note that the second parameter of replaceAll is an exclusive index value", "label": {"api": {"replaceAll": [[34, 43]]}}}, {"text": "It's easier to use a java.util.Map (key", "label": {"api": {"java.util.Map": [[21, 33]]}}}, {"text": "E.g., java.util.Math has a bunch of overloaded max methods", "label": {"api": {"java.util.Math": [[6, 19]]}}}, {"text": "BigInteger provides isProbablePrime(int) and there are several other fast (more or less) algorithms that allow to check whether a number is a primnumber with a given failure-rate", "label": {"api": {"isProbablePrime(int)": [[20, 39]]}}}, {"text": "That's because String.getBytes() returns an entirely different array object which is then assigned to buf", "label": {"api": {"String.getBytes()": [[15, 31]]}}}, {"text": "You may want to have a look at the API for String and Map", "label": {"api": {"String": [[43, 48]], "Map": [[54, 56]]}}}, {"text": "To run a hardcoded / loaded from file queries you can use execute like", "label": {"api": {"execute": [[58, 64]]}}}, {"text": "Regex lookbehind/lookahead (Java Pattern Reference) allows you to split a String and keep the delimiters", "label": {"api": {"Java Pattern Reference": [[28, 49]]}}}, {"text": "Calendar#getInstance is using the default timezone, which is by default, your own", "label": {"api": {"Calendar#getInstance": [[0, 19]]}}}, {"text": "A primitive double can't be null, you'll have to use the java.lang.Double wrapper", "label": {"api": {"java.lang.Double": [[57, 72]]}}}, {"text": "Previously I was able to write this same object to XML similarly with an XMLEncoder", "label": {"api": {"XMLEncoder": [[73, 82]]}}}, {"text": "Everything I've read from the documentation of ObjectOutputStream and it's examples would lead me to believe that this should work as XMLEncoder does", "label": {"api": {"XMLEncoder": [[134, 143]]}}}, {"text": "The URL can be obtained from Class.getResource(String)", "label": {"api": {"Class.getResource(String)": [[29, 53]]}}}, {"text": "Change (.+) to (.+?), this is covered in the JavaDoc of the Pattern class under \"Reluctant quantifiers\"", "label": {"api": {"Pattern": [[60, 66]]}}}, {"text": "One such case is with the class UUID and it's randomUUID() method", "label": {"api": {"UUID": [[32, 35], [52, 55]]}}}, {"text": "Given a scenario where a particular test depends on two randomly generated UUID to be distinct, is it excessive/unnecessary to add an assumption check for this case, e.g", "label": {"api": {"UUID": [[75, 78]]}}}, {"text": "Whilst it can be seen from many places including here that UUID collisions are practically impossible, the javadoc for such a method does not claim it to be", "label": {"api": {"UUID": [[59, 62]]}}}, {"text": "Static factory to retrieve a type 4 (pseudo randomly generated) UUID", "label": {"api": {"UUID": [[64, 67]]}}}, {"text": "The UUID is generated using a cryptographically strong pseudo random number generator", "label": {"api": {"UUID": [[4, 7]]}}}, {"text": "The clause cryptographically strong pseudo random number generator is assuring but no explicit statement is given to the uniqueness of generated UUIDs", "label": {"api": {"UUID": [[145, 148]]}}}, {"text": "This means that potentially future implementations of the randomUUID() could change it's implementation such that collisions become more likely without breaking the declared contract of the method", "label": {"api": {"UUID": [[64, 67]]}}}, {"text": "the actual code under specification uses a third party UUID generation system that is unknown to me but guarantees uniqueness", "label": {"api": {"UUID": [[55, 58]]}}}, {"text": "As this case is an extension to the original API I'm substituting their UUID generation with a dummy randomUUID() such that the assumption is only probable for the test (100% for the actual code)", "label": {"api": {"UUID": [[72, 75], [107, 110]]}}}, {"text": "Thread's stop method has been deprecated and hence you see warning", "label": {"api": {"stop": [[9, 12]]}}}, {"text": "If you just want to stop thread after 3 iteration, then you should break from loop and you will come out of run method which would stop your thread automatically", "label": {"api": {"stop": [[20, 23], [131, 134]]}}}, {"text": "Instead of using stop use something like", "label": {"api": {"stop": [[17, 20]]}}}, {"text": "Personally I'd use an Employee class and Department class, both would extend the Comparable<T> interface to make use of library functionality", "label": {"api": {"Comparable<T>": [[81, 93]]}}}, {"text": "Now Employee class only has to implement compareTo(Employee other) with the salary comparison", "label": {"api": {"compareTo(Employee other)": [[41, 65]]}}}, {"text": "This should allow you to use Collections.sort on lists of departments and get the right order", "label": {"api": {"Collections.sort": [[29, 44]]}}}, {"text": "Using Buffered Reader should improve the speed it takes to read the file as it has a much larger buffer size than Scanner", "label": {"api": {"Buffered Reader": [[6, 20]]}}}, {"text": "I see from one of your previous questions that you were using Buffered Reader initially", "label": {"api": {"Buffered Reader": [[62, 76]]}}}, {"text": "What you have here is a one-to-may relationship, you can use", "label": {"api": {"one-to-may": [[24, 33]]}}}, {"text": "Take look at @OrderColumn or this great article", "label": {"api": {"@OrderColumn": [[13, 24]]}}}, {"text": "You're using autoboxing by assigning primitives to Integer variables, and boxing uses Integer.valueOf", "label": {"api": {"Integer.valueOf": [[86, 100]]}}}]