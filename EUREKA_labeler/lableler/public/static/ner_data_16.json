[{"text": "I think the closest thing I can think of to what you want is a treemap (http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html), however you cannot get items by index only by key", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html": [[72, 134]]}}}, {"text": "Since toString() is part of Object, which all objects inherit from, System.out.println(Object o) (out is a PrintStream) knows there is a toString() implementation and it uses it (String.valueOf(Object o) is called first)", "label": {"api": {"System.out.println(Object o)": [[68, 95]], "PrintStream": [[107, 117]], "String.valueOf(Object o)": [[179, 202]]}}}, {"text": "The documentation of the PrintWriter.println(Object) method says", "label": {"api": {"documentation of the PrintWriter.println(Object) method": [[4, 58]]}}}, {"text": "in JavaFX there exists a class for binding the String content of GUI elements like TextFields to a SimpleStringProperty", "label": {"api": {"SimpleStringProperty": [[99, 118]]}}}, {"text": "Try PriorityQueue if you need to see ordered elements despite of insertion order", "label": {"api": {"PriorityQueue": [[4, 16]]}}}, {"text": "Since Java-8 there's a standalone method Entry.comparingByValue which can be used instead", "label": {"api": {"Entry.comparingByValue": [[41, 62]]}}}, {"text": "Your approach is fine, but in Java 8 you can make it a bit nicer using method references or lambdas (and replacing your Creator with the more standard Supplier<FilterDTO>)", "label": {"api": {"Supplier<FilterDTO>": [[151, 169]]}}}, {"text": "Here I've used the constructor's method reference to instantiate the Supplier<FilterDTO>", "label": {"api": {"Supplier<FilterDTO>": [[69, 87]]}}}, {"text": "Check out the JavaDoc in JDK10, https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html, an API note is added", "label": {"api": {"https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html": [[32, 97]]}}}, {"text": "Checking for string equality must be done with equals()", "label": {"api": {"equals()": [[47, 54]]}}}, {"text": "APIs that support this include the standard Java String.split() method, and Guava's Splitter class", "label": {"api": {"String.split()": [[49, 62]]}}}, {"text": "Simplest solution (assuming that we are talking about Java EE's HttpSession) would be not placing String representing array, but array itself via setAttribute(String name, Object value) so as you see value can be any Object, not only String", "label": {"api": {"HttpSession": [[64, 74]], "setAttribute(String name, Object value)": [[146, 184]]}}}, {"text": "To get the day (of the month) from a java.sql.Date, you have to use getDate", "label": {"api": {"getDate": [[68, 74]]}}}, {"text": "The correct way to get parts from a date is to use a Calendar", "label": {"api": {"Calendar": [[53, 60]]}}}, {"text": "Since TreeItem.getChildren() returns a ObservableList<TreeItem<T>>, you can use the methods of List to find the child you're looking for, e.g", "label": {"api": {"TreeItem.getChildren()": [[6, 27]], "ObservableList<TreeItem<T>>": [[39, 65]], "List": [[49, 52], [95, 98]]}}}, {"text": "using Stream to filter the content", "label": {"api": {"Stream": [[6, 11]]}}}, {"text": "Javadoc for EnumSet<E> of(E e1, E e2, E e3, E e4, E e5)", "label": {"api": {"Javadoc for EnumSet<E> of(E e1, E e2, E e3, E e4, E e5)": [[0, 54]]}}}, {"text": "Your Node class should override toString() method like this", "label": {"api": {"toString()": [[32, 41]]}}}, {"text": "BigInteger comes with methods that can be used to modify the numerical value stored within it", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "This may be useful to learn how to use BigInteger", "label": {"api": {"BigInteger": [[39, 48]]}}}, {"text": "Because the BigInteger method operations e.g", "label": {"api": {"BigInteger": [[12, 21]]}}}, {"text": "all return a BigInteger object containing the new value after the said operation, you can reassign an existing BigInteger reference variable to the BigInteger object returned by an operation like thus", "label": {"api": {"BigInteger": [[13, 22], [111, 120], [148, 157]]}}}, {"text": "In your case, since you are already using a long, you can use the BigInteger method valueOf (), which accepts a long parameter and returns a BigInteger object consisting of the long value", "label": {"api": {"BigInteger": [[66, 75], [141, 150]]}}}, {"text": "Rather than implementing your own bit shifting magic, why not use the java.nio.ByteBuffer class", "label": {"api": {"java.nio.ByteBuffer": [[70, 88]]}}}, {"text": "You're overengineering it; DataOutputStream.writeDouble() and related methods are for manually serializing a Java Object, so it can be re-read as a Java Object", "label": {"api": {"DataOutputStream.writeDouble()": [[27, 56]]}}}, {"text": "Your book should have explained at some point what a Comparable is", "label": {"api": {"Comparable": [[53, 62]]}}}, {"text": "If you go that route, I would suggest using an EnumMap to Map the type to the action, or (assuming the actions are mutable or need to be created per request) an action factory", "label": {"api": {"EnumMap": [[47, 53]]}}}, {"text": "Given a ZonedDateTime in the java.time package of Java 8 and later, how does one obtain an Instant", "label": {"api": {"ZonedDateTime": [[8, 20]], "java.time package": [[29, 45]], "Instant": [[91, 97]]}}}, {"text": "Going the other way ( Instant → ZonedDateTime ) is simply", "label": {"api": {"ZonedDateTime": [[32, 44]], "Instant": [[22, 28]]}}}, {"text": "Going from ZonedDateTime → Instant is needed for things like converting to the old-school java.util.Date class", "label": {"api": {"ZonedDateTime": [[11, 23]], "Instant": [[27, 33]], "java.util.Date": [[90, 103]]}}}, {"text": "You can use the toInstant() default method from ChronoZonedDateTime interface (which is inherited by ZonedDateTime", "label": {"api": {"toInstant()": [[16, 26]], "ChronoZonedDateTime": [[48, 66]], "ZonedDateTime": [[54, 66], [101, 113]]}}}, {"text": "You have to use Properties.store() to write the properties to a file", "label": {"api": {"Properties.store()": [[16, 33]]}}}, {"text": "Instead, use a PriorityQueue sorted by f-value for the open list and get your next node from the head of the open list", "label": {"api": {"PriorityQueue": [[15, 27]]}}}, {"text": "In java 8, you can use the computeIfAbsent to avoid even the possibility of duplicate initialization", "label": {"api": {"computeIfAbsent": [[27, 41]]}}}, {"text": "Extend an ExecutorService (that you already use), and extend the protected method newTaskFor() responsible for instantiating Futures from a Runnable or a Callable, creating a new CompletableFuture() in it", "label": {"api": {"newTaskFor()": [[82, 93]]}}}, {"text": "I would use either a ListView or a TableView", "label": {"api": {"ListView": [[21, 28]], "TableView": [[35, 43]]}}}, {"text": "By making the list unmodifiable, you'll ensure that if your Parallel code tries to mutate the list, you'll get a clear error right at the failure point", "label": {"api": {"unmodifiable": [[19, 30]]}}}, {"text": "Use thread-safe data structures - for instance, ConcurrentLinkedQueue is a threadsafe way for multiple processes to read and write to the same data structure", "label": {"api": {"ConcurrentLinkedQueue": [[48, 68]]}}}, {"text": "ConcurrentHashMap is another commonly used class", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "JavaDocs of LocalDate and DateTimeFormatter", "label": {"api": {"LocalDate": [[12, 20]], "DateTimeFormatter": [[26, 42]]}}}, {"text": "See this quote from the documentation of Statement#executeBatch()", "label": {"api": {"Statement#executeBatch()": [[41, 64]]}}}, {"text": "You're correct it's showing CDT in the toString() because your locale indicates that is the correct timezone for you", "label": {"api": {"locale": [[63, 68]]}}}, {"text": "Generally you should use toString() for debugging purposes, and use a date formatter to actually display dates to the user (optionally specifying an explicit timezone instead of the one specified by the user's locale)", "label": {"api": {"locale": [[210, 215]], "a date formatter": [[68, 83]]}}}, {"text": "I am facing a weird behavior of java.util.Calendar", "label": {"api": {"java.util.Calendar": [[32, 49]]}}}, {"text": "match any character without exception, you might want to use Pattern.DOTALL flag", "label": {"api": {"Pattern.DOTALL": [[61, 74]]}}}, {"text": "You can assign a null value to an object, but not to primitives; change it to Integer which wraps a value of the primitive type int in an object", "label": {"api": {"Integer": [[78, 84]]}}}, {"text": "The TableModelEvent tells you which data has been changed", "label": {"api": {"TableModelEvent": [[4, 18]]}}}, {"text": "And yes, @mKorbel is right that you should do this in a SwingWorker", "label": {"api": {"SwingWorker": [[56, 66]]}}}, {"text": "Java does this for you already, see java.security.MessageDigest", "label": {"api": {"java.security.MessageDigest": [[36, 62]]}}}, {"text": "As an alternative solution you can use Collections.checkedList", "label": {"api": {"Collections.checkedList": [[39, 61]]}}}, {"text": "Joda Time has a method DateTimeFormat.patternForStyle, which delegates to the patterns specified by the JDK in java.text.DateFormat", "label": {"api": {"java.text.DateFormat": [[111, 130]]}}}, {"text": "You should use TemporalType.TIMESTAMP that will map the field to a java.sql.Timestamp, hence it will contain also time related info, not only regarding date", "label": {"api": {"TemporalType.TIMESTAMP": [[15, 36]], "java.sql.Timestamp": [[67, 84]]}}}, {"text": "In comparison, the type you used, TemporalType.DATE are mapped to java.sql.Date, class containing information like day, month year", "label": {"api": {"TemporalType.DATE": [[34, 50]], "java.sql.Date": [[66, 78]]}}}, {"text": "If all else fails, you can always use the parent class Number and it's method doubleValue()", "label": {"api": {"doubleValue()": [[78, 90]]}}}, {"text": "Since you are representing a date, not a specific instant in time, you should represent the match's date as a LocalDate instance, rather than an obsolete and poorly-name Date instance", "label": {"api": {"LocalDate": [[110, 118]], "Date": [[115, 118], [170, 173]]}}}, {"text": "If you can, stick with LocalDate throughout your program, and avoid the deprecated Date class", "label": {"api": {"LocalDate": [[23, 31]], "Date": [[28, 31], [83, 86]]}}}, {"text": "If you need to interoperate with some other library that requires a Date, you can convert it, but you have choose the target time zone and time of day, which isn't included in the data you are parsing", "label": {"api": {"Date": [[68, 71]]}}}, {"text": "You can use Optional's ofNullable method to create an Optional that may or may not represent a null value", "label": {"api": {"Optional's ofNullable method": [[12, 39]]}}}, {"text": "Then you can use the map method that will, with a Function, map the result to a new value if the value wasn't already null", "label": {"api": {"the map method": [[17, 30]]}}}, {"text": "But, is there a similar threshold for trySplit(), a point where decomposing a problem into smaller chunks is counterproductive", "label": {"api": {"trySplit()": [[38, 47]]}}}, {"text": "If so, does the threshold depend on the relative cost of trySplit() and consuming an item in the course of tryAdvance()", "label": {"api": {"trySplit()": [[57, 66]], "consuming": [[72, 80]]}}}, {"text": "Java 8 gave us Math.addExact() for integers but not decimals", "label": {"api": {"Math.addExact()": [[15, 29]]}}}, {"text": "Judging by Double.MAX_VALUE and How to get biggest BigDecimal value I'd say the answer is yes", "label": {"api": {"Double.MAX_VALUE": [[11, 26]]}}}, {"text": "As such, why don't we have Math.addExact() for those types as well", "label": {"api": {"Math.addExact()": [[27, 41]]}}}, {"text": "I have been searching everything but the documentation at http://docs.oracle.com/javase/7/docs/api/javax/swing/SortOrder.html leaves a lot to be desired", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/SortOrder.html": [[58, 124]]}}}, {"text": "Use Java controls like JButton", "label": {"api": {"JButton": [[23, 29]]}}}, {"text": "Alternatively, make your own subclasses of JComponent or use JLabel", "label": {"api": {"JComponent": [[43, 52]]}}}, {"text": "Or use StringBuilde.replace method (which is faster but you will only nothe the difference if you use it inside a wide loop)", "label": {"api": {"StringBuilde.replace": [[7, 26]]}}}, {"text": "You need to tell the ImageIcon to notify the JLabel of frame changes, by passing the JLabel to setImageObserver", "label": {"api": {"setImageObserver": [[95, 110]]}}}, {"text": "I'd suggest you to take a look at the Java API implementation of a Linked List,  which offers you all possibilities you need", "label": {"api": {"Linked List": [[67, 77]]}}}, {"text": "Somewhat simpler solution is to use Comparator.comparingInt", "label": {"api": {"Comparator.comparingInt": [[36, 58]]}}}, {"text": "the JFrame is reachable, one way is via Windows#getWindows()", "label": {"api": {"Windows#getWindows()": [[40, 59]]}}}, {"text": "An InheritableThreadLocal differs in that child threads' initial values are inherited, rather than initially set to null", "label": {"api": {"InheritableThreadLocal": [[3, 24]]}}}, {"text": "Consider using the WebapplicationException", "label": {"api": {"WebapplicationException": [[19, 41]]}}}, {"text": "ordinal() gives you the position of enum declaration, not the value of the status code", "label": {"api": {"ordinal()": [[0, 8]]}}}, {"text": "You should consider generating identifier using the UUID class", "label": {"api": {"UUID": [[52, 55]]}}}, {"text": "You can use Java's UUID class to create UUID values as unique identifiers", "label": {"api": {"UUID": [[19, 22], [40, 43]]}}}, {"text": "You will be able to get the timestamp from the generated UUID if required at a later point of time", "label": {"api": {"UUID": [[57, 60]]}}}, {"text": "How do I extract a date from a UUID using Java", "label": {"api": {"UUID": [[31, 34]]}}}, {"text": "In case you don't find a more elegant way, you can always use a ThreadLocal", "label": {"api": {"ThreadLocal": [[64, 74]]}}}, {"text": "I can recommend you reading some doc about JFrame", "label": {"api": {"doc about JFrame": [[33, 48]]}}}, {"text": "Parse the Strings as Date like suggested in the comments, then retrieve the timestamps of both Date objects through the getTime() method", "label": {"api": {"getTime() method": [[120, 135]]}}}, {"text": "To evaluate a String containing a list of dates, you have to split the string along the list separator into an array of strings by using String#split()", "label": {"api": {"String#split()": [[137, 150]]}}}, {"text": "Then, you can parse each sub string into a Date object and retrieve the timestamp of each as per the #getTime() method mentioned in the first paragraph", "label": {"api": {"getTime() method": [[102, 117]]}}}, {"text": "This list can be searched for entries within the expected range, for example using the Stream API's filter function (Java 8 and newer)", "label": {"api": {"Stream API's filter function": [[87, 114]]}}}, {"text": "Besides Maps do have a remove methods, which accepts a key and removes the entry for this key", "label": {"api": {"remove": [[23, 28], [63, 68]]}}}, {"text": "You can use compareTo, Double is implementing Comparable interface", "label": {"api": {"compareTo": [[12, 20]]}}}, {"text": "An easy way to add elements is with the add() method", "label": {"api": {"add() method": [[40, 51]]}}}, {"text": "There is no constructor or method in LinkedList to specify the backing array", "label": {"api": {"LinkedList": [[37, 46]]}}}, {"text": "It sounds like you have an array and a LinkedList and are adding an object to the array and then adding the object to the LinkedList instance", "label": {"api": {"LinkedList": [[39, 48], [122, 131]]}}}, {"text": "Removing the object from the array does not remove it from the LinkedList in this scenario", "label": {"api": {"LinkedList": [[63, 72]]}}}, {"text": "Based on your description, you should be adding your object to the LinkedList instance and using that as your source of truth", "label": {"api": {"LinkedList": [[67, 76]]}}}, {"text": "You might want to use TreeMap and you would be able to get a sub map which seems to be what you are looking for", "label": {"api": {"sub map": [[61, 67]]}}}, {"text": "Another solution might be to pass out a WeakReference<Child> to every object that holds a possibly-orphaned Child and check for null every time you call get", "label": {"api": {"WeakReference<Child>": [[40, 59]]}}}, {"text": "The key point here is to use EntityManager.getReference", "label": {"api": {"EntityManager.getReference": [[29, 54]]}}}, {"text": "One way to do this is to use the setExtendedState and to set it to MAXIMIZED_BOTH as described in this question", "label": {"api": {"setExtendedState": [[33, 48]], "MAXIMIZED_BOTH": [[67, 80]]}}}, {"text": "The Scanner class throws an IOException when the file could not be read for some reason", "label": {"api": {"Scanner": [[4, 10]], "IOException": [[28, 38]]}}}, {"text": "However, IOException is a checked exception", "label": {"api": {"IOException": [[9, 19]]}}}, {"text": "When you declare throws IOException, you are telling Java that you will not handle the exception, and instead allow it to bubble up, and leave the caller of your method to handle the exception instead", "label": {"api": {"IOException": [[24, 34]]}}}, {"text": "You could use AtomicInteger instead of an int", "label": {"api": {"AtomicInteger": [[14, 26]]}}}, {"text": "It can if necessary at some point still determine the actual HTTP method being used via HttpServletRequest#getMethod()", "label": {"api": {"HttpServletRequest#getMethod()": [[88, 117]]}}}, {"text": "That is because it's an object of class MimeMultipart", "label": {"api": {"MimeMultipart": [[40, 52]]}}}, {"text": "You can downcast the result of message.getContent() to a MimeMultipart variable and analyse it", "label": {"api": {"MimeMultipart": [[57, 69]]}}}, {"text": "See the Javadoc of MimeBodyPart for details on how to analyse the parts of the message", "label": {"api": {"Javadoc of MimeBodyPart": [[8, 30]]}}}, {"text": "As noted in the TableModelEvent API for getColumn(), \"If the return value is ALL_COLUMNS; it means every column in the specified rows changed.\" Note that ALL_COLUMNS has the value -1", "label": {"api": {"TableModelEvent": [[16, 30]], "getColumn()": [[40, 50]], "ALL_COLUMNS": [[77, 87], [154, 164]]}}}, {"text": "You need to have two different mappings for different schema, so you have to create two java mapping classes and annotate them with the Table annotation to mark the schema for each specific entity", "label": {"api": {"schema": [[54, 59], [165, 170]]}}}, {"text": "You should use SetProperty like this", "label": {"api": {"SetProperty": [[15, 25]]}}}, {"text": "Then, you can set the values using an ObservableSet", "label": {"api": {"ObservableSet": [[38, 50]]}}}, {"text": "You can construct an ObservableSet with the help of FXCollections.observableSet(E..", "label": {"api": {"ObservableSet": [[21, 33]]}}}, {"text": "It will then be embedded inside the final jar and you can access it with Class.getResource(String name)", "label": {"api": {"Class.getResource(String name)": [[73, 102]]}}}, {"text": "The class java.lang.reflect.Array does not describe an array; it is a class that provides static methods to dynamically create and access Java arrays", "label": {"api": {"java.lang.reflect.Array": [[10, 32]]}}}, {"text": "If you already have a sorted list, use Collections.reverse", "label": {"api": {"Collections.reverse": [[39, 57]]}}}, {"text": "Better yet, use the already built-in Collections.reverseOrder Comparator", "label": {"api": {"Collections.reverse": [[37, 55]], "Collections.reverseOrder": [[37, 60]]}}}, {"text": "I would suggest you try using a LinkedHashMap, which will preserve the order, then do as Mena suggested", "label": {"api": {"LinkedHashMap": [[32, 44]]}}}, {"text": "Read the javadoc of Arrays", "label": {"api": {"Arrays": [[20, 25]]}}}, {"text": "This behaviour is actually documented", "label": {"api": {"actually documented": [[18, 36]]}}}, {"text": "The InputStream doesn't just return the number of bytes, it returns the bytes with read()", "label": {"api": {"InputStream": [[4, 14]]}}}, {"text": "After digging lots of resources, especially this one  and this one and realizing that I was not the only one facing this issue I found out that there is a class called ObjectFactory that is generated automatically with the help of which I can easily create certain JAXBElement instances to be passed as inputs to a WCF service function", "label": {"api": {"this one": [[44, 51], [58, 65]]}}}, {"text": "Now all that's left is to parse the input on-the-fly using Integer.parseInt", "label": {"api": {"Integer.parseInt": [[59, 74]]}}}, {"text": "I'm running into a situation where I would like to convert from a Julian date to an java.time.Instant (if that makes sense), or some Java time that can be more easily understood", "label": {"api": {"java.time.Instant": [[84, 100]]}}}, {"text": "I noticed there is a class called JulianFields, but I don't know  where/how to use it", "label": {"api": {"JulianFields": [[34, 45]]}}}, {"text": "It seems to refer to a SimpleDateFormat object", "label": {"api": {"SimpleDateFormat": [[23, 38]]}}}, {"text": "The Field class is a subclass of AccessibleObject", "label": {"api": {"AccessibleObject": [[33, 48]]}}}, {"text": "In your case the BinaryOperator<String> is what you need", "label": {"api": {"BinaryOperator<String>": [[17, 38]]}}}, {"text": "You can use a SimpleDateFormat to format a new Date()", "label": {"api": {"SimpleDateFormat": [[14, 29]], "new Date()": [[43, 52]]}}}, {"text": "Indeed, the documentation for Iterator essentially says that Iterator has superseded Enumeration", "label": {"api": {"documentation for Iterator": [[12, 37]]}}}, {"text": "Or use  Pane class", "label": {"api": {" Pane class": [[7, 17]]}}}, {"text": "You could also look into Futures, which are the Java class that deals with asynchronous loading situations such as this one", "label": {"api": {"Future": [[25, 30]]}}}, {"text": "To create a BigInteger, you can use the constructor taking a string parameter", "label": {"api": {"the constructor taking a string parameter": [[36, 76]]}}}, {"text": "Jacoco is an agent that gets added to the execution of your tests and which monitors them, analyzing which lines/branches have been executed (covered) and which have not", "label": {"api": {"agent": [[13, 17]]}}}, {"text": "Short solution - Integers simply don't go that high", "label": {"api": {"Integers": [[17, 24]]}}}, {"text": "Thus, the function throws this NumberFormatException - this is not a valid value for an int", "label": {"api": {"NumberFormatException": [[31, 51]]}}}, {"text": "Basically you are getting  NullPointerException.The code  you posted is not clear where actually you are getting this", "label": {"api": {"NullPointerException": [[27, 46]]}}}, {"text": "See What is a NullPointerException, and how do I fix it", "label": {"api": {"NullPointerException": [[14, 33]]}}}, {"text": "Formatter does not work like you think it does, but you don't actually need to use it anyway", "label": {"api": {"Formatter": [[0, 8]]}}}, {"text": "The lambda expression passed to Iterable#forEach isn't allowed to throw an exception, so you need to handle it there", "label": {"api": {"Iterable#forEach": [[32, 47]]}}}, {"text": "Use String.substring() as descriped in the API", "label": {"api": {"API": [[43, 45]]}}}, {"text": "It seems that Folder#getMessages() does not guarantee a specific order of the messages", "label": {"api": {"Folder#getMessages()": [[14, 33]]}}}, {"text": "Now create your underlying list with an extractor, so that it fires update events when the stateProperty changes", "label": {"api": {"extractor": [[40, 48]]}}}, {"text": "If what you want/need is to execute a group of jobs one after another but in a single thread different that the main app thread, then use Executors#newSingleThreadExecutor", "label": {"api": {"Executors#newSingleThreadExecutor": [[138, 170]]}}}, {"text": "One implementation is described in the javadoc section of Executor interface, another, optimized implementation, at my Github repository CodeSamples", "label": {"api": {"javadoc section of Executor interface": [[39, 75]]}}}, {"text": "Or, at the \"cost\" of relaxing the API to return a List instead of an ArrayList, the text book solution would be to use Collections.unmodifiableList", "label": {"api": {"Collections.unmodifiableList": [[119, 146]]}}}, {"text": "Because this is so easy to get wrong, I'd recommend working with the existing facilities provided by java.util.concurrent", "label": {"api": {"java.util.concurrent": [[101, 120]]}}}, {"text": "From the Javadoc of Preferences", "label": {"api": {"Preferences": [[20, 30]]}}}, {"text": "There is no problem with doing this, in fact the InputStreamReader documentation from the Java API does it", "label": {"api": {"InputStreamReader documentation": [[49, 79]]}}}, {"text": "In this case, the InputStreamReader is being used by the BufferedReader, which means they will both close when the BufferedReader close() function is called as it", "label": {"api": {"close()": [[130, 136]]}}}, {"text": "Finally you may use Java-8 Optional if you don't want to create/use non-standard methods", "label": {"api": {"Optional": [[27, 34]]}}}, {"text": "Having this your task can be solved pretty easily with the cascaded groupingBy", "label": {"api": {"groupingBy": [[68, 77]]}}}, {"text": "Make your User class implement the Comparable interface", "label": {"api": {"Comparable": [[35, 44]]}}}, {"text": "Call Collections.sort on the List<User>", "label": {"api": {"Collections.sort": [[5, 20]]}}}, {"text": "Quoting from The Java Docs for Serializable", "label": {"api": {"The Java Docs for Serializable": [[13, 42]]}}}, {"text": "Then the dialog meets both your requirement of being able to be closed via the native windowing system's window close icon as well as the JavaFX Dialog requirement of including a close button in the dialog for the close icon to work", "label": {"api": {"Dialog": [[145, 150]]}}}, {"text": "Alternately, you could use a Stage with showAndWait instead of a Dialog", "label": {"api": {"showAndWait": [[40, 50]], "Dialog": [[65, 70]]}}}, {"text": "If you must return null, at least wrap it in an optional or use guava", "label": {"api": {"optional": [[48, 55]]}}}, {"text": "Using Character#getNumericValue may be more idiomatic", "label": {"api": {"Character#getNumericValue": [[6, 30]]}}}, {"text": "Probably the shortest way is to use Files.write along with the trick which converts the Stream to the Iterable", "label": {"api": {"Files.write": [[36, 46]]}}}, {"text": "If you use scrollPane.getVerticalScrollBar().getValue(), you can save that value when you close the pane", "label": {"api": {"scrollPane.getVerticalScrollBar().getValue()": [[11, 54]]}}}, {"text": "Then, when you reload the pane, just use scrollPane.getVerticalScrollBar.setValue(savedValue)", "label": {"api": {"scrollPane.getVerticalScrollBar.setValue(savedValue)": [[41, 92]]}}}, {"text": "I would consider using a BorderLayout, and working with Insets of the inner panels", "label": {"api": {"Insets": [[56, 61]]}}}, {"text": "The read() method returns an int that stores the next byte that is read from the stream", "label": {"api": {"read() method": [[4, 16]]}}}, {"text": "If you type \"ABCD\", then without casting, then the println(int) method is called (System.out is a PrintStream), and the values of the bytes are printed", "label": {"api": {"println(int) method": [[51, 69]]}}}, {"text": "If you cast it to a char, then a different overloaded method, println(char) is called, which knows to print the character specified, so it \"works\" (echoes to you the characters you typed)", "label": {"api": {"println(char)": [[62, 74]]}}}, {"text": "The read() method returns an integer, or -1 if the end of stream has been reached", "label": {"api": {"returns an integer": [[18, 35]]}}}, {"text": "You may want to use the class java.beans.Introspector to obtain the names of the properties from the target class", "label": {"api": {"java.beans.Introspector": [[30, 52]]}}}, {"text": "With-replacement sampling is easy to implement in Java, simply use Random.nextInt(int) to select a random value between 0 and the size of your list", "label": {"api": {"Random.nextInt(int)": [[67, 85]]}}}, {"text": "Several people have suggested Collections.shuffle() which also works, but is more invasive than simply generating a random index", "label": {"api": {"Collections.shuffle()": [[30, 50]]}}}, {"text": "Collections.shuffle() has to iterate over the entire list, taking O(n log n) time, and modifies your list", "label": {"api": {"Collections.shuffle()": [[0, 20]]}}}, {"text": "Instead, you'll need to call getDeclaredField, because getField only gets public fields", "label": {"api": {"getDeclaredField": [[29, 44]], "getField only gets public fields": [[55, 86]]}}}, {"text": "Also, you'll need to get() the value of the Field, passing in an instance of the ayy class, which will return the value of the Field", "label": {"api": {"get() the value of the Field": [[21, 48]]}}}, {"text": "You have to allocate a new array for the result and then use System.arraycopy", "label": {"api": {"System.arraycopy": [[61, 76]]}}}, {"text": "According to the Integer API, Integer.toBinaryString() returns the twos complement, not the signed version", "label": {"api": {"Integer API": [[17, 27]]}}}, {"text": "Since Java 8 you can use Integer.parseUnsignedInt(s, 2);", "label": {"api": {"Integer.parseUnsignedInt(s, 2);": [[25, 55]]}}}, {"text": "You can pass an instance of StreamingOutput that copies the content of the source file to the client output and eventually deletes the file", "label": {"api": {"StreamingOutput": [[28, 42]]}}}, {"text": "create IntStreamEx (enhanced IntStream) where each element is the corresponding character of input line", "label": {"api": {"IntStream": [[7, 15], [29, 37]]}}}, {"text": "InterruptedException is thrown on job abort, so by catching it, it is possible to detect and handle job termination", "label": {"api": {"InterruptedException": [[0, 19]]}}}, {"text": "com.sun.net.httpserver.HttpServer can do so", "label": {"api": {"HttpServer": [[23, 32]]}}}, {"text": "A HttpServer is bound to an IP address and port number and listens for incoming TCP connections from clients on this address", "label": {"api": {"HttpServer": [[2, 11]]}}}, {"text": "if it's in WEB-INF/classes or in a JAR in WEB-INF/lib, then use getClass().getResourceAsStream(\"file.txt\"); otherwise use ServletRequest#getResourceAsStream()", "label": {"api": {"ServletRequest#getResourceAsStream()": [[122, 157]]}}}, {"text": "Also, think of creating a utility class with static methods if it makes sense of course - sometimes you do not need class member fields at all because there is no state to this class (Math class is an example) and static methods that return the result of some calculation/transformation is a better option", "label": {"api": {"Math class": [[184, 193]]}}}, {"text": "For the concrete problem of summing and averaging, use collectingAndThen along with summarizingDouble", "label": {"api": {"collectingAndThen": [[55, 71]], "summarizingDouble": [[84, 100]]}}}, {"text": "You can add a custom finisher step using Collectors.collectingAndThen(complexCollector, list -> ...) to convert this list to something more appropriate", "label": {"api": {"collectingAndThen": [[52, 68]]}}}, {"text": "I'd create a separate marshaller class using ByteBuffer to write out the values in the correct format", "label": {"api": {"ByteBuffer": [[45, 54]]}}}, {"text": "The easiest fix for that is to just inject using javax.inject.Provider, which allows us to lazily retrieve the object", "label": {"api": {"javax.inject.Provider": [[49, 69]]}}}, {"text": "Use a StringBuilder to speed things to there", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "ArrayList.indexOf() doesn't use reference equality to find the object", "label": {"api": {"ArrayList.indexOf()": [[0, 18]]}}}, {"text": "Use Collections.synchronizedList() to wrap your ArrayList in a synchronized version", "label": {"api": {"Collections.synchronizedList()": [[4, 33]]}}}, {"text": "Use java.util.Vector, a List that is already synchronized", "label": {"api": {"java.util.Vector": [[4, 19]]}}}, {"text": "Create a single-thread ExecutorService", "label": {"api": {"single-thread": [[9, 21]]}}}, {"text": "Whenever you need to interact with the COM port, whether the request originates from the socket or from the main program itself, submit the task to this service", "label": {"api": {"submit": [[129, 134]]}}}, {"text": "You can use a Proxy with a suitable InvocationHandler (though you'd have to pull out an interface for each of your singletons)", "label": {"api": {"Proxy": [[14, 18]]}}}, {"text": "or you can use an enhanced for loop on a sublist, using List's subList method", "label": {"api": {"List's subList method": [[56, 76]]}}}, {"text": "The add method doesn't modify the object; it returns a new BigInteger representing the sum", "label": {"api": {"add method": [[4, 13]]}}}, {"text": "This can be explained once we understand what longValue() is returning", "label": {"api": {"longValue()": [[46, 56]]}}}, {"text": "The only values that would print false for b and c are those BigIntegers that would convert to Long.MIN_VALUE AND Long.MAX_VALUE themselves, respectively, when longValue() is called", "label": {"api": {"longValue()": [[160, 170]]}}}, {"text": "Since Java 1.8 you can use BigInteger.longValueExact() which will throw an ArithmeticException if the BigInteger value cannot be exactly expressed as long value", "label": {"api": {"BigInteger.longValueExact()": [[27, 53]]}}}, {"text": "A simple way is to use an HttpURLConnection", "label": {"api": {"HttpURLConnection": [[26, 42]]}}}, {"text": "You need to call .addKeyListener() to register your KeyListener implementation", "label": {"api": {".addKeyListener()": [[17, 33]]}}}, {"text": "You're looking for the PagedResultsControl", "label": {"api": {"PagedResultsControl": [[23, 41]]}}}, {"text": "You can do this using Matcher.appendReplacement", "label": {"api": {"Matcher.appendReplacement": [[22, 46]]}}}, {"text": "Use Comparable interface", "label": {"api": {"Comparable": [[4, 13]]}}}, {"text": "There's a standard Java class java.text.BreakIterator which can be used to find the sentence boundaries", "label": {"api": {"java.text.BreakIterator": [[30, 52]]}}}, {"text": "If this is not an assignment, where you should implement this yourself, you should probably just use the AffineTransformOp.getBounds2D(BufferedImage) method, which is made for exactly this purpose", "label": {"api": {"AffineTransformOp.getBounds2D(BufferedImage)": [[105, 148]]}}}, {"text": "A HashMap cannot be sorted, you have to use a TreeMap like Brijesh suggested (Your elements have to implement Comparable or you have to provide a compartor during construction)", "label": {"api": {"TreeMap": [[46, 52]]}}}, {"text": "If you just want insertion order you could also use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[54, 66]]}}}, {"text": "An easy approach to your problem could be to use the .replaceAll(String regex, String replacement) method available in the string class", "label": {"api": {".replaceAll(String regex, String replacement)": [[53, 97]]}}}, {"text": "Taking the List as an example, if you where to have a method which returns an ArrayList<String> as a result", "label": {"api": {"List": [[11, 14], [83, 86]]}}}, {"text": "public ArrayList<String> foo(), then, you are bound to that particular type", "label": {"api": {"List": [[12, 15]]}}}, {"text": "If you want a linked list, you will probably need to write some sort of converter which creates a LinkedList<String> from an ArrayList<String>", "label": {"api": {"List": [[104, 107], [130, 133]]}}}, {"text": "public List<String> foo()", "label": {"api": {"List": [[7, 10]]}}}, {"text": "This will allow who ever consumes foo to be able to create any one of the data structures which implement the List interface without the need of going through hoops", "label": {"api": {"List": [[110, 113]]}}}, {"text": "One of the instances where working with objects makes sense is the readObject() method provided by the ObjectInputStream", "label": {"api": {"readObject()": [[67, 78]]}}}, {"text": "There are two getValue() methods defined on Attributes objects, one that takes a String parameter and one that takes a Attributes.Name parameter", "label": {"api": {"Attributes": [[44, 53], [119, 128]]}}}, {"text": "Looks like the EL implementation gets confused by this as it is trying to cast your string to an Attributes.Name object", "label": {"api": {"Attributes": [[97, 106]]}}}, {"text": "In Java, never concatenate Strings inside a loop, instead of this, use StringBuilder and check after each iteration if necessary to add more strings", "label": {"api": {"StringBuilder": [[71, 83]]}}}, {"text": "You normally acquire a Format object, appropriate to the data type and user language, which has the parseObject method which allows to deal with errors", "label": {"api": {"Format": [[23, 28]], "parseObject": [[100, 110]]}}}, {"text": "The are always handled by a DateFormat, so you always have a Format object and the question becomes meaningless", "label": {"api": {"Format": [[32, 37], [61, 66]], "DateFormat": [[28, 37]]}}}, {"text": "Simply use a HashSet<Id> instead of an array", "label": {"api": {"HashSet<Id>": [[13, 23]]}}}, {"text": "Also, you might have a look at CachedRowSet, for working with data in a disconnected fashion", "label": {"api": {"CachedRowSet": [[31, 42]]}}}, {"text": "String.split takes a regular expression, so you must escape + with \\\\", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "However, you can print leading zeroes of an int using use String.format", "label": {"api": {"String.format": [[58, 70]]}}}, {"text": "You can get a whole lot of additional File attributes with the java.nio classes, especially the Files utility class which has Files.getOwner() or can retrieve a PosixFileAttributeView", "label": {"api": {"Files": [[96, 100], [126, 130]], "PosixFileAttributeView": [[161, 182]]}}}, {"text": "To remove the duplicates, use a HashSet<String>", "label": {"api": {"HashSet<String>": [[32, 46]]}}}, {"text": "There is an Executors framework in java SE since java 1.5", "label": {"api": {"Executors": [[12, 20]]}}}, {"text": "More specifically for your use case the class Executors contains method newSingleThreadScheduledExecutor()", "label": {"api": {"Executors": [[46, 54]], "newSingleThreadScheduledExecutor()": [[72, 105]]}}}, {"text": "Which will return new ScheduledExecutorService instance", "label": {"api": {"ScheduledExecutorService": [[22, 45]]}}}, {"text": "Use that service to schedule some Runnable implementing work you need to do", "label": {"api": {"Runnable": [[34, 41]]}}}, {"text": "You may use workHandler or scheduler to further manipulation with the service or scheduled Runnable", "label": {"api": {"Runnable": [[91, 98]]}}}, {"text": "Before exiting your application execute scheduler.shutdown() followed by scheduler.awaitTermination(...timeout...) (read more)", "label": {"api": {"read more": [[116, 124]]}}}, {"text": "In java, the internal data of BitSet is stored as long[] instead of int[], I want to know why", "label": {"api": {"BitSet": [[30, 35]]}}}, {"text": "When querying or manipulating a single bit, there is no significant difference", "label": {"api": {"or": [[14, 15]]}}}, {"text": "You have to calculate the word index and read that word and, in case of an update, manipulate one bit of that word and write it back", "label": {"api": {"and": [[37, 39], [56, 58], [115, 117]], "or": [[27, 28], [52, 53], [111, 112]]}}}, {"text": "That’s all the same for int[] and long[]", "label": {"api": {"and": [[30, 32]], "or": [[21, 22]]}}}, {"text": "One could argue that doing it using a long instead of int could raise the amount of memory that has to be transferred for a single bit operation if you have a real 32 bit memory bus, but since Java was designed in the nineties of the last century, the designers decided that this is not an issue anymore", "label": {"api": {"or": [[87, 88], [119, 120], [174, 175], [300, 301]]}}}, {"text": "On the other hand, you get a big win when processing multiple bits at once", "label": {"api": {"and": [[14, 16]]}}}, {"text": "When you perform operations like and, or or xor on an entire BitSet, you can perform the operation on an entire word, read 64 bits, at once when using a long array", "label": {"api": {"and": [[33, 35]], "or": [[13, 14], [38, 39], [41, 42], [45, 46], [81, 82], [113, 114]], "xor": [[44, 46]]}}}, {"text": "Similarly, when searching for the next set bit, if the bit is not within the word of the start position, subsequent words are first tested against zero, which is an intrinsic operation, even for most 32 bit CPUs, so you can skip 64 zero bits at once while the first non-zero word will definitely contain the next set bit, so only one bit extraction operation is needed for the entire iteration", "label": {"api": {"or": [[27, 28], [78, 79], [117, 118], [192, 193], [276, 277], [370, 371]], "searching for the next set bit": [[16, 45]]}}}, {"text": "These benefits for bulk operations will outweigh any single-bit related drawbacks, if there ever are one", "label": {"api": {"or": [[16, 17]]}}}, {"text": "As said, most today’s CPU are capable of doing all operations on 64 bit words directly", "label": {"api": {"or": [[73, 74]]}}}, {"text": "See the Javadocs for putIfAbsent() and replace() for details", "label": {"api": {"putIfAbsent()": [[21, 33]], "replace()": [[39, 47]]}}}, {"text": "As Tagir Valeev points out in his answer, you can use merge() instead if you're on Java 8, which would shorten the code above to", "label": {"api": {"merge()": [[54, 60]]}}}, {"text": "Another option would be to let the values be AtomicInteger instead", "label": {"api": {"AtomicInteger": [[45, 57]]}}}, {"text": "For all this templates I want my own logic for the rendering of BigDecimal types", "label": {"api": {"BigDecimal": [[64, 73]]}}}, {"text": "Basically I need a renderer that makes sure every BigDecimal beeing rendered with as many decimal places as its scale", "label": {"api": {"BigDecimal": [[50, 59]]}}}, {"text": "Create a new URL object using your String value and call getHost() or any other method on it, like so", "label": {"api": {"URL": [[13, 15]], "getHost()": [[57, 65]]}}}, {"text": "To compare your Classes you can integrate the Comparable-Interface which let you add the needed Functionallity to compare two Classes", "label": {"api": {"Comparable": [[46, 55]]}}}, {"text": "You will need to use SwingUtilities.invokeLater(Runnable r)", "label": {"api": {"SwingUtilities.invokeLater(Runnable r)": [[21, 58]]}}}, {"text": "Use JToolBar inherithed method Component::setBounds", "label": {"api": {"JToolBar": [[4, 11]], "Component::setBounds": [[31, 50]]}}}, {"text": "In C#, the collection itself can be enumerated for key-value pairs; in Java, you must call a method to obtain a key-value set, which is called entrySet()", "label": {"api": {"entrySet()": [[143, 152]]}}}, {"text": "You could use the Stream.peek(action) method to log info about each object of your stream", "label": {"api": {"Stream.peek(action)": [[18, 36]]}}}, {"text": "The action must conform to the Consumer interface", "label": {"api": {"Consumer": [[31, 38]]}}}, {"text": "Have a look at the Javadoc of Attributes class", "label": {"api": {"Attributes class": [[30, 45]]}}}, {"text": "You can use getValue(String) to retrieve the value of a specific attribute", "label": {"api": {"getValue(String)": [[12, 27]]}}}, {"text": "I suggest to use null-safe Objects.toString() for getting string representation--it won't throw exception if attrs.get() returns null, which may happen if attribute is not found", "label": {"api": {"Objects.toString()": [[27, 44]]}}}, {"text": "I was checking the documentation of the URLConnection class and i wasn't able to find a getter/setter for the  connected field", "label": {"api": {"URLConnection": [[40, 52]]}}}, {"text": "Most likely, your implementation of Comparable is incorrect", "label": {"api": {"Comparable": [[36, 45]]}}}, {"text": "Your Comparable implementation is what PriorityQueue uses to know how to sort the items based on the value of a field", "label": {"api": {"Comparable": [[5, 14]]}}}, {"text": "You must implement Comparable in DECREASING order", "label": {"api": {"Comparable": [[19, 28]]}}}, {"text": "You can also use PriorityQueue(int initialCapacity, Comparator comparator) if you don't want to change the class definition of Item", "label": {"api": {"PriorityQueue(int initialCapacity, Comparator comparator)": [[17, 73]]}}}, {"text": "According to the Javadoc for PriorityQueue", "label": {"api": {"Javadoc for PriorityQueue": [[17, 41]]}}}, {"text": "The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used", "label": {"api": {"natural ordering": [[66, 81]]}}}, {"text": "A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException)", "label": {"api": {"natural ordering": [[28, 43]]}}}, {"text": "Can you instead use a thread-safe ordered collection like ConcurrentSkipListSet (non-blocking) or PriorityBlockingQueue (blocking)", "label": {"api": {"ConcurrentSkipListSet": [[58, 78]], "PriorityBlockingQueue": [[98, 118]]}}}, {"text": "See this doc link", "label": {"api": {"this doc link": [[4, 16]]}}}, {"text": "Both are having the super class ( java.lang.reflect.AccessibleObject) and you are accessing the same methods from that class", "label": {"api": {"java.lang.reflect.AccessibleObject": [[34, 67]]}}}, {"text": "Look at the class  java.lang.reflect.AccessibleObject", "label": {"api": {"java.lang.reflect.AccessibleObject": [[19, 52]]}}}, {"text": "Both java.lang.reflect.Field and java.lang.reflect.Method extend java.lang.reflect.AccessibleObject, which provides the method you're using", "label": {"api": {"java.lang.reflect.Field": [[5, 27]], "java.lang.reflect.Method": [[33, 56]], "java.lang.reflect.AccessibleObject": [[65, 98]]}}}, {"text": "Or from Java 7 on, the FileVisitor API", "label": {"api": {"FileVisitor": [[23, 33]]}}}, {"text": "JFrame.EXIT_ON_CLOSE is called a constant (or a static variable)", "label": {"api": {"JFrame.EXIT_ON_CLOSE": [[0, 19]], "EXIT_ON_CLOSE": [[7, 19]]}}}, {"text": "Not just as a parameter to a function, JFrame.EXIT_ON_CLOSE is a value you can use anywhere", "label": {"api": {"JFrame.EXIT_ON_CLOSE": [[39, 58]], "EXIT_ON_CLOSE": [[46, 58]]}}}, {"text": "setDefaultCloseOperation takes an int as its parameter to tell it what close operation you want", "label": {"api": {"setDefaultCloseOperation": [[0, 23]]}}}, {"text": "EXIT_ON_CLOSE - which happens to be 3, but could change - is the operation you are telling it to do", "label": {"api": {"EXIT_ON_CLOSE": [[0, 12]]}}}, {"text": "The entityManager#getReference seems to be what you are looking for", "label": {"api": {"entityManager#getReference": [[4, 29]]}}}, {"text": "JPA has the ManyToMany annotation, which creates the relationship for you", "label": {"api": {"ManyToMany": [[12, 21]]}}}, {"text": "ManyToMany is Lazy by default..", "label": {"api": {"ManyToMany": [[0, 9]]}}}, {"text": "process.waitFor() waits until the process is terminated", "label": {"api": {"process.waitFor()": [[0, 16]]}}}, {"text": "You can fix your code by removing the process.waitFor() line", "label": {"api": {"process.waitFor()": [[38, 54]]}}}, {"text": "According to this SO question, and ZonedDateTime's ofInstant(), one way is like so", "label": {"api": {"ZonedDateTime's ofInstant()": [[35, 61]]}}}, {"text": "Note that certain Longs are not required to be cached like certain Integers", "label": {"api": {"certain Longs are not required to be cached like certain Integers": [[10, 74]]}}}, {"text": "If you check SimpleDateFormat doc, you will see that there's no T in the format pattern", "label": {"api": {"SimpleDateFormat": [[13, 28]]}}}, {"text": "I thought I could easily outperform this by using ExecutorService instead of making new Threads constantly like", "label": {"api": {"ExecutorService": [[50, 64]]}}}, {"text": "In Oracle JDK the tasks are executed in the common ForkJoinPool pool which by default creates as many threads as many CPU cores you have", "label": {"api": {"common ForkJoinPool pool": [[44, 67]]}}}, {"text": "I think you're referring to java.util.TimeZone", "label": {"api": {"java.util.TimeZone": [[28, 45]]}}}, {"text": "You can loop all of your properties using the Properties class", "label": {"api": {"Properties": [[46, 55]]}}}, {"text": "PreparedStatement indexes are 1-based (see also setXX javadoc)", "label": {"api": {"setXX javadoc": [[48, 60]]}}}, {"text": "The method you are probably looking for is getKeyChar(), which does return 'h'", "label": {"api": {"getKeyChar()": [[43, 54]]}}}, {"text": "Alternatively, you can call KeyStroke.getKeyStroke('h', 0), which will specify the modifiers and thus will have a proper KeyCode value", "label": {"api": {"KeyStroke.getKeyStroke('h', 0)": [[28, 57]]}}}, {"text": "Also a CHM might be more appropriate", "label": {"api": {"CHM": [[7, 9]]}}}, {"text": "It's the constructor PrintWriter(String filename), which implies that \"$$$temp$$$.$$$\" is a filename of some type", "label": {"api": {"PrintWriter(String filename)": [[21, 48]]}}}, {"text": "While writing answers around SO, a user tried pointing out that java.io.File should not be used in new code, instead he argues that the the new object java.nio.Files should be used instead; he linked to this article", "label": {"api": {"Files": [[160, 164]], "File": [[72, 75], [160, 163]]}}}, {"text": "Now I have been developing in Java for several years now, and have not heard this argument before; since reading his post I have been searching, and have not found many other sources that confirm this, and personally, I feel like many of the points argued in the article are weak and that if you know how to read them, errors thrown by the File class will generally tell you exactly what the issue is", "label": {"api": {"File": [[340, 343]]}}}, {"text": "Is Files preferred over File for new code", "label": {"api": {"Files": [[3, 7]], "File": [[3, 6], [24, 27]]}}}, {"text": "LinkedList will work, and in fact implements the most stack-like interface in the JDK, Deque", "label": {"api": {"Deque": [[87, 91]]}}}, {"text": "ArrayDeque is the other main non-threadsafe implementation, and is probably more efficient if you only need the stack operations", "label": {"api": {"Deque": [[5, 9]], "ArrayDeque": [[0, 9]]}}}, {"text": "The above link for Deque lists the other two JDK-provided implementations, which are thread safe", "label": {"api": {"Deque": [[19, 23]]}}}, {"text": "You need to use Field::get to reflectively access the field", "label": {"api": {"Field::get": [[16, 25]]}}}, {"text": "You can also consider using a BitSet as suggested by yshavit", "label": {"api": {"BitSet": [[30, 35]]}}}, {"text": "As well as the boolean[] mentioned above, you might also consider a BitSet", "label": {"api": {"BitSet": [[68, 73]]}}}, {"text": "Since it is quite possible for the product to not be present, you could make ProductDB interface return an Optional of Product", "label": {"api": {"Optional": [[107, 114]]}}}, {"text": "Inside the get product function just get the Stream from products list, filter the elements that have desired productId and return the first", "label": {"api": {"Stream": [[45, 50]]}}}, {"text": "Here is the JavaDoc of the resolve function", "label": {"api": {"JavaDoc of the resolve function": [[12, 42]]}}}, {"text": "So, when it's time to go on line, actually have the golfer join a line, also known as a BlockingQueue", "label": {"api": {"BlockingQueue": [[88, 100]]}}}, {"text": "Pass the BlockingQueue into each Runnable as part of the constructor", "label": {"api": {"BlockingQueue": [[9, 21]]}}}, {"text": "The createArrayOf method was introduced in Java 1.6, but to the best of my knowledge it doesn't handle Oracle's PL/SQL associative arrays", "label": {"api": {"createArrayOf method": [[4, 23]]}}}, {"text": "If you don't need regular access to the entire \"row\", but just quick access to each cell you can use the built-in Map.Entry as your key", "label": {"api": {"Map.Entry": [[114, 122]]}}}, {"text": "If you are in a situation where you cannot pull in a third-party library easily, but you don't like the semantics of Map.Entry (which is written in terms of keys and values) you can write your own Pair class to have the same effect", "label": {"api": {"Map.Entry": [[117, 125]]}}}, {"text": "The Pattern documentation lists \\a as \"the bell character\", which means it will match a \\u0007 in the input", "label": {"api": {"Pattern documentation": [[4, 24]]}}}, {"text": "After reading a documentation of ParameterizedType interface I thought that an example of ParameterizedType's instance can be any parametrized type such as col in my code", "label": {"api": {"ParameterizedType": [[33, 49], [90, 106]]}}}, {"text": "Thus, what may be an instance of ParameterizedType", "label": {"api": {"ParameterizedType": [[33, 49]]}}}, {"text": "Similarly, a Field instance is used to represent a class member field of a certain type", "label": {"api": {"Field": [[13, 17]]}}}, {"text": "It doesn't mean that such a field would be an instance of Field", "label": {"api": {"Field": [[58, 62]]}}}, {"text": "From package java.util.concurrent JavaDoc", "label": {"api": {"package java.util.concurrent JavaDoc": [[5, 40]]}}}, {"text": "The easiest way would probably be to use String#split(String)", "label": {"api": {"String#split(String)": [[41, 60]]}}}, {"text": "You can use split function", "label": {"api": {"split": [[12, 16]]}}}, {"text": "You have to use Double.parseDouble function, as follows", "label": {"api": {"Double.parseDouble": [[16, 33]]}}}, {"text": "If reader is of type Scanner, then use Scanner#nextDouble instead to read the value as double and store it in your double variable", "label": {"api": {"Scanner#nextDouble": [[39, 56]]}}}, {"text": "decorate (wrap) the default FutureTask and override in your ExecutorService the newTaskFor() method returning your new class", "label": {"api": {"FutureTask": [[28, 37]], "newTaskFor()": [[80, 91]]}}}, {"text": "InputStream.read() returns the number of bytes read", "label": {"api": {"InputStream.read()": [[0, 17]]}}}, {"text": "To solve this you could define the mapping as HashMap<Character, Integer>, or use Character.getNumericValue instead of casting to int", "label": {"api": {"Character.getNumericValue": [[82, 106]]}}}, {"text": "For example initialize the array with Integer.MIN_VALUE and only handle values that are not equal to that value", "label": {"api": {"Integer.MIN_VALUE": [[38, 54]]}}}, {"text": "Could I ask about any example which uses getOwnerType() method where this method would return any Type object, but not a value \"null\"", "label": {"api": {"getOwnerType()": [[41, 54]]}}}, {"text": "This is a certain example of use getOwnerType() method which I found in Google", "label": {"api": {"getOwnerType()": [[33, 46]]}}}, {"text": "String#contains receives a plain CharacterSequence e.g", "label": {"api": {"String#contains": [[0, 14]]}}}, {"text": "The answer is in the Java 8 javadocs for yield", "label": {"api": {"Java 8 javadocs for yield": [[21, 45]]}}}, {"text": "For animations, use a Timer", "label": {"api": {"For animations, use a Timer": [[0, 26]]}}}, {"text": "In particular the problem in your case was probably the Month portion, which you can see from this part of the Javadoc for SimpleDateFormat", "label": {"api": {"Javadoc for SimpleDateFormat": [[111, 138]]}}}, {"text": "Specify the Locale to use in translating the name of the day of the week, “Thu”", "label": {"api": {"Locale": [[12, 17]]}}}, {"text": "You are in Italy (it says so in your profile); when I use Locale.Italy on my machine, I get the same error as you do", "label": {"api": {"Locale": [[58, 63]], "Locale.Italy": [[58, 69]]}}}, {"text": "If you specify Locale.US as in the below code, it should work", "label": {"api": {"Locale": [[15, 20]], "Locale.US": [[15, 23]]}}}, {"text": "I need to configure some attribute in ScriptEngine- or  ScriptContext-level, to be used in Java methods", "label": {"api": {"ScriptEngine": [[38, 49]], "ScriptContext": [[56, 68]]}}}, {"text": "So, how to get a reference to that ScriptContext in order to retrieve the value", "label": {"api": {"ScriptContext": [[35, 47]]}}}, {"text": "Create an Event listener of MouseEvent.ANY", "label": {"api": {"MouseEvent.ANY": [[28, 41]]}}}, {"text": "In addition to that create an AnimationTimer which runs permanently and checks if the mouse coordinates didn't change within an interval of \"delta\" ms", "label": {"api": {"AnimationTimer": [[30, 43]]}}}, {"text": "If you don't have to use a regular expression, you can make use of Java's built-in BreakIterator", "label": {"api": {"BreakIterator": [[83, 95]]}}}, {"text": "The following code shows an example of parsing sentences, however BreakIterator supports other forms of parsing (word, line, etc.)", "label": {"api": {"BreakIterator": [[66, 78]]}}}, {"text": "You can use an URLClassLoader to load classes dynamically from given folder", "label": {"api": {"URLClassLoader": [[15, 28]]}}}, {"text": "Since equals(...) is not a final method of Object, yes, it is very well be possible in a different situation", "label": {"api": {"equals(...)": [[6, 16]]}}}, {"text": "Integer, Boolean, etc.) and since these classes are final, you cannot extend them, thus a.equals(a) will always return true", "label": {"api": {"Integer": [[0, 6]], "Boolean": [[9, 15]]}}}, {"text": "The method keys() in Hashtable actually return Enumeration of keys", "label": {"api": {"keys()": [[11, 16]]}}}, {"text": "Hashtable is an old, outdated, class that existed in Java before the introduction of the standard collections framework in Java 1.2(!), and was retrofitted to adhere to the Map interface", "label": {"api": {"Hashtable": [[0, 8]], "Map": [[173, 175]]}}}, {"text": "keys() existed in the original Hashtable and returns an Enumaration of keys", "label": {"api": {"Hashtable": [[31, 39]], "Enumaration": [[56, 66]]}}}, {"text": "keySet() is more modern method that was introduced in the Map interface and returns a Set of the keys", "label": {"api": {"Map": [[58, 60]], "Set": [[3, 5], [86, 88]]}}}, {"text": "If you would like to use the code you pointed out, you can create the PrintWriter with the autoflush set to true, that will ensure that using one of the println, printf or format methods would flush the stream", "label": {"api": {"println": [[153, 159]], "printf": [[162, 167]], "format": [[172, 177]]}}}, {"text": "You cannot control a HashMap's ordering, as you've seen", "label": {"api": {"HashMap": [[21, 27]]}}}, {"text": "A LinkedHashMap is just a HashMap with a predictable iteration order - it's a step in the right direction, but it's still over-complicating things", "label": {"api": {"HashMap": [[8, 14], [26, 32]], "LinkedHashMap": [[2, 14]]}}}, {"text": "Java has a built-in interface for sorted maps (with the unsurprising name SortedMap), and a couple of implementation, the most popular one being a TreeMap", "label": {"api": {"SortedMap": [[74, 82]], "TreeMap": [[147, 153]]}}}, {"text": "You can set the default values for unavailable fields via DateTimeFormatterBuilder.parseDefaulting", "label": {"api": {"DateTimeFormatterBuilder.parseDefaulting": [[58, 97]]}}}, {"text": "See AtomicInteger (and other atomic primitives), it has method incrementAndGet()", "label": {"api": {"AtomicInteger": [[4, 16]], "atomic primitives": [[29, 45]], "incrementAndGet()": [[63, 79]]}}}, {"text": "Streams read/write bytes, while Readers read and Writers write character data", "label": {"api": {"read": [[8, 11], [40, 43]], "write": [[13, 17], [57, 61]], "Readers": [[32, 38]], "Writers": [[49, 55]]}}}, {"text": "Since underneath it all you always have bytes when doing I/O, this means that readers and writers do an additional step of converting bytes to characters", "label": {"api": {"read": [[78, 81]], "write": [[90, 94]], "converting": [[123, 132]]}}}, {"text": "One good reason is, for instance, that disk access is more efficient if you read/write a chunk of data at once, rather than reading/writing each byte/character individually", "label": {"api": {"read": [[76, 79], [124, 127]], "write": [[81, 85]]}}}, {"text": "Cast the first parameter to HttpServletRequest (if possible) and then call its getMethod() method", "label": {"api": {"HttpServletRequest": [[28, 45]], "getMethod()": [[79, 89]]}}}, {"text": "In this case, you could try to hunt down the source code of the getMethod() method above and do whatever it does in your own code", "label": {"api": {"getMethod()": [[64, 74]]}}}, {"text": "You can do it using String.format()", "label": {"api": {"String.format()": [[20, 34]]}}}, {"text": "You've got a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[13, 43]]}}}, {"text": "I suggest you use a CopyOnWriteArrayList instead of a classic ArrayList", "label": {"api": {"CopyOnWriteArrayList": [[20, 39]], "ArrayList": [[31, 39], [62, 70]]}}}, {"text": "We can try to improve on your solution with Stream.concat() and Stream.of()", "label": {"api": {"Stream.concat()": [[44, 58]], "Stream.of()": [[64, 74]]}}}, {"text": "If that's what you want, just use List.sublist() to truncate the last element from the list, e.g.", "label": {"api": {"List.sublist()": [[34, 47]]}}}, {"text": "See Pattern javadoc for more info", "label": {"api": {"Pattern javadoc": [[4, 18]]}}}, {"text": "To use the one already created you have to use the setController method of the FXMLLoader before loading the fxml file to use a controller instance you created yourself", "label": {"api": {"setController": [[51, 63]]}}}, {"text": "You probably want to use the ScheduledThreadPoolExecutor class", "label": {"api": {"ScheduledThreadPoolExecutor class": [[29, 61]]}}}, {"text": "What I search to do is to open a file using Desktop.open()", "label": {"api": {"Desktop.open()": [[44, 57]]}}}, {"text": "The simplest way to be more accurate involves the use of Timer which uses threads allowing for the printing and other overhead to be separated out from the timekeeping", "label": {"api": {"Timer": [[57, 61]]}}}, {"text": "However, it simply uses a less interesting but more simple explanation for the above which is Object.wait() which \"does not offer real-time guarantees\"", "label": {"api": {"Object.wait()": [[94, 106]]}}}, {"text": "This is a lambda expression for a Function", "label": {"api": {"Function": [[34, 41]]}}}, {"text": "The Stream.map() method takes a Function that can be applied to each element (Map.Entry) in the stream, and produces a stream of elements of a new type (WordComparable)", "label": {"api": {"Function": [[32, 39]]}}}, {"text": "If we read that code in plain English, we might say \"for each entry of my map, let's convert it to a WordComparable and add it to a list\"", "label": {"api": {"map": [[74, 76]]}}}, {"text": "Now, we can rephrase that sentence to \"for each entry of my map, let's convert it to a WordComparable, and when we have converted it all, let's make a list out of it\"", "label": {"api": {"map": [[60, 62]]}}}, {"text": "one that takes an entry of the map and converts it to a WordComparable", "label": {"api": {"map": [[31, 33]]}}}, {"text": "Java 8 introduces a new type named Function, which has one important method", "label": {"api": {"Function": [[35, 42]]}}}, {"text": "Writing good old Java, since Function is an interface, we can implement it to write our conversion code", "label": {"api": {"Function": [[29, 36]]}}}, {"text": "Java 8 also introduces the notion of Stream, that is to say, a sequence of elements (note that this sequence can be infinite)", "label": {"api": {"Stream": [[37, 42]]}}}, {"text": "We make use of the map method, whose goal is to apply a method on each element of the stream", "label": {"api": {"apply": [[48, 52]], "map": [[19, 21]], "stream": [[86, 91]]}}}, {"text": "EntryConverter, and we build a Stream of our entries using the stream method", "label": {"api": {"Stream": [[31, 36]], "stream": [[63, 68]]}}}, {"text": "collect all the elements into a List", "label": {"api": {"collect": [[0, 6]]}}}, {"text": "This is done using the collect method", "label": {"api": {"collect": [[23, 29]]}}}, {"text": "This method takes a Collector as argument, i.e", "label": {"api": {"Collector": [[20, 28]]}}}, {"text": "an object capable of reducing a stream into a final container", "label": {"api": {"stream": [[32, 37]]}}}, {"text": "Java 8 comes with a lot of prebuilt collectors; one of them being Collectors.toList()", "label": {"api": {"collect": [[36, 42]], "Collector": [[66, 74]], "Collectors.toList()": [[66, 84]]}}}, {"text": "This operator allows the creation of a Function much more painlessly than before", "label": {"api": {"Function": [[39, 46]]}}}, {"text": "The documentation for XPath#compile says that XPathExpressionException will be thrown \"If expression cannot be compiled\"", "label": {"api": {"The documentation for XPath#compile": [[0, 34]]}}}, {"text": "Similarly, the documentation for XPathExpression#evaluate says that XPathExpressionException will be thrown \"If the expression cannot be evaluated\"", "label": {"api": {"the documentation for XPathExpression#evaluate": [[11, 56]]}}}, {"text": "After some more digging I found Guava's SettableFuture and Java 8's CompletableFuture", "label": {"api": {"CompletableFuture": [[68, 84]]}}}, {"text": "If you want full precision, use BigDecimal instead", "label": {"api": {"BigDecimal": [[32, 41]]}}}, {"text": "ReentrantLock has an optional fairness parameter that can probably be used to implement your logic", "label": {"api": {"ReentrantLock": [[0, 12]]}}}, {"text": "The Java Accessibility API conveniently includes a getIndexAtPoint method as part of the AccessibleText interface that converts a location (such as that of the mouse pointer) to the index of the character at that location", "label": {"api": {"getIndexAtPoint": [[51, 65]]}}}, {"text": "label.getAccessibleContext().getAccessibleText() would return null, and using a forced cast of (AccessibleText) label.getAccessibleContext() would yield an object that only ever returned -1 from getIndexAtPoint", "label": {"api": {"getIndexAtPoint": [[195, 209]]}}}, {"text": "Because getIndexAtPoint returns an index relative only to the displayed characters, getting the desired substring is easier in the second example than my original one", "label": {"api": {"getIndexAtPoint": [[8, 22]]}}}, {"text": "From the API documentation of SimpleDateFormat (see the examples), the pattern to use in your case is", "label": {"api": {"SimpleDateFormat": [[30, 45]]}}}, {"text": "You're comparing it == 1, but compareTo's contract does not guarantee that it will be 1, just that it will be a positive number if s is greater than q, 0 if they're equal, or a negative number if s is less than q", "label": {"api": {"compareTo's contract": [[30, 49]]}}}, {"text": "I created a simple example using an ExecutorService and a BlockingQueue", "label": {"api": {"ExecutorService": [[36, 50]], "BlockingQueue": [[58, 70]]}}}, {"text": "SortedSet represents a set that is sorted according to some criterion (you could define your own Comparator), so take a look on implementations", "label": {"api": {"SortedSet": [[0, 8]]}}}, {"text": "TreeSet and ConcurrentSkipListSet", "label": {"api": {"TreeSet": [[0, 6]], "ConcurrentSkipListSet": [[12, 32]]}}}, {"text": "In addition to the SortedSet interface, there is also the LinkedHashSet class", "label": {"api": {"SortedSet": [[19, 27]], "LinkedHashSet": [[58, 70]]}}}, {"text": "LinkedHashSet is ordered, has predictable iteration order and allows to re-insert existing values (but without affecting insertion order)", "label": {"api": {"LinkedHashSet": [[0, 12]]}}}, {"text": "If they are correct, then, to delete the quotes you can use the String#replace method to replace all the double quotes with an empty", "label": {"api": {"String#replace": [[64, 77]]}}}, {"text": "Here's a trivial example that shows one way to filter a collection (In this case a List, like yours) in Java 8 by using a Stream (More information on using Streams can be found here)", "label": {"api": {"Stream": [[122, 127], [156, 161]]}}}, {"text": "See the iterator() JavaDoc", "label": {"api": {"iterator()": [[8, 17]]}}}, {"text": "Firstly you're calling fname.Length(3), which doesn't make sense as String doesn't have a Length(int n) method on it", "label": {"api": {"String": [[68, 73]]}}}, {"text": "What it does have is a substring(int) method and a length() method, which you can use as follows", "label": {"api": {"substring(int)": [[23, 36]], "length()": [[51, 58]]}}}, {"text": "As outlined in the linked JavaDocs, String.substring() \"Returns a new string that is a substring of this string", "label": {"api": {"String": [[36, 41]]}}}, {"text": "So if we can provide it with the index (or position) within the String fname where we want to start copying from", "label": {"api": {"String": [[64, 69]]}}}, {"text": "If I've got a String such as \"Chicken\", and I want the last 3 characters, I'd call \"Chicken\".substring(4), and the result would be \"ken\" (Strings are zero-indexed, so the character 'k' has index 4)", "label": {"api": {"String": [[14, 19], [138, 143]]}}}, {"text": "Instead of hard coding the index where I want to start the substring from, I use the String.length() method which tells me how long a String is, and subtract 3", "label": {"api": {"String": [[85, 90], [134, 139]], "length()": [[92, 99]]}}}, {"text": "In the above example, \"Chicken\".length() is 7, and so \"Chicken\".length() - 3 is the index where you should start substring-ing if you want the last 3 characters", "label": {"api": {"length()": [[32, 39], [64, 71]]}}}, {"text": "change your model and use LocalDate (on Java 8) or Date (pre Java 8) as data type", "label": {"api": {"LocalDate": [[26, 34]]}}}, {"text": "Alternatively (not recommended), you can convert the Strings to LocalDate upon comparison (which inherently is slower)", "label": {"api": {"LocalDate": [[64, 72]]}}}, {"text": "At the time paintThumb() is called, BasicSliderUI has already calculated thumbRect based on the result of getThumbSize()", "label": {"api": {"BasicSliderUI": [[36, 48]]}}}, {"text": "I have Sample.class file and Sample Class object at runtime, Then I modify a method body in A.class and redefine it with redefineClasses", "label": {"api": {"redefineClasses": [[121, 135]]}}}, {"text": "That said, this article shows how to wrap the resultset with an Iterator (ResultSetIterator) and pass it as the first parameter to Spliterators.spliteratorUnknownSize() in order to create a Spliterator", "label": {"api": {"Spliterators.spliteratorUnknownSize()": [[131, 167]], "Spliterator": [[131, 141], [190, 200]]}}}, {"text": "The Spliterator can then be used by StreamSupport in order to create a Stream on top of it", "label": {"api": {"Spliterator": [[4, 14]], "StreamSupport": [[36, 48]]}}}, {"text": "You should be able to do this with Stream's anyMatch method and a Predicate that performs the necessary side effect of Records.emit, etc", "label": {"api": {"anyMatch method": [[44, 58]]}}}, {"text": "The anyMatch method is a short-circuiting operation that will stop processing when the Predicate returns true", "label": {"api": {"anyMatch method": [[4, 18]]}}}, {"text": "You can use Integer.parseInt(String str, int radix), with radix being 2 for binary, 8 for octal, 10 for decimal and 16 for hexadecimal", "label": {"api": {"Integer.parseInt(String str, int radix)": [[12, 50]]}}}, {"text": "You know that this is not going to throw a ClassCastException because you just checked that it is assignable", "label": {"api": {"ClassCastException": [[43, 60]]}}}, {"text": "The relevant bit of the documentation for Serializable", "label": {"api": {"Serializable": [[42, 53]]}}}, {"text": "It is an error to declare a class Serializable if this is not the case", "label": {"api": {"Serializable": [[34, 45]]}}}, {"text": "Your superclass (ImmutableRangeMap) does not have a no-arg constructor and is not Serializable", "label": {"api": {"Serializable": [[82, 93]]}}}, {"text": "There is no requirement to have a no-arg constructor for Serializable classes (such as SerializableImmutableRangeMap)", "label": {"api": {"Serializable": [[57, 68], [87, 98]]}}}, {"text": "I would use BufferedReader, it reads buffered", "label": {"api": {"BufferedReader": [[12, 25]]}}}, {"text": "You can use Character.toUpperCase(char ch)", "label": {"api": {"Character.toUpperCase(char ch)": [[12, 41]]}}}, {"text": "I've see in SocksSocketImpl.connect(SocketAddress, int) that the order of ProxySelector.select(URI) does matter", "label": {"api": {"ProxySelector.select(URI)": [[74, 98]]}}}, {"text": "Use a JSplitPane as your contentPane of jFrame is the better way", "label": {"api": {"JSplitPane": [[6, 15]]}}}, {"text": "I have a hunch this answer by might be use of a Supplier", "label": {"api": {"Supplier": [[48, 55]]}}}, {"text": "Instead of going through all those hoops, just use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[53, 69]]}}}, {"text": "Alternatively, synchronized all access using Collections.synchronizedSet", "label": {"api": {"Collections.synchronizedSet": [[45, 71]]}}}, {"text": "Primarily, ConcurrentHashMap will not lock while querying the set (contains(), iteration, ...)", "label": {"api": {"ConcurrentHashMap": [[11, 27]]}}}, {"text": "Java provides a TreeMap which will allow you to specify a comparator in which it will sort your input", "label": {"api": {"TreeMap": [[16, 22]]}}}, {"text": "To use the TreeMap in a traditional way, you will need to do something like so", "label": {"api": {"TreeMap": [[11, 17]]}}}, {"text": "If I've understood you correctly, couldn't you use Collectors.toMap(Function<> keyMapper, Function<> valueMapper) collector, like the following", "label": {"api": {"Collectors.toMap(Function<> keyMapper, Function<> valueMapper)": [[51, 112]]}}}, {"text": "You can use toArray with an extra array as parameter", "label": {"api": {"toArray": [[12, 18]]}}}, {"text": "In Java-8 it's reasonable to provide a Supplier and use computeIfAbsent", "label": {"api": {"computeIfAbsent": [[56, 70]]}}}, {"text": "Note that unlike containsKey/put solutions using computeIfAbsent is safe for concurrent maps", "label": {"api": {"computeIfAbsent": [[49, 63]]}}}, {"text": "SelectionMode.MULTIPLE \"Allows for one or more contiguous range of indices to be selected at a time.\" Try shift, alt or ⌘ clicking multiple items to see the effect", "label": {"api": {"SelectionMode.MULTIPLE": [[0, 21]]}}}, {"text": "If you need an InputStream that contains both the headers and the content, write it to a file and then read it back in, or use a PipedInputStream and a thread", "label": {"api": {"PipedInputStream": [[129, 144]]}}}, {"text": "What the class SimpleDateFormat does is conversion between the classes String and Date according to your specifications", "label": {"api": {"SimpleDateFormat": [[15, 30]], "String": [[71, 76]], "Date": [[21, 24], [82, 85]]}}}, {"text": "But the resulting Date object is unaware of the SimpleDateFormat it was created by", "label": {"api": {"SimpleDateFormat": [[48, 63]], "Date": [[18, 21], [54, 57]]}}}, {"text": "When you pass a Date to println, it will appear in the default date format", "label": {"api": {"Date": [[16, 19]]}}}, {"text": "When you want to use your custom SimpleDateFormat also for formating the output, you need to use it again for converting the Date to a String", "label": {"api": {"SimpleDateFormat": [[33, 48]], "String": [[135, 140]], "Date": [[39, 42], [125, 128]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "Prefer using a ScheduledExecutorService over Timer", "label": {"api": {"ScheduledExecutorService": [[15, 38]]}}}, {"text": "Check out FocusTraversalPolicy", "label": {"api": {"FocusTraversalPolicy": [[10, 29]]}}}, {"text": "Instead of trying to figure out if a certain & is part of a value or an argument delimiter, encode the values before sending them to your app (e.g., by using URLEncoder), and decode it on the other side", "label": {"api": {"URLEncoder": [[158, 167]]}}}, {"text": "According to the Javadocs for SimpleDateFormat", "label": {"api": {"Javadocs for SimpleDateFormat": [[17, 45]]}}}, {"text": "You must use String.equals() to check for String equality, as outlined in this answer", "label": {"api": {"String.equals()": [[13, 27]]}}}, {"text": "System.out.println prints the text and adds a new line", "label": {"api": {"System.out.println": [[0, 17]], "System.out.print": [[0, 15]]}}}, {"text": "Use System.out.print to print on the same line instead", "label": {"api": {"System.out.print": [[4, 19]]}}}, {"text": "System.out.println(okidokiObject) prints Gangsta.okidoki@659e0bfd because it is the hashcode of your object (Hashcode is something like an ID, See Object toString())", "label": {"api": {"Object toString()": [[147, 163]]}}}, {"text": "Math.random() returns a double value between 0 (inclusive) and 1 (exclusive)", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "Therefore, when you take the number produced by Math.random() modulo 10, it returns the same double value", "label": {"api": {"Math.random()": [[48, 60]]}}}, {"text": "What you really want is to use a Random object and use Random.nextInt(bound)", "label": {"api": {"Random.nextInt(bound)": [[55, 75]]}}}, {"text": "The Math.random() method returns a random double that is from 0 (inclusive) to 1 (exclusive)", "label": {"api": {"Math.random()": [[4, 16]]}}}, {"text": "If you want a random number from 0-9, you can multiply Math.random() by 10, instead of taking the remainder when divided by 10", "label": {"api": {"Math.random()": [[55, 67]]}}}, {"text": "Alternatively, you can create a java.util.Random object and call nextInt(10)", "label": {"api": {"nextInt(10)": [[65, 75]]}}}, {"text": "There are more advanced techniques for dispatching work every so often, like ScheduledExecutorService, which you could also consider using", "label": {"api": {"ScheduledExecutorService": [[77, 100]]}}}, {"text": "Make sendQueue a LinkedBlockingQueue, and use poll timeouts", "label": {"api": {"LinkedBlockingQueue": [[17, 35]]}}}, {"text": "The JVM terminates when the last non-daemon thread finishes", "label": {"api": {"when the last non-daemon thread": [[19, 49]]}}}, {"text": "If you have only a Class object, how does one get a method reference to a method such as toString", "label": {"api": {"Class": [[19, 23]]}}}, {"text": "For example, consider a Java enum, a subclass of Enum", "label": {"api": {"Enum": [[49, 52]]}}}, {"text": "Here T is defined as <T extends Enum>", "label": {"api": {"Enum": [[32, 35]]}}}, {"text": "You can use String.contains", "label": {"api": {"String.contains": [[12, 26]]}}}, {"text": "Although IMO it does not provide clear information, please check this link about CSS inheritance", "label": {"api": {"this link": [[65, 73]]}}}, {"text": "Use copy-on-write list", "label": {"api": {"copy-on-write": [[4, 16]]}}}, {"text": "The field you use as a constant (java.sql.Types.INTEGER) is a int (public static final int INTEGER) as all the rest of constant values in java.sql.Types, and thats why your code works when you put 0 (maybe 0 value is the same than java.sql.Types.INTEGER or another Number type)", "label": {"api": {"java.sql.Types": [[33, 46], [138, 151], [231, 244]]}}}, {"text": "Class java.nio.file.Files contains several utility methods to copy files (new since Java 7)", "label": {"api": {"java.nio.file.Files": [[6, 24]]}}}, {"text": "What you're looking for is provided by other Java concurrency primitives like CountDownLatch, Phaser or Semaphore", "label": {"api": {"CountDownLatch": [[78, 91]], "Phaser": [[94, 99]], "Semaphore": [[104, 112]]}}}, {"text": "There is no problem implementing arbitrary wait/notify mechanisms using LockSupport.park() and LockSupport.unpark(Thread) as these basic primitives do not require holding any locks", "label": {"api": {"LockSupport.park()": [[72, 89]], "LockSupport.unpark(Thread)": [[95, 120]]}}}, {"text": "The reason why neither Object.wait/Object.notify nor Condition.await/Condition.signal offer you such a notification without holding a lock is a semantic one", "label": {"api": {"Condition": [[53, 61], [69, 77]]}}}, {"text": "You are using a CyclicBarrier incorrectly", "label": {"api": {"CyclicBarrier": [[16, 28]]}}}, {"text": "CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "You probably need to use a Semaphore although I am not sure what you need", "label": {"api": {"Semaphore": [[27, 35]]}}}, {"text": "However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly", "label": {"api": {"Semaphore": [[48, 56]]}}}, {"text": "You might be looking for an AtomicInteger", "label": {"api": {"AtomicInteger": [[28, 40]]}}}, {"text": "An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer", "label": {"api": {"AtomicInteger": [[3, 15]]}}}, {"text": "Convert the WAR resource path to an absolute disk file system path with help of ServletContext#getRealPath()", "label": {"api": {"ServletContext#getRealPath()": [[80, 107]]}}}, {"text": "In case none of above options apply, your last resort is creating a temporary file with help of File#createTempFile() in container managed temporary folder, grabbing the WAR resource contents by ServletContext#getResourceAsStream(), writing it to the temp file and finally provide the absolute temp file path", "label": {"api": {"File#createTempFile()": [[96, 116]], "ServletContext#getResourceAsStream()": [[195, 230]]}}}, {"text": "In case you're using JSF — as confirmed by the stack trace — you can obtain the ServletContext by ExternalContext#getContext(), the HttpServletRequest by ExternalContext#getRequest(), the ServletContext attributes by ExternalContext#getApplicationMap(), the real path by ExternalContext#getRealPath(), and the resource stream by ExternalContext#getResourceAsStream()", "label": {"api": {"ExternalContext#getContext()": [[98, 125]], "ExternalContext#getRequest()": [[154, 181]], "ExternalContext#getApplicationMap()": [[217, 251]], "ExternalContext#getRealPath()": [[271, 299]], "ExternalContext#getResourceAsStream()": [[329, 365]]}}}, {"text": "Take a look at the javadoc for ConcurrentMap", "label": {"api": {"javadoc for ConcurrentMap": [[19, 43]]}}}, {"text": "It simply complies to the the contract of ConcurrentMap which ensures that concurrent modifications are possible", "label": {"api": {"ConcurrentMap": [[42, 54]]}}}, {"text": "ConcurrentHashMap does not block when performing retrieval operations, and there is no locking for the usual operations", "label": {"api": {"ConcurrentHashMap does not block when performing retrieval operations, and there is no locking for the usual operations": [[0, 118]]}}}, {"text": "I think maybe you can look at HashMap, then you can write your code like", "label": {"api": {"HashMap": [[30, 36]]}}}, {"text": "From ConcurrentHashMap javadoc", "label": {"api": {"ConcurrentHashMap javadoc": [[5, 29]]}}}, {"text": "Instead, you can operate on each value using forEach by doing  something like this", "label": {"api": {"forEach": [[45, 51]]}}}, {"text": "In your case, you can get the value inside Stuff using .map, and then operate on it using forEach, like this", "label": {"api": {"forEach": [[90, 96]], ".map": [[55, 58]]}}}, {"text": "Why not use the built in Java ImageIO", "label": {"api": {"ImageIO": [[30, 36]]}}}, {"text": "The Timer is by far the better option of the two, however I would recommend you use a SwingWorker instead", "label": {"api": {"SwingWorker": [[86, 96]]}}}, {"text": "However, because your task is long running, you should probably use a SwingWorker, as it is useful for long running tasks related to the Swing GUI", "label": {"api": {"SwingWorker": [[70, 80]]}}}, {"text": "A SwingWorker is able to keep the GUI responsive while performing your task", "label": {"api": {"SwingWorker": [[2, 12]]}}}, {"text": "Use RequestDispatcher method and get the attributes", "label": {"api": {"RequestDispatcher": [[4, 20]]}}}, {"text": "How about the existing interface java.util.concurrent.Callable<V>", "label": {"api": {"java.util.concurrent.Callable<V>": [[33, 64]]}}}, {"text": "This is only mostly important if the objects implement Comparable", "label": {"api": {"implement Comparable": [[45, 64]]}}}, {"text": "I've added a JPanel in between, and given it BorderLayout", "label": {"api": {"BorderLayout": [[45, 56]]}}}, {"text": "I'm using setSize and setPreferredSize on the JLabel so that the layout managers can properly choose good sizes for the controls, and so that frame.pack works as expected", "label": {"api": {"frame.pack": [[142, 151]]}}}, {"text": "Check out the Scanner API", "label": {"api": {"API": [[22, 24]]}}}, {"text": "You should check out the String API for options to either force all of your input to one case, maybe while reading the file, or use a different flavor of a compare to method", "label": {"api": {"API": [[32, 34]]}}}, {"text": "You will need to fix your Comparator's logic according to the compare method's contract", "label": {"api": {"the compare method's contract": [[58, 86]]}}}, {"text": "This will return an Optional which might or might not contain a value", "label": {"api": {"Optional": [[20, 27]]}}}, {"text": "If you want to get rid of the Optional altogether", "label": {"api": {"Optional": [[30, 37]]}}}, {"text": "In Java, this translates a string to a byte array byte[]", "label": {"api": {"byte[]": [[50, 55]]}}}, {"text": "Instead of explicitly creating threads, feed Runnable tasks into a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[67, 84]]}}}, {"text": "The ThreadPoolExecutor constructors expect BlockingQueues, so that Executors creates instances also with other implementations of BlockingQueue, like SynchronousQueue or ArrayBlokingQueue (depending on the factory method you call in Executors)", "label": {"api": {"constructors": [[23, 34]]}}}, {"text": "E.g a method tell if an element could be inserted in the queue without violating the capacity restrictions (and without throwing Exception, check BlockingQueue.offer())", "label": {"api": {"BlockingQueue.offer()": [[146, 166]]}}}, {"text": "Your JavaFX Application is correctly synchronized in that \"modification of scene graph operations to live objects (those objects already attached to a scene) must be done on the JavaFX application thread.\" You can override init() to do other initialization or to  construct JavaFX objects other than a Scene or a Stage", "label": {"api": {"Application": [[12, 22]]}}}, {"text": "You could combine .flatMap and .map", "label": {"api": {".flatMap": [[18, 25]], ".map": [[31, 34]]}}}, {"text": "See the documentation for JFrame", "label": {"api": {"documentation for JFrame": [[8, 31]]}}}, {"text": "In our case, it was a Deflater and Inflater not properly ended", "label": {"api": {"Deflater": [[22, 29]], "Inflater": [[35, 42]]}}}, {"text": "This is also explained in the Javadoc of class Thread", "label": {"api": {"Javadoc of class Thread": [[30, 52]]}}}, {"text": "You could then just check whether your alternative button is selected by using JButton#isSelected() to then (de)select your button group using ButtonGroup#setSelected(ButtonModel,boolean)", "label": {"api": {"JButton#isSelected()": [[79, 98]], "ButtonGroup#setSelected(ButtonModel,boolean)": [[143, 186]]}}}, {"text": "Java uses these characters as digits for numbers in bases 2 through 36", "label": {"api": {"uses": [[5, 8]]}}}, {"text": "You can do this using the java.time classes built into Java 8 and later", "label": {"api": {"java.time": [[26, 34]]}}}, {"text": "As you are using Java 8, consider the Integer.parseUnsignedInt method", "label": {"api": {"Integer.parseUnsignedInt": [[38, 61]]}}}, {"text": "I also normally use ProcessBuilder", "label": {"api": {"ProcessBuilder": [[20, 33]]}}}, {"text": "The Java client is using the java.net.Socket class which provides TCP communication", "label": {"api": {"java.net.Socket": [[29, 43]]}}}, {"text": "On the other hand, the java.net.DatagramSocket class is used for UDP communication", "label": {"api": {"java.net.DatagramSocket": [[23, 45]]}}}, {"text": "Beginning with Java 7, you should use System.lineSeparator() instead of hard coding \\n, since the line separator really depends on which machine the code will run", "label": {"api": {"System.lineSeparator()": [[38, 59]]}}}, {"text": "If you fear that the XML's data may change, you might consider using the WatchService API to detect changes and re-parse the XML file", "label": {"api": {"WatchService": [[73, 84]]}}}, {"text": "If the Optional is not set, map will return the same unset Optional", "label": {"api": {"Optional": [[7, 14], [59, 66]], "map": [[28, 30]]}}}, {"text": "Otherwise, it will map it to an Optional containing the result of getName()", "label": {"api": {"Optional": [[32, 39]], "map": [[19, 21]]}}}, {"text": "Then we can use orElse to return a default value when the Optional is unset", "label": {"api": {"Optional": [[58, 65]], "orElse": [[16, 21]]}}}, {"text": "The compiler won't quite agree to that, because the Javadocs for getClass() state", "label": {"api": {"Javadocs for getClass()": [[52, 74]]}}}, {"text": "You might find it beneficial to read up more on Strings", "label": {"api": {"Strings": [[48, 54]]}}}, {"text": "Or better yet, use the built-in Arrays.copyOfRange", "label": {"api": {"Arrays.copyOfRange": [[32, 49]]}}}, {"text": "I have a server with a DatagramSocket bound to the \"ANY\" wildcard address (using the DatagramSocket(int) constructor)", "label": {"api": {"DatagramSocket": [[23, 36], [85, 98]], "DatagramSocket(int)": [[85, 103]]}}}, {"text": "Is there any way to fix this problem in Java, other than binding a separate DatagramSocket for every address", "label": {"api": {"DatagramSocket": [[76, 89]]}}}, {"text": "is designed to be the lowest level and most efficient way to read XML data\", according to Oracle", "label": {"api": {"according to Oracle": [[77, 95]]}}}, {"text": "You should use SwingWorker instead of a Thread to manipulate Swing components asynchronously", "label": {"api": {"SwingWorker": [[15, 25]]}}}, {"text": "The SwingWorker gives you a method \"process\" which you can use to make actions gradually, and a \"done\" method to finish your processing, both of these methods are safe to handle the event dispatch thread", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "The documentation for Random.nextInt says", "label": {"api": {"Random.nextInt": [[22, 35]]}}}, {"text": "In this case, you are calling Random.nextInt with a value of 366 (365 + 1), so that means that you are effectively reading some random number between 0 and 365", "label": {"api": {"Random.nextInt": [[30, 43]]}}}, {"text": "Java Date has millisecond precision so I've been creating the Gson object like so", "label": {"api": {"Date": [[5, 8]]}}}, {"text": "To explain why your pattern didn't work, you used z (lowercase z) which according to the documentation represents a General Timezone (e.g., Pacific Standard Time; PST; GMT-08:00)", "label": {"api": {"General Timezone": [[116, 131]]}}}, {"text": "Additionally, if you were to use Z (uppercase Z), it would also not work since it represents an RFC 822 time zone (e.g., -0800)", "label": {"api": {"RFC 822 time zone": [[96, 112]]}}}, {"text": "In another scenario where instead of the Z you have a time zone offset (e.g., -08, -0800, or -08:00), you can use X, XX, or XXX to represent an ISO 8610 time zone", "label": {"api": {"ISO 8610 time zone": [[144, 161]]}}}, {"text": "It's also worth looking at java.sql.Timestamp class which is also supported by Gson and has more fine grained precision (nanoseconds) but it's also an option I haven't explored", "label": {"api": {"java.sql.Timestamp": [[27, 44]]}}}, {"text": "Java 8 Instant class can be used to easily parse ISO-8601 timestamps without explicitly setting a format string, for example", "label": {"api": {"Instant": [[7, 13]]}}}, {"text": "Use Arrays class copyOfRange method", "label": {"api": {"copyOfRange": [[17, 27]]}}}, {"text": "In this case, the wrapper that is most suited to your purposes is DataInputStream, which has a readFully method that seems to be what you want; the code is much simpler and shorter", "label": {"api": {"readFully": [[95, 103]]}}}, {"text": "Mind you, Swing interprets a pretty old version of HTML, that doesn't meet today's standards", "label": {"api": {"old version": [[36, 46]]}}}, {"text": "If resources is in classpath, you can find for the image at classpath, using getResource(String name) or getResourceAsStream(String name)", "label": {"api": {"getResource(String name)": [[77, 100]], "getResourceAsStream(String name)": [[105, 136]]}}}, {"text": "The reason that the first version crashes is that calling to Scanner.close - also closes the underlying stream", "label": {"api": {"Scanner.close": [[61, 73]]}}}, {"text": "It can be proved by wrapping System.in with a class that doesn't do anything in close() method (the code for UnClosableDecorator was taken from here)", "label": {"api": {"System.in": [[29, 37]]}}}, {"text": "what you need is a Future", "label": {"api": {"Future": [[19, 24]]}}}, {"text": "Integer.parseInt returns an int", "label": {"api": {"Integer.parseInt": [[0, 15]]}}}, {"text": "This is covered in the Class and java.lang.reflect package documentation", "label": {"api": {"Class": [[23, 27]], "java.lang.reflect package": [[33, 57]]}}}, {"text": "You get the field via getDeclaredField, then force it accessible using setAccessible, then use the relevant getXyz method from Field (getInt, getString, whatever) to get its value", "label": {"api": {"getDeclaredField": [[22, 37]], "setAccessible": [[71, 83]], "Field": [[33, 37], [127, 131]]}}}, {"text": "I think you might need simple Dialog or Alert", "label": {"api": {"Dialog": [[30, 35]], "Alert": [[40, 44]]}}}, {"text": "If you don't like how default Java Dialogs look, you can extend DialogPane (or Dialog itself), design it in FXML and setDialogPane to your Dialog", "label": {"api": {"Dialog": [[35, 40], [64, 69], [79, 84], [120, 125], [139, 144]]}}}, {"text": "Here is how to create, show and get result from simple Alert without any fancy looks", "label": {"api": {"Alert": [[55, 59]]}}}, {"text": "So if you want confirmation from user, just put Alert into onCloseRequest handling and consume the event if he makes up his mind (clicks to cancel)", "label": {"api": {"Alert": [[48, 52]]}}}, {"text": "From javadoc of Collections.binarySearch(List, T, Comparator)", "label": {"api": {"Collections.binarySearch(List, T, Comparator)": [[16, 60]]}}}, {"text": "The ProcExecutor opens an OracleConnection, creates a CallableStatement from the OracleConnection and JobRequest, executes the CallableStatement, and closes everything", "label": {"api": {"CallableStatement": [[54, 70], [127, 143]]}}}, {"text": "The problem I'm having is that I want the Worker to retry the job execution (using an ExponentialBackoffPolicy from Spring-Retry with an initial period of 500ms, a final period of 30,000ms, and unlimited retries - the user can intervene and cancel the retry loop if they wish) if the exception is transient, and to log the exception and exit the Worker if the exception is fatal", "label": {"api": {"transient": [[297, 305]]}}}, {"text": "At present I'm using pingDatabase to test for transient faults", "label": {"api": {"transient": [[46, 54]]}}}, {"text": "Is there a better way of distinguishing between transient and non-transient faults", "label": {"api": {"transient": [[48, 56], [66, 74]], "non-transient": [[62, 74]]}}}, {"text": "I realize that SQLException has subclasses for transient and non-transient faults, but I'm unclear as to how I should treat subclasses such as SQLRecoverableException, e.g", "label": {"api": {"transient": [[47, 55], [65, 73]], "non-transient": [[61, 73]], "SQLRecoverableException": [[143, 165]]}}}, {"text": "retry a fixed number of times with a fixed retry period or else treat as a non-transient fault, or whether SQLWarning even needs to be retried at all", "label": {"api": {"transient": [[79, 87]], "non-transient": [[75, 87]], "SQLWarning": [[107, 116]]}}}, {"text": "If all of the Workers are encountering transient faults then ideally I'd like to pause all but one of them until the problem clears up", "label": {"api": {"transient": [[39, 47]]}}}, {"text": "See the PrintWriter's JavaDoc", "label": {"api": {"PrintWriter's JavaDoc": [[8, 28]]}}}, {"text": "PrintStream.printf(), String.format(), Method.invoke()", "label": {"api": {"PrintStream.printf()": [[0, 19]], "String.format()": [[22, 36]], "Method.invoke()": [[39, 53]]}}}, {"text": "All you can do is setting some application-specific flag or call Thread.interrupt(), but even that does not guarantee that the thread terminates", "label": {"api": {"the thread terminates": [[123, 143]]}}}, {"text": "This will call the new String(char[]) constructor", "label": {"api": {"new String(char[])": [[19, 36]]}}}, {"text": "A Random is not a random number", "label": {"api": {"Random": [[2, 7]]}}}, {"text": "A Random is a random number generator", "label": {"api": {"Random": [[2, 7]]}}}, {"text": "So if you want to get numbers to compare, you have to use one of the methods in Random to get the generator to generate a number", "label": {"api": {"Random": [[80, 85]]}}}, {"text": "You can use DecimalFormat, just set the RoundingMode", "label": {"api": {"RoundingMode": [[40, 51]]}}}, {"text": "From javadoc of ArrayList", "label": {"api": {"ArrayList": [[16, 24]]}}}, {"text": "Since missiles is an ArrayList, you can iterate using indexes (int i and int j) and then remove using missiles.remove(i) and missiles.remove(j)", "label": {"api": {"ArrayList": [[21, 29]]}}}, {"text": "CLOB columns, according to h2's documentation, are mapped to the Java java.sql.Clob type", "label": {"api": {"java.sql.Clob": [[70, 82]]}}}, {"text": "So the proper way to get just the content of the CLOB, not a \"description\" of it, is to use one of the methods of the java.sql.Clob type", "label": {"api": {"java.sql.Clob": [[118, 130]]}}}, {"text": "indexOf - Returns the index within this string of the first occurrence of the specified character", "label": {"api": {"indexOf": [[0, 6]]}}}, {"text": "substring - Returns a string that is a substring of this string", "label": {"api": {"substring": [[0, 8], [39, 47]]}}}, {"text": "And MapKeyJoinColumns/MapKeyJoinColumn will be skipped in this case, refer to the JPA document https://docs.oracle.com/javaee/6/api/javax/persistence/MapKeyJoinColumn.html I guess they're used for entity only", "label": {"api": {"https://docs.oracle.com/javaee/6/api/javax/persistence/MapKeyJoinColumn.html": [[95, 170]]}}}, {"text": "Use either command line arguments or the Scanner class", "label": {"api": {"Scanner class": [[41, 53]]}}}, {"text": "Given that you are using ExecutorService you could use submit instead of execute and store the returned Future in a list", "label": {"api": {"submit": [[55, 60]]}}}, {"text": "(This approach will also let you cancel the submitted tasks if required, through the Futures)", "label": {"api": {"submit": [[44, 49]]}}}, {"text": "See the java.util.GregorianCalendar#equals Javadoc", "label": {"api": {"java.util.GregorianCalendar#equals": [[8, 41]]}}}, {"text": "My answer uses the Scanner class and hopefully you find it helpful", "label": {"api": {"Scanner class": [[19, 31]]}}}, {"text": "This is possible using the mergeFunction parameter of Collectors.toMap(keyMapper, valueMapper, mergeFunction)", "label": {"api": {"Collectors.toMap(keyMapper, valueMapper, mergeFunction)": [[54, 108]]}}}, {"text": "There is the method File#setWritable(boolean) you could use", "label": {"api": {"File#setWritable(boolean)": [[20, 44]]}}}, {"text": "Probably the easiest way to handle storing a collection of objects is by using one of the Collections provided by Java", "label": {"api": {"Collections": [[90, 100]]}}}, {"text": "Check collections API", "label": {"api": {"Check collections API": [[0, 20]]}}}, {"text": "If you look at actual SimpleDateFormat API reference, you will see, that there are no such patterns (for yesterday, today) defined", "label": {"api": {"SimpleDateFormat": [[22, 37]]}}}, {"text": "Use add instead of set", "label": {"api": {"set": [[19, 21]]}}}, {"text": "You can not set (replace) an item that does not exist", "label": {"api": {"set": [[12, 14]]}}}, {"text": "From the docs on set", "label": {"api": {"set": [[17, 19]]}}}, {"text": "As expected per PriorityQueue.add Javadoc, this code throws a ClassCastException because the object is not comparable", "label": {"api": {"PriorityQueue.add": [[16, 32]]}}}, {"text": "This means the a StackOverflowError will be thrown", "label": {"api": {"StackOverflowError": [[17, 34]]}}}, {"text": "But because you are catching it (StackOverflowError is not an exception, it is java.lang.Error, which is a java.lang.Throwable) the application will not stop, it will continue recursing, it will not stop at all", "label": {"api": {"StackOverflowError": [[33, 50]]}}}, {"text": "As expected per PriorityQueue.add Javadoc, a ClassCastException is thrown because the second object is not comparable to the first one", "label": {"api": {"PriorityQueue.add": [[16, 32]]}}}, {"text": "To print in the same line, use System.out.print() instead of println", "label": {"api": {"System.out.print()": [[31, 48]]}}}, {"text": "You can store your As, Bs and Cs in ArrayList and then print them out", "label": {"api": {"ArrayList": [[36, 44]]}}}, {"text": "This code will be equals for the ArrayList of Bs and Cs (of course, the specific parts of each ArrayList have to change)", "label": {"api": {"ArrayList": [[33, 41], [95, 103]]}}}, {"text": "Change count to an AtomicInteger, which encapsulates such operations atomically on its own", "label": {"api": {"AtomicInteger": [[19, 31]]}}}, {"text": "I recommend GroupLayout", "label": {"api": {"GroupLayout": [[12, 22]]}}}, {"text": "Once you get used to it, nothing gives you the type of control for resizing components that GroupLayout does", "label": {"api": {"GroupLayout": [[92, 102]]}}}, {"text": "Use System.out.println() instead of System.out.print()", "label": {"api": {"System.out.println()": [[4, 23]]}}}, {"text": "Though I have not tried but IMO you can use the following constructor", "label": {"api": {"constructor": [[58, 68]]}}}, {"text": "Quoting javadoc of BufferedWriter.close()", "label": {"api": {"BufferedWriter.close()": [[19, 40]]}}}, {"text": "Closeable and AutoCloseable are general-purpose interfaces that do not know anything about flushing", "label": {"api": {"Closeable": [[0, 8], [18, 26]], "AutoCloseable": [[14, 26]]}}}, {"text": "A Writer on the other hand is a more specific-purpose abstract class that now knows something about flushing", "label": {"api": {"Writer": [[2, 7]]}}}, {"text": "Some excerpt of the documentation for the method Writer.close()", "label": {"api": {"Writer": [[49, 54]], "Writer.close()": [[49, 62]]}}}, {"text": "In java 8 the getOrDefault method is added to the Map interface", "label": {"api": {"getOrDefault": [[14, 25]]}}}, {"text": "I'm looking for a client-side JavaScript library that would let me write code similar to what I can do in other languages using some flavour of Option type, for example java.lang.Optional", "label": {"api": {"java.lang.Optional": [[169, 186]]}}}, {"text": "Such as blocking the publisher on a CountDownLatch which the event handler counts down", "label": {"api": {"CountDownLatch": [[36, 49]]}}}, {"text": "You could implement ThreadFactory to construct the custom Thread classes and supply a ThreadGroup instance to get the counts from", "label": {"api": {"ThreadFactory": [[20, 32]]}}}, {"text": "By using ThreadFactory, each instance could contain its own ThreadGroup, making counts accessible based on the factory used", "label": {"api": {"ThreadFactory": [[9, 21]]}}}, {"text": "Consider using ConcurrentHashMap if that will meet your use case", "label": {"api": {"ConcurrentHashMap": [[15, 31]]}}}, {"text": "If the only access is the put() call shown, then it's better to use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[70, 86]]}}}, {"text": "Since JavaFX 8u40, there is indeed an Alert class", "label": {"api": {"Alert": [[38, 42]]}}}, {"text": "Use your own implementation of BlockingQueue (like a PriorityBlockingQueue) and a manually constructed ThreadPoolExecutor that accepts as parameter your BlockingQueue", "label": {"api": {"PriorityBlockingQueue": [[53, 73]], "ThreadPoolExecutor": [[103, 120]]}}}, {"text": "As known, the ConcurrenthashMap class allows us to use iterators safely", "label": {"api": {"ConcurrenthashMap": [[14, 30]]}}}, {"text": "Using CDI, @RequestScoped Sessions are opned and closed automcatically", "label": {"api": {"@RequestScoped": [[11, 24]]}}}, {"text": "@RequestScoped ensured one Session per request so sessions aren't shared among multiple requests", "label": {"api": {"@RequestScoped": [[0, 13]]}}}, {"text": "Look at the Arrays class - it has many almost identical versions of its methods such as copyOf() (which one to link :P)", "label": {"api": {"Arrays": [[12, 17]]}}}, {"text": "You should read up the ExecutorService framework and decide which Executor case is the best for you", "label": {"api": {"ExecutorService": [[23, 37]]}}}, {"text": "Also, see the ScheduledThreadPoolExecutor if you want to start Threads with a delay or at a schedule", "label": {"api": {"ScheduledThreadPoolExecutor": [[14, 40]]}}}, {"text": "So, in the end, Collections#sort uses Arrays#sort (of object elements) behind the scenes", "label": {"api": {"Arrays#sort": [[38, 48]]}}}, {"text": "Has the MongoDB team expressed whether or not the Java driver will support the javax.json classes", "label": {"api": {"javax.json classes": [[79, 96]]}}}, {"text": "anyMatch is an operation that determines if at least one element matches the given predicate", "label": {"api": {"anyMatch": [[0, 7]]}}}, {"text": "SAXException is extended by  SAXNotRecognizedException, SAXNotSupportedException", "label": {"api": {"SAXException": [[0, 11]], "SAXNotRecognizedException": [[29, 53]], "SAXNotSupportedException": [[56, 79]]}}}, {"text": "if lets say 'do something' has some code that throws SAXNotRecognizedException or SAXNotSupportedException and if that happens then nothing should happen", "label": {"api": {"SAXNotRecognizedException": [[53, 77]], "SAXNotSupportedException": [[82, 105]]}}}, {"text": "If SAXNotRecognizedException occurs then will nothing happen since its a empty block", "label": {"api": {"SAXNotRecognizedException": [[3, 27]]}}}, {"text": "I basically want it to do nothing when SAXNotRecognizedException or SAXNotSupportedException occurs", "label": {"api": {"SAXNotRecognizedException": [[39, 63]], "SAXNotSupportedException": [[68, 91]]}}}, {"text": "You don't need to use Arrays.fill if you're already using for loops", "label": {"api": {"Arrays.fill": [[22, 32]]}}}, {"text": "Arrays.fill would be used instead of the inner for loop", "label": {"api": {"Arrays.fill": [[0, 10]]}}}, {"text": "The clearSelection() method \"Deselects all selected columns and rows.\" It only removes the selection highlighting, not the data", "label": {"api": {"clearSelection()": [[4, 19]]}}}, {"text": "So far I saw only EntityManager.lock(*) but this locks only given record", "label": {"api": {"EntityManager.lock(*)": [[18, 38]]}}}, {"text": "You should also look at the Javadoc for String.substring(int)", "label": {"api": {"String.substring(int)": [[40, 60]]}}}, {"text": "You either need to make Paciente a subclass of a JavaFX Pane, or you need to wrap the Paciente instance in a SwingNode", "label": {"api": {"SwingNode": [[109, 117]]}}}, {"text": "The latter (SwingNode) is tricky, because you will need to use two different threads to create the different components", "label": {"api": {"SwingNode": [[12, 20]]}}}, {"text": "Use getClass().getResourceAsStream() to get files that are on your classpath", "label": {"api": {"getClass().getResourceAsStream()": [[4, 35]]}}}, {"text": "You would have to have your main thread spin in a loop on some scalar, I would recommend one of the Atomics that java provides (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html), but you could use volatile if you wanted for this I think", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html": [[128, 216]]}}}, {"text": "So instead going with some AtomicXXX class it would be better to use some of the blocking queues which allow writing of data from one thread (with put()) and consumption of that data by the other", "label": {"api": {"blocking queues": [[81, 95]]}}}, {"text": "Have a look at Optional", "label": {"api": {"Optional": [[15, 22]]}}}, {"text": "To avoid that or excessive if (x != null) checks, using Optional you can use", "label": {"api": {"Optional": [[56, 63]]}}}, {"text": "If that object does not define toString(), then (via inheritance from the object object) it calls the \"default\" toString() method, which returns the string you observed; classname@hashcode", "label": {"api": {"\"default\" toString()": [[102, 121]]}}}, {"text": "NumberFormatException is a subclass of Exception", "label": {"api": {"NumberFormatException": [[0, 20]], "Exception": [[12, 20], [39, 47]]}}}, {"text": "Saying that both catch blocks should have the same behavior is like saying that you don't have any special treatment for NumberFormatException, just the same general treatment you have for Exception", "label": {"api": {"NumberFormatException": [[121, 141]], "Exception": [[133, 141], [189, 197]]}}}, {"text": "In that case, you can just omit its catch block and only catch Exception", "label": {"api": {"Exception": [[63, 71]]}}}, {"text": "You can use a HashSet<Foo> to do this", "label": {"api": {"HashSet<Foo>": [[14, 25]]}}}, {"text": "String.split(String regex, int limit) method allows for control over the number of resulting parts", "label": {"api": {"String.split(String regex, int limit)": [[0, 36]]}}}, {"text": "You can use String.split(String regex, int limit)", "label": {"api": {"String.split(String regex, int limit)": [[12, 48]]}}}, {"text": "You can just use split method of String class like this", "label": {"api": {"split method of String class": [[17, 44]]}}}, {"text": "The ArrayList(int capacity) constructor sets an initial capacity, but not initial items", "label": {"api": {"ArrayList(int capacity)": [[4, 26]]}}}, {"text": "Alternatively, you can use  TextFieldTableCell class", "label": {"api": {"TextFieldTableCell": [[28, 45]]}}}, {"text": "Is there a good reason that the Collections.list() method in the java.utils package returns an ArrayList<T> instead of List<T>", "label": {"api": {"Collections.list()": [[32, 49]]}}}, {"text": "I'm quoting the API Design from the The Java™ Tutorials", "label": {"api": {"API Design": [[16, 25]]}}}, {"text": "I thought I'd found the answer with Collections.unmodifiableList in Java 8", "label": {"api": {"Collections.unmodifiableList": [[36, 63]]}}}, {"text": "A custom ListCellRenderer", "label": {"api": {"ListCellRenderer": [[9, 24]]}}}, {"text": "Make the method BasicListUI#updateLayoutState() public", "label": {"api": {"BasicListUI#updateLayoutState()": [[16, 46]]}}}, {"text": "Class.getResourceAsStream retrieves the resource from the classpath and the webapp root folder is not in the classpath", "label": {"api": {"Class.getResourceAsStream": [[0, 24]]}}}, {"text": "You can use @EmbeddedId and @MapsId", "label": {"api": {"@EmbeddedId": [[12, 22]], "@MapsId": [[28, 34]]}}}, {"text": "The Period class in java.time handles only the date-oriented potion", "label": {"api": {"Period": [[4, 9]]}}}, {"text": "The Period class in Joda-Time handles full period", "label": {"api": {"Period": [[4, 9]]}}}, {"text": "Alternatively, you can use the class Duration in the package javax.xml.datatype for parsing strings like PnYnMnDTnHnMnS", "label": {"api": {"Duration": [[37, 44]], "javax.xml.datatype": [[61, 78]]}}}, {"text": "Some methods defined in javax.xml.datatype.Duration rely on an internal Calendar-instance (documented) so that those methods might not work if an instance of Duration holds very large values", "label": {"api": {"Duration": [[43, 50], [158, 165]], "javax.xml.datatype": [[24, 41]]}}}, {"text": "Otherwise the package javax.xml.datatype has the advantage to save the effort to embed an external library into your classpath", "label": {"api": {"javax.xml.datatype": [[22, 39]]}}}, {"text": "Second one (Time4J) offers the classes net.time4j.Duration and two formatting tools (Duration.Formatter for pattern-based printing/parsing and net.time4j.PrettyTime for localized printing in actually 78 languages)", "label": {"api": {"Duration": [[50, 57], [85, 92]]}}}, {"text": "The class Duration offers for parsing ISO-strings the static method parsePeriod(String) and also various normalizing methods", "label": {"api": {"Duration": [[10, 17]]}}}, {"text": "If they're stored as an array and you want an exact match, then you can use Arrays.equals for that", "label": {"api": {"Arrays.equals": [[76, 88]]}}}, {"text": "First of all, the deprecated Date constructor you used doesn't recognize a month with numeric value 12", "label": {"api": {"Date": [[29, 32]]}}}, {"text": "December is represented as 11, so date Date(2013, 12, 31) will cause a recalculation", "label": {"api": {"Date": [[39, 42]]}}}, {"text": "Secondly, you can now use Java 8's LocalDate to make your scenario easier", "label": {"api": {"Date": [[40, 43]], "LocalDate": [[35, 43]]}}}, {"text": "Note that month in LocalDate starts from 1 (January) to 12 (December) and not like Date which is from 0 (January) and 11 (December)", "label": {"api": {"Date": [[24, 27], [83, 86]], "LocalDate": [[19, 27]]}}}, {"text": "You could use the isAssignableFrom method", "label": {"api": {"isAssignableFrom": [[18, 33]]}}}, {"text": "Use a LinkedHashMap, which iterates over its entries in insertion order; simply insert the entries in the order you want them", "label": {"api": {"LinkedHashMap": [[6, 18]]}}}, {"text": "Please use the new Executor framework to create Threads, instead of manually doing the plumbing", "label": {"api": {"framework": [[28, 36]]}}}, {"text": "Implementations could differ, but in essence, you could create a thread which reads from Selector and executes some registered callbacks for each successful select", "label": {"api": {"Selector": [[89, 96]]}}}, {"text": "Then, for each new kind of IO, you could register it's Channel (or anything) with same Selector, and in this way implement 100% the same (but much more Flexible) implementation of single-threaded callback event loop", "label": {"api": {"Selector": [[87, 94]]}}}, {"text": "Having everything that's an object be an Object is a reasonable starting point for an OO language", "label": {"api": {"Object": [[41, 46]]}}}, {"text": "In practical terms, it means we know that if we're dealing with a non-null object reference, it will have equals, getClass, wait, notify, and all the other useful methods from Object", "label": {"api": {"Object": [[176, 181]]}}}, {"text": "DecimalFormat Javadoc specifies that the symbol , is the grouping separator", "label": {"api": {"DecimalFormat": [[0, 12]]}}}, {"text": "Is the syntax of date-time format strings as defined in Java's SimpleDateFormat class (like \"EEE, MMM d, ''yy\" and such) an original Java invention, or is it based on some other syntax definition like ICU's or CLDR's?", "label": {"api": {"SimpleDateFormat": [[63, 78]]}}}, {"text": "Is anybody aware of work that compares SimpleDateFormat syntax to those other definitions", "label": {"api": {"SimpleDateFormat": [[39, 54]]}}}, {"text": "To stop the task, add ListChangeListener to your ObservableList", "label": {"api": {"ListChangeListener": [[22, 39]]}}}, {"text": "To check if the objects' content is the same, use the function equals(Object otherObject)", "label": {"api": {"equals(Object otherObject)": [[63, 88]]}}}, {"text": "Implement a Comparator and make it sort your items as desired", "label": {"api": {"Comparator": [[12, 21]]}}}, {"text": "But the problem is that since putting Node objects into the item list is strongly not recommended(And it looks really weird)", "label": {"api": {"strongly not recommended": [[73, 96]]}}}, {"text": "You could use the ResultSetMetadata to check for the column's existence", "label": {"api": {"ResultSetMetadata": [[18, 34]]}}}, {"text": "You should read 'Deadline' field as a date using getDate", "label": {"api": {"getDate": [[49, 55]]}}}, {"text": "Not all types can be casted to another certain type, so checking with instanceof is a good practice to avoid a ClassCastException", "label": {"api": {"ClassCastException": [[111, 128]]}}}, {"text": "Additionally, instead of calling getOutputStream, you should be calling ServletResponse.getWriter, potentially after calling ServletResponse.setCharacterEncoding to ensure that it's using UTF-8", "label": {"api": {"ServletResponse.getWriter": [[72, 96]]}}}, {"text": "One other way would be to use Collections.max()", "label": {"api": {"Collections.max()": [[30, 46]]}}}, {"text": "The executeUpdate() method (no parameters), declared in PreparedStatement, will perform placeholder substitution", "label": {"api": {"executeUpdate() method": [[4, 25]]}}}, {"text": "Switch from PreparedStatement to CallableStatement", "label": {"api": {"CallableStatement": [[33, 49]]}}}, {"text": "The \"set\" methods work as before, but then you call execute() to execute the CallableStatement", "label": {"api": {"CallableStatement": [[77, 93]]}}}, {"text": "To call a stored procedure, you need a CallableStatement, not a PreparedStatement", "label": {"api": {"CallableStatement": [[39, 55]], "PreparedStatement": [[64, 80]]}}}, {"text": "Quoting CallableStatement Javadoc", "label": {"api": {"CallableStatement": [[8, 24]]}}}, {"text": "You could use a HashMap where the key is the letter and the value is the number of occurrences", "label": {"api": {"HashMap": [[16, 22]]}}}, {"text": "From the Semaphore javadoc", "label": {"api": {"Semaphore javadoc": [[9, 25]]}}}, {"text": "If instead you initialize with new Semaphore(1, false) or equivalently new Semaphore(1), then whenever a thread calls acquire(), it will become the first thread in line to get a permit", "label": {"api": {"equivalently": [[58, 69]]}}}, {"text": "But the commissionEmployee2 using super classes method which Object class", "label": {"api": {"Object": [[61, 66]]}}}, {"text": "toString()  method belongs to Object class which is super class of all Java classes, hence the no error", "label": {"api": {"toString()": [[0, 9]], "Object": [[30, 35]]}}}, {"text": "If you override it in your class, it executes that over-ridden implementation otherwise the default implementation from Object class", "label": {"api": {"Object": [[120, 125]]}}}, {"text": "Take the larger number, apply movePointRight iteratively while comparing with 0.1 to know when to stop", "label": {"api": {"movePointRight": [[30, 43]]}}}, {"text": "If you want a \"ConcurrentHashSet\", behaving the same way as a ConcurrentHashMap, you can just use Collections.newSetFromMap() and pass a ConcurrentHashMap as argument", "label": {"api": {"Collections.newSetFromMap()": [[98, 124]]}}}, {"text": "There is lot of information about Stateless, Stateful and Sigleton beans everywhere but almost nothing about javax.annotation.ManagedBean", "label": {"api": {"javax.annotation.ManagedBean": [[109, 136]]}}}, {"text": "If I annotate a class with @javax.annotation.ManagedBean will it be singleton or it will have instance pool like stateless", "label": {"api": {"javax.annotation.ManagedBean": [[28, 55]]}}}, {"text": "From the Javadoc for Scanner", "label": {"api": {"Javadoc for Scanner": [[9, 27]]}}}, {"text": "String.replaceAll() takes a regex as one of its arguments", "label": {"api": {"String.replaceAll()": [[0, 18]]}}}, {"text": "You need to use InputMismatchException to know if the value that you are retrieveing it's an int and ArrayIndexOutOfBoundsException to see if you are trying to access to a wrong size of your array", "label": {"api": {"InputMismatchException": [[16, 37]], "ArrayIndexOutOfBoundsException": [[101, 130]]}}}, {"text": "Now, instead of component.setLocation(x, y), use component.setBounds(x, y, width, height), so you also set a size for them", "label": {"api": {"component.setBounds(x, y, width, height)": [[49, 88]]}}}, {"text": "Particulary with Java 8 lamba expressions they introduced a lot of new methods on collection interfaces, like Iterable.forEach", "label": {"api": {"Iterable.forEach": [[110, 125]]}}}, {"text": "Just use the ArrayList.get(int index) method to get the object at that index", "label": {"api": {"ArrayList.get(int index)": [[13, 36]]}}}, {"text": "To retrieve a value from an ArrayList, use the get(int) method", "label": {"api": {"get(int)": [[47, 54]]}}}, {"text": "The problem is that you didn't tell SimpleDateFormat that the String had a UTC designator (you escaped it with 'Z')", "label": {"api": {"SimpleDateFormat": [[36, 51]]}}}, {"text": "According to SimpleDateFormat Javadoc, ISO 8601 format is obtained with the X pattern", "label": {"api": {"SimpleDateFormat": [[13, 28]], "ISO 8601 format": [[39, 53]]}}}, {"text": "If you make your object serializable, you can read/write the object using Object(Input|Output)Stream", "label": {"api": {"Input": [[81, 85]], "Output": [[87, 92]]}}}, {"text": "Also other constructors in the BufferedImage class deals with color models", "label": {"api": {"BufferedImage class": [[31, 49]]}}}, {"text": "You probably want to use GregorianCalendar which allows you to decode the date", "label": {"api": {"GregorianCalendar": [[25, 41]]}}}, {"text": "Java docs say", "label": {"api": {"Java docs say": [[0, 12]]}}}, {"text": "Long uses twice the number of bits int uses and can represent integral numbers up to Long.MAX_VALUE = 2^63-1", "label": {"api": {"Long.MAX_VALUE = 2^63-1": [[85, 107]]}}}, {"text": "If you want to use larger numbers, use BigInteger", "label": {"api": {"BigInteger": [[39, 48]]}}}, {"text": "If you want to use BigInteger, the normal arithmetic operators won't work anymore", "label": {"api": {"BigInteger": [[19, 28]]}}}, {"text": "You have to use the methods of BigInteger instead", "label": {"api": {"BigInteger": [[31, 40]]}}}, {"text": "String#split() method accepts a regex and | have a special meaning in regex", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "Or you can use Pattern class, to avoid all the mess", "label": {"api": {"Pattern": [[15, 21]]}}}, {"text": "You can check if there is more input with Scanner.hasNextLine()", "label": {"api": {"Scanner.hasNextLine()": [[42, 62]]}}}, {"text": "System.lineSeparator() returns the system-dependent line separator string", "label": {"api": {"System.lineSeparator()": [[0, 21]]}}}, {"text": "After, you can use .length() function to know how much positions have your String (how much chars have your String) so you won't have to convert it to any char or whatever", "label": {"api": {".length()": [[19, 27]]}}}, {"text": "The API docs explain how the addRow method works", "label": {"api": {"API docs": [[4, 11]]}}}, {"text": "Move to BigInteger instead", "label": {"api": {"BigInteger": [[8, 17]]}}}, {"text": "You can open a file with the (operating system) default application using the Desktop class, for example", "label": {"api": {"Desktop": [[78, 84]]}}}, {"text": "You'll have to use JDialog (http://docs.oracle.com/javase/7/docs/api/javax/swing/JDialog.html) instead", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/JDialog.html": [[28, 92]]}}}, {"text": "This uses the substring() method", "label": {"api": {"substring()": [[14, 24]]}}}, {"text": "Collections.shuffle(list) is an utility method that randomly permutes the given list in place", "label": {"api": {"Collections.shuffle(list)": [[0, 24]]}}}, {"text": "The FXMLLoader.load(URL, ResourceBundle) method you are calling is a static method - so it actually pays no attention to the FXMLLoader instance you instantiated, and consequently ignores the controllerFactory which references your Spring bean factory", "label": {"api": {"FXMLLoader.load(URL, ResourceBundle)": [[4, 39]]}}}, {"text": "This uses the instance method loader.load() which will use your controller factory", "label": {"api": {"loader.load()": [[30, 42]]}}}, {"text": "Use the TimeUnit enum found in Java 5 and later", "label": {"api": {"TimeUnit": [[8, 15]]}}}, {"text": "Now when I have a look at the documentation of the AutoCloseable interface at docs.oracle.com, it says", "label": {"api": {"AutoCloseable interface at docs.oracle.com": [[51, 92]]}}}, {"text": "Value lookups could use Arrays.binarySearch()", "label": {"api": {"Arrays.binarySearch()": [[24, 44]]}}}, {"text": "TreeMap is a class which will have key ordering", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "As John Bollinger suggested in the comments, ordering of the keys doesn't matter when calculating derivative, therefore you could simpley iterate over a HashMap, exactly the same way as I demonstrated above with the TreeMap", "label": {"api": {"TreeMap": [[216, 222]]}}}, {"text": "Use indexOf overload that takes the fromIndex position in a loop, count three spaces, and then use substring twice", "label": {"api": {"indexOf overload that takes the fromIndex position": [[4, 53]]}}}, {"text": "Your question says \"Collection\"", "label": {"api": {"Collection": [[20, 29]]}}}, {"text": "The Java Collection is an interface representing a collection of values", "label": {"api": {"Collection": [[9, 18]]}}}, {"text": "Notable sub-interfaces are List, Set, and Queue, just to mention a few", "label": {"api": {"List": [[27, 30]], "Set": [[33, 35]], "Queue": [[42, 46]]}}}, {"text": "The Collection interface is an extension of Iterable, and can as such be iterated", "label": {"api": {"Collection": [[4, 13]], "Iterable": [[44, 51]]}}}, {"text": "The Java Map is an interface representing mappings of keys to values", "label": {"api": {"Map": [[9, 11]]}}}, {"text": "It is NOT a sub-interface of Collection, although it is part of the Collections Framework of Java", "label": {"api": {"Collection": [[29, 38], [68, 77]]}}}, {"text": "It does not extend Iterable, and can not be iterated directly", "label": {"api": {"Iterable": [[19, 26]]}}}, {"text": "Since a Map consists of key/value pairs, it provides methods for iterating the map in 3 ways", "label": {"api": {"Map": [[8, 10]]}}}, {"text": "You can iterate the keys, you can iterate the values, and you can iterate the key/value pairs, using keySet(), values(), and entrySet(), respectively", "label": {"api": {"Set": [[104, 106], [130, 132]]}}}, {"text": "These are the \"views\" you are referring to, and they are needed because a Map is not a Collection and is not Iterable", "label": {"api": {"Collection": [[87, 96]], "Iterable": [[109, 116]], "Map": [[74, 76]]}}}, {"text": "Please be more clear next time you ask a question, because all the Collection interfaces and classes do not need a view to iterate them", "label": {"api": {"Collection": [[67, 76]]}}}, {"text": "As such, your question \"why we need Collection Views to Iterate through the Java Collections\" is meaningless", "label": {"api": {"Collection": [[36, 45], [81, 90]]}}}, {"text": "A Matcher object allows you to query it several times, so that you can find the expression, get the groups, find the expression again, get the groups, and so on", "label": {"api": {"Matcher": [[2, 8]]}}}, {"text": "Instead, it will start scanning from the start, as if you had a fresh Matcher", "label": {"api": {"Matcher": [[70, 76]]}}}, {"text": "You are wrong about LocalDateTime", "label": {"api": {"LocalDateTime": [[20, 32]]}}}, {"text": "LocalDateTime is an immutable date-time object that represents a date-time, often viewed as year-month-day-hour-minute-second", "label": {"api": {"LocalDateTime": [[0, 12]]}}}, {"text": "For example, the value \"2nd October 2007 at 13:45.30.123456789\" can be stored in a LocalDateTime", "label": {"api": {"LocalDateTime": [[83, 95]]}}}, {"text": "The difference between the two is that Instant represents an offset from the Epoch (01-01-1970) and, as such, represents a particular instant on the time-line", "label": {"api": {"Instant": [[39, 45]]}}}, {"text": "Two Instant objects created at the same moment in two different places of the Earth will have exactly the same value", "label": {"api": {"Instant": [[4, 10]]}}}, {"text": "Now you can use LinkedHashSet<Mva> to eliminate duplicates while maintaining the relative order, and without the risk of eliminating false positives", "label": {"api": {"LinkedHashSet<Mva>": [[16, 33]]}}}, {"text": "The h identifier in SimpleDateFormat formats the hours in AM/PM (1-12), so you actually do not output the real difference", "label": {"api": {"SimpleDateFormat": [[20, 35]]}}}, {"text": "In Java 8, using a StringJoiner can simplify the code a bit", "label": {"api": {"StringJoiner": [[19, 30]]}}}, {"text": "If you're using Java 8, the built-in LocalDate is the easiest to use", "label": {"api": {"LocalDate": [[37, 45]]}}}, {"text": "Otherwise, you have to use a Calendar object", "label": {"api": {"Calendar": [[29, 36]]}}}, {"text": "Using the Calendar object is more complicated, because the two dates you'll be comparing (birthday vs today) may be in different daylight savings time \"zones\"", "label": {"api": {"Calendar": [[10, 17]]}}}, {"text": "Here are the 3 implementations, using Java 8, Joda-Time, and Calendar, respectively", "label": {"api": {"Calendar": [[61, 68]]}}}, {"text": "I want to convert the result of System.nanoTime() to a date", "label": {"api": {"System.nanoTime()": [[32, 48]]}}}, {"text": "Unfortunately, System.nanoTime() is not what you want for this", "label": {"api": {"System.nanoTime()": [[15, 31]]}}}, {"text": "You probably want System.currentTimeMillis(), in which case you can use new Date(System.currentTimeMillis() + milliseconds) to get the date for that number of milliseconds in the future", "label": {"api": {"System.currentTimeMillis()": [[18, 43], [81, 106]]}}}, {"text": "While you could then subtract System.nanoTime(), scale the value, and add System.currentTimeMillis() to have a similar result..", "label": {"api": {"System.nanoTime()": [[30, 46]], "System.currentTimeMillis()": [[74, 99]]}}}, {"text": "since you're adding System.nanoTime() anyway and therefore have the original number of seconds, you could just use System.currentTimeMillis() directly", "label": {"api": {"System.nanoTime()": [[20, 36]], "System.currentTimeMillis()": [[115, 140]]}}}, {"text": "The easiest way to copy the data is probably using System.arraycopy()", "label": {"api": {"System.arraycopy()": [[51, 68]]}}}, {"text": "LocalDateTime implements comparable interface, so you can implement comparator like", "label": {"api": {"comparable": [[25, 34]]}}}, {"text": "If you cannot change the class to implement Comparable, you can still use external Comparator objects", "label": {"api": {"Comparator": [[83, 92]]}}}, {"text": "I stumbled into opposite problem (I needed self-closing tag) and I resolved in this way.You can try using this version of marshal() or modifying code from linked answer", "label": {"api": {"this version of marshal()": [[106, 130]]}}}, {"text": "See the node documentation", "label": {"api": {"node documentation": [[8, 25]]}}}, {"text": "Use java.time, now built into Java 8 and later", "label": {"api": {"java.time": [[4, 12]]}}}, {"text": "A quick bit of example code in java.time", "label": {"api": {"java.time": [[31, 39]]}}}, {"text": "Your input string happens to be in standard ISO 8601 format which java.time uses by default when parsing/generating strings", "label": {"api": {"java.time": [[66, 74]]}}}, {"text": "Search StackOverflow.com for many more examples of java.time", "label": {"api": {"java.time": [[51, 59]]}}}, {"text": "You would be better off using startsWith(String prefix) like this", "label": {"api": {"startsWith(String prefix)": [[30, 54]]}}}, {"text": "Your first try does not work because you are trying to get the index of the String ^Two inside your list, but indexOf(String str) does not accept regular expression", "label": {"api": {"indexOf(String str)": [[110, 128]]}}}, {"text": "Your second try does not work because matches(String regex) works on the entire String, not just on the beginning", "label": {"api": {"matches(String regex)": [[38, 58]]}}}, {"text": "It has a convenient toString(int radix) which you can use with a radix up to Character.MAX_RADIX which is generally at 36 giving you a maximum value of ZZ = 1295", "label": {"api": {"toString(int radix)": [[20, 38]], "Character.MAX_RADIX": [[77, 95]]}}}, {"text": "Please note that you need to compile the pattern using DOTALL", "label": {"api": {"DOTALL": [[55, 60]]}}}, {"text": "Note the use of a custom log handler in the properties file to emphasis the possibily of appending your own handler (which may extend the default FileHandler)", "label": {"api": {"FileHandler": [[146, 156]]}}}, {"text": "Map.entrySet() returns the type Set<Map.Entry>", "label": {"api": {"Map.entrySet()": [[0, 13]], "Set<Map.Entry>": [[32, 45]]}}}, {"text": "It would be better to add the entries to a new list that no other thread is accessing, then add them all together ( using addAll) to the shared ArrayList once you're done reading from the resultSet", "label": {"api": {"addAll": [[122, 127]]}}}, {"text": "You can get a filtered list of files in a folder/directory using File#listFiles(FilenameFilter)", "label": {"api": {"File#listFiles(FilenameFilter)": [[65, 94]]}}}, {"text": "When it tries calling a v2 method that doesn't exist in v1, you'll end up getting a (not-so) nice NoSuchMethodError", "label": {"api": {"NoSuchMethodError": [[98, 114]]}}}, {"text": "Calendar::getTime() returns a java.util.Date object, not a java.sql.Timestamp object", "label": {"api": {"Calendar::getTime()": [[0, 18]], "java.util.Date": [[30, 43]], "java.sql.Timestamp": [[59, 76]], "Calendar": [[0, 7]]}}}, {"text": "And also consider to replace Calendar with the new Date & Time API introduced in Java SE 8", "label": {"api": {"Calendar": [[29, 36]]}}}, {"text": "Just define the interface throwing an IOException the same way as stream api does", "label": {"api": {"IOException": [[38, 48]]}}}, {"text": "You can then in your implementation define extended types from IOException with specific details (socket disconnections, etc.)", "label": {"api": {"IOException": [[63, 73]]}}}, {"text": "The Java Servlet technology’s Session object is indeed aimed at solving this exact problem, how to track a single user’s set of current objects over time, beyond the HTTP request-response lifecycle", "label": {"api": {"Session": [[30, 36]]}}}, {"text": "Yes, as you add stuff to the Session object its memory usage grows in size", "label": {"api": {"Session": [[29, 35]]}}}, {"text": "If running low on memory, your Servlet container such as Tomcat may choose to write an older Session object to storage using Serialization", "label": {"api": {"Session": [[93, 99]]}}}, {"text": "The catch here is that all your objects in the Session must be serializable", "label": {"api": {"Session": [[47, 53]]}}}, {"text": "Look at the BlockingQueue interface in Java", "label": {"api": {"BlockingQueue": [[12, 24]]}}}, {"text": "Your best bet will be to use a SortedMap with the Comparator interface", "label": {"api": {"SortedMap": [[31, 39]], "Comparator": [[50, 59]]}}}, {"text": "This way complexity is only O(n) and insert and delete operations are cheaper than using a sortedMap", "label": {"api": {"sortedMap": [[91, 99]]}}}, {"text": "Anyway, I think patstuart's suggestion (using a sortedMap) is more elegant", "label": {"api": {"sortedMap": [[48, 56]]}}}, {"text": "The Javadocs for DateFormat.parse state", "label": {"api": {"Javadocs for DateFormat.parse": [[4, 32]]}}}, {"text": "I think you want the Runtime class", "label": {"api": {"Runtime class": [[21, 33]]}}}, {"text": "The proper way would be to synchronize the list with Collections.synchronizedList()", "label": {"api": {"Collections.synchronizedList()": [[53, 82]]}}}, {"text": "If you are traversing way more than the number of times you update your list, you can also use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[95, 114]]}}}, {"text": "Furthermore, findFirst() returns an Optional, which makes even more sense for findFirst() to be able to handle nulls", "label": {"api": {"Optional": [[36, 43]]}}}, {"text": "Once you have the IntStream, call summaryStatistics() to get back an IntSummaryStatistics object that holds the count, sum, min, max, and average", "label": {"api": {"summaryStatistics()": [[34, 52]]}}}, {"text": "Generally, you can call collect on the IntStream to perform your own customized calculations on the stream values", "label": {"api": {"collect": [[24, 30]]}}}, {"text": "Then you could pass an instance of this custom Spliterator.ofInt to StreamSupport.intStream to create an IntStream", "label": {"api": {"StreamSupport.intStream": [[68, 90]]}}}, {"text": "You can do it using the String.split(String regex) method, with regex being what separates each object", "label": {"api": {"String.split(String regex)": [[24, 49]]}}}, {"text": "If you want to convert the grades to ints, you can do it with the Integer.parseInt(String integer) method", "label": {"api": {"Integer.parseInt(String integer)": [[66, 97]]}}}, {"text": "You can directly do this with the Scanner, using its next() (for name) and nextInt() (for the grades) methods", "label": {"api": {"next()": [[53, 58]], "nextInt()": [[75, 83]]}}}, {"text": "To set the separator, use useDelimiter(String pattern)", "label": {"api": {"useDelimiter(String pattern)": [[26, 53]]}}}, {"text": "You could also use, as of Java 8, Integer.toUnsignedString to convert an int into a String representation of the unsigned 32-bit value", "label": {"api": {"Integer.toUnsignedString": [[34, 57]]}}}, {"text": "Unlike most other popular application languages, the matches() method in java only returns true if the regex matches the whole string (not part of the string like in perl, ruby, php, javascript etc)", "label": {"api": {"matches()": [[53, 61]]}}}, {"text": "You need to invoke awaitTermination on the executor object, in order to wait for the executor to finish shutting down", "label": {"api": {"awaitTermination": [[19, 34]]}}}, {"text": "If LWL is a String that represents a Double, try parsing that Double by using Double.parseDouble", "label": {"api": {"Double.parseDouble": [[78, 95]]}}}, {"text": "You'll need to write a custom Comparator in order to sort it", "label": {"api": {"Comparator": [[30, 39]]}}}, {"text": "You have startsWith method in String class", "label": {"api": {"startsWith": [[9, 18]]}}}, {"text": "You can use a StringBuilder to append all the digits from your int[] from max to 0", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "The two main implementations of List are ArrayList and LinkedList", "label": {"api": {"ArrayList": [[41, 49]], "LinkedList": [[55, 64]]}}}, {"text": "ArrayList can be accessed very quickly by index because it is backed by an array - you just need array[i] - but modifying the list requires moving much of the underlying array around so that is not efficient", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "You can add/remove items with LinkedList very efficiently but finding the nth entry is slow because it has to start at the head and walk the list counting nodes until it gets to the required location", "label": {"api": {"LinkedList": [[30, 39]]}}}, {"text": "In Java 7 this is java.lang.reflect.Member, however the Java 8 class library introduces a new type java.lang.reflect.Executable which is more specialized than the generic Member", "label": {"api": {"java.lang.reflect.Member": [[18, 41]], "java.lang.reflect.Executable": [[99, 126]]}}}, {"text": "You can use an EnumSet", "label": {"api": {"EnumSet": [[15, 21]]}}}, {"text": "You can use ServletContextListener in order to achieve this", "label": {"api": {"ServletContextListener": [[12, 33]]}}}, {"text": "You can use groupingBy with YearMonth as your classifier", "label": {"api": {"groupingBy": [[12, 21]], "YearMonth": [[28, 36]]}}}, {"text": "You can use setAll or addAll", "label": {"api": {"setAll": [[12, 17]], "addAll": [[22, 27]]}}}, {"text": "The reason that the old J2EE style EJBS that implement javax.ejb.EntityBean, javax.ejb.SessionBean and javax.ejb.MessageDrivenBean should be serializable is historical", "label": {"api": {"javax.ejb.EntityBean": [[55, 74]], "javax.ejb.SessionBean": [[77, 97]], "javax.ejb.MessageDrivenBean": [[103, 129]]}}}, {"text": "The original javax.ejb.EnterpriseBean interface that these extend happens to itself extend java.io.Serializable", "label": {"api": {"javax.ejb.EnterpriseBean": [[13, 36]], "java.io.Serializable": [[91, 110]]}}}, {"text": "The introduction of EJB 3 removed the requirement for any of these interfaces (and subsequently java.io.Serializable) to be implemented", "label": {"api": {"java.io.Serializable": [[96, 115]]}}}, {"text": "The interrupt method doesn't kill the thread", "label": {"api": {"interrupt method": [[4, 19]]}}}, {"text": "In run(), let the method complete if an InterruptedException is caught or if interrupted() returns true", "label": {"api": {"interrupted()": [[77, 89]]}}}, {"text": "I've never seen .equals called without something like string1.equals(string2);", "label": {"api": {".equals": [[16, 22], [61, 67]]}}}, {"text": "This can be difficult to look at, as it seems at first glance like an illegal forward reference, but it is perfectly valid and normal (and in fact is used in java.lang.Enum)", "label": {"api": {"java.lang.Enum": [[158, 171]]}}}, {"text": "The easiest thing to do is to create a new object with a title field and a date field then create a Comparator or implement Comparable", "label": {"api": {"Comparator": [[100, 109]], "Comparable": [[124, 133]]}}}, {"text": "I know it's simple to find out inheritance and interface implementations using Java reflection with Class#getSuperclass and Class#getInterfaces", "label": {"api": {"Class#getSuperclass": [[100, 118]], "Class#getInterfaces": [[124, 142]]}}}, {"text": "Associations and compositions can be inferred from class fields, so Class#getDeclaredFields", "label": {"api": {"Class#getDeclaredFields": [[68, 90]]}}}, {"text": "Java 8 Functions can be chained with the method andThen", "label": {"api": {"andThen": [[48, 54]]}}}, {"text": "Create a Comparator or implement Comparable to sort based on the frequency, then implement toString() to print it however you like", "label": {"api": {"Comparator": [[9, 18]], "Comparable": [[33, 42]]}}}, {"text": "To embed a swing component into JavaFX, you need to wrap it in a SwingNode", "label": {"api": {"SwingNode": [[65, 73]]}}}, {"text": "Note that SwingNode only works with lightweight components (i.e", "label": {"api": {"SwingNode": [[10, 18]]}}}, {"text": "You could implement the JobListener class, or just extend AbstractJobListener", "label": {"api": {"JobListener": [[24, 34], [66, 76]], "AbstractJobListener": [[58, 76]]}}}, {"text": "look at Scanner method hasNextLine() and try to use it in your code", "label": {"api": {"hasNextLine()": [[23, 35]]}}}, {"text": "Methods which are analogous to Stream.reduce(identity, accumulator, combiner) and Stream.reduce(identity, combiner), but with cancelPredicate", "label": {"api": {"Stream.reduce(identity, accumulator, combiner)": [[31, 76]], "Stream.reduce(identity, combiner)": [[82, 114]]}}}, {"text": "You can schedule multiple TimerTasks using a single Timer, they just can't run at the same time", "label": {"api": {"Timer": [[26, 30], [52, 56]]}}}, {"text": "But, quoting the javadoc of Timer", "label": {"api": {"Timer": [[28, 32]]}}}, {"text": "Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay", "label": {"api": {"ScheduledThreadPoolExecutor": [[105, 131]]}}}, {"text": "It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing TimerTask (just implement Runnable)", "label": {"api": {"Timer": [[55, 59], [61, 65], [183, 187]]}}}, {"text": "Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer", "label": {"api": {"Timer": [[79, 83]], "ScheduledThreadPoolExecutor": [[12, 38]]}}}, {"text": "System.nanoTime is not the current time", "label": {"api": {"System.nanoTime": [[0, 14]]}}}, {"text": "Use System.currentTimeMillis if you want the date(s) you've captured as milliseconds (see", "label": {"api": {"System.currentTimeMillis": [[4, 27]]}}}, {"text": "This is because changes to the list will result in changes to the TableView, and all changes to the scene graph must occur on the FX Application Thread", "label": {"api": {"all changes to the scene graph must occur on the FX Application Thread": [[81, 150]]}}}, {"text": "If you have a background thread that needs to update the list, you can schedule those updates to occur on the FX Application Thread by wrapping them in a call to Platform.runLater(...), or (and this is probably preferable) by using the javafx.concurrent API to manage your threading", "label": {"api": {"Platform.runLater(...)": [[162, 183]], "javafx.concurrent API": [[236, 256]]}}}, {"text": "If you can control the output, consider placing a space or any other separator between the two sets and create a SimpleDateFormat to parse it", "label": {"api": {"SimpleDateFormat": [[113, 128]]}}}, {"text": "The Desktop.open(File) class is launching an external application (see the Desktop javadocs) passing the name of a file the host operating system's file namespace", "label": {"api": {"Desktop javadocs": [[75, 90]]}}}, {"text": "You are missing the last parameter, scansize", "label": {"api": {"scansize": [[36, 43]]}}}, {"text": "You can use the width as the scansize, so it would be", "label": {"api": {"scansize": [[29, 36]]}}}, {"text": "Assuming you are using Java >= 7, you can check if a Path has a parent with the method Path.getParent()", "label": {"api": {"Path": [[53, 56], [87, 90]], "Path.getParent()": [[87, 102]]}}}, {"text": "However, as noted in the Javadoc, this does not check that the given Path actually exists on the filesystem", "label": {"api": {"Path": [[69, 72]]}}}, {"text": "You might want to add a check for that using Files.exists(path)", "label": {"api": {"Files.exists(path)": [[45, 62]]}}}, {"text": "This is done using a BiFunction<T,U,R>", "label": {"api": {"BiFunction<T,U,R>": [[21, 37]]}}}, {"text": "...And from the documentation for Matcher.matches", "label": {"api": {"Matcher.matches": [[34, 48]]}}}, {"text": "But unfortunately I cannot find it in the CSS Reference Guide", "label": {"api": {"CSS Reference Guide": [[42, 60]]}}}, {"text": "If you're up to Java 1.7 update 4, you can register a GarbageCollectorMXBean", "label": {"api": {"GarbageCollectorMXBean": [[54, 75]]}}}, {"text": "Also you can use pre-implemented Stack class which is also generic", "label": {"api": {"Stack": [[33, 37]]}}}, {"text": "ResultSet has getSQLXML(int) which returns a java.sql.SQLXML object", "label": {"api": {"SQLXML": [[17, 22], [54, 59]]}}}, {"text": "SQLXML gives you the most options to access the XML data", "label": {"api": {"SQLXML": [[0, 5]]}}}, {"text": "no fraction digits (contrary to your code), call df.setMaximumFractionDigits(0) and discard df.setMinimumFractionDigits(2)", "label": {"api": {"df.setMaximumFractionDigits(0)": [[49, 78]], "df.setMinimumFractionDigits(2)": [[92, 121]]}}}, {"text": "The issue is that Integer.valueOf returns an Integer, not an int, but your someOtherMethod expects an int", "label": {"api": {"Integer.valueOf": [[18, 32]]}}}, {"text": "The lambda expression in flatMap needs to return a Stream, as can be seen by the argument of flatMap which is of type Function<", "label": {"api": {"flatMap": [[25, 31], [93, 99]]}}}, {"text": "If you check out the JOptionPane Documentiation you can see all it's methods with parameters", "label": {"api": {"JOptionPane Documentiation": [[21, 46]]}}}, {"text": "There's a CheckedOutputStream that you perhaps can use as OutputStream when marshalling the content", "label": {"api": {"CheckedOutputStream": [[10, 28]]}}}, {"text": "Then you could use CheckedInputStream to read the data back again and see if it has changed", "label": {"api": {"CheckedInputStream": [[19, 36]]}}}, {"text": "Look into javax.script API docs on how to do this", "label": {"api": {"API docs": [[23, 30]]}}}, {"text": "Will SecurityException be thrown if I don't override the checkAccess method myself", "label": {"api": {"checkAccess": [[57, 67]]}}}, {"text": "Create a custom FileChooserUI by subclassing BasicFileChooserUI and limit the selection in your implementation of the nested class SelectionListener", "label": {"api": {"FileChooserUI": [[16, 28], [50, 62]]}}}, {"text": "You can see the different next***() on the doc on this link http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[60, 122]]}}}, {"text": "You need to implement the abstract method apply(T t)", "label": {"api": {"apply(T t)": [[42, 51]]}}}, {"text": "It's behaving exactly as documented", "label": {"api": {"documented": [[25, 34]]}}}, {"text": "You should use endsWith instead of indexOf", "label": {"api": {"endsWith": [[15, 22]], "indexOf": [[35, 41]]}}}, {"text": "indexOf will return the index where the passed string exactly matches the current string and, as the name suggests, endsWith will check if the current string ends with the passed string", "label": {"api": {"endsWith": [[116, 123]], "indexOf": [[0, 6]]}}}, {"text": "Here's an example that takes a DataSource as a dependency", "label": {"api": {"DataSource": [[31, 40]]}}}, {"text": "Then all you have to do is present the user with a dialog to input those four strings and construct your DataSource and pass it to construct your DbAccessClass", "label": {"api": {"DataSource": [[105, 114]]}}}, {"text": "Here's an example using BasicDataSource", "label": {"api": {"DataSource": [[29, 38]]}}}, {"text": "Scanner is a class name", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "Its replacement is ProcessBuilder", "label": {"api": {"ProcessBuilder": [[19, 32]]}}}, {"text": "In Jersey 2.0+, you can register a custom implementation of ClientRequestFilter that can manipulate the headers in the request that the Client API will send out", "label": {"api": {"ClientRequestFilter": [[60, 78]]}}}, {"text": "The getHeaders() method returns the MultivaluedMap on which you can put your header(s)", "label": {"api": {"getHeaders() method": [[4, 22]]}}}, {"text": "You can register your custom ClientRequestFilter with your ClientConfig before you call newClient", "label": {"api": {"ClientRequestFilter": [[29, 47]]}}}, {"text": "Once you have the Stream, call flatMap to replace the lines with the words, supplying the lambda expression to split out the words", "label": {"api": {"flatMap": [[31, 37]]}}}, {"text": "It also affects the correctness of any average calculation you wish to implement", "label": {"api": {"average": [[39, 45]]}}}, {"text": "To obtain the average, you can call mapToInt to map the stream of words to their lengths (yielding an IntStream), then call average, which returns an OptionalDouble", "label": {"api": {"mapToInt": [[36, 43]], "average": [[14, 20], [124, 130]]}}}, {"text": "Use IntSummaryStatistics to get the min, max and average in one pass", "label": {"api": {"IntSummaryStatistics": [[4, 23]]}}}, {"text": "The cell used to display the selected item is the buttonCell", "label": {"api": {"buttonCell": [[50, 59]]}}}, {"text": "In order to retrieve the body of the request in the servlet, you need to call ServletRequest#getReader", "label": {"api": {"ServletRequest#getReader": [[78, 101]]}}}, {"text": "You may want to use a Thread pool that has fixed amount of thread", "label": {"api": {"Thread pool that has fixed amount of thread": [[22, 64]]}}}, {"text": "Your program will first create a thread pool", "label": {"api": {"create a thread pool": [[24, 43]]}}}, {"text": "When a URL is read, the program will start a new task to download its content", "label": {"api": {"start a new task": [[37, 52]]}}}, {"text": "You program may maintain a queue", "label": {"api": {"queue": [[27, 31]]}}}, {"text": "When a task finish downloading HTMLs, it can push the URL and the result together into a queue", "label": {"api": {"queue": [[89, 93]]}}}, {"text": "When the main thread finish reading URLs and starting tasks, it can wait for the queue", "label": {"api": {"queue": [[81, 85]]}}}, {"text": "Once the queue have any responses, take the response out and write it to database", "label": {"api": {"queue": [[9, 13]], "Once the queue have any responses": [[0, 32]], "take the response out": [[35, 55]]}}}, {"text": "The various forms of String.join, this one accepting a delimiter and an Iterable, let you join together the elements' string representations with a delimiter - in this case a line separator", "label": {"api": {"accepting a delimiter and an Iterable": [[43, 79]]}}}, {"text": "When you look at the Javadoc of Arrays you can see that the List returned by Arrays.asList(...) is only a Bridge to use an Array as a List and therefore is fixed size", "label": {"api": {"Arrays": [[32, 37], [77, 82]]}}}, {"text": "Your DetectorThread will have to implement Callable", "label": {"api": {"Callable": [[43, 50]]}}}, {"text": "It's probably best to have one single thread recursively scan the directories, creating a Callable for each file", "label": {"api": {"Callable": [[90, 97]]}}}, {"text": "You can use String.format() method", "label": {"api": {"String.format()": [[12, 26]]}}}, {"text": "To do modular exponentiation in Java, you can use the modPow method on BigIntegers", "label": {"api": {"modPow": [[54, 59]]}}}, {"text": "I think you want a descendingIterator", "label": {"api": {"descendingIterator": [[19, 36]]}}}, {"text": "You need to look into the paged results control", "label": {"api": {"paged results control": [[26, 46]]}}}, {"text": "Verify that the sampleSizeInBits of your AudioFormat comports with your chosen amplitude", "label": {"api": {"AudioFormat": [[41, 51]]}}}, {"text": "You can try creating the chart in HTML and Javascript, and then displaying the resulting page in a JavaFX WebView", "label": {"api": {"WebView": [[106, 112]]}}}, {"text": "WebView uses a webkit driven engine, so it should work with any reasonable html/javascript that runs in webkit browsers, though as with any web engine technology there are some exceptions", "label": {"api": {"WebView": [[0, 6]]}}}, {"text": "Here, i is the index of query in src, but the increment term makes use of indexOf(String str, int fromIndex), which javadoc says", "label": {"api": {"indexOf(String str, int fromIndex)": [[74, 107]]}}}, {"text": "If you need to query the script of a particular character, use the Character.UnicodeScript class—but if you really need to need a complete list, you will need to read the UCD data files or enumerate through all code points", "label": {"api": {"Character.UnicodeScript": [[67, 89]]}}}, {"text": "There are other Map implementations, including LinkedHashMap and TreeMap which do not exhibit the behavior you describe", "label": {"api": {"LinkedHashMap": [[47, 59]], "TreeMap": [[65, 71]]}}}, {"text": "In the case of LinkedHashMap it is described in the Javadoc (in part) as a hash table and linked list implementation of the Map interface, with predictable iteration order", "label": {"api": {"LinkedHashMap": [[15, 27]]}}}, {"text": "You don't need extra libraries, as there are javax classes for parsing SOAP requests", "label": {"api": {"parsing SOAP requests": [[63, 83]]}}}, {"text": "Please note that there are more effective algorithms to reverse bits like one implemented in standard JDK Integer.reverse method", "label": {"api": {"Integer.reverse": [[106, 120]]}}}, {"text": "BigInteger has a random constructor", "label": {"api": {"random constructor": [[17, 34]]}}}, {"text": "It is pretty simple using Matcher.appendReplacement() and Matcher.appendTrail()", "label": {"api": {"Matcher.appendReplacement()": [[26, 52]], "Matcher.appendTrail()": [[58, 78]]}}}, {"text": "You can do this in a little longer way without any third-party library using Arrays.asList", "label": {"api": {"Arrays.asList": [[77, 89]]}}}, {"text": "Just check Future#isDone() yourself in an infinite loop on the current thread in an utility method which look like below", "label": {"api": {"Future#isDone()": [[11, 25]]}}}, {"text": "You could try parsing your first file first, storing all of the lines in a HashMap and then checking whether there is a mapping present for each of the lines of the second file", "label": {"api": {"HashMap": [[75, 81]]}}}, {"text": "For a Stream<Double>, this is DoubleSummaryStatistics", "label": {"api": {"DoubleSummaryStatistics": [[30, 52]], "Double": [[13, 18], [30, 35]]}}}, {"text": "It is obtained by collecting the stream with the summarizingDouble collector", "label": {"api": {"summarizingDouble": [[49, 65]], "Double": [[60, 65]]}}}, {"text": "This collector takes a ToDoubleFunction as argument", "label": {"api": {"Double": [[25, 30]]}}}, {"text": "Such statistics can be obtained for Integer, Long and Double values", "label": {"api": {"Integer": [[36, 42]], "Long": [[45, 48]], "Double": [[54, 59]]}}}, {"text": "Note that the general case of converting a Collection<Double> to a DoubleStream can be done with the code you already have", "label": {"api": {"Double": [[54, 59], [67, 72]]}}}, {"text": "However, JVM allows you to measure system business to adjust, see OperatingSystemMXBean, ThreadMXBean", "label": {"api": {"OperatingSystemMXBean": [[66, 86]]}}}, {"text": "You can use DecimalFormat to parse your integers with a custom format", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "You can use an overloaded version of the Collections.shuffle() that accepts a Random as a parameter, which you can initialized using the same seed via the setSeed() method", "label": {"api": {"Collections.shuffle()": [[41, 61]], "Random": [[78, 83]], "setSeed()": [[155, 163]]}}}, {"text": "So in your code you'll need a Random per card deck both using the same seed, example", "label": {"api": {"Random": [[30, 35]]}}}, {"text": "I found FileLock, with this I can lock a file while it is writing, but I need to have a process polling for the reading, that is not efficient", "label": {"api": {"FileLock": [[8, 15]]}}}, {"text": "Like PipedInputStream and PipedOutputStream need to use different threads to efficiently exchange data", "label": {"api": {"PipedInputStream": [[5, 20]], "PipedOutputStream": [[26, 42]]}}}, {"text": "The trick is to access the FXMLLoader's namespace and populate it with the properties, before loading the FXML", "label": {"api": {"namespace": [[40, 48]]}}}, {"text": "I've taken a look through the Iterable JavaDoc and certainly everything I expect to be passed to my interface will actually be a collection", "label": {"api": {"Iterable JavaDoc": [[30, 45]]}}}, {"text": "given a default method) spliterator() (pay attention to its Implementation Note), which lets you use it in conjunction with StreamSupport", "label": {"api": {"spliterator()": [[24, 36]], "StreamSupport": [[124, 136]]}}}, {"text": "In order to call a function, you first have to cast the script engine to Invocable", "label": {"api": {"Invocable": [[73, 81]]}}}, {"text": "This interface is implemented by the NashornScriptEngine and defines a method invokeFunction to call a JavaScript function for a given name", "label": {"api": {"invokeFunction": [[78, 91]]}}}, {"text": "It is also possible to avoid the cast to Invocable by asking the script engine to evalute a String", "label": {"api": {"Invocable": [[41, 49]]}}}, {"text": "When is it useful to work with the Java class Enumeration and why is it useful to work with it", "label": {"api": {"Enumeration": [[46, 56]]}}}, {"text": "If you know that the algorithm used was RSA, you can cast the public key to a RSAPublicKey and get the key length using getModulus()", "label": {"api": {"RSAPublicKey": [[78, 89]], "getModulus()": [[120, 131]]}}}, {"text": "For a DSA public key, you need to check the bit length of the prime and the subprime used, obtained with getP() and getQ()", "label": {"api": {"getP()": [[105, 110]], "getQ()": [[116, 121]]}}}, {"text": "This controller thread will communicate with the JMS listener using a Semaphore", "label": {"api": {"Semaphore": [[70, 78]]}}}, {"text": "The Semaphore is initialized with 10 permits, and every time an external process calls TerminationController#terminate (or however the external processes communicate with your listener process) it adds a permit to the Semaphore, and then JMSListener must first acquire a permit before it can call messageConsumer.release() which ensures that no more than ten processes can be active at a time", "label": {"api": {"Semaphore": [[4, 12], [218, 226]]}}}, {"text": "So far, I have created a Connection object as ThreadLocal, but I am not sure if it is good idea", "label": {"api": {"ThreadLocal": [[46, 56]]}}}, {"text": "I believe the popups from the menu is done with ContextMenu (the same as right clicking menu)", "label": {"api": {"ContextMenu": [[48, 58]]}}}, {"text": "You can use DecimalFormat", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "java.math.BigInteger is immutable and as such it is safe for access by multiple threads", "label": {"api": {"java.math.BigInteger": [[0, 19]]}}}, {"text": "You get an ArrayStoreException when adding the String", "label": {"api": {"ArrayStoreException": [[11, 29]]}}}, {"text": "Load the image into a java.awt.Image and scale it", "label": {"api": {"java.awt.Image": [[22, 35]]}}}, {"text": "To write out the image, you'll need to convert it to a java.awt.image.BufferedImage", "label": {"api": {"java.awt.image.BufferedImage": [[55, 82]]}}}, {"text": "Your Map is likely to be HashMap or TreeMap or other non-concurrent map", "label": {"api": {"HashMap": [[25, 31]]}}}, {"text": "Let's assume it's a HashMap", "label": {"api": {"HashMap": [[20, 26]]}}}, {"text": "Every stream is backed by Spliterator", "label": {"api": {"Spliterator": [[26, 36]]}}}, {"text": "After binding a Spliterator should, on a best-effort basis, throw ConcurrentModificationException if structural interference is detected", "label": {"api": {"Spliterator": [[16, 26]]}}}, {"text": "Spliterators that do this are called fail-fast", "label": {"api": {"Spliterator": [[0, 10]]}}}, {"text": "So the HashMap.keySet().spliterator() is not IMMUTABLE (because this Set can be modified) and not CONCURRENT (concurrent updates are unsafe for HashMap)", "label": {"api": {"HashMap": [[7, 13], [144, 150]]}}}, {"text": "Also it worth citing the HashMap documentation", "label": {"api": {"HashMap": [[25, 31]]}}}, {"text": "Is it a Scene", "label": {"api": {"Scene": [[8, 12]]}}}, {"text": "If you have a BLOB field in a relational database you can write to it (for one record at a time) with an OutputStream (see Blob.setBinaryStream())", "label": {"api": {"Blob.setBinaryStream()": [[123, 144]]}}}, {"text": "You can wrap this stream with a DataOutputStream which implements the DataOutput interface", "label": {"api": {"DataOutputStream": [[32, 47]]}}}, {"text": "You would then use StreamSupport.intStream() to generate your stream from an instance of the class above", "label": {"api": {"StreamSupport.intStream()": [[19, 43]]}}}, {"text": "Use SimpleDateFormat and split to keep file extension", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "You should be using DataOutputStream instead of PrintWriter", "label": {"api": {"DataOutputStream": [[20, 35]]}}}, {"text": "Similarly, reading should be done with a DataInputStream, specifically the readByte and readFully methods, rather than BufferedReader", "label": {"api": {"DataInputStream": [[41, 55]]}}}, {"text": "The documentation for getReceiver() says", "label": {"api": {"documentation for getReceiver()": [[4, 34]]}}}, {"text": "A better approach for your problem would be to first tokenize your expression using either String.split or StringTokenizer StringTokenizer, then loop through each token", "label": {"api": {"StringTokenizer": [[107, 121], [123, 137]]}}}, {"text": "if token is an operand push into a Stack--Java has a Stack class, so use that", "label": {"api": {"Stack": [[35, 39], [53, 57]]}}}, {"text": "The toString() method is implemented to return \"[\"+getNodeName()+\"", "label": {"api": {"Node": [[54, 57]]}}}, {"text": "See the javadoc of Node", "label": {"api": {"Node": [[19, 22]]}}}, {"text": "This is mentioned in Scanner JavaDoc", "label": {"api": {"Scanner JavaDoc": [[21, 35]]}}}, {"text": "The compile error you are getting is expected since LocalDate does not implement the interface Comparable<LocalDate>, so it does not comply to the type T in public static <T extends Comparable<T>> T max(List<T> d)", "label": {"api": {"LocalDate": [[52, 60], [106, 114]]}}}, {"text": "Instead, LocalDate implements ChronoLocalDate which itself implements Comparable<ChronoLocalDate>", "label": {"api": {"LocalDate": [[9, 17], [36, 44], [87, 95]]}}}, {"text": "the type T is found to be ChronoLocalDate", "label": {"api": {"LocalDate": [[32, 40]]}}}, {"text": "this is an example of how you can detect the click inside a JFrame", "label": {"api": {"JFrame": [[60, 65]]}}}, {"text": "Take a look at the SwingWorker class", "label": {"api": {"SwingWorker": [[19, 29]]}}}, {"text": "How do I use SwingWorker in Java", "label": {"api": {"SwingWorker": [[13, 23]]}}}, {"text": "This code is broken and can easily throw OutOfMemoryError because it doesn't limit the number of threads created, consider using a managed thread pool instead", "label": {"api": {"managed thread pool": [[131, 149]]}}}, {"text": "The := is wrong and the placeholder for return parameter must be listed before the call keyword (as documented in the JavaDocs)", "label": {"api": {"as documented in the JavaDocs": [[97, 125]]}}}, {"text": "When you're working with multiple threads you should use AtomicBoolean", "label": {"api": {"AtomicBoolean": [[57, 69]]}}}, {"text": "You should either protect at a more granular level (e.g., locking each account individually), or use a different lock construct such as ReadWriteLock which allows multiple threads to say share a lower level of access or a single thread to gain exclusive access", "label": {"api": {"ReadWriteLock": [[136, 148]]}}}, {"text": "The CompletableFuture.supplyAsync uses common ForkJoinPool to submit tasks which thread count by default is limited by number of hardware threads returned by Runtime.getRuntime().availableProcessors()", "label": {"api": {"CompletableFuture.supplyAsync": [[4, 32]], "supplyAsync": [[22, 32]]}}}, {"text": "You however can create your own pool and use it for your tasks using two-argument supplyAsync", "label": {"api": {"supplyAsync": [[82, 92]]}}}, {"text": "Currying means to transform your Consumer2<T1, T2> to a Function<T1,Consumer1<T2>>", "label": {"api": {"Consumer": [[33, 40], [68, 75]]}}}, {"text": "On the other hand, when you use the existing standard interfaces Consumer and BiConsumer you have no choice but to offer a utility method in a class different to these interfaces", "label": {"api": {"Consumer": [[65, 72], [80, 87]], "BiConsumer": [[78, 87]]}}}, {"text": "Deferreds seem similar, if not the same, as CompletableFutures (compare addCallback to thenApply)", "label": {"api": {"CompletableFutures": [[44, 61]]}}}, {"text": "Note that setValidating() only means to turn off DTD validation as defined by the W3C", "label": {"api": {"DTD validation": [[49, 62]]}}}, {"text": "How does one read the data in Process#getOutputStream() into a String", "label": {"api": {"Process#getOutputStream()": [[30, 54]]}}}, {"text": "You can use BigInteger which has no theoretical limit to it's size", "label": {"api": {"BigInteger": [[12, 21]]}}}, {"text": "I think the best approach for selecting the individual parts of the editor is to check the caretPosition in the editor and increment/decrement the appropriate portion as required", "label": {"api": {"caretPosition": [[91, 103]]}}}, {"text": "You can also set a TextFormatter on the editor to control the allowed input, etc", "label": {"api": {"TextFormatter": [[19, 31]]}}}, {"text": "But if you have to write serialization yourself for some reason, you need to write the size and each object (use Externalizable, it's faster than just Serializable)", "label": {"api": {"Externalizable": [[113, 126]]}}}, {"text": "Is there a way to return file:/// through the File Api", "label": {"api": {"File Api": [[46, 53]]}}}, {"text": "Using Class.newInstance(), as you mentioned (not sure if you had this exact way in mind)", "label": {"api": {"Class.newInstance()": [[6, 24]], "newInstance": [[12, 22]]}}}, {"text": "You could use Class.getDeclaredConstructor.newInstance if you want to use a constructor with arguments (example)", "label": {"api": {"Class.getDeclaredConstructor": [[14, 41]], "newInstance": [[43, 53]]}}}, {"text": "What you are looking for is called the map operation", "label": {"api": {"map": [[39, 41]]}}}, {"text": "This method is used to map an object to another object; quoting the Javadoc, which says it better", "label": {"api": {"map": [[23, 25]]}}}, {"text": "Note that the Stream is converted back to an array using the toArray(generator) method; the generator used is a function (it is actually a method reference here) returning a new Thing array", "label": {"api": {"toArray(generator)": [[61, 78]]}}}, {"text": "Java solution would involve watching a directory for changes using WatchService", "label": {"api": {"WatchService": [[67, 78]]}}}, {"text": "So long as the matcher isn't reset, Matcher#find will continue to match tokens until it exhausts the string", "label": {"api": {"Matcher#find": [[36, 47]]}}}, {"text": "As a general tip, Pattern.MULTILINE only makes sense with anchors (^ and $), and since you don't have any, you can safely remove it", "label": {"api": {"Pattern.MULTILINE": [[18, 34]]}}}, {"text": "You need to use List<T>#get and List<T>#set to manipulate ArrayList and List objects in general", "label": {"api": {"List<T>#get": [[16, 26]], "List<T>#set": [[32, 42]]}}}, {"text": "Furthermore a List<T> has no .length but a List<T>#size method to inspect the size", "label": {"api": {"List<T>#size": [[43, 54]]}}}]