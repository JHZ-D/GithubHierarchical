[{"text": "Second, the newInstance method in Class doesn't take any arguments", "label": {"api": {"newInstance method in Class": [[12, 38]]}}}, {"text": "Then you can call Constructor's newInstance method, which does take parameters", "label": {"api": {"Constructor's newInstance method": [[18, 49]]}}}, {"text": "Math.E will simply give you the value e", "label": {"api": {"Math.E": [[0, 5]]}}}, {"text": "you can make use of the constant pool to improve the performance of string comparisons in some circumstances, by using the String.intern() method", "label": {"api": {"String.intern()": [[123, 137]]}}}, {"text": "Check out isAfter() and isBefore()", "label": {"api": {"isAfter()": [[10, 18]], "isBefore()": [[24, 33]]}}}, {"text": "String.format is what you are looking for it returns a String and not a PrintStream like System.out.format", "label": {"api": {"String.format": [[0, 12]]}}}, {"text": "Take a look at Java.lang.String.format() Method for further information", "label": {"api": {"String.format": [[25, 37]]}}}, {"text": "You may use shared AtomicBoolean for this case", "label": {"api": {"AtomicBoolean": [[19, 31]]}}}, {"text": "You can use the Files.copy() methods", "label": {"api": {"Files.copy()": [[16, 27]]}}}, {"text": "As others already mentioned, you may look for a working Locale as argument to String#toLowerCase", "label": {"api": {"String#toLowerCase": [[78, 95]]}}}, {"text": "You can utilize @ElementCollection for this purpose", "label": {"api": {"@ElementCollection": [[16, 33]]}}}, {"text": "For the interested you can read more about the Service Provider Interface mechanism and the ServiceRegistry class in particular", "label": {"api": {"ServiceRegistry": [[92, 106]]}}}, {"text": "Moreover, you can simply use Character.isUpperCase method to check whether character is in upper case or not", "label": {"api": {"Character.isUpperCase": [[29, 49]]}}}, {"text": "The docs for this constructor provide details of the expected format of the argument string", "label": {"api": {"The docs for this constructor": [[0, 28]]}}}, {"text": "Then, you can add one year to this date, using the method plusYears(years)", "label": {"api": {"plusYears(years)": [[58, 73]]}}}, {"text": "LocalDate contains various methods to ease the task of adding or subtracting a temporal amount (like plusDays, plusMonths; the most general being plus(amount, unit) adding the amount given for the specified unit of time)", "label": {"api": {"LocalDate": [[0, 8]], "plusDays": [[101, 108]], "plusMonths": [[111, 120]], "plus(amount, unit)": [[146, 163]]}}}, {"text": "Next you call document.getElementsByTagName(\"derta-config\"), iterate the list (should be one long, right?), and use node.getParentNode().removeChild(node)", "label": {"api": {"document.getElementsByTagName(\"derta-config\")": [[14, 58]], "node.getParentNode().removeChild(node)": [[116, 153]]}}}, {"text": "After that, you call document.getElementsByTagName(\"hello\"), iterate the list, check the text content using node.getTextContent(), and if it is the value you want to change, you change it with node.setTextContent(newValue)", "label": {"api": {"node.getTextContent()": [[108, 128]], "node.setTextContent(newValue)": [[193, 221]]}}}, {"text": "Take a look at the UUID class", "label": {"api": {"UUID": [[19, 22]]}}}, {"text": "It has toString() function", "label": {"api": {"toString()": [[7, 16]]}}}, {"text": "Cloning HTTP request and response is possible via HttpServletResponseWrapper class http://docs.oracle.com/javaee/1.3/api/javax/servlet/http/HttpServletResponseWrapper.html", "label": {"api": {"http://docs.oracle.com/javaee/1.3/api/javax/servlet/http/HttpServletResponseWrapper.html": [[83, 170]]}}}, {"text": "You could also do it in Java with a Robot although that would be more hacky than the first solution", "label": {"api": {"Robot": [[36, 40]]}}}, {"text": "You could flatten out the loops by using Java 8 streams", "label": {"api": {"Java 8 streams": [[41, 54]]}}}, {"text": "Use count down latch in each thread", "label": {"api": {"count down latch": [[4, 19]]}}}, {"text": "Using Java8 streams will work really similar", "label": {"api": {"Java8": [[6, 10]]}}}, {"text": "You should use FileNameExtensionFilter", "label": {"api": {"FileNameExtensionFilter": [[15, 37]]}}}, {"text": "You should use a TableModelListener to watch for actual changes in the underlying data", "label": {"api": {"TableModelListener": [[17, 34]]}}}, {"text": "Here is a simple example of a TableModelListener that will count the number of checked boxes", "label": {"api": {"TableModelListener": [[30, 47]]}}}, {"text": "You can create a Stream of your accounts using stream(), map that stream to the amount of each account using mapToInt and sum the resulting IntStream using IntStream.sum()", "label": {"api": {"stream()": [[47, 54]], "mapToInt": [[109, 116]], "IntStream.sum()": [[156, 170]]}}}, {"text": "What we want is to implement our own Filter and add it to Neo server", "label": {"api": {"Filter": [[37, 42]]}}}, {"text": "For cases I need to execute host OS commands (Windows/OSX/Linux etc..), I use Runtime.exec(String)", "label": {"api": {"Runtime.exec(String)": [[78, 97]]}}}, {"text": "You can use Objects.requireNonNull for that", "label": {"api": {"Objects.requireNonNull": [[12, 33]]}}}, {"text": "It will do the check internally (so the IDE will not show a warning on your function) and raise a NullPointerException when the parameter is null", "label": {"api": {"NullPointerException": [[98, 117]]}}}, {"text": "Don't use DataInputStream for user input, use java.util.Scanner", "label": {"api": {"java.util.Scanner": [[46, 62]]}}}, {"text": "For example, you may not be aware of java.util.Objects yet", "label": {"api": {"java.util.Objects": [[37, 53]]}}}, {"text": "This utilizes the WebEngine class as part of JavaFX", "label": {"api": {"WebEngine": [[18, 26]]}}}, {"text": "Although Date.getDay is deprecated, if you read the Javadoc on Date it points you to the replacement method for the deprecation", "label": {"api": {"Javadoc on Date": [[52, 66]]}}}, {"text": "In this case, you may want to use the Calendar class to retrieve date and time information", "label": {"api": {"Calendar": [[38, 45]]}}}, {"text": "It internally uses the Formatter class", "label": {"api": {"Formatter": [[23, 31]]}}}, {"text": "For more info on the format string see the Formatter documentation", "label": {"api": {"Formatter": [[43, 51]]}}}, {"text": "Executor.submit(Runnable) will return a Future that according to the javadoc", "label": {"api": {"Executor.submit(Runnable)": [[0, 24]]}}}, {"text": "You need to use the FontMetrics class for that", "label": {"api": {"FontMetrics": [[20, 30]]}}}, {"text": "You can get the FontMetrics to use from the Graphics object, and then use the stringWidth and getHeight methods to get the size", "label": {"api": {"FontMetrics": [[16, 26]]}}}, {"text": "Use EntityManager.getReference() instead, to get a persistent, managed entity from its ID", "label": {"api": {"EntityManager.getReference()": [[4, 31]]}}}, {"text": "You can try to use a java ProxySelector class to do it, her is short example of it'usage from java proxy configuration guide", "label": {"api": {"ProxySelector": [[26, 38]]}}}, {"text": "You can try implementing finalize() method in your Class", "label": {"api": {"finalize()": [[25, 34]]}}}, {"text": "In this example, the ',' flag is used in the format string (all options and possibilities documented in the java.util.Formatter API doc", "label": {"api": {"java.util.Formatter API doc": [[108, 134]]}}}, {"text": "See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for details about the regular expression pattern", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html": [[4, 73]]}}}, {"text": "In order to construct an Image with a file located in the filesystem, you need to use the file", "label": {"api": {"Image": [[25, 29]]}}}, {"text": "Quoting the Image Javadoc", "label": {"api": {"Image": [[12, 16]]}}}, {"text": "This construct comes from the URL syntax of Java", "label": {"api": {"URL": [[30, 32]]}}}, {"text": "You could use ImageIO.read(File) instead", "label": {"api": {"ImageIO.read(File)": [[14, 31]]}}}, {"text": "It does not seem that any of the java.time API constructors accept a millisecond parameter in a local Epoch", "label": {"api": {"java.time API": [[33, 45]]}}}, {"text": "GridBagLayout has a method getLayoutDimensions() which returns array of two arrays", "label": {"api": {"getLayoutDimensions()": [[27, 47]]}}}, {"text": "See the Formatter Javadoc for the list of all token", "label": {"api": {"Formatter": [[8, 16]]}}}, {"text": "A Statement object can have only one active ResultSet, so when you execute rs2 = stmt.executeQuery(sql), the first ResultSet (rs) gets closed", "label": {"api": {"Statement": [[2, 10]]}}}, {"text": "Create two Statement objects, one for rs and another for rs2", "label": {"api": {"Statement": [[11, 19]]}}}, {"text": "Quoting the javadoc of Statement", "label": {"api": {"Statement": [[23, 31]]}}}, {"text": "By default, only one ResultSet object per Statement object can be open at the same time", "label": {"api": {"Statement": [[42, 50]]}}}, {"text": "Therefore, if the reading of one ResultSet object is interleaved with the reading of another, each must have been generated by different Statement objects", "label": {"api": {"Statement": [[137, 145]]}}}, {"text": "All execution methods in the Statement interface implicitly close a statment's current ResultSet object if an open one exists", "label": {"api": {"Statement": [[29, 37]]}}}, {"text": "Since Java 8, Comparators got a whole lot prettier..", "label": {"api": {"Comparators": [[14, 24]]}}}, {"text": "You can use System.nanoTime() to measure the time spent in your code", "label": {"api": {"System.nanoTime()": [[12, 28]]}}}, {"text": "Take a look at JavaDoc for it's methods", "label": {"api": {"JavaDoc for it's methods": [[15, 38]]}}}, {"text": "see this link", "label": {"api": {"this link": [[4, 12]]}}}, {"text": "As you can see in the Javadocs, List.toArray() returns an Object[], so the list's generic type information is lost", "label": {"api": {"List.toArray()": [[32, 45]], "toArray()": [[37, 45]]}}}, {"text": "If you need to preserve the generic information, you must use the alternative toArray() method which takes an array of the desired type (because you could, for instance, want to turn a List<String> into a List<CharSequence> and so on)", "label": {"api": {"toArray()": [[78, 86]]}}}, {"text": "However this is a little wasteful, as it forces the toArray() method to construct a new array of the appropriate size at runtime (via reflection)", "label": {"api": {"toArray()": [[52, 60]]}}}, {"text": "It has methods such as floor(E e)", "label": {"api": {"floor(E e)": [[23, 32]]}}}, {"text": "The super(ThreadName); statement invokes the Thread(String name) constructor of Thread class", "label": {"api": {"Thread": [[10, 15], [45, 50], [80, 85]]}}}, {"text": "Well the ConcurrentHashMap.computeIfAbsent documentation explicitly says", "label": {"api": {"ConcurrentHashMap.computeIfAbsent": [[9, 41]]}}}, {"text": "See Pattern for details about the regex used in split(), or javadoc for any classes and methods you need", "label": {"api": {"Pattern": [[4, 10]]}}}, {"text": "This solution works well but I prefer to call Cell.cancelEdit() but I don't find how without overriding a lot of classes", "label": {"api": {"Cell.cancelEdit()": [[46, 62]]}}}, {"text": "Cells already have an editable property, so you can just call setEditable(...) on the cell as needed", "label": {"api": {"editable property": [[22, 38]]}}}, {"text": "I have checked Oracle's Connection Documentation but to no avail", "label": {"api": {"Oracle's Connection Documentation": [[15, 47]]}}}, {"text": "The problem is that java.String.substring takes two int values, not char values", "label": {"api": {"java.String.substring": [[20, 40]]}}}, {"text": "Alternatively you can use String.format()  to format your double as you wanted", "label": {"api": {"String.format()": [[26, 40]]}}}, {"text": "You can use the trim() method of the String class for removing trailing (and leading) white space and line breaks", "label": {"api": {"trim()": [[16, 21]]}}}, {"text": "A LinkedList implements the Deque interface, which seems to be exactly what you need", "label": {"api": {"LinkedList": [[2, 11]], "Deque": [[28, 32]]}}}, {"text": "I'd suggest using Externalizable if you want to control the marshalling / unmarshalling", "label": {"api": {"Externalizable": [[18, 31]]}}}, {"text": "There's also the marker interface Serializable if you want to let Java automatically control the marshalling / unmarshalling", "label": {"api": {"Serializable": [[34, 45]]}}}, {"text": "Take a look at the ExecutorCompletionService it can execute multiple tasks and it will return you a future that you can use to wait", "label": {"api": {"ExecutorCompletionService": [[19, 43]]}}}, {"text": "You may use an array of BitSet objects to represent long bit-set", "label": {"api": {"BitSet": [[24, 29]]}}}, {"text": "You can use Enum.valueOf(Class, String)", "label": {"api": {"Enum.valueOf(Class, String)": [[12, 38]]}}}, {"text": "try using java.lang.String trim() function in the correct place", "label": {"api": {"trim()": [[27, 32]]}}}, {"text": "trim on \",\".trim() will produce \",\"", "label": {"api": {"trim()": [[12, 17]]}}}, {"text": "Need to trim() the final result", "label": {"api": {"trim()": [[8, 13]]}}}, {"text": "Add ActionListener to JButton, check example here", "label": {"api": {"ActionListener": [[4, 17]]}}}, {"text": "You can use StringJoiner from java.util package", "label": {"api": {"StringJoiner": [[12, 23]]}}}, {"text": "Java has two versions of Math.round()", "label": {"api": {"Math.round()": [[25, 36]]}}}, {"text": "Tried ArrayList In Java?", "label": {"api": {"ArrayList In Java": [[6, 22]]}}}, {"text": "Take a look at all the exception that are present in the java.sql package", "label": {"api": {"java.sql": [[57, 64]]}}}, {"text": "The DateTimeFormatter Javadoc lists all possible tokens with their signification", "label": {"api": {"DateTimeFormatter": [[4, 20]]}}}, {"text": "Check out Executors.newSingleThreadExecutor()", "label": {"api": {"Executors.newSingleThreadExecutor()": [[10, 44]]}}}, {"text": "Generally, If you want to store very big numbers in memory (that are too big for an int) and possibly do some math with them you'd have to use something like java.math.BigInteger", "label": {"api": {"java.math.BigInteger": [[158, 177]]}}}, {"text": "Then, If you want to format this value with a scientific notation, use NumberFormatter", "label": {"api": {"NumberFormatter": [[71, 85]]}}}, {"text": "You can create a Throwable (note that I'm not saying throw one, just create it) and call fillInStackTrace*, then use getStackTrace (or whatever you want to do at that point)", "label": {"api": {"Throwable": [[17, 25]], "fillInStackTrace": [[89, 104]], "getStackTrace": [[117, 129]]}}}, {"text": "* I think you need to call fillInStackTrace, but the constructor docs seem to suggest the constructor will call it, which makes me wonder why it would be a public method", "label": {"api": {"fillInStackTrace": [[27, 42]]}}}, {"text": "You can use multiple path transitions (one per node), with the starting time of each transition offset by the distance along the path that you want a node to start at (using jumpTo)", "label": {"api": {"jumpTo": [[174, 179]]}}}, {"text": "The Java libraries themselves consistently answer both of your questions \"no.\"  For example, the utility method Collections.shuffle accepts any List, and throws an exception if the List passed to it does not support the necessary operations", "label": {"api": {"Collections.shuffle": [[112, 130]]}}}, {"text": "You can use  toBack()  method after setVisible(true) method to open New JFrame  behind the main JFrame", "label": {"api": {"toBack()": [[13, 20]]}}}, {"text": "Put both the JavaFX chart and the TableView in the same scene within a single application and snapshot the entire scene rather than just the pie chart", "label": {"api": {"snapshot the entire scene": [[94, 118]]}}}, {"text": "Looks like you're getting exception while trying to connect to mentioned site page, then control goes to catch block and after that you're accessing not initialized variable document, that's why you're getting NPE", "label": {"api": {"NPE": [[210, 212]]}}}, {"text": "EntityManager.createQuery creates JPQL query interface whereas EntityManager.createNativeQuery will create native query interface", "label": {"api": {"EntityManager.createQuery": [[0, 24]], "EntityManager.createNativeQuery": [[63, 93]]}}}, {"text": "snapshot() can be used on nodes and not on scene", "label": {"api": {"snapshot()": [[0, 9]]}}}, {"text": "Collections#max runs in linear time with a worst-case performance of O(n), whereas Collections#sort is based on Timsort, which has a worst-case runtime of O(n log n)", "label": {"api": {"Collections#max": [[0, 14]], "Collections#sort": [[83, 98]]}}}, {"text": "Use a CountDownLatch for synchronization", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "I have a simple Java Socket connected to my Python socketserver", "label": {"api": {"Socket": [[21, 26]]}}}, {"text": "How to convert Image to BufferedImage in Java", "label": {"api": {"Image": [[15, 19], [32, 36]], "BufferedImage": [[24, 36]]}}}, {"text": "Note, that existing answer is apparently not correct, because it uses methods getWidth(null) and getHeight(null), which can return -1 if image is not loaded yet (Image is, by definition, an asynchronous object)", "label": {"api": {"Image": [[162, 166]], "getWidth(null)": [[78, 91]], "getHeight(null)": [[97, 111]]}}}, {"text": "BufferedReader.read() reads a single character and returns it as an integer (i.e", "label": {"api": {"BufferedReader.read()": [[0, 20]]}}}, {"text": "I just ran into the problem that the split method for strings wouldn't work with character \"|\" as an argument", "label": {"api": {"split method": [[37, 48]]}}}, {"text": "just use String::substring and String::split", "label": {"api": {"String::substring": [[9, 25]], "String::split": [[31, 43]]}}}, {"text": "One possible solution would be to convert both of your arrays to List and use removeAll", "label": {"api": {"removeAll": [[78, 86]]}}}, {"text": "java.sql.timestamp supports fractional seconds", "label": {"api": {"java.sql.timestamp": [[0, 17]]}}}, {"text": "This answer requires Java 1.6 or above, which added java.text.Normalizer", "label": {"api": {"java.text.Normalizer": [[52, 71]]}}}, {"text": "For this, we have to build our own DateTimeFormatter with the help of DateTimeFormatterBuilder", "label": {"api": {"DateTimeFormatterBuilder": [[70, 93]]}}}, {"text": "DateTimeFormatterBuilder has a method appendText(field, textLookup) whose goal is to look for the read text in the given map and replace it by the key associated to this value", "label": {"api": {"DateTimeFormatterBuilder": [[0, 23]], "appendText(field, textLookup)": [[38, 66]]}}}, {"text": "This is done by calling parseCaseInsensitive before appending the pattern for this", "label": {"api": {"parseCaseInsensitive": [[24, 43]]}}}, {"text": "If you need to associate a value with an enum outside the enum, the most performant way of doing it is by using EnumMap class designed specifically for this purpose", "label": {"api": {"EnumMap": [[112, 118]]}}}, {"text": "It's worth noting that the real HashMap.get() method takes an Object as its key, anyway", "label": {"api": {"HashMap.get()": [[32, 44]]}}}, {"text": "One possibility is an explicit call to Runtime exec method", "label": {"api": {"exec": [[47, 50]]}}}, {"text": "Well, if you already have the file reference and you are working with Java 1.6 or above, you can use Desktop class", "label": {"api": {"Desktop": [[101, 107]]}}}, {"text": "Remember that \"yourSelectedFile\" is File type", "label": {"api": {"File": [[27, 30], [36, 39]]}}}, {"text": "The I/O for stdout is normally buffered, which can prevent output from displaying immediately (stderr isn't),  The System.out instance of PrintStream is generally line buffered as well", "label": {"api": {"System.out": [[115, 124]]}}}, {"text": "System.out.print(\"some text...\\n\") or System.out.println(\"some text...\")", "label": {"api": {"System.out": [[0, 9], [38, 47]]}}}, {"text": "You can either add directory to the constructor of JFileChooser like this", "label": {"api": {"JFileChooser": [[51, 62]]}}}, {"text": "It is probably easier to just set it with the constructor, but if you need to change it after creating the JFileChooser, use setCurrentDirectory(File dir)", "label": {"api": {"JFileChooser": [[107, 118]]}}}, {"text": "If you can use Java8, I recommend the java.utils.SplitableRandom", "label": {"api": {"java.utils.SplitableRandom": [[38, 63]]}}}, {"text": "In my test java.utils.SplitableRandom is 30 times faster than java.utils.Random", "label": {"api": {"java.utils.SplitableRandom": [[11, 36]]}}}, {"text": "Socket.bind(SocketAddress bindpoint) in example can throw two different exceptions and the conditions that cause them to be thrown are different", "label": {"api": {"Socket.bind(SocketAddress bindpoint)": [[0, 35]]}}}, {"text": "With java 7 it is actually possible to see supressed exceptions with Throwable.getSupressed()", "label": {"api": {"Throwable.getSupressed()": [[69, 92]]}}}, {"text": "Parent.getChildren() is a protected method; in order to call it, your code must either be a subclass of Parent or in the same package as Parent", "label": {"api": {"Parent.getChildren()": [[0, 19]]}}}, {"text": "The Pane class, for example, does (and StackPane is a subclass of Pane)", "label": {"api": {"Pane": [[4, 7], [44, 47], [66, 69]]}}}, {"text": "If all your children subclass from Pane, you can replace Parent in your code with Pane", "label": {"api": {"Pane": [[35, 38], [82, 85]]}}}, {"text": "Simply using Integer#parseInt(String s, int radix) should be enough", "label": {"api": {"Integer#parseInt(String s, int radix)": [[13, 49]]}}}, {"text": "Once you have a string representing a number, you can use Integer.parseInt() to get an integer from it", "label": {"api": {"Integer.parseInt()": [[58, 75]]}}}, {"text": "The List.subList is your friend, use it", "label": {"api": {"List.subList": [[4, 15]]}}}, {"text": "You can use String.split() method", "label": {"api": {"String.split()": [[12, 25]]}}}, {"text": "You probably meant to use this constructor", "label": {"api": {"this constructor": [[26, 41]]}}}, {"text": "DatatypeConverter.parseBase64Binary can be used to decode a Base64 encoded String", "label": {"api": {"DatatypeConverter.parseBase64Binary": [[0, 34]]}}}, {"text": "If you don't have access to the source code, you can write your own method or use Files.readAllLines for Java >= 7", "label": {"api": {"Files.readAllLines": [[82, 99]]}}}, {"text": "You can change the locale used in JTextField with InputContext.selectInputMethod", "label": {"api": {"InputContext.selectInputMethod": [[50, 79]]}}}, {"text": "I am using javax.servlet.Registration to dynamically configure/register servlets", "label": {"api": {"javax.servlet.Registration": [[11, 36]]}}}, {"text": "Java streams in Java 8 make this pretty easy - the Stream.anyMatch method taking a predicate is exactly what you want", "label": {"api": {"Stream.anyMatch": [[51, 65]]}}}, {"text": "You can use an ArrayBlockingQueue and use poll(long, java.util.concurrent.TimeUnit)", "label": {"api": {"ArrayBlockingQueue": [[15, 32]], "poll(long, java.util.concurrent.TimeUnit)": [[42, 82]]}}}, {"text": "A very generic way of accessing another Java program is by writing a Java agent / using the Instrumentation API", "label": {"api": {"Instrumentation API": [[92, 110]]}}}, {"text": "As per the Javadoc of ExecutorService.awaitTermination (emphasis mine)", "label": {"api": {"ExecutorService.awaitTermination": [[22, 53]]}}}, {"text": "Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first", "label": {"api": {"shutdown": [[56, 63]]}}}, {"text": "That means you need to call shutdown first, like this", "label": {"api": {"shutdown": [[28, 35]]}}}, {"text": "This has unspecified behavior for the String(byte[], String) constructor, but in your implementation, these bad bytes are replaced by the \"�\" characters, which is \\uFFFD -- a three-byte character in UTF-8", "label": {"api": {"String(byte[], String)": [[38, 59]]}}}, {"text": "If you use %s instead of XX, then you can simply use String.format", "label": {"api": {"String.format": [[53, 65]]}}}, {"text": "One example from the Java library is CopyOnWriteArrayList, and anyone could make their own implementation as well", "label": {"api": {"CopyOnWriteArrayList": [[37, 56]]}}}, {"text": "If you use String#split(), you can use the two-argument version and supply a number of elements you want to get back", "label": {"api": {"String#split()": [[11, 24]]}}}, {"text": "You should have looked through the documentation for DecimalFormat and its superclass", "label": {"api": {"documentation for DecimalFormat": [[35, 65]], "its superclass": [[71, 84]]}}}, {"text": "You would have discovered that it has not only format methods, but also parse methods like this one", "label": {"api": {"this one": [[91, 98]]}}}, {"text": "For your case, it'd probably be easiest to just create a ConcurrentHashMap<String, Long> where the key is the thread name, e.g", "label": {"api": {"ConcurrentHashMap<String, Long>": [[57, 87]]}}}, {"text": "Just is case, are you aware that there is standard heap implementation in Java called PriorityQueue", "label": {"api": {"PriorityQueue": [[86, 98]]}}}, {"text": "If ArrayIndexOutOfBoundsException is the exception that is thrown (as opposed to being a \"cause\") then the reason is that you catch it outside of your loop", "label": {"api": {"\"cause\"": [[89, 95]]}}}, {"text": "However, you can pass in the class type to your generic class, that will allow you to use Array.newInstance(Class, int)", "label": {"api": {"Array.newInstance(Class, int)": [[90, 118]]}}}, {"text": "Because the servlet (your code) and the servlet container (Tomcat) are different entities, then to allow this flow (releasing tomcat thread but keep the client connection) we need to have this support in their contract, the package javax.servlet, which introduced in Servlet 3.0", "label": {"api": {"their contract": [[204, 217]]}}}, {"text": "In the main thread, you can join() and wait for the TestThread to complete", "label": {"api": {"join()": [[28, 33]]}}}, {"text": "One way to emulate this error would be to instrument this class loader to return an errornous InputStream for a given test value of fileName to throw an IOException", "label": {"api": {"instrument this class loader": [[42, 69]]}}}, {"text": "You need to use put on the LinkedBlockingQueue", "label": {"api": {"put": [[16, 18]]}}}, {"text": "put will wait as long as necessary until space is available", "label": {"api": {"put": [[0, 2]]}}}, {"text": "An alternative to re-inventing the wheel by manually calculating and setting the progressProperty of the bar is to use a Task", "label": {"api": {"Task": [[121, 124]]}}}, {"text": "Obviously, this is the very barest snippet - see Task for examples that play nicely with cancelling/interrupting the thread", "label": {"api": {"Task": [[49, 52]]}}}, {"text": "If my understanding of what you are trying to do is correct, one way to go about it is to implement equals(Object) in your Teacher class, then get the instances (say teacherA and teacherB) from your map by calling Map.get(String) with the key as the argument and then do if (teacherA.equals(teacherB))...", "label": {"api": {"equals(Object)": [[100, 113]]}}}, {"text": "In your implementation of equals(Object) you can define your rules to determine whether 2 teachers are equal (in your case it would probably be that they have same name and age)", "label": {"api": {"equals(Object)": [[26, 39]]}}}, {"text": "You're using java.awt.List that doesn't take a parameter - that's why you're getting \"type List does not take parameters\" error, you should use java.util.List instead", "label": {"api": {"java.awt.List": [[13, 25]], "java.util.List": [[144, 157]]}}}, {"text": "You can store basic information using the Preferences API", "label": {"api": {"Preferences": [[42, 52]]}}}, {"text": "There are 3 types of Throwables in Java", "label": {"api": {"Throwable": [[21, 29]]}}}, {"text": "What about the standard TreeMap, using the subMap(K,boolean,K,boolean) method", "label": {"api": {"subMap(K,boolean,K,boolean)": [[43, 69]]}}}, {"text": "b and b2 would not be equal (as per BigDecimal.equals) because they would have different scale", "label": {"api": {"BigDecimal.equals": [[36, 52]]}}}, {"text": "b would have a scale of 0 and b2 would have a scale of 1 (because add returns a BigDecimal whose scale is the max of the two BigDecimals scale)", "label": {"api": {"add": [[66, 68]]}}}, {"text": "See \"Calling back to Java from Javascript\" in the WebEngine API docs", "label": {"api": {"WebEngine API docs": [[50, 67]]}}}, {"text": "There is great NIO.2 API in JDK 1.7 with class Path, with help of this class you can easily access to folder with your JSPs (without any ServletContexts or whatever) and do what you need with list of JSP files, here is little sample for you", "label": {"api": {"Path": [[47, 50]]}}}, {"text": "If you prefer to modify the list in place, you might consider removeIf", "label": {"api": {"removeIf": [[62, 69]]}}}, {"text": "Whether the copying or modifying approach fits best will certainly depend on how you are using the list, and (if my guess about removeIf is correct) may also depend on what fraction of the elements are removed", "label": {"api": {"removeIf": [[128, 135]]}}}, {"text": "An AtomicBoolean is great for this, and in particular its compareAndSet method", "label": {"api": {"AtomicBoolean": [[3, 15]]}}}, {"text": "Note the Java 8 introduced getTypeName() to solve the issue, i.e", "label": {"api": {"getTypeName()": [[27, 39]]}}}, {"text": "String[].class.getTypeName() yields java.lang.String[]", "label": {"api": {"getTypeName()": [[15, 27]]}}}, {"text": "The Java docs specify that a no-arg constructor invocation will result in a capacity of Integer.MAX_VALUE, which is large but not actually infinite, so the queue is bounded (but for practical purposes, it might as well not be)", "label": {"api": {"no-arg constructor invocation": [[29, 57]]}}}, {"text": "The put method will block only if space needs to become available, meaning it will block if the queue already has a number of elements equal to capacity", "label": {"api": {"put": [[4, 6]]}}}, {"text": "I'd suggest harnessing the Java Collections API, and implement the Comparable interface in BanffMarathonRunner", "label": {"api": {"Comparable": [[67, 76]]}}}, {"text": "So September = 8 (http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html#MONTH)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html#MONTH": [[18, 91]]}}}, {"text": "To validate the input, you can use NumberFormatException which is thrown by the parseDouble() method using a try-catch block", "label": {"api": {"NumberFormatException": [[35, 55]], "parseDouble()": [[80, 92]]}}}, {"text": "To use this method your Student class should implement comperable interface", "label": {"api": {"comperable": [[55, 64]]}}}, {"text": "The easiest way to do what you want is to use a Task", "label": {"api": {"Task": [[48, 51]]}}}, {"text": "See the doc for Condition", "label": {"api": {"Condition": [[16, 24]]}}}, {"text": "A Condition is like a wait pool or wait set of an object and it replaces the use of the Object monitor methods (wait, notify and notifyAll)", "label": {"api": {"Condition": [[2, 10]]}}}, {"text": "Conditions enable one thread to suspend execution (to \"wait\") until notified by another thread that some state condition may now be true", "label": {"api": {"Condition": [[0, 8]]}}}, {"text": "A Condition instance is intrinsically bound to a lock just like the Object monitor methods require the lock of the shared object to wait or notify on", "label": {"api": {"Condition": [[2, 10]]}}}, {"text": "Scanner.nextLong() will throw an InputMismatchException when the value can't be represented as a long", "label": {"api": {"Scanner.nextLong()": [[0, 17]], "InputMismatchException": [[33, 54]]}}}, {"text": "If you call String.codePointCount instead of length(), you'll get 1", "label": {"api": {"String.codePointCount": [[12, 32]]}}}, {"text": "You should change the locale with Scanner.useLocale(locale)", "label": {"api": {"Scanner.useLocale(locale)": [[34, 58]]}}}, {"text": "There are a few things you have to change to achieve what you want, which I believe if just implement a Generic Comparator", "label": {"api": {"Comparator": [[112, 121]]}}}, {"text": "First, AComparator should look like", "label": {"api": {"Comparator": [[8, 17]]}}}, {"text": "You don't need your class B, since A and A2 will implement Comparable directly", "label": {"api": {"Comparable": [[59, 68]]}}}, {"text": "It is important that you read the documentation for Comparable, to understand what is expected from the returned value", "label": {"api": {"Comparable": [[52, 61]]}}}, {"text": "The ArrayList constructor you're using has nothing to do with the generic type", "label": {"api": {"ArrayList constructor": [[4, 24]]}}}, {"text": "The documentation for File.listFiles() includes", "label": {"api": {"documentation for File.listFiles()": [[4, 37]]}}}, {"text": "As in the description of java.io.File, java.nio.file should be used to overcome limitations from java.io.File", "label": {"api": {"java.io.File": [[25, 36], [97, 108]], "java.nio.file": [[39, 51]]}}}, {"text": "After i reworked the whole function and migrated from java.io.File and Strings to java.nio.file and Path it works fine", "label": {"api": {"java.io.File": [[54, 65]], "java.nio.file": [[82, 94]]}}}, {"text": "The Type interface and its implementations represent different cases of what kinds of types could be present here", "label": {"api": {"Type interface": [[4, 17]]}}}, {"text": "Call ParameterizedType's getActualTypeArguments method", "label": {"api": {"ParameterizedType's getActualTypeArguments method": [[5, 53]]}}}, {"text": "For BASE64, see How do I convert a byte array to Base64 in Java?, or use the new Base64 class (Java 8)", "label": {"api": {"Base64": [[49, 54], [81, 86]]}}}, {"text": "The interesting part for you is the @Column annotation which allows you to customize mapping of the value column", "label": {"api": {"@Column": [[36, 42]]}}}, {"text": "One situation is when you want to update the Javadoc documentation to reflect a more specific contract in the method in the subinterface, as is the case with Collection#addAll(Collection) and List#addAll(Collection)", "label": {"api": {"Collection#addAll(Collection)": [[158, 186]], "List#addAll(Collection)": [[192, 214]]}}}, {"text": "What you are looking for is just the contains method", "label": {"api": {"contains": [[37, 44]]}}}, {"text": "If your name list is only used to filter out persons from your result, you should consider using a Set as its contains method is O(1) (constant-time) so it will result in better performance", "label": {"api": {"contains": [[110, 117]]}}}, {"text": "In your code, replace LocalDate.now() with LocalDate.now(clock);", "label": {"api": {"LocalDate.now(clock);": [[43, 63]]}}}, {"text": "You can then pass Clock.systemDefaultZone() for production and a fixed clock for testing", "label": {"api": {"a fixed clock": [[63, 75]]}}}, {"text": "If we need to mock static methods like now() we can use multiple alternatives like PowerMock", "label": {"api": {"now()": [[39, 43]]}}}, {"text": "Another simple alternative is to use the now() method with a fixed Clock instance", "label": {"api": {"now()": [[41, 45]]}}}, {"text": "Certainly, most of the classes in java.time package have a now() method with a Clock parameter", "label": {"api": {"now()": [[59, 63]]}}}, {"text": "Seams like you could use the AsynchronousFileChannel (considering you are running Java 1.7+)", "label": {"api": {"AsynchronousFileChannel": [[29, 51]]}}}, {"text": "You would open a channel per file that you need to want to write to (see open method)", "label": {"api": {"open": [[10, 13], [73, 76]]}}}, {"text": "This type of channel provides the asynchronus write operation where you specify from which position in the file the write should occur - AsynchronousFileChannel#write(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler)", "label": {"api": {"AsynchronousFileChannel": [[137, 159]], "AsynchronousFileChannel#write(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler)": [[137, 232]], "CompletionHandler": [[215, 231]]}}}, {"text": "Note that the write can be only partially done, which you can check in the CompletionHandler passed to the write operation", "label": {"api": {"CompletionHandler": [[75, 91]]}}}, {"text": "Considering that you need the rectangles to be anchored at their respective location irrespective of the screen size, you need to remove the Group as the root of the Scene and make the AnchorPane the root of the scene", "label": {"api": {"Group": [[141, 145]]}}}, {"text": "Group layout does not resize automatically and retains the size of its children", "label": {"api": {"Group": [[0, 4]]}}}, {"text": "JavaFX's FXMLLoader method setControllerFactory takes a Callback as parameter", "label": {"api": {"setControllerFactory": [[27, 46]], "Callback": [[56, 63]]}}}, {"text": "In this case, the type of the argument is Callback<Class<?>, Object>", "label": {"api": {"Callback": [[42, 49]]}}}, {"text": "Here, c will have the type Class<?> because of the declared parameter of setControllerFactory", "label": {"api": {"setControllerFactory": [[73, 92]]}}}, {"text": "As a side note, everything will compile because setControllerFactory expects the result of the callback to be of type Object so the result of context.getBean(c) will always match", "label": {"api": {"setControllerFactory": [[48, 67]]}}}, {"text": "Use IntStream.asLongStream() method", "label": {"api": {"IntStream.asLongStream()": [[4, 27]]}}}, {"text": "By the way s.reduce(0, Long::sum) is the longer alternative for simple sum() method (which internally does the same)", "label": {"api": {"sum()": [[71, 75]]}}}, {"text": "An URI is quite complicated when you look at it from a distant perspective", "label": {"api": {"URI": [[3, 5]]}}}, {"text": "UriBuilder is designed to abstract you away from all this", "label": {"api": {"UriBuilder": [[0, 9]]}}}, {"text": "It will properly encode your parameters and will properly build your URI without too much hassle and with a simple syntax", "label": {"api": {"URI": [[69, 71]]}}}, {"text": "will build the following URI", "label": {"api": {"URI": [[25, 27]]}}}, {"text": "If async requests are enabled for a Servlet, then ServletRequest.isAsyncSupported() will return true for requests sent to this Servlet", "label": {"api": {"ServletRequest.isAsyncSupported()": [[50, 82]]}}}, {"text": "The combiner parameter in Stream.reduce is actually invoked only in the case of a parallel Stream", "label": {"api": {"Stream.reduce": [[26, 38]]}}}, {"text": "Is there any way to use generics with the Method class in Java", "label": {"api": {"Method": [[42, 47]]}}}, {"text": "I want to call invoke() on the Method object and have it return the actual return type of the method instead of Object", "label": {"api": {"Method": [[31, 36]], "invoke()": [[15, 22]], "Object": [[112, 117]]}}}, {"text": "To manipulate file bytes - read and write, you could use RandomAccessFile or a ByteBuffer", "label": {"api": {"RandomAccessFile": [[57, 72]], "ByteBuffer": [[79, 88]]}}}, {"text": "You can use clone(), because all arrays are Cloneable", "label": {"api": {"clone()": [[12, 18]], "Cloneable": [[44, 52]]}}}, {"text": "Though what made me confused is what should i put in the URI if i use Response.created(URI)", "label": {"api": {"URI": [[57, 59], [87, 89]]}}}, {"text": "A combination of length() and regionMatches(int toffset, String other, int ooffset, int len) should be quite efficient", "label": {"api": {"length()": [[17, 24]], "regionMatches(int toffset, String other, int ooffset, int len)": [[30, 91]]}}}, {"text": "You can use Bindings to create bindings based on condition", "label": {"api": {"Bindings": [[12, 19]]}}}, {"text": "The javadocs for Integer.valueOf(int) emit a pretty clear recommendation", "label": {"api": {"Integer.valueOf(int)": [[17, 36]]}}}, {"text": "This means implementations of the DocumentListener may not mutate the source of the event (i.e", "label": {"api": {"DocumentListener": [[34, 49]]}}}, {"text": "You should use a DocumentFilter for control over document manipulation", "label": {"api": {"DocumentFilter": [[17, 30]]}}}, {"text": "You are using javafx.application.Platform.exit() method where System.exit(int) should be used", "label": {"api": {"System.exit(int)": [[62, 77]]}}}, {"text": "In the documentation of the interrupt() method we have", "label": {"api": {"interrupt()": [[28, 38]]}}}, {"text": "If you want to have a dynamic resizing you should give a try to the GroupLayout that can easily be managed by Window Builder in the Eclipse IDE", "label": {"api": {"GroupLayout": [[68, 78]]}}}, {"text": "Once you will enable GroupLayout WindowBuilder Design view will show you two arrows on the corner of the component where you can arrange the alignment and the anchor of the component", "label": {"api": {"GroupLayout": [[21, 31]]}}}, {"text": "You should just set the MediaPlayer to the MediaView instead of re-initializing it by using the setMediaPlayer()", "label": {"api": {"setMediaPlayer()": [[96, 111]]}}}, {"text": "Note the use of the try-with-resource & AutoCloseable syntax found in newer versions of Java to simplify working with JDBC", "label": {"api": {"AutoCloseable": [[40, 52]]}}}, {"text": "Consider using a PauseTransition for functionality like this", "label": {"api": {"PauseTransition": [[17, 31]]}}}, {"text": "%d acesses the current date, the content of the curly brackets is a Simple Date Format, which you can customize to meet your needs", "label": {"api": {"Simple Date Format": [[68, 85]]}}}, {"text": "java already provides a method for this", "label": {"api": {"method": [[24, 29]]}}}, {"text": "The method is BigInteger.multiply(BigInteger)", "label": {"api": {"BigInteger.multiply(BigInteger)": [[14, 44]]}}}, {"text": "BigInteger.valueOf((long) 1); should be replaced by BigInteger.ONE", "label": {"api": {"BigInteger.ONE": [[52, 65]]}}}, {"text": "One elegant way to do this would be with a Pattern", "label": {"api": {"Pattern": [[43, 49]]}}}, {"text": "Here's the Javadocs of Arrays.sort(Object[])", "label": {"api": {"Arrays.sort(Object[])": [[23, 43]]}}}, {"text": "As your JFrame may contain many JRadioButton components arbitrarily nested in the frame's layout, you may need to recurse down the component hierarchy using Container.getComponents and check if each component is an instanceof JRadioButton, in which case you should cast and .setSelected(false) it, or a Container, in which case you should continue the recursion", "label": {"api": {"Container.getComponents": [[157, 179]]}}}, {"text": "From the java.util.Map api, it does not seem that it is possible with a Map", "label": {"api": {"java.util.Map api": [[9, 25]]}}}, {"text": "I also read about an emptyMap but it do not fulfil the same purposes", "label": {"api": {"read about an emptyMap": [[7, 28]]}}}, {"text": "As user:Mad Programmer mentioned above, you could use ShutdownHook", "label": {"api": {"ShutdownHook": [[54, 65]]}}}, {"text": "Probably it would be moreless efficient to use Java-8 method Arrays.parallelSetAll", "label": {"api": {"Arrays.parallelSetAll": [[61, 81]]}}}, {"text": "You can get it from the request using HttpServletRequest.getContextPath() or directly from the servlet context using ServletContext.getContextPath()", "label": {"api": {"HttpServletRequest.getContextPath()": [[38, 72]], "ServletContext.getContextPath()": [[117, 147]]}}}, {"text": "While \"A FontRenderContext which is directly constructed will most likely not represent any actual graphics device, and may lead to unexpected or incorrect results,\" you can obtain useful metrics from an instance of TextLayout, as shown here and here", "label": {"api": {"FontRenderContext": [[9, 25]], "TextLayout": [[216, 225]]}}}, {"text": "To access a Set in a thread-safe way, it would be better to use Collections.synchronizedSet and then synchronize access to the Set for iteration", "label": {"api": {"Collections.synchronizedSet": [[64, 90]]}}}, {"text": "this can be represented as an IntUnaryOperator", "label": {"api": {"IntUnaryOperator": [[30, 45]]}}}, {"text": "Therefore, curriedAdd is a function taking an int and returning an IntUnaryOperator, so it can be represented as IntFunction<IntUnaryOperator>", "label": {"api": {"IntUnaryOperator": [[67, 82], [125, 140]], "IntFunction<IntUnaryOperator>": [[113, 141]]}}}, {"text": "You could use StringBuilder or StringBuffer", "label": {"api": {"StringBuilder": [[14, 26]], "StringBuffer": [[31, 42]]}}}, {"text": "IntStream.range returns a sequential ordered IntStream from the start (inclusive) to the end (exclusive) by an incremental step of 1", "label": {"api": {"IntStream.range": [[0, 14]]}}}, {"text": "If you want to include the end element, you can use IntStream.rangeClosed", "label": {"api": {"IntStream.range": [[52, 66]], "IntStream.rangeClosed": [[52, 72]]}}}, {"text": "You just need a strict ResolverStyle", "label": {"api": {"ResolverStyle": [[23, 35]]}}}, {"text": "Sample code - where withResolverStyle(ResolverStyle.STRICT) is the important change, along with the use of uuuu rather than yyyy (where uuuu is \"year\" and \"yyyy\" is \"year of era\", and therefore ambiguous)", "label": {"api": {"ResolverStyle": [[24, 36], [38, 50]]}}}, {"text": "I would expect that if you called setLenient(true) prior to parsing, it would probably complain more, as detailed in the javadocs", "label": {"api": {"as detailed in the javadocs": [[102, 128]]}}}, {"text": "Quoting DateTimeFormatter.ISO_INSTANT Javadoc (emphasis mine)", "label": {"api": {"DateTimeFormatter.ISO_INSTANT": [[8, 36]]}}}, {"text": "Because setRowHeight() \"Sets the height, in pixels, of all cells to rowHeight, revalidates, and repaints,\" the approach is unsound", "label": {"api": {"setRowHeight()": [[8, 21]]}}}, {"text": "In your case, ConcurrentLinkedQueue would be a prime candidate", "label": {"api": {"ConcurrentLinkedQueue": [[14, 34]]}}}, {"text": "So, copy your list into a ConcurrentLinkedQueue (or build the \"list\" directly as a queue), and let your threads call poll() until it return null", "label": {"api": {"ConcurrentLinkedQueue": [[26, 46]], "poll()": [[117, 122]]}}}, {"text": "For this, you'd use a LinkedBlockingQueue, and the workers would call take()", "label": {"api": {"LinkedBlockingQueue": [[22, 40]], "take()": [[70, 75]]}}}, {"text": "I am doing this copy in shutdown hook of a premain method", "label": {"api": {"premain": [[43, 49]]}}}, {"text": "For example, you can see the load instructions reading the passed enum constant name and ordinal, as well as the this pointer, and passing them on to the superclass constructor, which requires them", "label": {"api": {"the superclass constructor": [[150, 175]]}}}, {"text": "The constructor new BigDecimal(double) is designed to preserve the precise value of the double argument, which can never be exactly 0.015", "label": {"api": {"new BigDecimal(double)": [[16, 37]]}}}, {"text": "Converting a double to a String chooses the shortest decimal representation needed to distinguish it from other possible double values", "label": {"api": {"Converting a double to a String": [[0, 30]]}}}, {"text": "In fact, the method BigDecimal.valueOf(double) exists for exactly this purpose, so you can shorten the above to", "label": {"api": {"BigDecimal.valueOf(double)": [[20, 45]]}}}, {"text": "You should use the new BigDecimal(double) constructor only if your purpose is to preserve the precise binary value of the argument", "label": {"api": {"new BigDecimal(double)": [[19, 40]]}}}, {"text": "Otherwise, call BigDecimal.valueOf(double), whose documentation says", "label": {"api": {"BigDecimal.valueOf(double)": [[16, 41]]}}}, {"text": "The only way I can think of accomplishing this is by writing your own TransferHandler, and overriding the getSourceActions and exportToClipboard methods", "label": {"api": {"TransferHandler": [[70, 84]]}}}, {"text": "You can convert the HTML to plain text yourself, rather than letting Swing use the getSelectedText method of JTextPane, by recursively converting each Element of the HTML Document, customizing the conversion in the case where the Element has a NameAttribute of IMG and also has an ALT attribute", "label": {"api": {"getSelectedText": [[83, 97]], "Element": [[151, 157], [230, 236]], "Document": [[171, 178]], "NameAttribute": [[244, 256]], "IMG": [[261, 263]], "ALT": [[281, 283]]}}}, {"text": "Instead of declaring the new interface you may use an existing BiFunction", "label": {"api": {"BiFunction": [[63, 72]]}}}, {"text": "you should either use TreeView<File> or TreeView<Path> (in other words, make the data type of the tree either File or Path)", "label": {"api": {"File": [[31, 34], [110, 113]], "Path": [[49, 52], [118, 121]]}}}, {"text": "ByteBuffer might help, as it lets you read the IEEE 754 representation of doubles", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "That said, your C code looks like it's getting 16 bits at a time, for which you might call ByteBuffer.getShort()", "label": {"api": {"ByteBuffer": [[91, 100]]}}}, {"text": "Implement equalsTo in a way that is consistent with your comparator (see https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html": [[73, 139]]}}}, {"text": "You should use a BufferedReader", "label": {"api": {"BufferedReader": [[17, 30]]}}}, {"text": "Its skip method skips characters and not bytes", "label": {"api": {"skip": [[4, 7], [16, 19]]}}}, {"text": "To skip 20 characters from an existing FileInputStream", "label": {"api": {"skip": [[3, 6]]}}}, {"text": "I read documentation of SimpleDateFormat and found that 'L' is supposed to give context-insensitive month name", "label": {"api": {"documentation of SimpleDateFormat": [[7, 39]]}}}, {"text": "For example, Map.containsKey contract is the following", "label": {"api": {"Map.containsKey": [[13, 27]]}}}, {"text": "I'm implementing the Future<Collection<Integer>> interface in order to share the result of some bulk computation among all thread in the application", "label": {"api": {"Future": [[21, 26]]}}}, {"text": "In fact, I intended to just put an instance of a class implemetnting Future<Collection<Integer>> into an ApplicationScope object so that any other thread which need the result just ask for the Future  from the object and call the method get() on it, therefore using the computation performed by some another thread", "label": {"api": {"Future": [[69, 74], [193, 198]]}}}, {"text": "But the method implementation doesn't satisfy the documentation of the Future because we need to throw CancellationException in any thread awaiting for the result (has called the get() method)", "label": {"api": {"Future": [[71, 76]]}}}, {"text": "Concurrency code is very hard to get right, and frameworks for distributed execution - notably ExecutorService - will provide Future instances referencing the units of work you care about", "label": {"api": {"ExecutorService": [[95, 109]]}}}, {"text": "Well you call JTable.removeColumn, each column of the array of columns is getting reindexed", "label": {"api": {"JTable.removeColumn": [[14, 32]]}}}, {"text": "If you need to build your query string, just use a StringBuilder", "label": {"api": {"StringBuilder": [[51, 63]]}}}, {"text": "I would propose a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[18, 30]]}}}, {"text": "So, I've read the Object#wait() method documentation and decided that it perfectly satisfies my needs", "label": {"api": {"Object#wait()": [[18, 30]]}}}, {"text": "Here's how my implementation of the Future#get() method looks", "label": {"api": {"Future#get()": [[36, 47]]}}}, {"text": "@SequenceGenerator defines the generator to be used for generating entity's primary keys", "label": {"api": {"@SequenceGenerator": [[0, 17]]}}}, {"text": "Its name attribute gives it a name to reference it by in the @GeneratedValue annotation", "label": {"api": {"@GeneratedValue": [[61, 75]]}}}, {"text": "Next you have @GeneratedValue", "label": {"api": {"@GeneratedValue": [[14, 28]]}}}, {"text": "The answer to the question can be read from javadoc to @SequenceGenerator", "label": {"api": {"@SequenceGenerator": [[55, 72]]}}}, {"text": "In that case, I recommend to define @SequenceGenerator on an entity similarly to named queries, instead of defining it on a particular PK", "label": {"api": {"@SequenceGenerator": [[36, 53]]}}}, {"text": "If you don't, a default generator would be used, which is completely different from the one defined by any @SequenceGenerator", "label": {"api": {"@SequenceGenerator": [[107, 124]]}}}, {"text": "You may even put the @SequenceGenerator annotation on a different entity, it does not make any difference, provided that you still reference it by its name in generator field of @GeneratedValue", "label": {"api": {"@SequenceGenerator": [[21, 38]]}}}, {"text": "Call flush() and the waiting data will be written immediately", "label": {"api": {"flush()": [[5, 11]]}}}, {"text": "Oracle's NUMERIC and DECIMAL can indeed be mapped to java.math.BigDecimal", "label": {"api": {"java.math.BigDecimal": [[53, 72]]}}}, {"text": "Comparisons are done with the compareTo method, like this", "label": {"api": {"compareTo": [[30, 38]]}}}, {"text": "For example \"add\" is an optional operation, because immutable collections should not allow it", "label": {"api": {"\"add\" is an optional operation": [[12, 41]]}}}, {"text": "It sounds like you you shouldn't be using a JButton at all, but rather you should be using a JToggleButton, one that stays selected after pressing, until pressed again", "label": {"api": {"JToggleButton": [[93, 105]]}}}, {"text": "To get this behavior, add your JToggleButtons to a single ButtonGroup object, similar to how you would do this for JRadioButtons", "label": {"api": {"JToggleButton": [[31, 43]]}}}, {"text": "It doesn't work because remove operation requires managed entity to be passed to it", "label": {"api": {"remove": [[24, 29]]}}}, {"text": "Because merge returns managed entity instance, you can call remove with the object it returns, because it is managed by JPA (the object you pass to merge is not affected, which is why your code fails)", "label": {"api": {"merge": [[8, 12], [148, 152]], "remove": [[60, 65]]}}}, {"text": "Use ArrayList::get(int index) and ArrayList::set(int index, T value)", "label": {"api": {"ArrayList::get(int index)": [[4, 28]], "ArrayList::set(int index, T value)": [[34, 67]]}}}, {"text": "You can find this in its documentation", "label": {"api": {"its documentation": [[21, 37]]}}}, {"text": "For its part, the constructor ArrayList(Collection) is documented to fill the list in the order that elements are returned by the specified Collection's iterator", "label": {"api": {"is documented": [[52, 64]]}}}, {"text": "You can use Scanner class", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "Use parenthesis in order to group the matches, try with", "label": {"api": {"group": [[28, 32]]}}}, {"text": "From the javadoc of String.valueOf(Object obj)", "label": {"api": {"String.valueOf(Object obj)": [[20, 45]]}}}, {"text": "Using a ReentrantReadWriteLock is perfectly suited for that", "label": {"api": {"ReentrantReadWriteLock": [[8, 29]]}}}, {"text": "This can be done in an elegant fashion using DateTimeFormatter optional sections", "label": {"api": {"DateTimeFormatter": [[45, 61]]}}}, {"text": "The DateTimeFormatterBuilder class contains the building blocks to make this work", "label": {"api": {"DateTimeFormatterBuilder": [[4, 27]]}}}, {"text": "The parseDefaulting() method allows a default value to be set for a specific field", "label": {"api": {"parseDefaulting()": [[4, 20]]}}}, {"text": "The split method was introduced much earlier", "label": {"api": {"much earlier": [[32, 43]]}}}, {"text": "And the callback Runnables are passed to their associated Executor on the same thread that executes the asyncTask because the ListeningExecutorService effectively wraps your asyncTask in a FutureTask that calls all callbacks when its done() method is called", "label": {"api": {"FutureTask": [[189, 198]]}}}, {"text": "UnsupportedOperationException of the Java Collections Framework", "label": {"api": {"UnsupportedOperationException": [[0, 28]]}}}, {"text": "While not using an ArrayList (a dynamic sized array), here is a quick fix", "label": {"api": {"ArrayList": [[19, 27]]}}}, {"text": "List class in Java 8 has a new method sort added to it", "label": {"api": {"List": [[0, 3]]}}}, {"text": "You should go for List.sort", "label": {"api": {"List.sort": [[18, 26]]}}}, {"text": "Example of using List.sort, to sort a list of String with respect to the length of the elements", "label": {"api": {"List.sort": [[17, 25]]}}}, {"text": "While it is true that putIfAbsent will always return the current value if there is a mapping for that key, the notion of \"previous value\" is introduced here to be consistent with the definition of Map.put, which returns the previous value", "label": {"api": {"Map.put": [[197, 203]]}}}, {"text": "It refers to the aligmentProperty of the Labeleled", "label": {"api": {"aligmentProperty": [[17, 32]]}}}, {"text": "Quoting the Javadoc of Stream.reduce", "label": {"api": {"Stream.reduce": [[23, 35]]}}}, {"text": "It's part of the contract of the Map interface", "label": {"api": {"Map interface": [[33, 45]]}}}, {"text": "The cast to TreeSet<String> is needed because subSet() is a method of the SortedSet interface and returns a SortedSet, but it's covariant because the TreeSet implementation returns a view (another efficiency benefit), which is of course another TreeSet", "label": {"api": {"TreeSet implementation": [[150, 171]]}}}, {"text": "A canonical example is Java's Formatter", "label": {"api": {"Formatter": [[30, 38]]}}}, {"text": "If you want to initialize a Map in a single statement, you can use Collectors.toMap", "label": {"api": {"Collectors.toMap": [[67, 82]]}}}, {"text": "but also can implement Initializable interface", "label": {"api": {"Initializable": [[23, 35]]}}}, {"text": "If you're in another thread, you can use invokeAndWait", "label": {"api": {"invokeAndWait": [[41, 53]]}}}, {"text": "There's no parse method with List<String> as a parameter which is why your code won't compile", "label": {"api": {"parse": [[11, 15]]}}}, {"text": "There's a parse that accepts a String", "label": {"api": {"parse": [[10, 14]]}}}, {"text": "The process method takes a List<V> as argument", "label": {"api": {"process": [[4, 10]]}}}, {"text": "You should not call directly process from the doInBackground method", "label": {"api": {"process": [[29, 35]]}}}, {"text": "Then you're trying to find the square root of -22, which, according to Math.sqrt(), is NaN", "label": {"api": {"Math.sqrt()": [[71, 81]]}}}, {"text": "Use Math.pow(z, 2), or simply use z * z instead", "label": {"api": {"Math.pow(z, 2)": [[4, 17]]}}}, {"text": "From java reference ( http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html )", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html": [[22, 81]]}}}, {"text": "A Java Path belongs to a FileSystem", "label": {"api": {"Path": [[7, 10]], "FileSystem": [[25, 34]]}}}, {"text": "A file system is implemented by a FileSystemProvider", "label": {"api": {"FileSystem": [[34, 43]], "FileSystemProvider": [[34, 51]]}}}, {"text": "WindowsFileSystemProvider), and one for zip files (ZipFileSystemProvider)", "label": {"api": {"FileSystem": [[7, 16], [54, 63]], "FileSystemProvider": [[7, 24], [54, 71]]}}}, {"text": "To get a Path to a file inside a Jar file, you need to get (create) a FileSystem for the content of the Jar file", "label": {"api": {"Path": [[9, 12]], "FileSystem": [[70, 79]]}}}, {"text": "You can then get a Path to a file in that file system", "label": {"api": {"Path": [[19, 22]]}}}, {"text": "Once you have those, you can create a FileSystem and get a Path to the jar'd file", "label": {"api": {"Path": [[59, 62]], "FileSystem": [[38, 47]]}}}, {"text": "Remember that FileSystem is an open resource and needs to be closed when you are done with it", "label": {"api": {"FileSystem": [[14, 23]]}}}, {"text": "You are looking for asynchronous responses which are supported by JAX-RS", "label": {"api": {"asynchronous responses": [[20, 41]]}}}, {"text": "With asynchronous responses, the thread that is responsible for answering a request is freed for handling another request already before a request is completed", "label": {"api": {"asynchronous responses": [[5, 26]]}}}, {"text": "What you would need to do additionally, would be to register a dedicated scheduler that is responsible for waking up your requests after a given time-out like in this example", "label": {"api": {"scheduler": [[73, 81]]}}}, {"text": "If you don't want to write your own custom class for every such use, you can utilize an existing type, such as AbstractMap.SimpleEntry", "label": {"api": {"AbstractMap.SimpleEntry": [[111, 133]]}}}, {"text": "It's hard to say from these ObjectNames, but I noticed there are 2 Kafka domains that are not quoted so my conjecture is that the JMX developer was trying to deal with key properties that contained JMX disallowed characters (or conditions where one might expect the same)", "label": {"api": {"quote": [[94, 98]]}}}, {"text": "Seems in this case they elected to simply quote the whole ObjectName", "label": {"api": {"quote": [[42, 46]]}}}, {"text": "Just use a map", "label": {"api": {"map": [[11, 13]]}}}, {"text": "Anyway, it would be more efficient to find the [ and ] with String#indexOf() and get the date string with String#substring()", "label": {"api": {"String#indexOf()": [[60, 75]], "String#substring()": [[106, 123]]}}}, {"text": "An extended FutureTask can be used (there are other options like the RejectedExecutionHandler) to perform the computation using the current thread in case the computation (the Callable in the code below) cannot be done concurrently", "label": {"api": {"FutureTask": [[12, 21]], "RejectedExecutionHandler": [[69, 92]]}}}, {"text": "Also please have a look at the WatchService java spec, reading documentation usually helps a lot", "label": {"api": {"WatchService java spec": [[31, 52]]}}}, {"text": "When you look at the official documentation you will see the explanation of the six parameters that this constructor uses", "label": {"api": {"official documentation": [[21, 42]]}}}, {"text": "Since the Desktop.open method requires a File object, you need to get an InputStream of your resource, copy it to a File in a temporary folder and open that new file", "label": {"api": {"Desktop.open": [[10, 21]]}}}, {"text": "Agents may also append other JARs to bootstrap classpath or system classpath by calling Instrumentation.appendToBootstrapClassLoaderSearch or Instrumentation.appendToSystemClassLoaderSearch respectively", "label": {"api": {"Instrumentation.appendToBootstrapClassLoaderSearch": [[88, 137]], "Instrumentation.appendToSystemClassLoaderSearch": [[142, 188]]}}}, {"text": "Just would like to suggest an improvement to handle the case of null list using Optional.ofNullable, new feature in Java 8", "label": {"api": {"new feature in Java 8": [[101, 121]]}}}, {"text": "I believe Collections.indexOfSubList implements this", "label": {"api": {"Collections.indexOfSubList": [[10, 35]]}}}, {"text": "You should use Collections.sort instead of Arrays.sort since you are sorting a Collection and not an array", "label": {"api": {"Collections.sort": [[15, 30]], "Arrays.sort": [[43, 53]]}}}, {"text": "What serializer is Entity.json(T entity) using to serialize/deserialize objects", "label": {"api": {"Entity.json(T entity)": [[19, 39]]}}}, {"text": "If you're using  String userObject = \"Anna\"; new DefaultMutableTreeNode(userObject);, then you might be able to use the DefaultMutableTreeNode#getUserObject() method", "label": {"api": {"new DefaultMutableTreeNode(userObject);": [[45, 83]], "DefaultMutableTreeNode#getUserObject()": [[120, 157]]}}}, {"text": "Looking at ItemEvent API you have getItemSelectable() method", "label": {"api": {"ItemEvent API": [[11, 23]]}}}, {"text": "Calendar.DATE represents the day of the month, not the day of the year", "label": {"api": {"Calendar.DATE": [[0, 12]], "Calendar": [[0, 7]]}}}, {"text": "Thus, when rolling the day of the month backwards of 1 unit, we are essentially going from the 1st to the last day of the month", "label": {"api": {"roll": [[11, 14]]}}}, {"text": "Quoting the roll Javadoc (emphasis mine)", "label": {"api": {"roll": [[12, 15]]}}}, {"text": "and quoting the Calendar Javadoc", "label": {"api": {"Calendar": [[16, 23]]}}}, {"text": "As such, fields like MONTH or YEAR are not changed by this method when rolling the day of the month", "label": {"api": {"roll": [[71, 74]]}}}, {"text": "You should use Calendar.DAY_OF_YEAR instead", "label": {"api": {"Calendar": [[15, 22]], "Calendar.DAY_OF_YEAR": [[15, 34]]}}}, {"text": "You may want to rely on the Class.isInstanceOf(Object)", "label": {"api": {"Class.isInstanceOf(Object)": [[28, 53]]}}}, {"text": "It appears to me like JMS TextMessage containing Java.lang.String isn't recognizing \\r\\n as line-break but instead treating the CR LF as part of input on a Windows machine", "label": {"api": {"TextMessage": [[26, 36]]}}}, {"text": "From the documentation of PrintStream#format()", "label": {"api": {"PrintStream#format()": [[26, 45]]}}}, {"text": "That means that PrintStream#format() will write the values to the output stream but you then append its toString representation which looks like java.io.PrintStream@1909752 to the row variable which you then print out to the same output stream", "label": {"api": {"PrintStream#format()": [[16, 35]]}}}, {"text": "You should use String.format() instead if you wish to append the formatted result to a String variable", "label": {"api": {"String.format()": [[15, 29]]}}}, {"text": "The contract of the compareTo method is to return a positive integer, 0 or a negative integer depending on whether the number is greater, equal or less than the given number", "label": {"api": {"compareTo": [[20, 28]]}}}, {"text": "Part.write() is a convenience method to write this uploaded item to disk, so you can just use part.write(SAVE_DIR + part.getSubmittedFileName()); and it's all handled for you (note that getSubmittedFileName() is available only for Servlet 3.1)", "label": {"api": {"Part.write()": [[0, 11]]}}}, {"text": "Best is to use ArrayList if you are allowed to do that", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "Stop using the outmoded java.util.Date class and embrace the power of the java.time API built into Java 8 and later (tutorial)", "label": {"api": {"java.time API": [[74, 86]]}}}, {"text": "Specifically, the DateTimeFormatter, LocalDate, and ChronoUnit classes", "label": {"api": {"DateTimeFormatter": [[18, 34]], "LocalDate": [[37, 45]], "ChronoUnit": [[52, 61]]}}}, {"text": "in the Javadoc of the Collectors class", "label": {"api": {"Collectors": [[22, 31]]}}}, {"text": "The typical key-value text file storage in Java is the Properties", "label": {"api": {"Properties": [[55, 64]]}}}, {"text": "java.lang.String implements java.lang.Comparable, so you could just do", "label": {"api": {"java.lang.String": [[0, 15]], "java.lang.Comparable": [[28, 47]]}}}, {"text": "You need to use FXCollections.observableList instead of FXCollections.observableArrayList", "label": {"api": {"FXCollections.observableList": [[16, 43]], "FXCollections.observableArrayList": [[56, 88]]}}}, {"text": "You should call addMouseMotionListener to register it", "label": {"api": {"addMouseMotionListener": [[16, 37]]}}}, {"text": "as the official oracle documentation says is not generally permissible for one thread to modify a Collection while another thread is iterating over it", "label": {"api": {"official oracle documentation says": [[7, 40]]}}}, {"text": "One-liner using DecimalFormat", "label": {"api": {"DecimalFormat": [[16, 28]]}}}, {"text": "An option can be to build one (or more) OSGi bundles (modules) from your application, listen to file change events ( https://blogs.oracle.com/thejavatutorials/entry/watching_a_directory_for_changes ), recompile and re-package the changed code using the built-in compiler ( http://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.html ) then update the new OSGi bundle", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.html": [[273, 342]]}}}, {"text": "If you like to know the allowed date format words in your currently used Locale, then you can try the following snippet, which uses the DateFormatSymbols class", "label": {"api": {"DateFormatSymbols": [[136, 152]]}}}, {"text": "You can also pass a Locale to the DateFormatSymbols constructor to get these strings from the specific locale", "label": {"api": {"DateFormatSymbols": [[34, 50]]}}}, {"text": "Use one integer semaphore, allowing 2 balls entering till other balls block", "label": {"api": {"semaphore": [[16, 24]]}}}, {"text": "If you want to allow only alphanumeric characters you can use a regex with \\w and leverage String.matches like", "label": {"api": {"String.matches": [[91, 104]]}}}, {"text": "And then using WindowsListener I change this \"property\" within windowIconified(), windowDeiconified() methods, but I feel like I'm missing something", "label": {"api": {"WindowsListener": [[15, 29]]}}}, {"text": "Alternatively, using Math.rint", "label": {"api": {"Math.rint": [[21, 29]]}}}, {"text": "You can use System.arrayCopy() to simplify your code", "label": {"api": {"System.arrayCopy()": [[12, 29]]}}}, {"text": "In your question if a Number can hold an Integer, you should see the inheritance of Integer in the Javadocs that it inherits from Number", "label": {"api": {"Number": [[22, 27], [130, 135]], "Integer": [[41, 47], [84, 90]]}}}, {"text": "You can also see that Number inherits from Object", "label": {"api": {"Number": [[22, 27]]}}}, {"text": "The static initializer code then calls into the JDBC framework to say \"Hi there, I'm a JDBC driver\" (by calling DriverManager.registerDriver)", "label": {"api": {"DriverManager.registerDriver": [[112, 139]]}}}, {"text": "Now i am trying to play a bit with different classes of java.lang package, and i cant call some public methods in the form (.Method), for example (.totalMemory) of the Runtime Class throws IllegalArgumentException", "label": {"api": {"totalMemory": [[148, 158]]}}}, {"text": "Quoting from the List.equals Javadoc", "label": {"api": {"List.equals": [[17, 27]]}}}, {"text": "Therefore, to check if a value exist, you can create a list and call containsValue with that List, because this method will call equals to determine equality", "label": {"api": {"containsValue": [[69, 81]]}}}, {"text": "You can easily create a List from an array of values with Arrays.asList", "label": {"api": {"Arrays.asList": [[58, 70]]}}}, {"text": "You could simplify this method considerably by using the retainAll method", "label": {"api": {"retainAll": [[57, 65]]}}}, {"text": "Most often developers simply use the ready solution, LinkedList", "label": {"api": {"LinkedList": [[53, 62]]}}}, {"text": "You can use a DataOutputStream to write your primitive types and Strings to a ByteArrayOutputStream", "label": {"api": {"DataOutputStream": [[14, 29]], "ByteArrayOutputStream": [[78, 98]]}}}, {"text": "You can then use toByteArray() to get a byte[] that you put into a ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[67, 86]], "InputStream": [[76, 86]]}}}, {"text": "You can wrap that InputStream in a DataInputStream to get back your primitives", "label": {"api": {"InputStream": [[18, 28], [39, 49]], "DataInputStream": [[35, 49]]}}}, {"text": "If you're doing a school assignment where you need to implement this yourself (which sounds like a dumb assignment), you can look up the implementations of ByteArrayOutputStream and ByteArrayInputStream on GrepCode", "label": {"api": {"ByteArrayOutputStream": [[156, 176]], "ByteArrayInputStream": [[182, 201]], "InputStream": [[191, 201]]}}}, {"text": "The Random class has a nextInt(int) method that makes it easy to select a value", "label": {"api": {"Random": [[4, 9]], "nextInt(int)": [[23, 34]]}}}, {"text": "As it says in the Javadoc for java.util.ArrayList", "label": {"api": {"Javadoc for java.util.ArrayList": [[18, 48]]}}}, {"text": "Also, consider using StringBuilder instead of all the String concatenations", "label": {"api": {"StringBuilder": [[21, 33]]}}}, {"text": "tells it to append when it's set to true, as you can see on the docs", "label": {"api": {"on the docs": [[57, 67]]}}}, {"text": "The Stream implementation is separated to Spliterator (which is input-specific code) and pipeline (which is input-independent code)", "label": {"api": {"Spliterator": [[42, 52]]}}}, {"text": "The Spliterator is similar to Iterator", "label": {"api": {"Spliterator": [[4, 14]]}}}, {"text": "There are also primitive specializations of Spliterator interface (Spliterator.OfInt, etc.) which can help you process primitive values like int, long or double efficiently", "label": {"api": {"Spliterator": [[44, 54], [67, 77]], "Spliterator.OfInt": [[67, 83]]}}}, {"text": "Thus to create your own Stream datasource you have to implement Spliterator, then call StreamSupport.stream(mySpliterator, isParallel) to create the Stream and StreamSupport.int/long/doubleStream for primitive specializations", "label": {"api": {"Spliterator": [[64, 74], [110, 120]], "StreamSupport.stream(mySpliterator, isParallel)": [[87, 133]]}}}, {"text": "Implementing the Spliterator is much simpler than implementing the whole stream pipeline (especially taking into account the parallel processing), so such separation makes sense", "label": {"api": {"Spliterator": [[17, 27]]}}}, {"text": "If you want to create your own stream source, you may start extending AbstractSpliterator", "label": {"api": {"Spliterator": [[78, 88]], "AbstractSpliterator": [[70, 88]]}}}, {"text": "The AbstractSpliterator provides default splitting behavior by reading a part of your source into array (calling your implemented tryAdvance method) and creating array-based spliterator for this prefix", "label": {"api": {"Spliterator": [[12, 22]], "AbstractSpliterator": [[4, 22]]}}}, {"text": "I would also recommend You to use unmodifiableMap from java.util.Collections or ImmutableMap from guava, to make sure it won't be changed during runtime", "label": {"api": {"unmodifiableMap": [[34, 48]]}}}, {"text": "PreparedStatement.setClob(int parameterIndex, Reader reader) was adding in Java 6, and you're using the JDBC driver from before that", "label": {"api": {"PreparedStatement.setClob(int parameterIndex, Reader reader)": [[0, 59]]}}}, {"text": "Let your Foo class implement Serializable, then you can use ObjectOutputStream to write your object to disk", "label": {"api": {"Serializable": [[29, 40]], "ObjectOutputStream": [[60, 77]]}}}, {"text": "A more efficient way will be to store the list of keywords in a Set and also the list of tokens on each line in a set", "label": {"api": {"Set": [[64, 66]]}}}, {"text": "You can use a ContainerRequestFilter, construct a new URI (based on the existing one), and set the URI in the ContainerRequestContext via the setRequestUri method", "label": {"api": {"setRequestUri": [[142, 154]]}}}, {"text": "With this approach however, I haven't found a way to replace individual path params based on param names from the matched Jersey resource's URI template, since \"setRequestUri\" is only allowed in the pre resource matching phase", "label": {"api": {"setRequestUri": [[161, 173]]}}}, {"text": "Your example uses getSelectionModel() to get the the list's ListSelectionModel, and it adds your listener directly to the selection model", "label": {"api": {"ListSelectionModel": [[60, 77]]}}}, {"text": "This bypasses the ListSelectionHandler, used internally by JList, which never gets a chance to fireSelectionValueChanged()", "label": {"api": {"JList": [[59, 63]]}}}, {"text": "Instead, let JList add your listener", "label": {"api": {"JList": [[13, 17]]}}}, {"text": "when I click an item on the JList, nothing is printed", "label": {"api": {"JList": [[28, 32]]}}}, {"text": "To add elements to the list, don't create a new JList; update the list's ListModel instead", "label": {"api": {"JList": [[48, 52]]}}}, {"text": "DataOutputStream is for writing values in a binary format that can be read again by DataInputStream", "label": {"api": {"DataOutputStream": [[0, 15]], "DataInputStream": [[84, 98]]}}}, {"text": "Use a PrintWriter for that", "label": {"api": {"PrintWriter": [[6, 16]]}}}, {"text": "You can grab the stream of the map's entry set, then map each entry to the string representation you want, joining them in a single string using Collectors.joining(CharSequence delimiter)", "label": {"api": {"Collectors.joining(CharSequence delimiter)": [[145, 186]]}}}, {"text": "This is the Timestamp class API", "label": {"api": {"API": [[28, 30]]}}}, {"text": "You can use ByteBuffer.wrap() with your full array", "label": {"api": {"ByteBuffer.wrap()": [[12, 28]]}}}, {"text": "You can either wrap on each call or manipulate the buffer's offset as needed with .position(int)", "label": {"api": {".position(int)": [[82, 95]]}}}, {"text": "The method you want is String.contains(CharSequence)", "label": {"api": {"String.contains(CharSequence)": [[23, 51]]}}}, {"text": "If you want to do it in a Java EE fashion, then you should inject a Conversation Scoped Session bean into the Servlet", "label": {"api": {"Conversation": [[68, 79]]}}}, {"text": "according to this Java page the File.setReadOnly() function is now a \"legacy\" function and should be replaced by Files.setAttribute()..", "label": {"api": {"File.setReadOnly()": [[32, 49]], "Files.setAttribute()": [[113, 132]]}}}, {"text": "If you're on Java 8, have a look at how the Stream.filter() method works", "label": {"api": {"Stream.filter()": [[44, 58]]}}}, {"text": "If you're not on Java 8, look at it anyway, because it's a good example of how to do it, which is to define an interface (Java 8 uses Predicate<T>) that has one method boolean test(T t)", "label": {"api": {"Predicate<T>": [[134, 145]]}}}, {"text": "You can use a StringBuilder to accumulate all the messages, and then display them, once, after the loop is done", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "To print the string representation of an array, use Arrays.toString(Object[])", "label": {"api": {"Arrays.toString(Object[])": [[52, 76]]}}}, {"text": "Use String.toCharArray() to convert the input to a char[]", "label": {"api": {"String": [[4, 9]]}}}, {"text": "Refer to the String javadocs", "label": {"api": {"String": [[13, 18]]}}}, {"text": "You should use the Task.updateProgress method", "label": {"api": {"Task.updateProgress": [[19, 37]]}}}, {"text": "Use string tokenizer to split the lines by spaces", "label": {"api": {"string tokenizer": [[4, 19]]}}}, {"text": "I used the method next() from the Scanner class in the code below", "label": {"api": {"Scanner": [[34, 40]]}}}, {"text": "The variable length of each field is handled by the call to appendValue(field)", "label": {"api": {"appendValue(field)": [[60, 77]]}}}, {"text": "This is done by using parseDefaulting(field, value) for each field of a LocalTime", "label": {"api": {"parseDefaulting(field, value)": [[22, 50]]}}}, {"text": "the minimum value for the range of valid values for that field (it is obtained by calling getMinimum to the ValueRange of that field; perhaps we could also hard-code 0 here)", "label": {"api": {"getMinimum": [[90, 99]], "ValueRange": [[108, 117]]}}}, {"text": "BufferedReader.lines() is a new method in Java 8 which I'm not too familiar with", "label": {"api": {"BufferedReader.lines()": [[0, 21]]}}}, {"text": "Java 8 added loads of default methods onto interfaces in the collections framework; however, the JavaDoc of the Collections.synchronizedX methods barely changed", "label": {"api": {"Collections.synchronizedX": [[112, 136]]}}}, {"text": "Quoting the Javadoc of findAny()", "label": {"api": {"findAny()": [[23, 31]]}}}, {"text": "You could use a CompletionService and submit all the tasks to it", "label": {"api": {"CompletionService": [[16, 32]]}}}, {"text": "Then, CompletionService.take() will return the Future of the first completed task", "label": {"api": {"CompletionService": [[6, 22]], "CompletionService.take()": [[6, 29]]}}}, {"text": "LinkedList does not override iterator() and the default implementation, defined in AbstractSequentialList is to call listIterator(), and LinkedList does override listIterator", "label": {"api": {"LinkedList": [[0, 9], [137, 146]], "iterator()": [[29, 38]], "AbstractSequentialList": [[83, 104]], "listIterator": [[117, 128], [162, 173]]}}}, {"text": "Quoting the documentation of LinkedList.listIterator", "label": {"api": {"LinkedList": [[29, 38]], "listIterator": [[40, 51]]}}}, {"text": "What you want is to use explicitely a ListIterator, instead of an Iterator, and use ListIterator.add", "label": {"api": {"ListIterator": [[38, 49], [84, 95]], "ListIterator.add": [[84, 99]]}}}, {"text": "Either use a StringTokenizer, where you can pass the delimiters as a String, and then loop over it (See this example) or even better use String.split with a regexp", "label": {"api": {"StringTokenizer": [[13, 27]]}}}, {"text": "Specifically, the MemoryMXBean will provide access to the different JVM heaps", "label": {"api": {"MemoryMXBean": [[18, 29]]}}}, {"text": "The documentation for DataOutput.writeUTF is pretty informative, though", "label": {"api": {"documentation for DataOutput.writeUTF": [[4, 40]]}}}, {"text": "The FileHandler uses the java.io.FileOutputStream to write log records", "label": {"api": {"java.io.FileOutputStream": [[25, 48]]}}}, {"text": "If a write fails then the FileHandler will fallback to using the assigned ErrorManager", "label": {"api": {"assigned ErrorManager": [[65, 85]]}}}, {"text": "You can avoid any switch or if/else statements with the new Java 1.8 time API using java.time.Month", "label": {"api": {"java.time.Month": [[84, 98]]}}}, {"text": "Don't pass startOffset into the read method", "label": {"api": {"the read method": [[28, 42]]}}}, {"text": "If you need to add \"dates\" or days to your date, you can use Calendar (http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html) for that", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html": [[71, 134]]}}}, {"text": "If you're using java 7-, the java.util.Calendar class provides an add method which you could utilize to increment the day/month/year/etc by any amount you'd like", "label": {"api": {"java.util.Calendar": [[29, 46]], "add": [[66, 68]]}}}, {"text": "Here's an example which adds 5 days to a given calendar instance", "label": {"api": {"add": [[24, 26]]}}}, {"text": "As @LouisWasserman mentioned, you can use ByteBuffer", "label": {"api": {"ByteBuffer": [[42, 51]]}}}, {"text": "You could programatically run the emulator using Runtime.exec() from within the body of your test method", "label": {"api": {"Runtime.exec()": [[49, 62]]}}}, {"text": "There is already a class to generate random numbers, you could use it", "label": {"api": {"class": [[19, 23]]}}}, {"text": "The reason is that you haven't progressed the cursor of the ResultSet by calling next() before accessing the data with getInt() / getString()", "label": {"api": {"next()": [[81, 86]]}}}, {"text": "If you want to loop through the whole result set, use while (rs.next()) instead", "label": {"api": {"next()": [[64, 69]]}}}, {"text": "Your second code snippet works because you are moving the cursor to the last position with rs.last() before accessing the column values for the first time", "label": {"api": {"rs.last()": [[91, 99]]}}}, {"text": "Please note that you should always inspect the return value of rs.next() / rs.last() / rs.first() methods before accessing the column values", "label": {"api": {"next()": [[66, 71]], "rs.last()": [[75, 83]]}}}, {"text": "If you need to initialize your buffer variable with an array you become from string, you need to use System#arraycopy method", "label": {"api": {"System#arraycopy": [[101, 116]]}}}, {"text": "With http://docs.oracle.com/javase/8/docs/api/java/nio/channels/AsynchronousSocketChannel.html you can make sure by repeating the reads until you have full message", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/nio/channels/AsynchronousSocketChannel.html": [[5, 93]]}}}, {"text": "You should use one of the implementations of BlockingQueue", "label": {"api": {"BlockingQueue": [[45, 57]]}}}, {"text": "I most commonly use ArrayBlockingQueue as it allows me to limit the memory footprint of the solution", "label": {"api": {"BlockingQueue": [[25, 37]], "ArrayBlockingQueue": [[20, 37]]}}}, {"text": "A LinkedBlockingDeque can be used for an unlimited size but be certain you cannot overload memory", "label": {"api": {"LinkedBlockingDeque": [[2, 20]]}}}, {"text": "Here are two threads communicating between themselves using an ArrayBlockingQueue", "label": {"api": {"BlockingQueue": [[68, 80]], "ArrayBlockingQueue": [[63, 80]]}}}, {"text": "For this use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[13, 28]]}}}, {"text": "You would then use writeUTF(String s) to write your Employee object as an XML string and then use readUTF() to get your XML string back", "label": {"api": {"writeUTF(String s)": [[19, 36]], "readUTF()": [[98, 106]]}}}, {"text": "The typical example is Function", "label": {"api": {"Function": [[23, 30]]}}}, {"text": "Function is an functional interface whose functional method, apply, is a method that takes a single argument and return a result", "label": {"api": {"Function": [[0, 7]], "apply": [[61, 65]]}}}, {"text": "(The FunctionalInterface annotation is not strictly necessary but it gives a clear intent)", "label": {"api": {"Function": [[5, 12]], "FunctionalInterface": [[5, 23]]}}}, {"text": "You may run your code that initializes the other classes in the init() method of one of your servlets", "label": {"api": {"init()": [[64, 69]]}}}, {"text": "System.arrayCopy does that for you", "label": {"api": {"System.arrayCopy": [[0, 15]]}}}, {"text": "You could use boxed()", "label": {"api": {"boxed()": [[14, 20]]}}}, {"text": "This maps a DoubleStream (Stream of primitive doubles, as returned by mapToDouble) to a Stream<Double>", "label": {"api": {"mapToDouble": [[70, 80]]}}}, {"text": "Note that I changed Double::valueOf to Double::parseDouble", "label": {"api": {"Double::valueOf": [[20, 34]], "Double::parseDouble": [[39, 57]]}}}, {"text": "But why are you using mapToDouble to begin with", "label": {"api": {"mapToDouble": [[22, 32]]}}}, {"text": "I was originally using basic functionality of Java's String.matchAll(String expression, String occurence); but now I use Pattern and Matcher classes", "label": {"api": {"String.matchAll(String expression, String occurence);": [[53, 105]]}}}, {"text": "You can use Comparator.reverseOrder() to have a comparator giving the reverse of the natural ordering", "label": {"api": {"Comparator.reverseOrder()": [[12, 36]]}}}, {"text": "If you want to reverse the ordering of an existing comparator, you can use Comparator.reversed()", "label": {"api": {"Comparator.reversed()": [[75, 95]]}}}, {"text": "By default, quoting the Javadoc of split(regex)", "label": {"api": {"split(regex)": [[35, 46]]}}}, {"text": "Quoting the Javadoc of split(regex, limit), about the limit parameter", "label": {"api": {"split(regex, limit)": [[23, 41]]}}}, {"text": "An ExecutorService provides robust, high-level support for general purpose parallel processing", "label": {"api": {"ExecutorService": [[3, 17]], "parallel": [[75, 82]]}}}, {"text": "In this example, the ExecutorService is created and destroyed with every request, which is costly", "label": {"api": {"ExecutorService": [[21, 35]]}}}, {"text": "In that case, you may want a cached thread pool instead of a fixed thread pool", "label": {"api": {"cached thread pool": [[29, 46]]}}}, {"text": "The newer ForkJoinPool, or the parallel Stream functionality built on fork-join could also be used, but it's suitable for a narrower set of tasks", "label": {"api": {"ForkJoinPool": [[10, 21]], "parallel": [[31, 38]], "Stream": [[40, 45]]}}}, {"text": "If the tasks don't block or throw checked exceptions, Stream is concise", "label": {"api": {"Stream": [[54, 59]]}}}, {"text": "If the tasks are time-consuming but can easily be recursively sub-divided into smaller tasks, ForkJoinPool might be worth using", "label": {"api": {"ForkJoinPool": [[94, 105]]}}}, {"text": "Here's an example using a Stream", "label": {"api": {"Stream": [[26, 31]]}}}, {"text": "This task is done via java.security.CertificateFactory", "label": {"api": {"java.security.CertificateFactory": [[22, 53]]}}}, {"text": "You can use flatMap", "label": {"api": {"flatMap": [[12, 18]]}}}, {"text": "flatMap is good for \"flattening\" nested collections", "label": {"api": {"flatMap": [[0, 6]]}}}, {"text": "To do this, you could subclass ModifiableObservableListBase, delegating it to a LinkedList, and implement Deque, also delegating those methods to the LinkedList", "label": {"api": {"ModifiableObservableListBase": [[31, 58]]}}}, {"text": "You'll have to look at the Javadoc of the Formatter-Class to find it", "label": {"api": {"Javadoc of the Formatter-Class": [[27, 56]]}}}, {"text": "Then, I found WebApplicationException which is an unchecked exception, returns a HTTP status code but does not allow me to set message as in a regular exception", "label": {"api": {"WebApplicationException": [[14, 36]]}}}, {"text": "In Java 9 there's a new filtering collector", "label": {"api": {"filtering": [[24, 32]]}}}, {"text": "What you want to do is have a Map<Character,Character> where key will be correct Character that in the String and the value should be Character that is encoded", "label": {"api": {"Map<Character,Character>": [[30, 53]]}}}, {"text": "Correct way is usage of ProcessBuilder", "label": {"api": {"ProcessBuilder": [[24, 37]]}}}, {"text": "Or some sort of a Collection, such as an ArrayList", "label": {"api": {"ArrayList": [[41, 49]]}}}, {"text": "you could use a case insensitive string comparison rather than toUpperCase", "label": {"api": {"a case insensitive string comparison": [[14, 49]]}}}, {"text": "ByteBuffer#wrap has a limitation on what's allowed to be the length", "label": {"api": {"has a limitation": [[16, 31]]}}}, {"text": "Although I absolutely agree with @Tagir's answer (and believe it should be accepted), to be fair one can make restrictions on what classes can implement what interfaces in runtime if he uses his own implementation of ClassLoader", "label": {"api": {"ClassLoader": [[217, 227]]}}}, {"text": "3 digits after the decimal point), you need to use a BigDecimal for this", "label": {"api": {"BigDecimal": [[53, 62]]}}}, {"text": "The divide(divisor, scale, roundingMode) function of BigDecimal can take a scale (here set to 3) and a rounding mode (here set to DOWN, this rounding mode truncates after the scale has been reached, which is what we want here)", "label": {"api": {"BigDecimal": [[53, 62]], "divide(divisor, scale, roundingMode)": [[4, 39]], "DOWN": [[130, 133]]}}}, {"text": "You can register a HttpSessionListener on the ServletContext to get notified when a session is invalidated", "label": {"api": {"HttpSessionListener": [[19, 37]]}}}, {"text": "The problem is that you are not using the correct BigInteger constructor", "label": {"api": {"BigInteger": [[50, 59]]}}}, {"text": "The BigInteger byte array constructor is designed to reconstruct a BigInteger from the output of BigInteger.toByteArray()", "label": {"api": {"BigInteger": [[4, 13], [67, 76], [97, 106]], "BigInteger byte array constructor": [[4, 36]], "BigInteger.toByteArray()": [[97, 120]]}}}, {"text": "Java represents BigIntegers in byte arrays using something similar to a twos-complement scheme", "label": {"api": {"BigInteger": [[16, 25]]}}}, {"text": "As a result, a negative BigInteger is represented by a byte array whose high order byte (the 0'th byte of the array) is >= 128", "label": {"api": {"BigInteger": [[24, 33]]}}}, {"text": "A positive BigInteger is always represented by a byte array whose high-order byte is < 128", "label": {"api": {"BigInteger": [[11, 20]]}}}, {"text": "If the true high-order byte of a positive BigInteger would be >= 128 then BigInteger.toByteArray() emits a byte array with a leading 0 byte", "label": {"api": {"BigInteger": [[42, 51], [74, 83]], "BigInteger.toByteArray()": [[74, 97]]}}}, {"text": "You can prepend a zero byte to your array and use the same BigInteger constructor you have been using, or you can instead use the BigInteger sign-magnitude constructor with your byte array as is", "label": {"api": {"BigInteger": [[59, 68], [130, 139]], "BigInteger sign-magnitude constructor": [[130, 166]]}}}, {"text": "using basic String matching or regular expressions, depending on how thorough it needs to be", "label": {"api": {"String matching": [[12, 26]], "regular expressions": [[31, 49]]}}}, {"text": "The simplest approach would most likely be a RandomAccessFile (http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html": [[63, 132]]}}}, {"text": "You should consider BigInteger, it can handle big numbers", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "More specifically using mod() and modpow() can solve many overflow issues", "label": {"api": {"mod()": [[24, 28]], "modpow()": [[34, 41]]}}}, {"text": "You can use Collectors.toMap(keyMapper, valueMapper, mergeFunction), use the e-mail as key, user as value and ignore the key conflicts by always returning the first value", "label": {"api": {"Collectors.toMap(keyMapper, valueMapper, mergeFunction)": [[12, 66]]}}}, {"text": "From the Map, you can then get the users by calling values()", "label": {"api": {"values()": [[52, 59]]}}}, {"text": "JTextComponent.getCaretPosition is what you are looking for; and work from there on to find the word", "label": {"api": {"JTextComponent.getCaretPosition": [[0, 30]]}}}, {"text": "As an alternative, you can use Math.floorMod (introduced in Java 8) instead", "label": {"api": {"Math.floorMod": [[31, 43]]}}}, {"text": "You are probably looking for BigDecimal", "label": {"api": {"BigDecimal": [[29, 38]]}}}, {"text": "A Swing Timer has a start and stop method which you can use", "label": {"api": {"start": [[20, 24]], "stop": [[30, 33]]}}}, {"text": "The second place (which is a much better place for this code) would be in a WindowListener, specifically in the windowOpened(WindowEvent e) method", "label": {"api": {"WindowListener": [[76, 89]]}}}, {"text": "Create a ClientRequestFilter", "label": {"api": {"ClientRequestFilter": [[9, 27]], "Client": [[9, 14]]}}}, {"text": "And register it in your Client", "label": {"api": {"Client": [[24, 29]]}}}, {"text": "The format(Date) method is final, so Mockito cannot spy it", "label": {"api": {"format(Date)": [[4, 15]]}}}, {"text": "Also, you could use a properties file that can be easily read by the Properties class", "label": {"api": {"Properties class": [[69, 84]]}}}, {"text": "The Writer API does not support writing arrays of arrays", "label": {"api": {"Writer API": [[4, 13]]}}}, {"text": "You're using replace, which doesn't use regular expressions", "label": {"api": {"replace": [[13, 19]]}}}, {"text": "The easiest solution is to use String.join", "label": {"api": {"String.join": [[31, 41]]}}}, {"text": "Use Map.equals(Map other) to check if both maps contain the same mappings", "label": {"api": {"Map.equals(Map other)": [[4, 24]]}}}, {"text": "If you just need to check if a map is a subset of another map, use map.entrySet().containsAll(other.entrySet())", "label": {"api": {"entrySet": [[71, 78], [100, 107]]}}}, {"text": "String.join() is for Java 8 or later", "label": {"api": {"String.join()": [[0, 12]]}}}, {"text": "By default, the toString method of Instant uses the DateTimeFormatter.ISO_INSTANT formatter", "label": {"api": {"toString": [[16, 23]], "Instant": [[35, 41]], "DateTimeFormatter.ISO_INSTANT": [[52, 80]]}}}, {"text": "It appears that you can’t really build your own format string for Instants anyway", "label": {"api": {"Instant": [[66, 72]]}}}, {"text": "Is the only option implementing my own java.time.format.DateTimeFormatterBuilder.InstantPrinterParser", "label": {"api": {"Instant": [[81, 87]]}}}, {"text": "since java 1.5 the PrintWriter class has a method printf (see https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html#printf-java.lang.String-java.lang.Object...-) which can help you because it admits just an array of parameters", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html#printf-java.lang.String-java.lang.Object...-": [[62, 172]]}}}, {"text": "So having a look through the JavaDocs for Ellipse2D, it's pretty clear that Ellipse2D doesn't expose the x/y properties publicly", "label": {"api": {"JavaDocs for Ellipse2D": [[29, 50]]}}}, {"text": "Use a Predicate for a single Car", "label": {"api": {"Predicate": [[6, 14]]}}}, {"text": "In the Predicate you could transform a car in a CarVO (if necessary) and then apply the logic for the single element", "label": {"api": {"Predicate": [[7, 15]]}}}, {"text": "Arrays.stream(array) returns an IntStream consisting of the elements of the array", "label": {"api": {"Arrays.stream(array)": [[0, 19]], "IntStream": [[32, 40]]}}}, {"text": "Then, distinct() returns an IntStream containing only the distinct elements of this stream", "label": {"api": {"IntStream": [[28, 36]], "distinct()": [[6, 15]]}}}, {"text": "Finally, count() returns the number of elements in this stream", "label": {"api": {"count()": [[9, 15]]}}}, {"text": "Note that count() returns a long so we need to cast it to an int in your case", "label": {"api": {"count()": [[10, 16]]}}}, {"text": "If you really want to unmarshall from a String of character then you'll have to provide your own MessageBodyReader", "label": {"api": {"MessageBodyReader": [[97, 113]]}}}, {"text": "If you really want to access a thread by name and you don't have a reference that can be used, you could use ThreadGroup and search the tree formed by groups and threads for the one with the correct name", "label": {"api": {"ThreadGroup": [[109, 119]]}}}, {"text": "Thus you should be able to call Thread.currentThread().getThreadGroup(), use getParent() to find the initial/root group, list all active threads using enumerate(Thread[]) and search the threads", "label": {"api": {"ThreadGroup": [[58, 68]]}}}, {"text": "The URL you obtained from Class.getResource() refers to an entry inside a jar file", "label": {"api": {"URL": [[4, 6]], "Class.getResource()": [[26, 44]]}}}, {"text": "You must use the URL.openStream() method to obtain an input stream from which you can read the contents of that entry", "label": {"api": {"URL": [[17, 19]], "URL.openStream()": [[17, 32]]}}}, {"text": "Or use Class.getResourceAsStream() to save a step", "label": {"api": {"Class.getResourceAsStream()": [[7, 33]]}}}, {"text": "When you ran your project in eclipse, the reason it did not fail is because the classpath entry that contained the file was a directory, and so the URL returned by Class.getResource() just happened to be a file on the local filesystem", "label": {"api": {"URL": [[148, 150]], "Class.getResource()": [[164, 182]]}}}, {"text": "Using URL.openStream() will work in both situations", "label": {"api": {"URL": [[6, 8]], "URL.openStream()": [[6, 21]]}}}, {"text": "See the Javadoc for LambdaMetaFactory for more details", "label": {"api": {"LambdaMetaFactory": [[20, 36]]}}}, {"text": "And then created a constant reference to each target-typed to Supplier<Long> using the LambdaMetaFactory", "label": {"api": {"LambdaMetaFactory": [[87, 103]]}}}, {"text": "You simply need to keep track of the current maximum, and update it accordingly", "label": {"api": {"maximum": [[45, 51]]}}}, {"text": "from the specifications of Math.random, we known that the lowest value is 0.0, so we first set max to 0.0d", "label": {"api": {"Math.random": [[27, 37]]}}}, {"text": "Next we update the maximum", "label": {"api": {"maximum": [[19, 25]]}}}, {"text": "max stored the maximum thus far, by calculating the maximum of max and x, we include x as well", "label": {"api": {"maximum": [[15, 21], [52, 58]]}}}, {"text": "Finally after the for loop, we know for sure that max contains the maximum value encountered, and we can print it (or do other things with it)", "label": {"api": {"maximum": [[67, 73]]}}}, {"text": "You need to use a PreparedStatement with", "label": {"api": {"PreparedStatement": [[18, 34]]}}}, {"text": "The best approach to follow in this case is to use Java Set instead of List<E> because it doesn't allow duplicates, so you will only have unique results", "label": {"api": {"Java Set": [[51, 58]]}}}, {"text": "Try using JAVA 7 Files.delete(Path)  which will throw an IOException with the reason why it failed", "label": {"api": {"JAVA 7 Files.delete(Path)": [[10, 34]]}}}, {"text": "You could define a Service which does the QuickSort computing (in a background thread) and tells your controller when the job is done", "label": {"api": {"Service": [[19, 25]]}}}, {"text": "For asking the user to select from a list of known options, a JComboBox is a better choice than a JTextField", "label": {"api": {"JComboBox": [[62, 70]]}}}, {"text": "From List#listIterator javadoc (emphasis mine)", "label": {"api": {"List#listIterator": [[5, 21]]}}}, {"text": "To solve your problem, just don't pass any argument when calling List#listIterator", "label": {"api": {"List#listIterator": [[65, 81]]}}}, {"text": "The easiest way to return a copy of the array would probably be by calling Arrays.copyOf", "label": {"api": {"Arrays.copyOf": [[75, 87]]}}}, {"text": "There are cases where a WeakHashMap won't replace a HashMap, for example", "label": {"api": {"WeakHashMap": [[24, 34]]}}}, {"text": "The garbage collector can remove weak keys at any time, causing the WeakHashMap methods to act as if entries were removed just then", "label": {"api": {"WeakHashMap": [[68, 78]]}}}, {"text": "(See the JavaDoc for examples.) It's risky to pass a WeakHashMap to code that may not be prepared for such changes", "label": {"api": {"WeakHashMap": [[53, 63]]}}}, {"text": "I recommend using a WeakHashMap only when you need to (e.g", "label": {"api": {"WeakHashMap": [[20, 30]]}}}, {"text": "isInstance is documented to always return false for primitives", "label": {"api": {"documented": [[14, 23]]}}}, {"text": "String.split takes a regex as parameter", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "Types that do not map naturally to a XML representation require writing an XmlAdapter implementation, Font and Color are such types", "label": {"api": {"XmlAdapter": [[75, 84]]}}}, {"text": "You can set that with setRequestMethod, but the default is already GET, so you don't need to do this", "label": {"api": {"setRequestMethod": [[22, 37]]}}}, {"text": "or you can use the method setRequestProperty", "label": {"api": {"setRequestProperty": [[26, 43]]}}}, {"text": "The Java 7 Specification says", "label": {"api": {"Java 7 Specification": [[4, 23]]}}}, {"text": "Whereas the Java 8 Specification says", "label": {"api": {"Java 8 Specification": [[12, 31]]}}}, {"text": "In the javaodoc for the stream package, at the end of the section Parallelism, I read", "label": {"api": {"javaodoc for the stream package": [[7, 37]]}}}, {"text": "As explained in this answer, Arrays.stream(long[]) creates LongStream, not Stream<Long>, so you need to use mapToObj() method, which will produce Stream<String> in this case", "label": {"api": {"mapToObj()": [[108, 117]]}}}, {"text": "Other option is to call boxed() on the result of Arrays.stream(long[]) to get Stream<Long> on which you can then call map()", "label": {"api": {"boxed()": [[24, 30]]}}}, {"text": "You should extract out this term and use Math.floor() (\"Gauss operator\"; denoted by square brackets in your formula) for calculating the result instead", "label": {"api": {"Math.floor()": [[41, 52]]}}}, {"text": "Java 7 added a new Objects.requireNonNull method for exactly this purpose", "label": {"api": {"Objects.requireNonNull": [[19, 40]]}}}, {"text": "Basically, pretty much everything that you might want to do that deals with collections/arrays, can be very concisely done with the Streams", "label": {"api": {"Streams": [[132, 138]]}}}, {"text": "In the general case, if you want to use the contents of a string literally, you can use Pattern.quote to automatically escape any special characters", "label": {"api": {"Pattern.quote": [[88, 100]]}}}, {"text": "Looking at the Java8 doc for OptionalInt, it seems that OptionalInt cannot be reused by setting a new value or emptying the existing value", "label": {"api": {"OptionalInt": [[29, 39], [56, 66]]}}}, {"text": "Moreover the JavaDoc shows only two ways of initializing an OptionalInt by calling static methods - looks like an immutable object", "label": {"api": {"OptionalInt": [[60, 70]]}}}, {"text": "For each row (let it be millions of rows) a new OptionalInt object would have to be created", "label": {"api": {"OptionalInt": [[48, 58]]}}}, {"text": "So I rather would have to reimplement it myself and avoid the Java8 utility class OptionalInt", "label": {"api": {"OptionalInt": [[82, 92]]}}}, {"text": "OptionalInt is immutable", "label": {"api": {"OptionalInt": [[0, 10]]}}}, {"text": "An OptionalInt is either created by calling the static factories empty() or of(value)", "label": {"api": {"OptionalInt": [[3, 13]], "empty()": [[65, 71]], "of(value)": [[76, 84]]}}}, {"text": "Then, there are several methods to get the optional value (getAsInt()), use a default value if no value is present (orElse(other)), etc., but you will find no methods to update the current value or empty it", "label": {"api": {"getAsInt()": [[59, 68]], "orElse(other)": [[116, 128]]}}}, {"text": "To return the value of an optional, or a default value if the optional has no value, you can use orElse(other)", "label": {"api": {"orElse(other)": [[97, 109]]}}}, {"text": "you can directly use max(comparator) with a comparator comparing the length of each String", "label": {"api": {"max(comparator)": [[21, 35]]}}}, {"text": "One such comparator can be obtained by calling Comparator.comparingInt(keyExtractor) with the key extractor being the method reference String::length", "label": {"api": {"Comparator.comparingInt(keyExtractor)": [[47, 83]]}}}, {"text": "I've used an ArrayList to know which value I've already encountered in the array so that I can not make the mistake of counting them twice", "label": {"api": {"ArrayList": [[13, 21]]}}}, {"text": "This method will mutate every Client and set the buys with the result of the operator (a DoubleUnaryOperator is an operator that takes a double as argument and returns a value of type double)", "label": {"api": {"DoubleUnaryOperator": [[89, 107]]}}}, {"text": "What you need is to use a Comparator or make your objects Comparable", "label": {"api": {"Comparator": [[26, 35]], "Comparable": [[58, 67]]}}}, {"text": "Comparators are responsible for comparing two objects of the same type", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "Since the objects here are Numbers, and they are not Comparable, you need to use a custom Comparator, like this", "label": {"api": {"Comparator": [[90, 99]], "Comparable": [[53, 62]]}}}, {"text": "Use ordinary ServerSocket to listen and create an ordinary server-side Socket and give that to SSLSocketFactory.createSocket(Socket,InputStream,boolean) with autoClose=false and if applicable consumed=null", "label": {"api": {"SSLSocketFactory.createSocket(Socket,InputStream,boolean)": [[95, 151]]}}}, {"text": "Both PrintWriter and FileWriter implement a constructor that takes a file name as its parameter", "label": {"api": {"PrintWriter": [[5, 15]], "FileWriter": [[21, 30]]}}}, {"text": "Do I need to use ResultSet instead", "label": {"api": {"ResultSet": [[17, 25]]}}}, {"text": "ThreadLocalRandom.nextInt(origin, bound) returns a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive)", "label": {"api": {"ThreadLocalRandom.nextInt(origin, bound)": [[0, 39]]}}}, {"text": "In this case you might want to wrap all (only some?) objects of interfaces which have those annotated methods in a proxy (have a look at java.lang.reflect.proxy) which executes the code you want before the method itself is called (have a look at java.lang.reflect.InvocationHandler)", "label": {"api": {"java.lang.reflect.proxy": [[137, 159]], "java.lang.reflect.InvocationHandler": [[246, 280]]}}}, {"text": "Combine this with Method.getDeclaredAnnotations() and you can probably build the thing you want", "label": {"api": {"Method.getDeclaredAnnotations()": [[18, 48]]}}}, {"text": "Easy enough to do with a BiFunction in Java 8", "label": {"api": {"BiFunction": [[25, 34]]}}}, {"text": "Use Integer.MIN_VALUE and Integer.MAX_VALUE instead", "label": {"api": {"Integer.MIN_VALUE": [[4, 20]], "Integer.MAX_VALUE": [[26, 42]]}}}, {"text": "If you want to receive result from any of the threads then in that case you can also use ExecutorCompletionService as well which maintains a queue of results in whatever order they are received", "label": {"api": {"ExecutorCompletionService": [[89, 113]]}}}, {"text": "You can use the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[16, 39]]}}}, {"text": "Later, you are calling sql (an instance variable) which is indeed of null value, which causes null pointer exception", "label": {"api": {"null pointer exception": [[94, 115]]}}}, {"text": "You need to declare the format first with one string that is a valid DecimalFormat pattern and then you can parse the real string", "label": {"api": {"DecimalFormat pattern": [[69, 89]]}}}, {"text": "As , is also a placeholder, I have had to quote the text 'Welcome,@'", "label": {"api": {"placeholder": [[15, 25]]}}}, {"text": "Note that the preferred way to start a process is to use ProcessBuilder, e.g.", "label": {"api": {"ProcessBuilder": [[57, 70]]}}}, {"text": "ProcessBuilder offers more possibilities, and using Runtime.exec is discouraged", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "You don't need to pass in Launcher to your callable — you can use ArgumentListBuilder as you are just now, but you can use ProcessBuilder rather than ProcStarter to execute NSIS", "label": {"api": {"ProcessBuilder": [[123, 136]]}}}, {"text": "If you look carefully at the Javadoc of String#split(String, int) (which is what String#split(String) calls), you will see why it behaves like this", "label": {"api": {"String#split(String, int)": [[40, 64]]}}}, {"text": "Since String#split(String) calls String#split(String, int) with the limit argument of zero, you can add whitespace to the end of the string without changing the number of words (because trailing empty strings will be discarded)", "label": {"api": {"String#split(String, int)": [[33, 57]]}}}, {"text": "So, I'm trying to extend CompletableFuture functionality", "label": {"api": {"CompletableFuture": [[25, 41]]}}}, {"text": "First test shouldReturnElapsedTime with extracted ContinuousCompletableFuture variable works fine, but other shouldOperateWithOwnExecutionTime fails", "label": {"api": {"CompletableFuture": [[60, 76]]}}}, {"text": "Meanwhile, I prefer to see it in my future code neither extracted ContinuousCompletableFuture variable", "label": {"api": {"CompletableFuture": [[76, 92]]}}}, {"text": "Apparently MediaRecorder.setOutputFile() also accepts a FileDescriptor", "label": {"api": {"MediaRecorder.setOutputFile()": [[11, 39]]}}}, {"text": "To get a file from the WEB-INF directory, use ServletContext.getResource(\"/WEB-INF/images/lol.png\")", "label": {"api": {"ServletContext.getResource(\"/WEB-INF/images/lol.png\")": [[46, 98]]}}}, {"text": "You first need to get a reference to Namespace, then you can call invocable.invokeMethod specifying Namespace as its context (this)", "label": {"api": {"invocable.invokeMethod": [[66, 87]]}}}, {"text": "You can also implement this method in a functional way by using java.util.stream.IntStream", "label": {"api": {"java.util.stream.IntStream": [[64, 89]]}}}, {"text": "Path.resolve(String) will resolve parent directory references, absolute, and relative paths", "label": {"api": {"Path.resolve(String)": [[0, 19]]}}}, {"text": "You can check that a path is a descendent of another path by using the Path.startsWith(Path) method", "label": {"api": {"Path.startsWith(Path)": [[71, 91]]}}}, {"text": "You can use Path.normalize() to strip out \"..\" elements (and their preceding elements) from a path — e.g", "label": {"api": {"Path.normalize()": [[12, 27]]}}}, {"text": "You can also use Path.startsWith(Path) to check whether one path is a descendant of another", "label": {"api": {"Path.startsWith(Path)": [[17, 37]]}}}, {"text": "And Path.isAbsolute() tells you, unsurprisingly, whether a path is absolute or relative", "label": {"api": {"Path.isAbsolute()": [[4, 20]]}}}, {"text": "To run a stored procedure you should use a CallableStatement", "label": {"api": {"CallableStatement": [[43, 59]]}}}, {"text": "It isn't a common usecase, but it definitely has its usages - e.g., to borrow from IdentityHashMap's documentation", "label": {"api": {"IdentityHashMap's documentation": [[83, 113]]}}}, {"text": "It helps to know the factory methods comparing… in the Comparator interface which save you from repeating the code for both sides of the comparison", "label": {"api": {"comparing…": [[37, 46]], "Comparator interface": [[55, 74]]}}}, {"text": "You'd be better off using System's InputStream", "label": {"api": {"System": [[26, 31]]}}}, {"text": "Another option would be to use a custom component approach for the second fxml", "label": {"api": {"custom component approach": [[33, 57]]}}}, {"text": "The javadoc for the java.lang.Math class might help you here", "label": {"api": {"java.lang.Math": [[20, 33]]}}}, {"text": "You need to call Unmarshaller.setEventHandler() to make invalid XML content fail", "label": {"api": {"Unmarshaller.setEventHandler()": [[17, 46]]}}}, {"text": "Combine this with the ValidationEventHandler (set through Unmarshaller.setEventHandler()) suggested in the previous answer if you wish to be notified about multiple errors or filter out validation errors that you want to tolerate", "label": {"api": {"ValidationEventHandler": [[22, 43]]}}}, {"text": "Long Term Persistence", "label": {"api": {"Long Term Persistence": [[0, 20]]}}}, {"text": "Assuming you already have an alist, you do this by calling ensureCapacity", "label": {"api": {"ensureCapacity": [[59, 72]]}}}, {"text": "But that basically just does ensureCapacity followed by a bunch of adds", "label": {"api": {"ensureCapacity": [[29, 42]]}}}, {"text": "See Collection.contains , Map.containsKey, and Map.containsValue", "label": {"api": {"Collection.contains": [[4, 22]], "Map.containsKey": [[26, 40]], "Map.containsValue": [[47, 63]]}}}, {"text": "This requires that the WorkPosition object overrides the equals(obj) method and hashCode(), like this", "label": {"api": {"equals(obj)": [[57, 67]], "hashCode()": [[80, 89]]}}}, {"text": "What changed is that instead of calling now(), the call is made to now(zone)", "label": {"api": {"now()": [[40, 44]], "now(zone)": [[67, 75]]}}}, {"text": "That is because now() always return the current system time in your time-zone", "label": {"api": {"now()": [[16, 20]]}}}, {"text": "you're in Europe and call LocalDateTime.now().atZone(ZoneId.of(\"America/Los_Angeles\")) - you are creating a date/time which represents the current-time in Europe as if you were located in Los Angeles, so you are creating a date/time which is actually in the future for Los Angeles residents (8 or 9 hours in the future, depending on DST)", "label": {"api": {"now()": [[40, 44]]}}}, {"text": "Use System.arraycopy, which is in the SDK to achieve your result", "label": {"api": {"System.arraycopy": [[4, 19]]}}}, {"text": "If the HSQLDB driver is JDBC4 compliant it should use and work with the Connection.isValid(int timeout) method", "label": {"api": {"Connection.isValid(int timeout)": [[72, 102]]}}}, {"text": "This code creates a BiConsumer (which is a consumer that takes 2 arguments)", "label": {"api": {"BiConsumer": [[20, 29]]}}}, {"text": "If you want, you could rewrite the `BiConsumer' in a more java8 friendly way", "label": {"api": {"BiConsumer": [[36, 45]]}}}, {"text": "You might want to further read about Optional and BiConsumer in the javadocs", "label": {"api": {"Optional": [[37, 44]], "BiConsumer": [[50, 59]]}}}, {"text": "You can use ScheduledExecutorService.scheduleAtFixedRate method to invoke a Runnable at a fixed rate", "label": {"api": {"ScheduledExecutorService.scheduleAtFixedRate": [[12, 55]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/String.html You can look at methods like indexOf or split or substring", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[0, 61]]}}}, {"text": "When you pass in the HashSet to the TreeSet constructor, it finds that your Chien objects aren't Comparable", "label": {"api": {"TreeSet constructor": [[36, 54]]}}}, {"text": "Create your TreeSet with your custom implementation of Comparator", "label": {"api": {"TreeSet with your custom implementation of Comparator": [[12, 64]]}}}, {"text": "When running Scala on Java 9, we can take advantage of Java's ProcessHandle which makes it easier to identify and work with native processes", "label": {"api": {"ProcessHandle": [[62, 74]]}}}, {"text": "First creates a Java Optional<ProcessHandle> from the given pid", "label": {"api": {"ProcessHandle": [[30, 42]]}}}, {"text": "And finally checks that the process is alive using ProcessHandle::isAlive", "label": {"api": {"ProcessHandle": [[51, 63]]}}}, {"text": "No import necessary as ProcessHandle is part of java.lang", "label": {"api": {"ProcessHandle": [[23, 35]]}}}, {"text": "If you take a look at the documentation for ArrayList.contains you will see that it only returns true if your keyword contains the provided string from your file", "label": {"api": {"ArrayList.contains": [[44, 61]]}}}, {"text": "I have isolated the performance-issue to these two method-calls createSession and send", "label": {"api": {"createSession": [[64, 76]], "send": [[82, 85]]}}}, {"text": "Sometimes I can send 500 messages without any occurence of that issue, but suddenly it's really slow", "label": {"api": {"send": [[16, 19]]}}}, {"text": "Or more commonly, consider using an ArrayList and add your elements to it", "label": {"api": {"ArrayList": [[36, 44]]}}}, {"text": "On that point, the documentation for the Comparable interface says", "label": {"api": {"documentation for the Comparable interface": [[19, 60]]}}}, {"text": "if you want to change the name of your file then File Class of io package provide the method renameTo", "label": {"api": {"renameTo": [[93, 100]]}}}, {"text": "Take a look at JavaDoc for ArrayList constructor", "label": {"api": {"JavaDoc for ArrayList constructor": [[15, 47]]}}}, {"text": "And now at the ArrayList#size() desctiption", "label": {"api": {"ArrayList#size()": [[15, 30]]}}}, {"text": "Your lists are still empty, and call to ArrayList#size() will return you 0 even in your first iteration", "label": {"api": {"ArrayList#size()": [[40, 55]]}}}, {"text": "Just to point out another approach, you can use LinkedList", "label": {"api": {"LinkedList": [[48, 57]]}}}, {"text": "You can use the AccessibleObject class", "label": {"api": {"AccessibleObject": [[16, 31]]}}}, {"text": "You may also be interested in Member interface depending on your requirement", "label": {"api": {"Member": [[30, 35]]}}}, {"text": "You can do this using Files.readAttributes(path, BasicFileAttributes.class).creationTime()", "label": {"api": {"BasicFileAttributes": [[49, 67]]}}}, {"text": "See BasicFileAttributes documentation for details", "label": {"api": {"BasicFileAttributes": [[4, 22]]}}}, {"text": "As many above/below me have pointed out you are attempting to catch an exception in one thread with a completely different thread, this means that the default exception handler is catching and handling it", "label": {"api": {"default exception handler is catching and handling it": [[151, 203]]}}}, {"text": "If you need the two threads to talk to each other then you have a few options, such as the spawned thread catching the exception and passing passing it over, to using an ExecutorService, calling get on the Future and seeing if it throws a ExecutionException", "label": {"api": {"ExecutorService": [[170, 184]], "Future": [[206, 211]], "ExecutionException": [[239, 256]]}}}, {"text": "You have mentioned that you are using TimerTasks", "label": {"api": {"TimerTask": [[38, 46]]}}}, {"text": "If you can move to ScheduledThreadPoolExecutor then you can use the Future method", "label": {"api": {"Future": [[68, 73]], "ScheduledThreadPoolExecutor": [[19, 45]]}}}, {"text": "If not then you are going to have to catch the exception the TimerTask and pass the fact if failed back to the main thread", "label": {"api": {"TimerTask": [[61, 69]]}}}, {"text": "createStatement() creates a new statement object, so you're execute a different statement than the one you're batching on", "label": {"api": {"createStatement()": [[0, 16]]}}}, {"text": "Something like this (using a Set)", "label": {"api": {"Set": [[29, 31]]}}}, {"text": "So instead, use the static toString(int) method in the Integer class", "label": {"api": {"toString(int)": [[27, 39]]}}}, {"text": "The official documentation(http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html) says", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html": [[27, 92]]}}}, {"text": "Note that instead of returning a new List, you could also return an unmodifiable view of the List, using Collections.unmodifiableList", "label": {"api": {"Collections.unmodifiableList": [[105, 132]]}}}, {"text": "There is also option to go with HttpServer implementation from com.sun package but I would use this only if I would be sure that Oracle Java will be used", "label": {"api": {"HttpServer": [[32, 41]]}}}, {"text": "If you look at the JavaDoc of ActionListener interface you see that it requires you to implement a method void actionPerformed(ActionEvent e)", "label": {"api": {"ActionListener": [[30, 43]]}}}, {"text": "Your custom ButtonHandler doesn't yet implement that method therfore it doesn't fullfill the contract that the ActionListener interface provides", "label": {"api": {"ActionListener": [[111, 124]]}}}, {"text": "Note that in most cases small ActionListener like click listeners for Buttons are implemented as anonymous functions", "label": {"api": {"ActionListener": [[30, 43]]}}}, {"text": "There is a nice \"official\" tutorial on how to write ActionListeners, make sure to read it", "label": {"api": {"ActionListener": [[52, 65]]}}}, {"text": "You could perfectly use a HashMap to achieve the same effect", "label": {"api": {"HashMap": [[26, 32]]}}}, {"text": "Consider using the Integer object instead of the int primitive to represent the presence of the bulk quantity where a null amount may represent that it is not present", "label": {"api": {"Integer": [[19, 25]]}}}, {"text": "In Java 8, you may also specify your getter to represent that the value of interest may possibly be null by changing the getter signatures to return your data wrapped in an Optional object, effectively reducing the chance that you will introduce a NullPointerException later on in your code", "label": {"api": {"Optional": [[173, 180]]}}}, {"text": "You can pass different Properties when creating a new JavaMail Session instance using Session.getInstance(properties)", "label": {"api": {"Session.getInstance(properties)": [[86, 116]]}}}, {"text": "Try throwing in a call to requestFocus() when the panel is added", "label": {"api": {"requestFocus()": [[26, 39]]}}}, {"text": "From the documentation of SimpleDateFormat", "label": {"api": {"documentation of SimpleDateFormat": [[9, 41]]}}}, {"text": "However you can mix text styles easily using a TextFlow", "label": {"api": {"TextFlow": [[47, 54]]}}}, {"text": "Usually you can just reference the TextFlow directly without placing it in an enclosing Label", "label": {"api": {"TextFlow": [[35, 42]]}}}, {"text": "You can still place the TextFlow in a Label if you wish by setting the TextFlow as a graphic of the label", "label": {"api": {"TextFlow": [[24, 31], [71, 78]]}}}, {"text": "Note that when you do this, the in-built eliding functionality (where the label text is truncated to dots if there is not enough space to display the label) of the Label will not work with the TextFlow", "label": {"api": {"TextFlow": [[193, 200]]}}}, {"text": "However, depending on what native code wants to do, it may be easier to just get encoded type name using Class.getName() (https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getName()) and parse it - an array type starts with '[', if there's single letter after it, it's array of primitive types, otherwise it's object array (in particular, it may be multidimensional array)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getName()": [[122, 193]]}}}, {"text": "If you have possibility of duplicate elements then multiple elements will map to same key and then you need to specify merge function", "label": {"api": {"merge function": [[119, 132]]}}}, {"text": "You will want to look at the Package java.util.regex package or iterate over the String and check each character", "label": {"api": {"Package java.util.regex": [[29, 51]]}}}, {"text": "To fill a List, it is possible to generate an infinite Stream using Stream.generate(s) and then limit the number of results with limit(maxSize)", "label": {"api": {"Stream.generate(s)": [[68, 85]], "limit(maxSize)": [[129, 142]]}}}, {"text": "If you insist on sorting in Java, use a custom Comparator", "label": {"api": {"Comparator": [[47, 56]]}}}, {"text": "An alternative solution to validating post-input would be to use a JFormattedTextField combined with a MaskFormatter to restrict the input to begin with", "label": {"api": {"JFormattedTextField": [[67, 85]], "MaskFormatter": [[103, 115]]}}}, {"text": "Locale.setDefault(\"<preferred_locale>\") read more about it here", "label": {"api": {"read more about it here": [[40, 62]]}}}, {"text": "That's the exact expected behavior of that rounding method", "label": {"api": {"expected behavior": [[17, 33]]}}}, {"text": "Your understanding about Expression.as() method is not what's happening in reality", "label": {"api": {"Expression.as()": [[25, 39]]}}}, {"text": "It looks like it should according to the Java API documentation on Collectors", "label": {"api": {"Java API documentation on Collectors": [[41, 76]]}}}, {"text": "And if you don't want to depend on Guava you could use Objects#equals method to simplify cumbersome null-checking", "label": {"api": {"Objects#equals method": [[55, 75]]}}}, {"text": "As suggested here, the preferred approach is to extend AbstractTableModel and fire a suitable TableModelEvent in your implementation of setValueAt()", "label": {"api": {"AbstractTableModel": [[55, 72]]}}}, {"text": "Add an instance of EventListenerList as a member of StabiliTableModel and fire your own events using the scheme outlined in the EventListenerList API", "label": {"api": {"EventListenerList": [[19, 35], [128, 144]]}}}, {"text": "Why java.util.Iterator interface has method remove()", "label": {"api": {"java.util.Iterator": [[4, 21]]}}}, {"text": "Also, enabling the removal of elements through Iterator makes the Iterable interface (which was added in Java 5) much more powerful", "label": {"api": {"Iterable": [[66, 73]]}}}, {"text": "many of the methods in Guava's Iterables utility class", "label": {"api": {"Iterable": [[31, 38]]}}}, {"text": "A long will have a max of about ~9.22 quintillion", "label": {"api": {"max": [[19, 21]]}}}, {"text": "Alternatively, start i at something close to the max already, like 9,223,372,036,854,700,000, and see if it still gives you the same issues", "label": {"api": {"max": [[49, 51]]}}}, {"text": "The max long is significantly high, at 9.223372e+18", "label": {"api": {"max": [[4, 6]]}}}, {"text": "For specifics, 9,223,372,036,854,775,807 is the number in question", "label": {"api": {"For specifics": [[0, 12]]}}}, {"text": "I've noticed that many of the methods (such as those in Graphics2D, for example) in the Java API have \"abstract\" modifiers", "label": {"api": {"Graphics2D": [[56, 65]]}}}, {"text": "So, how is it that I'm able to import a class like Graphics2D, create an instance of it and use its abstract methods", "label": {"api": {"Graphics2D": [[51, 60]]}}}, {"text": "So i am using the Java Point3D object", "label": {"api": {"Point3D": [[23, 29]]}}}, {"text": "Offtopic, Using Java 8 IntStream it is as simple as", "label": {"api": {"IntStream": [[23, 31]]}}}, {"text": "There is a HttpSessionListenr but it handles session created event after session is created", "label": {"api": {"HttpSessionListenr": [[11, 28]]}}}, {"text": "Create a Filter to initialize the session", "label": {"api": {"Filter": [[9, 14]]}}}, {"text": "The Javadoc of synchronizedList clearly states that", "label": {"api": {"synchronizedList": [[15, 30]]}}}, {"text": "Using Collections.synchronizedList, the following code will run fine", "label": {"api": {"synchronizedList": [[18, 33]]}}}, {"text": "Java Math#min(double, double) does the following", "label": {"api": {"Math#min(double, double)": [[5, 28]]}}}, {"text": "Using native APIs, your best bet to get rid of it would be as below with help of java.net.InetAddress and Inet6Address#getScopeId()", "label": {"api": {"java.net.InetAddress": [[81, 100]], "Inet6Address#getScopeId()": [[106, 130]]}}}, {"text": "This clumsiness is because the standard java.net.Inet6Address API doesn't have any method which returns the bare hostname without scope ID", "label": {"api": {"java.net.Inet6Address": [[40, 60]]}}}, {"text": "Note that String's split() method take regex as a param", "label": {"api": {"String's split()": [[10, 25]]}}}, {"text": "If you just want to verify that the certificate is valid, without logging in, you should use a SSLSocket and see if you can connect without getting an exception", "label": {"api": {"SSLSocket": [[95, 103]]}}}, {"text": "If you look at the Javadocs for Random, you can see this", "label": {"api": {"Javadocs for Random": [[19, 37]]}}}, {"text": "By default, @EnableAspectJAutoProxy (as well as most configurations that generates proxies, @EnableTransactionManagement, EnableAsync, etc.) uses JDK proxies", "label": {"api": {"JDK proxies": [[146, 156]]}}}, {"text": "JDK proxies only support super interfaces", "label": {"api": {"JDK proxies": [[0, 10]]}}}, {"text": "The instance returned by newProxyInstance (the entry point for creating JDK proxies) will have a super type of Proxy", "label": {"api": {"JDK proxies": [[72, 82]]}}}, {"text": "CGLIB are quite more powerful than JDK proxies", "label": {"api": {"JDK proxies": [[35, 45]]}}}, {"text": "Using Java 8 IntStream, it is as simple as", "label": {"api": {"IntStream": [[13, 21]]}}}, {"text": "First of all, if i understand your question correctly you will be needing a Collection object preferably a List to dynamically increment the size", "label": {"api": {"List": [[107, 110]]}}}, {"text": "You can't just have regular spaces in <types> because by default, org.jooq.util.AbstractDatabase will parse regular expressions in COMMENTS mode which makes the created Pattern object ignore whitespace in your regex", "label": {"api": {"ignore whitespace": [[184, 200]]}}}, {"text": "Just use @FormParam to inject form data", "label": {"api": {"@FormParam": [[9, 18]]}}}, {"text": "indexOf would return -1 if userGuess is not part of phrase", "label": {"api": {"indexOf": [[0, 6]]}}}, {"text": "Looks like you're using a javax.swing.Timer, which needs a long and an ActionListener as constructor arguments and does not have a schedule method", "label": {"api": {"javax.swing.Timer": [[26, 42]]}}}, {"text": "It seems that you meant to use a java.util.Timer instead based on the code you provided", "label": {"api": {"java.util.Timer": [[33, 47]]}}}, {"text": "So change import javax.swing.Timer to import java.util.Timer and you should be fine", "label": {"api": {"javax.swing.Timer": [[17, 33]], "java.util.Timer": [[45, 59]]}}}, {"text": "If you want the task to be executed multiple times, you should consider using either this schedule method or the scheduleAtFixedRate method depending on your needs", "label": {"api": {"this schedule method": [[85, 104]], "scheduleAtFixedRate method": [[113, 138]]}}}, {"text": "Instead of using setSelectedFile, use setCurrentDirectory instead", "label": {"api": {"setCurrentDirectory": [[38, 56]]}}}, {"text": "To access parent directory use the Paths factory to create a Path and retrieve its parent", "label": {"api": {"Paths": [[35, 39]]}}}, {"text": "To customize logging with JUL you can write your own Handler implementation", "label": {"api": {"JUL": [[26, 28]], "Handler": [[53, 59]]}}}, {"text": "If you want to log to a file you should extend FileHandler", "label": {"api": {"Handler": [[51, 57]], "FileHandler": [[47, 57]]}}}, {"text": "An implementation using ConsoleHandler could look like this", "label": {"api": {"Handler": [[31, 37]], "ConsoleHandler": [[24, 37]]}}}, {"text": "You can do this using the method Enum#valueOf()", "label": {"api": {"Enum#valueOf()": [[33, 46]]}}}, {"text": "Because it's an abstract class, ByteBuffer can't be instantiated directly, but you can use the allocate or allocateDirect factory methods", "label": {"api": {"allocate": [[95, 102], [107, 114]], "allocateDirect": [[107, 120]]}}}, {"text": "A direct byte buffer may be created by invoking the allocateDirect factory method of this class", "label": {"api": {"allocate": [[52, 59]], "allocateDirect": [[52, 65]]}}}, {"text": "It is therefore recommended that direct buffers be allocated primarily for large, long-lived buffers that are subject to the underlying system's native I/O operations", "label": {"api": {"allocate": [[51, 58]]}}}, {"text": "In general it is best to allocate direct buffers only when they yield a measureable gain in program performance", "label": {"api": {"allocate": [[25, 32]]}}}, {"text": "You may also consider MappedByteBuffer, for a ByteBuffer instance corresponding to a memory-mapped region of a file", "label": {"api": {"MappedByteBuffer": [[22, 37]]}}}, {"text": "You have overridden the toString() method in the State class", "label": {"api": {"toString()": [[24, 33]]}}}, {"text": "Therefore you get no output at all as for every value the toString() method is called in your loop", "label": {"api": {"toString()": [[58, 67]]}}}, {"text": "Remove the toString()method in order to use Java's default toString() implementation which returns the classname+hashCode() or make it return e.g", "label": {"api": {"toString()": [[11, 20], [59, 68]]}}}, {"text": "Use parallelStream() to accomplish this", "label": {"api": {"parallelStream()": [[4, 19]]}}}, {"text": "You should use toInstant on your LocalDateTime instead", "label": {"api": {"toInstant": [[15, 23]]}}}, {"text": "The Websocket equivalent of ServletContainerInitializer is the ServerApplicationConfig", "label": {"api": {"ServerApplicationConfig": [[63, 85]]}}}, {"text": "It only doesn't require a services file, the Websocket API will proactively scan the WAR and JARs in WAR for any classes implementing ServerApplicationConfig interface and use them", "label": {"api": {"ServerApplicationConfig": [[134, 156]]}}}, {"text": "You can in getEndpointConfigs() use ServerEndpointConfig.Builder to programmatically build a Websocket endpoint and return it", "label": {"api": {"ServerEndpointConfig.Builder": [[36, 63]]}}}, {"text": "The simplest way to check for a palindrome would be to utilize StringBuilder.reverse()", "label": {"api": {"StringBuilder.reverse()": [[63, 85]]}}}, {"text": "The currently used default line ending is available with System.lineSeparator() or the \"line.separator\" system property.", "label": {"api": {"System.lineSeparator()": [[57, 78]]}}}, {"text": "With Java 8, IntStream it is as simple as", "label": {"api": {"IntStream": [[13, 21]]}}}, {"text": "Quoting the Javadoc of the constructor of Date (emphasis mine)", "label": {"api": {"Date": [[42, 45]]}}}, {"text": "Allocates a Date object and initializes it so that it represents the time at which it was allocated, measured to the nearest millisecond", "label": {"api": {"Date": [[12, 15]]}}}, {"text": "As such, the Date that is printed is the date when the object was created", "label": {"api": {"Date": [[13, 16]]}}}, {"text": "Since you are printing the same Date object, it will be the same output", "label": {"api": {"Date": [[32, 35]]}}}, {"text": "Using Java 8 Arrays it is as simple as", "label": {"api": {"Arrays": [[13, 18]]}}}, {"text": "The type of list returned by this method is immutable, which leads to the UnsupportedOperationException", "label": {"api": {"immutable": [[44, 52]]}}}, {"text": "Have you tried to enable caching and set the cache hint to speedy", "label": {"api": {"enable caching": [[18, 31]], "set the cache hint to speedy": [[37, 64]]}}}, {"text": "I've able preserve enum constants apply configuration from http://proguard.sourceforge.net/manual/examples.html#enumerations", "label": {"api": {"constants": [[24, 32]]}}}, {"text": "At first glance it looks like working solution and constant preserved, so (Class.getEnumConstants()) return correct list of values", "label": {"api": {"Class.getEnumConstants()": [[75, 98]]}}}, {"text": "I think it will be easy understandable to look at debug session screenshot (there also listed constants)", "label": {"api": {"constants": [[94, 102]]}}}, {"text": "And if I try obtain fields, they are listed obfuscated as a, b, c, d, e, f", "label": {"api": {"fields": [[20, 25]]}}}, {"text": "My proguard configuration now look like (strip out some library listing and kipp particular classes, fields and methods about proguard complain)", "label": {"api": {"fields": [[101, 106]]}}}, {"text": "In both cases - use its constants (class.getEnumConstants()) and fields (class.getFields())", "label": {"api": {"constants": [[24, 32]], "fields": [[65, 70]], "class.getEnumConstants()": [[35, 58]], "class.getFields()": [[73, 89]]}}}, {"text": "By default, a JFrame (or rather, its content pane) has BorderLayout", "label": {"api": {"BorderLayout": [[55, 66]]}}}, {"text": "But you can't add more than one element at any of the BorderLayout's regions", "label": {"api": {"BorderLayout": [[54, 65]]}}}, {"text": "Use StringTokenizer class", "label": {"api": {"StringTokenizer": [[4, 18]]}}}, {"text": "This is what the work stealing algorithm was designed for, aka Fork Join Pool", "label": {"api": {"Fork Join Pool": [[63, 76]]}}}, {"text": "If you are sequencing multiple streams and want to ensure that each end in a line separator, wrap each stream in a FilterInputStream that returns an extra line separator at the end, if not in the filtered stream", "label": {"api": {"line separator": [[77, 90], [155, 168]], "FilterInputStream": [[115, 131]]}}}, {"text": "Here's the link", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "More specifically one of the sub classes of AbstractQueue", "label": {"api": {"AbstractQueue": [[44, 56]]}}}, {"text": "answer is in the comment of the selected answer, but it basically points to CharsetDecoder", "label": {"api": {"CharsetDecoder": [[76, 89]]}}}, {"text": "As mentioned in the comment, you can pass the ByteBuffer to CharsetDecoder on the fly and translate it into CharBuffer (then append to StringBuilder or whatever is preffered solution)", "label": {"api": {"CharsetDecoder": [[60, 73]]}}}, {"text": "Apart from providing your own implementation of Comparator (as seen in @SURESH ATTA answer) you can just simply use fact that String is implementing Comparable interface (Source) and you can use sort method like this", "label": {"api": {"Source": [[171, 176]]}}}, {"text": "A Scanner indeed doesn't have an int() method", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "It's called nextInt()", "label": {"api": {"nextInt()": [[12, 20]]}}}, {"text": "In this case, java.util.Math#max", "label": {"api": {"java.util.Math#max": [[14, 31]]}}}, {"text": "A Scanner allows you to read in text from some sort of input (e.g", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "That text is naturally a String (because it's a sequence of bytes, which Scanner interprets as characters)", "label": {"api": {"Scanner": [[73, 79]]}}}, {"text": "Scanner also provides the primitive methods as a convenience for reading in tokens that can be safely converted into primitives (e.g", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "Be sure to read the docs describing how Scanner splits words/tokens up as well", "label": {"api": {"Scanner": [[40, 46]]}}}, {"text": "If you need the information within the webapp itself, then you can store the data structure as a ServletContext attribute", "label": {"api": {"ServletContext": [[97, 110]]}}}, {"text": "If you want to distinct the row based on value of both area and location value then with Java 8 Streams, it is as simple as", "label": {"api": {"Streams": [[96, 102]]}}}, {"text": "If you read the documentation of the HashMap class, you see that it implements a hash table implementation based on the hashCode of the keys", "label": {"api": {"read the documentation": [[7, 28]]}}}, {"text": "JDBC supports read-only connections by calling Connection.setReadOnly(true)", "label": {"api": {"Connection.setReadOnly(true)": [[47, 74]]}}}, {"text": "Use a custom comparator", "label": {"api": {"comparator": [[13, 22]]}}}, {"text": "Then you can simply use the method Collections.sort", "label": {"api": {"Collections.sort": [[35, 50]]}}}, {"text": "You can use the MessageFormat class from the Java API", "label": {"api": {"MessageFormat class": [[16, 34]]}}}, {"text": "I was wondering what are the specific differences between preloader and splash screen in java", "label": {"api": {"preloader": [[58, 66]]}}}, {"text": "Or you can simply use Files.readAllBytes(), which will correctly read all the bytes from the file for you", "label": {"api": {"Files.readAllBytes()": [[22, 41]]}}}, {"text": "From the HashMap docs", "label": {"api": {"HashMap docs": [[9, 20]]}}}, {"text": "Use an event filter and whatever keyevent you need, here I use ANY", "label": {"api": {"keyevent": [[33, 40]], "ANY": [[63, 65]]}}}, {"text": "From PreparedStatement setString javadocs", "label": {"api": {"PreparedStatement setString javadocs": [[5, 40]]}}}, {"text": "Given your regex, I'll assume that <signed_float> does not support scientific notation", "label": {"api": {"regex": [[11, 15]]}}}, {"text": "Regex for matching a float/double to listed in the javadoc for Double.valueOf(String)", "label": {"api": {"Double.valueOf(String)": [[63, 84]]}}}, {"text": "In that case, the regex would be", "label": {"api": {"regex": [[18, 22]]}}}, {"text": "Check out the API", "label": {"api": {"the API": [[10, 16]]}}}, {"text": "Generally the ConcurrentHashMap performs better than the sinchronized hash map you are using", "label": {"api": {"ConcurrentHashMap": [[14, 30]]}}}, {"text": "I would recommend using Classloader.getResourceAsStream(..) instead", "label": {"api": {"Classloader.getResourceAsStream(..)": [[24, 58]]}}}, {"text": "Note that you can use new StreamSource(InputStream) to construct a reference to the schema document from the stream", "label": {"api": {"new StreamSource(InputStream)": [[22, 50]]}}}, {"text": "Due to JavaDoc for List#hashCode()", "label": {"api": {"List#hashCode()": [[19, 33]]}}}, {"text": "The same is true for the List#equals(), if you want to add your class to some other Collections, which do not require the object's hash", "label": {"api": {"List#equals()": [[25, 37]]}}}, {"text": "Override isCellEditable() in your table's TableModel and return true for the desired row", "label": {"api": {"TableModel": [[42, 51]]}}}, {"text": "You could just use String.contains()", "label": {"api": {"String.contains()": [[19, 35]]}}}, {"text": "Map#.keySet() returns a view of the key set, which doesn't support ordering", "label": {"api": {"Map#.keySet()": [[0, 12]]}}}, {"text": "appendValueReduced is used to format a reduced value of a temporal field", "label": {"api": {"appendValueReduced": [[0, 17]]}}}, {"text": "I specifically need it to support the java.nio.file.FileSystem class", "label": {"api": {"java.nio.file.FileSystem": [[38, 61]]}}}, {"text": "Sadly java.awt.Polygon does not support Polygons with holes", "label": {"api": {"java.awt.Polygon": [[6, 21]]}}}, {"text": "You can use java.awt.geom.Path2D to render a \"compound shape\" with a hole in it", "label": {"api": {"java.awt.geom.Path2D": [[12, 31]]}}}, {"text": "In Java 8 collections now have a removeIf() method you can leverage", "label": {"api": {"removeIf()": [[33, 42]]}}}, {"text": "You better use comparator for sorting same bean with different conditions", "label": {"api": {"comparator": [[15, 24]]}}}, {"text": "Is it possible to use Context annotation and RolesAllowed annotation in a JAX-RS resource with Apache CXF 2.4.6 and Spring Security 3.2.8", "label": {"api": {"Context": [[22, 28]], "RolesAllowed": [[45, 56]]}}}, {"text": "The problem seems to be that Spring creates a proxy and Apache CXF cannot inject that proxy with the SecurityContext", "label": {"api": {"Context": [[109, 115]], "SecurityContext": [[101, 115]]}}}, {"text": "You're already using the File class to read the files from a directory", "label": {"api": {"File": [[25, 28]]}}}, {"text": "To do it, take a look at Runnable interface", "label": {"api": {"Runnable": [[25, 32]]}}}, {"text": "The rules you've suggested violate the requirements of Object.equals, in particular", "label": {"api": {"Object.equals": [[55, 67]]}}}, {"text": "Maybe I'm not understanding the use case here, but you could try using a Comparator and then create a ComparableDomain interface that has something like getType (this returns Domain1, Domain2, etc) as well as the common getters/setters (for name, age, and id) and you make all your Domains implement the ComparableDomain", "label": {"api": {"using a Comparator": [[65, 82]]}}}, {"text": "This is the modular inverse of e with respect to φ(n), which can be calculated with BigInteger's modInverse method", "label": {"api": {"BigInteger's modInverse method": [[84, 113]]}}}, {"text": "It seems for performance reasons OptionalDouble does not simply extend Optional<Double>", "label": {"api": {"OptionalDouble": [[33, 46]], "Optional<Double>": [[71, 86]]}}}, {"text": "Also mind that you can \"manually\" add Strings into the String constant pool by using the method String#intern", "label": {"api": {"String#intern": [[96, 108]]}}}, {"text": "If you need to both remove and fetch the entry, you can use pollFirstEntry() (assuming the type of the variable you're using is at least a NavigableMap - but since you're using firstEntry, I guess it is)", "label": {"api": {"pollFirstEntry()": [[60, 75]]}}}, {"text": "You are passing a 2D array into a method (Arrays.fill) that expects a 1D array", "label": {"api": {"Arrays.fill": [[42, 52]]}}}, {"text": "There is another interesting lock in java8 - StampedLock", "label": {"api": {"StampedLock": [[45, 55]]}}}, {"text": "It is incorrect because the hashCode method is not required to return distinct ints for all possible states of the object", "label": {"api": {"the hashCode method": [[24, 42]]}}}, {"text": "It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results", "label": {"api": {"the hashCode method": [[114, 132]]}}}, {"text": "Using a Task will make it easy to execute code on the FX Application Thread once the background process has finished", "label": {"api": {"Task": [[8, 11]]}}}, {"text": "Use a SwingWorker to fire up your OperationsMethod()", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "And use a shared and synchronized variable to share the button state between your Swing class and the SwingWorker", "label": {"api": {"SwingWorker": [[102, 112]]}}}, {"text": "The @Deprecated annotation is not annotated with @Inherited", "label": {"api": {"@Deprecated": [[4, 14]], "@Inherited": [[49, 58]]}}}, {"text": "If you use the implementor/subclass instead of the interface/superclass for type declaration, then you probably need a @Deprecated annotation on the implementing/overriding method", "label": {"api": {"@Deprecated": [[119, 129]]}}}, {"text": "With List.retainAll it is as simple as", "label": {"api": {"List.retainAll": [[5, 18]]}}}, {"text": "You could use HttpServletRequest#getHeader to obtain content-length header which value should be size of the request", "label": {"api": {"HttpServletRequest#getHeader": [[14, 41]]}}}, {"text": "In that case, you can use the class CompletableFuture", "label": {"api": {"CompletableFuture": [[36, 52]]}}}, {"text": "The the get()-method of CompletableFuture also has an alternative overload with a timeout parameter", "label": {"api": {"CompletableFuture": [[24, 40]], "has an alternative overload with a timeout parameter": [[47, 98]]}}}, {"text": "As defined in the Platform.runLater-Doc", "label": {"api": {"Platform.runLater-Doc": [[18, 38]]}}}, {"text": "Still, if I submit it to an ExecutorService using a single-argument method, and ignore the return value (i", "label": {"api": {"ExecutorService": [[28, 42]]}}}, {"text": "no type inference information is available), ExecutorService#submit(Callable) is chosen at compile time, unless I explicitly cast my lambda to Runnable", "label": {"api": {"ExecutorService": [[45, 59]], "ExecutorService#submit(Callable)": [[45, 76]]}}}, {"text": "DateTimeFormatter works on the TemporalAccessor interface and does not differ between concrete implementations like Instant, LocalDateTime or ZonedDateTime", "label": {"api": {"TemporalAccessor": [[31, 46]]}}}, {"text": "That's how Thread.join() is implemented", "label": {"api": {"how Thread.join() is implemented": [[7, 38]]}}}, {"text": "You can use Random#nextBoolean to generate random boolean values for your array", "label": {"api": {"Random#nextBoolean": [[12, 29]]}}}, {"text": "Have a look at TableCellRenderer explained", "label": {"api": {"TableCellRenderer": [[15, 31]]}}}, {"text": "And the interface TableCellRenderer", "label": {"api": {"TableCellRenderer": [[18, 34]]}}}, {"text": "However, if you absolutely have to have the enhanced for loop, you can have the inner for loop operate over a sublist, with List's subList method, starting with the next element", "label": {"api": {"List's subList method": [[124, 144]]}}}, {"text": "Assuming list is declared as List<Whatever>, you may achieve this behavior properly by using ListIterator rather than for-each loops", "label": {"api": {"ListIterator": [[93, 104]]}}}, {"text": "I have a Java SE 8 Spring 4.1.6-RELEASE application, where I am implementing the org.springframework.jdbc.core.RowMapper<T> interface, and I had some questions about the java.sql.ResultSet interface that is passed in its T mapRow(ResultSet rs, int rowNum) method", "label": {"api": {"java.sql.ResultSet": [[170, 187]]}}}, {"text": "If you take a look at java.sql.ResultSet, you can see you don't need to be so explicit", "label": {"api": {"java.sql.ResultSet": [[22, 39]]}}}, {"text": "Actually, unless you have a typeMapper for you connection which allows you to use the getObject method, it will not work (java.sql.ResultSet.getObject)", "label": {"api": {"java.sql.ResultSet": [[122, 139]], "java.sql.ResultSet.getObject": [[122, 149]]}}}, {"text": "It is not possible to declare an \"array of volatiles ...\", but one can  declare F as AtomicIntegerArray and use compareAndSet to atomically change the array content without worrying about Thread-visibility", "label": {"api": {"compareAndSet": [[112, 124]]}}}, {"text": "I have two sections of code using Java's \"SHA256withRSA\" Signature", "label": {"api": {"Signature": [[57, 65]]}}}, {"text": "You can get an instance of the Class object by using Class.forName", "label": {"api": {"Class.forName": [[53, 65]]}}}, {"text": "Afterwards, you would have to instantiate the object by using the Class.newInstance", "label": {"api": {"Class.newInstance": [[66, 82]]}}}, {"text": "Use the keySet method to get the keys", "label": {"api": {"keySet": [[8, 13]]}}}, {"text": "To change the file name of a Path, use one of the resolveSibling() methods", "label": {"api": {"resolveSibling()": [[50, 65]]}}}, {"text": "Using this method ensures that the result Path object is for the same FileSystem as the source Path object", "label": {"api": {"FileSystem": [[70, 79]]}}}, {"text": "The old style would be to use RandomAccessFile (Java 1+)", "label": {"api": {"RandomAccessFile": [[30, 45]]}}}, {"text": "The new style would be to use SeekableByteChannel (Java 7+)", "label": {"api": {"SeekableByteChannel": [[30, 48]]}}}, {"text": "In short, you need to tell Spring LDAP that this particular attribute represents distinguished names, by working with Name instances rather than plain strings", "label": {"api": {"Name": [[118, 121]]}}}, {"text": "Use String.format to print same spaces each time, for example", "label": {"api": {"String.format": [[4, 16]]}}}, {"text": "What you have there is a YearMonth, not a LocalDate since the day is missing", "label": {"api": {"YearMonth": [[25, 33]], "LocalDate": [[42, 50]]}}}, {"text": "Create an interceptor binding annotation, which must be annotated with @Inherited and @InterceptorBinding", "label": {"api": {"@Inherited": [[71, 80]], "@InterceptorBinding": [[86, 104]], "@Interceptor": [[86, 97]]}}}, {"text": "Create the incerceptor class which is annotated with the interceptor binding annotation created above as well as with the @Interceptor annotation", "label": {"api": {"@Interceptor": [[122, 133]]}}}, {"text": "Every @AroundInvoke method takes an InvocationContext argument, returns an Object, and throws an Exception", "label": {"api": {"@AroundInvoke": [[6, 18]], "InvocationContext": [[36, 52]], "Object": [[75, 80]], "Exception": [[97, 105]]}}}, {"text": "The @AroundInvoke method must call the InvocationContext#proceed() method, which causes the target class method to be invoked", "label": {"api": {"@AroundInvoke": [[4, 16]], "InvocationContext": [[39, 55]], "InvocationContext#proceed()": [[39, 65]]}}}, {"text": "For example, the PaymentHandler bean is annotated @Logged, which means that any invocation of its business methods will cause the interceptor's @AroundInvoke method to be invoked", "label": {"api": {"@AroundInvoke": [[144, 156]]}}}, {"text": "MessageFormat has the exact usage", "label": {"api": {"MessageFormat": [[0, 12]]}}}, {"text": "The String.format() method is my personal preference", "label": {"api": {"String.format()": [[4, 18]]}}}, {"text": "You may want to do some reading into String.format() if you are starting out with Java", "label": {"api": {"String.format()": [[37, 51]]}}}, {"text": "If you're already on EL 3.0 (available on Servlet 3.1 containers like Tomcat 8, WildFly 8, etc), an alternative to your custom function is to just import it right away in JSP like below using the new EL 3.0 ImportHandler API", "label": {"api": {"ImportHandler": [[207, 219]]}}}, {"text": "If all you need is a container of unique objects, the best way to go is to have these objects implement the .equals() and .hashCode() methods so you can use a Set to handle the uniqueness logic", "label": {"api": {"Set": [[159, 161]]}}}, {"text": "If you need them to be linked for some reason, LinkedHashSet is there for you", "label": {"api": {"Set": [[57, 59]], "LinkedHashSet": [[47, 59]]}}}, {"text": "Your use of Timer may be your primary issue", "label": {"api": {"Timer": [[12, 16]]}}}, {"text": "The Timer definition reads", "label": {"api": {"Timer": [[4, 8]]}}}, {"text": "Corresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks, sequentially", "label": {"api": {"Timer": [[22, 26]]}}}, {"text": "Timer tasks should complete quickly", "label": {"api": {"Timer": [[0, 4]]}}}, {"text": "One way is that you can use the ScheduleExpression as follows", "label": {"api": {"ScheduleExpression": [[32, 49]]}}}, {"text": "Or use the @Schedules annotations", "label": {"api": {"@Schedules": [[11, 20]]}}}, {"text": "Java has IllegalStateException but its description doesn't match the problem here", "label": {"api": {"IllegalStateException": [[9, 29]]}}}, {"text": "If I'm asked to pick an existing runtime exception for the situation you have described, I might choose UncheckedIOException wrapped around an EOFException", "label": {"api": {"UncheckedIOException": [[104, 123]], "EOFException": [[143, 154]]}}}, {"text": "In the Pattern class documentation, the summary specifies", "label": {"api": {"Pattern class documentation": [[7, 33]]}}}, {"text": "Further down in that same Pattern class documentation (with emphasis added)", "label": {"api": {"same Pattern class documentation": [[21, 52]]}}}, {"text": "It only knows the declared return type which matches the return type of Class.forName() which is java.lang.Object", "label": {"api": {"declared return type": [[18, 37]]}}}, {"text": "You can tweak the loading of XML stylesheets or documents done with document(), xsl:import or xsl:include by providing an URIResolver", "label": {"api": {"URIResolver": [[122, 132]]}}}, {"text": "Now when the factory encounters the xsl:import directive your URIResolver is notified to provide a Source for the imported stylesheet", "label": {"api": {"URIResolver": [[62, 72]]}}}, {"text": "You therefore just need to provide a URIResolver which loads the imported stylesheet from the database and returns it as Source object", "label": {"api": {"URIResolver": [[37, 47]]}}}, {"text": "The easiest way is probably to use the aminmation API to implement the timer", "label": {"api": {"aminmation API": [[39, 52]]}}}, {"text": "To add something using the iterator, use the add method of the iterator", "label": {"api": {"use the add method of the iterator": [[37, 70]]}}}, {"text": "There is Years class in Joda-Time api,but it does not have any methods for getting seconds or milliseconds (or any methods about converting it to Duration)", "label": {"api": {"Duration": [[146, 153]]}}}, {"text": "I think IllegalArgumentException is best suited for such parameter sanity checks", "label": {"api": {"IllegalArgumentException": [[8, 31]]}}}, {"text": "Thats because Arrays.fill takes single array", "label": {"api": {"Arrays.fill": [[14, 24]]}}}, {"text": "You could create a Scanner which reads that string as if you where reading it through a stream", "label": {"api": {"Scanner": [[19, 25]]}}}, {"text": "There is no such builtin factory method, which you can easily check by looking at all usages of Predicate within the JFC and look for “Methods in … that return Predicate”", "label": {"api": {"all usages of Predicate within the JFC": [[82, 119]], "Predicate": [[96, 104], [160, 168]]}}}, {"text": "Besides the methods within Predicate itself, there is only Pattern.asPredicate() which returns a Predicate", "label": {"api": {"Predicate": [[27, 35], [69, 77], [97, 105]], "Pattern.asPredicate()": [[59, 79]]}}}, {"text": "Note that Predicate.isEqual does similar", "label": {"api": {"Predicate": [[10, 18]]}}}, {"text": "I suggest you'll use ArrayList instead", "label": {"api": {"ArrayList": [[21, 29]]}}}, {"text": "Assuming the MyList type is a Collection, you can use Collectors.toCollection", "label": {"api": {"Collectors.toCollection": [[54, 76]]}}}, {"text": "Because it's to convenient, Java's Locale implementation seems like the correct key for the mapping", "label": {"api": {"Locale": [[35, 40]]}}}, {"text": "If I just use HashMap<Locale, String> translations = ...; for the translation, my code will not be able to fall back when a specific locale is not available", "label": {"api": {"Locale": [[22, 27]]}}}, {"text": "You could also create your PriorityQueue with a custom Comparator object instead", "label": {"api": {"create your PriorityQueue with a custom Comparator": [[15, 64]]}}}, {"text": "You can do it with the Java Reflection API, by using the Class.getConstructor() and Constructor.newInstance() methods", "label": {"api": {"Class.getConstructor()": [[57, 78]], "Constructor.newInstance()": [[84, 108]]}}}, {"text": "If they all had another constructor, you could pass the class of the expected arguments to Class.getConstructor(), and the actual argument values to Constructor.newInstance()", "label": {"api": {"Class.getConstructor()": [[91, 112]], "Constructor.newInstance()": [[149, 173]]}}}, {"text": "This is all (kind of) explained in the contract of Closeable's .close(), which says", "label": {"api": {"contract of Closeable's .close()": [[39, 70]]}}}, {"text": "To set the owner for the filechooser, pass it to the appropriate show function fileChooser.showOpenDialog(parentStage)", "label": {"api": {"fileChooser.showOpenDialog(parentStage)": [[79, 117]]}}}, {"text": "You can use SwingUtilities.invokeLater if you'd like to execute code in the AWT event thread", "label": {"api": {"SwingUtilities.invokeLater": [[12, 37]]}}}, {"text": "I've used the DoubleStream.iterate() method, which receives a seed and a function that receives the current element of the stream as an input and returns the following element (for this I've added step to the current element)", "label": {"api": {"DoubleStream.iterate() method": [[14, 42]]}}}, {"text": "I also had to use the DoubleStream.limit() method, because the stream generated by DoubleStream.iterate() is infinite", "label": {"api": {"DoubleStream.limit() method": [[22, 48]]}}}, {"text": "There is a built in TranslateTransition for this", "label": {"api": {"TranslateTransition": [[20, 38]]}}}, {"text": "Detecting the click on the link is relatively easy, as described in the JEditorPane documentation", "label": {"api": {"JEditorPane documentation": [[72, 96]]}}}, {"text": "Then use Desktop.browse(URI) to show the URL in the default browser", "label": {"api": {"Desktop.browse(URI)": [[9, 27]]}}}, {"text": "In addition to that, you can simply use List.remove() for removing the element, and inspect the return value (true if the item was in the list and was removed) to give the correct feedback to the user", "label": {"api": {"List.remove()": [[40, 52]]}}}, {"text": "If you are allowed to use the Arrays class as part of your assignment, you can sort your array and use a binary search instead, which is not O(n)", "label": {"api": {"Arrays": [[30, 35]]}}}, {"text": "Here are the javadocs for compareTo() as well", "label": {"api": {"javadocs for compareTo()": [[13, 36]]}}}, {"text": "List has a listIterator() method that returns a ListIterator which can be iterated backwards by calling previous(), so you could create your own class implementing ListIterator that wraps another ListIterator, reversing the iteration order, i.e", "label": {"api": {"List": [[0, 3], [48, 51], [164, 167], [196, 199]], "listIterator()": [[11, 24]], "ListIterator": [[48, 59], [164, 175], [196, 207]], "previous()": [[104, 113]]}}}, {"text": "next() calls previous() and vice versa", "label": {"api": {"previous()": [[13, 22]], "next()": [[0, 5]]}}}, {"text": "O(1) indexing, O(log n) search, and O(n) insert and delete can be done by keeping a sorted ArrayList and using Collections.binarySearch to search for elements or insert/delete positions", "label": {"api": {"Collections.binarySearch": [[111, 134]]}}}, {"text": "If your primary goal is O(1) for indexed lookup (get()), then you can implement your own class implementing List, backed by an array, using Arrays.binarySearch()", "label": {"api": {"List": [[108, 111]], "Arrays.binarySearch()": [[140, 160]]}}}, {"text": "The add(E) method is violating the List definition (append), but is consistent with the Collection definition", "label": {"api": {"List": [[35, 38]]}}}, {"text": "If duplicate values are not allowed, which could be a logical restriction, consider also implementing NavigableSet, which is a SortedSet", "label": {"api": {"NavigableSet": [[102, 113]], "SortedSet": [[127, 135]]}}}, {"text": "Constructor defined in ArrayList can be used and initial capacity can be set to 100", "label": {"api": {"ArrayList": [[23, 31]]}}}, {"text": "If you want random values then use Random Class within the range of length of the array to get different and random values of x and y and avoid ArrayIndexOutOfBound exception", "label": {"api": {"Random Class": [[35, 46]]}}}, {"text": "Your main problem is that you're using a Graphics object as if it were a Graphics2D object, but it's not and as the Graphics class Java API entry will show you, the Graphics class does not have a draw method, while Graphics2D does", "label": {"api": {"Graphics class Java API entry": [[116, 144]], "Graphics2D": [[73, 82], [215, 224]]}}}, {"text": "This can be done using Collectors.joining(delimiter)", "label": {"api": {"Collectors.joining(delimiter)": [[23, 51]]}}}, {"text": "If that won't work for some reason (if the dates are in different formats, for example), then you can use Java's SimpleDateFormat class to parse the date Strings into Date objects", "label": {"api": {"SimpleDateFormat": [[113, 128]], "Date": [[119, 122], [167, 170]]}}}, {"text": "You could use map() to get a Stream of region lists and then mapToInt to get the number of regions for each country", "label": {"api": {"mapToInt": [[61, 68]]}}}, {"text": "After that use sum() to get the sum of all the values in the IntStream", "label": {"api": {"sum()": [[15, 19]]}}}, {"text": "System.getProperties() returns a Properties object that inherits from Hashtable<Object,Object>", "label": {"api": {"System.getProperties()": [[0, 21]], "Properties": [[10, 19], [33, 42]], "Hashtable<Object,Object>": [[70, 93]]}}}, {"text": "You should be using the exec(String[]) method it's far safer", "label": {"api": {"exec(String[])": [[24, 37]]}}}, {"text": "You use the Color(float, float, float), since the second parameter has type float", "label": {"api": {"Color(float, float, float)": [[12, 37]]}}}, {"text": "Classes in Java all derive from Object", "label": {"api": {"Object": [[32, 37]]}}}, {"text": "Since you have no explicit parent class, then the parent is Object and super is referencing Object", "label": {"api": {"Object": [[60, 65], [92, 97]]}}}, {"text": "Object  does support the toString() method", "label": {"api": {"Object": [[0, 5]], "toString() method": [[25, 41]]}}}, {"text": "Think about using String.join() or the StringJoiner class instead", "label": {"api": {"String.join()": [[18, 30]], "StringJoiner": [[39, 50]]}}}, {"text": "On the handle method you receive HttpExchange object in the t parameter that has the getRequestMethod method", "label": {"api": {"HttpExchange": [[33, 44]], "getRequestMethod": [[85, 100]]}}}, {"text": "Is there a converter which translates java ResourceBundles into iOS strings files", "label": {"api": {"java ResourceBundles": [[38, 57]]}}}, {"text": "Can we get table column info without using ResultSetMetaData object", "label": {"api": {"ResultSetMetaData": [[43, 59]]}}}, {"text": "You can get the column info of a table without running a SELECT statement by calling Connection.getMetaData().getColumns(null, null, \"MyTable\", \"%\")", "label": {"api": {"Connection.getMetaData()": [[85, 108]], "getColumns(null, null, \"MyTable\", \"%\")": [[110, 147]]}}}, {"text": "How to use controllers is described in full in the FXML reference, but in short", "label": {"api": {"FXML reference": [[51, 64]]}}}, {"text": "Since a 2D array is actually an array of arrays, you sort the outer array using a custom Comparator<String[]> by calling Arrays.sort(array, comparator)", "label": {"api": {"Comparator<String[]>": [[89, 108]], "Arrays.sort(array, comparator)": [[121, 150]]}}}, {"text": "The search for connected words should be done by adding all words to a TreeSet", "label": {"api": {"TreeSet": [[71, 77]]}}}, {"text": "For each suffix (1-, 2-, or 3-letter), call subSet(suffix, nextSuffix), where nextSuffix is the same as suffix except last character incremented by one", "label": {"api": {"subSet(suffix, nextSuffix)": [[44, 69]]}}}, {"text": "Keep a separate HashSet called used of words found so far, to prevent infinite looping and to prevent using longer paths to a word that was already found using a shorter path", "label": {"api": {"HashSet": [[16, 22]]}}}, {"text": "I was thinking of using a Java Set implementation, put all the strings in it and put it in memory", "label": {"api": {"Set": [[31, 33]]}}}, {"text": "For any given input, I would loop through the Set and find the records that contain the input using String.contains() and add the results to another Set or List", "label": {"api": {"Set": [[46, 48], [149, 151]]}}}, {"text": "Use Long.toBinaryString(long) or Integer.toBinaryString(int)", "label": {"api": {"Long.toBinaryString(long)": [[4, 28]], "Integer.toBinaryString(int)": [[33, 59]]}}}, {"text": "Use Double.doubleToRawLongBits(double) or Float.floatToRawIntBits(float), then convert to binary as above", "label": {"api": {"Double.doubleToRawLongBits(double)": [[4, 37]], "Float.floatToRawIntBits(float)": [[42, 71]]}}}, {"text": "You are a missing a call for entrada.nextLine() after opc = entrada.nextInt(); - it isn't advancing the input properly", "label": {"api": {"entrada.nextLine()": [[29, 46]], "entrada.nextInt()": [[60, 76]]}}}, {"text": "When you call entrada.nextInt() it consumes the int value, but not the newline character at the end", "label": {"api": {"entrada.nextInt()": [[14, 30]]}}}, {"text": "You can add key listener to the JTextField and override the keyreleased method", "label": {"api": {"JTextField": [[32, 41]]}}}, {"text": "You can use the static method Comparator.comparing to create a comparator based on a function that returns a comparable value", "label": {"api": {"Comparator.comparing": [[30, 49]]}}}, {"text": "if your class has a natural ordering according to these values, you better let it implement the interface Comparable and write the compare logic in there", "label": {"api": {"Comparable": [[106, 115]]}}}, {"text": "Java's List<T> has a boolean contains(Object) method, which is handy for situations when you wish to avoid duplicates", "label": {"api": {"boolean contains(Object)": [[21, 44]]}}}, {"text": "Note that using this approach, you shouldn't implement equals or hashCode in MCWarTeam, because you aren't gonna need it; as your map keys are team names, containsKey operates on String objects which already have well-defined equals and hashCode semantics", "label": {"api": {"containsKey": [[155, 165]]}}}, {"text": "You could use limit(int)", "label": {"api": {"limit(int)": [[14, 23]]}}}]