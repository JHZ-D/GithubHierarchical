[{"text": "Extending AbstractList is a quick way to get a list implementation up and running", "label": {"api": {"AbstractList": [[10, 21]]}}}, {"text": "Like the regular List.subList method, the following sublist is backed by the main list, so changes to the sublist will write through to the main list (which may or may not be a feature you wanted, but you can always create a new, separate ArrayList from the sublist if needed)", "label": {"api": {"List.subList": [[17, 28]]}}}, {"text": "You can just use ifPresent to get rid of isPresent and get if it is true", "label": {"api": {"ifPresent": [[17, 25]]}}}, {"text": "Formatter class (which is the basis of String.format method) operates using the concept of \"fields\"", "label": {"api": {"Formatter": [[0, 8]]}}}, {"text": "However, if you need some fine-grained formatting of numbers usually what you are looking for is DecimalFormat class, which allows you to easily customize how the numbers are represented", "label": {"api": {"DecimalFormat": [[97, 109]]}}}, {"text": "Instead of Math.pow() you need to use BigDecimal#pow()", "label": {"api": {"BigDecimal#pow()": [[38, 53]]}}}, {"text": "As mentioned before, Map is an option.More specifically HashMap, or another option could be Hashtable", "label": {"api": {"HashMap": [[56, 62]], "Hashtable": [[92, 100]]}}}, {"text": "Some major differences are HashMap allows nulls but it is not synchronized", "label": {"api": {"HashMap": [[27, 33]]}}}, {"text": "On the other hand Hashtable is synchronized and does not accept null as key", "label": {"api": {"Hashtable": [[18, 26]]}}}, {"text": "Say that user opens an page and browser send 3 request which is catched by servlet Filter", "label": {"api": {"servlet Filter": [[75, 88]]}}}, {"text": "The javadoc for Runtime.exec states that the command will be started in a separate process", "label": {"api": {"javadoc for Runtime.exec": [[4, 27]]}}}, {"text": "Check the JavaDoc of java.util.Formatter", "label": {"api": {"java.util.Formatter": [[21, 39]]}}}, {"text": "When grouping a Stream with Collectors.groupingBy, you can specify a reduction operation on the values with a custom Collector", "label": {"api": {"Collectors.groupingBy": [[28, 48]]}}}, {"text": "Here, we need to use Collectors.mapping, which takes a function (what the mapping is) and a collector (how to collect the mapped values)", "label": {"api": {"Collectors.mapping": [[21, 38]]}}}, {"text": "See the documentation PrintStream and the option", "label": {"api": {"PrintStream": [[22, 32]]}}}, {"text": "From JavaDoc for compareAndSet", "label": {"api": {"JavaDoc for compareAndSet": [[5, 29]]}}}, {"text": "You want the emailAddresses field of EmailAddress to be the value of the (outer) <emailAddresses> element, so you have to tell JAXB that, by specifying the @XmlValue annotation", "label": {"api": {"@XmlValue": [[156, 164]]}}}, {"text": "The @XmlValue annotation is especially useful when combined with @XmlAttribute, to support XML like this", "label": {"api": {"@XmlValue": [[4, 12]], "@XmlAttribute": [[65, 77]]}}}, {"text": "If you wanted to control these more carefully, then you can create your own class implementing Map", "label": {"api": {"Map": [[95, 97]]}}}, {"text": "You can set the HGrow in the createHeader method for your HBox", "label": {"api": {"HGrow": [[16, 20]]}}}, {"text": "Normally, I would suggest that you replace your int value (z) with enum constants, and store your Insets objects as values in an EnumMap", "label": {"api": {"EnumMap": [[129, 135]]}}}, {"text": "gridx and gridy default to GridBagConstraints.RELATIVE, which happens to do exactly what you want", "label": {"api": {"GridBagConstraints.RELATIVE": [[27, 53]]}}}, {"text": "it automatically adds each new component on the same row, unless gridwidth or gridheight is changed to REMAINDER, in which case a new row or column (respectively) will be started for the next relatively placed component", "label": {"api": {"REMAINDER": [[103, 111]]}}}, {"text": "Otherwise you can use (if on Java 8 - using the new pattern symbol \"x\")", "label": {"api": {"Java 8": [[29, 34]]}}}, {"text": "You can convert a stream of map entries to a Map by using Collectors.toMap, passing key supplier and value supplier methods", "label": {"api": {"Collectors.toMap": [[58, 73]]}}}, {"text": "The end index argument to substring is exclusive, which is why I added 1", "label": {"api": {"substring is exclusive": [[26, 47]]}}}, {"text": "It also suggested FilterInputStream, and FilterReader, but I don't think those are what I am looking for", "label": {"api": {"FilterInputStream": [[18, 34]], "FilterReader": [[41, 52]]}}}, {"text": "You are calling fmt1.format(testOne[i]); but you are not doing anything with the result", "label": {"api": {"format": [[21, 26]]}}}, {"text": "Calling format returns a String, it does not affect the thing being passed as a parameter, so when you later print testOne[0] etc", "label": {"api": {"format": [[8, 13]]}}}, {"text": "If you want the formatted values you will have to assign the return of .format() to something, keep it around, and print it instead of the original integer values", "label": {"api": {"format": [[16, 21], [72, 77]]}}}, {"text": "Look up BitSet in the Java API documentation", "label": {"api": {"Java API documentation": [[22, 43]]}}}, {"text": "Perhaps valueOf(long[]) will be the easiest to use in your case, even though you only need one element rather than a whole array, and you want an int, but a long is also ok", "label": {"api": {"valueOf(long[])": [[8, 22]]}}}, {"text": "If you are using Java8, you can use getOrDefault method", "label": {"api": {"getOrDefault": [[36, 47]]}}}, {"text": "This looks like an implementation of Set's removeAll", "label": {"api": {"removeAll": [[43, 51]]}}}, {"text": "If you want a Set that maintains insertion order, the class you're looking for is LinkedHashSet", "label": {"api": {"LinkedHashSet": [[82, 94]]}}}, {"text": "NoSuchMethodException is a subtype of ReflectiveOperationException, so it can only be thrown by code that uses reflection", "label": {"api": {"NoSuchMethodException": [[0, 20]]}}}, {"text": "In this case you'll get a NoSuchMethodError (which is an Error, not an Exception) when the code is executed instead", "label": {"api": {"NoSuchMethodError": [[26, 42]]}}}, {"text": "NoSuchMethodException is not the same as NoSuchMethodError", "label": {"api": {"NoSuchMethodException": [[0, 20]], "NoSuchMethodError": [[41, 57]]}}}, {"text": "NoSuchMethodException is thrown by calls to reflection API methods such as getMethod() and getConstructor()", "label": {"api": {"NoSuchMethodException": [[0, 20]], "getMethod()": [[75, 85]], "getConstructor()": [[91, 106]]}}}, {"text": "See the \"Uses\" page of the javadoc for more", "label": {"api": {"Uses": [[9, 12]]}}}, {"text": "NoSuchMethodError is thrown...", "label": {"api": {"NoSuchMethodError": [[0, 16]]}}}, {"text": "If you can use AWT, the Java standard library already has ConvolveOp built in", "label": {"api": {"ConvolveOp": [[58, 67]]}}}, {"text": "To \"properly\" convert an array to a string, you could use Arrays.toString", "label": {"api": {"Arrays.toString": [[58, 72]]}}}, {"text": "Using a BorderLayout will allow anything added to the BorderLayout.WEST, BorderLayout.EAST, BorderLayout.NORTH, BorderLayout.SOUTH spots to only take up as much space a needed and anything added to the BorderLayout.CENTER to take up all of the remaining space", "label": {"api": {"BorderLayout": [[8, 19], [54, 65], [73, 84], [92, 103], [112, 123], [202, 213]]}}}, {"text": "Just use GridLayout in your JPanel", "label": {"api": {"GridLayout": [[9, 18]]}}}, {"text": "The parameters of GraphicsContext.arc are not the same as GraphicsContext.strokeArc", "label": {"api": {"GraphicsContext.arc": [[18, 36]], "GraphicsContext.strokeArc": [[58, 82]]}}}, {"text": "Please check IntStream docs for further reference", "label": {"api": {"IntStream docs": [[13, 26]]}}}, {"text": "Make sure, you flush and close the file after you've done with it", "label": {"api": {"flush": [[15, 19]], "close": [[25, 29]]}}}, {"text": "Use int wrapper Integer", "label": {"api": {"Integer": [[16, 22]]}}}, {"text": "Just check the returned TimeZone", "label": {"api": {"TimeZone": [[24, 31]]}}}, {"text": "In Java 8, use the new ZoneId.of(String zoneId), which will fail for unknown time zones, and TimeZone.getTimeZone(ZoneId zoneId) if you need the old TimeZone", "label": {"api": {"TimeZone": [[93, 100], [105, 112], [149, 156]], "ZoneId.of(String zoneId)": [[23, 46]], "TimeZone.getTimeZone(ZoneId zoneId)": [[93, 127]]}}}, {"text": "It doesn't seem like this is the case because the Processor class only provides", "label": {"api": {"Processor": [[50, 58]]}}}, {"text": "Where the RoundEnvironment allows you to access a Set of annotated elements, e.g.", "label": {"api": {"RoundEnvironment": [[10, 25]]}}}, {"text": "Try to have a look into Semaphore", "label": {"api": {"Semaphore": [[24, 32]]}}}, {"text": "Initially, all I had was executorService's invokeAll, shutdown and awaitTermination calls that were used to ensure that all tasks complete (inspite of errors or not)", "label": {"api": {"awaitTermination": [[67, 82]]}}}, {"text": "I migrated the code to use CompletionService to display the results", "label": {"api": {"CompletionService": [[27, 43]]}}}, {"text": "Where can I enforce the awaitTermination clause in the CompletionService calls", "label": {"api": {"awaitTermination": [[24, 39]], "CompletionService": [[55, 71]]}}}, {"text": "In other words, how can I utilize timeout for CompletionService", "label": {"api": {"CompletionService": [[46, 62]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html So, it submits n tasks to a new instance of ExecutorCompletionService and waits n to complete", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html": [[0, 92]]}}}, {"text": "As per the Javadocs, the compareTo method should return 0 if the two objects are equal, any negative number if this object is \"smaller\" than the specified other, and any positive number if this object is \"larger\" than the specified other", "label": {"api": {"As per the Javadocs": [[0, 18]]}}}, {"text": "Sorting the array with this method taking a starting and ending indices", "label": {"api": {"this method taking a starting and ending indices": [[23, 70]]}}}, {"text": "WatchService is meant to provide this functionality, and there are implementations that use native events included in the JRE for most major OSes except for macOS (as of Feb", "label": {"api": {"WatchService": [[0, 11]]}}}, {"text": "For macOS, gmethvin/directory-watcher includes an open source implementation of WatchService that uses native events that can be used", "label": {"api": {"WatchService": [[80, 91]]}}}, {"text": "You should really read the String API", "label": {"api": {"String API": [[27, 36]]}}}, {"text": "Javadoc for wait", "label": {"api": {"Javadoc for wait": [[0, 15]]}}}, {"text": "Since you have a string, contatining 0s and 1s only, you can simply do it without casting to Long, just using String#charAt() and BitSet#set()", "label": {"api": {"BitSet#set()": [[130, 141]]}}}, {"text": "It is possible to solve the task with just ZipInputStream", "label": {"api": {"ZipInputStream": [[43, 56]]}}}, {"text": "You should read the input into a bytes array first, then build a String using the correct encoding", "label": {"api": {"build a String using the correct encoding": [[57, 97]]}}}, {"text": "To insert a date and a time, you need to use setTimestamp instead of setDate and the datatype of your database column must be DATETIME (or TIMESTAMP)", "label": {"api": {"setTimestamp": [[45, 56]], "setDate": [[69, 75]]}}}, {"text": "Quoting setDate Javadoc", "label": {"api": {"setDate": [[8, 14]]}}}, {"text": "Maybe you should look at the Java JDK and follow the example in the java.sql package", "label": {"api": {"example": [[53, 59]]}}}, {"text": "If users can extend your interface without your knowledge then a factory can't work; you have to stick to the JDBC example", "label": {"api": {"example": [[115, 121]]}}}, {"text": "Assuming you're on Java 8, you should use streams", "label": {"api": {"streams": [[42, 48]]}}}, {"text": "Basically, you can do a Collections.binarySearch() for the first item in the sequence", "label": {"api": {"Collections.binarySearch()": [[24, 49]]}}}, {"text": "If both path point to the same file/directory then you could make use of the Files class", "label": {"api": {"Files": [[77, 81]]}}}, {"text": "It has a method Files#isSameFile to which you pass two Path instances and it would check if both files are pointing to the same file at your directory", "label": {"api": {"Files": [[16, 20]], "Files#isSameFile": [[16, 31]]}}}, {"text": "Note that with Java 8, if b were defined as Optional<Object> (if not, you can always turn it into an Optional using Optional.ofNullable(b)), you could use orElseGet and write", "label": {"api": {"Optional<Object>": [[44, 59]], "Optional.ofNullable(b)": [[116, 137]], "orElseGet": [[155, 163]]}}}, {"text": "You can use the Scanner method hasNextDouble to check to see if the next token can be read as a double, and then use nextDouble to retrieve it", "label": {"api": {"hasNextDouble": [[31, 43]], "nextDouble": [[117, 126]]}}}, {"text": "Maybe the Window#pack() method will work", "label": {"api": {"Window#pack()": [[10, 22]]}}}, {"text": "groupingBy(classifier, downstream) is a collector that groups elements according to the given classifier (here, it is MyClass::getRate) and performs a reduction on the values using the downstream collector (here, it is counting())", "label": {"api": {"groupingBy(classifier, downstream)": [[0, 33]], "counting()": [[219, 228]]}}}, {"text": "An example in Java SE is StandardCopyOption and LinkOption, which both implement CopyOption", "label": {"api": {"StandardCopyOption": [[25, 42]], "LinkOption": [[48, 57]], "CopyOption": [[33, 42], [81, 90]]}}}, {"text": "Although CopyOption doesn't have any methods, you certainly can define methods in such an inherited interface if you wish", "label": {"api": {"CopyOption": [[9, 18]]}}}, {"text": "I would use an Executor service in this case", "label": {"api": {"Executor service": [[15, 30]]}}}, {"text": "It supports the addition of tasks (in many forms, including Runnable)", "label": {"api": {"Runnable": [[60, 67]]}}}, {"text": "You can easily create an ExecutorService using the Executors class", "label": {"api": {"Executors": [[51, 59]]}}}, {"text": "I'd recommend using a fixed size thread pool for this with 20-100 max threads - depending on how CPU intensive your tasks are", "label": {"api": {"fixed size thread pool": [[22, 43]]}}}, {"text": "Collect all the Future instances returned by the submit method and simply call get on all of them", "label": {"api": {"get": [[79, 81]]}}}, {"text": "Shut down the executor service and wait for all the submitted tasks to finish", "label": {"api": {"Shut down": [[0, 8]], "wait for all the submitted tasks to finish": [[35, 76]]}}}, {"text": "I did some Googling, but didn't find anything related to why Java's Reference class doesn't implement the Supplier interface", "label": {"api": {"Reference class": [[68, 82]], "Supplier interface": [[106, 123]]}}}, {"text": "The get() method of an instance of the Reference class returns the referent; the get() method of Supplier instance returns the result of a lambda expression", "label": {"api": {"Reference class": [[39, 53]]}}}, {"text": "As stated, the problem is that Collectors.toMap accumulates the element into Map<K,U> (the current implementation returns an HashMap but it's an internal detail)", "label": {"api": {"Collectors.toMap": [[31, 46]]}}}, {"text": "If you want to collect into an ImmutableMap, you can use the collectingAndThen collector", "label": {"api": {"collectingAndThen": [[61, 77]]}}}, {"text": "Use Collectors.toMap as the downstream collector and provide the function map -> ImmutableMap.copyOf(map) as a finisher", "label": {"api": {"Collectors.toMap": [[4, 19]]}}}, {"text": "Instead, update the viewport component via setViewportView()", "label": {"api": {"setViewportView()": [[43, 59]]}}}, {"text": "If you decide the annotation to be @Inherited, yes", "label": {"api": {"@Inherited": [[35, 44]]}}}, {"text": "In this example, @RestController is not defined with the @Inherited meta-annotation, so it is not applied to subclasess of AbstractController", "label": {"api": {"@Inherited": [[57, 66]]}}}, {"text": "See https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html for more discussion", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html": [[4, 67]]}}}, {"text": "Try this anyMatch of Lambda Expression(Java 8)", "label": {"api": {"anyMatch": [[9, 16]]}}}, {"text": "But in your case I would recommend to use an ArrayList or a Map (if you have to save the ID with it)", "label": {"api": {"ArrayList": [[45, 53]], "Map": [[60, 62]]}}}, {"text": "Using orElseGet you create a lambda which is executed only when the Optional is empty", "label": {"api": {"orElseGet": [[6, 14]]}}}, {"text": "What you're looking for is the Optional.or method introduced in Java 9", "label": {"api": {"Optional.or": [[31, 41]]}}}, {"text": "The problem you're seeing is when you implicitly call BigDecimal.toString(), which is documented to use exponential notation sometimes", "label": {"api": {"BigDecimal.toString()": [[54, 74]]}}}, {"text": "Instead, you want to use BigDecimal.toPlainString()", "label": {"api": {"BigDecimal.toPlainString()": [[25, 50]]}}}, {"text": "You can use a ServletContextListener", "label": {"api": {"ServletContextListener": [[14, 35]]}}}, {"text": "And make a Java class implement the ServletContextListener interface", "label": {"api": {"ServletContextListener": [[36, 57]]}}}, {"text": "Quoting DecimalFormat Javadoc", "label": {"api": {"DecimalFormat": [[8, 20]]}}}, {"text": "You are not setting an explicit grouping size, so it becomes 0 when you are constructing the DecimalFormat with the format you have (there is no grouping separator in your format)", "label": {"api": {"DecimalFormat": [[93, 105]]}}}, {"text": "Since you're already working with a ByteBuffer (since 1.4), however, you have a range of methods directly on it such as getDouble()", "label": {"api": {"getDouble()": [[120, 130]]}}}, {"text": "On plain Java, install a SecurityManager with a policy describing what you want", "label": {"api": {"SecurityManager": [[25, 39]]}}}, {"text": "While Android has a SecurityManager class, the docs say not to use it, and I don't think there's any way to do what you want, although I'm also not sure how it makes sense", "label": {"api": {"SecurityManager": [[20, 34]]}}}, {"text": "Iterate through a List<Point> in your implementation of paintComponent(), where each point is the leading baseline of a string", "label": {"api": {"paintComponent()": [[56, 71]], "leading baseline": [[98, 113]]}}}, {"text": "You can call DoubleStream's summaryStatistics method", "label": {"api": {"DoubleStream's summaryStatistics method": [[13, 51]]}}}, {"text": "Click Here for Oracle documentation regarding setELValue()", "label": {"api": {"Click Here": [[0, 9]]}}}, {"text": "Have a look at the javadoc for URI", "label": {"api": {"javadoc for URI": [[19, 33]]}}}, {"text": "This is all in the first section of the JavaFX CSS Reference Guide", "label": {"api": {"JavaFX CSS Reference Guide": [[40, 65]]}}}, {"text": "In Java you can use Guava TypeToken as an alternative to Class mentioned in @JoopEggen's answer", "label": {"api": {"Type": [[26, 29]]}}}, {"text": "This will let you work with different generic types more easily than using Type directly", "label": {"api": {"Type": [[75, 78]]}}}, {"text": "A possible solution would be to map each value in the array to itself if it's even and to its opposite if it's odd", "label": {"api": {"map": [[32, 34]]}}}, {"text": "That way, by summing the result, you will have added all even numbers and subtracted all odd ones", "label": {"api": {"sum": [[13, 15]]}}}, {"text": "You can retrieve an IntStream from an int array with Arrays.stream(array), then use map to transform the even and odd values and finally call sum to sum all values", "label": {"api": {"IntStream": [[20, 28]], "Arrays.stream(array)": [[53, 72]], "map": [[84, 86]], "sum": [[142, 144], [149, 151]]}}}, {"text": "Because the Integer wrapper type is nullable and in your queue you have a null Integer that you then try to cast as int primitive type ..", "label": {"api": {"Integer": [[12, 18], [79, 85]]}}}, {"text": "You could just use Java Random class", "label": {"api": {"Random": [[24, 29]]}}}, {"text": "There's AtomicReference<T> which is what I'd normally use", "label": {"api": {"AtomicReference<T>": [[8, 25]]}}}, {"text": "There is also AtomicReference although it is generally used in a multi-threading context", "label": {"api": {"AtomicReference": [[14, 28]]}}}, {"text": "Correct and safe way to do what you need is to use Long.compare", "label": {"api": {"Long.compare": [[51, 62]]}}}, {"text": "It creates an IntStream going from i to len exclusive (with the help of range), then filters the element of the buffer being equal to \\n (with the help of filter)", "label": {"api": {"IntStream": [[14, 22]], "range": [[72, 76]], "filter": [[85, 90], [155, 160]]}}}, {"text": "Since we're only interested in the first one, we call findFirst()", "label": {"api": {"findFirst()": [[54, 64]]}}}, {"text": "If none was found then we return len (with the help of orElse)", "label": {"api": {"orElse": [[55, 60]]}}}, {"text": "DateFormat is an abstract class with protected constructor.You can use SimpleDateFormat like this", "label": {"api": {"DateFormat": [[0, 9], [77, 86]], "SimpleDateFormat": [[71, 86]]}}}, {"text": "readLine() waits until you press a key", "label": {"api": {"readLine()": [[0, 9]]}}}, {"text": "You can call LogManager.readConfiguration() after you set the system property to load the settings", "label": {"api": {"LogManager.readConfiguration()": [[13, 42]]}}}, {"text": "The way you set an int field to null is with setNull rather than setInt", "label": {"api": {"setNull": [[45, 51]], "setInt": [[65, 70]]}}}, {"text": "setInt takes an int argument, so it cannot receive null as a value", "label": {"api": {"setInt": [[0, 5]]}}}, {"text": "You don't need any extra code, just the \\Q and \\E constructs, as documented in Java's Pattern class", "label": {"api": {"Java's Pattern class": [[79, 98]]}}}, {"text": "indexOf returns the index of the given string within the string it's called on", "label": {"api": {"indexOf": [[0, 6]]}}}, {"text": "As you already mentioned, the behaviour of split() changed in Java 8, and a zero-width match at the beginning however never produces such empty leading substring", "label": {"api": {"Java 8": [[62, 67]]}}}, {"text": "each thread has an interrupt flag, that you can change by interrupting the thread", "label": {"api": {"interrupting the thread": [[58, 80]]}}}, {"text": "You misinterpreted what Collections.reverse does", "label": {"api": {"Collections.reverse": [[24, 42]]}}}, {"text": "Take a look at the documentation of the equals method for BigDecimal", "label": {"api": {"documentation of the equals method for BigDecimal": [[19, 67]]}}}, {"text": "You can read the docs", "label": {"api": {"You can read the docs": [[0, 20]]}}}, {"text": "Here is the documentation", "label": {"api": {"Here is the documentation": [[0, 24]]}}}, {"text": "(1) The $ at the end of the pattern matches the end of the string; it will not let you match \"sen\" because \"sen\" isn't followed by the end of the string", "label": {"api": {"matches": [[36, 42]]}}}, {"text": "(2) You're using m.matches(), which only returns true if the entire string is matched", "label": {"api": {"matches": [[19, 25]]}}}, {"text": "See the definition of matches", "label": {"api": {"matches": [[22, 28]]}}}, {"text": "Remove $ and change matches() to find()", "label": {"api": {"matches": [[20, 26]]}}}, {"text": "JPanel has indeed a single setPreferredSize(Dimension d)", "label": {"api": {"setPreferredSize(Dimension d)": [[27, 55]]}}}, {"text": "You can check that JPanel.isPreferredSizeSet() returns null if you didn't set it", "label": {"api": {"JPanel.isPreferredSizeSet()": [[19, 45]]}}}, {"text": "The toString() method returns a textual representation of the object, but there is no guarantee this will include the class name", "label": {"api": {"textual representation": [[32, 53]]}}}, {"text": "In particular any textual representation could come from a string", "label": {"api": {"textual representation": [[18, 39]]}}}, {"text": "args) method with RowMapper as second argument (converted to Object[]), which in turn was given as a parameter to the JDBC's PreparedStatement.setObject this is not what you intended, and cannot work in general because your implementation of RowMapper is not Serializable", "label": {"api": {"Serializable": [[259, 270]]}}}, {"text": "I bet you are neglecting to invoke addObserver() on your Observer, or neglecting to invoke both setChanged() and notifyObservers() in your Observable", "label": {"api": {"Observer": [[38, 45], [57, 64], [119, 126]], "Observable": [[139, 148]]}}}, {"text": "JFileChooser has a method addActionListener which accepts an ActionListener which is invoked when the user presses one of the two buttons at the bottom of the JFileChooser window", "label": {"api": {"JFileChooser": [[0, 11], [159, 170]], "addActionListener": [[26, 42]], "ActionListener": [[29, 42], [61, 74]]}}}, {"text": "But, as I discovered, it is not invoked when the user closes the JFileChooser by clicking on the close button in the window title bar of the chooser (or using an other method of the OS to close it)", "label": {"api": {"JFileChooser": [[65, 76]]}}}, {"text": "How can a creator of a JFileChooser recognize when it has been closed in this case", "label": {"api": {"JFileChooser": [[23, 34]]}}}, {"text": "In conjunction with the result returned by showOpenDialog(), you can add an AncestorListener and implement ancestorRemoved()", "label": {"api": {"showOpenDialog()": [[43, 58]], "AncestorListener": [[76, 91]]}}}, {"text": "JFileChooser extends JComponent", "label": {"api": {"JComponent": [[21, 30]], "Component": [[22, 30]]}}}, {"text": "So if you want to use it asynchronously instead of invoking showDialog and letting the rest of the UI freeze, you can embed the JFileChooser in a regular JFrame or any other Component as it is done here", "label": {"api": {"Component": [[174, 182]]}}}, {"text": "After update of you question now I can guess that there is a problem with attribute in your ITask insterface please read that doc", "label": {"api": {"that": [[45, 48], [121, 124]]}}}, {"text": "Use hasNextLine() and nextLine() methods available in Scanner class", "label": {"api": {"hasNextLine()": [[4, 16]], "nextLine()": [[22, 31]]}}}, {"text": "You can use StringBuilder#reverse for reversing a String", "label": {"api": {"StringBuilder#reverse": [[12, 32]]}}}, {"text": "You need to set the request method to OPTIONS", "label": {"api": {"set the request method": [[12, 33]]}}}, {"text": "I am creating and using Line2D in Java", "label": {"api": {"Line2D": [[24, 29]]}}}, {"text": "I recommend use of javadoc (http://docs.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html": [[28, 97]]}}}, {"text": "The Java 8 java.time package has what you need", "label": {"api": {"java.time": [[11, 19]]}}}, {"text": "You're using a URL instance but RestTemplate expects an object of type URI", "label": {"api": {"URL": [[15, 17]], "URI": [[71, 73]]}}}, {"text": "Now you can load different images and use them in a java.awt.TrayIcon", "label": {"api": {"java.awt.TrayIcon": [[52, 68]]}}}, {"text": "Optionally, you could use a Timer instead of an actual thread, so your TimerRefreshRace will have its own timer which periodically fires an event", "label": {"api": {"Timer": [[28, 32], [71, 75]]}}}, {"text": "I feel providing a link to java.util.regex.Pattern API is not a good choice", "label": {"api": {"java.util.regex.Pattern": [[27, 49]]}}}, {"text": "You can get to the next result set using Statement.getMoreResults() and Statement.getResultSet", "label": {"api": {"Statement.getMoreResults()": [[41, 66]], "Statement.getResultSet": [[72, 93]]}}}, {"text": "Sure, not with String.split, but with Pattern.split you can", "label": {"api": {"String.split": [[15, 26]], "Pattern.split": [[38, 50]]}}}, {"text": "Pattern#split(String) method like this", "label": {"api": {"Pattern#split(String)": [[0, 20]]}}}, {"text": "So create ArrayList using Object type", "label": {"api": {"ArrayList": [[10, 18]]}}}, {"text": "The default method is delegating to Arrays#sort, which has existed since at least Java 1.7", "label": {"api": {"has existed since at least Java 1.7": [[55, 89]]}}}, {"text": "Each one is currently a server using the HttpServer class and makes requests using Apaches HTTP client library", "label": {"api": {"HttpServer": [[41, 50]]}}}, {"text": "As of Java 8 you can leverage Optional", "label": {"api": {"Optional": [[30, 37]]}}}, {"text": "Each map turns the Optional into a new one, but only if the source and target values are both non-null", "label": {"api": {"Optional": [[19, 26]]}}}, {"text": "A null value at any point ends up yielding an empty Optional which is safely ignored", "label": {"api": {"Optional": [[52, 59]]}}}, {"text": "You can compare the tree with the actual inheritance tree in the official documentation", "label": {"api": {"in the official documentation": [[58, 86]]}}}, {"text": "...and that PrintStream owns a BufferedWriter and can be set to auto-flush, but doesn't do so by default", "label": {"api": {"can be set to auto-flush, but doesn't do so by default": [[50, 103]]}}}, {"text": "The best way is to use PrintStream with autoFlush enabled", "label": {"api": {"PrintStream with autoFlush enabled": [[23, 56]]}}}, {"text": "I gone through this link for reference", "label": {"api": {"link": [[20, 23]]}}}, {"text": "You should use a StringBuilder for this task", "label": {"api": {"StringBuilder": [[17, 29]]}}}, {"text": "\"yy/mm/dd\", the year format in the alert date string yyyy, so use SimpleDateFormat to format accordingly", "label": {"api": {"SimpleDateFormat": [[66, 81]]}}}, {"text": "Please use the SimpleDateFormat to format the date string and everything should work fine", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "To open a stream on a remote file, you can use HttpURLConnection", "label": {"api": {"HttpURLConnection": [[47, 63]]}}}, {"text": "Call getInputStream() on an HttpURLConnection instance to get an input stream that you can process further", "label": {"api": {"HttpURLConnection": [[28, 44]], "getInputStream()": [[5, 20]]}}}, {"text": "I do not know the Serializer class, but judging from the exception, you need to make your GUID class implement the Interface java.io.Serializable like", "label": {"api": {"Interface": [[115, 123]]}}}, {"text": "From the javadoc for String.substring(int,int)", "label": {"api": {"String.substring(int,int)": [[21, 45]]}}}, {"text": "Search the modena.css stylesheet for -fx-shape", "label": {"api": {"-fx-shape": [[37, 45]]}}}, {"text": "Inside that selector, place a -fx-shape rule that defines a custom svg path for the shape you wish to use for checks", "label": {"api": {"-fx-shape": [[30, 38]]}}}, {"text": "An easier way to do this would be to split your String into an array using String.split() on a space, then counting the elements", "label": {"api": {"String.split()": [[75, 88]]}}}, {"text": "You can use the AffineTransform class and its method translate to flip the image horizontally", "label": {"api": {"AffineTransform": [[16, 30]]}}}, {"text": "You can do it with a XmlAdapter", "label": {"api": {"XmlAdapter": [[21, 30]]}}}, {"text": "First you create your XmlAdapter, for ex", "label": {"api": {"XmlAdapter": [[22, 31]]}}}, {"text": "Swing Threading Policy states", "label": {"api": {"Swing Threading Policy": [[0, 21]]}}}, {"text": "I wonder if you are looking for something like cyclic barriers", "label": {"api": {"cyclic barriers": [[47, 61]]}}}, {"text": "Use Scanner and Scanner.nextInt() method to take only Integer as input from the user", "label": {"api": {"Scanner": [[4, 10], [16, 22]], "Scanner.nextInt()": [[16, 32]]}}}, {"text": "If the user gives an input which is not an integer, it will throw an InputMismatchException", "label": {"api": {"InputMismatchException": [[69, 90]]}}}, {"text": "That's because you are getting the JSON String from String objJson = writer.toString();", "label": {"api": {"toString()": [[76, 85]]}}}, {"text": "this code will just call the toString() method on the writer instance", "label": {"api": {"toString()": [[29, 38]]}}}, {"text": "Since toString() is not overriden for this object, the result is the default com.google.gson.stream.JsonWriter@6a9454cd", "label": {"api": {"toString()": [[6, 15]]}}}, {"text": "In your case, you are using a ByteArrayOutputStream so you can call toString(charsetName) to get the content as a String", "label": {"api": {"ByteArrayOutputStream": [[30, 50]], "toString(charsetName)": [[68, 88]]}}}, {"text": "As a side note, you could just use a StringWriter instead and get the content with toString()", "label": {"api": {"StringWriter": [[37, 48]], "toString()": [[83, 92]]}}}, {"text": "This link will help with the pattern matching", "label": {"api": {"link": [[5, 8]]}}}, {"text": "In a standalone Java application you can register a shutdown hook which is called when the Java VM is terminated to close the open statements", "label": {"api": {"register a shutdown hook": [[41, 64]]}}}, {"text": "That's what SecurityManager is for", "label": {"api": {"SecurityManager": [[12, 26]]}}}, {"text": "Set the fill for your SnapshotParameters to Color.TRANSPARENT before you take a snapshot", "label": {"api": {"Set the fill": [[0, 11]], "Color.TRANSPARENT": [[44, 60]]}}}, {"text": "You can get the real path from the servlet context", "label": {"api": {"real path": [[16, 24]], "servlet context": [[35, 49]]}}}, {"text": "From there you can use the File APIs to get directory listings of files if you want", "label": {"api": {"File APIs": [[27, 35]]}}}, {"text": "To meet your requirements you have to create a custom log filter that checks the source class name and install it on the root logger", "label": {"api": {"log filter": [[54, 63]], "source class name": [[81, 97]]}}}, {"text": "Also, the level class has a parse method you can use to get rid of that switch statement", "label": {"api": {"parse": [[28, 32]]}}}, {"text": "You have to call next() before you can call remove() to advance the iterator (even though you don't need the element)", "label": {"api": {"remove()": [[44, 51]]}}}, {"text": "remove() will affect the element which has been returned by the call to next()", "label": {"api": {"remove()": [[0, 7]]}}}, {"text": "You are looking for Path.resolve(other)", "label": {"api": {"Path.resolve(other)": [[20, 38]]}}}, {"text": "Quoting Long.toBinaryString(i) Javadoc (emphasis mine)", "label": {"api": {"Long.toBinaryString(i)": [[8, 29]]}}}, {"text": "And quoting Long.parseLong(s, radix) (emphasis mine)", "label": {"api": {"Long.parseLong(s, radix)": [[12, 35]]}}}, {"text": "You should use Long.parseUnsignedLong(s, radix) instead", "label": {"api": {"Long.parseUnsignedLong(s, radix)": [[15, 46]]}}}, {"text": "The getGenericSuperclass method, as its name suggests, returns a Type that represents the superclass of the class, not the class itself", "label": {"api": {"getGenericSuperclass method": [[4, 30]]}}}, {"text": "To get your own class's type parameters, use the getTypeParameters method", "label": {"api": {"the getTypeParameters method": [[45, 72]]}}}, {"text": "Yes, you can get the current score with the method HashTable.get(Object key)", "label": {"api": {"HashTable.get(Object key)": [[51, 75]]}}}, {"text": "Read the API very carefully", "label": {"api": {"API": [[9, 11]]}}}, {"text": "Cipher#update(byte[]) returns a byte[] which you're not using for some reason", "label": {"api": {"Cipher#update(byte[])": [[0, 20]]}}}, {"text": "Just use Cipher#doFinal(byte[])", "label": {"api": {"Cipher#doFinal(byte[])": [[9, 30]]}}}, {"text": "You can use Stream's peek method, which returns the Stream because it's an intermediate operation", "label": {"api": {"Stream's peek method": [[12, 31]]}}}, {"text": "try this http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#contains(java.lang.CharSequence)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#contains(java.lang.CharSequence)": [[9, 103]]}}}, {"text": "Use the methods of java.net.URI to get all you need about the URL", "label": {"api": {"java.net.URI": [[19, 30]]}}}, {"text": "See NoSuchElementException from Java docs", "label": {"api": {"NoSuchElementException": [[4, 25]]}}}, {"text": "Taking a look at the Java Iterator interface may be of some help", "label": {"api": {"Java Iterator interface": [[21, 43]]}}}, {"text": "Remove the line import java.util.logging.Level1; (that doesn't exist, I think you wanted import java.util.logging.Level)", "label": {"api": {"import java.util.logging.Level": [[16, 45], [89, 118]]}}}, {"text": "First, the creation of the anonymous class for DirectoryStream.Filter is replaced with the method reference Files::isDirectory", "label": {"api": {"DirectoryStream.Filter": [[47, 68]]}}}, {"text": "Such a signature conforms with the signature of the only method boolean accept(Path) of the DirectoryStream.Filter interface", "label": {"api": {"boolean accept(Path)": [[64, 83]], "DirectoryStream.Filter": [[92, 113]]}}}, {"text": "Then, the rest of the code uses the new method forEach that was added to Iterable (which DirectoryStream is)", "label": {"api": {"forEach": [[47, 53]], "Iterable": [[73, 80]]}}}, {"text": "This method takes a single parameter that is a Consumer, which can be expressed as a lambda expression taking a single parameter of type Path and returning no result (the argument for this is the same as above)", "label": {"api": {"Consumer": [[47, 54]]}}}, {"text": "I'd set the System.out (via System.setOut) to a ByteArrayOutputStream backed PrintStream and check that", "label": {"api": {"System.setOut": [[28, 40]], "ByteArrayOutputStream": [[48, 68]]}}}, {"text": "The two things I would look at mocking are the Random and the Scanner", "label": {"api": {"Random": [[47, 52]], "Scanner": [[62, 68]]}}}, {"text": "If you mock the System.out (which you could do via System.setOut) you would end up showing that you can write mock verification but little else", "label": {"api": {"System.setOut": [[51, 63]]}}}, {"text": "By instead using ByteArrayOutputStream you can get the output in a significantly simplified way", "label": {"api": {"ByteArrayOutputStream": [[17, 37]]}}}, {"text": "The Random and Scanner are external systems that are much simpler to stub out and will not leave you with quite so brittle code", "label": {"api": {"Random": [[4, 9]], "Scanner": [[15, 21]]}}}, {"text": "At least the Javadocs of Timer#scheduleAtFixedRate suggest what you observed", "label": {"api": {"Timer#scheduleAtFixedRate": [[25, 49]]}}}, {"text": "For more details, you can use the function setConnectTimeout of Class URLConnection (refer to http://docs.oracle.com/javase/1.5.0/docs/api/java/net/URLConnection.html) to resolve it, see the picture and code below", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/net/URLConnection.html": [[94, 165]]}}}, {"text": "You should use a Collections.synchronizedList() insead of your ArrayList", "label": {"api": {"Collections.synchronizedList()": [[17, 46]]}}}, {"text": "You can use a Timer", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "See List.equals(..) and List.hashcode() to see that they do the right thing to enable this", "label": {"api": {"List.equals(..)": [[4, 18]], "List.hashcode()": [[24, 38]]}}}, {"text": "For one-way \"encryption\", use a message digest, also called a Cryptographic hash function", "label": {"api": {"message digest": [[32, 45]]}}}, {"text": "You can take a look at Platform::runLater", "label": {"api": {"Platform::runLater": [[23, 40]]}}}, {"text": "The second one works with every type of (potentially unordered) Iterable, as it doesn't rely on random access, i.e", "label": {"api": {"Iterable": [[64, 71]]}}}, {"text": "Alternately you can use the Java time API", "label": {"api": {"Java time API": [[28, 40]]}}}, {"text": "You can you a DecimalFormat to format the result", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "Here's a solution showing how the original program can be made to wait for all threads to finish by joining them", "label": {"api": {"joining": [[100, 106]]}}}, {"text": "Which means you can't use Object, instead you need to use Comparable", "label": {"api": {"Comparable": [[58, 67]]}}}, {"text": "With Java 8 Streams, it is as simple as", "label": {"api": {"Streams": [[12, 18]]}}}, {"text": "It should work, although when I ran it the numbers of rows inserted each time was returned as -2 (= Statement.SUCCESS_NO_INFO), so you may be better off ignoring these numbers", "label": {"api": {"Statement.SUCCESS_NO_INFO": [[100, 124]]}}}, {"text": "For this task, you can use Collectors.groupingBy(classifier, downstream)", "label": {"api": {"Collectors.groupingBy(classifier, downstream)": [[27, 71]]}}}, {"text": "To shuffle the entire deck, use Collections.shuffle", "label": {"api": {"Collections.shuffle": [[32, 50]]}}}, {"text": "ComboBox supports a cellFactory which allows essentially an arbitrary UI for displaying the item in each cell", "label": {"api": {"cellFactory": [[20, 30]]}}}, {"text": "ChoiceBox does not have this functionality and will only display text in each cell (which you can configure using a converter)", "label": {"api": {"converter": [[116, 124]]}}}, {"text": "The Graphics2D.drawString(str, x, y) Javadoc specifies", "label": {"api": {"Graphics2D.drawString(str, x, y)": [[4, 35]]}}}, {"text": "You can pass string directly to the constructor of BigDecimal", "label": {"api": {"BigDecimal": [[51, 60]]}}}, {"text": "You can draw an image yourself on a Canvas, then turn it into an Image with the snapshot method", "label": {"api": {"Canvas": [[36, 41]], "snapshot": [[80, 87]]}}}, {"text": "With JPA, try em.refresh(entity)", "label": {"api": {"em.refresh(entity)": [[14, 31]]}}}, {"text": "Look into the javadoc of Files.readAllLines", "label": {"api": {"Files.readAllLines": [[25, 42]]}}}, {"text": "You can shuffle the indexList by using the Collections.shuffle method, easy", "label": {"api": {"Collections.shuffle": [[43, 61]]}}}, {"text": "valueOf is a static method that returns the enum instance you're looking for", "label": {"api": {"valueOf": [[0, 6]]}}}, {"text": "When doing bu.valueOf(sc.next()) the result of the call is not stored anywhere, and bu will not change its value after the invocation", "label": {"api": {"valueOf": [[14, 20]]}}}, {"text": "For identifying errors in compilation, instead of running javac using ProcessBuilder a better alternative might be to use Java Compiler API", "label": {"api": {"Java Compiler API": [[122, 138]]}}}, {"text": "When using the JavaMail MimeBodyPart.attachFile method, or using a FileDataSource directly, JavaMail (well, actually JAF) will read the file using a FileInputStream into an 8K buffer, then write out the buffer, reusing the buffer to read the entire file", "label": {"api": {"FileDataSource": [[67, 80]]}}}, {"text": "With Java 8 Collectors.averagingInt, it is as simple as", "label": {"api": {"Collectors.averagingInt": [[12, 34]]}}}, {"text": "I have a couple of predicates that I all want to be satisfied", "label": {"api": {"predicates": [[19, 28]]}}}, {"text": "The things that can satisfy those predicates are a handful of strings", "label": {"api": {"predicates": [[34, 43]]}}}, {"text": "An individual string doesn't have to satisfy all (or any) of those predicates, but after I've looked at the last string, all of the predicates have to be satisified", "label": {"api": {"predicates": [[67, 76], [132, 141]]}}}, {"text": "My first take to represent this problem in Java was to use Stream's allMatch and anyMatch since I want all of the predicates to match any of the things to test", "label": {"api": {"predicates": [[114, 123]], "Stream": [[59, 64]]}}}, {"text": "Your code should be worked fine except for this exception 'ClassNotFoundException' that means that the org.json.JSONObject aren't in the classpath and on the build for project, make sure that you import by maven", "label": {"api": {"ClassNotFoundException": [[59, 80]]}}}, {"text": "Then use Timer.addActionListener() to add the listener", "label": {"api": {"Timer.addActionListener()": [[9, 33]]}}}, {"text": "Retrieve the annotation from the Class object representing Target, and use its value method", "label": {"api": {"value": [[79, 83]]}}}, {"text": "Don't use StringTokenizer", "label": {"api": {"StringTokenizer": [[10, 24]]}}}, {"text": "StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "You could just use String.split() (which is the JDK's suggested alternative), but it's less powerful and has confusing trailing-delimiter handling", "label": {"api": {"String.split()": [[19, 32]]}}}, {"text": "See, in particular, CharBuffer.subSequence", "label": {"api": {"CharBuffer.subSequence": [[20, 41]]}}}, {"text": "If you want to use the Java JCA/JCE then you can simply pass a KeyPair object instance consisting of an RSAPublicKey and RSAPrivateKey or just the public and private key objects themselves", "label": {"api": {"a KeyPair object instance": [[61, 85]]}}}, {"text": "As far as I remember, you should use the method createElementNS(String namespaceURI, String qualifiedName)", "label": {"api": {"createElementNS(String namespaceURI, String qualifiedName)": [[48, 105]]}}}, {"text": "hopefully you can do this by implementing javax.servlet.http.HttpSessionBindingListener interface and register it as a ServletContext listener through java configuration", "label": {"api": {"listener": [[134, 141]]}}}, {"text": "Simply use String.join, no need to create the nested stream", "label": {"api": {"String.join": [[11, 21]]}}}, {"text": "Collections.emptyList() is generic, but you're using it in its raw version", "label": {"api": {"Collections.emptyList()": [[0, 22]]}}}, {"text": "You can inspect your class via the Java Reflection API, there is a class called Constructor (see http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/package-frame.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/package-frame.html": [[97, 173]]}}}, {"text": "There is a subtle gotcha in the String.split(String) method, which is that empty tokens are discarded from the end of the string", "label": {"api": {"String.split(String) method": [[32, 58]]}}}, {"text": "Somewhat similar approach is implemented in Collector.of static method", "label": {"api": {"Collector.of": [[44, 55]]}}}, {"text": "For this matter, you could use String.regionMatches instead of contains", "label": {"api": {"String.regionMatches": [[31, 50]]}}}, {"text": "From what i've gathered, such a timer would be created using a thread object", "label": {"api": {"thread object": [[63, 75]]}}}, {"text": "Here's the docs if for Arrays.sort for more information on the method in the java.util.Arrays class", "label": {"api": {"Arrays.sort": [[23, 33]]}}}, {"text": "You could make your heap accept a Comparator in constructor and then provide a Comparator that reverses the order", "label": {"api": {"Comparator": [[34, 43], [79, 88]]}}}, {"text": "That's what the Comparator is for actually - defining an ordering that's not a natural one for the given class, being able to define multiple orderings of the same class, or indeed defining an ordering for a class you cannot modify", "label": {"api": {"Comparator": [[16, 25]]}}}, {"text": "The approach of accepting a comparator at construction time can be seen in TreeSet for example", "label": {"api": {"TreeSet": [[75, 81]]}}}, {"text": "This way you don't need wrappers as Map.forEach already accepts BiConsumer and Collectors.toMap second parameter essentially replaces your tupledResult", "label": {"api": {"Map.forEach": [[36, 46]], "Collectors.toMap": [[79, 94]]}}}, {"text": "It uses a regex http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html to check if the string is a positive or negative integer", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html": [[16, 84]]}}}, {"text": "If you have a different amount of Rows, and you can't excatly say how much rows it will be you should use ArrayList instead of an array with an fixed size", "label": {"api": {"ArrayList": [[106, 114]]}}}, {"text": "To an ArrayList you can add as muchs values as you want", "label": {"api": {"ArrayList": [[6, 14]]}}}, {"text": "However to answer your question, you can look up what each field with getDeclaredField", "label": {"api": {"getDeclaredField": [[70, 85]]}}}, {"text": "As such, it can be represented as a Predicate (because the Predicate interface has a single functional method with this exact signature, called test)", "label": {"api": {"Predicate": [[36, 44], [59, 67]], "test": [[144, 147]]}}}, {"text": "The type of p will be determined by the type of the Predicate you are creating", "label": {"api": {"Predicate": [[52, 60]]}}}, {"text": "If you're using JDBC4 drivers and pools (you should be), just use the unwrap(...) method from the Wrapper interface implemented by Connection, e.g", "label": {"api": {"just use the unwrap(...) method": [[57, 87]]}}}, {"text": "In addition to standard Jackson annotations and optional JAXB annotations (javax.xml.bind.annotation), Jackson provides some XML-specific annotations", "label": {"api": {"JAXB annotations": [[57, 72]], "javax.xml.bind.annotation": [[75, 99]]}}}, {"text": "So you have a java.lang.Long, which can be null, and turn it into an Option[scala.Long] which is None if the java.lang.Long is null", "label": {"api": {"java.lang.Long": [[14, 27], [109, 122]]}}}, {"text": "Perhaps the Scanner class would be more appropriate", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "I am writing some code to figure out metadata about classes implemented with JAX-RS and I'm writing a method that takes a Method and returns the HTTP Verb related to that method, basically figure out if it's annotated with @POST, @GET, @PUT or @DELETE", "label": {"api": {"Method": [[122, 127]]}}}, {"text": "It works fine, but I figured out that all those annotations are annotated with @HttpMethod and have a value with it's name as a String", "label": {"api": {"Method": [[84, 89]]}}}, {"text": "Is there a way for me to figure out from my reference of Method if it's annotated by an annotation which in turn is annotated with another specific annotation", "label": {"api": {"Method": [[57, 62]]}}}, {"text": "You are writing the totalBets value using BufferedWriter.write(int)", "label": {"api": {"BufferedWriter.write(int)": [[42, 66]]}}}, {"text": "While doing some functional programming in Java 8, I needed a tuple like in any functional programming languages, but then I figured out that  the language designer might be solving the need for Tuple by making the Bifunction", "label": {"api": {"Bifunction": [[215, 224]]}}}, {"text": "If you need a function that's taking 2 parameters you have to use Bifunction not Function, but I could not find any Documentation about this, is Java 8 really missing Tuples, or Bifunction can replace it's use", "label": {"api": {"Bifunction": [[66, 75], [178, 187]]}}}, {"text": "this question not as \"Does Java SE 8 have Pairs or Tuples?\" as the majority here is Bifunction which is not mentioned in the other question, I think question title now is more descriptive", "label": {"api": {"Bifunction": [[84, 93]]}}}, {"text": "It's best to create a java.util.Random object, so you can call nextInt(4) to get the range you need", "label": {"api": {"nextInt(4)": [[63, 72]]}}}, {"text": "You can also append the text", "label": {"api": {"append": [[13, 18]]}}}, {"text": "Just use Arrays.toString(double[]) instead", "label": {"api": {"Arrays.toString(double[])": [[9, 33]]}}}, {"text": "This mechanism is described in more detail in the JavaDocs for java.net.URL", "label": {"api": {"the JavaDocs for java.net.URL": [[46, 74]]}}}, {"text": "You can convert the Double to its long counterpart by calling longValue", "label": {"api": {"longValue": [[62, 70]]}}}, {"text": "You can also remove intermediate array using Pattern.splitAsStream", "label": {"api": {"Pattern.splitAsStream": [[45, 65]]}}}, {"text": "One of the ways to create the string of repeating symbols is to use Arrays.fill", "label": {"api": {"Arrays.fill": [[68, 78]]}}}, {"text": "Because executeUpdate method returns int .This int value shows how much rows are affected by your sql statement", "label": {"api": {"executeUpdate": [[8, 20]]}}}, {"text": "You could then sort them according to the index of that code by implementing your own Comparator, and then put it all together with Java 8's streaming APIs", "label": {"api": {"Comparator": [[86, 95]]}}}, {"text": "As aioobe commented, this can be done much more elegantly with Comparator.comparing", "label": {"api": {"Comparator": [[63, 72]]}}}, {"text": "Have you read SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[14, 29]]}}}, {"text": "If you want to add more flexibility in how your items are represented visually, you could use a cellFactory instead to create custom ListCells (there is an example in the javadoc linked)", "label": {"api": {"cellFactory": [[96, 106]]}}}, {"text": "I've found somthing about blobs in ResultSet's javadocs, but I'm not sure if this applies to the getBinaryStream method", "label": {"api": {"ResultSet's javadocs": [[35, 54]]}}}, {"text": "And by the way, there is the method String#matches(String regex) which does pretty much what your function isStringContainsReg does..", "label": {"api": {"String#matches(String regex)": [[36, 63]]}}}, {"text": "First, you want to compare the String by their length (using String.length()) and then lexicographically (this is exactly what's done by default with String.compareTo(other))", "label": {"api": {"String.length()": [[61, 75]], "String.compareTo(other)": [[150, 172]]}}}, {"text": "I am aware that Files.list(Path) uses Files.newDirectoryStream(Path) internally and basically just wraps the DirectoryStream", "label": {"api": {"Files.list(Path)": [[16, 31]], "Files.newDirectoryStream(Path)": [[38, 67]]}}}, {"text": "As would either synchronized blocks or Semaphores", "label": {"api": {"Semaphore": [[39, 47]]}}}, {"text": "The JOptionPane does not accept so many parameters", "label": {"api": {"JOptionPane": [[4, 14]]}}}, {"text": "Use another constructor to have the autoflush mode set (see Javadoc)", "label": {"api": {"see Javadoc": [[56, 66]]}}}, {"text": "Finally, put wait() call in the loop checking the loop condition as official documentation recommends", "label": {"api": {"recommends": [[91, 100]]}}}, {"text": "Instead of that you should use the equals-function of String", "label": {"api": {"equals-function": [[35, 49]]}}}, {"text": "Actually the Session.SESSION_TRANSACTED is right in the API docs for JMS Session", "label": {"api": {"Session": [[13, 19], [73, 79]]}}}, {"text": "Here is an little tutorial about enums", "label": {"api": {"enums": [[33, 37]]}}}, {"text": "You may need to map the path to your application using ServletContext.getRealPath() in order to get to the application's local folders", "label": {"api": {"ServletContext": [[55, 68]]}}}, {"text": "See the ServletContext documentation page for more info", "label": {"api": {"ServletContext": [[8, 21]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "You can add multiple handlers to a Logger", "label": {"api": {"add multiple handlers to a Logger": [[8, 40]]}}}, {"text": "Beginning with Java 8, I like to use ConcurrentHashMap#computeIfAbsent to achieve laziness", "label": {"api": {"ConcurrentHashMap#computeIfAbsent": [[37, 69]]}}}, {"text": "Since Java 1.6, the File class has a getFreeSpace method", "label": {"api": {"File": [[20, 23]]}}}, {"text": "They aren't threads themselves, but executed on a worker thread", "label": {"api": {"worker thread": [[50, 62]]}}}, {"text": "ToggleButton has a selectedProperty, so it is directly implementing the selection functionality", "label": {"api": {"ToggleButton": [[0, 11]]}}}, {"text": "However, ListView has a selectionModelProperty, so the selection modeling capability of the ListView is delegated to an associated class, rather than directly implemented in the ListView itself", "label": {"api": {"selectionModelProperty": [[24, 45]]}}}, {"text": "Java's AtomicInteger offers public final boolean compareAndSet(int expect, int update)", "label": {"api": {"public final boolean compareAndSet(int expect, int update)": [[28, 85]]}}}, {"text": "You don't need to use pattern and matcher here, just plain String#replaceAll method, read about it at the javadocs, as", "label": {"api": {"at the javadocs": [[99, 113]]}}}, {"text": "In Java 8 you can use @FunctionalInterface annotation on interfaces with a single abstract method", "label": {"api": {"@FunctionalInterface": [[22, 41]]}}}, {"text": "What you're looking for is javax.crypto.CipherInputStream", "label": {"api": {"javax.crypto.CipherInputStream": [[27, 56]]}}}, {"text": "Use a ByteArrayOutputStream instead of a FileOutputStream when decrypting", "label": {"api": {"ByteArrayOutputStream": [[6, 26]]}}}, {"text": "If you need to re-encrypt the data when your finished you'd use a ByteArrayInputStream to encrypt", "label": {"api": {"ByteArrayInputStream": [[66, 85]]}}}, {"text": "The only drawback I see is that getting the buffer from the ByteArrayOutputStream is apparently a copy operation", "label": {"api": {"ByteArrayOutputStream": [[60, 80]]}}}, {"text": "As an alternative if you are using java 1.8 then you could create a StringJoiner and split the String by -", "label": {"api": {"StringJoiner": [[68, 79]]}}}, {"text": "JDK doc for ArrayList constructor says that the initial capacity is 10", "label": {"api": {"ArrayList constructor": [[12, 32]]}}}, {"text": "To avvoid sleep i tend to use the class CountDownLatch to wait for invokations", "label": {"api": {"CountDownLatch": [[40, 53]]}}}, {"text": "If you wish to have this behaviour, you could use the Math.addExact(long x, long y) method from Java 8", "label": {"api": {"Math.addExact(long x, long y)": [[54, 82]]}}}, {"text": "I take it you are getting your ExecutorService via Executors.newSingleThreadExecutor()", "label": {"api": {"Executors.newSingleThreadExecutor()": [[51, 85]]}}}, {"text": "You can create with bounded queues if you wished, or with a queue that did not use FIFO (such as PriorityBlockingQueue", "label": {"api": {"PriorityBlockingQueue": [[97, 117]]}}}, {"text": "The documentation for ThreadPoolExecutor gives a good overview of your different options", "label": {"api": {"ThreadPoolExecutor": [[22, 39]]}}}, {"text": "getCookies, frees you from parsing the Cookie header string, and creating a java object out of it", "label": {"api": {"getCookies": [[0, 9]]}}}, {"text": "Be sure to pass true to cancel() so that it sends the interrupt", "label": {"api": {"cancel()": [[24, 31]]}}}, {"text": "You should be using String(byte[] bytes, int offset, int length, Charset charset)", "label": {"api": {"String(byte[] bytes, int offset, int length, Charset charset)": [[20, 80]]}}}, {"text": "This method seems to be the closest counterpart", "label": {"api": {"This method": [[0, 10]]}}}, {"text": "After some research, I found that there's a TreeWillExpandListener for swing", "label": {"api": {"TreeWillExpandListener": [[44, 65]]}}}, {"text": "You'll either need to do this before you add it to the model, or maybe look at Integer.toHexString() which will allow you to format your number as if it were unsigned", "label": {"api": {"Integer.toHexString()": [[79, 99]]}}}, {"text": "The Collection interface was introduced in Java 1.2 with the Collections API", "label": {"api": {"Collection interface": [[4, 23]]}}}, {"text": "However, the Iterable interface wasn't introduced until Java 1.5", "label": {"api": {"Iterable interface": [[13, 30]]}}}, {"text": "You might also take a look at the ScheduledExecutorService Interface", "label": {"api": {"ScheduledExecutorService ": [[34, 58]]}}}, {"text": "But i think the PrintWriter is the wrong choice for the output here", "label": {"api": {"PrintWriter": [[16, 26]]}}}, {"text": "I recommend using FileWriter", "label": {"api": {"FileWriter": [[18, 27]]}}}, {"text": "According to the documentations PrintWriter is used to print formatted representations of objects to a text-output stream, whereas you're using strings as parameters for the output", "label": {"api": {"PrintWriter": [[32, 42]]}}}, {"text": "So i believe FileWriter would be the more appropriate choice", "label": {"api": {"FileWriter": [[13, 22]]}}}, {"text": "Java provides a java.util.Timer class that is designed to execute a task on a background thread", "label": {"api": {"java.util.Timer": [[16, 30]]}}}, {"text": "Java 5 added a java.util.concurrent.ScheduledThreadPoolExecutor class that is more flexible than Timer, but also offers fixed-delay and fixed-rate execution methods", "label": {"api": {"java.util.concurrent.ScheduledThreadPoolExecutor": [[15, 62]]}}}, {"text": "The method String.replace(char,char) replaces all the occurrences of the given character with the new character", "label": {"api": {"String.replace(char,char)": [[11, 35]]}}}, {"text": "It looks like ImageIcon has a constructor that takes an Image, so you should be able to pass the BufferedImage into that constructor", "label": {"api": {"constructor": [[30, 40], [121, 131]]}}}, {"text": "If the latency is really problematic you can disable Nagle's algorithm with the TCP_NODELAY socket option", "label": {"api": {"TCP_NODELAY": [[80, 90]]}}}, {"text": "For most cases, it is generally preferable to just use one of the collection implementations found in java.util.concurrent, which implement iterators that are thread-safe and would not throw a ConcurrentModificationException from operations from a different thread", "label": {"api": {"java.util.concurrent": [[102, 121]]}}}, {"text": "If you have a final reference to a mutable object, consider a thread-safe collection", "label": {"api": {"thread-safe collection": [[62, 83]]}}}, {"text": "Additionally, the class ThreadReference has a method popFrames which allows you to remove frames from the stack", "label": {"api": {"ThreadReference": [[24, 38]]}}}, {"text": "In Java, you can move elements around an array using System.arraycopy, no loop necessary", "label": {"api": {"System.arraycopy": [[53, 68]]}}}, {"text": "You can use LocalTime in java.time built into Java 8 and later (Tutorial), or LocalTime from Joda-Time otherwise", "label": {"api": {"LocalTime": [[12, 20], [78, 86]], "java.time": [[25, 33]]}}}, {"text": "The documentation for ResultSet states \"columnIndex - the first column is 1, the second is 2, …\"", "label": {"api": {"documentation for ResultSet": [[4, 30]]}}}, {"text": "If you are using Java 8, a very clean solution is using the new StringJoiner class", "label": {"api": {"StringJoiner": [[64, 75]]}}}, {"text": "The overload of the StreamSource constructor taking a String (https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/stream/StreamSource.html#StreamSource-java.lang.String-) expects a String with a URI while you seem to pass in a String with some XML constructed on the fly", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/stream/StreamSource.html#StreamSource-java.lang.String-": [[62, 178]]}}}, {"text": "Just use Arrays.toString(array)", "label": {"api": {"Arrays.toString(array)": [[9, 30]]}}}, {"text": "You can use the indexOf(...) method for search in ArrayList", "label": {"api": {"indexOf(...)": [[16, 27]]}}}, {"text": "Read the javadoc of @Column to understand what else you can define there", "label": {"api": {"@Column": [[20, 26]]}}}, {"text": "toMap(keyMapper, valueMapper, mergeFunction)", "label": {"api": {"toMap(keyMapper, valueMapper, mergeFunction)": [[0, 43]]}}}, {"text": "toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)", "label": {"api": {"toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)": [[0, 56]]}}}, {"text": "In this case, and to be consistent with what the JDK currently does, I've chosen SomeException to be IllegalStateException", "label": {"api": {"IllegalStateException": [[101, 121]]}}}, {"text": "The constructor you're using to build your strings is the byte[] constructor for the String type, which I think is doing something other than what you're expecting", "label": {"api": {"byte[] constructor": [[58, 75]]}}}, {"text": "If you are on Java 7 or earlier, you could use the overloaded stop(Throwable obj) method to throw something besides a ThreadDeath error", "label": {"api": {"stop(Throwable obj)": [[62, 80]]}}}, {"text": "The TimerTask class has a method called cancel() which you can call to cancel a pending timer", "label": {"api": {"cancel()": [[40, 47]]}}}, {"text": "In your code, you will probably need to modify your timer() function to return a reference to the newly created TimerTask object, so that you can later call cancel()", "label": {"api": {"cancel()": [[157, 164]]}}}, {"text": "Under Google App Engine any object that you want to store in a HttpSession has to implement Serializable, and all of its fields have to be serializable, because an instance running in GAE might be migrated from one JVM to another", "label": {"api": {"HttpSession": [[63, 73]]}}}, {"text": "This means that if I want to store a FooBar instance into an HttpSession I can't have a field in it pointing back to the HttpSession", "label": {"api": {"HttpSession": [[61, 71], [121, 131]]}}}, {"text": "According to this blog post you can use the ID to get the DataStore entity representing the HttpSession, but I want a reference to the Java object, not the underlying data being used to migrate it between JVMs", "label": {"api": {"HttpSession": [[92, 102]]}}}, {"text": "Instead, it seems that what you want is a many-to-one foreign-key relationship (or perhaps just a one-to-one, if field2 can only be associated with one A)", "label": {"api": {"many-to-one foreign-key relationship": [[42, 77]]}}}, {"text": "See ConstraintViolation#getPropertyPath method", "label": {"api": {"ConstraintViolation#getPropertyPath": [[4, 38]]}}}, {"text": "You could use the orFilter method", "label": {"api": {"orFilter": [[18, 25]]}}}, {"text": "But it seems that regexFilter can already accomodate multiple columns (I think just one of those needs to match, so that should have the same result here)", "label": {"api": {"regexFilter": [[18, 28]]}}}, {"text": "From the Java spec (the language spec refers to Double.valueOf)", "label": {"api": {"Java spec": [[9, 17]]}}}, {"text": "Implement https://docs.oracle.com/javaee/6/api/javax/ws/rs/ext/ExceptionMapper.html and put the annotation @Provider to that", "label": {"api": {"https://docs.oracle.com/javaee/6/api/javax/ws/rs/ext/ExceptionMapper.html": [[10, 82]]}}}, {"text": "The java.nio.ByteBuffer class has methods that allow you to read and write standard data types to or from a byte array", "label": {"api": {"java.nio.ByteBuffer": [[4, 22]]}}}, {"text": "Java™ Platform, Standard Edition 8 API Specification", "label": {"api": {"Java™ Platform, Standard Edition 8 API Specification": [[0, 51]]}}}, {"text": "In Java 8 you can use any functional interface, i.e", "label": {"api": {"functional interface": [[26, 45]]}}}, {"text": "There are quite a few such interfaces in the java.util.function package, for single-argument and two-argument functions; in particular for functions which take and return int you should use IntUnaryOperator, already mentioned in other people's comments", "label": {"api": {"java.util.function": [[45, 62]], "IntUnaryOperator": [[190, 205]]}}}, {"text": "However there is an issue with the use of Math.atan (which return a value within the [-pi/2,pi/2], instead of the whole [-pi,pi] range) in Complex's add and sub", "label": {"api": {"Math.atan": [[42, 50]]}}}, {"text": "The Map class takes 2 classes at it's template which can be anything, as long as they match some perquisites", "label": {"api": {"perquisites": [[97, 107]]}}}, {"text": "On the official documentation, it is mentioned that .nextDouble() throws a InputMismatchException when the next token (user input) does not match a float (such as when the user inputs a letter)", "label": {"api": {"official documentation": [[7, 28]]}}}, {"text": "The most efficient way is to try to get Enum by name and catch the exception, using Enum.valueOf(String) method", "label": {"api": {"Enum.valueOf(String)": [[84, 103]]}}}, {"text": "You can use Map.get to get the existing value, then add add to it, and put it back", "label": {"api": {"Map.get": [[12, 18]]}}}, {"text": "You can shorten this, because Map.get and derivatives return null if the key is unknown", "label": {"api": {"Map.get": [[30, 36]]}}}, {"text": "The PriorityQueues usually accept a Comparator in order to determine how to sort the values inside", "label": {"api": {"Comparator": [[36, 45]]}}}, {"text": "If you don't provide one, then Java uses the default comparison method", "label": {"api": {"default comparison method": [[45, 69]]}}}, {"text": "If I undertand your problem correctly, you can just join the submitted task", "label": {"api": {"join": [[52, 55]]}}}, {"text": "Then create ExecutorService by calling one of the methods from  Executors factory like newCachedThreadPool", "label": {"api": {"Executors": [[64, 72]]}}}, {"text": "You are right in saying that if they are arrays you can't use Arrays.equals(), if they are List<>s then you cannot just use equals", "label": {"api": {"equals": [[69, 74], [124, 129]]}}}, {"text": "If you don't need to check for duplicates you could drop both lists into a HashSet using addAll and then compare the two HashSet or just use List.containsAll", "label": {"api": {"List.containsAll": [[141, 156]]}}}, {"text": "I suggest throwing a ClosedByInterruptException", "label": {"api": {"ClosedByInterruptException": [[21, 46]]}}}, {"text": "Although it belongs to the NIO library, it has a better defined API than the old InterruptedIOException, making it easier to handle", "label": {"api": {"InterruptedIOException": [[81, 102]]}}}, {"text": "See also Thread#interrupt()", "label": {"api": {"Thread#interrupt()": [[9, 26]]}}}, {"text": "The interrupt status is left clear in this case, as the API for InterruptedException suggests", "label": {"api": {"InterruptedException": [[64, 83]]}}}, {"text": "The javax.tools.* API would be a good entrance point to get started; however, there are also a number of (open source) source code parsers for Java out there", "label": {"api": {"javax.tools.*": [[4, 16]]}}}, {"text": "When you cast a long greater than Integer.MAX_VALUE to an integer you get an overflow and the value can turn negative", "label": {"api": {"Integer.MAX_VALUE": [[34, 50]]}}}, {"text": "Quoting afterExecute Javadoc", "label": {"api": {"afterExecute": [[8, 19]]}}}, {"text": "Since SQLException is a checked exception, it won't be passed to afterExecute", "label": {"api": {"afterExecute": [[65, 76]]}}}, {"text": "Even in you change your code to throw a RuntimeException, if won't be given to afterExecute", "label": {"api": {"afterExecute": [[79, 90]]}}}, {"text": "Use a collection class like ArrayList instead", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "You can use the Random class", "label": {"api": {"Random": [[16, 21]]}}}, {"text": "It has methods such as Random.nextInt where you can give it an upper bound and it will give you a random number between 0 (inclusive) and that number (exclusive)", "label": {"api": {"Random": [[23, 28]]}}}, {"text": "There are also other methods like Random.nextBoolean which returns 50% chance of true or false", "label": {"api": {"Random": [[34, 39]]}}}, {"text": "This can be done with the ProcessBuilder and Process classes in Java 8", "label": {"api": {"ProcessBuilder": [[26, 39]], "Process": [[26, 32], [45, 51]]}}}, {"text": "javax.media.jai.PerspectiveTransform from Java Advanced Imaging, for example", "label": {"api": {"javax.media.jai.PerspectiveTransform": [[0, 35]]}}}, {"text": "javafx.scene.effect.PerspectiveTransform  in a javafx.embed.swing.JFXPanel, part of javafx", "label": {"api": {"javafx.scene.effect.PerspectiveTransform": [[0, 39]], "javafx.embed.swing.JFXPanel": [[47, 73]]}}}, {"text": "Java 8 allows multiple annotations of the same type on same element with the help of @Repeatable annotation", "label": {"api": {"@Repeatable": [[85, 95]]}}}, {"text": "They should probably make boolean parameter for @Repeatable to treat singlecase annotations in the same way", "label": {"api": {"@Repeatable": [[48, 58]]}}}, {"text": "You can use Class::getAnnotationsByType in both cases", "label": {"api": {"Class::getAnnotationsByType": [[12, 38]]}}}, {"text": "It sounds like you're looking for peek", "label": {"api": {"peek": [[34, 37]]}}}, {"text": "To your direct question, use System.nanoTime() for more granular timestamps", "label": {"api": {"System.nanoTime()": [[29, 45]]}}}, {"text": "You could, if you really wanted, use Collections.checkedMap to wrap the map and enforce the type-safety at runtime", "label": {"api": {"Collections.checkedMap": [[37, 58]]}}}, {"text": "16) or, if you don't know how many buttons you'll have, then you'll want to store the data in a List<Character> and add the randomly generated characters into it so that they can be recalled later", "label": {"api": {"add": [[116, 118]]}}}, {"text": "To pick a random card, you can use Random#nextInt(int)", "label": {"api": {"Random#nextInt(int)": [[35, 53]]}}}, {"text": "These are two different classes that have the same name, in Java SDK Context is a name-object binding interface, and in Android Context is an abstract class that provides global information about the application environment", "label": {"api": {"Context": [[69, 75], [128, 134]]}}}, {"text": "In your case IllegalStateException suits best", "label": {"api": {"IllegalStateException": [[13, 33]]}}}, {"text": "Also note that it's better to check the passed string for null (I added Objects.requireNonNull for this)", "label": {"api": {"Objects.requireNonNull": [[72, 93]]}}}, {"text": "Use URLEncoder to do so", "label": {"api": {"URLEncoder": [[4, 13]]}}}, {"text": "You can check the existence of a class using Class.forName like this", "label": {"api": {"Class.forName": [[45, 57]]}}}, {"text": "If you really need to have the IEEEremainder method in GWT, implement it like that", "label": {"api": {"IEEEremainder": [[31, 43]]}}}, {"text": "If you try with this, you will see that withCallable will compile fine but that withSupplier does not compile; even if the lambda expression is compatible with the signature of both functional interfaces", "label": {"api": {"Callable": [[44, 51]]}}}, {"text": "The reason behind this is that the functional method of the Callable interface, which is call(), declares throws Exception in its signature", "label": {"api": {"Callable": [[60, 67]], "call()": [[89, 94]]}}}, {"text": "Supplier.get() does not", "label": {"api": {"Supplier.get()": [[0, 13]]}}}, {"text": "If you are using Java 8, you can use String.join String.join", "label": {"api": {"String.join": [[37, 47], [49, 59]]}}}, {"text": "If your file has fixed-length regions, you should use readfully(byte[]) using an appropriately-sized byte array, and then convert the byte array to a string using new String(bytes, StandardCharsets.UTF_8)", "label": {"api": {"readfully(byte[])": [[54, 70]]}}}, {"text": "Build your command without the < myJOB_Config.xml, then use ProcessBuilder.redirectInput(File)", "label": {"api": {"ProcessBuilder.redirectInput(File)": [[60, 93]]}}}, {"text": "Try checking the size of the queue or use the bounded version", "label": {"api": {"bounded version": [[46, 60]]}}}, {"text": "javax.swing.JTextArea is an old Swing component, while java.awt.TextArea is an even older AWT component (AWT stands for \"Abstract Windows Toolkit\" - some history here)", "label": {"api": {"AWT": [[90, 92], [105, 107]]}}}, {"text": "Use append() (link) or move textArea.setText(texts); below the while loop", "label": {"api": {"link": [[14, 17]]}}}, {"text": "The TestDataGenerator class defined above is annotated with @Singleton (ensuring there will be only one instance of the class) and @Startup (for eager initialization during the application startup sequence)", "label": {"api": {"@Singleton": [[60, 69]], "@Startup": [[131, 138]]}}}, {"text": "The @ArquillianResource annotation allows you to inject the URL to test your web application", "label": {"api": {"URL": [[60, 62]]}}}, {"text": "As of Java 8 there's also java.util.Base64, if you're not using Guava", "label": {"api": {"java.util.Base64": [[26, 41]]}}}, {"text": "See encode(byte[]) and wrap(OutputStream)", "label": {"api": {"encode(byte[])": [[4, 17]], "wrap(OutputStream)": [[23, 40]]}}}, {"text": "Each time you invoke pack(), the enclosing Window will be \"sized to fit the preferred size and layouts of its subcomponents.\" Override getPreferredScrollableViewportSize() and return a suitable multiple of the row height", "label": {"api": {"pack()": [[21, 26]]}}}, {"text": "When you add a new row, invoke pack(), and the enclosing Window will adopt the new size", "label": {"api": {"pack()": [[31, 36]]}}}, {"text": "The method to override in Object takes no parameters", "label": {"api": {"method to override in Object takes no parameters": [[4, 51]]}}}, {"text": "According to the fillRect definition, the second parameter is the location of the top of the box", "label": {"api": {"fillRect definition": [[17, 35]]}}}, {"text": "If you are using just a plain FileWriter or FileOutputStream, this may slow down your processing", "label": {"api": {"FileWriter": [[30, 39]], "FileOutputStream": [[44, 59]]}}}, {"text": "Therefore I would recommend to use a buffer to speed up the slower I/O by writing larger chunks but less often with either BufferedOutputStream or BufferedWriter wrapping your FileWriter or FileOutputStream", "label": {"api": {"FileWriter": [[176, 185]], "FileOutputStream": [[190, 205]], "BufferedOutputStream": [[123, 142]], "BufferedWriter": [[147, 160]]}}}, {"text": "useDelimiter returns this Scanner so you can use it to chain invocation", "label": {"api": {"useDelimiter": [[0, 11]]}}}, {"text": "Take for example the Scanner#ioException method", "label": {"api": {"Scanner#ioException": [[21, 39]]}}}, {"text": "For example the HashMap#get", "label": {"api": {"HashMap#get": [[16, 26]]}}}, {"text": "one way is to use a Timer (http://docs.oracle.com/javase/7/docs/api/java/util/Timer.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Timer.html": [[27, 87]]}}}, {"text": "You can set a ColorAdjust effect on the GraphicsContext object with setEffect(Effect)", "label": {"api": {"setEffect(Effect)": [[68, 84]]}}}, {"text": "String has a constructor that takes an array of char, a start and count", "label": {"api": {"String has a constructor": [[0, 23]]}}}, {"text": "Is it considered a good or bad practice to store constant enum values in the ServletContext via setAttribute", "label": {"api": {"ServletContext via setAttribute": [[77, 107]]}}}, {"text": "First the Java documentation for Character.isWhitespace seems to exclude it", "label": {"api": {"the Java documentation for Character.isWhitespace": [[6, 54]]}}}, {"text": "If you call equals on a custom class, you should implement it (aswell as hashCode)", "label": {"api": {"equals": [[12, 17]], "hashCode": [[73, 80]]}}}, {"text": "You can use TextFlow for that", "label": {"api": {"TextFlow": [[12, 19]]}}}, {"text": "You could like the object to be monitored in the thread using a WeakReference", "label": {"api": {"WeakReference": [[64, 76]]}}}, {"text": "If security is important, you need to provide the class filter", "label": {"api": {"class filter": [[50, 61]]}}}, {"text": "The example on class filter can be found here", "label": {"api": {"class filter": [[15, 26]]}}}, {"text": "You can use the regular expression (?<=value\\=\")(?:[^\"\\\\<]|\\\\\"|\\\\\\\\)++(?=\") in combination with Matcher#find() to find all values of the XML attribute value", "label": {"api": {"Matcher#find()": [[96, 109]]}}}, {"text": "Add the WebView to a StackPane, which \"will attempt to resize each child to fill its content area.\" Resize the frame to see how the StackPane reflows the WebView content based on the default Pos.CENTER", "label": {"api": {"StackPane": [[21, 29], [132, 140]]}}}, {"text": "Well, there is the method Class.isInstance..", "label": {"api": {"Class.isInstance": [[26, 41]]}}}, {"text": "If you need to specify chunks, you could use a ForkJoinPool as described here", "label": {"api": {"ForkJoinPool": [[47, 58]]}}}, {"text": "You could also have a functional interface as an argument", "label": {"api": {"functional interface": [[22, 41]]}}}, {"text": "Depending on your needs, the ForkJoinPool#submit() returns an instance of ForkJoinTask, which is a Future and you may use it to check for the status or wait for the end of your task", "label": {"api": {"ForkJoinPool": [[29, 40]], "Future": [[99, 104]]}}}, {"text": "You'd most probably want the ForkJoinPool instantiated only once (not instantiate it on every method call) and then reuse it to prevent CPU choking if the method is called multiple times", "label": {"api": {"ForkJoinPool": [[29, 40]]}}}, {"text": "See Java - String - startsWith for more information", "label": {"api": {"Java - String - startsWith": [[4, 29]]}}}, {"text": "All I can suggest is for future reference is that you setLenient(false) then the SimpleDateFormat will throw an appropriate ParseException when it encounters something like this", "label": {"api": {"setLenient(false)": [[54, 70]]}}}, {"text": "I would use a JSpinner configured with a JSpinnerNumberModel", "label": {"api": {"JSpinner": [[14, 21], [41, 48]], "JSpinnerNumberModel": [[41, 59]]}}}, {"text": "You can use a Phaser here nicely", "label": {"api": {"Phaser": [[14, 19]]}}}, {"text": "It's like a CyclicBarrier that supports a dynamic number of waiting parties for all threads arriving at a phase", "label": {"api": {"CyclicBarrier": [[12, 24]]}}}, {"text": "Consequently you might want to check out the tutorials for examples and Pattern for references to all the various patterns", "label": {"api": {"Pattern": [[72, 78]]}}}, {"text": "A LinkedBlockingQueue can be bounded, which is one of your criteria", "label": {"api": {"LinkedBlockingQueue": [[2, 20]]}}}, {"text": "using invokedynamic instructions), you can use a MethodHandle", "label": {"api": {"MethodHandle": [[49, 60]]}}}, {"text": "In this code, first a MethodHandles.Lookup object is retrieved", "label": {"api": {"MethodHandles.Lookup": [[22, 41]], "MethodHandle": [[22, 33]]}}}, {"text": "This class is reponsible for creating MethodHandle objects", "label": {"api": {"MethodHandle": [[38, 49]]}}}, {"text": "Then a MethodType object, which represents the arguments and return type accepted and returned by a method handle is created", "label": {"api": {"MethodType": [[7, 16]]}}}, {"text": "You can refer to this question  (and this one) for more information about what MethodHandles are", "label": {"api": {"MethodHandle": [[79, 90]]}}}, {"text": "Also, the API documentation of LambdaMetafactory is quite exhaustive", "label": {"api": {"API documentation of LambdaMetafactory": [[10, 47]]}}}, {"text": "It's absolutely legit to return null from trySplit() saying that \"I refuse to split\"", "label": {"api": {"absolutely legit": [[5, 20]]}}}, {"text": "However in general you may provide at least a limited parallelism extending the AbstractSpliterator class", "label": {"api": {"AbstractSpliterator": [[80, 98]]}}}, {"text": "Finally, the error in the first version (using \"[+-]?\\\\d+.*?\") stems from how you use Scanner's hasNext(String pattern) method, which is a comparison to the next token", "label": {"api": {"hasNext(String pattern)": [[96, 118]]}}}, {"text": "I recommend you to implement a custom data model using AbstractTableModel, then inside the method getValueAt(int row, int col) use NumberFormat as follows", "label": {"api": {"AbstractTableModel": [[55, 72]], "getValueAt(int row, int col)": [[98, 125]], "NumberFormat": [[131, 142]]}}}, {"text": "Java offers shutdown hooks via the Runtime class that are triggered on an application's termination but which must not perform long-lasting operations", "label": {"api": {"Runtime": [[35, 41]]}}}, {"text": "It's not clearly spelled out, but the Javadoc for the keyPress method is phrased in terms of \"keycodes\", which normally means that it's mapping to a specific physical key on the keyboard, which the operating system then interprets as some key event (such as \"hyphen\" or \"double S\")", "label": {"api": {"the Javadoc for the keyPress method": [[34, 68]]}}}, {"text": "Best solution for multi-threading issues are to use SwingWorker", "label": {"api": {"SwingWorker": [[52, 62]]}}}, {"text": "For AWT and Swing, you can get the appropriate size for a window by using the class GraphicsEnvironment", "label": {"api": {"GraphicsEnvironment": [[84, 102]]}}}, {"text": "Although a machine may have many graphics environments, you get access to the screen by calling the static method getLocalGraphicsEnvironment", "label": {"api": {"GraphicsEnvironment": [[122, 140]]}}}, {"text": "And it also takes the menu bar into account, which Toolkit.getScreenSize doesn't", "label": {"api": {"Screen": [[62, 67]]}}}, {"text": "For JavaFX, you can use the Screen class", "label": {"api": {"Screen": [[28, 33]]}}}, {"text": "newInstance takes variable arguments", "label": {"api": {"newInstance": [[0, 10]]}}}, {"text": "You need to call ProcessBuilder.inheritIO(), since you're not interested in capturing the output in the Java program", "label": {"api": {"ProcessBuilder.inheritIO()": [[17, 42]]}}}, {"text": "The default I/O mode is Redirect.PIPE, which is used to pipe command input from your Java program (rarely used), and to pipe command output (and error output) to your Java program", "label": {"api": {"Redirect.PIPE": [[24, 36]]}}}, {"text": "Arrays.asList() creates a fixed-size list, so once created, you cannot add more elements to it", "label": {"api": {"Arrays.asList()": [[0, 14]]}}}, {"text": "ObservableLists are created with the static factories from the FXCollections class", "label": {"api": {"FXCollections": [[63, 75]]}}}, {"text": "Java 8 version using Instant", "label": {"api": {"Instant": [[21, 27]]}}}, {"text": "You could use collectingAndThen to define a finisher operation on the resulting list", "label": {"api": {"collectingAndThen": [[14, 30]]}}}, {"text": "JOptionPane offers a ton of good, easy & flexible methods to do so", "label": {"api": {"JOptionPane": [[0, 10]]}}}, {"text": "The main JFrame won't be clickable anymore, since JOptionPane.showMessageDialog() produces a modal window", "label": {"api": {"JOptionPane": [[50, 60]]}}}, {"text": "When you add/remove components at runtime, always call revalidate() afterwards", "label": {"api": {"revalidate()": [[55, 66]]}}}, {"text": "revalidate() makes the component refresh/relayout", "label": {"api": {"revalidate()": [[0, 11]]}}}, {"text": "So just call revalidate() after you add the label and it will work", "label": {"api": {"revalidate()": [[13, 24]]}}}, {"text": "Standard output stream in OpenJDK is a PrintStream which wraps BufferedOutputStream, which wraps FileOutputStream which is created from FileDescriptor", "label": {"api": {"created": [[123, 129]]}}}, {"text": "There are special FileDescriptor objects which correspond to the stdin, stdout and stderr (in particular, see FileDescriptor.out)", "label": {"api": {"FileDescriptor.out": [[110, 127]]}}}, {"text": "String.split() is a very useful tool", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "String.trim() will do this for you", "label": {"api": {"String.trim()": [[0, 12]]}}}, {"text": "PrintWriter has 8 constructors", "label": {"api": {"PrintWriter": [[0, 10]]}}}, {"text": "I can create a new threadpool in java and execute tasks on it using the ExecutorService.newFixedThreadPool and ExecutorService.submit methods", "label": {"api": {"ExecutorService.newFixedThreadPool": [[72, 105]], "ExecutorService.submit": [[111, 132]]}}}, {"text": "Since Java-8 there's ForkJoinPool.commonPool() which is used by default by many methods involving parallel or asyncronous execution", "label": {"api": {"ForkJoinPool.commonPool()": [[21, 45]]}}}, {"text": "You can submit your own tasks to this pool using many methods of CompletableFuture class like CompletableFuture.supplyAsync()", "label": {"api": {"CompletableFuture.supplyAsync()": [[94, 124]]}}}, {"text": "If you are accessing them using filesystem paths, then you need to change all those accesses to use methods that use the classpath, such as the various getters in ClassLoader", "label": {"api": {"ClassLoader": [[163, 173]]}}}, {"text": "Your Climb interface respects the contract of a functional interface, that is, an interface with a single abstract method", "label": {"api": {"functional interface": [[48, 67]]}}}, {"text": "Both @Min and @Max annotations can be used on annotations themselves", "label": {"api": {"@Min": [[5, 8]], "@Max": [[14, 17]]}}}, {"text": "Java enum was introduced in version 1.5", "label": {"api": {"enum": [[5, 8]]}}}, {"text": "I think you might be missing the @MapsId annotation", "label": {"api": {"@MapsId": [[33, 39]]}}}, {"text": "In Java 1.7 or later, I would use ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[34, 50]]}}}, {"text": "The reason to use ThreadLocalRandom is explained here", "label": {"api": {"ThreadLocalRandom": [[18, 34]]}}}, {"text": "Also note, that the reason we +1 to the input to ThreadLocalRandom.nextInt() is to make sure the max is included in the range", "label": {"api": {"ThreadLocalRandom": [[49, 65]]}}}, {"text": "This creates a ConcurrentMap from the list of models by collecting it with Collectors.toConcurrentMap", "label": {"api": {"Collectors.toConcurrentMap": [[75, 100]]}}}, {"text": "You could get the i-th (i >= 1) element and apply compareTo(String other) against the previous one", "label": {"api": {"compareTo(String other)": [[50, 72]]}}}, {"text": "With the following code (from http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html": [[30, 99]]}}}, {"text": "See HashMap for example", "label": {"api": {"HashMap": [[4, 10]]}}}, {"text": "I suggest having a readw up on the List Interface from the Java API", "label": {"api": {"List Interface": [[35, 48]]}}}, {"text": "Use java.math.BigDecimal instead of double for arbitrary (finite) precision", "label": {"api": {"java.math.BigDecimal": [[4, 23]]}}}, {"text": "I am not an Android programmer, so I cannot verify that this is a direct equivalent, but it sounds as though you are looking for the Task class", "label": {"api": {"Task class": [[133, 142]]}}}, {"text": "You can bind to, or register a listener with, its progressProperty and you can register handlers via the setOnSucceeded, setOnFailed and similar methods", "label": {"api": {"progressProperty": [[50, 65]], "setOnSucceeded": [[105, 118]], "setOnFailed": [[121, 131]]}}}, {"text": "The progressProperty (and other properties) are updated on the FX Application Thread (so it is safe to update the UI in response to changes in their values), and the handlers for the state events (succeeded, failed, etc) are also invoked on the FX Application Thread", "label": {"api": {"progressProperty": [[4, 19]]}}}, {"text": "The true just means that there is a result, as stated in the javadoc of execute()", "label": {"api": {"execute()": [[72, 80]]}}}, {"text": "You need to call getResultSet() to get the actual result", "label": {"api": {"getResultSet()": [[17, 30]]}}}, {"text": "You need to Convert this to Calendar object and then you can get what ever you want from it", "label": {"api": {"Calendar": [[28, 35]]}}}, {"text": "Use this date to set it in Calendar", "label": {"api": {"Calendar": [[27, 34]]}}}, {"text": "You could use the date object it self but it deprecated https://docs.oracle.com/javase/7/docs/api/java/util/Date.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Date.html": [[56, 116]]}}}, {"text": "However, according to Java's DateTimeFormatter, the closest ISO 8601 format for this would be ISO_OFFSET_DATE_TIME, which looks like", "label": {"api": {"ISO_OFFSET_DATE_TIME": [[94, 113]]}}}, {"text": "If you read the API you'll note that rnd.nextInt(1) will always return zero (0)", "label": {"api": {"API": [[16, 18]]}}}, {"text": "keyboard is a Scanner object", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "It can't be compared like String with equals(\"0\")", "label": {"api": {"String": [[26, 31]]}}}, {"text": "Return an unmodifiable collection with Collection.unmodifiableList(list)", "label": {"api": {"Collection.unmodifiableList(list)": [[39, 71]]}}}, {"text": "You're calling the BigDecimal(double) constructor", "label": {"api": {"BigDecimal(double)": [[19, 36]]}}}, {"text": "Alternatively you could use BigDecimal.valueOf(double) instead of new BigDecimal(double) - but then you still have the problem that you've converted your real original source data (the text in your source code) into a binary floating point number first, potentially losing information", "label": {"api": {"BigDecimal(double)": [[70, 87]]}}}, {"text": "Consult the PrinterJob API to find the setJobName method", "label": {"api": {"PrinterJob API": [[12, 25]]}}}, {"text": "You are using the if else statemenet exactly how it should be used, yes technically you could if coding using Java 8 standards use the Optional (https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html) but for the example above would be more than overkill", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html": [[145, 209]]}}}, {"text": "Don't use \\n, instead use System.getProperty(\"line.separator\") or System#lineSeparator available since Java 7, to obtain a proper line separator that depends on the platform (Windows, *nix)", "label": {"api": {"System#lineSeparator": [[66, 85]]}}}, {"text": "The Scanner class has a next() method that returns the next \"token\" from the input", "label": {"api": {"Scanner class has a next() method": [[4, 36]]}}}, {"text": "If you want more precision you have to look up on BigDecimal", "label": {"api": {"BigDecimal": [[50, 59]]}}}, {"text": "Break the string into array and use Collections.reverse() as follows", "label": {"api": {"Collections.reverse()": [[36, 56]]}}}, {"text": "With Java 8 Arrays.stream, it is as simple as", "label": {"api": {"Arrays.stream": [[12, 24]]}}}, {"text": "After you successfully add(null) (it returns true to signal success), the list must obviously return true on contains(null) as well", "label": {"api": {"add": [[23, 25]], "contains": [[109, 116]]}}}, {"text": "In fact, you can even remove(null) from that list and it will be empty again", "label": {"api": {"remove": [[22, 27]]}}}, {"text": "Now you can create these objects with the data that the user inputs, and add them to a collection (i.e an ArrayList) or simply to an array", "label": {"api": {"ArrayList": [[106, 114]]}}}, {"text": "If that's not possible (for example, if you don't have access to the source of this class), you can use anyMatch with a predicate (only works in Java 8)", "label": {"api": {"anyMatch": [[104, 111]]}}}, {"text": "Byte Buddy hooks into the Java instrumentation API which allows the application of ClassFileTransformers to hook into a ClassLoaders loading process", "label": {"api": {"Java instrumentation API": [[26, 49]]}}}, {"text": "First, I thought CompletionStage.applyToEither does something similar, but it turns out it doesnt", "label": {"api": {"CompletionStage.applyToEither": [[17, 45]]}}}, {"text": "If multiple times, you don't want a singleton, but rather to create a queue of work", "label": {"api": {"queue": [[70, 74]]}}}, {"text": "You can do this in one of two ways, the first is to use a a want a thread pool, likely using one from the ExecutorService", "label": {"api": {"ExecutorService": [[106, 120]]}}}, {"text": "Your second option is to have a single queue reading from a queue and a single thread reading from the queue", "label": {"api": {"queue": [[39, 43], [60, 64], [103, 107]]}}}, {"text": "If you are trying to match either of two (or more) things in general, you can use the | operator, as described in the Pattern javadoc", "label": {"api": {"Pattern javadoc": [[118, 132]]}}}, {"text": "I think you are looking for the @Disposes annotation", "label": {"api": {"@Disposes": [[32, 40]]}}}, {"text": "The @Disposes annotation identifies the disposed parameter of a disposer method, allowing the application to perform customized cleanup of an object returned by a producer method or producer field", "label": {"api": {"@Disposes": [[4, 12]]}}}, {"text": "I don't know how your database connection provider looks like, but this example will give you the general idea on how to use the @Disposes annotation", "label": {"api": {"@Disposes": [[129, 137]]}}}, {"text": "As it's Comparable, you can use Stream.max", "label": {"api": {"Stream.max": [[32, 41]]}}}, {"text": "Stream.max method returns an Optional which is empty when your input list is empty", "label": {"api": {"Stream.max": [[0, 9]], "Optional": [[29, 36]]}}}, {"text": "Use .get(MyPojo.class) to have the response steam converted into an actual object", "label": {"api": {".get(MyPojo.class)": [[4, 21]]}}}, {"text": "You can use java.text.NumberFormat to work with the locale you want, e.g", "label": {"api": {"java.text.NumberFormat": [[12, 33]]}}}, {"text": "You'll then likely have a scheduled job (see ScheduledExecutorService) which removes stale entries", "label": {"api": {"ScheduledExecutorService": [[45, 68]]}}}, {"text": "Look into using a FileWriter and FileReader", "label": {"api": {"FileWriter": [[18, 27]], "FileReader": [[33, 42]]}}}, {"text": "You might also consider using a HashSet to accomplish this", "label": {"api": {"HashSet": [[32, 38]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#nextInt%28int%29 for reference", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#nextInt%28int%29": [[4, 82]]}}}, {"text": "Since you asked for hints, you can use Regex to add such rules", "label": {"api": {"Regex": [[39, 43]]}}}, {"text": "You can use Document Filter to implement these methods", "label": {"api": {"Document Filter": [[12, 26]]}}}, {"text": "I've just been reading through Java's documentation, and I'm wondering why their Queue implements both their Collection and their Iterable interfaces", "label": {"api": {"their Queue": [[75, 85]], "their Collection": [[103, 118]], "their Iterable": [[124, 137]]}}}, {"text": "If you don't want exceptions, and you're using Java 8, you might want to use the new Optional to force callers to check for special return value", "label": {"api": {"Optional": [[85, 92]]}}}, {"text": "Yes, you can use Collectors.collectingAndThen", "label": {"api": {"Collectors.collectingAndThen": [[17, 44]]}}}, {"text": "instead of using comparing, you can use comparingInt since Person.getAge() returns an int", "label": {"api": {"comparingInt": [[40, 51]]}}}, {"text": "You can user WatchService to detect new files or changed files in a directory", "label": {"api": {"WatchService": [[13, 24]]}}}, {"text": "OutOfMemoryError is not an Exception", "label": {"api": {"OutOfMemoryError": [[0, 15]]}}}, {"text": "You can pass multiple conditions in the constructor - you can even make them Predicates", "label": {"api": {"Predicates": [[77, 86]]}}}, {"text": "Different notifications under same critical section can be achived by using Condition", "label": {"api": {"Condition": [[76, 84]]}}}, {"text": "The Java Docs for Lock contain the following statement in documentation of the Methods lock, lockInterruptibly and tryLock", "label": {"api": {"Java Docs for Lock": [[4, 21]]}}}, {"text": "Maybe walkFileTree suits you better", "label": {"api": {"walkFileTree": [[6, 17]]}}}, {"text": "In Java 8 and later, the java.sql.Date class has a new valueOf(LocalDate date) method", "label": {"api": {"java.sql.Date": [[25, 37]], "valueOf(LocalDate date)": [[55, 77]]}}}, {"text": "The java.sql.Date is printed as 0123-12-27", "label": {"api": {"java.sql.Date": [[4, 16]]}}}, {"text": "You can use String.toCharArray", "label": {"api": {"String.toCharArray": [[12, 29]]}}}, {"text": "You simply have to override the toString() method of the class, read about it in java doc for Object class", "label": {"api": {"Object class": [[94, 105]]}}}, {"text": "First, use a Writer on top of the  output stream to write strings to files", "label": {"api": {"Writer": [[13, 18]]}}}, {"text": "Second, if you want to use your platform's line separator, you may use PrintWriter which has println() methods using the correct newline character or character sequence", "label": {"api": {"Writer": [[76, 81]], "PrintWriter": [[71, 81]]}}}, {"text": "Using a Graphics object you could calculate this using the font metrics", "label": {"api": {"Graphics": [[8, 15]]}}}, {"text": "PopupDateField will always return Date object as its value hence you will receive from this component hours and minutes", "label": {"api": {"Date": [[5, 8], [34, 37]]}}}, {"text": "Construct your Date or LocalDate object from the all components not just PopupDateField", "label": {"api": {"Date": [[15, 18], [28, 31], [78, 81]], "LocalDate": [[23, 31]]}}}, {"text": "You can also extend PopupDateField class by adding getLocalDate method which will convert Date to LocalDate", "label": {"api": {"Date": [[25, 28], [59, 62], [90, 93], [103, 106]], "LocalDate": [[54, 62], [98, 106]]}}}, {"text": "From the Formatter docs", "label": {"api": {"Formatter": [[9, 17]]}}}, {"text": "The Character class contains many useful methods for this task", "label": {"api": {"Character": [[4, 12]]}}}, {"text": "Other solution would be using a regex and replaceAll non digits characters (\\D) with the empty string", "label": {"api": {"replaceAll": [[42, 51]]}}}, {"text": "Visit the String API and the regex tutorial to fuel your creative fire", "label": {"api": {"String": [[10, 15]]}}}, {"text": "If you take a look at the API for System.arraycopy, you'll see that it's a method that copies data from one array to another array", "label": {"api": {"System.arraycopy": [[34, 49]]}}}, {"text": "Math.random() returns a double", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "You want an int value, so you should use the Random class", "label": {"api": {"Random": [[45, 50]]}}}, {"text": "nextInt(30) returns a random number between 0 and 29 (inclusive)", "label": {"api": {"nextInt(30)": [[0, 10]]}}}, {"text": "You may simply use a String#split method(here is a javadoc for it) with the new line sign \\\\n to split the text into the lines here, iterating over resulting array of the string representation of the lines, collecting them, for example, in some object representation, like some list of Title objects with it's subtitles", "label": {"api": {"a javadoc": [[49, 57]]}}}, {"text": "You should have only 1 scene", "label": {"api": {"scene": [[23, 27]]}}}, {"text": "In your example you could put your hboxes into a vbox and put the vbox on the scene", "label": {"api": {"vbox": [[49, 52], [66, 69]], "scene": [[78, 82]]}}}, {"text": "It seems you are looking for nested columns", "label": {"api": {"nested columns": [[29, 42]]}}}, {"text": "You could use String#matches with Regular Expression", "label": {"api": {"String#matches": [[14, 27]], "Regular Expression": [[34, 51]]}}}, {"text": "To send int wrap the stream with DataOutputStream and DataInputStream on the client side", "label": {"api": {"DataOutputStream": [[33, 48]]}}}, {"text": "An order-relation between strings can be found by stringA.compareTo(stringB) (http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo-java.lang.String-)", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo-java.lang.String-": [[78, 167]]}}}, {"text": "Once you have a Path there are a number of things you can do with it, including check if it exists via Files.exists(), or create it with Files.createFile()", "label": {"api": {"Files.exists()": [[103, 116]], "Files.createFile()": [[137, 154]]}}}, {"text": "Implicitly this path is relative to the current working directory, but you could pass it to Path.resolve() to create a new Path referring to a file in a different location", "label": {"api": {"Path.resolve()": [[92, 105]]}}}, {"text": "If so, you want to use Files.find() to search a directory and return a stream of the files that match a BiPredicate<Path, BasicFileAttributes> matcher you define", "label": {"api": {"Files.find()": [[23, 34]]}}}, {"text": "To manipulate a String with a date value, you first need to convert to a Date using SimpleDateFormat, then you can perform manipulation using a Calendar", "label": {"api": {"Date": [[73, 76], [90, 93]], "SimpleDateFormat": [[84, 99]], "Calendar": [[144, 151]]}}}, {"text": "If you need value for insertion into a database, you will of course use PreparedStatement, so you'll need a Timestamp instead", "label": {"api": {"PreparedStatement": [[72, 88]], "Timestamp": [[108, 116]]}}}, {"text": "You need to use the version of toArray() that accepts a generic argument", "label": {"api": {"toArray()": [[31, 39]]}}}, {"text": "List.toArray() returns an Object array", "label": {"api": {"List.toArray()": [[0, 13]]}}}, {"text": "Use List.toArray(T[]) instead", "label": {"api": {"List.toArray(T[])": [[4, 20]]}}}, {"text": "More info in the Java API", "label": {"api": {"Java API": [[17, 24]]}}}, {"text": "+ is a reserved character in regular expression and split takes regExp as a parameter", "label": {"api": {"split": [[52, 56]]}}}, {"text": "You could use a null Layout and then place components using setBounds()", "label": {"api": {"setBounds": [[60, 68]]}}}, {"text": "by using the Map interface", "label": {"api": {"Map": [[13, 15]]}}}, {"text": "It won't be possible to do that if we keep the default implementation of negate() in the Predicate class", "label": {"api": {"negate()": [[73, 80]]}}}, {"text": "As such, it isn't possible to have both predicate.test(null) and predicate.negate().test(null) return true", "label": {"api": {"negate()": [[75, 82]]}}}, {"text": "to the same output destination as your Java programs output, you need to use ProcessBuilder.inheritIO()", "label": {"api": {"ProcessBuilder.inheritIO()": [[77, 102]], "Process": [[77, 83]], "ProcessBuilder": [[77, 90]]}}}, {"text": "You should use ProcessBuilder anyway", "label": {"api": {"Process": [[15, 21]], "ProcessBuilder": [[15, 28]]}}}, {"text": "Quoting javadoc of Process", "label": {"api": {"Process": [[19, 25]]}}}, {"text": "stdin, stdout, stderr) operations will be redirected to the parent process, where they can be accessed via the streams obtained using the methods getOutputStream(), getInputStream(), and getErrorStream()", "label": {"api": {"getOutputStream()": [[146, 162]], "getInputStream()": [[165, 180]], "getErrorStream()": [[187, 202]]}}}, {"text": "Where desired, subprocess I/O can also be redirected using methods of the ProcessBuilder class", "label": {"api": {"Process": [[74, 80]], "subprocess I/O can also be redirected": [[15, 51]], "ProcessBuilder": [[74, 87]]}}}, {"text": "As of 1.5, ProcessBuilder.start() is the preferred way to create a Process", "label": {"api": {"Process": [[11, 17], [67, 73]], "ProcessBuilder": [[11, 24]], "ProcessBuilder.start()": [[11, 32]]}}}, {"text": "You don't need to convert array to string, you can directly execute a command using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[84, 97]]}}}, {"text": "The InputMismatchException is thrown by Scanner whenever a user types in a value that isn't the same as the value requested", "label": {"api": {"InputMismatchException": [[4, 25]]}}}, {"text": "You can construct (or pass in) a List<Predicate<String>>, and then go over it like so", "label": {"api": {"Predicate": [[38, 46]]}}}, {"text": "Elements in a HashSet are ordered (dispersed in the Javadoc) by the Object.hashCode()", "label": {"api": {"HashSet": [[14, 20]]}}}, {"text": "You can use a LinkedHashSet if you need a Set that preserves insertion order", "label": {"api": {"HashSet": [[20, 26]], "LinkedHashSet": [[14, 26]]}}}, {"text": "Take a look at Optional javadoc", "label": {"api": {"Optional javadoc": [[15, 30]]}}}, {"text": "to iterate over a map you need to keep a Collection instance", "label": {"api": {"Collection": [[41, 50]]}}}, {"text": "Java's ConcurrentLinkedQueue seems like your best bet for a FIFO ordered queue", "label": {"api": {"ConcurrentLinkedQueue": [[7, 27]]}}}, {"text": "According to http://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyEvent.html it's", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyEvent.html": [[13, 81]]}}}, {"text": "As you can see in the invoke method's signature, you provide all parameters in an array", "label": {"api": {"invoke method's signature": [[22, 46]]}}}, {"text": "Since the  reallocation is the problem, maybe a ByteBuffer http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html can solve this", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html": [[59, 123]]}}}, {"text": "The servlet API provides javax.servlet.http.HttpSessionListener in order that you can get notified when a session is created or destroyed", "label": {"api": {"javax.servlet.http.HttpSessionListener": [[25, 62]]}}}, {"text": "Use Thread.sleep(1) instead", "label": {"api": {"Thread.sleep(1)": [[4, 18]]}}}, {"text": "Perhaps you're looking for Desktop.open()", "label": {"api": {"Desktop.open()": [[27, 40]]}}}, {"text": "Columns in ResultSet are indexed starting from 1 and getColumnCount returns the number of selected columns", "label": {"api": {"ResultSet": [[11, 19]], "getColumnCount": [[53, 66]]}}}, {"text": "RandomAccessFile gives you random access to a file (surprise, surprise :)) and its readLine() method allows you to process it line by line", "label": {"api": {"RandomAccessFile": [[0, 15]]}}}, {"text": "Or for Java 8 and later, the currently preferred way might be to make use of new java.time API (you can play around with the method arguments)", "label": {"api": {"java.time": [[81, 89]]}}}, {"text": "This API includes a handy DayOfWeek enum", "label": {"api": {"DayOfWeek": [[26, 34]]}}}, {"text": "You could register a KeyEventDispatcher", "label": {"api": {"KeyEventDispatcher": [[21, 38]]}}}, {"text": "Note that the registered KeyEventDispatchers will receive KeyEvents before they are dispatched to their targets, allowing to retarget the event, consume it, dispatch the event itself, or make other changes", "label": {"api": {"KeyEventDispatcher": [[25, 42]]}}}, {"text": "The simplest fix to apply here is to use ThreadLocalRandom instead", "label": {"api": {"ThreadLocalRandom": [[41, 57]]}}}, {"text": "Note that ThreadLocalRandom.nextInt() has no fast-path like RandomUtils.nextInt(), so if you want to keep it, use", "label": {"api": {"ThreadLocalRandom": [[10, 26]]}}}, {"text": "Be careful not to cache ThreadLocalRandom.current() instance somewhere outside (like in field or static variable)", "label": {"api": {"ThreadLocalRandom": [[24, 40]]}}}, {"text": "You want to use Constructor#newInstance(Object...)", "label": {"api": {"Constructor#newInstance(Object...)": [[16, 49]]}}}, {"text": "This is effectively the same as a volatile field, but it's a little more flexible (you can reassign and pass around references to the AtomicReference) and has a few extra operations, like compareAndSet()", "label": {"api": {"compareAndSet()": [[188, 202]]}}}, {"text": "You can use a CountDownLatch or similar synchronizer class, but you need to pay close attention to the memory invariants they offer", "label": {"api": {"synchronizer": [[40, 51]]}}}, {"text": "Have a look at the Java Instrumentation API", "label": {"api": {"Java Instrumentation API": [[19, 42]]}}}, {"text": "Yes it is quite some overhead as every trim might construct a new string instance and then throws it away after comparison", "label": {"api": {"trim": [[39, 42]]}}}, {"text": "So trim the values when you read them from the database or from user input", "label": {"api": {"trim": [[3, 6]]}}}, {"text": "For the rest of the program flow in your code you can then be sure that all strings are already trimmed", "label": {"api": {"trim": [[96, 99]]}}}, {"text": "This will also prevent you from forgetting to put a trim before comparing the string somewhere else in your code", "label": {"api": {"trim": [[52, 55]]}}}, {"text": "Why to do comparison for pattern after listing files and then iterating again just filter the files by using List Files with filter and the files which satisfy your condition copy them", "label": {"api": {"List Files with filter": [[109, 130]]}}}, {"text": "The ReentrantReadWriteLock http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html seems to do what you need if you just signal across to release the lock", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html": [[27, 121]]}}}, {"text": "The reason you have to double up the (already doubled) backslashes  is that replaceAll takes a regular expression and a single backslash is used in regex", "label": {"api": {"replaceAll": [[76, 85]], "used in regex": [[140, 152]]}}}, {"text": "If the input fits in memory, you can create a thread pool then add a new task for each entry in the input", "label": {"api": {"thread pool": [[46, 56]]}}}, {"text": "Since you don't want to receive a JSON String in your methods and Bean Validation is not an option for your validation, you could try a MessageBodyWriter<T>", "label": {"api": {"MessageBodyWriter<T>": [[136, 155]]}}}, {"text": "JAX-RS uses MessageBodyWriter<T>s to parse incoming requests", "label": {"api": {"MessageBodyWriter<T>": [[12, 31]], "MessageBodyWriter<T>s": [[12, 32]]}}}, {"text": "Since you want something very specific, consider writing your own MessageBodyWriter<T>", "label": {"api": {"MessageBodyWriter<T>": [[66, 85]]}}}, {"text": "The @Provider annotation makes the class to be automatically discovered by the JAX-RS runtime during a provider scanning phase", "label": {"api": {"@Provider": [[4, 12]]}}}, {"text": "First of all I've examined the java doc of LocalDate.parse but it doesn't suit for my question", "label": {"api": {"LocalDate.parse": [[43, 57]]}}}, {"text": "31.02.2015 LocalDate.parse returns 28.02.2015 which is wrong", "label": {"api": {"LocalDate.parse": [[11, 25]]}}}, {"text": "Since you want it to stay with a default value (null) if no value is present, you can use the map and orElse methods", "label": {"api": {"map": [[94, 96]], "orElse": [[102, 107]]}}}, {"text": "If there are registered UncaughtExceptionHandler they will be called", "label": {"api": {"UncaughtExceptionHandler": [[24, 47]]}}}, {"text": "Your usage if the swing Timer class can be improved significantly", "label": {"api": {"swing Timer": [[18, 28]]}}}, {"text": "A better way to handle that is to store the value of System.currentTimeMillis somewhere and use it in your callback", "label": {"api": {"System.currentTimeMillis": [[53, 76]]}}}, {"text": "Rather than using stop(), use interrupt() on the expensive computation thread", "label": {"api": {"interrupt()": [[30, 40]]}}}, {"text": "You can check the interrupt flag for a thread using either interrupted() or isInterrupted()", "label": {"api": {"interrupted()": [[59, 71]], "isInterrupted()": [[76, 90]]}}}, {"text": "You're going to want to look into Pattern and its associate Matcher", "label": {"api": {"Pattern": [[34, 40]], "Matcher": [[60, 66]]}}}, {"text": "While String#replaceAll gives you what you want, it's not entirely semantic; you can certainly replace all of the \"e\"s with \"xyz\" and then compare them to see if there was no change, but using Matcher gives you a bit more obvious control over the logic", "label": {"api": {"Matcher": [[193, 199]]}}}, {"text": "Or use replaceAll", "label": {"api": {"replaceAll": [[7, 16]]}}}, {"text": "The format pattern %02d pads an integer with a zero given that it is less than two digits in length, as defined in the syntax for string formatting", "label": {"api": {"syntax for string formatting": [[119, 146]]}}}, {"text": "As @Nyavro mentioned in his comment, you can use a LinkedList which implements the Queue interface", "label": {"api": {"Queue": [[83, 87]]}}}, {"text": "You can use any Node in a Scene to get a reference to that scene", "label": {"api": {"Node": [[16, 19]]}}}, {"text": "Assuming the Node fields are actually injected by the loader, you can close the Stage using this code", "label": {"api": {"Node": [[13, 16]]}}}, {"text": "This is answered in the Javadoc for Executors.newFixedThreadPool", "label": {"api": {"Executors.newFixedThreadPool": [[36, 63]]}}}, {"text": "I do agree with @k0ner, use CompletableFuture available on Java8", "label": {"api": {"CompletableFuture": [[28, 44]]}}}, {"text": "There is an example at this answer about using CompletableFuture", "label": {"api": {"CompletableFuture": [[47, 63]]}}}, {"text": "See addCaretListener API", "label": {"api": {"addCaretListener": [[4, 19]]}}}, {"text": "Another example is java.time.Period", "label": {"api": {"java.time.Period": [[19, 34]]}}}, {"text": "Take for example java.time.Duration", "label": {"api": {"java.time.Duration": [[17, 34]]}}}, {"text": "Files.createTempFile allows you to create a temporary file in the default temporary directory of the JVM", "label": {"api": {"Files.createTempFile": [[0, 19]]}}}, {"text": "It is not possible to manage the lifecycle of file with try-with-resources using java.io.File or java.nio.file.Path", "label": {"api": {"java.io.File": [[81, 92]], "java.nio.file.Path": [[97, 114]]}}}, {"text": "I also recommend you to have 1 (and no more) JFrame in your app, so whenever you ALT+TAB you can see the running app", "label": {"api": {"JFrame": [[45, 50]]}}}, {"text": "To parse a single node, there is LSParser.parseWithContext", "label": {"api": {"LSParser.parseWithContext": [[33, 57]]}}}, {"text": "Read up on String.equalsIgnoreCase() for more information on how it works", "label": {"api": {"String.equalsIgnoreCase()": [[11, 35]]}}}, {"text": "The epoch day is obtained with toEpochDay() which is the count of days since 1970-01-01 (ISO)", "label": {"api": {"toEpochDay()": [[31, 42]]}}}, {"text": "As the Window Javadoc explains it, a top level window within which a scene is hosted, and with which the user interacts", "label": {"api": {"explains it": [[22, 32]]}}}, {"text": "Your Account class implements Runnable, and each Account object is responsible for updating its value", "label": {"api": {"Runnable": [[30, 37]]}}}, {"text": "You need to call ExecutorService.shutdown() and awaitTermination() to terminate the threads after all your work is done", "label": {"api": {"ExecutorService.shutdown()": [[17, 42]], "awaitTermination()": [[48, 65]]}}}, {"text": "default boolean remove(Object key, Object value)", "label": {"api": {"default boolean remove(Object key, Object value)": [[0, 47]]}}}, {"text": "You can make use of System.arrayCopy to copy sourceArray from start index to destination array from start index", "label": {"api": {"System.arrayCopy": [[20, 35]]}}}, {"text": "You can also specify how many elements should e copied as last argument to System.arrayCopy method", "label": {"api": {"System.arrayCopy": [[75, 90]]}}}, {"text": "For more details on how System.arrayCopy works, you can see the following tutorial or read my answer in this question", "label": {"api": {"System.arrayCopy": [[24, 39]]}}}, {"text": "In which case Boolean.parseBoolean() is exactly what you need", "label": {"api": {"Boolean.parseBoolean()": [[14, 35]]}}}, {"text": "If you just want to parse a year and a month, you can use the YearMonth object instead", "label": {"api": {"YearMonth": [[62, 70]]}}}, {"text": "You could use the Path class to do it in a way that is platform independent", "label": {"api": {"the Path class": [[14, 27]]}}}, {"text": "printf allows you some more formatting options (such as the number of decimal places) without having to use a DecimalFormat, but it is a choice on style rather than anything else", "label": {"api": {"DecimalFormat": [[110, 122]]}}}, {"text": "However, there is the class TreeSet, which implements SortedSet", "label": {"api": {"TreeSet": [[28, 34]]}}}, {"text": "Try await(), not wait()", "label": {"api": {"await()": [[4, 10]], "wait()": [[5, 10], [17, 22]]}}}, {"text": "await() will wait until the latch reaches zero", "label": {"api": {"await()": [[0, 6]], "wait()": [[1, 6]]}}}, {"text": "wait() is unrelated to latches, and is not what you want in your WorkerRunnable", "label": {"api": {"wait()": [[0, 5]]}}}, {"text": "But FYI, in order to call wait() without getting an exception, you have to own an object's monitor, and to become the owner, you have to be in a block that's synchronized on that object", "label": {"api": {"wait()": [[26, 31]]}}}, {"text": "The StampedLock JavaDoc and this article are good places to start reading up", "label": {"api": {"StampedLock": [[4, 14]]}}}, {"text": "The way to do what you are looking for would be to have message be a thread local variable or to place the setting of the message and the reading of it inside a single synchronized block, probably locking on the singleton object", "label": {"api": {"thread local": [[69, 80]]}}}, {"text": "Objects can be collected when they're no longer reachable", "label": {"api": {"reachable": [[48, 56]]}}}, {"text": "Part of garbage collection is determining whether an object is no longer reachable", "label": {"api": {"reachable": [[73, 81]]}}}, {"text": "EncryptedMessage and CompressedMessage should implement Serializable", "label": {"api": {"Serializable": [[56, 67]]}}}, {"text": "Just use a PreparedStatement to inject your values, it will escape them for you", "label": {"api": {"PreparedStatement": [[11, 27]]}}}, {"text": "See the relevant documentation for Map", "label": {"api": {"Map": [[35, 37]]}}}, {"text": "A map data structure inspects your object at insertion time in order to determine where it should live (for a HashMap it inspects the hashCode() and puts it in a particular bucket, for TreeMap it compares it against other keys and puts it in a particular branch of the tree, etc.)", "label": {"api": {"Map": [[114, 116], [189, 191]]}}}, {"text": "Maps provide efficient lookup because they then only look where the object is expected to be, and don't search the other buckets / rest of the tree", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "I go into some more detail about the assumptions HashMap makes and why in this related answer", "label": {"api": {"Map": [[53, 55]]}}}, {"text": "This can be implied from the Javadoc of Closeable#close()", "label": {"api": {"Closeable#close()": [[40, 56]]}}}, {"text": "For a simple solution I'd go with a Path that randomly extends and change the style of the path during time", "label": {"api": {"Path": [[36, 39]]}}}, {"text": "More sophisticated code could use a Canvas and paint the shattering on it", "label": {"api": {"Canvas": [[36, 41]]}}}, {"text": "In Java 8 you can use Stream.concat", "label": {"api": {"Stream.concat": [[22, 34]]}}}, {"text": "I've been investigating Java's ParseException, when trying to write my own method that parses from a String to an int, and have two questions", "label": {"api": {"ParseException": [[31, 44]]}}}, {"text": "Java's Integer.parseInt(String string) throws a NumberFormatException when an invalid input is given (makes sense with it being a subclass of IllegalArgumentException), and does not throw ParseException at all", "label": {"api": {"ParseException": [[188, 201]]}}}, {"text": "ParseException's constructor forces you to give it a value - what does it mean", "label": {"api": {"ParseException": [[0, 13]]}}}, {"text": "It subtracts one month from the current month and sets the day of month to its maximum value, obtained with getActualMaximum", "label": {"api": {"getActualMaximum": [[108, 123]]}}}, {"text": "I would do that with a JEditorPane using html tags", "label": {"api": {"JEditorPane": [[23, 33]]}}}, {"text": "All annotations implement the Annotation interface", "label": {"api": {"Annotation": [[30, 39]]}}}, {"text": "The Annotation interface exposes annotationType() which will give you access to the annotation type (yours)", "label": {"api": {"Annotation": [[4, 13]], "annotationType()": [[33, 48]]}}}, {"text": "You can therefore use the corresponding Class to retrieve the value of the Target annotation on your type", "label": {"api": {"retrieve": [[49, 56]]}}}, {"text": "Note that Annotation is just an interface", "label": {"api": {"Annotation": [[10, 19]]}}}, {"text": "Use something like java.util.concurrent.ArrayBlockingQueue instead (notice above)", "label": {"api": {"java.util.concurrent.ArrayBlockingQueue": [[19, 57]]}}}, {"text": "One of them is the invokeAll method of the ExecutorService, that returns only when all tasks that have been submitted are completed", "label": {"api": {"invokeAll": [[19, 27]]}}}, {"text": "If you want to run Selenium WebDriver tests using TestNG in parallel then you can use a ThreadLocal to maintain a WebDriver instance per thread", "label": {"api": {"ThreadLocal": [[88, 98]]}}}, {"text": "If you have more tests than threads and want to reuse WebDriver instances then you can use a ThreadLocal with an initial value", "label": {"api": {"ThreadLocal": [[93, 103]]}}}, {"text": "If you don't need to keep the returned Process object from Runtime.exec then you can use the simpler Desktop.getDesktop().open", "label": {"api": {"Desktop.getDesktop().open": [[101, 125]]}}}, {"text": "once you've read them to the end, you either need to explicitly rewind them (if they support rewinding), or you need to close them (always close your streams and readers!) and open a new one", "label": {"api": {"explicitly rewind": [[53, 69]]}}}, {"text": "No loops, no sleep, TranslateTransition, linked javadoc includes a sample", "label": {"api": {"TranslateTransition": [[20, 38]]}}}, {"text": "Then, when an event happens, you could use the JLabel#setIcon method to change the Icon dynamically", "label": {"api": {"JLabel#setIcon": [[47, 60]]}}}, {"text": "Perhaps I am misinterpreting task.isDone", "label": {"api": {"task.isDone": [[29, 39]]}}}, {"text": "It uses the executor you have provided or the common pool if you have not provided one", "label": {"api": {"you have provided": [[21, 37]], "common pool": [[46, 56]]}}}, {"text": "If a thread-safe highly-concurrent implementation is desired, then it is recommended to use ConcurrentHashMap in place of Hashtable", "label": {"api": {"ConcurrentHashMap": [[92, 108]]}}}, {"text": "Better use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[13, 29]]}}}, {"text": "Quoting the method divide(divisor, roundingMode) Javadoc", "label": {"api": {"divide(divisor, roundingMode)": [[19, 47]]}}}, {"text": "You need to change this division to use divide(divisor, scale, roundingMode) instead and specify the scale you want", "label": {"api": {"divide(divisor, scale, roundingMode)": [[40, 75]]}}}, {"text": "You can use System.nanoTime() or one of the many stopwatches to do this", "label": {"api": {"System.nanoTime()": [[12, 28]]}}}, {"text": "The SimpleDateFormat will throw an exception if the string was not parsable as a date", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Note here that you are really replicating some of the functionality of the Alert class", "label": {"api": {"Alert": [[75, 79]]}}}, {"text": "If you want to listen for any and all changes in your textfields, look into DocumentListener", "label": {"api": {"DocumentListener": [[76, 91]]}}}, {"text": "I am already listening to MenuListener.menuSelected() to know when a JMenu is showing on the screen", "label": {"api": {"MenuListener.menuSelected()": [[26, 52]], "JMenu": [[69, 73]]}}}, {"text": "Initially, the JMenu has 1 JMenuItem which says \"Loading...\"", "label": {"api": {"JMenu": [[15, 19], [27, 31]], "JMenuItem": [[27, 35]]}}}, {"text": "After a slow operation, I add JMenuItems to the JMenu", "label": {"api": {"JMenu": [[30, 34], [48, 52]], "JMenuItem": [[30, 38]]}}}, {"text": "The JMenu continues to show \"Loading...\"", "label": {"api": {"JMenu": [[4, 8]]}}}, {"text": "If I select another JMenu and come back, then the JMenu shows the added JMenuItems", "label": {"api": {"JMenu": [[20, 24], [50, 54], [72, 76]], "JMenuItem": [[72, 80]]}}}, {"text": "How do I cause the added JMenuItems to show up immediately", "label": {"api": {"JMenu": [[25, 29]], "JMenuItem": [[25, 33]]}}}, {"text": "You are getting an IndexOutOfBoundsException because substring found that end index was less than the begin index", "label": {"api": {"substring found that end index was less than the begin index": [[53, 112]]}}}, {"text": "Use an overload of indexOf that takes a second argument - the index at which to starting looking", "label": {"api": {"overload of indexOf that takes a second argument": [[7, 54]]}}}, {"text": "You can use a simple ArrayList for that", "label": {"api": {"ArrayList": [[21, 29]]}}}, {"text": "There is a Stack class in java", "label": {"api": {"Stack": [[11, 15]]}}}, {"text": "Stack's methods are synchronized, which adds some performance overhead, and in software development LinkedList is usually picked instead", "label": {"api": {"Stack": [[0, 4]], "LinkedList": [[100, 109]]}}}, {"text": "One way to get this is to use the java.util.Arrays utility to convert each element of the array to a String", "label": {"api": {"java.util.Arrays": [[34, 49]]}}}, {"text": "Java 8 has the new Optional class, e.g", "label": {"api": {"Optional": [[19, 26]]}}}, {"text": "ofNullable creates an Optional value out of the given employee", "label": {"api": {"ofNullable": [[0, 9]]}}}, {"text": "Then, this Optional is mapped to the name of the employee using map, which returns a new Optional with the given mapper applied if the Optional is non empty and an empty Optional if the Optional is empty", "label": {"api": {"map": [[23, 25], [64, 66], [113, 115]]}}}, {"text": "Finally, orElse returns the name of the employee or null is the Optional is empty", "label": {"api": {"orElse": [[9, 14]]}}}, {"text": "If on the other hand you want those values to be persisted for the next start of the application, you'd might want to consider Preferences instead", "label": {"api": {"Preferences": [[127, 137]]}}}, {"text": "You can use Java's build in ExecutorService for the same", "label": {"api": {"ExecutorService": [[28, 42]]}}}, {"text": "The default Array.sort(int[]) gives you ascending results instead of descending", "label": {"api": {"Array.sort(int[]) gives you ascending": [[12, 48]]}}}, {"text": "You could create your own Comparator and pass that in as agrument to the appropriate List::sort method, since you say you already \"have a sorted list\"", "label": {"api": {"List::sort": [[85, 94]]}}}, {"text": "If you want to make sure the string can be parsed to a double using Double.parseDouble(String s), see the regular expression that is provided in the javadoc of Double.valueOf(String s)", "label": {"api": {"Double.parseDouble(String s)": [[68, 95]], "Double.valueOf(String s)": [[160, 183]]}}}, {"text": "I also have found the Java Date class confusing because most of it is deprecated but I have found that the GregorianCalendar class to meet most of my needs", "label": {"api": {"GregorianCalendar": [[107, 123]]}}}, {"text": "One nice thing is that new GregorianCalendar(); will instantiate to the current time", "label": {"api": {"GregorianCalendar": [[27, 43]]}}}, {"text": "So according to this documentation the JSONParser class does not contain a parse() method", "label": {"api": {"this documentation": [[16, 33]]}}}, {"text": "The Arrays class provides several different implementations and chances are that you will find a suitable implementation there", "label": {"api": {"Arrays": [[4, 9]]}}}, {"text": "For the examples mentioned there is one for int[] int binarySearch(int[] a, int key) and one for generic objects int binarySearch(T[] a, T key, Comparator c) that may be of interest", "label": {"api": {"int binarySearch(int[] a, int key)": [[50, 83]], "int binarySearch(T[] a, T key, Comparator c)": [[113, 156]]}}}, {"text": "See the reference here, you can use exchange.getResponseBody() which provides you an OutputStream and you can use this as parameter when you create the ObjectOutputStream", "label": {"api": {"the reference here": [[4, 21]]}}}, {"text": "Lets say I have a grid of points, and i use some functions to 'mark' some of them and add them to a regular Java Polygon, like this", "label": {"api": {"Polygon": [[113, 119]]}}}, {"text": "How should I determinate what the outer boundary of the Polygon is", "label": {"api": {"Polygon": [[56, 62]]}}}, {"text": "I tried the Polygon methods like getBounds or getPathIterator but they won't work in my case, since those will use the inner points as well", "label": {"api": {"Polygon": [[12, 18]]}}}, {"text": "This is the code of StringBuilder.toString() in OpenJDK 8u40", "label": {"api": {"toString()": [[34, 43]]}}}, {"text": "However, when you set str2 = sb1.toString(), it gets set to a new String (having the same content), so == returns false", "label": {"api": {"toString()": [[33, 42]]}}}, {"text": "This is actually specified in toString() Javadoc (emphasis mine)", "label": {"api": {"toString()": [[30, 39]]}}}, {"text": "I would recommend using a java.util.HashMap<>", "label": {"api": {"java.util.HashMap<>": [[26, 44]]}}}, {"text": "Understand that you don't actually care about the files, you want their contents, so start using getResourceAsStream()--it works for both cases pretty transparently", "label": {"api": {"getResourceAsStream()": [[97, 117]]}}}, {"text": "You can use String.split(regex) to split the query String", "label": {"api": {"String.split(regex)": [[12, 30]]}}}, {"text": "To remove a element whilst in the middle of iterating, use Iterator.remove()", "label": {"api": {"Iterator.remove()": [[59, 75]]}}}, {"text": "Secondly, you're confusing Arrays and ArrayLists, which are different types, and have different ways to access their length and contents", "label": {"api": {"ArrayLists": [[38, 47]]}}}, {"text": "Otherwise, try Runtime.exec() or ClassLoader", "label": {"api": {"Runtime.exec()": [[15, 28]], "ClassLoader": [[33, 43]]}}}, {"text": "Note that I've never used ClassLoader, so I might be interpreting the docs wrong, but it seems to be something that might accomplish you're looking for", "label": {"api": {"ClassLoader": [[26, 36]]}}}, {"text": "Googling tells me that it's probably excessive to use it for a program such as yours, though, so I'd stick with Runtime.exec()", "label": {"api": {"Runtime.exec()": [[112, 125]]}}}, {"text": "You can use ServletContext#getRealPath() to get the  path of the deployed/expanded WAR folder structure on the server file system", "label": {"api": {"ServletContext#getRealPath()": [[12, 39]]}}}, {"text": "I don't know what is the ProductPopulation class you use to populate the list, so I can not say what exactly is the best way in your case, but in general a list can be ordered by means of the Collections.sort() method (see the method documentation)", "label": {"api": {"the method documentation": [[223, 246]]}}}, {"text": "For this, you can use Comparator.comparingInt(keyExtractor)", "label": {"api": {"Comparator.comparingInt(keyExtractor)": [[22, 58]]}}}, {"text": "It's simpler to use plain old Collections.min() with the corresponding comparator", "label": {"api": {"Collections.min()": [[30, 46]]}}}, {"text": "I don't think substring is a \"good\" way to do this as if you look at the API for String, there isn't a substring method that takes parameters other than indices of characters in the string", "label": {"api": {"API": [[73, 75]]}}}, {"text": "Assuming you still want to do this in a manner where you dump the array into a string, a more suitable method of the String API would be indexOf()", "label": {"api": {"API": [[124, 126]]}}}, {"text": "You can use the JavaCompiler API", "label": {"api": {"JavaCompiler API": [[16, 31]]}}}, {"text": "To make sure we handle the EDT correctly we use a SwingWorker", "label": {"api": {"SwingWorker": [[50, 60]]}}}, {"text": "SwingWorkers are special constructs designed to perform lengthy GUI-interaction tasks in a background thread", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "To get it from String, you could use SimpleDateFormat like", "label": {"api": {"SimpleDateFormat": [[37, 52]]}}}, {"text": "From my experience (and from javadoc of DataSource) this method will return you a connected Connection, you can use to query your database", "label": {"api": {"DataSource": [[40, 49]]}}}, {"text": "Calling String.intern() will have exactly that effect, without the need of a map", "label": {"api": {"String.intern()": [[8, 22]]}}}, {"text": "Without seeing the other part of your code, you could use an AtomicInteger instead and use incrementAndGet()", "label": {"api": {"AtomicInteger": [[61, 73]], "incrementAndGet()": [[91, 107]]}}}, {"text": "If you want to run from inside the IDE, add a main method that simply calls launch()", "label": {"api": {"launch()": [[76, 83]]}}}, {"text": "String#substring(int, int) doesn't work because that wouldn't work with scientific notation or would lose information 0.0000000000000001would become 0 and not 1e-16", "label": {"api": {"String#substring(int, int)": [[0, 25]]}}}, {"text": "String#format(String, Object...) with the %g format doesn't work because it leaves trailing/leading zeroes, and doesn't include the scientific notation in the digit count", "label": {"api": {"String#format(String, Object...)": [[0, 31]]}}}, {"text": "I also looked at DecimalFormat, but couldn't find anything that allowed setting the number of characters", "label": {"api": {"DecimalFormat": [[17, 29]]}}}, {"text": "Split each line read by the while loop using text.split(\"\\\\s+\"), and iterate the split values", "label": {"api": {"text.split(\"\\\\s+\")": [[45, 62]]}}}, {"text": "Did you take a look at the Artwork support in JAudioTagger and the Java ImageIO class", "label": {"api": {"ImageIO": [[72, 78]]}}}, {"text": "See ZipOutputStream for one such class that you could use", "label": {"api": {"ZipOutputStream": [[4, 18]]}}}, {"text": "You would then have your Team object implement the Comparable interface", "label": {"api": {"Comparable": [[51, 60]]}}}, {"text": "My question was that in order to do this copying would bufferedreader be a suitable option", "label": {"api": {"bufferedreader": [[55, 68]]}}}, {"text": "There is no guaranty that the read(byte[] b) method will read b.length number of bytes from the file which mean that your code could be sending more bytes then the file actually has", "label": {"api": {"read(byte[] b)": [[30, 43]]}}}, {"text": "For example, if you're processing a 10 MB file and the read(byte[] b) always reads b.length/2 from the file, you will be sending 20 MB", "label": {"api": {"read(byte[] b)": [[55, 68]]}}}, {"text": "Yes, you could have a Consumer<Game>", "label": {"api": {"Consumer<Game>": [[22, 35]]}}}, {"text": "But if that's what you want you could use Objects.hash(a)", "label": {"api": {"Objects.hash(a)": [[42, 56]]}}}, {"text": "The join method blocks until the Thread on which it is called dies", "label": {"api": {"join method": [[4, 14]]}}}, {"text": "You can use Integer.toBinaryString(int) to see the binary representation of any int", "label": {"api": {"Integer.toBinaryString(int)": [[12, 38]]}}}, {"text": "If you need to parse a binary String, you can use Integer.parseInt(String, int) where the first argument is the String to be parsed and second argument is a radix (for binary that would be 2)", "label": {"api": {"Integer.parseInt(String, int)": [[50, 78]]}}}, {"text": "You can use the UriInfo class in conjunction with  UriBuilder class to mount or create URLs using the current path", "label": {"api": {"UriInfo": [[16, 22]], "UriBuilder": [[51, 60]]}}}, {"text": "If you read the javadoc of toArray(), you can see that it returns an Object[], which you cannot simply cast to Coefficient[]", "label": {"api": {"toArray()": [[27, 35]]}}}, {"text": "Instead use toArray(T[] a)", "label": {"api": {"toArray(T[] a)": [[12, 25]]}}}, {"text": "I didn't know the Supplier interface was only available to Java 8, and used it in the core module, which as far as I understand, it compiles into a library that is shared by all android/html/desktop/ios versions of the game", "label": {"api": {"Supplier": [[18, 25]]}}}, {"text": "The desktop version runs fine (I have Java 8 installed), but my android app crashes with a NoClassDefFoundError error (BTW, the error message was showing the name of classes that I wrote, and not Supplier, but the error disappeared as soon as I removed every reference to Supplier and came back when I added them, so apparently the error message doesn't show the actual problem class)", "label": {"api": {"Supplier": [[196, 203], [272, 279]]}}}, {"text": "If I try to use Supplier in my android module, it won't even let me import the class, so it knows it doesn't support that Java version, but it'll happily let me use it in the core module without any warning", "label": {"api": {"Supplier": [[16, 23]]}}}, {"text": "I'm sure removing references to Supplier will solve the problem, but this fix may cause runtime errors later on if I inadvertently use any Java 8 features, so not a good way to solve it", "label": {"api": {"Supplier": [[32, 39]]}}}, {"text": "ScriptObjectMirror has an unwrap method that takes a Global object", "label": {"api": {"unwrap": [[26, 31]]}}}, {"text": "There is a ScriptUtils#unwrap that doesn't take in a global, but it also shows the same behavior", "label": {"api": {"ScriptUtils#unwrap": [[11, 28]]}}}, {"text": "See for it Interface Node, and think that it will also return the text of the node descendants (if they exist)", "label": {"api": {"Interface Node": [[11, 24]]}}}, {"text": "Secondly, if you just want to get content of file in String, you can do it in following way with java.nio.file.Files and without using any third party library", "label": {"api": {"java.nio.file.Files": [[97, 115]]}}}, {"text": "To understand why the paint method is invoked excessively, you can start by checking DefaultTableCellRenderer JavaDoc", "label": {"api": {"DefaultTableCellRenderer": [[85, 108]]}}}, {"text": "A simple and efficient (performance-wise & code-wise) rule of thumb, is to extend DefaultTableCellRenderer and customize it to your needs", "label": {"api": {"DefaultTableCellRenderer": [[82, 105]]}}}, {"text": "Uses an optimized Object (Modified JLabel in the case of DefaultTableCellRenderer) for drawing, revalidation and repainting", "label": {"api": {"DefaultTableCellRenderer": [[57, 80]]}}}, {"text": "This is what the BlockingQueue is for", "label": {"api": {"BlockingQueue": [[17, 29]]}}}, {"text": "See the Javadocs of javax.activation.MimetypesFileTypeMap", "label": {"api": {"javax.activation.MimetypesFileTypeMap": [[20, 56]]}}}, {"text": "My app uses System.setErr() to change stderr to a stream which will eventually be closed", "label": {"api": {"System.setErr()": [[12, 26]]}}}, {"text": "Immediately after it's closed I immediately use System.setErr() again to change stderr to a working stream, which goes fine for when my code does something like System.err.println(), but logging with java.util.logging  to the console (that is, to stderr) no longer works", "label": {"api": {"System.setErr()": [[48, 62]], "java.util.logging": [[200, 216]]}}}, {"text": "To solve this, I had to re-read the logging configuration file and then put back in the console logging handler myself", "label": {"api": {"re-read the logging configuration file": [[24, 61]], "console logging handler": [[88, 110]]}}}, {"text": "The simplest way (from a code perspective) is to make use of Collections.shuffle(), which shuffles Lists", "label": {"api": {"Collections.shuffle()": [[61, 81]]}}}, {"text": "System.out is just a static reference of type PrintStream, and the docs for PrintStream::println(Object) state", "label": {"api": {"PrintStream::println(Object)": [[76, 103]]}}}, {"text": "Tracing it down, String::valueOf(Object)'s javadoc state", "label": {"api": {"String::valueOf(Object)": [[17, 39]]}}}, {"text": "As an alternative to native code, you could call into ThreadMXBean", "label": {"api": {"ThreadMXBean": [[54, 65]]}}}, {"text": "The returned ThreadInfo objects contain information about Locks held and Locks the thread is waiting for", "label": {"api": {"ThreadInfo": [[13, 22]]}}}, {"text": "You are using the PreparedStatement.setTimestamp(int parameterIndex, Timestamp x) method", "label": {"api": {"PreparedStatement.setTimestamp(int parameterIndex, Timestamp x)": [[18, 80]]}}}, {"text": "To control the time zone, use the PreparedStatement.setTimestamp(int parameterIndex, Timestamp x, Calendar cal) method", "label": {"api": {"PreparedStatement.setTimestamp(int parameterIndex, Timestamp x, Calendar cal)": [[34, 110]]}}}, {"text": "For example, the int primitive type has wrapper class called Integer", "label": {"api": {"Integer": [[61, 67]]}}}, {"text": "HashMap inherits from AbstractMap, and AbstractMap's toString method is documented as follows", "label": {"api": {"AbstractMap": [[22, 32], [39, 49]]}}}, {"text": "The Java NumberFormat will give you what you want, but you can also write your own method", "label": {"api": {"NumberFormat": [[9, 20]]}}}, {"text": "Then, this Stream can be collected with the groupingBy(classifier, downstream) collector", "label": {"api": {"groupingBy(classifier, downstream)": [[44, 77]]}}}, {"text": "You need to use the two argument version of partitioningBy(predicate, downstream), which accepts a downstream collector", "label": {"api": {"partitioningBy(predicate, downstream)": [[44, 80]]}}}, {"text": "Java's string formatting has a built-in syntax for this", "label": {"api": {"string formatting": [[7, 23]]}}}, {"text": "You can use the method ScheduledExecutorService.scheduleAtFixedRate()", "label": {"api": {"ScheduledExecutorService.scheduleAtFixedRate()": [[23, 68]]}}}, {"text": "Unlike the method ScheduledExecutorService.scheduleAtFixedDelay(), this method tries to keep up", "label": {"api": {"ScheduledExecutorService.scheduleAtFixedDelay()": [[18, 64]]}}}, {"text": "The problem is that text.indexOf(String) only \"returns the index within this string of the first occurrence of the specified substring.\"", "label": {"api": {"text.indexOf(String)": [[20, 39]]}}}, {"text": "You could use text.indexOf(String, int), it will also \"start at the specified index", "label": {"api": {"text.indexOf(String, int)": [[14, 38]]}}}, {"text": "In Java 8, you should be using CompletableFuture (or Guava's ListenableFuture) for asynchronous tasks", "label": {"api": {"CompletableFuture": [[31, 47]]}}}, {"text": "You may see computeIfPresent as the single-entry pendant of replaceAll whereas the latter requires the key as a parameter, but it’s natural to support the same function as input to both operations and the API is consistent here", "label": {"api": {"computeIfPresent": [[12, 27]], "replaceAll": [[60, 69]]}}}, {"text": "Refer to the full documentation for the syntax of the String formatter", "label": {"api": {"full documentation": [[13, 30]]}}}, {"text": "Although you should probably avoid the use of multiple JFrames, isDisplayable() is a method you could use for this", "label": {"api": {"isDisplayable()": [[64, 78]]}}}, {"text": "In which case, you can override the compareTo function and sort them", "label": {"api": {"compareTo": [[36, 44]]}}}, {"text": "In this case you can just make use of the Java String's compareTo function", "label": {"api": {"compareTo": [[56, 64]]}}}, {"text": "Collection.retainAll(Collection c) may be what you need", "label": {"api": {"Collection.retainAll(Collection c)": [[0, 33]]}}}, {"text": "You should also note that Date's string constructor is deprecated https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#Date-java.lang.String-", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#Date-java.lang.String-": [[66, 149]]}}}, {"text": "You could do this by extending button and adding additional properties or by making use of the generic userData property that is settable on any node", "label": {"api": {"userData": [[103, 110]]}}}, {"text": "As described in the Javadoc, Image is abstract", "label": {"api": {"described in the Javadoc": [[3, 26]]}}}, {"text": "BufferedImage; however, that does not accept a filename in any of its constructors", "label": {"api": {"BufferedImage": [[0, 12]]}}}, {"text": "You can load an image from a file using ImageIO.read; various overloads exist which take InputStream, File or URL", "label": {"api": {"ImageIO.read": [[40, 51]]}}}, {"text": "Following Eran's answer, I suggest you should iterate the list with Iterator since it eliminate the need for manual indexes and also allows for item removal while iterating the list", "label": {"api": {"Iterator": [[68, 75]]}}}, {"text": "So activate() is a bit like @PostConstruct in JavaEE", "label": {"api": {"@PostConstruct": [[28, 41]]}}}, {"text": "The more modern solution of BlockingQueues is far better suited to inter-thread communications in Java", "label": {"api": {"BlockingQueue": [[28, 40]]}}}, {"text": "I would propose to set a custom handler of type UncaughtExceptionHandler for non-caught exceptions using method Thread.setDefaultUncaughtExceptionHandler", "label": {"api": {"UncaughtExceptionHandler": [[48, 71], [129, 152]], "Thread.setDefaultUncaughtExceptionHandler": [[112, 152]]}}}, {"text": "This is using the Java Linked List", "label": {"api": {"Java Linked List": [[18, 33]]}}}, {"text": "You can use the Desktop API#browse to achieve it", "label": {"api": {"Desktop API#browse": [[16, 33]]}}}, {"text": "I think you're looking for Enum.valueOf(Class, String), which accepts a Class of some type extending Enum and a String", "label": {"api": {"Enum.valueOf(Class, String)": [[27, 53]]}}}, {"text": "I recommend using a ScheduledThreadPoolExecutor with a core pool size of 1 and optionally with a thread priority of Thread.NORM_PRIORITY + 1 (use a ThreadFactoryBuilder to create a ThreadFactory with higher than standard priority) for the UI thread - this will let you schedule tasks such as the counter increment using ScheduledThreadPoolExecutor#scheduleAtFixedRate", "label": {"api": {"ScheduledThreadPoolExecutor": [[20, 46], [320, 346]]}}}, {"text": "From the javadoc of indexOf()", "label": {"api": {"indexOf()": [[20, 28]]}}}, {"text": "invokeAll blocks until all submitted tasks are completed", "label": {"api": {"invokeAll": [[0, 8]]}}}, {"text": "Take a look at Map in Java", "label": {"api": {"Map": [[15, 17]]}}}, {"text": "You might want to look into using an ArrayList (Oracle documentation) (Stack Overflow post), because they don't have a pre-defined size", "label": {"api": {"Oracle documentation": [[48, 67]]}}}, {"text": "This is because SimpleDateFormat happily parses \"2015-11-26\" and ignores the \" - Copy\" part", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "To detect if the whole string has been used, instead use the parse(String source, ParsePosition pos) method", "label": {"api": {"parse(String source, ParsePosition pos)": [[61, 99]]}}}, {"text": "BufferedReader.readLine() returns null if end of file is reached", "label": {"api": {"BufferedReader.readLine()": [[0, 24]]}}}, {"text": "Yo can get controller that is responsible for this fxml by FXMLoader#getController() method ( https://docs.oracle.com/javase/8/javafx/api/javafx/fxml/FXMLLoader.html#getController-- )", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/fxml/FXMLLoader.html#getController--": [[94, 180]]}}}, {"text": "Using splitAsStream can be advantageous over Stream.of(...) if the input String is long", "label": {"api": {"splitAsStream": [[6, 18]]}}}, {"text": "BLOB.createTemporary() works even with Java 1.4.2 (oracle 10); starting 1.6, there's createBlob function in sql.Connection, which should do the same", "label": {"api": {"createBlob": [[85, 94]]}}}, {"text": "You need to pass a FileOutputStream created with the constructor that accepts an append flag", "label": {"api": {"the constructor that accepts an append flag": [[49, 91]]}}}, {"text": "See https://docs.oracle.com/javase/8/docs/api/constant-values.html#javax.xml.stream.XMLStreamConstants.CHARACTERS, it is characters which has the value 4", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/constant-values.html#javax.xml.stream.XMLStreamConstants.CHARACTERS": [[4, 112]]}}}, {"text": "You must then use the methods getResultSet or getUpdateCount to retrieve the result, and getMoreResults to move to any subsequent result(s)", "label": {"api": {"getMoreResults": [[89, 102]]}}}, {"text": "You should use getMoreResults to process the remaining results and find the ResultSet", "label": {"api": {"getMoreResults": [[15, 28]]}}}, {"text": "From the Java-Doc of the setEchoChar() method", "label": {"api": {"setEchoChar()": [[25, 37]]}}}, {"text": "Instead, create a FileTreeModel that  implements TreeModel, as shown here", "label": {"api": {"TreeModel": [[22, 30], [49, 57]]}}}, {"text": "The classloader seems to ignore jar URLs (jar:<url>!/WEB-INF/lib/{entry}.jar)", "label": {"api": {"jar URLs": [[32, 39]]}}}, {"text": "I'm confused about list data-structures (GlueList , ArrayList and LinkedList)", "label": {"api": {"ArrayList": [[52, 60]], "LinkedList": [[66, 75]]}}}, {"text": "For example, calling a default method like Map#putIfAbsent fails to compile (unsupported reference error)", "label": {"api": {"Map#putIfAbsent": [[43, 57]]}}}, {"text": "Instead, use an Alert", "label": {"api": {"Alert": [[16, 20]]}}}, {"text": "List is a typed-interface", "label": {"api": {"List": [[0, 3]]}}}, {"text": "This means our interface is List<T>", "label": {"api": {"List": [[28, 31]]}}}, {"text": "Therefore, the list is List<Entry<S, E>>", "label": {"api": {"List": [[23, 26]]}}}, {"text": "Instead, you will need to parse the namesArray[pos] string (either when you read the file, or in the loop, look at String#split()), pull out the value 380, and compare against that", "label": {"api": {"String#split()": [[115, 128]]}}}, {"text": "You could also do String#contains() if its sufficient to just test for the line to contain 380", "label": {"api": {"String#contains()": [[18, 34]]}}}, {"text": "Do you try to use FileLock tryLock() or lock(), before rename file to .processing", "label": {"api": {"FileLock": [[18, 25]]}}}, {"text": "I want to write an asynchronous method that returns a CompletableFuture", "label": {"api": {"CompletableFuture": [[54, 70]]}}}, {"text": "Would it be better to return CompletableFuture<Void> or CompletableFuture<?>", "label": {"api": {"CompletableFuture": [[29, 45], [56, 72]]}}}, {"text": "CompletableFuture itself returns CompletableFuture<Void> from many of its methods", "label": {"api": {"CompletableFuture": [[0, 16], [33, 49]]}}}, {"text": "java.nio has a Future<Void> in AsynchronousSocketChannel", "label": {"api": {"AsynchronousSocketChannel": [[31, 55]]}}}, {"text": "On the other hand, java.util.concurrent classes like ExecutorService and ScheduledExecutorService return Future<?>", "label": {"api": {"ExecutorService": [[53, 67], [82, 96]], "ScheduledExecutorService": [[73, 96]]}}}, {"text": "According to Official Java Documentation the return element is the element previously at that position", "label": {"api": {"Official Java Documentation": [[13, 39]]}}}, {"text": "Item events are fired by components that implement the ItemSelectable interface", "label": {"api": {"ItemSelectable": [[55, 68]]}}}, {"text": "Generally, ItemSelectable components maintain on/off state for one or more items", "label": {"api": {"ItemSelectable": [[11, 24]]}}}, {"text": "Since a radio button fits this description, ItemListener would be a more suitable listener to use; try that instead", "label": {"api": {"ItemListener": [[44, 55]]}}}, {"text": "You can do that easily with System.arraycopy", "label": {"api": {"System.arraycopy": [[28, 43]]}}}, {"text": "You can use the method mouseMove(int x, int y) of the class java.awt.Robot", "label": {"api": {"java.awt.Robot": [[60, 73]]}}}, {"text": "Use the standard Java Semaphore", "label": {"api": {"Semaphore": [[22, 30]]}}}, {"text": "You can do this with Java's Semaphore as already told by Erik", "label": {"api": {"Semaphore": [[28, 36]]}}}, {"text": "Once you have a Connection to the database, you can get its metadata and extract the version from it with getDatabaseProductVersion()", "label": {"api": {"getDatabaseProductVersion()": [[106, 132]]}}}, {"text": "This works directly off of the Set returned by getKeys", "label": {"api": {"Set": [[31, 33]]}}}, {"text": "This returns a List that can be (among other things) iterated through with a for each loop", "label": {"api": {"List": [[15, 18]]}}}, {"text": "FileInputStream and FileOutputStream handles bytes of data", "label": {"api": {"FileInputStream": [[0, 14]], "FileOutputStream": [[20, 35]]}}}, {"text": "More specifically, read() reads a single byte and write(int) writes a byte", "label": {"api": {"read()": [[19, 24]], "write(int)": [[50, 59]]}}}, {"text": "The Javadoc of OutputStream.write(int) says", "label": {"api": {"write(int)": [[28, 37]], "OutputStream.write(int)": [[15, 37]]}}}, {"text": "I've read the http://docs.oracle.com/javase/8/docs/api/ , (tried to link 'setEnable') among some examples but don't seem to be making the connection", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/": [[14, 54]]}}}, {"text": "Or you can create your own custom Javadoc tags through a class extending Doclet, as described in the Doclet documentation", "label": {"api": {"in the Doclet documentation": [[94, 120]]}}}, {"text": "You may also use the implementation in java.util.Arrays", "label": {"api": {"java.util.Arrays": [[39, 54]]}}}, {"text": "The functionality provided by FileReader is very limited to just reading the chars from the defined stream", "label": {"api": {"FileReader": [[30, 39]]}}}, {"text": "The Scanner provide reliable and easy to use implementations for reading and parsing the streams (files), saves a lot of time in development", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "Use Collections#max(Collection, Comparator), and pass appropriate Comparator as second argument", "label": {"api": {"Collections#max(Collection, Comparator)": [[4, 42]]}}}, {"text": "to fill you array (or a part of it), with the same value, you can use the built-in Arrays.fill() utility", "label": {"api": {"Arrays.fill()": [[83, 95]]}}}, {"text": "using CyclicBarrier) you can't control the scheduling so they would progress differently", "label": {"api": {"CyclicBarrier": [[6, 18]]}}}, {"text": "You can sort a List instance with Collections.sort(yourList) - you now have a sorted collection that can also contain duplicate values", "label": {"api": {"List": [[15, 18], [55, 58]], "Collections.sort(yourList)": [[34, 59]]}}}, {"text": "You can remove the KeyListeners from the JList", "label": {"api": {"KeyListeners": [[19, 30]]}}}, {"text": "Note that your old-style iterator-loop could be rewritten in Java-8 using Collection.removeIf", "label": {"api": {"Collection.removeIf": [[74, 92]]}}}, {"text": "Just modify the ObservableList returned by Pane.getChildren()", "label": {"api": {"Pane.getChildren()": [[43, 60]]}}}, {"text": "There is a getLastAccessedTime() on the session object, that might help", "label": {"api": {"getLastAccessedTime()": [[11, 31]]}}}, {"text": "Sounds to me like you are looking for a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[40, 63]]}}}, {"text": "You could simply use Platform.runLater to make changes to the ui from a non-ui thread you start or use Task, that is designed to do a job like this", "label": {"api": {"Task": [[103, 106]]}}}, {"text": "When you write to your file, you seem not to be using flush", "label": {"api": {"flush": [[54, 58]]}}}, {"text": "The only method you should override is read()", "label": {"api": {"read()": [[39, 44]]}}}, {"text": "Use one of the JDK 7 Files.copy methods", "label": {"api": {"Files.copy": [[21, 30]]}}}, {"text": "Alternatively you could use one of the methods in the Files class, for example", "label": {"api": {"the Files class": [[50, 64]]}}}, {"text": "The intern mechanism is purely specified in high-level terms, in the JavaDoc for String#intern and v", "label": {"api": {"String#intern": [[81, 93]]}}}, {"text": "If you can load java class in your application \"on the fly\", then try to use following method LogManager.reset() or LogManager.readConfiguration()", "label": {"api": {"LogManager.reset()": [[94, 111]], "LogManager.readConfiguration()": [[116, 145]]}}}, {"text": "It is explained in details in the javadoc of ThreadPoolExecutor - extract", "label": {"api": {"ThreadPoolExecutor": [[45, 62]]}}}, {"text": "Set a timeout on the ServerSocket via ServerSocket#setSoTimeout(int)", "label": {"api": {"ServerSocket#setSoTimeout(int)": [[38, 67]]}}}, {"text": "Close the ServerSocket via ServerSocket#close() from a different thread", "label": {"api": {"ServerSocket#close()": [[27, 46]]}}}, {"text": "Have a look at the Integer.parseInt(x) method:http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String)": [[46, 135]]}}}, {"text": "There are convenience methods to help avoid inadvertent overflows, like Math.addExact(), but these wouldn't normally be used in a loop", "label": {"api": {"Math.addExact()": [[72, 86]]}}}, {"text": "In this case you can use ProcessBuilder", "label": {"api": {"ProcessBuilder": [[25, 38]]}}}, {"text": "If you want case insensitive search, convert both the input and the search words to lowercase", "label": {"api": {"lowercase": [[84, 92]]}}}, {"text": "If you don't want to count words twice, replace the indexOf and the while loop with a simple contains", "label": {"api": {"contains": [[93, 100]]}}}, {"text": "You can also simply use string replace / replaceAll methods to achieve your result", "label": {"api": {"replace": [[31, 37], [41, 47]], "replaceAll": [[41, 50]]}}}, {"text": "The easiest way to do that would probably be to extend Spliterators.AbstractIntSpliterator (note that this supplier returns the digits from the last digit to the first", "label": {"api": {"Spliterators.AbstractIntSpliterator": [[55, 89]]}}}, {"text": "Here is the solution you asked for, using ListIterator", "label": {"api": {"ListIterator": [[42, 53]]}}}, {"text": "I had to use the JavaFX's FileChooser and I saw that the method showOpenMultipleDialog would return null when no File are selected", "label": {"api": {"JavaFX's FileChooser": [[17, 36]]}}}, {"text": "The method DateTimeFormatter.withZone does not change the date/time", "label": {"api": {"DateTimeFormatter.withZone": [[11, 36]]}}}, {"text": "Setting a timezone with a specific ZoneId or ZoneOffset (using atZone to create a ZonedDateTime), you get the same date/time but in a different time zone (so it is a different instant in time)", "label": {"api": {"atZone": [[63, 68]]}}}, {"text": "Instead, you should construct the LocalDateTime by specifying the ZoneId or ZoneOffset using LocalDateTime.now(ZoneId)", "label": {"api": {"LocalDateTime.now(ZoneId)": [[93, 117]]}}}, {"text": "See also the JavaDoc of DoubleBinding", "label": {"api": {"DoubleBinding": [[24, 36]]}}}, {"text": "This is documented in NumberExpression Javadoc", "label": {"api": {"NumberExpression": [[22, 37]]}}}, {"text": "You could start a new Thread in which you're controlling your dot", "label": {"api": {"Thread": [[22, 27]]}}}, {"text": "However, after logging via the Java app, you should be able to use the JNLP Persistence APIs, if that helps", "label": {"api": {"JNLP Persistence APIs": [[71, 91]]}}}, {"text": "You can switch to PrintWriter class instead of BufferedWriter as it provides println(String str) method which can be used write a string and a newline character", "label": {"api": {"PrintWriter": [[18, 28]]}}}, {"text": "javax.xml.bind.DatatypeConverter is a strange choice for generating base64 represenation of your binary data", "label": {"api": {"javax.xml.bind.DatatypeConverter": [[0, 31]]}}}, {"text": "You can add the Bouncycastle provider to your project and make certain you have registered the provider with the Security class prior to calling Cipher.getInstance()", "label": {"api": {"Security": [[113, 120]]}}}, {"text": "If they are equal, I'd conclude you're not having a standard HashMap, but some other map implementation that bases on object identity, like IdentityHashMap", "label": {"api": {"IdentityHashMap": [[140, 154]]}}}, {"text": "Finally, you could also replace the private Object result; with a java.util.concurrent.CompletableFuture", "label": {"api": {"java.util.concurrent.CompletableFuture": [[66, 103]]}}}, {"text": "For that, use ExecutorService, usually created by a call to Executors, e.g.", "label": {"api": {"ExecutorService": [[14, 28]], "Executors": [[60, 68]]}}}, {"text": "Alternatively, the library/framework/technique that you use for sending the request and returning the result might already give you something like a Future or accept something like a callback (e.g", "label": {"api": {"Future": [[149, 154]]}}}, {"text": "Use StringBuilder to make a new string from the old one character-by-character", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "If you use an IntPredicate instead — which uses an int primitive as its input, and thus avoids the boxing — you'll find that the difference between the direct and lambda-based approach is virtually gone", "label": {"api": {"IntPredicate": [[14, 25]]}}}, {"text": "Create an ImageIcon", "label": {"api": {"ImageIcon": [[10, 18]]}}}, {"text": "Create a JLabel and pass the ImageIcon as a parameter", "label": {"api": {"ImageIcon": [[29, 37]], "JLabel": [[9, 14]]}}}, {"text": "Add the JLabel to the JPanel (or any other swing component)", "label": {"api": {"JLabel": [[8, 13]]}}}, {"text": "For more info about fxml features refer to Introduction to FXML", "label": {"api": {"Introduction to FXML": [[43, 62]]}}}, {"text": "A simplified approach would just start a thread and update UI via SwingUtilities.invokeLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[66, 93]]}}}, {"text": "In OpenJDK, println's body is synchronized altough the API does not state that it is", "label": {"api": {"API": [[55, 57]]}}}, {"text": "Use a BufferedReader to make your life easier", "label": {"api": {"BufferedReader": [[6, 19]]}}}, {"text": "There are more in the ServletRequest class and the HttpServletRequest (ref) - the class of the parameter that gets passed to the servlet service methods", "label": {"api": {"ref": [[71, 73]]}}}, {"text": "Clearly, from NotSerializableException Docs you get this exception, when your class has to implement this interface, and you didn't", "label": {"api": {"NotSerializableException Docs": [[14, 42]]}}}, {"text": "Secondly, MarshallException has a clear explanation in the Docs with possible reasons", "label": {"api": {"MarshallException": [[10, 26]]}}}, {"text": "Your initial implementation breaks the general contract for Comparators by not dealing correctly (i.e., returning 0) when the two types are equal", "label": {"api": {"Comparator": [[60, 69]]}}}, {"text": "Instead of trying to implement the comparison logic between two integers by yourself, why not let Integer do what it knows best", "label": {"api": {"what it knows best": [[109, 126]]}}}, {"text": "E set(int index, E element) method replaces element of specific index", "label": {"api": {"E set(int index, E element)": [[0, 26]]}}}]