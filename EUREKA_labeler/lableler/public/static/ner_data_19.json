[{"text": "The data structure appropriate to your task is Map", "label": {"api": {"Map": [[47, 49]]}}}, {"text": "See this javadoc for more information", "label": {"api": {"this javadoc": [[4, 15]]}}}, {"text": "As of Java 7 there's a more convenient method in java.nio.Files anyway", "label": {"api": {"java.nio.Files": [[49, 62]]}}}, {"text": "From the documentation for the Statement#close() method (PreparedStatement is a child of Statement)", "label": {"api": {"Statement#close()": [[31, 47]]}}}, {"text": "As described in load JavaDoc", "label": {"api": {"load": [[16, 19]]}}}, {"text": "You need to use \"\\\\\\\\s+\" instead of \"\\\\s+\", since \\ is the escape character in the regex replacement string syntax", "label": {"api": {"regex replacement string syntax": [[83, 113]]}}}, {"text": "Note that \\ just happens to be used as escape character in regex replacement string syntax in Java", "label": {"api": {"regex replacement string syntax": [[59, 89]]}}}, {"text": "If you are replacing a match with literal text, you can use Matcher.quoteReplacement to avoid dealing with the escaping in regex replacement string", "label": {"api": {"Matcher.quoteReplacement": [[60, 83]]}}}, {"text": "In this case, since you are searching for string and replace it with another string, you can use String.replace instead, which does normal string replacement", "label": {"api": {"String.replace": [[97, 110]]}}}, {"text": "You won't be able to do that easily using a Runnable", "label": {"api": {"Runnable": [[44, 51]]}}}, {"text": "You should use a Callable instead, quoting its Javadoc", "label": {"api": {"Callable": [[17, 24]]}}}, {"text": "You should use an ExecutorService and submit the Callable to it", "label": {"api": {"Callable": [[49, 56]]}}}, {"text": "It creates a Callable<Integer> holding the task returning the number of apples", "label": {"api": {"Callable": [[13, 20]]}}}, {"text": "You are using System.in.read() to read user input and it is wrong", "label": {"api": {"System.in.read()": [[14, 29]]}}}, {"text": "If you have the 32-bit IEEE-754 representation of a float in an int, you can convert back to float using Float.intBitsToFloat", "label": {"api": {"Float.intBitsToFloat": [[105, 124]]}}}, {"text": "For instance ConcurrentHashMap which will use (a function performed on) the hashcode to assign a location to an object in the map", "label": {"api": {"ConcurrentHashMap": [[13, 29]]}}}, {"text": "As you may already know, normally paint(Graphics) only get's called by the RepaintManager, which is responsible for repainting", "label": {"api": {"RepaintManager": [[75, 88]]}}}, {"text": "If RepaintManager or Component wouldn't call setClip(), getClip() would indeed return null", "label": {"api": {"RepaintManager": [[3, 16]]}}}, {"text": "You can view the full source code of RepaintManager here", "label": {"api": {"RepaintManager": [[37, 50]]}}}, {"text": "You can do that by creating a temporary file with help of File#createTempFile() in container managed temporary folder, writing the contents to it and finally provide the temp file as URI", "label": {"api": {"File#createTempFile()": [[58, 78]]}}}, {"text": "setOnMouseReleased you get a MouseEvent and on that one you have functions to check if certain keys are pressed that are usually combined with a mouse click", "label": {"api": {"MouseEvent": [[29, 38]]}}}, {"text": "See the JavaDoc for MouseEvent", "label": {"api": {"MouseEvent": [[20, 29]]}}}, {"text": "See the Node Javadoc on the different possible node types", "label": {"api": {"the Node Javadoc": [[4, 19]]}}}, {"text": "When you print a node's getTextContent it prints the node and its children, as per the Javadoc", "label": {"api": {"per the Javadoc": [[79, 93]]}}}, {"text": "I recommend to find the index of these spaces and use substring()", "label": {"api": {"substring()": [[54, 64]]}}}, {"text": "This is much simpler using String.endsWith()", "label": {"api": {"String.endsWith()": [[27, 43]]}}}, {"text": "You can use substring method of String", "label": {"api": {"substring": [[12, 20]]}}}, {"text": "You can also use endsWith method to check the last character of a string", "label": {"api": {"endsWith": [[17, 24]]}}}, {"text": "The idea is to use Graphics2D.draw(Shape) and use a Double precision shape, one of these, to represent a point", "label": {"api": {"these": [[83, 87]]}}}, {"text": "The documentation on java.nio.Files#createTempFile says", "label": {"api": {"java.nio.Files#createTempFile": [[21, 49]]}}}, {"text": "Read the Swing documentation", "label": {"api": {"Swing documentation": [[9, 27]]}}}, {"text": "You could write the data you've received into a ByteArrayOutputStream rather than a FileOutputStream, and then take the resulting byte array and write that to a FileOutputStream at a later time", "label": {"api": {"ByteArrayOutputStream": [[48, 68]]}}}, {"text": "Use the longValue() method of java.math.BigDecimal to loop through the array and convert each number you have received from the database to a long type", "label": {"api": {"longValue()": [[8, 18]]}}}, {"text": "I belive that a Scanner is what your looking for", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "string.split should accept regex as a parameter", "label": {"api": {"string.split": [[0, 11]]}}}, {"text": "If you use Executors.newScheduledThreadPool then you are effectively using a ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[77, 103]]}}}, {"text": "Use a FileChannel; it allows random access to any part of a file, in read, write or any combination of both", "label": {"api": {"FileChannel": [[6, 16]]}}}, {"text": "Use the built-in Security Manager functionality", "label": {"api": {"Security Manager": [[17, 32]]}}}, {"text": "You can, however, use the Set#containsAll(Collection<?>) method", "label": {"api": {"Set#containsAll(Collection<?>)": [[26, 55]]}}}, {"text": "If that is the case you can use the Java 8 computeIfAbsent which will only call a lambda to create the object if there is nothing associated with the key", "label": {"api": {"computeIfAbsent": [[43, 57]]}}}, {"text": "In order to make CounterObject safe without locking, you can look into classes such as AtomicInteger which can do many simple operations without locking", "label": {"api": {"AtomicInteger": [[87, 99]]}}}, {"text": "How do I list the files inside a JAR file?, specifically, using a FileSystem API since Java 7", "label": {"api": {"FileSystem": [[66, 75]]}}}, {"text": "Therefore, the best Solution would be to get the html page encoding with InputStreamReader.getEncoding()", "label": {"api": {"InputStreamReader.getEncoding()": [[73, 103]]}}}, {"text": "You can also supply index hints with Sybase, and JPA also defines a portable API for giving index hints to the database", "label": {"api": {"portable API for giving index hints": [[68, 102]]}}}, {"text": "You can remove underscores within the same Beanshell assertion using String.replaceAll() method like", "label": {"api": {"String.replaceAll()": [[69, 87]]}}}, {"text": "The try-with-resources try (DECLARATIONS) {  ..", "label": {"api": {"try-with-resources": [[4, 21]]}}}, {"text": "Get the index, and get the object", "label": {"api": {"get": [[19, 21]]}}}, {"text": "Using get and indexOf", "label": {"api": {"get": [[6, 8]], "indexOf": [[14, 20]]}}}, {"text": "You might want to do some error checking here, to catch the classic ArrayIndexOutOfBoundsException in case the list.indexOf method returns -1 because the font is missing", "label": {"api": {"indexOf": [[116, 122]]}}}, {"text": "GridLayout divides its space equally amongst all of its compoenents", "label": {"api": {"GridLayout": [[0, 9]]}}}, {"text": "The GridLayout class is a layout manager that lays out a container's components in a rectangular grid", "label": {"api": {"GridLayout": [[4, 13]]}}}, {"text": "Here I'll be using composite layouts by nesting the GridLayout inside a BorderLayout in the CENTER position and the convert button is in the PAGE_END position", "label": {"api": {"GridLayout": [[52, 61]]}}}, {"text": "The java.text.MessageFormat.format(pattern, argument…) function is designed just for this purpose", "label": {"api": {"java.text.MessageFormat.format(pattern, argument…)": [[4, 53]]}}}, {"text": "Deque has stack methods push() and pop(), implemented to be same as addFirst() and removeFirst()", "label": {"api": {"Deque": [[0, 4]]}}}, {"text": "BTW, String.matches try to match entire string, so ^, $ anchors are not necessary", "label": {"api": {"String.matches": [[5, 18]]}}}, {"text": "You can just use Files.find()", "label": {"api": {"Files.find()": [[17, 28]]}}}, {"text": "See also the javadoc of BiPredicate and BasicFileAttributes; in particular, BiPredicate has a .and() method which you will find useful in your situation", "label": {"api": {"BiPredicate": [[24, 34], [76, 86]], "BasicFileAttributes": [[40, 58]]}}}, {"text": "A JMenu is the menu itself, or as the documentation states", "label": {"api": {"JMenu": [[2, 6]]}}}, {"text": "An implementation of a menu -- a popup window containing JMenuItems that is displayed when the user selects an item on the JMenuBar", "label": {"api": {"JMenu": [[57, 61], [123, 127]], "JMenuItem": [[57, 65]]}}}, {"text": "A JMenuItem is a single item in such a menu", "label": {"api": {"JMenu": [[2, 6]], "JMenuItem": [[2, 10]]}}}, {"text": "a Statement doesn't have an execute() method", "label": {"api": {"Statement": [[2, 10]]}}}, {"text": "PreparedStatement, on the other hand, does", "label": {"api": {"Statement": [[8, 16]], "PreparedStatement": [[0, 16]]}}}, {"text": "Your statement varaible is in fact a PreparedStatement (in runtime), but you're storing it in a Statement variable, so the code won't compile", "label": {"api": {"Statement": [[45, 53], [96, 104]], "PreparedStatement": [[37, 53]]}}}, {"text": "Just store it in a PreparedStatement, and you should be OK", "label": {"api": {"Statement": [[27, 35]], "PreparedStatement": [[19, 35]]}}}, {"text": "Assuming this is actually critical-path in your code, then the one that performs fewer operations is likely to be faster, but if you can reuse a Pattern that should be even faster", "label": {"api": {"Pattern": [[145, 151]]}}}, {"text": "If you are using a J2EE compliant platform, you may use the javax.ws.rs.core.UriBuilder class to build your URI", "label": {"api": {"javax.ws.rs.core.UriBuilder": [[60, 86]]}}}, {"text": "The set method on a List requires that there already be an element at the index before the set is called for that index", "label": {"api": {"there already be an element at the index before the set is called for that index": [[39, 118]]}}}, {"text": "The more appropriate method to use would be add", "label": {"api": {"add": [[44, 46]]}}}, {"text": "Try closing the buffers", "label": {"api": {"closing": [[4, 10]]}}}, {"text": "Add a listener to the locationProperty() of the WebView's WebEngine and, within the listener, check if the new location matches your blacklist", "label": {"api": {"locationProperty()": [[22, 39]]}}}, {"text": "How about a ScheduledExecutorService instead of a Timer", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "You can actually do the same thing with a Timer rather than a ScheduledExecutorService, but the wonderful book \"Java Concurrency in Practice\" recommends the use of ScheduledExecutorService over Timer for a number of reasons, including for example, better handling if an exception is thrown from the task and a more flexible api", "label": {"api": {"ScheduledExecutorService": [[62, 85], [164, 187]]}}}, {"text": "Try abs() which takes a number of any type as a parameter and returns the absolute value of it, in the same type", "label": {"api": {"abs()": [[4, 8]]}}}, {"text": "There is a new Base64 class for this in Java 8", "label": {"api": {"Base64": [[15, 20]]}}}, {"text": "Does this class works for you , MediaSizeName", "label": {"api": {"MediaSizeName": [[32, 44]]}}}, {"text": "calXml.YEAR should be written Calendar.YEAR, because it is a constant (public static final) value to be used as a parameter to methods like get(int field) and add(int field, int amount)", "label": {"api": {"Calendar.YEAR": [[30, 42]], "get(int field)": [[140, 153]], "add(int field, int amount)": [[159, 184]]}}}, {"text": "To get the year, call calXml.get(Calendar.YEAR)", "label": {"api": {"Calendar.YEAR": [[33, 45]]}}}, {"text": "Also consider an AttributedString in your own JComponent, illustrated here and here", "label": {"api": {"AttributedString": [[17, 32]]}}}, {"text": "JLayeredPane has both a \"Layer\" and a \"Position\" concepts", "label": {"api": {"JLayeredPane": [[0, 11]]}}}, {"text": "The JLayeredPane methods moveToFront, moveToBack and setPosition can be used to re-position a component within its layer", "label": {"api": {"JLayeredPane": [[4, 15]], "moveToFront": [[25, 35]], "moveToBack": [[38, 47]], "setPosition": [[53, 63]]}}}, {"text": "If your TableModel extends AbstractTableModel, you can use getTableModelListeners() to identify the listening JTable", "label": {"api": {"AbstractTableModel": [[27, 44]]}}}, {"text": "Use a regular expression", "label": {"api": {"regular expression": [[6, 23]]}}}, {"text": "See the Javadoc for Thread.getId()", "label": {"api": {"Javadoc for Thread.getId()": [[8, 33]]}}}, {"text": "To satisfy the rule in your case, use AtomicBoolean", "label": {"api": {"AtomicBoolean": [[38, 50]]}}}, {"text": "they both are subclasses of AbstractSet", "label": {"api": {"AbstractSet": [[28, 38]]}}}, {"text": "If you don't tell it otherwise, your JFrame will have BorderLayout like this", "label": {"api": {"BorderLayout": [[54, 65]]}}}, {"text": "You may need to create a custom PropertyEditor and bind it using registerCustomEditor to do this", "label": {"api": {"PropertyEditor": [[32, 45]]}}}, {"text": "In Java 8, the removeIf method was added to Collection", "label": {"api": {"removeIf": [[15, 22]]}}}, {"text": "If your code is compiling successfully, then that means that Guava version 12.0 or higher is available on your compilation classpath at build time, but since version 11.0.2 is supplied at runtime by Hadoop, the method doesn't exist, resulting in NoSuchMethodError", "label": {"api": {"NoSuchMethodError": [[246, 262]]}}}, {"text": "Instead of mapping a jersey servlet in web.xml, you could configure your REST endpoint using Java code using standard Java EE 7 API (Application and @ApplicaionPath", "label": {"api": {"Application": [[133, 143]], "@ApplicaionPath": [[149, 163]]}}}, {"text": "Instead of extending UnicastRemoteObject, call its static method on your object", "label": {"api": {"UnicastRemoteObject": [[21, 39]]}}}, {"text": "The UnicastRemoteObject's API lists 6 ways to export an object", "label": {"api": {"UnicastRemoteObject": [[4, 22]]}}}, {"text": "3 involve subclassing UnicastRemoteObject and the other 3 involve calling exportObject (but 1 of the 3 is deprecated, so I listed the 2 above)", "label": {"api": {"UnicastRemoteObject": [[22, 40]]}}}, {"text": "The answer is simple, all you want to run in another thread must be called in method run()", "label": {"api": {"run()": [[85, 89]]}}}, {"text": "If you are using java 8, you can take advantage of the new merge method", "label": {"api": {"merge": [[59, 63]]}}}, {"text": "You could also use your custom class and customize the ListCells displayed in the ListView using the cellFactory, but if only Strings should be displayed, the default cellFactory and a ListView<String> should suffice", "label": {"api": {"cellFactory": [[101, 111], [167, 177]]}}}, {"text": "The way to go would be to add an KeyListener to your user interface", "label": {"api": {"KeyListener": [[33, 43]]}}}, {"text": "I know we can create a HashMap in Java", "label": {"api": {"HashMap": [[23, 29]]}}}, {"text": "But I want to create a HashMap in C# for my ASP.NET MVC project", "label": {"api": {"HashMap": [[23, 29]]}}}, {"text": "In Java we can create a HashMap like this", "label": {"api": {"HashMap": [[24, 30]]}}}, {"text": "Depending on the framework you are using, you may need to register a shutdown hook to close your application in a clean way", "label": {"api": {"shutdown hook": [[69, 81]]}}}, {"text": "It's also stated in the Hastable spec", "label": {"api": {"Hastable spec": [[24, 36]]}}}, {"text": "I have an approximate concurrent bounded queue written in Java - it is intended to mimic the behavior of a LinkedBlockingQueue except that a", "label": {"api": {"LinkedBlockingQueue": [[107, 125]]}}}, {"text": "According to this https://docs.oracle.com/javase/7/docs/api/java/awt/GridLayout.html it is a matter of ComponentOrientation", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/awt/GridLayout.html": [[18, 83]]}}}, {"text": "You can inject ResourceInfo, then get the Method with ri.getResourceMethod(), then call method.getAnnotations() to get the annotations", "label": {"api": {"ResourceInfo": [[15, 26]]}}}, {"text": "It seems what you're looking for is ScheduledExecutorService#scheduleAtFixedRate()", "label": {"api": {"ScheduledExecutorService#scheduleAtFixedRate()": [[36, 81]]}}}, {"text": "My suggestion would be to use the MessageDigest class to create your hash..", "label": {"api": {"MessageDigest": [[34, 46]]}}}, {"text": "You could use the Watch Service", "label": {"api": {"Watch Service": [[18, 30]]}}}, {"text": "I am working on HTML+CSS+Javascript with a Java team using the JavaFX WebView renderer", "label": {"api": {"JavaFX WebView": [[63, 76]]}}}, {"text": "You can ask them to include some string in the userAgent property of the WebEngine", "label": {"api": {"userAgent": [[47, 55]]}}}, {"text": "You can check this property from javascript (window.navigator.userAgent), e.g.", "label": {"api": {"userAgent": [[62, 70]]}}}, {"text": "Depending on your updates/reads ratio and the contention for the data, it may be useful to use ReadWriteLock instead of synchronized", "label": {"api": {"ReadWriteLock": [[95, 107]]}}}, {"text": "Like it is done in CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[19, 38]]}}}, {"text": "Since the user needs to select boy or girl, why not use a ChoiceBox for that, or better yet, a RadioButton", "label": {"api": {"ChoiceBox": [[58, 66]], "RadioButton": [[95, 105]]}}}, {"text": "Have the user select the choice they want, then perhaps have a Button for them to click to submit or have the ChoiceBox or RadioButton listen for changes by calling", "label": {"api": {"ChoiceBox": [[110, 118]], "RadioButton": [[123, 133]]}}}, {"text": "Transfer data between C and Java through direct byte buffers", "label": {"api": {"direct byte buffers": [[41, 59]]}}}, {"text": "For two processes talking to each other, you could use a memory mapped file to do this (you would use a MappedByteBuffer for this)", "label": {"api": {"MappedByteBuffer": [[104, 119]]}}}, {"text": "Stream#map() is a typed method, so you can explicitly specify the type", "label": {"api": {"Stream#map()": [[0, 11]]}}}, {"text": "Why not use pocessbuilder api", "label": {"api": {"pocessbuilder": [[12, 24]]}}}, {"text": "According to the JavaDoc for Future#get() (https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get%28%29)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get%28%29": [[43, 126]]}}}, {"text": "A ThreadPoolExecutor with a fixed size threads in a pool is the backbone", "label": {"api": {"ThreadPoolExecutor": [[2, 19]]}}}, {"text": "For each word, check if it is an e-mail address via the InternetAddress constructor", "label": {"api": {"InternetAddress": [[56, 70]]}}}, {"text": "I expect that setLayoutX internally calls setNeedsLayout", "label": {"api": {"setNeedsLayout": [[42, 55]]}}}, {"text": "Or you might use the Instrumentation API to add logging to classes as they are loaded", "label": {"api": {"Instrumentation API": [[21, 39]]}}}, {"text": "A possible solution is to use a SwingWorker object", "label": {"api": {"SwingWorker": [[32, 42]]}}}, {"text": "This means that you should use setEnable(false) on components that are no longer active (and setEnable(true) in SwingWorker.done())", "label": {"api": {"SwingWorker": [[112, 122]]}}}, {"text": "However this will be ignored by your MouseListener (see setEnabled)", "label": {"api": {"setEnabled)": [[56, 66]]}}}, {"text": "If you have defined a custom collection and want to be able to generate a stream from it then the simplest approach is to implement a Spliterator", "label": {"api": {"Spliterator": [[134, 144]]}}}, {"text": "You can also convert an Iterable into a Spliterator using the default spliterator method", "label": {"api": {"Spliterator": [[40, 50]]}}}, {"text": "You can use probeContentType(Path path) for this", "label": {"api": {"probeContentType(Path path)": [[12, 38]]}}}, {"text": "You could use ConcurrentSkipListSet instead of HashSet to make it threadsafe", "label": {"api": {"ConcurrentSkipListSet": [[14, 34]]}}}, {"text": "However, you could use java.nio.Files.copy to copy the InputStream to a temporary file and then get UCanAccess to open that", "label": {"api": {"java.nio.Files.copy": [[23, 41]]}}}, {"text": "The HashSet provides an explicit iterator through which you can remove the elements", "label": {"api": {"iterator": [[33, 40]]}}}, {"text": "I want to make a subclass of URLClassLoader which, when loadClass() is invoked, can examine the loaded class with reflection and conditionally decide to pretend it couldn't find that class, so as to allow for a child class loader to handle the loading instead", "label": {"api": {"URLClassLoader": [[29, 42]], "loadClass()": [[56, 66]]}}}, {"text": "You could use String's format method like", "label": {"api": {"format": [[23, 28]]}}}, {"text": "You could also use JDK's standard RunnableFuture like this", "label": {"api": {"RunnableFuture": [[34, 47]]}}}, {"text": "The most reliable, platform-independent way to join paths in Java is by using Path::resolve (as noted in the JavaDoc for Paths::get)", "label": {"api": {"Paths::get": [[121, 130]]}}}, {"text": "I want to wrap ConcurrentSkipListSet to keep a fixed capacity of the latest (according to Comparator) values", "label": {"api": {"ConcurrentSkipListSet": [[15, 35]], "Comparator": [[90, 99]]}}}, {"text": "How to wrap ConcurrentSkipListSet to keep a fixed capacity of the latest values in a thread-safe way", "label": {"api": {"ConcurrentSkipListSet": [[12, 32]]}}}, {"text": "You should try calling refreshTable by using SwingUtilities utility methods, eg", "label": {"api": {"SwingUtilities": [[45, 58]]}}}, {"text": "You need to use list.size()  instead", "label": {"api": {"size()": [[21, 26]]}}}, {"text": "After you connect to a remote VM, you can check whether it allows to  add methods or redefine classes", "label": {"api": {"add methods": [[70, 80]], "redefine classes": [[85, 100]]}}}, {"text": "As @Mike Mnomonic said in the comments, ConcurrentHashMap is a thread-safe map with a tunable concurrency level", "label": {"api": {"ConcurrentHashMap": [[40, 56]]}}}, {"text": "As with other hash maps, ConcurrentHashMap has a backing array; this backing array is split into several sub-arrays depending on your specified concurrency level (default 16) with one lock per sub-array, for example if you have a capacity of 128 and are using the default concurrency level of 16 then sub-array [0,8) has its own lock, [8, 16) has its own lock, [16, 24) has its own lock, and so forth, so two threads can write to two different sub-arrays without blocking each other", "label": {"api": {"ConcurrentHashMap": [[25, 41]]}}}, {"text": "If writes are very infrequent then you may get better performance with an ImmutableMap wrapped in an AtomicReference", "label": {"api": {"AtomicReference": [[101, 115]]}}}, {"text": "The naive approaches I could think of would be to make a StringBuilder or use a template engine like FreeMarker or Velocity, but this does not guarantee validity of the generated code since none of these approaches know what is valid java syntax", "label": {"api": {"StringBuilder": [[57, 69]]}}}, {"text": "You could annotate the string with javax.persistence.Lob", "label": {"api": {"Lob": [[53, 55]]}}}, {"text": "See Lob Javadoc", "label": {"api": {"Lob": [[4, 6]]}}}, {"text": "Portable applications should use the Lob annotation when mapping to a database Lob type", "label": {"api": {"Lob": [[37, 39], [79, 81]]}}}, {"text": "The Lob annotation may be used in conjunction with the Basic annotation or the ElementCollection annotation when the element collection value is of basic type", "label": {"api": {"Lob": [[4, 6]]}}}, {"text": "A Lob may be either a binary or character type", "label": {"api": {"Lob": [[2, 4]]}}}, {"text": "The Lob type is inferred from the type of the persistent field or property, and except for string and character-based types defaults to Blob", "label": {"api": {"Lob": [[4, 6]]}}}, {"text": "Additionally, you could also use @PrePersist to serialise Bar into its string form if you needed to do this immediately prior to persisting", "label": {"api": {"@PrePersist": [[33, 43]]}}}, {"text": "This refers to this document, in particular this sentence", "label": {"api": {"this document": [[15, 27]]}}}, {"text": "See the documentation for ByteBuffer for more information, particularly the getInt method", "label": {"api": {"documentation for ByteBuffer": [[8, 35]], "getInt": [[76, 81]]}}}, {"text": "Here invoking write(temp) writes the character with the temp code to the output", "label": {"api": {"write(temp)": [[14, 24]]}}}, {"text": "This is perfectly possible when using a Java agent in combination with Byte Buddy", "label": {"api": {"Java agent": [[40, 49]]}}}, {"text": "For example, you can modify the GpioFactory::getInstance method as demonstrated by the following Java agent", "label": {"api": {"Java agent": [[97, 106]]}}}, {"text": "If you do not have the possibility to add a Java agent at startup, on JDKs (not standard JVMs), you can use ByteBuddyAgent.install() (from the byte-buddy-agent dependency) to manually install an agent at runtime", "label": {"api": {"Java agent": [[44, 53]]}}}, {"text": "Finally, note that AspectJ and Byte Buddy both use a Java agent to achieve their instrumentation", "label": {"api": {"Java agent": [[53, 62]]}}}, {"text": "Neither time nor space complexity appears to be documented in the Javadoc for Stack.search", "label": {"api": {"Stack.search": [[78, 89]]}}}, {"text": "Of course, that can be done in Java, for instance using System.nanoTime() for precise timing", "label": {"api": {"System.nanoTime()": [[56, 72]]}}}, {"text": "Maps have a method called keyset which returns all the keys to the map as a set", "label": {"api": {"keyset": [[26, 31]]}}}, {"text": "The .substring() method is returning a new String object, it does not modify the StringBuilder itself", "label": {"api": {".substring()": [[4, 15]]}}}, {"text": "One way of doing this is converting the long to a String and parsing it using a SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[80, 95]]}}}, {"text": "For non-primitive user has to tell Java on how to know whether two objects are same or not and way is to override equals and hashcode methods which are invoked by Set#add method to determine the object being added already exists in the set or not", "label": {"api": {"Set#add": [[163, 169]]}}}, {"text": "So your boundFinder method does this (assuming you're using Java's built-in binarySearch method)", "label": {"api": {"binarySearch": [[76, 87]]}}}, {"text": "This can be achieved with the SystemTray and TrayIcon classes", "label": {"api": {"SystemTray": [[30, 39]], "TrayIcon": [[45, 52]]}}}, {"text": "Classic example for using the BitSet class", "label": {"api": {"BitSet": [[30, 35]]}}}, {"text": "In complexity terms, BitSet uses ~1 bit for each boolean value, which is way better than using big array of Boolean objects", "label": {"api": {"BitSet": [[21, 26]]}}}, {"text": "If your goal is to represent a number with exactly n significant figures to the right of the decimal, BigDecimal is the class to use", "label": {"api": {"BigDecimal": [[102, 111]]}}}, {"text": "A BigDecimal consists of an arbitrary precision integer unscaled value and a 32-bit integer scale", "label": {"api": {"BigDecimal": [[2, 11]]}}}, {"text": "The value of the number represented by the BigDecimal is therefore (unscaledValue × 10-scale)", "label": {"api": {"BigDecimal": [[43, 52]]}}}, {"text": "You may use a PrintWriter", "label": {"api": {"PrintWriter": [[14, 24]]}}}, {"text": "Actually, you need to use Collectors.toMap here instead of Collectors.groupingBy", "label": {"api": {"groupingBy": [[70, 79]], "toMap": [[37, 41]]}}}, {"text": "groupingBy is used to group elements of a Stream based on a grouping function", "label": {"api": {"groupingBy": [[0, 9]]}}}, {"text": "toMap will collect the elements into a Map where the key is the result of applying a given key mapper and the value is the result of applying a value mapper", "label": {"api": {"toMap": [[0, 4]]}}}, {"text": "Note that toMap, by default, will throw an exception if a duplicate is encountered", "label": {"api": {"toMap": [[10, 14]]}}}, {"text": "To configure Jackson in JAX-RS, you can register a Context-Resolver<ObjectMapper>, as seen in this post", "label": {"api": {"Context-Resolver<ObjectMapper>": [[51, 80]]}}}, {"text": "Alternatively, you could use Java's ClassLoader to load the file", "label": {"api": {"ClassLoader": [[36, 46]]}}}, {"text": "The ClassLoader works by searching from the project directory regardless of the current working directory", "label": {"api": {"ClassLoader": [[4, 14]]}}}, {"text": "See the JavaDoc for SimpleDateFormat for more explanation as to what the symbols mean", "label": {"api": {"JavaDoc for SimpleDateFormat": [[8, 35]]}}}, {"text": "Collector.minBy() produces a result of type Optional<T>, i.e", "label": {"api": {"Optional": [[44, 51]]}}}, {"text": "Optional<String> in your case", "label": {"api": {"Optional": [[0, 7]]}}}, {"text": "So you need to get the String value out of the Optional returned by collect()", "label": {"api": {"get": [[15, 17]], "Optional": [[47, 54]]}}}, {"text": "Note that get() will throw an exception is the stream was empty, and a min value coult thus not be found", "label": {"api": {"get": [[10, 12]]}}}, {"text": "Collectors.minBy and Collectors.maxBy return an Optional", "label": {"api": {"Collectors.minBy": [[0, 15]], "Collectors.maxBy": [[21, 36]], "Optional": [[48, 55]]}}}, {"text": "if the Stream is empty, an empty Optional is returned; otherwise, an Optional containing the result is returned", "label": {"api": {"Optional": [[33, 40], [69, 76]]}}}, {"text": "As a side-note, you can also return the minimum value by calling Collections.min (resp", "label": {"api": {"Collections.min": [[65, 79]]}}}, {"text": "String#compareTo is case-sensitive", "label": {"api": {"String#compareTo": [[0, 15]]}}}, {"text": "The Oracle Java 7 docs say to use Logger.getGlobal() but the Google java-docs-samples code uses Logger.getLogger(ClassName.class.getName())", "label": {"api": {"Oracle Java 7 docs say": [[4, 25]]}}}, {"text": "Check out the javadoc for java.lang.String", "label": {"api": {"java.lang.String": [[26, 41]]}}}, {"text": "You're probably looking for String.replace(CharSequence target, CharSequence replacement), which replaces every occurrence of target with replacement", "label": {"api": {"String.replace(CharSequence target, CharSequence replacement)": [[28, 88]]}}}, {"text": "As suggested in comments, I think using Map is a better option here", "label": {"api": {"Map": [[40, 42]]}}}, {"text": "The SimpleDateFormat has the details", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "A container may choose to create a pool of servlet instances that have implemented javax.servlet.SingleThreadModel in order to improve concurrency", "label": {"api": {"javax.servlet.SingleThreadModel": [[83, 113]]}}}, {"text": "How about using the default Socket() constructor, and then connect(SocketAddress, int), which allows you to specify a specific timeout", "label": {"api": {"connect(SocketAddress, int)": [[59, 85]]}}}, {"text": "Finally, the Stream is grouped by (groupingBy) the identity function and the reduction performed on the elements is just counting the number of occurences (counting())", "label": {"api": {"groupingBy": [[35, 44]], "counting()": [[156, 165]]}}}, {"text": "If you want to count the number of distinct values, you can add a call to distinct() before collecting the result (or use a Set instead of a List)", "label": {"api": {"distinct()": [[74, 83]]}}}, {"text": "Instead of using java.util.Formatter, I would strongly suggest using java.text.NumberFormat, which comes with a built-in currency formatter", "label": {"api": {"java.text.NumberFormat": [[69, 90]]}}}, {"text": "If you need to use the java.util.Formatter, this will work", "label": {"api": {"Formatter": [[33, 41]]}}}, {"text": "Expanded on the sample code from the Formatter page", "label": {"api": {"Formatter": [[37, 45]]}}}, {"text": "You can do this with a SequentialTransition", "label": {"api": {"SequentialTransition": [[23, 42]]}}}, {"text": "Your variable rssififo is of the generic Queue type rather than the concrete type CircularFifoQueue", "label": {"api": {"Queue": [[41, 45], [94, 98]]}}}, {"text": "The Queue interface does not have a get method, only the peek, poll and remove methods", "label": {"api": {"Queue": [[4, 8]]}}}, {"text": "If you change the declaration to CircularFifoQueue then you can access the get method", "label": {"api": {"Queue": [[45, 49]]}}}, {"text": "Consider using Files.delete instead of File.delete", "label": {"api": {"Files.delete": [[15, 26]]}}}, {"text": "According to the JavaDoc (https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getRow%28%29)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getRow%28%29": [[26, 103]]}}}, {"text": "In order to access the tabs you can use getTabs", "label": {"api": {"getTabs": [[40, 46]]}}}, {"text": "the node that represents the content, you can use setContent", "label": {"api": {"setContent": [[50, 59]]}}}, {"text": "See also https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html": [[9, 75]]}}}, {"text": "You should use keyReleased instead of keyPressed method of KeyAdapter and  you will get the updated value", "label": {"api": {"keyReleased": [[15, 25]]}}}, {"text": "When you call System.out.println(exp); it invokes String.valueOf(Object) which calls toString()", "label": {"api": {"String.valueOf(Object)": [[50, 71]]}}}, {"text": "The JTextArea.setLineWrap(boolean wrap) method might be what you're looking for", "label": {"api": {"JTextArea.setLineWrap(boolean wrap)": [[4, 38]]}}}, {"text": "You can extend AbstractSpliterator to solve this", "label": {"api": {"AbstractSpliterator": [[15, 33]]}}}, {"text": "Your paint() method should have a lowercase 'P'", "label": {"api": {"paint()": [[5, 11]]}}}, {"text": "You can use compareTo(E o) method to compare two enums (https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#compareTo(E))", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#compareTo(E)": [[56, 129]]}}}, {"text": "You can use compareTo(Integer anotherInteger) to compare to integers (https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#compareTo(java.lang.Integer))", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#compareTo(java.lang.Integer)": [[70, 162]]}}}, {"text": "The GridPane documentation states", "label": {"api": {"GridPane documentation": [[4, 25]]}}}, {"text": "If you'd like to do it the performing / memory efficient way, you could take a look at the TreeItem example code which will scan a folder only when you navigate into it", "label": {"api": {"TreeItem": [[91, 98]]}}}, {"text": "To get the SQL types out of the query result set you'll need the result set's ResultSetMetaData", "label": {"api": {"ResultSetMetaData": [[78, 94]]}}}, {"text": "The returned SQL types are those in java.sql.Types", "label": {"api": {"java.sql.Types": [[36, 49]]}}}, {"text": "The value type was of class java.lang.reflect.Type", "label": {"api": {"java.lang.reflect.Type": [[28, 49]]}}}, {"text": "String.split() takes a regular expression, so you need to quote strings that contain characters that have special meanings in regular expressions", "label": {"api": {"takes a regular expression": [[15, 40]]}}}, {"text": "Check KeyEvent.getCode () and the relevant constants in KeyCode", "label": {"api": {"KeyEvent.getCode ()": [[6, 24]], "KeyCode": [[56, 62]]}}}, {"text": "Java's FileChannel supports writing from an array of buffers to a channel in a gathering write with int write(ByteBuffer[] src)", "label": {"api": {"FileChannel": [[7, 17]]}}}, {"text": "It does exist, but with an extra parameter to make it even more general", "label": {"api": {"does exist": [[3, 12]]}}}, {"text": "To solve this problem, you would need to use the SwingUtilities.invokeLater(Runnable run)", "label": {"api": {"SwingUtilities.invokeLater(Runnable run)": [[49, 88]]}}}, {"text": "If you are using Java EE, see javax.validation.Validator for a yet another approach", "label": {"api": {"javax.validation.Validator": [[30, 55]]}}}, {"text": "You would need to make your Book class implement the Comparable interface, and then, compare the names of the books", "label": {"api": {"Comparable": [[53, 62]]}}}, {"text": "Now, the Java Framework already provides a sorting mechanism to sort lists through Collections.sort", "label": {"api": {"Collections.sort": [[83, 98]]}}}, {"text": "If you implement the interface above, you should be able to simply call Collections.sort(listOfBooks) and have your collection sorted", "label": {"api": {"Collections.sort": [[72, 87]]}}}, {"text": "Alternatively, if you need to implement your own sorting mechanism, you can simply do so and then compare the books by using the .compareTo method which the Comparable interface gives you", "label": {"api": {"Comparable": [[157, 166]]}}}, {"text": "is completely legal and creates a new String variable named Integer even though there is a class Integer", "label": {"api": {"a class Integer": [[89, 103]]}}}, {"text": "Other way is, you can use Components[] JPanel#getComponents() to get all components of panel(i.e", "label": {"api": {"Components[] JPanel#getComponents()": [[26, 60]]}}}, {"text": "Starting with Java 8, you can use the Math.floorMod(x, y) method", "label": {"api": {"Math.floorMod(x, y)": [[38, 56]]}}}, {"text": "You can use java.util.regex.Matcher", "label": {"api": {"java.util.regex.Matcher": [[12, 34]]}}}, {"text": "You can expand the range of your program by using long in place of int to accept numbers up to 9*1018, or to make it accept virtually unlimited range by using BigInteger", "label": {"api": {"BigInteger": [[159, 168]]}}}, {"text": "The toString() method is called by the API itself during the call to printf because you specified the %s identifier in the format String", "label": {"api": {"printf": [[69, 74]]}}}, {"text": "This method uses the class Formatter to format the output and quoting its documentation for the %s identifier (emphasis mine)", "label": {"api": {"its documentation": [[70, 86]]}}}, {"text": "Then all the requests are handled by the service() method, which calls the appropriate doXxx() method based on the request type (as documented)", "label": {"api": {"as documented": [[129, 141]]}}}, {"text": "Use LinkedHashMap, which has method removeEldestEntry", "label": {"api": {"LinkedHashMap": [[4, 16]], "removeEldestEntry": [[36, 52]]}}}, {"text": "What you can do is cast both types JButton and JMenuItem to their common supertype AbstractButton", "label": {"api": {"AbstractButton": [[83, 96]]}}}, {"text": "According to the documentation of Socket#connect, a timeout value of 0 (which we saw earlier is the default) is interpreted as an infinite timeout", "label": {"api": {"Socket#connect": [[34, 47]]}}}, {"text": "I'm trying to use ImageIcon as a final constant, but at the same time, I don't want the image to be changeable", "label": {"api": {"ImageIcon": [[18, 26]]}}}, {"text": "Then deserializing is just as simple as serializing, by using ObjectInputStream.readObject()", "label": {"api": {"ObjectInputStream.readObject()": [[62, 91]]}}}, {"text": "You could create a custom Comparator to treat the first part of the string numerically", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "I recommend that you create a Matcher and use the find() method in a loop", "label": {"api": {"Matcher": [[30, 36]]}}}, {"text": "Assuming you are using Java 8, and the javax.json package", "label": {"api": {"javax.json": [[39, 48]]}}}, {"text": "Double#min(double, double) was introduces in Java 8, which you compiled your code with", "label": {"api": {"Double#min(double, double)": [[0, 25]]}}}, {"text": "See the documentation for BufferedReader", "label": {"api": {"documentation for BufferedReader": [[8, 39]]}}}, {"text": "Note the use of .TYPE instead of .class for Integer and Boolean", "label": {"api": {".TYPE": [[16, 20]]}}}, {"text": "This is done by calling read(b) and giving an initialized byte array", "label": {"api": {"read(b)": [[24, 30]]}}}, {"text": "You can use the facilities provided since Java 7 with Java NIO.2 API (Files.copy(source, target, options...))", "label": {"api": {"Files.copy(source, target, options...)": [[70, 107]], "options": [[97, 103]]}}}, {"text": "If you want more control on the copy, you can give options to this call as the third variable arguments, like StandardCopyOption.REPLACE_EXISTING that will replace the target file if it already exists", "label": {"api": {"options": [[51, 57]], "StandardCopyOption.REPLACE_EXISTING": [[110, 144]]}}}, {"text": "Is there a way in Java to detect stateless charsets of all available charsets (Charset#availableCharsets())", "label": {"api": {"Charset#availableCharsets()": [[79, 105]]}}}, {"text": "Integer.MAX_VALUE = 2147483647 and the input string you've passed has a value of 2370371592", "label": {"api": {"Integer.MAX_VALUE = 2147483647": [[0, 29]]}}}, {"text": "From ArrayList javadoc", "label": {"api": {"ArrayList javadoc": [[5, 21]]}}}, {"text": "If you already have an array and you want to modify it in place, you can use Arrays.setAll", "label": {"api": {"Arrays.setAll": [[77, 89]]}}}, {"text": "A Java 8 solution would be to use Objects.isNull(Object), assuming a static import", "label": {"api": {"Objects.isNull(Object)": [[34, 55]]}}}, {"text": "You could use Files.walk(start, options...) to walk through a file tree recursively", "label": {"api": {"Files.walk(start, options...)": [[14, 42]], "options": [[32, 38]]}}}, {"text": "Among the options, there is FOLLOW_LINKS that will follow symbolic links", "label": {"api": {"options": [[10, 16]], "FOLLOW_LINKS": [[28, 39]]}}}, {"text": "You actually need to use orElseGet", "label": {"api": {"orElseGet": [[25, 33]]}}}, {"text": "That's why orElseGet exists", "label": {"api": {"orElseGet": [[11, 19]]}}}, {"text": "See the documentation of Pattern for more details", "label": {"api": {"documentation of Pattern": [[8, 31]]}}}, {"text": "For the WindowListener interface, this is WindowAdapter", "label": {"api": {"WindowListener": [[8, 21]], "WindowAdapter": [[42, 54]]}}}, {"text": "So, instead of implementing WindowListener (and all of its methods), you can just extend WindowAdapter and override only the methods you want", "label": {"api": {"WindowListener": [[28, 41]], "WindowAdapter": [[89, 101]]}}}, {"text": "You may use Java 8 Stream API and groupingBy collector", "label": {"api": {"groupingBy": [[34, 43]]}}}, {"text": "See the documentation for the PrintStream.println(Object)", "label": {"api": {"documentation for the PrintStream.println(Object)": [[8, 56]]}}}, {"text": "A class annotated with @MappedSuperclass has no table of it's own", "label": {"api": {"@MappedSuperclass": [[23, 39]]}}}, {"text": "It should be noted that \"checking if the string is only digits\" does not protect against exceptions when calling Integer.parseInt() - if you pass it a number greater than 2147483647 (ie Integer.MAX_VALUE) it will explode", "label": {"api": {"Integer.MAX_VALUE": [[186, 202]]}}}, {"text": "The Pattern.compile(String) method takes a string as input", "label": {"api": {"Pattern.compile(String)": [[4, 26]]}}}, {"text": "Note that there is an overloaded version of Application.launch that takes a parameter representing the class with the start method", "label": {"api": {"overloaded version of Application.launch": [[22, 61]]}}}, {"text": "Have a look at the MatchResult reference on https://docs.oracle.com/javase/7/docs/api/java/util/regex/MatchResult.html and check 'groupCount' section", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/regex/MatchResult.html": [[44, 117]]}}}, {"text": "You've used Calendar.HOUR, which controls only the 1-12 hour, not the 0-23 hour", "label": {"api": {"Calendar.HOUR": [[12, 24]]}}}, {"text": "To set it to midnight, try Calendar.HOUR_OF_DAY, which controls the 0-23 hour", "label": {"api": {"Calendar.HOUR": [[27, 39]], "Calendar.HOUR_OF_DAY": [[27, 46]]}}}, {"text": "Likely a better approach suggested by @Pshemo is to use the Scanner class", "label": {"api": {"Scanner": [[60, 66]]}}}, {"text": "Take a look at shuffle", "label": {"api": {"shuffle": [[15, 21]]}}}, {"text": "You can also try to build your array with random numbers right away with something like in this question, but I think the shuffle is alright for now", "label": {"api": {"shuffle": [[122, 128]]}}}, {"text": "It seems to be a common pattern (see Collections for a number of examples) to accept a collection of type T, where T extends Comparable<", "label": {"api": {"Collections": [[37, 47]]}}}, {"text": "But it seems technically impossible to fulfill the contract of compareTo() when comparing to a base class, because there's no way to ensure that another class doesn't extend the base with a contradictory comparison", "label": {"api": {"compareTo()": [[63, 73]]}}}, {"text": "We know Boolean.TRUE cannot be null, since it's true", "label": {"api": {"true": [[48, 51]]}}}, {"text": "We also know that Boolean.equals() will return false if passed null, not raise a NullPointerException, so it wouldn't matter if businessPartnership.getEscrowProvider() returned null", "label": {"api": {"Boolean.equals()": [[18, 33]]}}}, {"text": "In order to change sorting order, you can implement you own Comparator and use it to change the default order by using Collections.sort(arrayList, c)", "label": {"api": {"Comparator": [[60, 69]]}}}, {"text": "If your goal is to run some extra initialization code after the auto-wired dependencies are guaranteed to be in place, then one way to do that is to annotate a different method from the constructor with PostContruct", "label": {"api": {"PostContruct": [[203, 214]]}}}, {"text": "In order to display it correctly, you can loop through it, or use the Arrays.toString() method", "label": {"api": {"Arrays.toString()": [[70, 86]]}}}, {"text": "You can improve this by instead using ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[38, 54]]}}}, {"text": "Use Calendar to calculate the time difference", "label": {"api": {"Calendar": [[4, 11]]}}}, {"text": "Anything throwable extends Throwable (See Throwable Javadoc)", "label": {"api": {"Throwable Javadoc": [[42, 58]]}}}, {"text": "Use thread pools, which are created thanks to the Executors class", "label": {"api": {"Executors": [[50, 58]]}}}, {"text": "You could do it quite simply using Map.replaceAll", "label": {"api": {"Map.replaceAll": [[35, 48]]}}}, {"text": "Quoting from its API note", "label": {"api": {"API note": [[17, 24]]}}}, {"text": "Given is the following configuration of a ScheduledThreadPoolExecutor that runs a simple task every five seconds", "label": {"api": {"ScheduledThreadPoolExecutor": [[42, 68]]}}}, {"text": "On Oracle JRE 1.8.0_66 there’s one thread created by the ScheduledThreadPoolExecutor that constantly causes 100% load on one CPU core", "label": {"api": {"ScheduledThreadPoolExecutor": [[57, 83]]}}}, {"text": "Is the behavior of ScheduledThreadPoolExecutor with corePoolSize = 0 a known feature, an unvalidated misconfiguration or even a bug", "label": {"api": {"ScheduledThreadPoolExecutor": [[19, 45]]}}}, {"text": "See the java documentation for compareTo()", "label": {"api": {"See the java documentation for compareTo()": [[0, 41]]}}}, {"text": "How about using an EnumSet for that", "label": {"api": {"EnumSet": [[19, 25]]}}}, {"text": "Here's a way you could add elements dynamically to your 2nd JComboBox and from the docs there's a JComboBox#addItem() method where you can easily add elements to your JComboBox", "label": {"api": {"JComboBox": [[60, 68], [98, 106], [167, 175]], "JComboBox#addItem()": [[98, 116]]}}}, {"text": "But I find @svasa a better approach than mine while adding elements to you DefaultComboBoxModel with DefaultComboBoxModel#addElement()", "label": {"api": {"DefaultComboBoxModel#addElement()": [[101, 133]]}}}, {"text": "Using a recursive string conversion method such as Arrays.deepToString is unnecessary here", "label": {"api": {"Arrays.deepToString": [[51, 69]]}}}, {"text": "In fact, Arrays.deepToString's javadocs state", "label": {"api": {"Arrays.deepToString": [[9, 27]]}}}, {"text": "If an element e is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of Arrays.toString(e)", "label": {"api": {"Arrays.toString": [[123, 137]]}}}, {"text": "The method Arrays.deepToString itself must notice if an internal element is a primitive array, and it calls Arrays.toString in that case", "label": {"api": {"Arrays.deepToString": [[11, 29]], "Arrays.toString": [[108, 122]]}}}, {"text": "Use Arrays.toString instead, which has overloads for each primitive array type", "label": {"api": {"Arrays.toString": [[4, 18]]}}}, {"text": "The method contains() for a List will only return true if, for any element in the list, is true that element.equals(parameter)", "label": {"api": {"contains()": [[11, 20]]}}}, {"text": "If you look at the Javadoc for List at the contains method you will see that it uses the equals() method to evaluate if two objects are the same", "label": {"api": {"Javadoc for List": [[19, 34]]}}}, {"text": "It is highly unlikely that you will be able to get this information from Tyrus, as it relies on javax.servlet.http.HttpServletRequest.upgrade() which uses a javax.servlet.http.HttpUpgradeHandler, which is handed a   javax.servlet.http.WebConnection by the container", "label": {"api": {"javax.servlet.http.HttpServletRequest.upgrade()": [[96, 142]], "javax.servlet.http.HttpUpgradeHandler": [[157, 193]], "javax.servlet.http.WebConnection": [[216, 247]]}}}, {"text": "The Tyrus implementation of javax.servlet.http.HttpUpgradeHandler does not even track this information separately to include in the JSR356 layer", "label": {"api": {"javax.servlet.http.HttpUpgradeHandler": [[28, 64]]}}}, {"text": "The FXML controller class can optionally have a initialize() (and additionally can implement Initializable but not mandatory)", "label": {"api": {"Initializable": [[93, 105]]}}}, {"text": "Quoting javadoc of HashSet", "label": {"api": {"HashSet": [[19, 25]]}}}, {"text": "The actual order of the objects depend on the hash values of those objects, the current number of hash buckets in the HashSet, and the algorithm used to map a hash value to a hash bucket", "label": {"api": {"HashSet": [[118, 124]]}}}, {"text": "The algorithm may change between different versions of the Java Runtime Library, and the number of hash buckets may change as values are added and removed from the HashSet", "label": {"api": {"HashSet": [[164, 170]]}}}, {"text": "To see this in effect, try creating the HashSet with a different initial capacity, using the HashSet(int initialCapacity) constructor", "label": {"api": {"HashSet": [[40, 46], [93, 99]], "HashSet(int initialCapacity)": [[93, 120]]}}}, {"text": "For loop (in this case for-each loop) uses iterator (see Iterable interface https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html) to iterate through rows, so as you have written it will skip null values", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html": [[76, 140]]}}}, {"text": "You then use the DiscriminatorColumn annotation on Region to specify which column is used as the discriminator, and DiscriminatorValue on the subclasses to specify what value to use for the subclass in the discriminator column", "label": {"api": {"DiscriminatorColumn": [[17, 35]], "DiscriminatorValue": [[116, 133]]}}}, {"text": "You could use the utility methods of java.lang.nio.file.Files", "label": {"api": {"java.lang.nio.file.Files": [[37, 60]]}}}, {"text": "Depending on how the URL exists in your code (maybe it's not a String but an URI) you might use some pieces from this snippet", "label": {"api": {"URI": [[77, 79]]}}}, {"text": "You can use an @OrderColumn annotation (requires an extra column in the DB) to keep the elements of the list in a consistent order", "label": {"api": {"@OrderColumn": [[15, 26]]}}}, {"text": "In general, don't try to build XML through string concatenation, use a dedicated API like one of the various tree based APIs available in Java (DOM, XOM, JDOM) or https://docs.oracle.com/javase/7/docs/api/javax/xml/stream/XMLStreamWriter.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/xml/stream/XMLStreamWriter.html": [[163, 241]]}}}, {"text": "You'll want to use a List, and make use of Collections#shuffle to accomplish what you're interested in", "label": {"api": {"Collections#shuffle": [[43, 61]]}}}, {"text": "This code simply calls parallel() or not depending on the boolean parameter", "label": {"api": {"parallel()": [[23, 32]]}}}, {"text": "Read the javadoc of compareTo()", "label": {"api": {"compareTo()": [[20, 30]]}}}, {"text": "When using compareTo() you should always check result as < 0, <= 0, == 0, >= 0, > 0, or != 0, depending on your need", "label": {"api": {"compareTo()": [[11, 21]]}}}, {"text": "Actually, Files.lines returns a Stream of the lines that is lazy-populated", "label": {"api": {"Files.lines": [[10, 20]]}}}, {"text": "The Stream API provides such a method with the help of Stream.filter", "label": {"api": {"Stream.filter": [[55, 67]]}}}, {"text": "This method takes a Predicate as argument, which is a function that returns true for all the items that should be kept, and false otherwise", "label": {"api": {"Predicate": [[20, 28]]}}}, {"text": "In this case, we want a Predicate that would return true when the name is equal to \"Neda\"", "label": {"api": {"Predicate": [[24, 32]]}}}, {"text": "Note still that calling twice Files.lines(path) can be avoided by using directly a BufferedReader as in @Holger's answer", "label": {"api": {"Files.lines": [[30, 40]]}}}, {"text": "Don't use exec(String command), use exec(String[] cmdarray) instead", "label": {"api": {"exec(String command)": [[10, 29]], "exec(String[] cmdarray)": [[36, 58]]}}}, {"text": "My answer would have been Integer.toString(value)", "label": {"api": {"Integer.toString(value)": [[26, 48]]}}}, {"text": "For something like that you should use a logging library, either the Java built-in library, or a 3rd-party library such as log4j or logback", "label": {"api": {"built-in library": [[74, 89]]}}}, {"text": "I'm attempting to use Guice to inject dependencies into a ContainerRequestFilter that is being registered via a DynamicFeature", "label": {"api": {"DynamicFeature": [[112, 125]]}}}, {"text": "My end goal is to have an AuthenticationFilter that is applied to specific Resources via a DynamicFeature", "label": {"api": {"DynamicFeature": [[91, 104]]}}}, {"text": "This is part of a Dropwizard project and the pattern is based on Dropwizard's AuthDynamicFeature and AuthFilter but modified to support injection", "label": {"api": {"DynamicFeature": [[82, 95]]}}}, {"text": "And my DynamicFeature looks like this", "label": {"api": {"DynamicFeature": [[7, 20]]}}}, {"text": "Callback and Function seem very similar", "label": {"api": {"Callback": [[0, 7]], "Function": [[13, 20]]}}}, {"text": "The only substantial difference I can find is that Function has some utility methods for composing functions, while Callback doesn't", "label": {"api": {"Callback": [[116, 123]], "Function": [[51, 58]]}}}, {"text": "As Callback is a JavaFX class, I assume it came second, so my question is- why was it created", "label": {"api": {"Callback": [[3, 10]]}}}, {"text": "I try to find out how far the DP is routed, but I cant find anything useful under oracle", "label": {"api": {"oracle": [[82, 87]]}}}, {"text": "If you don't want to use a custom formatter then you can use the java.util.logging.SimpleFormatter and set the format property to %5$s which will just write out the message part of the log record", "label": {"api": {"java.util.logging.SimpleFormatter": [[65, 97]]}}}, {"text": "It won't work if you require another SimpleFormatter with a different pattern like a ConsoleHandler or if your raw data trips up MessageFormat patterns", "label": {"api": {"MessageFormat": [[129, 141]]}}}, {"text": "And you pass it a null object returned by Class.getResourceAsStream(path), and as the docs for ImageIO.read(InputStream input) state", "label": {"api": {"docs for ImageIO.read(InputStream input)": [[86, 125]]}}}, {"text": "After adding the elements, you may want to call revalidate()", "label": {"api": {"revalidate()": [[48, 59]]}}}, {"text": "More info on NullPointerException here on the docs and on this question", "label": {"api": {"here on the docs": [[34, 49]]}}}, {"text": "As shown here, invoke setRowCount(0) to clear the table's model and then model.addRow(row) to add a new row", "label": {"api": {"setRowCount(0)": [[22, 35]]}}}, {"text": "collect(groupingBy()) returns a map Map<K, List<T>>", "label": {"api": {"collect(groupingBy())": [[0, 20]]}}}, {"text": "Hopefully, the date is retrieved as a java.sql.Date, which does not have a specific form", "label": {"api": {"java.sql.Date": [[38, 50]]}}}, {"text": "Or, in java.time (Java 8 and later)", "label": {"api": {"java.time": [[7, 15]]}}}, {"text": "Use a custom Comparator implementation and put your logic in compareTo() to sort the hashmaps", "label": {"api": {"Comparator": [[13, 22]]}}}, {"text": "extends E> collection) method instead of the List#add(E element) one, which adds a single element to the List", "label": {"api": {"List#add(E element)": [[45, 63]]}}}, {"text": "LocalTime, which seems to be your implementation (your code does not include the imports) implements Comparable, so you can just use the method compareTo", "label": {"api": {"LocalTime": [[0, 8]], "compareTo": [[144, 152]]}}}, {"text": "So it seems that, if you need to see the contents of your ArrayList using toString(), all you need is to override the method toString() in your Person class", "label": {"api": {"toString()": [[74, 83], [125, 134]]}}}, {"text": "So when you print your ArrayList, it will just call the toString() method for each ArrayList element", "label": {"api": {"toString()": [[56, 65]]}}}, {"text": "You can store all the necessary information in a static ThreadLocal instance and read it afterwards", "label": {"api": {"ThreadLocal": [[56, 66]]}}}, {"text": "You can include a ServletContextListener", "label": {"api": {"ServletContextListener": [[18, 39]]}}}, {"text": "Put your code in the contextInitialized method", "label": {"api": {"contextInitialized": [[21, 38]]}}}, {"text": "You can assume the URL you are returning is a piece of plain text and use MediaType.TEXT_PLAIN", "label": {"api": {"MediaType.TEXT_PLAIN": [[74, 93]]}}}, {"text": "If you need, you can return a HTML document (using MediaType.TEXT_HTML) containing an <a> element, referencing the URL you want to return", "label": {"api": {"MediaType.TEXT_HTML": [[51, 69]]}}}, {"text": "Usually a ConcurrentModificationException will be thrown, but you can't rely on that assumption", "label": {"api": {"ConcurrentModificationException": [[10, 40]]}}}, {"text": "If a Collection is modified while iterating over it, in most of the implementations, a ConcurrentModificationException is thrown", "label": {"api": {"ConcurrentModificationException": [[87, 117]]}}}, {"text": "I try tests with \\b / \\B boundary matcher but they don't work if leading + sign was used", "label": {"api": {"boundary matcher": [[25, 40]]}}}, {"text": "Another possibility is to use a HashMap", "label": {"api": {"HashMap": [[32, 38]]}}}, {"text": "The method you're looking for probably is String.valueOf(Object)", "label": {"api": {"String.valueOf(Object)": [[42, 63]]}}}, {"text": "You normally use ACLFileAttributeView as stated in the short example", "label": {"api": {"ACLFileAttributeView": [[17, 36]]}}}, {"text": "For a detailed overview, I like to use this documentation from Oracle - while the examples are from chmod, the permissions themselves are the same in Java (but there also exists the shorter JavaDoc for them, AclEntryPermission Enums)", "label": {"api": {"AclEntryPermission Enums": [[208, 231]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/lang/ArrayStoreException.html for details", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/ArrayStoreException.html": [[4, 79]]}}}, {"text": "GregorianCalendar constructor have signature", "label": {"api": {"GregorianCalendar": [[0, 16]]}}}, {"text": "If you actually want to modify the original list, consider using removeIf", "label": {"api": {"removeIf": [[65, 72]]}}}, {"text": "Detach it so that a new managed one will be loaded from the db when the persistence provider looks for it in any subsequent operation it performs", "label": {"api": {"Detach": [[0, 5]]}}}, {"text": "Clear the entire persistence context, so that the persistence provider reloads again everything it needs in any subsequent operation in the same transaction", "label": {"api": {"Clear": [[0, 4]]}}}, {"text": "Depending on the use cases, you may want to flush any changes you may have done in the instances you intend to refresh/detach/clear before applying any of the above operations, otherwise those changes will not be synchronized with the database", "label": {"api": {"flush": [[44, 48]]}}}, {"text": "ScheduledExecutorService) to submit a Runnable/Callable that makes the necessary updates", "label": {"api": {"ScheduledExecutorService": [[0, 23]]}}}, {"text": "Per Javadocs, entityManager.remove only works with Managed entities and if called on detached entities it will result in IllegalStateException", "label": {"api": {"entityManager.remove": [[14, 33]]}}}, {"text": "A Java way of listing all available filesystem roots for example is using the listRoots() method but it cannot tell the filesystem types such as external, internal, OS drive or whatever", "label": {"api": {"listRoots()": [[78, 88]]}}}, {"text": "BigDecimal isn't a primitive, so you cannot use the <, > operators", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "However, since it's a Comparable, you can use the compareTo(BigDecimal) to the same effect", "label": {"api": {"BigDecimal": [[60, 69]], "Comparable": [[22, 31]], "compareTo(BigDecimal)": [[50, 70]]}}}, {"text": "If you can change your application to use one of the BlockingQueue implementations, there is a method drainTo that seems to do exactly what you want", "label": {"api": {"drainTo": [[102, 108]]}}}, {"text": "Oddly, it's not specified that drainTo is atomic, though it is in the implementations I checked (ArrayBlockingQueue and LinkedBlockingQueue)", "label": {"api": {"drainTo": [[31, 37]]}}}, {"text": "Stream.filter returns a new Stream consisting of the elements of this stream that match the given predicate", "label": {"api": {"Stream.filter": [[0, 12]], "Stream": [[0, 5], [28, 33]]}}}, {"text": "But it's important to note that it's a new Stream", "label": {"api": {"Stream": [[43, 48]]}}}, {"text": "Quoting from Stream Javadoc", "label": {"api": {"Stream": [[13, 18]]}}}, {"text": "In this case, filter is the intermediate operation that operated on the old Stream instance", "label": {"api": {"Stream": [[76, 81]]}}}, {"text": "Change Array.**asList**(forecastArray) to Arrays.asList(forecastArray)", "label": {"api": {"Arrays.asList": [[42, 54]]}}}, {"text": "Take a look at Arrays.asList method", "label": {"api": {"Arrays.asList": [[15, 27]]}}}, {"text": "This can be achieved using redirectErrorStream", "label": {"api": {"redirectErrorStream": [[27, 45]]}}}, {"text": "You could create a temporary file using File.createTempFile()", "label": {"api": {"File.createTempFile()": [[40, 60]]}}}, {"text": "It might make cleanup easier if you called deleteOnExit() for the created temporary file", "label": {"api": {"deleteOnExit()": [[43, 56]]}}}, {"text": "According to the javadocs for URI, the constructor java.net.URI should throw a URISyntaxException \"if the given string violates RFC 2396, as augmented by the above deviations\" with some minor deviations included", "label": {"api": {"javadocs for URI": [[17, 32]]}}}, {"text": "In your case, since String keys are strictly ordered, ConcurrentSkipListMap is a way to go", "label": {"api": {"ConcurrentSkipListMap": [[54, 74]]}}}, {"text": "It is both concurrent and navigable, and can be often used in place of ConcurrentHashMap", "label": {"api": {"concurrent": [[11, 20]], "navigable": [[26, 34]]}}}, {"text": "To get the next page from ConcurrentSkipListMap, call tailMap with the last key of the previous page as an anchor and then construct an iterator or a stream from the result submap", "label": {"api": {"ConcurrentSkipListMap": [[26, 46]]}}}, {"text": "One file reaches an OutOfMemoryError due to its extensive use of clones", "label": {"api": {"OutOfMemoryError": [[20, 35]]}}}, {"text": "These are vector graphics, not images, and we are primarily using Path nodes", "label": {"api": {"Path": [[66, 69]]}}}, {"text": "Display the contacts using a JTable and a delete button to delete the selected contact from the corresponding ArrayList element", "label": {"api": {"JTable": [[29, 34]]}}}, {"text": "You would do this by calling JTable.getSelectedRow() on your table model to get the correct contact in your ArrayList", "label": {"api": {"JTable": [[29, 34]]}}}, {"text": "You will want to use a Consumer for this", "label": {"api": {"Consumer": [[23, 30]]}}}, {"text": "Also, you should consider using an Executor instead of directly creating and starting threads..", "label": {"api": {"Executor": [[35, 42]]}}}, {"text": "If you absolutely must have LRU behavior, then the JDK standard LinkedHashMap is a good, straightforward choice", "label": {"api": {"LinkedHashMap": [[64, 76]]}}}, {"text": "You would need to subclass it and override removeEldestEntry with logic to signal when the cache has grown larger than you want it", "label": {"api": {"removeEldestEntry": [[43, 59]]}}}, {"text": "Use String.matches() for this", "label": {"api": {"String.matches()": [[4, 19]]}}}, {"text": "It has one method named handle() that takes in a generic type, this is the method whose parameters you should be considering; So you must pass in a parameter to it", "label": {"api": {"handle()": [[24, 31]]}}}, {"text": "Javadoc of Executor interface says the following", "label": {"api": {"Javadoc of Executor interface": [[0, 28]]}}}, {"text": "There's no public API available in current Servlet 3.1 version and thus also not in Servlet 3.0 as used by Tomcat 7", "label": {"api": {"public API": [[11, 20]]}}}, {"text": "NoClassDefFoundError means Java couldn't find the Class it was looking for", "label": {"api": {"NoClassDefFoundError": [[0, 19]]}}}, {"text": "That being said, you should really look into PreparedStatements and executing batches", "label": {"api": {"PreparedStatement": [[45, 61]], "executing batches": [[68, 84]]}}}, {"text": "I would suggest you wait for your threads to complete (either via CyclicBarrier or CountdownLatch for e.g.) and then you close the session", "label": {"api": {"CyclicBarrier": [[66, 78]], "CountdownLatch": [[83, 96]]}}}, {"text": "If you are using Java 8, then you can do it pretty easily using Files#list", "label": {"api": {"Files#list": [[64, 73]]}}}, {"text": "For periodic actions, consider using Timeline", "label": {"api": {"Timeline": [[37, 44]]}}}, {"text": "You should avoid loops and use addAll method to merge two set and avoid duplicates like", "label": {"api": {"set": [[58, 60]]}}}, {"text": "From the repaint documentation", "label": {"api": {"repaint documentation": [[9, 29]]}}}, {"text": "So, either use a Swing Timer rather than a ScheduledExecutorService, or wrap the label change into SwingUtilities.invokeLater()", "label": {"api": {"Swing Timer": [[17, 27]]}}}, {"text": "Then for your Deck you can simplify things as well by choosing a good data structure, in this case a TreeSet, which will automatically use the compareTo function you've provided for cards to sort the cards.", "label": {"api": {"TreeSet": [[101, 107]]}}}, {"text": "To do one animation after the other, put them in a SequentialTransition", "label": {"api": {"SequentialTransition": [[51, 70]]}}}, {"text": "The documentation of IntStream does not answer this explicitly or I cannot understand it properly", "label": {"api": {"IntStream": [[21, 29]]}}}, {"text": "Create a list model - most of the time DefaultListModel will do", "label": {"api": {"DefaultListModel": [[39, 54]]}}}, {"text": "set the selection mode, and possibly a custom ListCellRenderer", "label": {"api": {"ListCellRenderer": [[46, 61]]}}}, {"text": "Is that atleast possible through MethodHandle", "label": {"api": {"MethodHandle": [[33, 44]]}}}, {"text": "It is a RuntimeException thrown by TestNG", "label": {"api": {"RuntimeException": [[8, 23]]}}}, {"text": "This means that when initializing/constructing an instance of RAD3398LogoutTwiceTest that a constructor for Actions was invoked which then threw a NullPointerException on line 44", "label": {"api": {"NullPointerException": [[147, 166]]}}}, {"text": "As such, you are just missing a call to Collectors.mapping", "label": {"api": {"Collectors.mapping": [[40, 57]]}}}, {"text": "An XmlAdapter is the simplest and most generic solution", "label": {"api": {"XmlAdapter": [[3, 12]]}}}, {"text": "Java's BufferedReader.readLine() will match any possible line ending (CR, LF, CR LF), and PrintWriter.println(s) will print it out in platform's default line encoding (LF in your case), which will then be counted by wc -l on next run", "label": {"api": {"BufferedReader.readLine()": [[7, 31]], "PrintWriter.println(s)": [[90, 111]]}}}, {"text": "An appropriate solution would be to use Collectors.partitioningBy", "label": {"api": {"Collectors.partitioningBy": [[40, 64]]}}}, {"text": "The recommended way of generating random-numbers in java isn't Math.random() , but via the java.util.Random class (http://docs.oracle.com/javase/7/docs/api/java/util/Random.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Random.html": [[115, 176]]}}}, {"text": "A renderer that extends DefaultTableCellRenderer uses the same component (a JLabel) as a template for all cells (cf DefaultTableCellRenderer implementation notes - they call it rubber-stamping)", "label": {"api": {"DefaultTableCellRenderer": [[24, 47], [116, 139]]}}}, {"text": "The benefit of this tweak would be to allow you to use Arrays.fill which may make use of cpu-specific block-set instructions", "label": {"api": {"Arrays.fill": [[55, 65]]}}}, {"text": "Section 8.3 is describing the design patterns which introspection recognizes, in the absence of explicit BeanInfo", "label": {"api": {"introspection": [[52, 64]]}}}, {"text": "But, the more I think about it, maybe using InputVerifier and public boolean shouldYieldFocus(JComponent input) is more appropriate", "label": {"api": {"public boolean shouldYieldFocus(JComponent input)": [[62, 110]]}}}, {"text": "From the Oracle Documentation you can read this", "label": {"api": {"Oracle Documentation": [[9, 28]]}}}, {"text": "The newer, standard version of the JPA API has typed queries which would avoid those warnings, and allow you to get back a properly typed list", "label": {"api": {"typed queries": [[47, 59]]}}}, {"text": "The Protocol Buffers' TimeUtil.parseDuration would not give you the error message you say you got, and is not at all like Duration.parse, which is more clearly documented and might give that kind of error message", "label": {"api": {"more clearly documented": [[147, 169]]}}}, {"text": "Create a sublist with Lists subList method", "label": {"api": {"Lists subList method": [[22, 41]]}}}, {"text": "The official documentation of Collections.shuffle has a lot to say about what will happen", "label": {"api": {"official documentation of Collections.shuffle": [[4, 48]]}}}, {"text": "Adding a ChangeListener here to a ReadOnlyDoubleProperty seems to defeat that ideal", "label": {"api": {"ChangeListener": [[9, 22]], "ReadOnlyDoubleProperty": [[34, 55]]}}}, {"text": "First, the most specific type parameter I can use on the ChangeListener is Number", "label": {"api": {"ChangeListener": [[57, 70]], "Number": [[75, 80]]}}}, {"text": "It's a DoubleExpression", "label": {"api": {"DoubleExpression": [[7, 22]]}}}, {"text": "You can use Function.identity() which does the same", "label": {"api": {"Function.identity()": [[12, 30]]}}}, {"text": "If you really absolutely don't want to use Threads, you could spawn a new process using Runtime#exec - Execute a new Java process with the correct class path that executes a program for you", "label": {"api": {"Runtime#exec": [[88, 99]]}}}, {"text": "If you are OK with creating threads (They have a quite low footprint if used correctly), but don't want to use the Thread class directly, you can use an Executor, for example like this", "label": {"api": {"Executor": [[153, 160]]}}}, {"text": "It is actually a good idea to not use the Thread class directly - use Executor or Fork/Join", "label": {"api": {"Executor": [[70, 77]]}}}, {"text": "You can use the Element#getElement(int) method", "label": {"api": {"Element#getElement(int)": [[16, 38]]}}}, {"text": "The main task parses the file and sends batches of at most 100 items to an ExecutorService", "label": {"api": {"ExecutorService": [[75, 89]]}}}, {"text": "The ExecutorService should have a number of worker threads that equals the number of available database connections", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "The main thread should wait for the ExecutorService to finish processing all tasks prior to shutting down", "label": {"api": {"ExecutorService": [[36, 50]]}}}, {"text": "read current buffer, either using busy waiting (high-definition, high CPU usage) or using the \"precise\" version of sleep (OS-dependent definition, low CPU usage)", "label": {"api": {"sleep": [[115, 119]]}}}, {"text": "You can create a DoubleBinding with the utilities in the Bindings class (createDoubleBinding)", "label": {"api": {"Bindings": [[57, 64]], "createDoubleBinding": [[73, 91]]}}}, {"text": "For Java 8 you could switch to new class StringJoiner which has beed added for exactly that purpose", "label": {"api": {"StringJoiner": [[41, 52]]}}}, {"text": "I'm looking into Java Batch, and found a couple of good examples", "label": {"api": {"Java Batch": [[17, 26]]}}}, {"text": "To avoid this, run the whole computation in parallel using the new CompletionStage/CompletableFuture introduced in Java 8", "label": {"api": {"CompletionStage": [[67, 81]], "CompletableFuture": [[83, 99]]}}}, {"text": "Well, you could implement the interface List in your type", "label": {"api": {"List": [[40, 43]]}}}, {"text": "The StringJoiner is a utility class that was written specifically to be used with the new Java8 Stream functionality", "label": {"api": {"StringJoiner": [[4, 15]], "Stream": [[96, 101]]}}}, {"text": "The documentation of StringJoiner also refers to the Collectors.joining method", "label": {"api": {"StringJoiner": [[21, 32]], "Collectors.joining": [[53, 70]], "Collector": [[53, 61]]}}}, {"text": "It creates the StringJoiner, and wraps it in an object suitable to pass to Stream.collect, actually a Collector", "label": {"api": {"StringJoiner": [[15, 26]], "Stream": [[75, 80]], "Stream.collect": [[75, 88]], "Collector": [[102, 110]]}}}, {"text": "As part of the Stream API we now also have direct support for filters, it is just a matter of employing the fluent API (fluent because we keep adding .something(...)) to add the .filter method", "label": {"api": {"Stream": [[15, 20]], ".filter": [[178, 184]]}}}, {"text": "I have deliberately broken it up by defining an extra method, so you can see the type of the filter passed along, exposing the Predicate", "label": {"api": {"Predicate": [[127, 135]]}}}, {"text": "However if the Stream api is flexible enough that I do not see any need to abstract your own API for it", "label": {"api": {"Stream": [[15, 20]]}}}, {"text": "To retrieve name and address, you could use indexOf and substring methods of String", "label": {"api": {"String": [[77, 82]]}}}, {"text": "To respond to mouse clicks, use setOnMouseClicked", "label": {"api": {"setOnMouseClicked": [[32, 48]]}}}, {"text": "The reason why it works lies in the flatMap operation", "label": {"api": {"flatMap operation": [[36, 52]]}}}, {"text": "The general way to deal with errors like this is to use a streaming parser", "label": {"api": {"error": [[29, 33]]}}}, {"text": "When creating a Handler, you will be able to override/implement the error and fatalError methods", "label": {"api": {"error": [[68, 72]], "fatalError": [[78, 87]]}}}, {"text": "These will allow you to continue parsing, but that still leaves you to handle the actual errors", "label": {"api": {"error": [[89, 93]]}}}, {"text": "Obviously there are many possible errors in an XML document and it'll only make sense to handle some of them", "label": {"api": {"error": [[34, 38]]}}}, {"text": "If you want to scale it in relation to the monitor's resolution, I'd first get the height and width with the java.awt.Toolkit", "label": {"api": {"java.awt.Toolkit": [[109, 124]]}}}, {"text": "Timer.schedule(TimerTask, long) schedules a task to execute once, after the provided delay", "label": {"api": {"Timer.schedule(TimerTask, long)": [[0, 30]]}}}, {"text": "If you want it to repeat, you'll need to use Timer.schedule(TimerTask, long, long)", "label": {"api": {"Timer.schedule(TimerTask, long, long)": [[45, 81]]}}}, {"text": "System.nanoTime() provides nanosecond precision, but not necessarily nanosecond accuracy", "label": {"api": {"provides nanosecond precision, but not necessarily nanosecond accuracy": [[18, 87]]}}}, {"text": "To check the response code you'll have to send a request using java.net.HttpUrlConnection (or any other HTTP library) and then check the response code", "label": {"api": {"java.net.HttpUrlConnection": [[63, 88]]}}}, {"text": "Setting a BoxLayout LayoutManager should help you to align vertically (see Y_AXIS)", "label": {"api": {"BoxLayout": [[10, 18]]}}}, {"text": "HashMap.get will call equals, so for Strings, they must have the exact same content", "label": {"api": {"HashMap.get": [[0, 10]]}}}, {"text": "You can use reflection to get all fields in the class, and loop them to convert to an array of bytes", "label": {"api": {"fields": [[34, 39]]}}}, {"text": "If all your fields are Number (i.e", "label": {"api": {"fields": [[12, 17]], "Number": [[23, 28]]}}}, {"text": "The <dispatcher>ERROR</dispatcher> sets that the filter is only applied to requests dispatched to an error page", "label": {"api": {"dispatched": [[84, 93]]}}}, {"text": "Ok, I've found some soft of solution of how to initialize Blob without accessing session object", "label": {"api": {"Blob": [[58, 61]]}}}, {"text": "I used SerialBlob implementation", "label": {"api": {"Blob": [[13, 16]], "SerialBlob": [[7, 16]]}}}, {"text": "Another approach is to use a hash function (check https://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html) to compute the hash value of the website body", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html": [[50, 123]]}}}, {"text": "Having the session expire will not cause the user object to get removed from the static list, unless the list uses weak references", "label": {"api": {"weak references": [[115, 129]]}}}, {"text": "Weak references are specifically for the case where you want to hold onto a reference to something, but not let that impede having that object get garbage collected once all the non-weak references to it go away", "label": {"api": {"weak references": [[182, 196]]}}}, {"text": "In this example, the DefaultEditorKit action CopyAction is used as the menu item's Action", "label": {"api": {"DefaultEditorKit": [[21, 36]]}}}, {"text": "Use Toolkit.getMenuShortcutKeyMask() to get the correct accelerator, as discussed here", "label": {"api": {"Toolkit.getMenuShortcutKeyMask()": [[4, 35]]}}}, {"text": "According to the Javadocs for TextArea, TextArea defines scrollLeft and scrollTop properties which represent how much the content has been scrolled horizontally and vertically, respectively", "label": {"api": {"Javadocs for TextArea": [[17, 37]]}}}, {"text": "The first part of the code transforms the array of field names into a List of MethodHandle", "label": {"api": {"MethodHandle": [[78, 89]]}}}, {"text": "For each field, a MethodHandle is retrieved for that field", "label": {"api": {"MethodHandle": [[18, 29]]}}}, {"text": "this is done by obtaining a lookup from MethodHandles.lookup() and looking up a handle for the given field name with findGetter", "label": {"api": {"MethodHandle": [[40, 51]], "MethodHandles.lookup()": [[40, 61]], "findGetter": [[117, 126]]}}}, {"text": "Are you perhaps looking for List#add", "label": {"api": {"List#add": [[28, 35]]}}}, {"text": "Yes, you can add a list to another list using ArrayList#addAll - that would look like this", "label": {"api": {"List#add": [[51, 58]], "ArrayList#addAll": [[46, 61]]}}}, {"text": "The recommended way to copy a file is to use Files.copy(src, dest)", "label": {"api": {"Files.copy(src, dest)": [[45, 65]]}}}, {"text": "However I think you would rather move the file in your case", "label": {"api": {"move": [[33, 36]]}}}, {"text": "Use the overload of toUpperCase which accepts a Locale argument", "label": {"api": {"toUpperCase which accepts a Locale argument": [[20, 62]]}}}, {"text": "Use fillRect() to fill a rectangular area rather than just drawing a rectangle", "label": {"api": {"fillRect()": [[4, 13]]}}}, {"text": "Try any of java.util.List implementations for your purposes", "label": {"api": {"java.util.List": [[11, 24]]}}}, {"text": "IllegalArgumentException seems more valid of the two", "label": {"api": {"IllegalArgumentException": [[0, 23]]}}}, {"text": "passed invalid arguments) whereas ArithmeticException implies that the application was incapable of performing the arithmetic but gives no clues as to why", "label": {"api": {"ArithmeticException": [[34, 52]]}}}, {"text": "Use java 8 streams to convert this", "label": {"api": {"stream": [[11, 16]]}}}, {"text": "This makes a stream of the entries, then uses the map method to convert them to strings, then collects it to a list using Collectors.toList()", "label": {"api": {"stream": [[13, 18]], "Collectors.toList()": [[122, 140]]}}}, {"text": "While the above code works, you can also get a List<K> from a map by doing new ArrayList<>(map.keySet()), with this having the advantage than you don't need to convert the entryset to a list, before converted to a stream, and then back a list again", "label": {"api": {"stream": [[214, 219]]}}}, {"text": "You can use the List type's subList method to get a List object with a view of a particular range of elements from the original list", "label": {"api": {"List type's subList method": [[16, 41]]}}}, {"text": "I think it is safest to always use the parameter index when you bind the variable to the stored procedure call, using the setX() methods inherited from PreparedStatement, e.g.", "label": {"api": {"PreparedStatement": [[152, 168]]}}}, {"text": "From the JavaDocs of Connection.prepareCall()", "label": {"api": {"Connection.prepareCall()": [[21, 44]]}}}, {"text": "How safe is it to use java.nio.channels.FileLock for locking files among processes", "label": {"api": {"java.nio.channels.FileLock": [[22, 47]]}}}, {"text": "From the Javadoc of java.nio.channels.FileLock under Platform Dependencies", "label": {"api": {"java.nio.channels.FileLock": [[20, 45]]}}}, {"text": "You could try to use a StringBuilder", "label": {"api": {"StringBuilder": [[23, 35]]}}}, {"text": "I have a JTextField for entering the numbers", "label": {"api": {"JTextField": [[9, 18]]}}}, {"text": "I looked up the JTextField and Caret documentation but didn't find anything that could be useful for me, other than the setVisible() method which didn't work", "label": {"api": {"JTextField": [[16, 25]], "Caret": [[31, 35]]}}}, {"text": "Quoting from the Introduction to FXML", "label": {"api": {"Introduction to FXML": [[17, 36]]}}}, {"text": "There is an interface called Initializable from the fxml library", "label": {"api": {"Initializable": [[29, 41]]}}}, {"text": "The constructor you're using says", "label": {"api": {"constructor you're using": [[4, 27]]}}}, {"text": "The api for List.get() specifies that all List implementations should throw IndexOutOfBoundsException if index == list.size()", "label": {"api": {"List.get()": [[12, 21]]}}}, {"text": "You can use an Image constructor to create a thumbnail image from a larger image, here is a sample from the Image javadoc", "label": {"api": {"Image javadoc": [[108, 120]]}}}, {"text": "ImageIO can be used with SwingFXUtils to persist resized images to disk if you wish to do that", "label": {"api": {"ImageIO": [[0, 6]], "SwingFXUtils": [[25, 36]]}}}, {"text": "After you have created the resized Image, you can place it in an ImageView for display", "label": {"api": {"ImageView": [[65, 73]]}}}, {"text": "You can use an ImageView to resize the view of images by manipulating the ImageView's viewport or fitHeight and fitWidth properties", "label": {"api": {"ImageView": [[15, 23], [74, 82]]}}}, {"text": "Resizing the images in the ImageView rather than the Image constructor means that the Image backing the ImageView remains full size, which will quickly consume a lot of memory when you have a lot of images", "label": {"api": {"ImageView": [[27, 35], [104, 112]]}}}, {"text": "I'm playing with Java 8 Spliterator and created one to stream Fibonacci numbers up to a given n", "label": {"api": {"Spliterator": [[24, 34]]}}}, {"text": "You can use DocumentBuilderFactory and DocumentBuilder that comes along with java Api", "label": {"api": {"DocumentBuilderFactory": [[12, 33]], "DocumentBuilder": [[12, 26], [39, 53]]}}}, {"text": "using https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html this link you solve anything", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[6, 78]]}}}, {"text": "First, if you wish to layout controls vertically consider using VBox", "label": {"api": {"VBox": [[64, 67]]}}}, {"text": "This VBox should then be enclosed by a ScrollPane", "label": {"api": {"VBox": [[5, 8]]}}}, {"text": "If you then set the VBox's prefHeight to Control.USE_COMPUTED_SIZE and maxHeight to Double.POSITIVE_INFINITY the VBox should resize to fit it's content without limit, and the enclosing ScrollPane should show and hide scrollbars as necessary", "label": {"api": {"VBox": [[20, 23], [113, 116]]}}}, {"text": "The algorithm for computing it is specified in String.hashCode's documentation, so you can consider it part of the contract of how a String works", "label": {"api": {"String.hashCode's documentation": [[47, 77]]}}}, {"text": "This is done with parseDefaulting(field, value)", "label": {"api": {"parseDefaulting(field, value)": [[18, 46]]}}}, {"text": "Use the Normalizer class, but it won't do the whole work for you (it'll do a lot though, so you can handle the corner cases separately)", "label": {"api": {"Normalizer": [[8, 17]]}}}, {"text": "Try it like so, using this version of Runtime.exec", "label": {"api": {"Runtime.exec": [[38, 49]]}}}, {"text": "List (and ArrayList) is a sequential list", "label": {"api": {"List": [[0, 3], [15, 18]], "ArrayList": [[10, 18]]}}}, {"text": "the CSS documentation specifies the class names for the scroll pane and its content", "label": {"api": {"CSS documentation": [[4, 20]]}}}, {"text": "You can use Optional", "label": {"api": {"Optional": [[12, 19]]}}}, {"text": "(It will be slower if the UI thread is busy trying to do too much stuff, which you also make happen by scheduling so many calls to Platform.runLater().) You can fix this by using an AnimationTimer", "label": {"api": {"AnimationTimer": [[182, 195]]}}}, {"text": "The AnimationTimer.handle(...) method is called once every time a frame is rendered, so this effectively updates as often as JavaFX allows the UI to update", "label": {"api": {"AnimationTimer": [[4, 17]]}}}, {"text": "Array.sort()'s sorting algorithm is set by its content's natural ordering (the content's implementation of the Comparable interface)", "label": {"api": {"natural ordering": [[57, 72]]}}}, {"text": "For example, String's implementation (under String.compareTo(String)) specifies that this is done by lexicographical order (more commonly known as alphabetical order)", "label": {"api": {"String.compareTo(String)": [[44, 67]]}}}, {"text": "From the Javadoc of ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[20, 43]]}}}, {"text": "What you want is either filter() and findFirst() or iterate()", "label": {"api": {"filter()": [[24, 31]], "findFirst()": [[37, 47]], "iterate()": [[52, 60]]}}}, {"text": "This code simply opens a BufferedReader to a given file path and iterates over each line in it (until readLine() returns null, indicating the end of the file)", "label": {"api": {"BufferedReader": [[25, 38]], "readLine()": [[102, 111]]}}}, {"text": "There are quite a few issues here, which would be solved if you read the docs for Scanner", "label": {"api": {"docs for Scanner": [[73, 88]]}}}, {"text": "The intent of AutoCloseable is to automatically perform cleanups when it is no longer used", "label": {"api": {"AutoCloseable": [[14, 26]]}}}, {"text": "the a in the format is for AM/PM", "label": {"api": {"AM/PM": [[27, 31]]}}}, {"text": "As described in the JVM proxies documentation different system properties are required for the JVM wide proxy settings for http vs https", "label": {"api": {"JVM proxies documentation": [[20, 44]]}}}, {"text": "That means that when your matrix is changed by adding/deleting columns, you should call fireTableStructureChanged (from within the AbstractTableModel subclass)", "label": {"api": {"fireTableStructureChanged": [[88, 112]]}}}, {"text": "The API docs for SimpleDateFormat specifies, for Year", "label": {"api": {"API docs for SimpleDateFormat": [[4, 32]]}}}, {"text": "In Java 8, Map provides a getOrDefault method", "label": {"api": {"getOrDefault": [[26, 37]], "get": [[26, 28]]}}}, {"text": "In earlier versions, you are probably stuck with either getting the value for the key with get, and null-checking it; or using something like", "label": {"api": {"get": [[56, 58], [91, 93]]}}}, {"text": "You could use a CountDownLatch with a set count to wait until all invocations have finished, if you know beforehand how many calls you're going to perform", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "Your boolean vis field may be public, but \"The results of a write by one thread are guaranteed to be visible to a read by another thread only if the write operation happens-before the read operation.\" Make the field volatile, because \"A write to a volatile field happens-before every subsequent read of that same field.\" See Memory Consistency Properties for details", "label": {"api": {"Memory Consistency Properties": [[325, 353]]}}}, {"text": "For serialization, a MessageBodyWriter is used, and for deserialization, a MessageBodyReader is used", "label": {"api": {"MessageBodyWriter": [[21, 37]], "MessageBodyReader": [[75, 91]]}}}, {"text": "That said there are different MessageBodyWriters for Form and for String, namely FormProvider and StringMessageProvider, respectively", "label": {"api": {"MessageBodyWriter": [[30, 46]]}}}, {"text": "This will print the image scaled to the largest size that can be fit into a rectangle of pageLayout.getPrintableWidth() x pageLayout.getPrintableHeight() preserving the ratio, see ImageView.preserveRation", "label": {"api": {"ImageView.preserveRation": [[180, 203]]}}}, {"text": "Alternatively, with most libraries for creating mock collaborators, one could mock a Consumer that \"expects\" a series of accept() calls with particular elements", "label": {"api": {"Consume": [[85, 91]]}}}, {"text": "Consume the Stream with it, and then \"verify\" that its configured expectations were met", "label": {"api": {"Consume": [[0, 6]]}}}, {"text": "Alternatively, Java has a Calendar class which has functions to convert from epoch time to regular dates", "label": {"api": {"Calendar class": [[26, 39]]}}}, {"text": "There is no native Java SDK from Parse but you could use the REST Api and HttpUrlConnection class or any other http framwork to connect to the Parse API", "label": {"api": {"HttpUrlConnection": [[74, 90]]}}}, {"text": "So, in this case, wrap all your code inside your main inside a call to SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[71, 96]]}}}, {"text": "Java 8 introduced the method Files.walk(path) that returns a Stream of all the paths under a given path, recursively", "label": {"api": {"Files.walk(path)": [[29, 44]]}}}, {"text": "source.relativize(p) returns the relative path from the source to this path", "label": {"api": {"source.relativize(p)": [[0, 19]]}}}, {"text": "destination.resolve(other) returns the path constructed by appending this path to the other path", "label": {"api": {"destination.resolve(other)": [[0, 25]]}}}, {"text": "We first need to create the parent directories with Files.createDirectories(dir)", "label": {"api": {"Files.createDirectories(dir)": [[52, 79]]}}}, {"text": "dest.getParent() returns the parent path, that is to say, it drops the filename from the path", "label": {"api": {"dest.getParent()": [[0, 15]]}}}, {"text": "The final step is moving the source path to the target path with Files.move(source, target)", "label": {"api": {"Files.move(source, target)": [[65, 90]]}}}, {"text": "If you can't upgrade to Java 8 yet and keep with Java 7, you can still use Files.walkFileTree instead of Files.walk (the rest of the code would need adjustment but the idea is the same)", "label": {"api": {"Files.walkFileTree": [[75, 92]]}}}, {"text": "See here https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html#println() for the overloaded methods", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html#println()": [[9, 84]]}}}, {"text": "From the docs for the iterator of PriorityQueue", "label": {"api": {"for the iterator of PriorityQueue": [[14, 46]]}}}, {"text": "Your code essentially loops over the input strings, performs doSomthing on each of them (map in Java's terminology), ignores the results that are null (filter in Java's terminology) and then produces a list of those results (collect in Java's terminology)", "label": {"api": {"map": [[89, 91]], "filter": [[152, 157]], "collect": [[225, 231]]}}}, {"text": "As suggested by Tunaki, the not-null check can be cleaned up with Objects::nonNull", "label": {"api": {"Objects::nonNull": [[66, 81]]}}}, {"text": "Assuming this is an anonymous implementation of java.awt.event.ItemListener, it should implement the method itemStateChanged(ItemEvent e) - note the lowercase i in the API specification as opposed to the upper case I in your implementation", "label": {"api": {"java.awt.event.ItemListener": [[48, 74]], "itemStateChanged(ItemEvent e)": [[108, 136]]}}}, {"text": "Java 7 Collections.sort(list, c) specifies that", "label": {"api": {"Collections.sort(list, c)": [[7, 31]]}}}, {"text": "However, CopyOnWriteArrayList listIterator() method states that the iterator returned does not support the set operation", "label": {"api": {"listIterator()": [[30, 43]]}}}, {"text": "In Java 8, Collections.sort(list, c) changed implementation", "label": {"api": {"Collections.sort(list, c)": [[11, 35]]}}}, {"text": "And the new method CopyOnWriteArrayList.sort(c) (introduced in Java 8) does not use the list iterator so it works correctly", "label": {"api": {"CopyOnWriteArrayList.sort(c)": [[19, 46]]}}}, {"text": "In Java 8 the implementation of Collections.sort(List, Comparator) has been changed to now redirect to a new sort method in the List interface", "label": {"api": {"new sort method in the List interface": [[105, 141]]}}}, {"text": "It is called Math.hypot", "label": {"api": {"Math.hypot": [[13, 22]]}}}, {"text": "On that class you have the method distance(Point2D), which gives you the desired result", "label": {"api": {"distance(Point2D)": [[34, 50]]}}}, {"text": "Say, Boolean.valueOf(boolean value) in the standard library exists for the purpose of avoiding creation of extra objects", "label": {"api": {"Boolean.valueOf(boolean value)": [[5, 34]]}}}, {"text": "You can simply call the setBackground method to set the JButton's color", "label": {"api": {"setBackground": [[24, 36]]}}}, {"text": "You can use either Integer.parseInt( String s, int radix) or Long.parseLong( String s, int radix)", "label": {"api": {"Integer.parseInt( String s, int radix)": [[19, 56]], "Long.parseLong( String s, int radix)": [[61, 96]]}}}, {"text": "Your first attempt at optimisation should be to switch to a ConcurrentSkipListMap", "label": {"api": {"ConcurrentSkipListMap": [[60, 80]]}}}, {"text": "In your uploadFinished() method, you could first test the file type using https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#probeContentType(java.nio.file.Path)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#probeContentType(java.nio.file.Path)": [[74, 176]]}}}, {"text": "The argument to createElement() is called tagName, and is only that (\"img\" in your case)", "label": {"api": {"createElement()": [[16, 30]]}}}, {"text": "You need to call setAttribute(String name, String value) on the returned Element", "label": {"api": {"setAttribute(String name, String value)": [[17, 55]]}}}, {"text": "I have looked up java doc about LinkedBlockingQueue and SynchronousQueue,but I still don't know why they are used here,Is performance considering or others", "label": {"api": {"LinkedBlockingQueue": [[32, 50]], "SynchronousQueue": [[56, 71]]}}}, {"text": "From the Scanner documentation (emphasis by me)", "label": {"api": {"Scanner documentation": [[9, 29]]}}}, {"text": "You have the problem, that the Scanner is reading from the given InputStream which can be something like a file or in your case System.in", "label": {"api": {"Scanner": [[31, 37]], "InputStream": [[65, 75]], "System.in": [[128, 136]]}}}, {"text": "If your curly braces in the ArrayList are actually brackets (they probably are), you can use", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "if your ArrayList elements are also ArrayList then you need to use get(0).get(1) instead of get(0)[1]", "label": {"api": {"ArrayList": [[8, 16], [36, 44]]}}}, {"text": "From the documentation of FunctionalInterface", "label": {"api": {"documentation of FunctionalInterface": [[9, 44]]}}}, {"text": "You can use the constructor that gets a mode parameter, and pass FileDialog.SAVE", "label": {"api": {"constructor that gets a mode parameter": [[16, 53]]}}}, {"text": "I see that class UserTransactionAdapter implements UserTransaction but javax.transaction.UserTransaction don't exists in any spring jar", "label": {"api": {"UserTransaction": [[17, 31], [51, 65], [89, 103]]}}}, {"text": "In the other hand javax.transaction.UserTransaction exist in jboss runtime library but the implementation is in spring jar", "label": {"api": {"UserTransaction": [[36, 50]]}}}, {"text": "And another UserTransaction (from jbossxts-4.17.21.Final-redhat-2.jar) implementation", "label": {"api": {"UserTransaction": [[12, 26]]}}}, {"text": "UserTransactionImpl can be found in jbossxts-4.17.21.Final-redhat-2.jar in jboss modules folder", "label": {"api": {"UserTransaction": [[0, 14]]}}}, {"text": "In cases like these, use Task utility class which is similar to SwingWorker", "label": {"api": {"Task": [[25, 28]]}}}, {"text": "Run all background tasks on call method", "label": {"api": {"call": [[28, 31]]}}}, {"text": "In your case, you can instantly change text of dirStatus Text to \"Search in progress...\" (in buttons handle method) and then start \"Task\"", "label": {"api": {"Task": [[132, 135]]}}}, {"text": "And after task is done, you may remove \"Search in progress...\" from succeeded method (note that succeeded method runs in FX application thread so it's perfectly safe to update your Text from there)", "label": {"api": {"succeeded": [[68, 76], [96, 104]]}}}, {"text": "The API is a bit dusty, but there is a SequenceInputStream that will create what appears to be a single InputStream from a series of sub-streams", "label": {"api": {"SequenceInputStream": [[39, 57]]}}}, {"text": "Try ChronoUnit class", "label": {"api": {"ChronoUnit": [[4, 13]]}}}, {"text": "Use the java.net.URLEncoder and java.netURLDecoder to encode/decode URLs", "label": {"api": {"URLDecoder": [[40, 49]]}}}, {"text": "Maybe you should give a look on URLDecoder that would solve your problem", "label": {"api": {"URLDecoder": [[32, 41]]}}}, {"text": "You can use PopupFactory for this", "label": {"api": {"PopupFactory": [[12, 23]]}}}, {"text": "This looks like the format supported by the Java 8 java.time.Period class", "label": {"api": {"java.time.Period": [[51, 66]]}}}, {"text": "You need to upgrade your Java to at least Java6", "label": {"api": {"Java6": [[42, 46]]}}}, {"text": "It is because this function was added in Java6 and is not present in Java5", "label": {"api": {"Java6": [[41, 45]], "Java5": [[69, 73]]}}}, {"text": "Find the proper Element for the line number, get the start and end offset of the string in that line and replace the textarea text within those offsets with the new text", "label": {"api": {"Element": [[16, 22]]}}}, {"text": "You can run Java programs under a SecurityManager which can allow or block different kinds of operations, regardless of which user the program is being run by", "label": {"api": {"SecurityManager": [[34, 48]]}}}, {"text": "Any properties you configure the ResourceConfig using it's property(key, value), will be accessible through the Configuration interface which you can inject into your resource class", "label": {"api": {"Configuration": [[112, 124]]}}}, {"text": "Configuration Properties with Jersey for some other ideas", "label": {"api": {"Configuration": [[0, 12]]}}}, {"text": "FileChannel's force() method offers stronger guarantees about the state of the file after it returns than OutputStream's flush() method", "label": {"api": {"force()": [[14, 20]]}}}, {"text": "Obviously you do not have to close() the FileChannel that you called the force() method on", "label": {"api": {"force()": [[73, 79]]}}}, {"text": "If you need the behavior that force() specifies as part of the channel closure then you must explicitly call it the way you are doing in your close() method", "label": {"api": {"force()": [[30, 36]]}}}, {"text": "In order to be able to use the foreach construct, one has to implement Iterable<T> interface for the class", "label": {"api": {"Iterable<T>": [[71, 81]]}}}, {"text": "It should provide an Iterator<T> with the corresponding iterator() method", "label": {"api": {"Iterator<T>": [[21, 31]]}}}, {"text": "Writing an Iterator<T> implementation for your List<L> is rather simple, it should reference a ListCell<T>", "label": {"api": {"Iterator<T>": [[11, 21]]}}}, {"text": "Then you would add Iterable<T> interface to List<L> and just create a ListCellIterator<T> pointing at the first node in your iterator() method", "label": {"api": {"Iterable<T>": [[19, 29]], "Iterator<T>": [[78, 88]]}}}, {"text": "I noticed that Google Guava Sets class offers methods such as newHashSet taking an Iterable or Iterator", "label": {"api": {"HashSet": [[65, 71]]}}}, {"text": "The HashSet class bundled with Java already offers a constructor taking a Collection thereby giving similar behavior", "label": {"api": {"HashSet": [[4, 10]]}}}, {"text": "Maybe a GridBagLayout might not be suited for your current UI, and a BorderLayout would work better", "label": {"api": {"BorderLayout": [[69, 80]]}}}, {"text": "Put the red panel in BorderLayout.NORTH and put the blue panel in BorderLayout.CENTER", "label": {"api": {"BorderLayout": [[21, 32], [66, 77]]}}}, {"text": "See ArrayList that extends AbstractList and implements List", "label": {"api": {"ArrayList": [[4, 12]], "AbstractList": [[27, 38]], "List": [[9, 12], [35, 38], [55, 58]]}}}, {"text": "You can do this with a JAXRS Application and overriding getSingletons", "label": {"api": {"Application": [[29, 39]]}}}, {"text": "The problem is that you are using Matcher.matches() which, as the docs say", "label": {"api": {"Matcher.matches()": [[34, 50]]}}}, {"text": "Instead of Matcher.matches() you should use Matcher.find() which will find the next partial match", "label": {"api": {"Matcher.matches()": [[11, 27]], "Matcher.find()": [[44, 57]]}}}, {"text": "The ResultSetIterator implements Java's Iterator", "label": {"api": {"Iterator": [[13, 20], [40, 47]]}}}, {"text": "See the Javadoc for PipedReader.read()", "label": {"api": {"PipedReader.read()": [[20, 37]]}}}, {"text": "To schedule a task, use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[26, 49]]}}}, {"text": "You can use java.util.zip.ZipInputStream class to parse Zip file on-the-fly", "label": {"api": {"java.util.zip.ZipInputStream": [[12, 39]]}}}, {"text": "You are almost there - Matcher::matches attempts to match the whole string", "label": {"api": {"Matcher::matches attempts to match the whole string": [[23, 73]]}}}, {"text": "You can create a BooleanBinding with the help of the Bindings utility class and bind the disableProperty of a Button to it", "label": {"api": {"BooleanBinding": [[17, 30]], "Bindings": [[53, 60]], "disableProperty": [[89, 103]], "Button": [[110, 115]]}}}, {"text": "Also see the documentation for the java.lang.Character class", "label": {"api": {"java.lang.Character": [[35, 53]]}}}, {"text": "In the java api for AbstractTableModel, the parameters to fireTableCellUpdated are named row and column", "label": {"api": {"java api for AbstractTableModel": [[7, 37]], "TableModel": [[28, 37]]}}}, {"text": "getValueAt and setValueAt (from TableModel), uses the names rowIndex and columnIndex", "label": {"api": {"TableModel": [[32, 41]]}}}, {"text": "In the How to use Tables tutorial, there is a sample implementation of AbstractTableModel", "label": {"api": {"TableModel": [[79, 88]]}}}, {"text": "In this example, they implement setValueAt and drop the \"Index\" suffix to the parameters compared to the method defined in TableModel", "label": {"api": {"TableModel": [[123, 132]]}}}, {"text": "Enum already implements Comparable", "label": {"api": {"Enum": [[0, 3]], "Comparable": [[24, 33]]}}}, {"text": "But you can pass a custom Comparator to the TreeMap", "label": {"api": {"pass": [[12, 15]], "Comparator": [[26, 35]]}}}, {"text": "It is not necessary to call close() on the ResultSet here, because according to the Statement.close() doc", "label": {"api": {"Statement.close()": [[84, 100]]}}}, {"text": "But that's a bit of \"reinventing the wheel\", instead, you could just use the removeAll(Collcetion) method", "label": {"api": {"removeAll(Collcetion)": [[77, 97]]}}}, {"text": "Arrays.asList() takes a vararg as argument", "label": {"api": {"takes a vararg as argument": [[16, 41]]}}}, {"text": "Use the Sort overload that lets you pass a Comparator", "label": {"api": {"Sort overload": [[8, 20]]}}}, {"text": "You can use java.util.logging.LogManager.reset() to reload the default system configuration", "label": {"api": {"java.util.logging.LogManager.reset()": [[12, 47]]}}}, {"text": "Alternatively you can use the LogManager to enumerate all loggers and try to track down the handler, remove, and close it", "label": {"api": {"enumerate": [[44, 52]]}}}, {"text": "DocumentBuilder.parse to parse the file, call getDocumentElement() and check for getPrefix", "label": {"api": {"DocumentBuilder.parse": [[0, 20]], "getPrefix": [[81, 89]]}}}, {"text": "It uses LockSupport.park() which calls Unsafe's public native void park(boolean var1, long var2)", "label": {"api": {"LockSupport.park()": [[8, 25]]}}}, {"text": "Use the Duration from Java 8", "label": {"api": {"Duration": [[8, 15]]}}}, {"text": "I noticed an issue with java.lang.Boolean class that it can not parse nulls", "label": {"api": {"java.lang.Boolean": [[24, 40]]}}}, {"text": "I know it has the parseBoolean static method but as it's signature states it only accepts String and not an Object", "label": {"api": {"parseBoolean": [[18, 29]]}}}, {"text": "This is a feature of String.split", "label": {"api": {"String.split": [[21, 32]]}}}, {"text": "Reason for ConcurrentModificationException is you are trying to add to the list at the same time when you are iterating like", "label": {"api": {"ConcurrentModificationException": [[11, 41]]}}}, {"text": "You can use an Executor", "label": {"api": {"Executor": [[15, 22]]}}}, {"text": "The java.time framework built into Java 8 and later supports these formats", "label": {"api": {"java.time": [[4, 12]]}}}, {"text": "By default, the implementation of SecurityContextHolder is bound to an instance of ThreadLocal", "label": {"api": {"ThreadLocal": [[83, 93]]}}}, {"text": "The composition over ThreadLocal enables the user of API to be able take advantage of working with multiple views of data in different threads", "label": {"api": {"ThreadLocal": [[21, 31]]}}}, {"text": "As an addition to Wiktor Stribiżew’s answer, you may do the same without having to specify the pattern twice, by dealing with the java.util.regex package directly", "label": {"api": {"java.util.regex": [[130, 144]]}}}, {"text": "You can make a subclass of FilterOutputStream which writes the same bytes to multiple OutputStreams", "label": {"api": {"FilterOutputStream": [[27, 44]]}}}, {"text": "You can implement a functional interface (https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html) like java.util.function.Function in your class and expose an object of it as a global variable to nashorn", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html": [[42, 117]]}}}, {"text": "GridPane has an alignment property for setting \"The alignment of of the grid within the gridpane's width and height.\"", "label": {"api": {"alignment property": [[16, 33]]}}}, {"text": "A simple way would be not to use split but take the substring starting from the first index of", "label": {"api": {"substring": [[52, 60]]}}}, {"text": "If the colon isn't found, indexOf(':') will return -1 and you can start the substring at 0", "label": {"api": {"indexOf(':')": [[26, 37]], "substring": [[76, 84]]}}}, {"text": "Since you're inheriting from the Dialog class", "label": {"api": {"Dialog": [[33, 38]]}}}, {"text": "As you can see from the linked javadocs, Dialog does not have a constructor that takes only a string - you have to pass other parameters first (either another Dialog, Frame, Window, or null)", "label": {"api": {"Dialog": [[41, 46], [159, 164]]}}}, {"text": "As a temporary workaround, you can call super using null as the first parameter - this means that the Dialog you're creating does not have a parent window", "label": {"api": {"Dialog": [[102, 107]]}}}, {"text": "The method List.sort(comparator) that you are refering to was introduced in Java 8, whereas the utility method Collections.sort has been there since Java 1.2", "label": {"api": {"List.sort(comparator)": [[11, 31]], "Collections.sort": [[111, 126]]}}}, {"text": "Note that the change in implementation for Collections.sort was made in 8u20", "label": {"api": {"Collections.sort": [[43, 58]]}}}, {"text": "With Pattern.MULTILINE, the ^ is expected to match at the beginning of the string, but in Java it can be a bit different", "label": {"api": {"in Java": [[87, 93]]}}}, {"text": "Use createNativeQuery() to execute SQL", "label": {"api": {"createNativeQuery()": [[4, 22]]}}}, {"text": "The correct way to write your code is to use System.lineSeparator()", "label": {"api": {"System.lineSeparator()": [[45, 66]]}}}, {"text": "if you are building a string one piece at a time in a loop, you should use a StringBuilder instead of String", "label": {"api": {"StringBuilder": [[77, 89]]}}}, {"text": "Use returned Future object for control", "label": {"api": {"returned": [[4, 11]], "Future": [[13, 18]]}}}, {"text": "The main purpose of using ExecutorService is to hide how threads are created, reused and in general managed for the programmer", "label": {"api": {"ExecutorService": [[26, 40]]}}}, {"text": "Set a limit on your split", "label": {"api": {"Set a limit": [[0, 10]]}}}, {"text": "Streams are the most powerful, versatile tools for the job, this here will solve your problem if your want to find min/max of an array of Double", "label": {"api": {"Streams": [[0, 6]]}}}, {"text": "TreeSet is meant to maintain the order (either ascending or descending) of the elements as per either", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "while constructing TreeSet where you pass your implementation of how you want to order elements within set by implementing Comparator interface something like", "label": {"api": {"TreeSet": [[19, 25]]}}}, {"text": "I don't know where you got the idea that \"you can not assume any specific ordering\" of the elements returned by an Iterator", "label": {"api": {"Iterator": [[115, 122]]}}}, {"text": "Now, the javadoc of the iterator() method of Collection says", "label": {"api": {"iterator()": [[24, 33]]}}}, {"text": "For example, TreeSet, LinkedHashSet, EnumSet, and all List implementations do guarantee a defined order", "label": {"api": {"TreeSet": [[13, 19]], "LinkedHashSet": [[22, 34]], "EnumSet": [[37, 43]], "List": [[54, 57]]}}}, {"text": "TreeSet - The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "LinkedHashSet - This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order)", "label": {"api": {"LinkedHashSet": [[0, 12]]}}}, {"text": "EnumSet - The iterator returned by the iterator method traverses the elements in their natural order (the order in which the enum constants are declared)", "label": {"api": {"EnumSet": [[0, 6]]}}}, {"text": "List - An ordered collection (also known as a sequence)", "label": {"api": {"List": [[0, 3]]}}}, {"text": "- iterator() returns an iterator over the elements in this list in proper sequence", "label": {"api": {"iterator()": [[2, 11]]}}}, {"text": "The proper way to do this is to use the session and use response.sendRedirect or RequestDispatcher.forward methods", "label": {"api": {"response.sendRedirect": [[56, 76]], "RequestDispatcher.forward": [[81, 105]]}}}, {"text": "Javadoc (https://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html#tailMap(K)) is quite clear", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html#tailMap(K)": [[9, 85]]}}}, {"text": "FileImageOutputStream won't create the file if it doesn't exist", "label": {"api": {"FileImageOutputStream": [[0, 20]]}}}, {"text": "This can easily be done using Java NIO.2 API with Files.createDirectory(dir)", "label": {"api": {"Files.createDirectory(dir)": [[50, 75]]}}}, {"text": "If you need to create all the parent directories as well, you can use Files.createDirectories(dir)", "label": {"api": {"Files.createDirectories(dir)": [[70, 97]]}}}, {"text": "See the @XmlType annotation for how the type names of your classes are computed", "label": {"api": {"@XmlType": [[8, 15]]}}}, {"text": "The best way to accept any primitive type is to have overloads for every primitive type, like many methods in the core library do", "label": {"api": {"many methods in the core library do": [[94, 128]]}}}, {"text": "Depending on the needs, it might be better to use a class designed specifically for this purpose, like Date, both in the method and at the place where the method is called", "label": {"api": {"Date": [[103, 106]]}}}, {"text": "You can try using CopyOnWriteArrayList if you need that functionality", "label": {"api": {"CopyOnWriteArrayList": [[18, 37]]}}}, {"text": "You should use either List.set(int index, E element), or ListIterator.set(E e)", "label": {"api": {"List.set(int index, E element)": [[22, 51]], "ListIterator.set(E e)": [[57, 77]]}}}, {"text": "For a counterpoint, consider the behavior of autoboxed integers, as well as the related static methods such as Integer.valueOf()", "label": {"api": {"Integer.valueOf()": [[111, 127]]}}}, {"text": "I have used StringBuilder instead of a String", "label": {"api": {"String": [[12, 17], [39, 44]], "StringBuilder": [[12, 24]]}}}, {"text": "String and StringBuilder", "label": {"api": {"String": [[0, 5], [11, 16]], "StringBuilder": [[11, 23]]}}}, {"text": "Or you can use RandomAccessFile to set offset for the file then start reading", "label": {"api": {"RandomAccessFile": [[15, 30]]}}}, {"text": "The Java API documentation describes the purpose very clearly", "label": {"api": {"Java API documentation": [[4, 25]]}}}, {"text": "You can use Collectors.partitioningBy which does exactly what you want", "label": {"api": {"Collectors.partitioningBy": [[12, 36]]}}}, {"text": "Class.getResourceAsStream(name) attempts to find a resource with the given name, not an arbitrary file", "label": {"api": {"Class.getResourceAsStream(name)": [[0, 30]]}}}, {"text": "What you can do is use the Java NIO.2 API with the help of Files.newInputStream(path)", "label": {"api": {"Files.newInputStream(path)": [[59, 84]]}}}, {"text": "You can get a Path instance with the static factory Paths.get(first, more...)", "label": {"api": {"Paths.get(first, more...)": [[52, 76]]}}}, {"text": "In Java 8 you could use an Optional<Date> and check its empty() or isPresent() methods", "label": {"api": {"Optional<Date>": [[27, 40]]}}}, {"text": "You might use the standard Map.Entry<K,V> but I would personally suggest Apache Commons Lang3's Tuple type if possible", "label": {"api": {"Map.Entry<K,V>": [[27, 40]]}}}, {"text": "In non-POSIX regex flavors (as in Java, as The Pattern engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5), the first alternative is matched", "label": {"api": {"The Pattern engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5": [[43, 145]]}}}, {"text": "If you want your ID to be generated only in database and just read by hibernate you can use parameters 'insertable' and 'updatable' in @Column annotation", "label": {"api": {"@Column": [[135, 141]]}}}, {"text": "The standard java.util.Date class has a constructor Date(int year, int month, int date) but it has been deprecated for a long time", "label": {"api": {"java.util.Date": [[13, 26]]}}}, {"text": "You could also use a BreakIterator", "label": {"api": {"a BreakIterator": [[19, 33]]}}}, {"text": "Use a CSS Pseudoclass", "label": {"api": {"CSS Pseudoclass": [[6, 20]]}}}, {"text": "There is an overload of println that specifically takes a char", "label": {"api": {"overload of println that specifically takes a char": [[12, 61]]}}}, {"text": "To uncompress the response you can use GZipInputStream", "label": {"api": {"GZipInputStream": [[39, 53]]}}}, {"text": "You can fix both problems by making the count static variable an AtomicInteger", "label": {"api": {"AtomicInteger": [[65, 77]]}}}, {"text": "Use getAndIncrement instead of ++, and getAndAdd instead of +=", "label": {"api": {"getAndIncrement": [[4, 18]], "getAndAdd": [[39, 47]]}}}, {"text": "With 24 days, the product remains just below the maximum possible int value, Integer.MAX_VALUE, which is 2,147,483,647", "label": {"api": {"Integer.MAX_VALUE": [[77, 93]]}}}, {"text": "For such values, use a long literal for the first value (or cast it to a long) to avoid the overflow that comes with exceeding Integer.MAX_VALUE", "label": {"api": {"Integer.MAX_VALUE": [[127, 143]]}}}, {"text": "This works fine because the desired constructor for Date takes a long", "label": {"api": {"desired constructor for Date takes a long": [[28, 68]]}}}, {"text": "Also, with Java 8+, you can use Instant and its minus method to subtract the time", "label": {"api": {"Instant and its minus method": [[32, 59]]}}}, {"text": "I'm writing a utility class for FileChannels", "label": {"api": {"FileChannel": [[32, 42]]}}}, {"text": "To get a hold of the entries, you call Map.entrySet()", "label": {"api": {"Map.entrySet()": [[39, 52]]}}}, {"text": "This returns a Set<Map.Entry<String, Integer>> in your case", "label": {"api": {"Map.Entry": [[19, 27]]}}}, {"text": "Map.Entry represents an entry of the map", "label": {"api": {"Map.Entry": [[0, 8]]}}}, {"text": "getKey() returns the key of this entry, which is the word to write", "label": {"api": {"getKey()": [[0, 7]]}}}, {"text": "getValue() returns the value of this entry, which is the number of times it should be written", "label": {"api": {"getValue()": [[0, 9]]}}}, {"text": "Try using getDocumentElement instead of the first getElementsByTagName (by the way what's the value of element - should be \"map\")", "label": {"api": {"getDocumentElement": [[10, 27]]}}}, {"text": "The method split() belongs to String, not to Array", "label": {"api": {"split()": [[11, 17]], "String": [[30, 35]], "Array": [[45, 49]]}}}, {"text": "To make this work, you must define your data as String data = \"3.5,2.3,4.2,5.4,7.4,2.7\"; instead", "label": {"api": {"String": [[48, 53]]}}}, {"text": "setPreferredSize \"returns\" a void, so it cannot be passed as a parameter to add", "label": {"api": {"setPreferredSize": [[0, 15]], "add": [[76, 78]]}}}, {"text": "But The WebEngine class returns Documents which are very limited in selector possibilities compared to JSoup", "label": {"api": {"Documents": [[32, 40]]}}}, {"text": "If you want such a functionality, I would point to Set", "label": {"api": {"Set": [[51, 53]]}}}, {"text": "Observable.notifyObservers() will notify the observers only if the observable has been marked as changed", "label": {"api": {"Observable.notifyObservers()": [[0, 27]]}}}, {"text": "The way to set it changed is calling setChanged() - and that method is protected instead of public", "label": {"api": {"setChanged()": [[37, 48]]}}}, {"text": "You can just wait until all threads finish their job using CountDownLatch", "label": {"api": {"CountDownLatch": [[59, 72]]}}}, {"text": "To extract the number, you can use a Pattern and create a capturing group for the number", "label": {"api": {"Pattern": [[37, 43]]}}}, {"text": "This is done by creating a Matcher with the help of Pattern.matcher(input), filtering again the lines that actually contains a number with Matcher.find() and extracting the captured number with Matcher.group(group)", "label": {"api": {"Pattern": [[52, 58]], "Matcher": [[27, 33], [139, 145], [194, 200]], "Pattern.matcher(input)": [[52, 73]], "Matcher.find()": [[139, 152]], "Matcher.group(group)": [[194, 213]]}}}, {"text": "This Stream is converted to an Stream<Integer> with Stream.map(mapper)", "label": {"api": {"Stream<Integer>": [[31, 45]], "Stream.map(mapper)": [[52, 69]]}}}, {"text": "Finally, to sum the three biggest element, the Stream is sorted in reverse order (sorted(comparator) where the comparator is reverseOrder()), limited to the first 3 elements (limit(3)) and those elements are summed (sum() by first converting the Stream<Integer> into an IntStream with Stream.mapToInt)", "label": {"api": {"Stream<Integer>": [[246, 260]], "sorted(comparator)": [[82, 99]], "reverseOrder()": [[125, 138]], "limit(3)": [[175, 182]], "sum()": [[216, 220]], "Stream.mapToInt": [[285, 299]]}}}, {"text": "A primitive double isn't a Comparable, so you need to adapt this comparator to compare double[]", "label": {"api": {"Comparable": [[27, 36]]}}}, {"text": "To print the content of the array and not its address, use Arrays.toString", "label": {"api": {"Arrays.toString": [[59, 73]]}}}, {"text": "The meaning of the expression can be fully understood by following the regex Pattern reference documentation", "label": {"api": {"regex Pattern reference": [[71, 93]]}}}, {"text": "Round the result to the nearest integer", "label": {"api": {"Round": [[0, 4]]}}}, {"text": "You can read more about how to form the correct expression at Regular expressions", "label": {"api": {"Regular expressions": [[62, 80]]}}}, {"text": "The List.sort(...) method takes a Comparator which determines how the elements in the list should be compared to each other for the purposes of determining the order", "label": {"api": {"List.sort(...) method": [[4, 24]], "Comparator": [[34, 43]]}}}, {"text": "You can either implement Comparator yourself to specify that the Points should be compared by comparing their x values, which takes several lines of code, or you can use one of the built-in Comparators", "label": {"api": {"Comparator": [[25, 34], [190, 199]]}}}, {"text": "The Comparator interface defines default implementations for the case where you want to compare via something that is a simple function of the list element", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "Since you are comparing on an int property, you can use Comparator.comparingInt as follows", "label": {"api": {"Comparator": [[56, 65]], "Comparator.comparingInt": [[56, 78]]}}}, {"text": "The method Files.lines(path, cs) returns a Stream<Path> that already has a close handler closing the internal BufferedReader", "label": {"api": {"Files.lines(path, cs)": [[11, 31]]}}}, {"text": "See the Java documentation", "label": {"api": {"the Java documentation": [[4, 25]]}}}, {"text": "Because JBList extends JList, you may be able to use setVisibleRowCount(), as shown here", "label": {"api": {"JList": [[23, 27]]}}}, {"text": "I would pursue a solution similar to the one in the ReentrantReadWriteLock docs", "label": {"api": {"ReentrantReadWriteLock": [[52, 73]]}}}, {"text": "If you check out the Date javadoc you'll see that the constructor that you're calling requires the year-1900", "label": {"api": {"Date": [[21, 24]]}}}, {"text": "The comparator is created with the help of Comparator.comparingInt(keyExtractor) where the key extraction would be a function returning the value of a word", "label": {"api": {"Comparator.comparingInt(keyExtractor)": [[43, 79]]}}}, {"text": "This is done by creating a Stream<String> of the words (Arrays.stream(array)), sorting it according the comparator above (sorted(comparator)), mapping each word to the result of concatenating its value to it and finally collecting that into a String delimited by a space (Collectors.joining(delimiter))", "label": {"api": {"Arrays.stream(array)": [[56, 75]], "sorted(comparator)": [[122, 139]], "Collectors.joining(delimiter)": [[272, 300]]}}}, {"text": "System.out is an instance of java.io.PrintStream class that is provided as a static field of the System class", "label": {"api": {"java.io.PrintStream": [[29, 47]], "System": [[0, 5], [97, 102]]}}}, {"text": "All format specifiers are explained in the description of the java.util.Formatter class", "label": {"api": {"java.util.Formatter": [[62, 80]]}}}, {"text": "In the Java documentation for the Stream.collect (https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-) it says that as the second parameter a function which matches the functional interface BiConsumer is required which has an abstract method with two arguments", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-": [[50, 216]]}}}, {"text": "The method ResultSet.getObject(String columnLabel, Class<T> type) was added in JDBC 4.1 (Java 7)", "label": {"api": {"ResultSet.getObject(String columnLabel, Class<T> type)": [[11, 64]]}}}, {"text": "The index given to the methods in String in an index of it's underlying array char[] value not the index of a code point", "label": {"api": {"String": [[34, 39]]}}}, {"text": "These check bounds and wrap methods of Character", "label": {"api": {"Character": [[39, 47]]}}}, {"text": "the corresponding methods in Character identify and combine multiple char that belong to a single code point", "label": {"api": {"Character": [[29, 37]]}}}, {"text": "Something like tryLock", "label": {"api": {"tryLock": [[15, 21]]}}}, {"text": "For example, in your code mapToInt method is called with stateful lambda while documentation explicitly says that the passed function must be stateless", "label": {"api": {"explicitly says": [[93, 107]]}}}, {"text": "The correct way to access such data is with the Class.getResource method, which scans the classpath for the requested entry", "label": {"api": {"Class.getResource": [[48, 64]]}}}, {"text": "That's why Class.getResource assumes, by default, that your file is in a directory that matches the Class object's package structure", "label": {"api": {"Class.getResource": [[11, 27]]}}}, {"text": "You should probably use the publish/process API of the SwingWorker (see the second example of the SwingWorker API doc for code)", "label": {"api": {"SwingWorker API doc": [[98, 116]]}}}, {"text": "You could use a regular expression, particularly the Matcher class' find method", "label": {"api": {"Matcher": [[53, 59]]}}}, {"text": "It is wrapped with a call to collectingAndThen to extract the Optional value out of the first() collector (first() returns an Optional to handle the case where the stream is empty and would collect into an empty Optional; this is not possible here so we can call get() safely)", "label": {"api": {"collectingAndThen": [[29, 45]]}}}, {"text": "The second collector simply sums all the quantities with summingInt", "label": {"api": {"summingInt": [[57, 66]]}}}, {"text": "Since Map.values() returns a Collection, it is wrapped into a ArrayList to have the final result", "label": {"api": {"Map.values()": [[6, 17]]}}}, {"text": "As for the mechanics of String concatenation, you would generally be using StringBuilder rather than String for better performance", "label": {"api": {"StringBuilder": [[75, 87]]}}}, {"text": "Where thread-safety is needed, use StringBuffer", "label": {"api": {"StringBuffer": [[35, 46]]}}}, {"text": "You can learn more about view-indexes vs model-indexes from the Documentation on JTable introduction at the top", "label": {"api": {"Documentation on JTable": [[64, 86]]}}}, {"text": "While working with Java 8 Streams, I some times find that Stream doesn't have a particular method that I desire (e.g", "label": {"api": {"Stream": [[26, 31], [58, 63]]}}}, {"text": "How do I create my own stream class which has the additional methods with out re-writing the entire Java 8 Stream architecture", "label": {"api": {"Stream": [[107, 112]]}}}, {"text": "I am aware of the StreamEx library and know that it has takeWhile() and dropWhile()", "label": {"api": {"Stream": [[18, 23]]}}}, {"text": "An acceptable solution would be to show how Java 8 Stream or StreamEx can be extended", "label": {"api": {"Stream": [[51, 56], [61, 66]]}}}, {"text": "The Runtime class can be used to do this", "label": {"api": {"Runtime": [[4, 10]]}}}, {"text": "You can get an instance of this class via the static method Runtime.getRuntime()", "label": {"api": {"Runtime": [[60, 66], [71, 77]], "Runtime.getRuntime()": [[60, 79]]}}}, {"text": "In the Runtime class are several exec() methods that should be what you need", "label": {"api": {"Runtime": [[7, 13]]}}}, {"text": "Finally, you may consider the ProcessBuilder class more convenient depending on how complex your needs are", "label": {"api": {"ProcessBuilder": [[30, 43]]}}}, {"text": "Trying a QName with empty prefix or the equivalent XMLConstants.DEFAULT_NS_PREFIX as parameter will result in a default prefix (like ns1)  being generated", "label": {"api": {"XMLConstants.DEFAULT_NS_PREFIX": [[51, 80]]}}}, {"text": "Check out TimerTask", "label": {"api": {"TimerTask": [[10, 18]]}}}, {"text": "From a generic JDBC perspective, there is a way of determining the keywords, using the SQL:2003 keywords list (which you need to obtain yourself) + the result of DatabaseMetaData.getSQLKeywords()", "label": {"api": {"DatabaseMetaData.getSQLKeywords()": [[162, 194]]}}}, {"text": "6th and 5th doesn't have some of the methods", "label": {"api": {"doesn't have": [[12, 23]]}}}, {"text": "It works by using a single static instance of Random, and calling nextDouble() on it", "label": {"api": {"Random": [[46, 51]], "nextDouble()": [[66, 77]]}}}, {"text": "Javadoc of Math.random() even says so", "label": {"api": {"Math.random()": [[11, 23]]}}}, {"text": "You have to change minimalDaysInFirstWeek, see Calendar#setMinimalDaysInFirstWeek(int)", "label": {"api": {"Calendar#setMinimalDaysInFirstWeek(int)": [[47, 85]]}}}, {"text": "See also GregorianCalendar", "label": {"api": {"GregorianCalendar": [[9, 25]]}}}, {"text": "But if you code for your financial department, you should rather create your calendar with the right Locale instead of changing some properties, see Calendar#getInstance(Locale)", "label": {"api": {"Locale": [[101, 106], [170, 175]], "Calendar#getInstance(Locale)": [[149, 176]]}}}, {"text": "You can see this by printing out the result of Math.ulp (unit in last place) value", "label": {"api": {"Math.ulp": [[47, 54]]}}}, {"text": "The System class members in, out, and err are initialized in the private function initializeSystemClass()", "label": {"api": {"out": [[29, 31]]}}}, {"text": "The member out is not only an OutputStream", "label": {"api": {"out": [[11, 13]]}}}, {"text": "It is a PrintStream, and has an extended API", "label": {"api": {"PrintStream": [[8, 18]]}}}, {"text": "All of the print() methods that accept arguments of primitive type use the corresponding String.valueOf() methods to create a String object representing the value", "label": {"api": {"print()": [[11, 17]], "String.valueOf()": [[89, 104]]}}}, {"text": "These strings are then funneled through an OutputStreamWriter instance that encodes text into bytes using a specific character encoding", "label": {"api": {"OutputStreamWriter": [[43, 60]]}}}, {"text": "You can use FileLock to lock the file if the processes are in the same JVM", "label": {"api": {"FileLock": [[12, 19]]}}}, {"text": "The second prolem is that JOptionPane just does not provide any method that matches the arguments you try to pass in your getQuantity-mehod", "label": {"api": {"JOptionPane": [[26, 36]]}}}, {"text": "If you can assume that there's only one school with a given name, you could use the findFirst() method", "label": {"api": {"findFirst()": [[84, 94]]}}}, {"text": "First, If a nextXYZ method of Scanner encounters a wrong input, it won't throw a NumberFormatException but an InputMismatchException", "label": {"api": {"InputMismatchException": [[110, 131]]}}}, {"text": "While you can implement it in one class, given the fact that Java only has one tree model in the Swing package, it is pretty common to implement your own tree, which certainly involves more classes (can be inner or anonymous)", "label": {"api": {"tree model": [[79, 88]]}}}, {"text": "Don't use StringBuffer, use StringBuilder", "label": {"api": {"StringBuffer": [[10, 21]], "StringBuilder": [[28, 40]]}}}, {"text": "See javadoc of StringBuffer for why", "label": {"api": {"StringBuffer": [[15, 26]]}}}, {"text": "Better yet, use a char[] and Arrays.fill()", "label": {"api": {"Arrays.fill()": [[29, 41]]}}}, {"text": "I would recommend you to use the Executor framework and Listenable Futures from Guava instead of creating threads manually", "label": {"api": {"Executor framework": [[33, 50]]}}}, {"text": "In the factory use the Socket.connect(SocketAddress endpoint, int timeout)", "label": {"api": {"Socket.connect(SocketAddress endpoint, int timeout)": [[23, 73]]}}}, {"text": "You need to close() the scanner so that any resources held by it can be released", "label": {"api": {"close()": [[12, 18]]}}}, {"text": "How can I create an empty EnumSet when I don't have the runtime type of the generic enum", "label": {"api": {"EnumSet": [[26, 32]]}}}, {"text": "If you are using the default LogManager class then calling readConfiguration will reset the logging configuration", "label": {"api": {"readConfiguration": [[59, 75]]}}}, {"text": "Try map method of Stream instead", "label": {"api": {"Stream": [[18, 23]]}}}, {"text": "You can achieve this using map method of Stream", "label": {"api": {"Stream": [[41, 46]]}}}, {"text": "For an Iterable, it will follow the order of the corresponding Iterator (retrieved by calling Iterable.iterator()), that may or may not be consistent between runs", "label": {"api": {"Iterable.iterator()": [[94, 112]]}}}, {"text": "For example, it is explicitely specified that for List, the iterator retains the order", "label": {"api": {"it is explicitely specified that for List, the iterator retains the order": [[13, 85]]}}}, {"text": "While it is explicitely specified that for Set, the order is unspecified (unless an extra guarantee is made)", "label": {"api": {"it is explicitely specified that for Set, the order is unspecified (unless an extra guarantee is made)": [[6, 107]]}}}, {"text": "String.concat() will return the concatenation as a new String object", "label": {"api": {"String.concat()": [[0, 14]]}}}, {"text": "To use property access only for id property (while keeping field access for all the other properties), specify AccessType.PROPERTY for the id field", "label": {"api": {"AccessType.PROPERTY": [[111, 129]]}}}, {"text": "The groupingBy(classifier, downstream) collector is a collector that collects the Stream element into a Map where the keys are returned by the classifier and the values are the result of applying the downstream collector to all Stream elements having an equal key", "label": {"api": {"groupingBy(classifier, downstream)": [[4, 37]]}}}, {"text": "In this case, what we want is to count the values so we use Collectors.counting() as the downstream collector", "label": {"api": {"Collectors.counting()": [[60, 80]]}}}, {"text": "An alternative approach is reading your paths from a Properties file", "label": {"api": {"Properties": [[53, 62]]}}}, {"text": "So out of pure curiosity I used the trim() method of the String contained in element and somehow it works now", "label": {"api": {"trim()": [[36, 41]]}}}, {"text": "Using System.lineSeparator() for splitting solved the problem at the cause instead of using trim() to cure the symptoms", "label": {"api": {"trim()": [[92, 97]]}}}, {"text": "You can verify that manipulating the content of the list doesn't clone by checking its identityHashCode", "label": {"api": {"identityHashCode": [[87, 102]]}}}, {"text": "According to the API totalMemory() only ..", "label": {"api": {"API": [[17, 19]]}}}, {"text": "The method reference does not work for the 2nd method because WindowListener is not a functional interface; unlike the ActionListener interface which has a single abstract method actionPerformed()", "label": {"api": {"WindowListener": [[62, 75]], "actionPerformed()": [[179, 195]]}}}, {"text": "To match case-insensitively, pass the CASE_INSENSITIVE flag to Pattern.compile", "label": {"api": {"CASE_INSENSITIVE": [[38, 53]]}}}, {"text": "If you are using Java 8, you can use workSteaingPool from Executors, which returns ForkJoinPool", "label": {"api": {"Executors": [[58, 66]]}}}, {"text": "If you look at https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html you'll see that when pop() is called (even if it's within if statement), it will pop that element and move the pointer to the next element", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html": [[15, 76]]}}}, {"text": "Since your query already excludes the primary key, you then only have to change the PreparedStatement indexes to match the number of parameters in your query starting from one", "label": {"api": {"PreparedStatement": [[84, 100]], "starting from one": [[158, 174]]}}}, {"text": "Since you have 10 columns in addition to the primary ID column, your PreparedStatement might look something like the following", "label": {"api": {"PreparedStatement": [[69, 85]]}}}, {"text": "If you see the document, it takes an int value in pow()", "label": {"api": {"document": [[15, 22]]}}}, {"text": "The problem is that BigInteger.pow() takes an int and not a BigInteger", "label": {"api": {"BigInteger.pow()": [[20, 35]]}}}, {"text": "Your best bet is to use BigInteger.modPow() instead since that takes 2 BigIntegers", "label": {"api": {"BigInteger.modPow()": [[24, 42]]}}}, {"text": "I suggest using Integer class", "label": {"api": {"Integer": [[16, 22]]}}}, {"text": "If none of the conditions before last if statement satisfy, put a check if those Integers are initialized with null check", "label": {"api": {"Integer": [[81, 87]]}}}, {"text": "I have to call a shell script from a Java ME 8 Application but the CLDC 8 doesn't implement Runtime.exec()", "label": {"api": {"CLDC 8": [[67, 72]]}}}, {"text": "The ImageView class is used to display an image", "label": {"api": {"ImageView": [[4, 12]]}}}, {"text": "It has a viewport property that represents the portion of the image it is viewing", "label": {"api": {"viewport property": [[9, 25]]}}}, {"text": "If you actually need to store each piece as an individual image, you can snapshot the image view to create a new Image from it", "label": {"api": {"snapshot": [[73, 80]]}}}, {"text": "You have to pick one style to be the default (you can then override the default with AccessType for the desired properties)", "label": {"api": {"AccessType": [[85, 94]]}}}, {"text": "It also allows if to find the classes implementing javax.servlet.ServletContainerInitializer, and to call their onStartup() method, which allows the initializer to register servlets and filters dynamically", "label": {"api": {"javax.servlet.ServletContainerInitializer": [[51, 91]]}}}, {"text": "But that's not how it works, see the API documentation for Object#wait, especially the second paragraph", "label": {"api": {"the API documentation for Object#wait": [[33, 69]]}}}, {"text": "If you don't want to implement your own entry you could use AbstractMap.SimpleEntry", "label": {"api": {"AbstractMap.SimpleEntry": [[60, 82]]}}}, {"text": "As such, you could equivalently use Apache's MutableInt class or Java's AtomicInteger in the same way, just incrementing until the correct number has been reached", "label": {"api": {"Java's AtomicInteger": [[65, 84]]}}}, {"text": "A CountDownLatch could do the job", "label": {"api": {"CountDownLatch": [[2, 15]]}}}, {"text": "CountDownLatch latch = new CountDownLatch(n);", "label": {"api": {"CountDownLatch": [[0, 13], [27, 40]]}}}, {"text": "So guard it with a NumberFormatException (parseDouble)", "label": {"api": {"parseDouble": [[42, 52]]}}}, {"text": "The IntStream class's map method maps ints to more ints, with a IntUnaryOperator (int to int), not to objects", "label": {"api": {"IntStream class's map method": [[4, 31]]}}}, {"text": "Try the mapToObj method instead, which takes an IntFunction (int to object) instead", "label": {"api": {"mapToObj method": [[8, 22]]}}}, {"text": "You have to do this \"manually\" using clearRect, e.g.", "label": {"api": {"clearRect": [[37, 45]]}}}, {"text": "Instead of invoking it reflectively, you can use PreparedStatement.setObject(int, Object) or one of its siblings", "label": {"api": {"PreparedStatement.setObject(int, Object)": [[49, 88]]}}}, {"text": "You should return Response as the result of the interface method instead of the plain DTO", "label": {"api": {"Response": [[18, 25]]}}}, {"text": "I'm not sure about the level of control you're expecting (considering your reply to @peeskillet comment), but the Response object will give you the opportunity to fine tune your server's response (headers, cookies, status etc.) and read all of them at the client side - as you might see taking a look at Response's members like getStatus() and getHeaders()", "label": {"api": {"Response": [[114, 121], [304, 311]]}}}, {"text": "You can achieve 1 and 2 in one hit if you switch to ConcurrentMap.computeIfAbsent(...)", "label": {"api": {"ConcurrentMap.computeIfAbsent(...)": [[52, 85]]}}}, {"text": "If Java-7 then putIfAbsent but that requires an extra new - perhaps a bad thing if construction is expensive", "label": {"api": {"putIfAbsent": [[15, 25]]}}}, {"text": "Check it's official documentation", "label": {"api": {"official documentation": [[11, 32]]}}}, {"text": "Another option, if you are truly only interested in integers, would be the use of AtomicInteger, which has methods to atomically increment", "label": {"api": {"AtomicInteger": [[82, 94]]}}}, {"text": "Rather than implementing a Visitor pattern (as described here), you can use the isAssignableFrom() method on the class you want to test (https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isAssignableFrom-java.lang.Class-)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isAssignableFrom-java.lang.Class-": [[137, 232]]}}}, {"text": "Use the Collections.sort(List<T> list, Comparator<", "label": {"api": {"Comparator": [[39, 48]]}}}, {"text": "super T> c) static method and supply a custom Comparator whose compare() method extracts the numeric prefix from the two elements and only compares those prefixes", "label": {"api": {"Comparator": [[46, 55]], "compare()": [[63, 71]]}}}, {"text": "You could use String.split(\";\") to get the numeric prefix, for example", "label": {"api": {"String.split(\";\")": [[14, 30]]}}}, {"text": "Your question is not completely clear, but you need to use the BigInteger.equals() method, as in this example", "label": {"api": {"BigInteger.equals()": [[63, 81]]}}}, {"text": "Executors#newSingleThreadExecutor() returns a ThreadPoolExecutor wrapped in FinalizableDelegatedExecutorService (not public)", "label": {"api": {"Executors#newSingleThreadExecutor()": [[0, 34]], "ThreadPoolExecutor": [[46, 63]]}}}, {"text": "Does a ThreadPoolExecutor shut down properly without being wrapped in a FinalizableDelegatedExecutorService if garbage collected", "label": {"api": {"ThreadPoolExecutor": [[7, 24]]}}}, {"text": "values() returns a view of the values contained in this map", "label": {"api": {"values()": [[0, 7]]}}}, {"text": "The cause of the issue isn't adding the listener, it's using a editable ComboBox without a appropriate StringConverter", "label": {"api": {"StringConverter": [[103, 117]]}}}, {"text": "This is certainly not a bug; it's even documented in the javadoc", "label": {"api": {"in the javadoc": [[50, 63]]}}}, {"text": "If a different type is specified and the ComboBox is to be editable, it is necessary to specify a custom StringConverter", "label": {"api": {"StringConverter": [[105, 119]]}}}, {"text": "You could use a StringConverter like this", "label": {"api": {"StringConverter": [[16, 30]]}}}, {"text": "Using Java Time API, this can be done using the STRICT ResolverStyle", "label": {"api": {"STRICT": [[48, 53]]}}}, {"text": "By default, a formatter has the SMART ResolverStyle", "label": {"api": {"SMART": [[32, 36]]}}}, {"text": "By default, a formatter has the SMART resolver style", "label": {"api": {"SMART": [[32, 36]]}}}, {"text": "but you can change this by calling withResolverStyle(resolverStyle) on the formatter instance", "label": {"api": {"withResolverStyle(resolverStyle)": [[35, 66]]}}}, {"text": "I would like to use Java 8, how can I make this imperative style to functional style in java 8 Optional", "label": {"api": {"Optional": [[95, 102]]}}}, {"text": "Java uses Date::toString() function - so you print date in default format", "label": {"api": {"Date::toString()": [[10, 25]]}}}, {"text": "Scanner's explicitly states", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "See the javadoc of HashTable", "label": {"api": {"HashTable": [[19, 27]]}}}, {"text": "When you manage to find out how to play sound with microseconds position, you may want to use window closing event to write to file where your audio should start next time your program runs", "label": {"api": {"window closing event": [[94, 113]]}}}, {"text": "where readFully is guaranteed to fill the byte array, or will throw an exception if it reaches the end of the stream before completing", "label": {"api": {"readFully": [[6, 14]]}}}, {"text": "You could create a custom Logger that overrides removeHandler() to do any special processing that you need, and log to that instead of the root logger", "label": {"api": {"removeHandler()": [[48, 62]]}}}, {"text": "1) Has a shared CountDownLatch", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "2) Waits on the CountDownLatch to reach zero", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "With the CountDownLatch you can trigger all threads to call the thread-unsafe method at more or less the same time (all threads are ready to go from the same point in the runnable when the CountDownLatch reaches zero, but ultimately it is up to your operating system (and hardware) to decide what gets executed when)", "label": {"api": {"CountDownLatch": [[9, 22], [189, 202]]}}}, {"text": "Repeat the test or put your test in a for-loop (and replace the CountDownLatch with a CyclicBarrier, another concurrent tool that comes in handy for these kind of tests)", "label": {"api": {"CountDownLatch": [[64, 77]], "CyclicBarrier": [[86, 98]]}}}, {"text": "never assume threads start at the same time, synchronize them with tools like a CountDownLatch so you know exactly where threads are)", "label": {"api": {"CountDownLatch": [[80, 93]]}}}, {"text": "In any case, the general idea is to first setup a situation where it should go wrong and use automated brute force (many threads calling the method many times in a loop) combined with the smart use of concurrent tools like the CountDownLatch to show the test will always bring certain issues to the surface", "label": {"api": {"CountDownLatch": [[227, 240]]}}}, {"text": "it took me some time to figure out that after calling \"thread.start()\" the thread might not have started yet and that a CountDownLatch could be used to make sure the thread is where I want it to be)", "label": {"api": {"CountDownLatch": [[120, 133]]}}}, {"text": "If you want to navigate that deck I suggest you put the shuffled list in to a Queue, where you can look at the next card (peek) or take the next card (poll)", "label": {"api": {"Queue": [[78, 82]]}}}, {"text": "You can chain certain Collectors from java.util.stream.Collectors in order to make more complicated ones", "label": {"api": {"java.util.stream.Collectors": [[38, 64]]}}}, {"text": "You could, for instance, return some abstract Future-like object rather than a thread, if you want to extend the liberty of methodToTest to use various ways of doing asynchronous work", "label": {"api": {"Future": [[46, 51]]}}}, {"text": "Such a task pool could take the form of an ExecutorService, or a ThreadGroup, or any number of other forms", "label": {"api": {"ExecutorService": [[43, 57]], "ThreadGroup": [[65, 75]]}}}, {"text": "Adding this functionality is a bit tricky, because of the cell reuse mechanism (described in the Cell documentation)", "label": {"api": {"Cell documentation": [[97, 114]]}}}, {"text": "If the method returns a value, use Callable<V> instead", "label": {"api": {"Callable<V>": [[35, 45]]}}}, {"text": "Partitioning is done with partitioningBy(predicate, downstream)", "label": {"api": {"partitioningBy(predicate, downstream)": [[26, 62]]}}}, {"text": "In this case, the predicate would be your filtering function and the downstream collector would be summingLong to sum the values", "label": {"api": {"summingLong": [[99, 109]]}}}, {"text": "Therefore it's more convenient to use TabPane as type parameter instead of Void also you should call updateProgress to update the progress property and bind that property to the progress property of the ProgressIndicator", "label": {"api": {"updateProgress": [[101, 114]], "progress property": [[130, 146], [178, 194]], "the progress property of the ProgressIndicator": [[174, 219]]}}}, {"text": "The result can be added to the BorderPane in the onSucceded handler instead of creating a (more or less) complicated binding", "label": {"api": {"onSucceded handler": [[49, 66]]}}}, {"text": "According to the Javadoc of Double.valueOf", "label": {"api": {"Double.valueOf": [[28, 41]]}}}, {"text": "A little out of scope, but safer may be to use a ConcurrentHashmap", "label": {"api": {"ConcurrentHashmap": [[49, 65]]}}}, {"text": "Take a look at the documentation for executeUpdate()", "label": {"api": {"executeUpdate()": [[37, 51]]}}}, {"text": "We do not know what your in-house framework can and can't do, but it seems like they replicate the functionality of the Java standard classes Runnable and ExecutorService", "label": {"api": {"Runnable": [[142, 149]], "ExecutorService": [[155, 169]]}}}, {"text": "The Java standard classes solve this issue by having ExecutorService.submit(Runnable) return a Future on which you can then call .get() which blocks until the task is completed", "label": {"api": {"Runnable": [[76, 83]], "ExecutorService": [[53, 67]], "Future": [[95, 100]]}}}, {"text": "An alternative solution would be to modify ifdmWorkerService.startJob to take a Runnable as an optional second parameter and have it execute that Runnable when the first job was completed", "label": {"api": {"Runnable": [[80, 87], [146, 153]]}}}, {"text": "I have modified your code from above to make it a Factory where both the Factory and the provide method service are in the Singleton scope", "label": {"api": {"Singleton": [[123, 131]]}}}, {"text": "As a side note, when you use @Service the default scope becomes Singleton which is why the provide method (which cannot have @Service on it) is by default in the PerLookup scope", "label": {"api": {"Singleton": [[64, 72]]}}}, {"text": "You need to add a mapping downstream collector to the group by operation that maps the File Stream element into its name and collects those name into a List", "label": {"api": {"mapping": [[18, 24]]}}}, {"text": "And Math.hypot is useful too", "label": {"api": {"Math.hypot": [[4, 13]]}}}, {"text": "is.read() declares that it throws IOException", "label": {"api": {"is.read()": [[0, 8]]}}}, {"text": "InvalidClassException extends IOException", "label": {"api": {"InvalidClassException": [[0, 20]]}}}, {"text": "Therefore as far as your code knows, it is possible that is.read() could throw an InvalidClassException", "label": {"api": {"is.read()": [[57, 65]], "InvalidClassException": [[82, 102]]}}}, {"text": "A method reference is just a way to implement a functional interface, so you have to either, define yourself an appropriate interface or search the predefined types for a match", "label": {"api": {"search the predefined types": [[137, 163]]}}}, {"text": "Since your listener method consumes a target listener instance and an event object and doesn’t return a value, BiConsumer is an appropriate type", "label": {"api": {"BiConsumer": [[111, 120]]}}}, {"text": "You need to refresh the container by calling repaint() after modifying the instance variable", "label": {"api": {"repaint()": [[45, 53]]}}}, {"text": "When using a Channel's transferFrom( ) method, you are supposed to specify the maximum number of bytes to be transferred", "label": {"api": {"transferFrom( )": [[23, 37]]}}}, {"text": "Ẃhile there may be justifiable exceptions to this rule, I would say that in general you should block on close()", "label": {"api": {"close()": [[104, 110]]}}}, {"text": "AutoCloseable's close() suggests to throw a generic Exception", "label": {"api": {"close()": [[16, 22]]}}}, {"text": "By making the internal logic of close() asynchronous you cannot really pass on any misbehavior that may occur while closing your resource", "label": {"api": {"close()": [[32, 38]]}}}, {"text": "Create two different implementations of Comparator - one that compares price, and one that compares distance", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "Then you can use Collections.sort(List, Comparator) to sort the list using whichever sorting strategy you want", "label": {"api": {"Comparator": [[40, 49]], "Collections.sort(List, Comparator)": [[17, 50]]}}}, {"text": "Once you have got the data you needed, you should make use of FileWriter in order to write the information to file", "label": {"api": {"FileWriter": [[62, 71]]}}}, {"text": "What you are describing is called a \"partial ordering\", and the proper way to implement the behavior you're looking for in Java is with a Comparator that defines the ordering; something like", "label": {"api": {"Comparator": [[138, 147]]}}}, {"text": "You can then simply call Collections.max() to find the largest value in your first list", "label": {"api": {"Collections.max()": [[25, 41]]}}}, {"text": "Use copyOfRange to get sub array", "label": {"api": {"copyOfRange": [[4, 14]]}}}, {"text": "See Java 8 Documentation on Collectors", "label": {"api": {"Java 8 Documentation on Collectors": [[4, 37]]}}}, {"text": "You could simply use String.contains()", "label": {"api": {"String.contains()": [[21, 37]]}}}, {"text": "You pass the path to the constructor of Media", "label": {"api": {"the constructor of Media": [[21, 44]]}}}, {"text": "Fortunately File can be converted to URI using toURI", "label": {"api": {"toURI": [[47, 51]]}}}, {"text": "Per the SwingWorker API", "label": {"api": {"SwingWorker API": [[8, 22]]}}}, {"text": "the \"Threading\" section in the Application documentation)", "label": {"api": {"Application documentation": [[31, 55]]}}}, {"text": "I'd recommend using JFrame#setExtendedState to set the frame MAXIMIZED_BOTH state over the setSize hack you're currently using, it'll at least reduce the amount of code", "label": {"api": {"JFrame#setExtendedState": [[20, 42]]}}}, {"text": "That means that you need to map your Stream<Map.Entry<String, Double>> into a Stream<Pair<String, Double>>", "label": {"api": {"map": [[28, 30]]}}}, {"text": "This is done with the map operation", "label": {"api": {"map": [[22, 24]]}}}, {"text": "Finally, you want to collect that into a List, so we can use the built-in toList() collector", "label": {"api": {"toList()": [[74, 81]]}}}, {"text": "After making your matcher, you need to call find() (so it will actually try and make a match) before calling group() to get the group from the match it found", "label": {"api": {"find()": [[44, 49]], "group()": [[109, 115]]}}}, {"text": "From the docs for find()", "label": {"api": {"find()": [[18, 23]]}}}, {"text": "Because then it won't override Object.equals, which is the method used by many standard library algorithms for checking equality of two objects", "label": {"api": {"Object.equals": [[31, 43]]}}}, {"text": "Phaser is a good high-level tool for this kind of use case", "label": {"api": {"Phaser": [[0, 5]]}}}, {"text": "The Button class you are referencing is the AWT Button", "label": {"api": {"AWT Button": [[44, 53]]}}}, {"text": "Instead, you should be using the JavaFX Button", "label": {"api": {"JavaFX Button": [[33, 45]]}}}, {"text": "In mathematical terms a division by 0 is undefined and therefore throws an ArithmeticException", "label": {"api": {"ArithmeticException": [[75, 93]]}}}, {"text": "The above example uses JodaTime, but with Java 8 you can also use LocalTime", "label": {"api": {"LocalTime": [[66, 74]]}}}, {"text": "In the implementation of clear() you can observe that every object is set to null as well, this is to prevent any memory leaks if some object is referencing it", "label": {"api": {"clear()": [[25, 31]]}}}, {"text": "This is a good case for ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[24, 45]]}}}, {"text": "You can go through Function and here is the basic usage of the same", "label": {"api": {"Function": [[19, 26]]}}}, {"text": "You can use overloaded groupingBy method and pass TreeMap as Supplier", "label": {"api": {"groupingBy": [[23, 32]], "Supplier": [[61, 68]]}}}, {"text": "There is already a way to do this using the JDK's ThreadLocal, which stores distinct references for each (local) thread", "label": {"api": {"ThreadLocal": [[50, 60]]}}}, {"text": "You need to define a controller class", "label": {"api": {"controller class": [[21, 36]]}}}, {"text": "The common way for writing the encoding the strings is CharsetEncoder", "label": {"api": {"CharsetEncoder": [[55, 68]]}}}, {"text": "If you want the same functionality as a HashMap but with order you should use a TreeMap", "label": {"api": {"TreeMap": [[80, 86]]}}}, {"text": "HashMap gives you O(1) inserting and searching while they are O(log(n)) in TreeMap because it is internally implemented with a Red-Black tree", "label": {"api": {"TreeMap": [[75, 81]]}}}, {"text": "You can use an instanceof test for this, or (with a bit of trickery) do a lookup", "label": {"api": {"lookup": [[74, 79]]}}}, {"text": "If you want to get a bit more sophisticated, that method could take a DoubleBinaryOperator as a parameter, for specifying the behavior of each button", "label": {"api": {"DoubleBinaryOperator": [[70, 89]]}}}, {"text": "You forgot to shutdown your ExecutorService", "label": {"api": {"shutdown": [[14, 21]]}}}, {"text": "If you're willing to store the elements in the SortedSet in reverse order, the only change you need to make is to construct the TreeSet with an appropriate constructor which takes a custom Comparator", "label": {"api": {"an appropriate constructor": [[141, 166]], "Comparator": [[189, 198]]}}}, {"text": "Note the neat method here is Collections.reverseOrder() which returns a Comparator which compares in the opposite of the natural ordering of elements", "label": {"api": {"Comparator": [[72, 81]], "Collections.reverseOrder()": [[29, 54]]}}}, {"text": "Use varStatus on forEach and check for the last iteration to set the comma", "label": {"api": {"last iteration": [[43, 56]]}}}, {"text": "Use URLEncoder.encode() to do so", "label": {"api": {"URLEncoder.encode()": [[4, 22]]}}}, {"text": "The add(E e) method defined on the List<E> interface is specified as an optional operation", "label": {"api": {"add(E e)": [[4, 11]]}}}, {"text": "It might be an unmodifiable type created by calling Collections.unmodifiableList(), an instance of a Guava ImmutableList, or something else entirely", "label": {"api": {"Collections.unmodifiableList()": [[52, 81]]}}}, {"text": "You can get that information by calling the X509Certificate.getKeyUsage() method", "label": {"api": {"X509Certificate.getKeyUsage()": [[44, 72]]}}}, {"text": "Extended key usage information can be obtained from X509Certificate.getExtendedKeyUsage()", "label": {"api": {"X509Certificate.getExtendedKeyUsage()": [[52, 88]]}}}, {"text": "You get the response body as usual with Response#readEntity", "label": {"api": {"Response#readEntity": [[40, 58]]}}}, {"text": "With Response#getStatusInfo you get only HTTP status, class and reason phrase", "label": {"api": {"Response#getStatusInfo": [[5, 26]], "status": [[46, 51]], "class": [[54, 58]], "reason phrase": [[64, 76]]}}}, {"text": "The trick is to use the superclass' generic type information, which is accessible via the Class.getGenericSuperclass() and ParameterizedType.getActualTypeArguments() methods", "label": {"api": {"Class.getGenericSuperclass()": [[90, 117]], "ParameterizedType.getActualTypeArguments()": [[123, 164]]}}}, {"text": "I'm using java.time.LocalDate and monthValue and dayOfMonth attributes return single digits if the value is less than 10, and it does not work in IE", "label": {"api": {"java.time.LocalDate": [[10, 28]]}}}, {"text": "Java has extensive, highly informative documentation", "label": {"api": {"extensive, highly informative documentation": [[9, 51]]}}}, {"text": "In this case, the documentation for FileWriter says", "label": {"api": {"documentation for FileWriter": [[18, 45]]}}}, {"text": "Instead using JSF FlowScoped it is possible to obtain something very similar using ConversationScoped", "label": {"api": {"ConversationScoped": [[83, 100]]}}}, {"text": "A LocalDate represents date that is composed of a year, a month and a day", "label": {"api": {"LocalDate": [[2, 10]]}}}, {"text": "You can't make a LocalDate if you don't have those three fields defined", "label": {"api": {"LocalDate": [[17, 25]]}}}, {"text": "As such, you can't parse it in a LocalDate", "label": {"api": {"LocalDate": [[33, 41]]}}}, {"text": "If the day is irrelevant, you could parse it into a YearMonth object", "label": {"api": {"YearMonth": [[52, 60]]}}}, {"text": "YearMonth is an immutable date-time object that represents the combination of a year and month", "label": {"api": {"YearMonth": [[0, 8]]}}}, {"text": "You could then transform this YearMonth into a LocalDate by adjusting it to the first day of the month for example", "label": {"api": {"LocalDate": [[47, 55]], "YearMonth": [[30, 38]]}}}, {"text": "Like mentioned in the comment, check out DecimalFormat", "label": {"api": {"DecimalFormat": [[41, 53]]}}}, {"text": "thread.join() should be called after thread.start()", "label": {"api": {"thread.join()": [[0, 12]], "thread.start()": [[37, 50]]}}}, {"text": "Use ServiceUI to show a print selection dialog", "label": {"api": {"ServiceUI": [[4, 12]]}}}, {"text": "I found out that I can avoid this by using AccessController.doPrivileged method in my .jar file", "label": {"api": {"AccessController.doPrivileged": [[43, 71]]}}}, {"text": "Here is example of using AccessController.doPrivileged with your code", "label": {"api": {"AccessController.doPrivileged": [[25, 53]]}}}, {"text": "The Integer.getInteger(String) method states the following", "label": {"api": {"Integer.getInteger(String)": [[4, 29]]}}}, {"text": "If the array is long, you can use BigInteger", "label": {"api": {"BigInteger": [[34, 43]]}}}, {"text": "First of all, convert the array into a string and construct the BigInteger using the string", "label": {"api": {"BigInteger": [[64, 73]]}}}, {"text": "Then, do arithmetic using two BigInteger", "label": {"api": {"BigInteger": [[30, 39]]}}}, {"text": "Here is the code to convert the array into a BigInteger", "label": {"api": {"BigInteger": [[45, 54]]}}}, {"text": "For those reasons, I would just use Externalizable, and avoid the additional complexity", "label": {"api": {"Externalizable": [[36, 49]]}}}, {"text": "Now I've tried the andThen method of the functional interface Consumer in Java 8", "label": {"api": {"Consumer": [[62, 69]]}}}, {"text": "Instead, use replaceAll", "label": {"api": {"replaceAll": [[13, 22]]}}}, {"text": "The java class Properties is a thread-safe Class as per it's documentation", "label": {"api": {"Properties": [[15, 24]]}}}, {"text": "multiple threads can share a single Properties object without the need for external synchronization", "label": {"api": {"Properties": [[36, 45]]}}}, {"text": "Because of that reason, I have the habit of maintaining my Properties in a HashMap implementation of Map, which is not thread-safe, but much more lightweight", "label": {"api": {"Properties": [[59, 68]]}}}, {"text": "Eventually I need to revert to API's that can only accept 'Properties' as a Parameter, an example being DriverManager.getConnection(String,Properties)", "label": {"api": {"Properties": [[59, 68], [139, 148]], "DriverManager.getConnection(String,Properties)": [[104, 149]]}}}, {"text": "I need to convert my Map into Properties", "label": {"api": {"Properties": [[30, 39]]}}}, {"text": "Obvious problem, or maybe not so obvious as I avoided using an actual for-loop, is that I use a repeated call to Properties.setProperty", "label": {"api": {"Properties": [[113, 122]]}}}, {"text": "If Properties is truly thread safe, then that must mean that each call to setProperty is synchronized and has individual lock/unlock mechanisms added to it", "label": {"api": {"Properties": [[3, 12]]}}}, {"text": "Would it not be better in such a case that I manually lock the entire Properties instance first as in code below", "label": {"api": {"Properties": [[70, 79]]}}}, {"text": "One issue I was possibly expecting is that both manual lock on properties, and the individual calls to setProperties might have caused a deadlock, but it seems to run fine", "label": {"api": {"Properties": [[106, 115]]}}}, {"text": "The number 77777777777777777777777 (23 digits) is too long to fit in an int, because the maximum int possible is about 2 billion (10 digits)", "label": {"api": {"maximum int possible is about 2 billion (10 digits)": [[89, 139]]}}}, {"text": "It's also too long to fit in a long, whose maximum value is 19 digits", "label": {"api": {"long, whose maximum value is 19 digits": [[31, 68]]}}}, {"text": "Either include an error message stating that the number is too big, or switch your datatype to BigInteger, by using Scanner's nextBigInteger method", "label": {"api": {"Scanner's nextBigInteger method": [[116, 146]]}}}, {"text": "Use Scanner.hasNextDouble() e.g", "label": {"api": {"Scanner.hasNextDouble()": [[4, 26]]}}}, {"text": "Assuming your record_date is a SQL date in your database (and not some varchar), try it like this with a proper PreparedStatement", "label": {"api": {"PreparedStatement": [[112, 128]]}}}, {"text": "I would recommend reading the Javadoc for the Pattern class which provides a lot of details of how to use regexes", "label": {"api": {"Javadoc for the Pattern class": [[30, 58]]}}}, {"text": "You can use a ByteArrayOutputStream to write bytes to a byte array", "label": {"api": {"ByteArrayOutputStream": [[14, 34]]}}}, {"text": "a ByteArrayOutputStream is a special input kind of OutputStream, you are not required to close it, but it never hurts if you still do it", "label": {"api": {"ByteArrayOutputStream": [[2, 22]]}}}, {"text": "Then you can make the arrays smaller using Arrays.copyOf", "label": {"api": {"Arrays.copyOf": [[43, 55]]}}}, {"text": "Make a Stream<ObjectA> which is a Stream of your input list, with theAs.stream()", "label": {"api": {"theAs.stream()": [[66, 79]]}}}, {"text": "Map each ObjectA in the Stream to an ObjectB with Stream.map", "label": {"api": {"Stream.map": [[50, 59]]}}}]