[{"text": "To be more concise, you can use the interval mapping CriteriaBuilder#between(), and the query you have posted results in", "label": {"api": {"CriteriaBuilder#between()": [[53, 77]]}}}, {"text": "Just use String.replace(CharSequence target, CharSequence replacement) if you are dealing with literal strings", "label": {"api": {"String.replace(CharSequence target, CharSequence replacement)": [[9, 69]]}}}, {"text": "The String.replaceAll(String regex, String replacement) and String.replaceFirst(String regex, String replacement) functions works with Pattern (regex)", "label": {"api": {"String.replaceAll(String regex, String replacement)": [[4, 54]], "String.replaceFirst(String regex, String replacement)": [[60, 112]], "Pattern": [[135, 141]]}}}, {"text": "In such case, Matcher.quoteReplacement(String s) can be used to quote the replacement string when you want to replace with fixed string", "label": {"api": {"Matcher.quoteReplacement(String s)": [[14, 47]]}}}, {"text": "You can use the Scanner class to read from the System.in and check if the string is a number", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "You can try to use a constructor like this one, and try different charset", "label": {"api": {"this one": [[38, 45]]}}}, {"text": "org.hibernate.jpa.HibernatePersistenceProvider), you can use the PersistenceProvider#createContainerEntityManagerFactory(PersistenceUnitInfo info, Map map) method to bootstrap an EntityManagerFactory without needing a persistence.xml", "label": {"api": {"PersistenceProvider#createContainerEntityManagerFactory(PersistenceUnitInfo info, Map map)": [[65, 154]], "PersistenceUnitInfo": [[121, 139]]}}}, {"text": "However, it's annoying that you have to implement the PersistenceUnitInfo interface, so you are better off using Spring or Hibernate which both support bootstrapping JPA without a persistence.xml file", "label": {"api": {"PersistenceUnitInfo": [[54, 72]]}}}, {"text": "Where the PersistenceUnitInfo is implemented by the Spring-specific MutablePersistenceUnitInfo class", "label": {"api": {"PersistenceUnitInfo": [[10, 28], [75, 93]]}}}, {"text": "You can use a series of if statements or you could use a TreeMap which implements the NavigableMap interface", "label": {"api": {"TreeMap": [[57, 63]]}}}, {"text": "What you need to do is get the class object for the class whose method you wish to execute dynamically by using the static method Class.forName(String) passing in the class's name", "label": {"api": {"Class.forName(String)": [[130, 150]]}}}, {"text": "subsequently you can request the method you wish to execute using the getDeclaredMethod(String, Class<?>...) passing in the method's name and parameter types", "label": {"api": {"getDeclaredMethod(String, Class<?>...)": [[70, 107]]}}}, {"text": "Following that you can call invoke(Object, Object...) on the method with two null arguments (execute the method on no instance of the class (static execution) without any parameters)", "label": {"api": {"invoke(Object, Object...)": [[28, 52]]}}}, {"text": "A HyperlinkListener can be added to receive events representing clicks on hyerlinks", "label": {"api": {"HyperlinkListener": [[2, 18]]}}}, {"text": "You need to precise a Locale to your scanner object where decimals are separated by a dot, otherwise it uses your default locale (and it doesn't seem to separate them by a dot in your case)", "label": {"api": {"Locale": [[22, 27]]}}}, {"text": "The addAll method is defined on the Collection interface", "label": {"api": {"addAll method": [[4, 16]]}}}, {"text": "All these programs are written in Java and all threads in these programs are created using the Thread class", "label": {"api": {"Thread class": [[95, 106]]}}}, {"text": "I want to create a custom JPanel to allow my user to select one of 4 corners", "label": {"api": {"JPanel": [[26, 31]]}}}, {"text": "I have done this by using 4 JRadioButtons and placing a TitledBorder on the panel", "label": {"api": {"JRadioButton": [[28, 39]], "TitledBorder": [[56, 67]]}}}, {"text": "First I tried setting them to the minimum size using setMaximumSize() and setPreferredSize() but that did not work", "label": {"api": {"setMaximumSize()": [[53, 68]], "setPreferredSize()": [[74, 91]]}}}, {"text": "Then I tried overloading getMaximumSize() and getPreferredSize() but that seemed to have no effect either", "label": {"api": {"getMaximumSize()": [[25, 40]], "getPreferredSize()": [[46, 63]]}}}, {"text": "I've tested on a GridBagLayout where I want to place it and on a BorderLayout in a otherwise empty JFrame created for testing", "label": {"api": {"GridBagLayout": [[17, 29]], "BorderLayout": [[65, 76]], "JFrame": [[99, 104]]}}}, {"text": "The documentation for String.charAt http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#charAt(int) throws an error when you attempt to access out-of-bounds items in the String", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#charAt(int)": [[36, 109]]}}}, {"text": "Use the getMethod method on the a class to retrieve the proper Method object, which you can add to your ArrayList", "label": {"api": {"getMethod method": [[8, 23]]}}}, {"text": "The addAll method adds all elements in the collection argument to the collection on which you're calling addAll", "label": {"api": {"addAll method": [[4, 16]]}}}, {"text": "If you were to call add(Collection), then the Collection itself would just be the next new element", "label": {"api": {"add(Collection)": [[20, 34]]}}}, {"text": "To call a method that's represented by a Method, call the invoke method", "label": {"api": {"invoke method": [[58, 70]]}}}, {"text": "Careful, both the getMethod and invoke methods throw their own Exceptions that you'll have to catch", "label": {"api": {"invoke method": [[32, 44]]}}}, {"text": "Use String#matches() and a regex", "label": {"api": {"String#matches()": [[4, 19]]}}}, {"text": "There's not a method that does it in one call, but offsetByCodePoints() will help you do this", "label": {"api": {"offsetByCodePoints()": [[51, 70]]}}}, {"text": "You should use a SimpleDateFormat, and you can verify with a Calendar", "label": {"api": {"SimpleDateFormat": [[17, 32]], "Calendar": [[61, 68]]}}}, {"text": "Please see java.util.concurrent.CountDownLatch api to achieve this effectively in Java", "label": {"api": {"java.util.concurrent.CountDownLatch": [[11, 45]]}}}, {"text": "1) A CountDownLatch", "label": {"api": {"CountDownLatch": [[5, 18]]}}}, {"text": "Make the third thread wait on it, the CountDownLatch will only let this thread continue when the counter reaches 0", "label": {"api": {"CountDownLatch": [[38, 51]]}}}, {"text": "2) Using FutureTask", "label": {"api": {"FutureTask": [[9, 18]]}}}, {"text": "Use an executor to launch each task in parallel and return (immediately) a FutureTask, then pass the FutureTasks to you your third task and make that task call the get method in the Futures", "label": {"api": {"FutureTask": [[75, 84], [101, 110]]}}}, {"text": "File.listFiles() will give you the list of files", "label": {"api": {"File.listFiles()": [[0, 15]]}}}, {"text": "If you don't want to deal with executors, just create a FutureTask and pass it to a new thread", "label": {"api": {"FutureTask": [[56, 65]]}}}, {"text": "If you have a single task that needs to be done, you can use a Future and have the other Thread poll the (non-blocking) isDone() method whenever it is convenient", "label": {"api": {"Future": [[63, 68]]}}}, {"text": "If that task is executed frequently or you have many tasks to execute, using a ConcurrentLinkedQueue might be a better idea, which also comes in a variant that supports blocking till a result is delivered as LinkedBlockingQueue", "label": {"api": {"ConcurrentLinkedQueue": [[79, 99]], "LinkedBlockingQueue": [[208, 226]]}}}, {"text": "For example if you use a Swing GUI, you can have the DB thread call invokeLater from the SwingUtilities class, so processing the request is done on the main Swing thread at the next possible time", "label": {"api": {"invokeLater": [[68, 78]]}}}, {"text": "This is based on the EventQueue class, which might be more convenient to use in certain other scenarios", "label": {"api": {"EventQueue": [[21, 30]]}}}, {"text": "Use the containsAll(Collection<?>) method instead", "label": {"api": {"containsAll(Collection<?>)": [[8, 33]]}}}, {"text": "If you only want to convert your number into a String, just use the valueOf method of String class", "label": {"api": {"valueOf": [[68, 74]]}}}, {"text": "For converting Strings to Numbers use the valueOf methods of Integer, Double or Float (depends on which numbers you will have)", "label": {"api": {"valueOf": [[42, 48]]}}}, {"text": "Even better would be using java.awt.Component, since this class is defining all methods you want to use (setMinimumSize, setMaximumSize and setPreferredSize)", "label": {"api": {"setMinimumSize": [[105, 118]], "setMaximumSize": [[121, 134]], "setPreferredSize": [[140, 155]]}}}, {"text": "Create a HashSet<String> containing all your elements in wordsArray (as lower cases/upper cases)", "label": {"api": {"HashSet<String>": [[9, 23]]}}}, {"text": "For each new word englishword check if set.contains(englishword.toLowerCase())", "label": {"api": {"set.contains(englishword.toLowerCase())": [[39, 77]]}}}, {"text": "How about using, HashSet", "label": {"api": {"HashSet": [[17, 23]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html for details", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html": [[4, 68]]}}}, {"text": "(1) Or use the new Java 7 POSIX file system options", "label": {"api": {"POSIX": [[26, 30]]}}}, {"text": "And then just use the other version of toArray()", "label": {"api": {"other version": [[22, 34]]}}}, {"text": "From BufferedReader's documenation", "label": {"api": {"BufferedReader's documenation": [[5, 33]]}}}, {"text": "you can try java.util.Scanner for reading jut like java.io.BufferedReader, I mean", "label": {"api": {"java.util.Scanner": [[12, 28]], "java.io.BufferedReader": [[51, 72]]}}}, {"text": "Is that you are comparing two objects that have not implemented a equals method, this may cause some strange behaviours", "label": {"api": {"equal": [[66, 70]]}}}, {"text": "Override method equals from java.lang.Object to specify when two \"SNMPv3\" are equal", "label": {"api": {"java.lang.Object": [[28, 43]], "equal": [[16, 20], [78, 82]]}}}, {"text": "The getSouce() method contract says it returns an Object instance, and therefore casting at runtime it will either pass, or will fail and you will receive a ClassCastException", "label": {"api": {"getSouce()": [[4, 13]]}}}, {"text": "In the code snippet you provided, the path to the image file is considered to be on the file system (the constructor of class ImageIcon takes a file name as an argument)", "label": {"api": {"ImageIcon": [[126, 134]]}}}, {"text": "If you want to load a file (or an image) from the jar itself, you need to use ClassLoader.getResourceAsStream()", "label": {"api": {"ClassLoader.getResourceAsStream()": [[78, 110]]}}}, {"text": "The method getBoolean takes a System Property name as an argument, not the String value of the boolean", "label": {"api": {"getBoolean": [[11, 20]]}}}, {"text": "What you need is probably Boolean.parseBoolean()", "label": {"api": {"Boolean.parseBoolean()": [[26, 47]]}}}, {"text": "Store the numbers in Integer variables as the numeric values they are, and output them with the format you wish to with String.format() for instance", "label": {"api": {"String.format()": [[120, 134]]}}}, {"text": "In this case, use java.util.Calendar instead", "label": {"api": {"java.util.Calendar": [[18, 35]]}}}, {"text": "For this, you should be using PrintStream.printf or String.format bto do this", "label": {"api": {"PrintStream.printf": [[30, 47]], "String.format": [[52, 64]]}}}, {"text": "Carefully read the API for JComponent", "label": {"api": {"JComponent": [[27, 36]]}}}, {"text": "If you play with ArrayList and LinkedList you'll see that elements are printed in the order they are added", "label": {"api": {"ArrayList": [[17, 25]], "LinkedList": [[31, 40]]}}}, {"text": "It is important for ArrayList and LinkedList to behave the same way", "label": {"api": {"ArrayList": [[20, 28]], "LinkedList": [[34, 43]]}}}, {"text": "One way to optimize the second piece of code would be to store a pointer to the tail of the list as well as one to the head so that adds and pushes both take O(1) time", "label": {"api": {"adds": [[132, 135]], "pushes": [[141, 146]]}}}, {"text": "Collections#sort takes a List, not a Collection", "label": {"api": {"Collections#sort": [[0, 15]], "Collection": [[0, 9], [37, 46]]}}}, {"text": "The reason for this is that there are some classes implementing Collection that cannot be reordered arbitrarily", "label": {"api": {"Collection": [[64, 73]]}}}, {"text": "Collection says this about it", "label": {"api": {"Collection": [[0, 9]]}}}, {"text": "Hence why you only see Collection as a parameter in places like conversion constructors (which the tutorial calls a convention) and the family of xxxAll methods", "label": {"api": {"Collection": [[23, 32]], "xxxAll": [[146, 151]]}}}, {"text": "Use ServletContext.getRealPath() to locate the file on disk", "label": {"api": {"ServletContext.getRealPath()": [[4, 31]]}}}, {"text": "The method readLine() returns a String value where you're expecting a double value (see API)", "label": {"api": {"see API": [[84, 90]]}}}, {"text": "This can be done entirely without blocking using a ConcurrentHashMap like this", "label": {"api": {"ConcurrentHashMap": [[51, 67]]}}}, {"text": "Look at String.indexOf() and String.substring() to split the string up and rebuild your updated version", "label": {"api": {"String.indexOf()": [[8, 23]], "String.substring()": [[29, 46]]}}}, {"text": "To prove this point, add the following as the first lines of your test case main method and run the program", "label": {"api": {"add": [[21, 23]]}}}, {"text": "What you need to do is create a StreamHandler with your redirected System.err stream and then add and remove the StreamHandler from your logger", "label": {"api": {"StreamHandler": [[32, 44], [113, 125]], "add": [[94, 96]], "remove": [[102, 107]]}}}, {"text": "You can also toggle the use of parent handlers on your logger config to avoid writing to the original System.err", "label": {"api": {"parent handlers": [[31, 45]]}}}, {"text": "JDK wise, the ConsoleHandler and ErrorManager should have been designed to use the java.io.FileDescriptor which is never redirected", "label": {"api": {"java.io.FileDescriptor": [[83, 104]]}}}, {"text": "If the traversal operations on your list vastly outnumber the mutative operations, you might want to use a CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[107, 126]]}}}, {"text": "LinkedList implements the List Interface from Java, therefore you can just invoke addAll from one list to the other", "label": {"api": {"List Interface": [[26, 39]]}}}, {"text": "We pass the buffer into the DatagramPacket object and when the socket receives the UDP packet the buffer is filled with the mpeg-ts data", "label": {"api": {"DatagramPacket": [[28, 41]]}}}, {"text": "If you use \"/\" in the beginning of filepath, it's gonna be resolved from the package root (it is clearly stated in the JavaDocs)", "label": {"api": {"it is clearly stated in the JavaDocs": [[91, 126]]}}}, {"text": "The doc does seem to suggest this might be the case, saying", "label": {"api": {"The doc": [[0, 6]]}}}, {"text": "Don't use raw Threads, use an ExecutorService", "label": {"api": {"ExecutorService": [[30, 44]]}}}, {"text": "There are plenty of tutorials on the internet explaining the ExecutorService API in more detail", "label": {"api": {"ExecutorService": [[61, 75]]}}}, {"text": "Note that it is redundant to get the Text node by calling getLastChild() when using getTextContent() on an Element", "label": {"api": {"getTextContent()": [[84, 99]]}}}, {"text": "For reference, check the API docs", "label": {"api": {"API docs": [[25, 32]]}}}, {"text": "The 'correct' way to do non-blocking IO in Java is to use the NIO API, look in particular at java.nio.channels.AsynchronousSocketChannel that allows you to write code like this", "label": {"api": {"java.nio.channels.AsynchronousSocketChannel": [[93, 135]]}}}, {"text": "Then you can simply use the getRGB method", "label": {"api": {"getRGB": [[28, 33]]}}}, {"text": "If you absolutely need to display a new window for every task that is launched, then have a look at JInternalFrame", "label": {"api": {"JInternalFrame": [[100, 113]]}}}, {"text": "It is not appropriate to use an NIO ByteBuffer in this case as you are getting byte[] anyway, though it could come in handy later", "label": {"api": {"ByteBuffer": [[36, 45]]}}}, {"text": "However, the \"plain\" write function on BAOS takes an int not a byte (ByteArrayOutputStream.write)", "label": {"api": {"ByteArrayOutputStream.write": [[69, 95]]}}}, {"text": "So the real question is why OutputStream.write(int) is declared that way, when its stated goal is to write a single byte to the stream", "label": {"api": {"OutputStream.write(int)": [[28, 50]]}}}, {"text": "See also the NIO Buffer docs", "label": {"api": {"NIO Buffer docs": [[13, 27]]}}}, {"text": "If you have many threads, you should try to use AtomicInteger to be sure all threads get the same values of X and Y (it's worth the effort!)", "label": {"api": {"AtomicInteger": [[48, 60]]}}}, {"text": "I believe you want a combination of stripTrailingZeros, precision and scale, as demonstrated here", "label": {"api": {"stripTrailingZeros": [[36, 53]], "precision": [[56, 64]], "scale": [[70, 74]]}}}, {"text": "The call to stripTrailingZeros is required as otherwise it's entirely possible for a BigDecimal to be stored in a \"non-normalized\" form", "label": {"api": {"stripTrailingZeros": [[12, 29]]}}}, {"text": "For example, new BigDecimal(5000) has a precision of 4, not 1", "label": {"api": {"precision": [[40, 48]]}}}, {"text": "The call to scale() is used to handle cases where the normalized form has trailing zeroes before the decimal point, but nothing after the decimal point", "label": {"api": {"scale": [[12, 16]]}}}, {"text": "In this case, the scale will always be negative, and indicates the number of trailing zeroes", "label": {"api": {"scale": [[18, 22]]}}}, {"text": "I suppose you are looking for Collections.nCopies", "label": {"api": {"Collections.nCopies": [[30, 48]]}}}, {"text": "You can check that via isCancelled() but nothing happens if you don't check that manually", "label": {"api": {"isCancelled()": [[23, 35]]}}}, {"text": "Java already has an Exception for this http://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html, albeit a Runtime (unchecked) exception", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html": [[39, 119]]}}}, {"text": "You must activate the DOTALL flag when compiling the pattern", "label": {"api": {"DOTALL": [[22, 27]]}}}, {"text": "If you are using java 7 or greater and your code is in try catch resource block, then it is Auto closes", "label": {"api": {"Auto closes": [[92, 102]]}}}, {"text": "If in below versions you have to close with close()", "label": {"api": {"close()": [[44, 50]]}}}, {"text": "The reflect.Array.newInstance method uses native code because it must use native code", "label": {"api": {"reflect.Array.newInstance": [[4, 28]]}}}, {"text": "However, most code does not use the Array reflection (this includes \"multi-valued data structures\" such as ArrayList), but simply uses normal Java array access which is directly translated to the appropriate Java bytecode without going through reflect.Array or the native methods it uses", "label": {"api": {"ArrayList": [[107, 115]]}}}, {"text": "I suspect you're looking for List.indexOf", "label": {"api": {"List.indexOf": [[29, 40]]}}}, {"text": "ConcurrentModificationExceptions happen when modifying a Collection while iterating it, other than using the Iterator.remove() method", "label": {"api": {"Iterator.remove()": [[109, 125]]}}}, {"text": "Now this may not make much more sense to you yet, but at least it's proper Java code :) This is using generics - HashMap is a generic type with two type parameters - one for the key and one for the value", "label": {"api": {"HashMap": [[113, 119]]}}}, {"text": "The code provided isn't idiomatic Java code in terms of its use of ArrayList and HashMap, mind you", "label": {"api": {"HashMap": [[81, 87]]}}}, {"text": "When waked up, the thread goes to the RUNNING state again, but to signal the developer that it was waked up earlier than expected, it throws an InterruptedException, which is a checked exception", "label": {"api": {"InterruptedException": [[144, 163]]}}}, {"text": "If so, you could try the revalidate method", "label": {"api": {"revalidate": [[25, 34]]}}}, {"text": "You can also retrieve the PID from your Java application, using the platform runtime MXBean's getName() method", "label": {"api": {"platform runtime MXBean": [[68, 90]]}}}, {"text": "The indexOf method will use the equals method to determine if your Profile exists in the list", "label": {"api": {"equals method": [[32, 44]]}}}, {"text": "You must override the equals method in Profile to return the proper result", "label": {"api": {"equals method": [[22, 34]]}}}, {"text": "Usually, you should override the hashCode method if you override equals, but because a Profile isn't being used as the key here, it's not necessary", "label": {"api": {"hashCode method": [[33, 47]]}}}, {"text": "Also, I assume this is homework, so if you are allowed to use it, I would definitely take a look at the StringBuilder#reverse() method that Elliot Frisch mentioned (I admit, I never knew about this method before now, so major +1s to Elliot)", "label": {"api": {"StringBuilder#reverse()": [[104, 126]]}}}, {"text": "However, if we use java.awt.geom.Ellipse2D to represent the circle, you need to have the top-left corner of the square containing the circle and the diameter of the circle", "label": {"api": {"java.awt.geom.Ellipse2D": [[19, 41]]}}}, {"text": "In order to use the for each loop you need to implement the Iterable interface", "label": {"api": {"Iterable": [[60, 67]]}}}, {"text": "You can read the JComboBox docs for more information about this", "label": {"api": {"JComboBox": [[17, 25]]}}}, {"text": "For a non blocking alternative to timing, have a look at How to use Swing Timers which looks at the javax.swing.Timer class", "label": {"api": {"javax.swing.Timer": [[100, 116]]}}}, {"text": "If you had added at least one element to the ArrayList before calling .toArray() on it, then Designer will have something to show you", "label": {"api": {".toArray()": [[70, 79]]}}}, {"text": "That's because you're using .toArray() with no arguments, which returns an Object[]", "label": {"api": {".toArray()": [[28, 37]]}}}, {"text": "Use the other version, .toArray(T[] a), as follows to make sure you get a String[] returned", "label": {"api": {".toArray(T[] a)": [[23, 37]]}}}, {"text": "Which is OK with the compiler but throws an exception because boolean.class is a Class<Boolean> and boolean[] cannot be cast to Boolean[]", "label": {"api": {"boolean.class": [[62, 74]]}}}, {"text": "Or you can get the bounds with getBounds", "label": {"api": {"getBounds": [[31, 39]]}}}, {"text": "If you're talking about the Stack class, that, as templatetypedef pointed out, implements Vector, which has a get by index (along with a size method), and an iterator, either allowing you to iterate through it", "label": {"api": {"the Stack class": [[24, 38]], "Vector": [[90, 95]], "a get by index": [[108, 121]], "an iterator": [[155, 165]]}}}, {"text": "Let's use the String#split() method and break up the input string on forward slashes", "label": {"api": {"String#split()": [[14, 27]]}}}, {"text": "This is, of course, from Java EE 5; it seems that in Java EE 6 and newer, you're allowed to do so", "label": {"api": {"in Java EE 6": [[50, 61]]}}}, {"text": "Since your application can run on Tomcat which is a simple servlet container then you might want to use ServletContext#getServerInfo()", "label": {"api": {"ServletContext#getServerInfo()": [[104, 133]]}}}, {"text": "Find more on documentaton", "label": {"api": {"Find more on documentaton": [[0, 24]]}}}, {"text": "From the Java 7 JavaDoc (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArraySet.html": [[25, 110]]}}}, {"text": "It'll throw a NotSerializableException when you try to Serialize it", "label": {"api": {"NotSerializableException": [[14, 37]]}}}, {"text": "Since you want to extract the numeric values of each lines, I would recommend you take a look at the Pattern class", "label": {"api": {"Pattern": [[101, 107]]}}}, {"text": "If yes, you're talking about collections such as an ArrayList", "label": {"api": {"ArrayList": [[52, 60]]}}}, {"text": "Does anyone know how to remove the title bar of a JInternalFrame", "label": {"api": {"JInternalFrame": [[50, 63]]}}}, {"text": "Can I use ArrayList.trimToSize() method in dynamic arrayList", "label": {"api": {"ArrayList.trimToSize()": [[10, 31]]}}}, {"text": "I've accomplished something similar with SQS using Java's ExecutorService, Future, and the ConcurrentLinkedQueue", "label": {"api": {"ExecutorService": [[58, 72]], "Future": [[75, 80]], "ConcurrentLinkedQueue": [[91, 111]]}}}, {"text": "The ExecutorService creates a thread pool that can execute classes that implement the Callable interface and returns a Future", "label": {"api": {"ExecutorService": [[4, 18]], "Future": [[119, 124]]}}}, {"text": "As the ExecutorService creates the futures I push them onto a ConcurrentLinkedQueue that runs in a thread and processes the results as the futures complete", "label": {"api": {"ExecutorService": [[7, 21]], "ConcurrentLinkedQueue": [[62, 82]]}}}, {"text": "ConcurrentLinkedQueue to receive and process the future results", "label": {"api": {"ConcurrentLinkedQueue": [[0, 20]]}}}, {"text": "Yes, you'll need to write a custom java.lang.ClassLoader that uses the bytes read from the database to define the class", "label": {"api": {"java.lang.ClassLoader": [[35, 55]]}}}, {"text": "How about the File.renameTo(File dest) function", "label": {"api": {"File.renameTo(File dest)": [[14, 37]]}}}, {"text": "That is why the usage BigDecimal is encouraged", "label": {"api": {"BigDecimal": [[22, 31]]}}}, {"text": "To your question on how to use it properly, I've a simple example which can help you understand how BigDecimal can be used along with MathContext", "label": {"api": {"BigDecimal": [[100, 109]], "MathContext": [[134, 144]]}}}, {"text": "The documentation of Set's contain method is", "label": {"api": {"Set's contain method": [[21, 40]]}}}, {"text": "in regex language means any character (since String.split() takes a regular expression as a parameter.), which causes the string to be split on each character thus returning an empty array", "label": {"api": {"String.split()": [[45, 58]], "regular expression": [[68, 85]]}}}, {"text": "You can use the URLEncoder class to convert a String to percent encoding", "label": {"api": {"URLEncoder": [[16, 25]]}}}, {"text": "You can use URLEncoder for converting it to the desired format", "label": {"api": {"URLEncoder": [[12, 21]]}}}, {"text": "You should use the StringBuilder approach", "label": {"api": {"StringBuilder": [[19, 31]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html But like crush said above, your map would then only have two entries, which seems strange", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html": [[0, 62]]}}}, {"text": "A classic solution is to wrap it using Collections.unmodifiableList()", "label": {"api": {"Collections.unmodifiableList()": [[39, 68]]}}}, {"text": "For example SubString has a second function to copy the last chars starting from x", "label": {"api": {"second function": [[28, 42]]}}}, {"text": "Also, as a side note, for your implementation - a Queue will be a better idea I think", "label": {"api": {"Queue": [[50, 54]]}}}, {"text": "(when I wrote a PriorityQueue will be better I had multiple peaks in mind - which seems not to be the case for you, I think a simple Queue will be best)", "label": {"api": {"Queue": [[24, 28], [133, 137]]}}}, {"text": "Shouldn't Predicate#negate be what you are looking for", "label": {"api": {"Predicate#negate": [[10, 25]]}}}, {"text": "The direct answer to your question is to use DESKeySpec and KeyFactory using an algorithm string \"DES\" for the getInstance(String) method (just like you do for your KeyGenerator", "label": {"api": {"DESKeySpec": [[45, 54]], "KeyFactory": [[60, 69]]}}}, {"text": "So you wrap the right amount of bytes from the front (leftmost) part of your byte array containing the hash, wrap it in a DESKeySpec and use the SecretKeyFactory.generateSecret() method to create a key from it", "label": {"api": {"DESKeySpec": [[122, 131]], "KeyFactory": [[151, 160]]}}}, {"text": "There is a file chooser if that is what you are after", "label": {"api": {"file chooser": [[11, 22]]}}}, {"text": "Run the following sample, the method to use is getValue()", "label": {"api": {"getValue()": [[47, 56]]}}}, {"text": "If you wanted a binary search on a List collection, then make use of Collections#binarySearch()", "label": {"api": {"Collections#binarySearch()": [[69, 94]]}}}, {"text": "From the JavaDoc on TreeMap.headMap", "label": {"api": {"JavaDoc on TreeMap.headMap": [[9, 34]]}}}, {"text": "Collections.copy() does not perform a deep copy", "label": {"api": {"Collections.copy()": [[0, 17]]}}}, {"text": "You can iterate over all your elements, and use Arrays.copyOf on each list item", "label": {"api": {"Arrays.copyOf": [[48, 60]]}}}, {"text": "The only way to create a thread in Java is by creating a Thread object and starting it", "label": {"api": {"starting": [[75, 82]]}}}, {"text": "For example, in its various java.util.concurrent classes", "label": {"api": {"java.util.concurrent": [[28, 47]]}}}, {"text": "You can use Platform.runLater()", "label": {"api": {"Platform.runLater()": [[12, 30]]}}}, {"text": "You could convert your image to a writeableraster and use getpixel() and setpixel() methods to convert the colors underneath the user's mouse-pointer under certain conditions", "label": {"api": {"writeableraster": [[34, 48]]}}}, {"text": "The docs for setUndecorated(boolean) clearly state.", "label": {"api": {"setUndecorated(boolean)": [[13, 35]]}}}, {"text": "If there are more occurences of .., you could use regular expressions or a Scanner", "label": {"api": {"Scanner": [[75, 81]]}}}, {"text": "KeyEvent is a constant identifier, not a keycode the user has input", "label": {"api": {"KeyEvent": [[0, 7]]}}}, {"text": "KeyEvent's constant value is 400, meaning your check will always pass", "label": {"api": {"KeyEvent": [[0, 7]]}}}, {"text": "Try using InputStreamReader instead of FileReader", "label": {"api": {"InputStreamReader": [[10, 26]], "Reader": [[21, 26], [43, 48]]}}}, {"text": "This is possible because the constructor of CsvBeanReader accepts the abstract class Reader", "label": {"api": {"Reader": [[51, 56], [85, 90]]}}}, {"text": "You can construct the InputStreamReader using the InputStream you have obtained", "label": {"api": {"InputStreamReader": [[22, 38]], "Reader": [[33, 38]]}}}, {"text": "Through debugging, I think I've already traced the problem to the blocking behavior of SourceDataLine#write", "label": {"api": {"SourceDataLine#write": [[87, 106]]}}}, {"text": "The solution seems to be to use open(AudioFormat, int) to open the line with a specified buffer size", "label": {"api": {"open(AudioFormat, int)": [[32, 53]]}}}, {"text": "Use SimpleDateFormat to get the string representation of the date to a Date Object", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "You could try getting a new Date object from a String (since this is what you're trying to accomplish), so use a SimpleDateFormat for this", "label": {"api": {"SimpleDateFormat": [[113, 128]]}}}, {"text": "Similar to this, you can parse time or date and time into a java.util.Date using SimpleDateFormat and then convert it to the respective class java.sql.Time and java.sql.Timestamp using date.getTime()", "label": {"api": {"SimpleDateFormat": [[81, 96]]}}}, {"text": "But, matcher.find() always returns false hence toast message is not showing up", "label": {"api": {"matcher.find()": [[5, 18]]}}}, {"text": "On HashMap or Collection (which HashMap implements) size is a method use", "label": {"api": {"size": [[52, 55]]}}}, {"text": "Notice this form of the method uses the isEmpty() method which is a shortcut for checking if the list does not contain any items", "label": {"api": {"isEmpty()": [[40, 48]]}}}, {"text": "You need to implement the Iterable interface, which means you need to implement the iterator() method", "label": {"api": {"Iterable": [[26, 33]]}}}, {"text": "You need to follow example from @MapsId documentation (in your case, with @Id instead of @EmbeddedId)", "label": {"api": {"@MapsId documentation": [[32, 52]]}}}, {"text": "So when you print the line in the method, there's a line separator after it which is defined as so", "label": {"api": {"defined": [[85, 91]]}}}, {"text": "The line separator string is defined by the system property line.separator, and is not necessarily a single newline character ('\\n')", "label": {"api": {"defined": [[29, 35]]}}}, {"text": "Then you have to use getResource() to get an access to the embedded file in your jar", "label": {"api": {"getResource()": [[21, 33]]}}}, {"text": "That would return an URL that you can use to get an InputStream by calling openStream() and read from it, possibly extracting it to the hard drive for display, etc", "label": {"api": {"URL": [[21, 23]], "openStream()": [[75, 86]]}}}, {"text": "Use isAssignableFrom() method in Class class", "label": {"api": {"isAssignableFrom()": [[4, 21]]}}}, {"text": "You need to create equals() and hashCode() methods for your Fraction class", "label": {"api": {"equals()": [[19, 26]], "hashCode()": [[32, 41]]}}}, {"text": "For instance, your equals() method would look something like this", "label": {"api": {"equals()": [[19, 26]]}}}, {"text": "While your hashCode() method would look something like this", "label": {"api": {"hashCode()": [[11, 20]]}}}, {"text": "From the JavaDocs of UIManager", "label": {"api": {"JavaDocs of UIManager": [[9, 29]]}}}, {"text": "The method SwingUtilities.updateComponentTreeUI(java.awt.Component) makes it easy to apply updateUI to a containment hierarchy", "label": {"api": {"SwingUtilities.updateComponentTreeUI(java.awt.Component)": [[11, 66]]}}}, {"text": "Take a look at the javadoc, and you will see it (ctrl+f '@Target')", "label": {"api": {"@Target": [[57, 63]]}}}, {"text": "The @Target meta-annotation describes to what java language constructs an annotation can be applied", "label": {"api": {"@Target": [[4, 10]]}}}, {"text": "As a side note, you can see by looking at this javadoc, that @Target has a @Target of {ANNOTATION_TYPE}, which is effectively what makes an annotation a meta-annotation", "label": {"api": {"@Target": [[61, 67], [75, 81]]}}}, {"text": "As a matter of fact, the method PersistenceUtil.createEntityManagerFactory allows you to provide a properties map", "label": {"api": {"PersistenceUtil.createEntityManagerFactory": [[32, 73]]}}}, {"text": "I suggest you to use DatatypeConverter.parseHexBinary (or similar utility from library of your choice) to convert hexadecimal strings into byte arrays", "label": {"api": {"DatatypeConverter.parseHexBinary": [[21, 52]]}}}, {"text": "The javadoc for JMF Manager shows 3 versions of createPlayer; each of them take only one argument (either DataSource, MediaLocator, or URL)", "label": {"api": {"javadoc for JMF Manager": [[4, 26]]}}}, {"text": "Your code with throw NullPointerException", "label": {"api": {"NullPointerException": [[21, 40]]}}}, {"text": "Since BigInteger.modPow already implements this, you should just look at the source code of BigInteger", "label": {"api": {"BigInteger.modPow": [[6, 22]]}}}, {"text": "For that purposes you can use addSelectionInterval() method instead of setSelectionInterval()", "label": {"api": {"addSelectionInterval()": [[30, 51]]}}}, {"text": "Also, rather than using your own constants, you could either use DateTimeConstants.MILLIS_PER_HOUR or use java.util.concurrent.TimeUnit for conversions", "label": {"api": {"java.util.concurrent.TimeUnit": [[106, 134]]}}}, {"text": "This is happening because String#split accepts a regex", "label": {"api": {"String#split": [[26, 37]]}}}, {"text": "You would need to store each Timer instance in either an array or an ArrayList, and then call timer.stop() on each stored timer when you want to cancel them all", "label": {"api": {"ArrayList": [[69, 77]]}}}, {"text": "If you are on Servlet 3.0 and above, use HttpServletRequest.login()", "label": {"api": {"HttpServletRequest.login()": [[41, 66]]}}}, {"text": "The argument you pass to the Class#getDeclaredMethod() is an array of Class instances for the format parameter types of that method, which in this case will be Class.class, and not MySchool.class", "label": {"api": {"Class#getDeclaredMethod()": [[29, 53]]}}}, {"text": "Since your ArrayList contents are sorted, you should use Collections.binarySearch to locate your item", "label": {"api": {"Collections.binarySearch": [[57, 80]]}}}, {"text": "You should not use == (reference equality) for determining String equality, luckily there is an String#equalsIgnoreCase(String) method", "label": {"api": {"String#equalsIgnoreCase(String)": [[96, 126]]}}}, {"text": "You can have 2 decimal places using DecimalFormat", "label": {"api": {"DecimalFormat": [[36, 48]]}}}, {"text": "System.in is an InputStream, and InputStream's read method throws an IOException", "label": {"api": {"InputStream's read method throws an IOException": [[33, 79]]}}}, {"text": "Try your luck with SwingFXUtils", "label": {"api": {"SwingFXUtils": [[19, 30]]}}}, {"text": "Looking at the Javadoc for String you'll find many methods for manipulating / extracting the contained data", "label": {"api": {"Javadoc for String": [[15, 32]]}}}, {"text": "As I mentioned in the comments, it would probably be better to use an ArrayList of Strings for RANKS and use Collections.shuffle Then you can use the something like the following", "label": {"api": {"Collections.shuffle": [[109, 127]]}}}, {"text": "Alternatively, you could use Pattern.quote", "label": {"api": {"Pattern.quote": [[29, 41]]}}}, {"text": "System.currentTimeMillis() comes to mind", "label": {"api": {"System.currentTimeMillis()": [[0, 25]]}}}, {"text": "However in your case, if you want to measure where you are in a song relative to the beginning of the song you should probably use System.nanoTime() which is more accurate (and faster i believe)", "label": {"api": {"System.nanoTime()": [[131, 147]]}}}, {"text": "Your class Display should extend a Component (Container, Button, Canvas, Label ...)", "label": {"api": {"Component": [[35, 43]]}}}, {"text": "What you are trying to achieve is possible through the Reflection API (more on that here), however I think that for your particular problem, using reflection might be a little bit overkill, so it might be better to stick with the easier solutions", "label": {"api": {"Reflection API": [[55, 68]]}}}, {"text": "Your code will throw IndexOutOfBoundsException", "label": {"api": {"IndexOutOfBoundsException": [[21, 45]]}}}, {"text": "In this case, I think that the way to go is to use a JList", "label": {"api": {"JList": [[53, 57]]}}}, {"text": "In String you must use String#equals() method for checking instead of ==", "label": {"api": {"String#equals()": [[23, 37]]}}}, {"text": "Refer java.util.concurrent.TimeUnit Api in Java", "label": {"api": {"java.util.concurrent.TimeUnit": [[6, 34]]}}}, {"text": "Look at the code of CsvDataReader, it uses an InputStreamReader to read the input, without specifying the Charset", "label": {"api": {"InputStreamReader": [[46, 62]]}}}, {"text": "In this case the InputStreamReader uses the default charset", "label": {"api": {"InputStreamReader": [[17, 33]]}}}, {"text": "I am trying to use the Objects.equals(obj a, obj b) method (link) in Android, but it seems Android does not have access to it", "label": {"api": {"link": [[60, 63]]}}}, {"text": "From Sun's documentation for Line", "label": {"api": {"From Sun's documentation for Line": [[0, 32]]}}}, {"text": "See normalize and toRealPath", "label": {"api": {"normalize": [[4, 12]], "toRealPath": [[18, 27]]}}}, {"text": "I should, theoretically, be able to save the keystore and certificates that are on it with Java KeyStore", "label": {"api": {"store": [[48, 52]]}}}, {"text": "time to actually store my file", "label": {"api": {"store": [[17, 21]]}}}, {"text": "So, I use the FileOutputStream I created above to store the keyStore to", "label": {"api": {"store": [[50, 54]]}}}, {"text": "I'd suspect if anything went wrong during the actual saving, I'd get an exception at least (like CertificateException, which should be thrown 'if any of the certificates included in the keystore data could not be stored' along the docs)", "label": {"api": {"store": [[189, 193], [213, 217]]}}}, {"text": "Depending on the JDBC driver you are using you might work directly with XML (java.sql.SQLXML) or treat the XML as a string type", "label": {"api": {"java.sql.SQLXML": [[77, 91]]}}}, {"text": "You can use Instrumentation to register a retransform-capable ClassFileTransformer and request a re-transformation of the Proxy class", "label": {"api": {"Instrumentation": [[12, 26]], "register": [[31, 38]], "ClassFileTransformer": [[62, 81]], "re-transformation": [[97, 113]]}}}, {"text": "Then, within the transformer’s transform method you have hands on the byte array which makes up the class", "label": {"api": {"transform method": [[31, 46]]}}}, {"text": "Thats not a collections, while it is a 'list' in the traditional sense, it is not a java.util.ArrayList", "label": {"api": {"java.util.ArrayList": [[84, 102]]}}}, {"text": "String.split() is your friend", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "More information can be found in the JavaDocs for Serializable", "label": {"api": {"JavaDocs for Serializable": [[37, 61]]}}}, {"text": "If you want to do serious stuff with java arrays, don't miss java.util.Arrays", "label": {"api": {"java.util.Arrays": [[61, 76]]}}}, {"text": "These fields are declared on Rectangle2D.Float but testr is just a Rectangle2D", "label": {"api": {"Rectangle2D.Float": [[29, 45]]}}}, {"text": "Only setters to set the entire rectangle (namely setRect)", "label": {"api": {"setRect": [[49, 55]]}}}, {"text": "What is left to do is to extract the key from the Map.Entry", "label": {"api": {"Map.Entry": [[50, 58]]}}}, {"text": "From the Character.getNumericValue() documenation", "label": {"api": {"Character.getNumericValue() documenation": [[9, 48]]}}}, {"text": "Use the Point class", "label": {"api": {"Point class": [[8, 18]]}}}, {"text": "The Javadocs for println defer to the print method to cover what happens when a null is passed", "label": {"api": {"the print method": [[34, 49]]}}}, {"text": "From the Javadoc for PrintWriter", "label": {"api": {"Javadoc for PrintWriter": [[9, 31]]}}}, {"text": "Easier way is to have a set of Character keep adding to that and if length of that set is different from length of Word", "label": {"api": {"Character": [[31, 39]]}}}, {"text": "Supply it with a custom (simple) AbstractFormatterFactory", "label": {"api": {"AbstractFormatterFactory": [[33, 56]], "AbstractFormatter": [[33, 49]]}}}, {"text": "Your custom AbstractFormatterFactory makes custom (simple) AbstractFormatters", "label": {"api": {"AbstractFormatterFactory": [[12, 35]], "AbstractFormatter": [[12, 28], [59, 75]]}}}, {"text": "These AbstractFormatters handle the parsing of the user's input string to a value, and back, so you can then check for any parsing errors and throw ParseException if needed", "label": {"api": {"AbstractFormatter": [[6, 22]]}}}, {"text": "A custom DocumentFilter in the JFormattedTextField will do the trick", "label": {"api": {"DocumentFilter": [[9, 22]]}}}, {"text": "In AbstractFormatter there is a method called getDocumentFilter()", "label": {"api": {"AbstractFormatter": [[3, 19]], "DocumentFilter": [[49, 62]]}}}, {"text": "If you see the code, this method is called to add a DocumentFilter to the JFormattedTextField", "label": {"api": {"DocumentFilter": [[52, 65]]}}}, {"text": "DocumentFilters' methods are called while the user is typing, i.e", "label": {"api": {"DocumentFilter": [[0, 13]]}}}, {"text": "The default implementation returns null, which means no DocumentFilter will be added", "label": {"api": {"DocumentFilter": [[56, 69]]}}}, {"text": "So I just only overrided this method to implement my custom (simple) DocumentFilter which in turn checks the user input while the user is typing it..", "label": {"api": {"DocumentFilter": [[69, 82]]}}}, {"text": "Create a formatter with a format matching your input", "label": {"api": {"format matching your input": [[26, 51]]}}}, {"text": "Use parse, not format, to parse it", "label": {"api": {"parse": [[4, 8], [26, 30]]}}}, {"text": "You can convert a hex string to a byte array with DatatypeConverter.parseHexBinary", "label": {"api": {"DatatypeConverter.parseHexBinary": [[50, 81]]}}}, {"text": "using javax.tools.JavaCompiler, EclipseCompiler, or Janino)", "label": {"api": {"javax.tools.JavaCompiler": [[6, 29]]}}}, {"text": "The encodeText function from the same class will work on strings, but it produces Q-encoding, which is similar to quoted-printable but not quite the same", "label": {"api": {"encodeText": [[4, 13]]}}}, {"text": "You could just test the input against a regular expression using String.matches() to make sure it's only digits (no need to catch an exception such as a NumberFormatException - it can be considered bad practice to provoke exceptions to validate conditions)", "label": {"api": {"String.matches()": [[65, 80]], "NumberFormatException": [[153, 173]]}}}, {"text": "If you just want to try to convert to an Integer directly and catch an exception you should use Integer.parseInt() (it will throw a NumberFormatException if the input can't be parsed as an Integer)", "label": {"api": {"NumberFormatException": [[132, 152]], "Integer.parseInt()": [[96, 113]]}}}, {"text": "Use String.split(String regex, int limit) with negative limit (e.g", "label": {"api": {"String.split(String regex, int limit)": [[4, 40]]}}}, {"text": "When String.split(String regex) is called, it is called with limit = 0, which will remove all trailing empty strings in the array (in most cases, see below)", "label": {"api": {"String.split(String regex)": [[5, 30]]}}}, {"text": "The actual behavior of String.split(String regex) is quite confusing", "label": {"api": {"String.split(String regex)": [[23, 48]]}}}, {"text": "This uses String.matches(String regex) instead of going through Pattern class", "label": {"api": {"Pattern": [[64, 70]]}}}, {"text": "The regex above checks the character based on the Character.isJavaIdentifierStart and Character.isJavaIdentifierPart methods", "label": {"api": {"Character.isJavaIdentifierStart": [[50, 80]], "Character.isJavaIdentifierPart": [[86, 115]]}}}, {"text": "you can use a TreeMap and store the values in a reverse order", "label": {"api": {"TreeMap": [[14, 20]]}}}, {"text": "In particular, use the Class.getFields method to determine the fields of a given class", "label": {"api": {"Class.getFields": [[23, 37]]}}}, {"text": "Alternatively, you could use reflection (see for example getActualTypeArguments() from the ParametrizedType interface)", "label": {"api": {"getActualTypeArguments()": [[57, 80]]}}}, {"text": "You will need to call setText on each JLabel after calculating the new corresponding value for that label", "label": {"api": {"setText": [[22, 28]]}}}, {"text": "Just use the Enum.ordinal() method of an enum to get the ordered number from 0 to X which you can compare to your x variable", "label": {"api": {"Enum.ordinal()": [[13, 26]]}}}, {"text": "Call LogManager.readConfiguration() after you set the system property in your code", "label": {"api": {"LogManager.readConfiguration()": [[5, 34]]}}}, {"text": "Use ClassLoader.getResourceAsStream(String) and LogManager.readConfiguration(InputStream) to load your properties file", "label": {"api": {"ClassLoader.getResourceAsStream(String)": [[4, 42]], "LogManager.readConfiguration(InputStream)": [[48, 88]]}}}, {"text": "You may use return os.toString(\"UTF-8\");", "label": {"api": {"return os.toString(\"UTF-8\");": [[12, 39]]}}}, {"text": "Why aren't the Key Event descriptions pretty", "label": {"api": {"Key Event": [[15, 23]]}}}, {"text": "You simply use Date.compareTo() to compare two date objects", "label": {"api": {"Date.compareTo()": [[15, 30]]}}}, {"text": "If you want to learn Java from the scratch you start with generating a random int, converting this int to a String", "label": {"api": {"random int": [[71, 80]], "int to a String": [[99, 113]]}}}, {"text": "The String can be used to build your desired output", "label": {"api": {"build": [[26, 30]]}}}, {"text": "List#subList is exactly suited for this purpose", "label": {"api": {"List#subList": [[0, 11]]}}}, {"text": "A better idea, especially if you are working with money, is to use the BigDecimal class", "label": {"api": {"BigDecimal": [[71, 80]]}}}, {"text": "To meet your immediate needs, you can use BigDecimal as follows (although it may be best to eliminate the double type from your program and use BigDecimal throughout)", "label": {"api": {"BigDecimal": [[42, 51], [144, 153]]}}}, {"text": "In order to invoke one of the parameterized constructors, you need to effectively \"locate\" it by its signature using the getDeclaredConstructor method", "label": {"api": {"getDeclaredConstructor": [[121, 142]]}}}, {"text": "Use Arrays.toString to print out your array", "label": {"api": {"Arrays.toString": [[4, 18]]}}}, {"text": "You can also review example of usage in DirectByteBuffer class, which created by ByteBuffer#allocateDirect(int)", "label": {"api": {"ByteBuffer#allocateDirect(int)": [[81, 110]]}}}, {"text": "scale, at least by itself, is not what I need", "label": {"api": {"scale": [[0, 4]]}}}, {"text": "Use ReferenceQueues to archieve that", "label": {"api": {"ReferenceQueue": [[4, 17]]}}}, {"text": "You might want to look into PhantomReferences, too, depending on what you're actually trying to do (but WeakReferences work with the queues, too)", "label": {"api": {"PhantomReference": [[28, 43]]}}}, {"text": "The ReferenceQueue is superiour in all aspects", "label": {"api": {"ReferenceQueue": [[4, 17]]}}}, {"text": "My question is, how do I programmatically emulate cat test.wav | ffmpeg -i pipe:0 using JNI and avformat_open_input using a FileDescriptor", "label": {"api": {"FileDescriptor": [[124, 137]]}}}, {"text": "I think that the problem is that in Spring 4, they use @Repeatable annotation, which has only been introduced in Java 8", "label": {"api": {"@Repeatable": [[55, 65]]}}}, {"text": "Use a Session, as that probably is the only thing being null", "label": {"api": {"Session": [[6, 12]]}}}, {"text": "For more reading ByteBuffer", "label": {"api": {"ByteBuffer": [[17, 26]]}}}, {"text": "DataInputBuffer.ReadUTF() reads in a string encoded in modified utf-8, which makes it a bad candidate for reading data that is not encoded with DataOutputBuffer.WriteUTF()", "label": {"api": {"modified utf-8": [[55, 68]]}}}, {"text": "The variable i is of type LoopTagStatus", "label": {"api": {"LoopTagStatus": [[26, 38]]}}}, {"text": "To get an int, you can use getCount() or getIndex()", "label": {"api": {"getCount()": [[27, 36]], "getIndex()": [[41, 50]]}}}, {"text": "Use the byte array to form a ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[29, 48]]}}}, {"text": "Load the byte array input stream using ImageIO.read(InputStream)", "label": {"api": {"ImageIO.read(InputStream)": [[39, 63]]}}}, {"text": "Objects.equals is null-safe and will not mind when the phone number is null", "label": {"api": {"Objects.equals": [[0, 13]]}}}, {"text": "Then, in your application, you load your EntityManager using the @PersistenceContext annotation, specifying a \"unitName\" parameter", "label": {"api": {"\"unitName\"": [[110, 119]]}}}, {"text": "You can do this using the InetAddress.isSiteLocal() method", "label": {"api": {"InetAddress.isSiteLocal()": [[26, 50]]}}}, {"text": "The default java URLClassLoader uses files in directories or jars, so that's where the \"typically\" comes from, the \"not necessarily\" is just a hint that there may be other implementations", "label": {"api": {"URLClassLoader": [[17, 30]]}}}, {"text": "The toArray method returns a new array (therefore your P array is empty)", "label": {"api": {"toArray": [[4, 10]]}}}, {"text": "Use the contains method, it works like this", "label": {"api": {"contains": [[8, 15]]}}}, {"text": "If you want one process to block the other, you could use ReadWriteLock or similar", "label": {"api": {"ReadWriteLock": [[58, 70]]}}}, {"text": "It's a JPanel", "label": {"api": {"JPanel": [[7, 12]]}}}, {"text": "When you have this, you can sort the array with Arrays.sort(items, comparator)", "label": {"api": {"Arrays.sort(items, comparator)": [[48, 77]]}}}, {"text": "though I'd urge you to look into converting this code to use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[63, 86]]}}}, {"text": "Use a StringReader to read from a String", "label": {"api": {"StringReader": [[6, 17]]}}}, {"text": "You can use ServletContext#getResource() method to check resource (e.g", "label": {"api": {"ServletContext#getResource()": [[12, 39]]}}}, {"text": "Also, if you're already on Java 7, then you can use Objects.toString(Object) method, that handles null for you", "label": {"api": {"Objects.toString(Object)": [[52, 75]]}}}, {"text": "You could instead use    CopyOnWriteArrayList, it's not very efficient, but solves the ConcurrentModificationException, and you can use safely the remove method", "label": {"api": {"CopyOnWriteArrayList": [[25, 44]]}}}, {"text": "No you cannot, but you can create a separate Comparator for each ordering", "label": {"api": {"Comparator": [[45, 54]]}}}, {"text": "I have searched around on the interweb, and found a reference to a class called UndoManager", "label": {"api": {"UndoManager": [[80, 90]]}}}, {"text": "Also, the add item http://docs.oracle.com/javase/6/docs/api/javax/swing/JComboBox.html#addItem%28java.lang.Object%29 method allows you to use text field input for your JComboBox", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/swing/JComboBox.html#addItem%28java.lang.Object%29": [[19, 115]]}}}, {"text": "Apart from @IanRoberts's suggestion, you could make use of the @Encoded annotation to get to the original undecoded value of you parameter (by default Jersey decodes the values and that's why id+ASC becomes id ASC in your code)", "label": {"api": {"@Encoded": [[63, 70]]}}}, {"text": "To change the behavior you just add @Encoded", "label": {"api": {"@Encoded": [[36, 43]]}}}, {"text": "Both ArrayList and String implement Serializable", "label": {"api": {"Serializable": [[36, 47]]}}}, {"text": "You need to call the compareTo method, which will indicate the result of the comparison by returning an integer less than, greater than, or equal to 0", "label": {"api": {"compareTo": [[21, 29]]}}}, {"text": "Therefore, you can't use > even if the objects implement Comparable", "label": {"api": {"Comparable": [[57, 66]]}}}, {"text": "You have to use compareTo() instead", "label": {"api": {"compareTo()": [[16, 26]]}}}, {"text": "With that said, Java has its own HTTP server class available", "label": {"api": {"HTTP server class": [[33, 49]]}}}, {"text": "For writing new lines, check out the newLine() method of the BufferedWriter class", "label": {"api": {"check out the newLine() method": [[23, 52]]}}}, {"text": "The string appearing in the source code is interned, i.e., kept in a special pool, and there's no chance to collect it as it's referenced by the code of your method", "label": {"api": {"intern": [[43, 48]]}}}, {"text": "Consider using an AtomicReference to make the swap thread safe", "label": {"api": {"AtomicReference": [[18, 32]]}}}, {"text": "Go for ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[7, 23]]}}}, {"text": "You can use the Arrays.toString() static helper method as follows", "label": {"api": {"Arrays.toString()": [[16, 32]]}}}, {"text": "It's one of the things that the Javadoc recommends at the bottom", "label": {"api": {"Javadoc recommends at the bottom": [[32, 63]]}}}, {"text": "Look at the Method API, ...", "label": {"api": {"Method API": [[12, 21]]}}}, {"text": "As Takendarkk says a set is useful", "label": {"api": {"set": [[21, 23]]}}}, {"text": "putIfAbsent(K, V), but some other useful actions doesn't", "label": {"api": {"putIfAbsent(K, V)": [[0, 16]]}}}, {"text": "Why not just use the toLowerCase function on String, and use that version of the recipient as the key", "label": {"api": {"toLowerCase": [[21, 31]]}}}, {"text": "Set.addAll will do this", "label": {"api": {"Set.addAll": [[0, 9]]}}}, {"text": "As for the highest frequency, you could use the Collections.max method on the entry set like this", "label": {"api": {"Collections.max": [[48, 62]]}}}, {"text": "will make both a and str to point to String \"anything\"", "label": {"api": {"String": [[37, 42]]}}}, {"text": "String is immutable and can not be overwritten", "label": {"api": {"String": [[0, 5]]}}}, {"text": "If you check the JavaDoc for String", "label": {"api": {"String": [[29, 34]]}}}, {"text": "Most of the methods return a String", "label": {"api": {"String": [[29, 34]]}}}, {"text": "This is because any operation in a String will not change that String object but will result in a new String being created", "label": {"api": {"String": [[35, 40], [63, 68], [102, 107]]}}}, {"text": "Effectively you can never change a String after you create it", "label": {"api": {"String": [[35, 40]]}}}, {"text": "By Change I mean append new characters, remove characters without a new String object being created", "label": {"api": {"String": [[72, 77]]}}}, {"text": "You can use the result set's meta data to create a framework that will do type conversions and inject data into your classes depending on type", "label": {"api": {"result set's meta data": [[16, 37]]}}}, {"text": "Also make sure you deep clone your objects by overrriding the Object#clone method (see Object.clone()", "label": {"api": {"Object.clone()": [[87, 100]]}}}, {"text": "Have a look at NavigableMap", "label": {"api": {"NavigableMap": [[15, 26]]}}}, {"text": "You can use a TreeMap which has a built-in method for that", "label": {"api": {"built-in method": [[34, 48]]}}}, {"text": "javax.annotation.ManagedBean is not a jax-rs annotation, and because of that, the container shouldn't assume anything about jax-rs when reading that annotation, so, yes, @Path and @Produces are enough for the container to consider it as a jax-rs resource", "label": {"api": {"javax.annotation.ManagedBean": [[0, 27]]}}}, {"text": "You can use @ManagedBean if you want additional services (non-jax-rs related) to be provided to your resources by the container, check the link", "label": {"api": {"link": [[139, 142]]}}}, {"text": "You can use the Arraylist.remove() method", "label": {"api": {"Arraylist.remove()": [[16, 33]]}}}, {"text": "As you need to access elements at a given index I would suggest to use ArrayList", "label": {"api": {"ArrayList": [[71, 79]], "List": [[76, 79]]}}}, {"text": "If you know the index and just want to remove the element from there use LinkedList", "label": {"api": {"LinkedList": [[73, 82]], "List": [[79, 82]]}}}, {"text": "I would advise also coding against the List interface, hence your code will look like this", "label": {"api": {"List": [[39, 42]]}}}, {"text": "Read up on the API for String", "label": {"api": {"Read up on the API for String": [[0, 28]]}}}, {"text": "The return type of Object.getClass is special", "label": {"api": {"Object.getClass": [[19, 33]]}}}, {"text": "EnumSet.allOf declares the type parameter E extends Enum<E>, and in your case", "label": {"api": {"EnumSet.allOf": [[0, 12]]}}}, {"text": "EnumSet.allOf(sampleCol.getClass()) is allowed to compile with an \"unchecked invocation\" warning (this gets hidden by the subsequent \"unchecked conversion\" warning from assigning the resulting raw EnumSet to Set<C>)", "label": {"api": {"EnumSet.allOf": [[0, 12]]}}}, {"text": "you should use getDeclaringClass() instead", "label": {"api": {"getDeclaringClass()": [[15, 33]]}}}, {"text": "I would use the java.nio.file package.It has all that you need and more", "label": {"api": {"java.nio.file": [[16, 28]]}}}, {"text": "You may be able to leverage java.awt.TexturePaint, illustrated here and here", "label": {"api": {"java.awt.TexturePaint": [[28, 48]]}}}, {"text": "For more detailed information, read the javadocs ..", "label": {"api": {"the javadocs": [[36, 47]]}}}, {"text": "See the methods of the File API for details on listing the files and getting the date", "label": {"api": {"File": [[23, 26]]}}}, {"text": "This is (kind of) where equals() steps in - by its contract, two non-null instances must be equivalent to each other if they are indeed the same thing", "label": {"api": {"equals()": [[24, 31]]}}}, {"text": "I say \"kind of\" since there's really nothing to enforce the supposed contract on Object#equals; you could (with some effort) write an asymmetric equals() method, although one would wonder why you would want to", "label": {"api": {"equals()": [[145, 152]]}}}, {"text": "Use Array List", "label": {"api": {"Array List": [[4, 13]]}}}, {"text": "Examples of this are input streams to read from files (FileInputStream object in java), read from networks, read from existing byte arrays (ByteArrayInputStream), etc", "label": {"api": {"InputStream": [[59, 69], [149, 159]]}}}, {"text": "Writing to a file (FileOutputStream), writing to a TCP stream, writing to a target byte array are all examples of this", "label": {"api": {"OutputStream": [[23, 34]]}}}, {"text": "In java specifically, the InputStream and OutputStream class define the basic specifications of all I/O streams in java", "label": {"api": {"InputStream": [[26, 36]], "OutputStream": [[42, 53]]}}}, {"text": "to that since I have not used it, and am not sure if the Media source of the MediaPlayer can be a video camera", "label": {"api": {"Media": [[57, 61], [77, 81]], "MediaPlayer": [[77, 87]]}}}, {"text": "You should put a Thread.sleep(long) before the \"setContentView(R.layout.xxxx..)\" in the onCreate(..) function", "label": {"api": {"Thread.sleep(long)": [[17, 34]]}}}, {"text": "String.split(String regex) takes a regular expression", "label": {"api": {"String.split(String regex)": [[0, 25]]}}}, {"text": "You can use Arrays.copyOfRange", "label": {"api": {"Arrays.copyOfRange": [[12, 29]]}}}, {"text": "Field#getType() method returns you a Class<?> object, representing the Class instance for the type of that field", "label": {"api": {"Field#getType()": [[0, 14]], "Class<?>": [[37, 44]]}}}, {"text": "You can also do it using Class#isAssignableFrom() method like this", "label": {"api": {"Class#isAssignableFrom()": [[25, 48]]}}}, {"text": "Now, the issue that you are having can be solved by using Class#getComponentType() method", "label": {"api": {"Class#getComponentType()": [[58, 81]]}}}, {"text": "I can not use setDividerLocation(int) as I don't know the frame's size yet (I maximize it on startup)", "label": {"api": {"setDividerLocation(int)": [[14, 36]]}}}, {"text": "So, I use the proportional version, setDividerLocation(double)", "label": {"api": {"setDividerLocation(double)": [[36, 61]]}}}, {"text": "From the setDividerLocation(double) docs", "label": {"api": {"setDividerLocation(double)": [[9, 34]]}}}, {"text": "Should a more elegant solution be devised please look at SwingWorker which is based on a very similar procedure but with more advanced features", "label": {"api": {"SwingWorker": [[57, 67]]}}}, {"text": "Using printf is the simplest to achieve this", "label": {"api": {"printf": [[6, 11]]}}}, {"text": "You can also use DecimalFormat to show up to the digit you want to print", "label": {"api": {"DecimalFormat": [[17, 29]]}}}, {"text": "Well, a call to File.delete() does not necessary delete the file", "label": {"api": {"File.delete()": [[16, 28]]}}}, {"text": "I've used Regular Expressions to extract the information from the String using the Java Pattern Class", "label": {"api": {"Java Pattern Class": [[83, 100]]}}}, {"text": "How about using Files#readAllBytes", "label": {"api": {"Files#readAllBytes": [[16, 33]]}}}, {"text": "If you want to make a copy of the array's contents, Java provides a static method in the Arrays class", "label": {"api": {"static method in the Arrays class": [[68, 100]]}}}, {"text": "Use Scanner#nextLine() instead of Scanner#next()", "label": {"api": {"Scanner#nextLine()": [[4, 21]]}}}, {"text": "The latter only reads up to the next token delimiter which is a whitespace character of some sort by default", "label": {"api": {"whitespace character of some sort": [[64, 96]]}}}, {"text": "Socket has a getInetAddress() method that will return the remote's address, and a corresponding getPort() method that will return the remote's port", "label": {"api": {"getInetAddress()": [[13, 28]], "getPort()": [[96, 104]]}}}, {"text": "So, if you want to send a fresh copy of your list, you'll have to use the reset() method of ObjectOutputStream first", "label": {"api": {"reset()": [[74, 80]]}}}, {"text": "From the below URL, I am trying to extract 2 Strings i.e String a = \"region/country\"; and String b = \"123xyz\"; I tried using overloaded method of IndexOf but that too didnt help", "label": {"api": {"IndexOf": [[146, 152]]}}}, {"text": "What about using the static method in the Character class", "label": {"api": {"Character": [[42, 50]]}}}, {"text": "You can use the printBase64Binary and parseBase64Binary methods in standard Java to convert to and from base64 strings", "label": {"api": {"printBase64Binary": [[16, 32]], "parseBase64Binary": [[38, 54]]}}}, {"text": "Also, your encryptor's use of Cipher.doFinal(...) is a little suspicious to say the least", "label": {"api": {"Cipher.doFinal(...)": [[30, 48]]}}}, {"text": "Normally you want to encrypt each input piece with the Cipher.update(...) method, use doFinal(...) when you are all finished", "label": {"api": {"Cipher.update(...)": [[55, 72]]}}}, {"text": "compareTo is used to to evaluate greater/lesser/equal", "label": {"api": {"compareTo": [[0, 8]]}}}, {"text": "Equality in terms of a Set is determined by overriding the Object#equals(Object) method", "label": {"api": {"Object#equals(Object)": [[59, 79]]}}}, {"text": "According to the docs, JFileChooser.getSelectedFiles() returns a File array (not a list of Files)", "label": {"api": {"JFileChooser.getSelectedFiles()": [[23, 53]]}}}, {"text": "You can use the Collections.sort method with a custom Comparator", "label": {"api": {"Collections.sort": [[16, 31]], "Comparator": [[54, 63]]}}}, {"text": "I used anonymous Comparator class, you can also write an ordinary Comparator class, see Sri Harsha Chilakapati answer", "label": {"api": {"Comparator": [[17, 26], [66, 75]]}}}, {"text": "JComponent has a method paint(Graphics)", "label": {"api": {"a method paint(Graphics)": [[15, 38]]}}}, {"text": "Each object has toString() method, its default will display the class name representation, then adding @ and then the hashcode", "label": {"api": {"toString()": [[16, 25]]}}}, {"text": "You should use Arrays#toString() (Below is the implementation of it so you can better understand it)", "label": {"api": {"toString()": [[22, 31]], "Arrays#toString()": [[15, 31]]}}}, {"text": "Strings are objects in Java", "label": {"api": {"Strings": [[0, 6]]}}}, {"text": "To compare Strings (as with all objects) you need to use the .equals method", "label": {"api": {"Strings": [[11, 17]]}}}, {"text": "Then, at the server side, you need to get input stream from the request and read data --- and you need to do that in doPost method (http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getParameter%28java.lang.String%29)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getParameter%28java.lang.String%29": [[132, 235]]}}}, {"text": "One of the SwingUtilities.convertPoint() methods should do what you want", "label": {"api": {"SwingUtilities.convertPoint()": [[11, 39]]}}}, {"text": "The answer is yes, and the String class do it well", "label": {"api": {"String class": [[27, 38]]}}}, {"text": "The main class to deal with RE is java.util.regex.Pattern and their official tutorial is here", "label": {"api": {"java.util.regex.Pattern": [[34, 56]]}}}, {"text": "You didn't actually post any code where you're printing anything, but what you want is probably System.out.format()", "label": {"api": {"System.out.format()": [[96, 114]]}}}, {"text": "getClass() returns the Class object representing the \"Card\" class; therefore the code does not refer to Card#getName method, but rather to Class#getName which dutifully returns \"Card\"", "label": {"api": {"Class object": [[23, 34]], "Class#getName": [[139, 151]]}}}, {"text": "At any rate, I be tempted to use the Comparable interface..", "label": {"api": {"Comparable": [[37, 46]]}}}, {"text": "A possible solution would be to use BigInteger to implement the method (instead of long), it's a class for representing arbitrary-precision integers in Java", "label": {"api": {"BigInteger": [[36, 45]]}}}, {"text": "To avoid this, use BigInteger, which can deal with an arbitrary number of digits", "label": {"api": {"BigInteger": [[19, 28]]}}}, {"text": "Note that the return type must be String (or BigInteger) because even the modest value of 93 for x produces a result that is too great for any java primitive to represent", "label": {"api": {"BigInteger": [[45, 54]]}}}, {"text": "Random#nextInt() is neither a static method, nor built-in - you have to have an instance of the Random class to use it", "label": {"api": {"Random#nextInt()": [[0, 15]]}}}, {"text": "You are getting an int because you are adding the unicode values of those characters", "label": {"api": {"unicode values": [[50, 63]]}}}, {"text": "I suggest creating a Set<Integer> to hold your generated values, calling add() for each new card, and checking contains() to see whether a new value has already been selected", "label": {"api": {"Set<Integer>": [[21, 32]]}}}, {"text": "I would prefer using Set instead of a List as Set will automatically handle duplicates so that we need to worry about eliminating them by our own", "label": {"api": {"Set": [[21, 23], [46, 48]], "List": [[38, 41]]}}}, {"text": "Sets don't allow duplicates", "label": {"api": {"Sets": [[0, 3]]}}}, {"text": "and throw a IllegalArgumentException if needed", "label": {"api": {"IllegalArgumentException": [[12, 35]]}}}, {"text": "So you can use Collections.<String>binarySearch(List<String>,String) to search for the position of prefix", "label": {"api": {"Collections.<String>binarySearch(List<String>,String)": [[15, 67]]}}}, {"text": "Sounds like you just need a Scanner object", "label": {"api": {"Scanner": [[28, 34]]}}}, {"text": "To avoid the problem, use the constructor BigDecimal(String val) instead", "label": {"api": {"BigDecimal(String val)": [[42, 63]]}}}, {"text": "You could use runLater(Runnable) to make sure that your code is executed within the right thread", "label": {"api": {"runLater(Runnable)": [[14, 31]]}}}, {"text": "You could create an encoder corresponding to your charset explicitly and use its canEncode method", "label": {"api": {"its canEncode method": [[77, 96]]}}}, {"text": "is written using the Swing GUI toolkit, it is as simple as either using a JWindow, or calling Frame.setUndecorated(true)", "label": {"api": {"JWindow": [[74, 80]], "Frame.setUndecorated(true)": [[94, 119]]}}}, {"text": "You could use a PriorityBlockingQueue and use timestamps to define priorities - something like", "label": {"api": {"PriorityBlockingQueue": [[16, 36]]}}}, {"text": "You need to override the Object#toString() in your class", "label": {"api": {"Object#toString()": [[25, 41]]}}}, {"text": "Method#invoke(Object, Object...) takes the first argument as the object on which this method is invoked, and 2nd argument onwards, it takes the arguments of the method", "label": {"api": {"Method#invoke(Object, Object...)": [[0, 31]]}}}, {"text": "Since Integer#parseInt(String) is a static method", "label": {"api": {"Integer#parseInt(String)": [[6, 29]]}}}, {"text": "This will add the students object to the HashMap with locationID as key", "label": {"api": {"HashMap": [[41, 47]]}}}, {"text": "Iterate over this code and add students to the HashMap", "label": {"api": {"HashMap": [[47, 53]]}}}, {"text": "You can use the CropImageFilter (http://docs.oracle.com/javase/7/docs/api/java/awt/image/CropImageFilter.html) to crop your image after rotation", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/image/CropImageFilter.html": [[33, 108]]}}}, {"text": "If you intend to develop a tool that works like JConsole, you should explore the Java Management packages", "label": {"api": {"Java Management": [[81, 95]]}}}, {"text": "To me it looks, like the line you read from reader does not contain \"From:\" sequence, so execution does not enter while-loop, so the mark is not set, and when execution continues right after while-loop body, reset throws an exception, because the mark was not set, as per reset() documentation", "label": {"api": {"reset() documentation": [[272, 292]]}}}, {"text": "As per the cancel() documentation", "label": {"api": {"cancel() documentation": [[11, 32]]}}}, {"text": "To use it with a Pattern you need to use Matcher#replaceAll not String#replaceAll", "label": {"api": {"Matcher#replaceAll": [[41, 58]]}}}, {"text": "I know java.io.File has a method lastModified() which returns the time in milliseconds", "label": {"api": {"java.io.File": [[7, 18]], "lastModified()": [[33, 46]]}}}, {"text": "I can also pass that time in milliseconds to the constructor of the java.util.Date class", "label": {"api": {"java.util.Date": [[68, 81]]}}}, {"text": "If you can use Java 7 or 8 you could use the FileVisitor, but in Java 7 it means writing more then one line of code", "label": {"api": {"FileVisitor": [[45, 55]]}}}, {"text": "To me, this sounds like a Usecase of HashSet", "label": {"api": {"HashSet": [[37, 43]]}}}, {"text": "The explanation is in the second sentence of the Scanner javadoc", "label": {"api": {"Scanner javadoc": [[49, 63]]}}}, {"text": "It's just an application of java.security.KeyStore, nothing magical about it", "label": {"api": {"java.security.KeyStore": [[28, 49]]}}}, {"text": "(noted in InputStream#read)", "label": {"api": {"InputStream#read": [[10, 25]]}}}, {"text": "In this case, the get() method should return an instance of java.lang.Number", "label": {"api": {"java.lang.Number": [[60, 75]]}}}, {"text": "For more details you will want to look at the api for the java.util.Formatter class", "label": {"api": {"java.util.Formatter": [[58, 76]]}}}, {"text": "To properly use printf, provide the format all in the first argument, and supply values with all other arguments", "label": {"api": {"printf": [[16, 21]]}}}, {"text": "Also see the formatting summary", "label": {"api": {"formatting summary": [[13, 30]]}}}, {"text": "The Javadocs for Collections.binarySearch state", "label": {"api": {"Javadocs for Collections.binarySearch": [[4, 40]]}}}, {"text": "In ArrayBlockingQueue, inside the put method, why does it call notFull.signal() after catching InterruptedException", "label": {"api": {"ArrayBlockingQueue": [[3, 20]]}}}, {"text": "We can then use Graphics2D.scale(sx,sy)", "label": {"api": {"Graphics2D.scale(sx,sy)": [[16, 38]]}}}, {"text": "A scale instance of an AffineTransform (obtained using getScaleInstance(sx,sy)", "label": {"api": {"getScaleInstance(sx,sy)": [[55, 77]]}}}, {"text": "You should take a look at Jlist#setVisibleRowCount if you want to affect the number of visible rows a JList will show before it needs to be scrolled", "label": {"api": {"Jlist#setVisibleRowCount": [[26, 49]]}}}, {"text": "The actual width and height of each row is determined by the ListCellRenderer, but you can use JList#setPrototypeCellValue to affect how these might be calculated", "label": {"api": {"JList#setPrototypeCellValue": [[95, 121]]}}}, {"text": "In terms of speed, writeableraster allows you to make pretty fast alterations to an image", "label": {"api": {"writeableraster": [[19, 33]]}}}, {"text": "When I was doing that kind of coding, I found that using the setPixels method in writeableraster was a LOT faster than relying on the paintComponent approach, such as drawing shapes", "label": {"api": {"writeableraster": [[81, 95]]}}}, {"text": "You could use String#charAt() to access each individual char of your String and then use Character.getNumericValue to convert the char to its numeric equivalent", "label": {"api": {"Character.getNumericValue": [[89, 113]]}}}, {"text": "You can use Arrays.copyOf()", "label": {"api": {"Arrays.copyOf()": [[12, 26]]}}}, {"text": "I think it might be easier to use a Map here", "label": {"api": {"Map": [[36, 38]]}}}, {"text": "Use a ScheduledExecutorService with its scheduleAtFixedRate method", "label": {"api": {"scheduleAtFixedRate": [[40, 58]]}}}, {"text": "Just use the overload of addAll which takes the index at which to insert the items", "label": {"api": {"overload of addAll": [[13, 30]]}}}, {"text": "The problem is that you're using Matcher.matches(), which is documented as", "label": {"api": {"Matcher.matches()": [[33, 49]]}}}, {"text": "I think you probably want to be calling find() instead", "label": {"api": {"find()": [[40, 45]]}}}, {"text": "For a reference see the javadoc for Element", "label": {"api": {"javadoc for Element": [[24, 42]]}}}, {"text": "To check simple use Integer.parseInt() and catch the NumberFormatException (together with Scanner.next())", "label": {"api": {"Integer.parseInt()": [[20, 37]]}}}, {"text": "The first argument to the FileHandler is a file pattern described in the top level class documentation", "label": {"api": {"FileHandler": [[26, 36]]}}}, {"text": "If you pass just a file name without a pattern the FileHandler will have to resort to appending the generation to the file name so it can rotate between the files", "label": {"api": {"FileHandler": [[51, 61]]}}}, {"text": "If the generations clash due to multiple JVM instances running at the same time the FileHandler can append a unique number to the file name", "label": {"api": {"FileHandler": [[84, 94]]}}}, {"text": "If you're on Java 7 then you can use the KeyEvent.getExtendedKeyCodeForChar method to get the key code from a char", "label": {"api": {"KeyEvent.getExtendedKeyCodeForChar": [[41, 74]]}}}, {"text": "After some tests, I've found a more flexible solution using a TreeMap<Integer, Double> which allows you to have a specie of range (what you're looking for) and ease the search by using TreeMap#ceilingEntry", "label": {"api": {"TreeMap#ceilingEntry": [[185, 204]]}}}, {"text": "java.util.Map comes with entrySet() method that..", "label": {"api": {"entrySet()": [[25, 34]]}}}, {"text": "The URL must be encoded, and Java has an object for that", "label": {"api": {"Java has an object for that": [[29, 55]]}}}, {"text": "However I would instead investigate Executors and Futures, so you can spawn a thread via an Executor, get a Future and then call Future.get()", "label": {"api": {"Executors": [[36, 44]], "Futures": [[50, 56]]}}}, {"text": "From the documentation for PrintStream", "label": {"api": {"documentation for PrintStream": [[9, 37]]}}}, {"text": "So, depending on the platform encoding, System.out can lose data", "label": {"api": {"the platform encoding": [[17, 37]]}}}, {"text": "This approach will be much easier than dealing with Calendar", "label": {"api": {"Calendar": [[52, 59]]}}}, {"text": "Suggest reviewing the Javadoc for the PrintWriter", "label": {"api": {"PrintWriter": [[38, 48]]}}}, {"text": "Perhaps you should read JavaDoc API spec", "label": {"api": {"JavaDoc API spec": [[24, 39]]}}}, {"text": "You will also want to look at the JavaFX CSS Reference Guide, where the possible CSS elements for JavaFX are explained", "label": {"api": {"JavaFX CSS Reference Guide": [[34, 59]]}}}, {"text": "take a look at Collections.disjoint(Collection<?> c1, Collection<?> c2)", "label": {"api": {"Collections.disjoint(Collection<?> c1, Collection<?> c2)": [[15, 70]]}}}, {"text": "In general, when you're using a class you should look at its documentation - in this case the documentation for ArrayList", "label": {"api": {"documentation for ArrayList": [[94, 120]]}}}, {"text": "If dealing with larger numbers you'll need to switch to BigInteger or similar", "label": {"api": {"BigInteger": [[56, 65]]}}}, {"text": "You might want to be using the Scanner class for it, especially the Scanner.nextDouble() method", "label": {"api": {"Scanner": [[31, 37], [68, 74]], "Scanner.nextDouble()": [[68, 87]]}}}, {"text": "Also, if you don't know in advance the dimensions of the array - I'd suggest using an ArrayList instead of a regular array", "label": {"api": {"ArrayList": [[86, 94]]}}}, {"text": "You must use BigInteger to store values that exceed the max value of long", "label": {"api": {"BigInteger": [[13, 22]]}}}, {"text": "Just use http://docs.oracle.com/javase/6/docs/api/java/util/Random.html#nextInt(int) along with the size of an array", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Random.html#nextInt(int)": [[9, 83]]}}}, {"text": "You can specify the RoundingMode for the DecimalFormatter, but please choose it as per your needs(I've just given an example using HALF_UP)", "label": {"api": {"RoundingMode": [[20, 31]], "DecimalFormatter": [[41, 56]]}}}, {"text": "Alternatively, you can also use BigDecimal(incase you know why we usually go for BigDecimal instead of double) for the same", "label": {"api": {"BigDecimal": [[32, 41], [81, 90]]}}}, {"text": "At a last step you have to register a NamespaceContext implementation, which maps the namespace prefixes used in your XPath expressions to namespace URIs", "label": {"api": {"NamespaceContext": [[38, 53]]}}}, {"text": "By the way a LinkedList \"normally would\" do things I mentioned above, I mean a LinkedList is always a linked-list, even if you assign it to a Queue - it doesn't suddenly start using an array as the underlying implementation, as an ArrayDeque would (which also implements Queue), or something else", "label": {"api": {"ArrayDeque": [[231, 240]], "Deque": [[236, 240]]}}}, {"text": "Queue doesn't actually need to be FIFO (see the docs) (if it needed to be, a LinkedList would also need to be), so LinkedList would have quite a bit of freedom in this regard, so let's continue this explanation using Deque - it has methods to support addition and removal from either the front or the back", "label": {"api": {"Deque": [[217, 221]]}}}, {"text": "Because LinkedList implements Deque, it needs to implement the addFirst function", "label": {"api": {"Deque": [[30, 34]]}}}, {"text": "Based on the docs, the addFirst function needs to add to the front of the Deque, and indeed, with a LinkedList, it will add to the front of the LinkedList (while the front of the LinkedList doesn't need to be the front of the Deque, by looking at the Deque methods implemented in LinkedList, we see that the front of the Deque is the front of the LinkedList, and all the methods add to / remove from one of the sides, do so from the correct side)", "label": {"api": {"Deque": [[74, 78], [226, 230], [251, 255], [321, 325]]}}}, {"text": "Now for an important albeit somewhat confusing note - LinkedList can, for example, implement Deque and have an addFirst that doesn't do what it's supposed to - it can just, for example, print some random text", "label": {"api": {"Deque": [[93, 97]]}}}, {"text": "There's nothing in the language itself that prevents this - since, as far as the compiler is concerned, implementing Deque just requires that you define a bunch of methods - there's no enforcement of what these methods are supposed to do", "label": {"api": {"Deque": [[117, 121]]}}}, {"text": "In my current solution for Java, I use Java's ThreadPoolExecutor framework to create a job queue, a LinkedListBlockingQueue, and the number of threads equals the available processor on the system", "label": {"api": {"ThreadPoolExecutor": [[46, 63]]}}}, {"text": "The JOptionPane will disappear by itself, whether you click yes or no", "label": {"api": {"JOptionPane": [[4, 14]]}}}, {"text": "just check whether its path ends with \"/\" ( a slash)", "label": {"api": {"path": [[23, 26]]}}}, {"text": "There is nothing in the Driver API mandating that the URL you pass to DriverManager to connect to your database has a host name and a port", "label": {"api": {"Driver": [[24, 29], [70, 75]]}}}, {"text": "If you need your arithmetic to match closely with Decimals then use BigDecimal", "label": {"api": {"BigDecimal": [[68, 77]]}}}, {"text": "If you want to display a byte in hex, you can use Integer.toHexString()", "label": {"api": {"Integer.toHexString()": [[50, 70]]}}}, {"text": "The DriverManager class has various different methods of specifying parameters", "label": {"api": {"DriverManager": [[4, 16]]}}}, {"text": "One of them is the DriverManager.getConnection(String url, String user, String password) method that you're using in your above code", "label": {"api": {"DriverManager": [[19, 31]]}}}, {"text": "There's another one, DriverManager.getConnection(String url, Properties info) that allows to pass additional, possibly database-specific properties as well", "label": {"api": {"DriverManager": [[21, 33]]}}}, {"text": "You'll have to create an instance of the JOPtionPane and use the setWantsInput(boolean) method", "label": {"api": {"JOPtionPane": [[41, 51]], "setWantsInput(boolean)": [[65, 86]]}}}, {"text": "Then you'll need to add a ComponentListener to the Dialog to request selection of your password field", "label": {"api": {"ComponentListener": [[26, 42]]}}}, {"text": "You can find more similar documenation on the JOptionPane javadoc", "label": {"api": {"JOptionPane javadoc": [[46, 64]]}}}, {"text": "You can disable the creation of the xml declaration by setting the output properties on the transformer", "label": {"api": {"output properties": [[67, 83]]}}}, {"text": "If you want to generate text files from the xml then you probably want to specify an XSLT source in the TransformerFactory.newInstance call and set the output properties in that XSLT", "label": {"api": {"output properties": [[152, 168]]}}}, {"text": "You should use the Java File class", "label": {"api": {"File": [[24, 27]]}}}, {"text": "See String.split() if you are unfamiliair with this method", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "For the fill method, you could use Arrays.fill (see the java API javadocs)", "label": {"api": {"java API javadocs": [[56, 72]]}}}, {"text": "Its compare method will define the order of your Creatures that you want", "label": {"api": {"compare method": [[4, 17]]}}}, {"text": "scheduleAtFixedRate states that subsequent executions may be late but it does not wait the given time afterwords", "label": {"api": {"scheduleAtFixedRate": [[0, 18]]}}}, {"text": "Use Arrays.equals to compare arrays and see this for Strings comparisons", "label": {"api": {"Arrays.equals": [[4, 16]]}}}, {"text": "The jdk javadoc hints that using the native endianness can improve performance", "label": {"api": {"jdk javadoc": [[4, 14]]}}}, {"text": "Use a SimpleDateFormat with a pattern appropriate for your input format", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "You'll want to start by looking at the documentation for JOptionPane, specifically JOptionPane.showMessageDialog", "label": {"api": {"JOptionPane": [[57, 67], [83, 93]], "JOptionPane.showMessageDialog": [[83, 111]]}}}, {"text": "What you need to do is to parse the string (which is yielded by the .nextLine() method) into an integer using the Integer.parseInt(String s) method", "label": {"api": {"Integer.parseInt(String s)": [[114, 139]]}}}, {"text": "I'm using Elements.getElementValuesWithDefaults to retrieve annotationvalues", "label": {"api": {"Elements.getElementValuesWithDefaults": [[10, 46]]}}}, {"text": "Key of the returned Map is something extending ExecutableElement", "label": {"api": {"ExecutableElement": [[47, 63]]}}}, {"text": "I did not find an easy way to create an ExecutableElement as key to get the value", "label": {"api": {"ExecutableElement": [[40, 56]]}}}, {"text": "Have you looked at DecimalFormat (a derivation of the abstract NumberFormat)", "label": {"api": {"DecimalFormat": [[19, 31]]}}}, {"text": "As to your point of not wanting a BufferedReader because of buffering, I'd say don't use it", "label": {"api": {"Reader": [[42, 47]]}}}, {"text": "Use one of the other classes that extend Reader or, if you want to be that extreme, roll your own", "label": {"api": {"Reader": [[41, 46]]}}}, {"text": "There is nothing stopping you from creating your own class called DataInputReader, tacking on methods to read your primitives, and providing a proper readLine() implementation to suit your needs", "label": {"api": {"Reader": [[75, 80]]}}}, {"text": "However, if you are reading binary encoded data, I would recommend NOT using a Reader at all, and sticking with a InputStream so you can read raw bytes and handle the conversions yourself", "label": {"api": {"Reader": [[79, 84]]}}}, {"text": "Readers were designed with the handling of character encoding in mind, and as such have a tendency to modify what you are reading under the premise that it is trying to convert binary data to character strings", "label": {"api": {"Reader": [[0, 5]]}}}, {"text": "Add AdjustmentListeners to both ScrollBars", "label": {"api": {"AdjustmentListeners": [[4, 22]]}}}, {"text": "Whenever you scroll through them, you receive an AdjustementEvent that tells you whether the scroll value got incremented or decremented", "label": {"api": {"AdjustementEvent": [[49, 64]]}}}, {"text": "You'll want to use a Writer with the proper encoding", "label": {"api": {"Writer": [[21, 26]]}}}, {"text": "If you need to output a binary 16-bit signed integer for some reason, you can use writeShort, but if you really need that much control you may want to use a ByteBuffer instead", "label": {"api": {"ByteBuffer": [[157, 166]]}}}, {"text": "The value you're trying to convert is greater than the Integer.MAX_VALUE (2,147,483,647), you should use one of the alternative types Long, BigInteger", "label": {"api": {"Long": [[134, 137]], "BigInteger": [[140, 149]]}}}, {"text": "You have to use Arrays.toString method", "label": {"api": {"Arrays.toString": [[16, 30]]}}}, {"text": "ConcurrentHashMap doesn't allow either the key or the value to be null, unlike some other Map implementations", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "Read here ConcurrentHasMap guide, as you can read", "label": {"api": {"ConcurrentHasMap guide": [[10, 31]]}}}, {"text": "The string literal \"\\\\s\\\\s*\" is equivalent to the regular expression syntax \\s\\s* which matches \"a whitespace character followed by zero or more whitespace characters\"", "label": {"api": {"regular expression syntax": [[50, 74]]}}}, {"text": "See Pattern class documentation", "label": {"api": {"Pattern": [[4, 10]]}}}, {"text": "You may be looking or java.awt.image.LookupOp, which uses a java.awt.image.LookupTable to modify bands en bloc", "label": {"api": {"java.awt.image.LookupOp": [[22, 44]], "java.awt.image.LookupTable": [[60, 85]]}}}, {"text": "From what I understand, the proper place to do that is inside the ServerEndpointConfig.Configurator.modifyHandshake() method of my own Configurator implementation", "label": {"api": {"ServerEndpointConfig.Configurator.modifyHandshake()": [[66, 116]]}}}, {"text": "There's a HandshakeResponse parameter which allows adding headers to the response but I couldn't find any header that does the job", "label": {"api": {"HandshakeResponse": [[10, 26]]}}}, {"text": "The JavaDoc for TransformerFactory.newInstance() states", "label": {"api": {"TransformerFactory.newInstance()": [[16, 47]]}}}, {"text": "Yes, simply call the setProperty method", "label": {"api": {"setProperty": [[21, 31]]}}}, {"text": "Then, right before you close, call save", "label": {"api": {"save": [[35, 38]]}}}, {"text": "When you start up, call load the same way you already are", "label": {"api": {"load": [[24, 27]]}}}, {"text": "Even better than all of this, use Preferences", "label": {"api": {"Preferences": [[34, 44]]}}}, {"text": "Anyway, if you happen to work with synchronized collections, give a look at the classes at java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[91, 110]]}}}, {"text": "Some of them are CopyOnWriteArrayList (for List) and CopyOnWriteArraySet (for Set)", "label": {"api": {"CopyOnWriteArrayList": [[17, 36]], "CopyOnWriteArraySet": [[53, 71]]}}}, {"text": "Use Arrays.toString() to get the string representing the array", "label": {"api": {"Arrays.toString()": [[4, 20]]}}}, {"text": "original, use Class#isArray(), like this", "label": {"api": {"Class#isArray()": [[14, 28]]}}}, {"text": "You'll need to call remove, passing the index size, which will return the necessary item that you can return in your pop method", "label": {"api": {"remove, passing the index size": [[20, 49]]}}}, {"text": "The ActionListener interface is in java.awt.event; import it (same for ActionEvent)", "label": {"api": {"ActionListener interface is in java.awt.event": [[4, 48]]}}}, {"text": "The reason for this is that String implements Comparable<String>", "label": {"api": {"String implements Comparable<String>": [[28, 63]]}}}, {"text": "In java 1.7, new IO classes were added, including the Files utility class which has a method copy", "label": {"api": {"Files": [[54, 58]], "copy": [[93, 96]]}}}, {"text": "I finally ended up packing the OTP and password into a String and passed the two parameters username and (password+otp) to HttpServletRequest#login(java.lang.String username, java.lang.String password)", "label": {"api": {"HttpServletRequest#login(java.lang.String username, java.lang.String password)": [[123, 200]]}}}, {"text": "I'm using HttpUrlConnection class in my java code", "label": {"api": {"HttpUrlConnection": [[10, 26]]}}}, {"text": "To retrieve the bundles we have a custom java.util.ResourceBundle.Control", "label": {"api": {"java.util.ResourceBundle.Control": [[41, 72]]}}}, {"text": "There exists a str.indexOf(substring,index) method in the String API", "label": {"api": {"str.indexOf(substring,index)": [[15, 42]]}}}, {"text": "You can catch the fault in the client code, and in the catch block retrieve the fault code and string with exception.getFaultCode() and exception.getFaultString(), have a look at the javadoc for further details", "label": {"api": {"avadoc": [[184, 189]]}}}, {"text": "The Normalizer javadoc has a better explanation on Unicode {de,}composition", "label": {"api": {"Normalizer javadoc": [[4, 21]]}}}, {"text": "Don't forget to close your FileWriter once you are done writing to it", "label": {"api": {"close": [[16, 20]]}}}, {"text": "Application scoped beans are placed into the application map and remain there until the application is stopped", "label": {"api": {"application map": [[45, 59]]}}}, {"text": "Just consider Component.isShowing()", "label": {"api": {"Component.isShowing()": [[14, 34]]}}}, {"text": "Specifically, the redirectOutput(File) method", "label": {"api": {"redirectOutput(File)": [[18, 37]]}}}, {"text": "If using ProcessBuilder is a requirement, take a look at the example on ProcessBuilder's Documentation Page", "label": {"api": {"Documentation Page": [[89, 106]]}}}, {"text": "For good example of classes being extended, look at the Collection API in java.util where you can see java.util.AbstractList is extended to ultimately create two different types of list, each with different characteristics - java.util.ArrayList and java.util.LinkedList", "label": {"api": {"java.util": [[74, 82], [102, 110], [225, 233], [249, 257]], "java.util.AbstractList": [[102, 123]], "java.util.ArrayList": [[225, 243]], "java.util.LinkedList": [[249, 268]]}}}, {"text": "I'm not 100% sure I understand your requirement, but I think you can use a ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[75, 99]]}}}, {"text": "But I am getting the NumberFormatException", "label": {"api": {"NumberFormatException": [[21, 41]]}}}, {"text": "If you want to keep the time in your print statement, you can use a SimpleDateFormat instead", "label": {"api": {"SimpleDateFormat": [[68, 83]]}}}, {"text": "System.exit takes one argument and you should pass an exit status to it, e.g", "label": {"api": {"System.exit": [[0, 10]]}}}, {"text": "But if you experience redirects, you can tell HttpURLConnection to automatically follow them", "label": {"api": {"HttpURLConnection to automatically follow them": [[46, 91]]}}}, {"text": "In this case I would just use a simple String.split(String, int) with a limit of 2", "label": {"api": {"String.split(String, int)": [[39, 63]]}}}, {"text": "nextInt reads only the int value and skips the \\n (when you press enter key right after)", "label": {"api": {"nextInt": [[0, 6]]}}}, {"text": "You should add another nextLine right after the nextInt to consume the \\n", "label": {"api": {"nextInt": [[48, 54]], "nextLine": [[23, 30]]}}}, {"text": "you're looking at ArrayLists, not arrays", "label": {"api": {"ArrayList": [[18, 26]]}}}, {"text": "Another possibility is using a HashMap<String, Integer> but I feel like a custom class is more warranted here", "label": {"api": {"HashMap<String, Integer>": [[31, 54]]}}}, {"text": ".getResource() won't accept a backslash as a separator", "label": {"api": {".getResource() won't accept a backslash as a separator": [[0, 53]]}}}, {"text": "If a is in a Set, then this set can not contain b at the same time, because they are equal and sets don't contain duplicates", "label": {"api": {"Set": [[13, 15]]}}}, {"text": "Use System.nanoTime() instead, which is specifically designed for accurately measuring elapsed execution time, rather than telling the current wall time", "label": {"api": {"System.nanoTime()": [[4, 20]]}}}, {"text": "As a rough measure of the overhead, on my laptop, after JIT warmup, it takes about 14 milliseconds to call System.nanoTime() a million times", "label": {"api": {"System.nanoTime()": [[107, 123]]}}}, {"text": "Use the constant BigInteger.ZERO, which won't be == to any other \"zero\" instance", "label": {"api": {"BigInteger.ZERO": [[17, 31]]}}}, {"text": "Read Collections in Java", "label": {"api": {"Read Collections in Java": [[0, 23]]}}}, {"text": "For example, it doesn't make any sense to have indexOf method for the Set interface", "label": {"api": {"Set": [[70, 72]]}}}, {"text": "However, it can be useful sometimes to construct a new object of different type from an existing one, for example, if you have an ArrayList and you don't want to have duplicates, it does make sense to convert it to HashSet", "label": {"api": {"Set": [[219, 221]]}}}, {"text": "List#add will always return true, since it is unbounded and can contain duplicates", "label": {"api": {"List#add": [[0, 7]]}}}, {"text": "Set#add may return false, if you are adding an element that is already in the set", "label": {"api": {"Set#add": [[0, 6]]}}}, {"text": "Therefore you can use result of Collection#add method to check if an element you added changed the collection", "label": {"api": {"Collection#add": [[32, 45]]}}}, {"text": "See the keySet() method of maps, and to go further, see the toArray() method of sets", "label": {"api": {"keySet()": [[8, 15]], "toArray()": [[60, 68]]}}}, {"text": "Try using the classes that implement the Map interface, meaning that they provide the functionalities you are looking for", "label": {"api": {"Map": [[41, 43]]}}}, {"text": "HashMap is one of such classes", "label": {"api": {"Map": [[4, 6]], "HashMap": [[0, 6]]}}}, {"text": "You might also run into Hashtable, but I think that's overkill for what you want", "label": {"api": {"Hashtable": [[24, 32]]}}}, {"text": "See this question for an explanation of the difference between HashMap and Hashtable", "label": {"api": {"Map": [[67, 69]], "HashMap": [[63, 69]], "Hashtable": [[75, 83]]}}}, {"text": "I would suggest you use classOneFolder.toURI().toURL() instead of building the URL yourself as a String and then recreate a URL from it", "label": {"api": {".toURL()": [[46, 53]]}}}, {"text": "Using File.toURI().toURL() should always build a correct URL", "label": {"api": {"File.toURI()": [[6, 17]], ".toURL()": [[18, 25]]}}}, {"text": "When the Collections framework was expanded, Stack was replaced by the interface Deque", "label": {"api": {"Deque": [[81, 85]]}}}, {"text": "Implementations of Deque include ArrayDeque and LinkedList", "label": {"api": {"Deque": [[19, 23], [38, 42]], "ArrayDeque": [[33, 42]], "LinkedList": [[48, 57]]}}}, {"text": "Your issue seems to be related to blank spaces, I was able to get around the issue by using a ProcessBuilder since it works much better with spaces", "label": {"api": {"ProcessBuilder": [[94, 107]]}}}, {"text": "Use StringBuilder to build the desired String(using append())", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "The you can simply call toString() on the StringBuilder instance to get the String and use it in your JOptionPane.showMessageDialog() method", "label": {"api": {"StringBuilder": [[42, 54]]}}}, {"text": "On the enclosing parent call .setLayout(new BorderLayout());", "label": {"api": {"BorderLayout": [[44, 55]]}}}, {"text": "The component in the center (default) cell of a BorderLayout is forced to match the size of its container", "label": {"api": {"BorderLayout": [[48, 59]]}}}, {"text": "It is most likely being done by the LinkedList's toString() method when you display the list", "label": {"api": {"LinkedList's toString()": [[36, 58]]}}}, {"text": "Check the Java API for Character (http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#isUpperCase(char))", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#isUpperCase(char)": [[34, 116]]}}}, {"text": "For a post 1.5 JVM, you can use http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/Instrumentation.html#getAllLoadedClasses()", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/Instrumentation.html#getAllLoadedClasses()": [[32, 135]]}}}, {"text": "You can create a Polygon object", "label": {"api": {"Polygon": [[17, 23]]}}}, {"text": "a BufferedWriter for this", "label": {"api": {"BufferedWriter": [[2, 15]]}}}, {"text": "You can however apply a transform to a shape by adding a transform to the shape's transform list", "label": {"api": {"shape's transform list": [[74, 95]]}}}, {"text": "If I have a following method; is a call to Calendar.getInstance() thread-safe", "label": {"api": {"Calendar.getInstance()": [[43, 64]]}}}, {"text": "My understanding is Calendar.getInstance() isn't thread safe so following method can't be thread safe", "label": {"api": {"Calendar.getInstance()": [[20, 41]]}}}, {"text": "You can use the split(\"-\") method of the String class", "label": {"api": {"String": [[41, 46]]}}}, {"text": "Use String.split() function", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "With reflection, using Class#getEnumConstants() (quick and dirty demo)", "label": {"api": {"Class#getEnumConstants()": [[23, 46]]}}}, {"text": "I suggest that you can try to use ByteBuffer class from package NIO for example you can read the file as its original like this", "label": {"api": {"ByteBuffer": [[34, 43]]}}}, {"text": "Please refer to the Java API SimpleDateFormat (http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[47, 118]]}}}, {"text": "This is also the same reason there are different locks - read and write in ReadWriteLock", "label": {"api": {"ReadWriteLock": [[75, 87]]}}}, {"text": "A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing", "label": {"api": {"ReadWriteLock": [[2, 14]]}}}, {"text": "Use a Future and cancel it when necessary", "label": {"api": {"Future": [[6, 11]]}}}, {"text": "The return type of the Arrays.asList(...) function is a List<T>", "label": {"api": {"return type of the Arrays.asList(...) function": [[4, 49]]}}}, {"text": "Therefore you must not make any assumptions about the concrete type of the class used to implement the List interface", "label": {"api": {"List interface": [[103, 116]]}}}, {"text": "For that you can simply use something like the Deflater class", "label": {"api": {"the Deflater class": [[43, 60]]}}}, {"text": "Instead of using a Set<String> better use a Map<String,Integer> that stores the occurrence count for each word", "label": {"api": {"Map<String,Integer>": [[44, 62]]}}}, {"text": "You can use Map", "label": {"api": {"Map": [[12, 14]]}}}, {"text": "Tokenize the string and store it into a Map", "label": {"api": {"Map": [[40, 42]]}}}, {"text": "Instead of \"/\", use File.separator", "label": {"api": {"File.separator": [[20, 33]]}}}, {"text": "If this is not solving your issue, then use FileSystem.getSeparator()", "label": {"api": {"FileSystem.getSeparator()": [[44, 68]]}}}, {"text": "You can try to wrap your string with AtomicReference", "label": {"api": {"AtomicReference": [[37, 51]]}}}, {"text": "A better solution is to move your SocketConnectionThread code into SwingWorker", "label": {"api": {"SwingWorker": [[67, 77]]}}}, {"text": "Apart from the array index problem (see Stefan Beike's answer), you could you an ArrayList", "label": {"api": {"ArrayList": [[81, 89]]}}}, {"text": "Still if you want to keep primitive arrays, you could use System.arrayCopy to reallocate to a greater size array", "label": {"api": {"System.arrayCopy": [[58, 73]]}}}, {"text": "It sounds like you've just forgotten to implement hashCode", "label": {"api": {"hashCode": [[50, 57]]}}}, {"text": "Note that you don't really need to perform an ordering comparison in your equals method - you just need to check whether or not the names are equal", "label": {"api": {"equals": [[74, 79]]}}}, {"text": "Rather use Integer.compare(int, int) method", "label": {"api": {"Integer.compare(int, int)": [[11, 35]]}}}, {"text": "TreeSet doesn't use equals() to compare elements", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal", "label": {"api": {"TreeSet": [[2, 8]]}}}, {"text": "Threads execute tasks, so design your code around the idea of tasks that can create other tasks", "label": {"api": {"execute": [[8, 14]]}}}, {"text": "Tasks are simply Objects that implement the Runnable interface, nothing more", "label": {"api": {"Runnable": [[44, 51]]}}}, {"text": "Create one CachedThreadPool and whenever a task is ready to be executed, dump the task in the threadpool using the execute method", "label": {"api": {"CachedThreadPool": [[11, 26]], "execute": [[63, 69], [115, 121]]}}}, {"text": "You can simply call shutdownNow, but you'll probably want to device a technique that gives important tasks a chance to complete and then shutdown", "label": {"api": {"shutdownNow": [[20, 30]]}}}, {"text": "That will take some practice to get it right (shutdownHooks for example are not easy), but from then on you can re-use it whenever you need more than 1 thread", "label": {"api": {"shutdownHooks": [[46, 58]]}}}, {"text": "When you know the primary key value, please take a look at EntityManager#find (http://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html#find(java.lang.Class,java.lang.Object)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html#find(java.lang.Class,java.lang.Object)": [[79, 189]]}}}, {"text": "There's countless ways to implement that, but if you're running off of a .txt file and parsing it to a String, I would use String.split", "label": {"api": {"String.split": [[123, 134]]}}}, {"text": "I prefer Scanner, but there are plenty more", "label": {"api": {"Scanner": [[9, 15]]}}}, {"text": "JPA @GeneratedValue only works with primary key properties", "label": {"api": {"@GeneratedValue": [[4, 18]]}}}, {"text": "You could use String.replaceAll()", "label": {"api": {"String.replaceAll()": [[14, 32]]}}}, {"text": "Only if it's a regular expression (like you said in your question), you have to use String.replaceAll()", "label": {"api": {"String.replaceAll()": [[84, 102]]}}}, {"text": "Look at the ArrayList<E> documentation for more information on what methods are available to you", "label": {"api": {"ArrayList<E> documentation": [[12, 37]]}}}, {"text": "You are calling Scanner.next(), which \"Finds and returns the next complete token from this scanner\"", "label": {"api": {"Scanner.next()": [[16, 29]]}}}, {"text": "You want to call nextLine() instead, which takes a whole line of input", "label": {"api": {"nextLine()": [[17, 26]]}}}, {"text": "I recommend you to create a class to hold the data of each pair  and implements the Comparable interface to define the order criterion, then you can use the Arrays.sort() method", "label": {"api": {"Comparable": [[84, 93]]}}}, {"text": "I think that your problem is the default implementation of hashCode(), it may be based on the adress of the object", "label": {"api": {"may be based on the adress of the object": [[74, 113]]}}}, {"text": "Note that the await() method of CountDownLatch \"Causes the current thread to wait until the latch has counted down to zero.\" If that thread is the event dispatch thread, GUI updates will be blocked until the wait condition changes", "label": {"api": {"CountDownLatch": [[32, 45]]}}}, {"text": "In general, CountDownLatch is meant to allow separate threads to rendezvous; it should't be used to within the event dispatch thread", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "Check the javadocs for java.text.SimpleDateFormat It describes everything you need", "label": {"api": {"java.text.SimpleDateFormat": [[23, 48]]}}}, {"text": "You can use a regex expression and replaceAll() method from String", "label": {"api": {"replaceAll()": [[35, 46]]}}}, {"text": "For insert rows without transaction you can use @TranscactionAttribute with TransactionAttributeType.NOT_SUPPORTED", "label": {"api": {"TransactionAttributeType.NOT_SUPPORTED": [[76, 113]]}}}, {"text": "Refer to the constructor of the StringTokenizer class in Java", "label": {"api": {"StringTokenizer": [[32, 46]]}}}, {"text": "The Calendar class is intended to be used this way", "label": {"api": {"Calendar": [[4, 11]]}}}, {"text": "You need to look at CopyOnWriteArrayList<E>, its a concurrent implementation for ArrayList", "label": {"api": {"CopyOnWriteArrayList": [[20, 39]]}}}, {"text": "Read more about CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[16, 35]]}}}, {"text": "In this case, however, the @Before, @After, and @Test annotations can be trivially processed at runtime simply by invoking Class.getMethods() to retrieve the list of methods on the test class, and then using Method.getAnnotation() or Method.getDeclaredAnnotations() to inspect the annotations on the methods of that class to find the methods with those annotations", "label": {"api": {"Class.getMethods()": [[123, 140]], "Method.getAnnotation()": [[208, 229]], "Method.getDeclaredAnnotations()": [[234, 264]]}}}, {"text": "The toString method is intended, as the Java Language Specification specifies, to provide a string representation of the object", "label": {"api": {"Java Language Specification": [[40, 66]]}}}, {"text": "As such, the BasicDBObject returned is really just a simple wrapper around HashMap (With ordered keys and a certain view of serializing) ultimately and thus does not have the special properties associated with a DBCursor object", "label": {"api": {"HashMap": [[75, 81]]}}}, {"text": "With a class, you can use the (typed) class method getEnumConstants() (which returns null if the class isn't an enum class, but we've bound it to be an enum class)", "label": {"api": {"getEnumConstants()": [[51, 68]]}}}, {"text": "java.util.Map has a values() method just for this", "label": {"api": {"java.util.Map": [[0, 12]]}}}, {"text": "You can use the standard Java String pattern matching", "label": {"api": {"standard Java String pattern matching": [[16, 52]]}}}, {"text": "From the docs it is unclear if a @Singleton bean will be destroyed at some specific point", "label": {"api": {"From the docs": [[0, 12]]}}}, {"text": "The Java Math class describes what the min and max functions do in detail", "label": {"api": {"Math class": [[9, 18]]}}}, {"text": "Look into using a Timer", "label": {"api": {"Timer": [[18, 22]]}}}, {"text": "For example, the scheduleAtFixedRate() method", "label": {"api": {"scheduleAtFixedRate()": [[17, 37]]}}}, {"text": "Convert your list to an array to pass it in, using the toArray method", "label": {"api": {"toArray method": [[55, 68]]}}}, {"text": "For instance, Map.put(key,value) returns the previous value associated with the key", "label": {"api": {"Map.put(key,value)": [[14, 31]]}}}, {"text": "I'm writing a library that requires some of the functionality provided by the javax.imageio.ImageIO class", "label": {"api": {"javax.imageio.ImageIO": [[78, 98]]}}}, {"text": "I initially looked at java.util.ServiceLoader, which looked like it would do the job perfectly, but it appears that it is broken in android", "label": {"api": {"java.util.ServiceLoader": [[22, 44]]}}}, {"text": "Arrays are objects too, but they don't override Object's toString() method, which is responsible for the \"jumbled mess\"", "label": {"api": {"Object's toString()": [[48, 66]]}}}, {"text": "Explicitly convert the contents of the array to a String with Arrays.toString", "label": {"api": {"Arrays.toString": [[62, 76]]}}}, {"text": "You didn't indicate which version of java you are using but in 7 StringBuffer does have a replace method", "label": {"api": {"replace method": [[90, 103]]}}}, {"text": "You've tagged your question \"java\" so if you're using javax.xml.xpath you need to look up the setNamespaceContext method on XPath", "label": {"api": {"setNamespaceContext method on XPath": [[94, 128]]}}}, {"text": "JScrollPane(Component, int, int) with constants from ScrollPaneConstants", "label": {"api": {"JScrollPane(Component, int, int)": [[0, 31]], "ScrollPaneConstants": [[53, 71]]}}}, {"text": "Alternatively you can use String.intern() to obtain unique references from the pool of strings; those can be safely compared using the == operator", "label": {"api": {"String.intern()": [[26, 40]]}}}, {"text": "That's because you're printing the values of the static integer fields called HOUR, MINUTE, SECOND present in the Calendar class", "label": {"api": {"HOUR": [[78, 81]], "MINUTE": [[84, 89]], "SECOND": [[92, 97]]}}}, {"text": "You need to use the Calendar#get(field) method to get the HOUR, MINUTE, SECOND values from the Calendar", "label": {"api": {"HOUR": [[58, 61]], "MINUTE": [[64, 69]], "SECOND": [[72, 77]], "Calendar#get(field)": [[20, 38]]}}}, {"text": "Note that since HOUR, MINUTE, SECOND are static fields, you need to access them using the class name(Calendar.SECOND) and not using the instance(c.SECOND)", "label": {"api": {"HOUR": [[16, 19]], "MINUTE": [[22, 27]], "SECOND": [[30, 35], [110, 115], [147, 152]]}}}, {"text": "To perform tasks in background and updating UI elements in Swing application you can use SwingWorker class", "label": {"api": {"SwingWorker": [[89, 99]]}}}, {"text": "Why not throw just a single InvalidConfigurationException (I wouldn't use ParsingError - aside from anything else, I wouldn't expect this to be an Error subclass) which contains information about the specific problems", "label": {"api": {"Error": [[81, 85], [147, 151]]}}}, {"text": "In order to get it working, you can implement the java.lang.Iterable interface and override the Iterable#iterator() method in the ClassA, but then only one of the loops will be compiling, because the iteration will be applied only over the one of the lists", "label": {"api": {"java.lang.Iterable": [[50, 67]]}}}, {"text": "It should work if you use a Statement instead of a CallableStatement", "label": {"api": {"Statement": [[28, 36], [59, 67]], "CallableStatement": [[51, 67]]}}}, {"text": "You should use Statement for all DDL, PreparedStatement for DML and CallableStatement for procedure calls", "label": {"api": {"Statement": [[15, 23], [46, 54], [76, 84]], "CallableStatement": [[68, 84]]}}}, {"text": "A CallableStatement will try to detect and bind variables identified by a colon", "label": {"api": {"Statement": [[10, 18]], "CallableStatement": [[2, 18]]}}}, {"text": "To wrap the HttpServletResponse, you'll want to create a Filter that creates the HttpServletResponseWrapper and passes it down the chain instead of the original response passed to doFilter(..)", "label": {"api": {"Filter": [[57, 62], [182, 187]]}}}, {"text": "Instead, you could try to write the PDF to a ByteArrayOutputStream (for example) and later send that back to the web browser so you will be able to view the generated PDF", "label": {"api": {"ByteArrayOutputStream": [[45, 65]], "OutputStream": [[54, 65]]}}}, {"text": "A ByteArrayOutputStream behaves exactly the same as a FileOutputStream, except the bytes aren't written to a file, but to a byte[] (hence the name)", "label": {"api": {"ByteArrayOutputStream": [[2, 22]], "OutputStream": [[11, 22], [58, 69]]}}}, {"text": "Both of them extend the OutputStream interface, so they can be switched without further changes to your code", "label": {"api": {"OutputStream": [[24, 35]]}}}, {"text": "Streaming the response back to the browser isn't supported in GAE  so you could consider storing the contents of the ByteArrayOutputStream in the BlobStore in order to serve it back to the browser later on", "label": {"api": {"ByteArrayOutputStream": [[117, 137]], "OutputStream": [[126, 137]]}}}, {"text": "Look at the Pattern class to see how to regex text for hyperlinks", "label": {"api": {"Pattern": [[12, 18]]}}}, {"text": "In principle, all lambdas implementing the same raw interface could share a single runtime class just like MethodHandleProxies does", "label": {"api": {"MethodHandleProxies": [[107, 125]]}}}, {"text": "I believe this fails because of the underlying Java libraries that Signature class uses, since the Objective-C solution listed here appears to successfully verify the same credentials", "label": {"api": {"Signature class": [[67, 81]]}}}, {"text": "For each Id, you need a lightweight SerialExecutor like one described in JavaDocs of Executor", "label": {"api": {"JavaDocs of Executor": [[73, 92]]}}}, {"text": "Try with SimpleDateFormat to parse your String to a date", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "If I am understanding your use case correctly then I believe that I'd look into using an implementation of BlockingQueue for your message list", "label": {"api": {"BlockingQueue": [[107, 119]]}}}, {"text": "The DecimalFormat class can be used", "label": {"api": {"DecimalFormat": [[4, 16]]}}}, {"text": "One solution would be to use java.text.NumberFormat", "label": {"api": {"java.text.NumberFormat": [[29, 50]]}}}, {"text": "Use a java SimpleDateFormat like this", "label": {"api": {"SimpleDateFormat": [[11, 26]]}}}, {"text": "The malicious subclass's clone method can access its superclass's private members via the getDeclaredFields method - this returns all of the superclass's fields, even the ones that were declared private", "label": {"api": {"getDeclaredFields": [[90, 106]]}}}, {"text": "without mapping to a POJO), then you can just implement a basic MessageBodyReader, e.g", "label": {"api": {"MessageBodyReader": [[64, 80]]}}}, {"text": "Don't do that, use Arrays.sort()", "label": {"api": {"Arrays.sort()": [[19, 31]]}}}, {"text": "The API tells you why", "label": {"api": {"API": [[4, 6]]}}}, {"text": "I suggest looking at the Arrays and Collections classes for how to do this", "label": {"api": {"Collections": [[36, 46]]}}}, {"text": "It has defined methods like destroy ,getServletConfig() etc refer http://docs.oracle.com/javaee/6/api/javax/servlet/Servlet.html", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/Servlet.html": [[66, 127]]}}}, {"text": "Marker interface has no methods like Serializable Refer http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html and by the way there in no term defined by Java as Marker Interface", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html": [[56, 121]]}}}, {"text": "If you are on v6 or greater you can use DatatypeConverter", "label": {"api": {"DatatypeConverter": [[40, 56]]}}}, {"text": "Setting the field as accessible with AccessibleObject#setAccessible(boolean b) method (which is implemented in the Field class)", "label": {"api": {"AccessibleObject#setAccessible(boolean b)": [[37, 77]]}}}, {"text": "Fetching its value via the Field#get(Object obj) method", "label": {"api": {"Field#get(Object obj)": [[27, 47]]}}}, {"text": "a FileInputStream / FileOutputStream combination or - for not such a big file - use readAllBytes instead of the input stream", "label": {"api": {"readAllBytes": [[84, 95]]}}}, {"text": "It implements the Future interface", "label": {"api": {"Future": [[18, 23]]}}}, {"text": "You will probably find Arrays.copyOfRange() to be useful", "label": {"api": {"Arrays.copyOfRange()": [[23, 42]]}}}, {"text": "You can create an ArrayList to hold every line of every file, or create 3 differents array list for files", "label": {"api": {"ArrayList": [[18, 26]]}}}, {"text": "Then to add something in the ArrayList you should use add method", "label": {"api": {"ArrayList": [[29, 37]], "add": [[8, 10], [54, 56]]}}}, {"text": "By reading comments, i understand you want to use 3 differents ArrayList", "label": {"api": {"ArrayList": [[63, 71]]}}}, {"text": "The code is the same, just add 3 ArrayList", "label": {"api": {"ArrayList": [[33, 41]], "add": [[27, 29]]}}}, {"text": "I could only find half of an example in the MulticastChannel documentation", "label": {"api": {"MulticastChannel": [[44, 59]]}}}, {"text": "You could do it with the Scanner.nextLine() method to get full lines", "label": {"api": {"Scanner.nextLine()": [[25, 42]]}}}, {"text": "After that you have to split the numbers to get an array of them", "label": {"api": {"split": [[23, 27]]}}}, {"text": "Also consider using the Scanner.hasNextLine() method to proof, if there is another line in the stream", "label": {"api": {"Scanner.hasNextLine()": [[24, 44]]}}}, {"text": "The library can get the same values from keys using Key.getAlgorithm(), which will eliminate need for hardcoding and make library less security provider dependent", "label": {"api": {"Key.getAlgorithm()": [[52, 69]]}}}, {"text": "Try the replaceFirst method", "label": {"api": {"the replaceFirst method": [[4, 26]]}}}, {"text": "Try using replaceFirst() (available since Java 1.4), it does just what you need", "label": {"api": {"replaceFirst()": [[10, 23]]}}}, {"text": "For the first one, you need a FocusListener", "label": {"api": {"FocusListener": [[30, 42]]}}}, {"text": "For the second one, you need to add a DocumentListener to the document of the text field", "label": {"api": {"DocumentListener": [[38, 53]], "document": [[62, 69]]}}}, {"text": "It's typically solved by sharing a BlockingQueue among the producer threads and the consumer threads", "label": {"api": {"BlockingQueue": [[35, 47]]}}}, {"text": "List.isEmpty() is what you are looking for", "label": {"api": {"List.isEmpty()": [[0, 13]]}}}, {"text": "The signature of Object#equals is", "label": {"api": {"Object#equals": [[17, 29]]}}}, {"text": "For background processes you can use SwingWorker orExecutorService", "label": {"api": {"ExecutorService": [[51, 65]]}}}, {"text": "Now, at run-time, if x is not an instance of Y, then you got a ClassCastException", "label": {"api": {"ClassCastException": [[63, 80]]}}}, {"text": "See the Java regex reference for confirmation", "label": {"api": {"Java regex reference": [[8, 27]]}}}, {"text": "Use a Lock", "label": {"api": {"Lock": [[6, 9]]}}}, {"text": "You can use a Filter", "label": {"api": {"Filter": [[14, 19]]}}}, {"text": "I've had decent luck with HTTP Rewrite Filter", "label": {"api": {"Filter": [[39, 44]]}}}, {"text": "In the future, please read the documentation for the classes you're using; this is clearly explained in the Javadoc", "label": {"api": {"clearly explained in the Javadoc": [[83, 114]]}}}, {"text": "File Class provide function to get last modify date for that file", "label": {"api": {"File": [[0, 3]]}}}, {"text": "Here is JAVA Doc Reference", "label": {"api": {"JAVA Doc Reference": [[8, 25]]}}}, {"text": "For sorting file list based on File Name you may refer This Question", "label": {"api": {"File": [[31, 34]]}}}, {"text": "It will be the same type as the original object as long as it uses Object.clone() by calling super.clone() and that should be done by convention", "label": {"api": {"convention": [[134, 143]]}}}, {"text": "Read the doc here", "label": {"api": {"doc here": [[9, 16]]}}}, {"text": "This prints String but it is wrong by convention", "label": {"api": {"convention": [[38, 47]]}}}, {"text": "According to the API for the Vector class, you can use the iterator to go through your elements", "label": {"api": {"API for the Vector class": [[17, 40]]}}}, {"text": "Use Point2D.Double, which is exactly meant to store 2 doubles in a Point object", "label": {"api": {"Point2D.Double": [[4, 17]]}}}, {"text": "If you want to print out a Date as if it were a different timezone, you need to construct a DateFormat / SimpleDateFormat for that TimeZone and format it to a String that way", "label": {"api": {"format": [[144, 149]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/awt/geom/Area.html but still not sure how to get two Areas from one", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/geom/Area.html": [[0, 63]]}}}, {"text": "As another example of something similar, consider MouseAdapter", "label": {"api": {"MouseAdapter": [[50, 61]]}}}, {"text": "Instead, override getPreferredScrollableViewportSize() to return the desired size", "label": {"api": {"getPreferredScrollableViewportSize()": [[18, 53]]}}}, {"text": "If execution of javax.xml.parsers.DocumentBuilder.parse(File) takes a long time, may I obtain somehow the progress information from somewhere", "label": {"api": {"javax.xml.parsers.DocumentBuilder.parse(File)": [[16, 60]]}}}, {"text": "You can use one of Integer.valueOf(String) or Integer.parseInt(String); the difference is that parseInt will return an int primitive while valueOf will return an Integer", "label": {"api": {"Integer.valueOf(String)": [[19, 41]], "Integer.parseInt(String)": [[46, 69]]}}}, {"text": "Never-ever mix layout managers with setBounds()", "label": {"api": {"setBounds()": [[36, 46]]}}}, {"text": "Don't modify data structures while iterating over them - see http://docs.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html": [[61, 147]]}}}, {"text": "The Iterator will throw a ConcurrentModificationException if anything modifies the collection while it's iterating it, unless you call the iterator's own remove() method, which removes the current element", "label": {"api": {"iterator's own remove() method": [[139, 168]]}}}, {"text": "You can either create a copy of the data (Arrays.copyOf), e.g", "label": {"api": {"Arrays.copyOf": [[42, 54]]}}}, {"text": "Alternatively, if you store the data in a List (e.g", "label": {"api": {"List": [[42, 45]]}}}, {"text": "ArrayList) you can use the one-liner Collections.reverse()", "label": {"api": {"List": [[5, 8]], "ArrayList": [[0, 8]], "Collections.reverse()": [[37, 57]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html for information about creating Proxy objects that implement a given interface but can pass-through calls as desired", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html": [[4, 72]]}}}, {"text": "To use a Linked List, import java.util.LinkedList class in your program and use it like", "label": {"api": {"LinkedList": [[39, 48]]}}}, {"text": "Check out the LinkedList documentation", "label": {"api": {"LinkedList": [[14, 23]]}}}, {"text": "the StringBuffer class has .reverse() which reverses the character sequence", "label": {"api": {"StringBuffer": [[4, 15]], ".reverse()": [[27, 36]]}}}, {"text": "If you implement Iterable you will get the desired behavior", "label": {"api": {"Iterable": [[17, 24]]}}}, {"text": "I would also suggest to use a StringBuilder to assemble the output string", "label": {"api": {"StringBuilder": [[30, 42]]}}}, {"text": "Why don't you use String.indexOf()", "label": {"api": {"String.indexOf()": [[18, 33]]}}}, {"text": "I am using the Robot class and the createScreenCapture method to achieve this", "label": {"api": {"createScreenCapture": [[35, 53]]}}}, {"text": "Shouldn't the createScreenCapture method throw an exception because the permission is not granted", "label": {"api": {"createScreenCapture": [[14, 32]]}}}, {"text": "The Use of Multiple JFrames, Good/Bad Practice?", "label": {"api": {"JFrame": [[20, 25]]}}}, {"text": "You should have only one JFrame and use non-modal JDialog instead", "label": {"api": {"JFrame": [[25, 30]], "JDialog": [[50, 56]]}}}, {"text": "About your ActionListener implementation you can highly simplify your code by doing this", "label": {"api": {"ActionListener": [[11, 24]]}}}, {"text": "I resolved the issue by creating a new layout, based on a GridBagLayout instead of BorderLayout", "label": {"api": {"GridBagLayout": [[58, 70]]}}}, {"text": "In Java 8 there are no public, concrete classes implementing the interface Stream", "label": {"api": {"Stream": [[75, 80]]}}}, {"text": "One of the most important is StreamSupport.stream", "label": {"api": {"Stream": [[29, 34]], "StreamSupport.stream": [[29, 48]]}}}, {"text": "In particular, it is used in the default method Collection.stream –inherited by most collection classes", "label": {"api": {"Collection.stream": [[48, 64]]}}}, {"text": "The default implementation of this method creates a Spliterator by invoking spliterator(), and passes the created object to the factory method", "label": {"api": {"Spliterator": [[52, 62]]}}}, {"text": "Spliterator is a new interface introduced with Java 8 to support parallel streams", "label": {"api": {"Spliterator": [[0, 10]]}}}, {"text": "It is similar to Iterator, but in contrast to the latter, a Spliterator can be divided into parts, that can be processed independently", "label": {"api": {"Spliterator": [[60, 70]]}}}, {"text": "See Spliterator.trySplit for details", "label": {"api": {"Spliterator": [[4, 14]], "Spliterator.trySplit": [[4, 23]]}}}, {"text": "The default method Iterable.spliterator was also added in Java 8, so that every Iterable class automatically supports Spliterators", "label": {"api": {"Spliterator": [[118, 128]], "Iterable.spliterator": [[19, 38]]}}}, {"text": "The method creates the Spliterator from an arbitrary Iterator", "label": {"api": {"Spliterator": [[23, 33]]}}}, {"text": "If you combine these two steps, you can create a Stream from an arbitrary Iterator", "label": {"api": {"Stream": [[49, 54]]}}}, {"text": "To get an impression of Spliterators, here is a very simple example without using collections", "label": {"api": {"Spliterator": [[24, 34]]}}}, {"text": "The following class implements Spliterator to iterate over a half-open interval of integers", "label": {"api": {"Spliterator": [[31, 41]]}}}, {"text": "Just look at the join() method", "label": {"api": {"join()": [[17, 22]]}}}, {"text": "A possibly cleaner way would be to use an AtomicIntegerArray(10) and map between integers and booleans (0=false, 1=true)", "label": {"api": {"an AtomicIntegerArray(10)": [[39, 63]]}}}, {"text": "The JOptionPane.showInputDialog documentation states", "label": {"api": {"JOptionPane.showInputDialog": [[4, 30]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/lang/System.html for more details", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html": [[4, 65]]}}}, {"text": "So, when you pass it as the first argument of ImageIO.read(), it will throw an IllegalArgumentException, as said in ImageIO javadoc", "label": {"api": {"ImageIO javadoc": [[116, 130]]}}}, {"text": "According to the Class javadoc, getResourceAsStream() returns null when it can't find the ressource", "label": {"api": {"Class javadoc": [[17, 29]]}}}, {"text": "Also there is this online api documentation (Online Java EE API Docs) but sometimes its a bit tedious for checking it everytime, is there a way that i can integrate it somehow in my netbeans", "label": {"api": {"Online Java EE API Docs": [[45, 67]]}}}, {"text": "From the doc", "label": {"api": {"the doc": [[5, 11]]}}}, {"text": "The BitSet.length() method returns the index of the highest bit set, it does not return the total size", "label": {"api": {"BitSet.length()": [[4, 18]]}}}, {"text": "Use InputStream.available() to test whether data is available in the stream before reading the next dog", "label": {"api": {"InputStream.available()": [[4, 26]]}}}, {"text": "If you need to check, if the list contains an array with specific values, you will have to iterate over the list and use Arrays.equals(arr1, arr2)", "label": {"api": {"Arrays.equals(arr1, arr2)": [[121, 145]]}}}, {"text": "BigInteger has a toString() method, which gives a decimal string representation of the value", "label": {"api": {"toString()": [[17, 26]]}}}, {"text": "Try checking out the String.format() method", "label": {"api": {"String.format()": [[21, 35]]}}}, {"text": "Using correct format string you can do all of what you need in one line", "label": {"api": {"format string": [[14, 26]]}}}, {"text": "Take a look at Arrays.fill and all of its variants", "label": {"api": {"Arrays.fill": [[15, 25]]}}}, {"text": "new TypeToken<Multiset<String>>(){}.getType() in your case) to ParameterizedType to get at the type arguments (String in your example)", "label": {"api": {"ParameterizedType": [[63, 79]]}}}, {"text": "It then creates a new ParameterizedType which is the type of an ArrayList with the same type arguments (shown below)", "label": {"api": {"ParameterizedType": [[22, 38]]}}}, {"text": "The ListParameterizedType looks like this", "label": {"api": {"ParameterizedType": [[8, 24]]}}}, {"text": "You can use the length() method of String", "label": {"api": {"length()": [[16, 23]]}}}, {"text": "public int length()", "label": {"api": {"length()": [[11, 18]]}}}, {"text": "You have to use the instance method size() instead of length at the lines where you return", "label": {"api": {"size()": [[36, 41]]}}}, {"text": "If you need a dynamic array with variable number of elements, I would suggest looking into ArrayList class", "label": {"api": {"ArrayList": [[91, 99]]}}}, {"text": "PathIterator defines different types of segments, you should pay attention to this fact", "label": {"api": {"PathIterator": [[0, 11]]}}}, {"text": "The javadoc of ExecutorService states", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "Actions in a thread prior to the submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the result is retrieved via Future.get()", "label": {"api": {"ExecutorService": [[81, 95]]}}}, {"text": "So with JDBC you would do something like this", "label": {"api": {"JDBC": [[8, 11]]}}}, {"text": "You can use System.exit(...) to exit and a plain old Java Timer to schedule it for 10 seconds in the future", "label": {"api": {"System.exit(...)": [[12, 27]], "Timer": [[58, 62]]}}}, {"text": "Using System.exit() to exit the application can cause a lot of problems", "label": {"api": {"System.exit()": [[6, 18]]}}}, {"text": "Use Platform.exit() instead for nice and clean exit", "label": {"api": {"Platform.exit()": [[4, 18]]}}}, {"text": "You should use  Platform.exit() to exit JavaFX application, and a plain old Java Timer to schedule it for 10 seconds in the future", "label": {"api": {"Platform.exit()": [[16, 30]], "Timer": [[81, 85]]}}}, {"text": "The advantage of Platform.exit() over System.exit() is that it fires Application.stop() method before exiting where you can destroy resources properly", "label": {"api": {"System.exit()": [[38, 50]], "Platform.exit()": [[17, 31]], "Application.stop()": [[69, 86]]}}}, {"text": "At constructor invocation time injection hasn't occurred yet, keep in mind that the object is just being created so the container hasn't had time to inject anything, the proper way to do this is by using the @PostConstruct annotation", "label": {"api": {"@PostConstruct": [[208, 221]]}}}, {"text": "so you need to move the getCategories() invocation to a @PostConstruct annotated method, like this", "label": {"api": {"@PostConstruct": [[56, 69]]}}}, {"text": "You can read more about set() at http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#set(int, E)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#set(int": [[33, 105]]}}}, {"text": "You must place file.txt in the user.dir as specified by the File documentation", "label": {"api": {"File": [[60, 63]]}}}, {"text": "This is pretty easy to do using String.split", "label": {"api": {"String.split": [[32, 43]]}}}, {"text": "If you want to use your data structure with a for-each loop, you have to implement the interface Iterable (and implement an underlying iterator)", "label": {"api": {"Iterable": [[97, 104]]}}}, {"text": "As said in the String javadoc", "label": {"api": {"String javadoc": [[15, 28]]}}}, {"text": "This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero", "label": {"api": {"two-argument split method": [[40, 64]]}}}, {"text": "use the two-argument split method with a negative limit", "label": {"api": {"two-argument split method": [[8, 32]]}}}, {"text": "Create a temporary file using something like createTempFile(String prefix, String suffix), which will allow to you to write the image out and then read it back it when you need it..", "label": {"api": {"createTempFile(String prefix, String suffix)": [[45, 88]]}}}, {"text": "Collections#copy() is a utility method, that is intended to work for any List", "label": {"api": {"Collections#copy()": [[0, 17]]}}}, {"text": "A Future represents the result of an asynchronous computation and enables you to access the result of that computation when it's done (possibly in the future if the computation takes some time, hence the name)", "label": {"api": {"Future": [[2, 7]]}}}, {"text": "A Fork/Join pool is a form of ExecutorService (task execution system) that executes its tasks using multiple threads and uses a work stealing algorithm", "label": {"api": {"Fork/Join pool": [[2, 15]]}}}, {"text": "The result of a fork/join task is a Future", "label": {"api": {"Future": [[36, 41]]}}}, {"text": "You can utilize SimpleDateFormat for your purpose instead of manipulating your String", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "That can be done using the clearing rule of AlphaComposite", "label": {"api": {"AlphaComposite": [[44, 57]]}}}, {"text": "In that case you will need something like a fair lock which comes at a price", "label": {"api": {"fair lock": [[44, 52]]}}}, {"text": "using a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[8, 24]]}}}, {"text": "Use getListDataListeners() to get the listeners and transfer them to the new model", "label": {"api": {"getListDataListeners()": [[4, 25]]}}}, {"text": "Use removeAllElements() and recycle the existing model", "label": {"api": {"removeAllElements()": [[4, 22]]}}}, {"text": "Text doesn't implement equals() and hashCode() according to the contract", "label": {"api": {"according to the contract": [[47, 71]]}}}, {"text": "Adapted example from the Proxy javadoc", "label": {"api": {"Proxy javadoc": [[25, 37]]}}}, {"text": "You'll need a custom ProgressBarUI, perhaps derived from BasicProgressBarUI illustrated here", "label": {"api": {"BasicProgressBarUI": [[57, 74]]}}}, {"text": "Reading the javadocs for WatchEvent, I see that the count() method lets me know if an event is repeated by its result", "label": {"api": {"count()": [[52, 58]]}}}, {"text": "I am experimenting with the example on Oracle's site for the new WatchService API and this part confused me, especially because I will get a different number of events for successive runs of the same test code (in which I write to a file using a FileWriter without interacting with it manually), but the result of count() is never more than 1", "label": {"api": {"count()": [[314, 320]]}}}, {"text": "There are four types of events defined in StandardWatchEventKinds, but the OVERFLOW event indicates that events may have been lost, so I omitted it from the above number", "label": {"api": {"StandardWatchEventKinds": [[42, 64]]}}}, {"text": "You saw the results of the toString() method on the Object class, and you haven't overridden it in ArrivalDetails", "label": {"api": {"toString() method on the Object class": [[27, 63]]}}}, {"text": "You cannot remove it and keep the other two, however, you can disable it using setDefaultCloseOperation", "label": {"api": {"setDefaultCloseOperation": [[79, 102]]}}}, {"text": "For an undecorated frame you'd have to use JWindow instead of JFrame, then render your own title bar", "label": {"api": {"JWindow": [[43, 49]]}}}, {"text": "Note that ToolTipManager already registers VK_ESCAPE to hide tooltips and in normal cases escape works as expected", "label": {"api": {"ToolTipManager": [[10, 23]]}}}, {"text": "Note, however, that com.sun.tools.javac.main.JavaCompiler does not implement the javax.tools.JavaCompiler interface, and its API is therefore unavailable using this technique", "label": {"api": {"javax.tools.JavaCompiler": [[81, 104]]}}}, {"text": "From the Javadocs for the compareTo method in Comparable", "label": {"api": {"the Javadocs for the compareTo method in Comparable": [[5, 55]]}}}, {"text": "If the values are going to change, you should look into using an ArrayList which will be dynamic and vary with the length of your data", "label": {"api": {"ArrayList": [[65, 73]]}}}, {"text": "For instance, you could easily convert all that data to an ArrayList like this", "label": {"api": {"ArrayList": [[59, 67]]}}}, {"text": "Java has a URL class but it seems extremely limited - they query string is treated as a String, not a Map, and the only way to modify it is to call set and specify all the components of the URL instead of just setting the component I want to set", "label": {"api": {"URL class": [[11, 19]], "set": [[148, 150], [210, 212], [242, 244]]}}}, {"text": "There are a couple of easy ways to copy an array, namely System#arraycopy, Arrays#copyOf and clone", "label": {"api": {"System#arraycopy": [[57, 72]], "Arrays#copyOf": [[75, 87]], "clone": [[93, 97]]}}}, {"text": "(All arrays are cloneable.) For the 2D array you might want to make a helper method since you'd probably need to make a deep copy", "label": {"api": {"clone": [[16, 20]]}}}, {"text": "If you want to get the long data from the jTextField2 which is an object of JTextField, then you can do something like this", "label": {"api": {"JTextField": [[76, 85]]}}}, {"text": "You should have your TreeModel implement Serializable and you can then use simple Java to convert to XML and read it back fairly simply", "label": {"api": {"TreeModel": [[21, 29]], "Serializable": [[41, 52]], "convert to XML": [[90, 103]], "read it back": [[109, 120]]}}}, {"text": "Do note that you don't necessarily need to implement Serializable to use XStream -- it doesn't care", "label": {"api": {"Serializable": [[53, 64]]}}}, {"text": "The use of instanceof may be avoided by using Class#isAssignableFrom() instead", "label": {"api": {"Class#isAssignableFrom()": [[46, 69]]}}}, {"text": "For adding to Ivaylo answer, you can also store it in a StringBuilder and reverse it using reverse method", "label": {"api": {"reverse": [[74, 80], [91, 97]]}}}, {"text": ".length() property to get the amount of characters in a given String", "label": {"api": {".length()": [[0, 8]]}}}, {"text": ".isLetter(Char ch) to check if a character within a string is a letter", "label": {"api": {".isLetter(Char ch)": [[0, 17]]}}}, {"text": ".isUpperCase(Char ch) to check if a character is upper case", "label": {"api": {".isUpperCase(Char ch)": [[0, 20]]}}}, {"text": "See Statement.getGeneratedKeys() for obtaining generated id if required", "label": {"api": {"Statement.getGeneratedKeys()": [[4, 31]]}}}, {"text": "You can use the .split(String regex) to split the line you are reading by throwing in the # as a delimeter", "label": {"api": {".split(String regex)": [[16, 35]]}}}, {"text": "To replace one fixed string with another you should use the replace method that takes two CharSequence parameters instead - despite its name, this method does in fact replace all occurrences of the first CharSequence with the second one", "label": {"api": {"replace method that takes two CharSequence parameters": [[60, 112]]}}}, {"text": "If you use a concurrent queue like the LinkedBlockingQueue your problem should be solved", "label": {"api": {"LinkedBlockingQueue": [[39, 57]]}}}, {"text": "Also have a look into the ExecutorService class, which simplifies threading with Runnables a lot", "label": {"api": {"ExecutorService": [[26, 40]]}}}, {"text": "You can use an InputVerifier to verify the input of the table cell", "label": {"api": {"InputVerifier": [[15, 27]]}}}, {"text": "With the InputVerifier You will get validation per cell input", "label": {"api": {"InputVerifier": [[9, 21]]}}}, {"text": "With this particular InputVerifier, if the field it matches the regex oor if the field is empty, it will allow focus change, if not you will get an error dialog", "label": {"api": {"InputVerifier": [[21, 33]]}}}, {"text": "Unsure what the question is but the | character in the split() requires escaping (the argument to split() is a regular expression and not a plain string)", "label": {"api": {"split()": [[55, 61], [98, 104]]}}}, {"text": "Note that if you don't want to display the id in the list (or maybe display it in a non-standard way), you'd either have to override the element's toString() method or provide a custom ListCellRenderer", "label": {"api": {"ListCellRenderer": [[185, 200]]}}}, {"text": "I think the solution for you would be to implement CharSequence as a wrapper over very large text files", "label": {"api": {"CharSequence": [[51, 62]]}}}, {"text": "Because building a Matcher from a Pattern takes a CharSequence as an argument", "label": {"api": {"CharSequence": [[50, 61]]}}}, {"text": "A ClassLoader will only run static initializers once per class (as the class is loaded into memory)", "label": {"api": {"ClassLoader": [[2, 12]]}}}, {"text": "Since the XmlRootElement is not inherited, the subclass that is created by cglib will not longer carry this annotation", "label": {"api": {"XmlRootElement": [[10, 23]]}}}, {"text": "You could have an ArrayBlockingQueue to hold your URI's, and have it safely shared across Threads in a pool to execute", "label": {"api": {"ArrayBlockingQueue": [[18, 35]], "execute": [[111, 117]]}}}, {"text": "You're not using the FileOutputStream class correctly", "label": {"api": {"FileOutputStream": [[21, 36]]}}}, {"text": "If you want to write that number inside a file using FileOutputStream, you can read that file (using, for example, a FileInputStream), read the amount of bytes you want to read and write them into the output stream, then write that number using something akin to", "label": {"api": {"FileOutputStream": [[53, 68]], "FileInputStream": [[117, 131]]}}}, {"text": "If you want to get fancy, you can reroute System.Out to your own PrintStream using System.setOut(PrintStream out)", "label": {"api": {"PrintStream": [[65, 75], [97, 107]], "System.setOut(PrintStream out)": [[83, 112]]}}}, {"text": "At that point you can read that PrintStream using a InputStreamReader", "label": {"api": {"PrintStream": [[32, 42]], "InputStreamReader": [[52, 68]]}}}, {"text": "That InputStreamReader can then populate your GUI", "label": {"api": {"InputStreamReader": [[5, 21]]}}}, {"text": "But keep in mind, if you reroute System.Out, all methods using System.Out will use the new PrintStream", "label": {"api": {"PrintStream": [[91, 101]]}}}, {"text": "This concerns anything implementing Closeable", "label": {"api": {"Closeable": [[36, 44]]}}}, {"text": "Whether a Closeable holds system resources or not, the rule of thumb is", "label": {"api": {"Closeable": [[10, 18]]}}}, {"text": "Typical idiom (note that InputStream implements Closeable)", "label": {"api": {"Closeable": [[48, 56]]}}}, {"text": "With Java 7 you also have AutoCloseable (which Closeable implements) and the try-with-resources statement, so do", "label": {"api": {"Closeable": [[30, 38], [47, 55]]}}}, {"text": "First, note the substring documentation", "label": {"api": {"substring documentation": [[16, 38]]}}}, {"text": "Example using DocumentBuilder (fragment must be valid XHTML)", "label": {"api": {"DocumentBuilder": [[14, 28]]}}}, {"text": "To enable single cell selection, use setCellSelectionEnabled(true), which \"treats the intersection of the row and column selection models as the selected cells.\" See also this related answer", "label": {"api": {"setCellSelectionEnabled(true)": [[37, 65]]}}}, {"text": "I'm reading the getSystemClipboard() function found in http://docs.oracle.com/javase/7/docs/api/, under clipboard", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/": [[55, 95]]}}}, {"text": "If you're interested, java's TreeSet.subSet has a very similar problem, in which any additions outside the range of the specified subSet will not show up", "label": {"api": {"TreeSet.subSet": [[29, 42]]}}}, {"text": "Use ArrayList#get(int index)", "label": {"api": {"ArrayList#get(int index)": [[4, 27]]}}}, {"text": "If you just want to write an XML document having exact control over the creating of elements, attributes and other document components, you may use the XMLStreamWriter from the StAX API", "label": {"api": {"XMLStreamWriter": [[152, 166]]}}}, {"text": "You can use split() method", "label": {"api": {"split()": [[12, 18]]}}}, {"text": "Consult the Thread documentation as it provides examples on the two ways to create and start threads", "label": {"api": {"Thread": [[12, 17]]}}}, {"text": "From a design perspective, prefer the approach involving implementing Runnable", "label": {"api": {"Runnable": [[70, 77]]}}}, {"text": "To get started, have your AEStest class implement Runnable instead of extending Thread", "label": {"api": {"Thread": [[80, 85]], "Runnable": [[50, 57]]}}}, {"text": "However, Comparable itself has a type parameter, usually to itself", "label": {"api": {"Comparable itself has a type parameter": [[9, 46]]}}}, {"text": "This follows existing patterns in standard Java, such as Collections.sort, which defines T similarly", "label": {"api": {"Collections.sort": [[57, 72]]}}}, {"text": "You need to annotate your id field with @GeneratedValue, in order for JPA to know that the DB will generate the id automatically", "label": {"api": {"@GeneratedValue": [[40, 54]]}}}, {"text": "Get the file as a BufferedReader (http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html), by doing something like BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(fileName)))", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html": [[34, 101]]}}}, {"text": "SortedSet extends Collection which defines the method toArray", "label": {"api": {"toArray": [[54, 60]]}}}, {"text": "An alternative to making it thread-safe is to replace the int with an AtomicInteger, which has its own atomic getAndIncrement method", "label": {"api": {"getAndIncrement": [[110, 124]]}}}, {"text": "As others have noted, using the StringBuilder.setCharAt() method produces a more concise answer (with the ternary operator added, this is the shortest answer so far)", "label": {"api": {"StringBuilder.setCharAt()": [[32, 56]]}}}, {"text": "You can use the split method in String if you want to cleanly break the two parts", "label": {"api": {"split method in String": [[16, 37]]}}}, {"text": "The methods do a rounding according to the mode specified in the MathContext", "label": {"api": {"mode": [[43, 46]]}}}, {"text": "You may try like this using  Arrays#Sort(T[] a, Comparator c)", "label": {"api": {"Arrays#Sort(T[] a, Comparator c)": [[29, 60]]}}}, {"text": "Per the Javadoc of the parse method", "label": {"api": {"the Javadoc of the parse method": [[4, 34]]}}}, {"text": "If you wish to validate that it consumed the whole string, I suppose you could set up a ParsePosition object and use the two-arg overload, and then examine the ParsePosition afterward to see if it parsed to the end of the string", "label": {"api": {"use the two-arg overload": [[113, 136]]}}}, {"text": "Then you can create this instance in a Filter and put it in the request and configure it correctly", "label": {"api": {"Filter": [[39, 44]]}}}, {"text": "When the ExpressionFactory creates a ValueExpression it parses the expression and uses the VariableMapper to bind any expressions resolved from there", "label": {"api": {"ExpressionFactory": [[9, 25]], "ValueExpression": [[37, 51]], "VariableMapper": [[91, 104]]}}}, {"text": "Note that this is different to what happens when resolving variables from an ELResolver", "label": {"api": {"ELResolver": [[77, 86]]}}}, {"text": "As per http://docs.oracle.com/javaee/5/api/javax/persistence/OrderBy.html, OrderBy only orders the QuestionEntity instances at the point the association is retrieved", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/persistence/OrderBy.html": [[7, 72]]}}}, {"text": "Most likely, a semaphore will do the job for you, because with semaphores, the order of acquiring and releasing the locking mechanism doesn't matter", "label": {"api": {"semaphore": [[15, 23], [63, 71]]}}}, {"text": "with a semaphore, you can release before acquiring", "label": {"api": {"semaphore": [[7, 15]]}}}, {"text": "Since Java 8 new StringJoiner class has been introduced", "label": {"api": {"StringJoiner": [[17, 28]]}}}, {"text": "For more information please read StringJoiner", "label": {"api": {"StringJoiner": [[33, 44]]}}}, {"text": "Use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "I want to use Java 7 WatchService to monitor /proc folder, but that's not working (changes made in the folder are not reported)", "label": {"api": {"Java 7 WatchService": [[14, 32]]}}}, {"text": "Using the new JPA 2.1 stored procedure call, is there any way to pass a null parameter", "label": {"api": {"stored procedure": [[22, 37]]}}}, {"text": "A regular expression is the easier way, but probably on big files, the more efficient way in Java is going with a binary search, that is reading byte-per-byte with a RandomAccessFile - http://docs.oracle.com/javase/6/docs/api/java/io/RandomAccessFile.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/RandomAccessFile.html": [[185, 254]]}}}, {"text": "You would need Class#isInstance(Object) method, and also Class#cast(Object) method", "label": {"api": {"Class#isInstance(Object)": [[15, 38]], "Class#cast(Object)": [[57, 74]]}}}, {"text": "You don't need your own drawArc method, you should be calling the Graphics.drawArc() method", "label": {"api": {"Graphics.drawArc()": [[66, 83]]}}}, {"text": "You can use Map<Integer, Marker> (Integer are keys and Marker are values)", "label": {"api": {"Map<Integer, Marker>": [[12, 31]]}}}, {"text": "I implemented something similar using a PriorityBlockingQueue and CountDownLatches", "label": {"api": {"PriorityBlockingQueue": [[40, 60]], "CountDownLatches": [[66, 81]]}}}, {"text": "Then you can use a single PriorityBlockingQueue to manage threads, which are waiting for more characters", "label": {"api": {"PriorityBlockingQueue": [[26, 46]]}}}, {"text": "You can use the built-in binary search method", "label": {"api": {"built-in binary search method": [[16, 44]]}}}, {"text": "Why not just use the Arrays Class", "label": {"api": {"Arrays Class": [[21, 32]]}}}, {"text": "Now just apply Arrays.sort, sit back, and enjoy the movies", "label": {"api": {"Arrays.sort": [[15, 25]]}}}, {"text": "You can use the Collections class", "label": {"api": {"Collections": [[16, 26]]}}}, {"text": "You can look here (http://docs.oracle.com/javase/6/docs/api/java/lang/String.html) if it doesn't work", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[19, 80]]}}}, {"text": "Have a look at the java.lang.instrumentation API", "label": {"api": {"java.lang.instrumentation API": [[19, 47]]}}}, {"text": "You can do this using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[22, 37]]}}}, {"text": "Use String.split() with a regex \\\\s+ (or \\n+ for example, depending on what you exactly want)", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "This shou;d be done with simple iteration and  a StringBuilder", "label": {"api": {"StringBuilder": [[49, 61]]}}}, {"text": "Class#newInstance() returns an instance of type T, which is the class' generic type", "label": {"api": {"Class#newInstance()": [[0, 18]]}}}, {"text": "Use CharsetDecoder which has error handling", "label": {"api": {"CharsetDecoder": [[4, 17]]}}}, {"text": "Outside the thread, you can signal that the thread should prepare to shutdown by using the Thread.interrupt() method", "label": {"api": {"Thread.interrupt()": [[91, 108]]}}}, {"text": "Inside the thread, you should check Thread.interrupted() to test for interruption (and break from the loop if that is the case)", "label": {"api": {"Thread.interrupted()": [[36, 55]]}}}, {"text": "You should also modify your exception handler; the interrupted exception is thrown when Thread.interrupt() was called while the thread was sleeping, so you should modify the content of that handler to break from the loop", "label": {"api": {"Thread.interrupt()": [[88, 105]]}}}, {"text": "When you want the thread to pause, use queue.poll(long, TimeUnit) instead of wait", "label": {"api": {"queue.poll(long, TimeUnit)": [[39, 64]]}}}, {"text": "As long as it's in the same ThreadGroup, you can iterate through all the threads using Thread.enumerate() and find the given thread by it's id and do the usual synchronize and .notify()", "label": {"api": {"Thread.enumerate()": [[87, 104]]}}}, {"text": "You forgot to add your JRadioButtons to the ButtonGroup", "label": {"api": {"add": [[14, 16]]}}}, {"text": "You can by the way use a Filter (Interceptors are based on that technology), handling the thread-safety in the Servlets by yourself", "label": {"api": {"Filter": [[25, 30]]}}}, {"text": "As I indicated in the comments, the AffineTransform (http://docs.oracle.com/javase/7/docs/api/java/awt/geom/AffineTransform.html) is everything that you need", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/geom/AffineTransform.html": [[53, 127]]}}}, {"text": "I have sometimes thrown UnsupportedOperationException from a method whose functionality has not yet been implemented", "label": {"api": {"UnsupportedOperationException": [[24, 52]]}}}, {"text": "(There is also a NotImplementedException in Apache Commons which is a subclass of UnsupportedOperationException.) This was always meant as a placeholder and a message to others using the related class or service that the method is not yet complete", "label": {"api": {"UnsupportedOperationException": [[82, 110]]}}}, {"text": "As mentioned in the comments by @obicere you are better off using ArrayList or List", "label": {"api": {"ArrayList": [[66, 74]], "List": [[71, 74], [79, 82]]}}}, {"text": "Yes you can get the Class type of the actual object, using Object#getClass() method", "label": {"api": {"Object#getClass()": [[59, 75]]}}}, {"text": "The DataQueue read() method supports InterruptedException", "label": {"api": {"InterruptedException": [[37, 56]]}}}, {"text": "This service internally uses a ThreadLocal, which is a thread scoped holder for a variable of type PetitionContext", "label": {"api": {"ThreadLocal": [[31, 41]]}}}, {"text": "What you need is a Map", "label": {"api": {"Map": [[19, 21]]}}}, {"text": "Check out the add() method in the java.util.List interface", "label": {"api": {"java.util.List": [[34, 47]]}}}, {"text": "I suggest using a DataOutputStream/DataInputStream which provide methods for charset-safe String transmissions", "label": {"api": {"DataOutputStream": [[18, 33]], "DataInputStream": [[35, 49]]}}}, {"text": "Make absolutely sure you have imported org.openqa.selenium.NoSuchElementException and NOT java.util.NoSuchElementException", "label": {"api": {"java.util.NoSuchElementException": [[90, 121]]}}}, {"text": "The no-op finalize() methods shouldn't cause this problem but they may well exacerbate it", "label": {"api": {"finalize()": [[10, 19]]}}}, {"text": "The doc on finalize() reveals that having a finalize() method forces the GC to twice determine that the instance is unreferenced (before and after calling finalize())", "label": {"api": {"finalize()": [[11, 20], [44, 53], [155, 164]]}}}, {"text": "So once you can reproduce the problem, try deleting those no-op finalize() methods and see if the problem takes longer to reproduce", "label": {"api": {"finalize()": [[64, 73]]}}}, {"text": "It inefficiently reverses the string by placing each successive sub-string on the stack until it reaches a length less then 2; it then reverses the characters by popping those results off the stack and appending the first character to the sub-string", "label": {"api": {"reverse": [[17, 23], [135, 141]]}}}, {"text": "It is inefficient because Java includes the StringBuilder class and that has a reverse method", "label": {"api": {"reverse": [[79, 85]]}}}, {"text": "First you should have a look at the File class", "label": {"api": {"File": [[36, 39]]}}}, {"text": "To read files you also might want to give BufferedReader or any other Reader a shot", "label": {"api": {"BufferedReader": [[42, 55]]}}}, {"text": "File has the method createNewFile(), use it in combination with exists()", "label": {"api": {"File": [[0, 3], [29, 32]], "createNewFile()": [[20, 34]]}}}, {"text": "To save a file you should check out the FileWriter, it can write strings or append them to files", "label": {"api": {"File": [[40, 43]], "FileWriter": [[40, 49]]}}}, {"text": "For your editor you might want to replace the before mentioned BufferedReader with a LineReader, which also provides methods to get the line number", "label": {"api": {"BufferedReader": [[63, 76]]}}}, {"text": "Your starting point should be the Class class, which provides methods to retrieve the Fields, Methods, and Constructor's of a class", "label": {"api": {"Class": [[34, 38]]}}}, {"text": "Gson uses the Class object you provide, Participant.class, to find out all the fields it needs to populate", "label": {"api": {"Class": [[14, 18]]}}}, {"text": "Consider using something dynamic, like an ArrayList<JRadioButton> instead", "label": {"api": {"ArrayList<JRadioButton>": [[42, 64]]}}}, {"text": "Specifically, the checkRead method can be used to validate if a program is permitted to read from a given path, which covers not just FileInputStream.read() but any other means of reading files in Java", "label": {"api": {"checkRead": [[18, 26]]}}}, {"text": "Check out GraphicsEnvironment.getScreenDevices(), you can get the screen bounding rectangles from each device, e.g.", "label": {"api": {"GraphicsEnvironment.getScreenDevices()": [[10, 47]]}}}, {"text": "There's a lot of other info you can get from a GraphicsDevice which might be useful", "label": {"api": {"GraphicsDevice": [[47, 60]]}}}, {"text": "I'm curious, then, why it doesn't implement Map<Integer, Integer>", "label": {"api": {"Map<Integer, Integer>": [[44, 64]]}}}, {"text": "certainly nothing that an EnumMap doesn't handle with grace", "label": {"api": {"EnumMap": [[26, 32]]}}}, {"text": "If you mean the  FileNotFoundException, the documentation shows it does not extend RuntimeException, so it is a checked exception", "label": {"api": {"FileNotFoundException": [[17, 37]]}}}, {"text": "Since the elements of the list are Strings and since String implements Comparable, sorting a list is as simple as", "label": {"api": {"Comparable": [[71, 80]]}}}, {"text": "A simple solution is to use an ArrayList, then only add the \"approved\" elements", "label": {"api": {"ArrayList": [[31, 39]]}}}, {"text": "Because a List/ArrayList grows on demand, there are no trailing null (unassigned) elements as might be found in a fixed-size array", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "As per ResultSetMetaData documentation", "label": {"api": {"ResultSetMetaData": [[7, 23]]}}}, {"text": "If you care about decimal digits, then BigDecimal is a more suitable type for you", "label": {"api": {"BigDecimal": [[39, 48]]}}}, {"text": "BigDecimal does retain the number of decimal digits you use, but you'll need to be careful about exactly how you use it", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "You'll no doubt find the setScale method useful", "label": {"api": {"setScale": [[25, 32]]}}}, {"text": "You're trying to set date's boundaries to a java.util.Calendar object which is not possible", "label": {"api": {"java.util.Calendar": [[44, 61]]}}}, {"text": "If the behaviour will be the same for a set of components (for instance radio buttons or check boxes) then it makes sense have only one listener and use EventObject.getSource() to work with the event's source", "label": {"api": {"EventObject.getSource()": [[153, 175]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/applet/package-summary.html for example", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/applet/package-summary.html": [[4, 76]]}}}, {"text": "In the JDK, you have SimpleDateFormat to handle this kind of stuff", "label": {"api": {"SimpleDateFormat": [[21, 36]]}}}, {"text": "It will throw a ParseException if the date is invalid", "label": {"api": {"ParseException": [[16, 29]]}}}, {"text": "and http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/Document.html#importNode(org.w3c.dom.Node,%20boolean) for more detail", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/Document.html#importNode(org.w3c.dom.Node,%20boolean)": [[4, 109]]}}}, {"text": "Try Document.adoptNode to change the owner document to the target document", "label": {"api": {"Document.adoptNode": [[4, 21]]}}}, {"text": "Use Document.importNode to create a copy of the node adapted to the target document/DOM implementation", "label": {"api": {"Document.importNode": [[4, 22]]}}}, {"text": "What i need is a tool/class that acts like CoundDownLatch but can be counted up and down", "label": {"api": {"CoundDownLatch": [[43, 56]]}}}, {"text": "I looked into the Phaser class, but i don't know if it provides what i am looking for, maybe it can be used to solve this puzzle", "label": {"api": {"Phaser": [[18, 23]]}}}, {"text": "You should use an ExecutorService as discussed in How to wait for all threads to finish, using ExecutorService?", "label": {"api": {"ExecutorService": [[18, 32], [95, 109]]}}}, {"text": "Put them all into HashSet instead of list and check the return value of add() method", "label": {"api": {"add()": [[72, 76]]}}}, {"text": "You need to implement Comparable", "label": {"api": {"Comparable": [[22, 31]]}}}, {"text": "By implementing Comparable, you are then able to use Arrays.sort() to sort your array once it is populated with GEN objects", "label": {"api": {"Comparable": [[16, 25]], "Arrays.sort()": [[53, 65]]}}}, {"text": "Thus, once you've implemented Comparable, you only need to write", "label": {"api": {"Comparable": [[30, 39]]}}}, {"text": "In the particular case of a text component, TextAction provides access to the focused text component and the underlying Document model to which the JTextComponent listens", "label": {"api": {"TextAction": [[44, 53]]}}}]