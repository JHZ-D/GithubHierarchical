[{"text": "Collect the result with Stream.collect into a new list using Collectors.toList()", "label": {"api": {"Stream.collect": [[24, 37]], "Collectors.toList()": [[61, 79]]}}}, {"text": "Adding Thread.yield() to the outer loop in t mitigates the problem, as shown below", "label": {"api": {"Thread.yield()": [[7, 20]]}}}, {"text": "Except for the artificial nature of the example, a hint like Thread.yield() would not ordinarily be required", "label": {"api": {"Thread.yield()": [[61, 74]]}}}, {"text": "I do not believe that Thread.yield() should need to be called in this case at all, despite the artificial nature of the test case, however", "label": {"api": {"Thread.yield()": [[22, 35]]}}}, {"text": "Note that the GUI updates promptly in the example below, even without Thread.yield()", "label": {"api": {"Thread.yield()": [[70, 83]]}}}, {"text": "I am trying to analyze a thread dump which seems to indicate that there are numerous threads that are waiting on java.util.concurrent.Semaphore permits, i.e., the threads are waiting on Semaphore.acquire()", "label": {"api": {"java.util.concurrent.Semaphore": [[113, 142]]}}}, {"text": "This I was able to imply because the threads are in WAITING (parking) state, and from what I've understood, Semaphore's do not use LOCK monitors, but use LockSupport.park() instead, waiting on another thread to unpark it", "label": {"api": {"LockSupport.park()": [[154, 171]]}}}, {"text": "Integer iOb = new Integer(88); is not auto-boxing, Integer takes an int parameter in one of its constructor overloads (see API)", "label": {"api": {"API": [[123, 125]]}}}, {"text": "If you bind your server socket to an unspecified host address, the socket will be bind to all available interfaces (see InetSocketAddress)", "label": {"api": {"InetSocketAddress": [[120, 136]]}}}, {"text": "For example, using a properties file, or command line arguments", "label": {"api": {"properties": [[21, 30]]}}}, {"text": "Java internationalization of strings can be done through the ResourceBundle class", "label": {"api": {"ResourceBundle": [[61, 74]]}}}, {"text": "Since you are using an embeddableID, you can also use the @MapsId annotation so that the EmbeddedID's shipToId attribute gets set by JPA with the value from the referenced entity", "label": {"api": {"@MapsId": [[58, 64]]}}}, {"text": "The JoinColumn defines the field and the @MapsId forces it to override any column definition on the shipToId attribute", "label": {"api": {"@MapsId": [[41, 47]]}}}, {"text": "Implement a ServletContextListener and register it in the web.xml or via annotation", "label": {"api": {"ServletContextListener": [[12, 33]]}}}, {"text": "But from what I can see, the Comparable interface does not require that compareTo() be \"consistent with equals()\" (though it is strongly recommended)", "label": {"api": {"does not require": [[50, 65]]}}}, {"text": "From the Comparable documentation", "label": {"api": {"Comparable documentation": [[9, 32]]}}}, {"text": "@Nicol Bolas makes a good point - there is a function Files.readAllBytes(Path path), if you use it instead of re-implementing the functionality you will be less prone to little bugs like this", "label": {"api": {"Files.readAllBytes(Path path)": [[54, 82]]}}}, {"text": "So, you want every user just once, so a Set is the better choice", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "For this you may have a look at Oracle's Stream-documentation", "label": {"api": {"Stream": [[41, 46]]}}}, {"text": "JDBC Type -1 is LONGVARCHAR, and is the type that is supposed to be returned by your query", "label": {"api": {"LONGVARCHAR": [[16, 26]]}}}, {"text": "No mapping for LONGVARCHAR in Hibernate 3.2", "label": {"api": {"LONGVARCHAR": [[15, 25]]}}}, {"text": "Here .stream.collect(Collectors.joining()) part is Java 8 Stream way to join a sequence of Strings into one", "label": {"api": {"Collectors.joining()": [[21, 40]]}}}, {"text": "You can get it by calling TreeSet.iterator()", "label": {"api": {"TreeSet.iterator()": [[26, 43]]}}}, {"text": "I am using CompletableFuture.runAsync() to asynchronously initialise a few fields in an object", "label": {"api": {"CompletableFuture.runAsync()": [[11, 38]]}}}, {"text": "You may use toCollection(Supplier)", "label": {"api": {"toCollection(Supplier)": [[12, 33]]}}}, {"text": "The documentation for ResourceBundle indicates that the call to getBundle(String) retrieves the bundle from the default location within the classloader", "label": {"api": {"ResourceBundle": [[22, 35]]}}}, {"text": "Read a String, instead of an int", "label": {"api": {"String": [[7, 12]], "int": [[29, 31]]}}}, {"text": "You can start with Instant.ofEpochMilli(long)", "label": {"api": {"Instant.ofEpochMilli(long)": [[19, 44]]}}}, {"text": "In Java, methods that throw checked exceptions (Exception or its subtypes - IOException, InterruptedException, etc) must declare throws statement", "label": {"api": {"Exception": [[48, 56], [78, 86], [100, 108]]}}}, {"text": "What could potentially go wrong if only RuntimeException were allowed to be catched in this scenario", "label": {"api": {"Exception": [[47, 55]]}}}, {"text": "But if you care about starting them at the same time (almost) you can use CyclicBarrier (taken from here)", "label": {"api": {"CyclicBarrier": [[74, 86]]}}}, {"text": "As for the compareTo method - normally you implement the Comparable interface", "label": {"api": {"Comparable": [[57, 66]]}}}, {"text": "What repaint Component.repaint does (emphasis mine)", "label": {"api": {"Component.repaint": [[13, 29]]}}}, {"text": "Have a look at Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[15, 35]]}}}, {"text": "Stream.iterate returns 'an infinite sequential ordered Stream'", "label": {"api": {"Stream.iterate": [[0, 13]]}}}, {"text": "According to the description of the  Stream package", "label": {"api": {"Stream package": [[37, 50]]}}}, {"text": "The real cause is that ordered parallel .distinct() is the full barrier operation as described in documentation", "label": {"api": {"described": [[85, 93]]}}}, {"text": "The @Column annotation should still work for this collection of strings", "label": {"api": {"@Column": [[4, 10]]}}}, {"text": "If you really need specific (and changing) usernames/passwords depending on application logic, then you can use DataSource.getConnection(String username, String password)", "label": {"api": {"DataSource.getConnection(String username, String password)": [[112, 169]]}}}, {"text": "To get a human readable format using Arrays use", "label": {"api": {"Arrays": [[37, 42]]}}}, {"text": "Use the the Socket.setKeepAlive() or apply the heart beat mechanism", "label": {"api": {"Socket.setKeepAlive()": [[12, 32]]}}}, {"text": "For most you can just use the String.valueOf() method", "label": {"api": {"String.valueOf()": [[30, 45]]}}}, {"text": "You can use Character.isLowerCase() and Character.isUpperCase() to check an individual char", "label": {"api": {"Character.isLowerCase()": [[12, 34]], "Character.isUpperCase()": [[40, 62]]}}}, {"text": "Read the javadoc of Matcher.group(int group)", "label": {"api": {"Matcher.group(int group)": [[20, 43]]}}}, {"text": "See Formatter for details", "label": {"api": {"Formatter": [[4, 12]]}}}, {"text": "Printing single character is support - see https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html#print(char) , so no reason for compiler error", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html#print(char)": [[43, 120]]}}}, {"text": "How about Files.readAllLines()", "label": {"api": {"Files.readAllLines()": [[10, 29]]}}}, {"text": "There is no difference in function betweenaddElement() and add(), except that add() returns a boolean", "label": {"api": {"addElement()": [[42, 53]]}}}, {"text": "From the JavaDoc for addElement()", "label": {"api": {"addElement()": [[21, 32]]}}}, {"text": "This method is identical in functionality to the add(E) method (which is part of the List interface)", "label": {"api": {"add(E)": [[49, 54]], "List": [[85, 88]]}}}, {"text": "You can't traverse through the list using Iterator and modify the list with List-level add/remove methods at the same time", "label": {"api": {"add": [[87, 89]]}}}, {"text": "To add an element in such situations you can use ListIterator and its method add", "label": {"api": {"add": [[3, 5], [77, 79]]}}}, {"text": "I am using a Service in this example because it is a reusable Worker", "label": {"api": {"Service": [[13, 19]]}}}, {"text": "I would recommend you look into ThreadPoolExecutor when dealing with large number of threads", "label": {"api": {"ThreadPoolExecutor": [[32, 49]]}}}, {"text": "So, People use @Deprecated annotation for APIs that have been deprecated", "label": {"api": {"@Deprecated": [[15, 25]]}}}, {"text": "When you use thenRunAsync(Runnable), tasks will be executed using a thread pool (there are other possibilites - see API docs)", "label": {"api": {"API docs": [[116, 123]]}}}, {"text": "See the Color constructor documentation for details", "label": {"api": {"the Color constructor documentation": [[4, 38]]}}}, {"text": "When the response is received in the callback, and I've done my processing, I decrement a CountDownLatch", "label": {"api": {"CountDownLatch": [[90, 103]]}}}, {"text": "I await the CountDownLatch, \"blocking\" the current thread until the CountDownLatch reaches 0", "label": {"api": {"CountDownLatch": [[12, 25], [68, 81]]}}}, {"text": "we create a pattern that captures every character but only find the first one and print it (the dotall mode is enabled to handle the case where the first character is a line separator)", "label": {"api": {"dotall mode": [[96, 106]]}}}, {"text": "s.charAt(0) uses CharSequence API, not String, so formally it is correct answer", "label": {"api": {"CharSequence": [[17, 28]]}}}, {"text": "Another option is to use a method accepting CharSequence as argument, e", "label": {"api": {"CharSequence": [[44, 55]]}}}, {"text": "Starting from here, get the type parameters that are declared on the method with the getTypeParameters method, which returns a TypeVariable<Method>[]", "label": {"api": {"the getTypeParameters method": [[81, 108]]}}}, {"text": "The TypeVariable interface has a method to retrieve the name T, getName, and a method to retrieve the bounds, getBounds", "label": {"api": {"TypeVariable interface": [[4, 25]]}}}, {"text": "I am using Java's javax.imageio.ImageIO to read contents from my FlashAir 32Gb (2nd gen) and to write them to my local hard drive", "label": {"api": {"javax.imageio.ImageIO": [[18, 38]]}}}, {"text": "It's decoding the images, and then re-encoding them at the default JPEG compression rate (which, judging by the JPEGImageWriteParam documentation, is 0.75)", "label": {"api": {"JPEGImageWriteParam": [[112, 130]]}}}, {"text": "I would suggest using an InputStreamReader to read the file then wrap in a buffered reader as shown in the example", "label": {"api": {"InputStreamReader": [[25, 41]]}}}, {"text": "You can only call the XMLStreamReader.getElementText() method on elements which contain text-only content", "label": {"api": {"XMLStreamReader.getElementText()": [[22, 53]]}}}, {"text": "The Javadoc for XMLStreamReader.getElementText() contains detailed pseudocode which shows how the method computes the String that it returns and under what conditions it will throw an XMLStreamException", "label": {"api": {"XMLStreamReader.getElementText()": [[16, 47]]}}}, {"text": "I tried to generify Future by replacing it with Future<Runnable> but it created a compile error instead since submit() returns a Future<?>", "label": {"api": {"Future": [[20, 25], [48, 53], [129, 134]], "submit()": [[110, 117]]}}}, {"text": "Then after threadPool.shutdown() invoke threadPool.awaitTermination() -- to block until all tasks complete", "label": {"api": {"threadPool.awaitTermination()": [[40, 68]]}}}, {"text": "The idea is to have a MappedByteBuffer backed by a \"file\" on tmpfs filesystem", "label": {"api": {"MappedByteBuffer": [[22, 37]]}}}, {"text": "The performance of such MappedByteBuffer will be the same as for other Direct ByteBuffers, but it will persist the JVM restart, i.e", "label": {"api": {"MappedByteBuffer": [[24, 39]]}}}, {"text": "To create the correctly typed array, you need to use the reflection method Array.newInstance()", "label": {"api": {"Array.newInstance()": [[75, 93]]}}}, {"text": "Consider using Iterator for search and removal", "label": {"api": {"Iterator": [[15, 22]]}}}, {"text": "Invoke recover on your Session", "label": {"api": {"recover": [[7, 13]], "Session": [[23, 29]]}}}, {"text": "You can use an ImageView and setPickOnBounds for that", "label": {"api": {"ImageView": [[15, 23]], "setPickOnBounds": [[29, 43]]}}}, {"text": "The model has a getElementAt(int) method", "label": {"api": {"getElementAt(int)": [[16, 32]]}}}, {"text": "From the docs for the add method", "label": {"api": {"the docs for the add method": [[5, 31]]}}}, {"text": "Unless it is a specific requirement to use Vector, DON'T, and if it is, tell teacher to update assignment to something newer than 1998", "label": {"api": {"Vector": [[43, 48]]}}}, {"text": "Vector was replaced by ArrayList back in Java 1.2 in 1998, and javadoc says", "label": {"api": {"Vector": [[0, 5]], "ArrayList": [[23, 31]]}}}, {"text": "Unlike the new collection implementations, Vector is synchronized", "label": {"api": {"Vector": [[43, 48]]}}}, {"text": "If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector", "label": {"api": {"Vector": [[94, 99]], "ArrayList": [[72, 80]]}}}, {"text": "If synchronization is needed, I'd recommend using Collections.synchronizedList() around an ArrayList over the use of Vector, which means that Vector should never be used, unless with an old API that requires it", "label": {"api": {"Vector": [[117, 122], [142, 147]], "ArrayList": [[91, 99]], "Collections.synchronizedList()": [[50, 79]]}}}, {"text": "The above code will only perform well on List objects with direct access by index, such as ArrayList, but will perform badly on lists like LinkedList", "label": {"api": {"ArrayList": [[91, 99]]}}}, {"text": "Run the server in the context of a class that implements the cancel() method of Future<V>", "label": {"api": {"cancel()": [[61, 68]], "Future<V>": [[80, 88]]}}}, {"text": "SwingWorker<T,V> is such a RunnableFuture<V>; a complete example is seen here", "label": {"api": {"Future<V>": [[35, 43]], "RunnableFuture<V>": [[27, 43]]}}}, {"text": "But you could install a HttpSessionListener to get notified when sessions are created and destroyed and keep track of them in an own collection", "label": {"api": {"HttpSessionListener": [[24, 42]]}}}, {"text": "Alternatively you could install a HttpSessionAttributeListener to get notified when attributes are added and removed from sessions", "label": {"api": {"HttpSessionAttributeListener": [[34, 61]]}}}, {"text": "Note that the Ellipse2D boundary includes the upper-left corner's x and y coordinates, as well as width and height", "label": {"api": {"Ellipse2D": [[14, 22]]}}}, {"text": "If the result of getSupportsWindowDecorations() is true for a given LookAndFeel, you can invoke setWindowDecorationStyle() on the JRootPane", "label": {"api": {"getSupportsWindowDecorations()": [[17, 46]], "LookAndFeel": [[68, 78]], "setWindowDecorationStyle()": [[96, 121]], "JRootPane": [[130, 138]]}}}, {"text": "Of course, if you were actually willing to write something like this in a real application, you would want to use String.replace(target, replacement) like this", "label": {"api": {"String.replace(target, replacement)": [[114, 148]]}}}, {"text": "The problem with File.listFiles is that it does not list recursively", "label": {"api": {"File.listFiles": [[17, 30]]}}}, {"text": "If I understand your requirement correctly, have a look at the LocalDate.parse() methods", "label": {"api": {"LocalDate.parse()": [[63, 79]]}}}, {"text": "Use replaceAll with an according regular expression with capturing groups and use $1 and $2 in the replacement to reuse the strings in the captured groups", "label": {"api": {"replaceAll": [[4, 13]], "regular expression": [[33, 50]]}}}, {"text": "The java.time framework built into Java 8 and later parses two-digit year strings as being in the 2000s", "label": {"api": {"java.time": [[4, 12]]}}}, {"text": "From the java.time.DateTimeFormatter class documentation", "label": {"api": {"java.time": [[9, 17]], "java.time.DateTimeFormatter": [[9, 35]]}}}, {"text": "get Waits if necessary for the computation to complete, and then retrieves its result", "label": {"api": {"get": [[0, 2]]}}}, {"text": "Use isDone to check that you can call get without waiting", "label": {"api": {"get": [[38, 40]], "isDone": [[4, 9]]}}}, {"text": "SwingWorker's processmethod has different arguments and a different return type", "label": {"api": {"SwingWorker's processmethod": [[0, 26]]}}}, {"text": "Instead of looping forever on the isAlive() check, create a CountDownLatch when you start the thread, count it down when the thread finishes, and simply await() it in cancel", "label": {"api": {"CountDownLatch": [[60, 73]]}}}, {"text": "This will incidentally also solve the first problem at the same time without any need for volatile, because in addition to its scheduling coordination a CountDownLatch guarantees that any thread that awaited on it will see the results of everything done in any thread that counted it down", "label": {"api": {"CountDownLatch": [[153, 166]]}}}, {"text": "Replace the Thread t with a CountDownLatch", "label": {"api": {"CountDownLatch": [[28, 41]]}}}, {"text": "In start, initialize the CountDownLatch with a count of 1", "label": {"api": {"CountDownLatch": [[25, 38]]}}}, {"text": "In start, after initializing the CountDownLatch, get an ExecutorService by calling Executors.newSingleThreadExecutor(), and then submit the renameAllFiles call to it", "label": {"api": {"CountDownLatch": [[33, 46]], "Executors.newSingleThreadExecutor()": [[83, 117]]}}}, {"text": "Integer.toHexString(int) is available", "label": {"api": {"Integer.toHexString(int)": [[0, 23]]}}}, {"text": "As is BigInteger.toString(int radix)", "label": {"api": {"BigInteger.toString(int radix)": [[6, 35]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html It'll do all the shifting for you", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[0, 65]]}}}, {"text": "You need to call ResultSet.wasNull() to test whether the last column read had a value of SQL NULL", "label": {"api": {"ResultSet.wasNull()": [[17, 35]]}}}, {"text": "Hibernate uses the JPA @Index annotation which doesn't support function-based indexes", "label": {"api": {"@Index": [[23, 28]]}}}, {"text": "As of Java 7, the default locale comes in two categories", "label": {"api": {"the default locale comes in two categories": [[14, 55]]}}}, {"text": "The garbage collector traverses existing references and within the objects found this way, it will find meta information (i.e", "label": {"api": {"references": [[41, 50]]}}}, {"text": "a pointer to class specific information) needed to understand how much memory belongs to the object and how to interpret the contained data (to traverse the sub-references, if any)", "label": {"api": {"references": [[161, 170]]}}}, {"text": "Once all references to an object are gone, there is no information left about the former existence of this object", "label": {"api": {"references": [[9, 18]]}}}, {"text": "When you search memory that is considered to be unused, you may find reminiscences of old objects, but without references to their starting points, it’s impossible to say whether the bit pattern that looks like an object really is a dead object or just a coincidence", "label": {"api": {"references": [[111, 120]]}}}, {"text": "Similarly, soft, weak and phantom references encapsulate a reference to the object in question", "label": {"api": {"references": [[34, 43]]}}}, {"text": "You can obtain that with anyMatch", "label": {"api": {"anyMatch": [[25, 32]]}}}, {"text": "HashMap (and, in fact, all classes implementing Map) only stores one value per key", "label": {"api": {"Map": [[4, 6], [48, 50]]}}}, {"text": "Quoting the Javadoc of Map", "label": {"api": {"Map": [[23, 25]]}}}, {"text": "a Collection like a List or Set, so your map type might be Map<String, List<String>>", "label": {"api": {"Map": [[59, 61]]}}}, {"text": "You can override the public boolean equals(Object o) method of Object class in Address as", "label": {"api": {"public boolean equals(Object o)": [[21, 51]]}}}, {"text": "then you can use List.contains(Object o) method of List to verify that element(Address obj) is present or not in the list", "label": {"api": {"List.contains(Object o)": [[17, 39]]}}}, {"text": "In Java 8, you can use forEach to iterate over the entries of the hashmap and retrieve both key and value in each iteration", "label": {"api": {"forEach": [[23, 29]]}}}, {"text": "The int constructor parameter is an initial capacity, not the number of elements present initially", "label": {"api": {"initial capacity": [[36, 51]]}}}, {"text": "PriorityBlockingQueue.size() returns the number of elements present in the collection; PriorityBlockingQueue.remainingCapacity() returns the available capacity", "label": {"api": {"PriorityBlockingQueue.size()": [[0, 27]], "PriorityBlockingQueue.remainingCapacity()": [[87, 127]]}}}, {"text": "This is perfectly well explained in this javadoc", "label": {"api": {"this javadoc": [[36, 47]]}}}, {"text": "Consider use of a concurrent hashmap and the method Map.computeIfAbsent() which takes a function to call to compute a default value if key is absent from the map", "label": {"api": {"Map.computeIfAbsent()": [[52, 72]]}}}, {"text": "Have a look at MappedByteBuffer and ByteBuffer", "label": {"api": {"MappedByteBuffer": [[15, 30]], "ByteBuffer": [[21, 30], [36, 45]]}}}, {"text": "For this, you can calculate the duration between instant and toCheck with Duration.between", "label": {"api": {"Duration.between": [[74, 89]]}}}, {"text": "Since nextChar does not exist, I will offer you to consider trying the following", "label": {"api": {"does not exist": [[15, 28]]}}}, {"text": "I guess you already have the answer you seek but just for the sake of answering, you can try using result-set-metadata by using a select * from table and then checking the column names against your query (you'd have to parse the query string I guess...)", "label": {"api": {"result-set-metadata": [[99, 117]]}}}, {"text": "Math.round is underspecified, and I believe its behavior has actually changed in the past -- see http://bugs.java.com/view_bug.do?bug_id=6430675 -- but generally speaking it behaves like RoundingMode.HALF_UP, which has an extensive table of its differences from RoundingMode.CEILING or RoundingMode.FLOOR", "label": {"api": {"RoundingMode.HALF_UP": [[187, 206]]}}}, {"text": "If you define a no-parameter initialize() method in your Controller and don't implement the Initializable interface, then the FXML loader will still automatically invoke the initialize method", "label": {"api": {"Initializable": [[92, 104]]}}}, {"text": "If instead, you define a parameterized public void initialize(URL url, ResourceBundle rb) method in your Controller, then the FXML loader will not automatically invoke the initialize method unless your controller also implements the Initializable interface", "label": {"api": {"Initializable": [[233, 245]]}}}, {"text": "As the code in the question was using a parameterized initialize method and not also implementing Initializable, the initialization was not occurring", "label": {"api": {"Initializable": [[98, 110]]}}}, {"text": "In this framework, you would start off by getting an ExecutorService from one of the static factory methods in Executors, replace both new Thread and t.start() with a call to submit(), and then either coordinate between threads with a CountDownLatch or other provided synchronizer class or (as in your simple case) call get() on the Future that submit() returns", "label": {"api": {"Executors": [[111, 119]], "CountDownLatch": [[235, 248]]}}}, {"text": "The HTML document is in the WebEngine's document property, but it's loaded in the background, so you must wait for it to load", "label": {"api": {"document": [[9, 16], [40, 47]]}}}, {"text": "The document object is a regular XML document, so if the button has an id attribute, you can easily retrieve it", "label": {"api": {"document": [[4, 11], [37, 44]]}}}, {"text": "Finally, you can add a DOM event listener to the button, as described in the WebEngine documentation", "label": {"api": {"document": [[87, 94]], "WebEngine documentation": [[77, 99]]}}}, {"text": "You can use Timeline which is probably more suitable for this", "label": {"api": {"Timeline": [[12, 19]]}}}, {"text": "Alternatively, you may try to have the delay of the KeyFrame as zero, and use the Timeline's targetFrameRate, but I personally never tried it", "label": {"api": {"Timeline": [[82, 89]]}}}, {"text": "Like 1 but automatically by the data structure itself, use CopyOnWriteArrayList and return it (wrapped in unmodifiable)", "label": {"api": {"CopyOnWriteArrayList": [[59, 78]]}}}, {"text": "Depending on the properties of the data structure you need you could go for a non RandomAccess list like ConcurrentLinkedQueue or ConcurrentLinkedDeque, both allow iterating etc over the data structure without any extra synchronization", "label": {"api": {"ConcurrentLinkedQueue": [[105, 125]], "ConcurrentLinkedDeque": [[130, 150]]}}}, {"text": "See javadoc of Pattern", "label": {"api": {"Pattern": [[15, 21]]}}}, {"text": "Note that the replaceAll() method shown in comments is also using a regular expression", "label": {"api": {"replaceAll()": [[14, 25]]}}}, {"text": "Given a Map mapping a String to a List, is there a way to use Java Streams to return a Boolean where TRUE means one or more list had elements", "label": {"api": {"Map": [[8, 10]], "List": [[34, 37]]}}}, {"text": "No need to examine all the Map values (all the Lists)", "label": {"api": {"Map": [[27, 29]], "List": [[47, 50]]}}}, {"text": "Use the anyMatch method that finds if any element of the stream matches a Predicate", "label": {"api": {"the anyMatch method": [[4, 22]]}}}, {"text": "Go through the string and call Character.isLetter(char) for each char to test if it is a letter character", "label": {"api": {"Character.isLetter(char)": [[31, 54]]}}}, {"text": "Use System.nanoTime() if you want the highest precission", "label": {"api": {"System.nanoTime()": [[4, 20]]}}}, {"text": "It sounds like something as simple as java.util.Timer could do the job", "label": {"api": {"java.util.Timer": [[38, 52]]}}}, {"text": "From java documentation link", "label": {"api": {"link": [[24, 27]]}}}, {"text": "Have a look at this link to understand about various API related to memory", "label": {"api": {"link": [[20, 23]]}}}, {"text": "If you have a PreparedStatement you should be able to do something like this", "label": {"api": {"PreparedStatement": [[14, 30]]}}}, {"text": "Specifically, depending on the implementation of a collection this could throw ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[79, 109]]}}}, {"text": "java.util.TimerTask has only thread to run task", "label": {"api": {"java.util.TimerTask": [[0, 18]]}}}, {"text": "You can replace it with java.util.concurrent.ScheduledExecutorService, it could launch more thread to run task..", "label": {"api": {"java.util.concurrent.ScheduledExecutorService": [[24, 68]]}}}, {"text": "In the first case (ArrayList::new) you are using the constructor which takes an initial capacity argument, in the second case you are not", "label": {"api": {"constructor": [[53, 63]]}}}, {"text": "Here are the two constructors' current implementations", "label": {"api": {"constructor": [[17, 27]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/constant-values.html#java.util.Calendar.YEAR It's a different way of doing enumerations, with static final integers", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/constant-values.html#java.util.Calendar.YEAR": [[0, 85]]}}}, {"text": "Note that if you really want an OffsetDateTime, you can use ZonedDateTime.toOffsetDateTime() to convert a ZonedDateTime into an OffsetDateTime", "label": {"api": {"ZonedDateTime.toOffsetDateTime()": [[60, 91]]}}}, {"text": "And you could use equals() instead of == to compare two strings", "label": {"api": {"equals()": [[18, 25]]}}}, {"text": "In this case, use Map", "label": {"api": {"Map": [[18, 20]]}}}, {"text": "You can choose a file with a FileChooser or choose a directory with a DirectoryChooser", "label": {"api": {"FileChooser": [[29, 39]], "DirectoryChooser": [[70, 85]]}}}, {"text": "Whenever I check RandomAccessFile.length, will get I the accurate length", "label": {"api": {"RandomAccessFile.length": [[17, 39]]}}}, {"text": "From the documentation for the getBounds2D() method of Path2D.Float", "label": {"api": {"documentation for the getBounds2D() method of Path2D.Float": [[9, 66]]}}}, {"text": "This is actually just a copy of the general contract of Shape.getBounds2D()", "label": {"api": {"general contract of Shape.getBounds2D()": [[36, 74]]}}}, {"text": "FileSystems is an utility class/factory that is only used to get instances of FileSystem", "label": {"api": {"FileSystems": [[0, 10]], "FileSystem": [[0, 9], [78, 87]]}}}, {"text": "Refer to the class documentation for the methods in the FileSystems class", "label": {"api": {"FileSystems": [[56, 66]], "FileSystem": [[56, 65]], "class documentation": [[13, 31]]}}}, {"text": "Basically, you will never use FileSystems except when you want to get an instance of FileSystem", "label": {"api": {"FileSystems": [[30, 40]], "FileSystem": [[30, 39], [85, 94]]}}}, {"text": "For all other use cases, yo uwould only want to use FileSystem", "label": {"api": {"FileSystem": [[52, 61]]}}}, {"text": "The java.util.logging logging framework uses shutdown hooks to make sure the flush() method is called on its handlers", "label": {"api": {"handlers": [[109, 116]]}}}, {"text": "The handlers provided with the java api do implement this", "label": {"api": {"handlers": [[4, 11]]}}}, {"text": "You can use the JarFile class like this", "label": {"api": {"JarFile": [[16, 22]]}}}, {"text": "Similarly to Map.Entry", "label": {"api": {"Map.Entry": [[13, 21]]}}}, {"text": "You are not using correctly the Period class here", "label": {"api": {"Period": [[32, 37]]}}}, {"text": "The period between those two dates, as defined by the Period class is \"1 month\"", "label": {"api": {"Period": [[54, 59]]}}}, {"text": "If you print the period, you will have \"P1M\", which is the pattern to say that", "label": {"api": {"\"P1M\"": [[39, 43]]}}}, {"text": "As such, getDays(), which return the amount of days in the period, will return 0", "label": {"api": {"getDays()": [[9, 17]]}}}, {"text": "You can convince yourself of that by printing the result of getMonths, it would return 1", "label": {"api": {"getMonths": [[60, 68]], "Month": [[63, 67]]}}}, {"text": "In Java Time, there is an enum Month for all the months, and the method length(leapYear) return the length of this month, i.e", "label": {"api": {"Month": [[31, 35]], "length(leapYear)": [[72, 87]]}}}, {"text": "To check for the current year, we can call Year.now() and return if it's a leap year or not with isLeap()", "label": {"api": {"Year.now()": [[43, 52]], "isLeap()": [[97, 104]]}}}, {"text": "Therefore, we will parse each String into a YearMonth object using a custom DateTimeFormatter", "label": {"api": {"YearMonth": [[44, 52]], "DateTimeFormatter": [[76, 92]]}}}, {"text": "Once they are parsed, we can get the period between those two temporal objects with Period.between", "label": {"api": {"Period.between": [[84, 97]]}}}, {"text": "This method takes a LocalDate as parameter so we need to add a day to each YearMonth", "label": {"api": {"YearMonth": [[75, 83]]}}}, {"text": "Finally, getYears() return the amount of years in this period and getMonths() returns the amount of month", "label": {"api": {"getYears()": [[9, 18]], "getMonths()": [[66, 76]]}}}, {"text": "If you're using java 8 you should take a look at its new Base64 class", "label": {"api": {"Base64": [[57, 62]]}}}, {"text": "It will provide you with a Base64.Encoder whose encodeToString(byte[] src) method accepts a byte array and return a base64 encoded String", "label": {"api": {"Base64": [[27, 32]], "Base64.Encoder": [[27, 40]]}}}, {"text": "Using a stringjoiner directly isn't effective when you have all your information already self contained in a streamable list, because you can stream directly and create a string with Collectors.joining", "label": {"api": {"Collectors.joining": [[183, 200]]}}}, {"text": "The above code uses .stream() to loop over the List then .map() them to strings, then finally collects them using Collectors.joining", "label": {"api": {"Collectors.joining": [[114, 131]]}}}, {"text": "Yuri Schimke also suggested another method, you can also use DecimalFormat to format the numbers", "label": {"api": {"DecimalFormat": [[61, 73]]}}}, {"text": "I think the problem here is that you think a PropertyChangeListener will listen to setText() - It doesn't", "label": {"api": {"setText": [[83, 89]]}}}, {"text": "In the documentation of the propertyChange method it states", "label": {"api": {"propertyChange": [[28, 41]]}}}, {"text": "Furthermore in the setText method's documentation", "label": {"api": {"setText": [[19, 25]]}}}, {"text": "You can use if you want the TrayIcon.displayMessage", "label": {"api": {"TrayIcon.displayMessage": [[28, 50]]}}}, {"text": "For large content, instead of a JLabel, you can use a JEditorPane which has support for HTML content", "label": {"api": {"JEditorPane": [[54, 64]]}}}, {"text": "You can use \\p{Punct}, which is one of !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~, along with \\s which is a whitespace [ \\t\\n\\x0B\\f\\r]", "label": {"api": {"\\p{Punct}": [[12, 20]]}}}, {"text": "That method is documented to return the contents of the line, not including any line-termination characters", "label": {"api": {"not including any line-termination characters": [[62, 106]]}}}, {"text": "A system-dependent line separator is used by the Files.write() method you're calling, as documented in its sibling", "label": {"api": {"Files.write()": [[49, 61]], "documented in its sibling": [[89, 113]]}}}, {"text": "You can also get this system-dependent line separator with System.lineSeparator()", "label": {"api": {"System.lineSeparator()": [[59, 80]]}}}, {"text": "I was looking at the Executor interface", "label": {"api": {"Executor": [[21, 28]]}}}, {"text": "My question is, how can I implement this Thread Pool Executor to be accessible from all the requests received and act as a queue for all the threads", "label": {"api": {"Executor": [[53, 60]]}}}, {"text": "I was looking also at the Tomcat Executor, which I believe is used by Tomcat itself to manage its thread", "label": {"api": {"Executor": [[33, 40]]}}}, {"text": "Also please look at the documentation for Files.readAllLines and note that this function is not intended for reading in large files", "label": {"api": {"documentation for Files.readAllLines": [[24, 59]]}}}, {"text": "Use Scanner or BufferedReader instead on large files", "label": {"api": {"Scanner": [[4, 10]], "BufferedReader": [[15, 28]]}}}, {"text": "There is a much easier solution, using the built-in Collections.shuffle", "label": {"api": {"Collections.shuffle": [[52, 70]]}}}, {"text": "getByteRgbInstance() returns a pixel format in which there are three bytes per pixel", "label": {"api": {"getByteRgbInstance()": [[0, 19]]}}}, {"text": "The last argument to the setPixels method is the difference in offset in the array from the beginning of one row to the beginning of the next row", "label": {"api": {"setPixels": [[25, 33]]}}}, {"text": "Ideally, you would use something like a TreeSet", "label": {"api": {"TreeSet": [[40, 46]]}}}, {"text": "As you can surmise from the Process docs, the process object is created when you create a child process from your code", "label": {"api": {"Process docs,": [[28, 40]]}}}, {"text": "If you look at the documentation for ArrayList, you'll see that the methods that deal with size (adding, creating, determining size, etc) all return an int", "label": {"api": {"documentation for ArrayList": [[19, 45]]}}}, {"text": "The guava library has it's own Supplier which does not extend Java 8 Supplier", "label": {"api": {"Supplier": [[31, 38], [69, 76]]}}}, {"text": "Also guava provides a cache for suppliers - Suppliers#memoize", "label": {"api": {"Supplier": [[44, 51]]}}}, {"text": "Is there something similar, but for Java 8 Suppliers", "label": {"api": {"Supplier": [[43, 50]]}}}, {"text": "As per my understanding from the JavaDoc for the ProcessBuilder, it just spawns a separate process and continues with its execution", "label": {"api": {"JavaDoc for the ProcessBuilder": [[33, 62]]}}}, {"text": "assert throws an AssertionError if the assertion is false", "label": {"api": {"AssertionError": [[17, 30]]}}}, {"text": "You can execute command line statements from Java using a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[58, 71]]}}}, {"text": "Forget about your KeyListener , since PaintWindow will receive no key event , not being a java.awt.Component", "label": {"api": {"java.awt.Component": [[90, 107]]}}}, {"text": "If you have no idea what can be null, or want to check everything for null, the only way is to chain calls to Optional.map", "label": {"api": {"Optional.map": [[110, 121]]}}}, {"text": "The final call to orElse(0) allows to return the default value 0 if any mapper returned null", "label": {"api": {"orElse(0)": [[18, 26]]}}}, {"text": "Use a JDK AtomicReference as your bean, rather than creating a dedicated class just for storage", "label": {"api": {"AtomicReference": [[10, 24]]}}}, {"text": "Invoke the set method to store a value", "label": {"api": {"set": [[11, 13]]}}}, {"text": "Invoke the get to recover the value", "label": {"api": {"get": [[11, 13]]}}}, {"text": "Obviously you won't get rid of the steps in the route to store/fetch the value, but you can scrap away your custom class", "label": {"api": {"get": [[20, 22]]}}}, {"text": "The getRow doesn't work, because it \"Retrieves the current row number.\"", "label": {"api": {"getRow": [[4, 9]]}}}, {"text": "The canonicalization docs do not indicate why the CN of the server certificate is being canonicalized to this hex form", "label": {"api": {"canonicalization docs": [[4, 24]]}}}, {"text": "If you read the documentation for String.replaceAll, the return value of String.replaceAll is a result String", "label": {"api": {"String.replaceAll": [[34, 50], [73, 89]]}}}, {"text": "I can only search them by ID, which is not sufficient, as they can be added and removed by the user", "label": {"api": {"search them by ID": [[11, 27]]}}}, {"text": "It is usually far better to implement your tasks as a Runnable and then use a ThreadPoolExecutor to implement multithreading", "label": {"api": {"Runnable": [[54, 61]], "ThreadPoolExecutor": [[78, 95]]}}}, {"text": "The elegant solution to this, since Java 7, is to use Objects#equals(Object, Object), which is null-safe", "label": {"api": {"Objects#equals(Object, Object)": [[54, 83]]}}}, {"text": "Here's code for old style, and for new java.time API built into Java 8 and later", "label": {"api": {"java.time": [[39, 47]]}}}, {"text": "Use the find() method", "label": {"api": {"find()": [[8, 13]]}}}, {"text": "Just use the object's Class object, which has a getMethod method that will return a Method object for the method you want, then invoke it", "label": {"api": {"getMethod method": [[48, 63]], "Method object": [[84, 96]]}}}, {"text": "To invoke a Java method (and Rectangle.getHeight() is a method), you need a parentheses, like", "label": {"api": {"Rectangle.getHeight()": [[29, 49]]}}}, {"text": "Instead, it uses ReentrantReadWriteLock class in java.util.concurrent.locks package", "label": {"api": {"ReentrantReadWriteLock": [[17, 38]]}}}, {"text": "You want the setEnabled method of a JButton", "label": {"api": {"setEnabled": [[13, 22]]}}}, {"text": "Basically reflection is a mechanism to pass from strings to Classes, Methods, Constructors and viceversa", "label": {"api": {"Method": [[69, 74]]}}}, {"text": "In any case you need to obtain a reference to a Method", "label": {"api": {"Method": [[48, 53]]}}}, {"text": "From the class Method is possible to get the name of that method as a String with the method getName", "label": {"api": {"Method": [[15, 20]], "getName": [[93, 99]]}}}, {"text": "Instead of using a infinity recursive function calls, use a SingleThreadedExecutor, and use that to dispatch the update calls", "label": {"api": {"SingleThreadedExecutor": [[60, 81]]}}}, {"text": "You can adjust a given date with an adjuster with the method LocalDateTime.with(adjuster)", "label": {"api": {"LocalDateTime.with(adjuster)": [[61, 88]]}}}, {"text": "If you want to keep the current date in that case, you can use nextOrSame(dayOfWeek)", "label": {"api": {"nextOrSame(dayOfWeek)": [[63, 83]]}}}, {"text": "However, rather than rewriting your code around to use JSON and XML you can keep it by changing the signature of the big class to java.io.Exernalizable and implement readExternal() and writeExternal()", "label": {"api": {"java.io.Exernalizable": [[130, 150]]}}}, {"text": "However, since the column has a different name in the child entity, you'll need to change it using an @AttributeOverride to point to the personel_id @Column", "label": {"api": {"@AttributeOverride": [[102, 119]]}}}, {"text": "As Richard points out, I'm wrong—Java SE actually does say that the first week of a week-based year is the first Monday-based week containing at least four days, just like Joda-Time", "label": {"api": {"actually does say": [[41, 57]]}}}, {"text": "From the documentation of Java SE's IsoFields.WEEK_OF_WEEK_BASED_YEAR", "label": {"api": {"IsoFields.WEEK_OF_WEEK_BASED_YEAR": [[36, 68]]}}}, {"text": "Instead of sleeping the thread, use a PauseTransition and load your new scene after the pause has finished", "label": {"api": {"PauseTransition": [[38, 52]]}}}, {"text": "The ArrayList(int) constructor initializes the ArrayList's capacity, not it's size", "label": {"api": {"ArrayList(int)": [[4, 17]]}}}, {"text": "If you want to add a new element to an array list, you should use the add(T) or add(int, T) method", "label": {"api": {"add(T)": [[70, 75]], "add(int, T)": [[80, 90]]}}}, {"text": "You can just use the new Optional API in Java 8", "label": {"api": {"Optional API": [[25, 36]]}}}, {"text": "If you need to get an int reference from one thread to another, you either have to specify your own MutableInteger class, or use AtomicInteger", "label": {"api": {"AtomicInteger": [[129, 141]]}}}, {"text": "The class Console does not have the method readInt", "label": {"api": {"Console": [[10, 16]]}}}, {"text": "Or you can also refer to this answer in order to use Scanner", "label": {"api": {"Scanner": [[53, 59]]}}}, {"text": "For the latter option, I recommend a CountDownLatch", "label": {"api": {"CountDownLatch": [[37, 50]]}}}, {"text": "You can use Guava's Multimap and Java 8's Map.merge(K, V, BiFunction)", "label": {"api": {"Map.merge(K, V, BiFunction)": [[42, 68]]}}}, {"text": "If you are trying to reverse the String, then you can use StringBuilder.reverse()", "label": {"api": {"StringBuilder.reverse()": [[58, 80]]}}}, {"text": "You can do this using a StringBuilder", "label": {"api": {"StringBuilder": [[24, 36]]}}}, {"text": "So remove that loop, instead use a javax.swing.Timer to time your events", "label": {"api": {"javax.swing.Timer": [[35, 51]]}}}, {"text": "Let's use the Math.random() method which is static", "label": {"api": {"Math.random()": [[14, 26]]}}}, {"text": "The equals method should be overriden from Object.equals", "label": {"api": {"Object.equals": [[43, 55]]}}}, {"text": "always) also override Object.hashCode", "label": {"api": {"Object.hashCode": [[22, 36]]}}}, {"text": "Building strings is best done using the StringBuilder class", "label": {"api": {"StringBuilder": [[40, 52]]}}}, {"text": "From the Java Docs for Stream#reduce(), we see that the reduce operation returns an Optional<T>", "label": {"api": {"Java Docs for Stream#reduce()": [[9, 37]], "Optional": [[84, 91]]}}}, {"text": "An Optional simply wraps a value if there is a value present, otherwise is \"empty\"", "label": {"api": {"Optional": [[3, 10]]}}}, {"text": "Important operations on Optional include Optional#isPresent, which lets you know if there is something in the Optional or not, Optional#get, which returns the T wrapped in the Optional and throws an exception if called on Empty, and Optional#orElse which returns the T wrapped in the Optional if present, or the returns the default value provided if called on Empty", "label": {"api": {"Optional": [[24, 31], [41, 48], [110, 117], [127, 134], [176, 183], [233, 240], [284, 291]], "Optional#isPresent": [[41, 58]], "Optional#get": [[127, 138]], "Optional#orElse": [[233, 247]]}}}, {"text": "For your case, the rationale behind reduce() returning an Optional<Integer> is that the list you're trying to reduce may be empty", "label": {"api": {"Optional": [[58, 65]]}}}, {"text": "And finally, you should be setting the panel as the content pane using setContentPane", "label": {"api": {"setContentPane": [[71, 84]]}}}, {"text": "Usually it's best to have the panel dictate what its size should be by overriding setPreferredSize", "label": {"api": {"setPreferredSize": [[82, 97]]}}}, {"text": "In that case you don't need to set the size of the containing frame, rather you call pack to size the frame to the preferred size of its subcomponents", "label": {"api": {"pack": [[85, 88]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/javax/sound/sampled/Clip.html May help for more digging if you decide to try this route instead of toolkit", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/sound/sampled/Clip.html": [[0, 70]]}}}, {"text": "You should consider setting an auto-delay using setAutoDelay", "label": {"api": {"setAutoDelay": [[48, 59]]}}}, {"text": "Another thing you can try is add waitForIdle() before each key press", "label": {"api": {"waitForIdle()": [[33, 45]]}}}, {"text": "You could use the BufferedReader.lines, which returns a Stream<String> with the lines of the file", "label": {"api": {"BufferedReader.lines": [[18, 37]]}}}, {"text": "You can retrieve a Stream over the lines of the file with Files.lines(path) (and you can get a Path with Paths.get)", "label": {"api": {"Files.lines(path)": [[58, 74]], "Paths.get": [[105, 113]]}}}, {"text": "The header line is skipped with skip(1), then each line is split around \",\"", "label": {"api": {"skip(1)": [[32, 38]]}}}, {"text": "The group operation is done with the groupingBy(classifier, downstream) collector", "label": {"api": {"groupingBy(classifier, downstream)": [[37, 70]]}}}, {"text": "the classifier is a method that returns the key to group by and the downstream collector collects all Stream elements grouped to the same key; in this case, for the values having the same key, we want to map the Stream element to the Double value (mapping) and collects those Double into a List (toList())", "label": {"api": {"mapping": [[248, 254]], "toList()": [[296, 303]]}}}, {"text": "CXF provides the XmlAdapter for converting between XML and the custom datatypes", "label": {"api": {"XmlAdapter": [[17, 26]]}}}, {"text": "The issue I'm having is that the XmlAdapter can take only one BoundType in the generic, so I'm finding myself writing one adapter for each data type which seems wasteful", "label": {"api": {"XmlAdapter": [[33, 42]]}}}, {"text": "Have a look at the method ScheduledExecutorService#scheduleWithFixedDelay()", "label": {"api": {"ScheduledExecutorService#scheduleWithFixedDelay()": [[26, 74]]}}}, {"text": "As opposed to the method ScheduledExecutorService#scheduleAtFixedRate(), the method with fixed delay does not try to keep up", "label": {"api": {"ScheduledExecutorService#scheduleAtFixedRate()": [[25, 70]]}}}, {"text": "On the java.util.Pattern page all the regex are explained and && is only ever used next to a range (like [a-z&&[^e]])", "label": {"api": {"java.util.Pattern": [[7, 23]]}}}, {"text": "Store the .class in the map then use Class.newInstance() when needed", "label": {"api": {"Class.newInstance()": [[37, 55]]}}}, {"text": "You could also use the String.split() method, but that's up to you", "label": {"api": {"String.split()": [[23, 36]]}}}, {"text": "Consider using a Queue (BlockingQueue or similar) where you put the data to be written and which are then processed by one/more worker Threads (this approach is nothing crawler4j-specific)", "label": {"api": {"Queue": [[17, 21], [32, 36]], "BlockingQueue": [[24, 36]]}}}, {"text": "Concerning your follow-up question on how to pass the Queue to the crawler instances, this should do the trick (this is only from looking at the source code, haven't used crawler4j on my own)", "label": {"api": {"Queue": [[54, 58]]}}}, {"text": "Use https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html to find the right formatter in order to read the date", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html": [[4, 76]]}}}, {"text": "use Arrays.copyOf (or one of its variants)", "label": {"api": {"Arrays.copyOf": [[4, 16]]}}}, {"text": "To transform the list in one small method call, use List#replaceAll()", "label": {"api": {"List#replaceAll()": [[52, 68]]}}}, {"text": "Integer has a longValue method that returns the value as a long (primitive)", "label": {"api": {"longValue": [[14, 22]]}}}, {"text": "If you need parameters or a return value, you might want to have a look at the interfaces in the package java.util.function", "label": {"api": {"java.util.function": [[105, 122]]}}}, {"text": "Read the input with java.util.Scanner and a for loop", "label": {"api": {"java.util.Scanner": [[20, 36]]}}}, {"text": "If the array could be of any dimension, then the Objects.deepEquals() method might be of help", "label": {"api": {"Objects.deepEquals() method": [[49, 75]]}}}, {"text": "Now you just need to keep using java.lang.reflect.Array to manipulate it, since you don't know at compile-time how many dimensions it has", "label": {"api": {"java.lang.reflect.Array": [[32, 54]]}}}, {"text": "Also note that Java provides EnumSet as a memory-efficient Set implementation for enums", "label": {"api": {"EnumSet": [[29, 35]]}}}, {"text": "This is how you can iterate over your Map", "label": {"api": {"Map": [[38, 40]]}}}, {"text": "To get a specific value (Integer) from your Map use", "label": {"api": {"Map": [[44, 46]]}}}, {"text": "And as I see you are using Java 8 you can even use the nicer getOrDefault", "label": {"api": {"getOrDefault": [[61, 72]]}}}, {"text": "Another approach would be to use the Consumer.andThen(anotherConsumer) method to create a composed consumer made of inner consumers that execute in sequence", "label": {"api": {"Consumer.andThen(anotherConsumer)": [[37, 69]]}}}, {"text": "Check for lengths is null-safe, while check for contents is delegated to the Arrays.equals(array1, array2) method", "label": {"api": {"Arrays.equals(array1, array2)": [[77, 105]]}}}, {"text": "You can use field.getAnnotation() for this", "label": {"api": {"field.getAnnotation()": [[12, 32]]}}}, {"text": "You can use range()", "label": {"api": {"range()": [[12, 18]]}}}, {"text": "Of course you need to define your resultset as FORWARD_ONLY to guarantee this", "label": {"api": {"FORWARD_ONLY": [[47, 58]]}}}, {"text": "link to check whether you are in daylight saving", "label": {"api": {"link": [[0, 3]]}}}, {"text": "I think you are looking for .charAt()", "label": {"api": {".charAt()": [[28, 36]]}}}, {"text": "Afterwards, You might want to get the source object and convert it to a DOMSource object and then get the Node object which make the information retrieval much easier", "label": {"api": {"source": [[38, 43]], "Node": [[106, 109]]}}}, {"text": "The second issue was caused by attempting to cast the result of javax.net.URL.openConnection() (which in the App Engine runtime will return an instance of com.google.apphosting.utils.security.urlfetch.URLFetchServiceStreamHandler$Connection) to javax.net.ssl.HttpsURLConnection, which cannot be done", "label": {"api": {"javax.net.URL": [[64, 76]]}}}, {"text": "Therefore you could simply use a StringBuilder with its reverse-method", "label": {"api": {"StringBuilder": [[33, 45]]}}}, {"text": "If you look at the documentation for Scanner.nextInt(), you can see that it throws its own InputMismatchException", "label": {"api": {"Scanner.nextInt()": [[37, 53]]}}}, {"text": "However in this case I recommend adding a TextFormatter to the TextField which allows you to assign/input values of a type different to String using a TextField", "label": {"api": {"TextFormatter": [[42, 54]]}}}, {"text": "This allows you to assign the value using the TextFormatter, e.g", "label": {"api": {"TextFormatter": [[46, 58]]}}}, {"text": "For more information on this kind of string replacement works, see the documentation on the Formatter class", "label": {"api": {"Formatter": [[92, 100]]}}}, {"text": "What you could do is use LinkedHashMap in LRU mode and then override removeEldestEntry to limit the cache size", "label": {"api": {"LRU mode": [[42, 49]]}}}, {"text": "Because DirectoryStream implements Iterable which would iterate over the entries in a directory, and Observable.from(Iterable) converts the sequence into an Observable emitting the items in the sequence, which is the entries in a directory", "label": {"api": {"DirectoryStream": [[8, 22]]}}}, {"text": "equals() should always be commutative, i.e", "label": {"api": {"equals()": [[0, 7]]}}}, {"text": "Or symmetric, as the javadoc of equals() calls it", "label": {"api": {"equals()": [[32, 39]]}}}, {"text": "To implement this, you need to create an annotation processor that runs as a plug-in to javac", "label": {"api": {"annotation processor": [[41, 60]]}}}, {"text": "Frameworks exist to make it easy to create a compile-time annotation processor that ensures that methods are called legally", "label": {"api": {"annotation processor": [[58, 77]]}}}, {"text": "Finally, I used java.net.URL to get this working", "label": {"api": {"java.net.URL": [[16, 27]]}}}, {"text": "On this object, you can call addActionListener to add a action listener, like you have with a JTextField or a JButton", "label": {"api": {"addActionListener": [[29, 45]]}}}, {"text": "This is caused by the System.currentTimeMillis() granularity", "label": {"api": {"System.currentTimeMillis()": [[22, 47]]}}}, {"text": "The 0=361 was when you were called 10ms later but System.currentTimeMillis() had not kicked over one of it's ticks", "label": {"api": {"System.currentTimeMillis()": [[50, 75]]}}}, {"text": "Considering the comment discussion above, you could create an HttpResponse Wrapper", "label": {"api": {"HttpResponse Wrapper": [[62, 81]]}}}, {"text": "You should be able to do this using Connection.setClientInfo", "label": {"api": {"Connection.setClientInfo": [[36, 59]]}}}, {"text": "There's also the documentation on sleep", "label": {"api": {"sleep": [[34, 38]]}}}, {"text": "Causes the currently executing thread to sleep (temporarily cease execution) ..", "label": {"api": {"sleep": [[41, 45]]}}}, {"text": "See that when Supervisor sleeps, Calculate wakes up and runs to completion, taking 10 seconds, it then calls notify which wakes up Supervisor to continue", "label": {"api": {"sleep": [[25, 29]]}}}, {"text": "You can override the finalize() method (more info) and print out some information there", "label": {"api": {"more info": [[40, 48]]}}}, {"text": "The String argument accepted by Class.getResource is not a file name", "label": {"api": {"Class.getResource": [[32, 48]]}}}, {"text": "If your project is set up correctly, it probably bundles the contents of the res directory into your final .jar file, in which case the correct way to invoke Class.getResource is", "label": {"api": {"Class.getResource": [[158, 174]]}}}, {"text": "Note that although the above would work, you should probably follow java's standards and override Object#equals(Object), handling the notion that a Time instance cannot be equal to an object that isn't a Time instance", "label": {"api": {"Object#equals(Object)": [[98, 118]]}}}, {"text": "Just use replace()", "label": {"api": {"replace()": [[9, 17]]}}}, {"text": "If you are using Java 8 you can do this by using List.sort as follows", "label": {"api": {"List.sort": [[49, 57]]}}}, {"text": "You could always just write buffer.putInt(0, 50)", "label": {"api": {"buffer.putInt(0, 50)": [[28, 47]]}}}, {"text": "The container will propagate the javax.ejb.EJBContext to the thread that executes the asynchronous method", "label": {"api": {"javax.ejb.EJBContext": [[33, 52]]}}}, {"text": "You can inject this EJBContext into your interceptor and stash any state (such as your request scoped bean) that you want into it via javax.ejb.EJBContext.getContextData()", "label": {"api": {"javax.ejb.EJBContext": [[134, 153]], "javax.ejb.EJBContext.getContextData()": [[134, 170]]}}}, {"text": "You could look at a ScheduledThreadPoolExecutor which gets you out of the some of the nitty gritty thread management, which is an easy thing to get wrong as a program grows in complexity", "label": {"api": {"ScheduledThreadPoolExecutor": [[20, 46]]}}}, {"text": "As such, it does not comply anymore with the contract of the functional method of Consumer, which is apply and doesn't declare to throw checked exceptions", "label": {"api": {"Consumer": [[82, 89]], "apply": [[101, 105]]}}}, {"text": "Wrap this into a try-catch, where you can throw an unchecked exception instead UncheckedIOException", "label": {"api": {"UncheckedIOException": [[79, 98]]}}}, {"text": "A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "The contract of compareTo is a bit different", "label": {"api": {"compareTo": [[16, 24]]}}}, {"text": "You must have a Thread object, and even if you have a Thread, isAlive() won't return true unless you've started the Thread with the start method", "label": {"api": {"isAlive()": [[62, 70]]}}}, {"text": "In Java, this is done with Set#removeAll", "label": {"api": {"Set#removeAll": [[27, 39]]}}}, {"text": "Note that both System.out.printf and DecimalFormat use system-default locale for formatting, so you may see unexpectedly 18,56 instead of 18.56 in some countries", "label": {"api": {"DecimalFormat": [[37, 49]]}}}, {"text": "Like someone suggested, consider using a CountdownLatch while starting threads", "label": {"api": {"CountdownLatch": [[41, 54]]}}}, {"text": "Java Strings are Comparables, meaning they have a compareTo method which can be used to compare two such objects", "label": {"api": {"Comparable": [[17, 26]]}}}, {"text": "You can still use Arrays.sort method for this and just provide own customized Comparator", "label": {"api": {"Arrays.sort": [[18, 28]], "Comparator": [[78, 87]]}}}, {"text": "Also, you only read one byte", "label": {"api": {"only read one byte": [[10, 27]]}}}, {"text": "And you probably have issues because you are trying to override the final method .getClass() (so the name here is getMyClass() instead", "label": {"api": {".getClass()": [[81, 91]]}}}, {"text": "From the javadoc of .getClass() you can see that", "label": {"api": {".getClass()": [[20, 30]]}}}, {"text": "getClass is a final method of Object which returns a Class", "label": {"api": {"getClass": [[0, 7]]}}}, {"text": "You are getting that error because the compiler thinks you are trying to override getClass while changing the return type to something that is not a Class", "label": {"api": {"getClass": [[82, 89]]}}}, {"text": "If you want to return a String you will need to change the method name to something else or add parameters to the method so its signature does not match Object#getClass", "label": {"api": {"getClass": [[160, 167]]}}}, {"text": "The number of Unicode blocks defined in the JDK is frighteningly high, and scripts aren't any better", "label": {"api": {"is frighteningly high": [[48, 68]], "aren't any better": [[83, 99]]}}}, {"text": "I could maybe use Character.isLetter() (note, I elected the version with a char, not an int), but I'm sure that even that would be too large..", "label": {"api": {"Character.isLetter()": [[18, 37]]}}}, {"text": "If you're writing to a high-latency system (such as a networked hard drive), you should buffer your output with a BufferedOutputStream", "label": {"api": {"BufferedOutputStream": [[114, 133]]}}}, {"text": "Buffer your input with BufferedInputStream if it helps, though I didn't experience improvement in my test", "label": {"api": {"BufferedInputStream": [[23, 41]]}}}, {"text": "You can do this easily enough with replaceAll, which accepts a regular expression", "label": {"api": {"replaceAll": [[35, 44]]}}}, {"text": "In order to force synchronization between your threads you will have to use some other methods such as wait (with notify) and join", "label": {"api": {"wait": [[103, 106]], "notify": [[114, 119]], "join": [[126, 129]]}}}, {"text": "Another way you could do this is to pass in a Comparator instead of requiring T to be Comparable", "label": {"api": {"Comparator": [[46, 55]]}}}, {"text": "You could also provide a similar method to the other answers to skip writing the Comparator when T is Comparable", "label": {"api": {"Comparator": [[81, 90]]}}}, {"text": "You can ask the DatabaseMetaData to give you information about columns", "label": {"api": {"columns": [[63, 69]]}}}, {"text": "You should box the IntStream to a Stream<Integer>, then call toArray to make a array of it", "label": {"api": {"box": [[11, 13]], "toArray": [[61, 67]]}}}, {"text": "For what you are trying to achieve, you could create a new thread each time, or you could look at an ExecutorService", "label": {"api": {"ExecutorService": [[101, 115]]}}}, {"text": "Just create a single threaded executor (Executors.newSingleThreadExecutor), and submit your runnable to it every time you need it to run", "label": {"api": {"Executors.newSingleThreadExecutor": [[40, 72]]}}}, {"text": "This makes use of the invokeLater() method, which takes a Runnable", "label": {"api": {"invokeLater()": [[22, 34]]}}}, {"text": "To give you a more indepth look at how .equals() works, I recommend reading up on the Java Objects class", "label": {"api": {"the Java Objects class": [[82, 103]]}}}, {"text": "When you have dynamic keys, you can use a Map<K, V>", "label": {"api": {"Map<K, V>": [[42, 50]]}}}, {"text": "You need make StockQuote impement Serializable, because RMI uses Java's serialization mechanism to transmit data (such as method arguments and return value) over the wire", "label": {"api": {"Serializable": [[34, 45]]}}}, {"text": "The diffuseMap used in a PhongMaterial only provides for a single texture image, not a mip-mapped image, and though there are scene aliasing hints that can be applied, that concept differs from texture filtering hints which would be more applicable to your situation", "label": {"api": {"diffuseMap": [[4, 13]]}}}, {"text": "The javadoc for the ObjectOutputStream constructor also notes that you might want to flush the stream after creating it to ensure the header is sent", "label": {"api": {"javadoc for the ObjectOutputStream constructor": [[4, 49]]}}}, {"text": "But i cannot implement class in my project YearMonth which introduced in jdk 1.8", "label": {"api": {"YearMonth": [[43, 51]]}}}, {"text": "Follow these links for more info on Java Sets and Iterators", "label": {"api": {"Sets": [[41, 44]], "Iterators": [[50, 58]]}}}, {"text": "You can use ScheduledExecutorService for this task", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "You can use String.replaceAll(String regex, String replacement) to replace all the dots with an empty string", "label": {"api": {"String.replaceAll(String regex, String replacement)": [[12, 62]]}}}, {"text": "Since you are using the sleep() function, this may throw InterruptedException", "label": {"api": {"InterruptedException": [[57, 76]]}}}, {"text": "For WSDL handling, we can use org.w3c.dom api", "label": {"api": {"org.w3c.dom": [[30, 40]]}}}, {"text": "Use Integer.parseInt to convert your string to an int, then use PreparedStatement#setInt to set it on the statement for insertion", "label": {"api": {"Integer.parseInt": [[4, 19]]}}}, {"text": "Create an abstract class that contains implementations of Action", "label": {"api": {"Action": [[58, 63]]}}}, {"text": "The exact formulation depends on your domain, but EditorKit may serve as an example", "label": {"api": {"EditorKit": [[50, 58]]}}}, {"text": "As suggested here, concrete editor kits \"export useful Action classes that operate on the Document model common to text components.\" More discussion may be found here, here and here", "label": {"api": {"Action": [[55, 60]]}}}, {"text": "What you need is not the .keySet(), but rather the .entrySet()", "label": {"api": {".entrySet()": [[51, 61]]}}}, {"text": "This information is stored in a classes ProtectionDomain", "label": {"api": {"ProtectionDomain": [[40, 55]]}}}, {"text": "Inside the this object, there is a method called getCodeSource() that returns a CodeSource that contains the url of the location it came from", "label": {"api": {"getCodeSource()": [[49, 63]], "CodeSource": [[52, 61], [80, 89]]}}}, {"text": "If your young framework has any hope of working properly, you'll need to fix that (wrap everything in SwingUtilities.invokeLater(Runnable))", "label": {"api": {"SwingUtilities.invokeLater(Runnable)": [[102, 137]]}}}, {"text": "Instead of manually getting the set of keys, how about using the keySet() method on the HashMap object from Java", "label": {"api": {"method": [[74, 79]]}}}, {"text": "For the third bullet, see the size() method", "label": {"api": {"method": [[37, 42]]}}}, {"text": "You should use a PriorityQueue in stead of a TreeSet because that is make for queue's", "label": {"api": {"PriorityQueue": [[17, 29]]}}}, {"text": "Using a PriorityQueue is simple", "label": {"api": {"PriorityQueue": [[8, 20]]}}}, {"text": "Unlike a TreeSet, a PriorityQueue does allow duplicate elements, and gives them back in a FIFO order", "label": {"api": {"PriorityQueue": [[20, 32]]}}}, {"text": "If you need a treadsafe solution, you should use a PriorityBlockingQueue instead", "label": {"api": {"PriorityBlockingQueue": [[51, 71]]}}}, {"text": "You could use the Stream.collect(supplier, accumulator, combiner) method to transform the entries and conditionally accumulate them", "label": {"api": {"Stream.collect(supplier, accumulator, combiner)": [[18, 64]]}}}, {"text": "If you are transforming the values into the same type and want to modify the Map in place this could be alot shorter with replaceAll", "label": {"api": {"replaceAll": [[122, 131]]}}}, {"text": "I don't recommend doing this because It will not work for all valid Map implementations and may stop working for HashMap in the future, but you can currently use replaceAll and cast a HashMap to change the type of the values", "label": {"api": {"replaceAll": [[162, 171]]}}}, {"text": "The equals method in Object compares object references to see if they're identical", "label": {"api": {"equals method in Object": [[4, 26]]}}}, {"text": "You could perform the multiplication before casting - ((int)(Math.random()*size)), but really it'd be easier to use Random.nextInt(int)", "label": {"api": {"Random.nextInt(int)": [[116, 134]]}}}, {"text": "If you want to use a Pane rather than a FlowPane, then Pane has no internal layout, so you need to also set the layoutX and layoutY properties appropriately when you add to the Pane", "label": {"api": {"Pane": [[21, 24], [44, 47], [55, 58], [177, 180]], "FlowPane": [[40, 47]], "layoutX": [[112, 118]], "layoutY": [[124, 130]]}}}, {"text": "If you want to change the rendering order of nodes in the Pane (e.g", "label": {"api": {"Pane": [[58, 61]]}}}, {"text": "You can do it using Collectors", "label": {"api": {"Collectors": [[20, 29]]}}}, {"text": "You can do other cool stuff with Collectors, as explained in its javadoc", "label": {"api": {"Collectors": [[33, 42]]}}}, {"text": "Access in a linked list implementation, like java.util.LinkedList, is O(n)", "label": {"api": {"java.util.LinkedList": [[45, 64]]}}}, {"text": "Contrast that with an array-based list, like java.util.ArrayList", "label": {"api": {"java.util.ArrayList": [[45, 63]]}}}, {"text": "Notice how there is no enum ErrorManager.FILTER_FAILURE so that implies that the behavior is intentional", "label": {"api": {"ErrorManager.FILTER_FAILURE": [[28, 54]]}}}, {"text": "From the Handler.setErrorManager documentation", "label": {"api": {"Handler.setErrorManager": [[9, 31]]}}}, {"text": "If you don't want to use Task, just copy and paste with slight modifications to use the same technique as Task uses (the following code is just a copy and paste from the Task source)", "label": {"api": {"Task": [[25, 28], [106, 109], [170, 173]]}}}, {"text": "If you know that your value is an Integer, then you may wish to use an AtomicInteger rather than an AtomicReference", "label": {"api": {"AtomicInteger": [[71, 83]], "AtomicReference": [[100, 114]]}}}, {"text": "Then, configure the JVM to use it through the standard Java networking properties", "label": {"api": {"Java networking properties": [[55, 80]]}}}, {"text": "Check here https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html for the date and time letter patterns", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[11, 83]]}}}, {"text": "If you want to just discard new tasks when the current thread is busy, you could use a SingleThreadExecutor and configure it to discard any overflow tasks instead of queueing them", "label": {"api": {"discard any overflow tasks": [[128, 153]]}}}, {"text": "You would do that by setting the selection interval through ListSelectionModel.setSelectionInterval()", "label": {"api": {"ListSelectionModel.setSelectionInterval()": [[60, 100]]}}}, {"text": "You can get the selection model by calling JTable.getSelectionModel()", "label": {"api": {"JTable.getSelectionModel()": [[43, 68]]}}}, {"text": "I would count how many times String.indexOf returns a non-negative number", "label": {"api": {"String.indexOf": [[29, 42]]}}}, {"text": "Use the Platform#runLater() static method, which runs the specified Runnable on the JavaFX Application Thread; it could be called from any thread", "label": {"api": {"Platform#runLater()": [[8, 26]]}}}, {"text": "It is all the more important to act this way to detect errors early that, quoting the javadoc (emphasis mine)", "label": {"api": {"quoting the javadoc": [[74, 92]]}}}, {"text": "You can use Stream's filter method, passing a Predicate that ensures that the element doesn't exist in evens", "label": {"api": {"Stream's filter method": [[12, 33]]}}}, {"text": "ArrayList), you don't even need streams, just Collections's removeAll method", "label": {"api": {"Collections's removeAll method": [[46, 75]]}}}, {"text": "Just use a Comparator (assuming you have a getName method that returns the name)", "label": {"api": {"Comparator": [[11, 20]]}}}, {"text": "If you use a java version < 8, use Collections.sort and a anonymus class as Comparator (or use any other way to get a instance of Comparator comparing Animals appropriately)", "label": {"api": {"Comparator": [[76, 85], [130, 139]], "Collections.sort": [[35, 50]]}}}, {"text": "The File class's listFiles method can return its files in any order", "label": {"api": {"File class's listFiles method": [[4, 32]]}}}, {"text": "IntStream.rangeClosed return a IntStream of primitive int", "label": {"api": {"IntStream.rangeClosed": [[0, 20]]}}}, {"text": "Each is mapped to the object Person with mapToObj and collected into a list with Collectors.toList()", "label": {"api": {"mapToObj": [[41, 48]], "Collectors.toList()": [[81, 99]]}}}, {"text": "Just change new Pane() to new StackPane() and add your label to the pane's child list like you do your Polygon", "label": {"api": {"StackPane": [[30, 38]]}}}, {"text": "StackPane is a layout manager that allows you to layer items on top of each other (by default centering the layered items)", "label": {"api": {"StackPane": [[0, 8]]}}}, {"text": "Any collection (or container) class that implements the Iterable interface is eligible for iteration using the \"for-each loop\"", "label": {"api": {"Iterable": [[56, 63]]}}}, {"text": "Perhaps for historic reasons, the Java arrays did not implement the Iterable interface", "label": {"api": {"Iterable": [[68, 75]]}}}, {"text": "In Java 8, the forEach method was added to the Iterable interface as a default method", "label": {"api": {"Iterable": [[47, 54]], "forEach method": [[15, 28]]}}}, {"text": "It appears that code generation would be possible without requiring that arrays implement Iterable", "label": {"api": {"Iterable": [[90, 97]]}}}, {"text": "You need to pass an instance of an anonymous class to the addActionListener() method (it's a listener after all)", "label": {"api": {"ActionListener": [[61, 74]]}}}, {"text": "But, using Java 8, you can use a lambda expression to shorten the code (since ActionListener is a functional interface)", "label": {"api": {"ActionListener": [[78, 91]]}}}, {"text": "You can put System.lineSeparator in your string by concatenating", "label": {"api": {"System.lineSeparator": [[12, 31]]}}}, {"text": "Note that if you are building strings you need to start using StringBuilder to do that, rather than concatenating strings with +=", "label": {"api": {"StringBuilder": [[62, 74]]}}}, {"text": "If you instead use StringBuilder with a suitable capacity, you will not trash the heap", "label": {"api": {"StringBuilder": [[19, 31]], "suitable capacity": [[40, 56]]}}}, {"text": "Instead, this class prepares a buffer of suitable length that gets filled as you append strings to it", "label": {"api": {"append strings": [[81, 94]]}}}, {"text": "When your string is finally built, call StringBuilder.toString to get the string you want", "label": {"api": {"StringBuilder": [[40, 52]], "StringBuilder.toString": [[40, 61]]}}}, {"text": "Just use java.lang.reflect.Array.newInstance", "label": {"api": {"java.lang.reflect.Array.newInstance": [[9, 43]]}}}, {"text": "transitions like a SequentialTransition, a PauseTransition, a custom transition, etc", "label": {"api": {"SequentialTransition": [[19, 38]], "PauseTransition": [[43, 57]]}}}, {"text": "Or you could use an AnimationTimer for that", "label": {"api": {"AnimationTimer": [[20, 33]]}}}, {"text": "As of java8 you can use BufferedReader.lines() to get stream of line which you will have to split, tranform to a list and add to a list of lists", "label": {"api": {"BufferedReader.lines()": [[24, 45]]}}}, {"text": "If you are running in java7 you can use Files.readAllLines to get a list of lines", "label": {"api": {"Files.readAllLines": [[40, 57]]}}}, {"text": "If you know how to run this commands for your needs you can invoke them from Java using java.lang.ProcessBuilder", "label": {"api": {"java.lang.ProcessBuilder": [[88, 111]]}}}, {"text": "You can create an Area from an Ellipse2D that describes the outer circle, and subtract the ellipse that describes the inner circle", "label": {"api": {"Area": [[18, 21]], "Ellipse2D": [[31, 39]], "subtract": [[78, 85]]}}}, {"text": "This way, you will obtain an actual Shape that can either be drawn or filled (and this will only refer to the area that is actually covered by the ring!)", "label": {"api": {"Shape": [[36, 40]], "drawn": [[61, 65]], "filled": [[70, 75]]}}}, {"text": "This allows you, for example, to check whether the ring shape contains a certain point, or to fill it with a Paint that is more than a single color", "label": {"api": {"contains": [[62, 69]], "Paint": [[109, 113]]}}}, {"text": "Here is an example, the relevant part is the createRingShape method", "label": {"api": {"Shape": [[55, 59]]}}}, {"text": "Use an EventFilter and consume the events", "label": {"api": {"EventFilter": [[7, 17]]}}}, {"text": "Using a-b is a shortcut to Integer.compare(a, b) because in the absence of overflow it returns a positive number when a > b, zero when a == b, and a negative number otherwise", "label": {"api": {"Integer.compare": [[27, 41]]}}}, {"text": "However, the subtraction approach breaks down due to overflow when the two numbers are of large magnitude, so one should use Integer.compare instead", "label": {"api": {"Integer.compare": [[125, 139]]}}}, {"text": "I think that the ChangeListener can be considered a subset of EventHandler but it's not true because if you see the ChangeListener documentation you can notice that it doesn't implements the EventHandler interface (the ChangeListener implements the WeakChangeListener and the EventHandler implements the WeakEventHandler); however their use are similar", "label": {"api": {"ChangeListener": [[17, 30], [116, 129], [219, 232], [253, 266]]}}}, {"text": "Instead of calling close(), you can call flush() which flushes this output stream and forces any buffered output bytes to be written out", "label": {"api": {"flush()": [[41, 47]]}}}, {"text": "The best way to do this in JavaFX is to encapsulate the call in a Task", "label": {"api": {"Task": [[66, 69]]}}}, {"text": "It is important to keep in mind that DataOutputStream#writeInt(int) writes the four bytes of an int high to low", "label": {"api": {"DataOutputStream#writeInt(int)": [[37, 66]]}}}, {"text": "From the java.util.logging.Logger.setLevel documentation", "label": {"api": {"java.util.logging.Logger.setLevel": [[9, 41]]}}}, {"text": "Collectors.groupingBy Allows you to reduce a list to a map where the key is some manipulation of the list's element and the value is some aggregate function applied to a manipulation of the element", "label": {"api": {"Collectors.groupingBy": [[0, 20]]}}}, {"text": "and the example makes it clear that it means separate strings for each argument", "label": {"api": {"example": [[8, 14]]}}}, {"text": "I suggest that you look at the example in the javadoc to see how you are supposed to instantiate a ProcessBuilder object", "label": {"api": {"example": [[31, 37]], "the example in the javadoc": [[27, 52]]}}}, {"text": "So you first need to disable auto-commit mode, using Connection.setAutoCommit(false)", "label": {"api": {"Connection.setAutoCommit(false)": [[53, 83]]}}}, {"text": "This transaction can then either be committed using Connection.commit() or rolled back using Connection.rollback()", "label": {"api": {"Connection.commit()": [[52, 70]], "Connection.rollback()": [[93, 113]]}}}, {"text": "Your render method on the JPanel should only update state, and call for a repaint", "label": {"api": {"repaint": [[74, 80]]}}}, {"text": "The painting will be done in paintComponent as a result of the call to repaint", "label": {"api": {"repaint": [[71, 77]], "paintComponent": [[29, 42]]}}}, {"text": "Using Java 8, you don't to write any loop, you can just use String.join(delimiter, elements)", "label": {"api": {"String.join(delimiter, elements)": [[60, 91]]}}}, {"text": "Specify a different column name in Auditorium or use @AttributeOverride in Event to override the default name", "label": {"api": {"@AttributeOverride": [[53, 70]]}}}, {"text": "You can then just use TreeMap.floorEntry() to fetch the relevant Entry", "label": {"api": {"TreeMap.floorEntry()": [[22, 41]], "Entry": [[35, 39], [65, 69]]}}}, {"text": "You want to use Statement.execute(String sql) instead of the way you are executing it now", "label": {"api": {"Statement.execute(String sql)": [[16, 44]]}}}, {"text": "If you have a PreparedStatement on which you execute the SQL, use  PreparedStatement.execute()", "label": {"api": {" PreparedStatement.execute()": [[66, 93]]}}}, {"text": "They're functionally equivalent (save for how they handle the empty-list case), but you get both variants because LinkedList is an implementation of both a queue and a stack (namely Queue and Deque)", "label": {"api": {"Queue": [[182, 186]], "Deque": [[192, 196]]}}}, {"text": "BigDecimal does though", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "Its BigDecimal(String) constructor sets the value and the scale (number of places to the right of the decimal) from a string, so", "label": {"api": {"BigDecimal": [[4, 13]], "BigDecimal(String) constructor": [[4, 33]]}}}, {"text": "BigDecimal then gives you various math operations to stay within that scale, with various rounding options", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "If at some point you need to get the double value of the BigDecimal, you can use its doubleValue method", "label": {"api": {"BigDecimal": [[57, 66]], "doubleValue method": [[85, 102]]}}}, {"text": "Here's an example contrasting BigDecimal and double (Live Copy)", "label": {"api": {"BigDecimal": [[30, 39]]}}}, {"text": "As you didn't state the graphical framework I assume you use Swing, as it contains a doClick function", "label": {"api": {"doClick function": [[85, 100]]}}}, {"text": "This method collects all the unique (hence the Set instead of List) names from a JobList", "label": {"api": {"Set": [[47, 49]]}}}, {"text": "The method returns a Set", "label": {"api": {"Set": [[21, 23]]}}}, {"text": "You can iterate over a Set to get all its elements in turn", "label": {"api": {"Set": [[23, 25]]}}}, {"text": "Although I do not know how to turn those into a Proxy proxy which can then be used in client.SetProxy()", "label": {"api": {"Proxy proxy": [[48, 58]]}}}, {"text": "If you want it to be even faster, you can use a PreparedStatement", "label": {"api": {"PreparedStatement": [[48, 64]]}}}, {"text": "You can also use a Scanner and you won't need intermediate Strings or arrays in the process", "label": {"api": {"Scanner": [[19, 25]]}}}, {"text": "With RandomAccessFile, you can open a file, place the cursor at the place you want and read from it", "label": {"api": {"RandomAccessFile": [[5, 20]]}}}, {"text": "You should use a HashMap", "label": {"api": {"HashMap": [[17, 23]]}}}, {"text": "HashMaps contain pairs of keys and values", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "I have a framework that uses the interface CompletionStage and I'm curious why the helper methods anyOf or allOf found in CompletableFuture are defined there", "label": {"api": {"CompletionStage": [[43, 57]], "CompletableFuture": [[122, 138]]}}}, {"text": "I'm quite dissatisfied with the CompletionStage interface thus far", "label": {"api": {"CompletionStage": [[32, 46]]}}}, {"text": "Are there other Java libraries that are CompletionStage compliant but a different superset interface someone can recommend", "label": {"api": {"CompletionStage": [[40, 54]]}}}, {"text": "Or perhaps some library written with additional helper methods for working with CompletionStage", "label": {"api": {"CompletionStage": [[80, 94]]}}}, {"text": "If all you want, is a method providing the same anyOf and allOf functionality for objects of the type CompletionStage, you can simply resort to toCompletableFuture", "label": {"api": {"toCompletableFuture": [[144, 162]]}}}, {"text": "Use nextLine() if you want to read an entire line", "label": {"api": {"nextLine()": [[4, 13]]}}}, {"text": "There's also hasNextLine() to check if there is another line in the input", "label": {"api": {"hasNextLine()": [[13, 25]]}}}, {"text": "The code will keep listening to incoming message once it is started since it use a ThreadPool (Number of thread in the threadpool = a_numThreads) and each of the thread in the threadpool execute a Consumer (ConsumerTest)", "label": {"api": {"ThreadPool": [[83, 92]]}}}, {"text": "Try the new Date&Time API (java.time) of Java 8 and later", "label": {"api": {"java.time": [[27, 35]]}}}, {"text": "The Scanner class is great for reading user input", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "If you decide to implement it yourself, you can build your own disk-backed Dequeue by implementing a circular buffer on top of a (huge) mmaped file", "label": {"api": {"mmaped file": [[136, 146]]}}}, {"text": "Use Collections.sort(List, Comparator) instead of Collections.sort(List)", "label": {"api": {"Collections.sort(List, Comparator)": [[4, 37]], "Collections.sort(List)": [[50, 71]]}}}, {"text": "How to user Comparator you can check in Comparator API", "label": {"api": {"Comparator API": [[40, 53]]}}}, {"text": "Better use DatatypeConverter, avoid that warnings", "label": {"api": {"DatatypeConverter": [[11, 27]]}}}, {"text": "When DecimalFormat is constructed by using the DecimalFormat(String), it will use the default \"format locale\"", "label": {"api": {"DecimalFormat(String)": [[47, 67]]}}}, {"text": "See the API docs for more details", "label": {"api": {"API docs": [[8, 15]]}}}, {"text": "The API documentation for ClassLoader.getResource(String) claims that it will return null \"if the resource could not be found or the invoker doesn't have adequate privileges to get the resource\"", "label": {"api": {"The API documentation for ClassLoader.getResource(String)": [[0, 56]]}}}, {"text": "CertificateException \"indicates one of a variety of certificate problems\", and is moreover a subclass of GeneralSecurityException-- note the words privileges and security", "label": {"api": {"CertificateException": [[0, 19]], "GeneralSecurityException": [[105, 128]]}}}, {"text": "See ByteArrayOutputStream to create an OutputStream and convert to a String with ByteArrayOutputStream#toString()", "label": {"api": {"ByteArrayOutputStream": [[4, 24], [81, 101]], "OutputStream": [[13, 24], [39, 50], [90, 101]], "ByteArrayOutputStream#toString()": [[81, 112]]}}}, {"text": "Java 8 brought the Stream interface, and with it convenient map/filter/reduce operations on Java collections (and other things that can be turned into a stream)", "label": {"api": {"Stream": [[19, 24]]}}}, {"text": "The drawing in that class would be done in an override of paintComponent", "label": {"api": {"paintComponent": [[58, 71]]}}}, {"text": "You may use toMap collector with custom merge function", "label": {"api": {"toMap": [[12, 16]]}}}, {"text": "JavaSE has XMLFormatter out of the box", "label": {"api": {"XMLFormatter": [[11, 22]]}}}, {"text": "Exceptions that occur inside of the handler should be reported using Handler.reportError(String, Exception, int)", "label": {"api": {"Handler.reportError(String, Exception, int)": [[69, 111]]}}}, {"text": "Use a java.lang.ThreadLocal and some sort of enum to track the state changes", "label": {"api": {"java.lang.ThreadLocal": [[6, 26]]}}}, {"text": "preferably, in this case the best practice will be to return  an Optional object ( in that way you can prevent NullPointerException from your code/api consumer)", "label": {"api": {"Optional": [[65, 72]]}}}, {"text": "String class has the method contains(CharSequence s) that returns true if and only if the string contains the specified sequence of char values", "label": {"api": {"contains(CharSequence s)": [[28, 51]]}}}, {"text": "This method is more efficient than contains(CharSequence s) method of String", "label": {"api": {"contains(CharSequence s)": [[35, 58]]}}}, {"text": "If you take a look at TableModel, it has two methods, getColumnName and getColumnClass, now, you've overrriden getColumnClass, which is find, but internally to DefaultTableModel, it uses the column names you supplied to the constructor and returns them when getColumnName get's called", "label": {"api": {"TableModel": [[22, 31], [167, 176]]}}}, {"text": "So, when JTable#setModel is called, one of things it will do (by default) is call it's createDefaultColumnsFromModel method, this then uses the TableModel to build it's TableColumnModel, using the TableModel#getColumnName method to provide the TableColumn's headerValue property", "label": {"api": {"TableModel": [[144, 153], [197, 206]]}}}, {"text": "See Class Cipher documentation", "label": {"api": {"Class Cipher documentation": [[4, 29]]}}}, {"text": "You can use a Timeline to do this", "label": {"api": {"Timeline": [[14, 21]]}}}, {"text": "You can get the InputStream by using HttpServletRequest.getInputStream() to save the input stream into a data member then pass it on to the S3 SDK", "label": {"api": {"HttpServletRequest": [[37, 54]]}}}, {"text": "If you cast to something that isn't part of your object hierarchy you will get an exception (specifically a ClassCastException) when you run the program", "label": {"api": {"ClassCastException": [[108, 125]]}}}, {"text": "The default number of buckets in a HashMap is 16", "label": {"api": {"The default number of buckets in a HashMap is 16": [[0, 47]]}}}, {"text": "I have an ArrayList<List<String>> that I'm trying to iterate through and print, however, I keep getting a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[106, 136]]}}}, {"text": "Maybe a CopyOnWriteArrayList might be interesting", "label": {"api": {"CopyOnWriteArrayList": [[8, 27]]}}}, {"text": "It appears to me that JAR file indexing breaks the mechanics of ClassLoader.getResources()", "label": {"api": {"ClassLoader.getResources()": [[64, 89]], "getResources": [[76, 87]]}}}, {"text": "Doesn't the contract of getResources imply that all available resources matching the given name should be returned", "label": {"api": {"getResources": [[24, 35]]}}}, {"text": "In this case you want a Consumer", "label": {"api": {"Consumer": [[24, 31]]}}}, {"text": "To know all the parameters sent in a request, use HttpServletRequest#getParameterNames or HttpServletRequest#getParameterMap to evaluate each parameter and its value or values", "label": {"api": {"HttpServletRequest#getParameterNames": [[50, 85]], "HttpServletRequest#getParameterMap": [[90, 123]]}}}, {"text": "It's clear that compareAndSet is an atomic operation", "label": {"api": {"compareAndSet": [[16, 28]]}}}, {"text": "I think the first operation is atomic (but not quite sure because there is an if), and the second one is definitely not atomic because it consists of compareAndSet and a negation", "label": {"api": {"compareAndSet": [[150, 162]]}}}, {"text": "Use the Scanner class", "label": {"api": {"Scanner": [[8, 14]]}}}, {"text": "For the first error, since your table column type is not a String, you cannot use the no-argument version of TextFieldTableCell.forTableColumn()", "label": {"api": {"TextFieldTableCell.forTableColumn()": [[109, 143]]}}}, {"text": "You need to provide a converter, using the overloaded form of TextFieldTableCell.forTableColumn(...)", "label": {"api": {"overloaded form of TextFieldTableCell.forTableColumn(...)": [[43, 99]]}}}, {"text": "A possible solution would be to use a CachedRowSet, which is populated from a ResultSet but can outlive the associated Statement/Connection the ResultSet was produced by", "label": {"api": {"CachedRowSet": [[38, 49]]}}}, {"text": "Java uses a StringTokenizer for parsing the command to arguments in the exec call", "label": {"api": {"StringTokenizer": [[12, 26]], "exec": [[72, 75]]}}}, {"text": "A nicer way to add an ActionListener to an anonymous object can be done by using the double brace initialization syntax noted here", "label": {"api": {"add": [[15, 17]]}}}, {"text": "After searching through the Java API, I found that the add method returns the component being added", "label": {"api": {"add": [[55, 57], [94, 96]]}}}, {"text": "But you can get the added object like this", "label": {"api": {"add": [[20, 22]]}}}, {"text": "Read about class Pattern", "label": {"api": {"Pattern": [[17, 23]]}}}, {"text": "Then, since no match was made, sc.match() throws an IllegalStateException", "label": {"api": {"sc.match()": [[31, 40]]}}}, {"text": "You can use a BigInteger", "label": {"api": {"BigInteger": [[14, 23]]}}}, {"text": "This creates a Biginteger from the input String in base 2 (new BigInteger(val, radix)) and returns its bit count (bitCount())", "label": {"api": {"BigInteger": [[63, 72]], "new BigInteger(val, radix)": [[59, 84]], "bitCount()": [[114, 123]]}}}, {"text": "I successfully utilized javax.transaction.Synchronization which can be registered with the transaction and receives correct status", "label": {"api": {"javax.transaction.Synchronization": [[24, 56]]}}}, {"text": "You have replaced the table's default renderer, which knows how to render an Icon, with an instance of DefaultTableCellRenderer, which does not", "label": {"api": {"DefaultTableCellRenderer": [[103, 126]]}}}, {"text": "Remove the while block, and change the PublicationArray fron an array into an ArrayList", "label": {"api": {"ArrayList": [[78, 86]]}}}, {"text": "Read in the Image using the class java.awt.image.BufferedImage like this", "label": {"api": {"java.awt.image.BufferedImage": [[34, 61]]}}}, {"text": "Look at the Pattern class", "label": {"api": {"Pattern": [[12, 18]]}}}, {"text": "It uses the rules for double literals in Java source code, which 99% is not how you want your program to be fed (it allows exponents, hexadecimals and whatnot)", "label": {"api": {"in Java source code": [[38, 56]]}}}, {"text": "If the input comes from a human you'd better use DecimalFormat that is locale-aware and can be easily customized (it even offers control over rounding mode)", "label": {"api": {"DecimalFormat": [[49, 61]]}}}, {"text": "From a DecimalFormat you can get an Integer, a Number or a BigDecimal, depending on what that quantity describes and how you plan to use it", "label": {"api": {"DecimalFormat": [[7, 19]]}}}, {"text": "The new java.time-library (JSR-310) does force the user to code against exceptions - a clear regression compared with 'SimpleDateFormat`", "label": {"api": {"does force the user to code against exceptions": [[36, 81]]}}}, {"text": "From the documentation of the Logger class", "label": {"api": {"documentation of the Logger class": [[9, 41]]}}}, {"text": "I'd suggest using Matcher#replaceAll() for this", "label": {"api": {"Matcher#replaceAll()": [[18, 37]]}}}, {"text": "See java.nio.ShortBuffer and start digging from there", "label": {"api": {"java.nio.ShortBuffer": [[4, 23]]}}}, {"text": "How to fix depends on a number of factors, for example, you could use a ComponentListener and listen for componentResized events, but do you want to know about all the size events", "label": {"api": {"ComponentListener": [[72, 88]]}}}, {"text": "You create a new map from the first map, iterate over the second map and merge each key with the first map thanks to merge(key, value, remappingFunction)", "label": {"api": {"merge(key, value, remappingFunction)": [[117, 152]]}}}, {"text": "Technically speaking, BiFunction does not declare throwing any checked Exception", "label": {"api": {"BiFunction": [[22, 31]]}}}, {"text": "Instead you are usually expected to use unchecked exceptions and handle them in a way, specific for particular promise library (see documentation of CompletionStage for details on it's exception handling facilities)", "label": {"api": {"CompletionStage": [[149, 163]]}}}, {"text": "Use printf() or String.format(), or the underlying Formatter", "label": {"api": {"printf()": [[4, 11]], "String.format()": [[16, 30]], "Formatter": [[51, 59]]}}}, {"text": "This uses the map's keySet().stream() and values().stream() to get a stream of both, then connects them using Stream.concat, then finally turns it into a set", "label": {"api": {"Stream.concat": [[110, 122]]}}}, {"text": "An easy solution, which will also result in more efficient and more elegant code is to use String.charAt(), rather than splitting the original string to a lot of small String objects, and iterate from 0 to a.length for each character in the string", "label": {"api": {"String.charAt()": [[91, 105]]}}}, {"text": "You can simplify the access by using the wrapper classes such as AtomicLong", "label": {"api": {"AtomicLong": [[65, 74]]}}}, {"text": "See Timeline for more information", "label": {"api": {"Timeline": [[4, 11]]}}}, {"text": "I'm not sure what is going wrong without seeing the code, but since Java SE 7 the recommended way to move/ rename files is Files.move (NIO.2 File API)", "label": {"api": {"Files.move": [[123, 132]]}}}, {"text": "If you do want to be able to run multiple instances of the test class in parallel then you'll need to use something like a ThreadLocal<T>", "label": {"api": {"ThreadLocal<T>": [[123, 136]]}}}, {"text": "Also for hasNext()", "label": {"api": {"hasNext()": [[9, 17]]}}}, {"text": "As long as nothing of those things happen, hasNext() method doesn't return, so the condition in while is still not evaluated, so the loop is blocked there", "label": {"api": {"hasNext()": [[43, 51]]}}}, {"text": "From the Javadoc of createTempFile (emphasis mine)", "label": {"api": {"createTempFile": [[20, 33]]}}}, {"text": "Instead, you should just create a new file with Files.createFile(path) from Java NIO.2 API, or File#createNewFile() otherwise", "label": {"api": {"Files.createFile(path)": [[48, 69]], "File#createNewFile()": [[95, 114]]}}}, {"text": "java.lang.Math docs say for many functions, such as Math.pow", "label": {"api": {"Math.pow": [[52, 59]]}}}, {"text": "For example, can we rely on Math.pow(3.0, 2.0) == 9.0", "label": {"api": {"Math.pow": [[28, 35]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/net/URLEncoder.html for reference", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/net/URLEncoder.html": [[4, 69]]}}}, {"text": "You may also avoid a regex and use the class Character.UnicodeBlock", "label": {"api": {"Character.UnicodeBlock": [[45, 66]]}}}, {"text": "If you want to have something run when Tomcat starts, take a look at ServletContextListener", "label": {"api": {"ServletContextListener": [[69, 90]]}}}, {"text": "If you are just initializing the DB then ServletContextListener will allow that", "label": {"api": {"ServletContextListener": [[41, 62]]}}}, {"text": "But after that, don't use the ServletContextListener to also hand out database connections", "label": {"api": {"ServletContextListener": [[30, 51]]}}}, {"text": "You may be interested in the following code that looks for a normalized string inside a larger normalized string using a java.text.Normalizer", "label": {"api": {"java.text.Normalizer": [[121, 140]]}}}, {"text": "The Javadocs for this method state", "label": {"api": {"Javadocs for this method": [[4, 27]]}}}, {"text": "If you started the other program using ProcessBuilder, then you might be able to send the control sequence by writing the appropriate bytes to the process's input stream", "label": {"api": {"ProcessBuilder": [[39, 52]]}}}, {"text": "convertedArray[i] = UnitRepository.getUnitName(units3[i].trim()); where trim() will remove any extra whitepsace around the value, which should make the unit name to resolve correctly", "label": {"api": {"trim()": [[57, 62], [72, 77]]}}}, {"text": "That is because you are using the toString method which states that", "label": {"api": {"toString method": [[34, 48]]}}}, {"text": "You will need to use LocalDate.format method like this", "label": {"api": {"LocalDate.format method": [[21, 43]]}}}, {"text": "You can use SimpleDateFormat class for that purposes", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "Initialize SimpleDateFormat object with date format that you want as a parameter", "label": {"api": {"SimpleDateFormat": [[11, 26]]}}}, {"text": "Java is full of concepts that are considered bad idea nowadays but haven't been removed nevertheless - some more examples that come to my mind are clone() or Thread.stop()", "label": {"api": {"Thread.stop()": [[158, 170]]}}}, {"text": "Your student has a name (which is just plain text), and a series of answers (you can use an array, though the Java List API is generally easier to work with)", "label": {"api": {"Java List API": [[110, 122]]}}}, {"text": "If you still need the ability to sort students, for example, based on their performance on the quiz, you can use a Comparator", "label": {"api": {"Comparator": [[115, 124]]}}}, {"text": "You could also have your Student class implement the Comparable interface, in order to sort students by name", "label": {"api": {"Comparable": [[53, 62]]}}}, {"text": "If you want a list that allows you to add new elements, you should use a ArrayList", "label": {"api": {"ArrayList": [[73, 81]]}}}, {"text": "Collections class, which consists entirely of static methods operating on various collection interfaces", "label": {"api": {"Collections": [[0, 10]]}}}, {"text": "This may be particularly useful information when inlining the method call when it's called with a constant value, such as in the implementation of listIterator() (with no parameters), which is simply", "label": {"api": {"listIterator()": [[147, 160]]}}}, {"text": "The best approach is to use Joda-Time for Java 7 and earlier, and use the new java.time package for Java 8+", "label": {"api": {"java.time": [[78, 86]]}}}, {"text": "My question is, there must be a system clock that keeps going despite the device being asleep, how can I let the executor scheduler use that clock instead of the one it's using now which respects the device going to deep sleep and pauses ticking", "label": {"api": {"executor scheduler": [[113, 130]]}}}, {"text": "System.exit(int) is used to terminate the running JVM and returns 0 to the parent process", "label": {"api": {"System.exit(int)": [[0, 15]]}}}, {"text": "The docs of System.exit say (boldface mine)", "label": {"api": {"System.exit": [[12, 22]]}}}, {"text": "In that case using System.exit is perfectly fine", "label": {"api": {"System.exit": [[19, 29]]}}}, {"text": "Here's a solution that minimizes code duplication by avoiding the System.out.print/ln calls within the loop and instead storing the character values inside a StringBuilder, value of which is then printed before the program exits", "label": {"api": {"StringBuilder": [[158, 170]]}}}, {"text": "As per the oracle documentation, System.nanoTime() is not related to clock", "label": {"api": {"oracle documentation": [[11, 30]]}}}, {"text": "createNewFile takes 0 arguments, not 1", "label": {"api": {"createNewFile": [[0, 12]]}}}, {"text": "As per PrintWriter The PrintWriter(Writer) constructor Creates a new PrintWriter, without automatic line flushing", "label": {"api": {"PrintWriter": [[7, 17], [23, 33], [69, 79]], "PrintWriter(Writer)": [[23, 41]]}}}, {"text": "So either you require to call out.flush() before out.close() or for creating PrintWriter use this contrustor, with which your can specify 'true' to autoFlush parameter", "label": {"api": {"PrintWriter": [[77, 87]]}}}, {"text": "An application may get these parameters using the getParameters() method", "label": {"api": {"getParameters()": [[50, 64]]}}}, {"text": "nextInt is a method, not a data member - it should be called with parentheses", "label": {"api": {"nextInt": [[0, 6]]}}}, {"text": "Since a Collection is unindexed, the only remove method its interface exposes is Collection.remove(Object o), which removes the specified equal object", "label": {"api": {"Collection.remove(Object o)": [[81, 107]]}}}, {"text": "Doing col.remove(1); first calls Integer.valueOf(1) to get an Integer object, then asks the list to remove that object", "label": {"api": {"Integer.valueOf(1)": [[33, 50]]}}}, {"text": "When col's compile-time type is ArrayList, calling col.remove(1); instead invokes the method ArrayList.remove(int index) to remove the element at the specified position, thus removing b", "label": {"api": {"ArrayList.remove(int index)": [[93, 119]]}}}, {"text": "From the ArrayList documentation", "label": {"api": {"ArrayList documentation": [[9, 31]]}}}, {"text": "Reviewing Java 8 Stream API design, I was surprised by the generic invariance on the Stream.reduce() arguments", "label": {"api": {"Stream.reduce()": [[85, 99]]}}}, {"text": "Well if you looked at the documentation of JOptionPane you could have seen", "label": {"api": {"documentation of JOptionPane": [[26, 53]]}}}, {"text": "public Object[] getSelectionValues()", "label": {"api": {"public Object[] getSelectionValues()": [[0, 35]]}}}, {"text": "And public Object getValue()", "label": {"api": {"public Object getValue()": [[4, 27]]}}}, {"text": "Imagine you're now inserting objects of type Double and Long, and later you try to use Long#reverse", "label": {"api": {"Long#reverse": [[87, 98]]}}}, {"text": "You can use an ExecutorService", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "Then don't forget to shutdown()", "label": {"api": {"shutdown()": [[21, 30]]}}}, {"text": "Your download is executed in another Thread, this causes data to be downloaded simultaneously", "label": {"api": {"Thread": [[37, 42]]}}}, {"text": "The Thread management is delegated to SwingWorker, the class extended by DownloadTask", "label": {"api": {"Thread": [[4, 9]]}}}, {"text": "Your class should use Files.readAllLines() directly, avoid using arrays directly in favor of full list options and look something like this", "label": {"api": {"Files.readAllLines()": [[22, 41]]}}}, {"text": "A DefaultTableCellRenderer instance uses a template component to render all cells (namely itself, see documentation)", "label": {"api": {"DefaultTableCellRenderer": [[2, 25]]}}}, {"text": "Use JTable.convertRowIndexToModel and JTable.convertColumnIndexToModel to do that", "label": {"api": {"JTable.convertRowIndexToModel": [[4, 32]], "JTable.convertColumnIndexToModel": [[38, 69]]}}}, {"text": "Whenever you want to get a Map<…, List<…>> from a stream, you should first check, how the groupingBy collector fits in", "label": {"api": {"groupingBy collector": [[90, 109]]}}}, {"text": "Since you want the prefix \"foo:\" prepended, you’ll have to customize this group collector by inserting a mapping operation before collecting the items into a list", "label": {"api": {"customize this group collector": [[59, 88]], "mapping operation": [[105, 121]], "collecting the items into a list": [[130, 161]]}}}, {"text": "You should use this method instead", "label": {"api": {"this method": [[15, 25]]}}}, {"text": "For example, you don't need to read the whole file into memory, just use Files.lines to get a Stream<String> with every line in the file", "label": {"api": {"Files.lines": [[73, 83]]}}}, {"text": "The reducing (squashing) the several UserObject instances with the same primary id into a single instance (per Collectors.reducing) so that in the end you actually get a Map<Integer,UserObject>", "label": {"api": {"Collectors.reducing": [[111, 129]]}}}, {"text": "For completeness sake, using Java 8 you could achieve this with help of IntStream", "label": {"api": {"IntStream": [[72, 80]]}}}, {"text": "You should probably use it instead of LocalDateTime, since that LocalDateTime does not have a time zone", "label": {"api": {"LocalDateTime": [[38, 50], [64, 76]]}}}, {"text": "And then, ZonedDateTime docs states that", "label": {"api": {"ZonedDateTime docs states that": [[10, 39]]}}}, {"text": "This class handles conversion from the local time-line of LocalDateTime to the instant time-line of Instant", "label": {"api": {"LocalDateTime": [[58, 70]]}}}, {"text": "That happens because you are using the default toString method of ZonedDateTime and looks like the DateTimeFormatter.ISO_OFFSET_DATE_TIME is exactly what you want", "label": {"api": {"default toString method of ZonedDateTime": [[39, 78]], "DateTimeFormatter.ISO_OFFSET_DATE_TIME": [[99, 136]]}}}, {"text": "You could then have Person implement the Comparable interface, e.g", "label": {"api": {"Comparable": [[41, 50]]}}}, {"text": "Now that the ordering of a Person would be defined based on the dateTime attribute, sorting a List<Person> myPersonList in ascending datetime order is as simple as Collections.sort(myPersonList) and sorting by descending order as simple as Collections.sort(myPersonList, Collections.reverseOrder())", "label": {"api": {"Collections.sort(myPersonList)": [[164, 193]]}}}, {"text": "Alternatively, the quick-and-dirty solution to the problem is to create a custom Comparator, which would allow you to order a list of List<String> myStringList based on the datetime token (in index 5, when split by the _ delimiter) of each element", "label": {"api": {"Comparator": [[81, 90]]}}}, {"text": "With Comparator<String> myComparator = new UserInfoDateTimeComparator(), myStringList can be sorted through Collections.sort(myStringList, myComparator) in ascending datetime order and through Collections.sort(myStringList, Collections.reverseOrder(myComparator)) in descending order", "label": {"api": {"Comparator": [[5, 14], [26, 35], [59, 68], [141, 150], [251, 260]], "Collections.sort(myStringList, myComparator)": [[108, 151]]}}}, {"text": "One solution that I could suggest is using Proxy objects", "label": {"api": {"Proxy": [[43, 47]]}}}, {"text": "The Arrays class contains various methods for manipulating arrays, including the static stream() method which returns a sequential Stream with the specified array as its source", "label": {"api": {"Arrays": [[4, 9]], "stream()": [[88, 95]], "Stream": [[131, 136]]}}}, {"text": "You have to use @JoinColumn for association columns", "label": {"api": {"@JoinColumn": [[16, 26]]}}}, {"text": "If you're already on Java 7+, better yet is to let your context implement AutoCloseable whereby close() invokes remove() and then use a try-with-resources block", "label": {"api": {"AutoCloseable": [[74, 86]]}}}, {"text": "I have a Delegate that instanciate the corresponding Bean sending credentials (Josso Authentication) through InitialContext as shown here", "label": {"api": {"as shown here": [[124, 136]]}}}, {"text": "You can use Java's WatchService to watch a directory for changes", "label": {"api": {"WatchService": [[19, 30]]}}}, {"text": "The direct solution would be to invoke ifPresent(consumer) on the Optional returned by findFirst()", "label": {"api": {"ifPresent(consumer)": [[39, 57]], "findFirst()": [[87, 97]]}}}, {"text": "But note that the remove(Object) operation will again traverse the list to find the element to remove", "label": {"api": {"remove(Object)": [[18, 31]]}}}, {"text": "With this solution, the remove(int) operation operates directly on the index", "label": {"api": {"remove(int)": [[24, 34]]}}}, {"text": "The hashCode of List implementations is defined in terms of the hashCode of its elements", "label": {"api": {"defined in terms of the hashCode of its elements": [[40, 87]]}}}, {"text": "You seem to be assuming that it uses the default hashCode of Object, which is not the case", "label": {"api": {"default hashCode": [[41, 56]]}}}, {"text": "Additionally, even if ArrayList did not implement hashCode, the default hash code (also known as the identity hash code) of an ArrayList would not change if the internal array was re-allocated, as the ArrayList object itself stays the same, just the internal array object (that you don't get direct access to) will be replaced with a new one", "label": {"api": {"identity hash code": [[101, 118]]}}}, {"text": "String.format returns a String as per the docs", "label": {"api": {"String.format": [[0, 12]]}}}, {"text": "See the PasswordCallback from JAAS that uses this mechanism", "label": {"api": {"PasswordCallback": [[8, 23]]}}}, {"text": "If you need to specify endianness, or anything about the charset for that matter, you should use getBytes(Charset) or getBytes(String)", "label": {"api": {"getBytes(Charset)": [[97, 113]], "getBytes(String)": [[118, 133]]}}}, {"text": "There are a few standard charsets that all JREs support — including UTF_16BE (big endian) and UTF_16LE (little endian)", "label": {"api": {"few standard charsets": [[12, 32]]}}}, {"text": "What about a TreeSet", "label": {"api": {"TreeSet": [[13, 19]]}}}, {"text": "You may need to use the constructor with a Comparator", "label": {"api": {"constructor with a Comparator": [[24, 52]]}}}, {"text": "However, standard Java does have a class in the runtime library which contains all of the Java keywords - the SourceVersion enum in the javax.lang.model package", "label": {"api": {"SourceVersion enum in the javax.lang.model package": [[110, 159]]}}}, {"text": "This is what DataOutputStream # writeDouble does", "label": {"api": {"DataOutputStream": [[13, 28]], "writeDouble": [[32, 42]]}}}, {"text": "A Java >= 7 buffered solution which will take care of closing resources using a try-with-resources block", "label": {"api": {"buffered": [[12, 19]], "closing": [[54, 60]]}}}, {"text": "If you always want the ceil value, you could use Math.ceil", "label": {"api": {"Math.ceil": [[49, 57]]}}}, {"text": "You might want to use a Scanner object instead of BufferedReader", "label": {"api": {"Scanner": [[24, 30]]}}}, {"text": "You could also store the ticket numbers in an ArrayList constructed like this", "label": {"api": {"ArrayList": [[46, 54]]}}}, {"text": "Using a DateTimeFormatterBuilder, you can append the wanted pattern with the time part in an optional section, i.e", "label": {"api": {"DateTimeFormatterBuilder": [[8, 31]]}}}, {"text": "The OFFSET_SECONDS field to 0 represents no offset from UTC", "label": {"api": {"OFFSET_SECONDS": [[4, 17]]}}}, {"text": "The constructor for File taking a URI assumes it gets a file", "label": {"api": {"constructor for File taking a URI": [[4, 36]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/lang/String.html for more help", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[4, 66]]}}}, {"text": "Why does Collections.sort(List<T>) have the signature", "label": {"api": {"Collections.sort(List<T>)": [[9, 33]]}}}, {"text": "As you have already recognized, the behaviour of java.util.Date.toString() is based on TimeZone.getDefault()", "label": {"api": {"TimeZone.getDefault()": [[87, 107]]}}}, {"text": "I am parsing MS SQL date with java.text.SimpleDateFormat but it is giving me wrong output", "label": {"api": {"SimpleDateFormat": [[40, 55]]}}}, {"text": "According to the documentation of SimpleDateFormat, it should parse correctly or may be I am missing something", "label": {"api": {"SimpleDateFormat": [[34, 49]]}}}, {"text": "Within DateTimeFormatter, the S format specifier does mean \"fraction-of-second\"", "label": {"api": {"DateTimeFormatter": [[7, 23]]}}}, {"text": "You should use the Collection.removeIf(predicate) method", "label": {"api": {"Collection.removeIf(predicate)": [[19, 48]]}}}, {"text": "You can use addAll() of Collections", "label": {"api": {"addAll()": [[12, 19]]}}}, {"text": "As an example look at the API doc for classes in the java.util.concurrent packages, like BlockingQueue, see how methods like put and offer throw InterruptedException", "label": {"api": {"BlockingQueue": [[89, 101]]}}}, {"text": "Then you might use a BufferedReader to read the lines", "label": {"api": {"BufferedReader": [[21, 34]]}}}, {"text": "If you are using Java 8, then the OffsetTime may come in handy for a few reasons", "label": {"api": {"OffsetTime": [[34, 43]]}}}, {"text": "And you can compare to other time objects using the method isBefore", "label": {"api": {"isBefore": [[59, 66]]}}}, {"text": "If the date should be considered, then you can use OffsetDateTime", "label": {"api": {"OffsetDateTime": [[51, 64]]}}}, {"text": "But you can create a ServletContextListener which is loaded at application startup before any filter or servlet, initialize your variables in the listener, and let your serlvets and filters then use the already initialized variables", "label": {"api": {"ServletContextListener": [[21, 42]]}}}, {"text": "In the Java crypto libraries, there are two different representations of a key - Key and KeySpec", "label": {"api": {"Key": [[81, 83], [89, 91]], "KeySpec": [[89, 95]]}}}, {"text": "The docs imply there's a difference between the two - a KeySpec is 'transparent' (whatever that means), but has no methods, whereas Key has got a getEncoded method", "label": {"api": {"Key": [[56, 58], [132, 134]], "KeySpec": [[56, 62]]}}}, {"text": "You're meant to use a KeyFactory to convert between the two (and it indeed has got a getKeySpec method to convert)", "label": {"api": {"Key": [[22, 24], [88, 90]], "KeySpec": [[88, 94]], "KeyFactory": [[22, 31]]}}}, {"text": "However, SecretKeySpec implements both Key and KeySpec", "label": {"api": {"Key": [[15, 17], [39, 41], [47, 49]], "KeySpec": [[15, 21], [47, 53]]}}}, {"text": "But there is a SecretKeyFactory class as well, that doesn't inherit off KeyFactory", "label": {"api": {"Key": [[21, 23], [72, 74]], "KeyFactory": [[21, 30], [72, 81]]}}}, {"text": "What's the different between a Key and a KeySpec, and how does SecretKeySpec and SecretKeyFactory come into it", "label": {"api": {"Key": [[31, 33], [41, 43], [69, 71], [87, 89]], "KeySpec": [[41, 47], [69, 75]], "KeyFactory": [[87, 96]]}}}, {"text": "It looks like double.TryParse is what is ultimately used when Json.NET parses a number to double and Double.parseDouble is what is ultimately used when Jackson ObjectMapper parses a number to double", "label": {"api": {"Double.parseDouble": [[101, 118]]}}}, {"text": "Can I expect Microsoft's double.TryParse and Java's Double.parseDouble to agree exactly on the value of every JSON number", "label": {"api": {"Double.parseDouble": [[52, 69]]}}}, {"text": "I would suggest to use ExecutorService instead of creating threads by hand, more specifically Executors.newFixedThreadPool", "label": {"api": {"ExecutorService": [[23, 37]], "Executors.newFixedThreadPool": [[94, 121]]}}}, {"text": "On other hand, in your current code, replace synchronized block and incrementing of static variable with AtomicInteger", "label": {"api": {"AtomicInteger": [[105, 117]]}}}, {"text": "In spare time, take a look at java.util.concurrent package, it contains lots of great stuff usable for multithreading", "label": {"api": {"java.util.concurrent": [[30, 49]]}}}, {"text": "The Possible solution is define area as a array or list(if size is unknown), Store values in array and display it", "label": {"api": {"list": [[51, 54]]}}}, {"text": "There's a link to Java Filesystem glob patterns , which in turn links to getPathMatcher(String), that lists all the globbing options", "label": {"api": {"getPathMatcher(String)": [[73, 94]]}}}, {"text": "You can use Objects::nonNull from the Java8 SDK", "label": {"api": {"Objects::nonNull": [[12, 27]]}}}, {"text": "I know I can use the Invocable class to invoke methods on a class", "label": {"api": {"Invocable": [[21, 29]]}}}, {"text": "You can use StringTokenizer class for parsing data", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "Having said that, take a look at ScheduledExecutorService specifically at the scheduleAtFixedRate method", "label": {"api": {"ScheduledExecutorService": [[33, 56]]}}}, {"text": "I highly recommend browsing the javadocs for the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[49, 68]]}}}, {"text": "Take a look at java.io.RandomAccessFile.seek()", "label": {"api": {"java.io.RandomAccessFile.seek()": [[15, 45]]}}}, {"text": "You can set the position in the file for a FileInputStream using FileChannel.position(long) of it's FileChannel", "label": {"api": {"FileChannel.position(long)": [[65, 90]], "it's FileChannel": [[95, 110]]}}}, {"text": "You can use allMatch(predicate) to determine if all deals of an option are red", "label": {"api": {"allMatch(predicate)": [[12, 30]]}}}, {"text": "TreeMap provides the navigableKeySet() method which returns a NavigableSet which provides a descendingIterator()", "label": {"api": {"TreeMap": [[0, 6]], "navigableKeySet()": [[21, 37]], "NavigableSet": [[62, 73]], "descendingIterator()": [[92, 111]]}}}, {"text": "You can use a list of matrix parameters, represented by the @MatrixParam annotation, as following", "label": {"api": {"@MatrixParam": [[60, 71]]}}}, {"text": "Have you tried using a FileWriter with append mode", "label": {"api": {"FileWriter": [[23, 32]]}}}, {"text": "For example in case of TreeSet, iterators are fail-fast, therefore adding elements while iterating will trigger a ConcurrentModificationException", "label": {"api": {"TreeSet": [[23, 29]]}}}, {"text": "From the JavaDoc of TreeSet", "label": {"api": {"TreeSet": [[20, 26]]}}}, {"text": "However, more fundamentally, Collection.add (and Set.add) is documented as an optional operation, so we can never rely upon a call to SortedSet.add being safe, whether in the context an ongoing iteration or not", "label": {"api": {"Collection.add": [[29, 42]], "Set.add": [[49, 55], [140, 146]]}}}, {"text": "For instance, calling add on a SortedSet returned by Collections.unmodifiableSortedSet or a Guava ImmutableSortedSet would result in an UnsupportedOperationException", "label": {"api": {"Collections.unmodifiableSortedSet": [[53, 85]]}}}, {"text": "I've done some googling and reading through http://docs.oracle.com/javaee/6/api/javax/persistence/Query.html and haven't found an easy way to do what I'm looking to do", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/Query.html": [[44, 107]]}}}, {"text": "The constructor for Scanner that takes a String parameter does not do what you think it does", "label": {"api": {"Scanner": [[20, 26]]}}}, {"text": "Read the javadoc on the Scanner API", "label": {"api": {"Scanner": [[24, 30]]}}}, {"text": "I have looked at CriteriaBuilder.least(..) and greatest(..), but am having a difficult time trying to understand how to create the Expression<T> to pass to either function", "label": {"api": {"CriteriaBuilder.least(..)": [[17, 41]], "greatest(..)": [[47, 58]]}}}, {"text": "This could be achieved easily using stream API", "label": {"api": {"stream API": [[36, 45]]}}}, {"text": "In java 8 the compute method was added to the Map interface", "label": {"api": {"compute": [[14, 20]]}}}, {"text": "The lambda expression passed as second parameter to compute receives the old value the key was mapped to as second parameter or null, if there was no mapping", "label": {"api": {"compute": [[52, 58]]}}}, {"text": "You could also consider using an ExecutorService with a fixed number of threads, and submit the jobs to this executor service", "label": {"api": {"ExecutorService": [[33, 47]]}}}, {"text": "I though of doing something like return t.equals(URI_LIST_TYPE), but I don't know how to get an instance of Type that represents List<URI>", "label": {"api": {"Type": [[108, 111]]}}}, {"text": "You can implement your pojo to use a map as container for all your properties", "label": {"api": {"properties": [[67, 76]]}}}, {"text": "Or you directly use the built-in java properties", "label": {"api": {"properties": [[38, 47]]}}}, {"text": "JTable.getRowCount returns the number of rows in the view, not the model", "label": {"api": {"JTable.getRowCount": [[0, 17]]}}}, {"text": "You need to convert view indices to model indices and vice versa using the JTable.convertRowIndexToView and JTable.convertRowIndexToModel", "label": {"api": {"JTable.convertRowIndexToView": [[75, 102]], "JTable.convertRowIndexToModel": [[108, 136]]}}}, {"text": "Look into JTable.convertColumnIndexToView and JTable.convertColumnIndexToModel", "label": {"api": {"JTable.convertColumnIndexToView": [[10, 40]], "JTable.convertColumnIndexToModel": [[46, 77]]}}}, {"text": "Look up the value using model.getValueAt()", "label": {"api": {"model.getValueAt()": [[24, 41]]}}}, {"text": "Delete the row with model.removeRow(), afterwards decrement your loop variable (eg model.removeRow(i--);)", "label": {"api": {"model.removeRow()": [[20, 36]]}}}, {"text": "Iterate the model's dataVector to find the rows to delete, and delete them using Iterator.remove", "label": {"api": {"dataVector": [[20, 29]], "Iterator.remove": [[81, 95]]}}}, {"text": "After your loop, call fireTableChanged on your model", "label": {"api": {"fireTableChanged": [[22, 37]]}}}, {"text": "Servlet Context, the the meaning of ServletContext class, is the application-wide context a Servlet webapp has", "label": {"api": {"ServletContext": [[36, 49]]}}}, {"text": "You can achieve that using a GridLayout", "label": {"api": {"GridLayout": [[29, 38]]}}}, {"text": "assign a GridLayout to panelButton with two rows and one column, and then add the two panels to it", "label": {"api": {"GridLayout": [[9, 18]]}}}, {"text": "Now you can test the second method and pass a a fixed clock - no need to use a mocking framework", "label": {"api": {"a fixed clock": [[46, 58]]}}}, {"text": "You can serialize your GcsOutputChannel using any Java serialization means (typically using ObjectOutputStream)", "label": {"api": {"ObjectOutputStream": [[92, 109]]}}}, {"text": "The readObject method (https://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#readObject()) is what you want, you just need to cast the RESULT to the class you expect", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#readObject()": [[23, 107]]}}}, {"text": "This is an implementation using JSR-310", "label": {"api": {"JSR-310": [[32, 38]]}}}, {"text": "You can achieve that with your Scanner by using the useDelimiter method", "label": {"api": {"Scanner": [[31, 37]], "useDelimiter": [[52, 63]]}}}, {"text": "This matches the printf method signature, which takes in the format String first, followed by any number of Object variable parameters", "label": {"api": {"printf method signature": [[17, 39]]}}}, {"text": "In your case, using the index variant  getInt(int) would be the easiest", "label": {"api": {"getInt(int)": [[39, 49]]}}}, {"text": "The following snippet parses the Scanner input line by line adding to the list", "label": {"api": {"Scanner": [[33, 39]]}}}, {"text": "From the documentation for GridLayout", "label": {"api": {"documentation for GridLayout": [[9, 36]]}}}, {"text": "You might want to take a look at the new CompletableFuture facility", "label": {"api": {"CompletableFuture": [[41, 57]]}}}, {"text": "Java 8 ConcurrentHashMap.keySet() returns a KeySetView<K, V> while in Java 7 it returns a Set<K> (where K maps a key and V maps the value)", "label": {"api": {"ConcurrentHashMap.keySet()": [[7, 32]], "KeySetView<K, V>": [[44, 59]], "Set<K>": [[90, 95]]}}}, {"text": "From the JavaDoc of the java.awt.print.Printable (https://docs.oracle.com/javase/7/docs/api/java/awt/print/Printable.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/awt/print/Printable.html": [[50, 120]]}}}, {"text": "From getPathMatcher documentation", "label": {"api": {"getPathMatcher": [[5, 18]]}}}, {"text": "https://docs.oracle.com/javaee/7/api/javax/persistence/Converter.html, JSR-338, Chapter 11.1.10 Convert annotation, page 438", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/persistence/Converter.html": [[0, 68]]}}}, {"text": "You could use the scanner to check if there is an additional [appropriate] input with hasNextDouble()", "label": {"api": {"hasNextDouble()": [[86, 100]]}}}, {"text": "Basically, because the contract says so", "label": {"api": {"the contract says so": [[19, 38]]}}}, {"text": "You can do that by using the groupingBy(classifier, downstream) collector that will classify according to the first character of the key and the downstream collector, which is applied on all values classified to same key, would be averagingDouble", "label": {"api": {"groupingBy(classifier, downstream)": [[29, 62]], "averagingDouble": [[231, 245]]}}}, {"text": "The Stream interface has two overloads for the method of()", "label": {"api": {"Stream": [[4, 9]]}}}, {"text": "I see that the implementation differs between these methods, with the difference apparently being how the Spliterator is instantiated; but what advantage does this offer to the Stream API", "label": {"api": {"Stream": [[177, 182]]}}}, {"text": "However as soon as request is received (Socket.accept returns), almost all servers would immediately fork or reuse another thread to complete the request", "label": {"api": {"Socket.accept": [[40, 52]]}}}, {"text": "As others have mentioned, using a Future would be much simpler and easy to understand", "label": {"api": {"Future": [[34, 39]]}}}, {"text": "And then, you submit this task to an Executor", "label": {"api": {"Executor": [[37, 44]]}}}, {"text": "There are a lot of Executors in JDK", "label": {"api": {"Executor": [[19, 26]]}}}, {"text": "Remember that the futures returned by the executor are in the same order as the Callables you submitted (or added) to the Collection (in this case, an ArrayList)", "label": {"api": {"futures returned by the executor are in the same order as the Callables you submitted (or added)": [[18, 113]]}}}, {"text": "You can either synchronise access to this queue or better you can also have thread safe concurrent queue such as ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[113, 133]]}}}, {"text": "You could use an AsynchronousFileChannel, read a chunk of the file, and calculate the hash of the partition you read in a different thread once the partition is read", "label": {"api": {"AsynchronousFileChannel": [[17, 39]]}}}, {"text": "Because File is just an object representing a file name", "label": {"api": {"File": [[8, 11]]}}}, {"text": "While a FileReader is an open resource used for reading the content of a file, and implements AutoCloseable", "label": {"api": {"File": [[8, 11]], "FileReader": [[8, 17]], "AutoCloseable": [[94, 106]]}}}, {"text": "Java 8 has a function CompletableFuture.allOf(CompletableFuture<?>...cfs) that returns a CompletableFuture that is completed when all the given futures complete", "label": {"api": {"CompletableFuture.allOf(CompletableFuture<?>...cfs)": [[22, 72]]}}}, {"text": "If you task isn’t implementation of the snuffle algorithm you can use standard java.util.Collections#shuffle method", "label": {"api": {"java.util.Collections#shuffle": [[79, 107]]}}}, {"text": "I suggest you to look into the Java API", "label": {"api": {"Java API": [[31, 38]]}}}, {"text": "Arrays.asList receives an ellipsis (T...), so you just don't need the array literal", "label": {"api": {"Arrays.asList": [[0, 12]]}}}, {"text": "You could do this with two calls - substring to get the sequence you're interested in and then toUpperCase to capitalize it", "label": {"api": {"substring": [[35, 43]], "toUpperCase": [[95, 105]]}}}, {"text": "There's no such tool in the JDK, but you can simply wrap your InputStream into a DataInputStream and call readFully(byte[]) on it", "label": {"api": {"DataInputStream": [[81, 95]], "readFully(byte[])": [[106, 122]]}}}, {"text": "To have a class with a next() method, implement the Iterator interface and do the above internally", "label": {"api": {"Iterator": [[52, 59]]}}}, {"text": "TestNG associates each ITestResult with its execution thread using an InheritableThreadLocal<T>", "label": {"api": {"InheritableThreadLocal<T>": [[70, 94]]}}}, {"text": "You need to use the no-argument version of executeQuery(), i.e", "label": {"api": {"executeQuery()": [[43, 56]]}}}, {"text": "This appears to be backed up by the Javadoc for the TargetDataLine class", "label": {"api": {"TargetDataLine": [[52, 65]]}}}, {"text": "the tutorial in Java (https://docs.oracle.com/javase/tutorial/security/apisign/versig.html) doesn't teach how to obtain a certificate from the trusted certificate store and verify using that", "label": {"api": {"https://docs.oracle.com/javase/tutorial/security/apisign/versig.html": [[22, 89]]}}}, {"text": "String.valueOf and Integer.toString", "label": {"api": {"String.valueOf": [[0, 13]], "Integer.toString": [[19, 34]]}}}, {"text": "Read the javadoc of Stack", "label": {"api": {"Stack": [[20, 24]]}}}, {"text": "A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class", "label": {"api": {"Deque": [[79, 83]]}}}, {"text": "Even the javadoc of Deque says it", "label": {"api": {"Deque": [[20, 24]]}}}, {"text": "Deques can also be used as LIFO (Last-In-First-Out) stacks", "label": {"api": {"Deque": [[0, 4]]}}}, {"text": "This interface should be used in preference to the legacy Stack class", "label": {"api": {"Stack": [[58, 62]]}}}, {"text": "The string parameter to Enum.valueOf is the declared name of the enum", "label": {"api": {"Enum.valueOf": [[24, 35]]}}}, {"text": "I want to fetch some data from a database and display it in a JTable", "label": {"api": {"JTable": [[62, 67]]}}}, {"text": "You need to set the path of the cookie, otherwise it's valid only for the current path", "label": {"api": {"set the path": [[12, 23]]}}}, {"text": "This will create a DoubleStream with the help of the iterate(seed, f) method where the seed is 1 and the function, which returns the next value, simply increments the current iteration number i and multiplies the previous value with x / i", "label": {"api": {"iterate(seed, f)": [[53, 68]]}}}, {"text": "The Stream is limited to n element with limit and the sum is retrieved with sum()", "label": {"api": {"limit": [[14, 18], [40, 44]], "sum()": [[76, 80]]}}}, {"text": "Although there is no boolean stream, you can use an IntStream for this", "label": {"api": {"IntStream": [[52, 60]]}}}, {"text": "IntegerProperty.integerProperty creates a property that's bidirectionally connected to the property it wraps", "label": {"api": {"IntegerProperty.integerProperty": [[0, 30]]}}}, {"text": "Calling it with 0 is equivalent to calling the single-parameter overload", "label": {"api": {"equivalent": [[21, 30]]}}}, {"text": "I have gone through the Oracle Doc  but i could not find any way", "label": {"api": {"Oracle Doc ": [[24, 34]]}}}, {"text": "If you're sitting in a method invoked by servlet's service() (such as doGet(), doPost(), etc), then just use the inherited getServletContext() method", "label": {"api": {"service()": [[51, 59]], "getServletContext()": [[123, 141]]}}}, {"text": "If you're sitting in servlet's init(ServletConfig) method, then the inherited getServletContext() isn't available yet as long as you haven't called super.init(config)", "label": {"api": {"getServletContext()": [[78, 96]], "init(ServletConfig)": [[31, 49]], "ServletConfig": [[36, 48]]}}}, {"text": "You'd need to grab it from ServletConfig", "label": {"api": {"ServletConfig": [[27, 39]]}}}, {"text": "But much better is to override init() instead", "label": {"api": {"init()": [[31, 36]]}}}, {"text": "In a decent servlet you usually never need to override init(ServletConfig)", "label": {"api": {"init(ServletConfig)": [[55, 73]], "ServletConfig": [[60, 72]]}}}, {"text": "a filter which lacks the inherited getServletContext() method and you only have ServletRequest at hands, then you could grab it from there", "label": {"api": {"getServletContext()": [[35, 53]], "filter": [[2, 7]], "ServletRequest": [[80, 93]]}}}, {"text": "Hence the introduction of ServletRequest#getServletContext() — although you could also simply extract it from FilterConfig (hey, there's yet another way!)", "label": {"api": {"getServletContext()": [[41, 59]], "ServletRequest": [[26, 39]], "FilterConfig": [[110, 121]]}}}, {"text": "And then there are HTTP session listeners where you could listen on a.o", "label": {"api": {"HTTP session listeners": [[19, 40]]}}}, {"text": "There's no other way to obtain the servlet context than via HttpSession#getServletContext()", "label": {"api": {"getServletContext()": [[72, 90]], "HttpSession#getServletContext()": [[60, 90]]}}}, {"text": "Do note that there's no ServletRequest anywhere as there's not necessarily means of an active HTTP request during server side session timeout", "label": {"api": {"ServletRequest": [[24, 37]]}}}, {"text": "As last, there's also ServletContext#getContext() which returns the ServletContext of a different web application deployed to same server (this works only if the server is configured to enable cross context access on the target webapp)", "label": {"api": {"ServletContext#getContext()": [[22, 48]]}}}, {"text": "Yes, you can make a Stream<String> of your elements, map each of them to the respective enum value with the mapper MyVal::valueOf and collect that into a new EnumSet with toCollection initialized by noneOf", "label": {"api": {"toCollection": [[171, 182]], "noneOf": [[199, 204]]}}}, {"text": "String.replaceAll is for regular expressions", "label": {"api": {"String.replaceAll": [[0, 16]], "String.replace": [[0, 13]]}}}, {"text": "If you are not trying to use regular expressions, use String.replace, NOT String.replaceAll", "label": {"api": {"String.replaceAll": [[74, 90]], "String.replace": [[54, 67], [74, 87]]}}}, {"text": "I would like to understand the difference between javax.crypto.Mac and javax.crypto.Cipher", "label": {"api": {"javax.crypto.Mac": [[50, 65]], "javax.crypto.Cipher": [[71, 89]]}}}, {"text": "I'd use a SwingWorker for this kind of processing", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "Consider having your enum classes implement a common interface, like StandardCopyOption and Month do", "label": {"api": {"StandardCopyOption": [[69, 86]], "Month": [[92, 96]]}}}, {"text": "If Row implements Comparable<Row>, as shown in the example cited here, then Set<Row> will automatically exclude duplicates when you invoke add()", "label": {"api": {"add()": [[139, 143]]}}}, {"text": "The spec says that equal objects must have equal hash-codes", "label": {"api": {"spec": [[4, 7]]}}}, {"text": "A custom ServletContextListener would be an appropriate place to start/stop embedded netty servers", "label": {"api": {"ServletContextListener": [[9, 30]]}}}, {"text": "From the jdk", "label": {"api": {"jdk": [[9, 11]]}}}, {"text": "The scene anti-aliasing documentation refers to the SCENE3D conditional feature", "label": {"api": {"scene anti-aliasing documentation": [[4, 36]], "SCENE3D conditional feature": [[52, 78]]}}}, {"text": "You can use CDI and @Inject annotation", "label": {"api": {"@Inject": [[20, 26]]}}}, {"text": "If you don't like the behavior of the JScrollPane + JTextField, you need to use JScrollBar#setModel(BoundedRangeModel) + JTextField#getHorizontalVisibility()", "label": {"api": {"JScrollBar#setModel(BoundedRangeModel)": [[80, 117]], "JTextField#getHorizontalVisibility()": [[121, 156]]}}}, {"text": "First of all, you need to distinguish between ImageView and Image", "label": {"api": {"ImageView": [[46, 54]], "Image": [[46, 50], [60, 64]]}}}, {"text": "ImageView is the scene graph node which displays an Image, and Image is the actual image (shown by an ImageView)", "label": {"api": {"ImageView": [[0, 8], [102, 110]], "Image": [[0, 4], [52, 56], [63, 67], [102, 106]]}}}, {"text": "The ImageView is part of the scene graph and shows the Image it currently contains", "label": {"api": {"ImageView": [[4, 12]], "Image": [[4, 8], [55, 59]]}}}, {"text": "So, instead of creating multiple ImageView objects, only create one, and create Image objects for your images", "label": {"api": {"ImageView": [[33, 41]], "Image": [[33, 37], [80, 84]]}}}, {"text": "One way of converting JavaFX Image into byte[] is first to convert it to BufferedImage using SwingFXUtils, subsequently use ImageIO.write() to write into a ByteArrayOutputStream and obtain byte[] via toByteArray()", "label": {"api": {"ImageIO.write()": [[124, 138]]}}}, {"text": "Also depending on how you do processing on the client side, you can read data into JavaFX Image directly, using this constructor", "label": {"api": {"this constructor": [[112, 127]]}}}, {"text": "Alternatively, considering that you are reading the image from a file anyway, you can read the image into byte[] directly with Files.readAllBytes()", "label": {"api": {"Files.readAllBytes()": [[127, 146]]}}}, {"text": "But you can use getRequestURL()", "label": {"api": {"getRequestURL()": [[16, 30]]}}}, {"text": "Use -fx-padding (see CSS properties for Region)", "label": {"api": {"see CSS properties for Region": [[17, 45]]}}}, {"text": "IMHO that description is better than the one in the javadoc for the Region class", "label": {"api": {"javadoc for the Region class": [[52, 79]]}}}, {"text": "I managed to solve this issue by using the ServletContext.getResourceAsStream() which can be used to obtain an InputStream for the specified resource", "label": {"api": {"ServletContext.getResourceAsStream()": [[43, 78]], "InputStream": [[111, 121]]}}}, {"text": "According to the java documentation, there is a method intersects(Rectangle r)", "label": {"api": {"intersects(Rectangle r)": [[55, 77]]}}}, {"text": "Once your images are loaded, for each image create an ImageView and attach to the root", "label": {"api": {"ImageView": [[54, 62]]}}}, {"text": "To my mind this could be easily accomplished by implementing a ServletContextListener", "label": {"api": {"ServletContextListener": [[63, 84]]}}}, {"text": "You can use Collections.sort(list, comparator)", "label": {"api": {"Collections.sort(list, comparator)": [[12, 45]]}}}, {"text": "While looking for best existing lib (if I could, I'd like to avoid implementing it on my own) I found that FileHandler lib is almost exactly what I want", "label": {"api": {"FileHandler": [[107, 117]]}}}, {"text": "Also, if you know some other lib which could acomplish this, I'd be willing to ditch FileHandler in favor of that one", "label": {"api": {"FileHandler": [[85, 95]]}}}, {"text": "You have to create a custom java.util.Formatter and install it on your FileHandler", "label": {"api": {"custom java.util.Formatter": [[21, 46]], "install it": [[52, 61]]}}}, {"text": "The Formatter.getHead method is used to write your headers and is called every time the FileHandler is open or rotates", "label": {"api": {"Formatter.getHead": [[4, 20]]}}}, {"text": "The Formatter.format method would be used in this case to generate one row of data per given LogRecord", "label": {"api": {"Formatter.format": [[4, 19]]}}}, {"text": "So you need to generate (or reuse) one LogRecord every one second and publish it to the FileHandler", "label": {"api": {"publish": [[70, 76]]}}}, {"text": "From my Perl days, I'd like to be able to write code like this, given the definition Color.rgb(int,int,int)", "label": {"api": {"Color.rgb(int,int,int)": [[85, 106]]}}}, {"text": "I assumed I wouldn't have a problem, since when I call URLClassLoader.newInstance(), it gets created from the default parent class loader, which I suppose should be the SystemClassLoader, which I assume contains the WebApp classes", "label": {"api": {"from the default parent class loader": [[101, 136]]}}}, {"text": "See ImageIcon.setImageObserver for details", "label": {"api": {"ImageIcon.setImageObserver": [[4, 29]]}}}, {"text": "It would definitely simplify your code if your code became a task managed by a task scheduler, like a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[102, 125]]}}}, {"text": "You are looking for the flatMap(mapper) operation", "label": {"api": {"flatMap(mapper)": [[24, 38]]}}}, {"text": "In this case, we're making a Stream<Bookmark> by calling stream(), flat mapping it to the revisions of each bookmark and, finally, collecting that into a list with toList()", "label": {"api": {"stream()": [[57, 64]], "toList()": [[164, 171]]}}}, {"text": "Note that your current code could also be improved by calling addAll instead of looping over each revisions", "label": {"api": {"addAll": [[62, 67]]}}}, {"text": "Instead, use the Arrays.fill() method", "label": {"api": {"Arrays.fill()": [[17, 29]]}}}, {"text": "You can use java.util.Arrays to convert your array to a list via Arrays.asList(array) to create methods that return the next and previous entry like this (assuming no duplicates and that the list is already in order, as the question says)", "label": {"api": {"java.util.Arrays": [[12, 27]]}}}, {"text": "See DataInput for the byte structure of the UTF representation", "label": {"api": {"DataInput": [[4, 12]]}}}, {"text": "in this case I think Map is your best option.", "label": {"api": {"Map": [[21, 23]]}}}, {"text": "Java's BigInteger is an arbitrary length integer, limited only by available memory or implementation limitations, whereas SqlServer's BIGINT type is simply a 64 bit signed integer", "label": {"api": {"BigInteger": [[7, 16]]}}}, {"text": "You are likely experiencing truncation once the value stored in your BigInteger exceeds 2^63-1", "label": {"api": {"BigInteger": [[69, 78]]}}}, {"text": "boolean value = (cursor.getInt(registerDatabase.ID) == 1); thows a NPE because it has no results, to avoid this Exception use Objects.equals and check number of results of the Cursor", "label": {"api": {"NPE": [[67, 69]]}}}, {"text": "You can use a StringBuilder instead", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "You can use replaceFirst (that accepts a regex), using the following pattern", "label": {"api": {"replaceFirst": [[12, 23]]}}}, {"text": "Of course there are many alternatives, look at the String API to fuel your creative fire", "label": {"api": {"String API": [[51, 60]]}}}, {"text": "As per the BorderLayout API", "label": {"api": {"BorderLayout API": [[11, 26]]}}}, {"text": "Pass a Comparator as a constructor parameter, e.g", "label": {"api": {"Pass a Comparator as a constructor parameter": [[0, 43]]}}}, {"text": "You get a Future having a cancel method", "label": {"api": {"Future": [[10, 15]]}}}, {"text": "You need to create a class that extends AbstractTableModel", "label": {"api": {"AbstractTableModel": [[40, 57]]}}}, {"text": "In method getRowCount() you need to return the size of your array / list", "label": {"api": {"getRowCount()": [[10, 22]]}}}, {"text": "Now after this, use the java.util.Arrays.copyOf() method to trim out the empty elements of the array, like so", "label": {"api": {"java.util.Arrays.copyOf()": [[24, 48]]}}}, {"text": "Then finally, use the java.util.Arrays.copyOf() method to trim out the empty elements of the array again, like so", "label": {"api": {"java.util.Arrays.copyOf()": [[22, 46]]}}}, {"text": "Create a java.io.FileWriter object first, then create a java.io.PrintWriter based on that FileWriter object", "label": {"api": {"java.io.FileWriter": [[9, 26]], "java.io.PrintWriter": [[56, 74]]}}}, {"text": "From my research, it would seem that the Robot Java class and the FFmpeg tool are my best options", "label": {"api": {"Robot": [[41, 45]]}}}, {"text": "However, Robot seems to best-fit the use case of obtaining images, not videos", "label": {"api": {"Robot": [[9, 13]]}}}, {"text": "And consider to use computeIfAbsent() instead of putIfAbsent() in order to avoid unnessessary VoteItem creations", "label": {"api": {"computeIfAbsent()": [[20, 36]]}}}, {"text": "Collections#disjoint() may help to make this more readable", "label": {"api": {"Collections#disjoint()": [[0, 21]]}}}, {"text": "If we are to consider the current case, you can surely \"shorten\" the pattern to \\b (which will also find a match at the end of the string, though Java String#split will safely remove trailing empty elements from the resulting array) that matches all locations between a non-word and word characters and also at the start/end of the string if there is a word character at its start/end", "label": {"api": {"String#split": [[151, 162]]}}}, {"text": "See also the description of parser in question", "label": {"api": {"parser": [[28, 33]]}}}, {"text": "You can just use a HashSet and that should take care of the duplicates issue", "label": {"api": {"HashSet": [[19, 25]]}}}, {"text": "This will take your array, convert it to a List, feed that to the constructor of HashSet<String>, and then convert it back to an array for you", "label": {"api": {"HashSet": [[81, 87]]}}}, {"text": "You can use groupingBy(classifier) where the classifier extracts the year from the date", "label": {"api": {"groupingBy(classifier)": [[12, 33]]}}}, {"text": "In this case, the date is parsed with LocalDate.parse but you could easily extend that by giving your own formatter", "label": {"api": {"LocalDate.parse": [[38, 52]]}}}, {"text": "The API documentation seems pretty definite, no qualifications or weasel-wording", "label": {"api": {"API documentation": [[4, 20]]}}}, {"text": "According to the docs of Stream.concat()", "label": {"api": {"docs of Stream.concat()": [[17, 39]]}}}, {"text": "ConcurrentSkipListMap implements ConcurrentNavigableMap, which has a descdendingMap() method returning view of this map ordered in reverse", "label": {"api": {"descdendingMap()": [[69, 84]]}}}, {"text": "There is a Class#getDeclaringClass method that may work in your case", "label": {"api": {"Class#getDeclaringClass": [[11, 33]]}}}, {"text": "I've had a look at the \"group by\" styles of provided Collectors, but they don't seem to apply since I'm not really grouping by a classifier- you can't compute the groups based only on a property of each individual element, you have to consider the properties of each element in relation to the groups that have been computed so far", "label": {"api": {"Collectors": [[53, 62]]}}}, {"text": "Add a ChangeListener to the value property instead", "label": {"api": {"ChangeListener": [[6, 19]], "value property": [[28, 41]]}}}, {"text": "Also usually you'd use a Slider for this (since the handle size doesn't seem to have a meaning in this case)", "label": {"api": {"Slider": [[25, 30]]}}}, {"text": "I agree with Fabian, just use a Slider for this task, rather than a ScrollBar", "label": {"api": {"Slider": [[32, 37]], "ScrollBar": [[68, 76]]}}}, {"text": "A Slider is a more suitable control", "label": {"api": {"Slider": [[2, 7]]}}}, {"text": "As an alternative to a single-element array, you can instead use AtomicInteger", "label": {"api": {"AtomicInteger": [[65, 77]]}}}, {"text": "In order to get image's height we can use ImageIO.read(new URL(\"…\")).getHeight()", "label": {"api": {"ImageIO.read(new URL(\"…\")).getHeight()": [[42, 79]]}}}, {"text": "The ID's values are based on the strategy (see GenerationType) that is used along with the @GeneratedValue annotation", "label": {"api": {"GenerationType": [[47, 60]]}}}, {"text": "If you don't specify any specific strategy for a @GeneratedValue-field, the default strategy should be javax.persistence.GenerationType.AUTO according to the JPA JavaDoc of GeneratedValue", "label": {"api": {"GenerationType": [[121, 134]], "JPA JavaDoc of GeneratedValue": [[158, 186]]}}}, {"text": "However EclipseLink seems to use javax.persistence.GenerationType.TABLE according to their documentation", "label": {"api": {"GenerationType": [[51, 64]]}}}, {"text": "The strategy of the GeneratedValue is defined by the GenerationType enumerated type", "label": {"api": {"GenerationType": [[53, 66]]}}}, {"text": "If you want to use a different strategy or another table for generation you should take a look at the JavaDoc of TableGenerator and SequenceGenerator", "label": {"api": {"TableGenerator": [[113, 126]], "SequenceGenerator": [[132, 148]]}}}, {"text": "by using an Executor), but I wrote it very quickly", "label": {"api": {"Executor": [[12, 19]]}}}, {"text": "I do not believe there is something like that but you could use a ConcurrentSkipListMap<K,V> directly as a cache (see NavigableMap & time-based caches for an example) or keep a NavigableMap<K,V> in sync with a Guava Cache by loading/putting to both the cache and the navigable map and using a RemovalListener<K,V> to remove entries from the navigable map when they are removed from the cache (see Removal Listeners)", "label": {"api": {"ConcurrentSkipListMap<K,V>": [[66, 91]]}}}, {"text": "You could try to use a Timer (https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html) to schedule a task every 20 seconds", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html": [[30, 91]]}}}, {"text": "Character has many static isXxxx() methods to test if a character belongs to some category", "label": {"api": {"Character": [[0, 8]]}}}, {"text": "You can use a javax.swing.Timer object for this, for example", "label": {"api": {"javax.swing.Timer": [[14, 30]]}}}, {"text": "the null check on conn is superfluous as DriverManager.getConnection() throws an exception if it fails", "label": {"api": {"DriverManager.getConnection()": [[41, 69]]}}}, {"text": "In java 8 you can use Map#computeIfAbsent method", "label": {"api": {"Map#computeIfAbsent": [[22, 40]]}}}, {"text": "next() increments the result set cursor, therefore the instruction after it will exclude the first result", "label": {"api": {"next()": [[0, 5]]}}}, {"text": "What you probably want is isBeforeFirst(), which returns false if the cursor is not at the beginning of the result set OR if the result set is empty", "label": {"api": {"isBeforeFirst()": [[26, 40]]}}}, {"text": "It looks like you are trying to follow the FXML custom component pattern", "label": {"api": {"custom component pattern": [[48, 71]]}}}, {"text": "You can use Arrays.toString() like this", "label": {"api": {"Arrays.toString()": [[12, 28]]}}}, {"text": "FileWriter and FileReader assume that default character encoding is acceptable (UTF-8 on my system)", "label": {"api": {"FileWriter": [[0, 9]], "FileReader": [[15, 24]]}}}, {"text": "I'll add this from the text of the ConcurrentModificationException reference page", "label": {"api": {"ConcurrentModificationException reference page": [[35, 80]]}}}, {"text": "listIterator(int) and listIterator()", "label": {"api": {"listIterator(int)": [[0, 16]], "listIterator()": [[22, 35]]}}}, {"text": "Here the BorderLayout API specifically states (highlighting mine)", "label": {"api": {"BorderLayout API": [[9, 24]]}}}, {"text": "An Instant is a moment on the timeline in UTC", "label": {"api": {"Instant": [[3, 9]]}}}, {"text": "Using Java 7 NIO FileChannel#force method", "label": {"api": {"FileChannel": [[17, 27]], "force": [[29, 33]]}}}, {"text": "See the JavaDocs of java.lang.String.replaceAll and especially java.util.regex.Pattern for more information", "label": {"api": {"java.lang.String.replaceAll": [[20, 46]], "java.util.regex.Pattern": [[63, 85]]}}}, {"text": "The atan2() method returns the angle you need to move", "label": {"api": {"atan2()": [[4, 10]]}}}, {"text": "From a mathematical standpoint, Complex numbers can't be ordered, and as such aren't a good fit for the the Comparable interface", "label": {"api": {"Comparable": [[108, 117]]}}}, {"text": "Note that the contract of the compareTo method requires you to return an int, not a double", "label": {"api": {"compareTo": [[30, 38]]}}}, {"text": "Also, you should define your class as extending Comparable<Complex> instead of a raw Comparable, so you don't have to mess around with casting and runtime type checking", "label": {"api": {"Comparable": [[48, 57], [85, 94]]}}}, {"text": "The improvements in JDK 8's Comparator interface allow for a much more elegant implementation with the same behavior", "label": {"api": {"Comparator": [[28, 37]]}}}, {"text": "Depending on your use case, a work-around could be to use the Desktop class, though this will create a dependency on the AWT stack for the time being", "label": {"api": {"Desktop": [[62, 68]]}}}, {"text": "To determine if the result set can see its own updates call:DatabaseMetaData::ownUpdatesAreVisible", "label": {"api": {"DatabaseMetaData::ownUpdatesAreVisible": [[60, 97]]}}}, {"text": "Or, rather consider using ExecutorService for this and its shutdown method which can do the work easily and it's standard solution for this kind of problems", "label": {"api": {"shutdown method": [[59, 73]]}}}, {"text": "There is a LineNumberReader class which does exactly what you want", "label": {"api": {"LineNumberReader": [[11, 26]]}}}, {"text": "codePointAt(CharSequence seq, int index)", "label": {"api": {"codePointAt(CharSequence seq, int index)": [[0, 39]]}}}, {"text": "Try to call method setExtendedState", "label": {"api": {"setExtendedState": [[19, 34]]}}}, {"text": "replace() works with plain Strings, not regex", "label": {"api": {"replace()": [[0, 8]]}}}, {"text": "Use the wait(long timeout) method", "label": {"api": {"wait(long timeout)": [[8, 25]]}}}, {"text": "Use a ScheduledExecutorService (Tutorial)", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "We'll set our deadline to be x minutes in the future, using Instant from the modern java.time framework (Tutorial)", "label": {"api": {"Instant": [[60, 66]], "java.time": [[84, 92]]}}}, {"text": "I have the string value produced by NSLocale localeIdentifier, and I need to construct a java.util.Locale", "label": {"api": {"java.util.Locale": [[89, 104]]}}}, {"text": "ScheduledExecutorService.schedule() allows to execute a task after a specified delay", "label": {"api": {"ScheduledExecutorService.schedule()": [[0, 34]]}}}, {"text": "Platform.runLater() executes the Runnable on the JavaFX-Thread", "label": {"api": {"Platform.runLater()": [[0, 18]]}}}, {"text": "The basic facility to run something on the JavaFX application thread is Platform.runLater()", "label": {"api": {"Platform.runLater()": [[72, 90]]}}}, {"text": "Of course there are many helpful methods in the ArrayList API that can make your life much easier", "label": {"api": {"ArrayList": [[48, 56]]}}}, {"text": "If there's no restriction on other data structures, you can consider using Map as well", "label": {"api": {"Map": [[75, 77]]}}}, {"text": "I'll also add that you should probably consider using Joda Time for Java 7 or earlier, and java.time for Java 8 or newer", "label": {"api": {"java.time": [[91, 99]]}}}, {"text": "If you want your call to DatagramSocket.receive to finish at your time limit, you will need to make a call to DatagramSocket.setSoTimeout(int), which sets a timeout on the read operation", "label": {"api": {"DatagramSocket.setSoTimeout(int)": [[110, 141]]}}}, {"text": "For that I need a class that implements BeanInfo", "label": {"api": {"BeanInfo": [[40, 47]]}}}, {"text": "I am quite satisfied with the GUI elements of JavafX, however, the ListView control (https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/ListView.html) seems to offer no 'common' keyboard navigability by default", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/ListView.html": [[85, 162]]}}}, {"text": "StringBuilder's reverse takes the first situation into account, but I'm not aware of anything that takes the second into account", "label": {"api": {"StringBuilder's reverse": [[0, 22]]}}}, {"text": "ScheduledExecutorService inherits two methods from the ExecutorService, shutdown() and shutdownNow()", "label": {"api": {"ScheduledExecutorService": [[0, 23]], "ExecutorService": [[9, 23], [55, 69]], "shutdown()": [[72, 81]], "shutdownNow()": [[87, 99]]}}}, {"text": "I can't interrupt the threads because third party libraries are involved and they don't deal well with interrupts :-( But I need to cancel scheduled tasks, that are not currently executing since most of them are scheduled in an hour or so", "label": {"api": {"scheduled": [[139, 147], [212, 220]]}}}, {"text": "What's the Java 8 Stream equivalent of LINQ's SelectMany", "label": {"api": {"Java 8 Stream": [[11, 23]]}}}, {"text": "You're looking to flatMap all the values contained in the map", "label": {"api": {"flatMap": [[18, 24]]}}}, {"text": "This code first retrieves all the values of the map as a Collection<List<Tag>> with values(), creates a Stream out of this collection with stream(), and then flat maps each List<Tag> into a Stream with the method reference List::stream", "label": {"api": {"values()": [[84, 91]], "stream()": [[139, 146]]}}}, {"text": "This creates a Stream of the values with stream(), maps each of them to their size with mapToInt, where the mapper is the method reference List::size refering to List#size(), and sum the results with sum()", "label": {"api": {"stream()": [[41, 48]], "mapToInt": [[88, 95]], "List#size()": [[162, 172]], "sum()": [[200, 204]]}}}, {"text": "To avoid long living dead connections the best option is to set SO_KEEPALIVE option on the socket", "label": {"api": {"SO_KEEPALIVE": [[64, 75]]}}}, {"text": "If erase method just tries to remove an item from universeEntities collection by calling ArrayList's remove method it just break an iterator", "label": {"api": {"remove": [[30, 35], [101, 106]]}}}, {"text": "If you do not want to use iterators you can collect items that should be removed in some kind of collection, return from reduceLifeTime method and remove using removeAll afterwards", "label": {"api": {"remove": [[73, 78], [147, 152], [160, 165]]}}}, {"text": "In the case of lists implementing RandomAccess, which includes all arraylist style implementations, the solution will mimic something similar to Java 8’s ArrayList.removeIf implementation though we don’t have direct access to the internal array and I left out all fail-fast concurrent modification detection stuff", "label": {"api": {"removeIf": [[164, 171]]}}}, {"text": "The method also fulfills the contract of Java 8’s removeIf method of returning whether the list has been changed by the operation", "label": {"api": {"removeIf": [[50, 57]]}}}, {"text": "1 CopyOnWriteArrayList is an exception but for a copy-on-write list the idea of an in-place removeIf is moot, unless provided by the list itself, as, when implementing it via its remove(int) (or any other public) operation we’re effectively copying the entire list on each change", "label": {"api": {"removeIf": [[92, 99]]}}}, {"text": "So in that case, copying the entire list into an ordinary list, performing the removeIf on that list and copying it back will be more efficient in most cases", "label": {"api": {"removeIf": [[79, 86]]}}}, {"text": "Artist, pass MusiqueComparator.ARTISTE to Collections.sort to sort your list by that criterion", "label": {"api": {"Collections.sort": [[42, 57]]}}}, {"text": "You can use split() in the String class", "label": {"api": {"split()": [[12, 18]]}}}, {"text": "One option is to use javafx.animation.Timeline", "label": {"api": {"javafx.animation.Timeline": [[21, 45]]}}}, {"text": "or simply use Thread.sleep()", "label": {"api": {"Thread.sleep()": [[14, 27]]}}}, {"text": "getModifiers returns a set of flags", "label": {"api": {"getModifiers": [[0, 11]]}}}, {"text": "Assuming you are using Java 8, you can use the Executable.getParameters() method to get the formal parameters of a Method", "label": {"api": {"Executable.getParameters()": [[47, 72]]}}}, {"text": "This returns an array of Parameter instances, on which you can invoke Parameter.getModifiers()", "label": {"api": {"Parameter.getModifiers()": [[70, 93]]}}}, {"text": "If unable to get a true integration working, another option might be to simply make external Process calls out from Java to the command line Bluetooth utilities that you know already work", "label": {"api": {"Process": [[93, 99]]}}}, {"text": "java.lang.Integer.parseInt, I noticed that the code header is", "label": {"api": {"java.lang.Integer.parseInt": [[0, 25]]}}}, {"text": "Because NumberFormatException subclasses IllegalArgumentException, which in turn subclasses RuntimeException", "label": {"api": {"IllegalArgumentException": [[41, 64]], "RuntimeException": [[92, 107]]}}}, {"text": "Subclasses of RuntimeException, unlike those of Exception, do not need to be explicitly caught (although they can be)", "label": {"api": {"RuntimeException": [[14, 29]]}}}, {"text": "From the RuntimeException javadoc page", "label": {"api": {"RuntimeException": [[9, 24]]}}}, {"text": "RuntimeException and its subclasses are unchecked exceptions", "label": {"api": {"RuntimeException": [[0, 15]]}}}, {"text": "You can use writeByte to send STX, ETX", "label": {"api": {"writeByte": [[12, 20]]}}}, {"text": "For full documentation refer to JavaFX API", "label": {"api": {"JavaFX API": [[32, 41]]}}}, {"text": "It seems to me that you are also searching for a way to check if a certain Node is a direct or indirect child of another Node or Scene", "label": {"api": {"Node": [[75, 78], [121, 124]], "Scene": [[129, 133]]}}}, {"text": "Following a method that checks if a certain Node is a direct or indirect child of another Node", "label": {"api": {"Node": [[44, 47], [90, 93]]}}}, {"text": "To check if a given Node is the root or an indirect child of a Scene, we can use a similar approach", "label": {"api": {"Node": [[20, 23]], "Scene": [[63, 67]]}}}, {"text": "Use the @XmlTransient annotation", "label": {"api": {"@XmlTransient": [[8, 20]]}}}, {"text": "In Java 8, the conversion from list to array is relatively clean (see related question)", "label": {"api": {"Java 8": [[3, 8]]}}}, {"text": "If the Process was created using ProcessBuilder, then you should call redirectErrorStream(true) to merge the error output with the standard output", "label": {"api": {"ProcessBuilder": [[33, 46]], "redirectErrorStream(true)": [[70, 94]]}}}, {"text": "What you have seems identical to how the API documentation recommends you do this", "label": {"api": {"API documentation": [[41, 57]]}}}, {"text": "Integer.toString(int) returns the string representation of an integer", "label": {"api": {"Integer.toString(int)": [[0, 20]]}}}, {"text": "The simplest solution would be to use Collectors.summarizingInt()", "label": {"api": {"Collectors.summarizingInt()": [[38, 64]]}}}, {"text": "The IntSummaryStatistics class maintains count, sum, min and max values", "label": {"api": {"IntSummaryStatistics": [[4, 23]]}}}, {"text": "The Scanner has a method nextInt to retrieve the next integer", "label": {"api": {"nextInt": [[25, 31]]}}}, {"text": "Otherwise you can convert a string to an integer using the method Integer.parseInt as follow", "label": {"api": {"Integer.parseInt": [[66, 81]]}}}, {"text": "If you take a look to the EntityManager class (which means going one step deeper than Spring Data), you'll see its remove method returns nothing", "label": {"api": {"remove": [[115, 120]]}}}, {"text": "You should check out the Scanner API", "label": {"api": {"Scanner API": [[25, 35]]}}}, {"text": "You can get the reference by using getSource of the MouseEvent", "label": {"api": {"getSource": [[35, 43]], "MouseEvent": [[52, 61]]}}}, {"text": "Use BigDecimal#toPlainString(), per the documentation", "label": {"api": {"toPlainString()": [[15, 29]]}}}, {"text": "toPlainString() - Returns a string representation of this BigDecimal without an exponent field", "label": {"api": {"toPlainString()": [[0, 14]]}}}, {"text": "BigDecimal's documentation lists three to*String() methods", "label": {"api": {"BigDecimal's documentation": [[0, 25]]}}}, {"text": "The regular toString() method uses scientific notation (1.00E-7), while toEngineeringString() uses engineering notation (100E-9) and toPlainString() uses no notation (0.000000100)", "label": {"api": {"toPlainString()": [[133, 147]]}}}, {"text": "If you're looking for insertion order, use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[45, 57]]}}}, {"text": "If you're looking for natural order (A-Z, 0-9), use a TreeMap", "label": {"api": {"TreeMap": [[54, 60]]}}}, {"text": "You can use Collector API", "label": {"api": {"Collector": [[12, 20]]}}}, {"text": "Use flatMap, it does exactly what you need", "label": {"api": {"flatMap": [[4, 10]]}}}, {"text": "Also you can notice that this constructor is @Deprecated", "label": {"api": {"@Deprecated": [[45, 55]]}}}, {"text": "So better idea is to use Calendar", "label": {"api": {"Calendar": [[25, 32]]}}}, {"text": "Use Collections.sort() with Comparator", "label": {"api": {"Collections.sort() with Comparator": [[4, 37]]}}}, {"text": "The PrintWriter will create the file for you, even though nothing is written to it (like with this empty list)", "label": {"api": {"PrintWriter": [[4, 14]]}}}, {"text": "Java has the URLEncoder which will let you convert a String to the desired format", "label": {"api": {"URLEncoder": [[13, 22]]}}}, {"text": "To get your data into a useful format to go into the URLEncoder, I recommend a custom method to read the Object and produce the desired String", "label": {"api": {"URLEncoder": [[53, 62]]}}}, {"text": "Column aliases can be retrieved with ResultSetMetadata.getColumnLabel(int)", "label": {"api": {"ResultSetMetadata.getColumnLabel(int)": [[37, 73]]}}}, {"text": "each id is mapped to the corresponding Foo that is found by calling findFirst() on the foos having that id", "label": {"api": {"findFirst()": [[68, 78]]}}}, {"text": "That's because you need to use the String constructor, that also takes a radix", "label": {"api": {"String constructor, that also takes a radix": [[35, 77]]}}}, {"text": "equals should be defined to take an Object, not a Test", "label": {"api": {"equals": [[0, 5]]}}}, {"text": "Currently, I am changing the JavaFX Image to a BufferedImage, then using the BufferedImage#subImage function to get a sub image, then using SwingFXUtils to change it back to a JavaFX Image", "label": {"api": {"BufferedImage#subImage": [[77, 98]]}}}, {"text": "Use the GraphicsContext::drawImage method to draw the part of the image which you wish onto the canvas", "label": {"api": {"GraphicsContext::drawImage": [[8, 33]]}}}, {"text": "You should use Json factory class to create object builders", "label": {"api": {"Json": [[15, 18]], "builders": [[51, 58]]}}}, {"text": "The Double equals method is documented in the API documentation", "label": {"api": {"API documentation": [[46, 62]]}}}, {"text": "The method's got the following signature", "label": {"api": {"method": [[4, 9]]}}}, {"text": "In my opinion, it would be much more convinient to declare the method as follows", "label": {"api": {"method": [[63, 68]]}}}, {"text": "Alternatively you can set the focusTraversable property of the Button to false", "label": {"api": {"the focusTraversable property": [[26, 54]]}}}, {"text": "SS in SimpleDateFormat is milliseconds", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "However, a better solution would be to use a ListIterator", "label": {"api": {"ListIterator": [[45, 56]]}}}, {"text": "This code retrieves it with listIterator()", "label": {"api": {"listIterator()": [[28, 41]]}}}, {"text": "While there are still elements and the next element is 0, we remove it with remove()", "label": {"api": {"remove()": [[76, 83]]}}}, {"text": "Is not working as System.identityHashCode in Java does not guarantee two different objects will return a different identityHashCode (yes, yes it happens)", "label": {"api": {"System.identityHashCode": [[18, 40]]}}}, {"text": "Because you create Comparator that always returns the first element to be the greatest", "label": {"api": {"Comparator": [[19, 28]]}}}, {"text": "Use @PrimaryKeyJoinColumn instead of a foreign key", "label": {"api": {"@PrimaryKeyJoinColumn": [[4, 24]]}}}, {"text": "Take a look at the function File.lastModified and the functions in Date to check if it's in the last 7 days", "label": {"api": {"File.lastModified": [[28, 44]], "Date": [[67, 70]]}}}, {"text": "The closest would be to use parse(CharSequence,ParsePosition) using two different formatters", "label": {"api": {"parse(CharSequence,ParsePosition)": [[28, 60]]}}}, {"text": "As there say:when you call List.toString(),it will print out the element.toString() one by one,but you didn't custom the method for this element:Coin object,so its address is print out", "label": {"api": {"there": [[3, 7]]}}}, {"text": "Implement WindowListener in your new jFrame and pass a reference to the parent jFrame", "label": {"api": {"WindowListener": [[10, 23]]}}}, {"text": "Also, this method throws a ArithmeticException if the given argument is negative, which, as per your edit, is not your case", "label": {"api": {"ArithmeticException": [[27, 45]]}}}, {"text": "This is actually the same difference for primitive int a and b and calculating a % b (which behaves like remainder) and Math.floorMod(a, b) (which behaves like mod)", "label": {"api": {"Math.floorMod(a, b)": [[120, 138]]}}}, {"text": "In java, dictionaries are defined with the Map interface", "label": {"api": {"Map": [[43, 45]]}}}, {"text": "The common implementations are TreeMap and HashMap", "label": {"api": {"Map": [[35, 37], [47, 49]], "TreeMap": [[31, 37]], "HashMap": [[43, 49]]}}}, {"text": "Similarly, ArrayList and LinkedList are common implementations of the List interface", "label": {"api": {"ArrayList": [[11, 19]], "LinkedList": [[25, 34]], "List": [[16, 19], [31, 34], [70, 73]]}}}, {"text": "It seems the text field is listening for KEY_TYPED events", "label": {"api": {"text": [[13, 16]]}}}, {"text": "Note that for KEY_TYPED events, the text should be the empty string, and the code should be KeyCode.UNDEFINED", "label": {"api": {"text": [[36, 39]], "code": [[77, 80]]}}}, {"text": "Note also that in your test case, the text field is never added to a live scene", "label": {"api": {"text": [[38, 41]]}}}, {"text": "I am trying to use the Java's FileVisitor interface to walk through a list of files and import the contents onto a database", "label": {"api": {"FileVisitor": [[30, 40]]}}}, {"text": "Read the Queue interface documentation", "label": {"api": {"Queue interface documentation": [[9, 37]]}}}, {"text": "You must call ExecutorService#shutdown() or ExecutorService#shutdownNow() to terminate the executor's threadpool", "label": {"api": {"ExecutorService#shutdown()": [[14, 39]], "ExecutorService#shutdownNow()": [[44, 72]], "ExecutorService": [[14, 28], [44, 58]]}}}]