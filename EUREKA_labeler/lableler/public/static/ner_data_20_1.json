[{"text":"Collect the result with Stream.collect into a new list using Collectors.toList()","label":{"api":{"Stream.collect":[[24,37]],"Collectors.toList()":[[61,79]]}}},{"text":"Adding Thread.yield() to the outer loop in t mitigates the problem, as shown below","label":{"api":{"Thread.yield()":[[7,20]]}}},{"text":"Except for the artificial nature of the example, a hint like Thread.yield() would not ordinarily be required","label":{"api":{"Thread.yield()":[[61,74]]}}},{"text":"I do not believe that Thread.yield() should need to be called in this case at all, despite the artificial nature of the test case, however","label":{"api":{"Thread.yield()":[[22,35]]}}},{"text":"Note that the GUI updates promptly in the example below, even without Thread.yield()","label":{"api":{"Thread.yield()":[[70,83]]}}},{"text":"I am trying to analyze a thread dump which seems to indicate that there are numerous threads that are waiting on java.util.concurrent.Semaphore permits, i.e., the threads are waiting on Semaphore.acquire()","label":{"api":{"java.util.concurrent.Semaphore":[[113,142]],"Semaphore.acquire()":[[186,204]]}}},{"text":"This I was able to imply because the threads are in WAITING (parking) state, and from what I've understood, Semaphore's do not use LOCK monitors, but use LockSupport.park() instead, waiting on another thread to unpark it","label":{"api":{"Semaphore":[[108,116]],"LOCK monitors":[[131,143]],"LockSupport.park()":[[154,171]]}}},{"text":"Integer iOb = new Integer(88); is not auto-boxing, Integer takes an int parameter in one of its constructor overloads (see API)","label":{"api":{"Integer":[[51,57]]}}},{"text":"If you bind your server socket to an unspecified host address, the socket will be bind to all available interfaces (see InetSocketAddress)","label":{"api":{"InetSocketAddress":[[120,136]]}}},{"text":"For example, using a properties file, or command line arguments","label":{"api":{}}},{"text":"Java internationalization of strings can be done through the ResourceBundle class","label":{"api":{"ResourceBundle":[[61,74]]}}},{"text":"Since you are using an embeddableID, you can also use the @MapsId annotation so that the EmbeddedID's shipToId attribute gets set by JPA with the value from the referenced entity","label":{"api":{"@MapsId":[[58,64]],"JPA":[[133,135]]}}},{"text":"The JoinColumn defines the field and the @MapsId forces it to override any column definition on the shipToId attribute","label":{"api":{"JoinColumn":[[4,13]],"@MapsId":[[41,47]]}}},{"text":"Implement a ServletContextListener and register it in the web.xml or via annotation","label":{"api":{"ServletContextListener":[[12,33]]}}},{"text":"But from what I can see, the Comparable interface does not require that compareTo() be \"consistent with equals()\" (though it is strongly recommended)","label":{"api":{"Comparable":[[29,38]],"compareTo()":[[72,82]],"equals()":[[104,111]]}}},{"text":"From the Comparable documentation","label":{"api":{"Comparable":[[9,18]]}}},{"text":"@Nicol Bolas makes a good point - there is a function Files.readAllBytes(Path path), if you use it instead of re-implementing the functionality you will be less prone to little bugs like this","label":{"api":{"Files.readAllBytes(Path path)":[[54,82]]}}},{"text":"So, you want every user just once, so a Set is the better choice","label":{"api":{"Set":[[40,42]]}}},{"text":"For this you may have a look at Oracle's Stream-documentation","label":{"api":{"Stream":[[41,46]]}}},{"text":"JDBC Type -1 is LONGVARCHAR, and is the type that is supposed to be returned by your query","label":{"api":{"LONGVARCHAR":[[16,26]]}}},{"text":"No mapping for LONGVARCHAR in Hibernate 3.2","label":{"api":{"LONGVARCHAR":[[15,25]]}}},{"text":"Here .stream.collect(Collectors.joining()) part is Java 8 Stream way to join a sequence of Strings into one","label":{"api":{".stream.collect(Collectors.joining())":[[5,41]]}}},{"text":"You can get it by calling TreeSet.iterator()","label":{"api":{"TreeSet.iterator()":[[26,43]]}}},{"text":"I am using CompletableFuture.runAsync() to asynchronously initialise a few fields in an object","label":{"api":{"CompletableFuture.runAsync()":[[11,38]]}}},{"text":"You may use toCollection(Supplier)","label":{"api":{"toCollection(Supplier)":[[12,33]]}}},{"text":"The documentation for ResourceBundle indicates that the call to getBundle(String) retrieves the bundle from the default location within the classloader","label":{"api":{"ResourceBundle":[[22,35]],"getBundle(String)":[[64,80]]}}},{"text":"Read a String, instead of an int","label":{"api":{"String":[[7,12]],"int":[[29,31]]}}},{"text":"You can start with Instant.ofEpochMilli(long)","label":{"api":{"Instant.ofEpochMilli(long)":[[19,44]]}}},{"text":"In Java, methods that throw checked exceptions (Exception or its subtypes - IOException, InterruptedException, etc) must declare throws statement","label":{"api":{"Exception":[[48,56]],"IOException":[[76,86]],"InterruptedException":[[89,108]]}}},{"text":"What could potentially go wrong if only RuntimeException were allowed to be catched in this scenario","label":{"api":{"RuntimeException":[[40,55]]}}},{"text":"But if you care about starting them at the same time (almost) you can use CyclicBarrier (taken from here)","label":{"api":{"CyclicBarrier":[[74,86]]}}},{"text":"As for the compareTo method - normally you implement the Comparable interface","label":{"api":{"compareTo":[[11,19]],"Comparable":[[57,66]]}}},{"text":"What repaint Component.repaint does (emphasis mine)","label":{"api":{"Component.repaint":[[13,29]]}}},{"text":"Have a look at Collections.shuffle()","label":{"api":{"Collections.shuffle()":[[15,35]]}}},{"text":"Stream.iterate returns 'an infinite sequential ordered Stream'","label":{"api":{"Stream.iterate":[[0,13]]}}},{"text":"According to the description of the  Stream package","label":{"api":{"Stream":[[37,42]]}}},{"text":"The real cause is that ordered parallel .distinct() is the full barrier operation as described in documentation","label":{"api":{"parallel .distinct()":[[31,50]]}}},{"text":"The @Column annotation should still work for this collection of strings","label":{"api":{"@Column":[[4,10]]}}},{"text":"If you really need specific (and changing) usernames/passwords depending on application logic, then you can use DataSource.getConnection(String username, String password)","label":{"api":{"DataSource.getConnection(String username, String password)":[[112,169]]}}},{"text":"To get a human readable format using Arrays use","label":{"api":{"Arrays":[[37,42]]}}},{"text":"Use the the Socket.setKeepAlive() or apply the heart beat mechanism","label":{"api":{"Socket.setKeepAlive()":[[12,32]]}}},{"text":"For most you can just use the String.valueOf() method","label":{"api":{"String.valueOf()":[[30,45]]}}},{"text":"You can use Character.isLowerCase() and Character.isUpperCase() to check an individual char","label":{"api":{"Character.isLowerCase()":[[12,34]],"Character.isUpperCase()":[[40,62]]}}},{"text":"Read the javadoc of Matcher.group(int group)","label":{"api":{"Matcher.group(int group)":[[20,43]]}}},{"text":"See Formatter for details","label":{"api":{"Formatter":[[4,12]]}}},{"text":"Printing single character is support - see https://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html#print(char) , so no reason for compiler error","label":{"api":{}}},{"text":"How about Files.readAllLines()","label":{"api":{"Files.readAllLines()":[[10,29]]}}},{"text":"There is no difference in function betweenaddElement() and add(), except that add() returns a boolean","label":{"api":{"addElement()":[[42,53]],"add()":[[59,63],[78,82]]}}},{"text":"From the JavaDoc for addElement()","label":{"api":{"addElement()":[[21,32]]}}},{"text":"This method is identical in functionality to the add(E) method (which is part of the List interface)","label":{"api":{"add(E)":[[49,54]],"List":[[85,88]]}}},{"text":"You can't traverse through the list using Iterator and modify the list with List-level add/remove methods at the same time","label":{"api":{"Iterator":[[42,49]],"add":[[87,89]],"remove":[[91,96]]}}},{"text":"To add an element in such situations you can use ListIterator and its method add","label":{"api":{"ListIterator":[[49,60]],"add":[[77,79]]}}},{"text":"I am using a Service in this example because it is a reusable Worker","label":{"api":{"Service":[[13,19]],"reusable Worker":[[53,67]]}}},{"text":"I would recommend you look into ThreadPoolExecutor when dealing with large number of threads","label":{"api":{"ThreadPoolExecutor":[[32,49]]}}},{"text":"So, People use @Deprecated annotation for APIs that have been deprecated","label":{"api":{"@Deprecated":[[15,25]]}}},{"text":"When you use thenRunAsync(Runnable), tasks will be executed using a thread pool (there are other possibilites - see API docs)","label":{"api":{"thenRunAsync(Runnable)":[[13,34]]}}},{"text":"See the Color constructor documentation for details","label":{"api":{"Color":[[8,12]]}}},{"text":"When the response is received in the callback, and I've done my processing, I decrement a CountDownLatch","label":{"api":{"CountDownLatch":[[90,103]]}}},{"text":"I await the CountDownLatch, \"blocking\" the current thread until the CountDownLatch reaches 0","label":{"api":{"CountDownLatch":[[12,25],[68,81]]}}},{"text":"we create a pattern that captures every character but only find the first one and print it (the dotall mode is enabled to handle the case where the first character is a line separator)","label":{"api":{"dotall mode":[[96,106]]}}},{"text":"s.charAt(0) uses CharSequence API, not String, so formally it is correct answer","label":{"api":{"s.charAt(0)":[[0,10]],"CharSequence":[[17,28]],"String":[[39,44]]}}},{"text":"Another option is to use a method accepting CharSequence as argument, e","label":{"api":{"CharSequence":[[44,55]]}}},{"text":"Starting from here, get the type parameters that are declared on the method with the getTypeParameters method, which returns a TypeVariable<Method>[]","label":{"api":{"getTypeParameters":[[85,101]],"TypeVariable<Method>[]":[[127,148]]}}},{"text":"The TypeVariable interface has a method to retrieve the name T, getName, and a method to retrieve the bounds, getBounds","label":{"api":{"TypeVariable":[[4,15]],"getName":[[64,70]],"getBounds":[[110,118]]}}},{"text":"I am using Java's javax.imageio.ImageIO to read contents from my FlashAir 32Gb (2nd gen) and to write them to my local hard drive","label":{"api":{"javax.imageio.ImageIO":[[18,38]]}}},{"text":"It's decoding the images, and then re-encoding them at the default JPEG compression rate (which, judging by the JPEGImageWriteParam documentation, is 0.75)","label":{"api":{"JPEGImageWriteParam":[[112,130]]}}},{"text":"I would suggest using an InputStreamReader to read the file then wrap in a buffered reader as shown in the example","label":{"api":{"InputStreamReader":[[25,41]]}}},{"text":"You can only call the XMLStreamReader.getElementText() method on elements which contain text-only content","label":{"api":{"XMLStreamReader.getElementText()":[[22,53]]}}},{"text":"The Javadoc for XMLStreamReader.getElementText() contains detailed pseudocode which shows how the method computes the String that it returns and under what conditions it will throw an XMLStreamException","label":{"api":{"XMLStreamReader.getElementText()":[[16,47]],"XMLStreamException":[[184,201]]}}},{"text":"I tried to generify Future by replacing it with Future<Runnable> but it created a compile error instead since submit() returns a Future<?>","label":{"api":{"Future":[[20,25],[129,134]],"Future<Runnable>":[[48,63]],"submit()":[[110,117]]}}},{"text":"Then after threadPool.shutdown() invoke threadPool.awaitTermination() -- to block until all tasks complete","label":{"api":{"threadPool.shutdown()":[[11,31]],"threadPool.awaitTermination()":[[40,68]]}}},{"text":"The idea is to have a MappedByteBuffer backed by a \"file\" on tmpfs filesystem","label":{"api":{"MappedByteBuffer":[[22,37]]}}},{"text":"The performance of such MappedByteBuffer will be the same as for other Direct ByteBuffers, but it will persist the JVM restart, i.e","label":{"api":{"MappedByteBuffer":[[24,39]],"Direct ByteBuffers":[[71,88]]}}},{"text":"To create the correctly typed array, you need to use the reflection method Array.newInstance()","label":{"api":{"Array.newInstance()":[[75,93]]}}},{"text":"Consider using Iterator for search and removal","label":{"api":{"Iterator":[[15,22]]}}},{"text":"Invoke recover on your Session","label":{"api":{"recover":[[7,13]],"Session":[[23,29]]}}},{"text":"You can use an ImageView and setPickOnBounds for that","label":{"api":{"ImageView":[[15,23]],"setPickOnBounds":[[29,43]]}}},{"text":"The model has a getElementAt(int) method","label":{"api":{"getElementAt(int)":[[16,32]]}}},{"text":"From the docs for the add method","label":{"api":{"add":[[22,24]]}}},{"text":"Unless it is a specific requirement to use Vector, DON'T, and if it is, tell teacher to update assignment to something newer than 1998","label":{"api":{"Vector":[[43,48]]}}},{"text":"Vector was replaced by ArrayList back in Java 1.2 in 1998, and javadoc says","label":{"api":{"Vector":[[0,5]],"ArrayList":[[23,31]]}}},{"text":"Unlike the new collection implementations, Vector is synchronized","label":{"api":{"collection":[[15,24]],"Vector":[[43,48]]}}},{"text":"If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector","label":{"api":{"ArrayList":[[72,80]],"Vector":[[94,99]]}}},{"text":"If synchronization is needed, I'd recommend using Collections.synchronizedList() around an ArrayList over the use of Vector, which means that Vector should never be used, unless with an old API that requires it","label":{"api":{"Collections.synchronizedList()":[[50,79]],"ArrayList":[[91,99]],"Vector":[[117,122],[142,147]]}}},{"text":"The above code will only perform well on List objects with direct access by index, such as ArrayList, but will perform badly on lists like LinkedList","label":{"api":{"List":[[41,44]],"ArrayList":[[91,99]],"LinkedList":[[139,148]]}}},{"text":"Run the server in the context of a class that implements the cancel() method of Future<V>","label":{"api":{"cancel()":[[61,68]],"Future<V>":[[80,88]]}}},{"text":"SwingWorker<T,V> is such a RunnableFuture<V>; a complete example is seen here","label":{"api":{"SwingWorker<T,V>":[[0,15]],"RunnableFuture<V>":[[27,43]]}}},{"text":"But you could install a HttpSessionListener to get notified when sessions are created and destroyed and keep track of them in an own collection","label":{"api":{"HttpSessionListener":[[24,42]]}}},{"text":"Alternatively you could install a HttpSessionAttributeListener to get notified when attributes are added and removed from sessions","label":{"api":{"HttpSessionAttributeListener":[[34,61]]}}},{"text":"Note that the Ellipse2D boundary includes the upper-left corner's x and y coordinates, as well as width and height","label":{"api":{"Ellipse2D":[[14,22]]}}},{"text":"If the result of getSupportsWindowDecorations() is true for a given LookAndFeel, you can invoke setWindowDecorationStyle() on the JRootPane","label":{"api":{"getSupportsWindowDecorations()":[[17,46]],"LookAndFeel":[[68,78]],"setWindowDecorationStyle()":[[96,121]],"JRootPane":[[130,138]]}}},{"text":"Of course, if you were actually willing to write something like this in a real application, you would want to use String.replace(target, replacement) like this","label":{"api":{"String.replace(target, replacement)":[[114,148]]}}},{"text":"The problem with File.listFiles is that it does not list recursively","label":{"api":{"File.listFiles":[[17,30]]}}},{"text":"If I understand your requirement correctly, have a look at the LocalDate.parse() methods","label":{"api":{"LocalDate.parse()":[[63,79]]}}},{"text":"Use replaceAll with an according regular expression with capturing groups and use $1 and $2 in the replacement to reuse the strings in the captured groups","label":{"api":{"replaceAll":[[4,13]]}}},{"text":"The java.time framework built into Java 8 and later parses two-digit year strings as being in the 2000s","label":{"api":{"java.time":[[4,12]]}}},{"text":"From the java.time.DateTimeFormatter class documentation","label":{"api":{"java.time.DateTimeFormatter":[[9,35]]}}},{"text":"get Waits if necessary for the computation to complete, and then retrieves its result","label":{"api":{"get":[[0,2]]}}},{"text":"Use isDone to check that you can call get without waiting","label":{"api":{"isDone":[[4,9]],"get":[[38,40]]}}},{"text":"SwingWorker's processmethod has different arguments and a different return type","label":{"api":{"SwingWorker":[[0,10]],"processmethod":[[14,26]]}}},{"text":"Instead of looping forever on the isAlive() check, create a CountDownLatch when you start the thread, count it down when the thread finishes, and simply await() it in cancel","label":{"api":{"isAlive()":[[34,42]],"CountDownLatch":[[60,73]],"await()":[[153,159]]}}},{"text":"This will incidentally also solve the first problem at the same time without any need for volatile, because in addition to its scheduling coordination a CountDownLatch guarantees that any thread that awaited on it will see the results of everything done in any thread that counted it down","label":{"api":{"CountDownLatch":[[153,166]]}}},{"text":"Replace the Thread t with a CountDownLatch","label":{"api":{"Thread":[[12,17]],"CountDownLatch":[[28,41]]}}},{"text":"In start, initialize the CountDownLatch with a count of 1","label":{"api":{"CountDownLatch":[[25,38]]}}},{"text":"In start, after initializing the CountDownLatch, get an ExecutorService by calling Executors.newSingleThreadExecutor(), and then submit the renameAllFiles call to it","label":{"api":{"CountDownLatch":[[33,46]],"ExecutorService":[[56,70]],"Executors.newSingleThreadExecutor()":[[83,117]],"renameAllFiles":[[140,153]]}}},{"text":"Integer.toHexString(int) is available","label":{"api":{"Integer.toHexString(int)":[[0,23]]}}},{"text":"As is BigInteger.toString(int radix)","label":{"api":{"BigInteger.toString(int radix)":[[6,35]]}}},{"text":"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html It'll do all the shifting for you","label":{"api":{}}},{"text":"You need to call ResultSet.wasNull() to test whether the last column read had a value of SQL NULL","label":{"api":{"ResultSet.wasNull()":[[17,35]]}}},{"text":"Hibernate uses the JPA @Index annotation which doesn't support function-based indexes","label":{"api":{"@Index":[[23,28]]}}},{"text":"As of Java 7, the default locale comes in two categories","label":{"api":{"locale":[[26,31]]}}},{"text":"The garbage collector traverses existing references and within the objects found this way, it will find meta information (i.e","label":{"api":{"garbage collector":[[4,20]]}}},{"text":"a pointer to class specific information) needed to understand how much memory belongs to the object and how to interpret the contained data (to traverse the sub-references, if any)","label":{"api":{}}},{"text":"Once all references to an object are gone, there is no information left about the former existence of this object","label":{"api":{}}},{"text":"When you search memory that is considered to be unused, you may find reminiscences of old objects, but without references to their starting points, it’s impossible to say whether the bit pattern that looks like an object really is a dead object or just a coincidence","label":{"api":{}}},{"text":"Similarly, soft, weak and phantom references encapsulate a reference to the object in question","label":{"api":{}}},{"text":"You can obtain that with anyMatch","label":{"api":{"anyMatch":[[25,32]]}}},{"text":"HashMap (and, in fact, all classes implementing Map) only stores one value per key","label":{"api":{"HashMap":[[0,6]],"Map":[[48,50]]}}},{"text":"Quoting the Javadoc of Map","label":{"api":{"Map":[[23,25]]}}},{"text":"a Collection like a List or Set, so your map type might be Map<String, List<String>>","label":{"api":{"Collection":[[2,11]],"List":[[20,23]],"Set":[[28,30]],"Map<String, List<String>>":[[59,83]]}}},{"text":"You can override the public boolean equals(Object o) method of Object class in Address as","label":{"api":{"equals(Object o)":[[36,51]],"Object":[[63,68]]}}},{"text":"then you can use List.contains(Object o) method of List to verify that element(Address obj) is present or not in the list","label":{"api":{"List.contains(Object o)":[[17,39]],"element(Address obj)":[[71,90]]}}},{"text":"In Java 8, you can use forEach to iterate over the entries of the hashmap and retrieve both key and value in each iteration","label":{"api":{"forEach":[[23,29]]}}},{"text":"The int constructor parameter is an initial capacity, not the number of elements present initially","label":{"api":{}}},{"text":"PriorityBlockingQueue.size() returns the number of elements present in the collection; PriorityBlockingQueue.remainingCapacity() returns the available capacity","label":{"api":{"PriorityBlockingQueue.size()":[[0,27]],"PriorityBlockingQueue.remainingCapacity()":[[87,127]]}}},{"text":"This is perfectly well explained in this javadoc","label":{"api":{}}},{"text":"Consider use of a concurrent hashmap and the method Map.computeIfAbsent() which takes a function to call to compute a default value if key is absent from the map","label":{"api":{"concurrent hashmap":[[18,35]],"Map.computeIfAbsent()":[[52,72]]}}},{"text":"Have a look at MappedByteBuffer and ByteBuffer","label":{"api":{"MappedByteBuffer":[[15,30]],"ByteBuffer":[[36,45]]}}},{"text":"For this, you can calculate the duration between instant and toCheck with Duration.between","label":{"api":{"instant":[[49,55]],"toCheck":[[61,67]],"Duration.between":[[74,89]]}}},{"text":"Since nextChar does not exist, I will offer you to consider trying the following","label":{"api":{"nextChar":[[6,13]]}}},{"text":"I guess you already have the answer you seek but just for the sake of answering, you can try using result-set-metadata by using a select * from table and then checking the column names against your query (you'd have to parse the query string I guess...)","label":{"api":{"result-set-metadata":[[99,117]]}}},{"text":"Math.round is underspecified, and I believe its behavior has actually changed in the past -- see http://bugs.java.com/view_bug.do?bug_id=6430675 -- but generally speaking it behaves like RoundingMode.HALF_UP, which has an extensive table of its differences from RoundingMode.CEILING or RoundingMode.FLOOR","label":{"api":{"Math.round":[[0,9]],"RoundingMode.HALF_UP":[[187,206]],"RoundingMode.CEILING":[[262,281]],"RoundingMode.FLOOR":[[286,303]]}}},{"text":"If you define a no-parameter initialize() method in your Controller and don't implement the Initializable interface, then the FXML loader will still automatically invoke the initialize method","label":{"api":{"initialize()":[[29,40]],"Initializable":[[92,104]],"FXML loader":[[126,136]],"initialize":[[174,183]]}}},{"text":"If instead, you define a parameterized public void initialize(URL url, ResourceBundle rb) method in your Controller, then the FXML loader will not automatically invoke the initialize method unless your controller also implements the Initializable interface","label":{"api":{"initialize(URL url, ResourceBundle rb)":[[51,88]],"FXML loader":[[126,136]],"Initializable":[[233,245]]}}},{"text":"As the code in the question was using a parameterized initialize method and not also implementing Initializable, the initialization was not occurring","label":{"api":{"Initializable":[[98,110]]}}},{"text":"In this framework, you would start off by getting an ExecutorService from one of the static factory methods in Executors, replace both new Thread and t.start() with a call to submit(), and then either coordinate between threads with a CountDownLatch or other provided synchronizer class or (as in your simple case) call get() on the Future that submit() returns","label":{"api":{"ExecutorService":[[53,67]],"Executors":[[111,119]],"Thread":[[139,144]],"t.start()":[[150,158]],"submit()":[[175,182],[345,352]],"CountDownLatch":[[235,248]],"get()":[[320,324]],"Future":[[333,338]]}}},{"text":"The HTML document is in the WebEngine's document property, but it's loaded in the background, so you must wait for it to load","label":{"api":{"WebEngine":[[28,36]]}}},{"text":"The document object is a regular XML document, so if the button has an id attribute, you can easily retrieve it","label":{"api":{"document":[[4,11]],"button":[[57,62]]}}},{"text":"Finally, you can add a DOM event listener to the button, as described in the WebEngine documentation","label":{"api":{"DOM event listener":[[23,40]],"button":[[49,54]],"WebEngine":[[77,85]]}}},{"text":"You can use Timeline which is probably more suitable for this","label":{"api":{"Timeline":[[12,19]]}}},{"text":"Alternatively, you may try to have the delay of the KeyFrame as zero, and use the Timeline's targetFrameRate, but I personally never tried it","label":{"api":{"KeyFrame":[[52,59]],"Timeline":[[82,89]],"targetFrameRate":[[93,107]]}}},{"text":"Like 1 but automatically by the data structure itself, use CopyOnWriteArrayList and return it (wrapped in unmodifiable)","label":{"api":{"CopyOnWriteArrayList":[[59,78]]}}},{"text":"Depending on the properties of the data structure you need you could go for a non RandomAccess list like ConcurrentLinkedQueue or ConcurrentLinkedDeque, both allow iterating etc over the data structure without any extra synchronization","label":{"api":{"RandomAccess list":[[82,98]],"ConcurrentLinkedQueue":[[105,125]],"ConcurrentLinkedDeque":[[130,150]]}}},{"text":"See javadoc of Pattern","label":{"api":{"Pattern":[[15,21]]}}},{"text":"Note that the replaceAll() method shown in comments is also using a regular expression","label":{"api":{"replaceAll()":[[14,25]]}}},{"text":"Given a Map mapping a String to a List, is there a way to use Java Streams to return a Boolean where TRUE means one or more list had elements","label":{"api":{"Map":[[8,10]],"String":[[22,27]],"List":[[34,37]],"Streams":[[67,73]],"Boolean":[[87,93]]}}},{"text":"No need to examine all the Map values (all the Lists)","label":{"api":{"Map":[[27,29]],"List":[[47,50]]}}},{"text":"Use the anyMatch method that finds if any element of the stream matches a Predicate","label":{"api":{"anyMatch":[[8,15]],"Predicate":[[74,82]]}}},{"text":"Go through the string and call Character.isLetter(char) for each char to test if it is a letter character","label":{"api":{"Character.isLetter(char)":[[31,54]]}}},{"text":"Use System.nanoTime() if you want the highest precission","label":{"api":{"System.nanoTime()":[[4,20]]}}},{"text":"It sounds like something as simple as java.util.Timer could do the job","label":{"api":{"java.util.Timer":[[38,52]]}}},{"text":"From java documentation link","label":{"api":{}}},{"text":"Have a look at this link to understand about various API related to memory","label":{"api":{}}},{"text":"If you have a PreparedStatement you should be able to do something like this","label":{"api":{"PreparedStatement":[[14,30]]}}},{"text":"Specifically, depending on the implementation of a collection this could throw ConcurrentModificationException","label":{"api":{"collection":[[51,60]],"ConcurrentModificationException":[[79,109]]}}},{"text":"java.util.TimerTask has only thread to run task","label":{"api":{"java.util.TimerTask":[[0,18]]}}},{"text":"You can replace it with java.util.concurrent.ScheduledExecutorService, it could launch more thread to run task..","label":{"api":{"java.util.concurrent.ScheduledExecutorService":[[24,68]]}}},{"text":"In the first case (ArrayList::new) you are using the constructor which takes an initial capacity argument, in the second case you are not","label":{"api":{"ArrayList::new":[[19,32]]}}},{"text":"Here are the two constructors' current implementations","label":{"api":{}}},{"text":"https://docs.oracle.com/javase/7/docs/api/constant-values.html#java.util.Calendar.YEAR It's a different way of doing enumerations, with static final integers","label":{"api":{}}},{"text":"Note that if you really want an OffsetDateTime, you can use ZonedDateTime.toOffsetDateTime() to convert a ZonedDateTime into an OffsetDateTime","label":{"api":{"OffsetDateTime":[[32,45],[128,141]],"ZonedDateTime.toOffsetDateTime()":[[60,91]],"ZonedDateTime":[[106,118]]}}},{"text":"And you could use equals() instead of == to compare two strings","label":{"api":{"equals()":[[18,25]]}}},{"text":"In this case, use Map","label":{"api":{"Map":[[18,20]]}}},{"text":"You can choose a file with a FileChooser or choose a directory with a DirectoryChooser","label":{"api":{"FileChooser":[[29,39]],"DirectoryChooser":[[70,85]]}}},{"text":"Whenever I check RandomAccessFile.length, will get I the accurate length","label":{"api":{"RandomAccessFile.length":[[17,39]]}}},{"text":"From the documentation for the getBounds2D() method of Path2D.Float","label":{"api":{"getBounds2D()":[[31,43]],"Path2D.Float":[[55,66]]}}},{"text":"This is actually just a copy of the general contract of Shape.getBounds2D()","label":{"api":{"Shape.getBounds2D()":[[56,74]]}}},{"text":"FileSystems is an utility class/factory that is only used to get instances of FileSystem","label":{"api":{"FileSystems":[[0,10]],"FileSystem":[[78,87]]}}},{"text":"Refer to the class documentation for the methods in the FileSystems class","label":{"api":{"FileSystems":[[56,66]]}}},{"text":"Basically, you will never use FileSystems except when you want to get an instance of FileSystem","label":{"api":{"FileSystems":[[30,40]],"FileSystem":[[85,94]]}}},{"text":"For all other use cases, yo uwould only want to use FileSystem","label":{"api":{"FileSystem":[[52,61]]}}},{"text":"The java.util.logging logging framework uses shutdown hooks to make sure the flush() method is called on its handlers","label":{"api":{"java.util.logging":[[4,20]],"flush()":[[77,83]]}}},{"text":"The handlers provided with the java api do implement this","label":{"api":{}}},{"text":"You can use the JarFile class like this","label":{"api":{"JarFile":[[16,22]]}}},{"text":"Similarly to Map.Entry","label":{"api":{"Map.Entry":[[13,21]]}}},{"text":"You are not using correctly the Period class here","label":{"api":{"Period":[[32,37]]}}},{"text":"The period between those two dates, as defined by the Period class is \"1 month\"","label":{"api":{"Period":[[54,59]]}}},{"text":"If you print the period, you will have \"P1M\", which is the pattern to say that","label":{"api":{}}},{"text":"As such, getDays(), which return the amount of days in the period, will return 0","label":{"api":{"getDays()":[[9,17]]}}},{"text":"You can convince yourself of that by printing the result of getMonths, it would return 1","label":{"api":{"getMonths":[[60,68]]}}},{"text":"In Java Time, there is an enum Month for all the months, and the method length(leapYear) return the length of this month, i.e","label":{"api":{"Time":[[8,11]],"Month":[[31,35]],"length(leapYear)":[[72,87]]}}},{"text":"To check for the current year, we can call Year.now() and return if it's a leap year or not with isLeap()","label":{"api":{"Year.now()":[[43,52]],"isLeap()":[[97,104]]}}},{"text":"Therefore, we will parse each String into a YearMonth object using a custom DateTimeFormatter","label":{"api":{"YearMonth":[[44,52]],"DateTimeFormatter":[[76,92]]}}},{"text":"Once they are parsed, we can get the period between those two temporal objects with Period.between","label":{"api":{"Period.between":[[84,97]]}}},{"text":"This method takes a LocalDate as parameter so we need to add a day to each YearMonth","label":{"api":{"LocalDate":[[20,28]],"YearMonth":[[75,83]]}}},{"text":"Finally, getYears() return the amount of years in this period and getMonths() returns the amount of month","label":{"api":{"getYears()":[[9,18]],"getMonths()":[[66,76]]}}},{"text":"If you're using java 8 you should take a look at its new Base64 class","label":{"api":{"Base64":[[57,62]]}}},{"text":"It will provide you with a Base64.Encoder whose encodeToString(byte[] src) method accepts a byte array and return a base64 encoded String","label":{"api":{"Base64.Encoder":[[27,40]],"encodeToString(byte[] src)":[[48,73]]}}},{"text":"Using a stringjoiner directly isn't effective when you have all your information already self contained in a streamable list, because you can stream directly and create a string with Collectors.joining","label":{"api":{"stringjoiner":[[8,19]],"Collectors.joining":[[183,200]]}}},{"text":"The above code uses .stream() to loop over the List then .map() them to strings, then finally collects them using Collectors.joining","label":{"api":{".stream()":[[20,28]],".map()":[[57,62]],"Collectors.joining":[[114,131]]}}},{"text":"Yuri Schimke also suggested another method, you can also use DecimalFormat to format the numbers","label":{"api":{"DecimalFormat":[[61,73]]}}},{"text":"I think the problem here is that you think a PropertyChangeListener will listen to setText() - It doesn't","label":{"api":{"PropertyChangeListener":[[45,66]],"setText()":[[83,91]]}}},{"text":"In the documentation of the propertyChange method it states","label":{"api":{"propertyChange":[[28,41]]}}},{"text":"Furthermore in the setText method's documentation","label":{"api":{"setText":[[19,25]]}}},{"text":"You can use if you want the TrayIcon.displayMessage","label":{"api":{"TrayIcon.displayMessage":[[28,50]]}}},{"text":"For large content, instead of a JLabel, you can use a JEditorPane which has support for HTML content","label":{"api":{"JLabel":[[32,37]],"JEditorPane":[[54,64]]}}},{"text":"You can use \\p{Punct}, which is one of !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~, along with \\s which is a whitespace [ \\t\\n\\x0B\\f\\r]","label":{"api":{}}},{"text":"That method is documented to return the contents of the line, not including any line-termination characters","label":{"api":{}}},{"text":"A system-dependent line separator is used by the Files.write() method you're calling, as documented in its sibling","label":{"api":{"Files.write()":[[49,61]]}}},{"text":"You can also get this system-dependent line separator with System.lineSeparator()","label":{"api":{"System.lineSeparator()":[[59,80]]}}},{"text":"I was looking at the Executor interface","label":{"api":{"Executor":[[21,28]]}}},{"text":"My question is, how can I implement this Thread Pool Executor to be accessible from all the requests received and act as a queue for all the threads","label":{"api":{"Thread Pool Executor":[[41,60]]}}},{"text":"I was looking also at the Tomcat Executor, which I believe is used by Tomcat itself to manage its thread","label":{"api":{"Executor":[[33,40]]}}},{"text":"Also please look at the documentation for Files.readAllLines and note that this function is not intended for reading in large files","label":{"api":{"Files.readAllLines":[[42,59]]}}},{"text":"Use Scanner or BufferedReader instead on large files","label":{"api":{"Scanner":[[4,10]],"BufferedReader":[[15,28]]}}},{"text":"There is a much easier solution, using the built-in Collections.shuffle","label":{"api":{"Collections.shuffle":[[52,70]]}}},{"text":"getByteRgbInstance() returns a pixel format in which there are three bytes per pixel","label":{"api":{"getByteRgbInstance()":[[0,19]]}}},{"text":"The last argument to the setPixels method is the difference in offset in the array from the beginning of one row to the beginning of the next row","label":{"api":{"setPixels":[[25,33]]}}},{"text":"Ideally, you would use something like a TreeSet","label":{"api":{"TreeSet":[[40,46]]}}},{"text":"As you can surmise from the Process docs, the process object is created when you create a child process from your code","label":{"api":{"Process":[[28,34]]}}},{"text":"If you look at the documentation for ArrayList, you'll see that the methods that deal with size (adding, creating, determining size, etc) all return an int","label":{"api":{"ArrayList":[[37,45]]}}},{"text":"The guava library has it's own Supplier which does not extend Java 8 Supplier","label":{"api":{"Supplier":[[31,38],[69,76]]}}},{"text":"Also guava provides a cache for suppliers - Suppliers#memoize","label":{"api":{"Suppliers#memoize":[[44,60]]}}},{"text":"Is there something similar, but for Java 8 Suppliers","label":{"api":{"Suppliers":[[43,51]]}}},{"text":"As per my understanding from the JavaDoc for the ProcessBuilder, it just spawns a separate process and continues with its execution","label":{"api":{"ProcessBuilder":[[49,62]]}}},{"text":"assert throws an AssertionError if the assertion is false","label":{"api":{"AssertionError":[[17,30]]}}},{"text":"You can execute command line statements from Java using a ProcessBuilder","label":{"api":{"ProcessBuilder":[[58,71]]}}},{"text":"Forget about your KeyListener , since PaintWindow will receive no key event , not being a java.awt.Component","label":{"api":{"KeyListener":[[18,28]],"PaintWindow":[[38,48]],"java.awt.Component":[[90,107]]}}},{"text":"If you have no idea what can be null, or want to check everything for null, the only way is to chain calls to Optional.map","label":{"api":{"Optional.map":[[110,121]]}}},{"text":"The final call to orElse(0) allows to return the default value 0 if any mapper returned null","label":{"api":{"orElse(0)":[[18,26]]}}},{"text":"Use a JDK AtomicReference as your bean, rather than creating a dedicated class just for storage","label":{"api":{"AtomicReference":[[10,24]]}}},{"text":"Invoke the set method to store a value","label":{"api":{"set":[[11,13]]}}},{"text":"Invoke the get to recover the value","label":{"api":{"get":[[11,13]]}}},{"text":"Obviously you won't get rid of the steps in the route to store/fetch the value, but you can scrap away your custom class","label":{"api":{}}},{"text":"The getRow doesn't work, because it \"Retrieves the current row number.\"","label":{"api":{"getRow":[[4,9]]}}},{"text":"The canonicalization docs do not indicate why the CN of the server certificate is being canonicalized to this hex form","label":{"api":{"canonicalization":[[4,19]]}}},{"text":"If you read the documentation for String.replaceAll, the return value of String.replaceAll is a result String","label":{"api":{"String.replaceAll":[[34,50],[73,89]]}}},{"text":"I can only search them by ID, which is not sufficient, as they can be added and removed by the user","label":{"api":{}}},{"text":"It is usually far better to implement your tasks as a Runnable and then use a ThreadPoolExecutor to implement multithreading","label":{"api":{"Runnable":[[54,61]],"ThreadPoolExecutor":[[78,95]]}}},{"text":"The elegant solution to this, since Java 7, is to use Objects#equals(Object, Object), which is null-safe","label":{"api":{"Objects#equals(Object, Object)":[[54,83]]}}},{"text":"Here's code for old style, and for new java.time API built into Java 8 and later","label":{"api":{"java.time":[[39,47]]}}},{"text":"Use the find() method","label":{"api":{"find()":[[8,13]]}}},{"text":"Just use the object's Class object, which has a getMethod method that will return a Method object for the method you want, then invoke it","label":{"api":{"Class":[[22,26]],"getMethod":[[48,56]],"Method":[[84,89]]}}},{"text":"To invoke a Java method (and Rectangle.getHeight() is a method), you need a parentheses, like","label":{"api":{"Rectangle.getHeight()":[[29,49]]}}},{"text":"Instead, it uses ReentrantReadWriteLock class in java.util.concurrent.locks package","label":{"api":{"ReentrantReadWriteLock":[[17,38]],"java.util.concurrent.locks":[[49,74]]}}},{"text":"You want the setEnabled method of a JButton","label":{"api":{"setEnabled":[[13,22]],"JButton":[[36,42]]}}},{"text":"Basically reflection is a mechanism to pass from strings to Classes, Methods, Constructors and viceversa","label":{"api":{"Classe":[[60,65]],"Method":[[69,74]],"Constructor":[[78,88]]}}},{"text":"In any case you need to obtain a reference to a Method","label":{"api":{"Method":[[48,53]]}}},{"text":"From the class Method is possible to get the name of that method as a String with the method getName","label":{"api":{"Method":[[15,20]],"getName":[[93,99]]}}},{"text":"Instead of using a infinity recursive function calls, use a SingleThreadedExecutor, and use that to dispatch the update calls","label":{"api":{"SingleThreadedExecutor":[[60,81]]}}},{"text":"You can adjust a given date with an adjuster with the method LocalDateTime.with(adjuster)","label":{"api":{"LocalDateTime.with(adjuster)":[[61,88]]}}},{"text":"If you want to keep the current date in that case, you can use nextOrSame(dayOfWeek)","label":{"api":{"nextOrSame(dayOfWeek)":[[63,83]]}}},{"text":"However, rather than rewriting your code around to use JSON and XML you can keep it by changing the signature of the big class to java.io.Exernalizable and implement readExternal() and writeExternal()","label":{"api":{"java.io.Exernalizable":[[130,150]],"readExternal()":[[166,179]],"writeExternal()":[[185,199]]}}},{"text":"However, since the column has a different name in the child entity, you'll need to change it using an @AttributeOverride to point to the personel_id @Column","label":{"api":{"@AttributeOverride":[[102,119]],"@Column":[[149,155]]}}},{"text":"As Richard points out, I'm wrong—Java SE actually does say that the first week of a week-based year is the first Monday-based week containing at least four days, just like Joda-Time","label":{"api":{}}},{"text":"From the documentation of Java SE's IsoFields.WEEK_OF_WEEK_BASED_YEAR","label":{"api":{"IsoFields.WEEK_OF_WEEK_BASED_YEAR":[[36,68]]}}},{"text":"Instead of sleeping the thread, use a PauseTransition and load your new scene after the pause has finished","label":{"api":{"PauseTransition":[[38,52]]}}},{"text":"The ArrayList(int) constructor initializes the ArrayList's capacity, not it's size","label":{"api":{"ArrayList(int)":[[4,17]],"ArrayList":[[47,55]]}}},{"text":"If you want to add a new element to an array list, you should use the add(T) or add(int, T) method","label":{"api":{"array list":[[39,48]],"add(T)":[[70,75]],"add(int, T)":[[80,90]]}}},{"text":"You can just use the new Optional API in Java 8","label":{"api":{"Optional":[[25,32]]}}},{"text":"If you need to get an int reference from one thread to another, you either have to specify your own MutableInteger class, or use AtomicInteger","label":{"api":{"MutableInteger":[[100,113]],"AtomicInteger":[[129,141]]}}},{"text":"The class Console does not have the method readInt","label":{"api":{"Console":[[10,16]],"readInt":[[43,49]]}}},{"text":"Or you can also refer to this answer in order to use Scanner","label":{"api":{"Scanner":[[53,59]]}}},{"text":"For the latter option, I recommend a CountDownLatch","label":{"api":{"CountDownLatch":[[37,50]]}}},{"text":"You can use Guava's Multimap and Java 8's Map.merge(K, V, BiFunction)","label":{"api":{"Multimap":[[20,27]],"Map.merge(K, V, BiFunction)":[[42,68]]}}},{"text":"If you are trying to reverse the String, then you can use StringBuilder.reverse()","label":{"api":{"StringBuilder.reverse()":[[58,80]]}}},{"text":"You can do this using a StringBuilder","label":{"api":{"StringBuilder":[[24,36]]}}},{"text":"So remove that loop, instead use a javax.swing.Timer to time your events","label":{"api":{"javax.swing.Timer":[[35,51]]}}},{"text":"Let's use the Math.random() method which is static","label":{"api":{"Math.random()":[[14,26]]}}},{"text":"The equals method should be overriden from Object.equals","label":{"api":{"Object.equals":[[43,55]]}}},{"text":"always) also override Object.hashCode","label":{"api":{"Object.hashCode":[[22,36]]}}},{"text":"Building strings is best done using the StringBuilder class","label":{"api":{"StringBuilder":[[40,52]]}}},{"text":"From the Java Docs for Stream#reduce(), we see that the reduce operation returns an Optional<T>","label":{"api":{"Stream#reduce()":[[23,37]],"Optional<T>":[[84,94]]}}},{"text":"An Optional simply wraps a value if there is a value present, otherwise is \"empty\"","label":{"api":{"Optional":[[3,10]]}}},{"text":"Important operations on Optional include Optional#isPresent, which lets you know if there is something in the Optional or not, Optional#get, which returns the T wrapped in the Optional and throws an exception if called on Empty, and Optional#orElse which returns the T wrapped in the Optional if present, or the returns the default value provided if called on Empty","label":{"api":{"Optional":[[24,31],[110,117],[176,183],[284,291]],"Optional#isPresent":[[41,58]],"Optional#get":[[127,138]],"Empty":[[222,226],[360,364]],"Optional#orElse":[[233,247]]}}},{"text":"For your case, the rationale behind reduce() returning an Optional<Integer> is that the list you're trying to reduce may be empty","label":{"api":{"reduce()":[[36,43]],"Optional<Integer>":[[58,74]]}}},{"text":"And finally, you should be setting the panel as the content pane using setContentPane","label":{"api":{"setContentPane":[[71,84]]}}},{"text":"Usually it's best to have the panel dictate what its size should be by overriding setPreferredSize","label":{"api":{"setPreferredSize":[[82,97]]}}},{"text":"In that case you don't need to set the size of the containing frame, rather you call pack to size the frame to the preferred size of its subcomponents","label":{"api":{"pack":[[85,88]]}}},{"text":"https://docs.oracle.com/javase/7/docs/api/javax/sound/sampled/Clip.html May help for more digging if you decide to try this route instead of toolkit","label":{"api":{}}},{"text":"You should consider setting an auto-delay using setAutoDelay","label":{"api":{"setAutoDelay":[[48,59]]}}},{"text":"Another thing you can try is add waitForIdle() before each key press","label":{"api":{"waitForIdle()":[[33,45]]}}},{"text":"You could use the BufferedReader.lines, which returns a Stream<String> with the lines of the file","label":{"api":{"BufferedReader.lines":[[18,37]],"Stream<String>":[[56,69]]}}},{"text":"You can retrieve a Stream over the lines of the file with Files.lines(path) (and you can get a Path with Paths.get)","label":{"api":{"Files.lines(path)":[[58,74]],"Paths.get":[[105,113]]}}},{"text":"The header line is skipped with skip(1), then each line is split around \",\"","label":{"api":{"skip(1)":[[32,38]]}}},{"text":"The group operation is done with the groupingBy(classifier, downstream) collector","label":{"api":{"groupingBy(classifier, downstream)":[[37,70]]}}},{"text":"the classifier is a method that returns the key to group by and the downstream collector collects all Stream elements grouped to the same key; in this case, for the values having the same key, we want to map the Stream element to the Double value (mapping) and collects those Double into a List (toList())","label":{"api":{"classifier":[[4,13]],"Stream":[[102,107],[212,217]],"Double":[[234,239],[276,281]],"mapping":[[248,254]],"toList()":[[296,303]]}}},{"text":"CXF provides the XmlAdapter for converting between XML and the custom datatypes","label":{"api":{"XmlAdapter":[[17,26]]}}},{"text":"The issue I'm having is that the XmlAdapter can take only one BoundType in the generic, so I'm finding myself writing one adapter for each data type which seems wasteful","label":{"api":{"XmlAdapter":[[33,42]],"BoundType":[[62,70]]}}},{"text":"Have a look at the method ScheduledExecutorService#scheduleWithFixedDelay()","label":{"api":{"ScheduledExecutorService#scheduleWithFixedDelay()":[[26,74]]}}},{"text":"As opposed to the method ScheduledExecutorService#scheduleAtFixedRate(), the method with fixed delay does not try to keep up","label":{"api":{"ScheduledExecutorService#scheduleAtFixedRate()":[[25,70]]}}},{"text":"On the java.util.Pattern page all the regex are explained and && is only ever used next to a range (like [a-z&&[^e]])","label":{"api":{"java.util.Pattern":[[7,23]]}}},{"text":"Store the .class in the map then use Class.newInstance() when needed","label":{"api":{"Class.newInstance()":[[37,55]]}}},{"text":"You could also use the String.split() method, but that's up to you","label":{"api":{"String.split()":[[23,36]]}}},{"text":"Consider using a Queue (BlockingQueue or similar) where you put the data to be written and which are then processed by one/more worker Threads (this approach is nothing crawler4j-specific)","label":{"api":{"Queue":[[17,21]],"BlockingQueue":[[24,36]],"Threads":[[135,141]]}}},{"text":"Concerning your follow-up question on how to pass the Queue to the crawler instances, this should do the trick (this is only from looking at the source code, haven't used crawler4j on my own)","label":{"api":{"Queue":[[54,58]]}}},{"text":"Use https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html to find the right formatter in order to read the date","label":{"api":{}}},{"text":"use Arrays.copyOf (or one of its variants)","label":{"api":{"Arrays.copyOf":[[4,16]]}}},{"text":"To transform the list in one small method call, use List#replaceAll()","label":{"api":{"List#replaceAll()":[[52,68]]}}},{"text":"Integer has a longValue method that returns the value as a long (primitive)","label":{"api":{"Integer":[[0,6]],"longValue":[[14,22]]}}},{"text":"If you need parameters or a return value, you might want to have a look at the interfaces in the package java.util.function","label":{"api":{"java.util.function":[[105,122]]}}},{"text":"Read the input with java.util.Scanner and a for loop","label":{"api":{"java.util.Scanner":[[20,36]]}}},{"text":"If the array could be of any dimension, then the Objects.deepEquals() method might be of help","label":{"api":{"Objects.deepEquals()":[[49,68]]}}},{"text":"Now you just need to keep using java.lang.reflect.Array to manipulate it, since you don't know at compile-time how many dimensions it has","label":{"api":{"java.lang.reflect.Array":[[32,54]]}}},{"text":"Also note that Java provides EnumSet as a memory-efficient Set implementation for enums","label":{"api":{"EnumSet":[[29,35]],"Set":[[59,61]]}}},{"text":"This is how you can iterate over your Map","label":{"api":{"Map":[[38,40]]}}},{"text":"To get a specific value (Integer) from your Map use","label":{"api":{"Integer":[[25,31]],"Map":[[44,46]]}}},{"text":"And as I see you are using Java 8 you can even use the nicer getOrDefault","label":{"api":{"getOrDefault":[[61,72]]}}},{"text":"Another approach would be to use the Consumer.andThen(anotherConsumer) method to create a composed consumer made of inner consumers that execute in sequence","label":{"api":{"Consumer.andThen(anotherConsumer)":[[37,69]]}}},{"text":"Check for lengths is null-safe, while check for contents is delegated to the Arrays.equals(array1, array2) method","label":{"api":{"Arrays.equals(array1, array2)":[[77,105]]}}},{"text":"You can use field.getAnnotation() for this","label":{"api":{"field.getAnnotation()":[[12,32]]}}},{"text":"You can use range()","label":{"api":{"range()":[[12,18]]}}},{"text":"Of course you need to define your resultset as FORWARD_ONLY to guarantee this","label":{"api":{"FORWARD_ONLY":[[47,58]]}}},{"text":"link to check whether you are in daylight saving","label":{"api":{}}},{"text":"I think you are looking for .charAt()","label":{"api":{".charAt()":[[28,36]]}}},{"text":"Afterwards, You might want to get the source object and convert it to a DOMSource object and then get the Node object which make the information retrieval much easier","label":{"api":{"source":[[38,43]],"DOMSource":[[72,80]],"Node":[[106,109]]}}},{"text":"The second issue was caused by attempting to cast the result of javax.net.URL.openConnection() (which in the App Engine runtime will return an instance of com.google.apphosting.utils.security.urlfetch.URLFetchServiceStreamHandler$Connection) to javax.net.ssl.HttpsURLConnection, which cannot be done","label":{"api":{"javax.net.URL.openConnection()":[[64,93]],"com.google.apphosting.utils.security.urlfetch.URLFetchServiceStreamHandler$Connection":[[155,239]],"javax.net.ssl.HttpsURLConnection":[[245,276]]}}},{"text":"Therefore you could simply use a StringBuilder with its reverse-method","label":{"api":{"StringBuilder":[[33,45]]}}},{"text":"If you look at the documentation for Scanner.nextInt(), you can see that it throws its own InputMismatchException","label":{"api":{"Scanner.nextInt()":[[37,53]],"InputMismatchException":[[91,112]]}}},{"text":"However in this case I recommend adding a TextFormatter to the TextField which allows you to assign/input values of a type different to String using a TextField","label":{"api":{"TextFormatter":[[42,54]],"TextField":[[63,71],[151,159]],"String":[[136,141]]}}},{"text":"This allows you to assign the value using the TextFormatter, e.g","label":{"api":{"TextFormatter":[[46,58]]}}},{"text":"For more information on this kind of string replacement works, see the documentation on the Formatter class","label":{"api":{"Formatter":[[92,100]]}}},{"text":"What you could do is use LinkedHashMap in LRU mode and then override removeEldestEntry to limit the cache size","label":{"api":{"LinkedHashMap":[[25,37]],"removeEldestEntry":[[69,85]]}}},{"text":"Because DirectoryStream implements Iterable which would iterate over the entries in a directory, and Observable.from(Iterable) converts the sequence into an Observable emitting the items in the sequence, which is the entries in a directory","label":{"api":{"DirectoryStream":[[8,22]],"Iterable":[[35,42]],"Observable.from(Iterable)":[[101,125]]}}},{"text":"equals() should always be commutative, i.e","label":{"api":{"equals()":[[0,7]]}}},{"text":"Or symmetric, as the javadoc of equals() calls it","label":{"api":{"equals()":[[32,39]]}}},{"text":"To implement this, you need to create an annotation processor that runs as a plug-in to javac","label":{"api":{"annotation processor":[[41,60]]}}},{"text":"Frameworks exist to make it easy to create a compile-time annotation processor that ensures that methods are called legally","label":{"api":{"annotation processor":[[58,77]]}}},{"text":"Finally, I used java.net.URL to get this working","label":{"api":{"java.net.URL":[[16,27]]}}},{"text":"On this object, you can call addActionListener to add a action listener, like you have with a JTextField or a JButton","label":{"api":{"addActionListener":[[29,45]],"JTextField":[[94,103]],"JButton":[[110,116]]}}},{"text":"This is caused by the System.currentTimeMillis() granularity","label":{"api":{"System.currentTimeMillis()":[[22,47]]}}},{"text":"The 0=361 was when you were called 10ms later but System.currentTimeMillis() had not kicked over one of it's ticks","label":{"api":{"System.currentTimeMillis()":[[50,75]]}}},{"text":"Considering the comment discussion above, you could create an HttpResponse Wrapper","label":{"api":{"HttpResponse":[[62,73]]}}},{"text":"You should be able to do this using Connection.setClientInfo","label":{"api":{"Connection.setClientInfo":[[36,59]]}}},{"text":"There's also the documentation on sleep","label":{"api":{"sleep":[[34,38]]}}},{"text":"Causes the currently executing thread to sleep (temporarily cease execution) ..","label":{"api":{"sleep":[[41,45]]}}},{"text":"See that when Supervisor sleeps, Calculate wakes up and runs to completion, taking 10 seconds, it then calls notify which wakes up Supervisor to continue","label":{"api":{"sleep":[[25,29]],"Calculate":[[33,41]],"notify":[[109,114]],"Supervisor":[[131,140]]}}},{"text":"You can override the finalize() method (more info) and print out some information there","label":{"api":{"finalize()":[[21,30]]}}},{"text":"The String argument accepted by Class.getResource is not a file name","label":{"api":{"String":[[4,9]],"Class.getResource":[[32,48]]}}},{"text":"If your project is set up correctly, it probably bundles the contents of the res directory into your final .jar file, in which case the correct way to invoke Class.getResource is","label":{"api":{"Class.getResource":[[158,174]]}}},{"text":"Note that although the above would work, you should probably follow java's standards and override Object#equals(Object), handling the notion that a Time instance cannot be equal to an object that isn't a Time instance","label":{"api":{"Object#equals(Object)":[[98,118]],"Time":[[148,151],[204,207]]}}},{"text":"Just use replace()","label":{"api":{"replace()":[[9,17]]}}},{"text":"If you are using Java 8 you can do this by using List.sort as follows","label":{"api":{"List.sort":[[49,57]]}}},{"text":"You could always just write buffer.putInt(0, 50)","label":{"api":{"buffer.putInt(0, 50)":[[28,47]]}}},{"text":"The container will propagate the javax.ejb.EJBContext to the thread that executes the asynchronous method","label":{"api":{"javax.ejb.EJBContext":[[33,52]],"asynchronous":[[86,97]]}}},{"text":"You can inject this EJBContext into your interceptor and stash any state (such as your request scoped bean) that you want into it via javax.ejb.EJBContext.getContextData()","label":{"api":{"EJBContext":[[20,29]],"interceptor":[[41,51]],"javax.ejb.EJBContext.getContextData()":[[134,170]]}}},{"text":"You could look at a ScheduledThreadPoolExecutor which gets you out of the some of the nitty gritty thread management, which is an easy thing to get wrong as a program grows in complexity","label":{"api":{"ScheduledThreadPoolExecutor":[[20,46]]}}},{"text":"As such, it does not comply anymore with the contract of the functional method of Consumer, which is apply and doesn't declare to throw checked exceptions","label":{"api":{"Consumer":[[82,89]],"apply":[[101,105]]}}},{"text":"Wrap this into a try-catch, where you can throw an unchecked exception instead UncheckedIOException","label":{"api":{"UncheckedIOException":[[79,98]]}}},{"text":"A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace","label":{"api":{"Scanner":[[2,8]]}}},{"text":"The contract of compareTo is a bit different","label":{"api":{"compareTo":[[16,24]]}}},{"text":"You must have a Thread object, and even if you have a Thread, isAlive() won't return true unless you've started the Thread with the start method","label":{"api":{"Thread":[[16,21],[54,59],[116,121]],"isAlive()":[[62,70]]}}},{"text":"In Java, this is done with Set#removeAll","label":{"api":{"Set#removeAll":[[27,39]]}}},{"text":"Note that both System.out.printf and DecimalFormat use system-default locale for formatting, so you may see unexpectedly 18,56 instead of 18.56 in some countries","label":{"api":{"System.out.printf":[[15,31]],"DecimalFormat":[[37,49]]}}},{"text":"Like someone suggested, consider using a CountdownLatch while starting threads","label":{"api":{"CountdownLatch":[[41,54]]}}},{"text":"Java Strings are Comparables, meaning they have a compareTo method which can be used to compare two such objects","label":{"api":{"Comparable":[[17,26]],"compareTo":[[50,58]]}}},{"text":"You can still use Arrays.sort method for this and just provide own customized Comparator","label":{"api":{"Arrays.sort":[[18,28]],"Comparator":[[78,87]]}}},{"text":"Also, you only read one byte","label":{"api":{}}},{"text":"And you probably have issues because you are trying to override the final method .getClass() (so the name here is getMyClass() instead","label":{"api":{".getClass()":[[81,91]]}}},{"text":"From the javadoc of .getClass() you can see that","label":{"api":{".getClass()":[[20,30]]}}},{"text":"getClass is a final method of Object which returns a Class","label":{"api":{"getClass":[[0,7]],"Object":[[30,35]],"Class":[[53,57]]}}},{"text":"You are getting that error because the compiler thinks you are trying to override getClass while changing the return type to something that is not a Class","label":{"api":{"getClass":[[82,89]],"Class":[[149,153]]}}},{"text":"If you want to return a String you will need to change the method name to something else or add parameters to the method so its signature does not match Object#getClass","label":{"api":{"String":[[24,29]],"Object#getClass":[[153,167]]}}},{"text":"The number of Unicode blocks defined in the JDK is frighteningly high, and scripts aren't any better","label":{"api":{}}},{"text":"I could maybe use Character.isLetter() (note, I elected the version with a char, not an int), but I'm sure that even that would be too large..","label":{"api":{"Character.isLetter()":[[18,37]]}}},{"text":"If you're writing to a high-latency system (such as a networked hard drive), you should buffer your output with a BufferedOutputStream","label":{"api":{"BufferedOutputStream":[[114,133]]}}},{"text":"Buffer your input with BufferedInputStream if it helps, though I didn't experience improvement in my test","label":{"api":{"BufferedInputStream":[[23,41]]}}},{"text":"You can do this easily enough with replaceAll, which accepts a regular expression","label":{"api":{"replaceAll":[[35,44]]}}},{"text":"In order to force synchronization between your threads you will have to use some other methods such as wait (with notify) and join","label":{"api":{"wait":[[103,106]],"notify":[[114,119]],"join":[[126,129]]}}},{"text":"Another way you could do this is to pass in a Comparator instead of requiring T to be Comparable","label":{"api":{"Comparator":[[46,55]],"Comparable":[[86,95]]}}},{"text":"You could also provide a similar method to the other answers to skip writing the Comparator when T is Comparable","label":{"api":{"Comparator":[[81,90]],"Comparable":[[102,111]]}}},{"text":"You can ask the DatabaseMetaData to give you information about columns","label":{"api":{"DatabaseMetaData":[[16,31]]}}},{"text":"You should box the IntStream to a Stream<Integer>, then call toArray to make a array of it","label":{"api":{"IntStream":[[19,27]],"Stream<Integer>":[[34,48]],"toArray":[[61,67]]}}},{"text":"For what you are trying to achieve, you could create a new thread each time, or you could look at an ExecutorService","label":{"api":{"ExecutorService":[[101,115]]}}},{"text":"Just create a single threaded executor (Executors.newSingleThreadExecutor), and submit your runnable to it every time you need it to run","label":{"api":{"Executors.newSingleThreadExecutor":[[40,72]],"runnable":[[92,99]]}}},{"text":"This makes use of the invokeLater() method, which takes a Runnable","label":{"api":{"invokeLater()":[[22,34]],"Runnable":[[58,65]]}}},{"text":"To give you a more indepth look at how .equals() works, I recommend reading up on the Java Objects class","label":{"api":{".equals()":[[39,47]],"Objects":[[91,97]]}}},{"text":"When you have dynamic keys, you can use a Map<K, V>","label":{"api":{"Map<K, V>":[[42,50]]}}},{"text":"You need make StockQuote impement Serializable, because RMI uses Java's serialization mechanism to transmit data (such as method arguments and return value) over the wire","label":{"api":{"StockQuote":[[14,23]],"Serializable":[[34,45]],"RMI":[[56,58]]}}},{"text":"The diffuseMap used in a PhongMaterial only provides for a single texture image, not a mip-mapped image, and though there are scene aliasing hints that can be applied, that concept differs from texture filtering hints which would be more applicable to your situation","label":{"api":{"diffuseMap":[[4,13]],"PhongMaterial":[[25,37]]}}},{"text":"The javadoc for the ObjectOutputStream constructor also notes that you might want to flush the stream after creating it to ensure the header is sent","label":{"api":{"ObjectOutputStream":[[20,37]]}}},{"text":"But i cannot implement class in my project YearMonth which introduced in jdk 1.8","label":{"api":{"YearMonth":[[43,51]]}}},{"text":"Follow these links for more info on Java Sets and Iterators","label":{"api":{"Sets":[[41,44]],"Iterators":[[50,58]]}}},{"text":"You can use ScheduledExecutorService for this task","label":{"api":{"ScheduledExecutorService":[[12,35]]}}},{"text":"You can use String.replaceAll(String regex, String replacement) to replace all the dots with an empty string","label":{"api":{"String.replaceAll(String regex, String replacement)":[[12,62]]}}},{"text":"Since you are using the sleep() function, this may throw InterruptedException","label":{"api":{"sleep()":[[24,30]],"InterruptedException":[[57,76]]}}},{"text":"For WSDL handling, we can use org.w3c.dom api","label":{"api":{"org.w3c.dom":[[30,40]]}}},{"text":"Use Integer.parseInt to convert your string to an int, then use PreparedStatement#setInt to set it on the statement for insertion","label":{"api":{"Integer.parseInt":[[4,19]],"PreparedStatement#setInt":[[64,87]]}}},{"text":"Create an abstract class that contains implementations of Action","label":{"api":{"Action":[[58,63]]}}},{"text":"The exact formulation depends on your domain, but EditorKit may serve as an example","label":{"api":{"EditorKit":[[50,58]]}}},{"text":"As suggested here, concrete editor kits \"export useful Action classes that operate on the Document model common to text components.\" More discussion may be found here, here and here","label":{"api":{"Action":[[55,60]]}}},{"text":"What you need is not the .keySet(), but rather the .entrySet()","label":{"api":{".keySet()":[[25,33]],".entrySet()":[[51,61]]}}},{"text":"This information is stored in a classes ProtectionDomain","label":{"api":{"ProtectionDomain":[[40,55]]}}},{"text":"Inside the this object, there is a method called getCodeSource() that returns a CodeSource that contains the url of the location it came from","label":{"api":{"getCodeSource()":[[49,63]],"CodeSource":[[80,89]]}}},{"text":"If your young framework has any hope of working properly, you'll need to fix that (wrap everything in SwingUtilities.invokeLater(Runnable))","label":{"api":{"SwingUtilities.invokeLater(Runnable)":[[102,137]]}}},{"text":"Instead of manually getting the set of keys, how about using the keySet() method on the HashMap object from Java","label":{"api":{"keySet()":[[65,72]],"HashMap":[[88,94]]}}},{"text":"For the third bullet, see the size() method","label":{"api":{"size()":[[30,35]]}}},{"text":"You should use a PriorityQueue in stead of a TreeSet because that is make for queue's","label":{"api":{"PriorityQueue":[[17,29]],"TreeSet":[[45,51]]}}},{"text":"Using a PriorityQueue is simple","label":{"api":{"PriorityQueue":[[8,20]]}}},{"text":"Unlike a TreeSet, a PriorityQueue does allow duplicate elements, and gives them back in a FIFO order","label":{"api":{"TreeSet":[[9,15]],"PriorityQueue":[[20,32]]}}},{"text":"If you need a treadsafe solution, you should use a PriorityBlockingQueue instead","label":{"api":{"PriorityBlockingQueue":[[51,71]]}}},{"text":"You could use the Stream.collect(supplier, accumulator, combiner) method to transform the entries and conditionally accumulate them","label":{"api":{"Stream.collect(supplier, accumulator, combiner)":[[18,64]]}}},{"text":"If you are transforming the values into the same type and want to modify the Map in place this could be alot shorter with replaceAll","label":{"api":{"Map":[[77,79]],"replaceAll":[[122,131]]}}},{"text":"I don't recommend doing this because It will not work for all valid Map implementations and may stop working for HashMap in the future, but you can currently use replaceAll and cast a HashMap to change the type of the values","label":{"api":{"Map":[[68,70]],"HashMap":[[113,119],[184,190]],"replaceAll":[[162,171]]}}},{"text":"The equals method in Object compares object references to see if they're identical","label":{"api":{"equals":[[4,9]],"Object":[[21,26]]}}},{"text":"You could perform the multiplication before casting - ((int)(Math.random()*size)), but really it'd be easier to use Random.nextInt(int)","label":{"api":{"Math.random()":[[61,73]],"Random.nextInt(int)":[[116,134]]}}},{"text":"If you want to use a Pane rather than a FlowPane, then Pane has no internal layout, so you need to also set the layoutX and layoutY properties appropriately when you add to the Pane","label":{"api":{"Pane":[[21,24],[55,58],[177,180]],"FlowPane":[[40,47]],"layoutX":[[112,118]],"layoutY":[[124,130]]}}},{"text":"If you want to change the rendering order of nodes in the Pane (e.g","label":{"api":{"Pane":[[58,61]]}}},{"text":"You can do it using Collectors","label":{"api":{"Collectors":[[20,29]]}}},{"text":"You can do other cool stuff with Collectors, as explained in its javadoc","label":{"api":{"Collectors":[[33,42]]}}},{"text":"Access in a linked list implementation, like java.util.LinkedList, is O(n)","label":{"api":{"linked list":[[12,22]],"java.util.LinkedList":[[45,64]]}}},{"text":"Contrast that with an array-based list, like java.util.ArrayList","label":{"api":{"Contrast":[[0,7]],"java.util.ArrayList":[[45,63]]}}},{"text":"Notice how there is no enum ErrorManager.FILTER_FAILURE so that implies that the behavior is intentional","label":{"api":{"ErrorManager.FILTER_FAILURE":[[28,54]]}}},{"text":"From the Handler.setErrorManager documentation","label":{"api":{"Handler.setErrorManager":[[9,31]]}}},{"text":"If you don't want to use Task, just copy and paste with slight modifications to use the same technique as Task uses (the following code is just a copy and paste from the Task source)","label":{"api":{"Task":[[25,28],[106,109],[170,173]]}}},{"text":"If you know that your value is an Integer, then you may wish to use an AtomicInteger rather than an AtomicReference","label":{"api":{"Integer":[[34,40]],"AtomicInteger":[[71,83]],"AtomicReference":[[100,114]]}}},{"text":"Then, configure the JVM to use it through the standard Java networking properties","label":{"api":{"Java networking properties":[[55,80]]}}},{"text":"Check here https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html for the date and time letter patterns","label":{"api":{}}},{"text":"If you want to just discard new tasks when the current thread is busy, you could use a SingleThreadExecutor and configure it to discard any overflow tasks instead of queueing them","label":{"api":{"SingleThreadExecutor":[[87,106]]}}},{"text":"You would do that by setting the selection interval through ListSelectionModel.setSelectionInterval()","label":{"api":{"ListSelectionModel.setSelectionInterval()":[[60,100]]}}},{"text":"You can get the selection model by calling JTable.getSelectionModel()","label":{"api":{"JTable.getSelectionModel()":[[43,68]]}}},{"text":"I would count how many times String.indexOf returns a non-negative number","label":{"api":{"String.indexOf":[[29,42]]}}},{"text":"Use the Platform#runLater() static method, which runs the specified Runnable on the JavaFX Application Thread; it could be called from any thread","label":{"api":{"Platform#runLater()":[[8,26]],"Runnable":[[68,75]]}}},{"text":"It is all the more important to act this way to detect errors early that, quoting the javadoc (emphasis mine)","label":{"api":{}}},{"text":"You can use Stream's filter method, passing a Predicate that ensures that the element doesn't exist in evens","label":{"api":{"Stream":[[12,17]],"filter":[[21,26]],"Predicate":[[46,54]]}}},{"text":"ArrayList), you don't even need streams, just Collections's removeAll method","label":{"api":{"ArrayList":[[0,8]],"streams":[[32,38]],"Collections":[[46,56]],"removeAll":[[60,68]]}}},{"text":"Just use a Comparator (assuming you have a getName method that returns the name)","label":{"api":{"Comparator":[[11,20]],"getName":[[43,49]]}}},{"text":"If you use a java version < 8, use Collections.sort and a anonymus class as Comparator (or use any other way to get a instance of Comparator comparing Animals appropriately)","label":{"api":{"Collections.sort":[[35,50]],"Comparator":[[76,85],[130,139]]}}},{"text":"The File class's listFiles method can return its files in any order","label":{"api":{"File":[[4,7]],"listFiles":[[17,25]]}}},{"text":"IntStream.rangeClosed return a IntStream of primitive int","label":{"api":{"IntStream.rangeClosed":[[0,20]],"IntStream":[[31,39]]}}},{"text":"Each is mapped to the object Person with mapToObj and collected into a list with Collectors.toList()","label":{"api":{"mapToObj":[[41,48]],"Collectors.toList()":[[81,99]]}}},{"text":"Just change new Pane() to new StackPane() and add your label to the pane's child list like you do your Polygon","label":{"api":{"Pane()":[[16,21]],"StackPane()":[[30,40]],"Polygon":[[103,109]]}}},{"text":"StackPane is a layout manager that allows you to layer items on top of each other (by default centering the layered items)","label":{"api":{"StackPane":[[0,8]]}}},{"text":"Any collection (or container) class that implements the Iterable interface is eligible for iteration using the \"for-each loop\"","label":{"api":{"collection":[[4,13]],"container":[[19,27]],"Iterable":[[56,63]]}}},{"text":"Perhaps for historic reasons, the Java arrays did not implement the Iterable interface","label":{"api":{"Iterable":[[68,75]]}}},{"text":"In Java 8, the forEach method was added to the Iterable interface as a default method","label":{"api":{"forEach":[[15,21]],"Iterable":[[47,54]]}}},{"text":"It appears that code generation would be possible without requiring that arrays implement Iterable","label":{"api":{"Iterable":[[90,97]]}}},{"text":"You need to pass an instance of an anonymous class to the addActionListener() method (it's a listener after all)","label":{"api":{"addActionListener()":[[58,76]]}}},{"text":"But, using Java 8, you can use a lambda expression to shorten the code (since ActionListener is a functional interface)","label":{"api":{"ActionListener":[[78,91]]}}},{"text":"You can put System.lineSeparator in your string by concatenating","label":{"api":{"System.lineSeparator":[[12,31]]}}},{"text":"Note that if you are building strings you need to start using StringBuilder to do that, rather than concatenating strings with +=","label":{"api":{"StringBuilder":[[62,74]]}}},{"text":"If you instead use StringBuilder with a suitable capacity, you will not trash the heap","label":{"api":{"StringBuilder":[[19,31]]}}},{"text":"Instead, this class prepares a buffer of suitable length that gets filled as you append strings to it","label":{"api":{}}},{"text":"When your string is finally built, call StringBuilder.toString to get the string you want","label":{"api":{"StringBuilder.toString":[[40,61]]}}},{"text":"Just use java.lang.reflect.Array.newInstance","label":{"api":{"java.lang.reflect.Array.newInstance":[[9,43]]}}},{"text":"transitions like a SequentialTransition, a PauseTransition, a custom transition, etc","label":{"api":{"SequentialTransition":[[19,38]],"PauseTransition":[[43,57]]}}},{"text":"Or you could use an AnimationTimer for that","label":{"api":{"AnimationTimer":[[20,33]]}}},{"text":"As of java8 you can use BufferedReader.lines() to get stream of line which you will have to split, tranform to a list and add to a list of lists","label":{"api":{"BufferedReader.lines()":[[24,45]]}}},{"text":"If you are running in java7 you can use Files.readAllLines to get a list of lines","label":{"api":{"Files.readAllLines":[[40,57]]}}},{"text":"If you know how to run this commands for your needs you can invoke them from Java using java.lang.ProcessBuilder","label":{"api":{"java.lang.ProcessBuilder":[[88,111]]}}},{"text":"You can create an Area from an Ellipse2D that describes the outer circle, and subtract the ellipse that describes the inner circle","label":{"api":{"Area":[[18,21]],"Ellipse2D":[[31,39]]}}},{"text":"This way, you will obtain an actual Shape that can either be drawn or filled (and this will only refer to the area that is actually covered by the ring!)","label":{"api":{"Shape":[[36,40]],"drawn":[[61,65]],"filled":[[70,75]]}}},{"text":"This allows you, for example, to check whether the ring shape contains a certain point, or to fill it with a Paint that is more than a single color","label":{"api":{"Paint":[[109,113]]}}},{"text":"Here is an example, the relevant part is the createRingShape method","label":{"api":{"createRingShape":[[45,59]]}}},{"text":"Use an EventFilter and consume the events","label":{"api":{"EventFilter":[[7,17]]}}},{"text":"Using a-b is a shortcut to Integer.compare(a, b) because in the absence of overflow it returns a positive number when a > b, zero when a == b, and a negative number otherwise","label":{"api":{"Integer.compare(a, b)":[[27,47]]}}},{"text":"However, the subtraction approach breaks down due to overflow when the two numbers are of large magnitude, so one should use Integer.compare instead","label":{"api":{"Integer.compare":[[125,139]]}}},{"text":"I think that the ChangeListener can be considered a subset of EventHandler but it's not true because if you see the ChangeListener documentation you can notice that it doesn't implements the EventHandler interface (the ChangeListener implements the WeakChangeListener and the EventHandler implements the WeakEventHandler); however their use are similar","label":{"api":{"ChangeListener":[[17,30],[116,129],[219,232]],"EventHandler":[[62,73],[191,202],[276,287]],"WeakChangeListener":[[249,266]],"WeakEventHandler":[[304,319]]}}},{"text":"Instead of calling close(), you can call flush() which flushes this output stream and forces any buffered output bytes to be written out","label":{"api":{"close()":[[19,25]],"flush()":[[41,47]]}}},{"text":"The best way to do this in JavaFX is to encapsulate the call in a Task","label":{"api":{"Task":[[66,69]]}}},{"text":"It is important to keep in mind that DataOutputStream#writeInt(int) writes the four bytes of an int high to low","label":{"api":{"DataOutputStream#writeInt(int)":[[37,66]]}}},{"text":"From the java.util.logging.Logger.setLevel documentation","label":{"api":{"java.util.logging.Logger.setLevel":[[9,41]]}}},{"text":"Collectors.groupingBy Allows you to reduce a list to a map where the key is some manipulation of the list's element and the value is some aggregate function applied to a manipulation of the element","label":{"api":{"Collectors.groupingBy":[[0,20]]}}},{"text":"and the example makes it clear that it means separate strings for each argument","label":{"api":{}}},{"text":"I suggest that you look at the example in the javadoc to see how you are supposed to instantiate a ProcessBuilder object","label":{"api":{"ProcessBuilder":[[99,112]]}}},{"text":"So you first need to disable auto-commit mode, using Connection.setAutoCommit(false)","label":{"api":{"Connection.setAutoCommit(false)":[[53,83]]}}},{"text":"This transaction can then either be committed using Connection.commit() or rolled back using Connection.rollback()","label":{"api":{"Connection.commit()":[[52,70]],"Connection.rollback()":[[93,113]]}}},{"text":"Your render method on the JPanel should only update state, and call for a repaint","label":{"api":{"JPanel":[[26,31]],"repaint":[[74,80]]}}},{"text":"The painting will be done in paintComponent as a result of the call to repaint","label":{"api":{"paintComponent":[[29,42]],"repaint":[[71,77]]}}},{"text":"Using Java 8, you don't to write any loop, you can just use String.join(delimiter, elements)","label":{"api":{"String.join(delimiter, elements)":[[60,91]]}}},{"text":"Specify a different column name in Auditorium or use @AttributeOverride in Event to override the default name","label":{"api":{"Auditorium":[[35,44]],"@AttributeOverride":[[53,70]],"Event":[[75,79]]}}},{"text":"You can then just use TreeMap.floorEntry() to fetch the relevant Entry","label":{"api":{"TreeMap.floorEntry()":[[22,41]],"Entry":[[65,69]]}}},{"text":"You want to use Statement.execute(String sql) instead of the way you are executing it now","label":{"api":{"Statement.execute(String sql)":[[16,44]]}}},{"text":"If you have a PreparedStatement on which you execute the SQL, use  PreparedStatement.execute()","label":{"api":{"PreparedStatement":[[14,30]],"PreparedStatement.execute()":[[67,93]]}}},{"text":"They're functionally equivalent (save for how they handle the empty-list case), but you get both variants because LinkedList is an implementation of both a queue and a stack (namely Queue and Deque)","label":{"api":{"LinkedList":[[114,123]],"queue":[[156,160]],"stack":[[168,172]],"Queue":[[182,186]],"Deque":[[192,196]]}}},{"text":"BigDecimal does though","label":{"api":{"BigDecimal":[[0,9]]}}},{"text":"Its BigDecimal(String) constructor sets the value and the scale (number of places to the right of the decimal) from a string, so","label":{"api":{"BigDecimal(String)":[[4,21]]}}},{"text":"BigDecimal then gives you various math operations to stay within that scale, with various rounding options","label":{"api":{"BigDecimal":[[0,9]]}}},{"text":"If at some point you need to get the double value of the BigDecimal, you can use its doubleValue method","label":{"api":{"BigDecimal":[[57,66]],"doubleValue":[[85,95]]}}},{"text":"Here's an example contrasting BigDecimal and double (Live Copy)","label":{"api":{"BigDecimal":[[30,39]],"double":[[45,50]]}}},{"text":"As you didn't state the graphical framework I assume you use Swing, as it contains a doClick function","label":{"api":{"Swing":[[61,65]],"doClick":[[85,91]]}}},{"text":"This method collects all the unique (hence the Set instead of List) names from a JobList","label":{"api":{"Set":[[47,49]],"List":[[62,65]],"JobList":[[81,87]]}}},{"text":"The method returns a Set","label":{"api":{"Set":[[21,23]]}}},{"text":"You can iterate over a Set to get all its elements in turn","label":{"api":{"Set":[[23,25]]}}},{"text":"Although I do not know how to turn those into a Proxy proxy which can then be used in client.SetProxy()","label":{"api":{"Proxy":[[48,52]],"client.SetProxy()":[[86,102]]}}},{"text":"If you want it to be even faster, you can use a PreparedStatement","label":{"api":{"PreparedStatement":[[48,64]]}}},{"text":"You can also use a Scanner and you won't need intermediate Strings or arrays in the process","label":{"api":{"Scanner":[[19,25]]}}},{"text":"With RandomAccessFile, you can open a file, place the cursor at the place you want and read from it","label":{"api":{"RandomAccessFile":[[5,20]]}}},{"text":"You should use a HashMap","label":{"api":{"HashMap":[[17,23]]}}},{"text":"HashMaps contain pairs of keys and values","label":{"api":{"HashMap":[[0,6]]}}},{"text":"I have a framework that uses the interface CompletionStage and I'm curious why the helper methods anyOf or allOf found in CompletableFuture are defined there","label":{"api":{"CompletionStage":[[43,57]],"anyOf":[[98,102]],"allOf":[[107,111]],"CompletableFuture":[[122,138]]}}},{"text":"I'm quite dissatisfied with the CompletionStage interface thus far","label":{"api":{"CompletionStage":[[32,46]]}}},{"text":"Are there other Java libraries that are CompletionStage compliant but a different superset interface someone can recommend","label":{"api":{"CompletionStage":[[40,54]]}}},{"text":"Or perhaps some library written with additional helper methods for working with CompletionStage","label":{"api":{"CompletionStage":[[80,94]]}}},{"text":"If all you want, is a method providing the same anyOf and allOf functionality for objects of the type CompletionStage, you can simply resort to toCompletableFuture","label":{"api":{"anyOf":[[48,52]],"allOf":[[58,62]],"CompletionStage":[[102,116]],"toCompletableFuture":[[144,162]]}}},{"text":"Use nextLine() if you want to read an entire line","label":{"api":{"nextLine()":[[4,13]]}}},{"text":"There's also hasNextLine() to check if there is another line in the input","label":{"api":{"hasNextLine()":[[13,25]]}}},{"text":"The code will keep listening to incoming message once it is started since it use a ThreadPool (Number of thread in the threadpool = a_numThreads) and each of the thread in the threadpool execute a Consumer (ConsumerTest)","label":{"api":{"ThreadPool":[[83,92]],"Consumer":[[197,204]]}}},{"text":"Try the new Date&Time API (java.time) of Java 8 and later","label":{"api":{"java.time":[[27,35]]}}},{"text":"The Scanner class is great for reading user input","label":{"api":{"Scanner":[[4,10]]}}},{"text":"If you decide to implement it yourself, you can build your own disk-backed Dequeue by implementing a circular buffer on top of a (huge) mmaped file","label":{"api":{"Dequeue":[[75,81]]}}},{"text":"Use Collections.sort(List, Comparator) instead of Collections.sort(List)","label":{"api":{"Collections.sort(List, Comparator)":[[4,37]],"Collections.sort(List)":[[50,71]]}}},{"text":"How to user Comparator you can check in Comparator API","label":{"api":{"Comparator":[[12,21],[40,49]]}}},{"text":"Better use DatatypeConverter, avoid that warnings","label":{"api":{"DatatypeConverter":[[11,27]]}}},{"text":"When DecimalFormat is constructed by using the DecimalFormat(String), it will use the default \"format locale\"","label":{"api":{"DecimalFormat":[[5,17]],"DecimalFormat(String)":[[47,67]]}}},{"text":"See the API docs for more details","label":{"api":{}}},{"text":"The API documentation for ClassLoader.getResource(String) claims that it will return null \"if the resource could not be found or the invoker doesn't have adequate privileges to get the resource\"","label":{"api":{"ClassLoader.getResource(String)":[[26,56]]}}},{"text":"CertificateException \"indicates one of a variety of certificate problems\", and is moreover a subclass of GeneralSecurityException-- note the words privileges and security","label":{"api":{"CertificateException":[[0,19]],"GeneralSecurityException":[[105,128]]}}},{"text":"See ByteArrayOutputStream to create an OutputStream and convert to a String with ByteArrayOutputStream#toString()","label":{"api":{"ByteArrayOutputStream":[[4,24]],"OutputStream":[[39,50]],"String":[[69,74]],"ByteArrayOutputStream#toString()":[[81,112]]}}},{"text":"Java 8 brought the Stream interface, and with it convenient map/filter/reduce operations on Java collections (and other things that can be turned into a stream)","label":{"api":{"Stream":[[19,24]],"map":[[60,62]],"filter":[[64,69]],"reduce":[[71,76]]}}},{"text":"The drawing in that class would be done in an override of paintComponent","label":{"api":{"paintComponent":[[58,71]]}}},{"text":"You may use toMap collector with custom merge function","label":{"api":{"toMap":[[12,16]]}}},{"text":"JavaSE has XMLFormatter out of the box","label":{"api":{"XMLFormatter":[[11,22]]}}},{"text":"Exceptions that occur inside of the handler should be reported using Handler.reportError(String, Exception, int)","label":{"api":{"Handler.reportError(String, Exception, int)":[[69,111]]}}},{"text":"Use a java.lang.ThreadLocal and some sort of enum to track the state changes","label":{"api":{"java.lang.ThreadLocal":[[6,26]]}}},{"text":"preferably, in this case the best practice will be to return  an Optional object ( in that way you can prevent NullPointerException from your code/api consumer)","label":{"api":{"Optional":[[65,72]],"NullPointerException":[[111,130]]}}},{"text":"String class has the method contains(CharSequence s) that returns true if and only if the string contains the specified sequence of char values","label":{"api":{"contains(CharSequence s)":[[28,51]]}}},{"text":"This method is more efficient than contains(CharSequence s) method of String","label":{"api":{"contains(CharSequence s)":[[35,58]]}}},{"text":"If you take a look at TableModel, it has two methods, getColumnName and getColumnClass, now, you've overrriden getColumnClass, which is find, but internally to DefaultTableModel, it uses the column names you supplied to the constructor and returns them when getColumnName get's called","label":{"api":{"TableModel":[[22,31]],"getColumnName":[[54,66],[258,270]],"getColumnClass":[[72,85],[111,124]],"DefaultTableModel":[[160,176]]}}},{"text":"So, when JTable#setModel is called, one of things it will do (by default) is call it's createDefaultColumnsFromModel method, this then uses the TableModel to build it's TableColumnModel, using the TableModel#getColumnName method to provide the TableColumn's headerValue property","label":{"api":{"JTable#setModel":[[9,23]],"createDefaultColumnsFromModel":[[87,115]],"TableModel":[[144,153]],"TableColumnModel":[[169,184]],"TableModel#getColumnName":[[197,220]],"TableColumn":[[244,254]]}}},{"text":"See Class Cipher documentation","label":{"api":{"Cipher":[[10,15]]}}},{"text":"You can use a Timeline to do this","label":{"api":{"Timeline":[[14,21]]}}},{"text":"You can get the InputStream by using HttpServletRequest.getInputStream() to save the input stream into a data member then pass it on to the S3 SDK","label":{"api":{"InputStream":[[16,26]],"HttpServletRequest.getInputStream()":[[37,71]]}}},{"text":"If you cast to something that isn't part of your object hierarchy you will get an exception (specifically a ClassCastException) when you run the program","label":{"api":{"ClassCastException":[[108,125]]}}},{"text":"The default number of buckets in a HashMap is 16","label":{"api":{"HashMap":[[35,41]]}}},{"text":"I have an ArrayList<List<String>> that I'm trying to iterate through and print, however, I keep getting a ConcurrentModificationException","label":{"api":{"ArrayList<List<String>>":[[10,32]],"ConcurrentModificationException":[[106,136]]}}},{"text":"Maybe a CopyOnWriteArrayList might be interesting","label":{"api":{"CopyOnWriteArrayList":[[8,27]]}}},{"text":"It appears to me that JAR file indexing breaks the mechanics of ClassLoader.getResources()","label":{"api":{"ClassLoader.getResources()":[[64,89]]}}},{"text":"Doesn't the contract of getResources imply that all available resources matching the given name should be returned","label":{"api":{"getResources":[[24,35]]}}},{"text":"In this case you want a Consumer","label":{"api":{"Consumer":[[24,31]]}}},{"text":"To know all the parameters sent in a request, use HttpServletRequest#getParameterNames or HttpServletRequest#getParameterMap to evaluate each parameter and its value or values","label":{"api":{"HttpServletRequest#getParameterNames":[[50,85]],"HttpServletRequest#getParameterMap":[[90,123]]}}},{"text":"It's clear that compareAndSet is an atomic operation","label":{"api":{"compareAndSet":[[16,28]]}}},{"text":"I think the first operation is atomic (but not quite sure because there is an if), and the second one is definitely not atomic because it consists of compareAndSet and a negation","label":{"api":{"compareAndSet":[[150,162]]}}},{"text":"Use the Scanner class","label":{"api":{"Scanner":[[8,14]]}}},{"text":"For the first error, since your table column type is not a String, you cannot use the no-argument version of TextFieldTableCell.forTableColumn()","label":{"api":{"String":[[59,64]],"TextFieldTableCell.forTableColumn()":[[109,143]]}}},{"text":"You need to provide a converter, using the overloaded form of TextFieldTableCell.forTableColumn(...)","label":{"api":{"TextFieldTableCell.forTableColumn(...)":[[62,99]]}}},{"text":"A possible solution would be to use a CachedRowSet, which is populated from a ResultSet but can outlive the associated Statement/Connection the ResultSet was produced by","label":{"api":{"CachedRowSet":[[38,49]],"ResultSet":[[78,86],[144,152]],"Statement":[[119,127]],"Connection":[[129,138]]}}},{"text":"Java uses a StringTokenizer for parsing the command to arguments in the exec call","label":{"api":{"StringTokenizer":[[12,26]],"exec":[[72,75]]}}},{"text":"A nicer way to add an ActionListener to an anonymous object can be done by using the double brace initialization syntax noted here","label":{"api":{"ActionListener":[[22,35]]}}},{"text":"After searching through the Java API, I found that the add method returns the component being added","label":{"api":{"add":[[55,57]]}}},{"text":"But you can get the added object like this","label":{"api":{}}},{"text":"Read about class Pattern","label":{"api":{"Pattern":[[17,23]]}}},{"text":"Then, since no match was made, sc.match() throws an IllegalStateException","label":{"api":{"sc.match()":[[31,40]],"IllegalStateException":[[52,72]]}}},{"text":"You can use a BigInteger","label":{"api":{"BigInteger":[[14,23]]}}},{"text":"This creates a Biginteger from the input String in base 2 (new BigInteger(val, radix)) and returns its bit count (bitCount())","label":{"api":{"Biginteger":[[15,24]],"BigInteger(val, radix)":[[63,84]],"bitCount()":[[114,123]]}}},{"text":"I successfully utilized javax.transaction.Synchronization which can be registered with the transaction and receives correct status","label":{"api":{"javax.transaction.Synchronization":[[24,56]]}}},{"text":"You have replaced the table's default renderer, which knows how to render an Icon, with an instance of DefaultTableCellRenderer, which does not","label":{"api":{"DefaultTableCellRenderer":[[103,126]]}}},{"text":"Remove the while block, and change the PublicationArray fron an array into an ArrayList","label":{"api":{"PublicationArray":[[39,54]],"ArrayList":[[78,86]]}}},{"text":"Read in the Image using the class java.awt.image.BufferedImage like this","label":{"api":{"java.awt.image.BufferedImage":[[34,61]]}}},{"text":"Look at the Pattern class","label":{"api":{"Pattern":[[12,18]]}}},{"text":"It uses the rules for double literals in Java source code, which 99% is not how you want your program to be fed (it allows exponents, hexadecimals and whatnot)","label":{"api":{}}},{"text":"If the input comes from a human you'd better use DecimalFormat that is locale-aware and can be easily customized (it even offers control over rounding mode)","label":{"api":{"DecimalFormat":[[49,61]]}}},{"text":"From a DecimalFormat you can get an Integer, a Number or a BigDecimal, depending on what that quantity describes and how you plan to use it","label":{"api":{"DecimalFormat":[[7,19]],"Integer":[[36,42]],"Number":[[47,52]],"BigDecimal":[[59,68]]}}},{"text":"The new java.time-library (JSR-310) does force the user to code against exceptions - a clear regression compared with 'SimpleDateFormat`","label":{"api":{"java.time":[[8,16]],"SimpleDateFormat":[[119,134]]}}},{"text":"From the documentation of the Logger class","label":{"api":{"Logger":[[30,35]]}}},{"text":"I'd suggest using Matcher#replaceAll() for this","label":{"api":{"Matcher#replaceAll()":[[18,37]]}}},{"text":"See java.nio.ShortBuffer and start digging from there","label":{"api":{"java.nio.ShortBuffer":[[4,23]]}}},{"text":"How to fix depends on a number of factors, for example, you could use a ComponentListener and listen for componentResized events, but do you want to know about all the size events","label":{"api":{"ComponentListener":[[72,88]],"componentResized":[[105,120]]}}},{"text":"You create a new map from the first map, iterate over the second map and merge each key with the first map thanks to merge(key, value, remappingFunction)","label":{"api":{"merge(key, value, remappingFunction)":[[117,152]]}}},{"text":"Technically speaking, BiFunction does not declare throwing any checked Exception","label":{"api":{"BiFunction":[[22,31]],"Exception":[[71,79]]}}},{"text":"Instead you are usually expected to use unchecked exceptions and handle them in a way, specific for particular promise library (see documentation of CompletionStage for details on it's exception handling facilities)","label":{"api":{"CompletionStage":[[149,163]]}}},{"text":"Use printf() or String.format(), or the underlying Formatter","label":{"api":{"printf()":[[4,11]],"String.format()":[[16,30]],"Formatter":[[51,59]]}}},{"text":"This uses the map's keySet().stream() and values().stream() to get a stream of both, then connects them using Stream.concat, then finally turns it into a set","label":{"api":{"keySet().stream()":[[20,36]],"values().stream()":[[42,58]],"Stream.concat":[[110,122]]}}},{"text":"An easy solution, which will also result in more efficient and more elegant code is to use String.charAt(), rather than splitting the original string to a lot of small String objects, and iterate from 0 to a.length for each character in the string","label":{"api":{"String.charAt()":[[91,105]],"String":[[168,173]],"a.length":[[206,213]]}}},{"text":"You can simplify the access by using the wrapper classes such as AtomicLong","label":{"api":{"AtomicLong":[[65,74]]}}},{"text":"See Timeline for more information","label":{"api":{"Timeline":[[4,11]]}}},{"text":"I'm not sure what is going wrong without seeing the code, but since Java SE 7 the recommended way to move/ rename files is Files.move (NIO.2 File API)","label":{"api":{"Files.move":[[123,132]]}}},{"text":"If you do want to be able to run multiple instances of the test class in parallel then you'll need to use something like a ThreadLocal<T>","label":{"api":{"ThreadLocal<T>":[[123,136]]}}},{"text":"Also for hasNext()","label":{"api":{"hasNext()":[[9,17]]}}},{"text":"As long as nothing of those things happen, hasNext() method doesn't return, so the condition in while is still not evaluated, so the loop is blocked there","label":{"api":{"hasNext()":[[43,51]]}}},{"text":"From the Javadoc of createTempFile (emphasis mine)","label":{"api":{"createTempFile":[[20,33]]}}},{"text":"Instead, you should just create a new file with Files.createFile(path) from Java NIO.2 API, or File#createNewFile() otherwise","label":{"api":{"Files.createFile(path)":[[48,69]],"File#createNewFile()":[[95,114]]}}},{"text":"java.lang.Math docs say for many functions, such as Math.pow","label":{"api":{"java.lang.Math":[[0,13]],"Math.pow":[[52,59]]}}},{"text":"For example, can we rely on Math.pow(3.0, 2.0) == 9.0","label":{"api":{"Math.pow(3.0, 2.0)":[[28,45]]}}},{"text":"See https://docs.oracle.com/javase/7/docs/api/java/net/URLEncoder.html for reference","label":{"api":{}}},{"text":"You may also avoid a regex and use the class Character.UnicodeBlock","label":{"api":{"Character.UnicodeBlock":[[45,66]]}}},{"text":"If you want to have something run when Tomcat starts, take a look at ServletContextListener","label":{"api":{"ServletContextListener":[[69,90]]}}},{"text":"If you are just initializing the DB then ServletContextListener will allow that","label":{"api":{"ServletContextListener":[[41,62]]}}},{"text":"But after that, don't use the ServletContextListener to also hand out database connections","label":{"api":{"ServletContextListener":[[30,51]]}}},{"text":"You may be interested in the following code that looks for a normalized string inside a larger normalized string using a java.text.Normalizer","label":{"api":{"java.text.Normalizer":[[121,140]]}}},{"text":"The Javadocs for this method state","label":{"api":{}}},{"text":"If you started the other program using ProcessBuilder, then you might be able to send the control sequence by writing the appropriate bytes to the process's input stream","label":{"api":{"ProcessBuilder":[[39,52]]}}},{"text":"convertedArray[i] = UnitRepository.getUnitName(units3[i].trim()); where trim() will remove any extra whitepsace around the value, which should make the unit name to resolve correctly","label":{"api":{"trim()":[[72,77]]}}}]