[{"text":"You will need to use LocalDate.format method like this","label":{"api":{"LocalDate.format method":[[21,43]]}}},{"text":"You can use SimpleDateFormat class for that purposes","label":{"api":{"SimpleDateFormat":[[12,27]]}}},{"text":"Initialize SimpleDateFormat object with date format that you want as a parameter","label":{"api":{"SimpleDateFormat":[[11,26]]}}},{"text":"Java is full of concepts that are considered bad idea nowadays but haven't been removed nevertheless - some more examples that come to my mind are clone() or Thread.stop()","label":{"api":{"clone()":[[147,153]],"Thread.stop()":[[158,170]]}}},{"text":"Your student has a name (which is just plain text), and a series of answers (you can use an array, though the Java List API is generally easier to work with)","label":{"api":{"List":[[115,118]]}}},{"text":"If you still need the ability to sort students, for example, based on their performance on the quiz, you can use a Comparator","label":{"api":{"Comparator":[[115,124]]}}},{"text":"You could also have your Student class implement the Comparable interface, in order to sort students by name","label":{"api":{"Comparable":[[53,62]]}}},{"text":"If you want a list that allows you to add new elements, you should use a ArrayList","label":{"api":{"ArrayList":[[73,81]]}}},{"text":"Collections class, which consists entirely of static methods operating on various collection interfaces","label":{"api":{"Collections":[[0,10]],"collection":[[82,91]]}}},{"text":"This may be particularly useful information when inlining the method call when it's called with a constant value, such as in the implementation of listIterator() (with no parameters), which is simply","label":{"api":{"listIterator()":[[147,160]]}}},{"text":"The best approach is to use Joda-Time for Java 7 and earlier, and use the new java.time package for Java 8+","label":{"api":{"java.time":[[78,86]]}}},{"text":"My question is, there must be a system clock that keeps going despite the device being asleep, how can I let the executor scheduler use that clock instead of the one it's using now which respects the device going to deep sleep and pauses ticking","label":{"api":{"executor scheduler":[[113,130]]}}},{"text":"System.exit(int) is used to terminate the running JVM and returns 0 to the parent process","label":{"api":{"System.exit(int)":[[0,15]]}}},{"text":"The docs of System.exit say (boldface mine)","label":{"api":{"System.exit":[[12,22]]}}},{"text":"In that case using System.exit is perfectly fine","label":{"api":{"System.exit":[[19,29]]}}},{"text":"Here's a solution that minimizes code duplication by avoiding the System.out.print/ln calls within the loop and instead storing the character values inside a StringBuilder, value of which is then printed before the program exits","label":{"api":{"System.out.print":[[66,81]],"StringBuilder":[[158,170]]}}},{"text":"As per the oracle documentation, System.nanoTime() is not related to clock","label":{"api":{"System.nanoTime()":[[33,49]]}}},{"text":"createNewFile takes 0 arguments, not 1","label":{"api":{"createNewFile":[[0,12]]}}},{"text":"As per PrintWriter The PrintWriter(Writer) constructor Creates a new PrintWriter, without automatic line flushing","label":{"api":{"PrintWriter":[[7,17],[69,79]],"PrintWriter(Writer)":[[23,41]]}}},{"text":"So either you require to call out.flush() before out.close() or for creating PrintWriter use this contrustor, with which your can specify 'true' to autoFlush parameter","label":{"api":{"out.flush()":[[30,40]],"out.close()":[[49,59]],"PrintWriter":[[77,87]]}}},{"text":"An application may get these parameters using the getParameters() method","label":{"api":{"getParameters()":[[50,64]]}}},{"text":"nextInt is a method, not a data member - it should be called with parentheses","label":{"api":{"nextInt":[[0,6]]}}},{"text":"Since a Collection is unindexed, the only remove method its interface exposes is Collection.remove(Object o), which removes the specified equal object","label":{"api":{"Collection":[[8,17]],"Collection.remove(Object o)":[[81,107]]}}},{"text":"Doing col.remove(1); first calls Integer.valueOf(1) to get an Integer object, then asks the list to remove that object","label":{"api":{"col.remove(1)":[[6,18]],"Integer.valueOf(1)":[[33,50]]}}},{"text":"When col's compile-time type is ArrayList, calling col.remove(1); instead invokes the method ArrayList.remove(int index) to remove the element at the specified position, thus removing b","label":{"api":{"ArrayList":[[32,40]],"col.remove(1)":[[51,63]],"ArrayList.remove(int index)":[[93,119]]}}},{"text":"From the ArrayList documentation","label":{"api":{"ArrayList":[[9,17]]}}},{"text":"Reviewing Java 8 Stream API design, I was surprised by the generic invariance on the Stream.reduce() arguments","label":{"api":{"Stream":[[17,22]],"Stream.reduce()":[[85,99]]}}},{"text":"Well if you looked at the documentation of JOptionPane you could have seen","label":{"api":{"JOptionPane":[[43,53]]}}},{"text":"public Object[] getSelectionValues()","label":{"api":{"getSelectionValues()":[[16,35]]}}},{"text":"And public Object getValue()","label":{"api":{"getValue()":[[18,27]]}}},{"text":"Imagine you're now inserting objects of type Double and Long, and later you try to use Long#reverse","label":{"api":{"Double":[[45,50]],"Long":[[56,59]],"Long#reverse":[[87,98]]}}},{"text":"You can use an ExecutorService","label":{"api":{"ExecutorService":[[15,29]]}}},{"text":"Then don't forget to shutdown()","label":{"api":{"shutdown()":[[21,30]]}}},{"text":"Your download is executed in another Thread, this causes data to be downloaded simultaneously","label":{"api":{"Thread":[[37,42]]}}},{"text":"The Thread management is delegated to SwingWorker, the class extended by DownloadTask","label":{"api":{"Thread":[[4,9]],"SwingWorker":[[38,48]],"DownloadTask":[[73,84]]}}},{"text":"Your class should use Files.readAllLines() directly, avoid using arrays directly in favor of full list options and look something like this","label":{"api":{"Files.readAllLines()":[[22,41]]}}},{"text":"A DefaultTableCellRenderer instance uses a template component to render all cells (namely itself, see documentation)","label":{"api":{"DefaultTableCellRenderer":[[2,25]]}}},{"text":"Use JTable.convertRowIndexToModel and JTable.convertColumnIndexToModel to do that","label":{"api":{"JTable.convertRowIndexToModel":[[4,32]],"JTable.convertColumnIndexToModel":[[38,69]]}}},{"text":"Whenever you want to get a Map<…, List<…>> from a stream, you should first check, how the groupingBy collector fits in","label":{"api":{"Map<…, List<…>>":[[27,41]],"groupingBy":[[90,99]]}}},{"text":"Since you want the prefix \"foo:\" prepended, you’ll have to customize this group collector by inserting a mapping operation before collecting the items into a list","label":{"api":{"mapping":[[105,111]]}}},{"text":"You should use this method instead","label":{"api":{}}},{"text":"For example, you don't need to read the whole file into memory, just use Files.lines to get a Stream<String> with every line in the file","label":{"api":{"Files.lines":[[73,83]],"Stream<String>":[[94,107]]}}},{"text":"The reducing (squashing) the several UserObject instances with the same primary id into a single instance (per Collectors.reducing) so that in the end you actually get a Map<Integer,UserObject>","label":{"api":{"UserObject":[[37,46]],"Collectors.reducing":[[111,129]],"Map<Integer,UserObject>":[[170,192]]}}},{"text":"For completeness sake, using Java 8 you could achieve this with help of IntStream","label":{"api":{"IntStream":[[72,80]]}}},{"text":"You should probably use it instead of LocalDateTime, since that LocalDateTime does not have a time zone","label":{"api":{"LocalDateTime":[[38,50],[64,76]]}}},{"text":"And then, ZonedDateTime docs states that","label":{"api":{"ZonedDateTime":[[10,22]]}}},{"text":"This class handles conversion from the local time-line of LocalDateTime to the instant time-line of Instant","label":{"api":{"LocalDateTime":[[58,70]]}}}]