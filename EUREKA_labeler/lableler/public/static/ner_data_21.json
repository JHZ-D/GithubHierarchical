[{"text": "From the ExecutorService class Javadoc", "label": {"api": {"ExecutorService": [[9, 23]]}}}, {"text": "An ExecutorService can be shut down, which will cause it to reject new tasks", "label": {"api": {"ExecutorService": [[3, 17]]}}}, {"text": "Two different methods are provided for shutting down an ExecutorService", "label": {"api": {"ExecutorService": [[56, 70]]}}}, {"text": "You need to use flatMap to flatten the arrays", "label": {"api": {"flatMap": [[16, 22]]}}}, {"text": "Additionally, you can use distinct() on the stream instead of collecting into a HashSet", "label": {"api": {"distinct()": [[26, 35]]}}}, {"text": "The reason for the extra hours is because of the difference between your time zone and the default GMT of the JVM when creating the Date", "label": {"api": {"Date": [[132, 135]]}}}, {"text": "Since Java-8 you have a new option to use List.replaceAll", "label": {"api": {"List.replaceAll": [[42, 56]]}}}, {"text": "You should add ExcelFile.close() [ref] in your catch block and after you are done using the resource", "label": {"api": {"ref": [[34, 36]]}}}, {"text": "As such, calling LoadingCache.get(K) from CacheLoader.load(K) creates a recursive load that, if allowed to execute, would recurse too deeply causing a StackOverflowError to be thrown", "label": {"api": {"StackOverflowError": [[151, 168]]}}}, {"text": "Yes, this is what the flatMap operation is for", "label": {"api": {"flatMap": [[22, 28]]}}}, {"text": "A reduce method of a Java Stream", "label": {"api": {"reduce method": [[2, 14]]}}}, {"text": "Collection and Collections are very good tools to store Objects and apply some algorithms on them", "label": {"api": {"Collection": [[0, 9], [15, 24]], "Collections": [[15, 25]]}}}, {"text": "The apparent pause between each cycle is caused by the interpolator, which by default uses Interpolator.EASE_BOTH (so it decelerates at the end of each cycle and accelerates at the beginning)", "label": {"api": {"interpolator": [[55, 66]]}}}, {"text": "To remove this, just set the interpolator to Interpolator.LINEAR", "label": {"api": {"interpolator": [[29, 40]]}}}, {"text": "You can use flatMapToInt", "label": {"api": {"flatMapToInt": [[12, 23]]}}}, {"text": "Then, we sum the values with sum()", "label": {"api": {"sum()": [[29, 33]]}}}, {"text": "Otherwise, you are very likely to run afoul of the contract for equals()", "label": {"api": {"contract for equals()": [[51, 71]]}}}, {"text": "To compare objects, you should use the Comparable.compareTo method", "label": {"api": {"Comparable": [[39, 48]]}}}, {"text": "Note that this requires your elements to implement the Comparable interface - which common types like Integer, Double etc do, as well as things like String (which implements it consistently with lexicographic order)", "label": {"api": {"Comparable": [[55, 64]]}}}, {"text": "If your element class does not implement Comparable (and you can't make change it to implement it), you can use an \"external\" form of Comparable called Comparator, which is an interface like this", "label": {"api": {"Comparable": [[41, 50], [134, 143]], "Comparator": [[152, 161]]}}}, {"text": "where comparator is an instance of a class implementing Comparator<Student>", "label": {"api": {"Comparator": [[56, 65]]}}}, {"text": "(Actually, it can be Comparator<", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "If you know that the three doStuff() functions are running asynchronously, then you could try using Apache Commons IO TeeInputStream to copy the contents of the initial InputStream to a PipedOutputStream that is connected to a PipedInputStream that is being read by doStuff2()", "label": {"api": {"PipedOutputStream": [[186, 202]], "PipedInputStream": [[227, 242]]}}}, {"text": "Likewise you could set up a second TeeInputStream constructed using a second PipedOutputStream connected to a second PipedInputStream for doStuff3()", "label": {"api": {"PipedOutputStream": [[77, 93]], "PipedInputStream": [[117, 132]]}}}, {"text": "To this old class a few new methods have been added for conversion to/from java.time such as toInstant and from( Instant )", "label": {"api": {"toInstant": [[93, 101]], "from( Instant )": [[107, 121]]}}}, {"text": "You should always use PreparedStatement to interact with your database for multiple reasons", "label": {"api": {"PreparedStatement": [[22, 38]]}}}, {"text": "To see the wall-clock time for a particular time zone, apply a time zone (ZoneId) to get a ZonedDateTime", "label": {"api": {"ZoneId": [[74, 79]], "ZonedDateTime": [[91, 103]]}}}, {"text": "To generate strings in other formats, search Stack Overflow for many examples on using DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[87, 103]]}}}, {"text": "You are attempting to use ObjectInputStream.readObject() to fetch your serialized object from the file", "label": {"api": {"ObjectInputStream.readObject()": [[26, 55]]}}}, {"text": "Did you also use ObjectOutputStrem.writeObject() to originally write your object to the file", "label": {"api": {"ObjectOutputStrem.writeObject()": [[17, 47]]}}}, {"text": "Use an ArrayList instead of an array", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "Arrays are tedious to resize and shift elements, but ArrayList does it for you", "label": {"api": {"ArrayList": [[53, 61]]}}}, {"text": "See the remove() method", "label": {"api": {"remove()": [[8, 15]]}}}, {"text": "This information is easily accessible if you had referred to the [File docs]", "label": {"api": {"File docs": [[66, 74]]}}}, {"text": "Note that we could use a UnaryOperator<T> instead of Function<T, T>", "label": {"api": {"UnaryOperator<T>": [[25, 40]]}}}, {"text": "if you want to return a native query's results to an object I would suggest using SqlResultSetMapping", "label": {"api": {"SqlResultSetMapping": [[82, 100]]}}}, {"text": "But if you are talking about Snake game, it could be done with Timer and ActionListener classes", "label": {"api": {"Timer": [[63, 67]], "ActionListener": [[73, 86]]}}}, {"text": "You can construct a case-insensitive parser by using a DateTimeFormatterBuilder and calling parseCaseInsensitive()", "label": {"api": {"DateTimeFormatterBuilder": [[55, 78]], "parseCaseInsensitive()": [[92, 113]]}}}, {"text": "File.delete() simply returns a boolean, and value false cannot explain why", "label": {"api": {"File.delete()": [[0, 12]]}}}, {"text": "For me, \"naïve\" is something like using Map.merge() to collect lines by unique keys (id values)", "label": {"api": {"Map.merge()": [[40, 50]]}}}, {"text": "nextInt(int) produces a number from 0 (inclusive) to n (exclusive)", "label": {"api": {"nextInt(int)": [[0, 11]]}}}, {"text": "You open a modal window, using window.showAndWait(), then after closing the window you need to get the selected result from that modal window", "label": {"api": {"window.showAndWait()": [[31, 50]]}}}, {"text": "Documentation for window.showAndWait()", "label": {"api": {"window.showAndWait()": [[18, 37]]}}}, {"text": "For example, a method like Line2D#ptLineDistSq will still use the double values", "label": {"api": {"Line2D#ptLineDistSq": [[27, 45]]}}}, {"text": "Note that read() only needs to read only (at least) one character if the end of the stream has not been reached", "label": {"api": {"at least": [[42, 49]]}}}, {"text": "To change a line colour, you can use setStroke", "label": {"api": {"setStroke": [[37, 45]]}}}, {"text": "You will note I put the line object creation on its own line, so you can execute the setStroke method", "label": {"api": {"setStroke": [[85, 93]]}}}, {"text": "startCalendar.MONTH is the same as Calendar.MONTH, and is a static field declared in the Calendar class as", "label": {"api": {"Calendar.MONTH": [[5, 18], [35, 48]], "Calendar": [[5, 12], [35, 42], [89, 96]]}}}, {"text": "To get the month from the calendar, you need to call get()", "label": {"api": {"get()": [[53, 57]]}}}, {"text": "Calendar.MONTH), never by a reference variable (e.g", "label": {"api": {"Calendar.MONTH": [[0, 13]], "Calendar": [[0, 7]]}}}, {"text": "startCalendar.MONTH) and never by subclass (e.g", "label": {"api": {"Calendar.MONTH": [[5, 18]], "Calendar": [[5, 12]]}}}, {"text": "Therefore, I suggest using URLEncoder as follows", "label": {"api": {"URLEncoder": [[27, 36]]}}}, {"text": "TextFieldTableCell provides a method to create a cell factory given a converter", "label": {"api": {"TextFieldTableCell": [[0, 17]]}}}, {"text": "As converter a LocalDateTimeStringConverter can be used", "label": {"api": {"LocalDateTimeStringConverter": [[15, 42]]}}}, {"text": "One thing to note is that forEach does not guarantee that the parallel actions execute in the same order of the stream elements, so the printed lines in this case may not be in the same order with the original Web page (see https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-": [[224, 330]]}}}, {"text": "You're getting the transaction, then committing it, but you've never begun it", "label": {"api": {"begun": [[69, 73]]}}}, {"text": "If you want to maintain the order you need to use a specialized implementation, e.g., a LinkedHashSet, the retains the order of insertion", "label": {"api": {"LinkedHashSet": [[88, 100]]}}}, {"text": "One way of doing it whilst still keeping the keys as Strings would be to use the Treemap(Comparator) constructor", "label": {"api": {"Treemap(Comparator)": [[81, 99]]}}}, {"text": "If you are looking to process numbers with multiple digits, use String.split on the comma first", "label": {"api": {"String.split": [[64, 75]]}}}, {"text": "After than go through the array of strings, and parse each number using Integer.parseInt method", "label": {"api": {"Integer.parseInt": [[72, 87]]}}}, {"text": "I have a question on the differences between the Bits class from the LibGDX library and the BitSet class in the standard Java library", "label": {"api": {"BitSet": [[92, 97]]}}}, {"text": "You need to call ResultSet#next() to \"move the cursor forward one row from its current position.\" As you are expecting a single row to be returned from your query, you can call this in an if statement as shown below", "label": {"api": {"ResultSet#next()": [[17, 32]]}}}, {"text": "The documentation states that this uses the default charset for your platform, which may be UTF-8, Latin-1 or whatever regional default", "label": {"api": {"default charset": [[44, 58]]}}}, {"text": "Investigate that point and use either this String ctor or, if you want to be notified when the input contains undecodable garbage, the CharsetDecoder class", "label": {"api": {"this String ctor": [[38, 53]], "CharsetDecoder class": [[135, 154]]}}}, {"text": "If the messages are text-based and newline-delimited, you should definitely use a BufferedReader to read from the stream", "label": {"api": {"BufferedReader": [[82, 95]]}}}, {"text": "Assuming that your SP serial port is an InputStream, you could create a BufferedReader over it, and then call the readLine() method on the reader", "label": {"api": {"BufferedReader": [[72, 85]]}}}, {"text": "You have to cast the PublicKey to an RSAPublicKey, e.g", "label": {"api": {"PublicKey": [[21, 29], [40, 48]], "RSAPublicKey": [[37, 48]]}}}, {"text": "Try using getCanonicalHostName() rather than getHostName()", "label": {"api": {"getCanonicalHostName()": [[10, 31]], "getHostName()": [[45, 57]]}}}, {"text": "So we use Collectors.groupingBy(classifier, downstream) where the classifier returns that warehouseId", "label": {"api": {"Collectors.groupingBy(classifier, downstream)": [[10, 54]]}}}, {"text": "In this case, we only want to keep the widget, so we use Collectors.mapping(mapper, downstream) where the mapper returns the widget from the Map.Entry<Stock, Widget> and the downstream collectors collect into a list with Collectors.toList()", "label": {"api": {"Collectors.mapping(mapper, downstream)": [[57, 94]], "Collectors.toList()": [[221, 239]]}}}, {"text": "Yes, you need to use setNull method", "label": {"api": {"setNull": [[21, 27]]}}}, {"text": "To access a member of an ArrayList you should use get(int index)", "label": {"api": {"ArrayList": [[25, 33]], "get(int index)": [[50, 63]]}}}, {"text": "Java 6 introduced Locale.ROOT which is described as", "label": {"api": {"Locale.ROOT": [[18, 28]]}}}, {"text": "Both the blocking lock() and non-blocking trylock() methods will throw OverlappingFileLockException \"If a lock that overlaps the requested region is already held by this Java virtual machine, or if another thread is already blocked in this method and is attempting to lock an overlapping region of the same file\", as documented in the FileChannel javadoc", "label": {"api": {"FileChannel javadoc": [[335, 353]]}}}, {"text": "In Java, you really want to use Integer.toString to convert an integer to its corresponding String value", "label": {"api": {"Integer.toString": [[32, 47]]}}}, {"text": "When your only problem is waiting for the result, use ExecutorService for spawning your threads", "label": {"api": {"ExecutorService": [[54, 68]]}}}, {"text": "It can accept work jobs both as Runnable and Callable", "label": {"api": {"Runnable": [[32, 39]], "Callable": [[45, 52]]}}}, {"text": "When you use the latter, then you are given a Future object in return, that can be used to wait for the result", "label": {"api": {"Future": [[46, 51]]}}}, {"text": "You should consider using ExecutorService anyway, as from what I understand, you create many threads, and this is a perfect use case for executor services", "label": {"api": {"ExecutorService": [[26, 40]]}}}, {"text": "You can actually get it, by using the FileDescriptor class", "label": {"api": {"FileDescriptor": [[38, 51]]}}}, {"text": "Calling new PrintStream(new FileOutputStream(FileDescriptor.out))) should give you something which prints to stdout", "label": {"api": {"FileDescriptor": [[45, 58]]}}}, {"text": "Since Java 5, you can use java.util.concurrent.TimeUnit to avoid the use of Magic Numbers like 1000 and 60 in your code", "label": {"api": {"java.util.concurrent.TimeUnit": [[26, 54]]}}}, {"text": "You can find detail in java.util.Date javadoc", "label": {"api": {"java.util.Date": [[23, 36]]}}}, {"text": "Since Java 7 you can use java.nio.file.Files.delete and java.nio.file.Files.move", "label": {"api": {"java.nio.file.Files.delete": [[25, 50]], "java.nio.file.Files.move": [[56, 79]]}}}, {"text": "The key point is that you should use FaceletContext#includeFacelet() to include the composite component resource in the given parent", "label": {"api": {"FaceletContext#includeFacelet()": [[37, 67]]}}}, {"text": "Update since JSF 2.2, the ViewDeclarationLanguage class got a new createComponent() method taking the taglib URI and tag name which could also be used for this purpose", "label": {"api": {"createComponent()": [[66, 82]]}}}, {"text": "See the documentation for Enum.ordinal()", "label": {"api": {"documentation for Enum.ordinal()": [[8, 39]]}}}, {"text": "This method uses the Java ByteBuffer and ByteOrder functionality in the java.nio package", "label": {"api": {"ByteBuffer": [[26, 35]], "ByteOrder": [[41, 49]], "java.nio": [[72, 79]]}}}, {"text": "To create a Big Endian version you can simply leave out the call to order(ByteOrder)", "label": {"api": {"ByteOrder": [[74, 82]], "order(ByteOrder)": [[68, 83]]}}}, {"text": "In Java 8 you can also make use of the Integer.BYTES constant, which is more succinct than Integer.SIZE / Byte.SIZE", "label": {"api": {"Integer.BYTES": [[39, 51]]}}}, {"text": "You can use the Arrays.toString() static helper method as follows", "label": {"api": {"Arrays.toString()": [[16, 32]]}}}, {"text": "Read the javadoc of Object.clone() more carefully", "label": {"api": {"javadoc of Object.clone()": [[9, 33]]}}}, {"text": "If it's been sent as the raw request body, then use ServletRequest#getInputStream()", "label": {"api": {"ServletRequest#getInputStream()": [[52, 82]]}}}, {"text": "If it's been sent as a regular application/x-www-form-urlencoded request parameter, then use ServletRequest#getParameter()", "label": {"api": {"ServletRequest#getParameter()": [[93, 121]]}}}, {"text": "If it's been sent as an uploaded file in flavor of a multipart/form-data part, then use HttpServletRequest#getPart()", "label": {"api": {"HttpServletRequest#getPart()": [[88, 115]]}}}, {"text": "Just for completeness, wanted to point out the way to get this without having to grab the current instance of the ClassLoader,  using ClassLoader#getSystemResource", "label": {"api": {"ClassLoader#getSystemResource": [[134, 162]]}}}, {"text": "Use of Executors/Thread Pools can avoid the overhead, by reusing threads for multiple tasks for Executor", "label": {"api": {"Executors": [[7, 15]], "Executor": [[7, 14], [96, 103]]}}}, {"text": "Just use the ProcessBuilder and use the methods redirectOutput in combination with either redirectError or redirectErrorStream", "label": {"api": {"ProcessBuilder": [[13, 26]], "redirectOutput": [[48, 61]], "redirectError": [[90, 102], [107, 119]], "redirectErrorStream": [[107, 125]]}}}, {"text": "Another way of doing it is using the table model's getDataVector() method", "label": {"api": {"getDataVector()": [[51, 65]]}}}, {"text": "Therefore, simply drop the group-by from your criteria API query, and use cq.distinct(true) instead", "label": {"api": {"cq.distinct(true)": [[74, 90]]}}}, {"text": "You can implement a HttpSessionListener to track session creation and destroy using a logger", "label": {"api": {"HttpSessionListener": [[20, 38]]}}}, {"text": "This happens when the code calls HttpSession#invalidate()", "label": {"api": {"HttpSession#invalidate()": [[33, 56]]}}}, {"text": "This is trackable with a HttpSessionListener as well", "label": {"api": {"HttpSessionListener": [[25, 43]]}}}, {"text": "Wrap your Fileinputstream inside a BufferedInputStream", "label": {"api": {"BufferedInputStream": [[35, 53]]}}}, {"text": "You can use a PropertyDescriptor without an Inspector (which was suggested by Peter)", "label": {"api": {"PropertyDescriptor": [[14, 31]]}}}, {"text": "See the reference (section \"Classes for Unicode scripts, blocks, categories and binary properties\")", "label": {"api": {"the reference": [[4, 16]]}}}, {"text": "The first is to use the ListSelectionModel of the JTable and ensure that all of the matching rows are in the selected set; this will cause them to be visually distinguished with a minimum of coding", "label": {"api": {"ListSelectionModel": [[24, 41]]}}}, {"text": "The second way to accomplish this would be to use a custom TableCellRenderer that changes how a row is rendered if the row matches your selection criteria", "label": {"api": {"TableCellRenderer": [[59, 75]]}}}, {"text": "You can execute your statements in batch, some code example can be found here", "label": {"api": {"execute your statements in batch": [[8, 39]]}}}, {"text": "Use a int[] in most case and SortedMap<> for Unicode characters, avoid hidden Integer instantiation due to autoboxing", "label": {"api": {"SortedMap<>": [[29, 39]]}}}, {"text": "You can use the setDefaultCloseOperation() method of JDialog, specifying DISPOSE_ON_CLOSE", "label": {"api": {"setDefaultCloseOperation()": [[16, 41]]}}}, {"text": "MimetypesFileTypeMap, but I found this useful class MimeTypes and I did a little trick adding an extensions Mapping, remember this return the default extension by MimeType but can be inaccurate", "label": {"api": {"MimetypesFileTypeMap": [[0, 19]]}}}, {"text": "Apache Commons has one, or when you're already on Java 1.8, then use java.util.Base64", "label": {"api": {"java.util.Base64": [[69, 84]]}}}, {"text": "Java contains a Base64 class in the standard API since Java 1.8", "label": {"api": {"Base64 class": [[16, 27]]}}}, {"text": "It looks like in Java 7 you can just use System.lineSeparator()", "label": {"api": {"System.lineSeparator()": [[41, 62]]}}}, {"text": "However, if applicable and acceptable, it is more flexible than setClassAssertionStatus because it allows to enable/disable assertions checks at various points in the execution, even after the class is initialized", "label": {"api": {"setClassAssertionStatus": [[64, 86]]}}}, {"text": "For windows install pdf24 printer driver and for Linux use cups-pdf", "label": {"api": {"print": [[26, 30]]}}}, {"text": "After installation use print method of WebEngine", "label": {"api": {"print": [[23, 27]]}}}, {"text": "If using external library is ok for you, you could easily use ui4j to print Web page to pdf", "label": {"api": {"print": [[70, 74]]}}}, {"text": "How about java.net.HttpCookie", "label": {"api": {"java.net.HttpCookie": [[10, 28]]}}}, {"text": "Boolean.getBoolean probably doesn't do what you think it does", "label": {"api": {"Boolean.getBoolean": [[0, 17]]}}}, {"text": "Boolean.valueOf is probably what you're looking for", "label": {"api": {"Boolean.valueOf": [[0, 14]]}}}, {"text": "From the documentation for URLConnection", "label": {"api": {"URLConnection": [[27, 39]]}}}, {"text": "Java 8 - Integer(String)", "label": {"api": {"Java 8 - Integer(String)": [[0, 23]]}}}, {"text": "If you want to support all code points, use Character.toChars(int)", "label": {"api": {"Character.toChars(int)": [[44, 65]]}}}, {"text": "If you have Octal or Hex, parseInt take a radix as well", "label": {"api": {"parseInt": [[26, 33]]}}}, {"text": "you can use a new overload of Character.toString()", "label": {"api": {"a new overload of Character.toString()": [[12, 49]]}}}, {"text": "See that other answer for sample code, but the core of the idea is to set up an event loop for reading and writing (while loop with 10ms sleeping), and using low-level stream operations so that no caching and blocking is going on -- only try to read if you know the other process in fact wrote something (through InputStream.available())", "label": {"api": {"InputStream.available()": [[313, 335]]}}}, {"text": "See these functions of java.net.InetAddress - getLocalHost and getHostName", "label": {"api": {"getLocalHost": [[46, 57]], "getHostName": [[63, 73]]}}}, {"text": "This is also a good example of FileFilter used in JFileChooser", "label": {"api": {"FileFilter": [[31, 40]]}}}, {"text": "The basics are, you need to override FileFilter class and write your custom code in its accpet method", "label": {"api": {"FileFilter": [[37, 46]]}}}, {"text": "Or more simpler to use is FileNameFilter which has accept method with filename as argument, so you don't need to get it manually", "label": {"api": {"FileNameFilter": [[26, 39]]}}}, {"text": "I tried to do this with WatchService but I can't know from which directory the file was changed", "label": {"api": {"WatchService": [[24, 35]]}}}, {"text": "How can I retrieve the full path from the WatchEvent", "label": {"api": {"WatchEvent": [[42, 51]]}}}, {"text": "If you need Set rather than List, you can use EnumSet.allOf()", "label": {"api": {"EnumSet.allOf()": [[46, 60]]}}}, {"text": "You could use Queue instead of List", "label": {"api": {"Queue": [[14, 18]]}}}, {"text": "Be aware of the thread-safe behavior of Queue iterators, though (check the javadoc)", "label": {"api": {"Queue": [[40, 44]]}}}, {"text": "The method is definitely not deprecated and it's definitely not just used in IPv6", "label": {"api": {"definitely not deprecated": [[14, 38]]}}}, {"text": "Java 8 introduced the abstract class java.time.Clock which allows you to have an alternative implementation for testing", "label": {"api": {"java.time.Clock": [[37, 51]]}}}, {"text": "See the API for more information", "label": {"api": {"the API": [[4, 10]]}}}, {"text": "12.1.0.2) don't return sequence information when you call DatabaseMetaData#getTables with types set to [\"SEQUENCE\"], your best bet is to run the necessary query yourself, e.g.", "label": {"api": {"DatabaseMetaData#getTables": [[58, 83]]}}}, {"text": "Based on the answer of McDowell and his class IdMutexProvider, I have written the generic class LockMap that uses WeakHashMap to store lock objects", "label": {"api": {"WeakHashMap": [[114, 124]]}}}, {"text": "On the other hand, ReentrantLock provides methods for checking lock status, interruptible acquisition and acquisition with a timeout", "label": {"api": {"ReentrantLock": [[19, 31]]}}}, {"text": "The cancelation mechanism based on interruption is followed by Executors from java.util.concurrent", "label": {"api": {"Executors": [[63, 71]], "java.util.concurrent": [[78, 97]]}}}, {"text": "If you were on Java 8+, you could just use Stream#of()", "label": {"api": {"Stream#of()": [[43, 53]]}}}, {"text": "Try out this DocumentFilter", "label": {"api": {"DocumentFilter": [[13, 26]]}}}, {"text": "What happens if you call interrupt on a Thread before it calls Thread.sleep()", "label": {"api": {"Thread.sleep()": [[63, 76]]}}}, {"text": "Will the InterruptedException be thrown", "label": {"api": {"InterruptedException": [[9, 28]]}}}, {"text": "For more info, check out the API or the tutorials for Java 8", "label": {"api": {"the API": [[25, 31]]}}}, {"text": "You can use getSuperclass() up to the Object", "label": {"api": {"getSuperclass()": [[12, 26]]}}}, {"text": "Use Class.getSuperClass() to traverse the hierarchy", "label": {"api": {"Class.getSuperClass()": [[4, 24]]}}}, {"text": "Java 7 introduced ThreadLocalRandom which is isolated to the current thread", "label": {"api": {"ThreadLocalRandom": [[18, 34]]}}}, {"text": "This uses Formatter and relative indexing instead of SimpleDateFormat which is not thread-safe, btw", "label": {"api": {"Formatter": [[10, 18]]}}}, {"text": "Charsets.US_ASCII is of Charset type (not String) so you avoid checked UnsupportedEncodingException thrown only from String.getBytes(String), but not from String.getBytes(Charset)", "label": {"api": {"UnsupportedEncodingException": [[71, 98]], "String.getBytes(String)": [[117, 139]], "String.getBytes(Charset)": [[155, 178]]}}}, {"text": "In Java 7 there is equivalent StandardCharsets class", "label": {"api": {"StandardCharsets": [[30, 45]]}}}, {"text": "Who is looking for how to iterate the queue following the order, this can be achieved by using poll or remove", "label": {"api": {"poll": [[95, 98]], "remove": [[103, 108]]}}}, {"text": "The only diference between poll() and remove(), is that poll returns null when is empty and remove throws a NoSuchElementException", "label": {"api": {"poll": [[27, 30], [56, 59]], "remove": [[38, 43], [92, 97]]}}}, {"text": "Java 8 may finally bring a solution to this, but unfortunately (for Swing apps) it comes only as the JavaFX class FileChooser", "label": {"api": {"FileChooser": [[114, 124]]}}}, {"text": "With new Java 8 Stream API it actually becomes very elegant", "label": {"api": {"Stream API": [[16, 25]]}}}, {"text": "In Jersey 2.0, you'll want to use BeanParam to seamlessly provide what you're looking for in the normal Jersey style", "label": {"api": {"BeanParam": [[34, 42]]}}}, {"text": "From the above linked doc page, you can use BeanParam to do something like", "label": {"api": {"BeanParam": [[44, 52]]}}}, {"text": "You can use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[12, 29]]}}}, {"text": "1) I don't know if you can extend the class Principal", "label": {"api": {"Principal": [[44, 52]]}}}, {"text": "But note, in your LoginModule, before you finish the authentication calling the commit() (probably in your login() method), it is possible to add credentials in the Subject", "label": {"api": {"LoginModule": [[18, 28]], "commit()": [[80, 87]], "login()": [[107, 113]], "Subject": [[165, 171]]}}}, {"text": "Subject.getPrivateCredentials() or Subject.getPublicCredentials() (with no arguments)", "label": {"api": {"Subject": [[0, 6], [35, 41]], "getPrivateCredentials()": [[8, 30]], "getPublicCredentials()": [[43, 64]]}}}, {"text": "You can add a VM shutdown hook", "label": {"api": {"VM shutdown hook": [[14, 29]]}}}, {"text": "The idea looks ok, but I would suggest using Math.atan2 instead of Math.atan", "label": {"api": {"Math.atan2": [[45, 54]]}}}, {"text": "Here's an example using Arrays.deepEquals", "label": {"api": {"Arrays.deepEquals": [[24, 40]]}}}, {"text": "The advantage of using java.io.PipedInputStream and java.io.PipedOutputStream is that there is no additional consumption of memory", "label": {"api": {"java.io.PipedInputStream": [[23, 46]], "java.io.PipedOutputStream": [[52, 76]]}}}, {"text": "As an alternative to @Edwin Dalorzo's suggestion, you can call nextInt() to grab the next token from the input stream and try to convert it to an int", "label": {"api": {"try to convert it to an int": [[122, 148]]}}}, {"text": "How to convert a Long value into an Integer value in Java", "label": {"api": {"Long": [[17, 20]], "Integer": [[36, 42]]}}}, {"text": "The implementation is dead simple, and throws IllegalArgumentException on overflow", "label": {"api": {"IllegalArgumentException": [[46, 69]]}}}, {"text": "In Java 8 you can use toIntExact", "label": {"api": {"toIntExact": [[22, 31]]}}}, {"text": "Good thing about this method is that it throws an ArithmeticException if the argument (long) overflows an int", "label": {"api": {"ArithmeticException": [[50, 68]]}}}, {"text": "Use the String.toCharArray() method", "label": {"api": {"String.toCharArray()": [[8, 27]]}}}, {"text": "Starting from Java 8 you can use Stream", "label": {"api": {"Stream": [[33, 38]]}}}, {"text": "The java.util.logging.Level documentation does a good job of defining when to use a log level and the target audience of that log level", "label": {"api": {"java.util.logging.Level": [[4, 26]]}}}, {"text": "It should be in the class level documentation but instead the Level.FINE field provides a good overview", "label": {"api": {"FINE": [[68, 71]]}}}, {"text": "FINE is a message level providing tracing information", "label": {"api": {"FINE": [[0, 3]]}}}, {"text": "All of FINE, FINER, and FINEST are intended for relatively detailed tracing", "label": {"api": {"FINE": [[7, 10], [13, 16], [24, 27]], "FINER": [[13, 17]], "FINEST": [[24, 29]]}}}, {"text": "The exact meaning of the three levels will vary between subsystems, but in general, FINEST should be used for the most voluminous detailed output, FINER for somewhat less detailed output, and FINE for the lowest volume (and most important) messages", "label": {"api": {"FINE": [[84, 87], [147, 150], [192, 195]], "FINER": [[147, 151]], "FINEST": [[84, 89]]}}}, {"text": "In general the FINE level should be used for information that will be broadly interesting to developers who do not have a specialized interest in the specific subsystem", "label": {"api": {"FINE": [[15, 18]]}}}, {"text": "FINE messages might include things like minor (recoverable) failures", "label": {"api": {"FINE": [[0, 3]]}}}, {"text": "Issues indicating potential performance problems are also worth logging as FINE", "label": {"api": {"FINE": [[75, 78]]}}}, {"text": "One important thing to understand which is not mentioned in the level documentation is that call-site tracing information is logged at FINER", "label": {"api": {"FINE": [[135, 138]], "call-site tracing information is logged at FINER": [[92, 139]], "FINER": [[135, 139]]}}}, {"text": "If you log a message as FINE you will be able to configure logging system to see the log output with or without flow control log records surrounding the log message", "label": {"api": {"FINE": [[24, 27]]}}}, {"text": "So use FINE only when flow control log records are not required as context to understand this log tracing message", "label": {"api": {"FINE": [[7, 10]]}}}, {"text": "FINER indicates a fairly detailed tracing message", "label": {"api": {"FINE": [[0, 3]], "FINER": [[0, 4]]}}}, {"text": "By default logging calls for entering, returning, or throwing an exception are traced at this level", "label": {"api": {"entering": [[29, 36]], "throwing": [[53, 60]]}}}, {"text": "In general, most use of FINER should be left to call of entering, exiting, and throwing", "label": {"api": {"FINE": [[24, 27]], "FINER": [[24, 28]], "entering": [[56, 63]], "exiting": [[66, 72]], "throwing": [[79, 86]]}}}, {"text": "That will for the most part reserve FINER for call-site tracing when verbose logging is turned on", "label": {"api": {"FINE": [[36, 39]], "FINER": [[36, 40]]}}}, {"text": "FINEST indicates a highly detailed tracing message", "label": {"api": {"FINE": [[0, 3]], "FINEST": [[0, 5]]}}}, {"text": "Use FINEST when the tracing log message you are about to write requires context information about program control flow", "label": {"api": {"FINE": [[4, 7]], "FINEST": [[4, 9]]}}}, {"text": "You should also use FINEST for tracing messages that produce large amounts of output data", "label": {"api": {"FINE": [[20, 23]], "FINEST": [[20, 25]]}}}, {"text": "CONFIG messages are intended to provide a variety of static configuration information, to assist in debugging problems that may be associated with particular configurations", "label": {"api": {"CONFIG": [[0, 5]]}}}, {"text": "For example, CONFIG message might include the CPU type, the graphics depth, the GUI look-and-feel, etc", "label": {"api": {"CONFIG": [[13, 18]]}}}, {"text": "The CONFIG works well for assisting system admins with the items listed above", "label": {"api": {"CONFIG": [[4, 9]]}}}, {"text": "In general WARNING messages should describe events that will be of interest to end users or system managers, or which indicate potential problems", "label": {"api": {"WARNING": [[11, 17]]}}}, {"text": "An example use case could be exceptions thrown from AutoCloseable.close implementations", "label": {"api": {"AutoCloseable.close": [[52, 70]]}}}, {"text": "In general SEVERE messages should describe events that are of considerable importance and which will prevent normal program execution", "label": {"api": {"SEVERE": [[11, 16]]}}}, {"text": "For example, if you have transaction in your program where if any one of the steps fail then all of the steps voided then SEVERE would be appropriate to use as the log level", "label": {"api": {"SEVERE": [[122, 127]]}}}, {"text": "The most efficient ways (according to my benchmark) are to use the new HashMap.forEach() method added in Java 8 or HashMap.entrySet().forEach()", "label": {"api": {"HashMap.forEach()": [[71, 87]]}}}, {"text": "If you need to set the ascent+descent to the pixel size, you can correct the value using the FontMetrics", "label": {"api": {"FontMetrics": [[93, 103]]}}}, {"text": "The solution in my case was to extend JacksonJsonProvider, catch the specific Jackson json exceptions, and rethrow them as WebApplicationException", "label": {"api": {"WebApplicationException": [[123, 145]]}}}, {"text": "This violates the expectation of the Statement class (see here - http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html": [[65, 128]]}}}, {"text": "It uses this constructor to instantiate a Date that refers to zero milliseconds after (i.e", "label": {"api": {"this constructor": [[8, 23]]}}}, {"text": "Perhaps you can use ByteBuffer which allows order(ByteOrder.LITTLE_ENDIAN)  After that most of the methods are like DataInputStream", "label": {"api": {"order(ByteOrder.LITTLE_ENDIAN)": [[44, 73]]}}}, {"text": "As mentioned in comments, a StringBuilder is probably a faster implementation than using a StringBuffer", "label": {"api": {"StringBuilder": [[28, 40]], "StringBuffer": [[91, 102]]}}}, {"text": "This class provides an API compatible with StringBuffer, but with no guarantee of synchronization", "label": {"api": {"StringBuffer": [[43, 54]]}}}, {"text": "This class is designed for use as a drop-in replacement for StringBuffer in places where the string buffer was being used by a single thread (as is generally the case)", "label": {"api": {"StringBuffer": [[60, 71]]}}}, {"text": "Where possible, it is recommended that this class be used in preference to StringBuffer as it will be faster under most implementations", "label": {"api": {"StringBuffer": [[75, 86]]}}}, {"text": "Or if you need synchronization use the StringBuffer with similar usage", "label": {"api": {"StringBuffer": [[39, 50]]}}}, {"text": "A main purpose of a Set is to not have duplicates", "label": {"api": {"Set": [[20, 22]]}}}, {"text": "You either don't want a Set or you need a different Comparator", "label": {"api": {"Set": [[24, 26]]}}}, {"text": "Here the DateTimeFormatter pattern of \"yyyy-MM-dd[[ ]['T']HH:mm[:ss][XXX]]\" allows optionals within the square parentheses which can also be nested", "label": {"api": {"DateTimeFormatter": [[9, 25]]}}}, {"text": "Patterns can also be constructed from a DateTimeFormatterBuilder, which the above pattern is demonstrated here", "label": {"api": {"DateTimeFormatter": [[40, 56]], "DateTimeFormatterBuilder": [[40, 63]]}}}, {"text": "Worth mentioning Java 8 approach, using BiConsumer and lambda functions", "label": {"api": {"BiConsumer": [[40, 49]]}}}, {"text": "If all you want to do is read the same information more than once, and the input data is small enough to fit into memory, you can copy the data from your InputStream to a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[171, 191]]}}}, {"text": "Then you can obtain the associated array of bytes and open as many \"cloned\" ByteArrayInputStreams as you like", "label": {"api": {"ByteArrayInputStream": [[76, 95]]}}}, {"text": "Since Java 9 the the middle bits can be replaced with InputStream.transferTo", "label": {"api": {"InputStream.transferTo": [[54, 75]]}}}, {"text": "Or use Java8's Arrays#stream()", "label": {"api": {"Arrays#stream()": [[15, 29]]}}}, {"text": "The Random class uses a 48-bit seed that's conveniently divided into three pieces of 16 bits in each, like so", "label": {"api": {"Random": [[4, 9]]}}}, {"text": "Considering from java.io.File source code, list() method does", "label": {"api": {"java.io.File": [[17, 28]], "list()": [[43, 48]]}}}, {"text": "InetAddress has getByName() method to determine the IP address of a host, given the host's name", "label": {"api": {"getByName()": [[16, 26]]}}}, {"text": "So , you just try to catch an UnknownHostException when calling InetAddress.getByName()", "label": {"api": {"getByName()": [[76, 86]]}}}, {"text": "You have the Method class", "label": {"api": {"Method": [[13, 18]]}}}, {"text": "Using Java 8's Stream.filter() method in combination with List.contains()", "label": {"api": {"Stream.filter()": [[15, 29]], "List.contains()": [[58, 72]]}}}, {"text": "ExecutorService.submit(...) returns a Future<?> that has a cancel() method", "label": {"api": {"ExecutorService.submit(...)": [[0, 26]]}}}, {"text": "Use a LinkedHashMap instead", "label": {"api": {"LinkedHashMap": [[6, 18]]}}}, {"text": "I heard about java.util.logging, but I don't know how to begin", "label": {"api": {"java.util.logging": [[14, 30]]}}}, {"text": "Take a look at the java.util.logging package", "label": {"api": {"java.util.logging": [[19, 35]]}}}, {"text": "Without hard-coding the class name", "label": {"api": {"class name": [[24, 33]]}}}, {"text": "java.util.logging keeps you from having to tote one more jar file around with your application, and it works well with a good Formatter", "label": {"api": {"java.util.logging": [[0, 16]]}}}, {"text": "Then, you can just use various facilities of the Logger class", "label": {"api": {"Logger": [[49, 54]]}}}, {"text": "In the File class there are two strings, separator and pathSeparator", "label": {"api": {"separator": [[41, 49]], "pathSeparator": [[55, 67]]}}}, {"text": "It's available by HttpServletRequest#getUserPrincipal() or its shorthand HttpServletRequest#getRemoteUser()", "label": {"api": {"HttpServletRequest#getUserPrincipal()": [[18, 54]], "HttpServletRequest#getRemoteUser()": [[73, 106]]}}}, {"text": "However have a look at java.nio.channels.FileLock for the relevant API calls", "label": {"api": {"java.nio.channels.FileLock": [[23, 48]]}}}, {"text": "Use the Set#toArray(T[]) method taking a typed array argument of the same size", "label": {"api": {"Set#toArray(T[])": [[8, 23]]}}}, {"text": "The JDBC driver implementation should register itself in the static initializer", "label": {"api": {"should": [[31, 36]]}}}, {"text": "If you are developing with JDK 1.5 you can solve this using java.util.Formatter", "label": {"api": {"java.util.Formatter": [[60, 78]]}}}, {"text": "Heinz Kabutz's newsletter shows how to abort System.in reads using a buffer and ExecutorService", "label": {"api": {"buffer": [[69, 74]], "ExecutorService": [[80, 94]]}}}, {"text": "I'm doing this in Java and found the nextGaussian() method in the Random class, but I'm not sure how to use this in my situation", "label": {"api": {"Random class": [[66, 77]]}}}, {"text": "In Java 9, you can now use Matcher#results() to get a Stream<MatchResult> which you can use to get a list/array of matches", "label": {"api": {"Matcher#results()": [[27, 43]], "Stream<MatchResult>": [[54, 72]]}}}, {"text": "These days it's quite easy to get what you need without Guava, thanks to Map#computeIfAbsent()", "label": {"api": {"Map#computeIfAbsent()": [[73, 93]]}}}, {"text": "I'd recommend using File.createTempFile(String prefix, String suffix) which creates an empty file that doesn't collide with anything else on the file system", "label": {"api": {"File.createTempFile(String prefix, String suffix)": [[20, 68]]}}}, {"text": "You can use File.deleteOnExit to ensure that it's deleted when the program exits", "label": {"api": {"File.deleteOnExit": [[12, 28]]}}}, {"text": "Note that this requires Java 8 (Stream Documentation)", "label": {"api": {"Stream Documentation": [[32, 51]]}}}, {"text": "Here's a solution using Java 11's Files.readString", "label": {"api": {"Files.readString": [[34, 49]]}}}, {"text": "Similar to the previously posted solutions, the newTaskFor methods for Runnable and Callable can be overwritten in order to wrap the argument (see accepted solution) when creating the RunnableFuture", "label": {"api": {"newTaskFor": [[48, 57]]}}}, {"text": "For the ScheduledThreadPoolExecutor, the decorateTask methods would be overwritten instead", "label": {"api": {"decorateTask": [[41, 52]]}}}, {"text": "Sounds like a job for the good and old Introspector", "label": {"api": {"Introspector": [[39, 50]]}}}, {"text": "The nextFloat method doesn't take an argument", "label": {"api": {"nextFloat": [[4, 12]]}}}, {"text": "Are you implementing a thread-pooling mechanism similar to ExecutorService.submit() that requires you to forward exceptions back to the user so they can handle it", "label": {"api": {"ExecutorService.submit()": [[59, 82]]}}}, {"text": "Then you need to override setBorder() method", "label": {"api": {"setBorder()": [[26, 36]]}}}, {"text": "Then, you should also override the paintComponent() method", "label": {"api": {"paintComponent()": [[35, 50]]}}}, {"text": "Once a ServerSocket is created, it is bound (unless it uses the parameterless constructor java.net.ServerSocket.ServerSocket())", "label": {"api": {"java.net.ServerSocket.ServerSocket()": [[90, 125]]}}}, {"text": "Use the java.time classes in Java 8 and later", "label": {"api": {"java.time": [[8, 16]]}}}, {"text": "Calling ofEpochDay(long epochDay) obtains an instance of LocalDate from the epoch day count", "label": {"api": {"ofEpochDay(long epochDay)": [[8, 32]], "LocalDate": [[57, 65]]}}}, {"text": "System.arraycopy() is a shallow copy method", "label": {"api": {"System.arraycopy()": [[0, 17]]}}}, {"text": "By default, SwingWorker reuses worker threads, so it is perfectly normal that, even though, doInBackground() has returned, to still see the thread that executed your method", "label": {"api": {"SwingWorker": [[12, 22]]}}}, {"text": "SwingWorker-pool-1-thread-1, where that pool is managed by SwingWorker", "label": {"api": {"SwingWorker": [[0, 10], [59, 69]]}}}, {"text": "If you want more control, you can also pass the SwingWorker instance to an Executor", "label": {"api": {"SwingWorker": [[48, 58]], "Executor": [[75, 82]]}}}, {"text": "Just check SwingWorker and Executor javadoc for further information", "label": {"api": {"SwingWorker": [[11, 21]], "Executor": [[27, 34]]}}}, {"text": "Besides, SwingWorker.cancel() is not supposed to be called from doInBackground() but rather from another thread, generally the EDT, e.g", "label": {"api": {"SwingWorker": [[9, 19]]}}}, {"text": "For why, see the Javadoc", "label": {"api": {"see the Javadoc": [[9, 23]]}}}, {"text": "Use BufferedImage.TYPE_INT_ARGB or BufferedImage.TYPE_INT_RGB, as shown in this example", "label": {"api": {"BufferedImage.TYPE_INT_ARGB": [[4, 30]], "BufferedImage.TYPE_INT_RGB": [[35, 60]]}}}, {"text": "If you need to change the colors, you can use a LookupOp with a four-component LookupTable that adjusts the alpha component as required for BufferedImage.TYPE_3BYTE_BGR", "label": {"api": {"LookupOp": [[48, 55]], "BufferedImage.TYPE_3BYTE_BGR": [[140, 167]]}}}, {"text": "\"When data with non-opaque alpha is stored in an image of this type, the color data must be adjusted to a non-premultiplied form and the alpha discarded.\" Examples may be found in Using the Java 2D LookupOp Filter Class to Process Images and Image processing with Java 2D", "label": {"api": {"LookupOp": [[198, 205]]}}}, {"text": "If this is your use case, then you can chain input streams via SequenceInputStream to achieve the same result", "label": {"api": {"SequenceInputStream": [[63, 81]]}}}, {"text": "DateTimeFormatter is thread-safe and can do the same work as SimpleDateFormat", "label": {"api": {"DateTimeFormatter": [[0, 16]]}}}, {"text": "How about java.util.Arrays.asList", "label": {"api": {"java.util.Arrays.asList": [[10, 32]]}}}, {"text": "With Java 7, you can use Path, Paths, and Files", "label": {"api": {"Java 7": [[5, 10]], "Path": [[25, 28], [31, 34]], "Paths": [[31, 35]], "Files": [[42, 46]]}}}, {"text": "Here is the  link", "label": {"api": {"link": [[13, 16]]}}}, {"text": "If you're not opposed to using external libraries and you're on JDK 5+, Google Guava has a Stopwatch that uses System.nanoTime()", "label": {"api": {"System.nanoTime()": [[111, 127]]}}}, {"text": "If so, you can use the Desktop-class", "label": {"api": {"Desktop-class": [[23, 35]]}}}, {"text": "Since JavaFX 2.1 you can use an object of class javafx.stage.DirectoryChooser", "label": {"api": {"javafx.stage.DirectoryChooser": [[48, 76]]}}}, {"text": "What are the benefits of using ScheduledExecutorService's scheduleAtFixedRate() to run a piece of code on a regular basis instead of creating a new Runnable that has a forever loop coupled with a Thread.sleep() that causes the thread to sleep for the desired period", "label": {"api": {"ScheduledExecutorService": [[31, 54]], "scheduleAtFixedRate()": [[58, 78]], "Runnable": [[148, 155]], "Thread.sleep()": [[196, 209]]}}}, {"text": "One solution would be to use a TreeSet with a Comparator", "label": {"api": {"TreeSet": [[31, 37]]}}}, {"text": "TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "It's worth noting a one side effect of using TreeSet would be that your set is sorted", "label": {"api": {"TreeSet": [[45, 51]]}}}, {"text": "For alphabetical order following nationalization, use Collator", "label": {"api": {"Collator": [[54, 61]]}}}, {"text": "This way you can use Hibernate Validator or javax.validator api to validate the params", "label": {"api": {"javax.validator api": [[44, 62]]}}}, {"text": "Same answer, but for DocPrintJob", "label": {"api": {"DocPrintJob": [[21, 31]]}}}, {"text": "Java SE 7 has java.nio.file.attribute.PosixFileAttributes which gives you fine grained control over read, write, and execute permissions for owner, group, and others", "label": {"api": {"java.nio.file.attribute.PosixFileAttributes": [[14, 56]]}}}, {"text": "You need to go through SimpleDateFormat.format in order to format the date as a string", "label": {"api": {"SimpleDateFormat.format": [[23, 45]]}}}, {"text": "You can also customize your output by following the Java API on Date/Time conversions", "label": {"api": {"Java API on Date/Time conversions": [[52, 84]]}}}, {"text": "\"Programs\" may be started as separate Threads running inside the one JVM", "label": {"api": {"Threads": [[38, 44]]}}}, {"text": "Rather than pass your values in the constructor, you should create a ComboBoxModel derived class and pass that to the constructor", "label": {"api": {"ComboBoxModel": [[69, 81]], "ComboBox": [[69, 76]]}}}, {"text": "A simple example would be DefaultComboBoxModel, but you could create your own if that didn't satisfy your needs", "label": {"api": {"ComboBoxModel": [[33, 45]], "DefaultComboBoxModel": [[26, 45]], "ComboBox": [[33, 40]]}}}, {"text": "Then you can modify the model and the changes are applied to the ComboBox", "label": {"api": {"ComboBox": [[65, 72]]}}}, {"text": "you can pass in a ArrayBlockingQueue in the ThreadPoolExecutor constructor to get the desired effect", "label": {"api": {"ArrayBlockingQueue": [[18, 35]]}}}, {"text": "I've solved this with a Semaphore which I use to throttle tasks being submitted to the ExecutorService", "label": {"api": {"Semaphore": [[24, 32]]}}}, {"text": "In case the interface of java.util.zip is too complicated, you might want to have a look at http://commons.apache.org/compress/", "label": {"api": {"java.util.zip": [[25, 37]]}}}, {"text": "Check the documentation of Optional if you never used it before", "label": {"api": {"Optional": [[27, 34]]}}}, {"text": "You create reader and then read the first two lines from the file, remaining lines are loaded into jTextArea1", "label": {"api": {"read": [[11, 14], [27, 30]]}}}, {"text": "Line 1 reads the first line from the file", "label": {"api": {"read": [[7, 10]]}}}, {"text": "Then in the body of while you read the second line from the file at line 2", "label": {"api": {"read": [[30, 33]]}}}, {"text": "Line 3 reads the rest of the file into jTextArea1", "label": {"api": {"read": [[7, 10]]}}}, {"text": "On the next iteration of the while loop, reader.readLine() returns null since the file is completely read", "label": {"api": {"read": [[41, 44], [48, 51], [101, 104]]}}}, {"text": "To load text in a JTextComponent use its read method as suggested by Phill and Bhushankumar", "label": {"api": {"read": [[41, 44]]}}}, {"text": "The second parameter to read is not used by JTextArea, so it's safe to pass null", "label": {"api": {"read": [[24, 27]]}}}, {"text": "You can use a ThreadPoolExecutor with a pool size set to System.getRuntime().availableProcessors()Java 6 or Runtime.getRuntime().availableProcessors()Java 8 and .execute() it all the tasks you want to execute, then call tpe.shutdown() and then wait in a while(!tpe.terminated()) { /* waiting for all tasks to complete */} which blocks for all the submitted tasks to complete", "label": {"api": {"Runtime.getRuntime().availableProcessors()": [[108, 149]]}}}, {"text": "Beware that you might have to think about the byte order when doing so", "label": {"api": {"byte order": [[46, 55]]}}}, {"text": "Duration parsing is now included in Java 8", "label": {"api": {"Java 8": [[36, 41]]}}}, {"text": "Use standard ISO 8601 format with Duration.parse", "label": {"api": {"Duration.parse": [[34, 47]]}}}, {"text": "You can convert this duration to the total length in milliseconds", "label": {"api": {"convert this duration": [[8, 28]]}}}, {"text": "Instead, you want the Double class, specifically Double.longBitsToDouble", "label": {"api": {"Double.longBitsToDouble": [[49, 71]]}}}, {"text": "Concise solution with Java 8 using java.util.stream", "label": {"api": {"java.util.stream": [[35, 50]]}}}, {"text": "However, the Collection spec says that NullPointerException should be thrown when a collection does not support nulls", "label": {"api": {"Collection spec": [[13, 27]]}}}, {"text": "Have a look at the java.sql API to read more on how to get more meta data", "label": {"api": {"java.sql API": [[19, 30]]}}}, {"text": "If you are using Java 8 and up, you can use the newer java.time library to do this a bit more cleanly", "label": {"api": {"java.time": [[54, 62]]}}}, {"text": "You can use \"RandomAccessFile.readFully\" to read files entirely as a byte array", "label": {"api": {"RandomAccessFile.readFully": [[13, 38]]}}}, {"text": "How about Arrays.toString(byteArray)", "label": {"api": {"Arrays.toString(byteArray)": [[10, 35]]}}}, {"text": "You can use the GrayFilter class", "label": {"api": {"GrayFilter": [[16, 25]]}}}, {"text": "What is the difference between the String#equals method and the String#contentEquals method", "label": {"api": {"String#equals": [[35, 47]], "String#contentEquals": [[64, 83]]}}}, {"text": "The String#equals() not only compares the String's contents, but also checks if the other object is also an instance of a String", "label": {"api": {"String#equals()": [[4, 18]], "String": [[4, 9], [42, 47], [122, 127]]}}}, {"text": "The String#contentEquals() only compares the contents (the character sequence) and does not check if the other object is also an instance of String", "label": {"api": {"String#contentEquals()": [[4, 25]], "String": [[4, 9], [141, 146]]}}}, {"text": "It can be anything as long as it is an implementation of CharSequence which covers a.o", "label": {"api": {"CharSequence": [[57, 68]]}}}, {"text": "String, StringBuilder, StringBuffer, CharBuffer, etc", "label": {"api": {"String": [[0, 5], [8, 13], [23, 28]], "StringBuilder": [[8, 20]], "StringBuffer": [[23, 34]], "CharBuffer": [[37, 46]]}}}, {"text": "I'm storing a map of LinkedBlockingDeques (mapped by the ID of the external system receiving the live stream) in a singleton EJB", "label": {"api": {"LinkedBlockingDeque": [[21, 39]]}}}, {"text": "It will handle the connection closing for you- as the new versions of the class implement the Closable interface", "label": {"api": {"Closable": [[94, 101]]}}}, {"text": "If I where you, I would put all allowed characters in a char[] and use SecureRandom to select n characters from this array", "label": {"api": {"SecureRandom": [[71, 82]]}}}, {"text": "Java provides the metadata package and the ImageWriter class along with the ImageIO package", "label": {"api": {"metadata": [[18, 25]], "ImageWriter": [[43, 53]], "ImageIO": [[76, 82]]}}}, {"text": "You create your IIOMetadata object, then getImageWriters for your BufferedImage or IIOImage and use them to write the metadata", "label": {"api": {"metadata": [[118, 125]], "ImageWriter": [[44, 54]], "IIOMetadata": [[16, 26]], "BufferedImage": [[66, 78]], "IIOImage": [[83, 90]]}}}, {"text": "You can obtain the response code in Java by using URL.openConnection() and HttpURLConnection.getResponseCode()", "label": {"api": {"URL.openConnection()": [[50, 69]], "HttpURLConnection.getResponseCode()": [[75, 109]]}}}, {"text": "Since Java 8, it seems like the java.time standard library is the way to go", "label": {"api": {"java.time": [[32, 40]]}}}, {"text": "Note that from Java SE 8 onwards, users are asked to migrate to java.time (JSR-310) - a core part of the JDK which replaces this project", "label": {"api": {"java.time": [[64, 72]]}}}, {"text": "Were you to use Java 8, I think you want LocalDateTime", "label": {"api": {"LocalDateTime": [[41, 53]]}}}, {"text": "Use the type Types.REF_CURSOR for cursor return types", "label": {"api": {"Types.REF_CURSOR": [[13, 28]]}}}, {"text": "The Java 7 version of SimpleDateFormat supports ISO-8601 time zones using the uppercase letter X", "label": {"api": {"The Java 7 version of SimpleDateFormat": [[0, 37]]}}}, {"text": "In Java 1.7 or later, I would use ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[34, 50]]}}}, {"text": "The reason to use ThreadLocalRandom is explained here", "label": {"api": {"ThreadLocalRandom": [[18, 34]]}}}, {"text": "Also note, that the reason we +1 to the input to ThreadLocalRandom.nextInt() is to make sure the max is included in the range", "label": {"api": {"ThreadLocalRandom": [[49, 65]]}}}, {"text": "How about using isEqualNode", "label": {"api": {"isEqualNode": [[16, 26]]}}}, {"text": "You can always use mBeanServer.queryNames(null, null); for getting to all MBeans registered at a certain MBeanServer (where mBeanServer is the MBeanServerConnection which you obtained either locally or remotely)", "label": {"api": {"mBeanServer.queryNames(null, null);": [[19, 53]]}}}, {"text": "The setRGB() or getRaster() methods of BufferedImage work well for this", "label": {"api": {"setRGB()": [[4, 11]], "getRaster()": [[16, 26]], "BufferedImage": [[39, 51]]}}}, {"text": "Take a look at the CertPathValidator class from the JDK, which verifies a continuous chain of trust from the server's own certificate up through a trusted CA", "label": {"api": {"CertPathValidator": [[19, 35]]}}}, {"text": "It should be noted that StampedLock has since come out with Java 8, and it's much faster than ReentrantReadWriteLock (especially as you use more and more threads) when you don't use the lock in a reentrant manner (using StampedLock reentrantly can lead to deadlocks, so don't do it)", "label": {"api": {"StampedLock": [[24, 34], [220, 230]]}}}, {"text": "You can check whether a write lock has been established over your optimistic read nonlock by using the validate method", "label": {"api": {"the validate method": [[99, 117]]}}}, {"text": "this file is loaded as a ResourceBundle so if you need message for a different language add the language suffix to the file (eg ValidationMessages_de.properties for german translations)", "label": {"api": {"ResourceBundle": [[25, 38]]}}}, {"text": "In Java 7 there is something called a PathMatcher which allows you to use regular expressions to find a file", "label": {"api": {"PathMatcher": [[38, 48]]}}}, {"text": "This code shows how to use a java.text.SimpleDateFormat to parse a java.util.Date from a String", "label": {"api": {"java.text.SimpleDateFormat": [[29, 54]], "java.util.Date": [[67, 80]]}}}, {"text": "Use PreparedStatement instead", "label": {"api": {"PreparedStatement": [[4, 20]]}}}, {"text": "In case this page comes up in someones web search, as of Java 1.7 you can now use java.nio.charset.StandardCharsets to get access to constant definitions of standard charsets", "label": {"api": {"java.nio.charset.StandardCharsets": [[82, 114]]}}}, {"text": "public Color(float r, float g, float b, float a)", "label": {"api": {"public Color(float r, float g, float b, float a)": [[0, 47]]}}}, {"text": "I know you have HSB, but you can convert to RGB easily enough", "label": {"api": {"convert to RGB": [[33, 46]]}}}, {"text": "Latency could be introduced by implementing and injecting your own RMISocketFactory via calling setSocketFactory", "label": {"api": {"setSocketFactory": [[96, 111]]}}}, {"text": "You can simply use the mkdirs() method of java.io.File class", "label": {"api": {"mkdirs()": [[23, 30]]}}}, {"text": "In Java 8 I'd recommend to use Optional<Boolean>", "label": {"api": {"Optional": [[31, 38]]}}}, {"text": "For Android you probably can write your own Optional class (not sure, however, whether it's the best solution)", "label": {"api": {"Optional": [[44, 51]]}}}, {"text": "Java 8 onward, you can use Files#walk to list out all files and directories recursively in a given directory", "label": {"api": {"Files#walk": [[27, 36]]}}}, {"text": "On the flip side, if you only need to list the given directory but not its sub-directories, you can use the lazy method Files#list which will only give you the files and directories in the given directory", "label": {"api": {"Files#list": [[120, 129]]}}}, {"text": "Just use the constructor which accepts a byte array and a parameter to say whether it's positive or negative", "label": {"api": {"constructor": [[13, 23]]}}}, {"text": "Use the Introspector class", "label": {"api": {"Introspector": [[8, 19]]}}}, {"text": "Obtain the BeanInfo and use getPropertyDescriptors() method", "label": {"api": {"getPropertyDescriptors()": [[28, 51]]}}}, {"text": "Check out Oracle's documentation of the Scanner class for more info", "label": {"api": {"Oracle's documentation of the Scanner class": [[10, 52]]}}}, {"text": "Note that the regex version of replace, ie replaceAll(), is not required here; replace() still replaces all occurrences of the search term, but it searches for literal Strings, not regex matches", "label": {"api": {"replaceAll()": [[43, 54]], "replace()": [[79, 87]]}}}, {"text": "The following constructor, JLabel(String, int), allow you to specify the horizontal alignment of the label", "label": {"api": {"JLabel(String, int)": [[27, 45]]}}}, {"text": "just use system colors in your UI using SystemColor class (if that's just what you need) or use the same class for analyzing a contrast between current foreground and background colors (if you need to know if system colors are high contrast)", "label": {"api": {"SystemColor": [[40, 50]]}}}, {"text": "A entirely new API has been created to deal with files java.nio.file.Files", "label": {"api": {"java.nio.file.Files": [[55, 73]]}}}, {"text": "I would suggest using ServletRequest.getLocales() to let the container parse Accept-Language rather than trying to manage the complexity yourself", "label": {"api": {"ServletRequest.getLocales()": [[22, 48]]}}}, {"text": "For the record, now it is possible with Java 8", "label": {"api": {"Java 8": [[40, 45]]}}}, {"text": "The current answers suggest that Java's java.util.LinkedList is the Java translation of C++'s std::deque", "label": {"api": {"java.util.LinkedList": [[40, 59]]}}}, {"text": "It depends on exactly what you mean by \"length of [the] String\"", "label": {"api": {"String": [[56, 61]]}}}, {"text": "String.length() returns the number of chars in the String", "label": {"api": {"String.length()": [[0, 14]], "chars": [[38, 42]], "String": [[0, 5], [51, 56]], "char": [[38, 41]]}}}, {"text": "This is normally only useful for programming related tasks like allocating buffers because multi-byte encoding can cause problems which means one char doesn't mean one Unicode code point", "label": {"api": {"char": [[146, 149]]}}}, {"text": "String.codePointCount(int, int) and Character.codePointCount(CharSequence,int,int) both return the number of Unicode code points in the String", "label": {"api": {"String": [[0, 5], [136, 141]], "String.codePointCount(int, int)": [[0, 30]], "Character.codePointCount(CharSequence,int,int)": [[36, 81]]}}}, {"text": "This is normally only useful for programming related tasks that require looking at a String as a series of Unicode code points without needing to worry about multi-byte encoding interfering", "label": {"api": {"String": [[85, 90]]}}}, {"text": "BreakIterator.getCharacterInstance(Locale) can be used to get the next grapheme in a String for the given Locale", "label": {"api": {"String": [[85, 90]], "BreakIterator.getCharacterInstance(Locale)": [[0, 41]], "Locale": [[35, 40], [106, 111]]}}}, {"text": "Using this multiple times can allow you to count the number of graphemes in a String", "label": {"api": {"String": [[78, 83]]}}}, {"text": "Since graphemes are basically letters (in most circumstances) this method is useful for getting the number of writable characters the String contains", "label": {"api": {"String": [[134, 139]], "char": [[119, 122]]}}}, {"text": "Essentially this method returns approximately the same number you would get if you manually counted the number of letters in the String, making it useful for things like sizing user interfaces and splitting Strings without corrupting the data", "label": {"api": {"String": [[129, 134], [207, 212]]}}}, {"text": "To give you an idea of how each of the different methods can return different lengths for the exact same data, I created this class to quickly generate the lengths of the Unicode text contained within this page, which is designed to offer a comprehensive test of many different languages with non-English characters", "label": {"api": {"char": [[305, 308]]}}}, {"text": "As you can see, even the \"same-looking\" String could give different results for the length if you use either String.length() or String.codePointCount(int,int)", "label": {"api": {"String.length()": [[109, 123]], "String": [[40, 45], [109, 114], [128, 133]]}}}, {"text": "Files.copy(Path, Path, CopyOptions)", "label": {"api": {"Files.copy(Path, Path, CopyOptions)": [[0, 34]]}}}, {"text": "Note that CopyOptions has COPY_ATTRIBUTES, which will do what you want", "label": {"api": {"COPY_ATTRIBUTES": [[26, 40]]}}}, {"text": "DateTimeFormatter in Java 8 is immutable and thread-safe alternative to SimpleDateFormat", "label": {"api": {"DateTimeFormatter": [[0, 16]], "SimpleDateFormat": [[72, 87]]}}}, {"text": "You need to create your prepared statement with the resultSetConcurrency set to ResultSet.CONCUR_UPDATABLE", "label": {"api": {"create your prepared statement": [[12, 41]]}}}, {"text": "You just need to have your class inherit from Comparable", "label": {"api": {"Comparable": [[46, 55]]}}}, {"text": "then implement the compareTo method the way you like", "label": {"api": {"compareTo": [[19, 27]]}}}, {"text": "The following is a bit simplified example, please note that you can register the feature on WebTarget as well", "label": {"api": {"WebTarget": [[92, 100]]}}}, {"text": "The decision to use which comes from you, and if you look at the List API, you would notice that all of these List implementations extend in one way or another from List", "label": {"api": {"List API": [[65, 72]]}}}, {"text": "In the meantime, the best option seems to be to poll Process.exitValue(), wrapped in a try-catch", "label": {"api": {"Process.exitValue()": [[53, 71]]}}}, {"text": "As of Java 6, you can access the option directly using the HotSpotDiagnosticMXBean", "label": {"api": {"HotSpotDiagnosticMXBean": [[59, 81]]}}}, {"text": "Yes, you can do this by calling this.getClass()", "label": {"api": {"this.getClass()": [[32, 46]], "Class": [[40, 44]]}}}, {"text": "This will give you the Class instance for the runtime type of this", "label": {"api": {"Class": [[23, 27]]}}}, {"text": "If you just want the name of the class, you could use this.getClass().getName()", "label": {"api": {"this.getClass()": [[54, 68]], "Class": [[62, 66]], "this.getClass().getName()": [[54, 78]]}}}, {"text": "Lastly, there are also this.getClass().getSimpleName() and this.getClass().getCanonicalName()", "label": {"api": {"this.getClass()": [[23, 37], [59, 73]], "Class": [[31, 35], [67, 71]], "this.getClass().getSimpleName()": [[23, 53]], "this.getClass().getCanonicalName()": [[59, 92]]}}}, {"text": "To clear all previously drawn graphics, invoke g.clearRect(0, 0, getWidth(), getHeight())", "label": {"api": {"g.clearRect(0, 0, getWidth(), getHeight())": [[47, 88]]}}}, {"text": "You can refer to officail documentatio for XmlAdapter", "label": {"api": {"XmlAdapter": [[43, 52]]}}}, {"text": "solving it using classes from java.util.concurrent such as ExecutorServices, Callables, Futures etc", "label": {"api": {"java.util.concurrent": [[30, 49]]}}}, {"text": "Since you want to use a constructor with parameters, you'll need to look up the Constructor object and use it for the instantiation", "label": {"api": {"Constructor": [[80, 90]]}}}, {"text": "If you absolutely need to take this route, and if T is limited to a distinct set of types known at compile time, a compromise would be to keep a static Map of Constructors, which is loaded at startup - that way you don't have to dynamically look them up at every call to this method", "label": {"api": {"Constructor": [[159, 169]]}}}, {"text": "For example a Map<String, Constructor<?>> or Map<Class<?>, Constructor<?>>, which is populated using a static block", "label": {"api": {"Constructor": [[26, 36], [59, 69]]}}}, {"text": "The following uses functional interfaces", "label": {"api": {"functional interfaces": [[19, 39]]}}}, {"text": "You can very well use Collections.synchronizedList(List) if all you need is simple invocation synchronization", "label": {"api": {"Collections.synchronizedList(List)": [[22, 55]]}}}, {"text": "If you don't care about having index-based access and just want the insertion-order-preserving characteristics of a List, you could consider a java.util.concurrent.ConcurrentLinkedQueue", "label": {"api": {"java.util.concurrent.ConcurrentLinkedQueue": [[143, 184]]}}}, {"text": "Then I saw this comment in the javax.ejb.SessionSynchronization JavaDoc", "label": {"api": {"javax.ejb.SessionSynchronization JavaDoc": [[31, 70]]}}}, {"text": "This is not the case for Cipher, so you should not assume it to be threadsafe", "label": {"api": {"Cipher": [[25, 30]]}}}, {"text": "If you also need the ability to add elements while iterating, use a ListIterator", "label": {"api": {"ListIterator": [[68, 79]]}}}, {"text": "The general-purpose ReentrantLock neither implements nor provides anything that implements the AutoCloseable interface necessary for a try-with-resources statement", "label": {"api": {"ReentrantLock": [[20, 32]]}}}, {"text": "The concept isn't completely foreign to the Java API though, as FileChannel.lock() offers this functionality", "label": {"api": {"FileChannel.lock()": [[64, 81]]}}}, {"text": "You can abstract the use of File by using the intention of \"somewhere to write data\" by changing your API to use an OutputStream instead of a File, then pass the API a FileOutputStream in your production code, but pass it a ByteArrayOutputStream from your tests", "label": {"api": {"ByteArrayOutputStream": [[224, 244]]}}}, {"text": "A ByteArrayOutputStream is an in-memory stream, so it's very fast and you can simply inspect its contents by using its methods - it's perfect for testing", "label": {"api": {"ByteArrayOutputStream": [[2, 22]]}}}, {"text": "It looks like Java provides a concurrent Set implementation with its ConcurrentSkipListSet", "label": {"api": {"ConcurrentSkipListSet": [[69, 89]]}}}, {"text": "Use the Pattern#quote() method for escaping ||", "label": {"api": {"Pattern#quote()": [[8, 22]]}}}, {"text": "A Red-Black tree based NavigableMap implementation", "label": {"api": {"NavigableMap": [[23, 34]]}}}, {"text": "The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used..", "label": {"api": {"natural ordering": [[35, 50]], "Comparator": [[73, 82]]}}}, {"text": "Creating a server socket, bounds to a specific port with a ServerSocket instance as the application starts is a straight way", "label": {"api": {"ServerSocket": [[59, 70]]}}}, {"text": "Note that ServerSocket.accept() blocks, so running it in its own thread makes sense to not block the main Thread", "label": {"api": {"ServerSocket": [[10, 21]]}}}, {"text": "Consider using Math.round() for your calculations", "label": {"api": {"Math.round()": [[15, 26]]}}}, {"text": "double has limited accuracy and suffers from \"small remainder error\" issues, but using Math.round() will solve that problem nicely without having the hassle of dealing with BigDecimal (we aren't calculating inter-planetary rocket trajectories here)", "label": {"api": {"Math.round()": [[87, 98]], "BigDecimal": [[173, 182]]}}}, {"text": "The shape is under the aegis of the tabbed pane's UI delegate, which descends from  TabbedPaneUI", "label": {"api": {"TabbedPaneUI": [[84, 95]]}}}, {"text": "The MetalTabbedPaneUI subclass is an example that may help you decide how badly you want to replace the delegate", "label": {"api": {"TabbedPaneUI": [[9, 20]], "MetalTabbedPaneUI": [[4, 20]]}}}, {"text": "Also as Bohemian stated, env variables are set in the OS (however they 'can' be set through Java) and system properties are passed as command line options or set via setProperty()", "label": {"api": {"setProperty()": [[166, 178]]}}}, {"text": "For more information look  to the Specification", "label": {"api": {"Specification": [[34, 46]]}}}, {"text": "To get a human-readable toString(), you must use Arrays.toString(), like this", "label": {"api": {"Arrays.toString()": [[49, 65]]}}}, {"text": "This example shows how to use addWindowListener() with a WindowAdapter, a concrete implementation of the WindowListener interface", "label": {"api": {"WindowAdapter": [[57, 69]], "WindowListener": [[33, 46], [105, 118]]}}}, {"text": "I realize this is an old question, but have you considered firing up a javax.script.ScriptEngine and running the same JS templating system in Java as well", "label": {"api": {"javax.script.ScriptEngine": [[71, 95]]}}}, {"text": "You could use Piped Read/Writers (link)", "label": {"api": {"link": [[34, 37]]}}}, {"text": "Here the external unparsed entities for a DTD are retrieved by switching on the value given by the XMLEvent#getEventType() method", "label": {"api": {"XMLEvent#getEventType()": [[99, 121]]}}}, {"text": "Using | and & instead could result in a NullPointerException being thrown here", "label": {"api": {"NullPointerException": [[40, 59]]}}}, {"text": "in Java 8, there is a java.util.Base64 package", "label": {"api": {"Base64": [[32, 37]]}}}, {"text": "The API has a number of methods in the class Base64 to create a Decoder or Encoder", "label": {"api": {"Base64": [[45, 50]], "Decoder": [[64, 70]], "Encoder": [[75, 81]]}}}, {"text": "Basic - Uses \"The Base64 Alphabet\" as specified in Table 1 of RFC 4648 and RFC 2045 for encoding and decoding operation", "label": {"api": {"Base64": [[18, 23]]}}}, {"text": "URL and Filename safe - Uses the \"URL and Filename safe Base64 Alphabet\" as specified in Table 2 of RFC 4648 for encoding and decoding", "label": {"api": {"Base64": [[56, 61]]}}}, {"text": "MIME -  Uses the \"The Base64 Alphabet\" as specified in Table 1 of RFC 2045 for encoding and decoding operation", "label": {"api": {"Base64": [[22, 27]]}}}, {"text": "If I don't need to sort the column, how can I put a well-behaved control in the JTableHeader", "label": {"api": {"JTableHeader": [[80, 91]]}}}, {"text": "Take a look at public static Font decode(String str) here", "label": {"api": {"public static Font decode(String str)": [[15, 51]]}}}, {"text": "Since Java 1.5 we've had access to Window.setLocationByPlatform(boolean)", "label": {"api": {"Window.setLocationByPlatform(boolean)": [[35, 71]]}}}, {"text": "In JPA you can use @PrePersist and @PreUpdate annotation to annotate a method in your model (@Entity class) that will be called before persisting (INSERT) or updating (UPDATE)", "label": {"api": {"@PrePersist": [[19, 29]], "@PreUpdate": [[35, 44]]}}}, {"text": "You can create an entity listener, and add @EntityListeners annotation to your models, like", "label": {"api": {"@EntityListeners": [[43, 58]]}}}, {"text": "For multi-threaded environment, I'd recommend ConcurrentHashMap or another ConcurrentMap implementation", "label": {"api": {"ConcurrentHashMap": [[46, 62]]}}}, {"text": "\"If you do not honor the opaque property you will likely see visual artifacts.\"—paintComponent()", "label": {"api": {"paintComponent()": [[80, 95]]}}}, {"text": "I have a timer on daemon thread which is continuously writing data into a SocketChannel", "label": {"api": {"SocketChannel": [[74, 86]]}}}, {"text": "In the main class I do not have the object reference of this socket channel, but I do have the reference of the ServerSocket to which this socket channel is connected", "label": {"api": {"ServerSocket": [[112, 123]]}}}, {"text": "The ImageIO helper class offers methods to read and write images from/to files and streams", "label": {"api": {"ImageIO": [[4, 10]]}}}, {"text": "To read an image from a file, you can use ImageIO.read(File) (which returns a BufferedImage)", "label": {"api": {"ImageIO": [[42, 48]], "ImageIO.read(File)": [[42, 59]], "BufferedImage": [[78, 90]]}}}, {"text": "But since BufferedImage is a subclass of Image, you can do", "label": {"api": {"BufferedImage": [[10, 22]]}}}, {"text": "I would use an ImageIcon", "label": {"api": {"ImageIcon": [[15, 23]]}}}, {"text": "You likely need to set the System ID for StreamSource of the XSLT that you are loading", "label": {"api": {"set the System ID": [[19, 35]]}}}, {"text": "If you're already handling authentication in another way (such as by connection.setRequestProperty(\"Authorization\", ...), as this answer to another question describes), you can use Authenticator.setDefault() to choose to not to use any Authenticator for authentication", "label": {"api": {"Authenticator.setDefault()": [[181, 206]]}}}, {"text": "See the readAllBytes() method in the java.nio.file.Files class", "label": {"api": {"readAllBytes()": [[8, 21]], "java.nio.file.Files": [[37, 55]]}}}, {"text": "en1) of Enum type", "label": {"api": {"Enum": [[8, 11]]}}}, {"text": "If you are worried about having too many dialogs laying around, use a WeakReference to hold the reference", "label": {"api": {"WeakReference": [[70, 82]]}}}, {"text": "I used AbstractMap.SimpleEntry and AbstractMap.SimpleImmutableEntry when need to store pairs (like size and object collection)", "label": {"api": {"AbstractMap.SimpleEntry": [[7, 29]], "AbstractMap.SimpleImmutableEntry": [[35, 66]]}}}, {"text": "I used TextLayout to get the text properly centered", "label": {"api": {"TextLayout": [[7, 16]]}}}, {"text": "In Java 9, using List#of, which is an Immutable List Static Factory Methods, became more simpler", "label": {"api": {"List#of": [[17, 23]]}}}, {"text": "Frame.getFrames() returns an array of all frames", "label": {"api": {"Frame.getFrames()": [[0, 16]]}}}, {"text": "BiConsumer is one of many functional interfaces provided by java.util.function", "label": {"api": {"java.util.function": [[60, 77]]}}}, {"text": "The java.util.function package has several useful interfaces", "label": {"api": {"java.util.function": [[4, 21]]}}}, {"text": "JSyntaxPane is an EditorKit for JEditorPane (Swing), i.e", "label": {"api": {"JEditorPane (Swing)": [[32, 50]]}}}, {"text": "Just get the day names from the Locale of the language that you need, without using any formatter in between", "label": {"api": {"day names from the Locale": [[13, 37]]}}}, {"text": "If you want to replace a simple string and you don't need the abilities of regular expressions, you can just use replace, not replaceAll", "label": {"api": {"replace": [[15, 21], [113, 119], [126, 132]]}}}, {"text": "replace replaces each matching substring but does not interpret its argument as a regular expression", "label": {"api": {"replace": [[0, 6], [8, 14]]}}}, {"text": "Java 8 provides Byte.toUnsignedInt to convert byte to int by unsigned conversion", "label": {"api": {"Byte.toUnsignedInt": [[16, 33]]}}}, {"text": "If you are using class DatagramSocket, the UDP datagram received includes the header information and you can parse it out according to this DatagramSocket documentation", "label": {"api": {"DatagramSocket documentation": [[140, 167]]}}}, {"text": "Behind the scenes the above mentioned Array Functions use System.arraycopy(), if that's of any use", "label": {"api": {"System.arraycopy()": [[58, 75]]}}}, {"text": "Since Servlet 3.1 (Java EE 7), a new method is available, getContentLengthLong()", "label": {"api": {"getContentLengthLong()": [[58, 79]]}}}, {"text": "The same applies to its counterpart on the response, setContentLengthLong()", "label": {"api": {"setContentLengthLong()": [[53, 74]]}}}, {"text": "The Object class knows about one of its subclasses, namely String (in particular, to declare and implement the toString() method)", "label": {"api": {"Object": [[4, 9]], "String": [[59, 64], [113, 118]], "toString()": [[111, 120]]}}}, {"text": "Part of the java language specification is that all classes are implicitly subclasses of Object", "label": {"api": {"Object": [[89, 94]]}}}, {"text": "To solve this problem, you should use the Scanner class, which has a nextInt() method that is perfect for this", "label": {"api": {"Scanner": [[42, 48]], "nextInt()": [[69, 77]]}}}, {"text": "It will throw an InputMismatchException on invalid input, so if you want error handling, you should catch that", "label": {"api": {"InputMismatchException": [[17, 38]]}}}, {"text": "If you can do the rest of the processing inside a lambda you could use orElseGet", "label": {"api": {"orElseGet": [[71, 79]]}}}, {"text": "Use hasNextInt() to check if next token is int or not", "label": {"api": {"hasNextInt()": [[4, 15]]}}}, {"text": "You need to use JTextArea.setFont() to set a monospaced font, such as Courier, for the text area", "label": {"api": {"JTextArea.setFont()": [[16, 34]]}}}, {"text": "You are using removeAll(E...) where you need to pass the objects you want to remove", "label": {"api": {"removeAll(E...)": [[14, 28]]}}}, {"text": "To clear the list use clear() which will remove all items in your history list", "label": {"api": {"clear()": [[22, 28]]}}}, {"text": "For more details, have a look at Response and Response.ResponseBuilder classes documentation", "label": {"api": {"Response": [[33, 40], [46, 53], [55, 62]], "Response.ResponseBuilder": [[46, 69]]}}}, {"text": "In the Response.ResponseBuilder API you might find some useful methods that allow you to add information related to cache, cookies and headers to the HTTP response", "label": {"api": {"Response": [[7, 14], [16, 23]], "Response.ResponseBuilder": [[7, 30]], "cache": [[116, 120]], "cookies": [[123, 129]], "headers": [[135, 141]]}}}, {"text": "HandShakeRequest#getParameterMap() javadoc says following", "label": {"api": {"HandShakeRequest#getParameterMap() javadoc": [[0, 41]]}}}, {"text": "When having only HandShakeRequest at hands, which doesn't have any method directly returning path parameters, your best bet is to use getRequestURI() and perform string manipulation (split, substring, etc) in order to extract path parameters", "label": {"api": {"getRequestURI()": [[134, 148]]}}}, {"text": "The alternative is to move the task into Endpoint#onOpen() or @OnOpen, there path parameters are just directly available via Session#getPathParameters()", "label": {"api": {"Endpoint#onOpen()": [[41, 57]], "@OnOpen": [[62, 68]], "Session#getPathParameters()": [[125, 151]]}}}, {"text": "The typical solution is to use a collection which will not keep an object alive once all other references to it are gone, see WeakHashMap for more info", "label": {"api": {"WeakHashMap": [[126, 136]]}}}, {"text": "You can use List#containsAll()", "label": {"api": {"List#containsAll()": [[12, 29]]}}}, {"text": "Good job for a BitSet", "label": {"api": {"BitSet": [[15, 20]]}}}, {"text": "You can use proper lambda for BinaryOperator in reduce function", "label": {"api": {"BinaryOperator": [[30, 43]]}}}, {"text": "Please check Stream.collect() and Collector.of() javadocs for further reference", "label": {"api": {"Stream.collect()": [[13, 28]], "Collector.of()": [[34, 47]]}}}, {"text": "Use List#contains() -- and it's more readable and conventional not to have variable names start with an uppercase unless they are constants", "label": {"api": {"List#contains()": [[4, 18]]}}}, {"text": "As a reference, check the Javadoc for Integer", "label": {"api": {"Javadoc for Integer": [[26, 44]]}}}, {"text": "According to the documentation for Object.getClass()", "label": {"api": {"the documentation for Object.getClass()": [[13, 51]]}}}, {"text": "If you are starting a new thread using the Runnable, or submitting it to a Executor, then the new thread will see all the actions that happened up to the creation of the thread", "label": {"api": {"Executor": [[75, 82]]}}}, {"text": "Actions in a thread prior to submitting a Runnable object to an Executor happen-before its execution begins, perhaps in another thread", "label": {"api": {"Executor": [[64, 71]]}}}, {"text": "Jetbrains has recently decided that java.util.Optional (as well as Guava's com.google.common.base.Optional) shouldn't be used as field or parameter type..", "label": {"api": {"java.util.Optional": [[36, 53]]}}}, {"text": "The variables are strings, but charAt returns a char, which is a kind of number, and then you're adding those numbers together, which leaves you with an int", "label": {"api": {"charAt": [[31, 36]]}}}, {"text": "Use a StringBuilder instead and append the result of charAt twice", "label": {"api": {"charAt": [[53, 58]], "StringBuilder": [[6, 18]]}}}, {"text": "This is achieved through setting 60:40 constraints on the rows and columns for the GridPane", "label": {"api": {"constraints": [[39, 49]], "GridPane": [[83, 90]]}}}, {"text": "I find it a good tool to use to understand various layout types and constraints", "label": {"api": {"constraints": [[68, 78]]}}}, {"text": "Normally an AnchorPane is for fixed sized layouts", "label": {"api": {"AnchorPane": [[12, 21]]}}}, {"text": "If you want a dynamically sized layout, a different layout pane type is usually preferred, which is why the answer uses only a GridPane and not an AnchorPane", "label": {"api": {"AnchorPane": [[147, 156]], "GridPane": [[127, 134]]}}}, {"text": "Based on Oracle's Java 8 API, hasNext() is an abstract method, but I couldn't find where hasNext() is implemented", "label": {"api": {"Oracle's Java 8 API": [[9, 27]]}}}, {"text": "Is there a way to make a file stored as a jpg image into a Shape", "label": {"api": {"Shape": [[59, 63]]}}}, {"text": "The image is a rectangle so is there perhaps a way to store a Rectangle Shape and paint the image inside of the rectangle, maybe", "label": {"api": {"Shape": [[72, 76]]}}}, {"text": "Quoting javadoc of Collections.min()", "label": {"api": {"Collections.min()": [[19, 35]]}}}, {"text": "Note that I changed replaceAll() to replace() because former works with regex, but judging by your code seems you need replacement by string itself (don't worry, despite of confusing name it also replaces all occurrences)", "label": {"api": {"replace()": [[36, 44]]}}}, {"text": "If you want exactly Stream API, you may use reduce() operation", "label": {"api": {"reduce()": [[44, 51]]}}}, {"text": "Regardless, you can use a SimpleDateFormat to parse such strings", "label": {"api": {"SimpleDateFormat": [[26, 41]]}}}, {"text": "According to the documentation of ImageIO.read(InputStream input)", "label": {"api": {"ImageIO.read(InputStream input)": [[34, 64]]}}}, {"text": "Just use getURL() method of the connection, it will return already redirected url", "label": {"api": {"getURL()": [[9, 16]]}}}, {"text": "Look into Externalization", "label": {"api": {"Externalization": [[10, 24]]}}}, {"text": "In Java 8 you could use DoubleSummaryStatistics and do something like this", "label": {"api": {"DoubleSummaryStatistics": [[24, 46]]}}}, {"text": "To get max and min values around items of subMap, take the stream of its values, convert it to DoubleStream and use its .summaryStatistics() as follows", "label": {"api": {"DoubleStream": [[95, 106]], ".summaryStatistics()": [[120, 139]]}}}, {"text": "You could call the Class.new instance() method of the Class object you pass to the method via the parameter className", "label": {"api": {"Class.new instance()": [[19, 38]]}}}, {"text": "This code uses the java.time framework built into Java 8 and later (see Tutorial)", "label": {"api": {"java.time": [[19, 27]]}}}, {"text": "Runnable or Callable) however, there is nothing preventing arguments from being passed during creation; so you can simply move the msg argument from the execute() method to the command's constructor", "label": {"api": {"Runnable": [[0, 7]], "Callable": [[12, 19]]}}}, {"text": "In this case a List", "label": {"api": {"List": [[15, 18]]}}}, {"text": "The List will autoscale", "label": {"api": {"List": [[4, 7]]}}}, {"text": "The first and third parameter to arraycopy must be arrays, and ascii is a byte, not a byte[]", "label": {"api": {"arraycopy": [[33, 41]]}}}, {"text": "If you want to convert the string assetId to ASCII bytes, just call getBytes()", "label": {"api": {"getBytes()": [[68, 77]]}}}, {"text": "Ways around this would be specifying a controllerFactory or creating the controller instance yourself", "label": {"api": {"controllerFactory": [[39, 55]]}}}, {"text": "I just found that java.lang.StrictMath has E and PI which each is also available in java.lang.Math", "label": {"api": {"java.lang.StrictMath": [[18, 37]], "PI": [[49, 50]], "java.lang.Math": [[84, 97]]}}}, {"text": "You need to implement Iterable, source, then you'll be able to use your class in a \"for-each-loop\"", "label": {"api": {"source": [[32, 37]]}}}, {"text": "For the first part, you can take a look at the DecimalFormat class", "label": {"api": {"DecimalFormat": [[47, 59]]}}}, {"text": "Now, none of the Javadocs pertaining to OutputStream or the various interfaces it implements like Closeable mention anything about calling flush() before closing the stream", "label": {"api": {"OutputStream": [[40, 51]], "Closeable": [[98, 106]]}}}, {"text": "But, if you look at other Writer classes like BufferedWriter, PrintWriter, etc", "label": {"api": {"BufferedWriter": [[46, 59]], "PrintWriter": [[62, 72]], "Writer": [[26, 31], [54, 59], [67, 72]]}}}, {"text": "This is because they all implement the Writer class, and the docs there specify this behavior", "label": {"api": {"Writer": [[39, 44]]}}}, {"text": "One common trait I have found is that if a class implements the Writer interface, the docs invariably mention the fact that close() closes the stream after calling flush() first", "label": {"api": {"Writer": [[64, 69]]}}}, {"text": "OutputStream being an abstract class, I dug a little deeper", "label": {"api": {"OutputStream": [[0, 11]]}}}, {"text": "I found FilterOutputStream which happens to extend OutputStream", "label": {"api": {"OutputStream": [[14, 25], [51, 62]], "FilterOutputStream": [[8, 25]]}}}, {"text": "BufferedOutputStream, DataOutputStream, PrintStream extend FilterOutputStream and as a result, inherit the same close() method", "label": {"api": {"OutputStream": [[8, 19], [26, 37], [65, 76]], "FilterOutputStream": [[59, 76]], "BufferedOutputStream": [[0, 19]]}}}, {"text": "That's exactly what the Serializable interface does", "label": {"api": {"the Serializable interface": [[20, 45]]}}}, {"text": "If you want to update the existing file - read and write at the same time, you will need a RandomAccessFile stream", "label": {"api": {"RandomAccessFile": [[91, 106]]}}}, {"text": "Alternatively, you can cancel the Timer that is handling the job", "label": {"api": {"Timer": [[34, 38]]}}}, {"text": "One simple solution would be having a fixed map", "label": {"api": {"map": [[44, 46]]}}}, {"text": "Then you simply iterate on the sequence, and for each character ch, you replace it with map[ch]", "label": {"api": {"map": [[88, 90]]}}}, {"text": "There is a much simpler way of doing the exact same above by just calling Stream.anyMatch instead of doing filter then findAny", "label": {"api": {"Stream.anyMatch": [[74, 88]]}}}, {"text": "LinkedTransferQueue is a good candidate for the queue since submission to the queue does not block through a shared lock", "label": {"api": {"LinkedTransferQueue": [[0, 18]]}}}, {"text": "Because, list.add(E e) returns a boolean value", "label": {"api": {"list.add(E e)": [[9, 21]]}}}, {"text": "If I'm understanding correctly, this design is already implemented in the API, via ExecutorService and Future", "label": {"api": {"ExecutorService": [[83, 97]], "Future": [[103, 108]]}}}, {"text": "These will allow you a master (ExecutorService) to control a list of tasks, each containing a segment of your matrix, while the Futures report back upon completion", "label": {"api": {"ExecutorService": [[31, 45]], "Future": [[128, 133]]}}}, {"text": "You would still have to break up the matrix for each of the Future tasks, but should be trivial", "label": {"api": {"Future": [[60, 65]]}}}, {"text": "ContextRefreshedEvent) and the other allows you to monitor lifecycle events (initialized/destroyed) of the ServletContext", "label": {"api": {"initialized/destroyed": [[77, 97]]}}}, {"text": "You can use add(int index, E element), that inserts the specified element at the specified position in this list", "label": {"api": {"add(int index, E element)": [[12, 36]]}}}, {"text": "DataInput interface does provide methods for reading unsigned integer types - readUnsignedByte, which returns short and readUnsignedShort, which returns int", "label": {"api": {"DataInput": [[0, 8]]}}}, {"text": "The question is not how to deal with this problem, but why the DataInput interface doesn't have such a method", "label": {"api": {"DataInput": [[63, 71]]}}}, {"text": "You need to use two map operations in that case", "label": {"api": {"map": [[20, 22]]}}}, {"text": "The first one maps the Person to its sibling and the second one maps the Person to its age", "label": {"api": {"map": [[14, 16], [64, 66]]}}}, {"text": "You can use RandomAccessFile in each thread to read different sections of the file", "label": {"api": {"RandomAccessFile": [[12, 27]]}}}, {"text": "RandomAccessFile allows you to read bytes starting at the file pointer and advance the file pointer past the bytes read", "label": {"api": {"RandomAccessFile": [[0, 15]]}}}, {"text": "clipRect is used to make sure the lines don't draw above y=40", "label": {"api": {"clipRect": [[0, 7]]}}}, {"text": "atan2 expects dy as the first argument and dx as the second argument", "label": {"api": {"atan2": [[0, 4]]}}}, {"text": "You should read more what the Comparable interface is, and how to implement it", "label": {"api": {"what the Comparable interface is": [[21, 52]]}}}, {"text": "The following iterates over the entries of mapAdded by calling forEach(action) where the action consumes the key and value of each entry", "label": {"api": {"forEach(action)": [[63, 77]]}}}, {"text": "For each entry, we call merge(key, value, remappingFunction) on mapGlobal", "label": {"api": {"merge(key, value, remappingFunction)": [[24, 59]]}}}, {"text": "You are using Screen.getVisualBounds instead of Screen.getBounds", "label": {"api": {"Screen.getVisualBounds": [[14, 35]], "Screen.getBounds": [[48, 63]]}}}, {"text": "From the javadoc of Screen.getVisualBounds", "label": {"api": {"Screen.getVisualBounds": [[20, 41]]}}}, {"text": "My question is not \"How do I use java.nio.files.Path?\", I can find that from the Java API", "label": {"api": {"Java API": [[81, 88]]}}}, {"text": "You may consider using a vertical BoxLayout", "label": {"api": {"BoxLayout": [[34, 42]]}}}, {"text": "When parsing the input file, you could use the valueOf method to convert a string value to an OwnerType", "label": {"api": {"valueOf": [[47, 53]]}}}, {"text": "Official documentation recommend us", "label": {"api": {"recommend": [[23, 31]]}}}, {"text": "The answer to both of your problems is here https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[44, 107]]}}}, {"text": "It uses DefaultPersistenceUnitManager class to build an instance of  PersistenceUnitInfo which can then be provided to PersistenceProvider class's createContainerEntityManagerFactory", "label": {"api": {"PersistenceUnitInfo": [[69, 87]], "PersistenceProvider": [[119, 137]], "createContainerEntityManagerFactory": [[147, 181]]}}}, {"text": "Hibernate implements this interface so that Spring can create an instance of EntityMangerFactory class", "label": {"api": {"EntityMangerFactory": [[77, 95]]}}}, {"text": "In java 8, the Comparator class picked up a number of useful methods to make it easy to create comparators and chain comparisons together with various thenComparing options", "label": {"api": {"Comparator": [[15, 24]], "thenComparing": [[151, 163]]}}}, {"text": "For example, the compound method provides the ability to chain instances much like the thenComparing in java 8", "label": {"api": {"thenComparing": [[87, 99]]}}}, {"text": "The method SyncInvoker::get(java.lang.Class) throws an exception in this case", "label": {"api": {"SyncInvoker::get(java.lang.Class)": [[11, 43]]}}}, {"text": "If you dislike to catch the exception, you can use SyncInvoker::get(), which returns the Response in the case of an unsuccessful request (HTTP-status != 2xx) too", "label": {"api": {"SyncInvoker::get()": [[51, 68]], "Response": [[89, 96]]}}}, {"text": "To add headers use the Invocation.Builder", "label": {"api": {"Invocation.Builder": [[23, 40]]}}}, {"text": "Take a look at CountDownLatch class", "label": {"api": {"CountDownLatch": [[15, 28]]}}}, {"text": "Its JDK 8 documentation says", "label": {"api": {"JDK 8 documentation": [[4, 22]]}}}, {"text": "Projecting in Java is done using the map method", "label": {"api": {"map": [[37, 39]]}}}, {"text": "Because there is no bounds, and because the compiler sees that there are bounds on what can be passed to the single-arg Collections.sort method, there is your compiler error", "label": {"api": {"Collections.sort method": [[120, 142]]}}}, {"text": "The Scanner class does already do tokens", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "The trim() method on String will clear all leading and trailing whitespace", "label": {"api": {"trim() method on String": [[4, 26]]}}}, {"text": "You use the isEmpty() method on String for that", "label": {"api": {"isEmpty() method on String": [[12, 37]]}}}, {"text": "To randomize a List, call Collections.shuffle(List<?> list)", "label": {"api": {"Collections.shuffle(List<?> list)": [[26, 58]]}}}, {"text": "To get random integers in a defined range, use Random.nextInt(int n)", "label": {"api": {"Random.nextInt(int n)": [[47, 67]]}}}, {"text": "Every object in JavaFX extends from Node", "label": {"api": {"Node": [[36, 39]]}}}, {"text": "Which in turn implements Styleable", "label": {"api": {"Styleable": [[25, 33]]}}}, {"text": "You can also use EntityManager#merge method", "label": {"api": {"EntityManager#merge": [[17, 35]]}}}, {"text": "To append to a file, you need to use the FileWriter(String fileName, boolean append) constructor", "label": {"api": {"FileWriter(String fileName, boolean append)": [[41, 83]]}}}, {"text": "If you're going to write a lot of output, then a BufferedWriter may be good, and if you need to specify the character encoding, you need to wrap a FileOutputStream with an OutputStreamWriter", "label": {"api": {"BufferedWriter": [[49, 62]], "FileOutputStream": [[147, 162]], "OutputStreamWriter": [[172, 189]]}}}, {"text": "The PrintWriter(String fileName) you called is actually shorthand for", "label": {"api": {"PrintWriter(String fileName)": [[4, 31]]}}}, {"text": "Java futures are supposed to be non-blocking", "label": {"api": {"futures": [[5, 11]]}}}, {"text": "Either look at SimpleXml or just use java.util.Properties and roll your own via Reflection", "label": {"api": {"java.util.Properties": [[37, 56]]}}}, {"text": "You could use the Point class", "label": {"api": {"Point": [[18, 22]]}}}, {"text": "Instead of storing the possible indexes in separate arrays, just store them in one as a collection of Points", "label": {"api": {"Point": [[102, 106]]}}}, {"text": "It's possible to do this via Robot", "label": {"api": {"Robot": [[29, 33]]}}}, {"text": "You can use a Servlet filter", "label": {"api": {"Servlet filter": [[14, 27]]}}}, {"text": "If list is an Iterator, you may need something like", "label": {"api": {"Iterator": [[14, 21]]}}}, {"text": "However, for quick fix, you can either use unmodifiableList or Set (with equals and hashCode methods implemented in the respective class of course) for KodNameList", "label": {"api": {"unmodifiableList": [[43, 58]]}}}, {"text": "You can use a Map and Wrapper patterns to enclosed a set of methods to compute prime number as well as other stuff", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "You need Calendar.HOUR_OF_DAY constant, which is used to operate in 24-hour clock, instead of Calendar.HOUR", "label": {"api": {"Calendar.HOUR_OF_DAY": [[9, 28]], "Calendar.HOUR": [[9, 21], [94, 106]]}}}, {"text": "Try scanning based on a Pattern of one single character or using the Console class", "label": {"api": {"Pattern": [[24, 30]], "Console": [[69, 75]]}}}, {"text": "I would suggest you to study if it your need allows the usage of Java's FileTypeDetector class", "label": {"api": {"Java's FileTypeDetector class": [[65, 93]]}}}, {"text": "The method getResourceAsStream() opens a resource, not a file", "label": {"api": {"getResourceAsStream()": [[11, 31]]}}}, {"text": "I'm not Android developer but I think it could be easily implemented by using a CompletableFuture on Java 8", "label": {"api": {"CompletableFuture": [[80, 96]]}}}, {"text": "In Java, you can simply use Point2D::distance to calculate the distance between two points", "label": {"api": {"Point2D::distance": [[28, 44]]}}}, {"text": "Quoting javadoc of File.getParent() (emphasis mine)", "label": {"api": {"File.getParent()": [[19, 34]]}}}, {"text": "Using Math.random() is simple, but has it limitations", "label": {"api": {"Math.random()": [[6, 18]]}}}, {"text": "Alternatively, use Random", "label": {"api": {"Random": [[19, 24]]}}}, {"text": "A couple things....first, you should really familiarize yourself with the Java Date API, along with the DateFormat and SimpleDateFormat classes", "label": {"api": {"Date": [[79, 82], [104, 107], [125, 128]], "DateFormat": [[104, 113], [125, 134]], "SimpleDateFormat": [[119, 134]]}}}, {"text": "You could try something using String.split() like", "label": {"api": {"String.split()": [[30, 43]]}}}, {"text": "Or something using String.indexOf() and String.substr() like", "label": {"api": {"String.indexOf()": [[19, 34]], "String.substr()": [[40, 54]]}}}, {"text": "If you're new to Java, it's worth spending the time to review all the String functions", "label": {"api": {"String functions": [[70, 85]]}}}, {"text": "In Java 8 you could use ConcurrentHashMap's computeIfAbsent to provide initial value", "label": {"api": {"computeIfAbsent": [[44, 58]]}}}, {"text": "Take a look at JDK ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[19, 40]]}}}, {"text": "The java.util.concurrent.TimeUnit enum only goes up to DAYS", "label": {"api": {"java.util.concurrent.TimeUnit": [[4, 32]], "DAYS": [[55, 58]]}}}, {"text": "You could use ChronoUnit - it even goes as high as CENTURIES and ERAS", "label": {"api": {"ChronoUnit": [[14, 23]]}}}, {"text": "In the initialize() method of the controller for your FXML, invoke fire() on the button", "label": {"api": {"fire()": [[67, 72]]}}}, {"text": "Authentication configuration is passed in environment - the second argument to JMXConnectorServerFactory.newJMXConnectorServer", "label": {"api": {"JMXConnectorServerFactory.newJMXConnectorServer": [[79, 125]]}}}, {"text": "The default layout of JPanel is FlowLayout, which \"lets each component assume its natural (preferred) size,\" while precluding subsequent changes", "label": {"api": {"JPanel": [[22, 27]], "FlowLayout": [[32, 41]]}}}, {"text": "java.util.function.Function or com.google.common.base.Function) which takes a String and returns the desired type", "label": {"api": {"java.util.function.Function": [[0, 26]]}}}, {"text": "Use the Path, File, and Files classes offered by modern Java to make easier work of file-handling", "label": {"api": {"Path": [[8, 11]], "File": [[14, 17], [24, 27]], "Files": [[24, 28]]}}}, {"text": "Use a BufferedWriter for better performance with large amounts of data", "label": {"api": {"BufferedWriter": [[6, 19]]}}}, {"text": "Skip the explicit flushing, as the buffered writer will be flushed automatically as part of auto-closing the BufferedWriter and CSVPrinter", "label": {"api": {"BufferedWriter": [[109, 122]]}}}, {"text": "To quote the Javadoc, calling java.io.Writer::close “Closes the stream, flushing it first.”", "label": {"api": {"java.io.Writer::close": [[30, 50]]}}}, {"text": "The exec command returns a Process object", "label": {"api": {"Process": [[27, 33]]}}}, {"text": "You can use destroy method to kill the process", "label": {"api": {"destroy": [[12, 18]]}}}, {"text": "From the StreamTokenizer documentation", "label": {"api": {"StreamTokenizer": [[9, 23]]}}}, {"text": "You aren't actually relocating the ball when you move it", "label": {"api": {"relocating": [[20, 29]]}}}, {"text": "Use an AnimationTimer, Vector calculation and Forces", "label": {"api": {"AnimationTimer": [[7, 20]]}}}, {"text": "Though as @KevinO and the others have suggested, it is more suitable to be using IllegalArgumentException, e.g", "label": {"api": {"IllegalArgumentException": [[81, 104]]}}}, {"text": "Javadoc for DataInputStream says the following", "label": {"api": {"DataInputStream": [[12, 26]]}}}, {"text": "So it is probably not a good idea to read manually-written text from file using DataInputStream", "label": {"api": {"DataInputStream": [[80, 94]]}}}, {"text": "Consider using FileInputStream#read() method if you need to read bytes or FileReader#read() if you need to read characters", "label": {"api": {"FileInputStream#read()": [[15, 36]], "FileReader#read()": [[74, 90]]}}}, {"text": "Yes, you are looking for the thenCompose(fn) operation", "label": {"api": {"thenCompose(fn)": [[29, 43]]}}}, {"text": "A CountdownLatch is really good for having one thread wait for one or more threads to complete one or more tasks before proceeding", "label": {"api": {"CountdownLatch": [[2, 15]]}}}, {"text": "A StackPane \"lays out its children in a back-to-front stack\"", "label": {"api": {"StackPane": [[2, 10]]}}}, {"text": "So if you used a VBox instead of a StackPane, the circles would appear one below the other (in the y-direction), but note they would still not respect the centerX and centerY properties", "label": {"api": {"StackPane": [[35, 43]]}}}, {"text": "The problem is you are calling dialog.getType() (which is part of java.awt.Window) instead of the method dialog.getTypes() you implemented yourself in ConnectDialog", "label": {"api": {"dialog.getType()": [[31, 46]]}}}, {"text": "The method getType() returns an enum value of type java.awt.Window.Type (and in this case it returns java.awt.Window.Type.NORMAL, whose toString() value of NORMAL is used)", "label": {"api": {"java.awt.Window.Type": [[51, 70], [101, 120]]}}}, {"text": "This will create an infinite Stream of objects produced by the supplier () -> new MyObject(), limit the stream to the total desired length, and collect it into an array", "label": {"api": {"Stream": [[29, 34]]}}}, {"text": "You can find the explanation in Pattern Javadoc", "label": {"api": {"Pattern": [[32, 38]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "Then, use length() from your File class to set a parameter for a loop, then dynamically add the result of string concatenation with the \"Transaction\" + your loop index to your ArrayList", "label": {"api": {"length()": [[10, 17]], "File": [[29, 32]]}}}, {"text": "A Reader on the other hand will use a CharsetDecoder to process the byte input and turn it into a sequence of chars instead", "label": {"api": {"CharsetDecoder": [[38, 51]], "Charset": [[38, 44]]}}}, {"text": "And the way it will process the byte input will depend on the Charset used", "label": {"api": {"Charset": [[62, 68]]}}}, {"text": "For java8 you can deserialize a ZonedDateTime instance by using the library jackson-datatype-jsr310", "label": {"api": {"ZonedDateTime": [[32, 44]]}}}, {"text": "Have a look at RenderingHints", "label": {"api": {"RenderingHints": [[15, 28]]}}}, {"text": "You can set them with calling g2.setRenderingHint(RenderingHints.Key hintKey, Object hintValue)", "label": {"api": {"RenderingHints": [[50, 63]]}}}, {"text": "Use background loading for your images", "label": {"api": {"Use background loading for your images": [[0, 37]]}}}, {"text": "You also need to dispose of the Graphics as soon as you're done drawing on it", "label": {"api": {"dispose": [[17, 23]]}}}, {"text": "I recommend you look at the example code in the BufferStrategy documentation", "label": {"api": {"BufferStrategy documentation": [[48, 75]]}}}, {"text": "It has a method scheduleWithFixedDelay which I think would accomplish what you need to do", "label": {"api": {"scheduleWithFixedDelay": [[16, 37]]}}}, {"text": "What you might want to look at is Future interface in java concurrent package", "label": {"api": {"Future": [[34, 39]]}}}, {"text": "An alternative solution if you always want to wait until all task are done is to use ExecutorService.invokeAll", "label": {"api": {"ExecutorService.invokeAll": [[85, 109]]}}}, {"text": "From the documentation of Charset (see the \"when encoding\" parts)", "label": {"api": {"Charset": [[26, 32]]}}}, {"text": "If you would be satisfied with the logger being ineligible for GC prior to VM shutdown, then you could register a shutdown hook with the runtime, that flushes the logger", "label": {"api": {"shutdown hook": [[114, 126]]}}}, {"text": "Such a hook would need to hold a reference to the logger, and the runtime will hold on to a reference to the hook (an unstarted Thread) until it shuts down, so the logger will remain ineligible for GC until the runtime executes its shutdown hooks", "label": {"api": {"shutdown hook": [[232, 244]]}}}, {"text": "Luckily both of these are known, thanks to Method#getParameterTypes()", "label": {"api": {"Method#getParameterTypes()": [[43, 68]]}}}, {"text": "If your class has a single instance and is shared between threads and you really need to have each thread use it's own file, try using Java's ThreadLocal class", "label": {"api": {"ThreadLocal": [[142, 152]]}}}, {"text": "Not real sure what you are trying to do here but the first line is using the Comparable interface which, whatever Vertex.getElement() returns, implements", "label": {"api": {"Comparable": [[77, 86]]}}}, {"text": "See javadoc of divide(BigDecimal divisor)", "label": {"api": {"divide(BigDecimal divisor)": [[15, 40]]}}}, {"text": "divide(BigDecimal divisor, int scale, RoundingMode roundingMode)", "label": {"api": {"divide(BigDecimal divisor, int scale, RoundingMode roundingMode)": [[0, 63]]}}}, {"text": "As you can see, there is no single clear definition of \"natural ordering\", which is what Comparable defines", "label": {"api": {"Comparable": [[89, 98]]}}}, {"text": "Basically, if your program runs correctly, then it's grabbing the UTF-8 bytes, storing them as Java strings, then outputting them to the terminal in whatever the default encoding scheme is", "label": {"api": {"outputting them to the terminal in whatever the default encoding scheme": [[114, 184]]}}}, {"text": "This sounds like a good case for Java's CountDownLatch", "label": {"api": {"Java's CountDownLatch": [[33, 53]]}}}, {"text": "As was mentioned by Gremash you shoud implement comparable interface and override equals method , dont rush this , make sure you know what you doing since you can mess up work in collections when you use your own objects that implement this interface and use your method.Take a look(if possible) at Core Java 1-2 series this problematic is discussed in these books and detaily explained", "label": {"api": {"comparable": [[48, 57]], "equals": [[82, 87]]}}}, {"text": "There are some rules for instance equals() must define an equivalence relation (it must be reflexive, symmetric, and transitive), more on that", "label": {"api": {"equals": [[34, 39]]}}}, {"text": "What issues should be considered when overriding equals and hashCode in Java", "label": {"api": {"equals": [[49, 54]]}}}, {"text": "Is there a way of validating a preferences object against a XSD", "label": {"api": {"preferences": [[31, 41]]}}}, {"text": "As the preferences file uses as base an XML file in my opinion it should be possible to do this", "label": {"api": {"preferences": [[7, 17]]}}}, {"text": "I think that if it is only an algorithm and if you are on Java 8 you can use a Function or a Predicate or a Supplier in combination with a map to avoid the if statement, for example", "label": {"api": {"Function": [[79, 86]], "Predicate": [[93, 101]], "Supplier": [[108, 115]]}}}, {"text": "In the case you need to supply a different form like in the example you posted, you could use a Supplier instead of a predicate", "label": {"api": {"Supplier": [[96, 103]]}}}, {"text": "As suggested by Baldurian you can check this by using Scanner#hasNextLine()", "label": {"api": {"Scanner#hasNextLine()": [[54, 74]]}}}, {"text": "You can add a Locale to NumberFormat and parse in the documentation", "label": {"api": {"add a Locale to NumberFormat": [[8, 35]], "parse in the documentation": [[41, 66]]}}}, {"text": "Instead, you should use Class#isAssignableFrom()", "label": {"api": {"Class#isAssignableFrom()": [[24, 47]]}}}, {"text": "You could try using the poll method in some sort of loop to only wait a specified amount of time for one queue before polling the other one", "label": {"api": {"poll": [[24, 27], [118, 121]]}}}, {"text": "You must create a new array and copy A over it, perhaps by using System.arrayCopy", "label": {"api": {"System.arrayCopy": [[65, 80]]}}}, {"text": "What happens with JDBC is that there is java.sql.Driver, which provides the different components; and the JDBC drivers are required to implement that class using a service provider; see the javadoc of DriverManager for more details", "label": {"api": {"the javadoc of DriverManager": [[186, 213]]}}}, {"text": "As List#sublist() returns a view of the list, so all modifications performed in a sublist are reflected in that \"parent\" list", "label": {"api": {"List#sublist()": [[3, 16]]}}}, {"text": "You can use Collectors.groupingBy", "label": {"api": {"Collectors.groupingBy": [[12, 32]]}}}, {"text": "A java.time.LocalDate (or logically-equivalent classes likes org.joda.time.LocalDate) is the best way to represent a date-of-birth (DOB) in Java code", "label": {"api": {"java.time.LocalDate": [[2, 20]]}}}, {"text": "Note that DOB is not well-modelled as a java.sql.Date, or a java.util.Date", "label": {"api": {"java.sql.Date": [[40, 52]], "java.util.Date": [[60, 73]]}}}, {"text": "Use a BitSet", "label": {"api": {"BitSet": [[6, 11]]}}}, {"text": "You could use a LinkedHashSet, which a Set implementation that ensures that iteration order is the same order you added elements in", "label": {"api": {"LinkedHashSet": [[16, 28]]}}}, {"text": "Use LinkedHashSet which maintains encounter order", "label": {"api": {"LinkedHashSet": [[4, 16]]}}}, {"text": "Additionally, it just so happens that the String class in java has an indexOf method that will accomplish exactly what you're trying to do with the for loop", "label": {"api": {"indexOf": [[70, 76]]}}}, {"text": "The first operation in most Throwable constructors is to fill in the stack trace, which is where most of the expense is", "label": {"api": {"fill in the stack trace,": [[57, 80]]}}}, {"text": "This constructor is accessible when extending Exception as well", "label": {"api": {"This constructor": [[0, 15]]}}}, {"text": "Native code is invoked to fill in the stack trace, which records the trace in a lighter-weight, native structure", "label": {"api": {"fill in the stack trace,": [[26, 49]]}}}, {"text": "Corresponding Java StackTraceElement objects are lazily created from this record only when the getStackTrace(), printStackTrace(), or other methods that require the trace are called", "label": {"api": {"StackTraceElement": [[19, 35]]}}}, {"text": "The main cost is hidden in native fillInStackTrace method which walks through the call stack and collects all required information to build a stack trace", "label": {"api": {"fillInStackTrace": [[34, 49]]}}}, {"text": "The myth about high exception costs comes from the fact that most of Throwable constructors implicitly call fillInStackTrace", "label": {"api": {"fillInStackTrace": [[108, 123]], "constructor": [[79, 89]]}}}, {"text": "However, there is one constructor to create a Throwable without a stack trace", "label": {"api": {"constructor": [[22, 32]]}}}, {"text": "Another way to create lightweight exceptions is to override fillInStackTrace", "label": {"api": {"fillInStackTrace": [[60, 75]]}}}, {"text": "Try out the Robot class to emulate a key press", "label": {"api": {"Robot": [[12, 16]]}}}, {"text": "Use the Key Event class's VK_WINDOWS constant to press the windows key (this can be generalized to also press the up key with VK_UP)", "label": {"api": {"Key Event": [[8, 16]]}}}, {"text": "Keep in mind the Robot class throws an IllegalArgumentException if the key is invalid", "label": {"api": {"Robot": [[17, 21]]}}}, {"text": "According Double's Javadoc, this number is represented by Double.MIN_VALUE", "label": {"api": {"Double.MIN_VALUE": [[58, 73]]}}}, {"text": "You can send a POST request using Java code with a class like HttpURLConnection within the action", "label": {"api": {"HttpURLConnection": [[62, 78]]}}}, {"text": "Since Java 8, you can do it in one line with the java.time library", "label": {"api": {"java.time": [[49, 57]]}}}, {"text": "The second argument (like the first one) of toMap(keyMapper, valueMapper) is a function that takes the stream element and returns the value of the map", "label": {"api": {"toMap(keyMapper, valueMapper)": [[44, 72]]}}}, {"text": "You can use the Random#ints(randomNumberOrigin, randomNumberBound) method", "label": {"api": {"Random#ints(randomNumberOrigin, randomNumberBound)": [[16, 65]]}}}, {"text": "To ensure distinct values, distinct() is called and limit(...) allows to only keep the number of elements we want", "label": {"api": {"distinct()": [[27, 36]], "limit(...)": [[52, 61]]}}}, {"text": "You should parse the content of the textProperty of the TextField instead", "label": {"api": {"textProperty": [[36, 47]]}}}, {"text": "You should use Stream.min instead", "label": {"api": {"Stream.min": [[15, 24]]}}}, {"text": "JavaFX will render sub pixels for text when FontSmoothingType.LCD is used", "label": {"api": {"FontSmoothingType.LCD": [[44, 64]]}}}, {"text": "You can try java.math.BigInteger", "label": {"api": {"java.math.BigInteger": [[12, 31]]}}}, {"text": "You can also do it using Long.valueOf()", "label": {"api": {"Long.valueOf()": [[25, 38]]}}}, {"text": "I've set up a solution using Pipes (via the default created Pipe.SinkChannel and Pipe.SourceChannel objects), which is usable for testing", "label": {"api": {"Pipe": [[29, 32], [60, 63], [81, 84]]}}}, {"text": "The documentation indicates that Pipes will pick their backend based on the environment in which they are used", "label": {"api": {"Pipe": [[33, 36]]}}}, {"text": "As a result, Pipes will not be too useful for benchmarking, as the performance of the Pipe implementation will change depending on what OS I'm benchmarking on", "label": {"api": {"Pipe": [[13, 16], [86, 89]]}}}, {"text": "Assuming you're using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[22, 37]]}}}, {"text": "Java's SimpleDateFormat has to decide in which century your date should be", "label": {"api": {"SimpleDateFormat": [[7, 22]]}}}, {"text": "It does this by adjusting dates to be within 80 years before and 20 years after the time the SimpleDateFormat instance is created", "label": {"api": {"SimpleDateFormat": [[93, 108]]}}}, {"text": "Don't use the convenience regex methods that String offers", "label": {"api": {"String": [[45, 50]]}}}, {"text": "Leverage the regex API by using Pattern and Matcher directly, specifically Matcher.appendReplacement and Matcher.appendTail", "label": {"api": {"Pattern": [[32, 38]], "Matcher": [[44, 50], [75, 81], [105, 111]], "Matcher.appendReplacement": [[75, 99]], "Matcher.appendTail": [[105, 122]]}}}, {"text": "If we look at the ByteBuffer documentation, the IllegalArgumentException can only be caused by trying to allocate a negative buffer size", "label": {"api": {"ByteBuffer": [[18, 27]]}}}, {"text": "The root problem with the original approach is that the constructor of ObjectOutputStream writes a serialization stream header to the underlying stream  (https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html#ObjectOutputStream-java.io.OutputStream-)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html#ObjectOutputStream-java.io.OutputStream-": [[154, 267]]}}}, {"text": "It calls the method in a parent class - ResourceBundle.Control", "label": {"api": {"ResourceBundle.Control": [[40, 61]]}}}, {"text": "The anonymous inner class defined in the code listing you attached actually derives from ResourceBundle.Control", "label": {"api": {"ResourceBundle.Control": [[89, 110]]}}}, {"text": "When I create a temporary file in android (using File#createTempFile), and I move that file to another directory (from /cache to /files of my application storage), will that file become persistent", "label": {"api": {"File#createTempFile": [[49, 67]]}}}, {"text": "The File class helps to abstract the idea of \"OS Managed Temporary File Storage\" by providing File#createTempFile(String prefix, String suffix)  so the code doesn't need to know (or figure out) an appropriate OS-temp directory (the Java runtime does that for you)", "label": {"api": {"File#createTempFile(String prefix, String suffix)": [[94, 142]]}}}, {"text": "The exception means that the parseDouble that you are trying to do, is getting passed either an empty string or a string that cannot be formatted as a double [doc source]", "label": {"api": {"doc source": [[159, 168]]}}}, {"text": "Here you get the controller with getController before you call load", "label": {"api": {"load": [[63, 66]]}}}, {"text": "The load method loads the object hierarchy from an FXML document and also this method creates an controller object for you which can be retrieved by getController()", "label": {"api": {"load": [[4, 7], [16, 19]]}}}, {"text": "get the controller after you have loaded the FXML file", "label": {"api": {"load": [[34, 37]]}}}, {"text": "If you examine BufferedInputStream#read's documentation you'll see it may not read enough data to fill the entire array, and will return the number of bytes it actually read", "label": {"api": {"BufferedInputStream#read": [[15, 38]]}}}, {"text": "Consider using the java.nio.Files API instead", "label": {"api": {"java.nio.Files": [[19, 32]]}}}, {"text": "The second and third lines of your doInBackground method should be moved to the done method, which is guaranteed to be executed in the AWT event thread", "label": {"api": {"is guaranteed to be executed in the AWT event thread": [[99, 150]]}}}, {"text": "Thread#join(), this approach works as expected", "label": {"api": {"Thread#join()": [[0, 12]]}}}, {"text": "ExecutorService#shutdown(), this technique allows executing code, which comes after shutdown() even if not all threads are finished", "label": {"api": {"ExecutorService#shutdown()": [[0, 25]]}}}, {"text": "The JavaDoc for the Map interface have many more details", "label": {"api": {"JavaDoc for the Map interface": [[4, 32]]}}}, {"text": "Use a HashSet, and implement equals and hashCode in Data, like so", "label": {"api": {"HashSet": [[6, 12]], "equals": [[29, 34]], "hashCode": [[40, 47]], "Set": [[10, 12]]}}}, {"text": "Sets of any kind do not contain any duplicate elements", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "notify() picks a waiting thread based on what the underlying thread implementation selects", "label": {"api": {"notify()": [[0, 7]]}}}, {"text": "notifyAll() gives all the waiting threads an equal chance to compete", "label": {"api": {"notifyAll()": [[0, 10]]}}}, {"text": "I am using java.net.HttpUrlConnection to make Http request to my Server", "label": {"api": {"HttpUrlConnection": [[20, 36]]}}}, {"text": "HttpUrlConnection will throw an IOException corresponding to the error status", "label": {"api": {"HttpUrlConnection": [[0, 16]]}}}, {"text": "Does HttpUrlConnection always throw an IOException if the server return an error status (4xx, 5xx)", "label": {"api": {"HttpUrlConnection": [[5, 21]]}}}, {"text": "I take a look at HttpUrlConnection API description but I couldn't answer my question", "label": {"api": {"HttpUrlConnection": [[17, 33]]}}}, {"text": "For example, Java's ManagementFactory doesn't exists for android, BUT no compile error is thrown even if in this class there are unresolved symbols/libraries, in particular", "label": {"api": {"ManagementFactory": [[20, 36]]}}}, {"text": "If the array elements are primitive (like int), you can use java.util.Arrays.equals", "label": {"api": {"java.util.Arrays.equals": [[60, 82]]}}}, {"text": "If they are themselves Objects, java.util.Arrays.deepEquals will do a deep equality test (provided the Objects in the array supply a suitable override of Object#equals", "label": {"api": {"java.util.Arrays.deepEquals": [[32, 58]]}}}, {"text": "Take a look at the Java AudioSystem class", "label": {"api": {"AudioSystem": [[24, 34]]}}}, {"text": "With split() you can use a regular expression to split a given string around matches of the given regular expression", "label": {"api": {"split()": [[5, 11]]}}}, {"text": "Send it to println method to print the string by outputting to the console", "label": {"api": {"println": [[11, 17]]}}}, {"text": "The Map#put method doesn't return the map, it returns the previous value associated with key, or null if there was no mapping for key", "label": {"api": {"Map#put": [[4, 10]]}}}, {"text": "You're receiving an ArrayIndexOutOfBoundsException, meaning you've tried to access an array with an illegal index", "label": {"api": {"ArrayIndexOutOfBoundsException": [[20, 49]]}}}, {"text": "The error is in the documentation for Comparator.compare", "label": {"api": {"documentation for Comparator.compare": [[20, 55]]}}}, {"text": "You're trying to pass an Optional<String> instead of a normal String", "label": {"api": {"Optional<String>": [[25, 40]]}}}, {"text": "You need to fetch the string first with .get() before converting your result to an integer", "label": {"api": {".get()": [[40, 45]]}}}, {"text": "Returns the Type representing the direct superclass of the entity (class, interface, primitive type or void) represented by this Class", "label": {"api": {"Type": [[12, 15]]}}}, {"text": "If the superclass is a parameterized type, the Type object returned must accurately reflect the actual type parameters used in the source code", "label": {"api": {"Type": [[47, 50]]}}}, {"text": "See the declaration of ParameterizedType for the semantics of the creation process for parameterized types", "label": {"api": {"Type": [[36, 39]], "ParameterizedType": [[23, 39]]}}}, {"text": "The getGenericSuperclass method returns a Type Object, in this case a ParameterizedType", "label": {"api": {"getGenericSuperclass": [[4, 23]], "Type": [[42, 45], [83, 86]], "ParameterizedType": [[70, 86]]}}}, {"text": "ParameterizedType Is an actual Java class, part of the reflection package", "label": {"api": {"Type": [[13, 16]], "ParameterizedType": [[0, 16]]}}}, {"text": "ParameterizedType represents a parameterized type such as Collection", "label": {"api": {"Type": [[13, 16]], "ParameterizedType": [[0, 16]]}}}, {"text": "See TypeVariable for details on the creation process for type variables", "label": {"api": {"Type": [[4, 7]]}}}, {"text": "Then the call to ParameterizedType.getActualTypeArguments", "label": {"api": {"Type": [[30, 33], [44, 47]], "ParameterizedType": [[17, 33]], "ParameterizedType.getActualTypeArguments": [[17, 56]]}}}, {"text": "Returns an array of Type objects representing the actual type arguments to this type", "label": {"api": {"Type": [[20, 23]]}}}, {"text": "So to summarize the code, the GenericDaoJpaImpl method is getting the superclass of itself, then extracting the actual Type information from the class, in this case only the first element", "label": {"api": {"Type": [[119, 122]]}}}, {"text": "Therefore, the method is extracting the actual Type of T that is being used for this instance of the class", "label": {"api": {"Type": [[47, 50]]}}}, {"text": "There are only 4 methods on ThreadLocal; the one you need is obviously ThreadLocal.get()", "label": {"api": {"ThreadLocal.get()": [[71, 87]]}}}, {"text": "Subclass LinkedHashSet, overriding the add method", "label": {"api": {"LinkedHashSet": [[9, 21]], "add": [[39, 41]]}}}, {"text": "There is no conversion error from the BigDecimal(long) constructor", "label": {"api": {"BigDecimal(long)": [[38, 53]]}}}, {"text": "You need to be careful only when you use the BigDecimal(double) constructor", "label": {"api": {"BigDecimal(double)": [[45, 62]]}}}, {"text": "If decodeXmlValue contains a XML string, you should unmarshaller the XML value, take a look to Mashaller java documentation", "label": {"api": {"Mashaller java documentation": [[95, 122]]}}}, {"text": "Usually XOR obfuscation of text is done at the character level, so you probably want DataInputStream#readChar", "label": {"api": {"DataInputStream#readChar": [[85, 108]]}}}, {"text": "Replace ^ by \\\\^, that's a special symbol that represents the beginning of a line as MULTILINE modifier is not enabled", "label": {"api": {"MULTILINE": [[85, 93]]}}}, {"text": "If you want to use an ExecutorService for your long-running operations, then you might be interested in the method ExecutorService::shutdown", "label": {"api": {"ExecutorService::shutdown": [[115, 139]]}}}, {"text": "This looks like a job for regular expression parsing using java.util.Pattern and java.util.Matcher", "label": {"api": {"java.util.Pattern": [[59, 75]], "java.util.Matcher": [[81, 97]]}}}, {"text": "In particular, you'll want to make the regex specify groups, so you can access each Term as a group via the group() method on Matcher", "label": {"api": {"group()": [[108, 114]]}}}, {"text": "One option is to create Exception object and call fillInStackTrace method and finally call getStackTrace() method", "label": {"api": {"fillInStackTrace": [[50, 65]]}}}, {"text": "I would suggest using the Arrays.copyOf here since that would take care of copying over the elements in the old array", "label": {"api": {"Arrays.copyOf": [[26, 38]]}}}, {"text": "You can implement Cloneable interface in object type", "label": {"api": {"Cloneable": [[18, 26]]}}}, {"text": "It filters out null elements, with the Objects::nonNull predicate", "label": {"api": {"Objects::nonNull": [[39, 54]]}}}, {"text": "The Neuron class can be an event source for the Synapse class by using the PropertyChangeSupport class", "label": {"api": {"PropertyChangeSupport": [[75, 95]]}}}, {"text": "Try using an ArrayList", "label": {"api": {"ArrayList": [[13, 21]]}}}, {"text": "You can then use one of the two toArray methods if you specifically need an array", "label": {"api": {"toArray": [[32, 38]]}}}, {"text": "You should instead be using HttpURLConnection or the one from Apache - HttpClient for more functionalities", "label": {"api": {"HttpURLConnection": [[28, 44]]}}}, {"text": "You may use AtomicReferenceArray", "label": {"api": {"AtomicReferenceArray": [[12, 31]]}}}, {"text": "You need to close, or at least flush, the writer before you read from the file", "label": {"api": {"flush": [[31, 35]]}}}, {"text": "The obvious way is to first get maximum value by Collections.max(), then collect indicies where items are equal to max", "label": {"api": {"Collections.max()": [[49, 65]]}}}, {"text": "I would use a JList with a custom DefaultListCellRenderer", "label": {"api": {"JList": [[14, 18]], "DefaultListCellRenderer": [[34, 56]]}}}, {"text": "Cell renderers determine how the objects in a cell is shown, so in your case you want MenuItem objects in your JList and the renderer should extract the name string for showing", "label": {"api": {"JList": [[111, 115]]}}}, {"text": "Create a JList and add it to the viewport of a JScrollPane", "label": {"api": {"JList": [[9, 13]]}}}, {"text": "I'm currently iterating over the list, calling String.trim() for each String, and adding it to a new List<String> and reassigning back to the original list after", "label": {"api": {"String.trim()": [[47, 59]]}}}, {"text": "You shouldn't mix various Date-Objects and calculations in and expect it to work", "label": {"api": {"Date": [[26, 29]]}}}, {"text": "Use the SimpleDateFormat to parse/output Dates easily without any huge efford since it'll do it for you already", "label": {"api": {"SimpleDateFormat": [[8, 23]], "Date": [[14, 17], [41, 44]]}}}, {"text": "You'll get the usual Date which you can get the times from", "label": {"api": {"Date": [[21, 24]]}}}, {"text": "If you need help with Dates, you should check this simple Tutorial for more information", "label": {"api": {"Date": [[22, 25]]}}}, {"text": "SwingUtilities contains a number of methods that could help you do this, but my guess is that getAncestorNamed might be the most useful", "label": {"api": {"getAncestorNamed": [[94, 109]]}}}, {"text": "Like a \"collection-version\" of Objects.requireNonNull()", "label": {"api": {"Objects.requireNonNull()": [[31, 54]]}}}, {"text": "From the JavaDoc for LocalDate", "label": {"api": {"LocalDate": [[21, 29]]}}}, {"text": "Use LocalDateTime instead", "label": {"api": {"LocalDate": [[4, 12]], "LocalDateTime": [[4, 16]]}}}, {"text": "Unfortunatly the documentation of Java-8 does make the same mistake to let users think the problem is just because of missing time information", "label": {"api": {"documentation of Java-8": [[17, 39]]}}}, {"text": "Let's consider the documentation of Java-8 again which here points into the right direction", "label": {"api": {"documentation of Java-8": [[19, 41]]}}}, {"text": "As shown here, ensure that your TableModel contains instances of Date", "label": {"api": {"Date": [[65, 68]]}}}, {"text": "Because Date is Comparable, you can use compareTo() to determine if a date, d, falls between two dates, where d1 precedes or coincides with d2", "label": {"api": {"Date": [[8, 11]], "Comparable": [[16, 25]]}}}, {"text": "If you are using Java 8, there is now the java.util.StringJoiner class", "label": {"api": {"java.util.StringJoiner": [[42, 63]]}}}, {"text": "The dynamic way to do instanceof is to use the Class.isInstance() method", "label": {"api": {"Class.isInstance()": [[47, 64]]}}}, {"text": "java.lang.reflect for getting class names and method names", "label": {"api": {"java.lang.reflect": [[0, 16]]}}}, {"text": "java.io.FileOutputStream for writing into file", "label": {"api": {"java.io.FileOutputStream": [[0, 23]]}}}, {"text": "java.awt.Font for making certain characters bold/indeted", "label": {"api": {"java.awt.Font": [[0, 12]]}}}, {"text": "According to Object's equals method, they wouldn't be, but List overrides that equals specification", "label": {"api": {"overrides": [[64, 72]]}}}, {"text": "I would create a PNG image for each record, with a transparent background and data at the right place", "label": {"api": {"data at the right place": [[78, 100]]}}}, {"text": "Then I would launch the printing of these images", "label": {"api": {"printing": [[24, 31]]}}}, {"text": "I recommend writing an XPath expression, which returns all nodes you want to remove, then iterating through the result and removing the nodes from the DOM", "label": {"api": {"XPath expression": [[23, 38]]}}}, {"text": "See the javadoc for StringBuffer", "label": {"api": {"StringBuffer": [[20, 31]]}}}, {"text": "Start Futures and then wait for results before assigning", "label": {"api": {"Futures": [[6, 12]]}}}, {"text": "As all computeParamX() accept one MyItem argument and have void return, they have a signature of Consumer<MyItem>", "label": {"api": {"Consumer<MyItem>": [[97, 112]]}}}, {"text": "Maybe you mean OperatingSystemMXBean (OperatingSystemMXBean) which is a platform-specific management interface for the operating system on which the Java virtual machine is running", "label": {"api": {"OperatingSystemMXBean": [[15, 35], [38, 58]]}}}, {"text": "Or you can use process.destroyForcibly();, see the Process documentation for more info", "label": {"api": {"Process documentation": [[51, 71]]}}}, {"text": "To get friends of friends, use Set#addAll() in the for-each loop", "label": {"api": {"Set#addAll()": [[31, 42]]}}}, {"text": "To get number of mutual friends, use Set#retainAll()", "label": {"api": {"Set#retainAll()": [[37, 51]]}}}, {"text": "You can decorate your (primary) stage this ways", "label": {"api": {"stage": [[32, 36]]}}}, {"text": "To get the result you need to use the methode initStyle(StageStyle style)", "label": {"api": {"initStyle(StageStyle style)": [[46, 72]]}}}, {"text": "You can use the Runtime.exec(String) method for that", "label": {"api": {"Runtime.exec(String)": [[16, 35]]}}}, {"text": "If yes, you can do it simply by List#removeAll()", "label": {"api": {"List#removeAll()": [[32, 47]]}}}, {"text": "The javadoc of OutputStreamWriter even says so", "label": {"api": {"OutputStreamWriter": [[15, 32]]}}}, {"text": "For top efficiency, consider wrapping an OutputStreamWriter within a BufferedWriter so as to avoid frequent converter invocations", "label": {"api": {"OutputStreamWriter": [[41, 58]]}}}, {"text": "Read the process' standard error stream too, and see if this prompt is there", "label": {"api": {"process' standard error stream": [[9, 38]]}}}, {"text": "If using JPA 2.0, you can specify the @MapsId annotation in your entity, allowing JPA to set the tuturial.tutorialPK.tutorialTypeId value from the tutorial.tutorialType reference for you", "label": {"api": {"@MapsId": [[38, 44]]}}}, {"text": "I'd rather just listen on a TCP port with a ServerSocket and listen for POST requests", "label": {"api": {"ServerSocket": [[44, 55]]}}}, {"text": "You could do this using Java Stream", "label": {"api": {"Java Stream": [[24, 34]]}}}, {"text": "Note that ZonedDateTime.now() uses the system time zone, which should change if you update it", "label": {"api": {"which should change if you update it": [[57, 92]]}}}, {"text": "Optionally, you'll want to implement the TreeModel methods that manage the TreeModelListener list by using the scheme prescribed in an EventListenerList API; the DefaultTreeModel source code is a good example", "label": {"api": {"EventListenerList": [[135, 151]], "DefaultTreeModel": [[162, 177]]}}}, {"text": "yet now I should create a method that returns text with identifikace, druh, vek and majitel - all as a String", "label": {"api": {"method": [[26, 31]]}}}, {"text": "That is a hint for your method signature", "label": {"api": {"method": [[24, 29]]}}}, {"text": "you want to write a method that returns a String", "label": {"api": {"method": [[20, 25]]}}}, {"text": "In fact, this kind of a requirement is so common that every Java object gets this for free in the form of an already implemented method called", "label": {"api": {"method": [[129, 134]]}}}, {"text": "This default method is however not that useful", "label": {"api": {"method": [[13, 18]]}}}, {"text": "So, you override that method this way", "label": {"api": {"method": [[22, 27]]}}}, {"text": "Use XPath to return a Node, and pass that Node to an identity Transformer", "label": {"api": {"XPath": [[4, 8]], "Transformer": [[62, 72]]}}}, {"text": "Definition of Set", "label": {"api": {"Definition of Set": [[0, 16]]}}}, {"text": "Definition of HashSet", "label": {"api": {"Definition of HashSet": [[0, 20]]}}}, {"text": "I want to get sublist of an ArrayDeque such there is in ArrayList", "label": {"api": {"ArrayDeque": [[28, 37]], "there is in ArrayList": [[44, 64]]}}}, {"text": "See the Connection.prepareStatement(String sql, int[] columnIndexes) API method, then use Statement.getGeneratedKeys() to access the results", "label": {"api": {"Connection.prepareStatement(String sql, int[] columnIndexes)": [[8, 67]], "Statement.getGeneratedKeys()": [[90, 117]]}}}, {"text": "use an XML parser (such as SAXParser) to parse the file first, then iterate over nodes, looking for comment nodes", "label": {"api": {"SAXParser": [[27, 35]]}}}, {"text": "What you really seem to need is the plain @NotNull contained in the standard bean validation API", "label": {"api": {"@NotNull": [[42, 49]]}}}, {"text": "Here the Bindings.stringValueAt is used to select the element form the ObservableList", "label": {"api": {"Bindings.stringValueAt": [[9, 30]]}}}, {"text": "You should use a ZonedDateTime", "label": {"api": {"ZonedDateTime": [[17, 29]]}}}, {"text": "On the returned instance, you can then call toEpochSecond()", "label": {"api": {"toEpochSecond()": [[44, 58]]}}}, {"text": "Call now() each time you want an update", "label": {"api": {"now()": [[5, 9]]}}}, {"text": "Go https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html and look at the Add, Get, and Remove methods", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[3, 68]]}}}, {"text": "You can do this with a single Stream pipeline by, as you hinted, the 3 argument reduce method", "label": {"api": {"reduce": [[80, 85]]}}}, {"text": "in that case, you would map each element into the value you want to sum, and reduce the Stream by summing all BigIntegers", "label": {"api": {"reduce": [[77, 82]]}}}, {"text": "The ending index of substring is exclusive, so you are trimming one too many characters off the end of the substring", "label": {"api": {"ending index of substring is exclusive": [[4, 41]]}}}, {"text": "The javadocs here:https://docs.oracle.com/javase/7/docs/api/java/util/zip/ZipInputStream.html says that getNextEntry() will return null if there are no more entries", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/zip/ZipInputStream.html": [[18, 92]]}}}, {"text": "Implement an Externalizable instead", "label": {"api": {"Externalizable": [[13, 26]]}}}, {"text": "Then use writeObject to serialize the references with account for object identity", "label": {"api": {"writeObject": [[9, 19]]}}}, {"text": "Note, that I am not suggesting to implement Serializable (which is slow, because of being reflection-based), but rather implementing Externalizable, which is basically the same thing as Parcelable, except it plays well with serialization", "label": {"api": {"Externalizable": [[133, 146]]}}}, {"text": "Have a look at FileFilter or FilenameFilter interfaces", "label": {"api": {"FileFilter": [[15, 24]], "FilenameFilter": [[29, 42]]}}}, {"text": "Make sure eventsForThisCategory is not modified by multiple threads at the same time (or switch to ConcurrentHashMap), and make sure it is not modified while toString() is running (it is called when you create the debug output)", "label": {"api": {"ConcurrentHashMap": [[99, 115]]}}}, {"text": "You need RandomAccessFile, it can reads file by bytes , so you could do stream-like processing", "label": {"api": {"RandomAccessFile": [[9, 24]]}}}, {"text": "Thought RandomAccessFile is quite easy to use, but it turns out pretty slow for big files", "label": {"api": {"RandomAccessFile": [[8, 23]]}}}, {"text": "You could use @ElementCollection for having a List of related aliases without the need to map the whole entity", "label": {"api": {"@ElementCollection": [[14, 31]]}}}, {"text": "Difference between @OneToMany and @ElementCollection", "label": {"api": {"@ElementCollection": [[34, 51]]}}}, {"text": "I decided to use javax.lang.model.type.NullType for that purpose", "label": {"api": {"javax.lang.model.type.NullType": [[17, 46]]}}}, {"text": "Is java.lang.Void or something else more appropriate", "label": {"api": {"java.lang.Void": [[3, 16]]}}}, {"text": "Check the BufferedReader documentation and the Java Tutorials for Reading, Writing, and Creating Files", "label": {"api": {"BufferedReader": [[10, 23]]}}}, {"text": "Read about regular expressions, and the method matches from the String class", "label": {"api": {"matches": [[47, 53]]}}}, {"text": "You can change your Connector class to implement AutoCloseable (which just has one method", "label": {"api": {"AutoCloseable": [[49, 61]]}}}, {"text": "It seems that if there is no matching combination the resultSet will be empty and  next() will always evaluate as false, completely skipping the while loop", "label": {"api": {"next()": [[83, 88]]}}}, {"text": "However, when you sort using natural order (String.compareTo()), it sorts by Unicode (UTF-16) code point, which means that LSD will sort before Legion", "label": {"api": {"String.compareTo()": [[44, 61]]}}}, {"text": "You could simply use String.compareToIgnoreCase(), and you would get the desired ordering", "label": {"api": {"String.compareToIgnoreCase()": [[21, 48]]}}}, {"text": "For the array version, use String.CASE_INSENSITIVE_ORDER", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[27, 55]]}}}, {"text": "To sort alphabetically in any particular language, like the index in a book, you need a Collator", "label": {"api": {"Collator": [[88, 95]]}}}, {"text": "You can use the Collator.compare() method in the bubble sort logic, or give it to the Arrays.sort() method", "label": {"api": {"Collator": [[16, 23]], "Collator.compare()": [[16, 33]], "Arrays.sort()": [[86, 98]]}}}, {"text": "Check out the String class in the Java API and look at the compareTo function for comparing strings against each other for sorting", "label": {"api": {"Java API": [[34, 41]]}}}, {"text": "The trigonometric methods sin, cos, tan, and toRadians all accept double as a parameter and return double", "label": {"api": {"sin": [[26, 28]], "tan": [[36, 38]], "toRadians": [[45, 53]]}}}, {"text": "You can explicitly cast the results to float if you want, but you get better precision with double, so declare your sin, cos, and tan variables as doubles", "label": {"api": {"sin": [[116, 118]], "tan": [[130, 132]]}}}, {"text": "Use the format specifier f instead of d", "label": {"api": {"format specifier f instead of d": [[8, 38]]}}}, {"text": "If you look at the API documentation, you will see that the trig methods will all return doubles", "label": {"api": {"API documentation": [[19, 35]]}}}, {"text": "Here is used Pattern.splitAsStream() stream generator, which splits a given input by regex", "label": {"api": {"Pattern.splitAsStream()": [[13, 35]]}}}, {"text": "But the return value of String::concat is not assigned to anything", "label": {"api": {"String::concat": [[24, 37]]}}}, {"text": "According to the official JavaDoc the annotation @MappedSuperclass", "label": {"api": {"official JavaDoc": [[17, 32]]}}}, {"text": "Java's Long.valueOf method allows you to take a String with a given radix, and convert it to it's (base 10) Long equivalent", "label": {"api": {"Long.valueOf": [[7, 18]]}}}, {"text": "To reverse the operation, you can use the Long.toString method, which takes a long instance and converts it to a String representation, with a specified radix", "label": {"api": {"Long.toString": [[42, 54]]}}}, {"text": "You can use schedule(TimerTask task, long delay) instead of scheduleAtFixedRate(TimerTask task, long delay, long period)", "label": {"api": {"schedule(TimerTask task, long delay)": [[12, 47]]}}}, {"text": "You could use String.valueOf() method when you need to set \"null\" String for null objects", "label": {"api": {"String.valueOf()": [[14, 29]]}}}, {"text": "Since Entry<Double, Integer> isn't a super-type of Double, the constructor can't be matched", "label": {"api": {"constructor can't be matched": [[63, 90]]}}}, {"text": "You can use a Timeline with INDEFINITE cycle count for this purpose", "label": {"api": {"Timeline": [[14, 21]]}}}, {"text": "This code (taken from the JavaDoc) demonstrates the problem in NetBeans 8.0.2 (as well as Eclipse Mars.2)", "label": {"api": {"taken from the JavaDoc": [[11, 32]]}}}, {"text": "you can directly use a custom SortedMap with groupingBy(classifier, mapFactory, downstream)", "label": {"api": {"groupingBy(classifier, mapFactory, downstream)": [[45, 90]]}}}, {"text": "Note also that Files.lines returns a Stream that should be closed in a try-with-resources", "label": {"api": {"Files.lines": [[15, 25]]}}}, {"text": "Also, you could make better use of the Scanner, which has a next() method that will give you the words separated by blank space (space, tab, line endings, etc.), which is the default delimiter", "label": {"api": {"next()": [[60, 65]]}}}, {"text": "If you want to know how String or split() works, read the docs..", "label": {"api": {"String": [[24, 29]], "split()": [[34, 40]], "read the docs": [[49, 61]]}}}, {"text": "Like @BasilBourque, I suggest storing the times as LocalTimes - but I would also suggest using a NavigableSet such as TreeSet instead of a List (I'm assuming that the times in your list are all unique)", "label": {"api": {"NavigableSet": [[97, 108]], "TreeSet": [[118, 124]]}}}, {"text": "The idea is that TreeSet has a ceiling method that does exactly what you need", "label": {"api": {"TreeSet": [[17, 23]], "a ceiling method that does exactly what you need": [[29, 76]]}}}, {"text": "Using setSortsOnUpdates(), suggested here by @trcs, is the best general solution, but you may be able to optimize updates by the choice of TableModelEvent available to subclasses of AbstractTableModel", "label": {"api": {"setSortsOnUpdates()": [[6, 24]], "AbstractTableModel": [[182, 199]]}}}, {"text": "The maximal value, Integer.MAX_VALUE is 2,147,483,647", "label": {"api": {"Integer.MAX_VALUE": [[19, 35]]}}}, {"text": "This explains the exception you are getting - from parseInt", "label": {"api": {"parseInt": [[51, 58]]}}}, {"text": "Btw, you cann access a key store directly, see the KeyStore class", "label": {"api": {"KeyStore": [[51, 58]]}}}, {"text": "It does not work as s.toCharArray()", "label": {"api": {"s.toCharArray()": [[20, 34]]}}}, {"text": "How about Stream API", "label": {"api": {"Stream API": [[10, 19]]}}}, {"text": "It seems to me that you have a JPA API 1.0 jar in your runtime classpath as the orphanRemoval attribute got introduced in JPA 2.0 and the error you're getting means that the attribute itself is missing from the API version discovered at runtime, which should only happen in case of JPA 1.0", "label": {"api": {"orphanRemoval": [[80, 92]]}}}, {"text": "You can copy a file directly with Files.copy", "label": {"api": {"Files.copy": [[34, 43]]}}}, {"text": "It can also take a 3rd argument that are CopyOption", "label": {"api": {"CopyOption": [[41, 50]]}}}, {"text": "An example could be StandardCopyOption.REPLACE_EXISTING which replaces the target file if it already exists", "label": {"api": {"CopyOption": [[28, 37]], "StandardCopyOption.REPLACE_EXISTING": [[20, 54]]}}}, {"text": "You can call Scanner.nextInt() an arbitrary amount of time", "label": {"api": {"Scanner.nextInt()": [[13, 29]]}}}, {"text": "Check thread pool executor here If you need to wait for several operations, for example to build the zip file and finally transfer them, you can use a lock condition on any object or use directly a Semaphore for managing your concurrent threads", "label": {"api": {"Semaphore": [[198, 206]]}}}, {"text": "Write your data into a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[23, 43]]}}}, {"text": "One difference between ByteArrayOutputStream and what you have written here is that typical implementations double the size of the backing array, means that writing n bytes has O(n) amortized time complexity", "label": {"api": {"ByteArrayOutputStream": [[23, 43]]}}}, {"text": "As the java API docs says", "label": {"api": {"java API docs": [[7, 19]]}}}, {"text": "An AssertionError should be thrown to indicate that an assertion has failed, including when an impossible condition has been satisfied", "label": {"api": {"AssertionError": [[3, 16]]}}}, {"text": "The problem may be solved by use of a StringBuilder", "label": {"api": {"StringBuilder": [[38, 50]]}}}, {"text": "However, note the warning in the Javadoc", "label": {"api": {"warning in the Javadoc": [[18, 39]]}}}, {"text": "If you're using Java 8, you can register a Plugin with the compiler to add some additional functionality during compilation", "label": {"api": {"Plugin": [[43, 48]]}}}, {"text": "Documentation for TaskListener", "label": {"api": {"Documentation for TaskListener": [[0, 29]]}}}, {"text": "A task listener is passed a TaskEvent, which has a Kind", "label": {"api": {"TaskEvent": [[28, 36]], "Kind": [[51, 54]]}}}, {"text": "As you can see in the plugin's init function, arguments can be passed to the Plugin from the command line", "label": {"api": {"Plugin": [[77, 82]]}}}, {"text": "I'm not sure why but there doesn't appear to be any documentation on this page about it, but it can used by setting up a file called com.sun.source.util.Plugin (the FQ class name of the interface to implement) in your META-INF/services directory", "label": {"api": {"Plugin": [[153, 158]]}}}, {"text": "In your Ant task you'll just need to specify a compiler flag -Xplugin:Timestamp_Plugin (note this is the name provided by the Plugin's getName() function)", "label": {"api": {"Plugin": [[80, 85], [126, 131]]}}}, {"text": "You'll also need to provide the compiled Plugin and runtime dependencies on the classpath, or the annotation processor path, if one is specified", "label": {"api": {"Plugin": [[41, 46]]}}}, {"text": "(TimeUnit#sleep) is a convenience method that converts time arguments into the form required by the Thread.sleep method", "label": {"api": {"TimeUnit#sleep": [[1, 14]]}}}, {"text": "Using the Matcher class you can get the two matching groups using the group method", "label": {"api": {"Matcher": [[10, 16]]}}}, {"text": "If you want to format that Date, you can use the SimpleDateFormat (https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[67, 139]]}}}, {"text": "What you want to do is a grouping operation using the name property as key", "label": {"api": {"grouping operation": [[25, 42]]}}}, {"text": "So we map the elements to colors, collect them into Sets (which implies keeping distinct values only) and finish by querying the size", "label": {"api": {"map the elements": [[6, 21]], "collect them into Sets": [[34, 55]], "finish": [[106, 111]]}}}, {"text": "If you look at the Graphics API, and in particular at this method, you'll see", "label": {"api": {"Graphics API": [[19, 30]]}}}, {"text": "Form the URL relative to the code base of the application", "label": {"api": {"code base": [[29, 37]]}}}, {"text": "The fact that javac runs properly does not prevent you from getting NoClassDefFoundError problems due to missing dependencies", "label": {"api": {"NoClassDefFoundError": [[68, 87]]}}}, {"text": "I have two CompletionStages", "label": {"api": {"CompletionStage": [[11, 25]]}}}, {"text": "Instead of a TextArea, print a TextFlow", "label": {"api": {"TextFlow": [[31, 38]]}}}, {"text": "Notice that the TextFlow's maxWidth needs to be set using the PrinterJob's page layout, after the print dialog has been shown", "label": {"api": {"TextFlow": [[16, 23]]}}}, {"text": "In addition to @Elliott Frisch 's answer, if the object cannot be unboxed (like instances of BigInteger, BigDecimal, String, or anything non-numeric), the compareTo method of the Comparable interface is used, the the result is compared to 0 using relational operators", "label": {"api": {"Comparable": [[179, 188]]}}}, {"text": "With this, remember to implement Comparable when you need to compare classes you defined", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "Here is the byte code from your Java, which shows that Integer.intValue is called to get the int out of the Integer", "label": {"api": {"Integer.intValue": [[55, 70]]}}}, {"text": "Instead of guarding with a call to containsKey() as everyone suggests, simply use the putIfAbsent() method", "label": {"api": {"putIfAbsent()": [[86, 98]]}}}, {"text": "I suggest you use ProcessBuilder, redirect the error to the output and read both to the end before waiting for the exit code", "label": {"api": {"ProcessBuilder": [[18, 31]]}}}, {"text": "Store your File references in a Set rather than a List or array", "label": {"api": {"Set": [[32, 34]]}}}, {"text": "There are a lot of Exceptions that are more specific that inherit from RuntimeException though.IllegalArgumentException comes to mind", "label": {"api": {"IllegalArgumentException": [[95, 118]]}}}, {"text": "ArrayList is an implementation of java.util.List that's backed by an array", "label": {"api": {"ArrayList": [[0, 8]], "java.util.List": [[34, 47]]}}}, {"text": "You can use it anywhere you would use a java.util.List", "label": {"api": {"java.util.List": [[40, 53]]}}}, {"text": "I suppose the most obvious solution would be to use a method from the standard Java library such as Files#isSymbolicLink(), but unfortunately this method does not exist in the Android SDK as explained in this other StackOverflow post", "label": {"api": {"Files#isSymbolicLink()": [[100, 121]]}}}, {"text": "If you want to do something like on the picture, maybe the easiest approach if you add your entries as TextArea by setting the row span on Nodes, like", "label": {"api": {"row span": [[127, 134]]}}}, {"text": "As per the API, the split method takes a regular expression as argument", "label": {"api": {"API": [[11, 13]]}}}, {"text": "JavaFX has a Hyperlink control which basically has all the functionality you are looking for", "label": {"api": {"Hyperlink control": [[13, 29]]}}}, {"text": "Use a ListIterator and its previous() method to insert before the current element", "label": {"api": {"ListIterator": [[6, 17]]}}}, {"text": "ForkJoinPool implements Executor", "label": {"api": {"ForkJoinPool": [[0, 11]]}}}, {"text": "If so, you could create a ClientRequestFilter, as following", "label": {"api": {"ClientRequestFilter": [[26, 44]], "Client": [[26, 31]]}}}, {"text": "And register it when creating a Client instance", "label": {"api": {"Client": [[32, 37]]}}}, {"text": "(assuming you're using JsonObject)", "label": {"api": {"JsonObject": [[23, 32]]}}}, {"text": "The simplest lock you can use is the Reentrant Lock, reentrant meaning that, if you attempt to acquire the lock when you already have it, the operation will succeed", "label": {"api": {"Reentrant Lock": [[37, 50]]}}}, {"text": "An easy solution that does not involve any extra thread is to use ConcurrentHashMap#computeIfAbsent", "label": {"api": {"ConcurrentHashMap#computeIfAbsent": [[66, 98]]}}}, {"text": "You can use a LocalDate (which is part of the JDK since Java 8)", "label": {"api": {"LocalDate": [[14, 22]]}}}, {"text": "You could use arraycopy https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy(java.lang.Object,%20int,%20java.lang.Object,%20int,%20int), creating empty array and putting new item on [0] than copy the rest", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/System.html#arraycopy(java.lang.Object,%20int,%20java.lang.Object,%20int,%20int)": [[24, 155]]}}}, {"text": "You can use toMap method and then call map.values()", "label": {"api": {"toMap": [[12, 16]]}}}, {"text": "Otherwise will be called toString() of Object.class, which doesn't know which properties you would like to expose and will return ClassName@HashCode", "label": {"api": {"Object.class": [[39, 50]]}}}, {"text": "I have extensively read through https://docs.oracle.com/cd/E17802_01/products/products/java-media/jai/forDevelopers/jai-apidocs/javax/media/jai/PlanarImage.html to learn about the PlanarImage class, but I still cannot figure out how to properly format a ColorModel", "label": {"api": {"https://docs.oracle.com/cd/E17802_01/products/products/java-media/jai/forDevelopers/jai-apidocs/javax/media/jai/PlanarImage.html": [[32, 159]]}}}, {"text": "but you could easily use Integer.parseInt(String val) and BigInteger(String val) to do the conversion if you wanted", "label": {"api": {"Integer.parseInt(String val)": [[25, 52]], "BigInteger(String val)": [[58, 79]]}}}, {"text": "This looks like something for which you can use a single-threaded Executor with Runnables or Callables which you create as anonymous classes", "label": {"api": {"Executor": [[66, 73]], "Runnable": [[80, 87]], "Callable": [[93, 100]]}}}, {"text": "A bit of googling led me to the Executors factory which helps create a single-threaded executor", "label": {"api": {"Executor": [[32, 39]], "Executors": [[32, 40]]}}}, {"text": "I did not know what sort of return values your methods have, so I opted for Void as the return type of the Callables", "label": {"api": {"Callable": [[107, 114]]}}}, {"text": "The default delimiter is whitespace, but you can set it to something else via useDelimiter()", "label": {"api": {"useDelimiter()": [[78, 91]]}}}, {"text": "You can use Collections.reverse(list); check documentation", "label": {"api": {"check documentation": [[39, 57]]}}}, {"text": "In Java8 you can use Streams to access functional-style operations such as filter() and count()", "label": {"api": {"Streams": [[21, 27]]}}}, {"text": "Implement Comparable interface in your object", "label": {"api": {"Comparable": [[10, 19]]}}}, {"text": "And then you can use Collections class sort method as follows", "label": {"api": {"Collections class sort": [[21, 42]]}}}, {"text": "You want to use java.nio.file.Files.readAllLines", "label": {"api": {"java.nio.file.Files.readAllLines": [[16, 47]]}}}, {"text": "If you're looking to save state between reloads, you'll want to capture the current HTML and then use the WebView's loadContent functionality when the reload is complete", "label": {"api": {"loadContent functionality": [[116, 140]]}}}, {"text": "I think what you need is semaphore", "label": {"api": {"semaphore": [[25, 33]]}}}, {"text": "Briefly speaking, semaphore is a locking method", "label": {"api": {"semaphore": [[18, 26]]}}}, {"text": "You ask the resource from the semaphore singleton class, which is process scope unique, control the running number of function process", "label": {"api": {"semaphore": [[30, 38]]}}}, {"text": "The Graphics context specifies that \"All rendering operations modify only pixels which lie within the area bounded by the current clip,\" so no additional checks are typically required", "label": {"api": {"Graphics": [[4, 11]]}}}, {"text": "Serialize your shapes to FXML (you will need to code the serializer yourself)", "label": {"api": {"FXML": [[25, 28]]}}}, {"text": "Each time the user edits the shapes, serialize the to FXML again and save the FXML as a preference (as outlined in Frank Fotangs answer)", "label": {"api": {"FXML": [[54, 57], [78, 81]]}}}, {"text": "When the user first opens the application, read the current preference containing the FXML for the current shapes and load them up using an FXMLLoader", "label": {"api": {"FXML": [[86, 89], [140, 143]], "FXMLLoader": [[140, 149]]}}}, {"text": "The same technique can be used for implementing your Open and Save menu options, only instead of writing the serialized data to a preference you will write it to a file location chosen by a FileChooser", "label": {"api": {"FileChooser": [[190, 200]]}}}, {"text": "Now you don't need to use FXML for your serialized format, you could use other formats such as JSON or YAML and other serialization support libraries such as Jackson", "label": {"api": {"FXML": [[26, 29]]}}}, {"text": "However, to me, FXML seems the most logical format to choose because JavaFX ships with the FXMLLoader, which provides an easy to use API to transfer your serialized data (an FXML file representing your scene) into an in-memory structure (the scene graph), via a simple call to the load method", "label": {"api": {"FXML": [[16, 19], [91, 94], [174, 177]], "FXMLLoader": [[91, 100]], "load method": [[281, 291]]}}}, {"text": "What makes this task tricky rather than trivial is that the JavaFX API only ships with an FXMLLoader, it does not ship with a corresponding class (e.g", "label": {"api": {"FXML": [[90, 93]], "FXMLLoader": [[90, 99]]}}}, {"text": "an FXMLSaver), which does the opposite work of taking the in-memory structure (the scene graph) and creating serialized data from it (an FXML file)", "label": {"api": {"FXML": [[3, 6], [137, 140]]}}}, {"text": "Now, SceneBuilder is an open source project and does include logic to save a scene graph to an FXML file", "label": {"api": {"FXML": [[95, 98]]}}}, {"text": "For instance you can find source code for an FXMLSaver in the SceneBuilder source", "label": {"api": {"FXML": [[45, 48]]}}}, {"text": "The method replaceAll() takes a regex pattern as the first argument and a regex replacement as the second argument", "label": {"api": {"replaceAll()": [[11, 22]]}}}, {"text": "The method replace() takes two plain strings and does not apply any interpretation to them", "label": {"api": {"replace()": [[11, 19]]}}}, {"text": "If you actually wanted to use replaceAll() to do the job, you would write replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")", "label": {"api": {"replaceAll()": [[30, 41]]}}}, {"text": "But this is unnecessarily complicated, so simply use the replace() method instead", "label": {"api": {"replace()": [[57, 65]]}}}, {"text": "A URL is built like this (from Wikipedia)", "label": {"api": {"URL": [[2, 4]]}}}, {"text": "Your URL decomposes to (using URL, scheme is called protocol and fragment is called ref)", "label": {"api": {"URL": [[5, 7], [30, 32]]}}}, {"text": "Also, if you enter that URL into a web browser, the fragment is handled by the browser and not sent to the server", "label": {"api": {"URL": [[24, 26]]}}}, {"text": "Once the query has been extracted, you can use URLEncodedUtils.parse", "label": {"api": {"URL": [[47, 49]]}}}, {"text": "parse is not for the entire URL", "label": {"api": {"URL": [[28, 30]]}}}, {"text": "You don't need another thread, you can use a PauseTransition", "label": {"api": {"PauseTransition": [[45, 59]]}}}, {"text": "If for some reason you didn't wish to use a transition and you want to use your own threading, then you should look use JavaFX concurrency utilities such as Task", "label": {"api": {"Task": [[157, 160]]}}}, {"text": "If you didn't want to use a Task, then you can still create your own thread or runnable, but ensure that any callbacks are made using Platform.runLater()", "label": {"api": {"Task": [[28, 31]], "Platform.runLater()": [[134, 152]]}}}, {"text": "Of the different approaches, I recommend the PauseTransition over the others as then you don't need to deal with concurrency details such as threading, which are easy to get wrong", "label": {"api": {"PauseTransition": [[45, 59]]}}}, {"text": "You may first students by score using Comparator.somparing() comparator, then iterate over sorted list and apply ranks, as follows", "label": {"api": {"Comparator.somparing()": [[38, 59]]}}}, {"text": "For performance and quality aspects it could be also useful to set some RenderingHints.For more information see Controlling Rendering Quality", "label": {"api": {"RenderingHints": [[72, 85]]}}}, {"text": "Otherwise you won't be overriding the method defined in ActionListener - you'll just be creating a new method", "label": {"api": {"the method defined in ActionListener": [[34, 69]]}}}, {"text": "The actionPerformed method is declared with the ActionEvent parameter to pass the method details about the event (which component triggered the event, the action command, etc..)", "label": {"api": {"action command": [[155, 168]]}}}, {"text": "You can use BufferedInputStream.skip(long) to skip until right pos, and the read and write the amount of bytes from 1012 (startPos) to 2134 (endPos), that is 2134-1012=1122 bytes", "label": {"api": {"BufferedInputStream.skip(long)": [[12, 41]]}}}, {"text": "The various ExecutorService instances created by Executors and ForkJoinPool.commonPool() of course have quite different behaviour", "label": {"api": {"ExecutorService": [[12, 26]], "Executors": [[49, 57]], "ForkJoinPool.commonPool()": [[63, 87]]}}}, {"text": "Since the services using daemon threads die when the main thread dies, this is of course to be expected", "label": {"api": {"daemon threads": [[25, 38]]}}}, {"text": "And if I can't be sure if daemon threads will be used when I create ExecutorService instances like this, how should I create them in a way that guarantees the behaviour I want", "label": {"api": {"ExecutorService": [[68, 82]], "daemon threads": [[26, 39]]}}}, {"text": "When using getResource() from Class, the path is expected to be relative to the class if it is not prefixed with \"/\"", "label": {"api": {"getResource() from Class": [[11, 34]]}}}, {"text": "Throw an IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[9, 32]]}}}, {"text": "From stream package summary section on Side-effects", "label": {"api": {"stream package summary": [[5, 26]]}}}, {"text": "You need to provide a Cell Factory and a Cell Value Factory for your TableColumn", "label": {"api": {"Cell Factory": [[22, 33]], "Cell Value Factory": [[41, 58]]}}}, {"text": "The obvious answer is that you would maintain an internal selection state for the hexagon and just set a stroke in code on a hexagon shape or apply a drop shadow effect, but maybe you would prefer a different approach such as styling via css or subclassing ToggleButton", "label": {"api": {"set a stroke": [[99, 110]], "drop shadow effect": [[150, 167]], "ToggleButton": [[257, 268]]}}}, {"text": "For instance with a toggle button, there are selected and unselected states, as well as armed and unarmed states and hovered and unhovered styles, each of which can have different visual feedback applied", "label": {"api": {"selected": [[45, 52], [60, 67]], "armed": [[88, 92], [100, 104]]}}}, {"text": "One such way will be to use Scanner", "label": {"api": {"Scanner": [[28, 34]]}}}, {"text": "Why not to use Collections.sort()", "label": {"api": {"Collections.sort()": [[15, 32]]}}}, {"text": "Or, more efficiently, remove the loop and call arr.clear(); instead", "label": {"api": {"arr.clear();": [[47, 58]]}}}, {"text": "If you want to remove the value, call remove((Integer)i);", "label": {"api": {"remove((Integer)i);": [[38, 56]]}}}, {"text": "DelayQueue - More up-to-date", "label": {"api": {"DelayQueue": [[0, 9]]}}}, {"text": "ScheduledThreadPoolExecutor - Still more up-to-date than DelayQueue", "label": {"api": {"DelayQueue": [[57, 66]], "ScheduledThreadPoolExecutor": [[0, 26]]}}}, {"text": "The remove(int) will remove the element at the given index, not the element equal to the given value", "label": {"api": {"remove(int)": [[4, 14]]}}}, {"text": "Just mind that Random.nextInt(int) will throw an Exception if the argument is zero (if your List is empty)", "label": {"api": {"Random.nextInt(int)": [[15, 33]]}}}, {"text": "See the JavaDoc for new String(bytes[])", "label": {"api": {"new String(bytes[])": [[20, 38]]}}}, {"text": "On Java 8, you can use java.util.Base64 for that, on older platforms the Apache Commons Codec's Base64 class can be used", "label": {"api": {"java.util.Base64": [[23, 38]]}}}, {"text": "JavaDoc says that previouse() returns the previouse element in the list and moves the cursor position backwards", "label": {"api": {"says": [[8, 11]]}}}, {"text": "Your DefaultListModel has all the methods you need", "label": {"api": {"DefaultListModel": [[5, 20]]}}}, {"text": "If you just make updates to your DefaultListModel, you can recover your ArrayList with", "label": {"api": {"DefaultListModel": [[33, 48]]}}}]