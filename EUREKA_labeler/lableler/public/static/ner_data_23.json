[{"text": "Consider instead using a Popup to display the pauseMenu on top of the existing window, or just use a modal Stage with undecorated StageStyle, as in the following SSCCE", "label": {"api": {"Popup": [[25, 29]]}}}, {"text": "Open the file using a RandomAccessFile, seek to the beginning offset, define the buffer length and read the buffer fully", "label": {"api": {"RandomAccessFile": [[22, 37]]}}}, {"text": "The try-with-resources statement takes care of closing the RandomAccessFile", "label": {"api": {"RandomAccessFile": [[59, 74]]}}}, {"text": "You can try SwingUtilities.invokeLater and SwingUtilities.invokeAndWait instead of swingWorker", "label": {"api": {"SwingUtilities.invokeLater": [[12, 37]], "SwingUtilities.invokeAndWait": [[43, 70]]}}}, {"text": "You can construct all Swing objects on EDT and then let your SwingWorker (or any other thread) govern all updates by instructing EDT to execute them via SwingUtilities.invokeLater(Runnable)", "label": {"api": {"SwingUtilities.invokeLater(Runnable)": [[153, 188]]}}}, {"text": "Note that if you take a look at SwingWorker implementation, you'll see that it relies on javax.swing.Timer to execute done() and the Timer itself calls invokeLater, so calling it inside done again amounts to doing nothing", "label": {"api": {"javax.swing.Timer": [[89, 105]]}}}, {"text": "I am trying to create a fairly simple Collector that converts a Stream<Map.Entry> into a Map, but javac is complaining about the generics", "label": {"api": {"Collector": [[38, 46]]}}}, {"text": "You can see how the hashcode is calculated in the ArrayList.hashCode documentation", "label": {"api": {"ArrayList.hashCode": [[50, 67]]}}}, {"text": "Per the Map documentation", "label": {"api": {"Map documentation": [[8, 24]]}}}, {"text": "If you want a map where keys are looked up by identity rather than by value, you can use the IdentityHashMap class", "label": {"api": {"IdentityHashMap": [[93, 107]]}}}, {"text": "In the Joda-Time library, the Period class represents a period of time including years, months, days, hours, minutes, etc", "label": {"api": {"Period": [[30, 35]]}}}, {"text": "However, in Java Time API a Period class can only include a number of years, months and days", "label": {"api": {"Period": [[28, 33]]}}}, {"text": "Why can't I include a time in Java's Period object, and what is then the best way to express something like \"2 days and 1 hour\"", "label": {"api": {"Period": [[37, 42]]}}}, {"text": "Instead use a javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[14, 30]]}}}, {"text": "Take a look at URLClassLoader", "label": {"api": {"URLClassLoader": [[15, 28]]}}}, {"text": "Well, for a producer/consumer, I'd recommend LinkedBlockingQueue or ConcurrentLinkedQueue", "label": {"api": {"LinkedBlockingQueue": [[45, 63]], "ConcurrentLinkedQueue": [[68, 88]]}}}, {"text": "Here's an example if you used the ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[34, 54]]}}}, {"text": "You can use java.util.Scanner to parse a String using Scanner(String)", "label": {"api": {"java.util.Scanner": [[12, 28]], "Scanner(String)": [[54, 68]]}}}, {"text": "You can also use java.lang.StringBuilder to construct strings in an efficient manner", "label": {"api": {"java.lang.StringBuilder": [[17, 39]]}}}, {"text": "HashSet (Java Platform SE 8 ) says", "label": {"api": {"HashSet (Java Platform SE 8 )": [[0, 28]]}}}, {"text": "You use compareAndSet when you need to update some data already existent in AtomicReference and then put it back to this reference", "label": {"api": {"compareAndSet": [[8, 20]]}}}, {"text": "But with compareAndSet we could increase it atomically", "label": {"api": {"compareAndSet": [[9, 21]]}}}, {"text": "Also, you may Apache Commons IOUtils to simplify copying from one stream to the other or if you are using Java 8 then you can just call Files.copy method", "label": {"api": {"Files.copy": [[136, 145]]}}}, {"text": "The class TreeItem has a method getParent, which returns the parent of the specified TreeItem", "label": {"api": {"getParent": [[32, 40]]}}}, {"text": "This parent, which is also a TreeItem has a method getChildren to get the child TreeItems; the order of TreeItems in the returned ObservableList is the actual order that you can see on the screen, therefore you can insert a new element in a specific index with add after you retrieved the index of the element in the list with indexOf()", "label": {"api": {"getChildren": [[51, 61]], "add": [[261, 263]], "indexOf()": [[327, 335]]}}}, {"text": "Now that we have a FileReader , we can use the skip(long) function to go directly to where we want", "label": {"api": {"the skip(long) function": [[43, 65]]}}}, {"text": "Even the documentation on Short isn't helping (I must be dumb or something else at this point)", "label": {"api": {"Short": [[26, 30]]}}}, {"text": "Java's String.toLowerCase(Locale) uses the default where there is no \"tailoring\" data provided for the specified Locale's case mapping of the string", "label": {"api": {"String.toLowerCase(Locale)": [[7, 32]]}}}, {"text": "The java.io.File#mkdir method only declares to throw SecurityException - see API", "label": {"api": {"API": [[77, 79]]}}}, {"text": "java.lang.SecurityException is a RuntimeException and doesn't require being caught, although you may want to, depending on the context (again, see API)", "label": {"api": {"API": [[147, 149]]}}}, {"text": "You are not allowed to throw checked exceptions because the accept(T t, U u) method in the java.util.function.BiConsumer<T, U> interface doesn't declare any exceptions in its throws clause", "label": {"api": {"accept(T t, U u)": [[60, 75]], "java.util.function.BiConsumer<T, U>": [[91, 125]]}}}, {"text": "And, as you know, Map#forEach takes such a type", "label": {"api": {"Map#forEach": [[18, 28]]}}}, {"text": "You can use the Calendar class", "label": {"api": {"Calendar": [[16, 23]]}}}, {"text": "Despite you wrote about low level threading, it's clear that your problem can be solved with ForkJoinPool", "label": {"api": {"ForkJoinPool": [[93, 104]]}}}, {"text": "This is indeed possible, using Collectors", "label": {"api": {"Collector": [[31, 39]], "Collectors": [[31, 40]]}}}, {"text": "Or even Collectors", "label": {"api": {"Collector": [[8, 16]], "Collectors": [[8, 17]]}}}, {"text": "Assuming ObservableList is a Collection of some sort, you can do the following", "label": {"api": {"Collection": [[29, 38]]}}}, {"text": "If you want faster performance use something like the TreeMap class", "label": {"api": {"TreeMap": [[54, 60]]}}}, {"text": "I would suggest implementing the hashCode method on whatever object represents your customer", "label": {"api": {"hashCode method": [[33, 47]]}}}, {"text": "As the tasks are submitted you create a mapping (using HashMap) where the key is your customer and the value is a queue - I suggest ConcurrentLinkedQueue - then add either the task or the thread to the queue", "label": {"api": {"HashMap": [[55, 61]], "ConcurrentLinkedQueue": [[132, 152]]}}}, {"text": "You can do this using the peek method of the queue", "label": {"api": {"peek": [[26, 29]]}}}, {"text": "When the current task finishes it will call its queue's poll method to remove itself from the head of the queue and then calls peek to obtain the next task", "label": {"api": {"peek": [[127, 130]], "poll": [[56, 59]]}}}, {"text": "Where take is a blocking operation, can an interrupt not be ignored for the time being if an interrupt \"arrives\" between the check of Thread.currentThread().isInterrupted() and the call queue.take()", "label": {"api": {"take": [[6, 9], [192, 195]]}}}, {"text": "It is possible to use  poll with a timeout so that the loop is left after the timeout, but is it possible to check the interrupted status and act on it atomically", "label": {"api": {"poll with a timeout": [[23, 41]]}}}, {"text": "You could use the wasNull() method", "label": {"api": {"wasNull()": [[18, 26]]}}}, {"text": "The type isn't an instance of the HttpServletRequest class, it's an instance of java.lang.Class that contains the information about the HttpServletRequest class", "label": {"api": {"java.lang.Class": [[80, 94]]}}}, {"text": "java.util.function.Supplier<T>, (a Java 8 feature), is a functional interface that has one method get, which returns an object of the type T", "label": {"api": {"java.util.function.Supplier<T>": [[0, 29]]}}}, {"text": "hello as that’s the path, relative to foo bar baz to get to foo bar hello, i.e Paths.get(\"foo\", \"bar\", \"baz\").resolve(Paths.get(\"..\", \"hello\")).normalize() produces the same path as Paths.get(\"foo\", \"bar\", \"hello\"), regardless of any real file system structure", "label": {"api": {"resolve": [[110, 116]]}}}, {"text": "So whether you use Paths.get(\"..\", \"..\", \"temp\", \"delete\", \"dictionary.txt\") or Paths.get(\"a\", \"b\", \"c\", \"d\", \"e\"), it makes no difference, in either case, the implementation treats it as five nonmatching path components that have to be removed to resolve to Paths.get(\"zoo.txt\")", "label": {"api": {"resolve": [[248, 254]]}}}, {"text": "path components, the first resolved path will exhibit the problem whereas the second resolves to the expected zoo.txt", "label": {"api": {"resolve": [[27, 33], [85, 91]]}}}, {"text": "The documentation of relativize doesn’t mention that explicitly, but you can derive it from the documented relationship to resolve, whose documentation says “… this method considers this path to be a directory”", "label": {"api": {"resolve": [[123, 129]]}}}, {"text": "Other than that, you may use Arrays.sort", "label": {"api": {"Arrays.sort": [[29, 39]]}}}, {"text": "@XmlSeeAlso is used for binding sub-classes", "label": {"api": {"@XmlSeeAlso": [[0, 10]]}}}, {"text": "An example from @XmlSeeAlso documentation", "label": {"api": {"@XmlSeeAlso": [[16, 26]]}}}, {"text": "So, in your exemple, it is not necessary to use @XmlSeeAlso to bind the SomeClassOne and SomeClassTwo classes", "label": {"api": {"@XmlSeeAlso": [[48, 58]]}}}, {"text": "The entry object just calls the key's and value's equal methods in its equals method and thus just calls the arrays equal method which doesn't work as one would expect", "label": {"api": {"its equals method": [[67, 83]]}}}, {"text": "If you want to get around the wrapper you can also use lists, as their equals method is implemented as you would expect", "label": {"api": {"their equals method": [[65, 83]]}}}, {"text": "You have to add a function that overrides the Object.toString() method", "label": {"api": {"Object.toString()": [[46, 62]]}}}, {"text": "As already pointed out in the comments, the documentation of Files.isHidden states", "label": {"api": {"Files.isHidden": [[61, 74]]}}}, {"text": "Use Integer class and radix parameter of parseInt, and toHexString from the same class", "label": {"api": {"parseInt": [[41, 48]]}}}, {"text": "According to the official documentation of ResultSet you need to call the next() method before you can access the data elements from the ResultSet", "label": {"api": {"ResultSet": [[43, 51], [137, 145]]}}}, {"text": "A ResultSet cursor is initially positioned before the first row; the first call to the method next makes the first row the current row; the second call makes the second row the current row, and so on", "label": {"api": {"ResultSet": [[2, 10]]}}}, {"text": "As noted in the comment/answer by Jalal Kiswani, it's also recommendable to NOT close the DB-connection before you're finished processing the ResultSet", "label": {"api": {"ResultSet": [[142, 150]]}}}, {"text": "setDefaultUncaughtExceptionHandler is a method that will register a handler that will be invoked when an exception has been thrown in any thread and wasn't caught", "label": {"api": {"setDefaultUncaughtExceptionHandler": [[0, 33]]}}}, {"text": "You can also have a handler per thread by using setUncaughtExceptionHandler on a Thread instance", "label": {"api": {"setUncaughtExceptionHandler": [[48, 74]]}}}, {"text": "There are other interfaces available like Consumer<...> that take work for different types of methods, in the java.util.function package", "label": {"api": {"java.util.function": [[110, 127]]}}}, {"text": "Of course you can use ExecutorService or any other helpers for threading instead of manual thread spawning", "label": {"api": {"ExecutorService": [[22, 36]]}}}, {"text": "Instead of creating a new JLabel, you could use JLabel::setIcon to change the image", "label": {"api": {"JLabel::setIcon": [[48, 62]]}}}, {"text": "If degrees is not a String but an int for example, you can still convert it to one with String.valueOf", "label": {"api": {"String.valueOf": [[88, 101]]}}}, {"text": "If it is a string \"true\" or \"false\", then Boolean.valueOf() is correct, but that seems unlikely", "label": {"api": {"Boolean.valueOf()": [[42, 58]]}}}, {"text": "In second case I suggest using TreeMap", "label": {"api": {"TreeMap": [[31, 37]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/awt/event/WindowAdapter.html for more information", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/awt/event/WindowAdapter.html": [[4, 78]]}}}, {"text": "From the documentation for Application", "label": {"api": {"Application": [[27, 37]]}}}, {"text": "No need to roll your own doubly linked list, there already is one", "label": {"api": {"one": [[62, 64]]}}}, {"text": "If you must use your own, then you could implement List as; if you use a List implementation such as the build in doubly linked list, LinkedList, you can use Collections.shuffle", "label": {"api": {"LinkedList": [[134, 143]], "Collections.shuffle": [[158, 176]]}}}, {"text": "And I would use supply my own random", "label": {"api": {"random": [[30, 35]]}}}, {"text": "If you have an upper bounding character (I'll use z as an example), you could use a regular expression with replaceAll", "label": {"api": {"replaceAll": [[108, 117]]}}}, {"text": "The regular expression [g-z] means \"any character g through z inclusive\", see Pattern for details", "label": {"api": {"Pattern": [[78, 84]]}}}, {"text": "You may want to create the regular expression explicitly rather than relying on replaceAll's default version, if you want case-insensitivity for instance", "label": {"api": {"replaceAll": [[80, 89]]}}}, {"text": "If User and UserPage have parent-child relation, use CascadeType mapping", "label": {"api": {"CascadeType": [[53, 63]]}}}, {"text": "Basically, I have only one key class - a LocalDate", "label": {"api": {"LocalDate": [[41, 49]]}}}, {"text": "I use Box.Filler to push those computer icons to the table panel", "label": {"api": {"Box.Filler": [[6, 15]]}}}, {"text": "You probably want a LinkedHashMap where you put the longer keys in the map first (as you have in your example), because it will iterate the entries in insertion order (by default)", "label": {"api": {"LinkedHashMap": [[20, 32]]}}}, {"text": "You can use the new String(byte[] bytes, int offset, int length, String charsetName()) constructor", "label": {"api": {"new String(byte[] bytes, int offset, int length, String charsetName())": [[16, 85]]}}}, {"text": "All you have to do, is to use flip and compact correctly as shown in the documentation of compact", "label": {"api": {"shown in the documentation of compact": [[60, 96]]}}}, {"text": "The method Reader.read(CharBuffer) was missing in the first release of NIO, but handed in with Java 5", "label": {"api": {"method Reader.read(CharBuffer)": [[4, 33]]}}}, {"text": "java.sql.Time doesn't include milliseconds", "label": {"api": {"java.sql.Time": [[0, 12]]}}}, {"text": "Try using java.sql.Timestamp instead, as that will include the fractional seconds", "label": {"api": {"java.sql.Time": [[10, 22]], "java.sql.Timestamp": [[10, 27]]}}}, {"text": "As pointed out in the comments, the documentation for TreeItem has an example of lazily-populating the child nodes of the tree item", "label": {"api": {"documentation for TreeItem": [[36, 61]]}}}, {"text": "You're overriding Container#paintComponents(), which was inherited by your JFrame", "label": {"api": {"Container#paintComponents()": [[18, 44]]}}}, {"text": "Instead of extending JFrame, you need to extend JPanel so you can override its paintComponent() and getPreferredSize()", "label": {"api": {"JPanel": [[48, 53]]}}}, {"text": "See also java.util.Formatter for more information", "label": {"api": {"java.util.Formatter": [[9, 27]]}}}, {"text": "Its MapConstraint uses java.lang.Class.cast() to ensure that all the values in the map are legal instances of their corresponding keys", "label": {"api": {"java.lang.Class.cast()": [[23, 44]]}}}, {"text": "Best solution is to fetch the dates, map them to files, and let the fact that TreeMap objects implement SortedMap so they are ordered do the work for you", "label": {"api": {"TreeMap": [[78, 84]], "SortedMap": [[104, 112]]}}}, {"text": "The Runtime.getRuntime().exec(\"python myWebService.py\") call returns a process, that has a destroy() method to kill it", "label": {"api": {"process": [[71, 77]]}}}, {"text": "You should synchronize access to the ArrayList, or replace ArrayList with a concurrent collection like CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[103, 122]]}}}, {"text": "I am using the recent java.time package and in particular the day of week getter of LocalDate", "label": {"api": {"day of week getter": [[62, 79]]}}}, {"text": "I get a nice DayOfWeek enum when calling LocalDate.getDayOfWeek()", "label": {"api": {"DayOfWeek": [[13, 21], [54, 62]]}}}, {"text": "Obviously, in the DayOfWeek enum, SUNDAY value is 7, and in Calendar DAY_OF_WEEK field, SUNDAY value is 1", "label": {"api": {"DayOfWeek": [[18, 26]], "SUNDAY value is 7": [[34, 50]], "SUNDAY value is 1": [[88, 104]]}}}, {"text": "The WeekFields class exists for this purpose (used with LocalDate.get())", "label": {"api": {"WeekFields": [[4, 13]], "LocalDate.get()": [[56, 70]]}}}, {"text": "You can use CountDownLatch to achieve this", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "Read the String API- it has a lot of useful methods", "label": {"api": {"String API": [[9, 18]]}}}, {"text": "What you can do is create a copy of the master and use the List#retainAll method to retain the ordering as it is in the master", "label": {"api": {"List#retainAll": [[59, 72]]}}}, {"text": "Referring to the Javadoc of HashMap", "label": {"api": {"Javadoc of HashMap": [[17, 34]]}}}, {"text": "When you use a layout, invoking pack() \"Causes this Window to be sized to fit the preferred size and layouts of its subcomponents.\" When you don't, you have to try to calculate the bounds yourself", "label": {"api": {"pack()": [[32, 37]]}}}, {"text": "If you look at the BigInteger class in the documentation, then you can see that there is no constructor that accepts an int", "label": {"api": {"the BigInteger class in the documentation": [[15, 55]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html for details on the formatting in printf", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html": [[4, 69]]}}}, {"text": "Is it possible to get the current RAM usage of a java Process that is created with Runtime.getRuntime().exec(...);", "label": {"api": {"Process": [[54, 60]]}}}, {"text": "A Java 8 solution with a stream", "label": {"api": {"stream": [[25, 30]]}}}, {"text": "For the joining method I have a import static java.util.stream.Collectors.joining", "label": {"api": {"stream": [[56, 61]], "import static java.util.stream.Collectors.joining": [[32, 80]]}}}, {"text": "If you are willing to user Jersey Client API, your code could be like", "label": {"api": {"Jersey Client API": [[27, 43]]}}}, {"text": "You can follow any of the following format from SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[48, 63]]}}}, {"text": "I think java.util.LinkedHashMap is the solution for you", "label": {"api": {"java.util.LinkedHashMap": [[8, 30]]}}}, {"text": "See Comparator.compare ..", "label": {"api": {"Comparator.compare": [[4, 21]]}}}, {"text": "You would be better off using String.compareTo in your compare", "label": {"api": {"String.compareTo": [[30, 45]]}}}, {"text": "You can use the ByteBuffer class to create a byte array", "label": {"api": {"ByteBuffer": [[16, 25]]}}}, {"text": "Use time.with(TemporalAdjuster), specifying an instance of DayOfWeek, e.g", "label": {"api": {"time.with(TemporalAdjuster)": [[4, 30]], "DayOfWeek": [[59, 67]]}}}, {"text": "Check the useful StringBuilder class docs for further reference", "label": {"api": {"StringBuilder class docs": [[17, 40]]}}}, {"text": "You could use DoubleSummaryStatistics to hold both results before mapping to FooB", "label": {"api": {"DoubleSummaryStatistics": [[14, 36]]}}}, {"text": "If you're familiar with a z-index in CSS/HTML, a JLayeredPane basically adds a z-index to Swing by allowing you to set the order in which components are rendered", "label": {"api": {"JLayeredPane": [[49, 60]]}}}, {"text": "I would create a SwingWorker", "label": {"api": {"SwingWorker": [[17, 27]]}}}, {"text": "Override stop() in your Application subclass", "label": {"api": {"stop()": [[9, 14]]}}}, {"text": "Implementation of FileReader", "label": {"api": {"FileReader": [[18, 27]]}}}, {"text": "InputStreamReader has to do character encoding conversion from byte stream to char stream, which is slow on a byte-by-byte level, but faster in blocks", "label": {"api": {"InputStreamReader": [[0, 16]]}}}, {"text": "See javadoc of InputStreamReader", "label": {"api": {"InputStreamReader": [[15, 31]]}}}, {"text": "Each invocation of one of an InputStreamReader's read() methods may cause one or more bytes to be read from the underlying byte-input stream", "label": {"api": {"InputStreamReader": [[29, 45]]}}}, {"text": "For top efficiency, consider wrapping an InputStreamReader within a BufferedReader", "label": {"api": {"InputStreamReader": [[41, 57]]}}}, {"text": "I'm not entirely sure what the purpose of your approach is, but maybe you should have a look at BitSet", "label": {"api": {"BitSet": [[96, 101]]}}}, {"text": "You could put your longs into an array, create a BitSet using valueOf and then use a data structure that's actually meant to be used for logical operations", "label": {"api": {"BitSet": [[49, 54]]}}}, {"text": "It should be mentioned, since you stated to have a ordering which is not consistent with equals, that the TreeSet will also not be fully compliant with the Set contract as stated in its documentation", "label": {"api": {"its documentation": [[182, 198]]}}}, {"text": "First, you could try implementing the toString()-method, if it is not already implemented", "label": {"api": {"toString()": [[38, 47]]}}}, {"text": "From https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html It shows CompletableFuture has the following thenX methods", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html": [[5, 89]]}}}, {"text": "Are there any disadvantages (in terms of memory) for using Maps in Java", "label": {"api": {"Maps": [[59, 62]]}}}, {"text": "Because as per my knowledge if you are using HashMaps or any other collections Classes", "label": {"api": {"Maps": [[49, 52]], "HashMaps": [[45, 52]]}}}, {"text": "If you need to transfer from cards to choosenCards you need to use remove(index)", "label": {"api": {"remove(index)": [[67, 79]]}}}, {"text": "If you don't shut it down with executor.shutdown() it'll stay running of course, waiting for tasks that may never come", "label": {"api": {"executor.shutdown()": [[31, 49]]}}}, {"text": "I use Properties#storeToXML to convert java.util.Properties to XML format", "label": {"api": {"Properties#storeToXML": [[6, 26]]}}}, {"text": "The method Properties.storeToXml internally delegates to a loaded XmlPropertiesProvider (from package sun.util.spi)", "label": {"api": {"Properties.storeToXml": [[11, 31]]}}}, {"text": "This properties provider is either loaded by inspecting the system property \"sun.util.spi.XmlPropertiesProvider\" or (if not found) by loading it with the service loader mechanism", "label": {"api": {"service loader mechanism": [[154, 177]]}}}, {"text": "From the Javadoc of RandomAccess", "label": {"api": {"RandomAccess": [[20, 31]]}}}, {"text": "Once connected, the target JVM will launch a new connector server and the JMXServiceURL of that server can be retrieved from the VirtualMachine instance by looking up the agent property com.sun.management.jmxremote.localConnectorAddress", "label": {"api": {"JMXServiceURL": [[74, 86]], "VirtualMachine": [[129, 142]], "agent property": [[171, 184]]}}}, {"text": "While Scanner does provide methods to change its delimiter, I believe that the hasNext(String) and next(String) will be of greater use in this case", "label": {"api": {"hasNext(String)": [[79, 93]], "next(String)": [[99, 110]]}}}, {"text": "And yes, if the input list is RandomAccess, so is the transformed list", "label": {"api": {"RandomAccess": [[30, 41]]}}}, {"text": "BaseStream provides the method onClose which takes a Runnable", "label": {"api": {"onClose": [[31, 37]]}}}, {"text": "That 's why it has a method refresh() on EntityManger in case you want to overwrite the changes from DB values", "label": {"api": {"refresh()": [[28, 36]]}}}, {"text": "You may simply iterate over the keys, with the keys() method of Preferences", "label": {"api": {"keys()": [[47, 52]]}}}, {"text": "For example, you can use LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[25, 43]]}}}, {"text": "Arrays.sort(T[] a, Comparator c) doesn't work with primitive types arrays", "label": {"api": {"Arrays.sort(T[] a, Comparator c)": [[0, 31]]}}}, {"text": "You can use Class#getResource(java.lang.String) to obtain a URL corresponding to the location of the file relative to the classpath of the Java program", "label": {"api": {"Class#getResource(java.lang.String)": [[12, 46]]}}}, {"text": "See Properties documentation", "label": {"api": {"Properties": [[4, 13]]}}}, {"text": "See JTextArea.insert(String,int) which", "label": {"api": {"JTextArea.insert(String,int)": [[4, 31]]}}}, {"text": "Cast the connection to a Http(s)URLConnection, and call getErrorStream() to get the stream in case of error", "label": {"api": {"getErrorStream()": [[56, 71]]}}}, {"text": "The first child is actually a Text object, whose character content is \"\\n \" (or possibly \"\\r\\n \", depending on which platform’s line endings the XML document uses), representing the text between the opening <root> tag and the beginning of the first <node> tag", "label": {"api": {"Text": [[30, 33]]}}}, {"text": "You can parse the JSON string using a JsonReader, and then access the fields you need using a JsonObject", "label": {"api": {"JsonReader": [[38, 47]], "JsonObject": [[94, 103]]}}}, {"text": "This has nothing to do with Camel itself, but with Java's ThreadPoolExecutor in general", "label": {"api": {"ThreadPoolExecutor": [[58, 75]]}}}, {"text": "Try telling Camel to use a SynchronousQueue if you don't want your requests to be queued (not recommended, IMHO)", "label": {"api": {"SynchronousQueue": [[27, 42]]}}}, {"text": "See the javadoc for the JMS API", "label": {"api": {"javadoc for the JMS API": [[8, 30]]}}}, {"text": "Javadoc of getClass() (emphasis is from javadoc)", "label": {"api": {"getClass()": [[11, 20]]}}}, {"text": "Consider to store your variable in Map<String, Object> where the key is the name of your variable", "label": {"api": {"Map<String, Object>": [[35, 53]]}}}, {"text": "Since Java 2, Method extends AccessibleObject, which has the setAccessible(boolean) method", "label": {"api": {"setAccessible(boolean)": [[61, 82]]}}}, {"text": "In the more complex examples cited here, actions provided by EditorKit subclasses operate on the Document model used by text components; listening views update themselves in response", "label": {"api": {"EditorKit": [[61, 69]]}}}, {"text": "As it is also the parent of java.lang.RuntimeException, you can always attempt to catch it, as any piece of code may throw a RuntimeException", "label": {"api": {"java.lang.RuntimeException": [[28, 53]]}}}, {"text": "The example below uses List::contains to identify special dates", "label": {"api": {"List::contains": [[23, 36]]}}}, {"text": "The Timeline class can change any JavaFX property", "label": {"api": {"Timeline": [[4, 11]]}}}, {"text": "Using disjoint() from the standard Java Collections utilities can determine if two collections contain any common members", "label": {"api": {"disjoint()": [[6, 15]]}}}, {"text": "Internally, Collections.disjoint() checks if either collection is a Set and optimizes accordingly", "label": {"api": {"disjoint()": [[24, 33]]}}}, {"text": "Merely examining one cell with getValueAt won’t be sufficient;  instead, you’ll need to translate the sorted row to the corresponding model row, and obtain the data object for that row directly from the TableModel", "label": {"api": {"translate the sorted row to the corresponding model row": [[88, 142]]}}}, {"text": "As the AbstractButton API will tell you (this is the parent class of JButton), it is easy to change the icon of any button by simply calling its setIcon(Icon icon) method and pass in the new Icon", "label": {"api": {"AbstractButton API": [[7, 24]]}}}, {"text": "You can use for example getValue() or doubleValue() method of DoubleBinding", "label": {"api": {"getValue()": [[24, 33]], "doubleValue()": [[38, 50]]}}}, {"text": "For the same reason that fill and rotate and shuffle and swap and infinitely more possible list functions aren't declared in the List interface", "label": {"api": {"fill": [[25, 28]], "rotate": [[34, 39]], "shuffle": [[45, 51]], "swap": [[57, 60]]}}}, {"text": "Therefore, it would be pointless to force every class implementing List to provide a custom implementation of reverse (and fill, rotate, shuffle, swap, etc.)", "label": {"api": {"fill": [[123, 126]], "rotate": [[129, 134]], "shuffle": [[137, 143]], "swap": [[146, 149]]}}}, {"text": "Another approach would be to represent as a List and use the subList method, which returns a view, not a copy", "label": {"api": {"subList": [[61, 67]]}}}, {"text": "Docs for String.replace()", "label": {"api": {"Docs for String.replace()": [[0, 24]]}}}, {"text": "AFAIK Java 8's Optional is somewhat similar to Haskell's Maybe", "label": {"api": {"Optional": [[15, 22]]}}}, {"text": "Since Java's Optional is implemented using if/else, I guess this is the way to do it in Java", "label": {"api": {"Optional": [[13, 20]]}}}, {"text": "For example, Optional's map function is implemented this way", "label": {"api": {"Optional": [[13, 20]]}}}, {"text": "One possible way, and I'm not 100% sure that this is acceptable to do or not, but is to create your own model for the JTabbedPane, a model which implements SingleSelectionModel (check the SingleSelectionModel API), that overrides the setSelectedIndex(int index) method, the method that I'm pretty sure Swing uses when it wants to tell the JTabbedPane to change tabs", "label": {"api": {"SingleSelectionModel API": [[188, 211]]}}}, {"text": "If you create a class that extends from the DefaultSingleSelectionModel, a concrete class that implements the above interface and override this method, you could make method calls before the super's method is called, and thus make GUI calls before the tab changes", "label": {"api": {"DefaultSingleSelectionModel": [[44, 70]]}}}, {"text": "The password can be externalized by overriding the properties when instantiating the EntityManagerFactory", "label": {"api": {"EntityManagerFactory": [[85, 104]]}}}, {"text": "Random.nextInt can return a negative", "label": {"api": {"Random.nextInt": [[0, 13]]}}}, {"text": "Using the -fx-shape property of Region (see CSS Reference) you can create a semicircular shaped Button", "label": {"api": {"CSS Reference": [[44, 56]]}}}, {"text": "You should override findClass(String) instead of loadClass", "label": {"api": {"findClass(String)": [[20, 36]], "loadClass": [[49, 57]]}}}, {"text": "Use flatMap to convert the Stream<List<Variable>> to Stream<Variable> before calling collect", "label": {"api": {"flatMap": [[4, 10]]}}}, {"text": "The method parseInt(String s, int radix) can take a hexadecimal (signed) String and with the proper radix (16) it will parse it  to an Integer", "label": {"api": {"parseInt(String s, int radix)": [[11, 39]]}}}, {"text": "If you just simply want to have a tooltip over a Node (a Button in your case), it is reasonable to use a Tooltip and its graphicProperty rather than showing a different Stage", "label": {"api": {"Tooltip": [[105, 111]], "graphicProperty": [[121, 135]]}}}, {"text": "There is no avalilable method in https://docs.oracle.com/javase/7/docs/api/java/util/Map.html to get Entity from map if there is any key or value available", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Map.html": [[33, 92]]}}}, {"text": "It can work with the objects derived from java.lang.Number, but before to perform the comparison, the compiler \"makes\" an automatic unboxing operation", "label": {"api": {"java.lang.Number": [[42, 57]]}}}, {"text": "If you are using Java 8, then use the Base64 class available in the standard library", "label": {"api": {"Base64": [[38, 43]]}}}, {"text": "If you are not using Java 8, you can use a third-party library, for example Apache Commons Codec, which includes classes for Base64 encoding and decoding", "label": {"api": {"Base64": [[125, 130]]}}}, {"text": "It seems you are in search of a weak reference", "label": {"api": {"weak reference": [[32, 45]]}}}, {"text": "if no other reference to the object exists, the weak reference is lost too", "label": {"api": {"weak reference": [[48, 61]]}}}, {"text": "See Reference too", "label": {"api": {"Reference": [[4, 12]]}}}, {"text": "In this case you should hava a look at @BeanParam", "label": {"api": {"@BeanParam": [[39, 48]]}}}, {"text": "When I'm looking at the Java Object Ordering tutorial, the last section 'Comparators' of the article confused me a little bit", "label": {"api": {"Comparator": [[73, 82]]}}}, {"text": "Then it uses a customized Comparator in which the employees are sorted by the seniority to sort a list of employees and which I could understand", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "Then the tutorial explains why this won't work for a sorted collection such as TreeSet (a SortedSet), and the reason is", "label": {"api": {"TreeSet": [[79, 85]], "SortedSet": [[90, 98]], "Set": [[83, 85], [96, 98]]}}}, {"text": "This means that this Comparator equates objects that the equals method does not", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "When you're sorting a List, this doesn't matter; but when you're using the Comparator to order a sorted collection, it's fatal", "label": {"api": {"Comparator": [[75, 84]]}}}, {"text": "If you use this Comparator to insert multiple employees hired on the same date into a TreeSet, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored", "label": {"api": {"Comparator": [[16, 25]], "TreeSet": [[86, 92]], "Set": [[90, 92]]}}}, {"text": "Now I'm confused, since I know List allows duplicate elements while Set doesn't based on equals method", "label": {"api": {"Set": [[68, 70]]}}}, {"text": "So I wonder when the tutorial says the ordering generated by the Comparator is not compatible with equals, what does it mean", "label": {"api": {"Comparator": [[65, 74]]}}}, {"text": "And it also says 'If you use this Comparator to insert multiple employees hired on the same date into a TreeSet, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.' I don't understand how using a Comparator will affect the use of original equals method", "label": {"api": {"Comparator": [[34, 43], [258, 267]], "TreeSet": [[104, 110]], "Set": [[108, 110]]}}}, {"text": "I think my question is how the TreeSet will be produced and sorted in this case and when the compare and equals methods are used", "label": {"api": {"TreeSet": [[31, 37]], "Set": [[35, 37]]}}}, {"text": "One way to do it is to use HashSet ( https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html )", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html": [[37, 100]]}}}, {"text": "Is there a way I can calculate the min/max hash code possible for a string of a certain length using Java's .hashCode() method", "label": {"api": {".hashCode()": [[108, 118]]}}}, {"text": "Since it adds all the characters to compute the hash, I've tried finding the min/max hash by running .hashCode() on strings of the same length made up of the min/max character values (space = 32,", "label": {"api": {".hashCode()": [[101, 111]]}}}, {"text": "An easy way to do this is implementing the Runnable interface with an anonymous class", "label": {"api": {"Runnable": [[43, 50]]}}}, {"text": "The JavaFX equivalent to a JPanel is a Pane", "label": {"api": {"Pane": [[28, 31], [39, 42]]}}}, {"text": "Can you not use the constructor to initialize JTree with existing model", "label": {"api": {"constructor": [[20, 30]]}}}, {"text": "Note that the java.awt.List is not generic, and that's why you're getting the error", "label": {"api": {"java.awt.List": [[14, 26]]}}}, {"text": "Here firstEvent and secondEvent both contain the same list as Java sublist does not create a new list, but instead returns a  view of the original list", "label": {"api": {"view of the original list": [[126, 150]]}}}, {"text": "In general, if an entity instance is already in your Persistence context, you can find it by primary key with EntityManager.find", "label": {"api": {"EntityManager.find": [[110, 127]]}}}, {"text": "Otherwise, you can pick up a result from your database by way of JPQL or native querying", "label": {"api": {"JPQL": [[65, 68]], "native": [[73, 78]]}}}, {"text": "For your particular use case, it sounds like a querying solution would be the best fit; use one of the linked query creation methods from your entity, then use the Query.getResultList() method to pick up a list of objects that match the query criteria", "label": {"api": {"Query.getResultList()": [[164, 184]]}}}, {"text": "Yes, you can do it by calling tailMap", "label": {"api": {"tailMap": [[30, 36]]}}}, {"text": "For LinkedBlockingQueue, the javadoc specifies that the Iterator returned by iterator() is weakly consistent", "label": {"api": {"weakly consistent": [[91, 107]]}}}, {"text": "On your actual JFrame options in the properties aspect you have to change defaultCloseOperation from EXIT ON CLOSE to DISPOSE_ON_CLOSE", "label": {"api": {"EXIT ON CLOSE": [[101, 113]], "DISPOSE_ON_CLOSE": [[118, 133]]}}}, {"text": "Iterator can take advantage of generics, so you can have an Iterator<Student> that will return a Student instance when invoking next()", "label": {"api": {"Iterator": [[0, 7], [60, 67]], "next()": [[128, 133]]}}}, {"text": "Actually al.iterator() is already returning an Iterator<Student>, you're just erasing its generics by assigning it to a raw Iterator", "label": {"api": {"Iterator": [[47, 54], [124, 131]], "al.iterator()": [[9, 21]]}}}, {"text": "Iterator vs Iterator in java", "label": {"api": {"Iterator": [[0, 7], [12, 19]]}}}, {"text": "You need to set the time zone into fullMonthFormat, since you want the month of New York", "label": {"api": {"time zone": [[20, 28]]}}}, {"text": "Calling acquire(int) will block until specified number of permits are acquired", "label": {"api": {"acquire(int)": [[8, 19]]}}}, {"text": "Calling drainPermits() will acquire any permits that are currently available and return immediately", "label": {"api": {"drainPermits()": [[8, 21]]}}}, {"text": "If you are not using Lambdas, then you can use the Collections#frequency class, get the frequency of the zero element in the list and if the frequency is the same as the list sizes then you clear it..", "label": {"api": {"Collections#frequency": [[51, 71]]}}}, {"text": "Get the field, make it accessible, and assign the value you want", "label": {"api": {"field,": [[8, 13]], "accessible,": [[23, 33]], "assign": [[39, 44]]}}}, {"text": "You can add to it as described in the MimetypesFileTypeMap javadocs", "label": {"api": {"MimetypesFileTypeMap": [[38, 57]]}}}, {"text": "The BigInteger class can do that for you", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "Just use the constructor which takes a String, and then use toByteArray() to convert it", "label": {"api": {"the constructor which takes a String": [[9, 44]], "toByteArray()": [[60, 72]]}}}, {"text": "Register a listener with the toggle group's selectedToggle property", "label": {"api": {"toggle group's selectedToggle property": [[29, 66]]}}}, {"text": "The difference mainly shows up when assigning a \"non-trivial\" Stroke to the graphics object - usually, a certain BasicStroke", "label": {"api": {"BasicStroke": [[113, 123]]}}}, {"text": "It uses a stroke with a witdh of 15 and a join=BasicStroke.JOIN_ROUND", "label": {"api": {"BasicStroke": [[47, 57]]}}}, {"text": "In most cases, this will be a Path2D instance", "label": {"api": {"Path2D": [[30, 35]]}}}, {"text": "I've seen examples where you can use a http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/StreamingOutput.html from a Rest api so that the restful respones can be a Json stream", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/StreamingOutput.html": [[39, 111]]}}}, {"text": "To avoid this keep your list sorted and use binarySearch", "label": {"api": {"binarySearch": [[44, 55]]}}}, {"text": "This is precisely what the groupingBy collector was designed to do", "label": {"api": {"groupingBy": [[27, 36]]}}}, {"text": "If you look at the javadoc of the Pattern class, you will see that there is a character class for ASCII codes", "label": {"api": {"the javadoc of the Pattern class": [[15, 46]]}}}, {"text": "Use ListSelectionEvent.getValueIsAdjusting() to check it isn't (changing)", "label": {"api": {"ListSelectionEvent.getValueIsAdjusting()": [[4, 43]]}}}, {"text": "From the Java API for the File#renameTo() function, emphasis mine", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "Instead, we can use the Files#move() function, which allows us to specify overwrite options", "label": {"api": {"Files#move()": [[24, 35]]}}}, {"text": "You don't need a regex for that, you can simply use String#lastIndexOf", "label": {"api": {"String#lastIndexOf": [[52, 69]]}}}, {"text": "What you are describing is the map method", "label": {"api": {"map": [[31, 33]]}}}, {"text": "map lets you transform the value inside an Optional with a function if the value is present, and only changes the type of the optional if the value in not present", "label": {"api": {"map": [[0, 2]]}}}, {"text": "Note also that you can return null from the mapping function, in which case the result will be Optional.empty()", "label": {"api": {"map": [[44, 46]]}}}, {"text": "The arguments (and the program) are stored in a List<String>, you can get a reference to this list with ProcessBuilder.command(), you can then just add your parameters to this list", "label": {"api": {"ProcessBuilder.command()": [[104, 127]]}}}, {"text": "It is also possible with using indexOf, but this approach gets very messy when duplicates are found in the list", "label": {"api": {"indexOf": [[31, 37]]}}}, {"text": "I am not familiar with the JFreeChart classes and how exactly this kind of plot works, but since the XYSeries#add method seems to accept only a double value as first parameter, you won't be able to pass a Date value", "label": {"api": {"Date": [[205, 208]]}}}, {"text": "There is a possibility to \"interpret\" the timestamp by parsing the corresponding String to a Date object and use its getTime() method", "label": {"api": {"Date": [[93, 96]]}}}, {"text": "for parsing a String to a Date object refer to DateFormat, respectively SimpleDateFormat, and its parse(String s) method", "label": {"api": {"Date": [[26, 29], [47, 50], [78, 81]], "SimpleDateFormat": [[72, 87]]}}}, {"text": "All the code for printf is done in Java", "label": {"api": {"printf": [[17, 22]]}}}, {"text": "Most of the magic happens in the java.util.Formatter class", "label": {"api": {"java.util.Formatter": [[33, 51]]}}}, {"text": "See Formatter#format as well", "label": {"api": {"Formatter#format": [[4, 19]]}}}, {"text": "As an aside, I strongly recommend using the java.time API (e.g", "label": {"api": {"java.time API": [[44, 56]]}}}, {"text": "For example, LocalDate is immutable and has methods such as LocalDate.plusYears(...) that return a reference to a new LocalDate object", "label": {"api": {"LocalDate.plusYears(...)": [[60, 83]]}}}, {"text": "If you only want to listen to events then you should simply implement a custom handler and avoid extending logger", "label": {"api": {"custom handler": [[72, 85]]}}}, {"text": "Use java.lang.reflect.Array.newInstance(Class<?>, int...) (see https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Array.html#newInstance-java.lang.Class-int...-), as in", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Array.html#newInstance-java.lang.Class-int...-": [[63, 168]]}}}, {"text": "Java has a RandomAccess interface to identify List implementations that can be indexed in constant time, which is implemented by ArrayList for example, but not by LinkedList", "label": {"api": {"RandomAccess": [[11, 22]]}}}, {"text": "Next BufferedReader has a method BufferedReader::lines which returns a Stream<String>", "label": {"api": {"BufferedReader::lines": [[33, 53]]}}}, {"text": "If getColumnType(int column) returns Types.DATE (91), then it means you should be calling getDate()", "label": {"api": {"getColumnType(int column)": [[3, 27]], "Types.DATE": [[37, 46]], "getDate()": [[90, 98]]}}}, {"text": "An option is to make your Student class a Comparable<T> implementation", "label": {"api": {"Comparable<T>": [[42, 54]]}}}, {"text": "This way Collections.sort() will use your logic to sort the list", "label": {"api": {"Collections.sort()": [[9, 26]]}}}, {"text": "If your class can't implement Comparable<T>, then you can implement a custom Comparator<T> and use this version of Collections.sort() method", "label": {"api": {"Comparable<T>": [[30, 42]], "Comparator<T>": [[77, 89]], "Collections.sort()": [[115, 132]]}}}, {"text": "JDK 1.7 already contains a MultiValuedMap having a signature like public interface MultivaluedMap<K,V> extends Map<K,List<V>>", "label": {"api": {"MultiValuedMap": [[27, 40]]}}}, {"text": "Simply adds your random numbers in your list as you do then call Collections.shuffle(List) to reorder your List randomly", "label": {"api": {"Collections.shuffle(List)": [[65, 89]]}}}, {"text": "Take a look to SimpleDateFormat documentation", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "There is nothing in the documentation (see Oracle UUID javadoc) which guarentees that", "label": {"api": {"Oracle UUID javadoc": [[43, 61]]}}}, {"text": "Instead of use Arrays.asList(), you should construct the CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[57, 76]]}}}, {"text": "Note that I looked into WeekFields but I can't make it work with ChronoUnit.XXX.between(), so I didn't go too far", "label": {"api": {"WeekFields": [[24, 33]]}}}, {"text": "What you can do is implement a Swing Timer within your program", "label": {"api": {"Swing Timer": [[31, 41]]}}}, {"text": "Well, that’s exactly what you request when specifying Characteristics.CONCURRENT", "label": {"api": {"Characteristics.CONCURRENT": [[54, 79]]}}}, {"text": "As a side note, new HashSet<Characteristics>(Arrays.asList(Characteristics.CONCURRENT, Characteristics.UNORDERED)); is quite inefficient for specifying characteristics", "label": {"api": {"Characteristics.CONCURRENT": [[59, 84]]}}}, {"text": "You can just use EnumSet.of(Characteristics.CONCURRENT, Characteristics.UNORDERED)", "label": {"api": {"Characteristics.CONCURRENT": [[28, 53]]}}}, {"text": "This object can be retrieved with the getController method", "label": {"api": {"getController": [[38, 50]]}}}, {"text": "Base64 is used at several places, and before java.util.Base64 was introduced there were several sources", "label": {"api": {"java.util.Base64": [[45, 60]]}}}, {"text": "Class.forName() gives you the class object, which is useful for reflection", "label": {"api": {"Class.forName()": [[0, 14]]}}}, {"text": "Class.forName() will always use the ClassLoader of the caller, whereas ClassLoader.loadClass() can specify a different ClassLoader", "label": {"api": {"Class.forName()": [[0, 14]]}}}, {"text": "The Object::clone() can be used to create a copy of an existing object", "label": {"api": {"Object::clone()": [[4, 18]]}}}, {"text": "Using Class::newInstance() method", "label": {"api": {"Class::newInstance()": [[6, 25]]}}}, {"text": "Use the Constructor class from the java.lang.reflect package, part of Java Reflection facility", "label": {"api": {"Constructor": [[8, 18]], "java.lang.reflect": [[35, 51]]}}}, {"text": "Use a converter that uses the short version for the conversion and a custom cellFactory to create cells displaying the extended version", "label": {"api": {"converter": [[6, 14]], "cellFactory": [[76, 86]]}}}, {"text": "To bind to scene properties, you want to use Bindings.selectDouble, which can handle the initially null scene property of your button", "label": {"api": {"Bindings.selectDouble": [[45, 65]]}}}, {"text": "Given two instances of Type", "label": {"api": {"Type": [[23, 26]]}}}, {"text": "On your second code you're creating a method called paint() but it isn't Window#paint() but a new one", "label": {"api": {"Window#paint()": [[73, 86]]}}}, {"text": "They have a well defined persistent representation, the SerializedLambda", "label": {"api": {"SerializedLambda": [[56, 71]]}}}, {"text": "When you do that, Scanner closes its underlying stream, i.e", "label": {"api": {"closes its underlying stream": [[26, 53]]}}}, {"text": "Instead of sorting, use max()", "label": {"api": {"max()": [[24, 28]]}}}, {"text": "See the Optional class to see if some other getter would suit your needs, like orElseThrow()", "label": {"api": {"Optional": [[8, 15]]}}}, {"text": "As @Hovercraft suggests, the relevant API is your friend", "label": {"api": {"API": [[38, 40]]}}}, {"text": "A simple implementation is to store userData to a node", "label": {"api": {"userData": [[36, 43]]}}}, {"text": "Retrieve userData from a node", "label": {"api": {"userData": [[9, 16]]}}}, {"text": "Note that java.util.LinkedList is a doubly linked list", "label": {"api": {"java.util.LinkedList": [[10, 29]]}}}, {"text": "DateTimeFormatters can be used for this purpose", "label": {"api": {"DateTimeFormatters": [[0, 17]]}}}, {"text": "For example, if you mostly read and rarely modify your List, you can use the thread safe and efficient list CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[108, 127]]}}}, {"text": "Checked exceptions must be caught within a passed lambda (since the type is Consumer<...>)", "label": {"api": {"Consumer<...>": [[76, 88]]}}}, {"text": "When the bitmap is available as a java.awt.image.BufferedImage you can use the method getRGB(…)", "label": {"api": {"java.awt.image.BufferedImage": [[34, 61]], "getRGB(…)": [[86, 94]]}}}, {"text": "To create a BufferedImage you can use javax.imageio.ImageIO.read(File)", "label": {"api": {"javax.imageio.ImageIO.read(File)": [[38, 69]]}}}, {"text": "The class java.awt.Color can help you interpreting the returned int value", "label": {"api": {"java.awt.Color": [[10, 23]]}}}, {"text": "Pass the value to the constructor taking a single int and use the methods getRed(), getGreen() and getBlue()", "label": {"api": {"constructor taking a single int": [[22, 52]], "getRed()": [[74, 81]], "getGreen()": [[84, 93]], "getBlue()": [[99, 107]]}}}, {"text": "You can also use Formatter", "label": {"api": {"Formatter": [[17, 25]]}}}, {"text": "Anyway you should be using a TreeMap (check NavigableMap interface) instead of a hashmap which checks for close matches", "label": {"api": {"TreeMap": [[29, 35]]}}}, {"text": "In a KeyValue, the first parameter should be a WritableValue, e.g", "label": {"api": {"KeyValue": [[5, 12]]}}}, {"text": "Add a second KeyValue to drive the y coordinate", "label": {"api": {"KeyValue": [[13, 20]]}}}, {"text": "In the first example seen here, three instances of KeyValue move a figure from it's initial position to its destination position, which is size units away along each coordinate axis", "label": {"api": {"KeyValue": [[51, 58]]}}}, {"text": "At the same time, that same Circle moves parallel to the y axis  between 300 and 100 following the curve() defined by the parabola y = –4(x – ½)2 + 1, which has vertex (½, 1) and x intercepts at 0 and 1", "label": {"api": {"curve()": [[99, 105]]}}}, {"text": "This implementation of curve() models a parabolic path on a unit square, as required by the curve() API", "label": {"api": {"curve()": [[23, 29], [92, 98]]}}}, {"text": "What you should do is to make the JFrame a modal JDialog", "label": {"api": {"JDialog": [[49, 55]]}}}, {"text": "Instead of opening a JFrame, you open a JDialog", "label": {"api": {"JDialog": [[40, 46]]}}}, {"text": "Java has a built-in mechanism to handle such a problem - Comparators", "label": {"api": {"Comparator": [[57, 66]]}}}, {"text": "You can use an std::ifstream, and use either get() to read individual chars one by one, or extraction operator >> to read any given type that would be in plain text in the input stream, or read() to read a consecutive number of bytes", "label": {"api": {"read()": [[189, 194]]}}}, {"text": "Note that contrary to the java read()  the c++ read returns the stream", "label": {"api": {"read()": [[31, 36]]}}}, {"text": "The conversion point from java.time to java.sql.Time is java.time.LocalTime using java.sql.Time.valueOf(LocalTime)", "label": {"api": {"java.sql.Time.valueOf(LocalTime)": [[82, 113]]}}}, {"text": "Have you read up on how the Buffer superclass works", "label": {"api": {"Buffer superclass": [[28, 44]]}}}, {"text": "If you were to read the Javadocs for Comparator<T> https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html you would see that it is supposed to return a negative value if the first argument precedes the second, 0 if they are equivalent, and a positive value if the the first argument follows the second", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html": [[51, 117]]}}}, {"text": "DataSource is most commonly used in webapps, where your code needs a database Connection for the duration of the web request processing", "label": {"api": {"DataSource": [[0, 9]]}}}, {"text": "The DataSource is configured for the webapp server, and can then be used by your code to get a new Connection, without your code needing to know the details (e.g", "label": {"api": {"DataSource": [[4, 13]]}}}, {"text": "To summarize, the DataSource has two purposes", "label": {"api": {"DataSource": [[18, 27]]}}}, {"text": "For a small standalone single-threaded application, where the connection is created at startup and just used while the program is running, there is nothing gained by using a DataSource", "label": {"api": {"DataSource": [[174, 183]]}}}, {"text": "Using DriverManager is easier for such programs", "label": {"api": {"DriverManager": [[6, 18]]}}}, {"text": "I'm trying to evaluate javascript in Java by using the ScriptEngine class", "label": {"api": {"ScriptEngine": [[55, 66]]}}}, {"text": "AbstractProcessor provides a method called getSupportedAnnotationTypes which returns the names of the annotation types supported by the processor", "label": {"api": {"AbstractProcessor": [[0, 16]], "getSupportedAnnotationTypes": [[43, 69]]}}}, {"text": "The processor#process method will not be notified when a class is annotated with @Bypass annotation", "label": {"api": {"processor#process": [[4, 20]]}}}, {"text": "So, when using an AbstractProcessor, how to claim for annotations which target is another annotation", "label": {"api": {"AbstractProcessor": [[18, 34]]}}}, {"text": "In Java 8 a new Stream APIs were added", "label": {"api": {"Stream APIs": [[16, 26]]}}}, {"text": "Stream APIs example", "label": {"api": {"Stream APIs": [[0, 10]]}}}, {"text": "Implement the SocketFactory (particularly its SocketFactory.createSocket() method) to create a socket bound to specific local port", "label": {"api": {"SocketFactory": [[14, 26], [46, 58]], "SocketFactory.createSocket() method": [[46, 80]]}}}, {"text": "Use the FTPClient.setSocketFactory (inherited from the SocketClient) to assign your SocketFactory implementation", "label": {"api": {"SocketFactory": [[21, 33], [84, 96]]}}}, {"text": "This is covered by the JavaDoc for Float.toString(float)", "label": {"api": {"Float.toString(float)": [[35, 55]]}}}, {"text": "I'm able to access the Annotation2 from Mock class using an AbstractProcessor, as follows", "label": {"api": {"AbstractProcessor": [[60, 76]]}}}, {"text": "I'm trying to cleanup a mix of various code around datetime management to only Java 8 java.time namespace", "label": {"api": {"java.time": [[86, 94]]}}}, {"text": "Right now I have a small issue with the default DateTimeFormatter for Instant", "label": {"api": {"DateTimeFormatter": [[48, 64]], "Instant": [[70, 76]]}}}, {"text": "The DateTimeFormatter.ISO_INSTANT formatter only shows milliseconds when they are not equal to zero", "label": {"api": {"DateTimeFormatter": [[4, 20]], "DateTimeFormatter.ISO_INSTANT": [[4, 32]]}}}, {"text": "The same can be also achieved by using Java-level instrumentation API, see Instrumentation.retransformClasses", "label": {"api": {"Instrumentation.retransformClasses": [[75, 108]]}}}, {"text": "The key thing that makes it possible for us to configure the command/commands to be invoked on each terminal is the generic Consumer class, which represents the ability to be invoked with an instance of an object of the generically declared type as an argument", "label": {"api": {"Consumer": [[124, 131]]}}}, {"text": "So by passing in a series of Consumer<Terminal> objects which consume a Terminal and invoke a desired method on said Terminals, we can make an  ActionsActivator which invokes a configurable method/methods on the provided terminals", "label": {"api": {"Consumer": [[29, 36]]}}}, {"text": "As that post points out, you should instead be using a Comparator for the Card objects", "label": {"api": {"Comparator": [[55, 64]]}}}, {"text": "Also, instead of using < you can use a new instance of your CardComparator to determine whether or not to swap the cards", "label": {"api": {"Comparator": [[64, 73]]}}}, {"text": "The valueAt method of Bindings creates a binding to in a ObservableMap given the map and the key", "label": {"api": {"valueAt method of Bindings": [[4, 29]]}}}, {"text": "use the LocalDateTime property as value and you can define the cellFactory for the column to display it", "label": {"api": {"cellFactory": [[63, 73]]}}}, {"text": "Alternatively, you can have a DateTimeFormatter to convert the LocalDateTime into a String, but in this case table sorting will not work (will use string ordering)", "label": {"api": {"DateTimeFormatter": [[30, 46]]}}}, {"text": "In this case you can use the setCellValueFactory method of TableColumn to display it as a String on the TableView", "label": {"api": {"setCellValueFactory": [[29, 47]]}}}, {"text": "Parse it with LocalDateTime.parse and convert the result using OffsetDateTime.of", "label": {"api": {"OffsetDateTime.of": [[63, 79]]}}}, {"text": "In Java 8, the Comparator interface has a method thenComparing", "label": {"api": {"thenComparing": [[49, 61]]}}}, {"text": "Here is a link to the Node interface javadoc (which Element extends)", "label": {"api": {"link": [[10, 13]]}}}, {"text": "Each player entity corresponds to exactly one website entity", "label": {"api": {"one": [[42, 44]]}}}, {"text": "If we add the mappedBy option to the Website entity, the OneToOne unidirectional association will be transfornmed into a bidirectional one", "label": {"api": {"one": [[135, 137]]}}}, {"text": "You can consult this link and this one for more information", "label": {"api": {"one": [[35, 37]]}}}, {"text": "I'd like to decorate the interface PreparedStatement, in order to custom close it (just an example)", "label": {"api": {"PreparedStatement": [[35, 51]]}}}, {"text": "This means that I want to decorate an existing instance of PreparedStatement, thus, invoking other code, when close() is being invoked", "label": {"api": {"PreparedStatement": [[59, 75]]}}}, {"text": "For that, I need to default implement all tens of methods of PreparedStatement decorator just to delegate the calls to the inner object, like done here", "label": {"api": {"PreparedStatement": [[61, 77]]}}}, {"text": "Another option is to try and use Java's Proxy and InvocationHandler in order to provide a default implementation that does the delegate for all the methods in a single method", "label": {"api": {"Proxy and InvocationHandler": [[40, 66]], "InvocationHandler": [[50, 66]]}}}, {"text": "If a custom method exists, the InvocationHandler, directs the call to it", "label": {"api": {"InvocationHandler": [[31, 47]]}}}, {"text": "The problem with this solution is that the custom method cannot be marked as @Override and its signature cannot be checked for correctness, as it will require an abstract PreparedStatement, which the Proxy will not be able to instantiate", "label": {"api": {"PreparedStatement": [[171, 187]]}}}, {"text": "When I accept() a connection from a ServerSocketChannel, am I guaranteed that the returned SocketChannel is \"connected\", or could it happen that the returned channel is still performing some form a handshake or whatever and will only later set its SelectionKey.OP_CONNECT bit", "label": {"api": {"accept()": [[7, 14]], "connected": [[109, 117]], "SelectionKey.OP_CONNECT": [[248, 270]]}}}, {"text": "Quoting the Java Documentation for the above sort method, it uses an iterative mergesort algorithm adapted from Tim Peter's list sort for python (TimSort)", "label": {"api": {"Quoting the Java Documentation": [[0, 29]]}}}, {"text": "I love that optionals are in the Java standard library now", "label": {"api": {"optionals": [[12, 20]]}}}, {"text": "I am looking for a general solution which works for different combinations of numbers of optionals and sizes of code blocks", "label": {"api": {"optionals": [[89, 97]]}}}, {"text": "The method java.nio.file.Path.relativize() will throw IllegalArgumentException with some arguments", "label": {"api": {"java.nio.file.Path.relativize()": [[11, 41]]}}}, {"text": "getRoot() returns null if the path has no root component, otherwise / for Linux-like OS's and e.g", "label": {"api": {"getRoot()": [[0, 8]]}}}, {"text": "So, if both Path objects are for the same FileSystem, and both are either relative (getRoot() returns null), or both have the same root component, relativize() should work fine", "label": {"api": {"getRoot()": [[84, 92]], "Path": [[12, 15]], "FileSystem": [[42, 51]]}}}, {"text": "See TreeSet Java doc", "label": {"api": {"TreeSet Java doc": [[4, 19]]}}}, {"text": "I'm looking at Python's built-in exceptions and wondering what the closest equivalent of Java's UnsupportedOperationException is", "label": {"api": {"UnsupportedOperationException": [[96, 124]]}}}, {"text": "I use the java.lang.Boolean.logicalOr(boolean, boolean) method for this purpose", "label": {"api": {"java.lang.Boolean.logicalOr(boolean, boolean)": [[10, 54]]}}}, {"text": "Java 8 added an elegant removeIf method", "label": {"api": {"removeIf": [[24, 31]]}}}, {"text": "For example, the Collections.sort sort operation always sorts in ascending order", "label": {"api": {"Collections.sort": [[17, 32]]}}}, {"text": "You could use Comparator.comparingDouble and Comparator.reversed() for this purpose", "label": {"api": {"Comparator.comparingDouble": [[14, 39]], "Comparator.reversed()": [[45, 65]]}}}, {"text": "You just need to replace the chars at the indices in the original String that contained the char with the char, which can be done using setCharAt", "label": {"api": {"setCharAt": [[136, 144]]}}}, {"text": "Use an object instead, the class Integer in this case", "label": {"api": {"Integer": [[33, 39]]}}}, {"text": "Your public static void main( String[] args ) and field private int theAnswer = 42 are in the same class, because of that fact accessDirectly prints 42 just fine (you have access to field in outer class), but when you are using reflection, you are loading object Class Class Outer where field private int theAnswer = 42 is private (no access to another class private fields)", "label": {"api": {"Class": [[263, 267], [269, 273]]}}}, {"text": "From Java 8 Documentation for Comparable", "label": {"api": {"Comparable": [[30, 39]]}}}, {"text": "According to above, you just have to implement Comparable, and provide an implementation for compareTo for your object", "label": {"api": {"Comparable": [[47, 56]]}}}, {"text": "You can use indexOf with start parameter to start searching form given index, example implementation", "label": {"api": {"indexOf": [[12, 18]]}}}, {"text": "A PauseTransition can be used for this purpose", "label": {"api": {"PauseTransition": [[2, 16]]}}}, {"text": "If you want to overwrite the integer at given position use set(index, data) instead of add", "label": {"api": {"add": [[87, 89]], "set": [[59, 61]]}}}, {"text": "add is for adding data to array, so it won't replace exiting one, from javadocs", "label": {"api": {"add": [[0, 2], [11, 13]]}}}, {"text": "Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices)", "label": {"api": {"add": [[97, 99]]}}}, {"text": "set is for replacing existing data at given index with new data, from javadoc", "label": {"api": {"set": [[0, 2]]}}}, {"text": "You might be able to directly call TransferHandler#exportAsDrag(...) method in MouseMotionListener#mouseDragged(...)", "label": {"api": {"TransferHandler#exportAsDrag(...)": [[35, 67]]}}}, {"text": "The PrintStream method contains a character set name in the constructor", "label": {"api": {"PrintStream": [[4, 14]]}}}, {"text": "In your case the character set name would be US-ASCII", "label": {"api": {"US-ASCII": [[45, 52]]}}}, {"text": "When making use of a BufferedWriter, you could use Files.newBufferedWriter", "label": {"api": {"Files.newBufferedWriter": [[51, 73]]}}}, {"text": "Let's say I'm writing a method that should return a Map", "label": {"api": {"Map": [[52, 54]]}}}, {"text": "After thinking about it for a while, I've decided that there is no reason to modify this Map once it is created", "label": {"api": {"Map": [[89, 91]]}}}, {"text": "Thus, I would like to return an ImmutableMap", "label": {"api": {"Map": [[41, 43]]}}}, {"text": "Should I leave the return type as a generic Map, or should I specify that I'm returning an ImmutableMap", "label": {"api": {"Map": [[44, 46], [100, 102]]}}}, {"text": "I would use a TreeSet (basically a sorted set), where you drop off the first (lowest) element each time you add to the set", "label": {"api": {"TreeSet": [[14, 20]]}}}, {"text": "This problem is usually solved with a heap, but (perhaps counter-intuitively) you use a min-heap (the smallest element is the \"top\" of the heap)", "label": {"api": {"heap,": [[38, 42]]}}}, {"text": "When you are done, you can pop the elements off the heap from least to greatest", "label": {"api": {"pop": [[27, 29]]}}}, {"text": "You can compare the new item to the top of the heap efficiently, and you don't need to keep all of the elements strictly ordered all the time, so this is faster than a completely ordered collection like a TreeSet", "label": {"api": {"top of the heap efficiently,": [[36, 63]]}}}, {"text": "write to a BlockingQueue from your onMessage function, and read it from a separate thread that writes its content to a file", "label": {"api": {"BlockingQueue": [[11, 23]]}}}, {"text": "I suggest you to have a look to ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[32, 58]]}}}, {"text": "Also you can bind disableProperty of the Button to the selectedItemProperty of the selection model of the ListView conditionally", "label": {"api": {"disableProperty": [[18, 32]], "selectedItemProperty": [[55, 74]]}}}, {"text": "From the docs ArrayStoreException it seems like you are storing the wrong type into your array variable", "label": {"api": {"ArrayStoreException": [[14, 32]]}}}, {"text": "If you want to select all of them anyway, but do something special with the first 5, use Elements#subList(fromIndex, toIndex) (inherited from ArrayList)", "label": {"api": {"Elements#subList(fromIndex, toIndex)": [[89, 124]]}}}, {"text": "You can do it using the BadRequestException(Response response)constructor", "label": {"api": {"BadRequestException(Response response)": [[24, 61]]}}}, {"text": "replaceAll() returns a String object which you can store back like follows", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "Take a look on changed method of public interface ChangeListener<T>", "label": {"api": {"changed": [[15, 21]]}}}, {"text": "I think the best way would be to initialize the scheduler factory with a Properties-Object before creating a Scheduler", "label": {"api": {"Properties-Object": [[73, 89]]}}}, {"text": "Why not do the base conversion via Integer.toString(int i, int radix), where radix is just a fancy word for base, then use string manipulation as David Findlay suggests (though I'd probably use String#join and String#split), e.g.", "label": {"api": {"Integer.toString(int i, int radix)": [[35, 68]]}}}, {"text": "JAX-RS' WebApplicationException defines a getResponse() method", "label": {"api": {"WebApplicationException": [[8, 30]], "getResponse()": [[42, 54]], "Response": [[45, 52]]}}}, {"text": "Since Response objects should be closed in general, does that mean I should call getResponse() on WebApplicationException  instances that I would otherwise let fly", "label": {"api": {"WebApplicationException": [[98, 120]], "getResponse()": [[81, 93]], "Response": [[6, 13], [84, 91]], "should be closed": [[23, 38]]}}}, {"text": "Better use HashSet instead, to avoid duplications", "label": {"api": {"HashSet": [[11, 17]]}}}, {"text": "You have to call ResultSet.next() before you are able to access the fields of that ResultSet", "label": {"api": {"ResultSet.next()": [[17, 32]]}}}, {"text": "From the documentation of ResultSet.next()", "label": {"api": {"ResultSet.next()": [[26, 41]]}}}, {"text": "You could save the workbook in the user's temporary directory (see Files.createTemporaryFile()) and only move or copy it after the user has decided to keep it permanently", "label": {"api": {"Files.createTemporaryFile()": [[67, 93]]}}}, {"text": "If they don't want to keep it, you can immediately delete it with File.delete() or when your application exits with File.deleteOnExit()", "label": {"api": {"File.delete()": [[66, 78]], "File.deleteOnExit()": [[116, 134]]}}}, {"text": "Note that on Windows, both File.delete() and File.deleteOnExit() will only work consistently if you make sure that your application closes those files and their associated streams before attempting to delete them", "label": {"api": {"File.delete()": [[27, 39]], "File.deleteOnExit()": [[45, 63]]}}}, {"text": "As ever, consult the Javadoc for String.split(String)", "label": {"api": {"consult the Javadoc for String.split(String)": [[9, 52]]}}}, {"text": "In Java, List is an interface", "label": {"api": {"List": [[9, 12]]}}}, {"text": "Generally, ArrayList is a good starting point", "label": {"api": {"List": [[16, 19]], "ArrayList": [[11, 19]]}}}, {"text": "LinkedList is quite useful too", "label": {"api": {"List": [[6, 9]], "LinkedList": [[0, 9]]}}}, {"text": "You can resolve this by implementing a javax.servlet.http.HttpSessionListener", "label": {"api": {"javax.servlet.http.HttpSessionListener": [[39, 76]]}}}, {"text": "The HttpSessionListener.sessionDestroyed(HttpSessionEvent httpSessionEvent) will be invoked when the session expires", "label": {"api": {"HttpSessionListener.sessionDestroyed(HttpSessionEvent httpSessionEvent)": [[4, 74]]}}}, {"text": "If you annotate your implementation class with @javax.servlet.annotation.WebListener then Tomcat 7 will install and execute it for you as needed", "label": {"api": {"@javax.servlet.annotation.WebListener": [[47, 83]]}}}, {"text": "The opposite of .parallel is .sequential", "label": {"api": {".sequential": [[29, 39]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/util/Base64.Encoder.html#withoutPadding-- I know this is useful to solve my problem but I'm not able to figure out how to use withoutPadding() function in clojure", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Base64.Encoder.html#withoutPadding--": [[0, 87]]}}}, {"text": "TreeMap has a constructor from a SortedMap that retains the same Comparator (and thus, the ordering)", "label": {"api": {"constructor from a SortedMap": [[14, 41]]}}}, {"text": "However, since you're passing your TreeMap as a Map, this constructor is not used - instead, the constructor from a Map is called, and the ordering is lost", "label": {"api": {"constructor from a Map": [[97, 118]]}}}, {"text": "Might I suggest that you take a look at EnumSet", "label": {"api": {"EnumSet": [[40, 46]]}}}, {"text": "Try https://docs.oracle.com/javase/7/docs/api/java/lang/String.html for all references to a string in java and their predefined references", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[4, 66]]}}}, {"text": "You would have to pass the class of T along with it and use Class::isAssignableFrom", "label": {"api": {"Class::isAssignableFrom": [[60, 82]]}}}, {"text": "Do you checked the Process object returned by the startmethod", "label": {"api": {"Process": [[19, 25]]}}}, {"text": "If you look at the documentation for java.util.stream.Stream.map, you'll see that this method returns a new stream", "label": {"api": {"java.util.stream.Stream.map": [[37, 63]]}}}, {"text": "If you just need to modify your original list, since List implements Iterable, you can use java.lang.Iterable.forEach", "label": {"api": {"Iterable": [[69, 76], [101, 108]], "java.lang.Iterable.forEach": [[91, 116]]}}}, {"text": "If you are only interested in the year and the month, the best class would be YearMonth", "label": {"api": {"YearMonth": [[78, 86]]}}}, {"text": "If you do not know the number of tasks beforehand, you could use invokeAll", "label": {"api": {"invokeAll": [[65, 73]]}}}, {"text": "Starting with Java 7 you can use  the FileVisitor to build and filter your internal structure / view model", "label": {"api": {"FileVisitor": [[38, 48]]}}}, {"text": "In the  following simple example a FileVisitor is used to build a view model a view model of some directory", "label": {"api": {"FileVisitor": [[35, 45]]}}}, {"text": "If you don't need rotation then you can always extend the StreamHandler and provide a known file location", "label": {"api": {"StreamHandler": [[58, 70]]}}}, {"text": "If the monitoring tool supports incoming TCP connections then the java.util.logging.SocketHandler would be a way to send all of the log information to the monitoring tool and then you could have the monitoring tool decide where to store or send the log data", "label": {"api": {"java.util.logging.SocketHandler": [[66, 96]]}}}, {"text": "The API you're looking for is ProxySelector", "label": {"api": {"ProxySelector": [[30, 42]]}}}, {"text": "So I had to create a ProxySelector implementing the logic when the proxy should be applied or not", "label": {"api": {"ProxySelector": [[21, 33]]}}}, {"text": "Text 'Jun 4 2015' could not be parsed at index 0 even though I am fairly certain that my regular expression is correct", "label": {"api": {"is correct": [[108, 117]]}}}, {"text": "The swing.Timer is a simplified class that was customized for use with GUIs", "label": {"api": {"swing.Timer": [[4, 14]]}}}, {"text": "The util.Timer has by default a non-daemon thread and has the flexibility to be created otherwise", "label": {"api": {"util.Timer": [[4, 13]], "created otherwise": [[80, 96]]}}}, {"text": "Scanner#next() reads up to the first whitespace", "label": {"api": {"Scanner#next()": [[0, 13]]}}}, {"text": "If you want to read up to the end of the line, you should use nextLine() instead", "label": {"api": {"nextLine()": [[62, 71]]}}}, {"text": "The best solution for what you are looking for is the SubScene, a built-in JavaFX container", "label": {"api": {"container": [[82, 90]]}}}, {"text": "The SubScene class is the container for content in a scene graph", "label": {"api": {"container": [[26, 34]]}}}, {"text": "You could use List#contains for a linear search", "label": {"api": {"List#contains": [[14, 26]]}}}, {"text": "See Pad modifier in DateTimeFormatter for more details", "label": {"api": {"DateTimeFormatter": [[20, 36]]}}}, {"text": "As long as there is at least one reference pointing to your object it will not get garbage collected - if the reference is not a weak reference or something similiar", "label": {"api": {"weak reference": [[129, 142]]}}}, {"text": "GridPane doesn't have a own style class (see CSS reference), but similarly to tag selectors in HTML, Nodes can be selected by their java classes", "label": {"api": {"CSS reference": [[45, 57]]}}}, {"text": "Furthermore is is possible to add style classes from FXML since styleClass is a Read-Only List Property", "label": {"api": {"styleClass": [[64, 73]], "Read-Only List Property": [[80, 102]]}}}, {"text": "One solution would be using Matcher#groupCount", "label": {"api": {"Matcher#groupCount": [[28, 45]]}}}, {"text": "so calling input.nextLine(); Advances this scanner past the current line and returns the input that was skipped", "label": {"api": {"nextLine()": [[17, 26]]}}}, {"text": "Check the documentation for nextLine() method for a detailed explanation", "label": {"api": {"nextLine()": [[28, 37]]}}}, {"text": "Java Map is a good fit since it allows you to have key-value pairs (i.e", "label": {"api": {"Map": [[5, 7]]}}}, {"text": "It also allows you to quickly check if a given key exists, method containsKey(), or if a given value, method conatinsValue(), exists in the Map", "label": {"api": {"Map": [[140, 142]]}}}, {"text": "You could just use Java's InetAddress class", "label": {"api": {"Java's InetAddress": [[19, 36]]}}}, {"text": "You can use Pattern.splitAsStream(CharSequence) use a ByteArrayOutputStream in a collector", "label": {"api": {"Pattern.splitAsStream(CharSequence)": [[12, 46]]}}}, {"text": "If the PDF is a file on your filesystem, you can open it using the default PDF viewer with Desktop.open()", "label": {"api": {"Desktop.open()": [[91, 104]]}}}, {"text": "Take a look at Objects.requireNonNull for your required functionality", "label": {"api": {"Objects.requireNonNull": [[15, 36]]}}}, {"text": "If the code contained is a valid java code (including imports, full class def etc), then you can use java compiler API", "label": {"api": {"java compiler API": [[101, 117]]}}}, {"text": "Once you compile it, running it is easy, since you can either invoke java process with the generated class or load the generated class dynamically, and run the method using reflection", "label": {"api": {"invoke java process": [[62, 80]]}}}, {"text": "As per java documentation https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[26, 91]]}}}, {"text": "Use the method getAttributes to get the list of attributes of a node", "label": {"api": {"getAttributes": [[15, 27]]}}}, {"text": "I knew I could get the \"return value\" of a thread using Future and Callable in this fashion and I also knew how to schedule threads", "label": {"api": {"schedule threads": [[115, 130]]}}}, {"text": "Actually, you can avoid the loop altogether by using the String.split() method with the limit parameter set to 2", "label": {"api": {"String.split() method with the limit parameter": [[57, 102]]}}}, {"text": "when building up a string by concatenations in a loop, it's usually a good idea to use a StringBuilder, to avoid performance penalty", "label": {"api": {"StringBuilder": [[89, 101]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/lang/String.html this is Java doc URL", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[0, 62]]}}}, {"text": "Looking at the documentation of Font#loadFont I came across this remark", "label": {"api": {"Font#loadFont": [[32, 44]]}}}, {"text": "Here's the Java-Doc for Pattern", "label": {"api": {"Java-Doc": [[11, 18]]}}}, {"text": "You can see it in the Java-Doc for TreeMap", "label": {"api": {"Java-Doc": [[22, 29]]}}}, {"text": "A CyclicBarrier does what you want", "label": {"api": {"CyclicBarrier": [[2, 14]]}}}, {"text": "This is code for a Tooltip with an Image", "label": {"api": {"Tooltip": [[19, 25]]}}}, {"text": "Though, in looking at your image mockup, the highlighted areas don't really look like a Tooltip at all", "label": {"api": {"Tooltip": [[88, 94]]}}}, {"text": "Or you can just create a clickable ImageView", "label": {"api": {"ImageView": [[35, 43]]}}}, {"text": "According to http://docs.oracle.com/javase/tutorial/deployment/jar/packageman.html and http://docs.oracle.com/javase/8/docs/api/java/lang/Package.html#getImplementationVersion-- (and other sources), it should return \"19\", but it returns null", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/Package.html#getImplementationVersion--": [[87, 176]]}}}, {"text": "For integer, have a look at LongAdder", "label": {"api": {"LongAdder": [[28, 36]]}}}, {"text": "Conversion from integer to alphanumeric would be the usual divide&remainder (using the bases as kept) - with a catch", "label": {"api": {"divide&remainder": [[59, 74]]}}}, {"text": "You can create a stroked version of this shape, using a BasicStroke with the desired thickness and cap/join characteristics, by calling BasicStroke#createStrokedShape", "label": {"api": {"BasicStroke#createStrokedShape": [[136, 165]]}}}, {"text": "If you simply want to execute a Python subprocess just call", "label": {"api": {"exec": [[22, 25]]}}}, {"text": "Note that it's also safer to use the overload of exec that takes an array, so you don't have to do string-concatenation yourself (and therefore avoid a type of security exploit)", "label": {"api": {"exec": [[49, 52]]}}}, {"text": "Or with ProcessBuilder", "label": {"api": {"ProcessBuilder": [[8, 21]]}}}, {"text": "A Java agent can add jar files simply via the Instrumentation interface it received in the startup method, e.g", "label": {"api": {"Instrumentation": [[46, 60]]}}}, {"text": "If you intent to instrument JRE classes as well in a way that the instrumented classes need access to the classes of Code.jar, you’ll have to change the bootstrap path instead", "label": {"api": {"change the bootstrap path": [[142, 166]]}}}, {"text": "You can listen to the changes of the widthProperty and the heightProperty of the Stage", "label": {"api": {"widthProperty": [[37, 49]], "heightProperty": [[59, 72]]}}}, {"text": "You can use getSubImage(int x, int y, int w, int h), but you will get an image that shares the same raster than the original image, meaning that if you modify the new sub-image, then you also modify the original image", "label": {"api": {"getSubImage(int x, int y, int w, int h)": [[12, 50]]}}}, {"text": "You might be able to use PropertyChangeListener and JInternalFrame#IS_MAXIMUM_PROPERTY", "label": {"api": {"PropertyChangeListener": [[25, 46]], "JInternalFrame#IS_MAXIMUM_PROPERTY": [[52, 85]]}}}, {"text": "Next the Stream API offers Stream::iterate which is the right tool for your problem", "label": {"api": {"Stream::iterate": [[27, 41]]}}}, {"text": "ImageView is not a subclass of Shape hence it does not have a eg a stroke attribute - refer to http://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html to see what attributes you can set on ImageView", "label": {"api": {"http://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html": [[95, 164]]}}}, {"text": "The fullScreenExitKey property of the Stage can be set to KeyCombination.NO_MATCH", "label": {"api": {"fullScreenExitKey property of the Stage": [[4, 42]], "KeyCombination.NO_MATCH": [[58, 80]]}}}, {"text": "In Java use ProcessBuilder to create a child process and capture its standard output", "label": {"api": {"ProcessBuilder": [[12, 25]]}}}, {"text": "Check out the JLabel.setIcon() method", "label": {"api": {"JLabel.setIcon()": [[14, 29]]}}}, {"text": "You can use ProcessBuilder (see https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) and set the working directory using directory(...) instead of cd command", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html": [[32, 102]]}}}, {"text": "There is no equivalent to collect in Ruby", "label": {"api": {"collect": [[26, 32]]}}}, {"text": "Java's collect is a generalization of folding, Ruby has two folding operations", "label": {"api": {"collect": [[7, 13]], "Java's collect is a generalization of folding": [[0, 44]]}}}, {"text": "inject and each_with_object, both of which are special cases of Java's collect", "label": {"api": {"collect": [[71, 77]]}}}, {"text": "However, if you want the full generality of collect available in Ruby, you will have to implement it yourself", "label": {"api": {"collect": [[44, 50]]}}}, {"text": "A Java Thread is a high level wrapper that abstracts some of the functionality of a system thread; these kinds of threads are also known as managed threads", "label": {"api": {"Thread": [[7, 12]]}}}, {"text": "There's some management information (stack, instruction pointers, thread id, etc.) that the kernel keeps track of, but there is no such thing at the kernel level as a thread that is in a TIMED_WAITING state (the .NET equivalent to the WaitSleepJoin state)", "label": {"api": {"TIMED_WAITING": [[187, 199]]}}}, {"text": "Take a careful look at which methods are available on a plain java.lang.Thread at https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html": [[82, 144]]}}}, {"text": "Add the check boxes to a ButtonGroup", "label": {"api": {"ButtonGroup": [[25, 35]]}}}, {"text": "Creating a set of buttons with the same ButtonGroup object means that turning \"on\" one of those buttons turns off all other buttons in the group", "label": {"api": {"ButtonGroup": [[40, 50]]}}}, {"text": "A BigInteger is a class that hold integer with arbitrary precision", "label": {"api": {"BigInteger": [[2, 11]]}}}, {"text": "A BigInteger work for any integer number", "label": {"api": {"BigInteger": [[2, 11]]}}}, {"text": "HashMap is not threadsafe, see the API documentation", "label": {"api": {"the API documentation": [[31, 51]]}}}, {"text": "Use a ConcurrentHashMap instead, updates don't lock the whole data structure the way the above code with the synchronizedMap will", "label": {"api": {"ConcurrentHashMap": [[6, 22]]}}}, {"text": "You can pass the operation to the constructor as an IntBinaryOperator, for example", "label": {"api": {"an IntBinaryOperator": [[49, 68]]}}}, {"text": "The fxml can be rewritten using fx:include and nested controllers", "label": {"api": {"fx:include": [[32, 41]]}}}, {"text": "Specifically, XMLStreamReader.next() will throw a XMLStreamException for any well-formedness errors encountered in the XML being parsed", "label": {"api": {"XMLStreamReader.next()": [[14, 35]], "XMLStreamException": [[50, 67]]}}}, {"text": "If parsing progresses to where XMLStreamReader.hasNext() returns false and terminates your while loop without having triggered any XMLStreamExceptions, you can be sure that the XML is well-formed", "label": {"api": {"XMLStreamException": [[131, 148]], "XMLStreamReader.hasNext()": [[31, 55]]}}}, {"text": "Also you can use SortedList with appropriate comparator to wrap your original backing list", "label": {"api": {"SortedList": [[17, 26]]}}}, {"text": "On the Java side, it will be influenced by Calendar#setFirstDayOfWeek and Calendar#setMinimalDaysInFirstWeek (possibly others, check the Calendar docs)", "label": {"api": {"Calendar#setFirstDayOfWeek": [[43, 68]], "Calendar#setMinimalDaysInFirstWeek": [[74, 107]]}}}, {"text": "A collection of WeakReferences (https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html) might solve your problem", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html": [[32, 105]]}}}, {"text": "Maybe you can work with WeakReferences, for instance a WeakHashMap", "label": {"api": {"WeakReferences": [[24, 37]], "WeakHashMap": [[55, 65]]}}}, {"text": "I guess you should be using read(byte[]) and detect the end of the message somehow", "label": {"api": {"read(byte[])": [[28, 39]]}}}, {"text": "I'm looking to use PathIterator on an area within MATLAB in order to store the vertices in an array, and the returned int seems to be correct, but I cannot seem to get the coordinates to return correctly (the field coords in the online documentation)", "label": {"api": {"the field coords in the online documentation": [[205, 248]]}}}, {"text": "You could use HttpServletRequest which has a method called getRequestURL() to retrieve the actual URL, allowing you to parse which path was used", "label": {"api": {"HttpServletRequest": [[14, 31]]}}}, {"text": "In Java 8, the Comparator class has this really nifty static method that composes a Function to a Comparator by using the the result of the Function as the input for the Comparator", "label": {"api": {"really nifty static method": [[41, 66]]}}}, {"text": "I'm aware of Function#andThen(Function), but that is only useful for combining functions with other functions, and sadly, Predicate doesn't extend Function<T, Boolean>", "label": {"api": {"Function#andThen(Function)": [[13, 38]]}}}, {"text": "It is deleting a file that was marked for deletion on JVM termination with File.deleteOnExit", "label": {"api": {"File.deleteOnExit": [[75, 91]]}}}, {"text": "The Duration time parameter of the KeyFrame constructor takes time relative to the start of the animation, not relative to the last KeyFrame", "label": {"api": {"Duration time parameter": [[4, 26]], "KeyFrame constructor": [[35, 54]]}}}, {"text": "Javadoc of split(String regex) says", "label": {"api": {"split(String regex)": [[11, 29]], "split": [[11, 15]]}}}, {"text": "This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero", "label": {"api": {"split": [[53, 57]]}}}, {"text": "So, \",\".split(\",\") will return an empty array, i.e", "label": {"api": {"split": [[8, 12]]}}}, {"text": "If you want to keep trailing empty strings, use \",\".split(\",\", -1), which will return new String[] { \"\", \"\" }", "label": {"api": {"split": [[52, 56]]}}}, {"text": "This is not necessarily a bug in the JDK as such, since the API for SecretKey explicitly leaves it up to the implementing classes to define this behavior, though it does seem a little odd that this behavior is not overridden", "label": {"api": {"SecretKey": [[68, 76]]}}}, {"text": "If you are using java 8, you can try DateTimeFormatter with a pattern of \"EEE MMM d HH:mm:ss O yyyy\" likes", "label": {"api": {"DateTimeFormatter": [[37, 53]]}}}, {"text": "You can see Offset O in DateTimeFormatter for more details", "label": {"api": {"DateTimeFormatter": [[24, 40]]}}}, {"text": "Because your display centers on the description, use the JTextArea constructor that lets you specify a size in rows and columns", "label": {"api": {"JTextArea": [[57, 65]]}}}, {"text": "Use a RandomAccessFile if you need to read, say, the middle part of the file, or at a specific location you know", "label": {"api": {"RandomAccessFile": [[6, 21]]}}}, {"text": "Actually, a RandomAccessFile contains most of the functions that you may want to use from ByteBuffer, like writeShort, readShort, etc", "label": {"api": {"RandomAccessFile": [[12, 27]]}}}, {"text": "Checkout out the javax.print package and Lesson", "label": {"api": {"javax.print": [[17, 27]]}}}, {"text": "You can use getExceptionTypes() method", "label": {"api": {"getExceptionTypes()": [[12, 30]]}}}, {"text": "See this page", "label": {"api": {"this page": [[4, 12]]}}}, {"text": "Use BigInteger, but take note that it will be much slower, but with infinite size", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "Define your processor so that it supports all annotations by using \"*\" as its supported annotation type", "label": {"api": {"supports all annotations": [[33, 56]], "annotations": [[46, 56]]}}}, {"text": "Use getRootElements to get the entire set of elements every round", "label": {"api": {"getRootElements": [[4, 18]]}}}, {"text": "Create an ElementScanner8 to traverse any element that you find to look for ExecutableElements", "label": {"api": {"ElementScanner8": [[10, 24]]}}}, {"text": "There's no easy way to get methods that a given method has overridden, so you need to get the enclosing element of the method, look at its superclass and implemented interfaces (recursively), get their enclosed elements, filter out the methods, and test to see if it has been overridden by the method in question", "label": {"api": {"enclosing element": [[94, 110]], "superclass": [[139, 148]], "implemented interfaces": [[154, 175]], "enclosed elements": [[202, 218]], "filter out the methods": [[221, 242]], "test to see if it has been overridden": [[249, 285]]}}}, {"text": "If it has, you can check the annotations to see if it has one you care about", "label": {"api": {"annotations": [[29, 39]]}}}, {"text": "As noted here and here, getGraphics() is not how to perform custom painting in Swing", "label": {"api": {"getGraphics()": [[24, 36]]}}}, {"text": "Create the new array and copy the values using System.arraycopy()", "label": {"api": {"System.arraycopy()": [[47, 64]]}}}, {"text": "Use a mutable class, such as an array of a single int, or AtomicInteger", "label": {"api": {"AtomicInteger": [[58, 70]]}}}, {"text": "If you look at the documentation of Integer.parseInt it is specified this", "label": {"api": {"Integer.parseInt": [[36, 51]]}}}, {"text": "Instead, the InputMismatchException documentation specify this", "label": {"api": {"InputMismatchException": [[13, 34]]}}}, {"text": "This means you should catch NumberFormatException instead of InputMismatchException", "label": {"api": {"InputMismatchException": [[61, 82]]}}}, {"text": "I use ThreadLocalRandom as it is more straightforward as supported by this answer", "label": {"api": {"ThreadLocalRandom": [[6, 22]]}}}, {"text": "If you are not using Java 1.7+, use Random#nextInt(int) instead as also shown by that answer", "label": {"api": {"Random#nextInt(int)": [[36, 54]]}}}, {"text": "I have used the RowConstraints class", "label": {"api": {"RowConstraints": [[16, 29]]}}}, {"text": "I have added three RowConstraints for the GridPane and then on button press the maxHeightProperty of the first two constraints is set to 0 (hide) or 30 (show)", "label": {"api": {"RowConstraints": [[19, 32]], "maxHeightProperty": [[80, 96]]}}}, {"text": "Node has a -fx-scale-x, -fx-scale-y and an -fx-scale-z CSS property, which have the default value of 1", "label": {"api": {"Node": [[0, 3]]}}}, {"text": "Node is the superclass of Button therefore these properties are inherited", "label": {"api": {"Node": [[0, 3]]}}}, {"text": "I'm trying to use DateTimeFormatter in my project, but Android Studio can't find java.time.format.DateTimeFormatter package", "label": {"api": {"DateTimeFormatter": [[18, 34], [98, 114]]}}}, {"text": "If you want to represent \"now\" in your default time zone, use ZonedDateTime.now() instead", "label": {"api": {"ZonedDateTime.now()": [[62, 80]]}}}, {"text": "Given this, you should use LocalDate from the standard API, java.time", "label": {"api": {"LocalDate": [[27, 35]]}}}, {"text": "Your Deployment class can look just like it does now, just make sure to import the correct package (java.time.LocalDate)", "label": {"api": {"LocalDate": [[110, 118]]}}}, {"text": "Since you have access to the fields (year, month and day), you can use one of the of() methods in the API", "label": {"api": {"of()": [[82, 85]]}}}, {"text": "If you are using Java 8, use the new date and time API (package java.time); use for example LocalDate if you need to store a year/month/day, or a LocalTime if you need to store just a time-of-day (hours, minutes, seconds, milliseconds)", "label": {"api": {"LocalDate": [[92, 100]], "LocalTime": [[146, 154]]}}}, {"text": "control key, is pressed in java DropTargetDropEvent of dropping an OS file", "label": {"api": {"DropTargetDropEvent": [[32, 50]]}}}, {"text": "I also tried to use getDropAction of DropTargetDropEvent to detect control key", "label": {"api": {"DropTargetDropEvent": [[37, 55]], "getDropAction of DropTargetDropEvent": [[20, 55]]}}}, {"text": "If you had asked about a certain byte position, the answer would be java.io.RandomAccessFile", "label": {"api": {"java.io.RandomAccessFile": [[68, 91]]}}}, {"text": "In any case, you can refer to the JavaFX 8 default stylesheet (modena.css) and the JavaFX CSS Reference Guide", "label": {"api": {"JavaFX CSS Reference Guide": [[83, 108]]}}}, {"text": "Check the Javadoc of Comparator's compare method", "label": {"api": {"compare": [[34, 40]]}}}, {"text": "And by the way, the first implementation really shoud use Integer.compare()", "label": {"api": {"Integer.compare()": [[58, 74]]}}}, {"text": "An alternative would be using a List, which allows you to remove elements", "label": {"api": {"List": [[32, 35]]}}}, {"text": "Alternatively a Map<String, Integer> mapping from a word to the count could be used", "label": {"api": {"Map<String, Integer>": [[16, 35]]}}}, {"text": "You can for example listen to the selectedProperty   of CheckBoxTreeItem by adding a listener when you create the nodes of the tree", "label": {"api": {"selectedProperty": [[34, 49]]}}}, {"text": "The Files.walk doesn't appear to be protectable for symbolic link recursion", "label": {"api": {"Files.walk": [[4, 13]]}}}, {"text": "If you need a more robust method than arbitrarily limiting the depth you can implement a FileVisitor  which when it encounters a symbolic link does some checking to see if it is recursive and then decide if you want to follow it or not", "label": {"api": {"FileVisitor": [[89, 99]]}}}, {"text": "Then use the visitor with Files.walkFileTree", "label": {"api": {"Files.walk": [[26, 35]], "Files.walkFileTree": [[26, 43]]}}}, {"text": "As for detecting the symbolic links that are recursive I think you can do some sorcery with File.getCanonicalPath and a hash map of visited canonical paths", "label": {"api": {"File.getCanonicalPath": [[92, 112]]}}}, {"text": "I have implemented a queue that stores elements similar to a BlockingQueue", "label": {"api": {"BlockingQueue": [[61, 73]]}}}, {"text": "On retrieval, the consumer may specify a Predicate that is tested against the queue elements", "label": {"api": {"Predicate": [[41, 49]]}}}, {"text": "But how can I \"connect\" this queue to a pool of workers (preferably a ThreadPoolExecutor with dynamic thread management) which retrieve elements from this queue and do some work", "label": {"api": {"ThreadPoolExecutor": [[70, 87]]}}}, {"text": "The queue implementation is basically like the example in Condition, except that it's unbounded and not backed by an array, but a LinkedHashSet which doesn't allow duplicates and maintains insertion order", "label": {"api": {"Condition": [[58, 66]], "LinkedHashSet": [[130, 142]]}}}, {"text": "But you want to have the same exception for both cases and decide whether to throw 404 for GET/PathParam and POST/FormParam, you can inject the request into the mapper and check what method it is", "label": {"api": {"request": [[144, 150]]}}}, {"text": "If you want to decide by PathParams, you can inject UriInfo", "label": {"api": {"UriInfo": [[52, 58]]}}}, {"text": "JOptionPane has a method designed to create a relevant JDialog instance, so better try that", "label": {"api": {"method": [[18, 23]]}}}, {"text": "The way to use PreparedStatement with an unknown number of parameters is the way shown in this question, and there's no way to get around such iteration on the Java/application side", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "I have been looking for a \"varargs\" kind of method & syntax to feed into the PreparedStatement the variable number of arguments, say on a collection, and plug this as a single variable-placeholder into the query", "label": {"api": {"PreparedStatement": [[77, 93]]}}}, {"text": "I suggest that you use a hash set instead of a tree set", "label": {"api": {"hash set": [[25, 32]]}}}, {"text": "In order to achieve this behaviour you can either use classes that implement the lock interface, create an object and use that as a lock like so", "label": {"api": {"lock interface": [[81, 94]]}}}, {"text": "A Stage can be closed any time by calling its close method", "label": {"api": {"Stage": [[2, 6]]}}}, {"text": "More to the point however, InputStream is designed to read binary data, not characters, and binary data is (essentially) always read one byte at a time", "label": {"api": {"InputStream": [[27, 37]]}}}, {"text": "If you want to read text you wrap your stream in a Reader (preferably explicitly specifying the encoding to be used) to convert the binary data into text", "label": {"api": {"Reader": [[51, 56]]}}}, {"text": "The java.util.Objects utility class introduced in JDK 7 has a neat null-safe equals(Object, Object) method you could use", "label": {"api": {"java.util.Objects": [[4, 20]], "equals(Object, Object)": [[77, 98]]}}}, {"text": "LogManager.readConfiguration requires LoggingPermission(\"control\") when running under the security manager", "label": {"api": {"LogManager.readConfiguration": [[0, 27]]}}}, {"text": "The argument of Class.forName() must be a fully qualified class name, so in your case I think it should be", "label": {"api": {"fully qualified class name": [[42, 67]]}}}, {"text": "However you can use DateTimeFormatter class to construct the dates as per the required pattern", "label": {"api": {"DateTimeFormatter": [[20, 36]]}}}, {"text": "Why don't you use JsonObjectBuilder", "label": {"api": {"JsonObjectBuilder": [[18, 34]]}}}, {"text": "Because according to Java specifications the time/temporal/TemporalField was introduced in version 8, below this version it will not work", "label": {"api": {"Java specifications": [[21, 39]]}}}, {"text": "I know there is this method but the documentation says that the file will be converted to the target format", "label": {"api": {"this method": [[16, 26]]}}}, {"text": "There is AtomicInteger API in Java SE", "label": {"api": {"AtomicInteger": [[9, 21]]}}}, {"text": "The base year can be controlled using DateTimeFormatterBuilder.appendValueReduced()", "label": {"api": {"DateTimeFormatterBuilder.appendValueReduced()": [[38, 82]]}}}, {"text": "A list of available DateTimeFormatters is available in the API docs", "label": {"api": {"API docs": [[59, 66]]}}}, {"text": "You can use LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[12, 30]]}}}, {"text": "You can use setSoTimeout(1000) to make the call to accept() time out after 1 second (by throwing a java.net.SocketTimeoutException) if nothing connects", "label": {"api": {"setSoTimeout(1000)": [[12, 29]]}}}, {"text": "In order to expose a custom object as a JMX attribute, or the return value or an operation, it must be defined as an OpenType", "label": {"api": {"OpenType": [[117, 124]]}}}, {"text": "The usual way of doing this is to define an MXBean", "label": {"api": {"MXBean": [[44, 49]]}}}, {"text": "System.arraycopy() is probably the most efficient method", "label": {"api": {"System.arraycopy()": [[0, 17]]}}}, {"text": "When you want to capture multiple words that end with a newline, you should use Scanner.nextLine() instead", "label": {"api": {"Scanner.nextLine()": [[80, 97]]}}}, {"text": "To achieve this, you can use for example a StringConverter", "label": {"api": {"StringConverter": [[43, 57]]}}}, {"text": "You clear the ObservableList stored in the dataProperty of the Series", "label": {"api": {"dataProperty": [[43, 54]]}}}, {"text": "The problem is you don't clear seriesList before adding the elements, so it contains the elements on the second click twice, which will result in an IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[149, 172]]}}}, {"text": "You can use stream for that (skip first 2 elements)", "label": {"api": {"skip": [[29, 32]]}}}, {"text": "Or use subList", "label": {"api": {"subList": [[7, 13]]}}}, {"text": "This is as per API in latest Java 8 at the time of writing", "label": {"api": {"API": [[15, 17]]}}}, {"text": "Spring uses ThreadLocal to store the applicationContext but ExecutorService creates a different Thread where no beans are managed and/or the beanContext does not find any beans", "label": {"api": {"ThreadLocal": [[12, 22]]}}}, {"text": "ConcurrentHashMap avoids locking threads out of the entire map, and supports concurrent updates, see the API doc (my emphasis)", "label": {"api": {"the API doc": [[101, 111]]}}}, {"text": "You have to use only methods of https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html": [[32, 93]]}}}, {"text": "You could use, for example, https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html": [[28, 89]], "https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--": [[28, 103]]}}}, {"text": "TreeMap is your friend", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "Executing a second query on the PreparedStatement implicitly closes the ResultSet from the previous query", "label": {"api": {"Statement": [[40, 48]]}}}, {"text": "By default, only one ResultSet object per Statement object can be open at the same time", "label": {"api": {"Statement": [[42, 50]]}}}, {"text": "Don't use Statement's executeQuery(String) on PreparedStatement", "label": {"api": {"Statement": [[10, 18], [54, 62]]}}}, {"text": "In fact, the documentation for Statement#executeQuery says", "label": {"api": {"Statement": [[31, 39]], "Statement#executeQuery": [[31, 52]]}}}, {"text": "Note:This method cannot be called on a PreparedStatement or CallableStatement", "label": {"api": {"Statement": [[47, 55], [68, 76]]}}}, {"text": "You get the UnsupportedOperationException, because Parent#getChildrenUnmodifiable returns a read-only list", "label": {"api": {"UnsupportedOperationException": [[12, 40]], "Parent#getChildrenUnmodifiable": [[51, 80]]}}}, {"text": "Or, if you want to be a little bit more generic, you can cast the returned parent to a Pane after type check, as this class is the super class of JavaFX containers which allows modification on the children list", "label": {"api": {"Pane": [[87, 90]]}}}, {"text": "Granted this only accounts for a few common uppercase character classes (and could be inefficient depending upon context) - you would need to consult the the API if the regular expressions are complex and you need to account for all possible uppercase regular expression values", "label": {"api": {"API": [[158, 160]]}}}, {"text": "Calling Thread.currentThread().getStackTrace() can get you  the StackTraceElement of the current thread", "label": {"api": {"Thread.currentThread().getStackTrace()": [[8, 45]], "StackTraceElement": [[64, 80]]}}}, {"text": "You can then call getClassName(), getMethodName() and getLineNumber() to print out the class, method and line of code", "label": {"api": {"getClassName()": [[18, 31]], "getMethodName()": [[34, 48]], "getLineNumber()": [[54, 68]]}}}, {"text": "Here is the source code of the next() method in the Iterator provided by ArrayList.iterator()", "label": {"api": {"ArrayList.iterator()": [[73, 92]]}}}, {"text": "Java arrays inherit from Object, and do not override equals() and hashCode(), which means that a HashSet or HashMap of arrays are really \"identity\" sets/maps, i.e", "label": {"api": {"Object": [[25, 30]], "equals()": [[53, 60]], "hashCode()": [[66, 75]], "HashSet": [[97, 103]], "HashMap": [[108, 114]]}}}, {"text": "works similarly to IdentityHashMap", "label": {"api": {"HashMap": [[27, 33]], "IdentityHashMap": [[19, 33]]}}}, {"text": "There is no IdentityHashSet, because it would make little sense, though it can be simulated using IdentityHashMap", "label": {"api": {"HashSet": [[20, 26]], "HashMap": [[106, 112]], "IdentityHashMap": [[98, 112]]}}}, {"text": "Since arrays don't override equals() and hashCode(), they added equals() and hashCode() helper methods to the Arrays class, to your convenience", "label": {"api": {"equals()": [[28, 35], [64, 71]], "hashCode()": [[41, 50], [77, 86]], "Arrays": [[110, 115]]}}}, {"text": "Define a CoffeeConsumption class with two members, LocalTime and Integer for your two values", "label": {"api": {"LocalTime": [[51, 59]]}}}, {"text": "Create a Map, perhaps a SortedMap such as TreeMap", "label": {"api": {"SortedMap": [[24, 32]]}}}, {"text": "For each of you custom objects, grab its LocalTime and call getHour", "label": {"api": {"LocalTime": [[41, 49]], "getHour": [[60, 66]]}}}, {"text": "To save the totals, create a new SortedMap with Integer as key for hour-of-day and Integer as value for the hour’s total number of cups consumed", "label": {"api": {"SortedMap": [[33, 41]]}}}, {"text": "call LocalTime::plusHours( 1 )", "label": {"api": {"LocalTime": [[5, 13]]}}}, {"text": "Use String#equals() instead of == to compare Strings", "label": {"api": {"String#equals()": [[4, 18]], "String": [[4, 9], [45, 50]]}}}, {"text": "For a case insensitive comparison, use String#equalsIgnoreCase()", "label": {"api": {"String": [[39, 44]], "String#equalsIgnoreCase()": [[39, 63]]}}}, {"text": "Use shutdownNow if you want to terminate immediately", "label": {"api": {"shutdownNow": [[4, 14]]}}}, {"text": "findFirst returns an Optional", "label": {"api": {"Optional": [[21, 28]]}}}, {"text": "Using ListIterator<T> instead of iterating with for-each loop fixes the problem, because list iterator of ArrayList allows deletions", "label": {"api": {"ListIterator<T>": [[6, 20]]}}}, {"text": "Instead you should probably use a SwingWorker, and inside of the SwingWorker use a java.util.Timer, not a Swing Timer since you'll be off the Swing event thread, to repeatedly call the code to obtain the data that you need, and then pass the information to the GUI using the SwingWorker's publish/process method pair", "label": {"api": {"java.util.Timer": [[83, 97]]}}}, {"text": "Because this pattern was so common (see Comparator, Runnable, ActionListener), it was decided that the language could use a much cleaner syntax for it, and so in Java 8 we were given lambdas to turn the nasty block above into", "label": {"api": {"Comparator": [[40, 49]], "Runnable": [[52, 59]], "ActionListener": [[62, 75]]}}}, {"text": "You can use CSS to remove the context menu of TextField objects", "label": {"api": {"CSS": [[12, 14]]}}}, {"text": "The CONTEXT_MENU_REQUESTED event can be consumed before it reaches the target Node by a event filter that is added to the Scene or to a Parent containing all the TextFields that should not open the context menu", "label": {"api": {"CONTEXT_MENU_REQUESTED event": [[4, 31]]}}}, {"text": "The AtomicBoolean is not necessary here, but it might become handy if you have multiple producers and/or consumers", "label": {"api": {"AtomicBoolean": [[4, 16]]}}}, {"text": "It's also part of java.util.concurrent which you definitely should checkout", "label": {"api": {"java.util.concurrent": [[18, 37]]}}}, {"text": "The type of almost-equals you are implementing does not meet Object's contract for equals, because it is not transitive", "label": {"api": {"Object's contract for equals": [[61, 88]]}}}, {"text": "getOrDefault returns the default only if no mapping, you probably instead have a mapping to the empty string, you should check with custom code, perhaps building a method", "label": {"api": {"getOrDefault": [[0, 11]]}}}, {"text": "Then AutoCloseable interface's close() method takes the role of destructor", "label": {"api": {"AutoCloseable interface's close() method": [[5, 44]]}}}, {"text": "I've got a question about CompletableFuture and its possible usage for lazy computations", "label": {"api": {"CompletableFuture": [[26, 42]]}}}, {"text": "If I just create a CompletableFuture with supplyAssync method or something like that, it is OK", "label": {"api": {"CompletableFuture": [[19, 35]]}}}, {"text": "Does anybody know how to control when does CompletableFuture actually run", "label": {"api": {"CompletableFuture": [[43, 59]]}}}, {"text": "The clone method creates a shallow copy of your first object but your Accessor class has no instance field and does not override hashCode method, as a consequence the instances of this class get the default behaviour from Object class for hashCode", "label": {"api": {"hashCode": [[129, 136], [239, 246]]}}}, {"text": "This behaviour is similar as calling System#identityHashCode with your object as parameter", "label": {"api": {"System#identityHashCode": [[37, 59]]}}}, {"text": "You can sort an array by calling one of the sort() methods on Arrays", "label": {"api": {"Arrays": [[62, 67]]}}}, {"text": "Since your array is an Object[], this means that you need to implement Comparator<Object>", "label": {"api": {"Comparator<Object>": [[71, 88]]}}}, {"text": "Look into Java ServerSocket and a number of related / derivative classes", "label": {"api": {"Java ServerSocket": [[10, 26]]}}}, {"text": "You have to use terminal operation on a stream for it to execute (peek is not terminal, it is an intermediate operation, that returns a new Stream), e.g", "label": {"api": {"terminal operation": [[16, 33]]}}}, {"text": "It is because this is how these methods have been defined in the java api", "label": {"api": {"java api": [[65, 72]]}}}, {"text": "The AWT class Rectangle does store coordinates as ints", "label": {"api": {"does store coordinates as ints": [[24, 53]]}}}, {"text": "So two new classes, Rectangle2D.Float and Rectangle2D.Double were added, which store coordinates as floats and doubles respectively", "label": {"api": {"Rectangle2D.Float": [[20, 36]], "Rectangle2D.Double": [[42, 59]], "Rectangle2D": [[20, 30], [42, 52]]}}}, {"text": "A new abstract class, Rectangle2D was also added, as the superclass of the three rectangle classes", "label": {"api": {"Rectangle2D": [[22, 32]]}}}, {"text": "It does however, specify a contract that its subclasses follow (meaning that any Rectangle2D method is available in all three of its implementations)", "label": {"api": {"Rectangle2D": [[81, 91]]}}}, {"text": "Taking the abstraction an extra, perhaps superfluous, level, they also added RectangularShape as the superclass of several shapes with rectangular bounds", "label": {"api": {"RectangularShape": [[77, 92]]}}}, {"text": "Rectangle2D, RoundRectangle2D, Ellipse2D and Arc2D", "label": {"api": {"Rectangle2D": [[0, 10], [18, 28]]}}}, {"text": "That is the class that actually declares the getWidth() and getHeight() methods, which all RectangularShape subclasses must provide", "label": {"api": {"RectangularShape": [[91, 106]]}}}, {"text": "It is a similar story with Point, which uses int coordinates, but provides double getX() and double getY() methods, because of the later-added classes Point2D.Float, and Point2D.Double, and the abstract superclass Point2D", "label": {"api": {"Point2D": [[151, 157], [170, 176], [214, 220]]}}}, {"text": "The graphic property just is some content that is shown in addition to the text of the menu", "label": {"api": {"graphic property": [[4, 19]]}}}, {"text": "You could find out, if one of the MenuButtons in a MenuBar contains the node using lookupAll to find the nodes (provided the layout has already been performed on the MenuBar)", "label": {"api": {"MenuButtons": [[34, 44]], "lookupAll": [[83, 91]]}}}, {"text": "You can use collectingAndThen and perform an additional finisher operation on the built-in toList() collector that will return a singleton list in case there was no elements", "label": {"api": {"collectingAndThen": [[12, 28]]}}}, {"text": "In case of AWT you might want to use the GridLayout class", "label": {"api": {"GridLayout": [[41, 50]]}}}, {"text": "This is what the implementation of length method from String (Here's the JavaDoc) class looks like", "label": {"api": {"(Here's the JavaDoc)": [[61, 80]]}}}, {"text": "A Spliterator implementation based on AbstractSpliterator consumes values in each queue as needed", "label": {"api": {"Spliterator": [[2, 12], [46, 56]], "AbstractSpliterator": [[38, 56]]}}}, {"text": "Even so, the proposed implementation supports limited parallelization (see the implementation of trySplit in AbstractSpliterator)", "label": {"api": {"Spliterator": [[117, 127]], "AbstractSpliterator": [[109, 127]], "trySplit": [[97, 104]]}}}, {"text": "java.time.OffsetDateTime is not time-zone aware, i.e", "label": {"api": {"java.time.OffsetDateTime": [[0, 23]]}}}, {"text": "java.time.ZonedDateTime is time-zone aware, so if you use that, you should get same result", "label": {"api": {"java.time.ZonedDateTime": [[0, 22]]}}}, {"text": "Turns out the user was going through an XML file using javax.xml.stream.XMLStreamReader#next()", "label": {"api": {"javax.xml.stream.XMLStreamReader#next()": [[55, 93]]}}}, {"text": "You need to separate Swing calls from database calls, which is done using EventQueue.invokeLater (or its alias, SwingUtilities.invokeLater)", "label": {"api": {"EventQueue.invokeLater": [[74, 95]], "SwingUtilities.invokeLater": [[112, 137]]}}}, {"text": "For more information, see the javax.swing package contract, and Concurrency in Swing in the Java Tutorials", "label": {"api": {"javax.swing package contract": [[30, 57]]}}}, {"text": "Try using Files.move instead", "label": {"api": {"Files.move": [[10, 19]]}}}, {"text": "If you read the javadocs for renameTo, it states that", "label": {"api": {"renameTo": [[29, 36]]}}}, {"text": "You might want to consider using a Regex Pattern", "label": {"api": {"Pattern": [[41, 47]]}}}, {"text": "If the files are not too large, you could read the entire file into memory, then use a carefully crafted Regex Pattern to search for (SomeDataIKnow|DifferentDataIKnow|...)= and capture both the matching text before the equals sign and everything between the = and the next line break", "label": {"api": {"Pattern": [[111, 117]]}}}, {"text": "ThreadLocal was meant for different purpose as per oracle documentation", "label": {"api": {"ThreadLocal": [[0, 10]]}}}, {"text": "ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID)", "label": {"api": {"ThreadLocal": [[0, 10]]}}}, {"text": "In case of ThreadLocal varaibles, each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible", "label": {"api": {"ThreadLocal": [[11, 21], [152, 162]]}}}, {"text": "Javadoc for addRow method states", "label": {"api": {"addRow": [[12, 17]]}}}, {"text": "Normally this is as simple as loading the image from a url in the background and tracking it's progress by binding the progress property of the progress bar to the progress property of the image", "label": {"api": {"loading the image from a url in the background": [[30, 75]], "progress property of the progress bar": [[119, 155]], "progress property of the image": [[164, 193]]}}}, {"text": "So, instead of doing low level string operations; you should familiarize yourself with concepts like Java Paths in order to understand the abstractions you ought to use in order to create a reasonable plugin", "label": {"api": {"Paths": [[106, 110]]}}}, {"text": "I think that Path.subpath will do what you are describing", "label": {"api": {"Path.subpath": [[13, 24]]}}}, {"text": "The \"name\" attribute of the UniqueConstraint annotation was introduced in JPA 2.0", "label": {"api": {"UniqueConstraint annotation": [[28, 54]]}}}, {"text": "Use an Iterator to go through your list, and use the remove() method to remove the current element from your Collection", "label": {"api": {"Iterator": [[7, 14]], "remove()": [[53, 60]]}}}, {"text": "Don't extend JScrollPane", "label": {"api": {"JScrollPane": [[13, 23]]}}}, {"text": "Instead, use your table to construct a JScrollPane", "label": {"api": {"JScrollPane": [[39, 49]]}}}, {"text": "As shown in How a Scroll Pane Works, the first formulation adds the table directly to the JScrollPane, replacing the JViewport component that occupies the central position in the ScrollPaneLayout and that would have been used to display the table", "label": {"api": {"JScrollPane": [[90, 100]], "JViewport": [[117, 125]], "ScrollPaneLayout": [[179, 194]]}}}, {"text": "The second formulation invokes setViewportView(table) internally, which tells the scroll pane's JViewport what component to display", "label": {"api": {"JViewport": [[96, 104]]}}}, {"text": "Firstly I am using Statement#executeBatch for executing many UPDATE statements", "label": {"api": {"Statement#executeBatch": [[19, 40]]}}}, {"text": "Thread.join() waits until the thread dies", "label": {"api": {"Thread.join()": [[0, 12]]}}}, {"text": "As Andy Turner has mentioned in the comments, it might be usefull to use an ExecutorService to handle your Runnables", "label": {"api": {"ExecutorService": [[76, 90]]}}}, {"text": "I would use the HttpSession", "label": {"api": {"HttpSession": [[16, 26]]}}}, {"text": "Mandatory fields are validated with provided instance of type javax.validation.Validator through @Valid", "label": {"api": {"javax.validation.Validator": [[62, 87]]}}}, {"text": "If your strings are properties your may want to use RessourceBundle or Properties", "label": {"api": {"RessourceBundle": [[52, 66]], "Properties": [[71, 80]]}}}, {"text": "Use a CountDownLatch to coordinate between threads", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "As others have already suggested, use a Serializable implementation of java.util.Collection", "label": {"api": {"java.util.Collection": [[71, 90]]}}}, {"text": "(Most of the java.util collections--such as java.util.ArrayList and java.util.HashSet--are Serializable.) A collection of 0 or 1 elements shouldn't bother you (it's not relevant to the serialization of the collection) unless your game has other business requirements that care, but..", "label": {"api": {"java.util.ArrayList": [[44, 62]], "java.util.HashSet": [[68, 84]]}}}, {"text": "The images were loaded through ImageIO#read(File)", "label": {"api": {"ImageIO#read(File)": [[31, 48]]}}}, {"text": "You could try to use lookupPrintServices method of javax.print.PrintServiceLookup instead of JavaFX Printer to display the available printer services", "label": {"api": {"lookupPrintServices method": [[21, 46]]}}}, {"text": "Or if you just want to make the user able to select a printer before the actual printing, you could use showPrintDialog of PrinterJob as in the dialog the printer list is also refreshed", "label": {"api": {"showPrintDialog": [[104, 118]]}}}, {"text": "To find the highest or smallest values I use Math.max and Math.min", "label": {"api": {"Math.max": [[45, 52]], "Math.min": [[58, 65]]}}}, {"text": "The closest analogues you'll find are in the java.util.function package", "label": {"api": {"java.util.function": [[45, 62]]}}}, {"text": "You should use something like AtomicInteger for this, it will allow threadsafe incrementing and provide visibility guarantees", "label": {"api": {"AtomicInteger": [[30, 42]]}}}, {"text": "You need to annotate your exception mapper with @Provider, in order to register it with the JAX-RS runtime", "label": {"api": {"@Provider": [[48, 56]]}}}, {"text": "You could parse json ==> 10 Java Map, then merge the 10  Map through the Map::putAll method and finally pass the obtained Map that contains all the objects to Jackson", "label": {"api": {"Map": [[33, 35], [57, 59], [73, 75], [122, 124]], "Map::putAll": [[73, 83]]}}}, {"text": "distribution is a java.util.function.Function", "label": {"api": {"java.util.function": [[18, 35]]}}}, {"text": "For different combinations of in- and output types, there are different functional interfaces available in java.util.function", "label": {"api": {"java.util.function": [[107, 124]]}}}, {"text": "The behavioral specification of ReentrantLock specifies that it must be unlocked by the thread that locked it", "label": {"api": {"ReentrantLock": [[32, 44]]}}}, {"text": "If you have two classes (one for each of your settings and main views) why not add a controller in between them and have it as a listener of the JComboBox and an Observable to the main view", "label": {"api": {"Observable": [[162, 171]]}}}, {"text": "An Observer is a class which wants to observe another class for changes and act upon those changes", "label": {"api": {"Observer": [[3, 10]]}}}, {"text": "The class that changes is said to be Observable", "label": {"api": {"Observable": [[37, 46]]}}}, {"text": "setChanged() changes the state of the observable to changed", "label": {"api": {"setChanged()": [[0, 11]]}}}, {"text": "If you call notifyObservers() the observable should be checked for changes with hasChanged()", "label": {"api": {"Observer": [[18, 25]], "notifyObservers()": [[12, 28]], "hasChanged()": [[80, 91]]}}}, {"text": "clearChanged() sets the state back to unchanged", "label": {"api": {"clearChanged()": [[0, 13]]}}}, {"text": "Both effect the return value of hasChanged()", "label": {"api": {"hasChanged()": [[32, 43]]}}}, {"text": "Note that clearChanged() is automatically called by notifyObservers() and redundant in the code; therefore it's now removed", "label": {"api": {"Observer": [[58, 65]], "notifyObservers()": [[52, 68]], "clearChanged()": [[10, 23]]}}}, {"text": "I think the simplest approach is using an AtomicBoolean variable that is accessible to both threads - you could pass the variable in when constructing each thread's run class if necessary", "label": {"api": {"AtomicBoolean": [[42, 54]]}}}, {"text": "Nice thing about AtomicBoolean is that it is already thread safe/synchronized and mutable so that it can be passed around and modified by reference", "label": {"api": {"AtomicBoolean": [[17, 29]]}}}, {"text": "Also when you call the close function of a Socket object, the input and output streams will generate the relative exceptions", "label": {"api": {"close": [[23, 27]], "Socket": [[43, 48]]}}}, {"text": "Using java.time.LocalDate is not supported until now", "label": {"api": {"LocalDate": [[16, 24]]}}}, {"text": "So you must convert the LocalDate into java.util.Date before setting as cell value", "label": {"api": {"LocalDate": [[24, 32]]}}}, {"text": "Since LocalTime implements Temporal, there must be a signature match between those two or the contract is not fulfilled, which would lead to a compilation error", "label": {"api": {"LocalTime implements Temporal": [[6, 34]]}}}, {"text": "If you need to have arbitrary precision arithmetic you need to use BigDecimal", "label": {"api": {"BigDecimal": [[67, 76]]}}}, {"text": "As noted by @Thomas, BitSet.set(int) doesn't work like you apparently expect it to", "label": {"api": {"BitSet.set(int)": [[21, 35]]}}}, {"text": "Use the constructors of TreeMap and TreeSet which take a Comparator as a parameter, e.g", "label": {"api": {"TreeMap": [[24, 30]], "TreeSet": [[36, 42]]}}}, {"text": "Note that there is no restriction that the keys of the TreeMap or entries of the TreeSet need to implement Comparable", "label": {"api": {"TreeMap": [[55, 61]], "TreeSet": [[81, 87]]}}}, {"text": "If you're asking why we have things like ArrayList(int) (to set the capacity), ArrayList(Collection<", "label": {"api": {"ArrayList(int)": [[41, 54]]}}}, {"text": "extends E>) (to copy a list), etc., instead of just having ArrayList() and then using mutator methods, there are a couple of reasons", "label": {"api": {"ArrayList()": [[59, 69]]}}}, {"text": "java.util.Bitset allows for any number of bits; there is no \"only > 64 bits\" limitation", "label": {"api": {"java.util.Bitset": [[0, 15]]}}}, {"text": "getSelectedToggle returns you an instance of toggled radio button", "label": {"api": {"getSelectedToggle": [[0, 16]]}}}, {"text": "and then access the headers and cookies via methods on the HttpHeaders instance", "label": {"api": {"HttpHeaders": [[59, 69]]}}}, {"text": "The code was written prior to java.util.Objects.requireNonNull", "label": {"api": {"java.util.Objects.requireNonNull": [[30, 61]]}}}, {"text": "I ended up using RxJava, but not before coming up with a just-as-good solution using BlockingQueue instead of List in the Map", "label": {"api": {"BlockingQueue": [[85, 97]]}}}, {"text": "To alleviate this, I've used the drainTo(Collection) method on a per-request instantiated data structure", "label": {"api": {"drainTo(Collection)": [[33, 51]]}}}, {"text": "You could use MyInterface<T> and the Void type for the void case", "label": {"api": {"Void type": [[37, 45]]}}}, {"text": "You need to get the ListSelectionModel from the JList", "label": {"api": {"ListSelectionModel": [[20, 37]]}}}, {"text": "While the ListSelectionModel allows fine grained control over the selection behaviour of the JList,  JList itself also provides convenient methods like JList.setSelectedIndex() to simply modify the selected elements", "label": {"api": {"ListSelectionModel": [[10, 27]], "JList.setSelectedIndex()": [[152, 175]]}}}, {"text": "You'll want to use entrySet() instead of values() and then map each entry to a list of its key and values", "label": {"api": {"entrySet()": [[19, 28]], "values()": [[41, 48]]}}}, {"text": "This isn’t a good solution, in that it ignores NodeOrientation, and doesn’t support accessibility (meaning, among other things, no keyboard control)", "label": {"api": {"NodeOrientation": [[47, 61]]}}}, {"text": "ConcurrentModificationException occurs only when you modify the list when the same list is iterated using Iterator", "label": {"api": {"ConcurrentModificationException": [[0, 30]]}}}, {"text": "Find below your example modified to produce ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[44, 74]]}}}, {"text": "As with @QueryParam or @PathParam parameters, the underlying JAX-RS framework will try to convert the parameter on a best-effort attempt", "label": {"api": {"convert the parameter": [[90, 110]]}}}, {"text": "In cases where the parameter can not be marshalled to an object automatically, you can also inject an UriInfo object using a @Context annotation and then retrieve the matrix parameter via the respective PathSegment the parameter is annotated on and then marshal it to an object on your own", "label": {"api": {"PathSegment": [[203, 213]], "UriInfo": [[102, 108]]}}}, {"text": "As the PathSegment returns a MultivaluedMap, the same key is able to return multiple values (as a List) like in your case multiple IDs you want to insert into the DB query", "label": {"api": {"PathSegment": [[7, 17]], "MultivaluedMap": [[29, 42]]}}}, {"text": "UriInfo also provides a MultivaluedMap on looking up the path- and query-parameters", "label": {"api": {"MultivaluedMap": [[24, 37]], "UriInfo": [[0, 6]]}}}, {"text": "If you check the value of phrase, after invoking in.next(), you will see that's equal to \"Alpha\"", "label": {"api": {"next()": [[52, 57]]}}}, {"text": "By definition, Scanner's next() reads the next token", "label": {"api": {"next()": [[25, 30]]}}}, {"text": "The best way to control such OS related events is to use Robot class", "label": {"api": {"Robot": [[57, 61]]}}}, {"text": "You could use streams", "label": {"api": {"streams": [[14, 20]]}}}, {"text": "The constructor documentation says", "label": {"api": {"constructor documentation": [[4, 28]]}}}, {"text": "In both cases you would need to refresh the entity instance after saving if you want to use the generated value immediately after persisting the instance", "label": {"api": {"refresh": [[32, 38]]}}}, {"text": "Math class provides a perfect example - it has groups of function overload by type - four abs, four min, four max, and so on", "label": {"api": {"Math": [[0, 3]]}}}, {"text": "Math.intMax(a, b) which would be detrimental to readability of user's code", "label": {"api": {"Math": [[0, 3]]}}}, {"text": "Then, since Runnable is a Functional Interface, it can be defined as a lambda", "label": {"api": {"Runnable": [[12, 19]]}}}, {"text": "You can set the vmaxProperty of the ScrollPane", "label": {"api": {"vmaxProperty": [[16, 27]]}}}, {"text": "Another possiblity is to interrupt down-scrolling by listening to the vvalueProperty property of the ScrollPane", "label": {"api": {"vvalueProperty": [[70, 83]]}}}, {"text": "The more direct solution would be to check if the current result string simply contains a certain character and only add the character if it does not", "label": {"api": {"contains": [[79, 86]]}}}, {"text": "A ScrollPane's scroll position can be adjusted by holding down the mouse button and moving the mouse, if the pannable Property is set to true", "label": {"api": {"pannable Property": [[109, 125]]}}}, {"text": "Java documentations report this as the implementation for Random.nextDouble(), which is what Math.random() ends up invoking", "label": {"api": {"Random.nextDouble()": [[58, 76]]}}}, {"text": "ThreadLocalRandom is always preferable to Math.random", "label": {"api": {"ThreadLocalRandom": [[0, 16]]}}}, {"text": "Here is a JMH benchmark to compare the performance of Math.random() and ThreadLocalRandom.current().nextDouble() to a simple arithmetic operation", "label": {"api": {"ThreadLocalRandom": [[72, 88]]}}}, {"text": "The results show that ThreadLocalRandom works in just a few nanoseconds, its performance is comparable to a simple arithmetic operation and perfectly scales in multithreaded environment unlike Math.random", "label": {"api": {"ThreadLocalRandom": [[22, 38]]}}}, {"text": "You probably want ProcessBuilder#redirectOutput(File), as the > functionality is not of cat, rather what is calling cat (in our sense, the process builder)", "label": {"api": {"ProcessBuilder#redirectOutput(File)": [[18, 52]]}}}, {"text": "The Properties text format has no problem with either <s or >s", "label": {"api": {"Properties": [[4, 13]]}}}, {"text": "The exact specification of the file format is laid out in Properties.load() and makes no mention of either character", "label": {"api": {"Properties": [[58, 67]], "Properties.load()": [[58, 74]]}}}, {"text": "First we construct a Properties object and add a <key>:<value> pair", "label": {"api": {"Properties": [[21, 30]]}}}, {"text": "Then we write the object to a Writer and print the serialized contents, then we load those contents back into a new Properties object and can see there was no data loss", "label": {"api": {"Properties": [[116, 125]]}}}, {"text": "If you're using the XML file format (via loadFromXML() and storeToXML()) you need to escape < and > just like you would in any XML document", "label": {"api": {"loadFromXML()": [[41, 53]], "storeToXML()": [[59, 70]]}}}, {"text": "You can define the font size using CSS as inline style for the HBox, see style Property", "label": {"api": {"see style Property": [[69, 86]]}}}, {"text": "The correct property names for the CSS properties can be found in the JavaFX CSS Reference Guide", "label": {"api": {"the JavaFX CSS Reference Guide": [[66, 95]]}}}, {"text": "It could be clearer but this is described in the BorderLayout documentation", "label": {"api": {"BorderLayout": [[49, 60]]}}}, {"text": "Put another way, the CENTER component will be stretched (if needed) to fill the application, and any other components need to specify a preferred-size in order to take some of that from the CENTER", "label": {"api": {"preferred-size": [[136, 149]]}}}, {"text": "In short, specify a preferred size for your JPanel and the BorderLayout will try to allocate at least that much space for the panel", "label": {"api": {"BorderLayout": [[59, 70]]}}}, {"text": "Create a list of objects of this class, sort them using a custom comparator or by implementing Comparable<StringWithSortKey> interface, and write out str members of sorted objects into the output file", "label": {"api": {"Comparable<StringWithSortKey>": [[95, 123]]}}}, {"text": "The pattern that you described there is exactly the pattern of Comparable", "label": {"api": {"Comparable": [[63, 72]]}}}, {"text": "In fact, you should consider omitting your Parent interface, and replace it with Comparable instead", "label": {"api": {"Comparable": [[81, 90]]}}}, {"text": "The Comparable interface and its uses also show how this can be solved", "label": {"api": {"Comparable": [[4, 13]]}}}, {"text": "System.arraycopy was developed to do that..", "label": {"api": {"System.arraycopy": [[0, 15]]}}}, {"text": "Show the ContextMenu using the show(Node anchor, Side side, double dx, double dy) method", "label": {"api": {"show(Node anchor, Side side, double dx, double dy)": [[31, 80]]}}}, {"text": "I could imagine that you could use this technique to obtain information from ManagementFactory or some similar Java class that provides the needed information", "label": {"api": {"ManagementFactory": [[77, 93]]}}}, {"text": "I would suggest you to use JSONObject", "label": {"api": {"JSONObject": [[27, 36]]}}}, {"text": "Use a BufferedWriter instead", "label": {"api": {"BufferedWriter": [[6, 19]]}}}, {"text": "You just have to use the showOptionDialog method", "label": {"api": {"showOptionDialog": [[25, 40]]}}}, {"text": "From the Javadoc of Comparable", "label": {"api": {"Comparable": [[20, 29]]}}}, {"text": "I think you need to use FutureTask and store them in a Collection and use FutureTask.get() to retrieve the result when needed which is a blocking call", "label": {"api": {"FutureTask": [[24, 33], [74, 83]]}}}, {"text": "The easy one is using Scanner with the right delimiter (\"-\" in your case)", "label": {"api": {"Scanner": [[22, 28]]}}}, {"text": "In java 8 DateTimeFormatter supports quarters using q format and week of the year using w", "label": {"api": {"DateTimeFormatter": [[10, 26]]}}}, {"text": "Also, use pickOnBounds to only react when you click on the duck's pixels, not it's bounding box", "label": {"api": {"pickOnBounds": [[10, 21]]}}}, {"text": "You could loop over the results of readLine() and accumulate them until you get a null, indicating the end of the file (BTW, note that your snippet neglected to close the reader", "label": {"api": {"readLine()": [[35, 44]]}}}, {"text": "if you're using Java 8, you can save a lot of this boiler-plated code with the newly introduced lines() method", "label": {"api": {"lines()": [[96, 102]]}}}, {"text": "For example, JList itself has been JList<E> since Java 1.7", "label": {"api": {"JList": [[13, 17], [35, 39]]}}}, {"text": "Because setSelectedIndices() \"is a convenience method that clears the selection and then uses addSelectionInterval() on the selection model to add the indices,\" you can overload the method as desired (range checking elided for clarity)", "label": {"api": {"setSelectedIndices()": [[8, 27]]}}}, {"text": "Use Collectors.groupingBy with the appropriate getter method", "label": {"api": {"Collectors.groupingBy": [[4, 24]]}}}, {"text": "All you have to do is use BufferedImage and setRGB method to set your linear bar pixels", "label": {"api": {"BufferedImage": [[26, 38]]}}}, {"text": "If you take a look at the implemented interfaces, then LinkedList is a drop-in implementation for queues", "label": {"api": {"LinkedList": [[55, 64]]}}}, {"text": "Stack is not an interface in java, but a class", "label": {"api": {"Stack": [[0, 4]]}}}, {"text": "LinkedList doesn't contain the peek(), empty() and search() methods, so it's not a fully-fledged stack", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "If you absolutely need to constantly read the state of a button, use a Thread", "label": {"api": {"Thread": [[71, 76]]}}}, {"text": "After having done an insert, you need to leave the insert row using moveToCurrentRow() to go back to the row you where on, after having done that (and assuming you actually have a scrollable cursor) you can call beforeFirst()", "label": {"api": {"moveToCurrentRow()": [[68, 85]]}}}, {"text": "Considering you're \"not Java 8 friendly at this moment\" (you probably mean lambdas and streams), how about using StringJoiner", "label": {"api": {"StringJoiner": [[113, 124]]}}}, {"text": "For String operations like strncasecmp in C, use the methods of the String class, e.g", "label": {"api": {"String": [[4, 9], [68, 73]]}}}, {"text": "Also have a look at the StringUtils class from the Apache Commons Lang library", "label": {"api": {"String": [[24, 29]]}}}, {"text": "This is why the Java 8 time API has methods called atStartOfDay, not atMidnight", "label": {"api": {"atStartOfDay": [[51, 62]]}}}, {"text": "What you need is the Stream#findFirst() method once you have filtered the Stream using your predicate", "label": {"api": {"Stream#findFirst()": [[21, 38]]}}}, {"text": "This will return an Optional as there may not be any elements left after the filtering", "label": {"api": {"Optional": [[20, 27]]}}}, {"text": "RegexpMulitiline check is based on find(), see checks/regexp/MultilineDetector.java#L95", "label": {"api": {"find()": [[35, 40]]}}}, {"text": "Read the manual", "label": {"api": {"manual": [[9, 14]]}}}, {"text": "WeakReference-s or PhantomReference-s can solve this problem", "label": {"api": {"PhantomReference": [[19, 34]]}}}, {"text": "With Java 8, you can use String.join to join the individual characters from the term with character groups representing one or more of your special characters, i.e", "label": {"api": {"String.join": [[25, 35]]}}}, {"text": "Alternatively, you could also replaceAll the special chars with \"\" and check for equality", "label": {"api": {"replaceAll": [[30, 39]]}}}, {"text": "indexOf can take a second argument that says where to start in the string", "label": {"api": {"indexOf can take a second argument": [[0, 33]]}}}, {"text": "Use ResultSet.getMetaData() to find out about each column and no of columns and design table accordingly", "label": {"api": {"ResultSet.getMetaData()": [[4, 26]]}}}, {"text": "Use a HashSet", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "Put the lucky numbers in a HashSet, this will make it easy to check if some number is a lucky number", "label": {"api": {"HashSet": [[27, 33]]}}}, {"text": "For every person in the input, count how many of their numbers are in the lucky numbers set using HashSet.contains", "label": {"api": {"HashSet": [[98, 104]], "HashSet.contains": [[98, 113]]}}}, {"text": "If a name is important to you, call the Thread constructor that allows you to set your own name", "label": {"api": {"Thread constructor that allows you to set your own name": [[40, 94]]}}}, {"text": "Then you could use Arrays.copyOf(T[], int) which (per the Javadoc) copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length", "label": {"api": {"Arrays.copyOf(T[], int)": [[19, 41]]}}}, {"text": "I suggest you look into List<E> interface as well as its implementations like ArrayList<E> whose size can be changed", "label": {"api": {"List<E>": [[24, 30], [83, 89]], "ArrayList<E>": [[78, 89]]}}}, {"text": "You can just dynamically create a String array and use an enhanced for-loop to iterate it", "label": {"api": {"String": [[34, 39]]}}}, {"text": "or rather, AbstractCollection does, and ArrayList inherits the implementation", "label": {"api": {"AbstractCollection does": [[11, 33]]}}}, {"text": "I prefer to implement my own Filters to get 100% of control", "label": {"api": {"Filters": [[29, 35]]}}}, {"text": "You should either concatenate all isCharacters events between other events or set the IS_COALESCING property", "label": {"api": {"IS_COALESCING": [[86, 98]]}}}, {"text": "Read the Javadoc", "label": {"api": {"Read the Javadoc": [[0, 15]]}}}, {"text": "For avoiding this issue, you can wrap the url stream into a GZIPInputStream", "label": {"api": {"GZIPInputStream": [[60, 74]]}}}, {"text": "You can use the Bindings class to crate a binding that depends on doublePropertyTwo", "label": {"api": {"Bindings class": [[16, 29]]}}}, {"text": "I recommend you using the BigInteger, that works with the String representation", "label": {"api": {"BigInteger": [[26, 35]]}}}, {"text": "I do this with a Timer and mouse listeners (for moved and exited)", "label": {"api": {"Timer": [[17, 21]], "moved": [[48, 52]], "exited": [[58, 63]]}}}, {"text": "When the mouse is moved, the timer is reset, so the popup only shows when the mouse has been still", "label": {"api": {"moved": [[18, 22]]}}}, {"text": "It would also be OK if the popup moved with the mouse, but I'm not sure how to do that either", "label": {"api": {"moved": [[33, 37]]}}}, {"text": "I know it is possible with ObjectOutputStream, I have even found how to write multiple objects to a single file and read them back (which might sound like it solves my problem) but no, it doesn't", "label": {"api": {"ObjectOutputStream": [[27, 44]]}}}, {"text": "From my understanding, the Java Servlet specification requires that a Servlet container pull the Client Certificate from an HTTPS request and store that as an attribute on the HttpServletRequest", "label": {"api": {"Client Certificate from an HTTPS request and store that as an attribute on the HttpServletRequest": [[97, 193]]}}}, {"text": "Element.getElementsByTagNameNS() returns a NodeList, not an Element", "label": {"api": {"Element.getElementsByTagNameNS()": [[0, 31]], "NodeList": [[43, 50]]}}}, {"text": "Here is an example of using a regular expression replacement loop, which uses the appendReplacement() and appendTail() methods to build the result", "label": {"api": {"appendReplacement()": [[82, 100]], "appendTail()": [[106, 117]]}}}, {"text": "To eliminate the need for doing a string comparison to figure out which keyword was found, each keyword is made a capturing group, so existence of keyword can be quickly checked using start(int group)", "label": {"api": {"start(int group)": [[184, 199]]}}}, {"text": "As an alternative, consider Ellipse2D with suitable RenderingHints", "label": {"api": {"Ellipse2D": [[28, 36]], "RenderingHints": [[52, 65]]}}}, {"text": "Because various RenderingHints are implementation dependent, the example below will let you evaluate the effects individually", "label": {"api": {"RenderingHints": [[16, 29]]}}}, {"text": "I think that you are misunderstanding the purpose of the Object.hashCode() method - not hashing in general, but the reason why Java objects have this method", "label": {"api": {"Object.hashCode() method": [[57, 80]]}}}, {"text": "openConnection() does not modify the URL object, it returns a URLConnection instance that you could then use", "label": {"api": {"URLConnection": [[62, 74]]}}}, {"text": "Also note that Java 1.7 introduced java.util.Objects which has requireNonNull, so you don't even need a third party library", "label": {"api": {"java.util.Objects": [[35, 51]]}}}, {"text": "A ScrollPane stores its single child in the contentProperty", "label": {"api": {"contentProperty": [[44, 58]]}}}, {"text": "In case of you would like to store multiple Nodes in a ScrollPane the contentProperty should be set to one of the containers (Parent object) then the Nodes should be added to this container", "label": {"api": {"contentProperty": [[70, 84]]}}}, {"text": "There aren’t a lot of minutes in a day (in computing terms), so I would just use a BitSet to keep a flag for every single minute in the day", "label": {"api": {"BitSet": [[83, 88]]}}}, {"text": "Note that BitSet.clear expects the second argument to be an exclusive bound (just like String.substring and List.subList);  that is the reason for passing end + 1", "label": {"api": {"BitSet": [[10, 15]]}}}, {"text": "Otherwise, you can use clone if point implements cloneable", "label": {"api": {"cloneable": [[49, 57]]}}}, {"text": "You can use getime() function from Date class for conversion", "label": {"api": {"getime()": [[12, 19]]}}}, {"text": "If you look at the doc https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html Queue does not implement Serializable so make sure what ever object implements Queue is serializable", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html": [[23, 84]]}}}, {"text": "The definite answer is getName()", "label": {"api": {"getName()": [[23, 31]]}}}, {"text": "Although a bit hidden, this is specified in the Javadoc of the overload of forName(className, initialize, loader)", "label": {"api": {"forName(className, initialize, loader)": [[75, 112]]}}}, {"text": "And it is also specified that calling forName(className) is equivalent to calling this overload, with default values", "label": {"api": {"forName(className)": [[38, 55]]}}}, {"text": "You may want to take a look at LinkedList", "label": {"api": {"LinkedList": [[31, 40]]}}}, {"text": "From the documentation for CRC32.update", "label": {"api": {"CRC32.update": [[27, 38]]}}}, {"text": "Please read SimpleDateFormat javadocs for the format specification, yours is completely wrong", "label": {"api": {"SimpleDateFormat javadocs": [[12, 36]]}}}, {"text": "Here is what java API for StringBuffer, https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html,  says \"Every string buffer has a capacity", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html": [[40, 108]]}}}, {"text": "Check this link", "label": {"api": {"link": [[11, 14]]}}}, {"text": "Source Random class documentation", "label": {"api": {"Random class documentation": [[7, 32]]}}}, {"text": "The Timer class already creates a background thread for you, so this will run in a background thread without explicitly creating one", "label": {"api": {"Timer": [[4, 8]]}}}, {"text": "The standard libraries already have, for example, a Duration class which can be used to represent minutes and seconds, and which already implements all the arithmetic for you", "label": {"api": {"Duration class": [[52, 65]]}}}, {"text": "What you need to do is add a call to invalidate() after you have finished updating all of the points", "label": {"api": {"invalidate()": [[37, 48]]}}}, {"text": "You can simply add a listener to the valueProperty of the Slider and then you can either set the integer value of the new Number value", "label": {"api": {"valueProperty": [[37, 49]], "integer value": [[97, 109]]}}}, {"text": "or alternatively you can use integer rounding using Math.round", "label": {"api": {"Math.round": [[52, 61]]}}}, {"text": "If you \"move\" the focus, it will go to the next child with focusTraversable set to true", "label": {"api": {"focusTraversable": [[59, 74]]}}}, {"text": "I am using ScheduledExecutorService to do the job", "label": {"api": {"ScheduledExecutorService": [[11, 34]]}}}, {"text": "With an Instant, you can call atZone(zone) to combine it with a ZoneId in order to form a ZonedDateTime", "label": {"api": {"atZone(zone)": [[30, 41]], "ZoneId": [[64, 69]], "ZonedDateTime": [[90, 102]]}}}, {"text": "If you want to use the system time zone (the one of the running VM), you can get it with ZoneId.systemDefault()", "label": {"api": {"ZoneId": [[89, 94]], "ZoneId.systemDefault()": [[89, 110]]}}}, {"text": "To print it, you can use the two built-in formatter ISO_OFFSET_DATE_TIME or ISO_ZONED_DATE_TIME", "label": {"api": {"ISO_OFFSET_DATE_TIME": [[52, 71]], "ISO_ZONED_DATE_TIME": [[76, 94]]}}}, {"text": "You can of course build your own formatter if those one do not suit you, using ofPattern or the builder DateTimeFormatterBuilder", "label": {"api": {"ofPattern": [[79, 87]], "DateTimeFormatterBuilder": [[104, 127]]}}}, {"text": "This can be directly added to the formatter using withZone(ZoneId) - there is no need to manually convert to ZonedDateTime *", "label": {"api": {"withZone(ZoneId)": [[50, 65]]}}}, {"text": "* regrettably, in early Java 8 versions, the DateTimeformatter.withZone(ZoneId) method did not work, however this has now been fixed, so if the code above doesn't work, upgrade to the latest Java 8 patch release", "label": {"api": {"withZone(ZoneId)": [[63, 78]]}}}, {"text": "This is a bit subtle, but I think the answer lies in the wording of the documentation for shutdown", "label": {"api": {"documentation for shutdown": [[72, 97]]}}}, {"text": "Example using BooleanSupplier as Strategy", "label": {"api": {"BooleanSupplier": [[14, 28]]}}}, {"text": "You can use Nashorn API directly, e.g", "label": {"api": {"Nashorn API": [[12, 22]]}}}, {"text": "Another minor thing that using Nashorn API directly buys you is that you will know that you're definitely getting a Nashorn engine, something you couldn't necessarily be certain if you just asked for a JS engine from javax.script", "label": {"api": {"Nashorn API": [[31, 41]]}}}, {"text": "Because accept() returns void, what you ask is not possible \"out of the box\"", "label": {"api": {"void": [[25, 28]]}}}, {"text": "Use PasswordField instead of TextField, which is subclass of TextField and masks entered characters", "label": {"api": {"PasswordField": [[4, 16]]}}}, {"text": "If you want a solution that works on any recursive function, you can accept a Consumer object", "label": {"api": {"Consumer": [[78, 85]]}}}, {"text": "The URI class and URLDecoder class are designed to do what you want", "label": {"api": {"URI": [[4, 6]], "URLDecoder": [[18, 27]]}}}, {"text": "The structure of a URI is documented in the URI class documentation and in the RFC that defines the structure of a URI, RFC 3986", "label": {"api": {"URI": [[19, 21], [44, 46], [115, 117]]}}}, {"text": "fd.getFile() returns a relative path, and new File() will create a new File relative to the execution directory", "label": {"api": {"new File()": [[42, 51]]}}}, {"text": "Calling fd.getDirectory() + fd.getFile() works, but you should avoid constructing file paths with string concatenation - that's what the two-argument File constructor is for, so instead do", "label": {"api": {"two-argument File constructor": [[137, 165]]}}}, {"text": "There's also DirectoryChooser if you want to try JavaFX", "label": {"api": {"DirectoryChooser": [[13, 28]]}}}, {"text": "If you do not care about abrupt termination of the background tasks being executed by the threads spawned by a fixedThreadPool(), you can call the shutdown() method to stop the threads", "label": {"api": {"fixedThreadPool()": [[111, 127]], "shutdown()": [[147, 156]]}}}, {"text": "If you do care about clean termination, use the awaitTermination() method instead", "label": {"api": {"awaitTermination()": [[48, 65]]}}}, {"text": "Instead, you could use Scanner's hasXYZ methods", "label": {"api": {"Scanner": [[23, 29]]}}}, {"text": "For Swing, see \"Swing's Threading Policy\" in the javax.swing package documentation; for JavaFX see the \"Threading\" section of the Application documentation", "label": {"api": {"\"Swing's Threading Policy\" in the javax.swing package documentation": [[15, 81]], "\"Threading\" section of the Application documentation": [[103, 154]]}}}, {"text": "A StringIndexOutOfBoundsException is mostly thrown when you use charAt to select a character from a string that isn't there", "label": {"api": {"StringIndexOutOfBoundsException": [[2, 32]]}}}, {"text": "The pattern that should work is dd MMM, yyyy 'GMT' XXX indeed X is the timezone in ISO 8601 which seems to be what you are looking for", "label": {"api": {"ISO 8601": [[83, 90]]}}}, {"text": "You could call applyCss after adding the TableView to a Scene and access the TableHeaderRow after this call", "label": {"api": {"applyCss": [[15, 22]]}}}, {"text": "You have a NullPointerException, which is due to the fact that you try to call getImage() of a null object", "label": {"api": {"NullPointerException": [[11, 30]]}}}, {"text": "Refer to the XMLConstants JavaDocs for more details", "label": {"api": {"XMLConstants JavaDocs": [[13, 33]]}}}, {"text": "You create an new Document object, then \"copy\" the Node objects you want, using importNode()", "label": {"api": {"Document": [[18, 25]], "Node": [[51, 54], [86, 89]], "importNode()": [[80, 91]]}}}, {"text": "Replace get() with orElse(null)", "label": {"api": {"orElse(null)": [[19, 30]]}}}, {"text": "Java 8's syntax for Comparator.compating makes writing such comparators quite elegant", "label": {"api": {"Comparator.compating": [[20, 39]]}}}, {"text": "You could use FlowLayout but if they resize your frame then it will wrap the panels", "label": {"api": {"FlowLayout": [[14, 23]]}}}, {"text": "Alternatively, you could use an AtomicInteger, which provides an atomic incrementAndGet method", "label": {"api": {"AtomicInteger": [[32, 44]]}}}, {"text": "The disadvantage is that it only provides atomicity for that one operation; if you need some other operation to also be atomic (maybe you also want to increment a depositCounts field?), then AtomicInteger won't work", "label": {"api": {"AtomicInteger": [[191, 203]]}}}, {"text": "From https://docs.oracle.com/javase/7/docs/api/java/io/Writer.html and https://docs.oracle.com/javase/7/docs/api/java/io/FilterWriter.html, I find that FilterWriter is an abstract class, which extends Writer and has no extra mothods", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/Writer.html": [[5, 65]], "https://docs.oracle.com/javase/7/docs/api/java/io/FilterWriter.html": [[71, 137]]}}}, {"text": "Since your input dir String is UNC type, i think you should use Java's URI", "label": {"api": {"URI": [[71, 73]]}}}, {"text": "Use a BitSet, for the final AND functionality", "label": {"api": {"BitSet": [[6, 11]]}}}, {"text": "But you can use an IntSupplier, which is a functional interface representing a function supplying an int value", "label": {"api": {"IntSupplier": [[19, 29]]}}}, {"text": "Its functional method getAsInt is used to return the value", "label": {"api": {"getAsInt": [[22, 29]]}}}, {"text": "Additionally, if you don't want to return a primitive but an object MyObject, you can use the Supplier<MyObject> functional interface (or Callable<MyObject> if the method to call can throw a checked exception)", "label": {"api": {"Supplier<MyObject>": [[94, 111]], "Callable<MyObject>": [[138, 155]]}}}, {"text": "As such, a variable declared with the type Pesti can only be used to call ud() or any method from the class Object (Pesti's implicit superclass)", "label": {"api": {"Object": [[108, 113]]}}}, {"text": "I strongly recommend using the @Override annotation where appropriate to make your code more readable and to avoid mistakes like typos when trying to override a method", "label": {"api": {"@Override": [[31, 39]]}}}, {"text": "The o format specifier indicates that an integral value should be formatted in octal", "label": {"api": {"o format specifier": [[4, 21]]}}}, {"text": "If you want your parent to wait until all tasks completed, you can use a CountDownLatch", "label": {"api": {"CountDownLatch": [[73, 86]]}}}, {"text": "Causes the current thread to wait until the latch has counted down to zero, unless the thread is interrupted", "label": {"api": {"interrupted": [[97, 107]]}}}, {"text": "As you can see from the documentation for java.util.regex.Pattern, octal escapes have to start with \\0, but can have up to three digits after that", "label": {"api": {"the documentation for java.util.regex.Pattern": [[20, 64]]}}}, {"text": "You can look up T's methods and fields, and also create new instances by calling newInstance method", "label": {"api": {"newInstance": [[81, 91]]}}}, {"text": "As an alternative (if modifications are rare) use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[50, 69]]}}}, {"text": "Create custom ListCells in a cellFactory you use with the ComboBox and use it to modify the Cell's style based on the item it contains", "label": {"api": {"cellFactory": [[29, 39]]}}}, {"text": "It would be easier if you used a ButtonGroup", "label": {"api": {"ButtonGroup": [[33, 43]]}}}, {"text": "See How to Use the ButtonGroup Component for details", "label": {"api": {"ButtonGroup": [[19, 29]]}}}, {"text": "However, you can achieve this by using a Semaphore", "label": {"api": {"Semaphore": [[41, 49]]}}}, {"text": "I recommend exploring java.util.concurrent which is available since Java 5", "label": {"api": {"java.util.concurrent": [[22, 41]]}}}, {"text": "If you use the ProcessBuilder API instead of plain Runtime.exec(), then you can redirect Output and Error streams, including redirecting them to the same stream", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "If you cannot remove the object from the List, the only way I can think about to handle this would be wrapping your Objects into a WeakReference", "label": {"api": {"WeakReference": [[131, 143]]}}}, {"text": "One can use WeakReferences to avoid this; but of course, that requires that some piece of code would be pushing such WeakReference objects into the list initially", "label": {"api": {"WeakReferences": [[12, 25]]}}}, {"text": "The method ArrayList.remove(int index) returns the removed object", "label": {"api": {"ArrayList.remove(int index)": [[11, 37]]}}}, {"text": "You can try Pattern.quote(String) as next", "label": {"api": {"Pattern.quote(String)": [[12, 32]]}}}, {"text": "Implication of this is that you may need some kind of semaphore to limit concurrent image processing", "label": {"api": {"semaphore": [[54, 62]]}}}, {"text": "You can use LSResourceResolver to resolve the schema dependencies", "label": {"api": {"LSResourceResolver": [[12, 29]]}}}, {"text": "If you take a look at the ActionListener interface method detail, you will notice that the method actionPerformed take an ActionEvent as a parameter", "label": {"api": {"ActionListener": [[26, 39]]}}}, {"text": "It seems that your compareTo method violates the common contract that requires sgn(x.compareTo(y))to be equal to -sgn(y.compareTo(x))", "label": {"api": {"contract": [[56, 63]]}}}, {"text": "As getFooB() returns an instance of Optional<FooB>, to get the corresponding value of getA(), you need to use the map method as next", "label": {"api": {"map": [[114, 116]]}}}, {"text": "At best, with the help of some javadocs (HttpServletRequest and Principal), the expression could be", "label": {"api": {"HttpServletRequest": [[41, 58]], "Principal": [[64, 72]]}}}, {"text": "But a Principal is not the exact equivalent of a user", "label": {"api": {"Principal": [[6, 14]]}}}, {"text": "With a FilenameFilter it will be", "label": {"api": {"FilenameFilter": [[7, 20]]}}}, {"text": "Note that since your max method will likely just iterate the collection once, you can even change parameter type to Iterable, and everything will still work correctly", "label": {"api": {"Iterable": [[116, 123]]}}}, {"text": "This will allow you to find max value for non-collection iterables, such as java.nio.file.Path to find the last file (lexicographically) in a folder (if that makes sense)", "label": {"api": {"java.nio.file.Path": [[76, 93]]}}}, {"text": "Adding RenderingHints, seen here, makes the drawing smother", "label": {"api": {"RenderingHints": [[7, 20]]}}}, {"text": "Use a Pattern with groups to get the relevant parts of the string", "label": {"api": {"Pattern": [[6, 12]]}}}, {"text": "So I consulted the TextAttribute#UNDERLINE documentation", "label": {"api": {"TextAttribute#UNDERLINE documentation": [[19, 55]]}}}, {"text": "The constant value UNDERLINE_ON is provided", "label": {"api": {"UNDERLINE_ON": [[19, 30]]}}}, {"text": "If your curious about the benefits of using ListIterator over Iterator, then the ListIterator documentation provides more insight", "label": {"api": {"ListIterator documentation": [[81, 106]]}}}, {"text": "Use setMaxWidth on the individual controls and call setFillWidth(true) on the VBox itself", "label": {"api": {"setFillWidth(true)": [[52, 69]]}}}, {"text": "For this kind of need, a Scanner is not really suitable, you should use a BufferedReader and String.replace(char, char) as next", "label": {"api": {"String.replace(char, char)": [[93, 118]]}}}, {"text": "TableGroup is conceptually similar to a ButtonGroup, seen here and here", "label": {"api": {"ButtonGroup": [[40, 50]]}}}, {"text": "The reason the entire program appears to stop is that a program doesn't terminate if there are other active threads (unless those threads are daemon threads, which these aren't)", "label": {"api": {"daemon threads": [[142, 155]]}}}, {"text": "Concurrency in JavaFX, javafx.concurrent.Task and Platform.runLater", "label": {"api": {"javafx.concurrent.Task": [[23, 44]], "Platform.runLater": [[50, 66]]}}}, {"text": "Once all calculations are done, you can make a Platform.runLater call to update the UI based upon the updated calculations", "label": {"api": {"Platform.runLater": [[47, 63]]}}}, {"text": "You might want to try just running the calculations in their own task and invoking Platform.runLater when they are done before you attempt the additional complexity of adding something like fork/join", "label": {"api": {"Platform.runLater": [[83, 99]]}}}, {"text": "If you wish, you can try the Task with Platform.runLater call approach as outlined above instead", "label": {"api": {"Platform.runLater": [[39, 55]]}}}, {"text": "Documentation for charAt from Oracle", "label": {"api": {"charAt": [[18, 23]]}}}, {"text": "Since CDI 1.1, you can use CDI.current()", "label": {"api": {"CDI.current()": [[27, 39]], "CDI": [[6, 8], [27, 29]]}}}, {"text": "It returns the CDI instance that provides access to the current container", "label": {"api": {"CDI": [[15, 17]]}}}, {"text": "You can select a value through a multi-level hierarchy using Bindings.select", "label": {"api": {"Bindings.select": [[61, 75]]}}}, {"text": "If you want a collection, ordered by ID, with fast access by ID, then a TreeMap is the best option", "label": {"api": {"TreeMap": [[72, 78]]}}}, {"text": "If you also want concurrent access, where you can iterate the list while it is being updated, then a ConcurrentSkipListMap is your best option", "label": {"api": {"ConcurrentSkipListMap": [[101, 121]]}}}, {"text": "You can save  a lot of code bloat by using a case insensitive TreeSet", "label": {"api": {"case insensitive": [[45, 60]], "TreeSet": [[62, 68]]}}}, {"text": "As part of HiDPI support, Java 9 introduced multi-resolution support via the java.awt.MultiResolutionImage interface and the java.awt.image.AbstractMultiResolutionImage et al classes", "label": {"api": {"java.awt.MultiResolutionImage": [[77, 105]], "java.awt.image.AbstractMultiResolutionImage": [[125, 167]]}}}, {"text": "You use a Queue, where you take the first value from the queue using poll()", "label": {"api": {"Queue": [[10, 14]], "poll()": [[69, 74]]}}}, {"text": "If you cannot use the value yet, you add it back to the end of the queue using add()", "label": {"api": {"add()": [[79, 83]]}}}, {"text": "You keep taking the head value until the Queue is empty, e.g", "label": {"api": {"Queue": [[41, 45]]}}}, {"text": "when poll() returns null", "label": {"api": {"poll()": [[5, 10]]}}}, {"text": "For your purpose, an ArrayDeque is likely your best option for Queue implementation, or a LinkedList if you prefer", "label": {"api": {"Queue": [[63, 67]], "ArrayDeque": [[21, 30]], "LinkedList": [[90, 99]]}}}, {"text": "The only solution would be to write your own function or use Math#addExact, as you said", "label": {"api": {"Math#addExact": [[61, 73]]}}}, {"text": "If by \"timestamp\" you meant a count of milliseconds since the epoch of 1970 UTC, construct an Instant", "label": {"api": {"construct an Instant": [[81, 100]]}}}, {"text": "If you meant you want to compare a pair of moments to see if the elapsed time is less than 3 hours, use a Duration", "label": {"api": {"Duration": [[106, 113]]}}}, {"text": "I thought that an XMLFilter put before the XInclude aware parser, where the XMLFilter takes care of correcting the namespace, could solve this problem (without having to edit files manually respectively without having a separate processing step that first creates intermediary files with the corrected namespace)", "label": {"api": {"XMLFilter": [[18, 26], [76, 84]]}}}, {"text": "So I wrote the following XMLFilter, extending the XMLFilterImpl that SAX provides", "label": {"api": {"XMLFilter": [[25, 33], [50, 58]]}}}, {"text": "You can just invoke skip(n) to skip the first n-th element from the stream", "label": {"api": {"skip(n)": [[20, 26]]}}}, {"text": "You can convert your map to a list of Map.Entry<K,V> objects", "label": {"api": {"Map.Entry<K,V>": [[38, 51]]}}}, {"text": "The easiest way to do this is to write a custom Comparator and sort your list via Collections.sort(...)", "label": {"api": {"Comparator": [[48, 57]], "Collections.sort(...)": [[82, 102]]}}}, {"text": "To ensure the filter will be executed before the resource matching, annotate your filter with @PreMatching", "label": {"api": {"@PreMatching": [[94, 105]]}}}, {"text": "Yes, there is a TreeMap class in JDK", "label": {"api": {"in JDK": [[30, 35]]}}}, {"text": "The method Files.readAllLines() assumes that the file you are reading is encoded in UTF-8", "label": {"api": {"Files.readAllLines()": [[11, 30]], "readAllLines": [[17, 28]]}}}, {"text": "Find out what character encoding is used, and use the other readAllLines method, that allows you to specify the character encoding", "label": {"api": {"readAllLines": [[60, 71]]}}}, {"text": "Instead you should open resource stream with Class.getResourceAsStream or ClassLoader.getResourceAsStream methods and read the content from that stream", "label": {"api": {"Class.getResourceAsStream": [[45, 69]], "ClassLoader.getResourceAsStream": [[74, 104]]}}}, {"text": "In essence because the class it inherits from (Container) has a function to add a Component at a given position in it's list of components (add(Component comp, int layer)), as well as a function to add a Component with any given argument (to be passed to the LayoutManager) (add(Component comp, Object constraint))", "label": {"api": {"add(Component comp, int layer)": [[140, 169]], "add(Component comp, Object constraint)": [[275, 312]]}}}, {"text": "For that, use ImageIO.write(RenderedImage,String,File)", "label": {"api": {"ImageIO.write(RenderedImage,String,File)": [[14, 53]]}}}, {"text": "Consider using a ByteArrayInputStream as follows", "label": {"api": {"ByteArrayInputStream": [[17, 36]]}}}, {"text": "Alternatively, consider using a BufferedInputStream instead of manually reading the entire resource into a large buffer first", "label": {"api": {"BufferedInputStream": [[32, 50]]}}}, {"text": "Try using ByteArrayInputStream and let us know how it goes", "label": {"api": {"ByteArrayInputStream": [[10, 29]]}}}, {"text": "If you need something that can be dynamically updated, there's also the more sophisticated Preferences library", "label": {"api": {"Preferences": [[91, 101]]}}}, {"text": "It is used mostly with GUI applications (notably, IntelliJ IDEA was storing its configuration using Preferences the last time I checked)", "label": {"api": {"Preferences": [[100, 110]]}}}, {"text": "There's also an attempt to revive this library that I made with a project called cross-preferences by integrating modern distributed config stores (such as zookeeper, etcd or consul) as backing stores for java.util.prefs.Preferences and providing a web console for preference management", "label": {"api": {"Preferences": [[221, 231]]}}}, {"text": "No, it is not possible to register a new CharSet, other than by implementing a CharSetProvider, and it can only be registered thru META-INF/services", "label": {"api": {"CharSetProvider": [[79, 93]]}}}, {"text": "You can use a CountDownLatch in the parent thread which will wait until the child finishes it's work and calls the countDown() method so that the parent thread may continue it's work", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "You can have multiple children and you can adjust the CountDownLatch's count value to be equal to them", "label": {"api": {"CountDownLatch": [[54, 67]]}}}, {"text": "You can use BigInteger", "label": {"api": {"BigInteger": [[12, 21]]}}}, {"text": "You only have to browse the API for the java.util.concurrent.atomic package", "label": {"api": {"API": [[28, 30]]}}}, {"text": "I am planning to use unmodifiableMap API from Collections class", "label": {"api": {"unmodifiableMap": [[21, 35]]}}}, {"text": "If my parent map gets modified frequently - 50K times per day(with both put and remove calls), does this unmodifiableMap API adds any additional overhead to performance", "label": {"api": {"unmodifiableMap": [[105, 119]]}}}, {"text": "Is there any possibility to validate StandardMultipartHttpServletRequest using standard @Valid annotation and custom Validator", "label": {"api": {"@Valid": [[88, 93]]}}}, {"text": "You could use a Hash Set instead, it is designed to not allow duplicates", "label": {"api": {"Hash Set": [[16, 23]]}}}, {"text": "I think the problem you are having here is that the equals method compares strings", "label": {"api": {"equals": [[52, 57]]}}}, {"text": "But the readLine method is returning a logical null and not a \"Null\" string", "label": {"api": {"readLine": [[8, 15]]}}}, {"text": "You can also demonstrate this using classes from java.util.concurrent", "label": {"api": {"java.util.concurrent": [[49, 68]]}}}, {"text": "Both wait for different conditions, hence, a BlockingQueue doesn't meet the uniform waiters requirement", "label": {"api": {"BlockingQueue": [[45, 57]]}}}, {"text": "On the other hand, a CountDownLatch meets the uniform waiters requirement, but doesn't meet the one-in, one-out requirement", "label": {"api": {"CountDownLatch": [[21, 34]]}}}, {"text": "Read the Javadoc", "label": {"api": {"Read the Javadoc": [[0, 15]]}}}, {"text": "A char is promoted to an int, which takes precedence over autoboxing, so remove(int) is called instead of remove(Object) you may have intuitively expect", "label": {"api": {"remove(int)": [[73, 83]], "remove(Object)": [[106, 119]]}}}, {"text": "You've fallen into one trap with the StringTokenizer class, the second parameter is read as a set of distinct characters to use as a delimiter, not as a string that must be present as a whole", "label": {"api": {"whole": [[186, 190]]}}}, {"text": "A whitespace is determined by invoking isWhitespace, which returns true for space but also tabs or line feeds, like you did in your question", "label": {"api": {"isWhitespace": [[39, 50]]}}}, {"text": "The character is inserted by leveraging the StringBuilder#insert method, which is more direct that taking 2 substrings and concatenating them", "label": {"api": {"StringBuilder#insert": [[44, 63]]}}}, {"text": "If you want to merge them into an independent List<Integer> you can use Stream::concat like", "label": {"api": {"Stream::concat": [[72, 85]]}}}, {"text": "This is related to how ForkJoinTask.fork is implemented, if the current thread comes from a ForkJoinPool it will use the same pool to submit the new tasks but if not it will use the common pool with the total amount of processors in your local machine and here when you create your pool with Executors.newCachedThreadPool(), the thread created by this pool is not recognized as coming from a ForkJoinPool such that it uses the common pool", "label": {"api": {"ForkJoinTask.fork": [[23, 39]]}}}, {"text": "Note that ByteBuffer.wrap is lightweight and does not create a new array;  it just provides a ByteBuffer instance that delegates its storage to the byte array given to the method", "label": {"api": {"ByteBuffer.wrap": [[10, 24]]}}}, {"text": "If you plan to use the entire byte array, you can just use the easier-to-read ByteBuffer.wrap(byteArray)", "label": {"api": {"ByteBuffer.wrap": [[78, 92]]}}}, {"text": "Sonar does its job of warning you that StringBuilder is preferable because it is faster", "label": {"api": {"because it is faster": [[67, 86]]}}}, {"text": "While atomic toolkit provides atomicity of operations", "label": {"api": {"atomic toolkit": [[6, 19]]}}}, {"text": "Why there is a need to introduce new layer of abstraction like atomic toolkit, instead of enhancing volatile keyword itself", "label": {"api": {"atomic toolkit": [[63, 76]]}}}, {"text": "Is there any specific cases which may be solved by atomic toolkit", "label": {"api": {"atomic toolkit": [[51, 64]]}}}, {"text": "Actually if you'll take closer look into Atomic* implemetations then you'll see that all of them holds volatile field with value", "label": {"api": {"Atomic*": [[41, 47]]}}}]