[{"text": "If you need a function to run, you can use either a lambda (Java 8+ only) or as @JonnyHenly pointed out, a Runnable", "label": {"api": {"Runnable": [[107, 114]]}}}, {"text": "One alternative is to use a ConcurrentHashMap which takes care of thread-safety for us", "label": {"api": {"ConcurrentHashMap": [[28, 44]]}}}, {"text": "tableToString.indexOf(largestDigit) fails because that is a call to String.indexOf(int ch), but the parameter the not a char value but an int number", "label": {"api": {"String.indexOf(int ch)": [[68, 89]]}}}, {"text": "You can usually do this with a ServletContextListener", "label": {"api": {"ServletContextListener": [[31, 52]]}}}, {"text": "If you want to modify the lists in-place (not creating new lists), you can use Collection.removeIf method", "label": {"api": {"Collection.removeIf": [[79, 97]]}}}, {"text": "Based on the Map documentation, and on your comment under your question, you're not actually getting an exception from a.get(key)", "label": {"api": {"Map documentation": [[13, 29]]}}}, {"text": "Scanner implements AutoCloseable, so you can use use the try-with-resources here", "label": {"api": {"AutoCloseable": [[19, 31]]}}}, {"text": "I personnaly would use a Timer and a TimerTask which seem to fulfill your requirements and are already included in the JDK", "label": {"api": {"Timer": [[25, 29], [37, 41]], "TimerTask": [[37, 45]]}}}, {"text": "You can use an SQL specific java Array", "label": {"api": {"Array": [[33, 37]]}}}, {"text": "You can use a HttpURLConnection; Example", "label": {"api": {"HttpURLConnection": [[14, 30]]}}}, {"text": "Not tested, but the status bar's leftItems and rightItems are implemented as HBoxs, so you can use HBox style properties for them", "label": {"api": {"HBox style properties": [[99, 119]]}}}, {"text": "First, you need to map the action for the button to the method you defined using the onAction property of the button", "label": {"api": {"onAction": [[85, 92]]}}}, {"text": "The handler method either needs to take a parameter matching the type of event that is generated (ActionEvent for onAction), or no parameters", "label": {"api": {"onAction": [[114, 121]]}}}, {"text": "This is what the documentation says about Stream.generate(Supplier)", "label": {"api": {"Stream.generate(Supplier)": [[42, 66]]}}}, {"text": "If you don't know the size of your array, consider using a List instead", "label": {"api": {"List": [[59, 62]]}}}, {"text": "If you use a JDK 6+ version, you could use ThreadMXBean", "label": {"api": {"ThreadMXBean": [[43, 54]]}}}, {"text": "To solve your problem without using synchronized lists you could make a List[CompletableFuture] and at the end call CompletableFuture.allOf", "label": {"api": {"CompletableFuture.allOf": [[116, 138]]}}}, {"text": "In CompletableFuture.allOf you can make a new List without null values and sort that list", "label": {"api": {"CompletableFuture.allOf": [[3, 25]]}}}, {"text": "You can use SwingWorker to run it asynchronously so that it continues running the GUI while it runs the action", "label": {"api": {"SwingWorker": [[12, 22]]}}}, {"text": "Working with Future is definitely on the right path", "label": {"api": {"Future": [[13, 18]]}}}, {"text": "The fact that Spring 4 offers an AsyncRestTemplate that returns a Future is exactly what you want to use", "label": {"api": {"Future": [[66, 71]]}}}, {"text": "According to the java.time documentation, java.time should be able to present a LocalDateTime or LocalTime with nanoseconds precision, but when I run LocalDateTime.now() and print out, it only shows 3 digits instead of 9", "label": {"api": {"java.time documentation": [[17, 39]]}}}, {"text": "If you want additional digits to show up, even if they are zeroes, you will need to create a DateTimeFormatter and use that instead", "label": {"api": {"DateTimeFormatter": [[93, 109]]}}}, {"text": "Further, LocalDateTime.now() uses the system default Clock which is only guaranteed to have millisecond precision, but can use a higher resolution clock if one is available", "label": {"api": {"Clock": [[53, 57]]}}}, {"text": "The java.time classes use standard ISO 8601 formats by default when parsing or generating String representations of date-time values", "label": {"api": {"java.time": [[4, 12]]}}}, {"text": "But when I try to parse an Instant from an input string containing a comma, a DateTimeParseException is thrown", "label": {"api": {"parse": [[18, 22]], "Instant": [[27, 33]], "DateTimeParseException": [[78, 99]]}}}, {"text": "How do I parse such standard strings containing a comma", "label": {"api": {"parse": [[9, 13]]}}}, {"text": "There is a method from the node class that you can use, called addEventFilters", "label": {"api": {"addEventFilters": [[63, 77]]}}}, {"text": "Depending on your definition of built in method you should use a Map for that task", "label": {"api": {"Map": [[65, 67]]}}}, {"text": "You can create your own custom ObservableList by extending ModifiableObservableListBase as stated by this comment and shown in this answer", "label": {"api": {"ModifiableObservableListBase": [[59, 86]]}}}, {"text": "You are misusing awaitTermination", "label": {"api": {"awaitTermination": [[17, 32]]}}}, {"text": "To achieve your goal I'd suggest to use CountDownLatch (or latch that support increments like this one) to determine exact moment when there is no tasks left so you safely can do shutdown", "label": {"api": {"CountDownLatch": [[40, 53]]}}}, {"text": "Instead of using a CountDownLatch use a Phaser", "label": {"api": {"Phaser": [[40, 45]]}}}, {"text": "since it is a sorted map on the keys, determining the right threshold comment for a given value is simply a matter of getting the floorEntry for that value", "label": {"api": {"floorEntry": [[130, 139]]}}}, {"text": "Similarly, there is ceilingEntry to retrieve the entry having a key just after the one given", "label": {"api": {"ceilingEntry": [[20, 31]]}}}, {"text": "To handle that case, you need to check whether floorEntry returns null and handle it accordingly by returning a default value", "label": {"api": {"floorEntry": [[47, 56]]}}}, {"text": "Tried to get it from documentation (http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/UriInfo.html) but didn't get the difference properly", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/UriInfo.html": [[36, 100]]}}}, {"text": "I have a TableView that is populated with objects from the model class Foo", "label": {"api": {"TableView": [[9, 17]]}}}, {"text": "You can also a use Lock instead of using synchronized on an object", "label": {"api": {"Lock": [[19, 22]]}}}, {"text": "Since you are using SpringApplicationContext, you can create a ReentrantLock and add it to your context and then access it the same you are accessing the IDDAO instance", "label": {"api": {"Lock": [[72, 75]]}}}, {"text": "I have a TableView populated with data from the model class Foo", "label": {"api": {"TableView": [[9, 17]]}}}, {"text": "Namely, round to closest number with only two fractional digits, with ties being rounded to the even neighbor", "label": {"api": {"even neighbor": [[96, 108]]}}}, {"text": "use a class like StringBuilder in order to create a single string that \"lists\" all the nodes in your list", "label": {"api": {"StringBuilder": [[17, 29]]}}}, {"text": "You can use the @FunctionalInterface annotation to have the compiler enforce this for an interface (but it is not necessary, the interface can be used in lambdas even without it)", "label": {"api": {"@FunctionalInterface": [[16, 35]]}}}, {"text": "is there a another utility capable of both formatting strings and parsing strings (using the same object!) that can achieve this", "label": {"api": {"formatting": [[43, 52]], "parsing": [[66, 72]]}}}, {"text": "You have no way of knowing which text field will be the tenth, so what you likely want to do is add a change listener to each button, and within the listener check if 10 fields are non-empty", "label": {"api": {"change listener": [[102, 116]]}}}, {"text": "Use better concurrency constructs like ReentrantLock etc", "label": {"api": {"ReentrantLock": [[39, 51]]}}}, {"text": "In order to avoid this, you need to register a custom java.security.Provider that contains a different implementation of SecureRandomSpi", "label": {"api": {"java.security.Provider": [[54, 75]], "SecureRandomSpi": [[121, 135]]}}}, {"text": "Fortunately, JDK for Windows already has a suitable SecureRandomSpi implementation that relies on Microsoft Crypto API", "label": {"api": {"SecureRandomSpi": [[52, 66]]}}}, {"text": "Then you can call the Collections#shuffle Method and shuffle your Card-Deck with that", "label": {"api": {"Collections#shuffle": [[22, 40]]}}}, {"text": "Because array.length gives you number of bytes, you want to use Integer.BYTES (bytes per integer) not Integer.SIZE (bits per integer) when allocating for the buffer", "label": {"api": {"Integer.BYTES": [[64, 76]], "Integer.SIZE": [[102, 113]]}}}, {"text": "Maybe a java.util.concurrent.CountDownLatch may solve your problem like this", "label": {"api": {"java.util.concurrent.CountDownLatch": [[8, 42]]}}}, {"text": "Agents can be injected with HotSpot Attach API", "label": {"api": {"HotSpot Attach API": [[28, 45]]}}}, {"text": "To ensure the image was loaded before executing the database code, invoke Console.SetZones(newZones); inside EventQueue.invokeLater()", "label": {"api": {"EventQueue.invokeLater()": [[109, 132]]}}}, {"text": "If isRenovated() returns null, you should call PreparedStatement.setNull()", "label": {"api": {"PreparedStatement.setNull()": [[47, 73]]}}}, {"text": "quickly exceeds Integer.MAX_VALUE and overflows to a negative number", "label": {"api": {"Integer.MAX_VALUE": [[16, 32]]}}}, {"text": "You can use BigDecimal for your calcualtions", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "Try something like the following using StringBuilder.setLength", "label": {"api": {"StringBuilder.setLength": [[39, 61]]}}}, {"text": "Consider using a Scanner like you do in the client code or alternatively a BufferedReader", "label": {"api": {"Scanner": [[17, 23]], "BufferedReader": [[75, 88]]}}}, {"text": "Use getResultList() instead", "label": {"api": {"getResultList()": [[4, 18]]}}}, {"text": "You can use Stream::allMatch", "label": {"api": {"Stream::allMatch": [[12, 27]]}}}, {"text": "See the javaDocs of BufferedReader", "label": {"api": {"BufferedReader": [[20, 33]]}}}, {"text": "If you obtain a reference to the pool, or create and supply your own, you can intercept the appropriate method in https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html to set the name to your taste", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.ForkJoinWorkerThreadFactory.html": [[114, 221]]}}}, {"text": "All you need is to make it accessible", "label": {"api": {"accessible": [[27, 36]]}}}, {"text": "How, lets look at Executor.invokeAll, the signature is", "label": {"api": {"Executor.invokeAll": [[18, 35]]}}}, {"text": "The use case is already described by the interface CompletionStage<T>", "label": {"api": {"interface CompletionStage<T>": [[41, 68]]}}}, {"text": "it knew how to handle variables declared as ReentrantLock, but not how to handle variables declared as its interface Lock", "label": {"api": {"ReentrantLock": [[44, 56]], "Lock": [[53, 56], [117, 120]]}}}, {"text": "your main method needs to be annotated as @MayReleaseLocks", "label": {"api": {"Lock": [[53, 56]]}}}, {"text": "I think that Scanner should deal with this, although you could give us more information", "label": {"api": {"Scanner": [[13, 19]]}}}, {"text": "To overcome that limitation, Java NIO's Channels can be used, see e.g https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#force(boolean)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#force(boolean)": [[70, 160]]}}}, {"text": "You could collect all objects in a WeakHashMap and regularly run a clean-up job taking care of removing non-existent objects from you actual cache", "label": {"api": {"WeakHashMap": [[35, 45]]}}}, {"text": "You should be able to do this by creating an appropriate Collector, using the Collector.of static factory method", "label": {"api": {"Collector": [[57, 65], [78, 86]]}}}, {"text": "The Thread constructor takes Runnable and this is what you want to execute repeatedly", "label": {"api": {"Runnable": [[29, 36]]}}}, {"text": "Therefore you don't need Supplier as parameter type for loop, but Runnable", "label": {"api": {"Runnable": [[66, 73]]}}}, {"text": "Note that a ScheduledExecutorService provides the kind of scheduling you're implementing here", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "You can use the DayOfWeek enum to get a day by its number", "label": {"api": {"DayOfWeek": [[16, 24]]}}}, {"text": "Since no character encoding is specified in the code, the default character encoding of the system will be used (see API docs of the PrintWriter constructor) and we don't know what that is on your system", "label": {"api": {"PrintWriter constructor": [[133, 155]]}}}, {"text": "We have ZipFile class", "label": {"api": {"ZipFile": [[8, 14]]}}}, {"text": "It has entries method that returns enumeration of entries", "label": {"api": {"entries": [[7, 13], [50, 56]]}}}, {"text": "Now we can find entry or use getEntry method if we know name and path to file in zip", "label": {"api": {"getEntry": [[29, 36]]}}}, {"text": "Then, last step, we can use getInputStream method to read only entry that we want", "label": {"api": {"getInputStream": [[28, 41]]}}}, {"text": "In Java 8, you can use the DoubleSupplier interface to get a double value from an object", "label": {"api": {"DoubleSupplier": [[27, 40]]}}}, {"text": "Clojure already has a printf function that does the same thing as PrintStream.format, except that it prints specifically to *out*", "label": {"api": {"PrintStream.format": [[66, 83]]}}}, {"text": "You have to convert your byte[] to Base64 string, see java.util.Base64.Encoder.encodeToString(byte[] src) method, and display that string instead of mybyte array", "label": {"api": {"java.util.Base64.Encoder.encodeToString(byte[] src)": [[54, 104]]}}}, {"text": "You should catch SQLIntegrityViolationException, not just Exception", "label": {"api": {"SQLIntegrityViolationException": [[17, 46]]}}}, {"text": "At the very least you should catch SQLException and examine the SQL error code, although that will be vendor-specific", "label": {"api": {"SQL error code": [[64, 77]]}}}, {"text": "Seems quite easy using File::lastModified() over a folder and loop into File::listFiles()", "label": {"api": {"File::lastModified()": [[23, 42]]}}}, {"text": "Or you can use java.util.Optional from Java 8", "label": {"api": {"java.util.Optional": [[15, 32]]}}}, {"text": "Optional is usually used in java.util.stream lambdas for \"functional-style operations\"", "label": {"api": {"java.util.stream": [[28, 43]]}}}, {"text": "ListSelectionModel.MULTIPLE_INTERVAL_SELECTION is also available to JList, where you can use HORIZONTAL_WRAP to arrange for arbitrary cell selection  as shown here", "label": {"api": {"ListSelectionModel.MULTIPLE_INTERVAL_SELECTION": [[0, 45]]}}}, {"text": "If you’re running in a Java EE environment, you should use a TimerService or the @Schedule annotation", "label": {"api": {"TimerService": [[61, 72]], "@Schedule": [[81, 89]]}}}, {"text": "Since SQL databases don't have a type compatible with MonthDay, use a VARCHAR columns, and simply use toString() and MonthDay.parse()", "label": {"api": {"MonthDay": [[54, 61], [117, 124]], "toString()": [[102, 111]], "MonthDay.parse()": [[117, 132]]}}}, {"text": "Or use a custom DateTimeFormatter, if you don't like the --12-03 format", "label": {"api": {"DateTimeFormatter": [[16, 32]]}}}, {"text": "When you create your consumer you can specify a message selector to exclude messages with your producer's unique ID", "label": {"api": {"create your consumer": [[9, 28]]}}}, {"text": "Your producer can set its ID in a message property when creating its messages", "label": {"api": {"message property": [[34, 49]]}}}, {"text": "Note that Encoder is thread-safe, so you can save a copy in a private static final field", "label": {"api": {"Encoder is thread-safe": [[10, 31]]}}}, {"text": "There are classes in the standard Java library which are better suited (and specifically made) for this purpose; have a look at the package java.util.concurrent.locks", "label": {"api": {"java.util.concurrent.locks": [[140, 165]]}}}, {"text": "Because replaceAll expects a string defining a regular expression, and $ means \"end of line\" in regular expressions", "label": {"api": {"replaceAll": [[8, 17]]}}}, {"text": "For complex strings that you want to replace verbatim, Pattern.quote is useful", "label": {"api": {"Pattern.quote": [[55, 67]]}}}, {"text": "You don't need it here because your replacement is \"\", but if your replacement may have special characters in it (like backslashes or dollar signs), use Matcher.quoteReplacement on the replacement string as well", "label": {"api": {"Matcher.quoteReplacement": [[153, 176]]}}}, {"text": "You have to use Pattern to define a regular expression and a Matcher to find it in the text", "label": {"api": {"Pattern": [[16, 22]], "Matcher": [[61, 67]]}}}, {"text": "In order to find dates, percentages or whatever, you have to compile a Pattern with the Regular Expression that fits to your requirements, and apply it", "label": {"api": {"Pattern": [[71, 77]]}}}, {"text": "By using Pattern and Matcher you can go further than just find your value, and you can know the start position in the string, the end, the number of occurrences and many other helpful things", "label": {"api": {"Pattern": [[9, 15]], "Matcher": [[21, 27]]}}}, {"text": "Here you can find Pattern and Matcher official documentation", "label": {"api": {"Pattern": [[18, 24]], "Matcher": [[30, 36]]}}}, {"text": "The above pattern is actually taken from SimpleDateFormat - Examples Section", "label": {"api": {"SimpleDateFormat": [[41, 56]]}}}, {"text": "As said in the comments, you should use a Map", "label": {"api": {"Map": [[42, 44]]}}}, {"text": "If it is an option to use Java 8, you can use Optional as follows", "label": {"api": {"Optional": [[46, 53]]}}}, {"text": "Use the Appendable abstraction to ensure the generateTag (and likewise processMethod, if you wish) have no dependency to BufferedWriter", "label": {"api": {"Appendable": [[8, 17]]}}}, {"text": "Still there are APIs allowing to use CharSequence directly", "label": {"api": {"APIs allowing to use CharSequence directly": [[16, 57]]}}}, {"text": "Assuming your list in an array of strings, you could simply loop over the list and test each string with Pattern and Matcher from java.util.regx", "label": {"api": {"java.util.regx": [[130, 143]]}}}, {"text": "Its Javadoc doesn't say anything about thread-safety; so just going from the Javadoc, I can't assume that it's safe to expose the resulting map to other threads without taking some special steps of my own to gain thread-safety", "label": {"api": {"Its Javadoc": [[0, 10]]}}}, {"text": "This is explained in the documentation for Object#clone()", "label": {"api": {"documentation for Object#clone()": [[25, 56]]}}}, {"text": "A better fix yet, is probably to use the RescaleOp, which is built to do brightness adjustments on BufferedImages", "label": {"api": {"RescaleOp": [[41, 49]]}}}, {"text": "yes the Observable API shows that public void notifyObservers(Object arg) has an overload that accepts an Object parameter", "label": {"api": {"Observable API": [[8, 21]]}}}, {"text": "You should ckeck out Map::getOrDefault and Map::computeIfAbsent (added in Java 8); those do pretty much exactly what your function is supposed to do", "label": {"api": {"Map::getOrDefault": [[21, 37]], "Map::computeIfAbsent": [[43, 62]]}}}, {"text": "It's because you imported android.icu.text.SimpleDateFormat instead of java.text.SimpleDateFormat", "label": {"api": {"java.text.SimpleDateFormat": [[71, 96]]}}}, {"text": "From documentation of AbstractCollection", "label": {"api": {"documentation of AbstractCollection": [[5, 39]]}}}, {"text": "You don't need to write your own Comparator", "label": {"api": {"Comparator": [[33, 42]]}}}, {"text": "You can omit the String.CASE_INSENSITIVE_ORDER if the ordering should be case-sensitive", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[17, 45]]}}}, {"text": "Or if you need locale-dependent ordering, take a look at Collator", "label": {"api": {"Collator": [[57, 64]]}}}, {"text": "java.util.ArrayList is provided by the JRE, it is in rt.jar (and you can see the source)", "label": {"api": {"java.util.ArrayList": [[0, 18]]}}}, {"text": "Strings are immutable in Java, replaceAll doesn't modify the string in-place, it returns a new one", "label": {"api": {"replaceAll": [[31, 40]]}}}, {"text": "You should refer to the SimpleDateFormat doc for the formats you can specify", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "The relevant lines from the Comparator javadoc", "label": {"api": {"the Comparator javadoc": [[24, 45]]}}}, {"text": "Add instances of java.util.Date to your TableModel, and return the correct type in your implementation of getColumnClass(), as shown here", "label": {"api": {"java.util.Date": [[17, 30]]}}}, {"text": "As stated in the Java 8 documentation this method should throw an IOException \"if the input stream has been closed, or if some other I/O error occurs\"", "label": {"api": {"Java 8 documentation": [[17, 36]]}}}, {"text": "While SwingWorker does implement the Runnable interface, per its API section on the doInBackground() method", "label": {"api": {"API": [[65, 67]]}}}, {"text": "If you're using Java 8, you can eliminate this middle ArrayList by using lines() and then mapping to an int, then collecting the values into an array", "label": {"api": {"lines()": [[73, 79]]}}}, {"text": "So, pre-java 8, you would normally pass some instance of Runnable or using ExecutorService to pass Callables", "label": {"api": {"Runnable": [[57, 64]], "Callables": [[99, 107]]}}}, {"text": "Simply by using join", "label": {"api": {"join": [[16, 19]]}}}, {"text": "If your input contains a comma, you can first iterate on the arraylist and add quotes to each element, and only then use join", "label": {"api": {"join": [[121, 124]]}}}, {"text": "I'm not sure why it was working in Java 6, as [a method with that signature previously existed in Java 6](https://docs.oracle.com/javase/6/docs/api/java/lang/Enum.html#valueOf(java.lang.Class, java.lang.String)) (and has since Java 5)", "label": {"api": {"https://docs.oracle.com/javase/6/docs/api/java/lang/Enum.html#valueOf(java.lang.Class": [[106, 190]]}}}, {"text": "If the userData property is already in use, you could also use the properties map of Node to store a reference to the TextField instead", "label": {"api": {"properties map of Node": [[67, 88]]}}}, {"text": "You could use the constructor that accepts r,g,b and alpha parameters", "label": {"api": {"the constructor that accepts r,g,b and alpha parameters": [[14, 68]]}}}, {"text": "Why does Set.add() not return the object you are trying to add, or an object that is equal to the one you are trying to add if it is already in the set", "label": {"api": {"Set.add()": [[9, 17]]}}}, {"text": "I know I can use Map.getOrDefault, but then I need to specify the two parameters of the Map", "label": {"api": {"Map.getOrDefault": [[17, 32]]}}}, {"text": "If you strive for brevity rather than performance, there are Expression and Statement since Java 1.4", "label": {"api": {"Expression": [[61, 70]], "Statement": [[76, 84]]}}}, {"text": "Potentially more efficient is to use the LambdaMetafactory introduced in Java 8, which is the back-end of the lambda expressions and method references at runtime", "label": {"api": {"LambdaMetafactory": [[41, 57]]}}}, {"text": "If MyObject is mutable, the ideal solution would be a mutable reduction using collect()", "label": {"api": {"mutable reduction": [[54, 70]]}}}, {"text": "For AES encryption see the Java docs for javax.crypto", "label": {"api": {"javax.crypto": [[41, 52]]}}}, {"text": "Consider defining the cascade type for your collection", "label": {"api": {"cascade type": [[22, 33]]}}}, {"text": "This is my utility method to check if a replacement string is valid", "label": {"api": {"replacement string": [[40, 57]]}}}, {"text": "If this method throws, either the regex or the replacement string is invalid", "label": {"api": {"replacement string": [[47, 64]]}}}, {"text": "See for example Year.parse() and the Year section here", "label": {"api": {"Year.parse()": [[16, 27]]}}}, {"text": "Only arrays of primitives and Objects which implement the Comparable interface can be sorted", "label": {"api": {"Comparable": [[58, 67]]}}}, {"text": "@Holger correctly points out in the comments below that one of the overloaded static methods is indeed Arrays.sort(Object[]) but the docs explicitly state", "label": {"api": {"Arrays.sort(Object[])": [[103, 123]]}}}, {"text": "All elements in the array must implement the Comparable interface", "label": {"api": {"Comparable": [[45, 54]]}}}, {"text": "So it doesn't work for Objects that don't implement Comparable or one of its subinterfaces", "label": {"api": {"Comparable": [[52, 61]]}}}, {"text": "Similarly, Collections is also Util class where utility methods are given", "label": {"api": {"Collections": [[11, 21]]}}}, {"text": "You need to use thread priority to achieve your goal", "label": {"api": {"thread priority": [[16, 30]]}}}, {"text": "The idea of weak reference is to allow earlier garbage collection", "label": {"api": {"weak reference": [[12, 25]]}}}, {"text": "The JavaFX documentation for Task has the answer", "label": {"api": {"Task": [[29, 32]]}}}, {"text": "Because the Task is designed for use with JavaFX GUI applications, it ensures that every change to its public properties, as well as change notifications for state, errors, and for event handlers, all occur on the main JavaFX application thread", "label": {"api": {"Task": [[12, 15]]}}}, {"text": "You can use ServletContext.getRealPath() to locate that file", "label": {"api": {"ServletContext.getRealPath()": [[12, 39]]}}}, {"text": "Use a single threaded executor to execute the print jobs", "label": {"api": {"single threaded executor": [[6, 29]]}}}, {"text": "the ctor wants an argument of type java.net.URL which you could probably create with something like new URL(BASEURL);  instead of just passing BASEURL to that constructor", "label": {"api": {"java.net.URL": [[35, 46]]}}}, {"text": "As yoshi pointed out, the JLabel fills the entire content pane, so clicking anywhere in the content pane results in mouse events for the label", "label": {"api": {"JLabel": [[26, 31]]}}}, {"text": "1) You could also use GridBagLayout, instead of FlowLayout, in case you want the JLabel centered in its parent component (both vertically and horizontally)", "label": {"api": {"JLabel": [[81, 86]], "GridBagLayout": [[22, 34]], "FlowLayout": [[48, 57]]}}}, {"text": "Use the BufferedImage.getRGB(int x, int y), BufferedImage.getColorModel() and ColorModel.getAlpha(int pixel) methods to determine the alpha value of the clicked pixel for each mouse event", "label": {"api": {"BufferedImage.getRGB(int x, int y)": [[8, 41]], "BufferedImage.getColorModel()": [[44, 72]], "ColorModel.getAlpha(int pixel)": [[78, 107]], "Image": [[16, 20], [52, 56]], "BufferedImage": [[8, 20], [44, 56]]}}}, {"text": "And instead of Image.getScaledInstance(...) to scale the image (which returns Image, but we need BufferedImage), use the solution provided here", "label": {"api": {"Image.getScaledInstance(...)": [[15, 42]], "Image": [[15, 19], [78, 82], [105, 109]], "BufferedImage": [[97, 109]]}}}, {"text": "Also change the reference bi from Image to BufferedImage", "label": {"api": {"Image": [[34, 38], [51, 55]], "BufferedImage": [[43, 55]]}}}, {"text": "And then the MouseListener of the label", "label": {"api": {"MouseListener": [[13, 25]]}}}, {"text": "3) For the scaling of the Image, you can determine the new size with the method collapseInside(...)", "label": {"api": {"Image": [[26, 30]]}}}, {"text": "a) Scaled Image's width will be less than or equal to container's size width (resultDim.width <= containerDim.width)", "label": {"api": {"Image": [[10, 14]]}}}, {"text": "c) Aspect ratio of the original Image size will be preserved in the new Image size (resultDim.width / resultDim.height == originalDim.width / originalDim.height)", "label": {"api": {"Image": [[32, 36], [72, 76]]}}}, {"text": "With Image.getScaledInstance(...) and the previous getScaledBufferedImage(...) the aspect ratio of the Image could change", "label": {"api": {"Image.getScaledInstance(...)": [[5, 32]], "Image": [[5, 9], [68, 72], [103, 107]], "BufferedImage": [[60, 72]]}}}, {"text": "So I edit the getScaledBufferedImage(...) to use collapseInside(...)", "label": {"api": {"Image": [[31, 35]], "BufferedImage": [[23, 35]]}}}, {"text": "Alternatively, you may also override the paintComponent(...) of JPanel and use Graphics.drawImage(...) to paint the Image bi to the JPanel like so", "label": {"api": {"Image": [[92, 96], [116, 120]], "paintComponent(...)": [[41, 59]], "JPanel": [[64, 69], [132, 137]], "Graphics.drawImage(...)": [[79, 101]]}}}, {"text": "Then add the MouseListener to the JPanel as is", "label": {"api": {"MouseListener": [[13, 25]], "JPanel": [[34, 39]]}}}, {"text": "1) Using JLayeredPanes", "label": {"api": {"JLayeredPane": [[9, 20]]}}}, {"text": "There is a tutorial explaining them, and I guessed they could probably have a method to obtain the order of the visible pane for a given Point, or something like that, but they don't", "label": {"api": {"Point": [[137, 141]]}}}, {"text": "2) Using Container.getComponentAt(Point) and Container.findComponentAt(Point) in the MouseListener, but (as I found out after testing) these methods don't \"see through\" non-opaque (+transparent) pixels", "label": {"api": {"MouseListener": [[85, 97]], "Point": [[34, 38], [71, 75]], "Container.getComponentAt(Point)": [[9, 39]], "Container.findComponentAt(Point)": [[45, 76]]}}}, {"text": "3) Searching for reshaping or translucency in JPanels (inspired by How to Create Translucent and Shaped Windows), but nothing found", "label": {"api": {"JPanel": [[46, 51]]}}}, {"text": "If you assume the class has a no-argument accessible constructor, you're basically a newInstance() call away", "label": {"api": {"newInstance()": [[85, 97]]}}}, {"text": "No need to write a custom ClassLoader in your case, URLClassLoader should be enough, you simply provide an array of URL as parameter (corresponding to the folders of classes or jar files to include) to its constructor and eventually the parent class loader (Thread.currentThread().getContextClassLoader() could be a good candidate)", "label": {"api": {"URLClassLoader": [[52, 65]]}}}, {"text": "As you intend to do hot deployment, make sure that you call close() on your URLClassLoader instance to properly release the resources", "label": {"api": {"URLClassLoader": [[76, 89]]}}}, {"text": "The PrintStream that System.out uses has an internal buffer, since writing to stdout is relatively expensive -- you wouldn't necessarily want to do it for each character", "label": {"api": {"PrintStream that System.out uses": [[4, 35]]}}}, {"text": "You can force a manual flush by invoking System.out.flush()", "label": {"api": {"System.out.flush()": [[41, 58]]}}}, {"text": "If you don't know where the object is serialized using java.io.Serializable you better add this interface to DTOs", "label": {"api": {"java.io.Serializable": [[55, 74]]}}}, {"text": "Use the Instrumentation API to manually append the dependencies before running your actual agent application", "label": {"api": {"Instrumentation API": [[8, 26]]}}}, {"text": "While extracting, if the ZipEntry is a file, it can be extracted in a straightforward way by using BufferedOutputStream.write()", "label": {"api": {"ZipEntry": [[25, 32]], "BufferedOutputStream": [[99, 118]]}}}, {"text": "However, when ZipEntry is a directory, you can't do that because there is no directory present", "label": {"api": {"ZipEntry": [[14, 21]]}}}, {"text": "It looks like your code is using Float.parseFloat", "label": {"api": {"Float.parseFloat": [[33, 48]]}}}, {"text": "Returns a new float initialized to the value represented by the specified String, as performed by the valueOf method of class Float", "label": {"api": {"valueOf": [[102, 108]]}}}, {"text": "And valueOf has a detailed grammar, and includes this", "label": {"api": {"valueOf": [[4, 10]]}}}, {"text": "You can only create a new array and copy the contents in; you can do this conveniently using Arrays.copyOf (*)", "label": {"api": {"Arrays.copyOf": [[93, 105]]}}}, {"text": "However, as pointed out by @KevinEsche in his comment on the question, you might find an ArrayList (or maybe some other kind of List) more convenient to use", "label": {"api": {"ArrayList": [[89, 97]]}}}, {"text": "(*) The gotcha here is that Arrays.copyOf performs a shallow copy of arr, so any changes to the elements of arr[i] will be reflected in the elements of newArr[i] (for 0 <= i < arr.length)", "label": {"api": {"Arrays.copyOf": [[28, 40]]}}}, {"text": "Should you need it, you can make a deep copy by looping over the elements of arr, calling Arrays.copyOf on each", "label": {"api": {"Arrays.copyOf": [[90, 102]]}}}, {"text": "As described in the Javadoc of Integer.valueOf, values from -128 to 127 (at least) are cached", "label": {"api": {"the Javadoc of Integer.valueOf": [[16, 45]]}}}, {"text": "It entirely depends on the runtime retention policy of the annotation", "label": {"api": {"the runtime retention policy of the annotation": [[23, 68]]}}}, {"text": "There is a clone() method of the Object class", "label": {"api": {"clone()": [[11, 17]]}}}, {"text": "To be able to use it, you need to make sure you class implements Cloneable", "label": {"api": {"Cloneable": [[65, 73]]}}}, {"text": "It uses the fact that a String is a CharSequence, and that you can obtain an IntStream of either the characters or code points in it; this solution uses chars", "label": {"api": {"String": [[24, 29]], "CharSequence": [[36, 47]], "IntStream": [[77, 85]], "chars": [[153, 157]]}}}, {"text": "You can use the java.time classes built into Java 8 and later", "label": {"api": {"java.time": [[16, 24]]}}}, {"text": "More precisely you describe the kind of ExecutorService that Executors.newSingleThreadExecutor() returns", "label": {"api": {"Executors.newSingleThreadExecutor()": [[61, 95]]}}}, {"text": "Indeed matcher.find() will return the next subsequence in the input that matches with the pattern so if you call it only once, you will get only the first subsequence which is 07 here", "label": {"api": {"matcher.find()": [[7, 20]]}}}, {"text": "For example, you can use a Semaphore object to signal a thread when to stop and when to continue", "label": {"api": {"Semaphore": [[27, 35]]}}}, {"text": "I recommend you to read carefully the public documentation instead", "label": {"api": {"public documentation": [[38, 57]]}}}, {"text": "You'll see that getResourceAsStream search files upon the directory/jar file were your class has been loaded from", "label": {"api": {"getResource": [[16, 26]]}}}, {"text": "And if you want a clearer form to what is the actual path it resolves to when loading resources, I'd recommend you to try instead the very similar getResource method, to see the returned URL", "label": {"api": {"getResource": [[147, 157]]}}}, {"text": "I would try with equals or compareTo in your case in order to find the proper date", "label": {"api": {"equals": [[17, 22]], "compareTo": [[27, 35]]}}}, {"text": "What is the difference between == vs equals() in Java", "label": {"api": {"equals": [[37, 42]]}}}, {"text": "The one-arg version of OffsetDateTime.parse() specifies that it uses DateTimeFormatter.ISO_OFFSET_DATE_TIME as its formatter, and that formatter's docs specify that it supports three formats, as described in the docs of ZoneOffset.getId()", "label": {"api": {"the docs of ZoneOffset.getId()": [[208, 237]]}}}, {"text": "You are passing a string that represents a URL to your FileInputStream", "label": {"api": {"URL": [[43, 45]]}}}, {"text": "If you really want to pass a URL, then you need to use a real URL object, and use its openStream() method", "label": {"api": {"URL": [[29, 31], [62, 64]]}}}, {"text": "you do not create a FileInputStream from a string; you create a URL object; and then you call openStream() on that object to read from that stream", "label": {"api": {"URL": [[64, 66]]}}}, {"text": "ClassNotFoundException is thrown when no definition for the class with the specified name could be found, and by looking at stacktrace, since it contains $2 it makes me believe you (or someone) are using some inner class or anonymous inner class which uses some library that is not package in your .war file", "label": {"api": {"ClassNotFoundException": [[0, 21]]}}}, {"text": "As you can see in the TableCell javadoc there is no addItems method in TableCell", "label": {"api": {"TableCell javadoc": [[22, 38]]}}}, {"text": "You probably wanted to use the updateItem method", "label": {"api": {"the updateItem method": [[27, 47]]}}}, {"text": "Just my guess, you have got a collection and you want to keep the original version and modify the copy, maybe a real solution for you is to use java.util.stream.Stream", "label": {"api": {"java.util.stream.Stream": [[144, 166]]}}}, {"text": "Yes, every time new SortTask object is created, compute() method is called, because the method invokeAll forkes a set of tasks in a ForkJoinPool which implicitly calls compute for each one of them", "label": {"api": {"invokeAll": [[95, 103]]}}}, {"text": "So, instead of using Scanner class directly over the File, you can retrieve full lines with BufferedReader#readLine()", "label": {"api": {"BufferedReader#readLine()": [[92, 116]]}}}, {"text": "Once you have a line, trim() it and check if the first character is your delimiter", "label": {"api": {"trim()": [[22, 27]]}}}, {"text": "You can then spawn several threads in whatever code you are executing using the ExecutorService", "label": {"api": {"ExecutorService": [[80, 94]]}}}, {"text": "The ExecutorService includes many utility methods, detailed in the link, that might help you manage your processing", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "You can use a DelayQueue to deduplicate the events", "label": {"api": {"DelayQueue": [[14, 23]]}}}, {"text": "Calendar provides an abstract framework, and subclasses like GregorianCalendar provide implementations", "label": {"api": {"Calendar": [[0, 7], [70, 77]], "GregorianCalendar": [[61, 77]]}}}, {"text": "In other contexts, understand that Calendar.getInstance() maybe could return (for instance) a Chinese or a Hebrew calendar depending on the locality and system setup", "label": {"api": {"Calendar": [[35, 42]]}}}, {"text": "If what you really want is a GregorianCalendar explicitly, declare the variable as such", "label": {"api": {"Calendar": [[38, 45]], "GregorianCalendar": [[29, 45]]}}}, {"text": "Either use LSSerializer (http://docs.oracle.com/javase/8/docs/api/index.html?org/w3c/dom/ls/LSSerializer.html) or create a default Transformer from a TransformerFactory and then you can use that to serialize a DOM node, passing in a DOMSource to the transform method (https://docs.oracle.com/javase/7/docs/api/javax/xml/transform/Transformer.html#transform(javax.xml.transform.Source,%20javax.xml.transform.Result) and a StringWriter to collect the result", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/index.html?org/w3c/dom/ls/LSSerializer.html": [[25, 108]], "https://docs.oracle.com/javase/7/docs/api/javax/xml/transform/Transformer.html#transform(javax.xml.transform.Source,%20javax.xml.transform.Result)": [[268, 413]]}}}, {"text": "Java TreeMap is exactly for this", "label": {"api": {"TreeMap": [[5, 11]]}}}, {"text": "A TreeMap and HashMap can be used essentially the same, but they store their internal information slightly differently", "label": {"api": {"TreeMap": [[2, 8]]}}}, {"text": "What concrete ancestor class in the org.hibernate.internal.SessionImpl inheritance hierarchy, overrides Object.equals(Object) in such a way that the test at line \"/* 3 */\" below returns false", "label": {"api": {"Object.equals(Object)": [[104, 124]]}}}, {"text": "If you run the above with the \"-ea\" — enable assertions — switch, there will be an AssertionError thrown at the line labeled \"/* 4 */\"", "label": {"api": {"AssertionError": [[83, 96]]}}}, {"text": "But as far as I was able to find out, SessionImpl does not appear to — nor does any of its ancestors — override Object.equals(Object)", "label": {"api": {"Object.equals(Object)": [[112, 132]]}}}, {"text": "To my understanding, that \"shallow\" identity check (\"==\") is exactly what the default Object.equals(Object) does", "label": {"api": {"Object.equals(Object)": [[86, 106]]}}}, {"text": "I am working under the assumption that SessionImpl does not override the default Object.equals(Object) anywhere up its inheritance hierarchy", "label": {"api": {"Object.equals(Object)": [[81, 101]]}}}, {"text": "Does anybody else know why the SessionImpl.equals(Object) call above evaluates to false", "label": {"api": {"SessionImpl.equals(Object)": [[31, 56]]}}}, {"text": "String class has a constructor that accepts a char array i.e., String(char[] value) so, you can try this", "label": {"api": {"String": [[0, 5], [63, 68]], "String(char[] value)": [[63, 82]]}}}, {"text": "Another approach using ArrayList for working with list of string", "label": {"api": {"ArrayList": [[23, 31]]}}}, {"text": "If you are looking for an efficient way to check if a string contains a certain digit, use String.indexOf() (or maybe String.contains(); but the first one gives better performance)", "label": {"api": {"String.indexOf()": [[91, 106]], "String.contains()": [[118, 134]]}}}, {"text": "It looks to me like they have different scales", "label": {"api": {"scales": [[40, 45]]}}}, {"text": "Or if you care about matching the scales then you'll have to change the scale on either object using setScale(int newScale) to match the other", "label": {"api": {"scales": [[34, 39]]}}}, {"text": "You could exchange the part of you code which sets the text of the editor of the ComboBox with some code that sets up a cell factory and a converter", "label": {"api": {"editor": [[67, 72]], "cell factory": [[120, 131]], "converter": [[139, 147]]}}}, {"text": "The toString method of your converter will format the selected item in the needed form, and the cell factory ensures that the items in the drop down list are displayed in the original format", "label": {"api": {"cell factory": [[96, 107]], "converter": [[28, 36]]}}}, {"text": "I have also filled the fromString method of the converter", "label": {"api": {"converter": [[48, 56]]}}}, {"text": "This method is executed, when the user types into the editor then presses enter", "label": {"api": {"editor": [[54, 59]]}}}, {"text": "For example MouseInputAdapter", "label": {"api": {"MouseInputAdapter": [[12, 28]]}}}, {"text": "Is it created when registering it in the rmiregistry by calling calling Naming.bind", "label": {"api": {"Naming.bind": [[72, 82]]}}}, {"text": "But can't the stub also be created by calling UnicastRemoteObject.exportObject", "label": {"api": {"UnicastRemoteObject.exportObject": [[46, 77]]}}}, {"text": "When using Naming.bind do I need to pass a stub or a remote object", "label": {"api": {"Naming.bind": [[11, 21]]}}}, {"text": "From the documentation of Collections.sort() (http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-": [[46, 133]]}}}, {"text": "If you read https://docs.oracle.com/javase/7/docs/api/java/util/ConcurrentModificationException.html, it says", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/ConcurrentModificationException.html": [[12, 99]]}}}, {"text": "Take a look at this Java pattern matching tutorial to get a basic understanding of how the Pattern and Matcher classes work", "label": {"api": {"Pattern": [[91, 97]], "Matcher": [[103, 109]]}}}, {"text": "Enums are serializable by default", "label": {"api": {"Enums are serializable by default": [[0, 32]]}}}, {"text": "It is almost always a bad idea to use File.listFiles() because it eagerly allocates an array of files which may be very memory consuming", "label": {"api": {"File.listFiles()": [[38, 53]]}}}, {"text": "So recursive digSongs method may produce significant peak memory usage (or even lead to OutOfMemoryError)", "label": {"api": {"OutOfMemoryError": [[88, 103]]}}}, {"text": "Here is working Java code that illustrates few more aspects of calling Runtime.getRuntime().exec() like waiting for the process to complete and capturing the output and error streams", "label": {"api": {"Runtime.getRuntime().exec()": [[71, 97]]}}}, {"text": "getCurrentDirectory() returns a directory name, not a file name", "label": {"api": {"getCurrentDirectory()": [[0, 20]]}}}, {"text": "If you want the name of the file which was selected, you should use getSelectedFile()", "label": {"api": {"getSelectedFile()": [[68, 84]]}}}, {"text": "What you ask is not in the contract of List#indexOf(Object), so no, you should not try to make the list work that way", "label": {"api": {"List#indexOf(Object)": [[39, 58]]}}}, {"text": "How can I make a List or similar Collection that represents a subset of another collection, masking (filtering out) unwanted elements but without creating an entirely new collection structure", "label": {"api": {"List": [[17, 20]], "Collection": [[33, 42]]}}}, {"text": "extends Thinger> using Class#asSubclass, and then the compiler allows the implicit cast to Thinger<String>", "label": {"api": {"Class#asSubclass": [[23, 38]]}}}, {"text": "You can convert a single char representing a decimal digit to an int by calling Character.digit(myChar, 10)", "label": {"api": {"Character.digit(myChar, 10)": [[80, 106]]}}}, {"text": "However, if this is a one off occurance and your application would not be dealing with XML a lot, you can consider using XPath", "label": {"api": {"XPath": [[121, 125]]}}}, {"text": "You can use the Stream API for such need", "label": {"api": {"Stream API": [[16, 25]]}}}, {"text": "You might want to consider skipping intermediate array creation using Pattern.splitAsStream", "label": {"api": {"Pattern.splitAsStream": [[70, 90]]}}}, {"text": "As per the JFormattedTextField API section on getValue()", "label": {"api": {"JFormattedTextField API": [[11, 33]]}}}, {"text": "As mentioned before, use Float#parseFloat(String) but don't forget to replace the commas", "label": {"api": {"Float#parseFloat(String)": [[25, 48]]}}}, {"text": "Inspired by this great answer, you can also check out the corresponding Float#valueOf(String) if you prefer a nasty regex", "label": {"api": {"Float#valueOf(String)": [[72, 92]]}}}, {"text": "You specify the DecimalFormatSymbols to use", "label": {"api": {"DecimalFormatSymbols": [[16, 35]]}}}, {"text": "You can do that with Java's LineNumberReader", "label": {"api": {"LineNumberReader": [[28, 43]]}}}, {"text": "Before you ask, no, LineNumberReader#setLineNumber does not change the file position, it just artificially sets the reported line number", "label": {"api": {"LineNumberReader": [[20, 35]]}}}, {"text": "Another option is to just use a BufferedReader, calling readLine() 199 times to skip to the 200th lines, then reading the next 200 (or whatever) lines", "label": {"api": {"BufferedReader": [[32, 45]]}}}, {"text": "But, LineNumberReader just conveniently keeps track of the line number for you", "label": {"api": {"LineNumberReader": [[5, 20]]}}}, {"text": "A third option, since Java 8, is to use the streams API and do something like", "label": {"api": {"streams API": [[44, 54]]}}}, {"text": "Passing your processing Consumer to forEach()", "label": {"api": {"Consumer": [[24, 31]]}}}, {"text": "Example with LineNumberReader", "label": {"api": {"LineNumberReader": [[13, 28]]}}}, {"text": "Example with BufferedReader, not quite as straightforward as the above", "label": {"api": {"BufferedReader": [[13, 26]]}}}, {"text": "The showInputDialog method that you're calling returns an Object, but you're assigning the returned value to a String variable", "label": {"api": {"showInputDialog": [[4, 18]]}}}, {"text": "Let's avoid reinventing the wheel, just use SimpleDateFormat with the appropriate pattern as next", "label": {"api": {"SimpleDateFormat": [[44, 59]]}}}, {"text": "You can check if the bullet intersects other using Shape.intersect() in a custom Interpolator supplied to each relevant KeyValue", "label": {"api": {"Shape.intersect()": [[51, 67]], "Interpolator": [[81, 92]], "KeyValue": [[120, 127]]}}}, {"text": "The fragment below adds an Interpolator to shoot(), but you'll need an identical one for each direction", "label": {"api": {"Interpolator": [[27, 38]]}}}, {"text": "\"one will be synthesized using the target values that are current at the time\" the animation is played", "label": {"api": {"synthesized": [[13, 23]]}}}, {"text": "The fireValueChangedEvent method can be used to notify the JavaBeanDoubleProperty that the underlying data has been changed", "label": {"api": {"fireValueChangedEvent": [[4, 24]]}}}, {"text": "You might also want to place each table in a separate JInternalFrame container as this will allow you to move and resize the tables freely withing the main window", "label": {"api": {"JInternalFrame": [[54, 67]]}}}, {"text": "See the ResultSet API to explore more ways to retrieve values from the resultset", "label": {"api": {"ResultSet API": [[8, 20]]}}}, {"text": "In that case, use getResourceAsStream() to open an InputStream", "label": {"api": {"getResourceAsStream()": [[18, 38]]}}}, {"text": "You will then add all your components/elements into this panel and you can move them freelly around with the method Component.setBounds(...)", "label": {"api": {"Component.setBounds(...)": [[116, 139]]}}}, {"text": "You can determine which component was pressed by calling the method Component.getComponentAt(Point) inside the MouseListener of your panel", "label": {"api": {"Component.getComponentAt(Point)": [[68, 98]]}}}, {"text": "Method Component.getElementAt(Point) does not \"see through\" transparent/non-opaque pixels", "label": {"api": {"Component.getElementAt(Point)": [[7, 35]]}}}, {"text": "Each object knows it class object", "label": {"api": {"knows it class object": [[12, 32]]}}}, {"text": "According to the Javadoc, RandomAccessFile.readLine() is not aware of character encodings", "label": {"api": {"RandomAccessFile.readLine()": [[26, 52]]}}}, {"text": "The javadoc for File.renameTo specifically says that it may not be able to move a file between different volumes, and that you should use Files.move if you need to support this case in a platform independent way", "label": {"api": {"The javadoc for File.renameTo": [[0, 28]]}}}, {"text": "A much better option, though still a bit hacky, would be to use a UUID, which makes it easy to access the higher and lower long values", "label": {"api": {"UUID": [[66, 69]]}}}, {"text": "By calling await in ForLoop2, the thread will only wake up after the countDown is called in ForLoop1", "label": {"api": {"await": [[11, 15]], "countDown": [[69, 77]]}}}, {"text": "CountDownLatch is a versatile synchronization tool", "label": {"api": {"CountDownLatch": [[0, 13]]}}}, {"text": "According to the Java Specs for HashMap, the order is not guaranteed", "label": {"api": {"HashMap": [[32, 38]]}}}, {"text": "See this answer for a similar discussion, and the suggested usage of LinkedHashMap, which maintains insertion order", "label": {"api": {"HashMap": [[75, 81]], "LinkedHashMap": [[69, 81]]}}}, {"text": "First of all, rather than attempting to grab the results of the Future immediately after submitting each one (if you do this you're essentially just serializing everything and defeating the purpose), submit all of them, and then retrieve the results", "label": {"api": {"Future": [[64, 69]]}}}, {"text": "And finally, you need to check the docs for Future, which show you how to wait for it to be computed and obtain the results by using Future#get()", "label": {"api": {"Future": [[44, 49], [133, 138]]}}}, {"text": "What you need to use is rather an AtomicIntegerArray instead of a simple volatile int array", "label": {"api": {"AtomicIntegerArray": [[34, 51]]}}}, {"text": "A possible solution would be to remove the path (with spaces) from your constant field and use the directory method", "label": {"api": {"directory": [[99, 107]]}}}, {"text": "Sets this process builder's working directory", "label": {"api": {"directory": [[36, 44]]}}}, {"text": "Subprocesses subsequently started by this object's start() method will use this as their working directory", "label": {"api": {"directory": [[97, 105]]}}}, {"text": "The argument may be null -- this means to use the working directory of the current Java process, usually the directory named by the system property user.dir, as the working directory of the child process", "label": {"api": {"directory": [[58, 66], [109, 117], [173, 181]]}}}, {"text": "Jackson is a good choice and Maps should work fine", "label": {"api": {"Map": [[29, 31]]}}}, {"text": "One option is to run a Task in a different thread", "label": {"api": {"Task": [[23, 26]]}}}, {"text": "Platform.runLater is required in this case, because user interface objects, including all JavaFX Nodes, may only be accessed and modified in the UI thread", "label": {"api": {"Platform.runLater": [[0, 16]]}}}, {"text": "If your update() method is manipulating any Nodes, it will need to use Platform.runLater to do so", "label": {"api": {"Platform.runLater": [[71, 87]]}}}, {"text": "The Task class has built-in support for showing work progress in the UI, but since you haven’t included the code for your update() method, I can’t tell you whether that support would be useful in your situation", "label": {"api": {"Task": [[4, 7]]}}}, {"text": "Then you can access to your value 0.8979 using List#get(int), like this", "label": {"api": {"List#get(int)": [[47, 59]]}}}, {"text": "Oddly enough, I can't find documentation of the contains operator in MVEL's documention page, but it exists in the code and calls the standard Collection.contains() method", "label": {"api": {"Collection.contains()": [[143, 163]]}}}, {"text": "Wrap the array with Arrays.asList() and use List.subList()", "label": {"api": {"Arrays.asList()": [[20, 34]], "List.subList()": [[44, 57]]}}}, {"text": "Note also the use of javax.xml.bind.DatatypeConverter for base64 operations", "label": {"api": {"javax.xml.bind.DatatypeConverter": [[21, 52]]}}}, {"text": "Use a fixed thread pool executor for your tasks, let all your tasks use the same ReadWriteLock, and let it work itself out", "label": {"api": {"fixed thread pool executor": [[6, 31]], "ReadWriteLock": [[81, 93]]}}}, {"text": "If your output is even bigger than that, then try using the BigInteger", "label": {"api": {"BigInteger": [[60, 69]]}}}, {"text": "You can use a series of Stream.map and Stream.flatMap", "label": {"api": {"Stream.map": [[24, 33]], "Stream.flatMap": [[39, 52]]}}}, {"text": "I've tried setReshowDelay(), but that didn't work in the way I expected", "label": {"api": {"setReshowDelay()": [[11, 26]]}}}, {"text": "You should read the documentation of BigDecimal regarding calling the double version of the constructor", "label": {"api": {"documentation of BigDecimal regarding calling the double version of the constructor": [[20, 102]]}}}, {"text": "SimpleDateFormat gives you the answer", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "for my research I would like to know the authors of some of the Java standard library classes like Socket", "label": {"api": {"Socket": [[99, 104]]}}}, {"text": "The list is better for manipulation of an \"array\" for which you don't know length", "label": {"api": {"list": [[4, 7]]}}}, {"text": "Why does java.lang.Exception not provide a setter for the message and allow setting it only via the constructor (e.g", "label": {"api": {"java.lang.Exception": [[9, 27]]}}}, {"text": "As far as I know, invoking Runtime.exec(\"cmd.exe\", \"/c\", \"chcp\", \"65001\") will create a new console, change its code-page, and then kill the console", "label": {"api": {"Runtime.exec(\"cmd.exe\", \"/c\", \"chcp\", \"65001\")": [[27, 72]]}}}, {"text": "Your line needs a non-zero size; note the coordinates required by drawLine()", "label": {"api": {"drawLine()": [[66, 75]]}}}, {"text": "Use @XmlSeeAlso to let know the JAXB about the subclass during marshall/unmarshall", "label": {"api": {"@XmlSeeAlso": [[4, 14]]}}}, {"text": "BigDecimal is Immutable, arbitrary-precision signed decimal numbers", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "Many collections accepts another Collection as a constructor argument", "label": {"api": {"Collection": [[33, 42]]}}}, {"text": "You can obtain the current date in a given zone with the ZonedDateTime.now(zone) static factory", "label": {"api": {"ZonedDateTime.now(zone)": [[57, 79]]}}}, {"text": "Then, you can have the date at midnight (on the next day) in a given timezone with the method atStartOfDay(zone) on the type LocalDate", "label": {"api": {"atStartOfDay(zone)": [[94, 111]]}}}, {"text": "Send the wrapped key to the app, which must create a WrappedKeyEntry and use Keystore.setEntry() to store it", "label": {"api": {"Keystore.setEntry()": [[77, 95]]}}}, {"text": "From the Driver.connect API doc", "label": {"api": {"Driver.connect API doc": [[9, 30]]}}}, {"text": "Your best bet is to use Files.probeContentType() to determine the type of the file based on its content", "label": {"api": {"Files.probeContentType()": [[24, 47]]}}}, {"text": "You can now return a private Instant and not worry about callers being able to change it", "label": {"api": {"Instant": [[29, 35]]}}}, {"text": "If you have a TypeMirror object, you can get the kind of this type (TypeKind) with the getKind() method and then use the isPrimitive() method", "label": {"api": {"TypeMirror": [[14, 23]], "TypeKind": [[68, 75]], "getKind()": [[87, 95]], "isPrimitive()": [[121, 133]]}}}, {"text": "In this case, the method resolves to println(Object x) which states", "label": {"api": {"println(Object x)": [[37, 53]]}}}, {"text": "Remember that Java Date objects don't have a time zone", "label": {"api": {"Date": [[19, 22]]}}}, {"text": "Assuming you're using JDBC (not some NoSQL), you need a Timestamp", "label": {"api": {"Timestamp": [[56, 64]]}}}, {"text": "Now you can give that to a PreparedStatement using setTimestamp()", "label": {"api": {"Timestamp": [[54, 62]], "PreparedStatement": [[27, 43]], "setTimestamp()": [[51, 64]]}}}, {"text": "CompletableFuture†, introduced in Java 8, is just the ticket", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "CompletableFuture builds on this core concept by letting you attach all kinds of additional transformations and handlers to an existing future", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "In your case, you can use supplyAsync to run getTicketsById and getAccidentsById in background threads", "label": {"api": {"supplyAsync": [[26, 36]]}}}, {"text": "Since you want to call the corresponding setters when those methods return, you use thenAccept to say, \"when that method returns, supply the value to this setter\"", "label": {"api": {"thenAccept": [[84, 93]]}}}, {"text": "Wrapping both of those futures into a bigger one with allOf gets us there", "label": {"api": {"allOf": [[54, 58]]}}}, {"text": "The allOf future doesn't itself complete until the two inner futures are both completed", "label": {"api": {"allOf": [[4, 8]]}}}, {"text": "Finally, we join the allOf future, which waits for it to finish before proceeding", "label": {"api": {"allOf": [[21, 25]], "join": [[12, 15]]}}}, {"text": "If any of this code might throw an exception then join will throw that exception itself—although it'll be wrapped in a CompletionException—so you can add a try/catch around it if you wish", "label": {"api": {"join": [[50, 53]]}}}, {"text": "They got it right with CompletableFuture, but Future stole the ideal name", "label": {"api": {"CompletableFuture": [[23, 39]]}}}, {"text": "Searching on the documentation of Node in JavaFX i walked through this method", "label": {"api": {"Node": [[34, 37]]}}}, {"text": "As you might already know, in Java, the enums represent one or more constants of the same type, which could have their own properties - this include java.util.Function instances", "label": {"api": {"java.util.Function": [[149, 166]]}}}, {"text": "You can use the collect operation that you have on IntStream instead of boxing it into a Stream<Integer>", "label": {"api": {"collect": [[16, 22]]}}}, {"text": "This won't box every index into an Integer since the consumer part of the collector takes an ObjIntConsumer; so i in the code above is an int", "label": {"api": {"collect": [[74, 80]], "ObjIntConsumer": [[93, 106]]}}}, {"text": "When printing, there is an implicit call to toString() method", "label": {"api": {"toString()": [[44, 53]]}}}, {"text": "That method, in turn, says that it's equivalent to Arrays.asList(arr).hashCode()", "label": {"api": {"equivalent to Arrays.asList(arr).hashCode()": [[37, 79]]}}}, {"text": "The List interface defines a contract for hashCode, which is that it must be equivalent to", "label": {"api": {"defines a contract": [[19, 36]]}}}, {"text": "Thus two objects can very well have the same hashcode() (because, well", "label": {"api": {"hashcode()": [[45, 54]]}}}, {"text": "And that by the way why you always always always compare Strings using the equals() method; and not ==", "label": {"api": {"equals()": [[75, 82]]}}}, {"text": "I’m sure nothing I offer will match the complexity of Photoshop, but at the very least, you can colorize a grayscale image by using an RGBImageFilter to alter one or more of the RGB components of each pixel", "label": {"api": {"RGBImageFilter": [[135, 148]]}}}, {"text": "Arrays.copyOf is a standard, easy way to do this in one line", "label": {"api": {"Arrays.copyOf": [[0, 12]]}}}, {"text": "You're better of using a Map", "label": {"api": {"Map": [[25, 27]]}}}, {"text": "How exactly do I use the fireContentsChanged() method in java.swing.AbstractListModel", "label": {"api": {"java.swing.AbstractListModel": [[57, 84]]}}}, {"text": "I think you would be better off using Collections", "label": {"api": {"Collections": [[38, 48]]}}}, {"text": "Per the documentation for the java.util.logging.FileHandler", "label": {"api": {"java.util.logging.FileHandler": [[30, 58]]}}}, {"text": "Looks like your only option is to implement a config class to generate the file name you want and pass it to the FileHandler", "label": {"api": {"implement a config class": [[34, 57]]}}}, {"text": "I've noticed that java.io and java.nio implementations of random access files differ slightly with respect to how FileLocks are handled", "label": {"api": {"java.io": [[18, 24]], "FileLocks": [[114, 122]]}}}, {"text": "It appears as though (on Windows) java.io gives you a mandatory file lock and java.nio gives you an advisory file lock upon requesting it respectively", "label": {"api": {"java.io": [[34, 40]]}}}, {"text": "Per the Future interface contract, which ListenableFuture implements, get() returns the result of the Future, and thusly must block until necessary computations are complete", "label": {"api": {"Future": [[8, 13], [51, 56], [102, 107]]}}}, {"text": "Executing get() immediately after a Future call would give you no benefit, if system A calls system B with an async request, calling get right after will cause system A to wait", "label": {"api": {"Future": [[36, 41]]}}}, {"text": "If you want system A to keep doing things while B is processing the request, you may wish to add a Callback or Listener to the ListenableFuture so that A can do what it needs to do when B comes back (the ability to do this is kind of the reason why  ListenableFuture exists, as a matter of fact)", "label": {"api": {"Future": [[137, 142], [260, 265]]}}}, {"text": "You should use DataInputStream to read your int and DataOutputStream to write it, it is more appropriate in your case than a Scanner", "label": {"api": {"DataInputStream": [[15, 29]], "DataOutputStream": [[52, 67]]}}}, {"text": "The ThreadFactory.newThread should return a Thread that is responsible for running the parameter Runnable object", "label": {"api": {"ThreadFactory.newThread": [[4, 26]]}}}, {"text": "Use ListIterator to find the correct point to insert the element and to the insertion", "label": {"api": {"ListIterator": [[4, 15]]}}}, {"text": "Note that using a Iterator is enough to find the insertion point in O(n) and achieve O(n²) running time, but using ListIterator allows you to find and insert the element as well as remove the element for the next iteration of the outer loop iteration only a single iterator, if used in a clever way", "label": {"api": {"ListIterator": [[115, 126]], "using a Iterator": [[10, 25]]}}}, {"text": "Using a Comparator to compare objects by a specified criterion also allows you to specify a criterion to sort by", "label": {"api": {"Comparator": [[8, 17]]}}}, {"text": "In java 8 you can easily create a Comparator given the method reference to a method returning the sort criterion given a object", "label": {"api": {"Comparator": [[34, 43]]}}}, {"text": "Without using method references this can be done using compareTo of a object implementing the Comparable interface, like String", "label": {"api": {"Comparable": [[94, 103]]}}}, {"text": "This way you use the Strategy Pattern for the ordering relation allowing you to use different sortings by passing different Comparators", "label": {"api": {"Comparator": [[124, 133]]}}}, {"text": "And it's also the way the Collections class allows you to sort Lists with arbitrary contents, see Collections.sort(List, Comparator)", "label": {"api": {"Comparator": [[121, 130]], "Collections.sort(List, Comparator)": [[98, 131]]}}}, {"text": "Indeed L is not supported by Long.decode(String) and even if it was, it would be redondant as it will convert the result as a Long anyway", "label": {"api": {"Long.decode(String)": [[29, 47]]}}}, {"text": "executorService.scheduleAtFixedRate(task, 0, 1, TimeUnit.SECONDS); returns a ScheduledFuture<V>, which does have a cancel(boolean) method", "label": {"api": {"cancel(boolean)": [[115, 129]]}}}, {"text": "The method .thenApplyAsync(httpResponse -> new ChatActor.ChatMessage(httpResponse,\"1234\")) returns a CompletionStage<ChatActor.ChatMessage> rather than CompletionStage<HttpResponse>, as with your function httpResponse -> new ChatActor.ChatMessage(httpResponse,\"1234\"), you are converting the instance of type HttpResponse to an instance of type ChatActor.ChatMessage", "label": {"api": {"thenApplyAsync": [[12, 25]]}}}, {"text": "The reason why the compiler doesn’t simply say “cannot assign an instance of type CompletionStage<ChatActor.ChatMessage> to a variable of type CompletionStage<HttpResponse>” lies in the new type inference applied to the generic method thenApplyAsync", "label": {"api": {"thenApplyAsync": [[235, 248]]}}}, {"text": "You can just use toLowerCase() to remove the case sensitivity", "label": {"api": {"toLowerCase()": [[17, 29]]}}}, {"text": "And also the following quotation from official documentation  is really ambiguous", "label": {"api": {"official documentation": [[38, 59]]}}}, {"text": "Elements can be removed from an ArrayList using in various ways, for example by calling list.remove(index); or alternatively, by simply specifying the object to remove", "label": {"api": {"list.remove(index)": [[88, 105]], "object to remove": [[151, 166]]}}}, {"text": "You get the Class for the entry via getClass and ask that class if it's an array type via isArray", "label": {"api": {"getClass": [[36, 43]], "isArray": [[90, 96]]}}}, {"text": "We can detect the first case using my looping version above; but first, we check for the second case using array.getClass().getComponentType().getComponentType()", "label": {"api": {"getClass": [[113, 120]], "array.getClass().getComponentType().getComponentType()": [[107, 160]]}}}, {"text": "However, calling the method DatagramSocket#close from another thread releases the blocking receiver thread with a SocketException", "label": {"api": {"DatagramSocket#close": [[28, 47]]}}}, {"text": "This manual copying of stdout data is error prone (you would have to forcefully close the stream to terminate the sub thread) and thankfully, unnecessary since Java 7", "label": {"api": {"unnecessary since Java 7": [[142, 165]]}}}, {"text": "If you don’t want to direct all three channels this way, see redirectOutput(File), redirectOutput(ProcessBuilder.Redirect), and the similar methods for input and error channel", "label": {"api": {"redirectOutput(File)": [[61, 80]], "redirectOutput(ProcessBuilder.Redirect)": [[83, 121]]}}}, {"text": "Only the (default) mode ProcessBuilder.Redirect.PIPE requires you to provide input or receive output while the sub-process is runnig", "label": {"api": {"ProcessBuilder.Redirect.PIPE": [[24, 51]]}}}, {"text": "But before jumping into work I've studied some MySQL JDBC driver sources and found out that they contain two implementations of the java.sql.Driver interface", "label": {"api": {"java.sql.Driver": [[132, 146]]}}}, {"text": "While NonRegisteringDriver implements all the java.sql.Driver interface methods", "label": {"api": {"java.sql.Driver": [[46, 60]]}}}, {"text": "My first thought was, that by implementing a driver this way developers of MySQL driver are following java.sql.Driver guidlines that state the following", "label": {"api": {"java.sql.Driver": [[102, 116]]}}}, {"text": "You need a Stream of your Map, then filter it somehow and then map the result", "label": {"api": {"Stream": [[11, 16]], "filter": [[36, 41]], "map": [[63, 65]]}}}, {"text": "Using BigDecimal instead of double will solve your problem I think", "label": {"api": {"BigDecimal": [[6, 15]]}}}, {"text": "You can use java.util.AbstractMap to quickly create your own custom Map type", "label": {"api": {"java.util.AbstractMap": [[12, 32]]}}}, {"text": "Best way is to use the Java 8 LocalDate", "label": {"api": {"LocalDate": [[30, 38]]}}}, {"text": "Calendar.DATE is not a static field, it's a static variable that's used to reference which type of value you want to set/get in a specific Calendar instance", "label": {"api": {"Calendar.DATE": [[0, 12]]}}}, {"text": "Calendar.DATE is just a nice way of referencing the fifth element of that array", "label": {"api": {"Calendar.DATE": [[0, 12]]}}}, {"text": "The showing pseudoclass can be used for this purpose (see CSS Reference for Menu)", "label": {"api": {"CSS Reference for Menu": [[58, 79]]}}}, {"text": "Consider using a ListIterator which will allow you to safely insert (at the current position) while iterating", "label": {"api": {"ListIterator": [[17, 28]]}}}, {"text": "We would need to see the JDBC API you're calling to see if the Microsoft JDBC implementation throws java.sql.SQLIntegrityConstraintViolationException", "label": {"api": {"API": [[30, 32]]}}}, {"text": "Check the API", "label": {"api": {"API": [[10, 12]]}}}, {"text": "Please consider using an ExecutorService (made for managing threads with a specific policy)", "label": {"api": {"ExecutorService": [[25, 39]]}}}, {"text": "If you need a callback, you can also use CompletableFuture", "label": {"api": {"CompletableFuture": [[41, 57]]}}}, {"text": "findFirst() returns an Optional so if you want to have your code throw an exception in case you didn't find anything, you should use orElseThrow to throw it", "label": {"api": {"Optional": [[23, 30]], "orElseThrow": [[133, 143]]}}}, {"text": "Have a look at ProcessBuilder", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "If you want a sort that mutates the original List, use List#sort to avoid all the overhead of creating a new list", "label": {"api": {"List#sort": [[55, 63]]}}}, {"text": "Afterwards, you can call List#sort on each of the mBObjects", "label": {"api": {"List#sort": [[25, 33]]}}}, {"text": "In Java 8, the Random class has the alternative ints method that returns an IntStream", "label": {"api": {"ints": [[48, 51]], "IntStream": [[76, 84]]}}}, {"text": "It also provides Timeline and AnimationTimer classes for game loop design", "label": {"api": {"Timeline": [[17, 24]], "AnimationTimer": [[30, 43]]}}}, {"text": "Throwable has some hard-to-simulate system-provided methods like fillInStackTrace", "label": {"api": {"Throwable": [[0, 8]]}}}, {"text": "Throwable also has some impossible-to-mock final methods, like addSuppressed and getSuppressed", "label": {"api": {"Throwable": [[0, 8]]}}}, {"text": "Throwable, Exception, and RuntimeException are very explicitly designed for subclassing, so if you do want to test with a custom subclass, you could very easily create a real nested Exception or Throwable subclass within your test", "label": {"api": {"Throwable": [[0, 8], [195, 203]]}}}, {"text": "Your code is making the following call line.substring(0, 6) which is possible cause of an IndexOutOfBoundsException if line.length() < 6 as stated in the javadoc of String#subString", "label": {"api": {"String#subString": [[165, 180]]}}}, {"text": "ForkJoinPool.commonPool() obtains the one common pool", "label": {"api": {"ForkJoinPool": [[0, 11]]}}}, {"text": "You can create your own ForkJoinPool where you specify a thread factory which doesn't make the threads, daemon threads", "label": {"api": {"ForkJoinPool": [[24, 35]]}}}, {"text": "You can get the line provided by the user, then parse it using Integer.parseInt(String) in a do/while loop as next", "label": {"api": {"Integer.parseInt(String)": [[63, 86]]}}}, {"text": "I am using a ConcurrentLinkedQueue to queue elements before a set of threads processes them", "label": {"api": {"ConcurrentLinkedQueue": [[13, 33]]}}}, {"text": "I thought that queue.remove() would return null if there are no more elements in the queue but instead, I get a NoSuchElementException", "label": {"api": {"NoSuchElementException": [[112, 133]]}}}, {"text": "Catching a RuntimeException is not necessarily a \"bad habit\" by itself, but in this case it would be unnecessary since Queue contains methods for both requirements", "label": {"api": {"Queue": [[119, 123]]}}}, {"text": "Add a method to the EJB that has your existing timeOut method which calls javax.ejb.TimerService.createSingleActionTimer(long duration, TimerConfig config) with a short duration (10ms maybe?)", "label": {"api": {"javax.ejb.TimerService.createSingleActionTimer(long duration, TimerConfig config)": [[74, 154]]}}}, {"text": "IO is not a class of the package java.io which is the reason why it doesn't know it and your import is in gray", "label": {"api": {"java.io": [[33, 39]]}}}, {"text": "From the Scanner's documentation", "label": {"api": {"the Scanner's documentation": [[5, 31]]}}}, {"text": "Integer.parseInt throws a NumberFormatException if the conversion is not possible", "label": {"api": {"Integer.parseInt": [[0, 15]], "NumberFormatException": [[26, 46]]}}}, {"text": "In your case, when you want to store a reference to the text to be able to update it, it is more reasonable to use a Pane and put a Text instance on it", "label": {"api": {"Pane": [[117, 120]], "Text": [[132, 135]]}}}, {"text": "You can also eliminate the Platform.runlater(...) block by updating the messageProperty of the task inside call() then binding the textProperty of the Text to this property", "label": {"api": {"Text": [[151, 154]], "messageProperty": [[72, 86]]}}}, {"text": "Note that in Java 8, you can also do better without using streams using Map.forEach and Map.computeIfAbsent", "label": {"api": {"Map.forEach": [[72, 82]], "Map.computeIfAbsent": [[88, 106]]}}}, {"text": "I was trying Stream classes when I got this solution", "label": {"api": {"Stream": [[13, 18]]}}}, {"text": "Use Stream.allMatch which is a short-circuiting operation", "label": {"api": {"Stream.allMatch": [[4, 18]]}}}, {"text": "You should write a InvocationHandler (http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/InvocationHandler.html)  that would intercept calls to your objects, and then reflectively (using reflection API) invoke first the isConnected() method followed by the method to which the call was made", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/InvocationHandler.html": [[38, 118]]}}}, {"text": "The closest equivalent to what you are describing is probably the StringConverter class", "label": {"api": {"StringConverter": [[66, 80]]}}}, {"text": "All built-in cell implementations for virtualized controls (e.g", "label": {"api": {"built-in cell implementations": [[4, 32]]}}}, {"text": "ListView, TableView, etc) can be configured with an appropriate instance of StringConverter", "label": {"api": {"StringConverter": [[76, 90]]}}}, {"text": "Additionally, for example, a TextField (or other text input control) can have a TextFormatter set on it, which in turn can be instantiated specifying a StringConverter instance", "label": {"api": {"StringConverter": [[152, 166]], "TextFormatter": [[80, 92]], "specifying a StringConverter instance": [[139, 175]]}}}, {"text": "The first problem is that the getAttributes method returns a map that can hold nulls whereas Map<TextAttribute, Any> declares that its values must not be null", "label": {"api": {"getAttributes": [[30, 42]]}}}, {"text": "Such a listener invokes a context.listBindings(\"\") on bean creation, hence effectively browsing the LDAP directory", "label": {"api": {"listBindings": [[34, 45]]}}}, {"text": "Hence, a connection is rather simpler than a listBindings", "label": {"api": {"listBindings": [[45, 56]]}}}, {"text": "You can use the setTimeZone method to set the timezone to a particular value", "label": {"api": {"setTimeZone": [[16, 26]]}}}, {"text": "However, you also probably shouldn't be relying on the format of Calendar.toString()", "label": {"api": {"Calendar.toString()": [[65, 83]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html - I heard java 9 will have some major updates to date and time features", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html": [[0, 80]]}}}, {"text": "It just implies that Reflection methods like Class.getGenericSuperclass() will provide you with the information, which is indeed the mechanisim behind the Guava TypeToken", "label": {"api": {"Class.getGenericSuperclass()": [[45, 72]]}}}, {"text": "Jackson apparently does not like the java.beans.ConstructorProperties  annotation added to constructors", "label": {"api": {"java.beans.ConstructorProperties ": [[37, 69]]}}}, {"text": "I just realized that implementing the following algorithm to compute the hash code for a stream is not possible using Stream.reduce(...)", "label": {"api": {"Stream.reduce(...)": [[118, 135]]}}}, {"text": "The algorithm for List.hashCode()", "label": {"api": {"List.hashCode()": [[18, 32]]}}}, {"text": "The first is the visitFileFailed() method", "label": {"api": {"visitFileFailed() method": [[17, 40]]}}}, {"text": "You also have to override the postVisitDirectory() method; it has two arguments, the second being an IOException", "label": {"api": {"postVisitDirectory() method": [[30, 56]]}}}, {"text": "Use Files.move() instead", "label": {"api": {"Files.move()": [[4, 15]]}}}, {"text": "You could create a ReaderInterceptor and use Jackson to manipulate your JSON", "label": {"api": {"ReaderInterceptor": [[19, 35]]}}}, {"text": "Then register the ReaderInterceptor created above in your Client", "label": {"api": {"ReaderInterceptor": [[18, 34]], "Client": [[58, 63]]}}}, {"text": "See Pattern for more info on their use", "label": {"api": {"Pattern": [[4, 10]]}}}, {"text": "Use FileInputStream instead", "label": {"api": {"FileInputStream": [[4, 18]]}}}, {"text": "The class DecimalFormat from the package java.text handles this almost effortlessly", "label": {"api": {"DecimalFormat": [[10, 22]]}}}, {"text": "This is significant because as we know those wrappers make the collections thread-safe for simple operations (like get()/put()) but require manual synchronization for iteration", "label": {"api": {"manual synchronization": [[140, 161]]}}}, {"text": "The simplest fix is to change the map implementation to the threadsafe ConcurrentHashMap, or reorganise the code to use a copy of the map or otherwise avoid concurrent access while it is being modified", "label": {"api": {"ConcurrentHashMap": [[71, 87]]}}}, {"text": "I am trying to find out why my @PostLoad annotated method never gets invoked after loading the object from the database", "label": {"api": {"@PostLoad": [[31, 39]]}}}, {"text": "See the documentation of PrintStream.print(String)", "label": {"api": {"PrintStream.print(String)": [[25, 49]]}}}, {"text": "You can block user interaction without displaying a dialog by entering a SecondaryLoop after the animation starts", "label": {"api": {"SecondaryLoop": [[73, 85]]}}}, {"text": "When the animation concludes, exit() the SecondaryLoop", "label": {"api": {"SecondaryLoop": [[41, 53]]}}}, {"text": "And from the description of Statement", "label": {"api": {"Statement": [[28, 36]]}}}, {"text": "Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when more rows are needed for ResultSet objects genrated by this Statement", "label": {"api": {"Statement": [[160, 168]]}}}, {"text": "Override the isCellEditable(row,col) method of the table and return true for any row of the column that matches the current date", "label": {"api": {"isCellEditable(row,col)": [[13, 35]]}}}, {"text": "You can use Files.lines(Path) or Files.lines(Path, Charset) to get all lines streamed", "label": {"api": {"Files.lines(Path)": [[12, 28]], "Files.lines(Path, Charset)": [[33, 58]]}}}, {"text": "Instead of trying to reinvent the wheel, you should use a ScheduledExecutorService (which is actually a pool of threads that you can use to schedule tasks) created with Executors.newSingleThreadScheduledExecutor() (which is a pool of only one thread) to schedule your task every 300 milliseconds, then call cancel(boolean) on the corresponding Future instance when you want to stop the task", "label": {"api": {"ScheduledExecutorService": [[58, 81]], "Executors.newSingleThreadScheduledExecutor()": [[169, 212]], "cancel(boolean)": [[307, 321]], "Future": [[344, 349]]}}}, {"text": "Your executor can be defined as a private static final field as you only need one scheduler such that you will then have only one thread in your entire application", "label": {"api": {"executor": [[5, 12]]}}}, {"text": "Whilst intersection types exist in Java since the introduction of generics in Java 6, lambda support in Java 8 needed and brought us intersection casts", "label": {"api": {"intersection types": [[7, 24]]}}}, {"text": "Still, intersection types for variables have yet to be implemented", "label": {"api": {"intersection types": [[7, 24]]}}}, {"text": "Assuming that you use Java 8, it can be done using computeIfAbsent to initialize the List of values when it is a new key as next", "label": {"api": {"computeIfAbsent": [[51, 65]]}}}, {"text": "Anyhow, a good solution for your case study would be similar to the one implemented by Java Logger", "label": {"api": {"Logger": [[92, 97]]}}}, {"text": "Where a numeric values is associated to the Logger level (every possible Level has its value) that allow you to check if the current Logger should write anything to the log with a single if", "label": {"api": {"Logger": [[44, 49], [133, 138]]}}}, {"text": "For example when you call Logger#info(String)", "label": {"api": {"Logger": [[26, 31]]}}}, {"text": "Where levelValue is \"the current effective level value\" of the Logger", "label": {"api": {"Logger": [[63, 68]]}}}, {"text": "From the Java API (emphasis mine)", "label": {"api": {"the Java API": [[5, 16]]}}}, {"text": "You could use Integer.parseInt(), but it allows a leading +, and that's not allowed according to your javadoc", "label": {"api": {"Integer.parseInt()": [[14, 31]]}}}, {"text": "You can manually test for leading +, then use Integer.parseInt() like this", "label": {"api": {"Integer.parseInt()": [[46, 63]]}}}, {"text": "See Memory Consistency Properties in the javadoc", "label": {"api": {"Memory Consistency Properties": [[4, 32]]}}}, {"text": "HashMap is Serializable", "label": {"api": {"Serializable": [[11, 22]]}}}, {"text": "This means that you could write the HashMap to an ObjectOutputStream which is backed by a FileOutputStream to write the HashMap to a file, and later you could read from the file using an ObjectInputStream that's backed by a FileInputStream", "label": {"api": {"ObjectOutputStream": [[50, 67]], "FileOutputStream": [[90, 105]], "ObjectInputStream": [[187, 203]], "FileInputStream": [[224, 238]]}}}, {"text": "Please note that the entities of your HashMap must also be Serializable for this to work", "label": {"api": {"Serializable": [[59, 70]]}}}, {"text": "Check out Threads which gives a perfect example of how to do it", "label": {"api": {"Threads": [[10, 16]]}}}, {"text": "A custom LinkedList implementation will very likely be more efficient because it allows you to make optimizations for your needs, however the JDK's LinkedList will always be preferable for its re-usability and maintainability benefits", "label": {"api": {"LinkedList": [[9, 18], [148, 157]]}}}, {"text": "Nobody will ever need to maintain the implementation of the LinkedList", "label": {"api": {"LinkedList": [[60, 69]]}}}, {"text": "Your LinkedList will be compatible with many third-party libraries which use List", "label": {"api": {"LinkedList": [[5, 14]]}}}, {"text": "If you do decide to create a custom List implementation, you may choose to extend AbstractSequentialList in order to gain the benefits of #2, #4, and possibly #5", "label": {"api": {"AbstractSequentialList": [[82, 103]]}}}, {"text": "The method to use is called JComponent.requestFocus (API) and needs to be called after the elements are displayed, of course", "label": {"api": {"API": [[53, 55]]}}}, {"text": "Especially the Socket class has many states (KeepAlive, closed)", "label": {"api": {"class": [[22, 26]]}}}, {"text": "You aren't calling flush() between the println() calls and System.out and System.err are both (independently) buffered PrintStream(s)", "label": {"api": {"flush()": [[19, 25]]}}}, {"text": "A java.util.BitSet contains helper methods for dealing with raw bits, and conversions to and from byte arrays", "label": {"api": {"java.util.BitSet": [[2, 17]]}}}, {"text": "The best way is to use a Set<Integer> to store your already generated numbers in order to easily know if they have already been added/generated or not as next", "label": {"api": {"Set<Integer>": [[25, 36]]}}}, {"text": "You could also use StringBuilder to build up your output String", "label": {"api": {"StringBuilder": [[19, 31]]}}}, {"text": "If you're looking for tasks depending on each other, take a look at the CompletableFuture class", "label": {"api": {"CompletableFuture": [[72, 88]]}}}, {"text": "ArrayList, a Generic, stores objects of the type T", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "In contrast, a Collection is a container of objects (elements)", "label": {"api": {"Collection": [[15, 24]]}}}, {"text": "You're calling Scanner.nextInt() as the documentation says, if the next input is not an integer literal then it will throw InputMismatchException", "label": {"api": {"Scanner.nextInt()": [[15, 31]]}}}, {"text": "Java has INetAddress for this purpose", "label": {"api": {"INetAddress": [[9, 19]]}}}, {"text": "You see, if you would be using the INetAddress class, and you would be passing a string with an \"invalid\" address; that class would throw an exception", "label": {"api": {"INetAddress": [[35, 45]]}}}, {"text": "just read about replaceAll", "label": {"api": {"replaceAll": [[16, 25]]}}}, {"text": "The ShortMessage class has fields such as NOTE_ON that help you construct a message with the correct values", "label": {"api": {"NOTE_ON": [[42, 48]]}}}, {"text": "Although, setting alwaysOnTop might do the work for you — not sure what you're trying to achieve", "label": {"api": {"alwaysOnTop": [[18, 28]]}}}, {"text": "the line separator sent on the java side might not necessarily correspond to the line separator expected on the server side, expect if you're working cross-platform", "label": {"api": {"on the java side": [[24, 39]]}}}, {"text": "But if your lucky, the answer to your problem will be simple calls to setPriority(); using different priorities", "label": {"api": {"setPriority()": [[70, 82]]}}}, {"text": "If you have something those are paired (like employee name and payment in your example), better use Map instead of two discrete array", "label": {"api": {"Map": [[100, 102]]}}}, {"text": "The trick to waiting for that to complete on the main thread is to represent the call to new SSO() as a FutureTask, submit the FutureTask to SwingUtilities.invokeLater(), and then, back on the main thread, call get() on the FutureTask", "label": {"api": {"FutureTask": [[104, 113], [127, 136], [224, 233]]}}}, {"text": "If that leaves you with questions, the next step would be to lookup javadoc - you see; all your code deals with standard classes; and they are all well documented", "label": {"api": {"documented": [[152, 161]]}}}, {"text": "Referencing the documentation of the Fault and this thread on code ranch seems to suggest that a fault is being thrown from the provider of the service", "label": {"api": {"the documentation of the Fault": [[12, 41]]}}}, {"text": "That class should implement the Comparable interface", "label": {"api": {"Comparable": [[32, 41]]}}}, {"text": "Inside your custom class you have to override method compareTo(T o) which was inherited from Comparable interface", "label": {"api": {"Comparable": [[93, 102]]}}}, {"text": "It might be easiest to use XMLEncoder and XMLDecoder, which perform bean serialization", "label": {"api": {"XMLEncoder": [[27, 36]], "XMLDecoder": [[42, 51]]}}}, {"text": "First time as a Servlet Filter and second time in the filter chain of Spring Security", "label": {"api": {"Filter": [[24, 29]]}}}, {"text": "Filters will map to /*", "label": {"api": {"Filter": [[0, 5]]}}}, {"text": "If convention-based mapping is not flexible enough you can use the ServletRegistrationBean and FilterRegistrationBean classes for complete control", "label": {"api": {"Filter": [[95, 100]]}}}, {"text": "You should only add Spring Security filters (or extentions) to the filter chain, see HttpSecurity.html#addFilter", "label": {"api": {"Filter": [[106, 111]]}}}, {"text": "Adds a Filter that must be an instance of or extend one of the Filters provided within the Security framework", "label": {"api": {"Filter": [[7, 12], [63, 68]]}}}, {"text": "Your filter extends AbstractPreAuthenticatedProcessingFilter and should be added only to the filter chain", "label": {"api": {"Filter": [[54, 59]]}}}, {"text": "When using an embedded servlet container you can register Servlets and Filters directly as Spring beans", "label": {"api": {"Filter": [[71, 76]]}}}, {"text": "You can start here to learn about System.out; to then go forward and understand how such PrintStreams work in general", "label": {"api": {"System.out": [[34, 43]], "PrintStreams": [[89, 100]]}}}, {"text": "Sure, that is very well possible - when using multiple ClassLoader instances", "label": {"api": {"ClassLoader": [[55, 65]]}}}, {"text": "when each of your thread is using its own special ClassLoader, those threads could be working with \"different\" versions of the \"same\" jar file", "label": {"api": {"ClassLoader": [[50, 60]]}}}, {"text": "You should use setPosixFilePermissions method of Files class like", "label": {"api": {"setPosixFilePermissions": [[15, 37]]}}}, {"text": "At worst, you could set the user data of the grid pane to the text of the tab", "label": {"api": {"user data": [[28, 36]]}}}, {"text": "You can use pattern matching to slightly reduce clutter", "label": {"api": {"pattern matching": [[12, 27]]}}}, {"text": "Here's a functional way, which is more concise, if you are interested", "label": {"api": {"functional way": [[9, 22]]}}}, {"text": "If you start reworking your code to minimize how many formatters you need, be careful not to reference the same DecimalFormat object across threads, see the API documentation", "label": {"api": {"the API documentation": [[153, 173]]}}}, {"text": "If you want to pass a separate copy of the linked list to each thread, you need to use LinkedList#Clone", "label": {"api": {"LinkedList#Clone": [[87, 102]]}}}, {"text": "Instead Arcs can be used to draw parts of the rings", "label": {"api": {"Arcs": [[8, 11]]}}}, {"text": "Alternatively to call a method to hide the ComboBoxes, you can bind the visibleProperty of the ComboBoxes to their own itemsProperty with a custom binding", "label": {"api": {"visibleProperty": [[72, 86]], "itemsProperty": [[119, 131]]}}}, {"text": "When using a Canvas node, use the correct drawImage, i.e", "label": {"api": {"the correct drawImage": [[30, 50]]}}}, {"text": "Alternatively you could also use a ImageView for displaying part of a Image by setting the viewport property accordingly", "label": {"api": {"viewport property": [[91, 107]]}}}, {"text": "As you've mentioned already about it being in the CLASSPATH, it is better to use its IQDataSource class which implements DataSource Interface from JDBC standard", "label": {"api": {"DataSource Interface": [[121, 140]]}}}, {"text": "You can flatMap each student into a stream formed by the student along with their teachers", "label": {"api": {"flatMap": [[8, 14]]}}}, {"text": "concat is used to concatenate to the Stream of the teachers, a Stream formed by the student itself, obtained with of", "label": {"api": {"concat": [[0, 5], [18, 23]], "of": [[44, 45], [114, 115]]}}}, {"text": "First, don't use the File class", "label": {"api": {"File": [[21, 24]]}}}, {"text": "Instead, use Path and Files", "label": {"api": {"File": [[22, 25]], "Path": [[13, 16]], "Files": [[22, 26]]}}}, {"text": "In this particular case, you can use a DirectoryStream, which comes from the same family of classes (java.nio.file)", "label": {"api": {"DirectoryStream": [[39, 53]], "java.nio.file": [[101, 113]]}}}, {"text": "A DirectoryStream is an iterable object of files in a directory", "label": {"api": {"DirectoryStream": [[2, 16]]}}}, {"text": "And the Files class allows you to get a DirectoryStream of all the files in the directory that match a glob pattern", "label": {"api": {"File": [[8, 11]], "Files": [[8, 12]], "DirectoryStream": [[40, 54]]}}}, {"text": "Inject a JVMTI agent into a running process using Dynamic Attach mechanism", "label": {"api": {"Dynamic Attach mechanism": [[50, 73]]}}}, {"text": "You can use Console.readPassword() to disable echoing", "label": {"api": {"Console.readPassword()": [[12, 33]]}}}, {"text": "One of the localToScreen methods can be used to transform coordinates in a Node's coordinate system to screen coordinates", "label": {"api": {"the localToScreen methods": [[7, 31]]}}}, {"text": "You could create a custom JPanel and override its paintComponent method, but it’s generally easier to just use an OverlayLayout", "label": {"api": {"OverlayLayout": [[114, 126]]}}}, {"text": "You should simply use line.split(\" \") which will return an array of String, then get either the first or the second value using respectively the index 0 and 1 of the resulting array as next", "label": {"api": {"line.split(\" \")": [[22, 36]]}}}, {"text": "Another way could be to use line.indexOf(' ') to get the index of the space character in your String", "label": {"api": {"line.indexOf(' ')": [[28, 44]]}}}, {"text": "Many List implementations have an option to specify an initial capacity for the collection, why is this not allowed for CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[120, 139]]}}}, {"text": "Assuming you did intend to reconstruct a String, then InputStreamReader and LineNumberReader are your friends", "label": {"api": {"InputStreamReader": [[54, 70]], "LineNumberReader": [[76, 91]]}}}, {"text": "The InputStreamReader lets you do read() against the byte stream as chars (and, note, that UTF8 encoding is default, but NOT the only encoding you could use), and the LineNumberReader let's you pull line-by-line instead of char-by-char", "label": {"api": {"InputStreamReader": [[4, 20]], "LineNumberReader": [[167, 182]]}}}, {"text": "Of course, if you want char-by-char, you could use read() and lose LineNumberReader entirely", "label": {"api": {"LineNumberReader": [[67, 82]]}}}, {"text": "See the InputStreamReader docs for pointers to dealing with Charsets", "label": {"api": {"InputStreamReader": [[8, 24]]}}}, {"text": "System.out.println(float) calls String.valueOf(float), which calls Float.toString(float)", "label": {"api": {"Float.toString(float)": [[67, 87]]}}}, {"text": "The answer is in the documentation for Float.toString(float)", "label": {"api": {"Float.toString(float)": [[39, 59]]}}}, {"text": "If you want to call a task every few seconds, you can use a ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[60, 86]]}}}, {"text": "I recently encountered atomic classes from java.util.concurrent.atomic package", "label": {"api": {"java.util.concurrent.atomic": [[43, 69]]}}}, {"text": "Also, please explain what is AtomicReference", "label": {"api": {"AtomicReference": [[29, 43]]}}}, {"text": "java.util.concurrent.atomic package does it for us", "label": {"api": {"java.util.concurrent.atomic": [[0, 26]]}}}, {"text": "The way to unblock it immediately is to close the socket from the other thread", "label": {"api": {"close": [[40, 44]]}}}, {"text": "You should get the selected value of the ComboBox with getValue method", "label": {"api": {"getValue": [[55, 62]]}}}, {"text": "getValue will return the type which type the ComboBox has as generic parameter (the type of the items stored in the ComboBox)", "label": {"api": {"getValue": [[0, 7]]}}}, {"text": "public final T getValue()", "label": {"api": {"getValue": [[15, 22]]}}}, {"text": "If you are using Java 8 you can check new Date library and its DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[63, 79]]}}}, {"text": "Use this formatter to parse date using Date.parse", "label": {"api": {"Date.parse": [[39, 48]]}}}, {"text": "Get the root application name - This can be done by using ServletContext.getRealPath() - It returns the folder name, from which the war name can be extracted (and can be used, in my case at least as the app name)", "label": {"api": {"ServletContext.getRealPath()": [[58, 85]]}}}, {"text": "Indeed, from Period.between", "label": {"api": {"Period.between": [[13, 26]]}}}, {"text": "You have to implement all interfaces from javax.persistence - https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html": [[62, 136]]}}}, {"text": "boundsInLocal are coordinates in the Button's own coordinate system", "label": {"api": {"boundsInLocal": [[0, 12]]}}}, {"text": "There's some examples on how to use it, starting with InputContext.selectInputMethod(Locale locale)", "label": {"api": {"InputContext.selectInputMethod(Locale locale)": [[54, 98]]}}}, {"text": "If you don't use Cokie::setDomain, the attribute domain is not set", "label": {"api": {"Cokie::setDomain": [[17, 32]]}}}, {"text": "If you don't use Cokie::setDomain the path attribute is automatically set to the request path", "label": {"api": {"Cokie::setDomain": [[17, 32]]}}}, {"text": "subClassObject is not a MySuperClass instance, it's a java.lang.Class instance", "label": {"api": {"java.lang.Class": [[54, 68]]}}}, {"text": "In general non-Java terms, a URL is a specialized type of URI", "label": {"api": {"URI": [[58, 60]]}}}, {"text": "You can use the URI class (which is more modern than the venerable URL class, which has been around since Java 1.0) to create a URI more reliably, and you can convert it to a URL with the toURL method of URI", "label": {"api": {"URI": [[16, 18], [128, 130], [204, 206]], "toURL": [[188, 192]]}}}, {"text": "Use Form and just add parameters with Form#param(key, value)", "label": {"api": {"Form": [[4, 7], [38, 41]]}}}, {"text": "Once you are using the JAX-RS Client API, your client code can be like", "label": {"api": {"JAX-RS Client API": [[23, 39]]}}}, {"text": "Then read the content of the ZipInputStream", "label": {"api": {"ZipInputStream": [[29, 42]]}}}, {"text": "ProgressMonitor has two constructors", "label": {"api": {"ProgressMonitor": [[0, 14]]}}}, {"text": "I don't see the reason for the second (private) constructor, where the only change in signature is ProgressMonitor group which is always null", "label": {"api": {"ProgressMonitor": [[99, 113]]}}}, {"text": "Method#invoke's first parameter is the object to call the method on, not the name of the method (it already knows who it is)", "label": {"api": {"Method#invoke": [[0, 12]]}}}, {"text": "You simply cannot mix Integer.parseInt(inFromClient.readLine()) with writeInt(), you need to use a DataOutputStream to write your integers and DataInputStream to read them to make sure that your integers will be properly serialized and deserialized using the same protocol/algorithm", "label": {"api": {"DataOutputStream": [[99, 114]], "DataInputStream": [[143, 157]]}}}, {"text": "Alternatively you can use ObjectOutputStream and ObjectInputStream to write and read your array as an object using the methods writeObject and readObject as next", "label": {"api": {"ObjectOutputStream": [[26, 43]], "ObjectInputStream": [[49, 65]]}}}, {"text": "Since Java 8, I can now use Map's merge method like in the following example", "label": {"api": {"Map's merge method": [[28, 45]]}}}, {"text": "If you want to prevent duplicate elements, HashSet is a good option", "label": {"api": {"HashSet": [[43, 49]]}}}, {"text": "HashSet will do it for you in O(1) time complexity", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "Using HashSet.contains(Object), you can check if an element already exists", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "Using HashSet.toArray(T[]), you can obtain array in last", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "You can get this information via the Attach API", "label": {"api": {"Attach API": [[37, 46]]}}}, {"text": "I've looked at dynamic proxies via reflection which can only proxy interfaces (public methods) AND if you call anything annotated inside \"this\", you don't go through the proxy anymore so you lose that validation", "label": {"api": {"dynamic proxies": [[15, 29]]}}}, {"text": "You always could use a Map", "label": {"api": {"Map": [[23, 25]]}}}, {"text": "Using Jackson, a popular JSON parser for Java, it could be parsed into a Map<String,Object> object", "label": {"api": {"Map": [[73, 75]], "Object": [[84, 89]]}}}, {"text": "Instead of Object, you could use POJOs", "label": {"api": {"Object": [[11, 16]]}}}, {"text": "You can use the matches method", "label": {"api": {"matches": [[16, 22]]}}}, {"text": "find() searches for one matching value", "label": {"api": {"find()": [[0, 5]]}}}, {"text": "To get the next one, you must invoke find() again, hence the loop", "label": {"api": {"find()": [[37, 42]]}}}, {"text": "If you don't care adding coupling to your class a better approach could be to provide a Supplier<LocalDateTime> to your class as next", "label": {"api": {"Supplier<LocalDateTime>": [[88, 110]], "Supplier": [[88, 95]]}}}, {"text": "This way it will be easy to create a Supplier for testing purpose in your test case", "label": {"api": {"Supplier": [[37, 44]]}}}, {"text": "JDBC has an Array class for the SQL ARRAY, for some usages, like createArrayOf", "label": {"api": {"createArrayOf": [[65, 77]]}}}, {"text": "Response is an abstract class and RESTEasy has different sub classes for client and server, see BuiltResponse and ClientResponse", "label": {"api": {"Response": [[0, 7], [101, 108], [120, 127]]}}}, {"text": "Response#readEntity needs to be backed by an input stream", "label": {"api": {"Response": [[0, 7]]}}}, {"text": "A BuiltResponse is never backed by an input stream and therefore you get a IllegalStateException", "label": {"api": {"Response": [[7, 14]]}}}, {"text": "You can use Response#getEntity, it doesn't need an input stream", "label": {"api": {"Response": [[12, 19]], "Response#getEntity": [[12, 29]]}}}, {"text": "As per SimpleDateFormat docs", "label": {"api": {"SimpleDateFormat docs": [[7, 27]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html try class Files move() method", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html": [[0, 64]]}}}, {"text": "For simple purpose you could try using Invocation Handler", "label": {"api": {"Invocation Handler": [[39, 56]]}}}, {"text": "For more sophisticated manipulation you can use Java Instrumentation API", "label": {"api": {"Java Instrumentation API": [[48, 71]]}}}, {"text": "So is it possible to use a dynamic @ApplicationPath", "label": {"api": {"@ApplicationPath": [[35, 50]]}}}, {"text": "Just as it is possible to use a variable in the @Path annotation, could I write something like @ApplicationPath(\"/tenants/{id}/api\")", "label": {"api": {"@ApplicationPath": [[95, 110]], "@Path": [[48, 52]]}}}, {"text": "When you supply an int parameter to nextInt(), that parameter is the radix of the input that's being parsed", "label": {"api": {"the radix of the input that's being parsed": [[65, 106]]}}}, {"text": "You will need to create a Runnable to run on the main UI thread with SwingUtilities", "label": {"api": {"SwingUtilities": [[69, 82]]}}}, {"text": "I would suggest you change your class and method declarations to use the fact that Comparable<T> is generic", "label": {"api": {"Comparable<T>": [[83, 95]]}}}, {"text": "I think what you need is the String#split(String) method", "label": {"api": {"String#split(String)": [[29, 48]]}}}, {"text": "If you read the javadoc page for the CharSequence interface, it says that the behavior for equals is undefined", "label": {"api": {"CharSequence": [[37, 48]]}}}, {"text": "The result of comparing two objects that implement CharSequence is therefore, in general, undefined", "label": {"api": {"CharSequence": [[51, 62]]}}}, {"text": "It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map", "label": {"api": {"CharSequence": [[47, 58]]}}}, {"text": "It's supported by the built-in removeAll(Collection<?> c) method", "label": {"api": {"removeAll(Collection<?> c)": [[31, 56]]}}}, {"text": "If you experience bad performance because list2 is large, convert it to a Set first, since the removeAll() method is implemented by calling list2.contains(Object o)", "label": {"api": {"list2.contains(Object o)": [[140, 163]]}}}, {"text": "More info can be found in the Java API", "label": {"api": {"the Java API": [[26, 37]]}}}, {"text": "Since you need the result from a thread (LoadData) to be processed (ConversionLogic) I would use also an ExecutorCompletionService to help with gathering results from LoadData", "label": {"api": {"ExecutorCompletionService": [[105, 129]]}}}, {"text": "So I was thinking of using a ConcurrentHashMap with the identifier of each source as the key, and a LIFO queue (stack) as the value", "label": {"api": {"ConcurrentHashMap": [[29, 45]]}}}, {"text": "The producer could also add new keys to the map, and iterating through the entrySet of the Map seems to be weakly consistent", "label": {"api": {"entrySet": [[75, 82]]}}}, {"text": "Ideally I could also use some parallel processing on the stream of the entrySet to speed up the process", "label": {"api": {"entrySet": [[71, 78]]}}}, {"text": "In reality I could have used a LIFO BlockingDequeue and processed latest events first, but the problem with this approach is that there is a risk that one source could send more events than others and thus maybe get more events processed than the others", "label": {"api": {"BlockingDequeue": [[36, 50]]}}}, {"text": "Seems even JavaFX stated to follow CSS 2.1 groove and others aren`t implemented", "label": {"api": {"aren`t implemented": [[61, 78]]}}}, {"text": "So if you want the panel to be completely transparent, just use setOpaque(false) instead", "label": {"api": {"setOpaque(false)": [[64, 79]]}}}, {"text": "You've added the @XmlRootElement annotation to the User class, but it's not the root element as you're returning a list of users not a single user", "label": {"api": {"@XmlRootElement": [[17, 31]]}}}, {"text": "The correct way to do it in Java, assuming you're using JDBC, is to use a PreparedStatement", "label": {"api": {"PreparedStatement": [[74, 90]]}}}, {"text": "Is there any way to create an instance of the VariableElement without resorting to manually overriding all the methods, but rather via some standard library utility class", "label": {"api": {"VariableElement": [[46, 60]]}}}, {"text": "For example, a BufferedReader has a lines-method, which returns lines of a file (or other resources) as a Stream of Strings", "label": {"api": {"lines": [[36, 40], [64, 68]]}}}, {"text": "These connections are valid, i", "label": {"api": {"valid": [[22, 26]]}}}, {"text": "Additionally, none of such connections has readOnly flag set, so I can't tell whether I'm talking to a read-only instance until I execute some DML, which is when ER_OPTION_PREVENTS_STATEMENT comes in all its glory", "label": {"api": {"readOnly": [[43, 50]]}}}, {"text": "Even if I explicitly put a connection to a read-write mode by calling setReadOnly(false) and set the readOnlyPropagatesToServer flag, this only results in a driver sending SET SESSION TRANSACTION READ WRITE to the server, which doesn't lead to any exception thrown", "label": {"api": {"readOnly": [[101, 108]], "setReadOnly(false)": [[70, 87]]}}}, {"text": "This could be accomplished if there were a way to treat a connection to a read-only instance as an invalid/closed connection (i", "label": {"api": {"valid": [[101, 105]]}}}, {"text": "Can I have a validation query such as SHOW GLOBAL VARIABLES LIKE 'read_only' with an additional logic tied to it", "label": {"api": {"valid": [[13, 17]]}}}, {"text": "Is it possible to affect the pool's behavior w.r.t a connection based on which scalar value the validation query returns", "label": {"api": {"valid": [[96, 100]]}}}, {"text": "I read the Oracle docs http://docs.oracle.com/javase/1.5.0/docs/api/java/net/InetAddress.html#getHostName(), but I don't understand how to overcome the \"security manager\" the document mentions (or if it is indeed the reason the reverse lookup fails)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/net/InetAddress.html#getHostName()": [[23, 106]]}}}, {"text": "I would use a PriorityQueue sorted by the simulation time to execute next", "label": {"api": {"PriorityQueue": [[14, 26]]}}}, {"text": "As from the documentation of BufferedReader, we have this for read", "label": {"api": {"read": [[62, 65]]}}}, {"text": "And this for readLine", "label": {"api": {"read": [[13, 16]], "readLine": [[13, 20]]}}}, {"text": "So, set apart the details of when a line is considered to be terminated, the difference is that the first one read a single character whilst the second one read a whole line", "label": {"api": {"read": [[110, 113], [156, 159]]}}}, {"text": "LinkedList is a double ended queue (Deque) and therefore you can add and remove elements from both ends", "label": {"api": {"Deque": [[36, 40]]}}}, {"text": "The methods (push() and pop()) you are mentioning are from the Deque interface, which is also implemented by LinkedList", "label": {"api": {"Deque": [[63, 67]], "LinkedList": [[109, 118]]}}}, {"text": "The Javadoc for Deque states", "label": {"api": {"Deque": [[16, 20]]}}}, {"text": "Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit", "label": {"api": {"Deque": [[5, 9]]}}}, {"text": "If you really want to use LinkedList as a queue, you should assign the variable to that interface", "label": {"api": {"LinkedList": [[26, 35]]}}}, {"text": "As stated by Scanner docs", "label": {"api": {"Scanner docs": [[13, 24]]}}}, {"text": "A scanner's initial locale is the value returned by the Locale.getDefault() method; it may be changed via the useLocale(java.util.Locale) method", "label": {"api": {"Locale.getDefault()": [[56, 74]], "useLocale(java.util.Locale)": [[110, 136]]}}}, {"text": "The reset() method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed", "label": {"api": {"reset()": [[4, 10]]}}}, {"text": "The \\X construct comes from Perl, and the Javadoc for java.util.Pattern explicitly states in the section Comparison to Perl 5 that it is not supported", "label": {"api": {"Javadoc for java.util.Pattern": [[42, 70]]}}}, {"text": "A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class", "label": {"api": {"Deque": [[79, 83]]}}}, {"text": "Read the JOptionPane API to see what parameters you may need", "label": {"api": {"JOptionPane API": [[9, 23]]}}}, {"text": "Since, Math is a class in Java, you cannot use this as an object variable", "label": {"api": {"Math": [[7, 10]]}}}, {"text": "Well you could choose not to resolve the class by passing false to loadClass", "label": {"api": {"loadClass": [[67, 75]]}}}, {"text": "You could then do the resolution in a separate step by calling resolveClass explicitly", "label": {"api": {"resolveClass": [[63, 74]]}}}, {"text": "Collections.nCopies(...) returns an immutable list per the documentation", "label": {"api": {"Collections.nCopies(...)": [[0, 23]]}}}, {"text": "Scanner#next() reads white-space delimited (by default) string tokens", "label": {"api": {"Scanner#next()": [[0, 13]]}}}, {"text": "You can use Scanner#nextLine() instead", "label": {"api": {"Scanner#nextLine()": [[12, 29]]}}}, {"text": "Iterate the zip file using zipFile.entries() and add the zip entries to an ArrayList<ZipEntry>", "label": {"api": {"zipFile.entries()": [[27, 43]], "ArrayList<ZipEntry>": [[75, 93]]}}}, {"text": "Randomize that list by calling Collections.shuffle(list)", "label": {"api": {"Collections.shuffle(list)": [[31, 55]]}}}, {"text": "You can now simply iterate the randomized list and call zipFile.getInputStream(zipEntry)", "label": {"api": {"zipFile.getInputStream(zipEntry)": [[56, 87]]}}}, {"text": "Your problem is that Math.round(double a) returns long, and you're overflowing", "label": {"api": {"Math.round(double a)": [[21, 40]]}}}, {"text": "One easy way to do this, is to use BigDecimal", "label": {"api": {"BigDecimal": [[35, 44]]}}}, {"text": "Note that the rounding done by Math.round() is a HALF_CEILING which isn't supported by setScale()", "label": {"api": {"setScale()": [[87, 96]]}}}, {"text": "You might want to consider doing all you math using BigDecimal, if you need that level of precision", "label": {"api": {"BigDecimal": [[52, 61]]}}}, {"text": "Thankfully to interaction WebEngine you can also customise interface, layout, tabs and much more", "label": {"api": {"WebEngine": [[26, 34]]}}}, {"text": "You can Use JScrollPane(JEditorPane) , you might want to look at That", "label": {"api": {"JScrollPane(JEditorPane)": [[12, 35]]}}}, {"text": "I created a Java program that every 30 Minutes, reads information from a database, keeping them in a structure Vector<Vector<Object>>", "label": {"api": {"Vector<Vector<Object>>": [[111, 132]]}}}, {"text": "To do this use ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[15, 38]]}}}, {"text": "In your case you can try to solve the problem using the classes of the package javax.security.cert", "label": {"api": {"javax.security.cert": [[79, 97]]}}}, {"text": "Read the javadoc of PriorityQueue", "label": {"api": {"PriorityQueue": [[20, 32]]}}}, {"text": "We can use the fact that Boolean.compareTo() sorts false before true, so if we can get a false value for a DashboardObjectAIR[] that has an \"UnOk\" object, then it'll be easy", "label": {"api": {"Boolean.compareTo()": [[25, 43]]}}}, {"text": "I've implemented a LimitedComparableProperty", "label": {"api": {"Comparable": [[26, 35]]}}}, {"text": "Currently only Comparables are supported, no primitive types", "label": {"api": {"Comparable": [[15, 24]]}}}, {"text": "For formatting, you should use System.out.format(...) or String.format(...), whichever suits you better", "label": {"api": {"String.format(...)": [[57, 74]]}}}, {"text": "You could optimize it further by specifying the dropTable initial capacity and load factor (see the javadoc for HashMap) but that's up to your own judgement", "label": {"api": {"javadoc for HashMap": [[100, 118]]}}}, {"text": "And also as you need to sorted Seance you need to use SortedSet", "label": {"api": {"SortedSet": [[54, 62]]}}}, {"text": "ClassLoader.defineClass1, does not know anything about directory structure", "label": {"api": {"defineClass": [[12, 22]]}}}, {"text": "The error message says that the binary name passed as an argument to defineClass does not match the actual name discovered from the class data bytes", "label": {"api": {"defineClass": [[69, 79]]}}}, {"text": "The easiest workaround is to set name=null when calling defineClass", "label": {"api": {"defineClass": [[56, 66]]}}}, {"text": "If you haven't used a Map before, check this link out", "label": {"api": {"this link": [[40, 48]]}}}, {"text": "Convert from char[] to String with new String(char[]) and from String to char[] with String.toCharArray()", "label": {"api": {"new String(char[])": [[35, 52]], "String.toCharArray()": [[85, 104]]}}}, {"text": "Locale.getDisplayLanguage() displays the language in the default locale", "label": {"api": {"Locale.getDisplayLanguage()": [[0, 26]]}}}, {"text": "To force it to display in English, you can use Locale.getDisplayLanguage(Locale)", "label": {"api": {"Locale.getDisplayLanguage(Locale)": [[47, 79]]}}}, {"text": "loc.getDisplayLanguage() returns the name in the default locale, not in the locale of loc", "label": {"api": {"loc.getDisplayLanguage()": [[0, 23]]}}}, {"text": "To control the language of the display string, specify the locale using loc.getDisplayLanguage(Locale)", "label": {"api": {"loc.getDisplayLanguage(Locale)": [[72, 101]]}}}, {"text": "I believe Arrays.copyOfRange will be of help here", "label": {"api": {"Arrays.copyOfRange": [[10, 27]]}}}, {"text": "This means that, in the example, this refers to an instance of the ActionListener interface", "label": {"api": {"ActionListener": [[67, 80]]}}}, {"text": "In your example, the class containing the timer code happens to implement ActionListener", "label": {"api": {"ActionListener": [[74, 87]]}}}, {"text": "You can pass any instance of an ActionListener to your timer", "label": {"api": {"ActionListener": [[32, 45]]}}}, {"text": "The documentation of DateTimeFormatterBuilder specifies that \"Y\" appends the localized week-based year", "label": {"api": {"DateTimeFormatterBuilder": [[21, 44]]}}}, {"text": "Take a look at ConcurrentModificationException for a good explanation on why this exception happens", "label": {"api": {"ConcurrentModificationException": [[15, 45]]}}}, {"text": "if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[174, 204]]}}}, {"text": "While your computer is able to report something more precise (but probably not accurate, at least not in wall time) than milliseconds this does not change the fact the Java per default uses a Clock based off of System.currentTimeMillis()", "label": {"api": {"Clock": [[192, 196]]}}}, {"text": "You must provide a more precise Clock to get values more precise than ms", "label": {"api": {"Clock": [[32, 36]]}}}, {"text": "your implementation of that PriorityQueue ..", "label": {"api": {"PriorityQueue": [[28, 40]]}}}, {"text": "if you want to understand the methods you ought to implement, you can have a look at java's own PriorityQueue and its methods", "label": {"api": {"PriorityQueue": [[96, 108]]}}}, {"text": "In Java, java.lang.Math class provides different methods for mathematical operations", "label": {"api": {"java.lang.Math": [[9, 22]]}}}, {"text": "You can use a Stream", "label": {"api": {"Stream": [[14, 19]]}}}, {"text": "The implementation is based on Java 8 Collector conception", "label": {"api": {"Collector": [[38, 46]]}}}, {"text": "If you can't use Java 8 Stream, use Guava's FluentIterable (and Map#values() as @Lukas mentioned in comment)", "label": {"api": {"Map#values()": [[64, 75]]}}}, {"text": "Files.copy only has @throws clauses for IOException and two subclasses of IOException, even though it can throw many other subclasses of IOException", "label": {"api": {"Files.copy": [[0, 9]]}}}, {"text": "The JDBC method Statement.execute has a @throws clause for SQLException and one subclass of SQLException, even though there are many other subclasses of SQLException that can be thrown", "label": {"api": {"Statement.execute": [[16, 32]]}}}, {"text": "You can implement option #1 with a TreeMap and all the sorting will be handled for you as elements are added", "label": {"api": {"TreeMap": [[35, 41]]}}}, {"text": "Then use TreeMap#lastEntry() to get the entry with the highest key value", "label": {"api": {"TreeMap": [[9, 15]], "TreeMap#lastEntry()": [[9, 27]]}}}, {"text": "For internal map, you can use TreeMap", "label": {"api": {"TreeMap": [[30, 36]]}}}, {"text": "TreeMap guarantees log(n) time complexity for operations", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "A simpler solution would be a Semaphore with 2 permits", "label": {"api": {"Semaphore": [[30, 38]]}}}, {"text": "I'm trying to use a ThreadPoolExecutor along with Future (results) and Callable (task to be executed), but I can't figure out a simple way of correlating input (Callable) with the corresponding result (Future), it seems the only sensible way would be to create a wrapper (example) that contains all items, but this might be too much overhead for such a simple task", "label": {"api": {"ThreadPoolExecutor": [[20, 37]], "Future": [[50, 55], [202, 207]], "Callable": [[71, 78], [161, 168]]}}}, {"text": "Convince Graphics2D to use the target palette (IndexColorModel?)", "label": {"api": {"IndexColorModel": [[47, 61]]}}}, {"text": "But, as the getScene method is declared in the Node class, and both Button and ImageView are subclass of Node, you can cast to Node in both cases", "label": {"api": {"getScene": [[12, 19]]}}}, {"text": "If you need to mantain the order of fields you can use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[55, 67]]}}}, {"text": "See the Properties API, with loadFromXML and storeToXML", "label": {"api": {"Properties API": [[8, 21]]}}}, {"text": "The following method uses the createNativeQuery() method of the Java entity manager", "label": {"api": {"createNativeQuery()": [[30, 48]]}}}, {"text": "Despite the fact that there're quite a lot static methods which cause side effects (just have a look at System), static methods often (not always) lead to problems, for instance during testing", "label": {"api": {"System": [[104, 109]]}}}, {"text": "In fact, there exists a method for that very purpose", "label": {"api": {"there exists a method": [[9, 29]]}}}, {"text": "the JDBC specification allows that either it only contains the update counts of successfully executed statements before the first failure, or it contains all statements executes, where failures are marked with a value of EXECUTE_FAILED; from BatchUpdateException", "label": {"api": {"BatchUpdateException": [[242, 261]]}}}, {"text": "After a command in a batch update fails to execute properly and a BatchUpdateException is thrown, the driver may or may not continue to process the remaining commands in the batch", "label": {"api": {"BatchUpdateException": [[66, 85]]}}}, {"text": "If the driver continues processing after a failure, the array returned by the method BatchUpdateException.getUpdateCounts will have an element for every command in the batch rather than only elements for the commands that executed successfully before the error", "label": {"api": {"BatchUpdateException": [[85, 104]]}}}, {"text": "You could use a FileNameFilter, something like", "label": {"api": {"a FileNameFilter": [[14, 29]]}}}, {"text": "Alternatively, you could use Files::list", "label": {"api": {"Files::list": [[29, 39]]}}}, {"text": "This will give you a random number on the interval [min, max) because nextDouble includes 0 in the range of results ([0.0,1.0)) that it returns", "label": {"api": {"nextDouble": [[70, 79]]}}}, {"text": "Rather than asking for the minimum exclusively, you could ask for it inclusively -- but have the minimum be the next value of double using Math::nextUp", "label": {"api": {"Math::nextUp": [[139, 150]]}}}, {"text": "In theory, calling Math.nextUp(double d) should do it", "label": {"api": {"Math.nextUp(double d)": [[19, 39]]}}}, {"text": "Then use split() like so", "label": {"api": {"split()": [[9, 15]]}}}, {"text": "The next step is to use the String's split method to extract the values", "label": {"api": {"split method": [[37, 48]]}}}, {"text": "Finally, use the List add method to append the new `Box to your list", "label": {"api": {"add": [[22, 24]]}}}, {"text": "I use a SortedMap, implemented by a TreeMap, so the numbers will come out sorted in ascending order when getting the keySet, for nice output", "label": {"api": {"keySet": [[117, 122]]}}}, {"text": "One solution to accomplish that is with a CountDownLatch, by having the main thread wait for its count to reach zero, and having the two threads each decrease the count (the initial value of the count would be 1 in this case)", "label": {"api": {"CountDownLatch": [[42, 55]]}}}, {"text": "When creating a fixed set, I would prefer to use an enum api like this", "label": {"api": {"enum api": [[52, 59]]}}}, {"text": "See Math.sqrt javadoc for more details", "label": {"api": {"Math.sqrt javadoc": [[4, 20]]}}}, {"text": "You need to use Scanner.next(); instead of Scanner.nextLine(); because the nextLine method skips the current line", "label": {"api": {"Scanner.next();": [[16, 30]], "skips the current line": [[91, 112]]}}}, {"text": "Scanner.next() reads the next token", "label": {"api": {"Scanner.next()": [[0, 13]]}}}, {"text": "It sounds like you want to read a whole line, so use Scanner.nextLine()", "label": {"api": {"Scanner.nextLine()": [[53, 70]]}}}, {"text": "A HashSet is backed by a HashMap so you can refer to HashMap's javadoc for the rationale behind the choice of 0.75 as a default value", "label": {"api": {"HashMap's javadoc": [[53, 69]]}}}, {"text": "To solve this task you should to use javafx.concurrent.Task , Example", "label": {"api": {"javafx.concurrent.Task": [[37, 58]]}}}, {"text": "The Predicate interface is a functional interface that defines one abstract method boolean test(T t) where T in this case is the String type, since you're filtering on a Stream<String>", "label": {"api": {"Predicate": [[4, 12]]}}}, {"text": "Class objects also have a reference to the ClassLoader that loaded it, hence the getClassLoader() method in Class", "label": {"api": {"getClassLoader()": [[81, 96]]}}}, {"text": "I agree with @Jonny Henley that a simple ArrayList documentation look-up should be enough here but, in case the poster is a newbie, here's my answer", "label": {"api": {"ArrayList documentation": [[41, 63]]}}}, {"text": "I'm going to assume that elements1 and elements2 are some kind of Iterable<Element>, e.g", "label": {"api": {"Iterable<Element>": [[66, 82]]}}}, {"text": "Except that you don't have access to the Iterator", "label": {"api": {"Iterator": [[41, 48]]}}}, {"text": "but this is what the AtomicReference type is for", "label": {"api": {"AtomicReference": [[21, 35]]}}}, {"text": "You should use LocalDate rather than LocalDateTime", "label": {"api": {"LocalDate": [[15, 23], [37, 45]], "LocalDateTime": [[37, 49]]}}}, {"text": "See examples on the DateTimeFormatter class documentation page", "label": {"api": {"DateTimeFormatter": [[20, 36]]}}}, {"text": "Then you will provide your own comparator to it and use Arrays.sort(T[], Comparartor) to sort your array, as next", "label": {"api": {"Arrays.sort(T[], Comparartor)": [[56, 84]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html for more details and possible formats", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html": [[4, 69]]}}}, {"text": "If it is not good enough for you, you will need to implement your own TreeTableViewSelectionModel and set it using setSelectionModel(TreeTableView.TreeTableViewSelectionModel<S> value)", "label": {"api": {"TreeTableViewSelectionModel": [[70, 96], [147, 173]], "setSelectionModel(TreeTableView.TreeTableViewSelectionModel<S> value)": [[115, 183]]}}}, {"text": "I found JPA's CriteriaQuery#multiselect with a user-defined class, but it needs a non default constructor", "label": {"api": {"CriteriaQuery#multiselect": [[14, 38]]}}}, {"text": "I found JPA's CriteriaBuilder#construct, but it needs also a non default constructor", "label": {"api": {"CriteriaBuilder#construct": [[14, 38]]}}}, {"text": "Use a Task", "label": {"api": {"Task": [[6, 9]]}}}, {"text": "LocalDateTime doesn't have a time zone, so when you call atZone(), it's interpreted as being in the zone you're applying", "label": {"api": {"LocalDateTime": [[0, 12]], "atZone()": [[57, 64]]}}}, {"text": "This returns a ZonedDateTime formed from this date-time at the specified time-zone", "label": {"api": {"ZonedDateTime": [[15, 27]]}}}, {"text": "I've tracked down why and it is because the 3rd parameter in that method is supposed to be of the format specified in java.text.MessageFormat", "label": {"api": {"java.text.MessageFormat": [[118, 140]]}}}, {"text": "From the MessageFormat documentation", "label": {"api": {"MessageFormat documentation": [[9, 35]]}}}, {"text": "If you need more bits for a calculation you might consider BigInteger (for integral numbers) or BigDecimal (for decmial numbers)", "label": {"api": {"BigInteger": [[59, 68]], "BigDecimal": [[96, 105]]}}}, {"text": "Currently I am using the Clip class for sound effects, here's a preview of the (very basic and common) code I'm using", "label": {"api": {"Clip": [[25, 28]]}}}, {"text": "The problem with the Clip class however is that it creates a new Thread for itself on which it plays the audio", "label": {"api": {"Clip": [[21, 24]]}}}, {"text": "Indeed, as partStoreIds is an ArrayList of ArrayList only ArrayList instances can be added and since storeIds.subList(querySize*i, maxIndex) returns a List, you need to convert it first as an ArrayList using the constructor new ArrayList(Collection)", "label": {"api": {"new ArrayList(Collection)": [[224, 248]]}}}, {"text": "I'm using HttpsURLConnection (which uses methods in URLConnection)", "label": {"api": {"HttpsURLConnection": [[10, 27]], "URLConnection": [[15, 27], [52, 64]]}}}, {"text": "How to use URLConnection to refresh cache every hour", "label": {"api": {"URLConnection": [[11, 23]]}}}, {"text": "See also Enum ElementType in the Java documentation", "label": {"api": {"Enum ElementType": [[9, 24]]}}}, {"text": "Then you can simply add your byte array to your List using the add(E) method as next", "label": {"api": {"add(E)": [[63, 68]]}}}, {"text": "You will then be able to access to a given byte array from its index in the List using the method get(int) as you try to achieve", "label": {"api": {"get(int)": [[98, 105]]}}}, {"text": "The JavaDoc for TreeSet.add() states what we'd expect", "label": {"api": {"The JavaDoc for TreeSet.add()": [[0, 28]]}}}, {"text": "The standard input, output and error streams to/from a system process started from Java are accessed through the methods getOutputStream(), getInputStream() and getErrorStream() of Process", "label": {"api": {"Process": [[181, 187]]}}}, {"text": "Use Path::getFileName to get the file name from a path", "label": {"api": {"Path::getFileName": [[4, 20]]}}}, {"text": "ArrayList can the elements dynamically, so it is not required to know the size in advance", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "I'd use a regular expression", "label": {"api": {"regular expression": [[10, 27]]}}}, {"text": "See String.matches and regular expression documentation", "label": {"api": {"String.matches": [[4, 17]], "regular expression": [[23, 40]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/util/Map.html The most common classes that implement this interface for the purpose similar to yours is java.util.HashMap", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Map.html": [[0, 59]]}}}, {"text": "You can then use toArray() method to make array from the Set", "label": {"api": {"toArray()": [[17, 25]]}}}, {"text": "It is called toMap", "label": {"api": {"toMap": [[13, 17]]}}}, {"text": "toMap takes 2 functions as parameteres", "label": {"api": {"toMap": [[0, 4]]}}}, {"text": "Function.identity() returns a function that just returns its input", "label": {"api": {"Function.identity()": [[0, 18]]}}}, {"text": "If a missing row is not considered an error, catch the exception and return null (or Optional.empty())", "label": {"api": {"Optional.empty()": [[85, 100]]}}}, {"text": "However, because the string(int, int) method takes the end index to be exclusive, we should increase it by one", "label": {"api": {"string(int, int) method": [[21, 43]]}}}, {"text": "DatagramPacket's getAddress returns the IP address of the machine to which this datagram is being sent or from which the datagram was received", "label": {"api": {"DatagramPacket": [[0, 13]]}}}, {"text": "Your solution will always be deficient compared to what SimpleDateFormat is already doing for you", "label": {"api": {"SimpleDateFormat": [[56, 71]]}}}, {"text": "The class got a pre-implemented distance method wich can be checked against a radius", "label": {"api": {"distance method": [[32, 46]]}}}, {"text": "If you don't want to do the obvious (convert them to LocalDateTime¹ and compare the result), you can just compare them as strings, that particular date-time format (a nearly-full ISO-8601 timestamp, just missing a timezone indicator) works correctly when you use string comparison", "label": {"api": {"LocalDateTime": [[53, 65]]}}}, {"text": "¹ or Instant, if these are actually UTC date/times, but you'd need to add a Z to the end of the strings before parsing", "label": {"api": {"Instant": [[5, 11]]}}}, {"text": "Just create a class that extends HttpServlet and annotate it with @WebServlet", "label": {"api": {"HttpServlet": [[33, 43]], "@WebServlet": [[66, 76]]}}}, {"text": "Then override the doXXX(HttpServletRequest, HttpServletResponse) methods to handle the requests", "label": {"api": {"HttpServlet": [[24, 34], [44, 54]]}}}, {"text": "How can I parse this into the modern Date-Time types in Java, the java.time classes", "label": {"api": {"java.time": [[66, 74]]}}}, {"text": "The .jar file is not always obtainable, because ProtectionDomain.getCodeSource() is allowed to return null", "label": {"api": {"ProtectionDomain.getCodeSource() is allowed to return null": [[48, 105]]}}}, {"text": "The debug stack frame as shown above would be dynamically generated, just like a java.lang.reflect.Proxy, except that I'd like to be in full control of the entire fully qualified method name that ends up on the proxy", "label": {"api": {"java.lang.reflect.Proxy": [[81, 103]]}}}, {"text": "Per the documentation for Base64.Encoder.wrap(), you need to close the stream once you're done with it", "label": {"api": {"Base64.Encoder.wrap()": [[26, 46]]}}}, {"text": "findAny (which is preferable to findFirst if you do not need ordering) and anyMatch are short-circuiting operations, which means they can return early without consuming the entire stream if the conditions allow", "label": {"api": {"short-circuiting operations": [[88, 114]]}}}, {"text": "count() is not", "label": {"api": {"is not": [[8, 13]]}}}, {"text": "If the stream's final stage still uses a spliterator with the SIZED characteristic then count() may be as fast as the other two options", "label": {"api": {"SIZED": [[62, 66]]}}}, {"text": "But this is a far weaker property than short-circuiting since intermediate stream operations – such as filter() – are very likely to discard the SIZED aspect", "label": {"api": {"SIZED": [[145, 149]]}}}, {"text": "I have faced with inability to find all aliases for a domain name using InetAddress", "label": {"api": {"InetAddress": [[72, 82]]}}}, {"text": "According to java docs (link) method createStruct was introduced in java 1.6 so i know that ant is compiling to 1.6 and not to 1.5 as i polite ask him to do", "label": {"api": {"link": [[24, 27]]}}}, {"text": "As per the Java-Doc for java.util.Map, the hashCode and equals methods are overridden from the Object class", "label": {"api": {"java.util.Map": [[24, 36]]}}}, {"text": "creating a subclass from) ArrayList or LinkedList and overriding the set(), add(), addAll(), remove(), and removeRange() methods in such way that they ensure the uniqueness and sortedness conditions (invariants) would be a very clean design", "label": {"api": {"ArrayList": [[26, 34]]}}}, {"text": "ArrayList is a better choice to base your class on, if you aren't going to add or remove teams too frequently", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "ArrayList would give you O(n) insertion and removal, but O(log n) cost for element access and ensuring uniqueness if you use binary search (where n is the number of elements in the array)", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "The simplest code uses IntStream#summaryStatistics()", "label": {"api": {"IntStream#summaryStatistics()": [[23, 51]]}}}, {"text": "I've reached a stage where I'm going to have to change some behaviors of the AudioInputStream (thus having to override it)", "label": {"api": {"AudioInputStream": [[77, 92]]}}}, {"text": "From the AudioFormat docs", "label": {"api": {"AudioFormat docs": [[9, 24]]}}}, {"text": "You should probably use something like DateTimeFormatter.parse(CharSequence) Case in point is that your rules for leap years are incorrect", "label": {"api": {"DateTimeFormatter.parse(CharSequence)": [[39, 75]]}}}, {"text": "You should use a OneToMany relationship here with a another table that allows you to reference the rows in TrackingStatus for a single Parcel in ParcelTracking and you'll have something like", "label": {"api": {"OneToMany": [[17, 25]]}}}, {"text": "If you have only a counter, you could also consider using an instance of class AtomicInteger as counter and object monitor", "label": {"api": {"AtomicInteger": [[79, 91]]}}}, {"text": "The code will be the same as above except that you will create an instance using new AtomicInteger(1) to initialize the counter to 1 and then use get() to get the current value and incrementAndGet() to increment the counter", "label": {"api": {"AtomicInteger": [[85, 97]]}}}, {"text": "Since your use case is simple  ( just incrimenting the counter and print the value, AtomicInteger is better choice", "label": {"api": {"AtomicInteger": [[84, 96]]}}}, {"text": "A ScheduledExecutorService seems to be what you need", "label": {"api": {"ScheduledExecutorService": [[2, 25]]}}}, {"text": "Look at Executors class API and ExecutorService class API", "label": {"api": {"Executors": [[8, 16]], "ExecutorService": [[32, 46]]}}}, {"text": "Read about various implementations of ExecutorService available", "label": {"api": {"ExecutorService": [[38, 52]]}}}, {"text": "You could also investigate the ByteBuffer class which allows you to treat a byte array as an array of 16 bit short values, in whichever \"endian\" format you prefer", "label": {"api": {"ByteBuffer": [[31, 40]]}}}, {"text": "If you don't really care about the internal representation—for example, you don't have to expose it to an existing API that expects a sequence of bytes structured in a specific way—I recommend using BitSet as a simple and robust representation", "label": {"api": {"BitSet": [[199, 204]]}}}, {"text": "You can use the method List#contains() since contains will check for instances of ArrayList that are equal to the provided ArrayList which will be the case here as temp.equals(temp1) returns true since the method equals of an AbstractList compares their content and here the content of those ArrayList is equal", "label": {"api": {"List#contains()": [[23, 37]]}}}, {"text": "I annotate my @POST method arguments as @FormParam in hopes that it will require they be submitted only in an HTTP form and not as query string params", "label": {"api": {"@POST": [[14, 18]], "@FormParam": [[40, 49]]}}}, {"text": "You can access the command line parameters with Application.getParameters()", "label": {"api": {"Application.getParameters()": [[48, 74]]}}}, {"text": "You can use the @SupressWarning annotation, or, by hovering the mouse-pointer over the warning, there are options to disable for instance (auto-generates @SupressWarning), for file, for package, for project or \"forever\" (pah-dum-pshh =P)", "label": {"api": {"@SupressWarning": [[16, 30], [154, 168]]}}}, {"text": "Now, if you're stuck with a java.util.Date and there's nothing you can do about it, you should use the getTime() method (which you already know about) to decide among various SimpleDateFormat implementations for each of your output types", "label": {"api": {"SimpleDateFormat": [[175, 190]]}}}, {"text": "You can try importing and using java.sql.Time similar to this", "label": {"api": {"java.sql.Time": [[32, 44]]}}}, {"text": "The axis has these boundaries because the default value of the  autoRangingProperty is true and the default value of the forceZeroInRangeProperty is also true", "label": {"api": {"autoRangingProperty": [[64, 82]], "forceZeroInRangeProperty": [[121, 144]]}}}, {"text": "You can set the forceZeroInRangeProperty to false which will lead to have automatic ranging, but as the zero value is not forced to be displayed, the boundaries will be calculated based on the minimum and maximum value on the data displayed", "label": {"api": {"forceZeroInRangeProperty": [[16, 39]]}}}, {"text": "Either using for example the appropiate constructor to set the lower and upper bound", "label": {"api": {"constructor": [[40, 50]]}}}, {"text": "or by setting the autoRangingProperty to false and the lowerBoundProperty and the upperBoundProperty to the needed values", "label": {"api": {"autoRangingProperty": [[18, 36]], "lowerBoundProperty": [[55, 72]], "upperBoundProperty": [[82, 99]]}}}, {"text": "Example chart by setting forceZeroInRangeProperty to false", "label": {"api": {"forceZeroInRangeProperty": [[25, 48]]}}}, {"text": "Per the String JavaDoc", "label": {"api": {"String JavaDoc": [[8, 21]]}}}, {"text": "Within the same JVM, you can invoke() the main Method like they show here", "label": {"api": {"Method": [[47, 52]]}}}, {"text": "To match an actual method call on the Mock Object with an expectation, Object arguments are by default compared with equals()", "label": {"api": {"equals()": [[117, 124]]}}}, {"text": "You have to override equals(), use a built-in argument matcher (like EasyMock#anyObject), write your own IArgumentMatcher or use a Capture", "label": {"api": {"equals()": [[21, 28]]}}}, {"text": "The s stands for seconds, while S stands for fractions of a second, see Patterns for Formatting and Parsing", "label": {"api": {"Patterns for Formatting and Parsing": [[72, 106]]}}}, {"text": "If you need to format your pattern with spaces and tabs and newlines - with whitespace that will not be accounted for by the regex engine - you may use the (?x) modifier, or the Pattern.COMMENTS flag", "label": {"api": {"Pattern.COMMENTS": [[178, 193]]}}}, {"text": "Note that in case you add (?U) modifier, Pattern.UNICODE_CHARACTER_CLASS flag, \\s will match all Unicode whitespace (like [\\p{Zs}\\t\\r\\n])", "label": {"api": {"Pattern.UNICODE_CHARACTER_CLASS": [[41, 71]]}}}, {"text": "Since I am new to Apache Spark and it was my first time to use DefaultMutableTreeNode class, I can't explain the root cause but I find a way to make my code work", "label": {"api": {"DefaultMutableTreeNode": [[63, 84]]}}}, {"text": "The document of DefaultMutableTreeNode mentions This is not a thread safe class, which makes me think in Spark, passing variables of type that is thread unsafe from driver to executors may fail to pass values correctly", "label": {"api": {"DefaultMutableTreeNode": [[16, 37]]}}}, {"text": "However, my project needs a data structure like tree node, so I found this generic tree node implementation on stackoverflow to replace DefaultMutableTreeNode", "label": {"api": {"DefaultMutableTreeNode": [[136, 157]]}}}, {"text": "The fastest way to copy an array should be by using System.arraycopy()", "label": {"api": {"System.arraycopy()": [[52, 69]]}}}, {"text": "Please check out the DefaultTableModel API for the gory details", "label": {"api": {"DefaultTableModel API": [[21, 41]]}}}, {"text": "Java provides a method for that - all you need to do is to negate its result", "label": {"api": {"Java provides a method for that": [[0, 30]]}}}, {"text": "Well, the source code shows UUID.randomUUID uses SecureRandom", "label": {"api": {"UUID.randomUUID": [[28, 42]], "SecureRandom": [[49, 60]]}}}, {"text": "First of all, Java 8 supports \\Rto match a linebreak", "label": {"api": {"Java 8 supports \\Rto match a linebreak": [[14, 51]]}}}, {"text": "java.util.Date implements Comparable<Date>, so you can simply use", "label": {"api": {"java.util.Date": [[0, 13]]}}}, {"text": "I am not convinced this problem is a good fit for using the stream API, but an option would be to rely on Stream#peek() to keep a reference to one of the elements that matches the first filter, if none match the second one", "label": {"api": {"Stream#peek()": [[106, 118]]}}}, {"text": "If you only have a time to parse you can use LocalTime.parse() method", "label": {"api": {"method": [[63, 68]]}}}, {"text": "Now take a look at the methods of BitSet", "label": {"api": {"the methods of BitSet": [[19, 39]]}}}, {"text": "Since you are using Java, Comparator is nice way to achieve generality", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "In this case it says \"Unlike Comparable, a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation.\" See the comparator API", "label": {"api": {"the comparator API": [[175, 192]]}}}, {"text": "Here is a more advanced way to do it using IntStream from Java 8", "label": {"api": {"IntStream": [[43, 51]]}}}, {"text": "The DecimalFormat.format(long) method is an inherited method from the NumberFormat class — NumberFormat.format(long)", "label": {"api": {"NumberFormat.format(long)": [[91, 115]]}}}, {"text": "Another way would be to use the sublist method from the List interface to produce a new list with the 10 last elements, like this", "label": {"api": {"sublist": [[32, 38]]}}}, {"text": "Use the Graphics methods drawPolygon() to render the outline and fillPolygon() to fill its interior; both have the required signature, as shown here", "label": {"api": {"Graphics": [[8, 15]], "drawPolygon()": [[25, 37]], "fillPolygon()": [[65, 77]]}}}, {"text": "Because \"operations that draw the outline of a figure operate by traversing an infinitely thin path between pixels with a pixel-sized pen,\" cast the graphics context to Graphics2D so that you can use draw() and fill() on the corresponding Shape", "label": {"api": {"Graphics": [[169, 176]], "Graphics2D": [[169, 178]], "Shape": [[239, 243]]}}}, {"text": "I need it to have a custom thickness…I also don't want to use Graphics2D", "label": {"api": {"Graphics": [[62, 69]], "Graphics2D": [[62, 71]]}}}, {"text": "Custom thickness is not supported in the Graphics API", "label": {"api": {"Graphics": [[41, 48]]}}}, {"text": "As suggested here, the actual graphics context received by paintComponent() is an instance of Graphics2D, which does support custom stroke geometry", "label": {"api": {"Graphics": [[94, 101]], "Graphics2D": [[94, 103]]}}}, {"text": "The things is teacher haven't taught me Graphics2D, so I'm not supposed to use it", "label": {"api": {"Graphics": [[40, 47]], "Graphics2D": [[40, 49]]}}}, {"text": "I'm looking for a way to do it without Graphics2D…a guy has interpreted the question properly in this comment", "label": {"api": {"Graphics": [[39, 46]], "Graphics2D": [[39, 48]]}}}, {"text": "You can use AffineTransform to do the scaling", "label": {"api": {"AffineTransform": [[12, 26]]}}}, {"text": "While Graphics can't fill() an arbitrary Shape, such as one created by AffineTransform, it can clip the rendering as required", "label": {"api": {"Graphics": [[6, 13]], "AffineTransform": [[71, 85]], "Shape": [[41, 45]]}}}, {"text": "If you really want to be able to choose a binary function, look at BinaryOperator", "label": {"api": {"BinaryOperator": [[67, 80]]}}}, {"text": "The documentation does say that the order of iteration is not guaranteed", "label": {"api": {"say": [[23, 25]]}}}, {"text": "You tell FileSystem.getPathMatcher(String) to interpret the pattern as a \"glob\" instead of \"regex\"", "label": {"api": {"FileSystem.getPathMatcher(String)": [[9, 41]]}}}, {"text": "Here is the java.util.concurrent.FutureTask doc page, and here am using lambda expression without creating Callable implementation class, and here is My code just want to test how callable interface works but result make me unsatisfied", "label": {"api": {"Here is the java.util.concurrent.FutureTask doc page": [[0, 51]]}}}, {"text": "So a few points from the LinkedBlockingQueue Javadoc", "label": {"api": {"LinkedBlockingQueue Javadoc": [[25, 51]]}}}, {"text": "You can't remove a method, not without changing the byte code and breaking the code's \"contract\", but you could extend the class and have the child class's method override throw an UnsupportedOperationException if called", "label": {"api": {"UnsupportedOperationException": [[181, 209]]}}}, {"text": "You will need to use a regular expression and as you need to only replace the last match, you will need to reverse everything using StringBuilder#reverse() and use a reversed regular expression so instead of using \\b123\\b we use \\b321\\b, so your final code will be", "label": {"api": {"StringBuilder#reverse()": [[132, 154]]}}}, {"text": "If your priority is inserting and/or removing elements from a collection that maintains an arbitrary order, the the LinkedList class bundled with Java meets that need", "label": {"api": {"LinkedList": [[116, 125]]}}}, {"text": "The downside to LinkedList is that access by index number is expensive as finding the nth element means traversing n links going from one element to the next in the chain", "label": {"api": {"LinkedList": [[16, 25]]}}}, {"text": "Another downside to LinkedList is searching, for similar reason (sequential access)", "label": {"api": {"LinkedList": [[20, 29]]}}}, {"text": "Both LinkedList and ArrayList allow duplicates", "label": {"api": {"LinkedList": [[5, 14]]}}}, {"text": "Neither LinkedList nor ArrayList are thread-safe", "label": {"api": {"LinkedList": [[8, 17]]}}}, {"text": "If you want to load an image file stored right next to your class file, use Class::getResourceAsStream(String name)", "label": {"api": {"Class::getResourceAsStream(String name)": [[76, 114]]}}}, {"text": "With a 48-bit seed, you should find approximately 28 thousand seeds that do the same thing", "label": {"api": {"48-bit seed": [[7, 17]]}}}, {"text": "Invoke the parent class's paintComponent() to avoid \"visual artifacts.\" Use the coordinates passed to the constructor in your implementation", "label": {"api": {"paintComponent()": [[26, 41]]}}}, {"text": "Don't make equals do anything more than what the contract says it should do", "label": {"api": {"contract": [[49, 56]]}}}, {"text": "Instead, use a check for indexOf to see if the element already exists in the List", "label": {"api": {"indexOf": [[25, 31]]}}}, {"text": "If you don't want the collection to contain any duplicates and you don't care about the order of elements, however, you should be using a HashSet instead of a List", "label": {"api": {"HashSet": [[138, 144]]}}}, {"text": "This will automatically keep out duplicates by checking equals, and will return false on the add method when a duplicate exists", "label": {"api": {"add": [[93, 95]]}}}, {"text": "You will need to override the hashCode method on your object also", "label": {"api": {"hashCode": [[30, 37]]}}}, {"text": "You can use the regular expressions syntax as described in the java.util.regex.Pattern javadoc", "label": {"api": {"java.util.regex.Pattern javadoc": [[63, 93]]}}}, {"text": "That way you use the setBounds(Rectangle r) inherited from java.awt.Component in JComponent", "label": {"api": {"setBounds(Rectangle r)": [[21, 42]]}}}, {"text": "It can be done thanks to a JFXPanel which allows to embed a JavaFX component into a Swing component and from a Swing component you can easily create an Applet", "label": {"api": {"JFXPanel": [[27, 34]]}}}, {"text": "(4) I know that synchronizedList's Iterator should be part of 'synchronized' block (https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#synchronizedList(java.util.List), does it require the lock (synchronization) for accessing the 'synchronizedList.get(index)' method (like in above)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#synchronizedList(java.util.List)": [[84, 184]]}}}, {"text": "Is it possible to provide a Seed to a ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[38, 54]]}}}, {"text": "So can we use ThreadLocalRandom using seed or it's not designed for that", "label": {"api": {"ThreadLocalRandom": [[14, 30]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#getContentLengthLong() for more info", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#getContentLengthLong()": [[4, 95]]}}}, {"text": "In this case, there should only be one @Joincolumn and one entity must be selected as the owning entity, with the other entity marking the relation with a 'mappedby' (see http://docs.oracle.com/javaee/6/api/javax/persistence/ManyToOne.html)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/ManyToOne.html": [[171, 238]]}}}, {"text": "One way could be to use XPaths to match the required node(s)", "label": {"api": {"XPaths": [[24, 29]]}}}, {"text": "Unfortunately, IntStream doesn't have a sorted method that takes a Comparator (only a parameterless method, that's why you have to box and unbox to use Stream.sorted(Comparator)", "label": {"api": {"IntStream": [[15, 23]], "parameterless method": [[86, 105]], "Stream.sorted(Comparator)": [[152, 176]]}}}, {"text": "Once you will use the correct BigInteger class, you will have to use BigInteger.valueOf(long) to create your instances and BigInteger.add(BigInteger) to add values as next", "label": {"api": {"BigInteger.valueOf(long)": [[69, 92]], "BigInteger.add(BigInteger)": [[123, 148]]}}}, {"text": "You could use the built-in version instead", "label": {"api": {"built-in version": [[18, 33]]}}}, {"text": "Well, first, convert that String into a Date object using a SimpleDateFormat object", "label": {"api": {"SimpleDateFormat": [[60, 75]]}}}, {"text": "Then, if you are using plain statements, reformat it the way Oracle would accept it in an SQL INSERT command, using again a SimpleDateFormat object", "label": {"api": {"SimpleDateFormat": [[124, 139]]}}}, {"text": "I would recommend you to better use a PreparedStatement instead of a plain SQL INSERT statement so your statement is sanitized", "label": {"api": {"PreparedStatement": [[38, 54]]}}}, {"text": "See Integer.parse(String s, radix) method", "label": {"api": {"Integer.parse(String s, radix)": [[4, 33]]}}}, {"text": "The List interface specifies its equals and hashCode contract and any implementation that changed that would be in violation", "label": {"api": {"equals": [[33, 38]], "hashCode": [[44, 51]]}}}, {"text": "Depending on the complexity of your program, it could be done using 2 CountDownLatch to synchronize your threads, one to release Client1 once Client2 has done reading and another one to release Client3 once Client1 has done reading", "label": {"api": {"CountDownLatch": [[70, 83]]}}}, {"text": "Create your instance of ConcurrentHashMap with the constructor ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) in order to set the concurrencyLevel corresponding to the total amount of segments to use knowing that by default it is 16 and choose it wisely as using a significantly higher value than what you need can waste space and time, and a significantly lower value can lead to thread contention", "label": {"api": {"ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)": [[63, 140]]}}}, {"text": "It creates a primaryStage and launches the javafx ui thread", "label": {"api": {"Stage": [[20, 24]]}}}, {"text": "You can have as many Stages as you want", "label": {"api": {"Stage": [[21, 25]]}}}, {"text": "Application provides you with a Stage in the start method, which has some special properties, compared to manually created Stages", "label": {"api": {"Application": [[0, 10]], "Stage": [[32, 36], [123, 127]]}}}, {"text": "Every Stage can hold exactly one Scene at a time", "label": {"api": {"Stage": [[6, 10]], "Scene": [[33, 37]]}}}, {"text": "Scenes can be swapped out, but is discouraged to do so", "label": {"api": {"Scene": [[0, 4]]}}}, {"text": "It is better to just swap out the root of the Scene", "label": {"api": {"Scene": [[46, 50]]}}}, {"text": "Every Scene needs exactly one Parent as the root", "label": {"api": {"Scene": [[6, 10]], "Parent": [[30, 35]]}}}, {"text": "You can have a FXML file describe a single Button or the root Node of a Scene and all its children", "label": {"api": {"Scene": [[72, 76]]}}}, {"text": "FXML is not bound to a single Scene", "label": {"api": {"Scene": [[30, 34]]}}}, {"text": "If you want you can have the FXML file describe a Label and a Textfield inside a GridPane (like a standart input formular) and load it every time you need this arrangement somewhere (as often as you want, even in a single Scene)", "label": {"api": {"Scene": [[222, 226]]}}}, {"text": "You can use String#indexOf(char) to find the index in the String of the separator then use String#substring to extract the sub strings, as next", "label": {"api": {"String#indexOf(char)": [[12, 31]]}}}, {"text": "You could use Arrays.sort() to sort your String-array names, and then get the first item", "label": {"api": {"Arrays.sort()": [[14, 26]]}}}, {"text": "If the Spliterator used has the CONCURRENT characteristic, then the stream is thread-safe", "label": {"api": {"Spliterator": [[7, 17]], "CONCURRENT": [[32, 41]]}}}, {"text": "ConcurrentHashMap reports CONCURRENT for its views, while HashMap does not", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "each operation in a pipeline defines which properties the user-supplied methods should have, the key concepts are non-interference, statefulness and side-effects", "label": {"api": {"non-interference": [[114, 129]]}}}, {"text": "Compare filter and peek", "label": {"api": {"filter": [[8, 13]], "peek": [[19, 22]]}}}, {"text": "Collector/Collectors don't spell out their requirements quite as clearly, but the supplied functions should generally be non-interfering, side-effect-free and stateless just like intermediate ops, especially when concurrent collectors are used", "label": {"api": {"Collector": [[0, 8], [10, 18]], "Collectors": [[10, 19]]}}}, {"text": "You could simply use .or between the 2 Predicates", "label": {"api": {".or": [[21, 23]]}}}, {"text": "groupingBy does exactly what you want", "label": {"api": {"groupingBy": [[0, 9]]}}}, {"text": "You need some kind of loop to iterate through the BufferedReader", "label": {"api": {"BufferedReader": [[50, 63]]}}}, {"text": "See API for BufferedReader", "label": {"api": {"BufferedReader": [[12, 25]]}}}, {"text": "Please look at class AtomicInteger", "label": {"api": {"AtomicInteger": [[21, 33]]}}}, {"text": "And yes you AtomicInteger variable will need to be static, so it will be the same instance available to to all your Threads", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "You could use a ByteArrayOutputStream to store the content of each byte arrays of your list but to make it efficient, we would need to create the instance of ByteArrayOutputStream with an initial size that matches the best as possible with the target size, so if you know the size or at least the average size of the array of bytes, you should use it, the code would be", "label": {"api": {"ByteArrayOutputStream": [[16, 36], [158, 178]]}}}, {"text": "Another approach would be to use SequenceInputStream in order to logically concatenate all the ByteArrayInputStream instances representing one element of your list, as next", "label": {"api": {"SequenceInputStream": [[33, 51]]}}}, {"text": "Use the ifPresent method", "label": {"api": {"ifPresent method": [[8, 23]]}}}, {"text": "You cannot put table name as parameter using PreparedStatement", "label": {"api": {"PreparedStatement": [[45, 61]], "Statement": [[53, 61]]}}}, {"text": "Concatenating string to execute query with dynamic table name using Statement is possible, however it is not recommended because of risk of SQL injection", "label": {"api": {"Statement": [[68, 76]]}}}, {"text": "It could be done using String#split(regex) as next", "label": {"api": {"String#split(regex)": [[23, 41]]}}}, {"text": "Now, for you infinite loop problem, when hasNextDouble() is false, it means that the user entered something wrong (ignoring the potential end-of-stream issue)", "label": {"api": {"hasNextDouble()": [[41, 55]]}}}, {"text": "In that case you need to discard that bad input, which is best done by calling nextLine()", "label": {"api": {"nextLine()": [[79, 88]]}}}, {"text": "Use a TextFromatter to convert the TextField's text to another type instead", "label": {"api": {"TextFromatter": [[6, 18]]}}}, {"text": "It seems that you want to use replaceAll which uses a regex instead of replace that doesn't", "label": {"api": {"replaceAll": [[30, 39]]}}}, {"text": "If you check the replaceAll javadocs you will find", "label": {"api": {"replaceAll": [[17, 26]]}}}, {"text": "According to the Javadocs for the next() method of java.util.Scanner", "label": {"api": {"Javadocs for the next() method of java.util.Scanner": [[17, 67]]}}}, {"text": "What you could do instead is make use of the fact that the String class has a method toCharArray(), which returns the sequence of characters in the string as an array", "label": {"api": {"toCharArray()": [[85, 97]]}}}, {"text": "HashSet#add() returns true if the set did not contain the specified element", "label": {"api": {"HashSet#add()": [[0, 12]]}}}, {"text": "read(byte[] b, int off, int len) is not required to fill the buffer", "label": {"api": {"read(byte[] b, int off, int len)": [[0, 31]]}}}, {"text": "Each of these operations can also be done using DoubleStream from Java 8", "label": {"api": {"DoubleStream": [[48, 59]]}}}, {"text": "See http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more details", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html": [[4, 72]]}}}, {"text": "If you want to execute your task sequentially simply create a ExecutorService with only one thread thanks to Executors.newSingleThreadExecutor()", "label": {"api": {"ExecutorService": [[62, 76]], "Executors.newSingleThreadExecutor()": [[109, 143]]}}}, {"text": "If you have different type of tasks and you want to execute only the tasks of the same type sequentially, you can use the same single threaded ExecutorService for the same type of tasks, no need to reinvent the wheel", "label": {"api": {"ExecutorService": [[143, 157]]}}}, {"text": "So let's say that you have 1 000 different type of tasks, you could use 200 single threaded ExecutorService, the only thing that you need to implement yourself is the fact that you always need to use the same single threaded ExecutorService for a given type of task", "label": {"api": {"ExecutorService": [[92, 106], [225, 239]]}}}, {"text": "Why don't you check the HTTP status code family", "label": {"api": {"HTTP status code family": [[24, 46]]}}}, {"text": "Based on the CSS reference of TabPane and the source code of TabPaneSkin", "label": {"api": {"CSS reference": [[13, 25]]}}}, {"text": "UTF-8 is the standard Charset that is used", "label": {"api": {"UTF-8": [[0, 4]]}}}, {"text": "You are trying to decode the data packet as ASCII (which is the default encoding of the decode() function) but I'm guessing its ISO_8859_1 or UTF-8 (more likely)", "label": {"api": {"UTF-8": [[142, 146]]}}}, {"text": "You can do this using a ThreadLocal", "label": {"api": {"ThreadLocal": [[24, 34]]}}}, {"text": "It is still possible to leak drivers, but only if threads die without removing their value from the ThreadLocal", "label": {"api": {"ThreadLocal": [[100, 110]]}}}, {"text": "You should convert your tasks into a sub class of SwingWorker, then you will be able to use a PropertyChangeListener in order to modify the text of your status whenever the progress of your task evolves", "label": {"api": {"SwingWorker": [[50, 60]]}}}, {"text": "Instead of using a for-loop over m's size, I recommend iteration over m's keySet() via a foreach-loop", "label": {"api": {"keySet()": [[74, 81]]}}}, {"text": "You should bind the types of the Map and HashMap properly (see the Javadoc of Map for details)", "label": {"api": {"Javadoc of Map": [[67, 80]]}}}, {"text": "The workaround is based on the fact that File.getAbsolutFile() by default returns the directory resolved against the directory defined by user.dir option", "label": {"api": {"File.getAbsolutFile()": [[41, 61]]}}}, {"text": "String.split(\"\") will split a String into all its parts", "label": {"api": {"String.split(\"\")": [[0, 15]]}}}, {"text": "Support for Java 8's Optional<T>, like the rest of Java 8 support, came out in Guice 4.0 (Apr 2015), and only when using the Multibindings OptionalBinder", "label": {"api": {"Java 8's Optional<T>": [[12, 31]]}}}, {"text": "You need to look at Scanner's delimeter and findInLine functions", "label": {"api": {"delimeter": [[30, 38]], "findInLine": [[44, 53]]}}}, {"text": "If the elements of the list are Comparable, then you could do it like this", "label": {"api": {"Comparable": [[32, 41]]}}}, {"text": "You can use the equals or equalsIgnoreCase methods to check your string inputs", "label": {"api": {"equalsIgnoreCase": [[26, 41]]}}}, {"text": "Compare to today’s date via the LocalDate class", "label": {"api": {"LocalDate": [[32, 40]]}}}, {"text": "The YearMonth class provides that feature", "label": {"api": {"YearMonth": [[4, 12]]}}}, {"text": "It could be achieved with a WriterInterceptor", "label": {"api": {"WriterInterceptor": [[28, 44]]}}}, {"text": "After consulting their API docs, I have not been able to figure out how to go about converting a typical ThreadPoolExecutor into a pool of Fibers", "label": {"api": {"ThreadPoolExecutor": [[105, 122]]}}}, {"text": "I am looking at the Scanner documentation (https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html) and I see that there are conditional hasNext methods that only return true if the next element satisfies a certain condition", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[43, 106]]}}}, {"text": "The hasNext(Pattern pattern) should do the job, or hasNext(String pattern) which additionally compiles the pattern from String to Pattern", "label": {"api": {"hasNext(Pattern pattern)": [[4, 27]], "hasNext(String pattern)": [[51, 73]]}}}, {"text": "Stage defines a showAndWait method that will show the window and then block execution until the window is dismissed", "label": {"api": {"showAndWait": [[16, 26]]}}}, {"text": "It does some magic to ensure the UI remains responsive while the code execution is blocked.) So one approach is to call showAndWait in your loop, as this will prevent the loop progressing to the next iteration until the window is dismissed", "label": {"api": {"showAndWait": [[120, 130]]}}}, {"text": "to allow the user to choose a file, you might consider using a FileChooser (tutorial)", "label": {"api": {"FileChooser": [[63, 73]]}}}, {"text": "Use a OutputStreamWriter to specify the target encoding with the constructor new PrintWriter(writer), so it should be something like that", "label": {"api": {"OutputStreamWriter": [[6, 23]], "new PrintWriter(writer)": [[77, 99]]}}}, {"text": "You can use a CountDownLatch to make one thread await until an operation performed by another thread is completed", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "Let's suppose T1 and T2 are your threads and they share a CountDownLatch initialized with a counter of 1", "label": {"api": {"CountDownLatch": [[58, 71]]}}}, {"text": "Have a look at the split() method for Strings", "label": {"api": {"split()": [[19, 25]]}}}, {"text": "You basically just need to create a File object and run the getCanonicalPath() method to get what you want", "label": {"api": {"the getCanonicalPath() method": [[56, 84]]}}}, {"text": "you want to read about java.lang.Math.max() which already provides exactly that functionality (not only for int, but all the other numerical primitive types as well)", "label": {"api": {"java.lang.Math.max()": [[23, 42]]}}}, {"text": "scheduleAtFixedRate is probably what you want as it will wait for your tasks to finish, iff one takes longer than the rate you specify", "label": {"api": {"scheduleAtFixedRate": [[0, 18]]}}}, {"text": "You could construct a SimpleDateFomat that matches your format and use that", "label": {"api": {"SimpleDateFomat": [[22, 36]]}}}, {"text": "As you are talking about simple things that would fit into environment variables, the natural thing to use would be java Properties", "label": {"api": {"Properties": [[121, 130]]}}}, {"text": "For recover, if you don't need to return a superclass and want to swallow all exceptions, you could just use exceptionally", "label": {"api": {"exceptionally": [[109, 121]]}}}, {"text": "Otherwise, you need to use handle to get a CompletableFuture<CompletableFuture<U>>, and then use thenCompose to collapse it", "label": {"api": {"handle": [[27, 32]], "thenCompose": [[97, 107]]}}}, {"text": "You can use int arrays with Random class", "label": {"api": {"Random": [[28, 33]]}}}, {"text": "Since you literally want to skip the \"r\" then read the number, you could use Scanner#skip", "label": {"api": {"Scanner#skip": [[77, 88]]}}}, {"text": "The documentation for Scanner explains this quite clearly in the intro text, and even shows an example", "label": {"api": {"explains this quite clearly": [[30, 56]]}}}, {"text": "Seems as though you're displaying the default toString() inherited from java.lang.Object", "label": {"api": {"toString()": [[46, 55]]}}}, {"text": "More detailed info can be found at JavaFX CSS Reference Guide in Scatter Chart section", "label": {"api": {"JavaFX CSS Reference Guide": [[35, 60]]}}}, {"text": "I could now implement an ExceptionMapper<StaleStateException> for Jersey to deliver a HTTP 503 response with a Retry-After header or something like that to the client to tell it to retry its request", "label": {"api": {"ExceptionMapper<StaleStateException>": [[25, 60]]}}}, {"text": "As @Andrew said, you can use a new Color(int rgb)", "label": {"api": {"new Color(int rgb)": [[31, 48]]}}}, {"text": "If you want to parse an unsigned decimal number, just do it with a Scanner", "label": {"api": {"Scanner": [[67, 73]]}}}, {"text": "With the Scanner#hasNextInt (and the equivalent for double), you can avoid having exceptions thrown, and thus don't need try-catch clauses", "label": {"api": {"Scanner#hasNextInt": [[9, 26]]}}}, {"text": "This is actually/coincidentally very similar to the implementation of BufferedReader.lines() (which is internally used by Files.lines(Path))", "label": {"api": {"BufferedReader.lines()": [[70, 91]], "Files.lines(Path)": [[122, 138]]}}}, {"text": "It may be less overhead not to use both of these methods but instead use Files.newBufferedReader(Path) and BufferedReader.readLine() directly", "label": {"api": {"Files.newBufferedReader(Path)": [[73, 101]], "BufferedReader.readLine()": [[107, 131]]}}}, {"text": "I believe a Semaphore is exactly what you are after", "label": {"api": {"Semaphore": [[12, 20]]}}}, {"text": "Considering that Semaphore.acquire() is blocking, if you are submitting hundreeds of this processes and these take a long time to complete, it is possible that all the threads in the ThreadPoolTaskExecutor will block waiting for a permit", "label": {"api": {"Semaphore": [[17, 25]]}}}, {"text": "You could probably achieve level exclusivity using three ReadWriteLocks, one for each level", "label": {"api": {"ReadWriteLock": [[57, 69]]}}}, {"text": "If you really want priority functionality you could control access using a queue - a PriorityQueue is an obvious choice", "label": {"api": {"PriorityQueue": [[85, 97]]}}}, {"text": "So, you have to parametrize the JVM through the standard Java network properties to make it use the system proxy", "label": {"api": {"Java network properties": [[57, 79]]}}}, {"text": "Use System.setProperty instead", "label": {"api": {"System.setProperty": [[4, 21]]}}}, {"text": "ReentrantLock is one of the alternatives to synchronization", "label": {"api": {"ReentrantLock": [[0, 12]]}}}, {"text": "Just go for Random.nextInt() then, like", "label": {"api": {"Random.nextInt()": [[12, 27]]}}}, {"text": "The problem is that the first call to Logger.getLogger during class loading reads the log configuration and your configureLogger method fails due to JDK-8033661", "label": {"api": {"Logger.getLogger": [[38, 53]]}}}, {"text": "To workaround this you have to ensure that configureLogger runs before the first call to Logger.getLogger", "label": {"api": {"Logger.getLogger": [[89, 104]]}}}, {"text": "Otherwise you can use the LogManager config option to manually setup your configuration", "label": {"api": {"LogManager config option to manually setup your configuration": [[26, 86]]}}}, {"text": "In the LocalDateTime class, there is a method to convert epoch second and nano second to UTC time", "label": {"api": {"LocalDateTime": [[7, 19]]}}}, {"text": "However, it obtains an instance of LocalDateTime using seconds from the epoch of 1970-01-01T00:00:00Z", "label": {"api": {"LocalDateTime": [[35, 47]]}}}, {"text": "You can try to schedule a task using ScheduledExecutorService to print the next characters with an initial delay", "label": {"api": {"schedule": [[15, 22]]}}}, {"text": "Then reschedule with the next characters to print until you finish", "label": {"api": {"schedule": [[7, 14]]}}}, {"text": "You can get exactly the serialVersionUID of any class whether the field is present or not, via ObjectStreamClass.forName(String).getSerialVersionUID()", "label": {"api": {"ObjectStreamClass.forName(String)": [[95, 127]], ".getSerialVersionUID()": [[128, 149]]}}}, {"text": "I recently came across the sources of AWT's EventQueue where I saw this piece of code", "label": {"api": {"EventQueue": [[44, 53]]}}}, {"text": "So you're synchronizing on different objects each time (unless amt happens to be zero, and balance.intValue() is in the range cached by your JVM's implementation of Integer.valueOf)", "label": {"api": {"in the range cached by your JVM's implementation of Integer.valueOf": [[113, 179]]}}}, {"text": "As suggested by Andy, to use AtomicInteger", "label": {"api": {"AtomicInteger": [[29, 41]]}}}, {"text": "Then, in your Thread code each thread gets top 1000 (using this method) records from the queue and does it's processing", "label": {"api": {"using this method": [[53, 69]]}}}, {"text": "Just create a Set with the content of your List (using HashSets copy constructor) and compare sizes", "label": {"api": {"copy constructor": [[64, 79]]}}}, {"text": "Setting up the defaultExceptionHandler doesn't help", "label": {"api": {"defaultExceptionHandler": [[15, 37]]}}}, {"text": "If you want to print it out properly, you could use Arrays.toString(byte[])", "label": {"api": {"Arrays.toString(byte[])": [[52, 74]]}}}, {"text": "A LinkedList is not thread-safe so you can't share it with several threads as you currently do otherwise you will face unpredictable bugs like this one due to concurrent modifications that lead to an inconsistent state, use instead a thread-safe deque such as ConcurrentLinkedDeque", "label": {"api": {"ConcurrentLinkedDeque": [[260, 280]]}}}, {"text": "Instead, you can use javax.swing.Timer which is made to do what you're trying to do", "label": {"api": {"javax.swing.Timer": [[21, 37]]}}}, {"text": "The javax.swing.Timer has two features that can make it a little easier to use with GUIs", "label": {"api": {"javax.swing.Timer": [[4, 20]]}}}, {"text": "Since you're calling compareTo(Object) on Strings, you need to check then if the result is bigger than zero", "label": {"api": {"compareTo(Object)": [[21, 37]]}}}, {"text": "The simplest way to find a word in a char array is probably to convert it first into a String, then use contains as next no need to reinvent the wheel", "label": {"api": {"contains": [[104, 111]]}}}, {"text": "This is the most basic way which is case sensitive and will return true if the word is only a subpart of a bigger word, so something more appropriate would be to use matches with a case insensitive regular expression that defines the word boundaries as below", "label": {"api": {"matches": [[166, 172]]}}}, {"text": "For instance using CountdownLatch", "label": {"api": {"CountdownLatch": [[19, 32]]}}}, {"text": "My reading of the CertificateFactory.generateCertificate() docs left one case unclear to me, what should be returned when the stream is positioned at EOF", "label": {"api": {"CertificateFactory.generateCertificate()": [[18, 57]]}}}]