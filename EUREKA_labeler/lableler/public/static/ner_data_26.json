[{"text": "Unless you store a separate map of names to Person objects, you have to loop through the keySet of the map, comparing each key to the string", "label": {"api": {"keySet": [[89, 94]]}}}, {"text": "What you need is to assign you lambda expression to a Predicate and not a Consumer because as JB Nizet commented - a Predicate returns a boolean and a Consumer returns void", "label": {"api": {"Predicate": [[54, 62], [117, 125]], "Consumer": [[74, 81], [151, 158]]}}}, {"text": "You might want to look at the Java Documentation for Predicate and Consumer to understand a bit more how to use both Functional Interfaces", "label": {"api": {"Predicate": [[53, 61]], "Consumer": [[67, 74]]}}}, {"text": "You can use method between from ChronoUnit", "label": {"api": {"ChronoUnit": [[32, 41]]}}}, {"text": "I have problem while deserializing javax.json.JsonObject that is fetched from rest endpoint that returns javax.json.JsonObject", "label": {"api": {"JsonObject": [[46, 55], [116, 125]]}}}, {"text": "After little debugging, I found that exception coming from Johnzone JsonObject implementation, and it is NullPointerException when using method JsonObject.getJsonObject(name)", "label": {"api": {"JsonObject": [[68, 77], [144, 153], [158, 167]]}}}, {"text": "From javadoc for JsonObject it saying that method should not throw exception if no mapping for name is found", "label": {"api": {"JsonObject": [[17, 26]]}}}, {"text": "And this is problem for me because JsonObject.getJsonObject(name) is called in third party library", "label": {"api": {"JsonObject": [[35, 44], [49, 58]]}}}, {"text": "Is there workround to use another javax.json.JsonObject implementation when application war is run in TomEE server", "label": {"api": {"JsonObject": [[45, 54]]}}}, {"text": "This makes some sense, because the generic type of the field is erased--not readable at runtime--and because Java's reflection methods getDeclaredFields and getDeclaredMethods are returned \"not in any particular order\"", "label": {"api": {"\"not in any particular order\"": [[189, 217]]}}}, {"text": "Given a String of binary called str and some sort of OutputStream (e.g", "label": {"api": {"OutputStream": [[53, 64]]}}}, {"text": "a FileOutputStream) called out", "label": {"api": {"OutputStream": [[6, 17]], "FileOutputStream": [[2, 17]]}}}, {"text": "For every 8 characters in str, get the byte's numerical value with Integer.parseInt, and write it to out", "label": {"api": {"Integer.parseInt": [[67, 82]], "write": [[89, 93]]}}}, {"text": "Another more advanced method to format numbers in general, is NumberFormat", "label": {"api": {"NumberFormat": [[62, 73]]}}}, {"text": "I was planning to wrap each source queue in a separate class which would override add/offer methods and trigger this class's notFull and notEmpty conditions just like in the sample usage of Condition , but, being new to Java queues, I thought there might be a better/safer/more efficient approach or a library already in place", "label": {"api": {"Condition": [[190, 198]]}}}, {"text": "If the \"\\n\" always occurs at the end, use String.trim() [this won't remove the period, however, if you care about doing that]", "label": {"api": {"String.trim()": [[42, 54]]}}}, {"text": "If you want to eliminate internal newlines, you could use String.replaceAll()", "label": {"api": {"String.replaceAll()": [[58, 76]]}}}, {"text": "You could also copy the string into a StringBuilder or array to construct a new string, skipping over the elements you wish to discard, or you could locate the relevant indices and use substring() to get a substring that excludes the elements you don't like", "label": {"api": {"StringBuilder": [[38, 50]], "substring()": [[185, 195]]}}}, {"text": "Character.toTitleCase(char c) only handles 1:1 mappings (e.g", "label": {"api": {"Character.toTitleCase(char c)": [[0, 28]]}}}, {"text": "You should better use a PrintWriter, which is more comfortable", "label": {"api": {"PrintWriter": [[24, 34]]}}}, {"text": "If an annotation has its rentention policy set to RUNTIME or CLASS, it will actually be included in the class file", "label": {"api": {"rentention policy": [[25, 41]]}}}, {"text": "The function you're looking for is double atan(double tangent) which, given the tangent, will return the angle in radians", "label": {"api": {"double atan(double tangent)": [[35, 61]]}}}, {"text": "From there, you can simply multiply it by 180 / PI to get degrees or, better yet, use the inbuilt double toDegrees(double radians)", "label": {"api": {"double toDegrees(double radians)": [[98, 129]]}}}, {"text": "I would suggest using ResourceBundle class as it is widely accepted way for localization", "label": {"api": {"ResourceBundle": [[22, 35]]}}}, {"text": "If you want to log unchecked exceptions, catch RuntimeException and log them", "label": {"api": {"RuntimeException": [[47, 62]], "Exception": [[54, 62]]}}}, {"text": "To log all exceptions, catch Exception and log them", "label": {"api": {"Exception": [[29, 37]]}}}, {"text": "To also log errors, catch Throwable and log them", "label": {"api": {"Throwable": [[26, 34]]}}}, {"text": "If you use threads, you'd want to do this in the run() method of the Runnable / Thread", "label": {"api": {"Runnable": [[69, 76]], "Thread": [[80, 85]]}}}, {"text": "In a Servlet web application, you might do that in a Filter, and rethrow the exception so container can handle error correctly", "label": {"api": {"Filter": [[53, 58]]}}}, {"text": "Java appears to have Files.createFile for this", "label": {"api": {"Files.createFile": [[21, 36]]}}}, {"text": "Additionally, you have a more fuzzy File.setExecutable to do it after the fact, which is not Unix canonical behavior, but probably fine for your use case", "label": {"api": {"File.setExecutable": [[36, 53]]}}}, {"text": "The StackOverFlow infact is a runtime error", "label": {"api": {"StackOverFlow": [[4, 16]]}}}, {"text": "collections with no duplicates), the natural solution would be to use Sets", "label": {"api": {"Sets": [[70, 73]]}}}, {"text": "Due to the nature of the setDoOutput(boolean) (Java-Doc) method it can be used to detect the internal state like this", "label": {"api": {"Java-Doc": [[47, 54]]}}}, {"text": "Using Spring's htmlEscape(String input, String encoding) you can pass an encoding like \"UTF-8\"", "label": {"api": {"\"UTF-8\"": [[87, 93]]}}}, {"text": "You can use java-7 Path class", "label": {"api": {"Path": [[19, 22]]}}}, {"text": "Yes, clone creates a copy of your object including all the properties, but, as stated at the Java docs", "label": {"api": {"at the Java docs": [[86, 101]]}}}, {"text": "Please, also be aware of the restrictions and conventions defined by clone method", "label": {"api": {"restrictions and conventions defined by clone method": [[29, 80]]}}}, {"text": "Are you thinking about something like Optional", "label": {"api": {"Optional": [[38, 45]]}}}, {"text": "I want to use the default configured with mail.from property for the javax.mail.Session (defined in context.xml)", "label": {"api": {"mail.from": [[42, 50]], "javax.mail.Session": [[69, 86]]}}}, {"text": "Java's MimeMessage#setFrom method supports that feature", "label": {"api": {"MimeMessage#setFrom": [[7, 25]]}}}, {"text": "The ArrayList.hashCode implementation has that property", "label": {"api": {"List.hashCode": [[9, 21]]}}}, {"text": "Note that Set and List both define how implementations must define equals and hashCode (Set.hashCode, List.hashCode), so any (compliant) implementation of those respective collections is going to look pretty much the same", "label": {"api": {"Set.hashCode": [[88, 99]], "List.hashCode": [[102, 114]]}}}, {"text": "You're asking about the JVM specification, but your test demonstrates the behavior of java.lang.ClassLoader, an independent class which is \"invoked by the Java virtual machine to resolve class references\"", "label": {"api": {"\"invoked by the Java virtual machine to resolve class references\"": [[139, 203]]}}}, {"text": "Use map to convert from Optional<String> to Optional<Long>", "label": {"api": {"map": [[4, 6]]}}}, {"text": "The Screen API allows you to check the values you have are within the bounds of the current configuration", "label": {"api": {"Screen API": [[4, 13]]}}}, {"text": "The idea is to keep a map of keys and Runnables", "label": {"api": {"Runnable": [[38, 45]]}}}, {"text": "By having Runnable as value it is possible to define a void method reference without parameters", "label": {"api": {"Runnable": [[10, 17]]}}}, {"text": "As for Java 1.8, the methods addExact, subtractExact and multiplyExact have been added to the API to provide this feature, as pointed out by @Tom in the comments", "label": {"api": {"addExact": [[29, 36]], "subtractExact": [[39, 51]], "multiplyExact": [[57, 69]]}}}, {"text": "Use the method EnumSet.noneOf", "label": {"api": {"EnumSet.noneOf": [[15, 28]]}}}, {"text": "Please, check CopyOnWriteArrayList It will allow you to change the list atomically and get valid list snapshot every time you iterate/search through it", "label": {"api": {"CopyOnWriteArrayList": [[14, 33]]}}}, {"text": "Drawback is that underlying array is copied on every CopyOnWriteArrayList modification", "label": {"api": {"CopyOnWriteArrayList": [[53, 72]]}}}, {"text": "-1 is the value that String.indexOf() returns when there is no index in that string that carries the corresponding char/character sequence", "label": {"api": {"String.indexOf()": [[21, 36]]}}}, {"text": "The JavaDoc of Period states that it models", "label": {"api": {"Period": [[15, 20]]}}}, {"text": "You will want to call setTitleAt(...) on the JTabbedPane to change the title of the tab", "label": {"api": {"setTitleAt(...)": [[22, 36]]}}}, {"text": "The sub-process is being launched via the Java ProcessBuilder API", "label": {"api": {"ProcessBuilder": [[47, 60]]}}}, {"text": "I tried manually closing the stream returned by Process.getOutputStream() immediately after starting the sub-process", "label": {"api": {"Process.getOutputStream()": [[48, 72]]}}}, {"text": "I tried using ProcessBuilder.redirectInput to redirect sub-process input to read from an empty file, and from /dev/null", "label": {"api": {"ProcessBuilder": [[14, 27]], "ProcessBuilder.redirectInput": [[14, 41]]}}}, {"text": "For good measure, I even tried passing Redirect.INHERIT to ProcessBuilder even though that doesn't seem like it's remotely what I want", "label": {"api": {"ProcessBuilder": [[59, 72]]}}}, {"text": "Use setAccelerator instead", "label": {"api": {"setAccelerator": [[4, 17]]}}}, {"text": "I have a few closely related questions that popped up while trying to use ReentrantReadWriteLock to control access to a fairly complex data structure that has a number of different read and write operations", "label": {"api": {"ReentrantReadWriteLock": [[74, 95]]}}}, {"text": "is is bad to use WriteLock.isHeldByCurrentThread to check for errors (e.g., expecting a write lock but none is present, or as a condition to release the write lock)", "label": {"api": {"WriteLock.isHeldByCurrentThread": [[17, 47]]}}}, {"text": "Do I pass a lockedAquired boolean to methods that may be called from code that already possesses a lock, do I ensure they are uniquely acquired, or should I use ReadLock.tryLock()", "label": {"api": {"ReadLock.tryLock()": [[161, 178]]}}}, {"text": "Off the top of my head you could use a NavigableMap (there are two implementations in the JDK), it has a subMap method that is slice like", "label": {"api": {"NavigableMap": [[39, 50]], "subMap": [[105, 110]]}}}, {"text": "Alternatively an ArrayList of Key, Value pairs (sorted by Key)", "label": {"api": {"ArrayList": [[17, 25]]}}}, {"text": "Find the end of the ranges using Collection.binarySearch and then sublist to get your slice", "label": {"api": {"Collection.binarySearch": [[33, 55]], "sublist": [[66, 72]]}}}, {"text": "The Set interface has a remove method that will do the job", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "The default button skin implementation invokes consumeMouseEvents(true)", "label": {"api": {"consumeMouseEvents(true)": [[47, 70]]}}}, {"text": "\"Input events\" in the documentation you linked refers to event subclasses in the javafx.scene.input package", "label": {"api": {"javafx.scene.input": [[81, 98]]}}}, {"text": "Typically, for a control, you are not interested in events such as these, but in higher-level \"semantic\" events such as ActionEvent", "label": {"api": {"ActionEvent": [[120, 130]]}}}, {"text": "You need to implement Comparable interface for your user class and implement its compareTo method", "label": {"api": {"Comparable": [[22, 31]]}}}, {"text": "Instead use the Comparable interface provided by Core Java", "label": {"api": {"Comparable interface provided by Core Java": [[16, 57]]}}}, {"text": "As mentioned in the the Java docs -stylesheetfile <path>, you can only supply one css file, you can try merging Java provided default stylesheet.css with yours and try", "label": {"api": {"stylesheet.css": [[134, 147]]}}}, {"text": "Since Stream API is now available to Java", "label": {"api": {"Stream": [[6, 11]]}}}, {"text": "The behavior is well-defined, see javadoc of atZone()", "label": {"api": {"atZone()": [[45, 52]]}}}, {"text": "As for example, there are such things as Threadpools or the whole ExecutorService infrastructure that allow you to do things in parallel without the effort of managing Thread objects yourself", "label": {"api": {"ExecutorService": [[66, 80]]}}}, {"text": "And you could have also called Comparator.reversed", "label": {"api": {"Comparator.reversed": [[31, 49]]}}}, {"text": "If you're using Java 8 time API (or something like Joda time), you can easily achieve this by using isBefore()", "label": {"api": {"isBefore()": [[100, 109]]}}}, {"text": "Java 2D provides AffineTransform, but an affine transformation ensures that parallel lines remain parallel after transformation", "label": {"api": {"AffineTransform": [[17, 31]]}}}, {"text": "2) Store the regular System InputStream", "label": {"api": {"InputStream": [[28, 38]]}}}, {"text": "3) Create your own subclass of InputStream (let's call it YourCustomInputStream), and implement the different read methods, to print what was read from System.in to System.out, and also return the value", "label": {"api": {"InputStream": [[31, 41], [68, 78]]}}}, {"text": "Java's SecureRandom is the equivalent you're looking for", "label": {"api": {"SecureRandom": [[7, 18]]}}}, {"text": "The documentation details some other ways to get an instance of SecureRandom, depending on your requirements", "label": {"api": {"SecureRandom": [[64, 75]]}}}, {"text": "However is there a specifc reason that you do not want to use a javafx ListView which seems to be doing exactly what you are trying to do", "label": {"api": {"ListView": [[71, 78]]}}}, {"text": "All you need is to implement the Comparable interface for your User class", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "Interoperability, §3 Integrating JavaFX into Swing Applications, add your custom javafx.scene.control.Label to a javafx.embed.swing.JFXPanel", "label": {"api": {"javafx.embed.swing.JFXPanel": [[113, 139]]}}}, {"text": "Apparently the class FileDataSource accepts a File or String at it's constructor", "label": {"api": {"FileDataSource": [[21, 34]], "File": [[21, 24], [46, 49]]}}}, {"text": "So passing the File object directly simply solves the problem", "label": {"api": {"File": [[15, 18]]}}}, {"text": "The docs for ProcessBuilder suggest the method redirectInput will create a Process with its stdin set to a File", "label": {"api": {"redirectInput": [[47, 59]]}}}, {"text": "ByteBuffer has method get() and it returns byte from the current position", "label": {"api": {"method get()": [[15, 26]]}}}, {"text": "This approach is detailed in the JavaDoc for synchronizedList", "label": {"api": {"detailed in the JavaDoc for synchronizedList": [[17, 60]]}}}, {"text": "In the code where the JavFX Button is being built", "label": {"api": {"Button": [[28, 33]]}}}, {"text": "It seems to me the choice of JCheckBox is dubious, and a JToggleButton might be a better choice", "label": {"api": {"Button": [[64, 69]]}}}, {"text": "Examples of writing Listeners for Swing Buttons can be found here", "label": {"api": {"Button": [[40, 45]]}}}, {"text": "shutdownNow() attempts to stop the running thread, but as its API documentation says", "label": {"api": {"shutdownNow()": [[0, 12]]}}}, {"text": "So the thread may still be running when the code after the call to shutdownNow() returns", "label": {"api": {"shutdownNow()": [[67, 79]]}}}, {"text": "Note also that you need to make sure that the task running in the thread actually terminates; shutdownNow() is not going to kill the thread, it will just try to interrupt it", "label": {"api": {"shutdownNow()": [[94, 106]]}}}, {"text": "As the documentation says, call executorService.awaitTermination(...) after calling shutdownNow() to wait until the thread has stopped", "label": {"api": {"shutdownNow()": [[84, 96]], "executorService.awaitTermination(...)": [[32, 68]]}}}, {"text": "This way, you append the end of the file, see the constructor FileWriter(File file, boolean append)", "label": {"api": {"FileWriter(File file, boolean append)": [[62, 98]]}}}, {"text": "You're passing a String to icBuilder.parse(xmlString), so you're actually invoking DocumentBuilder.parse(String uri)", "label": {"api": {"DocumentBuilder.parse(String uri)": [[83, 115]]}}}, {"text": "The parse(String) method takes a uri pointing to an XML document, not its content", "label": {"api": {"parse(String)": [[4, 16]]}}}, {"text": "In order to parse the content, you'll have to construct your own InputSource", "label": {"api": {"InputSource": [[65, 75]]}}}, {"text": "The java.util.concurrent.Semaphore has a constructor that takes a fairness flag", "label": {"api": {"constructor that takes a fairness flag": [[41, 78]]}}}, {"text": "You could combine both approaches by using a private static ThreadLocal to hold the Uploader", "label": {"api": {"ThreadLocal": [[60, 70]]}}}, {"text": "If you are using Java 8 you can use Stream and Collectors", "label": {"api": {"Stream": [[36, 41]], "Collectors": [[47, 56]]}}}, {"text": "Your function raiseToPow()'s functionality can be achieved using Math.pow", "label": {"api": {"Math.pow": [[65, 72]]}}}, {"text": "From the Javadoc for Connection#rollback()", "label": {"api": {"Connection#rollback()": [[21, 41]]}}}, {"text": "Did you know that you could write something similar also with streams and with nio.Files", "label": {"api": {"nio.Files": [[79, 87]]}}}, {"text": "Something like Thread.setDefaultUncaughtExceptionHandler", "label": {"api": {"Thread.setDefaultUncaughtExceptionHandler": [[15, 55]]}}}, {"text": "If your classes respect the JavaBeans convention (standard getters and setters encapsulate fields), you can use the Introspector, and several frameworks that rely on it", "label": {"api": {"Introspector": [[116, 127]]}}}, {"text": "Sounds like you want a SortedMap implementation instead, probably a TreeMap", "label": {"api": {"SortedMap": [[23, 31]], "TreeMap": [[68, 74]]}}}, {"text": "ArrayList implements java.io.Serializable (ArrayList JavaDoc), therefore all elements stored are serialized", "label": {"api": {"ArrayList JavaDoc": [[43, 59]]}}}, {"text": "From the JavaDoc of String#valueOf", "label": {"api": {"String#valueOf": [[20, 33]]}}}, {"text": "The method format(Object object) will call behind the scene DateFormat#format(Object obj, StringBuffer toAppendTo, FieldPosition fieldPosition) which only accepts as stated into the javadoc a Number or a Date as type of the parameter obj otherwise an IllegalArgumentException is thrown", "label": {"api": {"DateFormat#format(Object obj, StringBuffer toAppendTo, FieldPosition fieldPosition)": [[60, 142]]}}}, {"text": "java.util.regex.Pattern is almost good enough, but its javadoc points out how it differs from Perl", "label": {"api": {"java.util.regex.Pattern": [[0, 22]]}}}, {"text": "The problem is that java.util.regex.Pattern is designed to work with a regular expression syntax that is not exactly Perl-compliant", "label": {"api": {"java.util.regex.Pattern": [[20, 42]]}}}, {"text": "In addition to Peter's suggestion, you can use CopyOnWriteArrayList instead of synchronizing ArrayList with wrapper", "label": {"api": {"CopyOnWriteArrayList": [[47, 66]]}}}, {"text": "You can have a look into the MemoryMXBean to see if that can give you what you are looking for, as it represents", "label": {"api": {"MemoryMXBean": [[29, 40]]}}}, {"text": "Use Callable instead of Runnable", "label": {"api": {"Callable": [[4, 11]]}}}, {"text": "There is no way to put both String and Object[] to java.util.logging.Logger", "label": {"api": {"java.util.logging.Logger": [[51, 74]]}}}, {"text": "Also you can create your own log method that points to java.util.logging.Logger.log, something like", "label": {"api": {"java.util.logging.Logger": [[55, 78]]}}}, {"text": "However, this doesn't use the log record parameters array which has some utility with filters", "label": {"api": {"log record parameters array": [[30, 56]]}}}, {"text": "Another option is to create a helper method to construct the log record and let the caller log it", "label": {"api": {"construct the log record": [[47, 70]], "log it": [[91, 96]]}}}, {"text": "As Jon Skeet said, use a PreparedStatement, addBatch(), and executeBatch()", "label": {"api": {"PreparedStatement": [[25, 41]], "addBatch()": [[44, 53]], "executeBatch()": [[60, 73]]}}}, {"text": "Use String.split() to split your text into words", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "Have a look at java.util.concurrent.atomic package", "label": {"api": {"java.util.concurrent.atomic": [[15, 41]]}}}, {"text": "AtomicReference is one solution", "label": {"api": {"AtomicReference": [[0, 14]]}}}, {"text": "When to use AtomicReference in Java", "label": {"api": {"AtomicReference": [[12, 26]]}}}, {"text": "You can use a ScheduledExecutorService with a timeout", "label": {"api": {"ScheduledExecutorService": [[14, 37]]}}}, {"text": "Otherwise, you can use InputStream.read(b, off, len), starting from an offset of 0 and with your desired length", "label": {"api": {"InputStream.read(b, off, len)": [[23, 51]]}}}, {"text": "Then finally rebuild the file using RandomAccessFile to be able to write the content of the file at a given position, knowing that you can rely on setLength(long newLength) to create an empty file with a target size in order to be able to write the content of the file concurrently using a dedicated instance of RandomAccessFile for each thread", "label": {"api": {"RandomAccessFile": [[36, 51], [312, 327]], "setLength(long newLength)": [[147, 171]]}}}, {"text": "Also note the MediaPlayer javadoc", "label": {"api": {"MediaPlayer javadoc": [[14, 32]]}}}, {"text": "CancellationException is thrown when the task is cancelled, by calling cancel()", "label": {"api": {"cancel()": [[71, 78]]}}}, {"text": "Math.pow() returns a double", "label": {"api": {"Math.pow()": [[0, 9]]}}}, {"text": "So you can not use Math.pow() for your purpose", "label": {"api": {"Math.pow()": [[19, 28]]}}}, {"text": "If you are having trouble using a BufferedReader to go through line by line you could use a Scanner instead and assuming the file is not very big scan the whole file into a string and subsequently use split() to obtain an array of all the words in the file", "label": {"api": {"split()": [[201, 207]]}}}, {"text": "You should use the String's split method with a space-regex (like \"\\s+\" or similar) to handle the word separation", "label": {"api": {"String's split method": [[19, 39]]}}}, {"text": "Before you split the string, you should use the trim method to be sure that there's no space before or after the string to prevent wrong splits", "label": {"api": {"trim method": [[48, 58]]}}}, {"text": "Can also be done using Streams", "label": {"api": {"Streams": [[23, 29]]}}}, {"text": "Useful in your case is WeakReference", "label": {"api": {"WeakReference": [[23, 35]]}}}, {"text": "It uses the following reduce method", "label": {"api": {"reduce method": [[22, 34]]}}}, {"text": "it is not guaranteed that a call to read will always read the exact same amount of bytes from your input", "label": {"api": {"read": [[36, 39], [53, 56]]}}}, {"text": "To the contrary, that read method returns the number of bytes read back to you", "label": {"api": {"read": [[22, 25], [62, 65]]}}}, {"text": "So you always need a loop that keeps reading until all expected bytes were really read", "label": {"api": {"read": [[37, 40], [82, 85]]}}}, {"text": "The Element class implements Node interface, so you can use getTextContent()", "label": {"api": {"getTextContent()": [[60, 75]]}}}, {"text": "It is based on the example given in the Deflater javadoc and uses Deflater class to compress data and Inflater class to uncompress it back", "label": {"api": {"example given in the Deflater javadoc": [[19, 55]], "Deflater": [[40, 47], [66, 73]], "Inflater": [[102, 109]]}}}, {"text": "There is no need for a ByteArrayInputStream, but you could use an InflaterInputStream wrapping it, if you really want to (but using the Inflater directly is easier)", "label": {"api": {"Inflater": [[66, 73], [136, 143]], "InflaterInputStream": [[66, 84]]}}}, {"text": "2) Implement Servlet API ServletContainerInitializer interface in your application", "label": {"api": {"ServletContainerInitializer": [[25, 51]]}}}, {"text": "Then add the fully qualified name of your class to the special text file in your war archive:META-INF/services/javax.servlet.ServletContainerInitializer, in order to register your class to be called by container", "label": {"api": {"ServletContainerInitializer": [[125, 151]]}}}, {"text": "Locale has nothing to do with time zone, only presentation when generating a String representation", "label": {"api": {"Locale": [[0, 5]]}}}, {"text": "Locale determines (a) the human language for translation of name of day, name of month, and such, and (b) the cultural norms deciding issues of abbreviation, capitalization, punctuation, and such", "label": {"api": {"Locale": [[0, 5]]}}}, {"text": "You can have a Asia/Kolkata time zone with Locale.CANADA_FRENCH presentation, or a Pacific/Auckland time zone with a Locale.ITALY presentation", "label": {"api": {"Locale": [[43, 48], [117, 122]]}}}, {"text": "Here is your code fixed to use only one scanner, and converting to degrees since the output of Math.atan is in radians", "label": {"api": {"Math.atan": [[95, 103]]}}}, {"text": "If you're using a full JEE server (Wildfly, Glassfish, WLS, etc.) you can use the TimerService with the method createTimer", "label": {"api": {"TimerService": [[82, 93]], "createTimer": [[111, 121]]}}}, {"text": "Read the Javadoc on Thread.sleep()", "label": {"api": {"Javadoc on Thread.sleep()": [[9, 33]]}}}, {"text": "String.split() takes a regex string", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "You need to be using java.util.regex.Pattern and get everything before the match of a Regex for the cost and the match of the regex for the cost", "label": {"api": {"java.util.regex.Pattern": [[21, 43]]}}}, {"text": "It offers them and if not accepted passes them to the configured RejectedExecutionHandler", "label": {"api": {"offers": [[3, 8]], "RejectedExecutionHandler": [[65, 88]]}}}, {"text": "By default this is the abort policy handler, which causes a RejectedExecutionException to be thrown", "label": {"api": {"abort policy handler": [[23, 42]]}}}, {"text": "If you read the Javadoc for Scanner#nextLine(), you will see that a NoSuchElementException occurs when the next line cannot be read, which would be the case with an empty file", "label": {"api": {"Javadoc for Scanner#nextLine()": [[16, 45]]}}}, {"text": "The transaction attribute type NOT_SUPPORTED simply means that this method does not support any transaction", "label": {"api": {"NOT_SUPPORTED": [[31, 43]]}}}, {"text": "The transaction attribute type REQUIRED now throws the exception because ..", "label": {"api": {"REQUIRED": [[31, 38]]}}}, {"text": "So, in this scenario you could use the type REQUIRES_NEW on your methodB that will now always start with a fresh new transaction regardless whether there was one before (which will be suspended) or not", "label": {"api": {"REQUIRES_NEW": [[44, 55]]}}}, {"text": "I have two LinkedHashMaps with the same set of keys", "label": {"api": {"LinkedHashMap": [[11, 23]]}}}, {"text": "You can implement your game loop using an AnimationTimer as demoed here", "label": {"api": {"AnimationTimer": [[42, 55]]}}}, {"text": "Here is a sample of using an AnimationTimer for display", "label": {"api": {"AnimationTimer": [[29, 42]]}}}, {"text": "It logs in using the KrbLoginModule to create a subject based on some given test user from the domain, which all appears to be working fine", "label": {"api": {"KrbLoginModule": [[21, 34]]}}}, {"text": "I then started using the \"Stream version\" of the initSecContext which takes an input and output stream (I gave the in/out streams of the socket I had open to my server - I assume that's what it wants)", "label": {"api": {"initSecContext": [[49, 62]]}}}, {"text": "As mentioned earlier, when I read in the token with initSecContext, I'm expecting a length first (i.e", "label": {"api": {"initSecContext": [[52, 65]]}}}, {"text": "So I looked at the token that's getting spit out by initSecContext and encoded to Base64, it's YII..", "label": {"api": {"initSecContext": [[52, 65]]}}}, {"text": "How about using a Scanner to get the users input as an int and converting that int to a String using valueOf", "label": {"api": {"Scanner": [[18, 24]], "valueOf": [[101, 107]]}}}, {"text": "Try something like this using a Scanner, converting the String input into a char array using toCharArray() and checking each char using isLetterOrDigit and checking if the character is not in \"AEIOUaeiou\" using indexOf() and therefore not a vowel", "label": {"api": {"Scanner": [[32, 38]], "toCharArray()": [[93, 105]], "isLetterOrDigit": [[136, 150]], "indexOf()": [[211, 219]]}}}, {"text": "Unfortunately, ForkJoinPool does not work well in the face of Thread.sleep(), because it designed for many short tasks that finish quickly, rather than tasks that block for a long time", "label": {"api": {"ForkJoinPool": [[15, 26]]}}}, {"text": "Instead, for what you are trying to accomplish, I would recommend using ScheduledThreadPoolExecutor and dividing your task into two parts", "label": {"api": {"ScheduledThreadPoolExecutor": [[72, 98]]}}}, {"text": "@Abzal Kalimbetov is wrong about getErrorStream(), which will return an InputStream when an exception is raised, indicating response code >= 400 is received from the server", "label": {"api": {"getErrorStream()": [[33, 48]]}}}, {"text": "This could be done using Pattern and Matcher to cut off the old date", "label": {"api": {"Pattern": [[25, 31]]}}}, {"text": "From the javadoc of Collections#frequency", "label": {"api": {"Collections#frequency": [[20, 40]]}}}, {"text": "Now you need to change your Collections#frequency call to work on the Tester and not the name field of Tester", "label": {"api": {"Collections#frequency": [[28, 48]]}}}, {"text": "The JavaDoc for FileOutputStream specifically says \"FileOutputStream is meant for writing streams of raw bytes such as image data", "label": {"api": {"FileOutputStream": [[16, 31], [52, 67]]}}}, {"text": "For writing streams of characters, consider using FileWriter.\" This is because FileOutputStream has no understanding of character encoding and code pages", "label": {"api": {"FileOutputStream": [[79, 94]], "FileWriter": [[50, 59]], "Writer": [[54, 59]]}}}, {"text": "When you use Arabic characters then you are both using an invalid codepage, and since String are stored as UTF-16, an invalid number of bytes (Arabic characters are much more likely to be multi-byte then English characters)", "label": {"api": {"String": [[86, 91]]}}}, {"text": "The JavaDoc of FileWriter informs us that \"The constructors of this class assume that the default character encoding and the default byte-buffer size are acceptable", "label": {"api": {"FileWriter": [[15, 24]], "Writer": [[19, 24]]}}}, {"text": "To specify these values yourself, construct an OutputStreamWriter on a FileOutputStream.\" So, following the instructions we are given, to correct your problem we should implement the following replacement for the dos variable section (using StandardCharsets for brevity)", "label": {"api": {"FileOutputStream": [[71, 86]], "OutputStreamWriter": [[47, 64]], "StandardCharsets": [[241, 256]], "Writer": [[59, 64]], "Charset": [[249, 255]]}}}, {"text": "However, because of the way your code is structured, even this correction may run into a problem once you surround the OutputStreamWriter with another Writer, say for example a BufferedWriter", "label": {"api": {"OutputStreamWriter": [[119, 136]], "Writer": [[131, 136], [151, 156], [185, 190]], "BufferedWriter": [[177, 190]]}}}, {"text": "OutputStreamWriter uses an internal buffer of a set size to buffer the input in certain circumstances, and giving it a huge input String like this may cause problems or even lead to an IOException", "label": {"api": {"String": [[130, 135]], "OutputStreamWriter": [[0, 17]], "Writer": [[12, 17]], "IOException": [[185, 195]]}}}, {"text": "My provided example uses the write(String, int, int) method directly, which skips the buffer, but that workaround only works until you add another Writer wrapper", "label": {"api": {"String": [[35, 40]], "Writer": [[147, 152]], "write(String, int, int)": [[29, 51]]}}}, {"text": "You should also replace the BufferedInputStream bun with an InputStreamReader, which is the InputStream version of OutputStreamWriter", "label": {"api": {"OutputStreamWriter": [[115, 132]], "Writer": [[127, 132]], "InputStreamReader": [[60, 76]], "InputStream": [[36, 46], [60, 70], [92, 102]]}}}, {"text": "If you want additional buffering for performance reasons you can wrap this with a BufferedReader", "label": {"api": {"BufferedReader": [[82, 95]]}}}, {"text": "Also, for both the input and output Reader/Writer you may need to choose a different Charset then UTF-8, but as I don't know what file encoding you use/will use, I just defaulted to UTF-8", "label": {"api": {"Writer": [[43, 48]], "Charset": [[85, 91]]}}}, {"text": "There is already a \"default\" way to compare to long values, and that is Long.compare()", "label": {"api": {"Long.compare()": [[72, 85]]}}}, {"text": "You're looking for Math.log(double e) which accepts and returns type double", "label": {"api": {"Math.log(double e)": [[19, 36]]}}}, {"text": "In a java project, in order to execute tasks in an asynchronous manner I'm using ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[81, 98]]}}}, {"text": "You simply gain c-style formatting options for your output, though you do lose some compatibility, since Formatter does not extend Writer", "label": {"api": {"Formatter": [[105, 113]], "Writer": [[131, 136]]}}}, {"text": "If you really wanted to be sure, though, Formatter does happen to have a constructor that accepts Appandable objects, and PrintWriter, by virtue of extending Writer, happens to implement that interface", "label": {"api": {"Formatter": [[41, 49]], "PrintWriter": [[122, 132]], "Writer": [[127, 132], [158, 163]]}}}, {"text": "This means you could construct a Formatter such that it uses a PrintWriter to do its dirty work, instead of the default BufferedWriter it would normally internally use to output to a file", "label": {"api": {"Formatter": [[33, 41]], "PrintWriter": [[63, 73]], "Writer": [[68, 73], [128, 133]], "BufferedWriter": [[120, 133]]}}}, {"text": "However, this would be overkill, as while Print and BufferedWriter have internal differences with exception handling, exposed methods, and performance, the printed output would ultimately be identical since Formatter interacts with both the same way", "label": {"api": {"Formatter": [[207, 215]], "Writer": [[60, 65]], "BufferedWriter": [[52, 65]]}}}, {"text": "Consider the Reference API", "label": {"api": {"Reference API": [[13, 25]]}}}, {"text": "You can use orElseThrow when you try to retrieve the value", "label": {"api": {"orElseThrow": [[12, 22]]}}}, {"text": "In Java 8 Using nio Files.lines() method, Stream.map() and PrintWriter", "label": {"api": {"Files.lines()": [[20, 32]], "Stream.map()": [[42, 53]]}}}, {"text": "Just use ScriptEngine#put to set the respective variable", "label": {"api": {"ScriptEngine#put": [[9, 24]]}}}, {"text": "Instead of trying to generate the path to the file using manual hard-coded String, let's make a Path and have it generate the file path for you", "label": {"api": {"String": [[75, 80]], "Path": [[96, 99]]}}}, {"text": "Using Runtime.exec() is basically like using the Run..", "label": {"api": {"Runtime.exec()": [[6, 19]]}}}, {"text": "This code uses ProcessBuilder to set the directory to the same parent directory as before, but the command has been modified to remove the file redirection and instead the file redirection is achieved using the redirectinput() method", "label": {"api": {"ProcessBuilder": [[15, 28]], "redirectinput()": [[211, 225]]}}}, {"text": "Assuming T implements Comparable (because you need to be able to calculate the maximum of two values) you can wrap your code in a method such as this", "label": {"api": {"Comparable": [[22, 31]]}}}, {"text": "It creates a Set<Map.Entry<String, List<T>>> of which you can create a Stream which is converted into a Map<String, T> by converting the value type using Collections.max() which uses Comparable.compareTo to compare two objects and determine which one is greater than the other", "label": {"api": {"Comparable": [[183, 192]]}}}, {"text": "Note that you can just use it as is for boxed types like Integer or Double (and many more) as they all implement Comparable", "label": {"api": {"Comparable": [[113, 122]]}}}, {"text": "A String provides the method String#compareTo(String), since it implements the interface Comparable<String>", "label": {"api": {"String#compareTo(String)": [[29, 52]], "Comparable<String>": [[89, 106]]}}}, {"text": "According to the JavaDoc - TimeUnit", "label": {"api": {"TimeUnit": [[27, 34]]}}}, {"text": "Because Java String has String.length() (and doesn't have a reverse(String) method), and it is a final class (that means you cannot sub-class it to add custom methods)", "label": {"api": {"String.length()": [[24, 38]]}}}, {"text": "It is worth mentioning, but not directly to your question, that there is already a StringBuilder.reverse() method", "label": {"api": {"StringBuilder.reverse()": [[83, 105]]}}}, {"text": "Why doesn't ByteArrayOutputStream override the OutputStream.write(byte[] b) method", "label": {"api": {"OutputStream.write(byte[] b)": [[47, 74]]}}}, {"text": "It only overrides the write(byte[] b, int off, int len) version taking an offset and length", "label": {"api": {"write(byte[] b, int off, int len)": [[22, 54]]}}}, {"text": "Use a concurrent collection (instead of List) to store the sockets, for example ConcurrentLinkedDeque", "label": {"api": {"ConcurrentLinkedDeque": [[80, 100]]}}}, {"text": "You could implement this using for example a CompletionService", "label": {"api": {"CompletionService": [[45, 61]]}}}, {"text": "values argument in reduce function is Iterable, not a single value", "label": {"api": {"Iterable": [[38, 45]]}}}, {"text": "Without call to next(), you simply invoke toString() method on Iterable object itself, which prints its class name", "label": {"api": {"Iterable": [[63, 70]]}}}, {"text": "The Java 8 version includes the new constructor", "label": {"api": {"Java 8 version includes the new constructor": [[4, 46]]}}}, {"text": "There is no need to reinvent the wheel, java.util.concurrent package already contains thread-safe implementation of Map interface -  ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[133, 149]]}}}, {"text": "I started using ReentrantReadWriteLock have a thread in WAITING state, waiting for a ReentrantReadWriteLock$FairSync in the \"locked ownable synchronizers\" list of another thread in WAITING state (a ThreadPoolExecutor)", "label": {"api": {"ReentrantReadWriteLock": [[16, 37], [85, 106]]}}}, {"text": "This is probaby a good use case for Preferences", "label": {"api": {"Preferences": [[36, 46]]}}}, {"text": "If you're using Java 8, you can go with a LocalDateTime", "label": {"api": {"LocalDateTime": [[42, 54]]}}}, {"text": "If you want to include a time-zone, you can use ZonedDateTime", "label": {"api": {"ZonedDateTime": [[48, 60]]}}}, {"text": "See JavaDoc for that addShutdownHook()", "label": {"api": {"addShutdownHook()": [[21, 37]]}}}, {"text": "By reversing the String using StringBuilder.reverse()and passing it only once to setText() it should work correctly", "label": {"api": {"StringBuilder.reverse()": [[30, 52]]}}}, {"text": "I'm also assuming that you're using MediaPlayer and Media", "label": {"api": {"MediaPlayer": [[36, 46]], "Media": [[36, 40], [52, 56]]}}}, {"text": "As per ServerSocket(int port, int backlog), backlog indicates maximum length of the queue", "label": {"api": {"ServerSocket(int port, int backlog)": [[7, 41]]}}}, {"text": "(You don't just want to show the solution; you want to show multiple \"animation frames\" to the user, each of which represents a step in the solution.) So you should use the animation API", "label": {"api": {"animation API": [[173, 185]]}}}, {"text": "The simplest way might be a Timeline", "label": {"api": {"Timeline": [[28, 35]]}}}, {"text": "A more sophisticated approach might be to represent each move of a face by an animation (showing the actual rotation), and then combine them all into a SequentialTransition", "label": {"api": {"SequentialTransition": [[152, 171]]}}}, {"text": "I know that BigDecimal's scale is a 32-bit int but is there any way at all to bypass this and calculate such a big value", "label": {"api": {"scale is a 32-bit int": [[25, 45]]}}}, {"text": "LocalDateTime is abstract class", "label": {"api": {"LocalDateTime": [[0, 12]]}}}, {"text": "I have a question, Why can LocalDateTime return the instance", "label": {"api": {"LocalDateTime": [[27, 39]]}}}, {"text": "System.out.println(q), according to its documentation, calls String.valueOf(q), which according to its documentation calls q.toString(), which according to its documentation uses the order of elements from q.iterator(), which according to its documentation is not in any particular order", "label": {"api": {"its documentation": [[36, 52], [99, 115], [156, 172], [239, 255]]}}}, {"text": "You can use tailSet to get all items starting with the current one", "label": {"api": {"tailSet": [[12, 18]]}}}, {"text": "I let myself quote the docs for java.io.Serializable", "label": {"api": {"java.io.Serializable": [[32, 51]]}}}, {"text": "Read in the original file using Files.readAllLines, then iterate over the resulting list and use Files.createFile to create a new file based on the words being iterated over", "label": {"api": {"Files.readAllLines": [[32, 49]], "Files.createFile": [[97, 112]]}}}, {"text": "or preferably use a Date variable, and set it with setDate() rather than setString(), changing the format of your String to what valueOf() expects, as JohnMatthewIanDavis pointed out", "label": {"api": {"to what valueOf() expects": [[121, 145]]}}}, {"text": "According to @MouseEvents sugestion, you can also use sublist method of the ArrayList", "label": {"api": {"sublist": [[54, 60]]}}}, {"text": "Note that Java 8's Optional may allow you to write this in a more elegant way (although elegance is somewhat in the eye of the beholder)", "label": {"api": {"Optional": [[19, 26]]}}}, {"text": "Depending on the application pattern, you can also use the Stream#reduce method that accepts an identity as the first argument, which in this case is the \"identity BiFunction\" (actually, a projection on the second argument)", "label": {"api": {"Stream#reduce": [[59, 71]]}}}, {"text": "You need to be catching a NumberFormatException rather than an InputMismatchException like so", "label": {"api": {"NumberFormatException": [[26, 46]], "InputMismatchException": [[63, 84]]}}}, {"text": "The method parseInt(String s) throws a NumberFormatException not a InputMismatchException", "label": {"api": {"parseInt(String s)": [[11, 28]]}}}, {"text": "You can get it from System.in, e.g., by using a Scanner", "label": {"api": {"System.in": [[20, 28]], "Scanner": [[48, 54]]}}}, {"text": "I have a Font object and I need both the width and height of the font", "label": {"api": {"Font": [[9, 12]]}}}, {"text": "I know that the getSize() returns the height of the font as the point-size of a font is generally the height, but I'm at a loss when it comes to determining the width of the font", "label": {"api": {"getSize()": [[16, 24]]}}}, {"text": "Alternatively, being able to determine the width of each specific character supported by the Font would also be an acceptable solution", "label": {"api": {"Font": [[93, 96]]}}}, {"text": "My best guess is that the width is specified when using the loadFont method, but the documentation does not specify whether the size parameter represents the width or the height of the font", "label": {"api": {"Font": [[64, 67]], "loadFont": [[60, 67]]}}}, {"text": "You can implement ReadWriteLock for this specific purpose", "label": {"api": {"ReadWriteLock": [[18, 30]]}}}, {"text": "You can read more about it here:", "label": {"api": {"here:": [[27, 31]]}}}, {"text": "As per Javadocs, shutdown() will wait for all submit tasks to be executed", "label": {"api": {"shutdown()": [[17, 26]]}}}, {"text": "I have added a shutdown hook which calls ExecutorService.shutdown()", "label": {"api": {"shutdown()": [[57, 66]]}}}, {"text": "But it doesn't until I add a awaitTermination() call after the shutdown() call", "label": {"api": {"shutdown()": [[63, 72]]}}}, {"text": "If two values are stored with the same key, HashMap.put(K key, V value) will overwrite the former value with the later", "label": {"api": {"HashMap.put(K key, V value) will overwrite the former value with the later": [[44, 117]]}}}, {"text": "You should wait for completion of both Threads before querying the size of yur map by calling join() on your Thread-objects", "label": {"api": {"join() on your Thread-objects": [[94, 122]]}}}, {"text": "If you need a thread-safe Hashmap, use ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[39, 55]]}}}, {"text": "If you are determined to write your own thread-safe implementation of the Map interface, I recommend Oracle's Lesson on Concurrency to start with, followed by Brian Goetz's \"Java Concurrency in Practice\" and maybe a little bit of Javier Fernández González' \"Mastering Concurrency Programming with Java 8\"", "label": {"api": {"Map interface": [[74, 86]]}}}, {"text": "You could also try Files.walkFileTree if you don't want to deal with try-with-resources blocks; setting the max-depth to 2 (since you're starting from parent) you can override preVisitDirectory() and only print paths two-deeper than parent", "label": {"api": {"Files.walkFileTree": [[19, 36]]}}}, {"text": "Java 7+ code should prefer the java.nio.file APIs, which my example uses", "label": {"api": {"java.nio.file": [[31, 43]]}}}, {"text": "If you already use Java 8, there is a sophisticated date-time API in package java.time", "label": {"api": {"java.time": [[77, 85]]}}}, {"text": "As pointed out by @DmitriyKotov, you should switch to an AtomicInteger", "label": {"api": {"AtomicInteger": [[57, 69]]}}}, {"text": "Technically, most \"request scope\" solutions use ThreadLocal under the hood", "label": {"api": {"ThreadLocal": [[48, 58]]}}}, {"text": "MDC also uses ThreadLocal", "label": {"api": {"ThreadLocal": [[14, 24]]}}}, {"text": "If you just replace MDC with your own ThreadLocal-based storage you won't win much", "label": {"api": {"ThreadLocal": [[38, 48]]}}}, {"text": "From the JavaDoc of Selector#select()", "label": {"api": {"Selector#select()": [[20, 36]]}}}, {"text": "The method void call(boolean successful) can be represented by a Consumer<Boolean> as void accept(Boolean b), which is built into java", "label": {"api": {"Consumer<Boolean>": [[65, 81]]}}}, {"text": "One of the comments already pointed you to the Future class, which offers the functionality that you seemingly wanted to implement there", "label": {"api": {"Future": [[47, 52]]}}}, {"text": "Alternatively, the CompletableFeature class offers mechanisms for adding a \"callback\" that will be informed when the result is avaliable", "label": {"api": {"CompletableFeature": [[19, 36]]}}}, {"text": "You could use EnumSet to hold permissions like this", "label": {"api": {"EnumSet": [[14, 20]]}}}, {"text": "Refer to this article for more information", "label": {"api": {"this article": [[9, 20]]}}}, {"text": "See the API documentation", "label": {"api": {"the API documentation": [[4, 24]]}}}, {"text": "Although the javadoc for Void says it's", "label": {"api": {"javadoc for Void": [[13, 28]]}}}, {"text": "Take a look at address http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#Random(long) for documentation of constructor", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#Random(long)": [[23, 97]]}}}, {"text": "Then you can create a List<Employee> and call Collections.sort() which will sort the elements based on the ordering defined by the Comparator", "label": {"api": {"Collections.sort()": [[46, 63]]}}}, {"text": "Or in Java 8 you can use a method reference, and just pass Comparator.comparing(Employee::getFirstName) to the Comparator parameter of Collections.sort()", "label": {"api": {"Collections.sort()": [[135, 152]]}}}, {"text": "You can use Line to add a geometric line segment to your scene graph", "label": {"api": {"Line": [[12, 15]]}}}, {"text": "Subsequently, you can call setStroke to set the color for that line", "label": {"api": {"setStroke": [[27, 35]]}}}, {"text": "The method can take a Color object", "label": {"api": {"Color": [[22, 26]]}}}, {"text": "There are various methods for manipulating the hue of the color object in the provided link, most notably deriveColor, which can be used to shift the hue value", "label": {"api": {"Color": [[112, 116]], "deriveColor": [[106, 116]]}}}, {"text": "Furthermore, once you have added a Line object, you can bind its endX and endY properties to the position of your ant", "label": {"api": {"Line": [[35, 38]], "endX": [[65, 68]], "endY": [[74, 77]]}}}, {"text": "This way, as the ant moves along some path, it will \"drag\" the end of the Line object behind it", "label": {"api": {"Line": [[74, 77]]}}}, {"text": "in your case I would suggest working with CyclicBarrier in a way that your code would look like", "label": {"api": {"CyclicBarrier": [[42, 54]]}}}, {"text": "If you'd like the getPrice calls to run asynchronously, you can use ExecutorService, like so", "label": {"api": {"ExecutorService": [[68, 82]]}}}, {"text": "This info is available in the ZoneRules class", "label": {"api": {"ZoneRules": [[30, 38]]}}}, {"text": "There BigDecimal.toPlainString() converts BigDecimal to String", "label": {"api": {"BigDecimal.toPlainString()": [[6, 31]]}}}, {"text": "As far as I can see Cipher is in javax.crypto class", "label": {"api": {"class": [[46, 50]]}}}, {"text": "For me @NamedNativeQuery is the most elegant way", "label": {"api": {"@NamedNativeQuery": [[7, 23]]}}}, {"text": "Since you're running a recurring task every second, ScheduledExecutorService.scheduledAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) is a good fit", "label": {"api": {"ScheduledExecutorService.scheduledAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)": [[52, 161]]}}}, {"text": "The filter in this case needs an int predicate", "label": {"api": {"int predicate": [[33, 45]]}}}, {"text": "This is in a way the inverse of the Stream.flatMap(...) family of methods, but, ironically, there doesn't seem to be any idiomatic functional way of doing this and so you may have to create the batches yourself in an imperative manner — for example", "label": {"api": {"Stream.flatMap(...)": [[36, 54]]}}}, {"text": "Is there any way how to check (and append event handler on it) if application is going to be closed in FXML controller (not main class derived from Application but controller attached to FXML file derived from Initializable)", "label": {"api": {"Application": [[148, 158]], "Initializable": [[210, 222]]}}}, {"text": "The producer can either can leave a Future for the consumer to populate", "label": {"api": {"Future": [[36, 41]]}}}, {"text": "The producer then calls the Future's get() method, which will cause the producers thread to stop until the consumer finishes", "label": {"api": {"Future": [[28, 33]]}}}, {"text": "The same can be done using a CountDownLatch", "label": {"api": {"CountDownLatch": [[29, 42]]}}}, {"text": "The difference between the latch and the future is that a Future is used when the producer needs to generate an object that is required by the holder of the Future object", "label": {"api": {"Future": [[58, 63], [157, 162]]}}}, {"text": "Whereas a CountDownLatch is used primarily for synchronizing multiple threads", "label": {"api": {"CountDownLatch": [[10, 23]]}}}, {"text": "Though to make Future or CountDOwnLatch work in this example would require some changes to the problem, for example the LinkedList will have to pass more than just an Integer", "label": {"api": {"Future": [[15, 20]]}}}, {"text": "An easier solution would be to swap out the LinkedList with a SynchronousQueue", "label": {"api": {"SynchronousQueue": [[62, 77]]}}}, {"text": "A SynchronousQueue contains zero elements in it, so when an item is inserted into the queue, the queue blocks until a consumer comes and takes the item", "label": {"api": {"SynchronousQueue": [[2, 17]]}}}, {"text": "Further attempts to put an object into the SynchronousQueue will block until the item is consumed", "label": {"api": {"SynchronousQueue": [[43, 58]]}}}, {"text": "Then create a ListCellRenderer that will return a string that is the \"display name\" for example", "label": {"api": {"ListCellRenderer": [[14, 29]]}}}, {"text": "You can try setting the background of the scroll pane's viewport by using scrollPane.getViewport().setBackground(Color.XXX)", "label": {"api": {"viewport": [[56, 63]]}}}, {"text": "Logic in JavaFX that works based upon reflective naming such as PropertyValueFactory works with either is or get prefixes on the getter names", "label": {"api": {"PropertyValueFactory": [[64, 83]]}}}, {"text": "There is LocalDate class in Java 8 which will do the difference (and much more)", "label": {"api": {"LocalDate": [[9, 17]]}}}, {"text": "To assign the current date into end use now() method", "label": {"api": {"now()": [[40, 44]]}}}, {"text": "For others, who are not limited with Java 8, you can use completeOnTimeout method, which was introduced in Java 9", "label": {"api": {"completeOnTimeout": [[57, 73]]}}}, {"text": "That ExecutorService has actually two shutdown-related methods; based on the simple fact that both ways of shutting down a service make sense", "label": {"api": {"ExecutorService": [[5, 19]]}}}, {"text": "you can't make an ExecutorService a AutoClosable because that service does not have a single \"close\" like operation; but two", "label": {"api": {"ExecutorService": [[18, 32]]}}}, {"text": "If you want to lock the execution of all main thread, you can use CountDownLatch", "label": {"api": {"CountDownLatch": [[66, 79]]}}}, {"text": "Part has a write(String) method which writes the part directly to a file", "label": {"api": {"write(String) method": [[11, 30]]}}}, {"text": "See https://docs.oracle.com/javase/8/docs/api/java/awt/RenderingHints.html for more rendering options", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/awt/RenderingHints.html": [[4, 73]]}}}, {"text": "The behavior you're describing is exactly what the anyMatch method is designed for", "label": {"api": {"anyMatch": [[51, 58]]}}}, {"text": "If you use Java 8 and the classes of java.time, you can use Clock", "label": {"api": {"Clock": [[60, 64]]}}}, {"text": "At normal application run time you can then inject and use the normal system clock provided by Clock.systemDefaultZone(), for tests you can inject a Clock instance with a fixed time, for example provided by Clock.fixed or subclassing Clock if you need more control", "label": {"api": {"Clock": [[95, 99], [149, 153], [207, 211], [234, 238]], "Clock.fixed": [[207, 217]]}}}, {"text": "This is a relatively straightforward case for appendReplacement", "label": {"api": {"appendReplacement": [[46, 62]]}}}, {"text": "One simple way to accomplish this is by using Collections::shuffle to randomly permute the elements and then selecting a subset of the shuffled list", "label": {"api": {"Collections::shuffle": [[46, 65]]}}}, {"text": "Use String.startsWith and String.endsWith", "label": {"api": {"String.startsWith": [[4, 20]], "String.endsWith": [[26, 40]]}}}, {"text": "The second thing I would like to introduce to you is the data structure known as the Map", "label": {"api": {"Map": [[85, 87]]}}}, {"text": "Maps are also known as Dictionaries, and that can often help understanding how they work", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "A Map will take one object and map it to another object, like how a Dictionary maps a word to its definition, or a phonebook maps a person's name to their phone number", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "We can simplify your Room class a ton by using a Map", "label": {"api": {"Map": [[49, 51]]}}}, {"text": "Please read more about the Java Map interface here", "label": {"api": {"Map": [[32, 34]]}}}, {"text": "Call shutdown before submitting the task", "label": {"api": {"shutdown": [[5, 12]]}}}, {"text": "If you call submit() after shutdown(), you will get this type of execption", "label": {"api": {"shutdown": [[27, 34]]}}}, {"text": "Look at String class API", "label": {"api": {"String": [[8, 13]]}}}, {"text": "You can use lastIndexOf(String str, int fromIndex), substring(int beginIndex) and length() methods", "label": {"api": {"String": [[24, 29]]}}}, {"text": "ResultSet#next() iterates over the rows in the result set (which, in this case, is just a single row)", "label": {"api": {"ResultSet#next()": [[0, 15]]}}}, {"text": "If you don't know the result set's structure upfront, you can dynamically deduce it from a ResultSetMetaData object", "label": {"api": {"ResultSetMetaData": [[91, 107]]}}}, {"text": "You can still use the Stream API and lambdas in the method by invoking Stream.of(String...)", "label": {"api": {"Stream.of(String...)": [[71, 90]]}}}, {"text": "This can be done conveniently with a SwingWorker, as shown in the following example, which reads a file called example.txt", "label": {"api": {"SwingWorker": [[37, 47]]}}}, {"text": "Just look at the java File API", "label": {"api": {"java File API": [[17, 29]]}}}, {"text": "isDirectory() returns, if the file is a directory or not", "label": {"api": {"isDirectory()": [[0, 12]]}}}, {"text": "isFile() returns, if it is a file", "label": {"api": {"isFile()": [[0, 7]]}}}, {"text": "readUTF() reads binary encoded stream, not text data", "label": {"api": {"readUTF()": [[0, 8]]}}}, {"text": "See readUTF() documentation", "label": {"api": {"readUTF()": [[4, 12]]}}}, {"text": "This is also mentioned in the class documentation of ClassLoader", "label": {"api": {"class documentation of ClassLoader": [[30, 63]]}}}, {"text": "& the Oracle offical explaination for the exception", "label": {"api": {"exception": [[42, 50]]}}}, {"text": "Meanwhile, there is a blog about how to debug for this exception which may help you resolving it", "label": {"api": {"exception": [[55, 63]]}}}, {"text": "System.out is a PrintStream, which has several overloads for println", "label": {"api": {"PrintStream": [[16, 26]]}}}, {"text": "You could use flatMap instead", "label": {"api": {"flatMap": [[14, 20]]}}}, {"text": "Thread#sleep(long) pauses the main thread before it returns from its main method (i.e", "label": {"api": {"Thread#sleep(long)": [[0, 17]]}}}, {"text": "Another possibility might be using an ExecutorService that supports timeouts, see this Q&A for an example involving ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[116, 139]]}}}, {"text": "Maybe you could use the Function<T, R> interface", "label": {"api": {"Function<T, R> interface": [[24, 47]]}}}, {"text": "Use Pattern.quoteReplacement to escape all metacharacters in the replacement", "label": {"api": {"Pattern.quoteReplacement": [[4, 27]]}}}, {"text": "The general formula for replacing things in a string that requires more logic is in Matcher#appendReplacement", "label": {"api": {"Matcher#appendReplacement": [[84, 108]]}}}, {"text": "Then to package the jar, you can use this tutorial, which uses the Java Compiler API", "label": {"api": {"Java Compiler API": [[67, 83]]}}}, {"text": "I was reading the javafx region online documentation and came across minWidth(forHeight),minHeight(forWidth),getPrefWidth(forHeight),getPrefHeight(forWidth), getMaxWidth(forHeight), getMaxHeight(forWidth) etc", "label": {"api": {"javafx region online documentation": [[18, 51]]}}}, {"text": "In Java 8, I think it would be a bit cleaner to use Comparator::comparing", "label": {"api": {"Comparator::comparing": [[52, 72]]}}}, {"text": "Hashmap does NOT implement (or extend to be more precise) Hashtable", "label": {"api": {"Hashmap": [[0, 6]]}}}, {"text": "You can use the Formatter", "label": {"api": {"Formatter": [[16, 24]]}}}, {"text": "Did you mean to extend java.awt.Canvas instead", "label": {"api": {"java.awt.Canvas": [[23, 37]]}}}, {"text": "Long.numberOfTrailingZeros() will use the CPU intrinsic that counts the number of consecutive zero bits starting from the least-significant bit (the BSF instruction on x86 processors)", "label": {"api": {"Long.numberOfTrailingZeros()": [[0, 27]]}}}, {"text": "You can use Collections.singletonMap to map each String to a Map<String,String>", "label": {"api": {"Collections.singletonMap": [[12, 35]]}}}, {"text": "Like Piotr says, you can use Stream#sorted to sort the stream", "label": {"api": {"Stream#sorted": [[29, 41]]}}}, {"text": "But I cannot use that on Android; specifically Date.from(Instant instant) is missing", "label": {"api": {"Date.from(Instant instant)": [[47, 72]]}}}, {"text": "Enum is ALWAYS a sigleton so your constructor is guaranteed to be called only once (per a enum value) Also you don't need to even have ID as Enum has method public final int ordinal() that returns its zero-based sequential number in the enum", "label": {"api": {"public final int ordinal()": [[157, 182]]}}}, {"text": "Have a look at the Java Api", "label": {"api": {"Java Api": [[19, 26]]}}}, {"text": "The more precise feature for checking a timeout when sending is setAsyncSendTimeout", "label": {"api": {"setAsyncSendTimeout": [[64, 82]]}}}, {"text": "To do that, you need to iterate them, and you need to use the reflection method Class.isInstance(Object obj)", "label": {"api": {"Class.isInstance(Object obj)": [[80, 107]]}}}, {"text": "Whilst I don't like using exceptions to detect things you expect under normal conditions (like reaching the end of the stream), the Javadoc of EOFException indicates that this is how you're meant to detect end of the stream", "label": {"api": {"EOFException": [[143, 154]]}}}, {"text": "The javadoc of Comparator.comparing() says", "label": {"api": {"Comparator.comparing()": [[15, 36]]}}}, {"text": "System.out is a PrintStream, so", "label": {"api": {"System.out": [[0, 9]], "PrintStream": [[16, 26]]}}}, {"text": "It allows to collect them (see Collectors), regrouping them by key (groupingBy), and in your case to compute a summary statistics", "label": {"api": {"Collectors": [[31, 40]]}}}, {"text": "See the javadoc for Collectors.summarizingInt", "label": {"api": {"Collectors": [[20, 29]], "Collectors.summarizingInt": [[20, 44]]}}}, {"text": "Let's look at the statement (int)Math.random() * 4 for an explanation", "label": {"api": {"Math.random()": [[33, 45]]}}}, {"text": "Now, in Java a type cast has precedence over +, -, * and /, so what actually happens is ((int)Math.random()) * 4", "label": {"api": {"Math.random()": [[94, 106]]}}}, {"text": "Math.random() returns a floating point number between 0.0 and 1.0 exclusive, so roughly [0.0, 0.999999...]", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "I recommend you to use the Random class instead", "label": {"api": {"Random": [[27, 32]]}}}, {"text": "It provides a method nextInt(int n), which returns a random integer between 0 inclusive and n exclusive, so [0, n - 1]", "label": {"api": {"nextInt(int n)": [[21, 34]]}}}, {"text": "Use the power of Scanner", "label": {"api": {"Scanner": [[17, 23]]}}}, {"text": "To perform this operation you need to call the intValue method on the Double object", "label": {"api": {"method": [[56, 61]]}}}, {"text": "This method performs a cast, into an int value, on the double value wrapped within the Double object, d", "label": {"api": {"method": [[5, 10]]}}}, {"text": "TableView keeps its items in ObservableList", "label": {"api": {"ObservableList": [[29, 42]]}}}, {"text": "ObservableList extends List and therefore allows you to use any methods List declares, like List.add and List.addAll", "label": {"api": {"List.add": [[92, 99], [105, 112]], "List.addAll": [[105, 115]]}}}, {"text": "I have a Java app that uses Robot to control the mouse and keyboard", "label": {"api": {"Robot": [[28, 32]]}}}, {"text": "It is weakly consistent", "label": {"api": {"weakly consistent": [[6, 22]]}}}, {"text": "Use an EnumMap instead, which is a high-performance Map specifically designed for enum keys", "label": {"api": {"EnumMap": [[7, 13]]}}}, {"text": "The method useDelimiter(String pattern) uses the given String as a regular expression pattern, which behaves differently than your everyday String escape sequence", "label": {"api": {"useDelimiter(String pattern)": [[11, 38]]}}}, {"text": "First, you may prefer List but not array to store your information if you read input from console and you can't control the input length of your user", "label": {"api": {"List": [[22, 25]]}}}, {"text": "Second, you may want to use String#split to split and convert it if necessary", "label": {"api": {"String#split": [[28, 39]]}}}, {"text": "\"Thrown by various accessor methods to indicate that the element being requested does not exist.\" - from JDK8 doc ( link )", "label": {"api": {"link": [[116, 119]]}}}, {"text": "You appear to have a fundamental misunderstanding over the way equals and hashCode interact", "label": {"api": {"hashCode": [[74, 81]], "equals": [[63, 68]]}}}, {"text": "they don't; operator == checks object identity, so in your program it will return false even if you properly override hashCode and equals", "label": {"api": {"hashCode": [[118, 125]], "equals": [[131, 136]]}}}, {"text": "You must always override both these methods in pairs, and call equals to check equality", "label": {"api": {"equals": [[63, 68]]}}}, {"text": "Returning the same hash code tells hash-based containers that your objects may be equal, thus triggering an additional call to equals; returning different hash codes allows hash containers to skip the call to equals", "label": {"api": {"equals": [[127, 132], [209, 214]]}}}, {"text": "documentation for hashCode and equals", "label": {"api": {"hashCode": [[18, 25]], "equals": [[31, 36]]}}}, {"text": "An Integer#parseInt(String s) throws unchecked exception NumberFormatException if the string is not parseable integer", "label": {"api": {"Integer#parseInt(String s)": [[3, 28]], "NumberFormatException": [[57, 77]]}}}, {"text": "This is just another answer using streams and merge function of Maps", "label": {"api": {"merge": [[46, 50]]}}}, {"text": "If efficiency is your primary concern, I think you can use your solution and make it more efficient by using an indexed for loop on the listResult if it is RandomAccess", "label": {"api": {"RandomAccess": [[156, 167]]}}}, {"text": "The ListIterate utility will use different iteration code for RandomAccess lists and non-RandomAccess lists", "label": {"api": {"RandomAccess": [[62, 73], [89, 100]]}}}, {"text": "You need to use the get(int) method of a list to access objects in the list based on their index", "label": {"api": {"get(int)": [[20, 27]]}}}, {"text": "Why not just call String#toCharArray on the string", "label": {"api": {"String#toCharArray": [[18, 35]]}}}, {"text": "Note that you may want to loop through the string using String#charAt instead, because it is unnecessary to copy the character array, especially for very large strings", "label": {"api": {"String#charAt": [[56, 68]]}}}, {"text": "Note that it is a static method, so calling it from a object instance is not right either, just use Cipher.getMaxAllowedKeyLength where you need it", "label": {"api": {"Cipher": [[100, 105]]}}}, {"text": "The ciphers and key sizes that MUST be supported are listed in the Cipher class itself (all the way to the bottom)", "label": {"api": {"Cipher": [[67, 72]]}}}, {"text": "You can use JSONObject.getInt() method", "label": {"api": {"JSONObject.getInt()": [[12, 30]]}}}, {"text": "Both methods you are looking for are in java.io.ObjectInputStream class (link)", "label": {"api": {"link": [[73, 76]]}}}, {"text": "If you have a list of words to filter for called filter and an array of sentences you could use Collections.disjoint to compare if the words of that sentence does not overlap with the words to filter for", "label": {"api": {"Collections.disjoint": [[96, 115]]}}}, {"text": "invokeLater (asynchronous) and invokeAndWait (synchronous) are utility methods to update GUI elements from another thread", "label": {"api": {"invokeLater": [[0, 10]], "invokeAndWait": [[31, 43]]}}}, {"text": "The javax.xml.parsers.SAXParser does not support reading comments", "label": {"api": {"javax.xml.parsers.SAXParser": [[4, 30]]}}}, {"text": "The org.xml.sax.ext.LexicalHandler allows you catching comments when parsing with org.xml.sax.XMLReader", "label": {"api": {"org.xml.sax.ext.LexicalHandler": [[4, 33]], "org.xml.sax.XMLReader": [[82, 102]]}}}, {"text": "If you want to connect a comment to an element, which comes right after it, you can additionally pass a org.xml.sax.ContentHandler to the parser and track other XML content by it", "label": {"api": {"org.xml.sax.ContentHandler": [[104, 129]]}}}, {"text": "currentTimeMillis() returns the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC", "label": {"api": {"currentTimeMillis()": [[0, 18]]}}}, {"text": "Client-server connection and subsequently Socket is based on the TCP protocol model", "label": {"api": {"Socket": [[42, 47]]}}}, {"text": "What you seek is DatagramSocket based on UDP, you might suffer the loss of packages but that's the way things work", "label": {"api": {"Socket": [[25, 30]], "DatagramSocket": [[17, 30]]}}}, {"text": "The heuristic on solving similar problems in the future is to learn to use the Java API, search on the class of interest, here the Shape type, check out the Shape API", "label": {"api": {"Java API": [[79, 86]], "Shape API": [[157, 165]]}}}, {"text": "Check out its API and see what methods are available to it", "label": {"api": {"its API": [[10, 16]]}}}, {"text": "Here it has useful methods from its parent class RectangularShape, including getX() and getY()", "label": {"api": {"RectangularShape": [[49, 64]]}}}, {"text": "You want to use a capturing group", "label": {"api": {"capturing group": [[18, 32]]}}}, {"text": "In Java 8+, you can use IntStream.anyMatch", "label": {"api": {"IntStream.anyMatch": [[24, 41]]}}}, {"text": "you set the valueProperty as a String value", "label": {"api": {"valueProperty": [[12, 24]]}}}, {"text": "Don't call repaint in your paint method", "label": {"api": {"repaint": [[11, 17]]}}}, {"text": "repaint() means \"This component needs to be repainted\"", "label": {"api": {"repaint": [[0, 6], [44, 50]]}}}, {"text": "Perhaps you don't realise you are overriding the paint(Graphics) method, which determines how a component is rendered", "label": {"api": {"paint(Graphics)": [[49, 63]]}}}, {"text": "You are not correctly overriding the process method , the signature is like", "label": {"api": {"process": [[37, 43]]}}}, {"text": "Maybe it's a good idea to consider using public methods like TableView#scrollTo(int index) or similar methods", "label": {"api": {"TableView#scrollTo(int index)": [[61, 89]]}}}, {"text": "This is done with the Optional::map method", "label": {"api": {"the Optional::map method": [[18, 41]]}}}, {"text": "Indeed keep in mind that the method split(String regex) expects a regular expression as argument", "label": {"api": {"split(String regex)": [[36, 54]], "regular expression": [[66, 83]]}}}, {"text": "You should set a NavigationFilter which ignores all changes to the caret position", "label": {"api": {"set a NavigationFilter": [[11, 32]]}}}, {"text": "You could use Optional#flatMap to 'unwrap' the inner optional", "label": {"api": {"Optional#flatMap": [[14, 29]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/Character.UnicodeScript.html (look for Since", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Character.UnicodeScript.html": [[0, 78]]}}}, {"text": "You might prefer the classes and methods available from java.nio (generally) and the read methods available in Files (specifically) when dealing with small files", "label": {"api": {"java.nio": [[56, 63]], "Files": [[111, 115]]}}}, {"text": "It looks like the code is appending the file content line by line to a JTextArea (or worse, an old AWT TextArea)", "label": {"api": {"JTextArea": [[71, 79]]}}}, {"text": "Have you considered using a DelayQueue", "label": {"api": {"DelayQueue": [[28, 37]]}}}, {"text": "use an ExceptionMapper", "label": {"api": {"ExceptionMapper": [[7, 21]]}}}, {"text": "The @Provider annotation tells the JAX-RS runtime to discover this class when scanning", "label": {"api": {"@Provider": [[4, 12]]}}}, {"text": "If the application code throws a MyCustomExceptionMapper, JAX-RS will look for an exception mapper registered with that type, and will go up the super class if it can't find one", "label": {"api": {"ExceptionMapper": [[41, 55]]}}}, {"text": "Or simply (?!ES|PT|DE)[A-Z]{2} if you use the method matches(String regex) as mentioned by @WiktorStribiżew", "label": {"api": {"matches(String regex)": [[53, 73]]}}}, {"text": "But note that the GenericConverter interface in this cases is structurally equal to the Function interface - so there is probably no reason to create a new one", "label": {"api": {"Function": [[88, 95]]}}}, {"text": "Use Lists instead of Arrays, and then turn to Collections.shuffle() - that method puts your elements into a random order", "label": {"api": {"Collections.shuffle()": [[46, 66]]}}}, {"text": "To avoid that you need to use BigInteger", "label": {"api": {"BigInteger": [[30, 39]]}}}, {"text": "Set the fill to an ImagePattern, or a Gradient to achieve the hatch", "label": {"api": {"ImagePattern": [[19, 30]], "Gradient": [[38, 45]]}}}, {"text": "I recommend using LinkedHashSet since it's add and remove operations runs in O(1) (assuming even distribution of the hash codes)", "label": {"api": {"LinkedHashSet": [[18, 30]]}}}, {"text": "You could try using a CountDownLatch", "label": {"api": {"CountDownLatch": [[22, 35]]}}}, {"text": "The code example is from Reading Directly from a URL, but the tutorial is old", "label": {"api": {"URL": [[49, 51]]}}}, {"text": "If you use a URL that does not redirect, like http://www.google.com you will see that the code works", "label": {"api": {"URL": [[13, 15]]}}}, {"text": "If you want a more robust program that handles redirects, you'll probably want to use a HttpURLConnection instead of the basic URL, as it has more features for you to use", "label": {"api": {"HttpURLConnection": [[88, 104]], "URL": [[92, 94], [127, 129]]}}}, {"text": "As suggested by one of the comments a Deque would be a good data structure to achieve this", "label": {"api": {"Deque": [[38, 42]]}}}, {"text": "Boolean.class is not equal to Boolean.TYPE (the Class object representing the primitive type boolean)", "label": {"api": {"Boolean.class": [[0, 12]], "Boolean.TYPE": [[30, 41]]}}}, {"text": "If the idea is to use the same PreparedStatement for different queries of the same type with only parameters' value that change, yes it is possible, simply call clearParameters() first to clear the parameters in case you want to reuse it before setting the new parameters' value", "label": {"api": {"clearParameters()": [[161, 177]]}}}, {"text": "You should use the BigDecimal.signum() method for check the sign of BigDecimal", "label": {"api": {"BigDecimal.signum()": [[19, 37]]}}}, {"text": "Make use of the LinkedHashSet class instead", "label": {"api": {"LinkedHashSet": [[16, 28]]}}}, {"text": "when query is not in a transaction, and connection is currently in read-only mode (using Spring @Transactional(readOnly = false)) for example", "label": {"api": {"read-only mode": [[67, 80]]}}}, {"text": "JRootPane inherits getName() from it's parent, Component, and JRootPane does not override the method", "label": {"api": {"JRootPane": [[0, 8], [62, 70]], "Component": [[47, 55]]}}}, {"text": "It calls the package-private method constructComponentName(), which returns null unconditionally", "label": {"api": {"Component": [[45, 53]]}}}, {"text": "If you need a thread-safe Queue, a ConcurrentLinkedQueue could be enough for you but if you rather need a thread-safe BlockingQueue, you should use a LinkedBlockingQueue instead for such need like the example of implementation of the pattern Active Object on wikipedia", "label": {"api": {"ConcurrentLinkedQueue": [[35, 55]], "LinkedBlockingQueue": [[150, 168]]}}}, {"text": "Check that the map isn't null (not that HashMap.containsKey(T) returned null, because it didn't - it can't", "label": {"api": {"HashMap.containsKey(T)": [[40, 61]]}}}, {"text": "In CSS (JavaFX) all properties start with the keyword \"-fx-\" (excepted fo Visibility), So either the syntax is false or this property does not work with this selector", "label": {"api": {"Visibility": [[74, 83]]}}}, {"text": "Just give it a look at the Enumeration documentation", "label": {"api": {"the Enumeration documentation": [[23, 51]]}}}, {"text": "If you check the nextElement() signature it returns E", "label": {"api": {"nextElement() signature": [[17, 39]]}}}, {"text": "You can use Comparator interface for custom sorting", "label": {"api": {"Comparator": [[12, 21]]}}}, {"text": "For your actual problem; hard to say; but in general, when using a Scanner, those class has a whole set of methods like hasNextLine() that can be used to check that there is really some input available", "label": {"api": {"hasNextLine()": [[120, 132]]}}}, {"text": "Which yields the following list (not including -fx-text or anything that allows you to set the content according to the CSS Reference Guide)", "label": {"api": {"CSS Reference Guide": [[120, 138]]}}}, {"text": "Since all fonts in a line share a baseline*, you can compute a character’s visual position by calling modelToView and subtracting the descent and ascent from the bottom of the rectangle", "label": {"api": {"modelToView": [[102, 112]], "View": [[109, 112]]}}}, {"text": "However, the actual font for any document position can be obtained from the corresponding View", "label": {"api": {"View": [[90, 93]]}}}, {"text": "Since toLocalDateTime() also applies the system's default timezone conversion, this AttributeConverter basically cancels out the conversion applied by the JDBC driver", "label": {"api": {"toLocalDateTime()": [[6, 22]]}}}, {"text": "What you need to do is to use a Set that is thread-safe for iGraphicSectors as you obviously read and modify it concurrently, the simplest way can be to use the decorator Collections.synchronizedSet(Set<T> s) to make your current Set thread-safe, any read and write accesses will then be automatically protected with a synchronized block thanks to the decorator, however you still need to protect iterations over it explicitly with a synchronized block", "label": {"api": {"Collections.synchronizedSet(Set<T> s)": [[171, 207]]}}}, {"text": "If you have many reader (iterators) and want them to execute in parallel, you should definitely replace synchronization with the use of ReadWriteLock", "label": {"api": {"ReadWriteLock": [[136, 148]]}}}, {"text": "Instead, create a ReentrantReadWriteLock, and always obtain locks around any use of the map, using readLock() for readers (iteration, get(), containsKey(), etc), and writeLock() for mutators (put(), remove(), iteration with remove(), etc)", "label": {"api": {"ReadWriteLock": [[27, 39]], "ReentrantReadWriteLock": [[18, 39]]}}}, {"text": "That class ObservableList has a nice method addAll()", "label": {"api": {"addAll()": [[44, 51]]}}}, {"text": "Instead of doing that, you could call addAll() on an existing collection to add the newly created one; like", "label": {"api": {"addAll()": [[38, 45]]}}}, {"text": "The toSet() collector returns a Set with “no guarantees on the type, mutability, serializability, or thread-safety”", "label": {"api": {"“no guarantees on the type, mutability, serializability, or thread-safety”": [[41, 114]]}}}, {"text": "You will probably want to check that words has a length of 2 after your call to split()", "label": {"api": {"split()": [[80, 86]]}}}, {"text": "Also keep in mind that Integer.parseInt() can throw a NumberFormatException if it is not able to parse the data in the scores column as an integer", "label": {"api": {"Integer.parseInt()": [[23, 40]], "NumberFormatException": [[54, 74]]}}}, {"text": "In your specific case, you might want to use computeIfPresent method of ConcurrentHashMap", "label": {"api": {"computeIfPresent method": [[45, 67]]}}}, {"text": "You could initialise a CountdownLatch with the number of elements, then await it in the main thread", "label": {"api": {"CountdownLatch": [[23, 36]]}}}, {"text": "There's a few options here, but generally you'll want to use the Java Scanner class as it's designed for exactly this kind of thing", "label": {"api": {"Scanner class": [[70, 82]]}}}, {"text": "You can use the @SuppressWarnings annotation", "label": {"api": {"@SuppressWarnings": [[16, 32]]}}}, {"text": "What is the list of valid @SuppressWarnings warning names in Java", "label": {"api": {"@SuppressWarnings": [[26, 42]]}}}, {"text": "Better use something like BorderLayout in your case for the JFrame", "label": {"api": {"BorderLayout": [[26, 37]]}}}, {"text": "How you can interpret the return value of the binary search method is explained in the Java API docs", "label": {"api": {"Java API docs": [[87, 99]]}}}, {"text": "Why not use a Timer", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "Use ${system_property:line.separator}, this will read the Java system property named line.separator, which is in the list of always present system properties", "label": {"api": {"list of always present system properties": [[117, 156]]}}}, {"text": "Use a single replaceAll() method with updated regex otherwise the second replaceAll() call will replace including the first four digits", "label": {"api": {"replaceAll()": [[13, 24], [73, 84]]}}}, {"text": "Apache introduced a new Thread Pool called WaterMarkExecutor that extends ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[74, 91]]}}}, {"text": "and what advantage does it have over ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[37, 54]]}}}, {"text": "Change split(\"=\") to split(\"=\", -1), so trailing empty strings will not be discarded", "label": {"api": {"split(\"=\")": [[7, 16]], "split(\"=\", -1)": [[21, 34]]}}}, {"text": "Have a look at the BufferStrategy class", "label": {"api": {"BufferStrategy": [[19, 32]]}}}, {"text": "You could go over the list's contents and call String.valueOf(Object) of each one", "label": {"api": {"String.valueOf(Object)": [[47, 68]]}}}, {"text": "This can also be done inline with a ListIterator, if you're so inclined", "label": {"api": {"ListIterator": [[36, 47]]}}}, {"text": "What you need here is to observe the slider's valueProperty()", "label": {"api": {"valueProperty()": [[46, 60]]}}}, {"text": "You will get a ClassCastException", "label": {"api": {"ClassCastException": [[15, 32]]}}}, {"text": "Assuming that a Book has a getPages method returning a collection of Pages, you need to use flatMap method to \"flatten\" collections of pages inside a collection of books", "label": {"api": {"flatMap": [[92, 98]]}}}, {"text": "In the documentation from the ArrayList class it is written in bold", "label": {"api": {"ArrayList class": [[30, 44]]}}}, {"text": "On the documentation page of the Vector class, in the last paragraph of the introduction text, the last sentences are", "label": {"api": {"Vector class": [[33, 44]]}}}, {"text": "The method isStillSincePress() can be used together with the getEventType(), both from the MouseEvent API", "label": {"api": {"isStillSincePress()": [[11, 29]], "getEventType()": [[61, 74]]}}}, {"text": "See the documentation to ExecutorService", "label": {"api": {"ExecutorService": [[25, 39]]}}}, {"text": "Actions in a thread prior to the submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the result is retrieved via Future.get()", "label": {"api": {"ExecutorService": [[81, 95]], "happen-before": [[97, 109], [157, 169]]}}}, {"text": "String.split() returns an array of values between each occurrence of the delimiter", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "The reason you're getting \"garbage\" values is because arrays use the default implementation of toString()", "label": {"api": {"default implementation": [[69, 90]]}}}, {"text": "You could flatten your multidimensional Array with this method, and call List#size() on it", "label": {"api": {"List#size()": [[73, 83]]}}}, {"text": "To ignore errors during recursive directory traversal you need to use walkFileTree with a FileVisitor that does error handling", "label": {"api": {"FileVisitor": [[90, 100]]}}}, {"text": "If Yes, then change your GenerationType from Auto to SEQUENCE", "label": {"api": {"SEQUENCE": [[53, 60]]}}}, {"text": "I've a similar setup with Postgres and setting GenerationType as SEQUENCE and giving allocationSize = 1 worked for me", "label": {"api": {"SEQUENCE": [[65, 72]]}}}, {"text": "You are not supposed to iterate over the entries to find a match, you are supposed to use get(Object key) or getOrDefault(Object key, V defaultValue) to get the full form of a given abbreviation, otherwise instead of getting your full form with a time complexity of O(1), you will get it with a O(n) which is of course not good in term of performances, you would lose the real benefit of having your key/value pairs in a Map", "label": {"api": {"get(Object key)": [[90, 104]], "getOrDefault(Object key, V defaultValue)": [[109, 148]]}}}, {"text": "Using the Stream API, it could simply be", "label": {"api": {"Stream API": [[10, 19]]}}}, {"text": "A good way to handle currency is to use BigDecimal", "label": {"api": {"BigDecimal": [[40, 49]]}}}, {"text": "Here is also some example of BigDecimal for Android", "label": {"api": {"BigDecimal": [[29, 38]]}}}, {"text": "You might use a custom Collector to achieve your goal", "label": {"api": {"Collector": [[23, 31]]}}}, {"text": "You should use the Nested Controllers technique shown in the documentation to access the controllers for the included FXML files", "label": {"api": {"shown in the documentation": [[48, 73]]}}}, {"text": "Class.getResource is used to retrieve the URL of a resource that can be found in the classpath", "label": {"api": {"getResource": [[6, 16]]}}}, {"text": "FXMLLoader then loads the file with this URL", "label": {"api": {"loads": [[16, 20]], "FXMLLoader": [[0, 9]]}}}, {"text": "FXMLLoader has two way of loading , by URL or by InputStream", "label": {"api": {"FXMLLoader": [[0, 9]]}}}, {"text": "poll the queue, check for null, and use zero if it is", "label": {"api": {"poll the queue": [[0, 13]]}}}, {"text": "either way, you might want to look into the uncaughtExceptionHandler", "label": {"api": {"uncaughtExceptionHandler": [[44, 67]]}}}, {"text": "The reason for this problem is that java.text.MessageFormat is being used", "label": {"api": {"java.text.MessageFormat": [[36, 58]]}}}, {"text": "A Clob can be up to 2,147,483,647 characters long so it should be enough in your case, to prevent this issue instead of providing the value as a String literal which is limited to 4,000 characters long as you already have noticed, provide it as a nAscii stream or a Clob, thanks to respectively one of the methods setAsciiStream or thanks to the method setClob(int parameterIndex, Reader reader) of the class PreparedStatement", "label": {"api": {"setClob(int parameterIndex, Reader reader)": [[353, 394]]}}}, {"text": "Float.parseFloat returns float, not Float", "label": {"api": {"Float.parseFloat": [[0, 15]]}}}, {"text": "The second two operands of a conditional operator must be of the same type, but you're giving it float (the result of Float.parseFloat) and Float (def)", "label": {"api": {"Float.parseFloat": [[118, 133]]}}}, {"text": "Lots of ways to do that, but as Zefick points out, the simplest is Float.valueOf(String)", "label": {"api": {"Float.valueOf(String)": [[67, 87]]}}}, {"text": "The string is URL encoded, you can use URLDecoder.decode( urlstring, encoding ) to decode it before passing it to the database", "label": {"api": {"URLDecoder.decode( urlstring, encoding )": [[39, 78]]}}}, {"text": "you could/should use java.util.Properties; and there is full support for reading that information from files; or writing to", "label": {"api": {"java.util.Properties": [[21, 40]]}}}, {"text": "The JAXB API has been part of the Java SE API for a while now, and you can find the classes in package javax.xml.bind", "label": {"api": {"package javax.xml.bind": [[95, 116]]}}}, {"text": "One of the possible ways to do it, just invoke method createArrayOf on your connection (see also this answer)", "label": {"api": {"method": [[47, 52]]}}}, {"text": "It's not obvious to me why they designed it this way, but the code that implements the Expect:100 logic is only used if you have called one of setFixedLengthStreamingMode(int contentlen) or the overload for long or setChunkedStreamingMode(int chunklen) before doing getOutputStream", "label": {"api": {"setFixedLengthStreamingMode(int contentlen)": [[143, 185]], "the overload for long": [[190, 210]], "setChunkedStreamingMode(int chunklen)": [[215, 251]]}}}, {"text": "I see in the Java docs that Base64.Encoder has a method to encode bytes into bytes", "label": {"api": {"the Java docs": [[9, 21]]}}}, {"text": "If you're asking what the method does, based on the javadoc of encodeToString(), it would seem to return the bytes representing the base64 string in ISO_8859_1", "label": {"api": {"encodeToString()": [[63, 78]]}}}, {"text": "The javadoc for the ImageIO.read(InputStream is) method states", "label": {"api": {"ImageIO.read(InputStream is)": [[20, 47]]}}}, {"text": "BufferedWriter uses the default toString() implementation from Object", "label": {"api": {"BufferedWriter": [[0, 13]], "toString()": [[32, 41]]}}}, {"text": "The returned String contains the class name and the Objects hashCode()", "label": {"api": {"hashCode()": [[60, 69]]}}}, {"text": "If you want a string containing the output either use String.format or a StringWriter to format your output before you write it to the file", "label": {"api": {"String.format": [[54, 66]], "StringWriter": [[73, 84]]}}}, {"text": "as mentioned by other answers the BufferedWriter is used internally by the Formatter when it is created with a filename", "label": {"api": {"BufferedWriter": [[34, 47]]}}}, {"text": "Formatter.toString() calls BufferedWriter.toString() in this case", "label": {"api": {"BufferedWriter": [[27, 40]], "toString()": [[10, 19], [42, 51]], "Formatter.toString()": [[0, 19]]}}}, {"text": "In Java 8 you can use getAndAccumulate as follows", "label": {"api": {"getAndAccumulate": [[22, 37]]}}}, {"text": "Try using a BufferedWriter", "label": {"api": {"BufferedWriter": [[12, 25]]}}}, {"text": "Also, don't forget to call the flush method in the end so that all buffered data is outputted", "label": {"api": {"flush": [[31, 35]]}}}, {"text": "A second option could be using a StringBuilder", "label": {"api": {"StringBuilder": [[33, 45]]}}}, {"text": "If you aren't using regular expressions, better to use String.replace()", "label": {"api": {"String.replace()": [[55, 70]]}}}, {"text": "String.replace() does a literal replacement, it doesn't treat the arguments as regular expressions", "label": {"api": {"String.replace()": [[0, 15]]}}}, {"text": "String.replaceAll  uses regex", "label": {"api": {"String.replaceAll": [[0, 16]]}}}, {"text": "Do not use a Timer for this, unless you are prepared to wrap each update to the scrollbar value in a call to Platform.runLater", "label": {"api": {"Platform.runLater": [[109, 125]]}}}, {"text": "The correct approach is to use a Timeline animation", "label": {"api": {"Timeline": [[33, 40]]}}}, {"text": "Then to retrieve the content of your column as an InputStream use getBinaryStream(String columnLabel) or getBinaryStream(int columnIndex)", "label": {"api": {"getBinaryStream(String columnLabel)": [[66, 100]], "getBinaryStream(int columnIndex)": [[105, 136]]}}}, {"text": "You need to use one of the updateAAD methods", "label": {"api": {"updateAAD methods": [[27, 43]]}}}, {"text": "You can use the method peek() to check what the next event is going to be", "label": {"api": {"peek()": [[23, 28]]}}}, {"text": "You can then use method isCharacters() on the resulting XMLEvent to find out if the next event is text", "label": {"api": {"isCharacters()": [[24, 37]]}}}, {"text": "Use the method asCharacters() on it to get a Characters object", "label": {"api": {"asCharacters()": [[15, 28]]}}}, {"text": "Note that you'll want to test for isIgnorableWhiteSpace() so that the empty space between an opening tag and another opening tag without significant text isn't reported", "label": {"api": {"isIgnorableWhiteSpace()": [[34, 56]]}}}, {"text": "format uses String.format(), which uses Formatter, which afaict does not support any rounding mode except HALF_UP", "label": {"api": {"Formatter": [[40, 48]]}}}, {"text": "and create your underlying list with an extractor so that it fires events when the properties of interest change", "label": {"api": {"extractor": [[40, 48]]}}}, {"text": "As Sotirios Delimanolis stated in the comment, you may also want to have a look at the javadoc and follow @see BinaryOperator", "label": {"api": {"@see BinaryOperator": [[106, 124]]}}}, {"text": "Or have a look at the function package summary javadoc", "label": {"api": {"function package summary javadoc": [[22, 53]]}}}, {"text": "For example map.put(K, V)", "label": {"api": {"map.put(K, V)": [[12, 24]]}}}, {"text": "You are calling getSelectedText() when you should be calling getText()", "label": {"api": {"getSelectedText()": [[16, 32]], "getText()": [[61, 69]]}}}, {"text": "The documentation for getSelectedText() says", "label": {"api": {"getSelectedText()": [[22, 38]]}}}, {"text": "To just get whatever has been typed in the JTextField, use getText()", "label": {"api": {"getText()": [[59, 67]]}}}, {"text": "You never instantiate MyMouseListener or add it to any component with addMouseListener()", "label": {"api": {"addMouseListener()": [[70, 87]]}}}, {"text": "As Jesper answer above, the API docs is very clear about it", "label": {"api": {"API docs": [[28, 35]]}}}, {"text": "you should use a Set, insert all your elements into the Set, and it would not have any duplicates if you insert the same value twice", "label": {"api": {"Set": [[17, 19], [56, 58]]}}}, {"text": "All classes (except for classes for primitives) have a common ancestor (at the very worst, the Object class), and we can use this information in order to ensure there is some ordering", "label": {"api": {"Object": [[95, 100]]}}}, {"text": "At the worst, you can simply compare the two classes on their \"depth\" in their respective inheritance hierarchies rooted from Object", "label": {"api": {"Object": [[126, 131]]}}}, {"text": "The documentation for DocumentBuilder.parse(String) states", "label": {"api": {"documentation for DocumentBuilder.parse(String)": [[4, 50]]}}}, {"text": "To read a file inside a .jar, you use Class.getResource or Class.getResourceAsStream", "label": {"api": {"Class.getResource": [[38, 54], [59, 75]], "Class.getResourceAsStream": [[59, 83]]}}}, {"text": "Note that both Class.getResource and Class.getResourceAsStream return null if the argument is not a path of an existing jar entry", "label": {"api": {"Class.getResource": [[15, 31], [37, 53]], "Class.getResourceAsStream": [[37, 61]]}}}, {"text": "Remember that split() takes a regex as parameter, not a String and so, you can do something like the above code to get the desired output", "label": {"api": {"split()": [[14, 20]]}}}, {"text": "The easiest way of achieving this is to put all available numbers in a list and then shuffle it", "label": {"api": {"shuffle": [[85, 91]]}}}, {"text": "However, doing so would violate the documentated behavior of equals, which states that this property must hold for any valid implementation", "label": {"api": {"documentated behavior of equals": [[36, 66]]}}}, {"text": "The contract for equals has 5 rules, and the first one covers this case", "label": {"api": {"The contract for equals has 5 rules": [[0, 34]]}}}, {"text": "However try this code to allow for any capitalization of answer using toLowerCase()", "label": {"api": {"toLowerCase()": [[70, 82]]}}}, {"text": "Using distinct class loaders has the additional advantage that you can close them when you’re done", "label": {"api": {"close them": [[71, 80]]}}}, {"text": "If you need to persist these data or settings, you can use Properties", "label": {"api": {"Properties": [[59, 68]]}}}, {"text": "You can set margin for JPanel (contaiter) using EmptyBorder class", "label": {"api": {"EmptyBorder": [[48, 58]]}}}, {"text": "To overcome this use BigDecimal", "label": {"api": {"BigDecimal": [[21, 30]]}}}, {"text": "However make sure you set the Scale and RoundingMode", "label": {"api": {"Scale": [[30, 34]], "RoundingMode": [[40, 51]]}}}, {"text": "As is described in the Javadoc, Comparable is intended to model the natural ordering, which is a total order, and so to be able to have anti-symmetry, the type of the argument of compareTo should be the same as the type on which that method is defined", "label": {"api": {"in the Javadoc": [[16, 29]]}}}, {"text": "it is in your classpath, so you can use getResourceAsStream()", "label": {"api": {"getResourceAsStream()": [[40, 60]]}}}, {"text": "The \"paste\" functionality is implemented in the TextInputControl superclass of TextField in public void paste()", "label": {"api": {"public void paste()": [[92, 110]]}}}, {"text": "The best way is tu use String#replaceAll method, but you have to store it explicitely into the variable because strings are immutable", "label": {"api": {"String#replaceAll": [[23, 39]]}}}, {"text": "If you create a File object for the parent directory of the files you want to list, you can call that object's listFiles() to get an array of File objects in that directory", "label": {"api": {"listFiles()": [[111, 121]]}}}, {"text": "But how about using the Stream-API instead", "label": {"api": {"Stream-API": [[24, 33]], "Stream": [[24, 29]]}}}, {"text": "with the following IntBinaryOperator-returning function", "label": {"api": {"IntBinaryOperator": [[19, 35]]}}}, {"text": "Note that you could also use IntStream.sum to achieve a simple sum", "label": {"api": {"Stream": [[32, 37]]}}}, {"text": "Just have a look at the OptionalInt-javadoc for your options", "label": {"api": {"OptionalInt-javadoc": [[24, 42]]}}}, {"text": "As soon as you move away from the primitive int you may want to exchange the code by using Stream, BinaryOperator<Integer> and Optional<Integer>", "label": {"api": {"Stream": [[91, 96]], "BinaryOperator<Integer>": [[99, 121]], "Optional<Integer>": [[127, 143]]}}}, {"text": "But why messing with indexes and arrays, if you can use Streams and so few lines of code", "label": {"api": {"Stream": [[56, 61]]}}}, {"text": "If you need to format the cell items, also provide a cell factory", "label": {"api": {"cell factory": [[53, 64]]}}}, {"text": "Because we are using a ReadOnlyObjectWrapper around the data value, if you made the table cell editable (which I did not do in this sample), it would not write back the edited value to the array", "label": {"api": {"ReadOnlyObjectWrapper": [[23, 43]]}}}, {"text": "The wrapper is necessary to convert the double data value to an ObservableValue (as required by the cell factory interface)", "label": {"api": {"cell factory": [[100, 111]]}}}, {"text": "If you don't need the virtualization features and other features of a TableView, you could always just use labels in a GridPane instead", "label": {"api": {"GridPane": [[119, 126]]}}}, {"text": "I would like the displayed timestamp to be displayed in a localized format (based on the Locale of the system); which is easy enough using either of the DateTimeFormatter.ofLocalizedDateTime() methods", "label": {"api": {"DateTimeFormatter.ofLocalizedDateTime()": [[153, 191]]}}}, {"text": "You can define your own EmployeeComparator that implements Comparator<Employee> (see comparator) and use it like following", "label": {"api": {"comparator": [[85, 94]]}}}, {"text": "Assuming that you use Java 8, you could do that using the Stream API, by using the literal \"2017 Girl\" as separator pattern and by using Collectors.joining() as collector to build a new String without any occurence of the provided pattern", "label": {"api": {"Stream API": [[58, 67]], "Collectors.joining()": [[137, 156]]}}}, {"text": "The JPA TemporalType.TIMESTAMP corresponds to the JDBC java.sql.Timestamp type, which in turn corresponds to Oracle's (and the SQL standard) TIMESTAMP [ WITHOUT TIME ZONE ] type", "label": {"api": {"TemporalType.TIMESTAMP": [[8, 29]], "java.sql.Timestamp": [[55, 72]]}}}, {"text": "While JDBC 4.2 (Java 8) added support also for OffsetDateTime, Java EE 7's TemporalType is not there yet", "label": {"api": {"OffsetDateTime": [[47, 60]]}}}, {"text": "Check out the String.startsWith() method and use that to check the value of the hyperlink before you call processPage", "label": {"api": {"Check out": [[0, 8]]}}}, {"text": "Use String.indexOf() checking to see if each abbreviation exists in the input string and replaceAll() to modify the string if it does", "label": {"api": {"String.indexOf()": [[4, 19]], "replaceAll()": [[89, 100]]}}}, {"text": "This above implementation does not deal with any irregular capitalization of input for that issue I suggest you look into toLowerCase() or to toUppperCase()", "label": {"api": {"toLowerCase()": [[122, 134]], "toUppperCase()": [[142, 155]]}}}, {"text": "In response to your first question, set.remove(i) calls Set#remove(Object), which removes an element by value", "label": {"api": {"Set#remove(Object)": [[56, 73]]}}}, {"text": "List also has a remove(Object) method (inherited from Collection), but since i is int, list.remove(i) resolves to the more specific List#remove(int), which removes an element by index", "label": {"api": {"List#remove(int)": [[132, 147]]}}}, {"text": "See the javadoc to System#arraycopy() for specifics", "label": {"api": {"System#arraycopy()": [[19, 36]]}}}, {"text": "See documentation of getInputStream", "label": {"api": {"getInputStream": [[21, 34]]}}}, {"text": "See javadoc PrintWriter", "label": {"api": {"javadoc PrintWriter": [[4, 22]]}}}, {"text": "You can use Arrays#toString() with the entry set from your map to get a neatly printed map", "label": {"api": {"Arrays#toString()": [[12, 28]]}}}, {"text": "As the Javadoc for PriorityQueue discusses", "label": {"api": {"Javadoc for PriorityQueue": [[7, 31]]}}}, {"text": "Maybe the Stream API and Collectors.partitioningBy could help you", "label": {"api": {"Stream API": [[10, 19]], "Collectors.partitioningBy": [[25, 49]]}}}, {"text": "The Java Collections APIallows you to Sort as well as util.Arrays", "label": {"api": {"Java Collections API": [[4, 23]], "util.Arrays": [[54, 64]]}}}, {"text": "Besides using double you may also want to look at BigDecimal instead", "label": {"api": {"BigDecimal": [[50, 59]]}}}, {"text": "What you could do is use a StringBuilder that will be initialized with your input String, then use setCharAt(int index, char ch) to modify a given char, this way you avoid building a new String at each iteration as you currently do with the operator += on String", "label": {"api": {"StringBuilder": [[27, 39]], "setCharAt(int index, char ch)": [[99, 127]]}}}, {"text": "If you want to simply remove the characters, you should use the method append(CharSequence s, int start, int end) to build the content of your target String, as next", "label": {"api": {"append(CharSequence s, int start, int end)": [[71, 112]]}}}, {"text": "You can use Double.parseDouble() to convert your string to double", "label": {"api": {"Double.parseDouble()": [[12, 31]]}}}, {"text": "More likely than not, however, the practical reason for the implementation is given by by these remarks in the Javadocs for java.StrictMath", "label": {"api": {"the Javadocs for java.StrictMath": [[107, 138]]}}}, {"text": "You can use an List implementation as ArrayList", "label": {"api": {"List": [[15, 18], [43, 46]], "ArrayList": [[38, 46]]}}}, {"text": "The initial capacity is optional, but you can instantiate the array using new ArrayList<>(20), where 20 is the initial (not maximum) capacity", "label": {"api": {"List": [[83, 86]], "ArrayList": [[78, 86]]}}}, {"text": "I recommend you to use ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[23, 39]]}}}, {"text": "Use a Comparator with the Collections.sort() method", "label": {"api": {"Comparator": [[6, 15]], "Collections.sort()": [[26, 43]]}}}, {"text": "You can use Path class", "label": {"api": {"Path": [[12, 15]]}}}, {"text": "You can use the redirectError(), redirectInput(), and redirectOutput() methods as needed to prevent such blocking", "label": {"api": {"redirectError(), redirectInput(), and redirectOutput()": [[16, 69]]}}}, {"text": "A quote from the Set javadoc", "label": {"api": {"Set javadoc": [[17, 27]]}}}, {"text": "Keep in mind that when you implement equals you should also implement hashcode, as explained here and in the equals javadoc", "label": {"api": {"equals javadoc": [[109, 122]]}}}, {"text": "How about simply using the built-in DayOfWeek enum", "label": {"api": {"DayOfWeek": [[36, 44]]}}}, {"text": "From the Java API", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "By analogy with ToolTipManager setDismissDelay(int milliseconds) method, i would like to implement a dismiss delay for the rollover effect on a JButton", "label": {"api": {"ToolTipManager": [[16, 29]]}}}, {"text": "You already have a ChangeListener dispatching events as needed, executing callbacks right on the JavaFX Application Thread; just use it", "label": {"api": {"ChangeListener": [[19, 32]]}}}, {"text": "You should wrap the set method calls on your StringProperty's instance into a Platform.runLater(Runnable runnable) to prevent this issue by ensuring that it is modified through the JavaFX Application Thread as next, indeed calling set will have a direct impact on your UI as it is bound and only the JavaFX Application Thread is allowed to modify your UI since the Java FX Components are not thread safe", "label": {"api": {"Platform.runLater(Runnable runnable)": [[78, 113]]}}}, {"text": "Here is the list of all methods of the HashMap class", "label": {"api": {"Here is the list": [[0, 15]]}}}, {"text": "You could use a StringBuilder like so", "label": {"api": {"StringBuilder": [[16, 28]]}}}, {"text": "The documentation for String.substring", "label": {"api": {"String.substring": [[22, 37]]}}}, {"text": "I have to admit that I don't completely understand how the lambda is allowed to be assigned to the Iterable type in the following code..", "label": {"api": {"Iterable": [[99, 106]]}}}, {"text": "My understanding is that the lambda () -> iterator is acting as a Supplier function", "label": {"api": {"Supplier": [[66, 73]]}}}, {"text": "Iterable isn't a FunctionalInterface so how can it be assigned this lambda", "label": {"api": {"Iterable": [[0, 7]], "FunctionalInterface": [[17, 35]]}}}, {"text": "Iterable does satisfy the criteria for a functional interface, because it has only one abstract method", "label": {"api": {"Iterable": [[0, 7]]}}}, {"text": "Anyway to automate such variations by Locale rather than explicitly define formatting patterns", "label": {"api": {"Locale": [[38, 43]]}}}, {"text": "You’re looking for the sin method present in the Math library", "label": {"api": {"the Math library": [[45, 60]]}}}, {"text": "Assuming that you use Java 8, you could use a Function to convert a String to a given type, you would then rewrite your method as next", "label": {"api": {"Function": [[46, 53]]}}}, {"text": "For previous version of Java, the logic is the same, simply use FluentIterable from Google Guava to replace the Stream and use com.google.common.base.Function instead of java.util.function.Function as mapper function", "label": {"api": {"Function": [[150, 157], [189, 196]]}}}, {"text": "Simply use String.indexOf() to first fetch the position of that \"=\" within your string", "label": {"api": {"String.indexOf()": [[11, 26]]}}}, {"text": "or you go one step further and use regular expressions to get more complicated jobs done", "label": {"api": {"regular expressions": [[35, 53]]}}}, {"text": "double has a minimum value", "label": {"api": {"minimum value": [[13, 25]]}}}, {"text": "You could use the BigDecimal class", "label": {"api": {"BigDecimal": [[18, 27]]}}}, {"text": "Copy the Set and remove all of the elements in the List using the removeAll method", "label": {"api": {"removeAll method": [[66, 81]]}}}, {"text": "Is there no way (regardless of how \"hacky\" it is) to detect when Java's System.err has been written to in order to be able to execute logic if and when this happens", "label": {"api": {"System.err": [[72, 81]]}}}, {"text": "— I'm currently working with a custom subclass of Thread (let's call it SwallowingThread) which swallows a number of exceptions in its implementation of Thread.run() in a manner similar to the following code", "label": {"api": {"Thread.run()": [[153, 164]]}}}, {"text": "— I had originally tried writing a UncaughtExceptionHandler to do this only to find out that it isn't catching the exceptions because they were swallowed rather than simply being e.g", "label": {"api": {"UncaughtExceptionHandler": [[35, 58]]}}}, {"text": "You can achieve this by using Stream#flatMap instead of Stream#map", "label": {"api": {"Stream#flatMap": [[30, 43]]}}}, {"text": "The implementation of your Comparator is not correct, as you want to have highest value first (and not the opposite lowest value first), you are supposed to return a positive value if character.getVoteCount() < p1.getVoteCount() and a negative value if character.getVoteCount() > p1.getVoteCount(), you should use Integer.compare(int x, int y) to compare the values of getVoteCount() (assuming that it returns an int) such that your Comparator could be", "label": {"api": {"Integer.compare(int x, int y)": [[314, 342]]}}}, {"text": "You should use the method Map::computeIfAbsent to create or get the List", "label": {"api": {"Map::computeIfAbsent": [[26, 45]]}}}, {"text": "Here's the Javadoc for StandardOpenOptions", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "The for loop with indexes is fine, but just so you know, you can also use a ListIterator which allows replacing of the current item via set", "label": {"api": {"ListIterator": [[76, 87]]}}}, {"text": "This works for ArrayList and LinkedList etc without a ConcurrentModificationException because that is only thrown following structural modification of the list", "label": {"api": {"structural modification of the list": [[124, 158]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/overview-summary.html for example", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/overview-summary.html": [[4, 66]]}}}, {"text": "String.intern() documentation says", "label": {"api": {"String.intern() documentation": [[0, 28]]}}}, {"text": "In my opinion, ExecutorService is a good idea and you should submit a Callable to ExecutoService so that you get back a Future", "label": {"api": {"Callable": [[70, 77]], "Future": [[120, 125]]}}}, {"text": "To handle situation # 1 , you should logically AND return value of isDone() method call for all Futures and to handle situation # 2, you should do logical OR and something like that", "label": {"api": {"isDone()": [[67, 74]], "Future": [[96, 101]]}}}, {"text": "Here are references - Callable & Future", "label": {"api": {"Callable": [[22, 29]], "Future": [[33, 38]]}}}, {"text": "If you want to delay the generation of your interfaces until the absolutely last second, have a look at RoundEnvironment.processingOver()", "label": {"api": {"RoundEnvironment.processingOver()": [[104, 136]]}}}, {"text": "As an alternative you may want to check out the java.util.concurrent.atomic package", "label": {"api": {"java.util.concurrent.atomic": [[48, 74]]}}}, {"text": "I am not entirely sure if this is your issue but I noticed that there is a seek method on RandomAccessFile that allows you to move the file pointer to the end of the file for writes", "label": {"api": {"seek": [[75, 78]]}}}, {"text": "Instead, convert the byte array to String using DatatypeConverter#printHexBinary(byte[]) and pass that to Toast method", "label": {"api": {"DatatypeConverter#printHexBinary(byte[])": [[48, 87]]}}}, {"text": "If you want to read the JAR, I think you should use FileInputStream (for reading) instead of FileOutputStream (for writing)", "label": {"api": {"FileInputStream": [[52, 66]]}}}, {"text": "But consider the groupingBy collector accepting a downstream Collector which allows you to reduce the groups to their final result in-place", "label": {"api": {"groupingBy collector accepting a downstream Collector": [[17, 69]]}}}, {"text": "reducing as downstream collector", "label": {"api": {"reducing": [[0, 7]]}}}, {"text": "Note that there are other combining Collectors like mapping and collectingAndThen", "label": {"api": {"mapping": [[52, 58]], "collectingAndThen": [[64, 80]]}}}, {"text": "For convenience, this collector combines a mapping step with a follow-up reduction step", "label": {"api": {"mapping": [[43, 49]], "this collector": [[17, 30]]}}}, {"text": "Use LocalDate, the class built into Java 8 and later to represent a date-only without a time-of-day and without a time zone", "label": {"api": {"LocalDate": [[4, 12]]}}}, {"text": "If need be, you can indeed extract each piece of a LocalDate", "label": {"api": {"LocalDate": [[51, 59]]}}}, {"text": "I have created HttpServletRequestWrapper which removes brackets [] from the request parameters", "label": {"api": {"HttpServletRequestWrapper": [[15, 39]]}}}, {"text": "The JavaDocs for findFirst say that if the stream has an encounter order, then the first element will always be returned, but if the stream does not have an encounter order, any element may be returned", "label": {"api": {"JavaDocs for findFirst": [[4, 25]]}}}, {"text": "Reading the Java Doc for Phaser shows an overridle method called onAdvance which can be used to Print the phase X finished when the phase is actually finished", "label": {"api": {"Phaser": [[25, 30]]}}}, {"text": "Your data seems to be json, so you might want to take a look at JsonObject and it's use", "label": {"api": {"JsonObject": [[64, 73]]}}}, {"text": "Inside the Preloader, override handleApplicationNotification(PreloaderNotification info)", "label": {"api": {"handleApplicationNotification(PreloaderNotification info)": [[31, 87]]}}}, {"text": "If you use Java 8 you could also just call forEach or map on your Stream and you are done, e.g", "label": {"api": {"forEach": [[43, 49]], "map": [[54, 56]], "Stream": [[66, 71]]}}}, {"text": "where doStuff() is the consumer dealing with the String or use yourStream.forEach(s -> doStuff()) if you don't want to handle the string and just do stuff", "label": {"api": {"forEach": [[74, 80]], "Stream": [[67, 72]], "consumer": [[23, 30]]}}}, {"text": "It may lose regarding performance and it may also lose if you don't want to call Stream.of/Arrays.stream or Collection.stream() just to obtain the stream", "label": {"api": {"Stream": [[81, 86]]}}}, {"text": "According to the Javadocs of Collectors.map()", "label": {"api": {"Collectors.map()": [[29, 44]]}}}, {"text": "PropertyResourceBundle which already serves this purpose and provides a Java interface to textually defined resources", "label": {"api": {"PropertyResourceBundle": [[0, 21]]}}}, {"text": "You could use Rectangle#intersects in order to have the calculation done for you", "label": {"api": {"Rectangle#intersects": [[14, 33]]}}}, {"text": "Read the documentation for String.intern()", "label": {"api": {"String.intern()": [[27, 41]]}}}, {"text": "If you have an input like 14:00 you don't need to do manual formatting, instead you can use java.time.format.DateTimeFormatter", "label": {"api": {"java.time.format.DateTimeFormatter": [[92, 125]]}}}, {"text": "I assume that your Message class implements Serializable", "label": {"api": {"Serializable": [[44, 55]]}}}, {"text": "In this case, when you write your message, it gets automatically serialized from the java runtime, as explained in the Serializable interface", "label": {"api": {"Serializable": [[119, 130]]}}}, {"text": "However, I might suggest that you follow the Externalizable interface way", "label": {"api": {"Externalizable": [[45, 58]]}}}, {"text": "your Message class will implement Externalizable", "label": {"api": {"Externalizable": [[34, 47]]}}}, {"text": "In Java, you can use String.format() to get the same behavior", "label": {"api": {"String.format()": [[21, 35]]}}}, {"text": "See the format string documentation for details about format string syntax", "label": {"api": {"the format string documentation": [[4, 34]]}}}, {"text": "You can achieve the same in Java with String.format()", "label": {"api": {"String.format()": [[38, 52]]}}}, {"text": "To encode this string with the correct Base64 scheme that can be used in URLs, you can use Base64.getUrlEncoder() since Java 8", "label": {"api": {"Base64.getUrlEncoder()": [[91, 112]]}}}, {"text": "Since this cannot be done by applying CSS rules to the node, you have to supply your own cell factory implementation to the combobox", "label": {"api": {"cell factory": [[89, 100]]}}}, {"text": "Pay attention, it's an Iterable, not a Collection", "label": {"api": {"Iterable": [[23, 30]], "Collection": [[39, 48]]}}}, {"text": "The column names in your unique constraint should not be comma separated but rather separate String values in an array (see http://docs.oracle.com/javaee/6/api/javax/persistence/UniqueConstraint.html)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/UniqueConstraint.html": [[124, 198]]}}}, {"text": "The Document API of adoptNode, and importNode Document API  requires appending the target nodes into doc2 which modifies dom structure of doc2", "label": {"api": {"Document API ": [[4, 16], [46, 58]]}}}, {"text": "I believe the answer lies in the WritableByteChannel.write documentation", "label": {"api": {"WritableByteChannel.write": [[33, 57]]}}}, {"text": "For this you could simply create an URLClassLoader to which you would provide the location of your library as URL (using URLClassLoader.newInstance(URL[] urls, ClassLoader parent)), then by reflection you would retrieve the class of your library corresponding to the entry point and invoke your target method", "label": {"api": {"URLClassLoader": [[36, 49], [121, 134]], "URLClassLoader.newInstance(URL[] urls, ClassLoader parent)": [[121, 178]]}}}, {"text": "To avoid building a new URLClassLoader at each call, you could consider relying on a ThreadLocal to store the URLClassLoader or the Class or the Method instance to be used for a given thread", "label": {"api": {"URLClassLoader": [[24, 37], [110, 123]], "ThreadLocal": [[85, 95]]}}}, {"text": "I could store the corresponding Method in a ThreadLocal to retrieve it by reflection only once per thread using ThreadLocal.withInitial(Supplier<", "label": {"api": {"ThreadLocal": [[44, 54], [112, 122]]}}}, {"text": "Once you are done with your library, you should cleanup the ThreadLocal for each thread of your thread pool to prevent memory leaks and to do so here is how you could proceed", "label": {"api": {"ThreadLocal": [[60, 70]]}}}, {"text": "A variant using Files and the Stream API and a regex pattern matcher", "label": {"api": {"Files": [[16, 20]], "Stream": [[30, 35]], "regex pattern matcher": [[47, 67]]}}}, {"text": "Just exchange the Files.lines...-line with", "label": {"api": {"Files": [[18, 22]]}}}, {"text": "Basically you have to look into the  ProcessBuilder", "label": {"api": {"ProcessBuilder": [[37, 50]]}}}, {"text": "By looking at the serialization documentation (https://docs.oracle.com/javase/8/docs/api/serialized-form.html#java.io.File) you can notice that the serialization util only saves the path of the file (with the original separator which is converted while deserializing if needed), rather than its content", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/serialized-form.html#java.io.File": [[47, 121]]}}}, {"text": "You need to implement \"full press-drag-release gestures\", as described in the MouseEvent documentation", "label": {"api": {"MouseEvent documentation": [[78, 101]]}}}, {"text": "To register out parameters, you can use CallableStatement.registerOutParameter", "label": {"api": {"CallableStatement.registerOutParameter": [[40, 77]]}}}, {"text": "Try a Map", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "More specifically, a Map<String, Integer>", "label": {"api": {"Map": [[21, 23]]}}}, {"text": "In most cases when using a Map the implementation class you want is probably HashMap", "label": {"api": {"Map": [[27, 29], [81, 83]], "HashMap": [[77, 83]]}}}, {"text": "Collectors.toMap() expects a Function for both parameters", "label": {"api": {"Collectors.toMap()": [[0, 17]]}}}, {"text": "It uses a Service that can be started more than once", "label": {"api": {"Service": [[10, 16]]}}}, {"text": "Usually solution could be implemented with Queue", "label": {"api": {"Queue": [[43, 47]]}}}, {"text": "Any Entity that is interested to receive the result should be listening to the Queue (i.e", "label": {"api": {"Queue": [[79, 83]]}}}, {"text": "Queue implementation could be a comercialy available products such as Rabbit MQ for example or as simple as Java provided classes that can work as in memory queues", "label": {"api": {"Queue": [[0, 4]]}}}, {"text": "(See Queue interface and its various implementations)", "label": {"api": {"Queue": [[5, 9]]}}}, {"text": "You could use a two dimensional vector, and then perhaps the clone() method", "label": {"api": {"vector": [[32, 37]]}}}, {"text": "The awesome thing about vector is that it can grow and shrink as you need it to", "label": {"api": {"vector": [[24, 29]]}}}, {"text": "Try the following pattern matcher", "label": {"api": {"pattern matcher": [[18, 32]]}}}, {"text": "When using readEntity, you provide generic type information by using GenericType", "label": {"api": {"GenericType": [[69, 79]]}}}, {"text": "In Java's PropertyChangeSupport observable maintains a list of observers", "label": {"api": {"PropertyChangeSupport": [[10, 30]]}}}, {"text": "I'll throw my solution into the mix, taking into account Peter Lawrey's advice about using AtomicInteger", "label": {"api": {"AtomicInteger": [[91, 103]]}}}, {"text": "We use a mutable object to communicate between threads (AtomicInteger)", "label": {"api": {"AtomicInteger": [[56, 68]]}}}, {"text": "You could a TreeMap with as key the current total of the previous probabilities and as value the corresponding object, then generate a random number between 0 and 1, and finally use ceilingEntry(K key) to get the object corresponding to the first key that is greater or equal to the current random value", "label": {"api": {"TreeMap": [[12, 18]], "ceilingEntry(K key)": [[182, 200]]}}}, {"text": "You can use Stream#reduce(BinaryOperator)", "label": {"api": {"Stream#reduce(BinaryOperator)": [[12, 40]]}}}, {"text": "I would expect that the best effort done by the JVM to reclaim space includes removing objects that are only weakly reachable (weak set elements without any strong references)", "label": {"api": {"best effort": [[24, 34]]}}}, {"text": "As far as I understand Guava's MoreExecutors.directExecutor() creates an Executor which will executes the runnable before the execute method call could return", "label": {"api": {"Executor": [[35, 42], [51, 58], [73, 80]]}}}, {"text": "You can use String#replaceAll() with the pattern /.*?(\\s|$) to remove the POS tags", "label": {"api": {"String#replaceAll()": [[12, 30]]}}}, {"text": "File(String parent, String child ) , e.g", "label": {"api": {"File(String parent, String child )": [[0, 33]]}}}, {"text": "You've said \"...whereas date value is same...\" which suggests you're looking at other aspects of the Date object, like getHours and such, but note all those \"Deprecated\" notices on those methods", "label": {"api": {"getHours": [[119, 126]]}}}, {"text": "You see, the Properties class has a method getProperty(String, String) where the second argument can be used to pass a default value for example", "label": {"api": {"getProperty(String, String)": [[43, 69]]}}}, {"text": "Since you only want to modify the values, you can use Map#replaceAll", "label": {"api": {"Map#replaceAll": [[54, 67]]}}}, {"text": "Then let HighscoreEntry implement Comparable", "label": {"api": {"Comparable": [[34, 43]]}}}, {"text": "Actually you can, using FileSystem", "label": {"api": {"FileSystem": [[24, 33]]}}}, {"text": "Some common interfaces availale are Runnable, Callable and Supplier or Function", "label": {"api": {"Runnable": [[36, 43]], "Callable": [[46, 53]], "Supplier": [[59, 66]], "Function": [[71, 78]]}}}, {"text": "Runnable doesn't have a return value and Callable throws Exception forcing you to catch it, Function needs an argument", "label": {"api": {"Runnable": [[0, 7]], "Callable": [[41, 48]], "Function": [[92, 99]]}}}, {"text": "Supplier remains a good candidate", "label": {"api": {"Supplier": [[0, 7]]}}}, {"text": "Here's an example with Supplier and sub class based keys", "label": {"api": {"Supplier": [[23, 30]]}}}, {"text": "Use the Animation API", "label": {"api": {"Animation API": [[8, 20]]}}}, {"text": "simulate a \"select\"-event) by calling Selector.wakeup()", "label": {"api": {"Selector": [[38, 45]], "wakeup()": [[47, 54]]}}}, {"text": "When I accidentally put my thread into a busy-loop by always calling wakeup() before every call to select(), I noticed that my other NIO channels were no longer getting serviced at all", "label": {"api": {"wakeup()": [[69, 76]], "select()": [[99, 106]]}}}, {"text": "After a bit of messing around with this I figured out that the reason for my other channels no longer being serviced was that select() did not fill the list of selectedKeys() if it returned immediately due to a pending wakeup()", "label": {"api": {"wakeup()": [[219, 226]], "select()": [[126, 133]], "selectedKeys()": [[160, 173]]}}}, {"text": "If so, is there a way to prevent this more elegantly than by following every select() with an additional selectNow()", "label": {"api": {"select()": [[77, 84]], "selectNow()": [[105, 115]]}}}, {"text": "Refer to the section called Patterns for Formatting and Parsing in the javadoc for DateTimeFormatter for details about the format-string passed to DateTimeFormatter.ofPattern()", "label": {"api": {"javadoc for DateTimeFormatter": [[71, 99]]}}}, {"text": "Since Java 1.6, there's a new type of collection, called ArrayDeque that has the fast random access like an array, but also has the fast add/remove at the ends", "label": {"api": {"ArrayDeque": [[57, 66]]}}}, {"text": "You are looking for the Java Instrumentation API", "label": {"api": {"Java Instrumentation API": [[24, 47]]}}}, {"text": "It will be very easy for you to write an Invocable class Coherence Node based processing documentation apply the business logic to get the expected result", "label": {"api": {"Coherence Node based processing documentation": [[57, 101]]}}}, {"text": "You can use String#matches() to check if a name begins with any of the special characters on your blacklist", "label": {"api": {"String#matches()": [[12, 27]]}}}, {"text": "From the Javadoc for FileWriter(File file, boolean append)", "label": {"api": {"Javadoc for FileWriter(File file, boolean append)": [[9, 57]]}}}, {"text": "This isn't \"no rounding\", it's DOWN rounding", "label": {"api": {"DOWN rounding": [[31, 43]]}}}, {"text": "Simply set the roundingMode", "label": {"api": {"set the roundingMode": [[7, 26]]}}}, {"text": "If you want only one consumer to wake up, you should use notify From the  API documentation", "label": {"api": {"API documentation": [[74, 90]]}}}, {"text": "As such, I have created a utility function that will take an array of AnnotationDesc objects and return a Map that associates the fully-qualified name of the annotation to the AnnotationDesc object that describes it", "label": {"api": {"AnnotationDesc": [[70, 83], [176, 189]]}}}, {"text": "For what it's worth, I have also tried using qualifiedName, which is another method exposed by the return value of the AnnotationDesc.annotationType method", "label": {"api": {"AnnotationDesc": [[119, 132]]}}}, {"text": "Arrays.asList() creates a fixed-size List that is directly backed by the varargs array parameter", "label": {"api": {"Arrays.asList()": [[0, 14]]}}}, {"text": "Its implementation of toArray() is a simple System.arraycopy()", "label": {"api": {"toArray()": [[22, 30]], "System.arraycopy()": [[44, 61]]}}}, {"text": "On the other hand, when you do myList.stream().toArray(String[]::new), the size is not known, so the Stream.toArray() method has to consume the stream, collect all the values, then create the array and copy the values into the array", "label": {"api": {"toArray()": [[108, 116]], "Stream.toArray()": [[101, 116]]}}}, {"text": "You can use getClass() and instanceof for your check", "label": {"api": {"getClass()": [[12, 21]]}}}, {"text": "This may not be the style of answer you want, but a simple call to String#replaceAll() should work", "label": {"api": {"String#replaceAll()": [[67, 85]]}}}, {"text": "Easy to understand, nice to read, but comes at the cost of creating a new char array", "label": {"api": {"new char array": [[70, 83]]}}}, {"text": "the queries are not known ahead of time and are parsed and analysed at runtime (though things like PreparedStatement allow some pre-compilation to happen as well as being generally safer)", "label": {"api": {"PreparedStatement": [[99, 115]]}}}, {"text": "Another option is to call #connectToServer(Object, URI), which will force WebSocket client to use the provided instance (not to create a new one)", "label": {"api": {"#connectToServer(Object, URI)": [[26, 54]]}}}, {"text": "An example would be DataInputStream, which wraps an InputStream to allow you to read String objects and more, when InputStream is only capable of primitive data", "label": {"api": {"DataInputStream": [[20, 34]]}}}, {"text": "You need to ensure that nums isn't undefined first, otherwise attempting to reference a property from an undefined or null object will result in a NullPointerException", "label": {"api": {"NullPointerException": [[147, 166]]}}}, {"text": "Did you use ElementCollection", "label": {"api": {"ElementCollection": [[12, 28]]}}}, {"text": "The Javadoc of List may prove interesting", "label": {"api": {"List": [[15, 18]]}}}, {"text": "I switched the ^ operator (which, as @Nick Bell pointed out, is a bitwise exclusive OR) for Math.pow", "label": {"api": {"Math.pow": [[92, 99]]}}}, {"text": "all you have to do is use a SynchronousQueue in conjuction of a RejectedExecutionHandler, using the following constructor ..", "label": {"api": {"constructor": [[110, 120]]}}}, {"text": "AtomicInteger provides operations like getAndIncrement that can be used for this purpose without having to use a lock", "label": {"api": {"getAndIncrement": [[39, 53]]}}}, {"text": "You can use PropertyEditorSupport to handle the form input as follows", "label": {"api": {"PropertyEditorSupport": [[12, 32]]}}}, {"text": "Create class extending PropertyEditorSupport to convert String received from client to BigDecimal, for example", "label": {"api": {"PropertyEditorSupport": [[23, 43]], "BigDecimal": [[87, 96]]}}}, {"text": "Instead use .next() to skip the next token if it's not valid, and use .hasNextDouble() to determine if the next token is a valid double (rather than catching the InputMismatchException)", "label": {"api": {".next()": [[12, 18]], ".hasNextDouble()": [[70, 85]]}}}, {"text": "Upon debugging, I found that this behaviour is caused by SimplePrincipalCollection using a LinkedHashSet to store the principals", "label": {"api": {"LinkedHashSet": [[91, 103]]}}}, {"text": "By the way if I were you, I'd use List and ArrayList instead of Array, that would save your some unecessary hassle", "label": {"api": {"List": [[34, 37], [48, 51]], "ArrayList": [[43, 51]]}}}, {"text": "Different methods available in session are listed in http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpSession.html", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpSession.html": [[53, 123]]}}}, {"text": "Create your WebDriver instances using a ThreadLocal", "label": {"api": {"ThreadLocal": [[40, 50]]}}}, {"text": "Quoting the JavaDoc on ThreadLocal", "label": {"api": {"ThreadLocal": [[23, 33]]}}}, {"text": "ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID)", "label": {"api": {"ThreadLocal": [[0, 10]]}}}, {"text": "You may use a Matcher#appendReplacement method to build the result \"as you match\"", "label": {"api": {"Matcher#appendReplacement": [[14, 38]]}}}, {"text": "Or simply use Objects.requireNonNull as Holger states in the comment, if NullPointerException suffices your needs", "label": {"api": {"Objects.requireNonNull": [[14, 35]]}}}, {"text": "First, awaitTermination will block until all tasks terminate", "label": {"api": {"block": [[29, 33]]}}}, {"text": "Arrays#asList creates unmodifiable list, check the docs", "label": {"api": {"Arrays#asList": [[0, 12]]}}}, {"text": "Note that String#split takes a regex, and the regex you passed doesn't match the pattern you're looking for", "label": {"api": {"String#split": [[10, 21]]}}}, {"text": "You might want to read the documentation of Pattern and Matcher for more information about the solution above", "label": {"api": {"Pattern": [[44, 50]], "Matcher": [[56, 62]]}}}, {"text": "In case of annotations, it’s usually even simpler, as the typical Reflection implementations don’t generate a class having all these methods, but generate a proxy whose invocation handler will look up the requested value by looking up the method’s name in a Map containing the values discovered in the class file", "label": {"api": {"proxy": [[157, 161]]}}}, {"text": "You can use Optional.ofNullable to achieve this", "label": {"api": {"Optional.ofNullable": [[12, 30]]}}}, {"text": "You can tell if an input string matched partially by inspecting the result of the Matcher.hitEnd function, which tells if the match failed because the end of the input string was reached", "label": {"api": {"Matcher.hitEnd": [[82, 95]]}}}, {"text": "If AIMP3.exe is willing to read from stdin (\"standard in\") rather than from a named file, you can do this by writing to the output stream you can get from Process's getOutputStream", "label": {"api": {"getOutputStream": [[165, 179]]}}}, {"text": "You may take a look at Formatter as you may not always be interested to print the results", "label": {"api": {"Formatter": [[23, 31]]}}}, {"text": "In essence, I'm trying to read a CamelCase ResourceBundle through an UpperCase name from an external .jar", "label": {"api": {"ResourceBundle": [[43, 56]]}}}, {"text": "the ResourceBundle is called MessageBundle and I read it with MESSAGEBUNDLE", "label": {"api": {"ResourceBundle": [[4, 17]]}}}, {"text": "The project ResourceBundleDependency consist only of a property file", "label": {"api": {"ResourceBundle": [[12, 25]]}}}, {"text": "The project ResourceBundleReader consists of a property file, a main method and it has a dependency to the project ResourceBundleDependency", "label": {"api": {"ResourceBundle": [[12, 25], [115, 128]]}}}, {"text": "In the main method of BundleReader, I try and read both ResourceBundles in 2 ways", "label": {"api": {"ResourceBundle": [[56, 69]]}}}, {"text": "When I close the ResourceBundleDependency project in NetBeans and run the same method again (I've built the dependency), it locates the file when called in a CamelCase manner but can't find it using the UpperCase manner", "label": {"api": {"ResourceBundle": [[17, 30]]}}}, {"text": "Calling java -jar ResourceBundleReader-1.0-SNAPSHOT.jar, I get the following output", "label": {"api": {"ResourceBundle": [[18, 31]]}}}, {"text": "Works fine from NetBeans, can't even read its own ResourceBundle in UpperCase", "label": {"api": {"ResourceBundle": [[50, 63]]}}}, {"text": "The ResourceBundle and PropertyResourceBundle JavaDoc don't really mention anything from resolving by UpperCase", "label": {"api": {"ResourceBundle": [[4, 17], [31, 44]], "PropertyResourceBundle": [[23, 44]]}}}, {"text": "Try using a Scanner for your class instead", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "You can use the NIO WatchService", "label": {"api": {"NIO WatchService": [[16, 31]]}}}, {"text": "To load UI dynamicly you should use FXMLLoader", "label": {"api": {"FXMLLoader": [[36, 45]]}}}, {"text": "Your PasswordFieldCell class inherits a lot of useful methods from TableCell", "label": {"api": {"TableCell": [[67, 75]]}}}, {"text": "Instead, you should use Class.forName(className)", "label": {"api": {"Class.forName(className)": [[24, 47]]}}}, {"text": "One way I see is to use a ConcurrentLinkedDeque and iterating until you reach the most recently added item", "label": {"api": {"ConcurrentLinkedDeque": [[26, 46]]}}}, {"text": "The way that ConcurrentLinkedDeque works is that calls to offer(Object) and add(Object) will place the item at the tail of the queue", "label": {"api": {"ConcurrentLinkedDeque": [[13, 33]]}}}, {"text": "Use a SubScene, which, like a Scene has a camera, depth buffering, etc", "label": {"api": {"SubScene": [[6, 13]]}}}, {"text": "I think you can add a ComponentListener to listen for the change of size of a frame", "label": {"api": {"ComponentListener": [[22, 38]]}}}, {"text": "I would like to format a BigDecimal value according to the following rules", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "I have searched the forums but not found a matching question (here, here and here) and I have looked at the javadoc for BigDecimal and NumberFormat without understanding how to do this", "label": {"api": {"BigDecimal": [[120, 129]], "NumberFormat": [[135, 146]]}}}, {"text": "Channels are not wrappers around streams (unless you explicitly wrap a stream via Channels.newChannel(InputStream) or Channels.newChannel(OutputStream)) and they are not a “totally new concept”", "label": {"api": {"Channels.newChannel(InputStream)": [[82, 113]], "Channels.newChannel(OutputStream)": [[118, 150]]}}}, {"text": "Thread.interrupt does not kill the thread, just resumes it if its paused, and in general it is not a good idea to kill threads manually", "label": {"api": {"Thread.interrupt": [[0, 15]]}}}, {"text": "Its documentation refers to Map.merge to explain the semantics of the merge function, but unfortunately, that documentation is a bit thin too", "label": {"api": {"Its documentation": [[0, 16]]}}}, {"text": "toMap’s documentation further states", "label": {"api": {"toMap’s documentation": [[0, 20]]}}}, {"text": "Generally, all builtin collectors provided by Collectors are only unordered, if explicitly stated, which is only the case for the “…Concurrent…” collectors and the toSet() collector", "label": {"api": {"Collectors": [[46, 55]]}}}, {"text": "A CXF StaxSource is a JAXP Source so the standard way of converting it to a String would be to use the transformation API (TrAX)", "label": {"api": {"JAXP Source": [[22, 32]]}}}, {"text": "Using HashSets requires you to have implemented equals() and hashCode() methods in your Book class, though", "label": {"api": {"hashCode()": [[61, 70]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html  for more details about the Instant class", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html": [[0, 63]]}}}, {"text": "Each session is represented by a HttpSession object", "label": {"api": {"HttpSession": [[33, 43]]}}}, {"text": "Call setMaxInactiveInterval on that session object", "label": {"api": {"setMaxInactiveInterval": [[5, 26]]}}}, {"text": "Also, you can programmatically close a session by calling invalidate on that session object, as discussed here", "label": {"api": {"invalidate": [[58, 67]]}}}, {"text": "You can ask for that session’s start time as a count of milliseconds since the epoch of 1970 UTC by calling getCreationTime", "label": {"api": {"getCreationTime": [[108, 122]]}}}, {"text": "Make an Instant from that to see that moment in UTC", "label": {"api": {"Instant": [[8, 14]]}}}, {"text": "Use Duration object to see elapsed time", "label": {"api": {"Duration": [[4, 11]]}}}, {"text": "For current moment, call Instant.now", "label": {"api": {"Instant": [[25, 31]]}}}, {"text": "The java.lang.ExceptionInInitializerError is used as a wrapper to indicate that an exception arises in the static initializer block or the evaluation of a static variable’s value", "label": {"api": {"java.lang.ExceptionInInitializerError": [[4, 40]]}}}, {"text": "The old API did not include a constructor of the Tabclass with two parameters; the new one that you want to use does", "label": {"api": {"old API": [[4, 10]], "new one": [[83, 89]]}}}, {"text": "The return value is -1 because there is no String \"kansas\" in allStates, and ArrayList#indexOf returns -1 if the element is not present in the list", "label": {"api": {"returns -1 if the element is not present in the list": [[95, 146]]}}}, {"text": "Use putIfAbsent() to insert conditionally", "label": {"api": {"putIfAbsent()": [[4, 16]]}}}, {"text": "Look at the javadoc of both, then find a way to create a java.time.LocalDateTime from the getter methods of org.joda.time.LocalDateTime", "label": {"api": {"java.time.LocalDateTime": [[57, 79]]}}}, {"text": "So, to create a java.time.LocalDateTime, use LocalDateTime.of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)", "label": {"api": {"java.time.LocalDateTime": [[16, 38]], "LocalDateTime.of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)": [[45, 149]]}}}, {"text": "I focus in my answer on that part of your question that is not related to the \"why not catch Errors\"; but your implicit idea that you \"can't catch Errors\"", "label": {"api": {"Error": [[93, 97], [147, 151]]}}}, {"text": "Error is a subclass of Throwable", "label": {"api": {"Error": [[0, 4]]}}}, {"text": "But you are correct about the fact that only instances of that other child-class called Exception of Throwable should be caught using try/catch", "label": {"api": {"Exception": [[88, 96]]}}}, {"text": "You may want to use EntityManager.getReference()", "label": {"api": {"EntityManager.getReference()": [[20, 47]]}}}, {"text": "If you take a look at the Java Class class, you'll find it has methods for accessing its constructors, fields, methods and more", "label": {"api": {"Java Class class": [[26, 41]]}}}, {"text": "The Introspector class in package java.beans allows you to obtain bean info for a class", "label": {"api": {"Introspector class in package java.beans": [[4, 43]]}}}, {"text": "If you want to use an array, you'll have to populate it with Method instances", "label": {"api": {"Method instances": [[61, 76]]}}}, {"text": "At oracles documentation we see that Integer is an object that holds an int", "label": {"api": {"oracles documentation": [[3, 23]]}}}, {"text": "For more information this question has a good breakdown", "label": {"api": {"this question": [[21, 33]]}}}, {"text": "I would suggest to use the standard parts of java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[45, 64]]}}}, {"text": "If you need more control over the process, it is also possible to use the CyclicBarrier", "label": {"api": {"CyclicBarrier": [[74, 86]]}}}, {"text": "The issue is that you are using JFileChooser.getCurrentDirectory() instead of JFileChooser.getSelectedFile()", "label": {"api": {"JFileChooser.getCurrentDirectory()": [[32, 65]], "JFileChooser.getSelectedFile()": [[78, 107]]}}}, {"text": "The first request exchange is the negotiation step, the second request exchange is the lookup() step, then the other request exchanges are the remote procedure calls (when we use methods from our class which extends Remote)", "label": {"api": {"Remote": [[216, 221]]}}}, {"text": "The ProcessBuilder start() method returns a Process object", "label": {"api": {"start()": [[19, 25]]}}}, {"text": "That has a destroy() method", "label": {"api": {"destroy()": [[11, 19]]}}}, {"text": "If you want to modify existing collection, it's better to use Collection.removeIf", "label": {"api": {"Collection.removeIf": [[62, 80]]}}}, {"text": "I think you need to use FOLLOW_LINKS option", "label": {"api": {"FOLLOW_LINKS": [[24, 35]]}}}, {"text": "I have a SimpleIntegerProperty which should be able to store null", "label": {"api": {"IntegerProperty": [[15, 29]]}}}, {"text": "However, this is not possible, as written in the JavaDoc of IntegerProperty", "label": {"api": {"IntegerProperty": [[60, 74]]}}}, {"text": "Load the data in a Task, running in a background thread", "label": {"api": {"Task": [[19, 22]]}}}, {"text": "Display the loading animation (or ProgressIndicator, etc) when you start the task, and remove it when the task finishes", "label": {"api": {"ProgressIndicator": [[34, 50]]}}}, {"text": "I would like to verify one thing about InetAddress.getByName(String)", "label": {"api": {"InetAddress.getByName(String)": [[39, 67]]}}}, {"text": "You store your random numbers in a (Hash-)Set, One feature of Set as described in the API is that they do not contain duplicate values (by comparing them with their equals() method)", "label": {"api": {"API": [[86, 88]]}}}, {"text": "It seems you missed the existence of the Channels helper class", "label": {"api": {"Channels": [[41, 48]]}}}, {"text": "Check the date and time patterns table; Month is capital M and minute is lower m", "label": {"api": {"date and time patterns": [[10, 31]]}}}, {"text": "It utilizes Character.toUpperCase() which allows the user to enter the equivalent lowercase letters as well", "label": {"api": {"Character.toUpperCase()": [[12, 34]]}}}, {"text": "You first need to parse the strings into a date - in your case, the LocalDateTime class seems appropriate", "label": {"api": {"LocalDateTime class": [[68, 86]]}}}, {"text": "If you are using Java8 you could use LocalTime like so", "label": {"api": {"LocalTime": [[37, 45]]}}}, {"text": "If I understand the question correctly, you need a toMap collector with custom merger like this", "label": {"api": {"toMap": [[51, 55]]}}}, {"text": "Adding a collection of objects in a specific order, that's what the PriorityQueue (Java Platform SE 7) is made for", "label": {"api": {"PriorityQueue (Java Platform SE 7)": [[68, 101]]}}}, {"text": "This may be in cases where constructors may not easily accept extra parameters like in Eclipse SWT, or where instances are automatically constructed like in Java serialization, Google GSON, Apache Crunch, or in any other case where instances are created outside of your control", "label": {"api": {"Java serialization": [[157, 174]]}}}, {"text": "You may use SortedMap<K,V> and TreeMap<K,V> like that", "label": {"api": {"SortedMap<K,V>": [[12, 25]], "TreeMap<K,V>": [[31, 42]]}}}, {"text": "I'm using the lightweight server provided in oracle java since java 1.6 and I'm using just to receive POST responses from another server", "label": {"api": {"oracle java": [[45, 55]]}}}, {"text": "ThreadLocal<Checksum> is your answer", "label": {"api": {"ThreadLocal<Checksum>": [[0, 20]]}}}, {"text": "Be sure to read up on direct bytebuffers before doing this; if you aren't actually reusing the buffer, this could be slow", "label": {"api": {"direct bytebuffers": [[22, 39]]}}}, {"text": "Another way to provide the stack size is by specifying it in the constructor when creating Threads by hand", "label": {"api": {"in the constructor": [[58, 75]]}}}, {"text": "The zero-argument toArray() method returns Object[], which you're incorrectly casting to Toys[][]", "label": {"api": {"toArray()": [[18, 26]]}}}, {"text": "Try this overload instead", "label": {"api": {"this overload": [[4, 16]]}}}, {"text": "Examples are Apache HTTP client that you mentioned, OkHttp or the plain-old HttpUrlConnection shipping with the JDK", "label": {"api": {"HttpUrlConnection": [[76, 92]]}}}, {"text": "You can usually mix and match the different REST client libraries and HTTP clients except for Retrofit because Retrofit has a hard dependency on OkHttp since version 2 (with Retrofit 1.x you can use Apache HTTP Client, HttpUrlConnection or OkHttp)", "label": {"api": {"HttpUrlConnection": [[219, 235]]}}}, {"text": "Create a Java Agent that registers a ClassFileTransformer to modify FormatData_en_NZ class data during class loading", "label": {"api": {"Java Agent": [[9, 18]], "ClassFileTransformer": [[37, 56]]}}}, {"text": "See also the documentation for SimpleDateFormat", "label": {"api": {"documentation for SimpleDateFormat": [[13, 46]]}}}, {"text": "As @Kent suggested, you should use a Set for this", "label": {"api": {"Set": [[37, 39]]}}}, {"text": "Basically removes duplicates by converting the ArrayList into a HashSet", "label": {"api": {"Set": [[68, 70]]}}}, {"text": "The Arrays.sort method expects a java.util.Comparator implementation", "label": {"api": {"Arrays.sort": [[4, 14]]}}}, {"text": "If you want to use Arrays.sort, use an implementation of java.util.Comparator", "label": {"api": {"Arrays.sort": [[19, 29]]}}}, {"text": "Or use the predefined formatter, DateTimeFormatter.ISO_LOCAL_DATE_TIME", "label": {"api": {"DateTimeFormatter.ISO_LOCAL_DATE_TIME": [[33, 69]]}}}, {"text": "Note that if you don't provide a formatter, calling ldt.toString gives output in standard ISO 8601 format (including milliseconds) - that may be acceptable for you", "label": {"api": {"ldt.toString": [[52, 63]]}}}, {"text": "Request URI is a part of URL you're looking for", "label": {"api": {"Request URI": [[0, 10]]}}}, {"text": "If you are using Jackson as JSON provider, you need the jackson-datatype-jsr310 dependency to support OffsetDateTime", "label": {"api": {"OffsetDateTime": [[102, 115]]}}}, {"text": "ExecutorService would be an example of the third statement", "label": {"api": {"ExecutorService": [[0, 14]]}}}, {"text": "So, ExecutorService should swallow the interruption, having dealt with it appropriately from the perspective of the interrupted runnable, in order to allow reuse of the thread for the next runnable", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "You just need to replace your first map() with flatMap()", "label": {"api": {"flatMap()": [[47, 55]]}}}, {"text": "You can use the Timer included in the JRE", "label": {"api": {"Timer": [[16, 20]]}}}, {"text": "From JavaDoc ResultSet", "label": {"api": {"ResultSet": [[13, 21]]}}}, {"text": "A ResultSet cursor is initially positioned before the first row; the first call to the method next makes the first row the current row; the second call makes the second row the current row, and so on", "label": {"api": {"ResultSet": [[2, 10]]}}}, {"text": "Therefore I use the Java Crypto API", "label": {"api": {"Java Crypto API": [[20, 34]]}}}, {"text": "String.replace should do exactly what you described", "label": {"api": {"String.replace": [[0, 13]]}}}, {"text": "This result is suitable for passing to InetAddress.getByAddress(), etc", "label": {"api": {"InetAddress.getByAddress()": [[39, 64]]}}}, {"text": "To intercept requests and responses on client side, use ClientRequestFilter and ClientResponseFilter", "label": {"api": {"ClientRequestFilter": [[56, 74]], "ClientResponseFilter": [[80, 99]]}}}, {"text": "To intercept requests and responses on server side, use ContainerRequestFilter and ContainerResponseFilter", "label": {"api": {"ContainerRequestFilter": [[56, 77]], "ContainerResponseFilter": [[83, 105]]}}}, {"text": "Alternatively, you might consider using StringBuilder in order to avoid the overhead of creating an entirely new string (and matcher) every iteration", "label": {"api": {"StringBuilder": [[40, 52]]}}}, {"text": "appended text) of the StringBuilder object", "label": {"api": {"StringBuilder": [[22, 34]]}}}, {"text": "If you must do so, one option is to use a java.util.concurrent.atomic.AtomicBoolean, which is mutable type", "label": {"api": {"java.util.concurrent.atomic.AtomicBoolean": [[42, 82]]}}}, {"text": "You could use something like BigInteger, which should be larger then you need", "label": {"api": {"BigInteger": [[29, 38]]}}}, {"text": "You should be able to accomplish what you want by annotating your timer tasks with @javax.annotation.security.RunAs(\"readRole\")", "label": {"api": {"@javax.annotation.security.RunAs(\"readRole\")": [[83, 126]]}}}, {"text": "If you are using Java 8, instead of put you can call a merge method", "label": {"api": {"merge": [[55, 59]]}}}, {"text": "If map already had a value corresponding to given key, the merge function passed as third argument will be called which just adds the content of the new map to the previously existing one", "label": {"api": {"merge": [[59, 63]]}}}, {"text": "Or there is a proxy in your network that must be explicitly configured for Java to be able to connect to external resources", "label": {"api": {"must be explicitly configured for Java": [[41, 78]]}}}, {"text": "If I understand the question correctly, the simple solution would be to use Math.multiplyExact (which appeared in Java 8)", "label": {"api": {"Math.multiplyExact": [[76, 93]]}}}, {"text": "The default implementation of the Command Pattern in Java is the Runnable interface, more recently augmented with the Callable interface", "label": {"api": {"Runnable": [[65, 72]], "Callable": [[118, 125]]}}}, {"text": "For the other part of your question; check out the Javadoc for consume() (which is inherited from InputEvent)", "label": {"api": {"consume()": [[63, 71]]}}}, {"text": "Calling consume() in your context ..", "label": {"api": {"consume()": [[8, 16]]}}}, {"text": "Based on your updated requirements, that the length of the account number can vary, I would suggest the use of Matcher.appendReplacement, like so", "label": {"api": {"Matcher.appendReplacement": [[111, 135]]}}}, {"text": "See if it helps", "label": {"api": {"See if it helps": [[0, 14]]}}}, {"text": "I think DateFormat#setTimeZone(TimeZone) is what you are looking for", "label": {"api": {"DateFormat#setTimeZone(TimeZone)": [[8, 39]]}}}, {"text": "The code could be made portable by checking what is the System.lineSeparator() if needed", "label": {"api": {"System.lineSeparator()": [[56, 77]]}}}, {"text": "Try using DatatypeConverter.printHexBinary(byte[] val) to convert byte[] encrypted back into hex", "label": {"api": {"DatatypeConverter.printHexBinary(byte[] val)": [[10, 53]]}}}, {"text": "You can use String.split(String regex) to split your text and later choose parts you wanted", "label": {"api": {"String.split(String regex)": [[12, 37]]}}}, {"text": "The problem is that a ScrollBar is not focus traversable by default and key events are only fired for focused Nodes", "label": {"api": {"focus traversable": [[39, 55]]}}}, {"text": "You can set the ScrollBar focus traversable", "label": {"api": {"focus traversable": [[26, 42]]}}}, {"text": "Also, you may want to take a look at the example code in the documentation of Matcher.appendReplacement and use it as a starting point", "label": {"api": {"Matcher.appendReplacement": [[78, 102]]}}}, {"text": "So, basically you need to create separate layer for each new line and use strokeLine method", "label": {"api": {"strokeLine method": [[74, 90]]}}}, {"text": "The Scanner class is probably what you're after", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "For curl’s -X option, use setRequestMethod", "label": {"api": {"setRequestMethod": [[26, 41]]}}}, {"text": "For curl’s -T option, use setDoOutput(true), getOutputStream(), and Files.copy", "label": {"api": {"setDoOutput(true)": [[26, 42]], "getOutputStream()": [[45, 61]], "Files.copy": [[68, 77]]}}}, {"text": "For curl’s -u option, set the Authorization request header to \"Basic \" (including the space) followed by the base 64 encoded form of user + \":\" + password", "label": {"api": {"request header": [[44, 57]], "base 64 encoded": [[109, 123]]}}}, {"text": "The String.format method helps with that (also see the documentation for Formatter)", "label": {"api": {"String.format": [[4, 16]], "Formatter": [[73, 81]]}}}, {"text": "The java.time classes have planned for the possibility of an even wider spread of time zones as zones are frequently re-defined", "label": {"api": {"java.time": [[4, 12]]}}}, {"text": "To quote the java.time.ZoneOffset class documentation", "label": {"api": {"java.time": [[13, 21]], "java.time.ZoneOffset": [[13, 32]]}}}, {"text": "Armed with this knowledge, you should take some solace in knowing that Java's ZoneOffset supports an offset range of +18:00 to -18:00, and ZoneOffset.of accepts a String parameter", "label": {"api": {"an offset range of +18:00 to -18:00": [[98, 132]]}}}, {"text": "Additionally, I would recommend to use a ScheduledExecutorService instead of Thread.sleep-s", "label": {"api": {"ScheduledExecutorService": [[41, 64]]}}}, {"text": "You can use SimpleDateFormat to do it", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "So you just need to convert value in your data to Date and then format it using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[80, 95]]}}}, {"text": "Finally note that given the fact that the list is always sorted, you may consider using Collections.binarySearch() method with custom comparator", "label": {"api": {"Collections.binarySearch()": [[88, 113]]}}}, {"text": "In your JHeatChart, override the drawHeatMap() method and specify a different boundary color prior to invoking draw(), (untested)", "label": {"api": {"draw()": [[111, 116]]}}}, {"text": "I'm using a JAX-RS ExceptionMapper to catch application exceptions and return custom output", "label": {"api": {"ExceptionMapper": [[19, 33]]}}}, {"text": "Currently the code uses a terrible hack based on the UriInfo request path to determine what media type is chosen", "label": {"api": {"UriInfo": [[53, 59]]}}}, {"text": "Ideally the media type should be the same as the @Produces annotation on the method that threw the exception, but I haven't been able to find any way to get that annotation in the ExceptionMapper", "label": {"api": {"ExceptionMapper": [[180, 194]], "@Produces": [[49, 57]]}}}, {"text": "You can inject ResourceInfo in to the mapper", "label": {"api": {"ResourceInfo": [[15, 26]]}}}, {"text": "You just need to cast it to ParameterizedType", "label": {"api": {"ParameterizedType": [[28, 44]]}}}, {"text": "A better solution will be to use HttpURLConnection", "label": {"api": {"HttpURLConnection": [[33, 49]]}}}, {"text": "You don't want to have the milliseconds and the timezone part, so we just unset them using DatatypeConstants.FIELD_UNDEFINED as stated in the JavaDoc https://docs.oracle.com/javase/7/docs/api/javax/xml/datatype/XMLGregorianCalendar.html#setMillisecond(int)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/xml/datatype/XMLGregorianCalendar.html#setMillisecond(int)": [[150, 255]]}}}, {"text": "An example of such a class is JAXBContext from the Java API", "label": {"api": {"JAXBContext": [[30, 40]]}}}, {"text": "The abstract class (JAXBContext in this example) is the entry point for the API", "label": {"api": {"JAXBContext": [[20, 30]]}}}, {"text": "So, for JAXB, you'd find files with filename javax.xml.bind.JAXBContext in jar files", "label": {"api": {"JAXBContext": [[60, 70]]}}}, {"text": "The files would then contain one or more lines listing implementations of JAXBContext, which can be instantiated to provide an entry to that provider", "label": {"api": {"JAXBContext": [[74, 84]]}}}, {"text": "Construct a DefaultCellEditor with a JComboBox<String>, as illustrated here, and use it as a cell editor", "label": {"api": {"DefaultCellEditor": [[12, 28]]}}}, {"text": "Given a particular value, you can use the getIndexOf() method of the editor's DefaultComboBoxModel to determine the position it had when in use as an editor", "label": {"api": {"DefaultComboBoxModel": [[78, 97]]}}}, {"text": "Another approach to verifying this is to use a ThreadLocal to count the actual number of threads running", "label": {"api": {"ThreadLocal": [[47, 57]]}}}, {"text": "I've created the following unit test which uses a ThreadLocal to count the number of threads created by the Executor", "label": {"api": {"ThreadLocal": [[50, 60]]}}}, {"text": "Now the argument type for withTimeout and pollingEvery is Duration", "label": {"api": {"Duration": [[58, 65]]}}}, {"text": "To sort an array, you may use java.util.Arrays.sort", "label": {"api": {"java.util.Arrays.sort": [[30, 50]]}}}, {"text": "As we know that the focus doesn't shift to the thread(with the FutureTask) until we call FutureTask.get() method", "label": {"api": {"focus doesn't shift to the thread(with the FutureTask) until we call FutureTask.get() method": [[20, 111]]}}}, {"text": "To convert a LocalDateTime to another time zone, you first apply the original time zone using atZone(), which returns a ZonedDateTime, then convert to the new time zone using withZoneSameInstant(), and finally convert the result back to a LocalDateTime", "label": {"api": {"LocalDateTime": [[13, 25], [239, 251]], "atZone()": [[94, 101]], "ZonedDateTime": [[120, 132]], "withZoneSameInstant()": [[175, 195]]}}}, {"text": "One easy approach is to submit your Runnable(s) to an ExecutorService, then call shutdown, then call awaitTermination", "label": {"api": {"shutdown": [[81, 88]], "awaitTermination": [[101, 116]]}}}, {"text": "I think problem is inter deployment EJB calls requires lookup", "label": {"api": {"lookup": [[55, 60]]}}}, {"text": "I want to be able to use Stream#sorted() to sort my output by the product of 2 fields (price * quantity)", "label": {"api": {"Stream#sorted()": [[25, 39]]}}}, {"text": "Note that you could use the built-in comparator for sorting doubles", "label": {"api": {"built-in comparator": [[28, 46]]}}}, {"text": "As a side note, you might want to use BigDecimal if you want to have an exact floating point precision", "label": {"api": {"BigDecimal": [[38, 47]]}}}, {"text": "Use the StringTokenizer", "label": {"api": {"StringTokenizer": [[8, 22]]}}}, {"text": "It contains a constructor StringTokenizer(String str, String delim) -- in which your delimiter will be the carat (\"^\") character, and a nextToken() function to return the next token as a String", "label": {"api": {"StringTokenizer": [[26, 40]]}}}, {"text": "For example, here we generate one LocalDate object for each day in a month represented by YearMonth by repeatedly calling YearMonth::atDay", "label": {"api": {"LocalDate": [[34, 42]], "YearMonth": [[90, 98], [122, 130]], "YearMonth::atDay": [[122, 137]]}}}, {"text": "However, the iteration order of a PriorityQueue is undefined", "label": {"api": {"undefined": [[51, 59]]}}}, {"text": "I got it to work using the @XmlElements annotation, as follows", "label": {"api": {"@XmlElements": [[27, 38]]}}}, {"text": "You need a Comparator here", "label": {"api": {"Comparator": [[11, 20]]}}}, {"text": "To properly initialize a ThreadLocal look at the documentation, which provides an example showing how to set an initial-value (by overriding the aptly-named initialValue() method)", "label": {"api": {"initialValue()": [[157, 170]]}}}, {"text": "Yes, a HashMap can be used as a key to another map, as the class properly overrides .equals() and .hashCode()", "label": {"api": {".equals()": [[84, 92]], ".hashCode()": [[98, 108]]}}}, {"text": "You could use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[14, 29]]}}}, {"text": "SimpleDateFormat and DateTimeFormatter are different", "label": {"api": {"SimpleDateFormat": [[0, 15]], "DateTimeFormatter": [[21, 37]]}}}, {"text": "A ThreadPoolExecutor will automatically adjust the pool size (see getPoolSize()) according to the bounds set by corePoolSize (see getCorePoolSize()) and maximumPoolSize (see getMaximumPoolSize())", "label": {"api": {"ThreadPoolExecutor": [[2, 19]]}}}, {"text": "( from ThreadPoolExecutor javadoc )", "label": {"api": {"ThreadPoolExecutor": [[7, 24]]}}}, {"text": "Your inheritance scheme is essentially the same as that of ArrayList", "label": {"api": {"ArrayList": [[59, 67]]}}}, {"text": "The javadoc for ArrayList shows exactly what you are complaining about", "label": {"api": {"ArrayList": [[16, 24]]}}}, {"text": "A Socket is constructed using an InetAddress", "label": {"api": {"Socket is constructed": [[2, 22]]}}}, {"text": "The InetAddress javadoc says", "label": {"api": {"InetAddress javadoc": [[4, 22]]}}}, {"text": "In this case, you will have to implement the Externalizable interface", "label": {"api": {"Externalizable": [[45, 58]]}}}, {"text": "To use the URL in a scanner, get an input stream from it, then use new Scanner(InputStream)", "label": {"api": {"get an input stream from it": [[29, 55]], "new Scanner(InputStream)": [[67, 90]]}}}, {"text": "Use a StringBuilder in order to quickly and easily mutate a string, and then return the toString() value", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "You can use setCharAt in order to change the characters at certain indexes", "label": {"api": {"setCharAt": [[12, 20]]}}}, {"text": "In the loop, you extract the first number using substring(begin, end), and parse that into a number using Integer.parseInt(s)", "label": {"api": {"substring(begin, end)": [[48, 68]], "Integer.parseInt(s)": [[106, 124]]}}}, {"text": "You then start another (inner) loop, incrementing that number by one at a time, formatting the number to text using Integer.toString(i), and check if the next N characters of the input (extracted using substring(begin, end)) matches", "label": {"api": {"substring(begin, end)": [[202, 222]], "Integer.toString(i)": [[116, 134]]}}}, {"text": "According to http://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html your method is named next() not Next()", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html": [[13, 75]]}}}, {"text": "I was looking at the Duration class in Java 8 and noticed that it does not have", "label": {"api": {"Duration": [[21, 28]]}}}, {"text": "The class oracle.jbo.domain.Number is a wrapper around the class java.lang.Number", "label": {"api": {"oracle.jbo.domain.Number": [[10, 33]], "java.lang.Number": [[65, 80]]}}}, {"text": "The oracle.jbo.domain.* classes, also known as the \"JBO Generic Domains\", provide lightweight wrappers for the native Java data types, such as java.lang.Number and java.sql.Date", "label": {"api": {"java.lang.Number": [[143, 158]]}}}, {"text": "As the choices of native synchronization are limited, I thought I'd switch to Condition, but it has exactly the same problem", "label": {"api": {"exactly the same problem": [[100, 123]]}}}, {"text": "The WritableImage provides an PixelFormat handling an byte array in exactly that way, using PixelWriter's setPixels with the PixelFormat set to PixelFormat.getByteRgbInstance()", "label": {"api": {"WritableImage": [[4, 16]], "PixelFormat": [[30, 40], [125, 135], [144, 154]], "PixelWriter": [[92, 102]], "setPixels": [[106, 114]], "PixelFormat.getByteRgbInstance()": [[144, 175]]}}}, {"text": "Another option is to use removeIf from Collection interface (you just need to negate the condition)", "label": {"api": {"removeIf": [[25, 32]]}}}, {"text": "There is also a BitSet for handling a vector of bits", "label": {"api": {"BitSet": [[16, 21]]}}}, {"text": "You can use the java.net.URI-class to extract the hostname from the string", "label": {"api": {"java.net.URI": [[16, 27]]}}}, {"text": "It's equivalent to add, as documented", "label": {"api": {"as documented": [[24, 36]]}}}, {"text": "An OutputStream has no method writeBytes; but it offers a write(byte[]) method that could be used to write all chars of the password with one call", "label": {"api": {"OutputStream": [[3, 14]]}}}, {"text": "Because you're not respecting the preconditions of the reduce() method", "label": {"api": {"preconditions of the reduce()": [[34, 62]]}}}, {"text": "If you use ScriptEngine.createEngine API to create ENGINE_SCOPE Bindings, it'll work as expected", "label": {"api": {"ScriptEngine.createEngine": [[11, 35]]}}}, {"text": "You could just check the list's size() (and of course, it must also be non-negative)", "label": {"api": {"size()": [[32, 37]]}}}, {"text": "This might be irrelevant (don't know if Android fully supports java-8), but you can do it using standard java api", "label": {"api": {"api": [[110, 112]]}}}, {"text": "Consider using ThreadPoolExecutor to avoid creating many Threads manually", "label": {"api": {"ThreadPoolExecutor": [[15, 32]]}}}, {"text": "the ProcessBuilder API", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "You could shuffle your ArrayList and choose the first 3 items from it like so", "label": {"api": {"shuffle": [[10, 16]]}}}, {"text": "If you're using Java 8+, Check out the functional streams and in particular IntStream", "label": {"api": {"streams": [[50, 56]], "IntStream": [[76, 84]]}}}, {"text": "From the SimpleDateFormat.parse() documentation", "label": {"api": {"SimpleDateFormat.parse()": [[9, 32]]}}}, {"text": "when your requirement is to deal with dynamic number of elements; then use Java's List interface resp", "label": {"api": {"List": [[82, 85]]}}}, {"text": "However this will basically give you a naive implementation of a List, so preferably a List could be used instead to avoid extra work (or more accurately any of the concrete implementations)", "label": {"api": {"List": [[65, 68], [87, 90]]}}}, {"text": "Using the URLEncoder class would work", "label": {"api": {"URLEncoder class": [[10, 25]]}}}, {"text": "You can use #putIfAbsent(), which will atomically place the item in the map or return null otherwise, so you could put in your while loop while not null", "label": {"api": {"#putIfAbsent()": [[12, 25]]}}}, {"text": "You can use putIfAbsent(K key, V value)", "label": {"api": {"putIfAbsent(K key, V value)": [[12, 38]]}}}, {"text": "I've found and tried a number of recommended solutions to this issue, such as using a Promise to implement a cancellable Future or using java.util.concurrent.Future which has a cancel() method", "label": {"api": {"cancel()": [[177, 184]]}}}, {"text": "First you need to look at ScheduledExecutorService and its implementations", "label": {"api": {"ScheduledExecutorService": [[26, 49]]}}}, {"text": "You can just use new Map api merge introduced in java-8", "label": {"api": {"merge": [[29, 33]]}}}, {"text": "I think your problem lies mainly in you using a java.util.Timer instead of a javax.swing.Timer and probably you're blocking the Event Dispatch Thread (EDT)", "label": {"api": {"java.util.Timer": [[48, 62]], "javax.swing.Timer": [[77, 93]]}}}, {"text": "Your way to set variables is not secure it can make syntax error or cause an SQL Injection so suggest to use Prepapred Statement, this way is more secure so instead your query you can use", "label": {"api": {"Prepapred Statement": [[109, 127]]}}}, {"text": "Here is the link to help you understand better", "label": {"api": {"link": [[12, 15]]}}}, {"text": "First of all, throwing a checked exception will not normally trigger a transaction rollback unless you specifically configure for this using @ javax.ejb.ApplicationException(rollback = true) on a specific Exception type", "label": {"api": {"@ javax.ejb.ApplicationException(rollback = true)": [[141, 189]]}}}, {"text": "Take a look at the documentation for JLabel, particularly the method setText()", "label": {"api": {"setText()": [[69, 77]]}}}, {"text": "If second-accuracy is good enough, you could simplify your code greatly, using javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[79, 95]]}}}, {"text": "Instead, you have to use setTimestamp(), because your date string has time-of-day (hour, minute, second)", "label": {"api": {"setTimestamp()": [[25, 38]]}}}, {"text": "First, you have to parse the text using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[40, 55]]}}}, {"text": "Then convert from java.util.Date to java.sql.Timestamp", "label": {"api": {"java.util.Date": [[18, 31]], "java.sql.Timestamp": [[36, 53]]}}}, {"text": "Finally call setTimestamp()", "label": {"api": {"setTimestamp()": [[13, 26]]}}}, {"text": "It's also directly spelled out in the javadoc for ExecutorService#shutdownNow()", "label": {"api": {"ExecutorService#shutdownNow()": [[50, 78]], "ExecutorService": [[50, 64]]}}}, {"text": "Other reasons why a Thread may still be alive after interruption are mentioned in the javadoc of Thread#interrupt()", "label": {"api": {"Thread#interrupt()": [[97, 114]]}}}, {"text": "The logic of the stop() method is not obvious without carefully studying the javadoc of ExecutorService (see section \"Usage Examples\", 2nd example)", "label": {"api": {"ExecutorService": [[88, 102]]}}}, {"text": "Shutdown of the ExecutorService is initiated and tasks that were awaiting execution are collected", "label": {"api": {"ExecutorService": [[16, 30]]}}}, {"text": "The specification clearly says", "label": {"api": {"The specification": [[0, 16]]}}}, {"text": "The specification simply states what you can not expect to always work, it doesn’t state what you can expect to always fail", "label": {"api": {"The specification": [[0, 16]]}}}, {"text": "As the javadoc of lastIndexOf states, you get -1 if the object is not found", "label": {"api": {"the javadoc of lastIndexOf": [[3, 28]]}}}]