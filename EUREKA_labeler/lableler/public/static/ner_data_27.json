[{"text": "You can use IntSummaryStatistics class", "label": {"api": {"IntSummaryStatistics": [[12, 31]]}}}, {"text": "Although the documentation could be clearer on this front DataSource.getConnection() actually opens a new connection (as opposed to returning an existing one) thus you need to close each instance returned from that method", "label": {"api": {"DataSource.getConnection()": [[58, 83]]}}}, {"text": "Since filter() and map() are stateless operations, each supplier will be called and its result validated before the next one is attempted", "label": {"api": {"stateless": [[29, 37]]}}}, {"text": "If a non-empty result is found, the stream will terminate immediately, because findFirst() is short-circuiting", "label": {"api": {"short-circuiting": [[94, 109]]}}}, {"text": "From the JDBC API documentation of ResultSet (emphasis mine)", "label": {"api": {"ResultSet": [[35, 43]]}}}, {"text": "Or use method handles", "label": {"api": {"method handles": [[7, 20]]}}}, {"text": "You can use the pattern .*[014689].* along with String.matches()", "label": {"api": {"String.matches()": [[48, 63]]}}}, {"text": "If you would like to have independent ToggleButtons, simply do not put the ToggleButtons into a ToggleGroup, and then you can listen to the selectedProperty of the toggles separately", "label": {"api": {"selectedProperty": [[140, 155]]}}}, {"text": "Alternatively you can also use the onActionProperty", "label": {"api": {"onActionProperty": [[35, 50]]}}}, {"text": "Is there a simpler way than ByteBuffer Charset.encode(CharBuffer cb)", "label": {"api": {"ByteBuffer Charset.encode(CharBuffer cb)": [[28, 67]]}}}, {"text": "I'm trying to understand how Thread.sleep may be related to Happens-Before", "label": {"api": {"Thread.sleep": [[29, 40]]}}}, {"text": "Since Thread.sleep is a native method, I want to understand how it resolves happens-before", "label": {"api": {"Thread.sleep": [[6, 17]]}}}, {"text": "I might be misunderstanding your problem, but can't you just parse it", "label": {"api": {"parse": [[61, 65]]}}}, {"text": "It is java.util.Map (that the common interface), the most often used implementation is java.util.HashMap", "label": {"api": {"java.util.Map": [[6, 18]], "java.util.HashMap": [[87, 103]]}}}, {"text": "You can use XMLStreamConstants.START_ELEMENT and XMLStreamConstants.END_ELEMENT to determine start and end tags", "label": {"api": {"XMLStreamConstants.START_ELEMENT": [[12, 43]], "XMLStreamConstants.END_ELEMENT": [[49, 78]]}}}, {"text": "All collections (all forms of list and other collections) in the Java Collections framework have a method on them toArray() that converts the collection to an array", "label": {"api": {"toArray()": [[114, 122]], "Collections": [[70, 80]]}}}, {"text": "Another useful part of the framework is the Collections class", "label": {"api": {"Collections": [[44, 54]]}}}, {"text": "It has an addAll() method that accepts a Collection and an array and adds the elements from the array to the collection for you", "label": {"api": {"addAll()": [[10, 17]]}}}, {"text": "When working with arrays, you'll want to be familiar with the handy Arrays class", "label": {"api": {"Arrays": [[68, 73]]}}}, {"text": "One of the handy methods it provides is asList() which returns a List implementation which contains all of the elements in the array you provide", "label": {"api": {"asList()": [[40, 47]], "List": [[42, 45], [65, 68]]}}}, {"text": "This can be useful, for example, in conjunction with the addAll() that all of the collections have", "label": {"api": {"addAll()": [[57, 64]]}}}, {"text": "To convert a month's name to it's integer value you can actually use Month#valueOf method", "label": {"api": {"Month#valueOf": [[69, 81]]}}}, {"text": "More sophisticated locking idioms are supported by the java.util.concurrent.locks package", "label": {"api": {"java.util.concurrent.locks": [[55, 80]]}}}, {"text": "Many people accidentally used the Object.equals() method rather than the Field.equal() method (e.g", "label": {"api": {"Object.equals()": [[34, 48]]}}}, {"text": "If it's another thread, then perhaps you could change you list type to CopyOnWriteArrayList or lock the list by adding synchronized statement, but nevertheless, don't change the list within that", "label": {"api": {"CopyOnWriteArrayList": [[71, 90]]}}}, {"text": "As I mentioned, if you do not put the ToggleButtons into a ToggleGroup you can listen to the selectedProperty of the toggles separately", "label": {"api": {"selectedProperty": [[93, 108]]}}}, {"text": "you can also use the onActionProperty", "label": {"api": {"onActionProperty": [[21, 36]]}}}, {"text": "What you could do is to use string.replaceAll which accepts a regex, and replaces all occurrences of it with a given string", "label": {"api": {"string.replaceAll": [[28, 44]]}}}, {"text": "You can use an java.util.concurrent.DoubleAdder and Collectors#toMap like this", "label": {"api": {"java.util.concurrent.DoubleAdder": [[15, 46]], "Collectors#toMap": [[52, 67]]}}}, {"text": "Reading the documentation for String.replace should explain what happened here (I marked the relevant part in bold)", "label": {"api": {"String.replace": [[30, 43]]}}}, {"text": "In case your method returns CompletableFuture use join method - documentation CompletableFuture::join", "label": {"api": {"documentation CompletableFuture::join": [[64, 100]]}}}, {"text": "For instance, KeyAdapter implements all the methods from KeyListener", "label": {"api": {"KeyAdapter": [[14, 23]], "KeyListener": [[57, 67]]}}}, {"text": "If you want to do something special with e.g keytyped, you would create a subclass of KeyAdapter and override only this method", "label": {"api": {"KeyAdapter": [[86, 95]]}}}, {"text": "You can use DecimalFormat", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "If that's not to your taste, you can change the rounding algorithm used by using the  DecimalFormat.setRoundingMode(RoundingMode mode) method", "label": {"api": {"DecimalFormat": [[86, 98]]}}}, {"text": "JFrame#setVisible(...) should be one of the last lines to be called", "label": {"api": {"JFrame#setVisible(...)": [[0, 21]]}}}, {"text": "You're calling JFrame#setSize(...), you should instead override the getPreferredSize of your inner JPanels and then call JFrame#pack(), so your JFrame reduces its size to the minimum size where all your components are visible on their preferred sizes", "label": {"api": {"JFrame#setSize(...)": [[15, 33]], "getPreferredSize": [[68, 83]], "JFrame#pack()": [[121, 133]]}}}, {"text": "But if you want to follow my above recommendations you could try this code, which uses layout managers, empty borders, overrides getPreferredSize() methods and uses pack(), etc and generates a really similar GUI like the one you already have", "label": {"api": {"getPreferredSize": [[129, 144]]}}}, {"text": "The maximum value for a signed integer in Java is 2,147,483,647 (2^31 -1)", "label": {"api": {"maximum value for a signed integer in Java": [[4, 45]]}}}, {"text": "Also instead of using Thread.sleep(), you might want to take a look to the CountDownLatch class", "label": {"api": {"CountDownLatch": [[75, 88]]}}}, {"text": "Note the end of the Stream’s class documentation", "label": {"api": {"the Stream’s class documentation": [[16, 47]]}}}, {"text": "If you call ArrayList.remove() the element at the given index is removed from the list (and all elements following it move down one index)", "label": {"api": {"ArrayList.remove()": [[12, 29]]}}}, {"text": "You can use generateSeed(int) or getSeed(int) to statically retrieve the seed input that is also used for SecureRandom itself", "label": {"api": {"generateSeed(int)": [[12, 28]], "getSeed(int)": [[33, 44]]}}}, {"text": "You can use the standard System.nanoTime() and add that to the internal state of the CSPRNG using the badly named setSeed method", "label": {"api": {"System.nanoTime()": [[25, 41]]}}}, {"text": "print(float) and print(double)", "label": {"api": {"print(float)": [[0, 11]], "print(double)": [[17, 29]]}}}, {"text": "Is there a way to use a supplier in a way similar to the java.util.Logger class", "label": {"api": {"java.util.Logger class": [[57, 78]]}}}, {"text": "In case you want to parse a String representing a date, you should use should use DateTimeFormatter, as for e.g", "label": {"api": {"DateTimeFormatter": [[82, 98]]}}}, {"text": "You need the max property of the slider to be equal to the total number of seconds of the media you are playing", "label": {"api": {"max property": [[13, 24]]}}}, {"text": "Note that the totalDuration of the media won't be known until the media player has read enough information from the media resource", "label": {"api": {"totalDuration": [[14, 26]]}}}, {"text": "List#toArray(T[]) uses this pattern for this purpose", "label": {"api": {"List#toArray(T[])": [[0, 16]]}}}, {"text": "The Enumeration interface does not expose its size, and some (many?) implementations indeed do not have this knowledge", "label": {"api": {"Enumeration": [[4, 14]]}}}, {"text": "The problem is that JButton (its predecessor AbstractButton) uses EventListenerList class to store listeners", "label": {"api": {"JButton": [[20, 26]], "AbstractButton": [[45, 58]], "EventListenerList": [[66, 82]]}}}, {"text": "By the way, in Java 8 this \"grouping\" operation is way easier to do with the Stream API, specifically by using Collectors.groupingBy", "label": {"api": {"Collectors.groupingBy": [[111, 131]]}}}, {"text": "As @SotiriosDelimanolis hinted, Map.get() accepts Object, not the key type, so the compiler is unable to infer the target lambda type", "label": {"api": {"Map.get()": [[32, 40]]}}}, {"text": "Use an overload that does accept the key type, like merge()", "label": {"api": {"merge()": [[52, 58]]}}}, {"text": "From the documentation for TreeSet, emphasis mine", "label": {"api": {"the documentation for TreeSet": [[5, 33]]}}}, {"text": "You can do this using Collections.shuffle(list) This way you won't get any repeats but you will sort the whole list which could be a waste if there are hundreds of entries and you only want to show 20", "label": {"api": {"Collections.shuffle(list)": [[22, 46]]}}}, {"text": "BTW, it seems in case you want to go with the Closeable solution, a better way is to implement AutoCloseable instead since it would allow you to use try-with-resources in the code that uses these listeners", "label": {"api": {"AutoCloseable": [[95, 107]]}}}, {"text": "In the documentation of AutoCloseable, the following is mentioned", "label": {"api": {"AutoCloseable": [[24, 36]]}}}, {"text": "It is possible, and in fact common, for a base class to implement AutoCloseable even though not all of its subclasses or instances will hold releasable resources", "label": {"api": {"AutoCloseable": [[66, 78]]}}}, {"text": "For code that must operate in complete generality, or when it is known that the AutoCloseable instance requires resource release, it is recommended to use try-with-resources constructions", "label": {"api": {"AutoCloseable": [[80, 92]]}}}, {"text": "This note implies that a class may implement AutoCloseable even if its implementation does not use actual resources", "label": {"api": {"AutoCloseable": [[45, 57]]}}}, {"text": "Properties extends Hashtable, so you can find the keys present in both objects using set intersection", "label": {"api": {"Properties": [[0, 9]], "Hashtable": [[19, 27]]}}}, {"text": "I know I have to return it recursively, but the doc I found at the documentation I found about Set can't help me", "label": {"api": {"the documentation I found about Set": [[63, 97]]}}}, {"text": "From the documentation for DefaultTableCellRenderer (emphasis mine)", "label": {"api": {"the documentation for DefaultTableCellRenderer": [[5, 50]]}}}, {"text": "The .accept() method blocks your main thread until a new connection arrives", "label": {"api": {".accept()": [[4, 12]]}}}, {"text": "You can use MessageDigest to convert to SHA256, and Base64 to convert it to Base64", "label": {"api": {"MessageDigest": [[12, 24]], "Base64": [[52, 57], [76, 81]]}}}, {"text": "As already noted, the parameters to Collectors.toMap have to be functions, so you have to change 0 to name -> 0 (you can use any other parameter name instead of name)", "label": {"api": {"Collectors.toMap": [[36, 51]]}}}, {"text": "To fix this, you could pipe the stream through Stream.distinct first", "label": {"api": {"Stream.distinct": [[47, 61]]}}}, {"text": "Or don't initialize those defaults at all, and use getOrDefault or computeIfAbsent instead", "label": {"api": {"getOrDefault": [[51, 62]], "computeIfAbsent": [[67, 81]]}}}, {"text": "Or, if you want to get the counts of the names, you can just use Collectors.groupingBy and Collectors.counting", "label": {"api": {"Collectors.groupingBy": [[65, 85]], "Collectors.counting": [[91, 109]]}}}, {"text": "You could use the Statement.executeUpdate() instead", "label": {"api": {"Statement.executeUpdate()": [[18, 42]]}}}, {"text": "For your purpose more better approach would be use of HashSet<Integer> which holds only unique elements and which is Dynamic in nature so no need to waste extra space as well as it can make your work very easy", "label": {"api": {"HashSet<Integer>": [[54, 69]]}}}, {"text": "So first you need to all elements in the HashSet<Integer> and then by using Iterator you can easily iterate through it but the insertion order can be disturbed here", "label": {"api": {"HashSet<Integer>": [[41, 56]]}}}, {"text": "So as replied by @Alnitak You can use LinkedHashSet<Integer> to have insertion order same", "label": {"api": {"HashSet<Integer>": [[44, 59]]}}}, {"text": "The two-int constructor is Rectangle(int width, int height), and it implicitly sets the upper-left corner to (0, 0), which is why your code prints true", "label": {"api": {"Rectangle(int width, int height)": [[27, 58]]}}}, {"text": "Rectangle(int x, int y, int width, int height)", "label": {"api": {"Rectangle(int x, int y, int width, int height)": [[0, 45]]}}}, {"text": "Now keep in mind the following quote from the docs for Rectangle.add(Point)", "label": {"api": {"Rectangle.add(Point)": [[55, 74]]}}}, {"text": "As a bonus, it's already implemented in Collections.shuffle() (the doc mentions it runs in linear time)", "label": {"api": {"Collections.shuffle()": [[40, 60]]}}}, {"text": "Please read the Java API specifications carefully", "label": {"api": {"Java API specifications": [[16, 38]]}}}, {"text": "Java's equivalent of Type is Class", "label": {"api": {"Class": [[29, 33]]}}}, {"text": "x is promoted to int, and System.out.println(int) is called, and it prints it as a number", "label": {"api": {"System.out.println(int)": [[26, 48]]}}}, {"text": "Instead, use java.sql.Timestamp like this", "label": {"api": {"java.sql.Timestamp": [[13, 30]]}}}, {"text": "It looks like you're filtering a list to see if anything in another list matches it, and collect the results in another list", "label": {"api": {"filter": [[21, 26]], "collect": [[89, 95]]}}}, {"text": "So you can use filter, anyMatch and collect", "label": {"api": {"filter": [[15, 20]], "anyMatch": [[23, 30]], "collect": [[36, 42]]}}}, {"text": "You should look at Executors and ThreadPoolExecutor", "label": {"api": {"Executors": [[19, 27]], "ThreadPoolExecutor": [[33, 50]]}}}, {"text": "From the JavaDoc of the Set interface", "label": {"api": {"the JavaDoc of the Set interface": [[5, 36]]}}}, {"text": "Check here how to use streams in Java 8", "label": {"api": {"streams": [[22, 28]]}}}, {"text": "First .stream() the List, then use Stream#filter and finally collect to a new List", "label": {"api": {"Stream#filter": [[35, 47]]}}}, {"text": "TreeMap implements Red-Black tree which is an alternative to AVL", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "As stated in the comments, you could use a StringBuilder instead of Scanner class", "label": {"api": {"StringBuilder": [[43, 55]]}}}, {"text": "You can roll your own resettable timer with Object.wait(long) and Object.notify()", "label": {"api": {"Object.wait(long)": [[44, 60]], "Object.notify()": [[66, 80]]}}}, {"text": "The length in frames is a simple computation that relies on information in the AudioFormat", "label": {"api": {"AudioFormat": [[79, 89]]}}}, {"text": "There's no way of getting threads dedicated to a particular executor, but from inside the JVM you can use Thread#getAllStackTraces to get a map of call stacks for all live threads", "label": {"api": {"Thread#getAllStackTraces": [[106, 129]]}}}, {"text": "WebTarget#path return a new WebTarget instance", "label": {"api": {"WebTarget#path": [[0, 13]]}}}, {"text": "I was reading the Java docs and encountered this sentence", "label": {"api": {"this sentence": [[44, 56]]}}}, {"text": "You can move the decimal place using BigDecimal like this..", "label": {"api": {"BigDecimal": [[37, 46]]}}}, {"text": "I'm leaning about the CyclicBarrier and I wrote this demo", "label": {"api": {"CyclicBarrier": [[22, 34]]}}}, {"text": "My question is that the CyclicBarrier instance reset itself when the last await() arrived", "label": {"api": {"CyclicBarrier": [[24, 36]]}}}, {"text": "You are invoking the constructor  StringBuffer(int capacity)", "label": {"api": {"StringBuffer(int capacity)": [[34, 59]]}}}, {"text": "This cannot be cleanly done on Java level for an arbitrary thread, as there are no non-deprecated methods to suspend it", "label": {"api": {"deprecated methods": [[87, 104]]}}}, {"text": "The Year class represents a year, and offers some handy methods", "label": {"api": {"Year": [[4, 7]]}}}, {"text": "We can obtain a date by specifying a day-of-year 1-365 (or 366 in Leap Year)", "label": {"api": {"Year": [[71, 74]]}}}, {"text": "The ThreadLocalRandom class provides a thread-safe (safe if always accessed via .current()) random number generator", "label": {"api": {"ThreadLocalRandom": [[4, 20]]}}}, {"text": "You can use the SimpleDateFormat class (avoid the space)", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "That being said, Java has its own HttpServer and HttpsServer classes", "label": {"api": {"HttpServer": [[34, 43]], "HttpsServer": [[49, 59]]}}}, {"text": "For the annotation JoinColumn, you simply needs to get it first with getAnnotation(Class<T> annotationClass) then check the value of nullable()", "label": {"api": {"getAnnotation(Class<T> annotationClass)": [[69, 107]]}}}, {"text": "You can convert your String to an array of characters - String#toCharArray", "label": {"api": {"String#toCharArray": [[56, 73]]}}}, {"text": "InetSocketAddress.getAddress() is final, as listed in the docs", "label": {"api": {"as listed in the docs": [[41, 61]]}}}, {"text": "There are no write methods on FileWriter that take an Object", "label": {"api": {"FileWriter": [[30, 39]], "Writer": [[34, 39]]}}}, {"text": "FileWriter, OutputStreamWriter, and Writer", "label": {"api": {"FileWriter": [[0, 9]], "OutputStreamWriter": [[12, 29]], "Writer": [[4, 9], [24, 29], [36, 41]]}}}, {"text": "Your schedule(…) call contains more arguments than the method has parameters", "label": {"api": {"the method": [[51, 60]]}}}, {"text": "You want to use https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isInstance-java.lang.Object-", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#isInstance-java.lang.Object-": [[16, 106]]}}}, {"text": "You can use the onActionProperty", "label": {"api": {"onActionProperty": [[16, 31]]}}}, {"text": "I would propose one of the options that use the selectedProperty as the onActionProperty will change only if the button was pressed (by mouse, touch or key) or if you programatically call the fire() method", "label": {"api": {"onActionProperty": [[72, 87]]}}}, {"text": "You will need to first get the date value via either .getDate() or .getCalendar(), then you should use something like SimpleDateFormat to format the date", "label": {"api": {"SimpleDateFormat": [[118, 133]]}}}, {"text": "Just set the correct Locale with scanner.useLocale(locale), https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html#useLocale-java.util.Locale-", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html#useLocale-java.util.Locale-": [[60, 151]]}}}, {"text": "Be sure to read the Image documentation for how the string representation of the URL is interpreted", "label": {"api": {"Image documentation": [[20, 38]]}}}, {"text": "It sounds like you're looking for a Consumer, which will work as long as you fill in the generics with a value other than <?>", "label": {"api": {"Consumer": [[36, 43]]}}}, {"text": "Why node is of type DOCUMENT_POSITION_DISCONNECTED and not ELEMENT_NODE", "label": {"api": {"DOCUMENT_POSITION_DISCONNECTED": [[20, 49]]}}}, {"text": "Thus, you'll need to use & 0xff (or Byte.toUnsignedInt) to strip those added bits from each byte", "label": {"api": {"Byte.toUnsignedInt": [[36, 53]]}}}, {"text": "From the documentation of JList.setLayoutOrientation", "label": {"api": {"documentation of JList.setLayoutOrientation": [[9, 51]]}}}, {"text": "If you need them beside each other, just put them in a HBox", "label": {"api": {"HBox": [[55, 58]]}}}, {"text": "A complete description of layout panes, such as HBox, is in the tutorial", "label": {"api": {"HBox": [[48, 51]]}}}, {"text": "Check out the documentation at http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#arraycopy-java.lang.Object-int-java.lang.Object-int-int- for what the parameters should be", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#arraycopy-java.lang.Object-int-java.lang.Object-int-int-": [[31, 149]]}}}, {"text": "The only method that consume newline of the input is nextLine(), so if you use nextInt() and then you want to capture anything else you have to call a nextLine() after you call nextInt()", "label": {"api": {"nextLine()": [[53, 62], [151, 160]]}}}, {"text": "Use the String(byte[], int, int, String) constructor", "label": {"api": {"String(byte[], int, int, String)": [[8, 39]]}}}, {"text": "In the code, you should use System.getProperty(\"ABC_HOME\") instead", "label": {"api": {"System.getProperty(\"ABC_HOME\")": [[28, 57]]}}}, {"text": "The two comparisons can be chained using thenComparing", "label": {"api": {"thenComparing": [[41, 53]]}}}, {"text": "You can use multiselect with Tuple, for select only specific columns", "label": {"api": {"Tuple": [[29, 33]]}}}, {"text": "A better solution is to use a semaphore (or similarly, a latch)", "label": {"api": {"semaphore": [[30, 38]], "latch": [[57, 61]]}}}, {"text": "After the listener gets the value, it releases a semaphore, which allows your thread to return the value, as shown below", "label": {"api": {"semaphore": [[49, 57]]}}}, {"text": "Just use String's replace method", "label": {"api": {"replace": [[18, 24]]}}}, {"text": "If all you want to do is serialize a DOM node then in the Java world you can use LSSerializer (https://docs.oracle.com/javase/7/docs/api/org/w3c/dom/ls/LSSerializer.html) instead of a default Transformer and then you have the method setNewLine (https://docs.oracle.com/javase/7/docs/api/org/w3c/dom/ls/LSSerializer.html#setNewLine(java.lang.String)) to define or control your preferred line ending", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/org/w3c/dom/ls/LSSerializer.html": [[95, 168], [245, 318]], "https://docs.oracle.com/javase/7/docs/api/org/w3c/dom/ls/LSSerializer.html#setNewLine(java.lang.String)": [[245, 347]]}}}, {"text": "You will need to specify the namespace specifically on the element if it is not default for the whole package", "label": {"api": {"namespace": [[29, 37]]}}}, {"text": "To get your main task to wait for the sub task execution, you could use the Future returned by Executor.submit() this way", "label": {"api": {"Future": [[76, 81]], "Executor.submit()": [[95, 111]]}}}, {"text": "You can't create a file and its non-existent parent directories in one step, but you can create the parent directories first with File.mkdirs() and then create the file", "label": {"api": {"File.mkdirs()": [[130, 142]]}}}, {"text": "You can use java.awt.Robot to send keyboard input to the active window", "label": {"api": {"java.awt.Robot": [[12, 25]]}}}, {"text": "The documentation for File#listFiles() does not state that it walks all subdirectories", "label": {"api": {"File#listFiles()": [[22, 37]]}}}, {"text": "A good choice here is AtomicInteger", "label": {"api": {"AtomicInteger": [[22, 34]]}}}, {"text": "Using Pattern and Matcher, you can search for repeated characters easily", "label": {"api": {"Pattern": [[6, 12]], "Matcher": [[18, 24]]}}}, {"text": "You can use String.replaceAll with a regular expression", "label": {"api": {"String.replaceAll": [[12, 28]]}}}, {"text": "I've been reading about the timer method here  https://docs.oracle.com/javase/7/docs/api/java/util/Timer.html but I've been unable to comprehend what I'm supposed to type to repeat the sequence say, once every 10 milliseconds, only when the button is being pressed", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Timer.html": [[47, 108]]}}}, {"text": "A very clear and easy way you could solve this, is by using a ListIterator", "label": {"api": {"ListIterator": [[62, 73]]}}}, {"text": "I would suggest for your propose to use a HashMap", "label": {"api": {"HashMap": [[42, 48]]}}}, {"text": "Consider the specification for the put method of the java.util.Map interface", "label": {"api": {"put": [[35, 37]], "java.util.Map": [[53, 65]]}}}, {"text": "The put method signature is", "label": {"api": {"put": [[4, 6]]}}}, {"text": "Can someone demonstrate how Map#put might throw a ClassCastException at runtime", "label": {"api": {"put": [[32, 34]]}}}, {"text": "If you look at the documentation for HashMap.put, you'll notice that it doesn't mention ClassCastException at all", "label": {"api": {"documentation for HashMap.put": [[19, 47]]}}}, {"text": "As mentioned in the comments, TreeMap.put does throw a ClassCastException because it needs to be able to accurately compare the keys", "label": {"api": {"TreeMap.put": [[30, 40]]}}}, {"text": "You can use the Process API to execute git commands directly", "label": {"api": {"Process API": [[16, 26]]}}}, {"text": "The documentation for List.sort(Comparator) says that if you pass in null, then the list will be sorted according it it's natural ordering", "label": {"api": {"List.sort(Comparator)": [[22, 42]]}}}, {"text": "(See Integer.MAX_VALUE.) Your example phone number is much larger than that", "label": {"api": {"Integer.MAX_VALUE": [[5, 21]]}}}, {"text": "As the javadoc of the start method in Thread says", "label": {"api": {"the javadoc of the start method in Thread": [[3, 43]]}}}, {"text": "By default, messages printed to System.out are appended to the {cf_root}\\runtime\\logs\\coldfusion-out.log file", "label": {"api": {"System.out": [[32, 41]]}}}, {"text": "As an aside, the System.out is probably for demo purposes only", "label": {"api": {"System.out": [[17, 26]]}}}, {"text": "You can use Comparator.comparingInt to make the comparator", "label": {"api": {"Comparator.comparingInt": [[12, 34]]}}}, {"text": "A better practice is to setup your own logging.properties file and configure your project to use that on startup", "label": {"api": {"logging.properties": [[39, 56]]}}}, {"text": "You also don't need to create your own formatter as you can  change the format pattern of the SimpleFormater on the command line by using the following", "label": {"api": {"change the format pattern of the SimpleFormater": [[61, 107]]}}}, {"text": "Also, File.getName() doesn't give you enough of the path to construct a new File correctly", "label": {"api": {"File.getName()": [[6, 19]]}}}, {"text": "Note that Java's trig functions take their parameters as radians, so you need to convert the angle in degrees appropriately", "label": {"api": {"convert the angle in degrees appropriately": [[81, 122]]}}}, {"text": "You should use an ExecutorCompletionService, wrap your executor with it and then calling #take() will return the first completed result", "label": {"api": {"ExecutorCompletionService": [[18, 42]], "#take()": [[89, 95]]}}}, {"text": "Write an implementation of the TemporalAdjuster interface", "label": {"api": {"TemporalAdjuster": [[31, 46]]}}}, {"text": "Pass your TemporalAdjuster object to LocalDate.with", "label": {"api": {"TemporalAdjuster": [[10, 25]], "LocalDate.with": [[37, 50]]}}}, {"text": "The magic happens inside the FXMLLoader", "label": {"api": {"FXMLLoader": [[29, 38]]}}}, {"text": "AWT - Frame, Window, Dialog .", "label": {"api": {"Frame": [[6, 10]], "Window": [[13, 18]], "Dialog": [[21, 26]]}}}, {"text": "Swing - JFrame, JWindow, JDialog, JOptionPane .", "label": {"api": {"Frame": [[9, 13]], "Window": [[17, 22]], "Dialog": [[26, 31]], "JFrame": [[8, 13]], "JWindow": [[16, 22]], "JDialog": [[25, 31]], "JOptionPane": [[34, 44]]}}}, {"text": "Java-FX - Stage (I have not used Java-FX much, so am unfamiliar with the other variants of TLCs, but see the Java-FX API docs for other examples)", "label": {"api": {"Stage": [[10, 14]], "Java-FX API docs": [[109, 124]]}}}, {"text": "You can use StreamSupport class", "label": {"api": {"StreamSupport": [[12, 24]]}}}, {"text": "AFAIK you don't have to double buffer yourself but can use JComponent.setDoubleBuffered()", "label": {"api": {"JComponent.setDoubleBuffered()": [[59, 88]]}}}, {"text": "Java 8 supports use of \\R as a Linebreak matcher that will match any Unicode linebreak sequence", "label": {"api": {"Linebreak matcher": [[31, 47]]}}}, {"text": "You may refer to this link for more information on the method", "label": {"api": {"link": [[22, 25]]}}}, {"text": "This is because you violated Java requirement for overriding equals", "label": {"api": {"Java requirement for overriding equals": [[29, 66]]}}}, {"text": "It's not really clear what you're asking, but methods like swap(...) and shuffle(...) do indeed only for work for a List", "label": {"api": {"swap(...)": [[59, 67]], "shuffle(...)": [[73, 84]]}}}, {"text": "But no, methods like addAll(...) work for any Collection, like for example Set (a subclass)", "label": {"api": {"addAll(...)": [[21, 31]]}}}, {"text": "StringJoiner was added to Java 8 for this purpose", "label": {"api": {"StringJoiner": [[0, 11]]}}}, {"text": "Also String.join is a superb alternative for this task", "label": {"api": {"String.join": [[5, 15]]}}}, {"text": "When a JVM* autoboxes a boolean it calls Boolean.valueOf(boolean) which returns either Boolean.TRUE or Boolean.FALSE which are static final Boolean fields", "label": {"api": {"Boolean.valueOf(boolean)": [[41, 64]], "Boolean.TRUE": [[87, 98]], "Boolean.FALSE": [[103, 115]], "Boolean": [[41, 47], [87, 93], [103, 109], [140, 146]], "valueOf(boolean)": [[49, 64]]}}}, {"text": "It does not create a new Boolean instance", "label": {"api": {"Boolean": [[25, 31]]}}}, {"text": "As such, the PLACEHOLDER you've defined is in fact a reference to Boolean.TRUE and is redundant", "label": {"api": {"Boolean.TRUE": [[66, 77]], "Boolean": [[66, 72]]}}}, {"text": "If you want a straight-up LRU you can use Collections.newSetFromMap(Map) with LinkedHashMap", "label": {"api": {"Collections.newSetFromMap(Map)": [[42, 71]], "LinkedHashMap": [[78, 90]]}}}, {"text": "Theoretically there could be some JVM implementation(s) out there that don't call Boolean.valueOf(boolean) (or something similar) at runtime when autoboxing boolean primitives but if such an implementation exists I am fairly confident you are not using it and that very few if any individuals are", "label": {"api": {"Boolean.valueOf(boolean)": [[82, 105]], "Boolean": [[82, 88]], "valueOf(boolean)": [[90, 105]]}}}, {"text": "Unless a new instance is required, the static factory valueOf(boolean) is generally a better choice", "label": {"api": {"valueOf(boolean)": [[54, 69]]}}}, {"text": "From the documentation of Writer.write(int)", "label": {"api": {"the documentation of Writer.write(int)": [[5, 42]]}}}, {"text": "Use a java.util.concurrent.ConcurrentHashMap as the type of graphMap so that you know it can handle concurrent additions (of different keys)", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[6, 43]]}}}, {"text": "Synchronize on graphName after interning it", "label": {"api": {"interning it": [[31, 42]]}}}, {"text": "How do I get SpringLayout to work in IntelliJ's GUI builder", "label": {"api": {"SpringLayout": [[13, 24]]}}}, {"text": "The setCellValueFactory method requires a Callback<CellDataFeatures, ObservableValue>", "label": {"api": {"setCellValueFactory": [[4, 22]], "CellDataFeatures": [[51, 66]]}}}, {"text": "a function that maps a CellDataFeatures object to an ObservableValue containing the value to be displayed", "label": {"api": {"CellDataFeatures": [[23, 38]]}}}, {"text": "It can at most only be enabled during build time in web.xml or during deploy time by ServletContext#addServlet()", "label": {"api": {"ServletContext#addServlet()": [[85, 111]]}}}, {"text": "Why don't you use File#listFiles()", "label": {"api": {"File#listFiles()": [[18, 33]]}}}, {"text": "For that, you should use the Animation API", "label": {"api": {"Animation API": [[29, 41]]}}}, {"text": "E.g., using a Timeline", "label": {"api": {"Timeline": [[14, 21]]}}}, {"text": "In you have an array of Objects, Java allows you to sort arrays in a range using Arrays.sort", "label": {"api": {"Arrays.sort": [[81, 91]]}}}, {"text": "For another, the JFileChooser API will tell you which method returns just a single File and which returns an array of File[]", "label": {"api": {"JFileChooser API": [[17, 32]]}}}, {"text": "You'll likely want to use a Supplier to store reference to the method because your method takes no input and returns one output (whereas a java Function takes one input and returns one output)", "label": {"api": {"Function": [[144, 151]]}}}, {"text": "According to the official Java Doc (https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html": [[36, 99]]}}}, {"text": "You can compose such predicates with .and() and .or(), allowing you to define a single aggregate predicate that applies all the checks you would like, rather than trying to chain n .filter() calls", "label": {"api": {".and()": [[37, 42]], ".or()": [[48, 52]]}}}, {"text": "According to Java ArrayList API with get(int index) method you just obtain the element in index position in your ArrayList", "label": {"api": {"Java ArrayList API": [[13, 30]]}}}, {"text": "You could use AbstractList and Collections to perhaps make it a little easier to follow", "label": {"api": {"AbstractList": [[14, 25]], "Collections": [[31, 41]]}}}, {"text": "In addition you may use Java Stream API and java.lang.StringBuilder to make the code better", "label": {"api": {"java.lang.StringBuilder": [[44, 66]]}}}, {"text": "Sample of a Timeline based Metronome with some visual controls and Metronome beat timing indicator", "label": {"api": {"Timeline": [[12, 19]]}}}, {"text": "Use a ListIterator to do this", "label": {"api": {"ListIterator": [[6, 17]]}}}, {"text": "After you could convert your RGB array to BufferedImage", "label": {"api": {"BufferedImage": [[42, 54]]}}}, {"text": "To answer your direct question, you want toMap(), twice", "label": {"api": {"toMap()": [[41, 47]]}}}, {"text": "You implement the interface Iterator to allow iterating over your nodes", "label": {"api": {"Iterator": [[28, 35]]}}}, {"text": "Then you let Node implement Iterable to allow the use of a for each statement on your nodes", "label": {"api": {"Iterable": [[28, 35]]}}}, {"text": "As you are iterating over the lines of text in the file, use String's startsWith() method to check if the line starts with the sequences you are trying to avoid", "label": {"api": {"startsWith()": [[70, 81]]}}}, {"text": "JMeter Variables are basically ThreadLocal therefore you don't need to do anything", "label": {"api": {"ThreadLocal": [[31, 41]]}}}, {"text": "Looks like Java has exact POJO Map.Entry like you want", "label": {"api": {"Map.Entry": [[31, 39]]}}}, {"text": "The class must be then registered via Java ServiceLoader mechanism by adding full name of the class with its packages into the file with name org.hibernate.boot.spi.SessionFactoryBuilderFactory into the java module’s META-INF/services directory", "label": {"api": {"Java ServiceLoader mechanism": [[38, 65]]}}}, {"text": "Best-practices here would involve you injecting a Clock, which will give you access to any objects (including LocalDateTime) you need via an override of the now method", "label": {"api": {"Clock": [[50, 54]]}}}, {"text": "As in Ash's answer, you could make a method overload with your current signature that creates a new SystemClock, and then test the method that accepts the clock", "label": {"api": {"Clock": [[106, 110]]}}}, {"text": "This way, in your test, you can pass in a value from Clock.fixed", "label": {"api": {"Clock": [[53, 57]], "Clock.fixed": [[53, 63]]}}}, {"text": "You can use an ElementIterator to copy over a JTextPane’s StyledDocument element by element, with all styling, including icons", "label": {"api": {"ElementIterator": [[15, 29]]}}}, {"text": "Have you tried public char getKeyChar()", "label": {"api": {"public char getKeyChar()": [[15, 38]]}}}, {"text": "You can assert on a boolean condition using Stream#anyMatch(Predicate filter)", "label": {"api": {"Stream#anyMatch(Predicate filter)": [[44, 76]]}}}, {"text": "Use a ConcurrentHashMap to allow access and modification from different threads", "label": {"api": {"ConcurrentHashMap": [[6, 22]]}}}, {"text": "I was exploring Java classloaders then I faced the SecureClassLoader", "label": {"api": {"SecureClassLoader": [[51, 67]]}}}, {"text": "Could anyone explain what the SecureClassLoader is used for", "label": {"api": {"SecureClassLoader": [[30, 46]]}}}, {"text": "You might try with DirectoryStream", "label": {"api": {"DirectoryStream": [[19, 33]]}}}, {"text": "You can also make the DirectoryStream filter files for you if you need to", "label": {"api": {"DirectoryStream": [[22, 36]]}}}, {"text": "all you need to do is add a parameter to the Files.newDirectoryStream call", "label": {"api": {"DirectoryStream": [[54, 68]]}}}, {"text": "First of all, you should convert one or the other of these lists into a Set, so that the .contains() check is efficient", "label": {"api": {"Set": [[72, 74]], ".contains()": [[89, 99]]}}}, {"text": "Calling .contains() on a List is a linear-time operation, meaning doing so n times is quadratic", "label": {"api": {".contains()": [[8, 18]]}}}, {"text": "Once you've done that it's straightforward to use .filter() or even .partitioningBy() to determine where the two lists overlap", "label": {"api": {".filter()": [[50, 58]], ".partitioningBy()": [[68, 84]]}}}, {"text": "Guava provides efficient implementations of these operations in their Sets utility", "label": {"api": {"Set": [[70, 72]]}}}, {"text": "If you run out of memory, you run out of memory; if infinite memory were possible then OutOfMemoryError in Java (and System.OutOfMemoryException in .NET) would not exist and memory leaks would not crash programs", "label": {"api": {"OutOfMemoryError": [[87, 102]]}}}, {"text": "You probably want to do something around String or toUpperCase(int) to handle Unicode, see Oracle", "label": {"api": {"Oracle": [[91, 96]]}}}, {"text": "Even the CopyOnWriteArrayList doesn't provide an atomic operation to check if an element exists in the list and execute some code on it like the Map's interface computeIfPresent", "label": {"api": {"CopyOnWriteArrayList": [[9, 28]]}}}, {"text": "While this should work, it's worth noting that using a stream is a bit of an overkill - you could just use List#sort(Comparator) directly", "label": {"api": {"List#sort(Comparator)": [[107, 127]]}}}, {"text": "Use a Scanner", "label": {"api": {"Scanner": [[6, 12]]}}}, {"text": "There is an overload for Collections.sort which will take in a Comparator, which will allow you to define the sort order for your items", "label": {"api": {"Collections.sort": [[25, 40]], "Comparator": [[63, 72]]}}}, {"text": "In this case, all you have to do is define your own implementation of the Comparator interface which does as you please", "label": {"api": {"Comparator": [[74, 83]]}}}, {"text": "There you go", "label": {"api": {"There you go": [[0, 11]]}}}, {"text": "And, from the Javadoc of Class.newInstance()", "label": {"api": {"the Javadoc of Class.newInstance()": [[10, 43]]}}}, {"text": "JTextField is a subclass of JTextComponent which has a setCaretColor(...) method you can use", "label": {"api": {"setCaretColor(...)": [[55, 72]]}}}, {"text": "Don't reinvent the wheel - let a Scanner do the heavy lifting for you", "label": {"api": {"Scanner": [[33, 39]]}}}, {"text": "You are probably looking for equals(Object o) (Oracle Doc) though I can't be sure from your description of the problem", "label": {"api": {"Oracle Doc": [[47, 56]]}}}, {"text": "Use a HashMap instead of an array to access these by key instead of index if you prefer", "label": {"api": {"HashMap": [[6, 12]]}}}, {"text": "Found the answer - I used the ProcessingEnvironment instance variable (in my AbstractProcessor subclass) to get javax.lang.model.util.Elements instance to perform really helpful Element/Type/Package access", "label": {"api": {"javax.lang.model.util.Elements": [[112, 141]]}}}, {"text": "Apparently the Types class has more helpful utility methods to handle generics", "label": {"api": {"Types": [[15, 19]]}}}, {"text": "You can use String.format(fmt, ...) read the format api docs", "label": {"api": {"format api docs": [[45, 59]]}}}, {"text": "A JavaFX Application class cannot have an constructor with arguments, as an instance is created when calling Application#launch() (see the life cycle of a JavaFX Application)", "label": {"api": {"the life cycle of a JavaFX Application": [[135, 172]]}}}, {"text": "The BigInteger(byte[]) constructor takes a byte array that's interpreted as a two's complement integer, and you can then use the add function to add the two", "label": {"api": {"BigInteger(byte[])": [[4, 21]]}}}, {"text": "Note that in problems involving factorials, overflow is a given and you may want to consider higher precision arithmetic such as BigInteger", "label": {"api": {"BigInteger": [[129, 138]]}}}, {"text": "You are confusion about LocalDate with LocalDateTime, LocalDateTime is used with Year, Month, Day with Times, like", "label": {"api": {"LocalDate": [[24, 32], [39, 47], [54, 62]], "LocalDateTime": [[39, 51], [54, 66]]}}}, {"text": "and LocalDate is used with Year, Monthand Day without Time, like", "label": {"api": {"LocalDate": [[4, 12]]}}}, {"text": "LocalDate to parse time text, like", "label": {"api": {"LocalDate": [[0, 8]]}}}, {"text": "Have a look at JTabbedPane#setSelectedIndex and JTabbedPane#getSelectedIndex", "label": {"api": {"JTabbedPane#setSelectedIndex": [[15, 42]], "JTabbedPane#getSelectedIndex": [[48, 75]]}}}, {"text": "From Pattern Documentation ; The (?!...) part means \"only match if the text following (hence", "label": {"api": {"Pattern Documentation": [[5, 25]]}}}, {"text": "Use Arrays::stream instead", "label": {"api": {"Arrays::stream": [[4, 17]]}}}, {"text": "Specifically, any object must be equal to itself, per the equals Javadoc", "label": {"api": {"equals Javadoc": [[58, 71]]}}}, {"text": "Since a hash code is required to be consistent with the behavior of the equals method, this applies to hashCode as well", "label": {"api": {"required to be consistent": [[21, 45]]}}}, {"text": "readLine() declares that it throws an IOException", "label": {"api": {"IOException": [[38, 48]]}}}, {"text": "From the documentation for PropertyChangeSupport.firePropertyChange", "label": {"api": {"documentation for PropertyChangeSupport.firePropertyChange": [[9, 66]]}}}, {"text": "Namely, while your use of java.util.ConcurrentHashMap guarantees thread safety within Map API calls, it does nothing to ensure that the mappings could not have changed in between invocations, such as between the time that you invoke containsKey and the time that you invoke put, or between the time that you invoke get and the time that you invoke put", "label": {"api": {"java.util.ConcurrentHashMap": [[26, 52]], "containsKey": [[233, 243]], "put": [[274, 276], [348, 350]], "get": [[315, 317]], "ConcurrentHashMap": [[36, 52]]}}}, {"text": "As of Java 8 (which your use of lambdas and streams indicates you are using), one option to rectify this problem is to make the check-existing + get + set sequence atomic via the compute API call", "label": {"api": {"put": [[182, 184]], "get": [[145, 147]], "compute API call": [[179, 194]], "compute": [[179, 185]]}}}, {"text": "compute allows you to provide a key and a lambda (or method reference) specifying how to mutate the value mapped to that key, and ConcurrentHashMap guarantees that the lambda, which encompasses your full check-and-set logic, will be executed atomically", "label": {"api": {"put": [[3, 5]], "compute": [[0, 6]], "ConcurrentHashMap": [[130, 146]]}}}, {"text": "On the javadoc, \"value-based\" has a link to this page, which explains in more details what it means", "label": {"api": {"this page": [[44, 52]]}}}, {"text": "From a processing point of you, using a reference defined by an fx:id is going to be more efficient than calling lookup()", "label": {"api": {"lookup()": [[113, 120]]}}}, {"text": ".distinct() is described in the javadoc as a stateful intermediate operation, so I'm assuming (although I'm still fairly new to streams) I should be able to supply some logic", "label": {"api": {".distinct()": [[0, 10]], "stateful intermediate operation": [[45, 75]]}}}, {"text": "The https://docs.oracle.com/javase/7/docs/api/java/awt/Image.html#getScaledInstance(int,%20int,%20int) is a good way to handle by the way", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/awt/Image.html#getScaledInstance(int,%20int,%20int)": [[4, 101]]}}}, {"text": "You can construct a File from the given pathname and loop over the File#getParent() chain", "label": {"api": {"File": [[20, 23], [67, 70]], "File#getParent()": [[67, 82]]}}}, {"text": "Just remember to resolve the given pathname using File#getCanonicalFile()", "label": {"api": {"File": [[50, 53], [67, 70]]}}}, {"text": "A SortedSet implementation can be used to do the job", "label": {"api": {"SortedSet": [[2, 10]]}}}, {"text": "Note that I used Class.getDeclaredFields(), not Class.getFields(), because the latter only processes public fields", "label": {"api": {"Class.getDeclaredFields()": [[17, 41]], "Class.getFields()": [[48, 64]]}}}, {"text": "A project-wide src/test/resources/logging.properties can be set specifically for unit testing via the java.util.logging.config.file System property using a single line in your @BeforeClass method", "label": {"api": {"java.util.logging.config.file": [[102, 130]]}}}, {"text": "In either case, class CompletableFuture may help", "label": {"api": {"CompletableFuture": [[22, 38]]}}}, {"text": "The non-abstract Pi class extends the abstract Number class, which has 4 abstract methods", "label": {"api": {"Number": [[47, 52]]}}}, {"text": "You might find String.split to be helpful", "label": {"api": {"String.split": [[15, 26]]}}}, {"text": "(see documentation https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html": [[19, 80]]}}}, {"text": "Have a look at the constructors of the KeyFrame class", "label": {"api": {"constructors of the KeyFrame class": [[19, 52]]}}}, {"text": "extracting substrings), use the Pattern class", "label": {"api": {"Pattern": [[32, 38]]}}}, {"text": "In this case, you can use ReadWriteLock in java", "label": {"api": {"ReadWriteLock": [[26, 38]]}}}, {"text": "A ReadWriteLock allows any number of threads to get the read lock, but to get the write lock, all the read locks have to be released", "label": {"api": {"ReadWriteLock": [[2, 14]]}}}, {"text": "As you can read from official Java documentation, the default close operation for JFrame is HIDE_ON_CLOSE, so your answer is correct", "label": {"api": {"official Java documentation": [[21, 47]]}}}, {"text": "A MouseMotionListener, such as the MouseMotionHandler used during rubber band selection in the example cited here, allows the view to be updated in its implementation of mouseDragged()", "label": {"api": {"MouseMotionListener": [[2, 20]]}}}, {"text": "The encoded public keys you're trying to read are not of the format expected by X509EncodedKeySpec", "label": {"api": {"X509EncodedKeySpec": [[80, 97]]}}}, {"text": "Then trying a simple main method (I implemented a CountDownLatch to have all my threads starting at the same time, it's not mandatory)", "label": {"api": {"CountDownLatch": [[50, 63]]}}}, {"text": "The hashCode method as stated in the Oracle Docs is a numeric representation of an object in Java", "label": {"api": {"hashCode": [[4, 11]]}}}, {"text": "So, it is not recommended to implement the equals method by comparing hash codes", "label": {"api": {"equals": [[43, 48]]}}}, {"text": "In most cases, your only certainty is that if two objects are equal using o1.equals(o2) then o1.hashCode() == o2.hashCode()", "label": {"api": {"hashCode": [[96, 103], [113, 120]], "equals": [[77, 82]]}}}, {"text": "In the equals method you can define a more complex logic for comparing two objects of the same class", "label": {"api": {"equals": [[7, 12]]}}}, {"text": "The code has \"DESede/CBC/NOPadding\", there is a typo, it should be \"DESede/CBC/NoPadding\", see Class Cipher", "label": {"api": {"Class Cipher": [[95, 106]]}}}, {"text": "Not to completely change your code or approach, using StringBuilder seems to work well", "label": {"api": {"StringBuilder": [[54, 66]]}}}, {"text": "You can use the static void setMargin(Node child, Insets value) method to do this", "label": {"api": {"the static void setMargin(Node child, Insets value) method": [[12, 69]]}}}, {"text": "This is the idea behind the BitSet class", "label": {"api": {"BitSet": [[28, 33]]}}}, {"text": "Since you are using the Hibernate-specific @Validated group validation annotation instead of the JSR-303/349/380 specification @Valid annotation, there may be some differences between the implementation you used (I'm guessing version 5, which conformed to API 1.1)", "label": {"api": {"@Valid": [[43, 48], [127, 132]]}}}, {"text": "See API for more details", "label": {"api": {"API": [[4, 6]]}}}, {"text": "If Process is not live start again, see API for more details", "label": {"api": {"API": [[40, 42]]}}}, {"text": "How about the startsWith() function", "label": {"api": {"startsWith()": [[14, 25]]}}}, {"text": "I'm thinking of using a List to hold all of the widths, then summing them in a for each loop", "label": {"api": {"List": [[24, 27]]}}}, {"text": "Yes, according to the javadocs it guarantees", "label": {"api": {"javadocs it guarantees": [[22, 43]]}}}, {"text": "You could use String#substring(int beginIndex) instead", "label": {"api": {"String#substring(int beginIndex)": [[14, 45]]}}}, {"text": "In Java 8, use thenComparing to easily chain comparisons", "label": {"api": {"thenComparing": [[15, 27]]}}}, {"text": "The poor one that the Date documentation refers you to, the Calendar class", "label": {"api": {"the Date documentation": [[18, 39]]}}}, {"text": "The LocalDate class offers methods getDayOfMonth(), getMonth(), getYear() and many others, and they give you the expected results", "label": {"api": {"getDay": [[35, 40]], "getMonth": [[52, 59]], "getYear": [[64, 70]]}}}, {"text": "If you want to understand what was going on (I would want that), see the documentation of its getDay, getMonth and getYear methods", "label": {"api": {"getDay": [[94, 99]], "getMonth": [[102, 109]], "getYear": [[115, 121]]}}}, {"text": "You need to use LinkedHashMap in order to retain the order of the elements (i.e., insertion order) and you can refer the below code to retrieve the first 10 elements from the loaded map object", "label": {"api": {"LinkedHashMap": [[16, 28]]}}}, {"text": "As per the JOptionPane API, if the user cancels the dialog, null is returned", "label": {"api": {"JOptionPane API": [[11, 25]]}}}, {"text": "Also, the above code uses Iterator to safely remove the objects from the list", "label": {"api": {"Iterator": [[26, 33]]}}}, {"text": "In order to avoid NoSuchElementException, you should always check whether there is more tokens with the help of StringTokenizer.hasMoreTokens()", "label": {"api": {"StringTokenizer.hasMoreTokens()": [[112, 142]]}}}, {"text": "Without having thought about the mathematics of this too deeply, it seems to me that you could just use the nextDouble method to generate a double within the desired range and then cast the result to float", "label": {"api": {"nextDouble": [[108, 117]]}}}, {"text": "On second thought, I would recommend using instead the short-circuiting allMatch() operation", "label": {"api": {"short-circuiting allMatch()": [[55, 81]]}}}, {"text": "A couple of methods of generating the shadowImage are demonstrated, one is a ColorAdjust effect on the original image, the other is generation of a shadow image using a PixelWriter", "label": {"api": {"ColorAdjust": [[77, 87]], "PixelWriter": [[169, 179]]}}}, {"text": "Your original solution of using a PixelWriter for everything with an appropriate algorithm for shadow generation is more elegant (if you can get it to work ;-)", "label": {"api": {"PixelWriter": [[34, 44]]}}}, {"text": "Inbuilt, JavaFX has a DropShadow effect, which is almost what you want, especially when you set the spread to 1 and the radius to 0, however, it just generates a single offset shadow image rather than a long shadow effect", "label": {"api": {"DropShadow": [[22, 31]]}}}, {"text": "Regarding question 1, I would rather subclass ReentrantLock and Condition, then override the signal and await methods, because with this approach, you lose anyway the possibility to use the keyword synchronized on method", "label": {"api": {"ReentrantLock": [[46, 58]], "Condition": [[64, 72]]}}}, {"text": "A big caveat in my opinion is that if you wish to use ReentrantLock and/or Condition, you are going to have to write new wrappers (which might not be straightforward), risking to introduce more complexity, and more issues", "label": {"api": {"ReentrantLock": [[54, 66]], "Condition": [[75, 83]]}}}, {"text": "The docs don't explicitly state that a ConcurrentModificationException will occur if you invoke Collection#size", "label": {"api": {"don't explicitly state": [[9, 30]]}}}, {"text": "The only real times it's thrown are described in ConcurrentModificationException itself", "label": {"api": {"are described in ConcurrentModificationException itself": [[32, 86]]}}}, {"text": "If you're really worried about this sort of thing, then be sure that the concrete implementation of your collection uses an approriate size() method, like ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[155, 175]]}}}, {"text": "You will have to use sql result set mapping which is part of JPA", "label": {"api": {"sql result set mapping": [[21, 42]]}}}, {"text": "While you can declare your variable volatile to solve the problem, the real solution would be using Object.wait and Object.notifyAll to handle the waiting period", "label": {"api": {"Object.wait": [[100, 110]], "Object.notifyAll": [[116, 131]]}}}, {"text": "You could implement part of this functionality yourself by using the NavigableSet interface (TreeSet being the standard implementation)", "label": {"api": {"NavigableSet": [[69, 80]]}}}, {"text": "This can be resolved (if you need to) by applying keepAlives on the socket", "label": {"api": {"keepAlives": [[50, 59]]}}}, {"text": "Java 8 alleviates some of the boilerplate for sorting by particular fields with Comparator.comparing", "label": {"api": {"Comparator.comparing": [[80, 99]]}}}, {"text": "You can read more about the JPEG metadata format in the documentation", "label": {"api": {"JPEG metadata format": [[28, 47]]}}}, {"text": "I can not yet make a statement about the efficiency, but, you may want to look into Stream.reduce", "label": {"api": {"Stream.reduce": [[84, 96]]}}}, {"text": "If you just want to see the byte array of your String encoded as UTF8 then simply use getBytes(Charset charset) method", "label": {"api": {"getBytes(Charset charset)": [[86, 110]]}}}, {"text": "I tried the various methods described in Date and Time Patterns, but the result is always the same", "label": {"api": {"Date and Time Patterns": [[41, 62]]}}}, {"text": "ImageIO.read() closes the stream, as indicated in the javadoc", "label": {"api": {"ImageIO.read()": [[0, 13]]}}}, {"text": "There is a count method in stream to do counts for you", "label": {"api": {"count": [[11, 15], [40, 44]]}}}, {"text": "If you want parallelisation, change .stream() to .parallelStream()", "label": {"api": {".stream()": [[36, 44]], ".parallelStream()": [[49, 65]]}}}, {"text": "The selectionModel.selectedItemProperty is a ReadOnlyObjectProperty<T> where T is the type of elements in the item list backing your TableView<T>", "label": {"api": {"selectionModel.selectedItemProperty": [[4, 38]], "item list": [[110, 118]]}}}, {"text": "If it is one parameter, then an InvalidationListener is being defined, if it is 3 parameters, then a ChangeListener is being defined", "label": {"api": {"ChangeListener": [[101, 114]], "InvalidationListener": [[32, 51]]}}}, {"text": "There are two addListener(...) methods as it is an overloaded method, one for a ChangeListener and another for an InvalidationListener", "label": {"api": {"ChangeListener": [[80, 93]], "InvalidationListener": [[114, 133]]}}}, {"text": "\"use a ChangeListener if you need to know the new value in the listener, otherwise use an InvalidationListener\"", "label": {"api": {"ChangeListener": [[7, 20]], "InvalidationListener": [[90, 109]]}}}, {"text": "Have fun and notice that I used a Swing Timer instead of the Util Timer you're using", "label": {"api": {"Swing Timer": [[34, 44]], "Util Timer": [[61, 70]]}}}, {"text": "The server side needs to open a ServerSocket; and wait for incoming clients to connect to it", "label": {"api": {"ServerSocket": [[32, 43]]}}}, {"text": "Simply use its writeUTF(String str) method", "label": {"api": {"writeUTF(String str)": [[15, 34]]}}}, {"text": "I am new to this asynchronous topic and I have seen alrady some people are using CountDownLatch", "label": {"api": {"CountDownLatch": [[81, 94]]}}}, {"text": "It could be achieved with a XmlAdapter", "label": {"api": {"XmlAdapter": [[28, 37]]}}}, {"text": "Don't place your items in a StackPane if you want to explicitly define their layout positions (setX and setY)", "label": {"api": {"StackPane": [[28, 36]], "Pane": [[33, 36]]}}}, {"text": "A StackPane is a managed layout pane", "label": {"api": {"StackPane": [[2, 10]], "Pane": [[7, 10]]}}}, {"text": "It will automatically set the location of items added to it (default is to center everything one on top of the other inside the StackPane)", "label": {"api": {"StackPane": [[128, 136]], "Pane": [[133, 136]]}}}, {"text": "Instead use a Pane or a Group, which are not managed layout panes and allow you to layout your content in the Pane however you wish", "label": {"api": {"Pane": [[14, 17], [110, 113]], "Group": [[24, 28]]}}}, {"text": "To layout your content inside the Pane, you can use setLayoutX and setLayoutY rather than setX and setY, though I guess setX and setY should also work (I've never used them before on ImageView)", "label": {"api": {"Pane": [[34, 37]], "setLayoutX": [[52, 61]], "setLayoutY": [[67, 76]]}}}, {"text": "If you however want for whatever reason to position a item in a StackPane you can use setTranslateX and setTranslateY", "label": {"api": {"setTranslateX": [[86, 98]], "setTranslateY": [[104, 116]]}}}, {"text": "EnumSet), and your X class might look like", "label": {"api": {"EnumSet": [[0, 6]]}}}, {"text": "If you want to do lexical analysis, you have a StreamTokenizer in Java but it's quite limited", "label": {"api": {"StreamTokenizer in Java": [[47, 69]]}}}, {"text": "You haven't specified append=true in the constructor of FileOutputStream, so the last process to run (number 2) will overwrite the content written by the previous one", "label": {"api": {"constructor": [[41, 51]]}}}, {"text": "You can use a FileLock", "label": {"api": {"FileLock": [[14, 21]]}}}, {"text": "Use java.lang.Double.compare to compare double primitives for equals methods", "label": {"api": {"java.lang.Double.compare": [[4, 27]]}}}, {"text": "Using the Collectors class (example is just copy and pasted from there)", "label": {"api": {"Collectors": [[10, 19]]}}}, {"text": "Replace your awt code with the JavaFX Screen class", "label": {"api": {"Screen": [[38, 43]]}}}, {"text": "See docs Class PropertyResourceBundle", "label": {"api": {"Class PropertyResourceBundle": [[9, 36]]}}}, {"text": "Map.get isn't a generic method", "label": {"api": {"Map.get": [[0, 6]]}}}, {"text": "if you are using Java 8 or later, you can use LocalDate", "label": {"api": {"LocalDate": [[46, 54]]}}}, {"text": "The LocalDate class represents a date-only value without time-of-day and without time zone", "label": {"api": {"LocalDate": [[4, 12]]}}}, {"text": "This should work if you use ResultSet.getObject(index) to populate the table", "label": {"api": {"ResultSet.getObject(index)": [[28, 53]]}}}, {"text": "A static invocation of Thread.sleep..", "label": {"api": {"Thread.sleep": [[23, 34]]}}}, {"text": "That's why you need to catch InterruptedException when invoking Thread.sleep, as the thread might be interrupted while sleeping, e.g", "label": {"api": {"Thread.sleep": [[64, 75]]}}}, {"text": "You can use JDK's Collections#newSetFromMap(Map<K, Boolean>)", "label": {"api": {"Collections#newSetFromMap(Map<K, Boolean>)": [[18, 59]]}}}, {"text": "You could use Class.cast", "label": {"api": {"Class.cast": [[14, 23]]}}}, {"text": "What you need is a Mutable Reduction, which can be implemented via Collector.of(…) like it has been already implemented with the prebuilt collectors Collectors.toList(), Collectors.toSet(), etc", "label": {"api": {"Mutable Reduction": [[19, 35]]}}}, {"text": "The problem is that you pass in the result of the push method, which is not a Stack<Carte>, but a Carte", "label": {"api": {"push": [[50, 53]]}}}, {"text": "As of Java 8, one option is to wrap your Long in an java.util.Optional", "label": {"api": {"java.util.Optional": [[52, 69]]}}}, {"text": "Unfortunately, the Number base class doesn't have a sum method, so you can't do this directly", "label": {"api": {"Number": [[19, 24]]}}}, {"text": "What you could do, however, is call doubleValue() on each Number you receive, and sum them as a doubles", "label": {"api": {"Number": [[58, 63]]}}}, {"text": "From http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T- but the same language is in Comparator", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-": [[5, 83]]}}}, {"text": "When you call split(\",\"), trailing empty strings are discarded, which leaves you with an empty array", "label": {"api": {"split(\",\")": [[14, 23]]}}}, {"text": "One solution is to call split(\",\", -1), which preserves trailing empty strings", "label": {"api": {"split(\",\", -1)": [[24, 37]]}}}, {"text": "SortedMap may be your best bet", "label": {"api": {"SortedMap": [[0, 8]]}}}, {"text": "On the other hand, simple insertion as implemented in Java (ArrayList.add()) will only take O(1) because the element is appended to the end of the array, so no shift is required", "label": {"api": {"ArrayList.add()": [[60, 74]]}}}, {"text": "you create own custom Comparator", "label": {"api": {"Comparator": [[22, 31]]}}}, {"text": "For example the java.util.zip.ZipOutputStream class allows to create a zip with a specific level of compression by invoking the setLevel(int level) method", "label": {"api": {"java.util.zip.ZipOutputStream": [[16, 44]]}}}, {"text": "You can use removeAll to remove all elements that are present in another collection", "label": {"api": {"removeAll": [[12, 20]]}}}, {"text": "then use removeAll as I mentioned", "label": {"api": {"removeAll": [[9, 17]]}}}, {"text": "Try the following, but use Java 8 and the java.time API instead", "label": {"api": {"java.time": [[42, 50]]}}}, {"text": "Note that setActionCommand is a method  from AbstractButton, and also works for JButton for instance", "label": {"api": {"AbstractButton": [[45, 58]]}}}, {"text": "As with all Regions you can set the minWidth property", "label": {"api": {"the minWidth property": [[32, 52]]}}}, {"text": "All layouts will lay out an invisible node as if it is visible", "label": {"api": {"invisible": [[28, 36]]}}}, {"text": "You can use an invisible Label as a “strut” by making it invisible and placing it, along with your visible node, in a StackPane", "label": {"api": {"invisible": [[15, 23], [57, 65]]}}}, {"text": "Another option is to simply make your value Label invisible instead of making its text empty, but I realize there are circumstances where that may not be possible, such as if the Label’s text property is bound", "label": {"api": {"invisible": [[50, 58]]}}}, {"text": "Assuming you are using this implementation of JSONArray..", "label": {"api": {"this implementation": [[23, 41]]}}}, {"text": "Just call the stream() method which is inherited by all classes implementing Collection", "label": {"api": {"stream()": [[14, 21]]}}}, {"text": "If you want your thread to be terminated, you should invoke setDaemon method on the thread", "label": {"api": {"setDaemon": [[60, 68]]}}}, {"text": "This is well documented and completely normal", "label": {"api": {"well documented": [[8, 22]]}}}, {"text": "If you want all threads to terminate before the main thread exists, you need to Thread.join() them", "label": {"api": {"Thread.join()": [[80, 92]]}}}, {"text": "Note that Runtime.exit() terminates threads quite harshly", "label": {"api": {"Runtime.exit()": [[10, 23]]}}}, {"text": "You could just chain the futures together directly using the CompletableFuture.handle() method", "label": {"api": {"CompletableFuture.handle()": [[61, 86]]}}}, {"text": "The variable filter is an instance of an anonymous class implementing interface Filter, the interface Filter has only one method so in Java 8 it's a functional interface, and the initialisation code above can be shortened by lambda expression in Java 8 to", "label": {"api": {"functional interface": [[149, 168]]}}}, {"text": "You'll have to use something smarter, like a BigInteger", "label": {"api": {"BigInteger": [[45, 54]]}}}, {"text": "To deal with big numbers you can use the BigInteger class", "label": {"api": {"BigInteger": [[41, 50]]}}}, {"text": "The onHidden and onHiding properties are EventHandler<Event>, not EventHandler<ActionEvent>", "label": {"api": {"onHidden": [[4, 11]], "onHiding": [[17, 24]]}}}, {"text": "Just change the parameter type for the onHidden and onHiding handler methods to Event", "label": {"api": {"onHidden": [[39, 46]], "onHiding": [[52, 59]]}}}, {"text": "This method will also throw an IO Exception should there be a problem accessing the supplied data file", "label": {"api": {"IO Exception": [[31, 42]]}}}, {"text": "Like  Oscar Martinez said, you could read a string of numbers delimited by white space and build your integer array like this example (before parsing the string to int, I verify if the string can be converted to int or not using a regex )", "label": {"api": {"regex": [[231, 235]]}}}, {"text": "In Java 8, there are functions like Integer.toUnsignedLong(int) or Integer.divideUnsigned(...) (Java 8 Class Integer) but unfortunately I cannot use this version of Java", "label": {"api": {"Java 8 Class Integer": [[96, 115]]}}}, {"text": "To remove or change default character that appears instead of letters use JPasswordField#setEchoChar(char c) method", "label": {"api": {"JPasswordField#setEchoChar(char c)": [[74, 107]]}}}, {"text": "NoSuchElementException is thrown by LinkedList.getFirst when the list is empty", "label": {"api": {"NoSuchElementException": [[0, 21]], "LinkedList.getFirst": [[36, 54]]}}}, {"text": "This means your calling scope would need to handle/rethrow that exception from the constructor, or you could choose to suppress the exception rather than throwing it", "label": {"api": {"suppress the exception": [[119, 140]]}}}, {"text": "Could someone please help me understand the significance of radix in the Character.forDigit(int digit, int radix) method", "label": {"api": {"Character.forDigit(int digit, int radix)": [[73, 112]]}}}, {"text": "Would there be anything wrong with using String#matches() here", "label": {"api": {"String#matches()": [[41, 56]]}}}, {"text": "How to insert and fetch java.time types such as LocalDate via JDBC to an SQL database such as the H2 Database Engine", "label": {"api": {"java.time": [[24, 32]], "LocalDate": [[48, 56]]}}}, {"text": "The old way using PreparedStatement::setDate and ResultSet::getDate works for the legacy java.sql.Date type", "label": {"api": {"PreparedStatement::setDate": [[18, 43]], "ResultSet::getDate": [[49, 66]], "java.sql.Date": [[89, 101]]}}}, {"text": "What is the modern way for sending java.time types through a JDBC driver", "label": {"api": {"java.time": [[35, 43]]}}}, {"text": "Annotation processors can use Elements#getTypeElement to interospect compiled classes as well as source-defined classes", "label": {"api": {"Elements#getTypeElement": [[30, 52]]}}}, {"text": "So, concepts to study would be ExecutorServices and things like Future", "label": {"api": {"Future": [[64, 69]]}}}, {"text": "Read the docs, https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[15, 87]]}}}, {"text": "For whole-day events, the best representation in Java 8+ is LocalDate", "label": {"api": {"LocalDate": [[60, 68]]}}}, {"text": "LocalDate, on the other hand, has equals() and hashCode() implemented to suit exactly your use case", "label": {"api": {"LocalDate": [[0, 8]]}}}, {"text": "If GigaSpaces is calling LogManager.reset(), then one hacky, smelly, dirty way to get around removing your handler is to extend FileHandler and override equals", "label": {"api": {"LogManager.reset()": [[25, 42]]}}}, {"text": "Ideally, I'd design the map so that you can pass in a custom IntFunction as hashing strategy", "label": {"api": {"IntFunction": [[61, 71]]}}}, {"text": "You may even want to use an IntBinaryOperator, where one param is the int and the other is the number of buckets", "label": {"api": {"IntBinaryOperator": [[28, 44]]}}}, {"text": "Use reflection to iterate over the fields", "label": {"api": {"fields": [[35, 40]]}}}, {"text": "Use add() from ArrayList to push_back", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "I need to port Character.isJavaIdentifierStart method to javascript/typescript", "label": {"api": {"Character.isJavaIdentifierStart": [[15, 45]]}}}, {"text": "Assuming request is an Optional ifPresent consumes a value and returns void", "label": {"api": {"ifPresent": [[32, 40]]}}}, {"text": "DatatypeConverter.parseBase64Binary is specified to parse the XML Schema xsd:base64Binary type, which requires output padding", "label": {"api": {"DatatypeConverter.parseBase64Binary": [[0, 34]]}}}, {"text": "Either use a different decoder (Java 8 has java.util.Base64, Apache Commons.Codec has one, Guava has one too), or pad the output yourself (if length of string after removing all non-Base64 characters is not divisible by 4, pad with '=' until it is)", "label": {"api": {"java.util.Base64": [[43, 58]]}}}, {"text": "You will need to add something like the ExpiresFilter to your servlet container", "label": {"api": {"Filter": [[47, 52]]}}}, {"text": "If you need a more portable approach for use in different application servers, you might end up writing a generic servlet Filter like I did", "label": {"api": {"Filter": [[122, 127]]}}}, {"text": "max-age headers for HttpServletRequests on your given paths", "label": {"api": {"HttpServletRequests": [[20, 38]]}}}, {"text": "How about the following program using bunch of replaceAll methods and lookbehinds", "label": {"api": {"replaceAll": [[47, 56]], "lookbehind": [[70, 79]]}}}, {"text": "The one method returns a single char value (primitive type); the other one returns a String (reference type)", "label": {"api": {"char value": [[32, 41]], "String": [[85, 90]]}}}, {"text": "But that doesn't make a char the same as a String", "label": {"api": {"String": [[43, 48]]}}}, {"text": "You may check the String documentation, it has a lot of methods to do this", "label": {"api": {"String": [[18, 23]]}}}, {"text": "Use Collectors.groupingBy with a downstream collector which gets the second part of the split line before collecting to a list", "label": {"api": {"Collectors.groupingBy": [[4, 24]]}}}, {"text": "SecurityManager has getClassContext(), but that just gives me the class of the instance - I want the instance itself", "label": {"api": {"SecurityManager has getClassContext()": [[0, 36]]}}}, {"text": "The reference for Java's regex syntax is the Javadoc for class Pattern", "label": {"api": {"Pattern": [[63, 69]]}}}, {"text": "If you are using java 8 then DateTimeFormatter is what you are looking for", "label": {"api": {"DateTimeFormatter": [[29, 45]]}}}, {"text": "call classField.get(Object obj)", "label": {"api": {"classField.get(Object obj)": [[5, 30]]}}}, {"text": "I took the reference of the Java 6 documentation (https://docs.oracle.com/javase/6/docs/api/java/io/File.html)", "label": {"api": {"https://docs.oracle.com/javase/6/docs/api/java/io/File.html": [[50, 108]]}}}, {"text": "Any time the user makes any change to the editor (more specifically to the underlying model object); you set that property to true", "label": {"api": {"model": [[86, 90]]}}}, {"text": "You can use Double.parseDouble for this purpose", "label": {"api": {"Double.parseDouble": [[12, 29]]}}}, {"text": "The Java 8 Base64 library has two variants that can be used in URI building", "label": {"api": {"Base64": [[11, 16]]}}}, {"text": "Then, in Java 8 we can define an array of Suppliers", "label": {"api": {"Supplier": [[42, 49]]}}}, {"text": "Look at the methods valueOf(LocalTime) and toLocalTime() in that class", "label": {"api": {"valueOf(LocalTime)": [[20, 37]], "toLocalTime()": [[43, 55]]}}}, {"text": "You will have to create a new thread which will run your loop, the ExecutorService will run this loop (or whatever code you put into the call() method) for the specified amount of time", "label": {"api": {"ExecutorService": [[67, 81]]}}}, {"text": "For example, the javax.swing.Timer class can be used, which fires ActionEvent notifications after the expiry of the timer", "label": {"api": {"javax.swing.Timer": [[17, 33]]}}}, {"text": "Yet, another example, this time with try-with-resources and using the Files class to create the BufferedWriter", "label": {"api": {"Files class": [[70, 80]]}}}, {"text": "You can also use the Files.write method", "label": {"api": {"Files.write": [[21, 31]]}}}, {"text": "Run a new program with ProcessBuilder", "label": {"api": {"ProcessBuilder": [[23, 36]]}}}, {"text": "Try sorting the dogs by breed and rank and then do a for-loop to add them in the dogsTotal", "label": {"api": {"sorting": [[4, 10]]}}}, {"text": "There are nice abstraction concepts, like ExecutorService and things like Futures and Promises", "label": {"api": {"ExecutorService": [[42, 56]]}}}, {"text": "one can use dependency injection to provide such an ExecutorService to the production code; and then you can define your own service ..", "label": {"api": {"ExecutorService": [[52, 66]]}}}, {"text": "You should synchronize access to your count variable, or use an AtomicInteger or LongAdder instead of an int", "label": {"api": {"AtomicInteger": [[64, 76]], "LongAdder": [[81, 89]]}}}, {"text": "You are forgetting to seek (set the file pointer) back to the start of the file after writing to it, so it will try to read from the end of the file", "label": {"api": {"seek (set the file pointer)": [[22, 48]]}}}, {"text": "In this case I would recommend you to have a look at the peek method", "label": {"api": {"peek": [[57, 60]]}}}, {"text": "Use Matcher.find() method to match parts of the test string and then Matcher.group() method to access the parts captured by the round brackets", "label": {"api": {"Matcher.find()": [[4, 17]]}}}, {"text": "A non-zero value determines the JDBC fetch size (calls Statement.setFetchSize())", "label": {"api": {"Statement.setFetchSize()": [[55, 78]]}}}, {"text": "As i told in my comment you can use java.util.hashmap for this", "label": {"api": {"java.util.hashmap": [[36, 52]]}}}, {"text": "You can make a HashMap for storing the frequency", "label": {"api": {"HashMap": [[15, 21]]}}}, {"text": "Check out the javax.xml.transform package", "label": {"api": {"javax.xml.transform": [[14, 32]]}}}, {"text": "Your entry point for obtaining a transformer will be the TransformerFactory class", "label": {"api": {"TransformerFactory class": [[57, 80]]}}}, {"text": "The parameter value can then be supplied using method setParameter on a Transformer", "label": {"api": {"setParameter on a Transformer": [[54, 82]]}}}, {"text": "The correct way to redirect to a file is with the redirectOutput method", "label": {"api": {"redirectOutput": [[50, 63]]}}}, {"text": "Override toString and equals in the SuperWapen class", "label": {"api": {"toString": [[9, 16]], "equals": [[22, 27]]}}}, {"text": "Use skip(1) to ignore the first element", "label": {"api": {"skip(1)": [[4, 10]]}}}, {"text": "The PropertyValueFactory implementation will trigger the update notification (and subsequent update to a value in a cell in the table), whenever the property is changed", "label": {"api": {"PropertyValueFactory": [[4, 23]]}}}, {"text": "You can do that by running any updates using Platform.runLater()", "label": {"api": {"Platform.runLater()": [[45, 63]]}}}, {"text": "This is to ensure that when if you have other threads updating AnotherClass.listings values, it doesn't have a side effect of trying to update your table through the linkage established via the PropertyValueFactory", "label": {"api": {"PropertyValueFactory": [[194, 213]]}}}, {"text": "To understand how to achieve that you can look the Task documentation sections about tasks which return ObservableLists, Partial Results Tasks and Tasks which modify the Scene Graph and will likely need to use some combination of the idioms described in those samples to achieve the result you require", "label": {"api": {"Task documentation": [[51, 68]]}}}, {"text": "Try splitting it into two parts using String#split", "label": {"api": {"String#split": [[38, 49]]}}}, {"text": "You should read the Java API for useful functions", "label": {"api": {"the Java API": [[16, 27]]}}}, {"text": "If you look at the Javadocs for Comparable, https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html, how many abstract methods do you see documented there", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html": [[44, 110]]}}}, {"text": "If you want to actually maintain a sorted collection, then you can look into things like a SortedSet such as TreeSet", "label": {"api": {"SortedSet": [[91, 99]], "TreeSet": [[109, 115]]}}}, {"text": "Now use this custom comparator to sort your list with the Collections.sort utility", "label": {"api": {"Collections.sort": [[58, 73]]}}}, {"text": "If you also want to remove a leading or trailing space which might be leftover, you can use String.trim() for that", "label": {"api": {"String.trim()": [[92, 104]]}}}, {"text": "You can sort it in numerical order by passing a custom Comparator to the sort() method", "label": {"api": {"Comparator": [[55, 64]], "sort()": [[73, 78]]}}}, {"text": "In java 8, you can use Comparator.comparingInt() to do the actual comparision, in combination with the Integer.parseInt() method to perform the conversion from string to int", "label": {"api": {"Comparator": [[23, 32]], "Comparator.comparingInt()": [[23, 47]], "Integer.parseInt()": [[103, 120]]}}}, {"text": "Like mentioned by @Radiodef using AtomicBoolean can relieve you of most of the synchronisation if used properly", "label": {"api": {"AtomicBoolean": [[34, 46]]}}}, {"text": "Get a synchronisation object from the java concurrent package", "label": {"api": {"concurrent package": [[43, 60]]}}}, {"text": "More light reading on the AtomicBoolean object", "label": {"api": {"AtomicBoolean": [[26, 38]]}}}, {"text": "Collections.max returns the maximum element of the given collection", "label": {"api": {"Collections.max": [[0, 14]]}}}, {"text": "First of all you can use AccessController.doPriviledged() inside the task running on the ForkJoinPool", "label": {"api": {"AccessController.doPriviledged()": [[25, 56]]}}}, {"text": "Finally, use DownloadService service implementation to load jar file resource when needed", "label": {"api": {"DownloadService": [[13, 27]]}}}, {"text": "FilmEntry itself should already be an Enum (see tutorial) with a custom toString() method", "label": {"api": {"Enum": [[38, 41]]}}}, {"text": "Just use a String Tokenizer or, if you know where the substrings are, use .substring(int start,int end)", "label": {"api": {"String Tokenizer": [[11, 26]]}}}, {"text": "If you want to work with timezones on an object level you might have a look into ZonedDateTime", "label": {"api": {"ZonedDateTime": [[81, 93]]}}}, {"text": "JList is backed by a ListModel<E> instance", "label": {"api": {"ListModel<E>": [[21, 32]]}}}, {"text": "an extension of AbstractListModel", "label": {"api": {"AbstractListModel": [[16, 32]]}}}, {"text": "To display the ToDos in a meaningful way in the List, create a toString() implementation on your ToDo class (JList will call that to get a string representation of your object), or supply your own ListCellRenderer to the JList instance", "label": {"api": {"supply your own ListCellRenderer to the JList instance": [[181, 234]]}}}, {"text": "If you need to re-sort, make sure your ListModel implementation correctly notifies the JList each time it changes the order", "label": {"api": {"notifies": [[74, 81]]}}}, {"text": "rather than implement your own sort, use Collections.sort(todos)", "label": {"api": {"Collections.sort(todos)": [[41, 63]]}}}, {"text": "In order to sort your list appropriately, you will need ToDo to implement Comparable<ToDo>", "label": {"api": {"Comparable<ToDo>": [[74, 89]]}}}, {"text": "Sometimes this is good enough but often you will need better control over things, this is when classes like ReentrantLock come handy", "label": {"api": {"ReentrantLock": [[108, 120]]}}}, {"text": "What you are looking for is probably javax.enterprise.util.TypeLiteral", "label": {"api": {"javax.enterprise.util.TypeLiteral": [[37, 69]]}}}, {"text": "Using Map's replaceAll method should suffice", "label": {"api": {"replaceAll": [[12, 21]]}}}, {"text": "This utilizes the Collections.sort method, which takes a list and a comparator", "label": {"api": {"Collections.sort": [[18, 33]]}}}, {"text": "If you want to run these as separate threads, you need to call the Thread.start() method", "label": {"api": {"Thread.start()": [[67, 80]]}}}, {"text": "As an aside, usually you can just subclass Runnable rather than Thread", "label": {"api": {"Runnable": [[43, 50]]}}}, {"text": "Then you can choose to pass your Runnable to the Thread(Runnable) constructor -- or to an ExecutorService", "label": {"api": {"Runnable": [[33, 40], [56, 63]], "ExecutorService": [[90, 104]]}}}, {"text": "You could use a Map, for example a HashMap, where you use the words as keys and the number of their occurrence as values", "label": {"api": {"HashMap": [[35, 41]]}}}, {"text": "java doc of those two methods has great explanation about it", "label": {"api": {"java doc of those two methods": [[0, 28]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html with a code example", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html": [[0, 80]]}}}, {"text": "The select* methods of the Bindings class are made for this", "label": {"api": {"select* methods": [[4, 18]]}}}, {"text": "TimeUnit is an enum, with values like SECONDS, HOURS, MINUTES etc (here's javadoc) so you can configure different time units", "label": {"api": {"here's": [[67, 72]]}}}, {"text": "The Thread.destroy() method would have done that, but it was never implemented, and its documentation explains why it would be unsafe to use even if it worked", "label": {"api": {"Thread.destroy()": [[4, 19]], "destroy": [[11, 17]]}}}, {"text": "There are some other deprecated methods like Thread.stop() and Thread.suspend() which may actually work, but they're also unsafe to use; again, their documentation explains why", "label": {"api": {"Thread.stop()": [[45, 57]], "Thread.suspend()": [[63, 78]]}}}, {"text": "As an workaround, you could run your task in an entirely separate process, so that you can destroy it when you want it to stop", "label": {"api": {"process": [[66, 72]], "destroy": [[91, 97]]}}}, {"text": "That is safe, since processes are isolated from each other and destroying the child process can't leave the parent process in an unstable state", "label": {"api": {"process": [[20, 26], [84, 90], [115, 121]], "destroy": [[63, 69]]}}}, {"text": "Interacting with a separate process is more difficult, though, since you can't share variables between processes like you can with threads", "label": {"api": {"process": [[28, 34], [103, 109]]}}}, {"text": "You'd need to send messages through the process's input and output streams", "label": {"api": {"process": [[40, 46]]}}}, {"text": "poll removes the head of the queue, use peek instead", "label": {"api": {"poll removes the head": [[0, 20]]}}}, {"text": "If you want to make output result looks like table, you have to use java.util.Formatter", "label": {"api": {"java.util.Formatter": [[68, 86]]}}}, {"text": "You can just use String#substring method", "label": {"api": {"String#substring": [[17, 32]]}}}, {"text": "If you were just looking to open the file from within your java application, then you could use Desktop.open(fileName) or even a simple Runtime.exec(fileName)", "label": {"api": {"Desktop.open(fileName)": [[96, 117]], "Runtime.exec(fileName)": [[136, 157]]}}}, {"text": "An Exchanger may be viewed as a bidirectional form of a SynchronousQueue", "label": {"api": {"SynchronousQueue": [[56, 71]]}}}, {"text": "The Concurrent Collections section in the javadoc for package java.util.concurrent says", "label": {"api": {"java.util.concurrent": [[62, 81]]}}}, {"text": "There is a fundamental difference between the ClassNotFoundException which the ClassLoader uses to report an absent class immediately when a loadClass attempt is made and the subtypes of LinkageError which are thrown when the class has been found, but structural constraints are violated or dependencies could not be resolved", "label": {"api": {"LinkageError": [[187, 198]]}}}, {"text": "These subtypes of LinkageError (which includes NoClassDefFoundError) might be even thrown at a much later time, due to the lazy resolving/verification", "label": {"api": {"LinkageError": [[18, 29]]}}}, {"text": "So in your case, a class file has been loaded, apparently because your operating system or file system is not case sensitive, but the NoClassDefFoundError has been thrown within defineClass due to the mismatching name (note that this method takes the expected name as parameter)", "label": {"api": {"defineClass": [[178, 188]]}}}, {"text": "More information about lookaround assertions and non-capturing groups can be found in the javadoc of the Pattern class", "label": {"api": {"javadoc of the Pattern class": [[90, 117]]}}}, {"text": "You can use String.matches() method to test if the second string matches the splitted one from the first string", "label": {"api": {"String.matches()": [[12, 27]]}}}, {"text": "You can use the Collectors.groupingBy variant that takes a mapFactory as an argument", "label": {"api": {"Collectors.groupingBy": [[16, 36]]}}}, {"text": "in such case use InheritableThreadLocal to store information", "label": {"api": {"InheritableThreadLocal": [[17, 38]]}}}, {"text": "consider too, using equalsIgnoreCase so you have no problem to accept case variant inputs from the user...", "label": {"api": {"equalsIgnoreCase": [[20, 35]]}}}, {"text": "If you want the keys to be in ascending order, use an implementation of SortedMap, like TreeMap", "label": {"api": {"TreeMap": [[88, 94]]}}}, {"text": "In addition to what @AndyTurner stated about HashMap not guaranteeing order, it appears that TreeMap provides the functionality you are looking for", "label": {"api": {"TreeMap": [[93, 99]]}}}, {"text": "It does not specifies any methods (see the documentation)", "label": {"api": {"not specifies any methods (see the documentation)": [[8, 56]]}}}, {"text": "Object has a Object clone() method itself (that raises an error)", "label": {"api": {"Object clone()": [[13, 26]]}}}, {"text": "In this case super.clone() will thus throw the CloneNotSupportedException since in the specifications of Object.clone()", "label": {"api": {"specifications of Object.clone()": [[87, 118]]}}}, {"text": "Your particular issue comes from the use of a SynchronousQueue, as the documentation mentions", "label": {"api": {"SynchronousQueue": [[46, 61]]}}}, {"text": "So if you replace this by a LinkedBlockingQueue, it actually works", "label": {"api": {"LinkedBlockingQueue": [[28, 46]]}}}, {"text": "What you can use however, regarding Executors, is a Executors.newSingleThreadExecutor as it uses at top one thread to execute task", "label": {"api": {"Executors.newSingleThreadExecutor": [[52, 84]]}}}, {"text": "The best advice I can give you is to use a collection in the java.util.concurrent package and passing that collection along to your methods", "label": {"api": {"package": [[82, 88]]}}}, {"text": "The new date and time classes in java.time generally don’t come with the surprises experienced with the old ones", "label": {"api": {"java.time": [[33, 41]]}}}, {"text": "The context is missing, if you mean background color in Swing component (e.g JFrame, JPanel) they have methods getBackground() or setBackground(Color)", "label": {"api": {"Color": [[144, 148]]}}}, {"text": "Color in java have lot of methods for return Color type eg", "label": {"api": {"Color": [[0, 4], [45, 49]]}}}, {"text": "I couldn't get my way around with LocalDateTime, ZonedDateTime and so on, so I decided to go with Instant and it worked fine", "label": {"api": {"Instant": [[98, 104]]}}}, {"text": "A java string containing special chars such as ç takes two bytes of size in each special char, but String length method or getting the length of it with the byte array returned from getBytes method doesn't return special chars counted as two bytes", "label": {"api": {"String length method": [[99, 118]], "getBytes method": [[182, 196]]}}}, {"text": "The key points here are the use of toMap() to collect by userid and flatmap() to turn a Stream<List<SomeObject>> into a Stream<SomeObject> so you can collect them into one collection", "label": {"api": {"toMap()": [[35, 41]], "flatmap()": [[68, 76]]}}}, {"text": "To ensure that all characters are digits, you may want to use Character.isDigit just before your switch statement", "label": {"api": {"Character.isDigit": [[62, 78]]}}}, {"text": "Why you simply don't use String::endsWith", "label": {"api": {"String::endsWith": [[25, 40]]}}}, {"text": "That is supposed to return a WritableRaster ..", "label": {"api": {"WritableRaster": [[29, 42]]}}}, {"text": "That class is using from getDataBuffer() from the Raster class; and there we find", "label": {"api": {"getDataBuffer()": [[25, 39]]}}}, {"text": "You need the cast because you are overriding Object#clone(), which dates back to pre-generics JDK1.0 and has a return type of Object", "label": {"api": {"Object#clone()": [[45, 58]]}}}, {"text": "when you turn to the javadoc for that DefaultTableModel you will find", "label": {"api": {"DefaultTableModel": [[38, 54]]}}}, {"text": "no need to change your code; when the goal of your code is to create such a DefaultTableModel object", "label": {"api": {"DefaultTableModel": [[76, 92]]}}}, {"text": "You can parse it once and store the results in a ThreadLocal or InheritableThreadLocal if you create new threads", "label": {"api": {"ThreadLocal": [[49, 59], [75, 85]]}}}, {"text": "Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist)", "label": {"api": {"ThreadLocal": [[118, 128]]}}}, {"text": "Once you've got that working, you should look into the AffineTransform class, which will allow you a lot more options", "label": {"api": {"AffineTransform": [[55, 69]]}}}, {"text": "If you are interested in the transition rules then the following may help you", "label": {"api": {"transition rules": [[29, 44]]}}}, {"text": "The ZoneDateTime javadoc also contains some hints regarding the \"gap\" and \"overlap\" and the corresponding offsets", "label": {"api": {"The ZoneDateTime javadoc": [[0, 23]]}}}, {"text": "If you are only interested in whether your time is a daylight saving's time or not, isDaylightSavings(Instant) might help you", "label": {"api": {"isDaylightSavings(Instant)": [[84, 109]]}}}, {"text": "Jackson uses the Class#getDeclaredConstructor() with no argument (method accepts vararg) witch means", "label": {"api": {"Class#getDeclaredConstructor()": [[17, 46]]}}}, {"text": "If you need to include the response generated by another servlet, call request.getRequestDispatcher(\"path to include\").include()", "label": {"api": {"request.getRequestDispatcher(\"path to include\").include()": [[71, 127]]}}}, {"text": "If you need to pass the request to another thread, use request.getRequestDispatcher(\"path to forward\").forward()", "label": {"api": {"request.getRequestDispatcher(\"path to forward\").forward()": [[55, 111]]}}}, {"text": "However, if you are on Java-7, then you could set up your own DateFormatSymbolsProvider specialized for Armenian language via the service loader mechanism", "label": {"api": {"DateFormatSymbolsProvider": [[62, 86]], "service loader mechanism": [[130, 153]]}}}, {"text": "For Spring version 4.1+ you can use Java 8 Optional for declaring optional dependencies", "label": {"api": {"Optional": [[43, 50]]}}}, {"text": "So if no bean of type Transmission is found then Optional.empty() is injected", "label": {"api": {"Optional": [[49, 56]]}}}, {"text": "You may want to just call submit on your ExecutorService and be fine, e.g", "label": {"api": {"submit": [[26, 31]], "ExecutorService": [[41, 55]]}}}, {"text": "You may also want to look into Executors javadoc and follow the documentation there", "label": {"api": {"Executors javadoc": [[31, 47]]}}}, {"text": "it is just a wrapper and offers two constructors, one accepting a Callable and one a Runnable", "label": {"api": {"accepting a Callable": [[54, 73]]}}}, {"text": "See the FutureTask get documentation", "label": {"api": {"FutureTask get documentation": [[8, 35]]}}}, {"text": "suppressing the given exceptions using addSuppressed", "label": {"api": {"addSuppressed": [[39, 51]]}}}, {"text": "You can then retrieve it again later using getSuppressed()", "label": {"api": {"getSuppressed()": [[43, 57]]}}}, {"text": "That's what the JDK uses, for instance in Character.codePointAt(CharSequence seq, int index) and String(int[] codePoints, int offset, int count)", "label": {"api": {"Character.codePointAt(CharSequence seq, int index)": [[42, 91]], "String(int[] codePoints, int offset, int count)": [[97, 143]]}}}, {"text": "Arrays.sort() is using a merge sort", "label": {"api": {"Arrays": [[0, 5]]}}}, {"text": "See the Arrays API for details", "label": {"api": {"Arrays": [[8, 13]]}}}, {"text": "Check the API here", "label": {"api": {"API here": [[10, 17]]}}}, {"text": "The TemporalAdjuster interface provides for classes to manipulate date-time values", "label": {"api": {"TemporalAdjuster": [[4, 19]]}}}, {"text": "The TemporalAdjusters class provides several handy implementations", "label": {"api": {"TemporalAdjuster": [[4, 19]], "TemporalAdjusters": [[4, 20]]}}}, {"text": "We also accept that either that first or last of month may actually be the desired day-of-week which is what the “orSame” means in the TemporalAdjusters calls seen below", "label": {"api": {"TemporalAdjuster": [[135, 150]], "TemporalAdjusters": [[135, 151]]}}}, {"text": "By the way, if you need to represent the entire month, look at the YearMonth class", "label": {"api": {"YearMonth": [[67, 75]]}}}, {"text": "The Thread class is a good start", "label": {"api": {"Thread": [[4, 9]]}}}, {"text": "This list is from https://docs.oracle.com/javase/8/docs/api/java/io/IOException.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/io/IOException.html": [[18, 83]]}}}, {"text": "Use DateTimeFormatter pattern \"yyyy-MM-dd HH:mm:ss VV\"", "label": {"api": {"DateTimeFormatter": [[4, 20]]}}}, {"text": "From the documentation of TreeMap", "label": {"api": {"documentation of TreeMap": [[9, 32]]}}}, {"text": "If you want to go the regex route with String#replaceAll(), then you can consider using the following pattern", "label": {"api": {"String#replaceAll()": [[39, 57]]}}}, {"text": "I did go through the official documentation but did not find any help", "label": {"api": {"official documentation": [[21, 42]]}}}, {"text": "Because then you can step back; and use a lot of the built-in features of Java collections; like the List.contains() method", "label": {"api": {"List.contains()": [[101, 115]]}}}, {"text": "Oracle Documentation describe that z and Z both are use for time zone", "label": {"api": {"Oracle": [[0, 5]]}}}, {"text": "The tutorial you mention uses a PropertyValueFactory", "label": {"api": {"PropertyValueFactory": [[32, 51]]}}}, {"text": "If your user object doesn't have property accessors for the values, but only getters, you can wrap the result in a ReadOnlyObjectWrapper as described in the PropertyValueFactory documentation", "label": {"api": {"PropertyValueFactory": [[157, 176]]}}}, {"text": "This is a standard API so it should work for any compliant JAX-RS 2.0 client (including Liberty's jaxrsClient-2.0 feature)", "label": {"api": {"standard API": [[10, 21]]}}}, {"text": "Try reading something from a file or console, those Strings aren't \"interned\", thus equals() (and also hashcode()) needs to be overriden", "label": {"api": {"hashcode()": [[103, 112]]}}}, {"text": "We can save the intermediate step of collectiong to a Map by transforming directly to a Stream of SimpleEntry, for example", "label": {"api": {"SimpleEntry": [[98, 108]]}}}, {"text": "However, my spider checks HttpURLConnection#getResponseCode() to see if it has reached the final URL by getting HTTP response code 200 and use URLConnection#getHeaderField() to get the Location field if HTTP response code 3xx is received", "label": {"api": {"HttpURLConnection#getResponseCode()": [[26, 60]], "URLConnection#getHeaderField()": [[143, 172]]}}}, {"text": "I have google this issue a bit and apparently javax.script is somehow related, but I have no idea how to make it works", "label": {"api": {"javax.script": [[46, 57]]}}}, {"text": "Just convert to LocalDate", "label": {"api": {"LocalDate": [[16, 24]]}}}, {"text": "A non-zero value determines the JDBC fetch size (calls Statement.setFetchSize())", "label": {"api": {"Statement.setFetchSize()": [[55, 78]]}}}, {"text": "The hashCode method is defined on java.lang.Object (and overridden in subclasses when needed), so you can call it on any object", "label": {"api": {"hashCode": [[4, 11]]}}}, {"text": "In your case connection.hashCode() should give you the hash code of connection object", "label": {"api": {"hashCode": [[24, 31]]}}}, {"text": "I'm a beginner on Java, and working with Java class reference recently", "label": {"api": {"Java class reference": [[41, 60]]}}}, {"text": "Since there's no version of replaceAll() that accepts a lambda expression, I think your best bet would be to use a Matcher object", "label": {"api": {"Matcher": [[115, 121]]}}}, {"text": "(https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html)  The blocking queue works using the java built-in synchronization mechanism and allows one thread to pass information to another", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html": [[1, 81]]}}}, {"text": "The easiest way to accomplish that goal is to bind the types that you don't want to be made available (in this case B and C) with a @Qualifier that is not accessible", "label": {"api": {"@Qualifier": [[132, 141]]}}}, {"text": "Comparator.comparing method accept a Function<T,R extends Comparable<", "label": {"api": {"Comparator.comparing": [[0, 19]], "Comparator": [[0, 9]]}}}, {"text": "Stream.sort method accept a Comparator, and Comparator is more like a BiFunction<T,T,Integer> so it is compatiable with String::compareToIgnoreCase", "label": {"api": {"Stream.sort": [[0, 10]], "Comparator": [[28, 37], [44, 53]]}}}, {"text": "Use invoke setNumberFormatOverride() on your plot's NumberAxis, as shown here", "label": {"api": {"NumberFormat": [[14, 25]]}}}, {"text": "You'll need a custom NumberFormat, possibly using one of the approach shown here or here", "label": {"api": {"NumberFormat": [[21, 32]]}}}, {"text": "Notice the use of splitAsStream(), so the result of the split doesn't have to be stored in an intermediate array", "label": {"api": {"splitAsStream()": [[18, 32]]}}}, {"text": "String#matches accepts a string defining a regular expression", "label": {"api": {"String#matches": [[0, 13]]}}}, {"text": "But I can tell you java gammar not support this feature for fields/variables, maybe in the next jdk will be enable this feature which a field/variable refer to Callable", "label": {"api": {"Callable": [[160, 167]]}}}, {"text": "Here I'm using Collector.of to create a custom collector that will accumulate elements on a LinkedHashMap", "label": {"api": {"Collector.of": [[15, 26]]}}}, {"text": "You need to bear in mind that the Java Comparator return value is three-valued (i.e", "label": {"api": {"Comparator": [[39, 48]]}}}, {"text": "To add an element, use the merge method", "label": {"api": {"merge": [[27, 31]]}}}, {"text": "And to remove an element, you might want to use the computeIfPresent method", "label": {"api": {"computeIfPresent": [[52, 67]]}}}, {"text": "The applet draws with the class Graphics and passes you an instance in the paint method", "label": {"api": {"Graphics": [[32, 39]]}}}, {"text": "You can use Graphics to do many cool things on the screen, so check its methods out", "label": {"api": {"Graphics": [[12, 19]]}}}, {"text": "You can use ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "the method reference expression must be assign an exactly Function Interface at compile time", "label": {"api": {"Function Interface": [[58, 75]]}}}, {"text": "and Function Interface is a SAM Interface", "label": {"api": {"Function Interface": [[4, 21]]}}}, {"text": "but you can using reflection or invoke api to achieve it", "label": {"api": {"reflection": [[18, 27]], "invoke": [[32, 37]]}}}, {"text": "let see each method expression refer to a Function Interface in your SomeClass results in refers to different Function Interface type", "label": {"api": {"Function Interface": [[42, 59], [110, 127]]}}}, {"text": "using IntStream.range & IntStream.mapToObj methods", "label": {"api": {"IntStream.range": [[6, 20]], "IntStream.mapToObj": [[24, 41]]}}}, {"text": "We are hashing a password using the PBKDF2 algorithm, using the SecretKeyFactory.generateSecret function, like this", "label": {"api": {"SecretKeyFactory.generateSecret": [[64, 94]]}}}, {"text": "(https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) in order to split a string", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[1, 63]]}}}, {"text": "the server code waits on one server socket; and when a new client comes in and accept() gives you a \"dedicated\" socket to talk to that client", "label": {"api": {"accept()": [[79, 86]]}}}, {"text": "Say, you want to generate a challenges with t trials, where int t = random.nextInt(5) + 4, such that 4 <= t <= 8 (note that nextInt's bound is exclusive)", "label": {"api": {"nextInt": [[75, 81], [124, 130]]}}}, {"text": "Every trial gets an associated value of random.nextInt(100) + 25 (so between 25 and 124), if I read your code correctly", "label": {"api": {"nextInt": [[47, 53]]}}}, {"text": "Synchronized Set, will be enough", "label": {"api": {"Synchronized Set": [[0, 15]]}}}, {"text": "You should use .exists() to check whether the file exists, or better, .canRead() to check if you can really read it", "label": {"api": {"use .exists()": [[11, 23]], ".canRead()": [[70, 79]]}}}, {"text": "As a sidenote, the Node parent class also has a relocate method for easily changing both the X and Y coordinates", "label": {"api": {"relocate": [[48, 55]]}}}, {"text": "One more important point here is that as you are using double for width and length, you might face rounding issues (look here for more details) and you might need to consider using BigDecimal, if you have to avoid the problems", "label": {"api": {"BigDecimal": [[181, 190]]}}}, {"text": "You can use a TreeMap with your custom Comparator", "label": {"api": {"TreeMap": [[14, 20]], "Comparator": [[39, 48]]}}}, {"text": "In your Comparator compare the values of dates", "label": {"api": {"Comparator": [[8, 17]]}}}, {"text": "If you use the string array version it should find the executable", "label": {"api": {"string array version": [[15, 34]]}}}, {"text": "You could use String.matches(String regex)", "label": {"api": {"String.matches(String regex)": [[14, 41]]}}}, {"text": "You can use String.matches() to validate the expression entered by the user", "label": {"api": {"String.matches()": [[12, 27]]}}}, {"text": "You can use Tab's selectedProperty to know if it is selected or not, and by extension if its content is visible or not", "label": {"api": {"selectedProperty": [[18, 33]]}}}, {"text": "I replaced your thread with a JavaFX Timeline", "label": {"api": {"Timeline": [[37, 44]]}}}, {"text": "The ComponentListener can be replaced with a change listener on selectedProperty() and querying the new value", "label": {"api": {"selectedProperty": [[64, 79]]}}}, {"text": "JPanel.addMouseListener can to achieve it", "label": {"api": {"JPanel.addMouseListener": [[0, 22]]}}}, {"text": "Java's SynchronizedMap, which is created by calling Collections.synchronizedMap() seems to be using a single mutex for all of the map's operations", "label": {"api": {"Collections.synchronizedMap()": [[52, 80]]}}}, {"text": "Wouldn't a ReadWriteLock be more suitable here", "label": {"api": {"ReadWriteLock": [[11, 23]]}}}, {"text": "Normally \"return class object of p\" means return the Class object of p", "label": {"api": {"Class": [[53, 57]]}}}, {"text": "So in your example either p.getClass() or Product.class", "label": {"api": {"Class": [[31, 35]]}}}, {"text": "If, for instance, you want to perform a test on the values to be printed, or otherwise manipulate them, you can use the keySet method to get a collection of all keys in the map", "label": {"api": {"keySet": [[120, 125]]}}}, {"text": "The host and port of your URL are figured out by using HttpServletRequest#getRequestURL (or getRequestURI)", "label": {"api": {"HttpServletRequest#getRequestURL": [[55, 86]]}}}, {"text": "Don't use replaceAll()", "label": {"api": {"replaceAll()": [[10, 21]]}}}, {"text": "Instead, create a StringBuilder for building up the result string", "label": {"api": {"StringBuilder": [[18, 30]]}}}, {"text": "Then loop through the characters of the input string with a normal for loop using String methods length() and charAt()", "label": {"api": {"length()": [[97, 104]], "charAt()": [[110, 117]]}}}, {"text": "the errors occurs when java.sql.Date imported which is derived from java.util.Date, and DateFormat.parse return a java.util.Date", "label": {"api": {"java.sql.Date": [[23, 35]], "java.util.Date": [[68, 81], [114, 127]], "DateFormat.parse": [[88, 103]]}}}, {"text": "so you can't assign java.util.Date to derived type java.sql.Date", "label": {"api": {"java.sql.Date": [[51, 63]], "java.util.Date": [[20, 33]]}}}, {"text": "OR assign it to a full-name type of java.util.Date when you both using java.sql.Date and java.util.Date", "label": {"api": {"java.sql.Date": [[71, 83]], "java.util.Date": [[36, 49], [89, 102]]}}}, {"text": "OR if you need convert java.util.Date to a java.sql.Date you can do as follows", "label": {"api": {"java.sql.Date": [[43, 55]], "java.util.Date": [[23, 36]]}}}, {"text": "OR if you need convert java.util.Date to a java.sql.Time you can do as follows", "label": {"api": {"java.util.Date": [[23, 36]]}}}, {"text": "Basically, you are providing the isAnnotationPresent() method definition to the Lambda expression (of anyMatch method which accepts for Predicate) and the value from the stream will automatically be passed as an argument to the anyMatch method", "label": {"api": {"Predicate": [[136, 144]]}}}, {"text": "If you don't want to add a third-party library, you could use Regular Expression to parse the line", "label": {"api": {"Regular Expression": [[62, 79]]}}}, {"text": "Reading lines from a file should not be done with a Scanner", "label": {"api": {"Scanner": [[52, 58]]}}}, {"text": "Use a BufferedReader instead", "label": {"api": {"BufferedReader": [[6, 19]]}}}, {"text": "See Scanner vs", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "Now how about OneToOne", "label": {"api": {"OneToOne": [[14, 21]]}}}, {"text": "However as part of a monolithic application you can consider node-local variants of it - including maybe the Java 8 Streams", "label": {"api": {"Java 8 Streams": [[109, 122]]}}}, {"text": "Take note of the parallelStream() method that is also available on your List<X>", "label": {"api": {"parallelStream()": [[17, 32]]}}}, {"text": "Mapping an Employee to a Person you can use Collectors.mapping/Stream.map that others has already provided so I will skipped it", "label": {"api": {"Collectors.mapping": [[44, 61]], "Stream.map": [[63, 72]]}}}, {"text": "But it seems that it would be possible via getAllLoadedClasses() in the Instrumentation API", "label": {"api": {"Instrumentation API": [[72, 90]]}}}, {"text": "You can use Pattern.CASE_INSENSITIVE field option to make your regex case insensitive instead of using (?i) flag in your regex", "label": {"api": {"Pattern.CASE_INSENSITIVE": [[12, 35]]}}}, {"text": "these classes were created \"ages\" ago - when you check the javadoc for Hashtable, you find it says \"since Java 1.0\"; whereas HashMap says \"1.2\"", "label": {"api": {"Hashtable": [[71, 79]]}}}, {"text": "Both BluetoothSocket and BufferedReader implement Closeable interface, which means that as soon as you are done with that object you should take care of disposing from them via calling close(), otherwise you'd end up with memory leakage", "label": {"api": {"BufferedReader": [[25, 38]]}}}, {"text": "I think CompletableFuture.allOf() seems like a replacement for Futures.allAsList(), but I don't see anything quite like successfulAsList()", "label": {"api": {"CompletableFuture.allOf()": [[8, 32]]}}}, {"text": "If id's are assigned in order of creation, add the orders to a Deque when created", "label": {"api": {"Deque": [[63, 67]]}}}, {"text": "The Deque will then implicitly be ordered by ID", "label": {"api": {"Deque": [[4, 8]]}}}, {"text": "Whenever an order is marked complete, check the first entry in the Deque", "label": {"api": {"Deque": [[67, 71]]}}}, {"text": "If it is complete, remove it from the Deque (or move it to another one)", "label": {"api": {"Deque": [[38, 42]]}}}, {"text": "Then check next (now first) entry in the Deque again, in case multiple orders are ready, and repeat as needed", "label": {"api": {"Deque": [[41, 45]]}}}, {"text": "That Deque of incomplete orders is maintained independently of any Map you might need for looking up the order by ID", "label": {"api": {"Deque": [[5, 9]]}}}, {"text": "If you just need a zlib stream, use DeflaterOutputStream instead", "label": {"api": {"DeflaterOutputStream": [[36, 55]]}}}, {"text": "You can use the static method Enum.valueOf(Class<T> enumType, String name) which returns an enum of type T, if the name matches an enum constants of that type", "label": {"api": {"Enum.valueOf(Class<T> enumType, String name)": [[30, 73]]}}}, {"text": "You may get such a timestamp from for example System.currentTimeMillis() or Instant.now().toEpochMilli()", "label": {"api": {"System.currentTimeMillis()": [[46, 71]]}}}, {"text": "Try using the concurrent hash map", "label": {"api": {"concurrent hash map": [[14, 32]]}}}, {"text": "But if you use concurrent hash map and if you have 2 write operation writing in different range, both can go simultaneously", "label": {"api": {"concurrent hash map": [[15, 33]]}}}, {"text": "Please refer how concurrent hash map works before using it to get better understanding", "label": {"api": {"concurrent hash map": [[17, 35]]}}}, {"text": "In summary, you could create a Comparator for the corresponding class; or implement the Comparable interface", "label": {"api": {"Comparator": [[31, 40]], "Comparable": [[88, 97]]}}}, {"text": "Because List#remove(int) also returns the element, you can both stream the list's elements and remove them via a stream", "label": {"api": {"List#remove(int)": [[8, 23]]}}}, {"text": "From the javadoc of Stream#generate()", "label": {"api": {"Stream#generate()": [[20, 36]]}}}, {"text": "If OptList is not a collection type, then you can still use collect, but you have to build your own collector", "label": {"api": {"build your own collector": [[85, 108]]}}}, {"text": "As shown here, you can invoke setNumberFormatOverride() to set the desired DecimalFormat", "label": {"api": {"setNumberFormatOverride()": [[30, 54]], "DecimalFormat": [[75, 87]]}}}, {"text": "You can invoke the setExponentSeparator() method of DecimalFormatSymbols to set the desired exponent separator", "label": {"api": {"DecimalFormat": [[52, 64]], "setExponentSeparator()": [[19, 40]], "DecimalFormatSymbols": [[52, 71]]}}}, {"text": "According to the docs, the system property java.compiler should be present", "label": {"api": {"According to the docs": [[0, 20]]}}}, {"text": "You could make the dates into LocalDateTime objects and use the compareTo method", "label": {"api": {"LocalDateTime": [[30, 42]]}}}, {"text": "I would use the List#sort function like so", "label": {"api": {"List#sort": [[16, 24]]}}}, {"text": "Luckily, the Map interface defines the putAll method, which has the following signature", "label": {"api": {"putAll method": [[39, 51]]}}}, {"text": "This means that the putAll method accepts a map whose keys and values might be of types that are subtypes of its own key and value types, respectively", "label": {"api": {"putAll method": [[20, 32]]}}}, {"text": "There is also Java NIO's PathMatcher, which is made for dealing with paths", "label": {"api": {"PathMatcher": [[25, 35]]}}}, {"text": "For example, you can use a java.nio.ByteBuffer which has the machinery to cope with endian isssues", "label": {"api": {"java.nio.ByteBuffer": [[27, 45]]}}}, {"text": "Regarding the operations counter, you better use AtomicInteger because that supports multithreaded decrement and increment operations", "label": {"api": {"AtomicInteger": [[49, 61]]}}}, {"text": "Note that these methods above use the get() and the decrementAndGet() method of AtomicInteger()", "label": {"api": {"AtomicInteger": [[80, 92]]}}}, {"text": "If all the methods have the same signature double m(int), then you can use something like the IntToDoubleFunction interface and pass a method reference", "label": {"api": {"the IntToDoubleFunction interface": [[90, 122]]}}}, {"text": "The other point you might need to note that is, for your task (using int variable across threads), you can simply use AtomicInteger API with which you can avoid explicit synchronization in your code", "label": {"api": {"AtomicInteger": [[118, 130]]}}}, {"text": "But if it is not possible to store the fields other than different variable then you can use Class.getField method to get the field by name", "label": {"api": {"Class.getField": [[93, 106]]}}}, {"text": "Are you aware, that Thread.getAllStackTraces() returns a Map that already contains all stack traces", "label": {"api": {"Thread.getAllStackTraces()": [[20, 45]]}}}, {"text": "Cause File.getName(), File.getPath(), Path.getFileName(), etc seem to return the NFC normalized strings for both files, thus considering them both as equal", "label": {"api": {"File.getName()": [[6, 19]], "File.getPath()": [[22, 35]], "Path.getFileName()": [[38, 55]]}}}, {"text": "So I think I found the answer as I was writing the question, and it looks like there is one way to get the filename in its original normalization form, and that is through the Path.toUri() method", "label": {"api": {"Path.toUri()": [[176, 187]]}}}, {"text": "Interestingly enough the File.toURI() does not do the same", "label": {"api": {"File.toURI()": [[25, 36]]}}}, {"text": "Collectors.mapping() will simply apply the given function before the collection happens", "label": {"api": {"Collectors.mapping()": [[0, 19]]}}}, {"text": "You can use a so called ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[24, 47]]}}}, {"text": "You can use DatabaseMetaData.getColumns(...), column CHAR_OCTET_LENGTH, but this is possibly not populated for data types other than char/varchar", "label": {"api": {"DatabaseMetaData.getColumns(...)": [[12, 43]]}}}, {"text": "You can prevent this by passing in a second parameter, making use of another constructor of FileWriter, one that accepts an append flag", "label": {"api": {"another constructor of FileWriter": [[69, 101]]}}}, {"text": "Your objectives sound exactly like the use case of a ReadWriteLock, which allows only one writer, but arbitrary readers if there is no writer", "label": {"api": {"ReadWriteLock": [[53, 65]]}}}, {"text": "I'm reading the docs for TextField, and I came across a property called prefColumnCount", "label": {"api": {"TextField": [[25, 33]]}}}, {"text": "Now, Collectors.groupingBy has an overloaded version that accepts what is called a downstream collector, meaning that you can collect the objects that match a value into another structure different than a List", "label": {"api": {"Collectors.groupingBy": [[5, 25]]}}}, {"text": "Try using the atomic ConcurrentHashMap.merge() to increment the count", "label": {"api": {"ConcurrentHashMap.merge()": [[21, 45]]}}}, {"text": "If you want to sort the array, simple use Arrays.paralellSort() and get whatever values you need from the resulting array", "label": {"api": {"Arrays.paralellSort()": [[42, 62]]}}}, {"text": "It would be best to use a HashSet to contain the list of already selected values, since a HashSet can efficiently be checked for a value and have a value added to it", "label": {"api": {"HashSet": [[26, 32], [90, 96]]}}}, {"text": "The simplest option would be to use the Collectors.partitioningBy method along with Java 8's Streams and Collectors", "label": {"api": {"Collectors.partitioningBy": [[40, 64]], "Streams": [[93, 99]], "Collectors": [[40, 49], [105, 114]]}}}, {"text": "Please refer https://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html#read() oracle doc , to get more info of read method", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html#read()": [[13, 88]]}}}, {"text": "There is no equivalent of the g flag in JAVA, you have to use replaceall() instead of replace() if you want to replace or use a matcher and a while loop (see How can I find all matches to a regular expression in android)", "label": {"api": {"replaceall()": [[62, 73]]}}}, {"text": "I suggest using LocalDate instead", "label": {"api": {"LocalDate": [[16, 24]]}}}, {"text": "If you want to return what you're matching, you should use Matcher.find", "label": {"api": {"Matcher.find": [[59, 70]]}}}, {"text": "Start a single thread up front, then use a BlockingQueue to send list from thread 1 to thread 2", "label": {"api": {"BlockingQueue": [[43, 55]]}}}, {"text": "using an Executor", "label": {"api": {"Executor": [[9, 16]]}}}, {"text": "BufferedReader's (look here) readLine() reads a single line from the file, so you need to write a loop as shown below", "label": {"api": {"BufferedReader": [[0, 13]]}}}, {"text": "Also, you don't need Scanner object in your code (if you use BufferedReader), so it would be simply as shown below", "label": {"api": {"BufferedReader": [[61, 74]]}}}, {"text": "Going with @jaredr's suggestion though, if you absolutely have to retain key order, have a look at SortedMap", "label": {"api": {"SortedMap": [[99, 107]]}}}, {"text": "You could also use Java's built in ByteBuffer to help manage this kind of stuff", "label": {"api": {"ByteBuffer": [[35, 44]]}}}, {"text": "This uses regular expressions and the String.replaceAll function", "label": {"api": {"String.replaceAll": [[38, 54]]}}}, {"text": "you could use the replace() method of the String class", "label": {"api": {"replace()": [[18, 26]]}}}, {"text": "It seems you are looking for positive lookahead which matches only if expression A is followed by expression b", "label": {"api": {"positive lookahead": [[29, 46]]}}}, {"text": "Just generate a UUID normally, such as with UUID.randomUUID(), then convert it to a string with UUID.toString(), and then finally replace the first 8 characters as desired", "label": {"api": {"UUID.randomUUID()": [[44, 60]], "UUID.toString()": [[96, 110]]}}}, {"text": "I would make use of the split method here", "label": {"api": {"split": [[24, 28]]}}}, {"text": "You can use the Math.max() method to simplify it", "label": {"api": {"Math.max()": [[16, 25]]}}}, {"text": "Or you can use IntStream.max(), which is better if you have many values", "label": {"api": {"IntStream.max()": [[15, 29]]}}}, {"text": "You can use LinkedHashSet", "label": {"api": {"LinkedHashSet": [[12, 24]]}}}, {"text": "Why you don't use Arrays.toString(oneD) and Arrays.deepToString(twoD) like this", "label": {"api": {"Arrays.toString(oneD)": [[18, 38]], "Arrays.deepToString(twoD)": [[44, 68]]}}}, {"text": "Another better approach is to use a Dynamic Structure like ArrayList", "label": {"api": {"ArrayList": [[59, 67]]}}}, {"text": "So here you need to have Array of ArrayList and then you can remove the element with remove() method", "label": {"api": {"ArrayList": [[34, 42]], "remove()": [[85, 92]]}}}, {"text": "In case if you want to update any element then you can use set() method", "label": {"api": {"set()": [[59, 63]]}}}, {"text": "Binary search expects input sequence to be sorted (as by the sort(byte[]) method)", "label": {"api": {"Binary search expects input sequence to be sorted": [[0, 48]]}}}, {"text": "Well...no, there wouldn't be, ServerSockets don't have streamed input/output", "label": {"api": {"ServerSocket": [[30, 41]], "Socket": [[36, 41]]}}}, {"text": "A ServerSocket accepts connections, creating a Socket for each connection received (see accept), which is where the streams for that connection are", "label": {"api": {"ServerSocket": [[2, 13]], "Socket": [[8, 13], [47, 52]], "accept": [[15, 20], [88, 93]]}}}, {"text": "Take a look at Joda-Time or the Java 8 package java.time", "label": {"api": {"java.time": [[47, 55]]}}}, {"text": "The BigInteger class may be useful for storing your huge integers", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "It would be relatively easy to build a wrapper class with the sum of rational numbers (expressed as some BigInteger p over another BigInteger q), and you could extend these to have a rational part, imaginary part, infinitesimal part, and infinitely large part", "label": {"api": {"BigInteger": [[105, 114], [131, 140]]}}}, {"text": "I guess you're just looking for BigDecimal or BigInteger which can handle integers with arbitrary length or precision", "label": {"api": {"BigDecimal": [[32, 41]], "BigInteger": [[46, 55]]}}}, {"text": "Ways around it include increasing it via the -Xss JVM option, setting the stack size in the Thread constructor, re-writing it non-recursive or using the Trampoline pattern", "label": {"api": {"constructor": [[99, 109]]}}}, {"text": "BufferedWriter.write(int) writes a single character", "label": {"api": {"BufferedWriter.write(int)": [[0, 24]]}}}, {"text": "By default, Collectors.toSet() creates a HashSet, though this is not guaranteed by the specification", "label": {"api": {"Collectors.toSet()": [[12, 29]]}}}, {"text": "Supplier is one of the functional interfaces of Java 8", "label": {"api": {"Supplier": [[0, 7]]}}}, {"text": "So in your case, Supplier<IStatus> should return an IStatus instance", "label": {"api": {"Supplier": [[17, 24]]}}}, {"text": "This lambda expression will be an implementation for the get method of the Supplier interface", "label": {"api": {"Supplier": [[75, 82]]}}}, {"text": "Eventually I've found the class, ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[33, 53]]}}}, {"text": "One is Java Agent that uses Reflection to change the field value", "label": {"api": {"Java Agent": [[7, 16]]}}}, {"text": "Java Agent's main class should have agentmain entry point", "label": {"api": {"Java Agent": [[0, 9]]}}}, {"text": "JavaDoc If the header you wish to remove is also #0, then lastIndexOf is what you’re looking for, supposing then that there are at most two occurences of #0 – When the old and new headers are both #0", "label": {"api": {"lastIndexOf": [[58, 68]]}}}, {"text": "This is from the MessageFormat documentation", "label": {"api": {"MessageFormat documentation": [[17, 43]]}}}, {"text": "The problem is that the StreamHandler.setOutputStream wraps the given stream in a OutputStreamWriter which according to the javadocs", "label": {"api": {"StreamHandler.setOutputStream": [[24, 52]], "OutputStreamWriter": [[82, 99]]}}}, {"text": "Since you don't want to create a new class you can use the ConsoleHandler which will flush to console but by default will write to error stream", "label": {"api": {"ConsoleHandler": [[59, 72]]}}}, {"text": "A subclass really is your best bet because you can end up accidentally closing the System.out by calling Handler.close() through LogManager.getLogManager().reset() or by calling StreamHandler.setOutputStream which means you won't see any output at all", "label": {"api": {"StreamHandler.setOutputStream": [[178, 206]]}}}, {"text": "The generic type of the map is determined by String::toLowerCase and Collectors.counting() in the final method call", "label": {"api": {"Collectors.counting()": [[69, 89]]}}}, {"text": "Files.lines(Path) creates a Stream<String> of the lines in a file", "label": {"api": {"Files.lines(Path)": [[0, 16]], "Stream<String>": [[28, 41]]}}}, {"text": "Stream.map(Function<String, String>) transforms the input stream of strings into another stream of strings using the call to line.replaceAll(...)", "label": {"api": {"Stream.map(Function<String, String>)": [[0, 35]]}}}, {"text": "The stream of edited lines now gets Stream.flatMap(Function<String, Stream<String>>) to it to split the lines into words and return a single continuous stream", "label": {"api": {"Stream<String>": [[68, 81]], "Stream.flatMap(Function<String, Stream<String>>)": [[36, 83]]}}}, {"text": "You only need to know what the final result is (in this case a Stream<String>)", "label": {"api": {"Stream<String>": [[63, 76]]}}}, {"text": "Now that you have a Stream<String> of words in the file, you apply what is called the terminal operation", "label": {"api": {"Stream<String>": [[20, 33]]}}}, {"text": "The collector is created by Collectors.groupingBy(Function<String, String>, Supplier<Map<String, String>>, Collector<String, String, Long>)", "label": {"api": {"Collectors.groupingBy(Function<String, String>, Supplier<Map<String, String>>, Collector<String, String, Long>)": [[28, 138]]}}}, {"text": "The downstream Collector is created by Collectors.counting(), which just counts the number of elements in each stream", "label": {"api": {"Collectors.counting()": [[39, 59]]}}}, {"text": "This is pretty well documented in the java.util.stream package summary", "label": {"api": {"java.util.stream package summary": [[38, 69]]}}}, {"text": "http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html says no", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html": [[0, 71]]}}}, {"text": "Judging by this presentation (PDF), you should be using the FXCollections utility class (update", "label": {"api": {"the FXCollections utility class": [[56, 86]]}}}, {"text": "Have a look at the JavaFX CSS Reference Guide for more CSS information", "label": {"api": {"JavaFX CSS Reference Guide": [[19, 44]]}}}, {"text": "getParameterNames of request object returns an implementation of Enumeration interface", "label": {"api": {"Enumeration": [[65, 75]]}}}, {"text": "As the returned object implements Enumeration it is possible to call methods of this interface in your code", "label": {"api": {"Enumeration": [[34, 44]]}}}, {"text": "It is enough to know, that the returned result implements Enumeration interface, and it is possible to use Enumeration interface methods with the obtained result", "label": {"api": {"Enumeration": [[58, 68], [107, 117]]}}}, {"text": "Because SwingWorker notifies any PropertyChangeListener on the event dispatch thread, simply listen for the bound property state", "label": {"api": {"SwingWorker": [[8, 18]]}}}, {"text": "Possible values include DONE, PENDING and STARTED", "label": {"api": {"values": [[9, 14]]}}}, {"text": "That's what collect with groupingBy is for", "label": {"api": {"collect": [[12, 18]], "groupingBy": [[25, 34]]}}}, {"text": "From the ObjectOutputStream Javadoc", "label": {"api": {"ObjectOutputStream Javadoc": [[9, 34]]}}}, {"text": "Only objects that support the java.io.Serializable interface can be written to streams", "label": {"api": {"Serializable": [[38, 49]]}}}, {"text": "Your Animal class should implement Serializable interface", "label": {"api": {"Serializable": [[35, 46]]}}}, {"text": "This is exactly what the groupingBy collector allows you to do", "label": {"api": {"groupingBy": [[25, 34]]}}}, {"text": "Then the mapping collector converts the KeyValue objects into their respective values", "label": {"api": {"mapping": [[9, 15]]}}}, {"text": "One possibility would be to create a custom class extending PrintStream, that would simply pass whatever is passed to it to another PrintStream, then wrap that around System.out, via System.setOut(); the custom class could have a ThreadLocal private attribute that could be used to tell it if, for the current thread, the text should be intercepted", "label": {"api": {"PrintStream": [[60, 70], [132, 142]], "ThreadLocal": [[230, 240]]}}}, {"text": "As your level of contention is low a simple ReentrantLock should do the job", "label": {"api": {"ReentrantLock": [[44, 56]]}}}, {"text": "You might use LocalTime#isAfter and LocalTime#isBefore for that", "label": {"api": {"LocalTime#isAfter": [[14, 30]], "LocalTime#isBefore": [[36, 53]]}}}, {"text": "It's very likely you have an Application subclass somewhere in your application", "label": {"api": {"Application": [[29, 39]]}}}, {"text": "A Set cannot contain duplicate elements", "label": {"api": {"Set": [[2, 4]]}}}, {"text": "In Java, I want to receive those messages but they never arrive, it's always stuck on receive()", "label": {"api": {"receive()": [[86, 94]]}}}, {"text": "To add an element, use the merge method", "label": {"api": {"merge": [[27, 31]]}}}, {"text": "And to remove an element, you might want to use the computeIfPresent method", "label": {"api": {"computeIfPresent": [[52, 67]]}}}, {"text": "The class java.sql.Timestamp is the one the persistence provider uses to parse a date from the DB regardless the value is just a date", "label": {"api": {"java.sql.Timestamp": [[10, 27]]}}}, {"text": "Note that this class extends from java.util.Date not java.sql.Date", "label": {"api": {"java.util.Date": [[34, 47]], "java.sql.Date": [[53, 65]]}}}, {"text": "You can using Map#compute to simplify your code", "label": {"api": {"Map#compute": [[14, 24]]}}}, {"text": "OR using Stream#peek & Stream#collect to describe it does two things", "label": {"api": {"Stream#peek": [[9, 19]], "Stream#collect": [[23, 36]]}}}, {"text": "The Java URL class has support many types of parsing URLs", "label": {"api": {"URL class": [[9, 17]]}}}, {"text": "Collection.containsAll is a good real world example of their use", "label": {"api": {"Collection.containsAll": [[0, 21]]}}}, {"text": "In particular, Collection.containsAll accepts any Collection as its argument", "label": {"api": {"Collection.containsAll": [[15, 36]]}}}, {"text": "Not sure what version of Java you are using, but you could use a simple RuleBasedCollator to switch the order of the few characters that need to be switched (the rest should follow Unicode order)", "label": {"api": {"RuleBasedCollator": [[72, 88]]}}}, {"text": "There is also a complete example in the Java Tutorials that show how to use the RuleBasedCollator you create", "label": {"api": {"RuleBasedCollator": [[80, 96]]}}}, {"text": "If you are using Java 8, you can use the computeIfAbsent method to add a recommendation for an actor, as follows", "label": {"api": {"computeIfAbsent method": [[41, 62]]}}}, {"text": "You can use System.arraycopy() to copy the data", "label": {"api": {"System.arraycopy()": [[12, 29]]}}}, {"text": "How about using the built in Collections.synchronizedList", "label": {"api": {"Collections.synchronizedList": [[29, 56]]}}}, {"text": "You can use @Lob from javax.persistence..", "label": {"api": {"javax.persistence": [[22, 38]]}}}, {"text": "That event is triggered when the mouse is released during a \"full press-drag-release gesture\" within the application; not when data is dropped during a \"platform-supported drag-and-drop gesture\" (see the documentation for MouseEvent for a description of these different dragging modes)", "label": {"api": {"documentation for MouseEvent": [[204, 231]]}}}, {"text": "I am using a Phaser to attempt some synchronization in my java code", "label": {"api": {"Phaser": [[13, 18]]}}}, {"text": "That kind of information probably belongs in user preferences, which you access using the Preferences class", "label": {"api": {"Preferences": [[90, 100]]}}}, {"text": "Alternatively, if you want to pre-process every inbound request, then consider implementing that via a Filter instead of a servlet", "label": {"api": {"Filter": [[103, 108]]}}}, {"text": "You can steal the DialogPane from an Alert instance, and add it to a regular Stage", "label": {"api": {"DialogPane": [[18, 27]]}}}, {"text": "Stream.concat will take two streams and concatenate them", "label": {"api": {"Stream.concat": [[0, 12]]}}}, {"text": "You can turn any OutputStream into a Channel using the Channels.newChannel method", "label": {"api": {"Channels.newChannel": [[55, 73]]}}}, {"text": "Use the fact that Map#get returns null when there is not a mapping in order to determine if you need to put a new collection in the map, then add the value to the collection", "label": {"api": {"Map#get": [[18, 24]]}}}, {"text": "Use Map#computeIfAbsent to add a new collection to the map if there is not a mapping, and then add the value to the returned collection", "label": {"api": {"Map#computeIfAbsent": [[4, 22]]}}}, {"text": "You should surround this with a try/catch in case of InterruptedExceptions", "label": {"api": {"InterruptedException": [[53, 72]]}}}, {"text": "Or simply for a random number can use the static random() method in Math class", "label": {"api": {"random()": [[49, 56]]}}}, {"text": "Means that you are using the current object run() method, from the Runnable interface, as this thread main/starting method", "label": {"api": {"Runnable": [[67, 74]]}}}, {"text": "You could use a Timeline to animate the angle property of a Rotate transform applied to the Line", "label": {"api": {"a Rotate transform": [[58, 75]]}}}, {"text": "Have a look at documentation of wait() method", "label": {"api": {"wait()": [[32, 37]]}}}, {"text": "the Map.Entry interface and the AbstractMap.SimpleEntry class", "label": {"api": {"Map.Entry": [[4, 12]], "AbstractMap.SimpleEntry": [[32, 54]]}}}, {"text": "If you need the class to be immutable, you could use the AbstractMap.SimpleImmutableEntry class instead", "label": {"api": {"AbstractMap.SimpleImmutableEntry": [[57, 88]]}}}, {"text": "See ArrayList.remove(Object obj)", "label": {"api": {"ArrayList.remove(Object obj)": [[4, 31]]}}}, {"text": "You aren't checking the return value from ResultSet.next()", "label": {"api": {"ResultSet.next()": [[42, 57]]}}}, {"text": "Here I'm using List.sort and Comparator.comparing methods", "label": {"api": {"List.sort": [[15, 23]], "Comparator.comparing": [[29, 48]]}}}, {"text": "You haven’t said what type of component contains the double-clicked text, but if it’s a JTextField or JTextArea or any other subclass of JTextComponent, you can simply call copy()", "label": {"api": {"copy()": [[173, 178]]}}}, {"text": "You can use the built-in ordinal() method that comes with enums", "label": {"api": {"ordinal()": [[25, 33]]}}}, {"text": "Javadoc to the rescue", "label": {"api": {"Javadoc to the rescue": [[0, 20]]}}}, {"text": "You don't need to make your Fruit class implement Comparable<Fruit>; you can do it by passing a custom Comparator to the array, like this", "label": {"api": {"passing a custom Comparator to the array": [[86, 125]]}}}, {"text": "This uses the Comparator.comparing method", "label": {"api": {"Comparator.comparing": [[14, 33]]}}}, {"text": "Given your updates to the question, the answer is build around enums and maps", "label": {"api": {"maps": [[73, 76]]}}}, {"text": "you could use either Calendar#before or Calendar#after to make a comparison which returns a boolean", "label": {"api": {"Calendar#before": [[21, 35]], "Calendar#after": [[40, 53]]}}}, {"text": "There's no caching in Java itself, but there's SoftReference", "label": {"api": {"SoftReference": [[47, 59]]}}}, {"text": "Yes, Java offers three types of indirect references which are sensitive to memory usage", "label": {"api": {"three types of indirect references": [[17, 50]]}}}, {"text": "A cache can use a SoftReference that will be cleared before the process raises an OutOfMemoryError", "label": {"api": {"SoftReference": [[18, 30]]}}}, {"text": "As long as there is plenty of memory, however, the SoftReference will prevent its referent from being garbage collected", "label": {"api": {"SoftReference": [[51, 63]]}}}, {"text": "I don't see all code but I suppose You Should use in Your if condition string.equals(Object other) instead of \"==\" operator", "label": {"api": {"string.equals(Object other)": [[71, 97]]}}}, {"text": "Yor map was ignored by the driver because you should have provided classes' names which implement SQLData", "label": {"api": {"SQLData": [[98, 104]]}}}, {"text": "Altough it is not explicitly set in getObject(int,Map)'s documentation, you can see it mentioned in getObject(int,Class)", "label": {"api": {"getObject(int,Map)": [[36, 53]], "getObject(int,Class)": [[100, 119]]}}}, {"text": "Read all about SQLData to learn how to set yor own custom mapping", "label": {"api": {"SQLData": [[15, 21]]}}}, {"text": "Java throws ArrayStoreException when an attempt has been made to store the wrong type of object into an array of objects", "label": {"api": {"ArrayStoreException": [[12, 30]]}}}, {"text": "Here's javadoc for replaceAll method", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "A much better way of executing code in java is ProcessBuilder", "label": {"api": {"ProcessBuilder": [[47, 60]]}}}, {"text": "And this is what I'm doing with the Collection.removeIf method, whose predicate returns true if the key is not present in the hm1 map", "label": {"api": {"Collection.removeIf method": [[36, 61]]}}}, {"text": "Comparator<Person> is a class which has a method compare(Person, Person) method on it", "label": {"api": {"compare(Person, Person)": [[49, 71]]}}}, {"text": "Note that you can do your \"default\" example also with the natural ordering comparator", "label": {"api": {"natural ordering comparator": [[58, 84]]}}}, {"text": "In order to make this transition as smooth as possible, it would be ideal if the replacement queuing system (Kafka) had an asynchronous subscription mechanism, similar to our current project's JMS mechanism of using MessageListener and MessageConsumer to subscribe to topics and receive asynchronous notifications", "label": {"api": {"MessageListener": [[216, 230]], "MessageConsumer": [[236, 250]]}}}, {"text": "You should read up on what a URI actually is", "label": {"api": {"what a URI actually is": [[22, 43]]}}}, {"text": "You can convert a file name to a URI with the Path.toUri method", "label": {"api": {"Path.toUri": [[46, 55]]}}}, {"text": "Math is in the java.lang package, so it's part of Java's native language; there is no 3rd-party library involved", "label": {"api": {"Math": [[0, 3]]}}}, {"text": "Math.pow(double x, double y) takes two doubles--x and y--and returns the double representation of x^y", "label": {"api": {"Math": [[0, 3]], "Math.pow(double x, double y)": [[0, 27]]}}}, {"text": "Perhaps the easiest way is by using Java's implementation of Future", "label": {"api": {"Future": [[61, 66]]}}}, {"text": "You can define one (or more) Futures which will execute on separate threads, block until they are all done with Future.get(), and then complete your other tasks based on the results", "label": {"api": {"Future": [[29, 34], [112, 117]], "Future.get()": [[112, 123]]}}}, {"text": "The starting points are calculated at random and are in scene co-ordinates, then converted to local co-ordinates via the sceneToLocal function", "label": {"api": {"sceneToLocal": [[121, 132]]}}}, {"text": "You can use CyclicBarrier", "label": {"api": {"CyclicBarrier": [[12, 24]]}}}, {"text": "The groupingBy puts all prio1-matching entries from the prio1 and prio2 filtered entries into the key true and the remaining prio2-matching entries into false", "label": {"api": {"groupingBy": [[4, 13]]}}}, {"text": "Does ThreadLocalRandom's nextInt() method (i.e", "label": {"api": {"ThreadLocalRandom's nextInt() method": [[5, 40]]}}}, {"text": "between Integer.MIN_VALUE and Integer.MAX_VALUE) or is there some implicit range (e.g", "label": {"api": {"Integer.MIN_VALUE": [[8, 24]], "Integer.MAX_VALUE": [[30, 46]]}}}, {"text": "The Javadoc doesn't explicitly state whether or not an implicit range is used but the source code for ThreadLocalRandom seems to indicate that no range is used as ThreadLocalRandom's nextInt() method is actually java.util.Random's nextInt() method, which calls java.util.Random.next(32)", "label": {"api": {"ThreadLocalRandom's nextInt() method": [[163, 198]], "java.util.Random.next(32)": [[261, 285]]}}}, {"text": "Javadoc of invoke() says", "label": {"api": {"invoke()": [[11, 18]]}}}, {"text": "Javadoc of Integer.getInteger(String nm) says", "label": {"api": {"Integer.getInteger(String nm)": [[11, 39]]}}}, {"text": "You should be calling Integer.valueOf(String s)", "label": {"api": {"Integer.valueOf(String s)": [[22, 46]]}}}, {"text": "Alternatively pass an instance of an Calendar with your local timezone (Calendar.getInstance()) to PreparedStatement.setTimestamp", "label": {"api": {"PreparedStatement.setTimestamp": [[99, 128]]}}}, {"text": "If you operate on Java 8 or newer, please consider using Collection::removeIf and give it a predicate lambda to select the items to remove", "label": {"api": {"Collection::removeIf": [[57, 76]]}}}, {"text": "The method getName(), does not provide you with the password in the field, instead it gives you the name of the component (which in your code isn't even set)", "label": {"api": {"getName()": [[11, 19]]}}}, {"text": "If you want to obtain the password from the JPasswordField, you need to use getPassword()", "label": {"api": {"getPassword()": [[76, 88]]}}}, {"text": "As you know, JOptionPane.showOptionDialog() returns an int, not a String", "label": {"api": {"JOptionPane.showOptionDialog()": [[13, 42]]}}}, {"text": "I annotated Sorter as a @FunctionalInterface above, which notes that the interface is intended to be used to construct lambda expressions", "label": {"api": {"@FunctionalInterface": [[24, 43]]}}}, {"text": "For example, we can use Arrays.sort() as our strategy", "label": {"api": {"Arrays.sort()": [[24, 36]]}}}, {"text": "The documentation for plaf.basic is a little foreboding, but I've seen some other answers around SO saying that setting the UI is fine", "label": {"api": {"documentation for plaf.basic": [[4, 31]]}}}, {"text": "A Duration represents a span of time not attached to the timeline", "label": {"api": {"Duration": [[2, 9]]}}}, {"text": "Essentially I'm looking for something similar to Files#walk but for directories", "label": {"api": {"Files#walk": [[49, 58]]}}}, {"text": "Where required, the isSameFile method may be used to check if two paths locate the same file", "label": {"api": {"isSameFile": [[20, 29]]}}}, {"text": "Since your Paths are not tested with regards of the FileSystem, you should use Files::isSameFile", "label": {"api": {"isSameFile": [[86, 95]], "Files::isSameFile": [[79, 95]]}}}, {"text": "TreeSet sorts elements according to its natural ordering, so you can get the largest element", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "getDeclaredMethods includes all methods declared by the class itself, whereas getMethods returns only public methods, but also those inherited from a base class (here from java.lang.Object)", "label": {"api": {"getDeclaredMethod": [[0, 16]], "getMethods": [[78, 87]]}}}, {"text": "Read more about it in the Javadocs for getDeclaredMethod and getMethods", "label": {"api": {"getDeclaredMethod": [[39, 55]], "getMethods": [[61, 70]]}}}, {"text": "Then, using a StringConverter using this same class as type, you define the method toString to return the String you want", "label": {"api": {"StringConverter": [[14, 28]]}}}, {"text": "Then to get the selectedValue, get the selectionModel, and get the item with getModelItem", "label": {"api": {"selectionModel": [[39, 52]], "getModelItem": [[77, 88]]}}}, {"text": "String::split can take a second parameter indicating how many groups to form, which in your case is 5", "label": {"api": {"String::split can take a second parameter": [[0, 40]]}}}, {"text": "I can only guess that with SecretKeySpec changing the algorithm doesn't matter because", "label": {"api": {"SecretKeySpec": [[27, 39]]}}}, {"text": "I think you are looking for database metadata", "label": {"api": {"database metadata": [[28, 44]]}}}, {"text": "You can obtain database metadata from database connection via getMetaData() method", "label": {"api": {"database metadata": [[15, 31]], "getMetaData() method": [[62, 81]]}}}, {"text": "Look at the getExportedKeys() method of the obtained DatabaseMetaData implementation", "label": {"api": {"getExportedKeys()": [[12, 28]]}}}, {"text": "You need to use a custom Comparator", "label": {"api": {"Comparator": [[25, 34]]}}}, {"text": "Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow precise control over the sort order", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "Below a Comparator implementation valid since java 1.2", "label": {"api": {"Comparator": [[8, 17]]}}}, {"text": "You would be rather looking towards String.match() for example", "label": {"api": {"String.match()": [[36, 49]]}}}, {"text": "Here I'm using the Collectors.toMap utility, which collects the elements of the stream by determining the key and value of the map, accepting a merge function that is used to merge elements when the key is equal", "label": {"api": {"Collectors.toMap": [[19, 34]]}}}, {"text": "I've left this as UPPERCASE (you can use equalsIgnoreCase if you don't care about case)", "label": {"api": {"equalsIgnoreCase": [[41, 56]]}}}, {"text": "If I understand correctly, you do not want to use regex (which is what String.replaceAll does), just do literal string replacement with String.replace, and use one fewer backslash", "label": {"api": {"String.replace": [[71, 84], [136, 149]]}}}, {"text": "The following using the Future.get() method would block the current thread until the send is completed before performing some action", "label": {"api": {"Future.get()": [[24, 35]]}}}, {"text": "You could try using String#matches() on each product to see if the fragment entered is a partial match", "label": {"api": {"String#matches()": [[20, 35]]}}}, {"text": "This code uses Java 8 Streams to filter out the matching products", "label": {"api": {"Streams": [[22, 28]]}}}, {"text": "read the javadoc of the classes you are using, this behavior is explicitly documented", "label": {"api": {"documented": [[75, 84]]}}}, {"text": "If you want to be able to work with arbitrary sized Integer values; use the existing java.math.BigInteger class", "label": {"api": {"java.math.BigInteger": [[85, 104]]}}}, {"text": "If you call OutputStream.write(int), which is a method for writing a single byte, it will ignore all the bits except the bottom eight", "label": {"api": {"OutputStream.write(int)": [[12, 34]]}}}, {"text": "For instance, DataOutputStream.writeInt writes an integer as four bytes, because that's what that method is for", "label": {"api": {"DataOutputStream.writeInt": [[14, 38]]}}}, {"text": "You can then subclass the java.util.logging.FileHandler to recognize the new pattern syntax", "label": {"api": {"java.util.logging.FileHandler": [[26, 54]]}}}, {"text": "If you want duplicates removed and keeping order why don't you use a TreeSet", "label": {"api": {"TreeSet": [[69, 75]]}}}, {"text": "Rather than using an inline style, I would recommend setting the background via the background property directly", "label": {"api": {"background property": [[84, 102]]}}}, {"text": "The Background class provides Java API programmatic access to all the same properties that can be set by CSS", "label": {"api": {"Background": [[4, 13]]}}}, {"text": "note - usually you should use Stack#empty method to determine whether there are still elements left in the Stack or not.The only reason I've used a for loop here is just to organise the output while performing pop() operation on the elements", "label": {"api": {"Stack#empty": [[30, 40]]}}}, {"text": "Some of these sequences exist, others don't, you can check the Pattern docs for details", "label": {"api": {"Pattern docs": [[63, 74]]}}}, {"text": "In any case, you will be better served using language utilities like String.split() to count your words, unless you're required to do it manually", "label": {"api": {"String.split()": [[69, 82]]}}}, {"text": "If this is a program where you don't want or expect the console for any input or output, you can reset stdin, stdout, and stderr through System calls, but that could be seen as confusing and somewhat drastic", "label": {"api": {"System calls": [[137, 148]]}}}, {"text": "The user, Basil Bourque, provided a better solution than the one I provided below by using Java's YearMonth class", "label": {"api": {"Month": [[102, 106]]}}}, {"text": "Using the Month enum", "label": {"api": {"Month": [[10, 14]]}}}, {"text": "If you'd rather not use an external library, you can emulate it with a nested Map", "label": {"api": {"Map": [[78, 80]]}}}, {"text": "An easy way is Collections.rotate", "label": {"api": {"Collections.rotate": [[15, 32]]}}}, {"text": "As I mentioned in my comment, a GridPane would be a better option for you, to do this you can do it like this", "label": {"api": {"GridPane": [[32, 39]]}}}, {"text": "for more information you can refer to GridPane on the Oracle page", "label": {"api": {"GridPane": [[38, 45]]}}}, {"text": "You can use String::format", "label": {"api": {"String::format": [[12, 25]]}}}, {"text": "Although it is true that the only \"elements\" in a String are characters, you can use String.charAt(int) to get a character at a valid index (but you cannot use [])", "label": {"api": {"String.charAt(int)": [[85, 102]]}}}, {"text": "If you just want to check if the entered number is valid for a certain base, you can use Long.parseLong's overload which receives a radix as a second parameter and will raise an exception if the number is invalid for the selected radix", "label": {"api": {"Long.parseLong": [[89, 102]]}}}, {"text": "JavaFX has the abstract class Material for representing materials of 3D surfaces", "label": {"api": {"abstract class Material": [[15, 37]]}}}, {"text": "The current JDK gives only a PhongMaterial implementation", "label": {"api": {"PhongMaterial": [[29, 41]]}}}, {"text": "I was looking into adding my own material (like Lambert or Blinn etc.) by extending Material similar to how PhongMaterial is implemented", "label": {"api": {"PhongMaterial": [[108, 120]]}}}, {"text": "The behavior (color calculation) specified in the PhongMaterial documentation is nowhere to be found - not in the class itself and not in the internal classes Iv'e looked at", "label": {"api": {"PhongMaterial": [[50, 62]]}}}, {"text": "The PhongMaterial class only holds the properties and not the behavior, which I find strange to begin with", "label": {"api": {"PhongMaterial": [[4, 16]]}}}, {"text": "PhongMaterial appears to be deeply coupled with internal classes", "label": {"api": {"PhongMaterial": [[0, 12]]}}}, {"text": "com.sun.javafx.sg.prism.NGPhongMaterial, which according to some documentation is the peer node created by the graphics Toolkit/Pipeline implementation", "label": {"api": {"PhongMaterial": [[26, 38]]}}}, {"text": "com.sun.prism.PhongMaterial, which represents a phong material for retained mode rendering", "label": {"api": {"PhongMaterial": [[14, 26]]}}}, {"text": "com.sun.prism.TextureMap is a wrapper class to hold map related information for the PhongMaterial", "label": {"api": {"PhongMaterial": [[84, 96]]}}}, {"text": "Additionally, you would need to use FilteredList and FXCollections.observableArrayList(extractor)", "label": {"api": {"FilteredList": [[36, 47]], "FXCollections.observableArrayList(extractor)": [[53, 96]]}}}, {"text": "To make sure it responds to changes of the state of existing rooms, you need to use FXCollections.observableArrayList(extractor) overload", "label": {"api": {"FXCollections.observableArrayList(extractor)": [[84, 127]]}}}, {"text": "do all Java implementations need to comply with this version or could an implementation define the behaviour of some methods and classes differently, as long as it's compatible with the JLS", "label": {"api": {"this version": [[48, 59]]}}}, {"text": "To generate a secure key, use a KeyGenerator", "label": {"api": {"KeyGenerator": [[32, 43]]}}}, {"text": "HashMap does not guarantee/retain the insertion order of the elements, so use LinkedHashMap to preserve the order of the characters you are inserting", "label": {"api": {"HashMap": [[0, 6], [84, 90]]}}}, {"text": "However, if creating a class such as Person is not an option, you could still accomplish what you want with the help of a TreeMap, which sorts the entries by key", "label": {"api": {"TreeMap": [[122, 128]]}}}, {"text": "Here I'm using the Map.computeIfAbsent method", "label": {"api": {"Map.computeIfAbsent": [[19, 37]]}}}, {"text": "I'm streaming the values of the map (which are lists), and then I use the Stream.flatMap method to flatten the stream of lists to a stream that contains the elements of all lists, in sequence", "label": {"api": {"Stream.flatMap": [[74, 87]]}}}, {"text": "Then I transform those indices into their corresponding names from the acc.names list via the Stream.map method, and finally print them", "label": {"api": {"Stream.map": [[94, 103]]}}}, {"text": "One thing you can do is cast the script engine to a Compilable, and use it to make a CompiledScript for repeated invocation", "label": {"api": {"Compilable": [[52, 61]]}}}, {"text": "Implementations of NavigableMap, such as TreeMap, provide methods to look up keys \"adjacent to\" a given value, without requiring an exact map", "label": {"api": {"NavigableMap": [[19, 30]], "TreeMap": [[41, 47]]}}}, {"text": "The higherEntry method seems to do what you want", "label": {"api": {"higherEntry": [[4, 14]]}}}, {"text": "Allways use method equals method for comparing Strings", "label": {"api": {"equals": [[19, 24]]}}}, {"text": "You need to write a Java agent and attach it dynamically to transform a class after it was already loaded", "label": {"api": {"a Java agent": [[18, 29]]}}}, {"text": "With such a Java agent, the changes you are allowed to apply are however limited to changing the body of a method, you cannot add members (fields or methods) or change the signature of existing ones", "label": {"api": {"a Java agent": [[10, 21]]}}}, {"text": "I do know .count already, but it seems to work well only if I exchange a .forEach with a .map and use the .count as terminal operation instead", "label": {"api": {".count": [[10, 15], [106, 111]]}}}, {"text": "Java 7 introduced java.lang.Objects with nice little helper methods such as requireNonNull()", "label": {"api": {"java.lang.Objects": [[18, 34]]}}}, {"text": "Attempting to assume a String contains bytes will result in the corruption of your bytes;  specifically, String.getBytes() encodes the String’s codepoints using a charset encoding transformation", "label": {"api": {"encodes": [[123, 129]]}}}, {"text": "The correct way to create a Base 64 encoded string is with the encodeToString method", "label": {"api": {"encodeToString": [[63, 76]]}}}, {"text": "An alternative to removing all the duplicated \"AA\" from the list is using Stream#filter method to keep all the elements that don't have the value of \"AA\"", "label": {"api": {"Stream#filter": [[74, 86]]}}}, {"text": "The format you are asking for is exactly what DateTimeFormatter.ISO_OFFSET_DATE_TIME is giving you", "label": {"api": {"DateTimeFormatter.ISO_OFFSET_DATE_TIME": [[46, 83]]}}}, {"text": "Is there some equals-utility that lets you first extract a key just like there is Comparator.comparing which accepts a key extractor function", "label": {"api": {"Comparator.comparing": [[82, 101]]}}}, {"text": "In Java BigDecimal holds only the numeric value, so it won't be possible to store the number -000000000000256.07 in a BigDecimal, all the leading zeros will be ommitted", "label": {"api": {"BigDecimal": [[8, 17], [118, 127]]}}}, {"text": "You can instead store it as -256.07 in a BigDecimal then format it again (when you need to display it), using DecimalFormat", "label": {"api": {"BigDecimal": [[41, 50]], "DecimalFormat": [[110, 122]]}}}, {"text": "Refer the link", "label": {"api": {"link": [[10, 13]]}}}, {"text": "Scala version 2.12 supports converting lambda expressions to types with a  \"single abstract method\" (SAM), aka \"Functional Interface\", like Java 8 does", "label": {"api": {"Functional Interface": [[112, 131]]}}}, {"text": "Run a new program with ProcessBuilder", "label": {"api": {"ProcessBuilder": [[23, 36]]}}}, {"text": "The JLS is accurate, but you've made an incorrect assumption about what Class.getMethods() returns", "label": {"api": {"Class.getMethods()": [[72, 89]]}}}, {"text": "Collections#frequency would be appropriate if you wanted to count how many times a particular Human object appeared in your list", "label": {"api": {"Collections#frequency": [[0, 20]]}}}, {"text": "Use the withLaterOffsetAtOverlap() method", "label": {"api": {"withLaterOffsetAtOverlap()": [[8, 33]]}}}, {"text": "Basically, a LinkedList IS-A Collection, so you can simply typecast collection object (from super class Class1) to  linkedList object and return the first element as shown below", "label": {"api": {"LinkedList": [[13, 22]], "Collection": [[29, 38]]}}}, {"text": "To use it load a KeyStore with \"algorithm\" \"PKCS12\"", "label": {"api": {"KeyStore": [[17, 24]]}}}, {"text": "you could combine String#substring and String#indexOf to retrieve the required data", "label": {"api": {"String#substring": [[18, 33]], "String#indexOf": [[39, 52]]}}}, {"text": "I suggest you can simply use Collections.shuffle() as shown below rather than reinventing the shuffling logic which is already provided by Collections API", "label": {"api": {"Collections.shuffle()": [[29, 49]]}}}, {"text": "Use SimpleDateFormat to parse() the time column and create a time series chart, as shown here", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "I'd suggest using IntStream.generate(IntSupplier s), with an IntSupplier that remembers previously generated prime numbers", "label": {"api": {"IntStream.generate(IntSupplier s)": [[18, 50]], "IntSupplier": [[37, 47], [61, 71]]}}}, {"text": "The latest release added support for sharing memory between python and java using numpy ndarrays and java  direct buffers", "label": {"api": {"direct buffers": [[107, 120]]}}}, {"text": "Using RandomAccessFile you'll be able to seek the file pointer to write new, or update an already existing record", "label": {"api": {"RandomAccessFile": [[6, 21]]}}}, {"text": "To be more portable, you may serialize the record using ByteBuffer, already used by FileChannel which is an interface to RandomAccessFile, see RandomAccessFile.getChannel()", "label": {"api": {"RandomAccessFile": [[121, 136], [143, 158]], "ByteBuffer": [[56, 65]], "FileChannel": [[84, 94]], "RandomAccessFile.getChannel()": [[143, 171]]}}}, {"text": "You need to use String API's contains() or equals() methods as shown below", "label": {"api": {"String": [[16, 21]], "contains()": [[29, 38]], "equals()": [[43, 50]]}}}, {"text": "If you are looking for the whole word match, then you need to use equals() as shown below", "label": {"api": {"equals()": [[66, 73]]}}}, {"text": "I assume you are looking for JMenuItems and also that you added them to your JMenu using add function", "label": {"api": {"add": [[58, 60], [89, 91]]}}}, {"text": "In that case you could use the getItemCount() and getItem(int pos) functions as below", "label": {"api": {"getItemCount()": [[31, 44]], "getItem(int pos)": [[50, 65]]}}}, {"text": "If you don't want to create your own class implementing Future and providing a setter (or extending FutureTask and making the setter public), you can use the ready-made CompletableFuture", "label": {"api": {"FutureTask": [[100, 109]], "CompletableFuture": [[169, 185]]}}}, {"text": "You can use Scanner's nextLine() which reads the newline instead of next() as shown below", "label": {"api": {"Scanner": [[12, 18]], "nextLine()": [[22, 31]]}}}, {"text": "Per the documentation, http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T- returns an int, which doesn't work as an if condition", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-": [[23, 101]]}}}, {"text": "Notice that in (T t, U u) -> test(t, u) || other.test(t, u); the test() method is on your IOBiPredicate (and therefore is specified as throws IOException), while other.test() is calling BiPredicate.test(), which does not", "label": {"api": {"BiPredicate.test()": [[186, 203]]}}}, {"text": "you might also want to use equalsIgnoreCase(String other)", "label": {"api": {"equalsIgnoreCase(String other)": [[27, 56]]}}}, {"text": "If you take a look at the split(String regex, int limit)(emphasis is mine)", "label": {"api": {"split(String regex, int limit)": [[26, 55]]}}}, {"text": "Alternatively, you can add all the numbers in the range to a list, and shuffle it", "label": {"api": {"shuffle": [[71, 77]]}}}, {"text": "Essentially, you'd need to find the index of a in each shuffled list", "label": {"api": {"shuffle": [[55, 61]]}}}, {"text": "You could print a sub-list of each string of guesses from zero to its respective correct index", "label": {"api": {"sub-list": [[18, 25]]}}}, {"text": "This comparison of StampedLock and other locks show that StampedLock is the fastest as contention rises", "label": {"api": {"StampedLock": [[19, 29], [57, 67]]}}}, {"text": "MalformedInputException means your text file is not in the charset (encoding) you requested", "label": {"api": {"MalformedInputException": [[0, 22]], "charset": [[59, 65]]}}}, {"text": "Although your code does not explicitly specify a charset, the Files.lines method always uses UTF-8", "label": {"api": {"charset": [[49, 55]], "Files.lines method always uses UTF-8": [[62, 97]]}}}, {"text": "Bytes from the file are decoded into characters using the UTF-8 charset", "label": {"api": {"charset": [[64, 70]]}}}, {"text": "Since your text file is not a UTF-8 text file, you’ll need to specify its charset in your code", "label": {"api": {"charset": [[74, 80]], "specify its charset": [[62, 80]]}}}, {"text": "If you aren’t sure, the file probably uses the system’s default charset", "label": {"api": {"charset": [[64, 70]]}}}, {"text": "You have stated in a comment that your text file is “ANSI,” which is the (technically incorrect) name Windows uses for its one-byte charsets", "label": {"api": {"charset": [[132, 138]]}}}, {"text": "I use java.time.Period#getDays() to get the number of days for a given period of LocalDates", "label": {"api": {"java.time.Period#getDays()": [[6, 31]]}}}, {"text": "When you want to solve a problem using the Stream API, you should stop searching for solutions using forEach", "label": {"api": {"Stream": [[43, 48]]}}}, {"text": "A Stream has quite a few other methods to offer", "label": {"api": {"Stream": [[2, 7]]}}}, {"text": "But you may also read the package documentation or the tutorial to find ways to break out of the thinking in loops/forEach", "label": {"api": {"package documentation": [[26, 46]]}}}, {"text": "I haven't tried it, but I would try to create a 3D scene on a SubScene, and set that as the graphic property of the menu item", "label": {"api": {"SubScene": [[62, 69]], "graphic property": [[92, 107]]}}}, {"text": "Anyway to mix 2D and 3D you need to create SubScenes", "label": {"api": {"SubScene": [[43, 50]]}}}, {"text": "The return value from Integer.parseInt() is a primitive int", "label": {"api": {"Integer.parseInt()": [[22, 39]]}}}, {"text": "Integer.parseInt() will \"throw a NumberFormatException if the string does not contain a parsable integer\" (quoted from javadoc)", "label": {"api": {"Integer.parseInt()": [[0, 17]]}}}, {"text": "You can use CharsetEncoder to write directly to a ByteBuffer", "label": {"api": {"CharsetEncoder": [[12, 25]]}}}, {"text": "You can also check the result of the encode() method to see if it was successful", "label": {"api": {"encode()": [[37, 44]]}}}, {"text": "You need to use Stream#map method, something like this", "label": {"api": {"Stream#map": [[16, 25]]}}}, {"text": "If you want to provide a default that is not computed unless needed, you can use computeIfAbsent", "label": {"api": {"computeIfAbsent": [[81, 95]]}}}, {"text": "Reading the Javadoc for SimpleDateFormat, I found that using Z for timezone is very strict", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "With the new stream method in the Optional API as of JDK9, you can invoke the stream method to transform from Optional<T> to Stream<T> which then enables one to peek and then if you want to go back to the Optional<T> just invoke findFirst() or findAny()", "label": {"api": {"stream": [[13, 18], [78, 83]]}}}, {"text": "Use the stream API for Json", "label": {"api": {"stream API for Json": [[8, 26]]}}}, {"text": "First, create a single Shape by appending your lines to a Path2D", "label": {"api": {"Path2D": [[58, 63]]}}}, {"text": "Then, pass it to Graphics2D.fill(Shape)", "label": {"api": {"Graphics2D.fill(Shape)": [[17, 38]]}}}, {"text": "The split() method doesn't expect normal strings, but regular expressions", "label": {"api": {"split()": [[4, 10]], "regular expressions": [[54, 72]]}}}, {"text": "I now moved it away from the web.xml and placed it inside my Application as follows", "label": {"api": {"Application": [[61, 71]]}}}, {"text": "You should read the description of KeyEvent fully - it contains the answer", "label": {"api": {"KeyEvent": [[35, 42]]}}}, {"text": "list.remove() throws ConcurrentModificationException if you are removing elements while iterating it", "label": {"api": {"ConcurrentModificationException": [[21, 51]]}}}, {"text": "So, you need to use list.set() to set the value at an index while iterating the list as shown in the below code (follow the comments)", "label": {"api": {"list.set()": [[20, 29]]}}}, {"text": "indexOf has a version that accepts an index to start searching from", "label": {"api": {"version": [[14, 20]]}}}, {"text": "You could use toLowerCase()", "label": {"api": {"toLowerCase()": [[14, 26]]}}}, {"text": "Assuming that sdf is a SimpleDateFormat instance, format will never return null", "label": {"api": {"format": [[50, 55]]}}}, {"text": "Here more about patterns", "label": {"api": {"patterns": [[16, 23]]}}}, {"text": "When you turn to the java \"system classes\"; such as Collections or Objects you find a reasonable amount of \"helpful\" functionality there", "label": {"api": {"Collections": [[52, 62]], "Objects": [[67, 73]]}}}, {"text": "You should use a FilteredList for this functionality", "label": {"api": {"FilteredList": [[17, 28]]}}}, {"text": "In Java, every object inherits the method equals(Object obj) from the Object class", "label": {"api": {"Object class": [[70, 81]]}}}, {"text": "As a side note, if you are just generally concerned about having a collection without any duplicates, you can use a Set instead of a List, which will call that equals() method that you overrode to compare objects for you", "label": {"api": {"Set": [[116, 118]]}}}, {"text": "What we do here is we count the DoubleSummaryStatistics on the list (it counts the average, max, min etc", "label": {"api": {"DoubleSummaryStatistics": [[32, 54]]}}}, {"text": "I'd suggest you utilise Scanner#hasNextInt to identify whether an integer has been entered or not", "label": {"api": {"Scanner#hasNextInt": [[24, 41]]}}}, {"text": "As for when the \"user presses enter without typing anything\", we can simply use the String#isEmpty method", "label": {"api": {"String#isEmpty": [[84, 97]]}}}, {"text": "Usually the fastest way of sharing memory between Java and native code is by using direct ByteBuffers (ones that are created with allocateDirect)", "label": {"api": {"ByteBuffer": [[90, 99]]}}}, {"text": "The downside of using a ByteBuffer is that there is no data abstraction, like a class' field has a specific type, a position in the byte buffer does not", "label": {"api": {"ByteBuffer": [[24, 33]]}}}, {"text": "create another collection, collect all items that you'd like to remove and then removeAll() items", "label": {"api": {"removeAll()": [[80, 90]]}}}, {"text": "But to set it on properly it's better to use the Runtime.exec(String[] cmdarray, String[] envp) method", "label": {"api": {"Runtime.exec(String[] cmdarray, String[] envp)": [[49, 94]]}}}, {"text": "Because DefaultTableModel uses convertToVector() internally, updating the clickedData array used to create model2 does not change the content of the model's dataVector", "label": {"api": {"DefaultTableModel": [[8, 24]]}}}, {"text": "Class.getDeclaredMethods states the following", "label": {"api": {"Class.getDeclaredMethods": [[0, 23]]}}}, {"text": "Class.getDeclaredClasses, however, does not specify anything about the order of the elements in the returned array", "label": {"api": {"Class.getDeclaredClasses": [[0, 23]]}}}, {"text": "Based on what I can tell from the Database JDBC Developer's Guide, RAW maps to Java's byte[] type, which indicates that I should use ResultSet's getBytes() method", "label": {"api": {"ResultSet's getBytes() method": [[133, 161]]}}}, {"text": "You don't have compareTo method in Record class so that's why it's not found :) You probably should implement Comparable interface", "label": {"api": {"Comparable": [[110, 119]]}}}, {"text": "The method maxLength() returns the maximum length of this month in days, as the API documentation says", "label": {"api": {"API documentation": [[80, 96]]}}}, {"text": "The method maxLength() is not suitable to determine the context-dependent length of February (either 28 or 29 days)", "label": {"api": {"maxLength()": [[11, 21]]}}}]