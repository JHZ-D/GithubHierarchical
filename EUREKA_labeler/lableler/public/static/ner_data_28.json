[{"text": "You should consider the method lengthOfMonth() instead", "label": {"api": {"lengthOfMonth()": [[31, 45]]}}}, {"text": "The java.util.Date class, for whatever reason, was not designed to be immutable", "label": {"api": {"java.util.Date": [[4, 17]]}}}, {"text": "If you can avoid it, do not use java.util.Date", "label": {"api": {"java.util.Date": [[32, 45]]}}}, {"text": "I cannot understand, nor find a suitable example of the Collectors.toMap method with the Supplied argument; this one", "label": {"api": {"this one": [[108, 115]]}}}, {"text": "You can create a LinkedHashMap with groupingBy that will preserve the insertion order unlike HashMap", "label": {"api": {"LinkedHashMap": [[17, 29]], "groupingBy": [[36, 45]]}}}, {"text": "Here is the documentation for LinkedHashMap and the specific groupingBy I am using", "label": {"api": {"LinkedHashMap": [[30, 42]], "groupingBy": [[61, 70]]}}}, {"text": "Here is the section on Arrays, Language Basics, and the Tutorials Home, and the API Reference", "label": {"api": {"API Reference": [[80, 92]]}}}, {"text": "You can use Java API for it, Java provides ScheduledThreadPoolExecutor which will let you", "label": {"api": {"ScheduledThreadPoolExecutor": [[43, 69]]}}}, {"text": "As an aside, if you want the to get results back from the execution of thread then instead of using Runnable you can use Callable interface which lets you return something, and ScheduledThreadPoolExecutor has overloaded methods which let you pass a Callable object", "label": {"api": {"ScheduledThreadPoolExecutor": [[177, 203]]}}}, {"text": "Take a look at Collectors.partitioningBy, which receives a predicate as an  argument", "label": {"api": {"Collectors.partitioningBy": [[15, 39]]}}}, {"text": "Note that Collectors.partitioningBy has an overloaded version that accepts a second argument, which is a downstream collector you can use if you want each partition to be collected to something different than a list", "label": {"api": {"Collectors.partitioningBy": [[10, 34]]}}}, {"text": "Collectors.partitioningBy will always have a result for true and false in the Map, i.e", "label": {"api": {"Collectors.partitioningBy": [[0, 24]]}}}, {"text": "In your case, you want to look into using DecimalFormat - you specify a pattern that can be used to extract the \"numberic\" parts of those strings", "label": {"api": {"DecimalFormat": [[42, 54]]}}}, {"text": "Floating point numbers come with rounding errors; thus you should rather look into using BigDecimal", "label": {"api": {"BigDecimal": [[89, 98]]}}}, {"text": "Or else you can also use try-with-resources (because Connection implements AutoCloseable) as shown below", "label": {"api": {"AutoCloseable": [[75, 87]]}}}, {"text": "Instances of your class can't be changed per se, but since Date is mutable (assuming it's java.util.Date), the information inside them could be changed", "label": {"api": {"java.util.Date": [[90, 103]]}}}, {"text": "Alternatively, use an immutable date type such as LocalDate or LocalDateTime instead of a mutable one", "label": {"api": {"LocalDate": [[50, 58], [63, 71]], "LocalDateTime": [[63, 75]]}}}, {"text": "Also, use java.util.Random nextInt() with an upper bound (in your case, the max value for the dice can be 6, so use upper bound as 7) to generate the random numbers as shown above", "label": {"api": {"java.util.Random": [[10, 25]]}}}, {"text": "You could use Collector.of to accumulate salaries on a per-state basis into an ArrayList, then use the finisher function to calculate the average for every state", "label": {"api": {"Collector.of": [[14, 25]]}}}, {"text": "Now, we can use Collector.of with this class", "label": {"api": {"Collector.of": [[16, 27]]}}}, {"text": "If you are using JDK1.7 or earlier, you need to use Iterator to safely remove the words occured only once as shown below", "label": {"api": {"Iterator": [[52, 59]]}}}, {"text": "Use the static Tooltip.install(node, tooltip) method to install a tooltip onto a node which does not possess a node.setTooltip(tooltip) method", "label": {"api": {"Tooltip.install(node, tooltip)": [[15, 44]]}}}, {"text": "The answer is in the documentation to finalize()", "label": {"api": {"finalize()": [[38, 47]]}}}, {"text": "A Map with the keys being the level string and the values being references of a functional interface type (Runnable or an appropriate interface from java.util.function, or your own) you can initialize with method references, lambdas, anonymous class instances, or even concrete class instances as required", "label": {"api": {"java.util.function": [[149, 166]]}}}, {"text": "You can use list1.removeAll(list2) to remove all list2 elements from list1", "label": {"api": {"list1.removeAll(list2)": [[12, 33]]}}}, {"text": "You can use .remove(Object o) method which deletes the first occurrence of the object", "label": {"api": {".remove(Object o)": [[12, 28]]}}}, {"text": "Is there a convenience method to compare a YearMonth against a LocalDate (or any other temporal) within Java 8 time API", "label": {"api": {"YearMonth": [[43, 51]], "LocalDate": [[63, 71]]}}}, {"text": "if I compare YearMonth to LocalDate I am only interested in the comparison of month and year (the common denominator of both)", "label": {"api": {"YearMonth": [[13, 21]], "LocalDate": [[26, 34]]}}}, {"text": "In the second version of indexOf an index to start searching from is provided", "label": {"api": {"indexOf": [[25, 31]]}}}, {"text": "Documentation for indexOf", "label": {"api": {"indexOf": [[18, 24]]}}}, {"text": "And as you mentioned, the javadoc of Iterator::remove is quite clear", "label": {"api": {"Iterator::remove": [[37, 52]]}}}, {"text": "Your condition will, however, cause the loop to exit if the Thread running it is interrupted by another thread calling interrupt() on it, assuming no other code in the loop calls interrupted() (which clears the current Thread’s interrupted status)", "label": {"api": {"interrupt()": [[119, 129]]}}}, {"text": "The text you have quoted is explaining that a Thread’s code must act on an interrupt, by checking the Thread’s interrupted status, or by calling a method capable of throwing InterruptedException (or ClosedByInterruptException)", "label": {"api": {"ClosedByInterruptException": [[199, 224]]}}}, {"text": "If the Thread’s code does none of those things, calling interrupt() on that Thread will have no effect on code execution;  it will merely set the Thread’s interrupted status, which is just a boolean property of the Thread", "label": {"api": {"interrupt()": [[56, 66]]}}}, {"text": "I would consider using the ArrayList data structure", "label": {"api": {"ArrayList": [[27, 35]]}}}, {"text": "If you are unfamiliar with how ArrayLists work I would read up on the documentation", "label": {"api": {"ArrayList": [[31, 39]]}}}, {"text": "ArrayList is resisable array.And is equivalent to C++ Vector", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "If you look at the Java SE documentation you will see that there is not a single interface named that way", "label": {"api": {"Java SE documentation": [[19, 39]]}}}, {"text": "In fact, you’ll find that Java SE classes work the same way;  see EnumSet and EnumMap for examples", "label": {"api": {"EnumSet": [[66, 72]], "EnumMap": [[78, 84]]}}}, {"text": "Another somewhat cleaner approach is using a Java 8 Function", "label": {"api": {"Function": [[52, 59]]}}}, {"text": "Use the built-in comparator for the field you want to use and apply the Comparator::reversed operation like this", "label": {"api": {"Comparator::reversed": [[72, 91]]}}}, {"text": "Use a cell factory", "label": {"api": {"cell factory": [[6, 17]]}}}, {"text": "The BufferedOutputStream allows to improve performance by using buffer", "label": {"api": {"BufferedOutputStream": [[4, 23]]}}}, {"text": "The next calls of the write() method of BufferedOutputStream will store bytes in buffer until it filled again", "label": {"api": {"BufferedOutputStream": [[40, 59]]}}}, {"text": "The ByteArrayOutputStream allows to write the stream of bytes to the array of bytes", "label": {"api": {"ByteArrayOutputStream": [[4, 24]]}}}, {"text": "Here's the javadoc", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "For String comparison , You need to use String#equals() method", "label": {"api": {"String#equals()": [[40, 54]]}}}, {"text": "The Arrays.asList version is immutable, that's the exact reason why it's throwing an  UnsupportedOperationException", "label": {"api": {"Arrays.asList": [[4, 16]]}}}, {"text": "Arrays.asList returns a fixed-size list backed by the specified array", "label": {"api": {"Arrays.asList": [[0, 12]]}}}, {"text": "What toMap does is", "label": {"api": {"toMap": [[5, 9]]}}}, {"text": "This uses the method Collector.of, which creates a custom collector based on its arguments", "label": {"api": {"Collector.of": [[21, 32]]}}}, {"text": "Then, you could use Collector.of with these methods", "label": {"api": {"Collector.of": [[20, 31]]}}}, {"text": "If yes, then you need to use contains method, here's the Javadoc", "label": {"api": {"here's": [[46, 51]]}}}, {"text": "Don't use executeQuery() for an INSERT statement", "label": {"api": {"executeQuery()": [[10, 23]]}}}, {"text": "Use Platform#runLater to update the GUI from a non-GUI thread", "label": {"api": {"Platform#runLater": [[4, 20]]}}}, {"text": "I assume you meant ArrayList when you said \"array\", since in Java you can't \"add\" to a full array", "label": {"api": {"ArrayList": [[19, 27]]}}}, {"text": "This distinction is important because inserting into an ArrayList at an arbitrary position is an O(n) operation, because all elements to the right must be \"shifted\" along by one position to make room for the element being inserted", "label": {"api": {"ArrayList": [[56, 64]]}}}, {"text": "Adding to (the tail of) a LinkedList is always a O(1) (constant time) operation", "label": {"api": {"LinkedList": [[26, 35]]}}}, {"text": "Adding to an ArrayList is usually a O(1) operation, but may be a O(n) operation if the backing array is full, because a new array must be allocated and every element copied across", "label": {"api": {"ArrayList": [[13, 21]]}}}, {"text": "In the general case of the array not being full, the performance of ArrayList is (slightly) faster than LinkedList, but the difference is very small", "label": {"api": {"ArrayList": [[68, 76]], "LinkedList": [[104, 113]]}}}, {"text": "The amortised cost of both is the same, but if constant time is required every time, only a LinkedList can do it", "label": {"api": {"LinkedList": [[92, 101]]}}}, {"text": "After running the code above, if you're not satisfied with their ranges than I would recommend using BigDecimal as this type doesn't have a limit (rather your RAM is the limit)", "label": {"api": {"BigDecimal": [[101, 110]]}}}, {"text": "You might need to use the specific overload of setTimestamp that takes a Calendar object if you want to represent a \"TIMESTAMP WITH TIME ZONE\" value", "label": {"api": {"setTimestamp": [[47, 58]]}}}, {"text": "You said only the Desktop directory exists, so you'll need to use mkdirs to construct the whole directory tree", "label": {"api": {"mkdirs": [[66, 71]]}}}, {"text": "I usually do it with CountDownLatch", "label": {"api": {"CountDownLatch": [[21, 34]]}}}, {"text": "Simply use split() method as below", "label": {"api": {"split()": [[11, 17]]}}}, {"text": "Considering the case you are using Java 8 and file is huge in size it is better to make use of Streams API", "label": {"api": {"Streams API": [[95, 105]]}}}, {"text": "Here's the java spec for 'Collections.shufffle'", "label": {"api": {"java spec": [[11, 19]]}}}, {"text": "This anonymous subclass overrides the cancel(bool) method with a new implementation", "label": {"api": {"cancel(bool)": [[38, 49]]}}}, {"text": "You can also use Java's Stack class", "label": {"api": {"Stack": [[24, 28]]}}}, {"text": "The \"correct\" answer is to use a BlockingQueue to connect sender / receivers - instead of re-inventing something \"like a queue\"", "label": {"api": {"BlockingQueue": [[33, 45]]}}}, {"text": "See here for more material how to use BlockingQueue", "label": {"api": {"BlockingQueue": [[38, 50]]}}}, {"text": "Stack extends Vector and so inherits all of Vector's public methods, one of which is elementAt(int)", "label": {"api": {"elementAt(int)": [[85, 98]]}}}, {"text": "You have mistakenly assumed that the argument to getResourceAsStream is supposed to be a file name", "label": {"api": {"getResourceAsStream": [[49, 67]]}}}, {"text": "If you want to load a Font directly from a File, don’t use getResourceAsStream", "label": {"api": {"getResourceAsStream": [[59, 77]]}}}, {"text": "From the Javadocs, there's a clear difference between compose and andThen", "label": {"api": {"compose": [[54, 60]], "andThen": [[66, 72]]}}}, {"text": "Returns a composed function that first applies the before function to its input, and then applies this function to the result", "label": {"api": {"compose": [[10, 16]]}}}, {"text": "Returns a composed function that first applies this function to its input, and then applies the after function to the result", "label": {"api": {"compose": [[10, 16]]}}}, {"text": "You may want to look at https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html that will allow you pause your test code until your business code has counted down on your latch", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html": [[24, 105]]}}}, {"text": "Use TreeMap which allows insertion in log n time and deletion in log n time", "label": {"api": {"TreeMap": [[4, 10]]}}}, {"text": "You can have there TreeMap<Integer,Integer> where key stores the value of element and value stores the frequency of the element", "label": {"api": {"TreeMap": [[19, 25]]}}}, {"text": "If you need to do only Insert and Delete operation , Use Java's Priority Queue", "label": {"api": {"Priority Queue": [[64, 77]]}}}, {"text": "You can do Insertion, Deletion by implementing the functions for TreeMap", "label": {"api": {"TreeMap": [[65, 71]]}}}, {"text": "Application.launch(args) is equivalent to Application.launch(TheClass.class, args), where TheClass is the immediately enclosing class of the method call", "label": {"api": {"Application.launch(args)": [[0, 23]], "Application.launch(TheClass.class, args)": [[42, 81]]}}}, {"text": "I'd use a TreeMap, reversing the keys and indexes", "label": {"api": {"TreeMap": [[10, 16]]}}}, {"text": "TreeMap orders iterations by the provided Comparator, so use Comparator.reverseOrder to get the largest-to-smallest ordering", "label": {"api": {"TreeMap": [[0, 6]], "Comparator": [[42, 51], [61, 70]], "Comparator.reverseOrder": [[61, 83]]}}}, {"text": "An ArrayList is an implementation of List", "label": {"api": {"List": [[8, 11], [37, 40]]}}}, {"text": "It's a List that is implemented using arrays", "label": {"api": {"List": [[7, 10]]}}}, {"text": "The list interface doesn't support the concept of multi-dimensional lists therefore you wouldn't expect ArrayList to either", "label": {"api": {"List": [[109, 112]], "list interface": [[4, 17]]}}}, {"text": "there is a Stack class in Java API", "label": {"api": {"Stack": [[11, 15]]}}}, {"text": "The Deque interface contains a little more than the Stack", "label": {"api": {"Stack": [[52, 56]], "Deque": [[4, 8]]}}}, {"text": "You can start any implementation, like ArrayDeque", "label": {"api": {"Deque": [[44, 48]], "ArrayDeque": [[39, 48]]}}}, {"text": "Similarly, there is a Queue interface with numerous implementations", "label": {"api": {"Queue": [[22, 26]]}}}, {"text": "ArrayDeque is one of them", "label": {"api": {"Deque": [[5, 9]], "ArrayDeque": [[0, 9]]}}}, {"text": "I was using the Point class to be used with these tokens", "label": {"api": {"Point": [[16, 20]]}}}, {"text": "Maybe you want to read the javadoc for ReentrantLock which explains the concept as well", "label": {"api": {"ReentrantLock": [[39, 51]]}}}, {"text": "or in Java8 DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[12, 28]]}}}, {"text": "If you are packaging JMeter into your solution you will need to unpack it somewhere in order to make it work", "label": {"api": {"unpack it somewhere": [[64, 82]]}}}, {"text": "Read more about this here", "label": {"api": {"Read more about this here": [[0, 24]]}}}, {"text": "You can also use the PseudoClass API", "label": {"api": {"PseudoClass": [[21, 31]]}}}, {"text": "There is also a possiblity to set the style attributes in runtime directly in the code by getting the divider Nodes from the scene-graph using the Node#lookupAll (or lookup) method, but I highly recommend to avoid this approach", "label": {"api": {"Node#lookupAll": [[147, 160]]}}}, {"text": "You can use for example the focusOwnerProperty of the Scene", "label": {"api": {"focusOwnerProperty": [[28, 45]]}}}, {"text": "where checkFocus checks recursively the focusedProperty of the nodes originated from the VBox", "label": {"api": {"focusedProperty": [[40, 54]]}}}, {"text": "You could find the information you need into DatabaseMetaData documentation", "label": {"api": {"DatabaseMetaData documentation": [[45, 74]]}}}, {"text": "Here's the javadoc for enum's equals() method and this is what it says", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "Use this for String.valueOf()", "label": {"api": {"String.valueOf()": [[13, 28]]}}}, {"text": "From the documentation for JEditorPane.setPage", "label": {"api": {"documentation for JEditorPane.setPage": [[9, 45]]}}}, {"text": "From the documentation of HTMLEditorKit", "label": {"api": {"documentation of HTMLEditorKit": [[9, 38]]}}}, {"text": "Make sure to check and see if the list is empty first or use Optional, otherwise you might get a NoSuchElementException", "label": {"api": {"Optional": [[61, 68]]}}}, {"text": "Use Jframe.dispose() instead on the one you want to close", "label": {"api": {"dispose": [[11, 17]]}}}, {"text": "Ignoring the Swing threading issue present in your code, you have to call Handler.isLoggable(Record) so your publish method respects the log level you have set", "label": {"api": {"Handler.isLoggable(Record)": [[74, 99]]}}}, {"text": "I have an EventHandler that I set as an event filter on TextFields", "label": {"api": {"event filter": [[40, 51]]}}}, {"text": "When I write the class, I get the source TextField by calling getSource() on the event and casting it to a TextField", "label": {"api": {"getSource()": [[62, 72]]}}}, {"text": "How can I write the class so that it can't be used anywhere except as an event filter for a TextField", "label": {"api": {"event filter": [[73, 84]]}}}, {"text": "But if you need to get this highest element many times, or, if after getting this highest element, you also need to get the second highest element, then you could perfectly use a PriorityQueue", "label": {"api": {"PriorityQueue": [[179, 191]]}}}, {"text": "Then, you could use your queue to get the element with the highest priority by means of the PriorityQueue.peek method", "label": {"api": {"PriorityQueue": [[92, 104]], "PriorityQueue.peek": [[92, 109]]}}}, {"text": "If you want to get and remove the element from the queue instead, you should use the PriorityQueue.poll method", "label": {"api": {"PriorityQueue": [[85, 97]], "PriorityQueue.poll": [[85, 102]]}}}, {"text": "You can use BigDecimal to get perfect math, but it is much slower", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "Here's a BigDecimal tutorial", "label": {"api": {"BigDecimal": [[9, 18]]}}}, {"text": "But, there is another reason to introduce an abstract class and pull down all static methods to the abstract class when you using java Proxy api", "label": {"api": {"Proxy": [[135, 139]]}}}, {"text": "In the documentation (https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) you can find the Java implementations of Collection in the \"All Known Implementing Classes\" section", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html": [[22, 88]]}}}, {"text": "You have Timestamp::compareTo(java.util.Date o) in java.sql.TimeStamp class", "label": {"api": {"Timestamp::compareTo(java.util.Date o)": [[9, 46]], "java.sql.TimeStamp": [[51, 68]]}}}, {"text": "If you want to append to the end of the TextArea you can use appendText rather than setText", "label": {"api": {"appendText": [[61, 70]]}}}, {"text": "In the code of TextInputControl, appendText will call insertText as insertText(getLength(), text); therefore textArea.appendText(str + \"\\n\"); and textArea.insertText(textArea.getLength(), str + \"\\n\"); are equal", "label": {"api": {"appendText": [[33, 42], [118, 127]]}}}, {"text": "you use one of the many methods on String, such as contains()", "label": {"api": {"contains()": [[51, 60]]}}}, {"text": "If you need something \"more fuzzy\", you would be turning to matches() fore example which takes a regular expression", "label": {"api": {"matches()": [[60, 68]]}}}, {"text": "Those allow for a great deal of \"fine tuned\" patterns to be used", "label": {"api": {"patterns": [[45, 52]]}}}, {"text": "You should use JList.isSelectionEmpty() as a condition instead of testing against the value that might be null", "label": {"api": {"JList.isSelectionEmpty()": [[15, 38]]}}}, {"text": "Regarding the @PreDestroy you could overwrite Object.finalize", "label": {"api": {"Object.finalize": [[46, 60]]}}}, {"text": "You might want to create an ArrayList and add all the Arrays of files to it", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "You can use the standard class java.util.Base64 for this", "label": {"api": {"java.util.Base64": [[31, 46]]}}}, {"text": "(The documentation for Stage explicitly states that \"Stage objects must be constructed and modified on the FX Application Thread\".) So you should do", "label": {"api": {"documentation for Stage": [[5, 27]]}}}, {"text": "I occasionally find myself needing to run code on some arbitrary thread or pass a Runnable to some arbitrary consumer, and missing the full functionality of java.util.concurrent -- for instance, writing Swing and JavaFX applications,  posting UI updates from a background thread to the main UI thread with SwingUtilities.invokeLater() or Platform.runLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[306, 333]], "Platform.runLater()": [[338, 356]]}}}, {"text": "It's easy enough to wrap APIs like these in an Executor", "label": {"api": {"Executor": [[47, 54]]}}}, {"text": "AbstractExecutorService provides some but not all of the methods needed to bootstrap a single-abstract-method Executor to a full ExecutorService", "label": {"api": {"Executor": [[8, 15], [110, 117], [129, 136]], "AbstractExecutorService": [[0, 22]], "ExecutorService": [[8, 22], [129, 143]]}}}, {"text": "This isn't really a question about Swing or JavaFX; those are just examples of the kind of situation that might require bootstrapping from an arbitrary thread or an Executor-like task runner to a full ExecutorService", "label": {"api": {"Executor": [[165, 172], [201, 208]], "ExecutorService": [[201, 215]]}}}, {"text": "Basically, you are not using substring() correctly", "label": {"api": {"substring() ": [[29, 40]]}}}, {"text": "If you want to guard against overflow, use the \"exact\" methods of Math (added in Java 8)", "label": {"api": {"Math": [[66, 69]]}}}, {"text": "you can accomplish your task with the use of BigInteger", "label": {"api": {"BigInteger": [[45, 54]]}}}, {"text": "Looks like you are confusing the org.apache.juli.FileHandler and the java.util.logging.FileHandler", "label": {"api": {"java.util.logging.FileHandler": [[69, 97]]}}}, {"text": "From the config file you are wanting to use the java.util.logging.FileHandler so you need to install that handler on the logger", "label": {"api": {"java.util.logging.FileHandler": [[48, 76]]}}}, {"text": "Just a BTW, with Java 9 there are static methods in the Map interface to create immutable Maps with some number of entries like", "label": {"api": {"static methods in the Map interface": [[34, 68]]}}}, {"text": "I solved the problem performing the transfer asynchronously using CompletableFuture(take a look at runAsync and supplyAsync methods)", "label": {"api": {"CompletableFuture": [[66, 82]]}}}, {"text": "CompletableFuture.allOf, CompletableFuture.thenCompose, etc..", "label": {"api": {"CompletableFuture": [[0, 16], [25, 41]]}}}, {"text": "I read some of the Scanner documentation, which says among other things", "label": {"api": {"Scanner documentation": [[19, 39]]}}}, {"text": "The definitive specification of the default delimiter is only stated in the documentation of Scanner.reset(), which resets the delimiter to the default", "label": {"api": {"Scanner.reset()": [[93, 107]]}}}, {"text": "As for loading the page, you’ll need a container capable of loading the page and executing its JavaScript;  the WebView class of JavaFX is one such container", "label": {"api": {"WebView": [[112, 118]]}}}, {"text": "Every WebView has an associated WebEngine which provides the loaded page as an XML Document (even if the original content was not XHTML);  you can use XPath on that Document to extract the text of the relevant <td> elements", "label": {"api": {"WebView": [[6, 12]], "Document": [[83, 90], [165, 172]], "XPath": [[151, 155]]}}}, {"text": "From the SortedSet documentation", "label": {"api": {"SortedSet documentation": [[9, 31]]}}}, {"text": "The explanation of “consistent with equals” is defined in the Comparable documentation", "label": {"api": {"Comparable documentation": [[62, 85]]}}}, {"text": "You can match using Pattern and Matcher this will return all matching instances, then you can iterate over the results and add to map", "label": {"api": {"Pattern": [[20, 26]], "Matcher": [[32, 38]]}}}, {"text": "A GridBagLayout uses the weightx and weighty properties of GridBagConstraints to determine how extra space is distributed", "label": {"api": {"GridBagLayout": [[2, 14]]}}}, {"text": "GridBagLayout uses the largest weightx of all cells in a column to determine the column’s actual horizontal weight for all cells in that column, and similarly, the largest weighty of all cells in a row determines that row’s vertical weight", "label": {"api": {"GridBagLayout": [[0, 12]]}}}, {"text": "You'll need to override the get method of the Supplier interface", "label": {"api": {"get": [[28, 30]]}}}, {"text": "You can use CipherInputStream and CipherOutputStream to enrypt Input and Output stream respectively", "label": {"api": {"CipherInputStream": [[12, 28]], "CipherOutputStream": [[34, 51]]}}}, {"text": "And you can use getString(1) to get the RESORT_NAME, check ResultSet .getString(int index) method for further details", "label": {"api": {"ResultSet .getString(int index) method": [[59, 96]]}}}, {"text": "I've read Java 8 comparable, these two examples(1,2)", "label": {"api": {"Java 8 comparable": [[10, 26]]}}}, {"text": "If you use a double, actually public BigDecimal(double val) is called", "label": {"api": {"public BigDecimal(double val)": [[30, 58]]}}}, {"text": "the javadoc of the constructor you're using, you'd already know the answer", "label": {"api": {"constructor": [[19, 29]]}}}, {"text": "When a double must be used as a source for a BigDecimal, note that this constructor provides an exact conversion; it does not give the same result as converting the double to a String using the Double.toString(double) method and then using the BigDecimal(String) constructor", "label": {"api": {"constructor": [[72, 82], [263, 273]], "Double.toString(double)": [[194, 216]], "BigDecimal(String)": [[244, 261]]}}}, {"text": "To get that result, use the static valueOf(double) method", "label": {"api": {"valueOf(double)": [[35, 49]]}}}, {"text": "When you then look at the javadoc of BigDecimal.valueOf(double), you'll find", "label": {"api": {"valueOf(double)": [[48, 62]], "BigDecimal.valueOf(double)": [[37, 62]]}}}, {"text": "This is generally the preferred way to convert a double (or float) into a BigDecimal, as the value returned is equal to that resulting from constructing a BigDecimal from the result of using Double.toString(double)", "label": {"api": {"Double.toString(double)": [[191, 213]]}}}, {"text": "From the Javadoc of Matcher.group(int)", "label": {"api": {"Javadoc of Matcher.group(int)": [[9, 37]]}}}, {"text": "Once you have done that you can implement Logout by invoking a servlet which calls HttpServletRequest.logout() and then invalidates the HttpSession", "label": {"api": {"HttpServletRequest.logout()": [[83, 109]]}}}, {"text": "plusDays doesn't alter the original LocalDate, you have to assign the result", "label": {"api": {"plusDays": [[0, 7]]}}}, {"text": "an implementation of the interface XMLStreamWriter", "label": {"api": {"XMLStreamWriter": [[35, 49]]}}}, {"text": "This is why you have thenAcceptAsync(), which will run your Consumer in a non-blocking way", "label": {"api": {"thenAcceptAsync()": [[21, 37]]}}}, {"text": "But a SQLite database file has internal structures for which the driver needs random access (like RandamAccessFile in Java)", "label": {"api": {"RandamAccessFile": [[98, 113]]}}}, {"text": "Instead, you could do it with a Function that extracts the desired property from the given object, as follows", "label": {"api": {"Function": [[32, 39]]}}}, {"text": "You're looking for a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[21, 33]], "Map": [[31, 33]]}}}, {"text": "If you go to the JavaDoc for an interface like Map, there's a \"All Known Implementing Classes\" section where you can see a list of all implementations in the JDK, and see if any meet your needs..", "label": {"api": {"Map": [[47, 49]]}}}, {"text": "You could use Collectors.collectingAndThen to add the entry with the total to every inner map", "label": {"api": {"Collectors.collectingAndThen": [[14, 41]]}}}, {"text": "Also, you should see Collectors.collectingAndThen", "label": {"api": {"Collectors.collectingAndThen": [[21, 48]]}}}, {"text": "You can get the appropriate method with Class.getMethod()", "label": {"api": {"Class.getMethod()": [[40, 56]]}}}, {"text": "Then you can invoke the method with Method.invoke()", "label": {"api": {"Method.invoke()": [[36, 50]]}}}, {"text": "Use Long.numberOfTrailingZeros - this will be exactly the index you are looking for", "label": {"api": {"Long.numberOfTrailingZeros": [[4, 29]]}}}, {"text": "Long.numberOfLeadingZeros can be also useful if you count bits starting from the highest one", "label": {"api": {"Long.numberOfLeadingZeros": [[0, 24]]}}}, {"text": "I have a GregorianCalendar object", "label": {"api": {"GregorianCalendar": [[9, 25]]}}}, {"text": "Both arrSort1  and arrSort are referencing the same array hence the outcome, you might want to use Arrays.copyOf", "label": {"api": {"Arrays.copyOf": [[99, 111]]}}}, {"text": "The register method returns the WatchKey, as described in the documentation, which has a cancel() method", "label": {"api": {"cancel()": [[89, 96]]}}}, {"text": "Have a look at the Optional documentation to see what functionality it provides", "label": {"api": {"Optional documentation": [[19, 40]]}}}, {"text": "You can use File::delete or evern File::deleteOnExit", "label": {"api": {"File::delete": [[12, 23], [34, 45]], "File::deleteOnExit": [[34, 51]]}}}, {"text": "This doesn't appear to be documented in the ClassLoader Javadoc", "label": {"api": {"ClassLoader": [[44, 54]]}}}, {"text": "Here I've used the Map.merge method, which uses the provided function (in this case Long::sum) to merge the provided value with the existent value (if the map already had a mapping for the given key), or maps the provided key to the provided value (if the map didn't contain a mapping for the given key)", "label": {"api": {"Map.merge": [[19, 27]]}}}, {"text": "Just like ConcurrentHashMap, you can synchronize the ArrayList using CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[69, 88]]}}}, {"text": "CopyOnWriteArrayList provides same thread safety but for an ArrayList", "label": {"api": {"CopyOnWriteArrayList": [[0, 19]]}}}, {"text": "To have your print statements work as you intend them to, you have to override the toString method", "label": {"api": {"toString": [[83, 90]]}}}, {"text": "The reason it's printing an empty array is that it's currently calling HashMap's toString, and, as you don't define any of the HashMap fields, it's treating it as an empty HashMap", "label": {"api": {"toString": [[81, 88]]}}}, {"text": "Use String#matches() with the pattern \\s*", "label": {"api": {"String#matches()": [[4, 19]]}}}, {"text": "You can use @PostConstruct to execute a particular method immediately after the constructor has done its work", "label": {"api": {"@PostConstruct": [[12, 25]]}}}, {"text": "If you don't know what a Map is, then read the Java collections tutorial, and the javadoc of the Map interface", "label": {"api": {"javadoc of the Map interface": [[82, 109]]}}}, {"text": "By reading the javadoc of String, you should be able to figure out how to loop through all the characters of that string", "label": {"api": {"javadoc of String": [[15, 31]]}}}, {"text": "The problem is that you defined a total_Guests variable twice (1) and tried to assign a String result of the showInputDialog method to the int variable (2)", "label": {"api": {"showInputDialog": [[109, 123]]}}}, {"text": "Have a look at the showInputDialog method declaration", "label": {"api": {"showInputDialog": [[19, 33]]}}}, {"text": "You could have matrixA be of type int[] and rowHolder have generic parameter Integer if you used a custom converter instead of ArrayList#toArray", "label": {"api": {"ArrayList#toArray": [[127, 143]]}}}, {"text": "If a CharSequence is enough, you can do this", "label": {"api": {"CharSequence": [[5, 16]]}}}, {"text": "LocalDateTime and LocalDate are incompatible types as is (although they both implement Temporal, in case you can work with that)", "label": {"api": {"Temporal": [[87, 94]]}}}, {"text": "Otherwise, you have a LocalDateTime#toLocalDate conversion method available", "label": {"api": {"LocalDateTime#toLocalDate": [[22, 46]]}}}, {"text": "flatMap is available for such a purpose", "label": {"api": {"flatMap": [[0, 6]]}}}, {"text": "It seems that the message format for lists doesn't like spaces in it", "label": {"api": {"message format": [[18, 31]]}}}, {"text": "if you don't intend to modify the list then you can use Arrays.asList", "label": {"api": {"Arrays.asList": [[56, 68]]}}}, {"text": "Workbook.create(InputStream inp) needs inp to support marking and reseting or be wrapped into PushbackInputStream", "label": {"api": {"PushbackInputStream": [[94, 112]]}}}, {"text": "You can use ServletRequest.getParameterNames(), ServletRequest.getParameterMap(), and ServletRequest.getParameter() methods to accomplish this task", "label": {"api": {"ServletRequest.getParameterNames()": [[12, 45]], "ServletRequest.getParameterMap()": [[48, 79]], "ServletRequest.getParameter()": [[86, 114]]}}}, {"text": "It sounds like you want a CompletableFuture", "label": {"api": {"CompletableFuture": [[26, 42]]}}}, {"text": "You've given your DateAxis a SimpleDateFormat override of \"ss.SS\", which shows seconds.milliseconds", "label": {"api": {"SimpleDateFormat": [[29, 44]]}}}, {"text": "You are probably looking for a BiConsumer", "label": {"api": {"a BiConsumer": [[29, 40]]}}}, {"text": "But now it seems that I have to handle some exception from JavaMail - MessagingException", "label": {"api": {"MessagingException": [[70, 87]]}}}, {"text": "You need to use ServletContext.getResource(), or to put the images undere WEB-INF/classes", "label": {"api": {"ServletContext.getResource()": [[16, 43]]}}}, {"text": "See DateTimeFormatterBuilder and the method appendText(TemporalField,Map)", "label": {"api": {"appendText(TemporalField,Map)": [[44, 72]]}}}, {"text": "If you are looking for exact match for comparing two arrays, you can use Arrays equals() method from JDK like Arrays.equals(array1, array2) as shown below", "label": {"api": {"Arrays.equals(array1, array2)": [[110, 138]]}}}, {"text": "Timestamp extends Date to provide nanosecond accuracy", "label": {"api": {"Timestamp": [[0, 8]]}}}, {"text": "Neither Date nor Timestamp are designed to refer to a specific timezone as ZoneDateTime", "label": {"api": {"Timestamp": [[17, 25]]}}}, {"text": "If you need to convert ZonedDateTime -> Timestamp you will have to discard the timezone/offset information", "label": {"api": {"Timestamp": [[40, 48]]}}}, {"text": "and for converting Timestamp -> ZonedDateTime you need to specify an offset", "label": {"api": {"Timestamp": [[19, 27]]}}}, {"text": "As a side note, depending on which version of Java you are using, I would recommend using the new java.time package (JDK 1.8+) or the back port of that package (JDK 1.6+) instead of the outdated (no pun intended) Date and/or Calendar classes", "label": {"api": {"java.time": [[98, 106]]}}}, {"text": "you can use Collections.sort and pass in your own comparator", "label": {"api": {"Collections.sort": [[12, 27]]}}}, {"text": "You could work around this by making a mutable container, an array or a list, but a better approach is to use stream's findFirst method", "label": {"api": {"findFirst": [[119, 127]]}}}, {"text": "Well you could just use split(String, int)) with a limit of 2", "label": {"api": {"split(String, int))": [[24, 42]]}}}, {"text": "It loads the file pretty much instantly and prints out 'Done' but it takes a long time (about an hour) for the String to be converted into a BigInteger, is there anything I can do to speed this up and quickly load the number", "label": {"api": {"BigInteger": [[141, 150]]}}}, {"text": "As an optimization, since BigInteger is Serializable, you could save it to a binary file once and speed up your loading considerably", "label": {"api": {"BigInteger": [[26, 35]], "Serializable": [[40, 51]]}}}, {"text": "Use ObjectOutputStream to save your big integer and ObjectInputStream to read it back in", "label": {"api": {"ObjectOutputStream": [[4, 21]], "ObjectInputStream": [[52, 68]]}}}, {"text": "reduce requires that the supplied function be associative", "label": {"api": {"reduce": [[0, 5]], "associative": [[46, 56]]}}}, {"text": "To be associative, the function must satisfy (x op y) op z == x op (y op z) for any x, y and z", "label": {"api": {"associative": [[6, 16]]}}}, {"text": "Furthermore, the first parameter supplied to reduce must be an identity with respect to the accumulator function", "label": {"api": {"reduce": [[45, 50]]}}}, {"text": "side note - I wouldn't recommend concatenating strings within a loop as that is a performance bottleneck, you're better off using a StringBuilder along with StringBuilder#append method", "label": {"api": {"StringBuilder": [[132, 144], [157, 169]], "StringBuilder#append": [[157, 176]]}}}, {"text": "If you can change getOriginDestinationList() and getFareList() you should make them return Collections.emptyList()", "label": {"api": {"Collections.emptyList()": [[91, 113]]}}}, {"text": "If you are not returning lists, you might consider to use an java.util.Optional", "label": {"api": {"java.util.Optional": [[61, 78]]}}}, {"text": "Objects.requireNotNull() could be helpful here", "label": {"api": {"Objects.requireNotNull()": [[0, 23]]}}}, {"text": "java.util.Date doesn't store time zone information", "label": {"api": {"java.util.Date": [[0, 13]]}}}, {"text": "To retain time zone, use ZonedDateTime or OffsetDateTime (Java 8+)", "label": {"api": {"ZonedDateTime": [[25, 37]], "OffsetDateTime": [[42, 55]]}}}, {"text": "As you can see in the Oracle Java doc the documentation says that Arrays.asList(..) returns a fixed sized list", "label": {"api": {"Oracle Java doc": [[22, 36]]}}}, {"text": "The Arrays.asList() javadoc briefly mentions", "label": {"api": {"Arrays.asList()": [[4, 18]]}}}, {"text": "I'm shocked this actually passed the compiler, but that aside, you clear a JTable, by setting the row count to 0, like the following", "label": {"api": {"setting the row count to 0": [[86, 111]]}}}, {"text": "Then I suggest you to use ProcessBuilder like", "label": {"api": {"ProcessBuilder": [[26, 39]]}}}, {"text": "At the end, I'm collecting the stream with Collector.of", "label": {"api": {"Collector.of": [[43, 54]]}}}, {"text": "The class you need is JAXBSource", "label": {"api": {"JAXBSource": [[22, 31]]}}}, {"text": "It implements the javax.xml.transform.Source interface and lets you provide an object and a JAXBContext or a Marshaller", "label": {"api": {"the javax.xml.transform.Source interface": [[14, 53]]}}}, {"text": "You can use a custom Comparator", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "You'll need to use String#compareTo to sort the object within the ArrayList by their names", "label": {"api": {"String#compareTo": [[19, 34]]}}}, {"text": "This helper method uses Collector.of and a local class Acc to accumulate the streams returned by the provided streamMapper function, which takes an element of the original stream as an argument", "label": {"api": {"Collector.of": [[24, 35]]}}}, {"text": "These streams are accumulated in a Stream.Builder that will be built when the collector's finisher function is applied", "label": {"api": {"Stream.Builder": [[35, 48]]}}}, {"text": "(I could have used a list of streams instead of a stream of streams, but I think that Stream.Builder is both very efficient and highly underused)", "label": {"api": {"Stream.Builder": [[86, 99]]}}}, {"text": "Here's the javadoc for parse method, this is what it says", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "Now also suppose you have a BiFunction<String, Integer, Person> that maps name and age arguments to instances of the Person class", "label": {"api": {"BiFunction<String, Integer, Person>": [[28, 62]]}}}, {"text": "Parse your input as a LocalDateTime object as it lacks any indication of time zone or offset-from-UTC", "label": {"api": {"LocalDateTime": [[22, 34]]}}}, {"text": "You should be able to force the trailing zeros you desire in the decimal fraction in a string representing the value of this LocalDateTime object", "label": {"api": {"LocalDateTime": [[125, 137]]}}}, {"text": "Use either a DateTimeFormatter or a DateTimeFormatterBuilder", "label": {"api": {"DateTimeFormatter": [[13, 29], [36, 52]], "DateTimeFormatterBuilder": [[36, 59]]}}}, {"text": "Check out class Random and use method nextInt(int n) to get a random integer in interval [0, n[ (note that n is exclusive)", "label": {"api": {"method nextInt(int n)": [[31, 51]]}}}, {"text": "You can use Files.lines() to stream the data from your file", "label": {"api": {"Files.lines()": [[12, 24]]}}}, {"text": "You can use Math.floor to reduce each float to the value of the nearest integer below it", "label": {"api": {"Math.floor": [[12, 21]]}}}, {"text": "All that counts is the described behaviour of the API", "label": {"api": {"API": [[50, 52]]}}}, {"text": "Your resource is in a fixed, known location on your classpath, so it's best to use the Class#getResourceAsStream method", "label": {"api": {"Class#getResourceAsStream method": [[87, 118]]}}}, {"text": "Using Java 8 Streams, here's another way to do this", "label": {"api": {"Java 8 Streams": [[6, 19]]}}}, {"text": "As per the Java API the default capacity for a java.util.ArrayList is 10", "label": {"api": {"per the Java API": [[3, 18]]}}}, {"text": "Not only AtomicInteger and AtomicLong, atomic package classes are thread safe", "label": {"api": {"atomic": [[39, 44]]}}}, {"text": "In essence, the classes in this package extend the notion of volatile values, fields, and array elements to those that also provide an atomic conditional update operation of the form", "label": {"api": {"atomic": [[135, 140]]}}}, {"text": "For example, classes AtomicLong and AtomicInteger provide atomic increment methods", "label": {"api": {"atomic": [[58, 63]]}}}, {"text": "That is because Runnable has method void run(), with no parameters, and you're trying to call run(num)", "label": {"api": {"Runnable": [[16, 23]], "void run()": [[36, 45]]}}}, {"text": "Seems you might want a method boolean xxx(String), so replace Runnable with Predicate<String>, and you can call it using test(num) instead of run()", "label": {"api": {"Runnable": [[62, 69]], "Predicate<String>": [[76, 92]]}}}, {"text": "That then leads to compilation error Cannot create a generic array of Predicate<String>, so you have to replace the array with a List", "label": {"api": {"Predicate<String>": [[70, 86]], "List": [[129, 132]]}}}, {"text": "If you want to return an object of class Boolean rather than a primitive boolean, change the return type from lowercase ‘boolean’ to the initial-cap ‘Boolean’ word", "label": {"api": {"Boolean": [[41, 47], [150, 156]]}}}, {"text": "The trim() method removes leading and trailing whitespace", "label": {"api": {"removes leading and trailing whitespace": [[18, 56]]}}}, {"text": "To make a number of Runnable objects, executed in a separate Thread, execute sequentially, you should use the single thread ExecutorService", "label": {"api": {"ExecutorService": [[124, 138]]}}}, {"text": "The ExecutorService is responsible for proper management of the Thread objects (ok, all one of them in this case) ..", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "You can use the newLine() methor prior to writing the new name out to file", "label": {"api": {"newLine()": [[16, 24]]}}}, {"text": "I'm using ServerSocket in order to listen to the network for clients that are attempting to connect", "label": {"api": {"ServerSocket": [[10, 21]]}}}, {"text": "In other words, I call ServerSocket.accept() to \"find\" the clients", "label": {"api": {"ServerSocket": [[23, 34]], "ServerSocket.accept()": [[23, 43]]}}}, {"text": "If not via ServerSocket, perhaps some other way", "label": {"api": {"ServerSocket": [[11, 22]]}}}, {"text": "I don't see how ServerSocket could be used in any other way", "label": {"api": {"ServerSocket": [[16, 27]]}}}, {"text": "I have an AudioInputStream that does not support skip()", "label": {"api": {"AudioInputStream": [[10, 25]]}}}, {"text": "I also tried opening the file with a BufferedInputStream, calling skip() on that, and then passing the BufferedInputStream to AudioSystem.getAudioInputStream() a few different ways, but those failed as well", "label": {"api": {"AudioInputStream": [[141, 156]]}}}, {"text": "You should certainly not try to roll your own when AudioInputStream.skip() already exists", "label": {"api": {"AudioInputStream.skip()": [[51, 73]]}}}, {"text": "I would like to change it to a Date Object using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[49, 64]]}}}, {"text": "I have read the SimpleDateFormat API and cant see anything relating to a T", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "Unless you have a good reason best to use Files.copy(Path, Path, CopyOption...)", "label": {"api": {"Files.copy(Path, Path, CopyOption...)": [[42, 78]]}}}, {"text": "You need to translate those indexes using JTable.convertRowIndexToModel and JTable.convertColumnIndexToModel before calling getModel().getValueAt()", "label": {"api": {"JTable.convertRowIndexToModel": [[42, 70]], "JTable.convertColumnIndexToModel": [[76, 107]]}}}, {"text": "You can read more about this in the introductory description in the JTable documentation", "label": {"api": {"JTable documentation": [[68, 87]]}}}, {"text": "Alternatively, use JTable.getValueAt() instead", "label": {"api": {"JTable.getValueAt()": [[19, 37]]}}}, {"text": "and consider the documentation of URLClassLoader.close()", "label": {"api": {"URLClassLoader.close()": [[34, 55]]}}}, {"text": "I would just use the overload of Collectors.toMap that accepts a merge function to combine the values when it finds a collision on the keys", "label": {"api": {"Collectors.toMap": [[33, 48]]}}}, {"text": "StringTokenizer has an overloaded constructor that takes a third boolean argument", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "This is all well-documented in the Collector javadoc, and the Collector is the parameter you're giving to the collect() method", "label": {"api": {"Collector": [[35, 43], [62, 70]], "collect()": [[110, 118]]}}}, {"text": "The translate(int, int) method simply moved the rectangle by the specified X and Y distances, without changing its size", "label": {"api": {"translate(int, int)": [[4, 22]]}}}, {"text": "You can plug in the constructor by using the Supplier interface", "label": {"api": {"Supplier": [[45, 52]]}}}, {"text": "Depending on the nature of your problem you may find that using a Deque is appropriate", "label": {"api": {"Deque": [[66, 70]]}}}, {"text": "java-8 Duration is different with joda Duration", "label": {"api": {"Duration": [[7, 14], [39, 46]]}}}, {"text": "For more info, check this for regex", "label": {"api": {"check this for regex": [[15, 34]]}}}, {"text": "Starting from this example using javafx.scene.web.WebView, I made the following changes to produce the result shown below", "label": {"api": {"javafx.scene.web.WebView": [[33, 56]]}}}, {"text": "You may for example use DateTimeFormatter.ISO_LOCAL_DATE to obtain yyyy-MM-dd", "label": {"api": {"DateTimeFormatter.ISO_LOCAL_DATE": [[24, 55]]}}}, {"text": "You almost certainly want to use a StringBuilder instead of StringBuffer", "label": {"api": {"StringBuffer": [[60, 71]]}}}, {"text": "As of release JDK 5, [StringBuffer] has been supplemented with an equivalent class designed for use by a single thread, StringBuilder", "label": {"api": {"StringBuffer": [[22, 33]]}}}, {"text": "What the single-command-string form of Runtime.exec() does is to perform by-whitespace-only tokenizing of the string via StringTokenizer", "label": {"api": {"single-command-string form of Runtime.exec()": [[9, 52]], "StringTokenizer": [[121, 135]]}}}, {"text": "Then you could probably register a custom subclass of ConsoleHandler that includes the thread-specific information that is acquired via Thread.currentThread.getId() (or a ThreadLocal variable, if you need to associate more data with the thread) on its own before printing the actual logging message", "label": {"api": {"ConsoleHandler": [[54, 67]]}}}, {"text": "Use java.lang.Character.isDefined(int) to filter out code points that are not assigned at all", "label": {"api": {"java.lang.Character.isDefined(int)": [[4, 37]]}}}, {"text": "If you also want to filter out characters that are valid but not displayable, you should additionally check isIdentifierIgnorable(int)", "label": {"api": {"isIdentifierIgnorable(int)": [[108, 133]]}}}, {"text": "Better use FileChooser for files and for directories (like in this case) DirectoryChooser", "label": {"api": {"FileChooser": [[11, 21]], "DirectoryChooser": [[73, 88]]}}}, {"text": "I know what the java.io.DataInputStream.readUnsignedShort() method does.But the problem is that <<16 thing", "label": {"api": {"java.io.DataInputStream.readUnsignedShort()": [[16, 58]]}}}, {"text": "DataInputStream#readUnsignedShort return a int which spend 32 bits, but the short type spend 16 bits", "label": {"api": {"DataInputStream#readUnsignedShort": [[0, 32]]}}}, {"text": "Implementing AutoCloseable allows you to do this", "label": {"api": {"AutoCloseable": [[13, 25]]}}}, {"text": "Note that try-with-resources and AutoCloseable post-date both Josh Bloch's direct involvement with Java and Effective Java 2nd edition", "label": {"api": {"AutoCloseable": [[33, 45]]}}}, {"text": "A valid attempt would be to read the file line by line, then remove all occurrences of the symbols using replaceAll(...) (which is further explained in their java docs) but instead you could use the following replace", "label": {"api": {"in their java docs": [[149, 166]]}}}, {"text": "The example should be discarded except to observe that Pane \"may be used directly in cases where absolute positioning of children is required.\" In this case, your JavaFX example does not", "label": {"api": {"Pane": [[55, 58]]}}}, {"text": "Enum is the simple name of the java.lang.Enum class, which is the superclass of all enumerated types defined using the enum keyword", "label": {"api": {"java.lang.Enum class": [[31, 50]]}}}, {"text": "Since the DateTime has no api for DateTime.plus(DateTime)/DateTime.minus(DateTime), but you can plus / minus a Period on a DateTime , then you need a DateTime to start, and the code using Collectors api is replacing toMap with groupingBy which is more efficiently and expressiveness for doing the task in your case", "label": {"api": {"Collectors api": [[188, 201]]}}}, {"text": "You should really consider configuring your loggers using the java.util.logging.config.file system property and creating your own logging.properties file", "label": {"api": {"java.util.logging.config.file": [[62, 90]]}}}, {"text": "For more details on mapping a POJO to a Map and vice versa, refer to this answer", "label": {"api": {"Map": [[40, 42]]}}}, {"text": "The nuance is that I'm using the overloaded version of Collectors.groupingBy that accepts a factory for the map, because in the next step I want to remove the entries whose duration is less than 10 hours, and the spec doesn't guarantee that the map returned by the Collectors.groupingBy methods that take either one or two arguments is mutable", "label": {"api": {"overloaded version of Collectors.groupingBy that accepts a factory for the map": [[33, 110]]}}}, {"text": "If you want to do everything in a single line, you might want to use Collectors.collectingAndThen", "label": {"api": {"Collectors.collectingAndThen": [[69, 96]]}}}, {"text": "Here I've used Collectors.collectingAndThen to modify the map returned by Collectors.groupingBy", "label": {"api": {"Collectors.collectingAndThen": [[15, 42]]}}}, {"text": "And, within the finisher function, I've used Collection.removeIf, which takes a predicate and removes all the entries that match that predicate", "label": {"api": {"Collection.removeIf": [[45, 63]]}}}, {"text": "First, to remove the items I would recommend using the removeif() method on the arraylist", "label": {"api": {"method": [[66, 71]]}}}, {"text": "Second, You could add the object to the array then simply sort the array afterwards", "label": {"api": {"sort": [[58, 61]]}}}, {"text": "You would just have to write a comparator to sort it by", "label": {"api": {"sort": [[45, 48]]}}}, {"text": "One approach is to use NIO's ByteBuffer", "label": {"api": {"ByteBuffer": [[29, 38]]}}}, {"text": "Conveniently, the RoundingMode enumeration provides such functionality to DecimalFormat with its RoundingMode.CEILING field", "label": {"api": {"RoundingMode": [[18, 29], [97, 108]]}}}, {"text": "THEN your code operate on a stream should be like below, and you don't need casting the result by using Collectors#toCollection", "label": {"api": {"Collectors#toCollection": [[104, 126]]}}}, {"text": "No; you don't have to, but you really should", "label": {"api": {"you don't have to": [[4, 20]]}}}, {"text": "I'm experiencing very strange performance degradation in my utility class - shortly I'm adding method last(revIndex) into my clone of native ArrayDeque class, which does not have access by index", "label": {"api": {"ArrayDeque": [[141, 150]]}}}, {"text": "As per the documentation for the Initializable interface", "label": {"api": {"Initializable": [[33, 45]]}}}, {"text": "To avoid this, you can use a PreparedStatement which will take care of sanitizing your inputs for you", "label": {"api": {"PreparedStatement": [[29, 45]]}}}, {"text": "and then set them using the methods of the PreparedStatement class", "label": {"api": {"PreparedStatement": [[43, 59]]}}}, {"text": "Note my use of a try with resources block - which will close the PreparedStatement and ResultSet as if they were closed in a finally block", "label": {"api": {"PreparedStatement": [[65, 81]]}}}, {"text": "The code that performs the actual execution works exclusively in terms of Java-8 functional interfaces (for compatibility reasons), so I need to have an intermediate stage where the Method instances discovered using reflection are converted to appropriate functional interfaces", "label": {"api": {"Method": [[182, 187]]}}}, {"text": "I achieve this using the MethodHandleProxies class", "label": {"api": {"Method": [[25, 30]], "MethodHandleProxies": [[25, 43]]}}}, {"text": "This causes an \"unchecked conversion\" warning when using the MethodHandleProxies.asInterfaceInstance method, since that method returns the \"bare\" interface", "label": {"api": {"Method": [[61, 66]], "MethodHandleProxies": [[61, 79]]}}}, {"text": "Making MethodInterface non-generic would solve this particular problem, but would mean that it would no longer work with method references for arbitrary types (which is desirable for other parts of the code)", "label": {"api": {"Method": [[7, 12]]}}}, {"text": "For example, with the above definitions of TestClass and MethodInterface, the following line compiles", "label": {"api": {"Method": [[57, 62]]}}}, {"text": "However, changing to the following definition of MethodInterface breaks this", "label": {"api": {"Method": [[49, 54]]}}}, {"text": "Assigning TestClass::testMethod to an instance of this interface doesn't compile, as the parameters are of the wrong types", "label": {"api": {"Method": [[25, 30]]}}}, {"text": "By the way, if your target interface is a functional interface, you can use LambdaMetafactory instead of MethodHandleProxies", "label": {"api": {"LambdaMetafactory": [[76, 92]]}}}, {"text": "You can implement these collections over chunks of bytes (obtained as new byte[...] or ByteBuffer.allocate[Direct](...) or unsafe.allocateMemory(...))", "label": {"api": {"ByteBuffer": [[87, 96]]}}}, {"text": "From the Javadoc for wait()", "label": {"api": {"the Javadoc for wait()": [[5, 26]]}}}, {"text": "If you have to work with chunks, your MappedByteBuffer seems to be a reasonable approach", "label": {"api": {"MappedByteBuffer": [[38, 53]]}}}, {"text": "For the queue, I'd use a blocking queue with a fixed capacity—such as ArrayBlockingQueue—to better control the memory usage (lines/chunks in queue + lines/chunks among workers = lines/chunks in memory)", "label": {"api": {"ArrayBlockingQueue": [[70, 87]]}}}, {"text": "Because SwingFXUtils.toFXImage makes a copy, a background Task<Image> could continue to update a single BufferedImage while publishing interim Image results via updateValue()", "label": {"api": {"SwingFXUtils.toFXImage": [[8, 29]]}}}, {"text": "Since there are a lot of methods that could be invoked with a null", "label": {"api": {"a lot of methods": [[16, 31]]}}}, {"text": "You can using java-8 Stream#anyMatch to checking the strings is whether null or empty", "label": {"api": {"Stream#anyMatch": [[21, 35]]}}}, {"text": "You should use different names for your path parameters variable templates, then you can get the path parameters with UriInfo#getPathParameters() in the AbstractFamilyMember#children() method", "label": {"api": {"UriInfo#getPathParameters()": [[118, 144]]}}}, {"text": "You can use the URLConnection.getInputStream() and URLConnection.getOutputStream() methods to get the input/output streams for it", "label": {"api": {"URLConnection.getInputStream()": [[16, 45]], "URLConnection.getOutputStream()": [[51, 81]]}}}, {"text": "I'm considering the ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[20, 40]]}}}, {"text": "Another option would be a synchronized List", "label": {"api": {"synchronized List": [[26, 42]]}}}, {"text": "Java has a logging framework already built in, and it is fully customizable to create different handlers and formatters", "label": {"api": {"logging framework": [[11, 27]]}}}, {"text": "If you don't like the standard Java logging framework for whatever reason there are still many others available", "label": {"api": {"logging framework": [[36, 52]]}}}, {"text": "You should put these in a Map", "label": {"api": {"Map": [[26, 28]]}}}, {"text": "In jdk-8 you can merging multi-iterators simpler by using Stream#flatMap & Stream#iterator, for example", "label": {"api": {"Stream#flatMap": [[58, 71]], "Stream#iterator": [[75, 89]]}}}, {"text": "I have a problem with matching the two words with a space between them in Pattern.compile in Java", "label": {"api": {"Pattern.compile": [[74, 88]]}}}, {"text": "you probably want to use instead the java.util.regex.Matcher you just created", "label": {"api": {"java.util.regex.Matcher": [[37, 59]]}}}, {"text": "Instead of for-each-add, you can collect stream items with Collectors.toSet()", "label": {"api": {"Collectors.toSet()": [[59, 76]]}}}, {"text": "Use toList() if you need to maintain the order of children", "label": {"api": {"toList()": [[4, 11]]}}}, {"text": "You can make an unmodifiable map whose map values are also unmodifiable by extending AbstractMap", "label": {"api": {"AbstractMap": [[85, 95]]}}}, {"text": "in combination with the unmodifiable AbstractMap example", "label": {"api": {"AbstractMap": [[37, 47]]}}}, {"text": "Parse the file line for line, for example with a Stringtokenizer", "label": {"api": {"Stringtokenizer": [[49, 63]]}}}, {"text": "This uses the 1 argument JScrollPane constructor, which has a default policy for the scrollbar", "label": {"api": {"JScrollPane constructor": [[25, 47]]}}}, {"text": "In java, you can specify the flags Pattern.CASE_INSENSITIVE and Pattern.UNICODE_CASE, i.e.", "label": {"api": {"CASE_INSENSITIVE": [[43, 58]], "UNICODE_CASE": [[72, 83]]}}}, {"text": "With the Pattern.CASE_INSENSITIVE", "label": {"api": {"CASE_INSENSITIVE": [[17, 32]]}}}, {"text": "When this flag is specified then case-insensitive matching, when enabled by the CASE_INSENSITIVE flag, is done in a manner consistent with the Unicode Standard", "label": {"api": {"CASE_INSENSITIVE": [[80, 95]]}}}, {"text": "The embedded flag expression can include CASE_INSENSITIVE, MULTILINE, DOTALL, UNICODE_CASE, CANON_EQ, UNIX_LINES, LITERAL, UNICODE_CHARACTER_CLASS and COMMENTS", "label": {"api": {"CASE_INSENSITIVE": [[41, 56]], "MULTILINE": [[59, 67]], "DOTALL": [[70, 75]], "UNICODE_CASE": [[78, 89]], "CANON_EQ": [[92, 99]], "UNIX_LINES": [[102, 111]], "LITERAL": [[114, 120]], "UNICODE_CHARACTER_CLASS": [[123, 145]], "COMMENTS": [[151, 158]]}}}, {"text": "You can use class Colectionsthat provides method public static <T> List<T> synchronizedList(List<T> list) (See API here)", "label": {"api": {"API": [[111, 113]]}}}, {"text": "The two-argument XPath.evaluate method will automatically concatenate the text content of any matched elements", "label": {"api": {"two-argument XPath.evaluate method": [[4, 37]]}}}, {"text": "you're adding the character codes rather than the digits; you can use Character.getNumericValue to solve the problem at hand", "label": {"api": {"Character.getNumericValue": [[70, 94]]}}}, {"text": "Another thing is you're supposed to compare strings with .equals()", "label": {"api": {".equals()": [[57, 65]]}}}, {"text": "The problem here is that arrays don't override Object#equals method hence the output you're receiving; rather you can create ArrayList of ArrayLists instead e.g", "label": {"api": {"Object#equals": [[47, 59]]}}}, {"text": "You should use the Consumer  not Function type, since your Function has no output, and Consumer is used for this scenario", "label": {"api": {"Consumer": [[19, 26], [87, 94]]}}}, {"text": "You could do it using the version of Stream.collect that accepts a supplier, an accumulator function and a combiner function, as follows", "label": {"api": {"Stream.collect": [[37, 50]]}}}, {"text": "The package summary of java.util.stream states the following", "label": {"api": {"package summary": [[4, 18]]}}}, {"text": "I can read at http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#intern%28%29 that the class String has a pool of strings", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#intern%28%29": [[14, 88]]}}}, {"text": "According to the javadocs for Timestamp that gets you the milliseconds from epoch", "label": {"api": {"javadocs for Timestamp": [[17, 38]]}}}, {"text": "Stream#anyMatch() returns a boolean while Stream#findAny() returns an object which matches the predicate", "label": {"api": {"Stream#anyMatch()": [[0, 16]], "Stream#findAny()": [[42, 57]]}}}, {"text": "Yes it is, as the Stream.findAny() documentation states", "label": {"api": {"Stream.findAny()": [[18, 33]]}}}, {"text": "You can use BigInteger to work with such data", "label": {"api": {"BigInteger": [[12, 21]]}}}, {"text": "HttpServletRequest is an interface for a HTTP specific servlet request", "label": {"api": {"HttpServletRequest": [[0, 17]]}}}, {"text": "Typically you get instances of this interface in servlet filters or servlets", "label": {"api": {"servlet filters": [[49, 63]], "servlets": [[68, 75]]}}}, {"text": "With a HttpServletRequestWrapper you can wrap the original request and overwrite some methods so that it behaves slightly different", "label": {"api": {"HttpServletRequest": [[7, 24]], "HttpServletRequestWrapper": [[7, 31]]}}}, {"text": "You have a bunch of servlets and JSPs which expect some request parameters in a certain format", "label": {"api": {"servlets": [[20, 27]]}}}, {"text": "Assuming there is no central string to date function (it's an inherited legacy application), you have to find all places in the servlets and JSPs", "label": {"api": {"servlets": [[128, 135]]}}}, {"text": "You map the filter so that all requests to your servlets and JSPs will go through this filter", "label": {"api": {"servlets": [[48, 55]]}}}, {"text": "The servlets and JSPs get the date fields always in the expected old format", "label": {"api": {"servlets": [[4, 11]]}}}, {"text": "We need a new instance of interface HttpServletRequest which behaves exactly like the original instance req", "label": {"api": {"HttpServletRequest": [[36, 53]]}}}, {"text": "All other methods of interface HttpServletRequest should behave like the original methods", "label": {"api": {"HttpServletRequest": [[31, 48]]}}}, {"text": "We create an instance of HttpServletRequest and implement all methods", "label": {"api": {"HttpServletRequest": [[25, 42]]}}}, {"text": "So here comes the class HttpServletRequestWrapper into account", "label": {"api": {"HttpServletRequest": [[24, 41]], "HttpServletRequestWrapper": [[24, 48]]}}}, {"text": "This is a default wrapper implementation which takes the original request instance and implements all methods of interface HttpServletRequest as simple wrapper methods calling the corresponding method of the original request, just as we did above", "label": {"api": {"HttpServletRequest": [[123, 140]]}}}, {"text": "By subclassing HttpServletRequestWrapper we only have to overwrite the four param methods with custom behaviour", "label": {"api": {"HttpServletRequest": [[15, 32]], "HttpServletRequestWrapper": [[15, 39]]}}}, {"text": "See the package summary for java.util.concurrent.atomic", "label": {"api": {"package summary": [[8, 22]]}}}, {"text": "In the ChangeListener, instead of creating a new SpinnerNumberModel, just update the maximum value of the existing model", "label": {"api": {"SpinnerNumberModel": [[49, 66]], "Number": [[56, 61]]}}}, {"text": "JSpinner has a getModel() method the returns a SpinnerModel", "label": {"api": {"JSpinner": [[0, 7]]}}}, {"text": "You can cast it to a SpinnerNumberModel, but you should use instanceof to check that the cast will work", "label": {"api": {"SpinnerNumberModel": [[21, 38]], "Number": [[28, 33]]}}}, {"text": "In either case, newMaximum is a Number, and all subclasses supported by SpinnerNumberModel are Comparable", "label": {"api": {"SpinnerNumberModel": [[72, 89]], "Number": [[32, 37], [79, 84]]}}}, {"text": "We insert the (?m) directive to enable MULTILINE mode so that ^ and $ match the beginning and ends of lines, respectively", "label": {"api": {"MULTILINE": [[39, 47]]}}}, {"text": "This error  is thrown if an application tries to access or modify a specified field of an object, and that object no longer has that field or also changed (in general partially compiled or same class in other depending project)", "label": {"api": {"error": [[5, 9]]}}}, {"text": "A way to solve this is to call Byte.toUnsignedInt(...) (Java API) with the byte read", "label": {"api": {"Byte.toUnsignedInt(...)": [[31, 53]]}}}, {"text": "The key method is rangeRefinedBy(Temporal) on TemporalField", "label": {"api": {"rangeRefinedBy(Temporal)": [[18, 41]]}}}, {"text": "If you are using Java, you can use HashMap", "label": {"api": {"HashMap": [[35, 41]]}}}, {"text": "Code that uses HashMap to find the unduplicated number in a list", "label": {"api": {"HashMap": [[15, 21]]}}}, {"text": "At the end, I'm using Collector.of to create a collector based on the methods of the Acc class", "label": {"api": {"Collector.of": [[22, 33]]}}}, {"text": "Use isAlive() to check whether these commands are still being executed (and kill these processes after some timeout)", "label": {"api": {"isAlive()": [[4, 12]]}}}, {"text": "Use waitFor(long timeout, TimeUnit unit) method to make them terminate after a timeout", "label": {"api": {"waitFor(long timeout, TimeUnit unit)": [[4, 39]]}}}, {"text": "You could then check if the processes exited gracefully with exitValue() method", "label": {"api": {"exitValue()": [[61, 71]]}}}, {"text": "Most standard attributes can be read directly from the Package class", "label": {"api": {"Package": [[55, 61]]}}}, {"text": "Instead, you can use a JarInputStream", "label": {"api": {"JarInputStream": [[23, 36]]}}}, {"text": "Alternatively, you could read the manifest directly by constructing a JarURLConnection compound URL", "label": {"api": {"JarURLConnection": [[70, 85]]}}}, {"text": "Note that ProtectionDomain.getCodeSource() can return null", "label": {"api": {"ProtectionDomain.getCodeSource() can return null": [[10, 57]]}}}, {"text": "A better way to specify a version number in an application is to put it in either the Specification-Version or Implementation-Version attribute of the manifest, so it can be read from a Package method", "label": {"api": {"Package": [[186, 192]]}}}, {"text": "Remember that while Implementation-Version is a free-form string, a Specification-Version value must consist of groups of ASCII digits separated by periods", "label": {"api": {"a Specification-Version value must consist of groups of ASCII digits separated by periods": [[66, 154]]}}}, {"text": "Another way is simply to create a data file and include it in your .jar, which you can then read using Class.getResource or Class.getResourceAsStream", "label": {"api": {"Class.getResource": [[103, 119], [124, 140]], "Class.getResourceAsStream": [[124, 148]]}}}, {"text": "I'd use Arrays.fill and fill the array with nulls", "label": {"api": {"Arrays.fill": [[8, 18]]}}}, {"text": "Just using String#replaceAll can achieve your way", "label": {"api": {"String#replaceAll": [[11, 27]]}}}, {"text": "This is what the Application.stop method should be used for", "label": {"api": {"Application.stop": [[17, 32]]}}}, {"text": "Element#getModifiers() will tell you if the class is abstract or not", "label": {"api": {"Element#getModifiers()": [[0, 21]]}}}, {"text": "Element#getKind() will tell you if it is an interface", "label": {"api": {"Element#getKind()": [[0, 16]]}}}, {"text": "Instead, run your ProcessBuilder in the background of a SwingWorker, as shown in this complete example", "label": {"api": {"ProcessBuilder": [[18, 31]]}}}, {"text": "Maybe you can have a look on Collections.singletonList(object)", "label": {"api": {"Collections.singletonList(object)": [[29, 61]]}}}, {"text": "Here I'm using Stream.reduce, which takes the identity and an operator as arguments", "label": {"api": {"Stream.reduce": [[15, 27]]}}}, {"text": "Stream.reduce applies the Predicate::and operator to all elements of the stream to produce a result predicate, and uses the identity to operate on the first element of the stream", "label": {"api": {"Stream.reduce": [[0, 12]]}}}, {"text": "You'll need to alter your solution a little bit and use IntStream#range to index into the list until list.size()-1", "label": {"api": {"IntStream#range": [[56, 70]]}}}, {"text": "You can compose Stream#toList with Stream#collectingAndThen to copy a List, then use List#replaceAll to replace all items except the last one", "label": {"api": {"Stream#toList": [[16, 28]], "Stream#collectingAndThen": [[35, 58]], "List#replaceAll": [[85, 99]]}}}, {"text": "To call a constructor that takes arguments, use getConstructor(Class<?>...) to get a Constructor", "label": {"api": {"getConstructor(Class<?>...)": [[48, 74]]}}}, {"text": "Well, you can use for example getConstructor(Class...) to get a constructor which is other than the default no-argument one", "label": {"api": {"getConstructor(Class...)": [[30, 53]]}}}, {"text": "A functional interface must is a SAM interface", "label": {"api": {"functional interface": [[2, 21]]}}}, {"text": "a functional interface has exactly one abstract method", "label": {"api": {"functional interface": [[2, 21]]}}}, {"text": "Java's File class is nothing but an abstraction", "label": {"api": {"File": [[7, 10]]}}}, {"text": "One purpose would be, as you have already said (https://docs.oracle.com/javase/7/docs/api/java/io/File.html), that you can benefit from methods that are additional and more specifically than those from String", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/File.html": [[48, 106]]}}}, {"text": "If your filesystem is POSIX compatible then you may use this method for instance", "label": {"api": {"this method": [[56, 66]]}}}, {"text": "setKeyEntry takes a Certificate argument which is located at java.security.cert.Certificate", "label": {"api": {"setKeyEntry": [[0, 10]]}}}, {"text": "I decided to use Point class because it obviously allows to easily store coordinates of a point", "label": {"api": {"Point": [[17, 21]]}}}, {"text": "The problem is everywhere in my program I store it as int whereas Point returns double when using getX() and getY() methods", "label": {"api": {"Point": [[66, 70]]}}}, {"text": "This is checked at runtime, resulting in a InvalidKeyException if the key and algorithm do not match", "label": {"api": {"InvalidKeyException": [[43, 61]]}}}, {"text": "Math.radnom() returns a double that's greater or equal than 0.0 and less than 1.0", "label": {"api": {"Math.radnom()": [[0, 12]]}}}, {"text": "I am trying to create a class that extends java.io.PrintWriter", "label": {"api": {"java.io.PrintWriter": [[43, 61]]}}}, {"text": "It's also the case that you could pass a Class<E> and use type.getEnumConstants() instead of passing the values() directly, if you ever needed to do that", "label": {"api": {"type.getEnumConstants()": [[58, 80]]}}}, {"text": "It seems like you are looking for flatMap", "label": {"api": {"flatMap": [[34, 40]]}}}, {"text": "Note that you can copy all the content of an InputStream to a file in one line of code using Files", "label": {"api": {"Files": [[93, 97]]}}}, {"text": "To preserve (and be able to change) the order, see OrderColumn and the Hibernate documentation about ordered lists​", "label": {"api": {"OrderColumn": [[51, 61]]}}}, {"text": "But it's probably easier to use ByteBuffer", "label": {"api": {"ByteBuffer": [[32, 41]]}}}, {"text": "ByteBuffer is BIG_ENDIAN by default", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "You could use Bindings.selectFloat", "label": {"api": {"Bindings.selectFloat": [[14, 33]]}}}, {"text": "The Float constructor is overloaded to accept either a float or a double parameter", "label": {"api": {"Float": [[4, 8]]}}}, {"text": "From the documentation of that StreamSupport.stream method (Link)", "label": {"api": {"Link": [[60, 63]]}}}, {"text": "Instead of using the naturalOrder comparator, you can use String.CASE_INSENSITIVE_ORDER", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[58, 86]]}}}, {"text": "the documentation Consumer#andThen says", "label": {"api": {"Consumer#andThen": [[18, 33]]}}}, {"text": "In the second case you can use Class.getDeclaredField method, but it's quite likely there's a better way to achieve your purposes", "label": {"api": {"Class.getDeclaredField": [[31, 52]]}}}, {"text": "If you use Java 8, you can use computeIfAbsent to greatly simplify the code", "label": {"api": {"computeIfAbsent": [[31, 45]]}}}, {"text": "WHAT you actually need is a Collector to collecting all elements in the stream that  is instance of special type", "label": {"api": {"Collector": [[28, 36]]}}}, {"text": "AND you can do something as further like as Stream#map by using Collectors#mapping, for example", "label": {"api": {"Collector": [[64, 72]], "Stream#map": [[44, 53]], "Collectors#mapping": [[64, 81]]}}}, {"text": "WHERE you only want to consuming the Stream once, you can easily composing the last Collector as below", "label": {"api": {"Collector": [[84, 92]]}}}, {"text": "Why did you need to composes Collectors", "label": {"api": {"Collector": [[29, 37]]}}}, {"text": "and you can see jdk has introduced Collectors#filtering in jdk-9 that will make the execution routes shorter without losing its expressiveness", "label": {"api": {"Collector": [[35, 43]]}}}, {"text": "AND you can refactoring the code above according to Separation of Concerns as further, then filtering can be reused like as jdk-9 Collectors#filtering", "label": {"api": {"Collector": [[130, 138]]}}}, {"text": "The wait and notify methods exist precisely to solve this problem", "label": {"api": {"wait": [[4, 7]], "notify": [[13, 18]]}}}, {"text": "The reason this works is that wait() will temporarily, and atomically, release the synchronized lock, allowing another thread to synchronize on that object", "label": {"api": {"wait": [[30, 33]]}}}, {"text": "Note that wait() must be called in a loop which checks the condition being waited for, since wait() can occasionally return even if no other thread called notify()", "label": {"api": {"wait": [[10, 13], [75, 78], [93, 96]], "notify": [[155, 160]]}}}, {"text": "A well-behaved thread will place the entire wait-loop in a try/catch block, so the thread will exit when interrupted", "label": {"api": {"wait": [[44, 47]]}}}, {"text": "NullPointerException is a RuntimeException, which means that it is designed for reporting programming errors", "label": {"api": {"NullPointerException": [[0, 19]]}}}, {"text": "Use @Inherited to inherit annotations", "label": {"api": {"@Inherited": [[4, 13]]}}}, {"text": "To retrieve a String consisting of all the ID's separated by the delimiter \",\" you first have to map the Person ID's into a new stream which you can then apply Collectors.joining on", "label": {"api": {"map": [[97, 99]], "Collectors.joining": [[160, 177]]}}}, {"text": "You can also using Collectors#mapping as below", "label": {"api": {"Collectors#mapping": [[19, 36]]}}}, {"text": "You can use ByteBuffer.allocateDirect to create native accessible memory", "label": {"api": {"ByteBuffer.allocateDirect": [[12, 36]]}}}, {"text": "But java can't refer a method dierctly except you using reflection api Method/using a anonymous class that implements SAM interface which delegates request to a method before in jdk-8", "label": {"api": {"Method": [[71, 76]]}}}, {"text": "You can use the Card.disconnect() method to reset card (beware of this)", "label": {"api": {"Card.disconnect()": [[16, 32]]}}}, {"text": "But (IMHO) the best way is to use card ATR (as given by Card.getATR()) for guessing the correct card family (if possible)", "label": {"api": {"Card.getATR()": [[56, 68]]}}}, {"text": "Reason being that you're still receiving a list of lists is because when you apply Stream::of it's returning a new stream of the existing ones", "label": {"api": {"Stream::of": [[83, 92]]}}}, {"text": "That is when you perform Stream::of it's like having {{{1,2}}, {{3,4}}, {{5,6}}} then when you perform flatMap it's like doing this", "label": {"api": {"Stream::of": [[25, 34]], "flatMap": [[103, 109]]}}}, {"text": "rather you can use .flatMap(Collection::stream) to take a stream of streams such as", "label": {"api": {"flatMap": [[20, 26]]}}}, {"text": "I am using the package javax.json", "label": {"api": {"javax.json": [[23, 32]]}}}, {"text": "But they are not universally faster, under some circumstances, when you want to transfer large chunks of data between direct bytebuffers, files or sockets the channel scatter/gather or transfer methods or memory-mapped files can be more performant since they avoid intermediate copying", "label": {"api": {"scatter/gather": [[167, 180]], "transfer": [[80, 87], [185, 192]]}}}, {"text": "Ideally, the functions and consumers used in a stream should be stateless and without side-effects, as recommended in the java.util.stream package documentation", "label": {"api": {"java.util.stream package documentation": [[122, 159]]}}}, {"text": "And you used TreeSet which is an implementation class for both Set<E> and SortedSet<E> interfaces", "label": {"api": {"TreeSet": [[13, 19]]}}}, {"text": "So your actual mapping won't work with TreeSet, you should use a Set<CoachGroup> instead of a TreeSet<CoachGroup>", "label": {"api": {"TreeSet": [[39, 45], [94, 100]]}}}, {"text": "After I get dig into it, I found there are many duplicated logic between Stream and Collector that violates Don't repeat yourself principle, e.g", "label": {"api": {"Stream": [[73, 78]], "Collector": [[84, 92]]}}}, {"text": "Stream#map & Collectors#mapping, Stream#filter & Collectors#filtering in jdk-9 and .etc", "label": {"api": {"Stream": [[0, 5], [33, 38]], "Collector": [[13, 21], [49, 57]], "Stream#map": [[0, 9]], "Collectors#mapping": [[13, 30]], "Stream#filter": [[33, 45]]}}}, {"text": "But it seems to reasonable since Stream abide by Tell, Don't ask principle/Law of Demeter and Collector abide by Composition over Inheritance principle", "label": {"api": {"Stream": [[33, 38]], "Collector": [[94, 102]]}}}, {"text": "I can only think of a few reasons why Stream operations is duplicated with Collectors as below", "label": {"api": {"Stream": [[38, 43]], "Collector": [[75, 83]]}}}, {"text": "We don't care of how the Stream is created in a big context", "label": {"api": {"Stream": [[25, 30]]}}}, {"text": "in this case Stream operation is more effectively and faster than Collector since it can mapping a Stream to another Stream simply, for example", "label": {"api": {"Stream": [[13, 18], [99, 104], [117, 122]], "Collector": [[66, 74]]}}}, {"text": "Collector is more powerful that can composes Collectors together to collecting elements in a stream, However, Stream only providing some useful/highly used operations", "label": {"api": {"Stream": [[110, 115]], "Collector": [[0, 8], [45, 53]]}}}, {"text": "Stream operations is more expressiveness than Collector when doing some simpler working, but they are more slower than Collectors since it will creates a new stream for each operation and Stream is more heavier and abstract than Collector", "label": {"api": {"Stream": [[0, 5], [188, 193]], "Collector": [[46, 54], [119, 127], [229, 237]]}}}, {"text": "Collector can't applying short-circuiting terminal operation as Stream", "label": {"api": {"Stream": [[64, 69]], "Collector": [[0, 8]]}}}, {"text": "Does anyone can come up with other disadvantage/advantage why Stream operations is duplicated with Collectors here", "label": {"api": {"Stream": [[62, 67]], "Collector": [[99, 107]]}}}, {"text": "O(m+n), is to convert the List to a HashSet, then check using contains()", "label": {"api": {"HashSet": [[36, 42]], "contains()": [[62, 71]]}}}, {"text": "If you don't convert to Set, and use the contains() method of List directly, performance would be O(mn), where m is number of elements in the list", "label": {"api": {"contains()": [[41, 50]]}}}, {"text": "You should stick to the recommended pattern and put your condition in a while to avoid spurious wakeups", "label": {"api": {"the recommended pattern": [[20, 42]]}}}, {"text": "Collection<E> then defines", "label": {"api": {"defines": [[19, 25]]}}}, {"text": "As others pointed out, the .stream() method is implemented as a default method in the Collection interface itself, as you can see it in the method signature in the official documentation", "label": {"api": {"official documentation": [[164, 185]]}}}, {"text": "However, implementing the same heavy Stream interface for every collection would be a lot of work and duplication, so they use an intermediate abstraction called Spliterator", "label": {"api": {"Spliterator": [[162, 172]]}}}, {"text": "If you want an identity transformation then (with JAXP) either create a new Transformer without providing a stylesheet at all (https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newTransformer--) or make sure the XSLT you provide is actually performing the copy, your code with a top level \"<xsl:copy-of select=\\\".\\\"/> \" should not even compile I think, you rather want <xsl:template match=\"/\"><xsl:copy-of select=\".\"/></xsl:template>", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newTransformer--": [[127, 228]]}}}, {"text": "You can supply an executor to the ...Async variants of the callbacks, so supplying the same single threaded executor to the one callbacks that lock and unlock should ensure they execute on the same thread", "label": {"api": {"...Async variants": [[34, 50]], "single threaded executor": [[92, 115]]}}}, {"text": "To open the browser, you can use the Desktop#browse(URI) method", "label": {"api": {"Desktop#browse(URI)": [[37, 55]]}}}, {"text": "In your case you can use getGenericReturnType", "label": {"api": {"getGenericReturnType": [[25, 44]]}}}, {"text": "If you print t, you'll find that it's a java.lang.reflect.ParameterizedType Set<Employee>", "label": {"api": {"java.lang.reflect.ParameterizedType": [[40, 74]]}}}, {"text": "However, you've now stepped off a cliff in to the wacky world of java.lang.reflect.Type and its subtypes", "label": {"api": {"java.lang.reflect.Type": [[65, 86]]}}}, {"text": "The generic return type is List<T>, because getGenericReturnType() returns the type in the declaration", "label": {"api": {"getGenericReturnType": [[44, 63]]}}}, {"text": "As of Java 8, you should be using java.util.Base64 instead", "label": {"api": {"java.util.Base64": [[34, 49]]}}}, {"text": "However, it looks like you’re using Java 7, so you’ll want to use DatatypeConverter.parseBase64Binary and DatatypeConverter.printBase64Binary instead", "label": {"api": {"DatatypeConverter.parseBase64Binary": [[66, 100]], "DatatypeConverter.printBase64Binary": [[106, 140]]}}}, {"text": "The equals function of the Object class was added in Java JDK 1.0", "label": {"api": {"Object": [[27, 32]]}}}, {"text": "After seeing the posted code, you are using Objects.equals(), which is a utility method that checks equals() in a null-safe manner", "label": {"api": {"Object": [[44, 49]]}}}, {"text": "ArrayList extends AbstractList, which extends AbstractCollection", "label": {"api": {"AbstractCollection": [[46, 63]]}}}, {"text": "I'm just copy your code snippet and adapting your last generic argument Long  to Pair by Collectors#collectingAndThen", "label": {"api": {"Collectors#collectingAndThen": [[89, 116]]}}}, {"text": "I you would like to make random results repeatable, then you may want to use Random with seed", "label": {"api": {"Random with seed": [[77, 92]]}}}, {"text": "Looking at the JavaDocs for JLabel..", "label": {"api": {"Looking at the JavaDocs for JLabel": [[0, 33]]}}}, {"text": "setLocation takes ints as parameters", "label": {"api": {"setLocation": [[0, 10]]}}}, {"text": "You can use the replaceAll method to replace a regular expression of a sequence of 0 characters with a space", "label": {"api": {"replaceAll": [[16, 25]]}}}, {"text": "Thread uses the monitor on itself for other stuff, like join", "label": {"api": {"join": [[56, 59]]}}}, {"text": "Refer to the documentation on Formatter", "label": {"api": {"Refer to the documentation": [[0, 25]]}}}, {"text": "You could use the TimerService in conjunction with the @Timeout annotation to work with millisecond intervals", "label": {"api": {"TimerService": [[18, 29]], "@Timeout": [[55, 62]]}}}, {"text": "From the Javadoc for File#length()", "label": {"api": {"File#length()": [[21, 33]]}}}, {"text": "You can use the Java Comparable interface to get a better result", "label": {"api": {"Comparable": [[21, 30]]}}}, {"text": "Using Math#round(float a) will round the float to the nearest integer", "label": {"api": {"Math#round(float a)": [[6, 24]]}}}, {"text": "You can use Stream#anyMatch to accomplish the task at hand", "label": {"api": {"Stream#anyMatch": [[12, 26]]}}}, {"text": "You can either use an array to store the input from Scanner#next or a List (preferable) then simply display the contents of the list", "label": {"api": {"Scanner#next": [[52, 63]]}}}, {"text": "The body of OfInt#forEachRemaining(Consumer) is a good example of applying  Adapter Design Pattern for reusing OfInt#forEachRenaming(IntConsumer)", "label": {"api": {"OfInt#forEachRemaining(Consumer)": [[12, 43]], "OfInt#forEachRenaming(IntConsumer)": [[111, 144]]}}}, {"text": "Note that you could have found this behavior without looking into the source code, just by looking at the official API documentation, you have linked yourself", "label": {"api": {"the official API documentation": [[102, 131]]}}}, {"text": "If the action is an instance of IntConsumer then it is cast to IntConsumer and passed to forEachRemaining(java.util.function.IntConsumer); otherwise the action is adapted to an instance of IntConsumer, by boxing the argument of IntConsumer, and then passed to forEachRemaining(java.util.function.IntConsumer)", "label": {"api": {"forEachRemaining(java.util.function.IntConsumer)": [[89, 136], [260, 307]]}}}, {"text": "You can use Stream#allMatch", "label": {"api": {"Stream#allMatch": [[12, 26]]}}}, {"text": "If your are using Java 8, you can use the StringJoiner class", "label": {"api": {"StringJoiner": [[42, 53]]}}}, {"text": "You can using Optional#map to achieve your way, for example", "label": {"api": {"Optional#map": [[14, 25]]}}}, {"text": "I would recommend using the delimiter for Scanner see below", "label": {"api": {"delimiter": [[28, 36]]}}}, {"text": "If you launch a subprocess then you'll usually be able to access that value in some way (see the Process docs for Java), but it's not generally used for communicating results", "label": {"api": {"the Process docs": [[93, 108]]}}}, {"text": "See the ProcessBuilder docs for how you could do that in Java", "label": {"api": {"the ProcessBuilder docs": [[4, 26]]}}}, {"text": "The issue is that you have used  ArrayList.add(int index, E element)", "label": {"api": {"ArrayList.add(int index, E element)": [[33, 67]]}}}, {"text": "So simply use ArrayList.add(E element) method instead", "label": {"api": {"ArrayList.add(E element)": [[14, 37]]}}}, {"text": "I also urge you to study the SwingWorker's documentation and see the Swing's Threading Policy", "label": {"api": {"SwingWorker's documentation": [[29, 55]], "Swing's Threading Policy": [[69, 92]]}}}, {"text": "Use mapToInt method to produce a stream of primitive integers", "label": {"api": {"mapToInt": [[4, 11]]}}}, {"text": "Take a look at Exception's JavaDoc", "label": {"api": {"Exception's JavaDoc": [[15, 33]]}}}, {"text": "Well the oracle example is self-explanatory here", "label": {"api": {"example": [[16, 22]]}}}, {"text": "With JAX-RS can define an ExceptionMapper to handle ConstraintViolationExceptions", "label": {"api": {"ExceptionMapper": [[26, 40]], "ConstraintViolationException": [[52, 79]], "ConstraintViolation": [[52, 70]]}}}, {"text": "From the ConstraintViolationException, you can get a set of ConstraintViolation, that exposes the constraint violation context, then map the details you need to an abitrary class and return in the response", "label": {"api": {"ConstraintViolationException": [[9, 36]], "ConstraintViolation": [[9, 27], [60, 78]]}}}, {"text": "Yeah sure , you can catch object instantiations with an Instrumentation", "label": {"api": {"Instrumentation": [[56, 70]]}}}, {"text": "The agent needs to register a ClassFileTransformer that will scan the bytecode of all loaded classes for new object instructions and do well.", "label": {"api": {"ClassFileTransformer": [[30, 49]]}}}, {"text": "When Stream#toArray(IntFunction<A[]> generator) is ready to produce an array, it calls generator and passes (generator.apply) the size of the inner collection to get a collection to fill it up", "label": {"api": {"Stream#toArray(IntFunction<A[]> generator)": [[5, 46]], "generator.apply": [[109, 123]]}}}, {"text": "I would say the existing answers provide some insight but none of them yet talk about IntFunction<R>", "label": {"api": {"IntFunction<R>": [[86, 99]]}}}, {"text": "The javadoc for Connection#rollback clearly states", "label": {"api": {"javadoc for Connection#rollback": [[4, 34]]}}}, {"text": "I strongly recommend to use a fixed thread pool instead, which has exactly the functionality that the posted code tries to achieve, but has been written by experts understanding these pitfalls of multithreading", "label": {"api": {"fixed thread pool": [[30, 46]]}}}, {"text": "Here is from the Oracle docs", "label": {"api": {"Oracle docs": [[17, 27]]}}}, {"text": "you can using Stream#flatMap to merge all of Student[] in a List together", "label": {"api": {"Stream#flatMap": [[14, 27]]}}}, {"text": "I've used flatMap to flatten all the streams with the entries of the inner maps into one stream", "label": {"api": {"flatMap": [[10, 16]]}}}, {"text": "Then, I've used Collectors.toMap to collect all these entries into a new map", "label": {"api": {"Collectors.toMap": [[16, 31]]}}}, {"text": "In such case, you can use the overloaded version of Collectors.toMap, which accepts a function to merge values when there's a collision between keys", "label": {"api": {"Collectors.toMap": [[52, 67]], "overloaded version of Collectors.toMap": [[30, 67]]}}}, {"text": "If all you want to do is to isolate each word from your text and print it out to the console, you can use String#split(String regex) and split on any amount of whitespace", "label": {"api": {"String#split(String regex)": [[106, 131]]}}}, {"text": "With JAX-RS, you can define an ExceptionMapper to map an exception to a Response", "label": {"api": {"ExceptionMapper": [[31, 45]], "Response": [[72, 79]]}}}, {"text": "You need to write a javax.ws.rs.ext.Provider that implements an javax.ws.rs.ext.ExceptionMapper", "label": {"api": {"javax.ws.rs.ext.Provider": [[20, 43]], "javax.ws.rs.ext.ExceptionMapper": [[64, 94]]}}}, {"text": "You can just use List.replaceAll", "label": {"api": {"List.replaceAll": [[17, 31]]}}}, {"text": "every initialized JVM has these system properties, which is a subtype of Hashtable, hence, explains the Hashtable.Entry instances", "label": {"api": {"system properties": [[32, 48]]}}}, {"text": "Finally, I'm using Collector.of to create a collector based on the methods of the Acc class", "label": {"api": {"Collector.of": [[19, 30]]}}}, {"text": "What you see here is that ThreadLocal.initialValue() and integer incrementation are not thread-safe by default, so their combination will not become thread-safe either", "label": {"api": {"ThreadLocal": [[26, 36]]}}}, {"text": "The 'official' ThreadLocal example uses AtomicInteger (and that is what others are suggesting too), which makes integer incrementation thread-safe", "label": {"api": {"ThreadLocal": [[15, 25]]}}}, {"text": "Reading standard error requires invoking the getErrorStream() method of the Process object, and reading from the returned InputStream in a separate Thread", "label": {"api": {"getErrorStream()": [[45, 60]]}}}, {"text": "That is one of the reasons Runtime.exec was replaced years ago by ProcessBuilder, which makes viewing of a Process’s output much easier", "label": {"api": {"ProcessBuilder": [[66, 79]]}}}, {"text": "The generic solution is to use java.text.Collator, which is a specialised Comparator that not only handles uppercase/lowercase, but can also deal with diacritic signs (such as ä and ë) and knows about locale differences (e.g", "label": {"api": {"java.text.Collator": [[31, 48]]}}}, {"text": "read about PrintWriter", "label": {"api": {"read about PrintWriter": [[0, 21]]}}}, {"text": "If you can not use the Java 8 Stream API, you can still make your code a bit shorter by using Map#values to iterate the values lists directly, instead of the keys, and List#addAll to add all the values to the result list at once", "label": {"api": {"Map#values": [[94, 103]], "List#addAll": [[168, 178]]}}}, {"text": "This escaping is necessary because replaceAll treats the first argument as a regular expression", "label": {"api": {"replaceAll": [[35, 44]]}}}, {"text": "The first argument to the replaceAll in your case should be \\\\", "label": {"api": {"replaceAll": [[26, 35]]}}}, {"text": "The javax.xml.bind.DatatypeConverter class has all conversions needed for XML", "label": {"api": {"javax.xml.bind.DatatypeConverter": [[4, 35]]}}}, {"text": "Instead of worrying about all of that, why not check out AtomicLong and AtomicInteger", "label": {"api": {"AtomicLong": [[57, 66]], "AtomicInteger": [[72, 84]]}}}, {"text": "An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer", "label": {"api": {"AtomicInteger": [[3, 15]]}}}, {"text": "While looking for ways to do this I came across the AbstractBorder class", "label": {"api": {"AbstractBorder": [[52, 65]]}}}, {"text": "If you are on Java 8, you could use the Stream API with a Predicate", "label": {"api": {"Stream": [[40, 45]], "Predicate": [[58, 66]]}}}, {"text": "The argument of the Stream.filter method is a Predicate that is expressed as a lambda expression, in this case car -> someModel.equals(car.getModel())", "label": {"api": {"Stream": [[20, 25]], "Predicate": [[46, 54]]}}}, {"text": "The way to abstract this to a method is to pass the list, the predicate, and if you want, a Consumer that will take some action on the matching elements", "label": {"api": {"Consumer": [[92, 99]]}}}, {"text": "Another option, as mentioned by saka1029, is to use Comparator's functions of Comparator.comparing and Comparator.thenComparing on the steam of the class's objects", "label": {"api": {"Comparator's functions": [[52, 73]]}}}, {"text": "To parse the input in binary, use Scanner.nextBigInteger() with a radix of 2", "label": {"api": {"Scanner.nextBigInteger()": [[34, 57]]}}}, {"text": "If you are using Java 8 you can use String::join like this", "label": {"api": {"String::join": [[36, 47]]}}}, {"text": "You can use <fx:reference> to reference existing objects by their fx:id", "label": {"api": {"<fx:reference>": [[12, 25]]}}}, {"text": "If you want to animate the width of the stage holding your new scene, you can use a Transition", "label": {"api": {"Transition": [[84, 93]]}}}, {"text": "If your request object is an instance of HttpServletRequest, you can do this", "label": {"api": {"HttpServletRequest": [[41, 58]]}}}, {"text": "Have you tried setIconImage in the new java.awt.Taskbar class", "label": {"api": {"setIconImage": [[15, 26]]}}}, {"text": "Take a look at the StringTokenizer", "label": {"api": {"StringTokenizer": [[19, 33]]}}}, {"text": "It may be easier for you to use the JSON Processing API (and part of Java EE 7)", "label": {"api": {"JSON Processing API": [[36, 54]]}}}, {"text": "The WeakReference documentation implies that weak references are only handled when the garbage collector runs", "label": {"api": {"WeakReference documentation": [[4, 30]]}}}, {"text": "The class HashMap<K,V>() is a real sample of this case, K is the type for the key value and V is the type for the value", "label": {"api": {"HashMap<K,V>()": [[10, 23]]}}}, {"text": "String#split() takes a regex", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "I provide another method by SpringMVC,using the HandlerInterceptor,when you implements it,it provides 3 methods,each of them contains HttpServletRequest,you can set attribute using request.setAttribute(\"xx\",\"yy\"),below are the code", "label": {"api": {"HttpServletRequest": [[134, 151]]}}}, {"text": "An alternative way would be to parse it as a Duration, but you will need to change the format a bit first", "label": {"api": {"a Duration": [[43, 52]]}}}, {"text": "Why not use the Year class, which is part of the JDK since Java 8", "label": {"api": {"the Year": [[12, 19]]}}}, {"text": "Use LinkedHashMap and construct an EnumMap from it each time you need one", "label": {"api": {"construct an EnumMap": [[22, 41]]}}}, {"text": "JPA 2.0 allows derived IDs, an expanded to support this better by adding @MapsId", "label": {"api": {"@MapsId": [[73, 79]]}}}, {"text": "check if the startTime is after endTime and swap the opernads if required", "label": {"api": {"is after": [[23, 30]]}}}, {"text": "A better approach would be to write your own PathDataSource that's similar to FileDataSource but uses Files.newInputStream instead of FileInputStream", "label": {"api": {"Files.newInputStream": [[102, 121]]}}}, {"text": "You probably want to use a List<Integer> instead", "label": {"api": {"List<Integer>": [[27, 39]]}}}, {"text": "This is, for example, how java.util.Set specifies its hashCode to be order-independent", "label": {"api": {"java.util.Set": [[26, 38]]}}}, {"text": "It relies solely on the value obtained from the getID method", "label": {"api": {"getID": [[48, 52]]}}}, {"text": "Now I noticed that SingletonSet, as returned by Collections.singleton(), does not implement SortedSet", "label": {"api": {"Collections.singleton()": [[48, 70]]}}}, {"text": "The SortedSet interface defines methods that require a Comparator for the set elements", "label": {"api": {"SortedSet": [[4, 12]], "Comparator": [[55, 64]]}}}, {"text": "Thus elements maintained by a SortedSet have to be comparable", "label": {"api": {"SortedSet": [[30, 38]]}}}, {"text": "If the singleton returned by Collections.singleton() would implement SortedSet, then Collections.singleton() could accept Comparables only (which is not what we want)", "label": {"api": {"SortedSet": [[69, 77]], "Comparables": [[122, 132]]}}}, {"text": "See JavaDoc for using FileFilter with JFileChooser", "label": {"api": {"FileFilter": [[22, 31]]}}}, {"text": "You need to implement custom FileFilter that not only will check the file name extension but also check if file content is a text", "label": {"api": {"FileFilter": [[29, 38]]}}}, {"text": "CountDownLatch is what you're looking for", "label": {"api": {"CountDownLatch": [[0, 13]]}}}, {"text": "From the JavaDoc for Date.parse (which is used by the Deprecated(!!) String constructor)", "label": {"api": {"JavaDoc for Date.parse": [[9, 30]]}}}, {"text": "I wanted to use a similar technique to pre-process and reuse a Polygon , but a Polygon doesn't expose items property, or a similar one", "label": {"api": {"Polygon": [[63, 69], [79, 85]]}}}, {"text": "My solution was to extend Polygon and add such property", "label": {"api": {"Polygon": [[26, 32]]}}}, {"text": "is it the right approach, or is there a better way to dynamically loads point to a Polygon constructed byFXML, avoiding post-processing", "label": {"api": {"Polygon": [[83, 89]]}}}, {"text": "And PrintStream.println() calls String.valueOf() for objects", "label": {"api": {"PrintStream.println()": [[4, 24]], "String.valueOf()": [[32, 47]]}}}, {"text": "And for a String the PrintStream.println() prints out the string", "label": {"api": {"PrintStream.println()": [[21, 41]]}}}, {"text": "Where as for the Customer class you are defaulting to the Object.toString() causing to the print the Customer@ string", "label": {"api": {"Object.toString()": [[58, 74]]}}}, {"text": "But you can open it via Class.getResourceAsStream()", "label": {"api": {"Class.getResourceAsStream()": [[24, 50]]}}}, {"text": "Map has a fairly complex contract that will be difficult (or impossible) to properly follow with the data structure you're describing", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "Furthermore, the behavior of this \"map\" doesn't really match the conceptual purpose of a Map, as lookups are expensive (likely O(nk), where k is the complexity of the pattern)", "label": {"api": {"Map": [[89, 91]]}}}, {"text": "I'd suggest avoiding implementing Map and instead defining a dedicated class that just supports the behavior you need", "label": {"api": {"Map": [[34, 36]]}}}, {"text": "In addition to not needing to implement the full Map contract, we can also give our methods clearer names and better signatures", "label": {"api": {"Map": [[49, 51]]}}}, {"text": "Your example would end up looking like this (you'll likely want a standard functional interface as the V type, but it depends on what you need)", "label": {"api": {"functional interface": [[75, 94]]}}}, {"text": "You can simply String.join the strings together and print them", "label": {"api": {"String.join": [[15, 25]]}}}, {"text": "Finally note that although this program does not contain a loop, the String.join definitely need some form of looping inside the method", "label": {"api": {"String.join": [[69, 79]]}}}, {"text": "Of course, java.util.ArrayList does this for you", "label": {"api": {"java.util.ArrayList": [[11, 29]]}}}, {"text": "You can use the split function from the string class", "label": {"api": {"split": [[16, 20]]}}}, {"text": "You may also have come across the @FunctionalInterface annotation - this can be placed on an interface to enforce at compile-time that the interface has exactly one abstract method", "label": {"api": {"@FunctionalInterface": [[34, 53]]}}}, {"text": "If SmartAdder was annotated with @FunctionalInterface the interface itself would not compile", "label": {"api": {"@FunctionalInterface": [[33, 52]]}}}, {"text": "IF you need to inverse a Predicate you can using Predicate#negate, for example", "label": {"api": {"Predicate#negate": [[49, 64]]}}}, {"text": "IF you want to list all odd numbers, you should use Stream#filter, for example", "label": {"api": {"Stream#filter": [[52, 64]]}}}, {"text": "IF you want to find the first odd number, you can use Stream#findFirst, for example", "label": {"api": {"Stream#findFirst": [[54, 69]]}}}, {"text": "IF you want to find the first odd number regardless of the elements order, you can use Stream#findAny, for example", "label": {"api": {"Stream#findAny": [[87, 100]]}}}, {"text": "both Stream#findAny and Stream#findFirst are short-circuiting terminal operation, which means it will exit once any intermediate operation is satisfied", "label": {"api": {"Stream#findFirst": [[24, 39]], "Stream#findAny": [[5, 18]], "short-circuiting terminal operation": [[45, 79]], "intermediate operation": [[116, 137]]}}}, {"text": "For reference, see JavaDoc for ServletContext#getResourceAsStream and this StackOverflow post", "label": {"api": {"ServletContext#getResourceAsStream": [[31, 64]]}}}, {"text": "Read the SimpleDateFormat javadoc", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "If panel2 is a JPanel, it doesn't have a setIcon method", "label": {"api": {"JPanel": [[15, 20]]}}}, {"text": "Use a JLabel instead , it has such a method", "label": {"api": {"JLabel": [[6, 11]]}}}, {"text": "So when designing your own objects that should close some resource at end of their life, try to implement java.lang.AutoCloseable interface and add the appropriate methods", "label": {"api": {"java.lang.AutoCloseable": [[106, 128]]}}}, {"text": "DNS lookup can hurt performance on some machines", "label": {"api": {"DNS lookup": [[0, 9]]}}}, {"text": "For the JDK you can change the security properties for caching DNS lookup networkaddress.cache.ttl and networkaddress.cache.negative.ttl or set the system properties sun.net.inetaddr.ttl and sun.net.inetaddr.negative.ttl", "label": {"api": {"DNS lookup": [[63, 72]]}}}, {"text": "If you want to prevent all DNS lookups during a transport then you have to use IP addresses", "label": {"api": {"DNS lookup": [[27, 36]]}}}, {"text": "Since you're using PreparedStatement, I think you need to have question marks in the query and then use pstmt.setString()", "label": {"api": {"PreparedStatement": [[19, 35]]}}}, {"text": "Then I'm calling invokeAny from two different threads using the same ExecutorService", "label": {"api": {"invokeAny": [[17, 25]]}}}, {"text": "As per the invokeAny documentation", "label": {"api": {"invokeAny": [[11, 19]]}}}, {"text": "My question is, upon successful return of invokeAny, will it cancel all the threads which are in the thread pool or will it cancel only the tasks which are called in separate threads", "label": {"api": {"invokeAny": [[42, 50]]}}}, {"text": "Arrays.binarySearch() returns a negative value if the item isn't already in the array, so that it can distinguish between where the item is if it is there and where it should be if it isn't there", "label": {"api": {"Arrays.binarySearch()": [[0, 20]]}}}, {"text": "You should take a look to ProcessBuilder", "label": {"api": {"ProcessBuilder": [[26, 39]]}}}, {"text": "I have approached this using String's substring(int, int), lastIndexOf(str, int) and charAt(int) method", "label": {"api": {"substring(int, int)": [[38, 56]], "lastIndexOf(str, int)": [[59, 79]], "charAt(int)": [[85, 95]]}}}, {"text": "The charAt(int) is used to check if the character is a space or not", "label": {"api": {"charAt(int)": [[4, 14]]}}}, {"text": "This is achieved by lastIndexOf(str, int)", "label": {"api": {"lastIndexOf(str, int)": [[20, 40]]}}}, {"text": "I know that if you want to reference back from @Embeddable to its parent you can set the parent \"manually\" in the setter and use @Access(AccessType.PROPERTY) for this embedded field as stated in this answer, but what if this embedded element is mapped in a collection, which is lazy loaded", "label": {"api": {"@Access(AccessType.PROPERTY)": [[129, 156]]}}}, {"text": "@CollectionTable.JoinColumns() is used to set the foreign key columns of the collection table which reference the primary table of the entity, which means that once set this optional property, there is no necessary to \"manually\" reference back from @embeddable to its parent", "label": {"api": {"@CollectionTable.JoinColumns()": [[0, 29]]}}}, {"text": "The Optional.ifPresent method receives a Consumer that will be used only if the Optional contains a non-null value", "label": {"api": {"Optional.ifPresent": [[4, 21]], "Consumer": [[41, 48]]}}}, {"text": "ifPresent will then use this Consumer argument, only if the value is present", "label": {"api": {"Consumer": [[29, 36]]}}}, {"text": "calling flush() method may push the unsaved data to database", "label": {"api": {"flush": [[8, 12]]}}}, {"text": "The constructor you are using takes a String argument - denoting a file name", "label": {"api": {"constructor": [[4, 14]]}}}, {"text": "You're loading the fxml using a static method (FXMLLoader.load(URL)) instead of a instance method", "label": {"api": {"FXMLLoader.load(URL)": [[47, 66]]}}}, {"text": "Look at the second example, line #2 at https://docs.oracle.com/javase/7/docs/api/java/text/ChoiceFormat.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/ChoiceFormat.html": [[39, 107]]}}}, {"text": "You can use Calendar to set a year after parsing", "label": {"api": {"Calendar": [[12, 19]]}}}, {"text": "Assuming regionIDList is a List, use contains instead of equals", "label": {"api": {"contains": [[37, 44]]}}}, {"text": "Seems like your SurfaceView is locking thread with ReentrantLock, but possibly having a problem initialising after setting WaitLock, and the ReentrantLock stays locked by SurfaceView, this is causing your Thread blocked usually know as Jank", "label": {"api": {"ReentrantLock": [[51, 63], [141, 153]]}}}, {"text": "A functional way to approach the problem is to filter the non-colliding ships and projectiles", "label": {"api": {"filter": [[47, 52]]}}}, {"text": "A ReaderInterceptor allows you to manipulate inbound entity streams, that is, the streams coming from the \"wire\"", "label": {"api": {"ReaderInterceptor": [[2, 18]]}}}, {"text": "The timer will allow you to set an ActionListener to be fired after a provided delay has elapsed", "label": {"api": {"ActionListener": [[35, 48]]}}}, {"text": "Signature of method is void registerOutParameter(int parameterIndex, int sqlType), where sqlType is described as \"the JDBC type code defined by java.sql.Types\"", "label": {"api": {"void registerOutParameter(int parameterIndex, int sqlType)": [[23, 80]]}}}, {"text": "Also, javadoc of CallableStatement shows that the syntax of the SQL string is {?= call <procedure-name>[(<arg1>,<arg2>, ...)]}, which means your statement should be", "label": {"api": {"CallableStatement": [[17, 33]]}}}, {"text": "Because the pattern expects to see a single character from the class A(BC), and matches matches the entire input against the regex (doesn't look for partial matches)", "label": {"api": {"matches": [[80, 86], [88, 94], [157, 163]]}}}, {"text": "in Java 8 you can use Stream#mapToInt to imitate Array.ConvertAll in C#", "label": {"api": {"Stream#mapToInt": [[22, 36]]}}}, {"text": "You could, however, use the getChildren() method on a Pane to iterate through that Pane's nodes to get to a particular node's coordinates", "label": {"api": {"Pane": [[54, 57], [83, 86]]}}}, {"text": "Use the built-in indexOf() method of String", "label": {"api": {"indexOf()": [[17, 25]]}}}, {"text": "As described in its javadoc, ThreadLocalRandom is similar to Random (i.e", "label": {"api": {"its javadoc": [[16, 26]]}}}, {"text": "So the question is \"what is the difference between Random and SecureRandom\" implementations", "label": {"api": {"SecureRandom": [[62, 73]]}}}, {"text": "SecureRandom differs in that, it passed tests that are required for safety in cryptology", "label": {"api": {"SecureRandom": [[0, 11]]}}}, {"text": "For more details see SecureRandom javadoc", "label": {"api": {"SecureRandom": [[21, 32]]}}}, {"text": "You can use map#containsValue to check if your edge is pointed to by something", "label": {"api": {"map#containsValue": [[12, 28]]}}}, {"text": "You could implement Filter from the Servlet API using the same URI defined in the @ServerEndpoint annotation, then you'll be able to intercept the handshake request", "label": {"api": {"Filter": [[20, 25]], "@ServerEndpoint": [[82, 96]]}}}, {"text": "Just to elaborate on what Krishna Kuntala said, when you look at the Logger class, the add handler is adding on an ArrayList", "label": {"api": {"Logger": [[69, 74]], "ArrayList": [[115, 123]]}}}, {"text": "To start the threads at exactly the same time i would recommend giving CyclicBarrier a try", "label": {"api": {"CyclicBarrier": [[71, 83]]}}}, {"text": "CyclicBarrier is \"A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point\"", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "If this is OK for you, you can take advantage of some very useful methods of TreeMap, such as headMap, tailMap and subMap, to name the most relevant ones", "label": {"api": {"very useful methods of TreeMap": [[54, 83]]}}}, {"text": "Based from this documentation, GooglePlayServicesAvailabilityIOException wraps a GooglePlayServicesAvailabilityException into an IOException so it can be caught directly", "label": {"api": {"IOException": [[61, 71], [129, 139]]}}}, {"text": "The @NotNull and @Email annotations are validation annotations (@Email is from Hibernate though)", "label": {"api": {"@NotNull": [[4, 11]]}}}, {"text": "UUID.fromString(String)requires the passed String to adhere to the 'string standard representation' as described in UUID.toString()", "label": {"api": {"UUID.toString()": [[116, 130]]}}}, {"text": "See UUID.fromString() and UUID.toString()", "label": {"api": {"UUID.fromString()": [[4, 20]], "UUID.toString()": [[26, 40]]}}}, {"text": "If you are using Java 8, you can parse the dates to LocalDates without the need for a formatter because they are in ISO format", "label": {"api": {"the dates to LocalDates": [[39, 61]]}}}, {"text": "Then you can calculate the number of days between them with using a ChronoUnit", "label": {"api": {"a ChronoUnit": [[66, 77]]}}}, {"text": "Then register your filter in your the ContextResolver for ObjectMapper", "label": {"api": {"ContextResolver": [[38, 52]]}}}, {"text": "If you are using recent versions of Java then there are APIs like ReentrantLock and ReadWriteLock which provides more granular support for locking", "label": {"api": {"ReentrantLock": [[66, 78]], "ReadWriteLock": [[84, 96]]}}}, {"text": "In general comment, using synchronized or private static final Object lock = new Object(); for locking is the old way of locking, with the new concurrency API provided by Java, you should be using APIs like ReentrantLock and ReadWriteLock for implementing your synchronization mechanism", "label": {"api": {"ReentrantLock": [[207, 219]], "ReadWriteLock": [[225, 237]]}}}, {"text": "Extra code after what you have done is findFirst which will returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty", "label": {"api": {"findFirst": [[39, 47]], "Optional": [[71, 78], [137, 144]]}}}, {"text": "The last map will be applied on the resulting Optional<ContactDTO> if it's not empty to create a Contact or else return an empty Optional<Contact>", "label": {"api": {"Optional": [[46, 53], [129, 136]], "map": [[9, 11]]}}}, {"text": "Java Agent provides services needed to instrument Java programming language code", "label": {"api": {"Java Agent": [[0, 9]]}}}, {"text": "ClassFileTransformer is an implementation for Java Agent, and the transformation occurs before the class is defined by the JVM", "label": {"api": {"Java Agent": [[46, 55]], "ClassFileTransformer": [[0, 19]]}}}, {"text": "An illustration of how Java Agent works", "label": {"api": {"Java Agent": [[23, 32]]}}}, {"text": "As I checked Interface Instrumentation, I didn't see any direct api to save the transformed bytecode", "label": {"api": {"Interface Instrumentation": [[13, 37]]}}}, {"text": "I wonder whether it is possible to use Java Agent to achieve my goal, or some other tools", "label": {"api": {"Java Agent": [[39, 48]]}}}, {"text": "Running Maven build of this project will invoke the Google AutoService annotation processor, create a registration file for your custom processor, and build a .jar with it", "label": {"api": {"custom processor": [[129, 144]]}}}, {"text": "Otherwise the registration file that must be picked up by Java ServiceLoader is generated during compilation and obviously not included in the compiler's classpath", "label": {"api": {"Java ServiceLoader": [[58, 75]]}}}, {"text": "In the createSymbolicLink method documentation, it says it throws a FileAlreadyExistsException if a file with the same Path as the link file already exists", "label": {"api": {"createSymbolicLink method documentation": [[7, 45]]}}}, {"text": "You can work around this though by relying on a handle() with a BiFunction that returns a CompletionStage", "label": {"api": {"handle()": [[48, 55]]}}}, {"text": "Integer wrapper class contains a built-in API that may help you with that", "label": {"api": {"built-in API": [[33, 44]]}}}, {"text": "If you do not expect the names to have any sensible order, I would probably go with UUID", "label": {"api": {"UUID": [[84, 87]]}}}, {"text": "If you're worried about uniqueness of the UUID, have a look at this thread", "label": {"api": {"UUID": [[42, 45]]}}}, {"text": "This question is well answered by @Eran, @TheLostMind and all, so I am not putting same point, I just want to take the opportunity make a point on how SoftReference and WeakReference helps to \"delay\" the out of memory exception", "label": {"api": {"SoftReference": [[151, 163]], "WeakReference": [[169, 181]]}}}, {"text": "I'm using Collectors.toMap to do the job, which has three arguments", "label": {"api": {"Collectors.toMap": [[10, 25]]}}}, {"text": "you can suspend a CompletableFuture until completed by CompletableFuture#join, for example", "label": {"api": {"CompletableFuture#join": [[55, 76]]}}}, {"text": "Consider the documentation of CompletableFuture", "label": {"api": {"documentation of CompletableFuture": [[13, 46]]}}}, {"text": "All async methods without an explicit Executor argument are performed using the ForkJoinPool.commonPool() (unless it does not support a parallelism level of at least two, in which case, a new Thread is created to run each task)", "label": {"api": {"ForkJoinPool.commonPool()": [[80, 104]]}}}, {"text": "your methods signature should be as below, and the Collection#addAll also does it in java", "label": {"api": {"Collection#addAll": [[51, 67]]}}}, {"text": "This can be acheived by using streams", "label": {"api": {"streams": [[30, 36]]}}}, {"text": "To append text in the caret position, you could try JTextPane#replaceSelection(String) which from the docs", "label": {"api": {"JTextPane#replaceSelection(String)": [[52, 85]]}}}, {"text": "Just came across openJDK JPopupMenu class method isPopupMenu(), which is implemented as follows", "label": {"api": {"JPopupMenu": [[25, 34]]}}}, {"text": "Simply use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[11, 28]]}}}, {"text": "Just base64 encode the data instead (see https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html": [[41, 103]]}}}, {"text": "DefaultTableCellRenderer.getTableCellRendererComponent takes as parameters view indexes", "label": {"api": {"DefaultTableCellRenderer.getTableCellRendererComponent": [[0, 53]]}}}, {"text": "You need to convert those indexes using JTable.convertRowIndexToModel and JTable.convertColumnIndexToModel first", "label": {"api": {"JTable.convertRowIndexToModel": [[40, 68]], "JTable.convertColumnIndexToModel": [[74, 105]]}}}, {"text": "That being said, you can use ClassLoader.getResourceAsStream() method to access a file on the CLASSPATH", "label": {"api": {"ClassLoader.getResourceAsStream()": [[29, 61]]}}}, {"text": "As indicated in the javadoc of ZonedId.SHORT_IDS, “BST” is not British Summer Time but Bangladesh Standard Time (Asia/Dhaka)", "label": {"api": {"the javadoc of ZonedId.SHORT_IDS": [[16, 47]]}}}, {"text": "This creates a BitSet from the flags argument and then calls the BitSet.stream method, which returns an IntStream of indices for which the bitset contains a bit on, e.g", "label": {"api": {"BitSet": [[15, 20], [65, 70]], "BitSet.stream": [[65, 77]], "IntStream": [[104, 112]]}}}, {"text": "Adjust the minimum width", "label": {"api": {"minimum width": [[11, 23]]}}}, {"text": "176 is the minimum width this control can have", "label": {"api": {"minimum width": [[11, 23]]}}}, {"text": "This property is a Map and in Groovy, you can add an entry directly with the subscript operator []", "label": {"api": {"Map": [[19, 21]]}}}, {"text": "It takes two arguments (a name and a value) and adds a new entry to the Map mentioned above", "label": {"api": {"Map": [[72, 74]]}}}, {"text": "You can check this by looking at the implementation, which in the end simply calls Timestamp(int year, int month, int date, int hour, int minute, int second, int nano) which calls public Date(int year, int month, int date, int hrs, int min, int sec), which says (emphasis mine)", "label": {"api": {"Timestamp(int year, int month, int date, int hour, int minute, int second, int nano)": [[83, 166]], "public Date(int year, int month, int date, int hrs, int min, int sec)": [[180, 248]]}}}, {"text": "Use a ReadWriteLock, which generally means a ReentrantReadWriteLock", "label": {"api": {"ReadWriteLock": [[6, 18], [54, 66]], "ReentrantReadWriteLock": [[45, 66]]}}}, {"text": "A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing", "label": {"api": {"ReadWriteLock": [[2, 14]]}}}, {"text": "A more robust routine would keep an IdentityHashMap of every object seen so far (perhaps excluding known value types like String and Integer) so you don't end up with infinite recursion in a case where two objects reference each other", "label": {"api": {"IdentityHashMap": [[36, 50]]}}}, {"text": "To compare two Date objects, you will need the compareTo() method from the Date class", "label": {"api": {"method": [[59, 64]]}}}, {"text": "IF you want an operation is executed in a parallel stream, you should using the reduction operation", "label": {"api": {"reduction operation": [[80, 98]]}}}, {"text": "Note that if you've filled the buffer up with put() calls, you need to call flip()", "label": {"api": {"flip()": [[76, 81]]}}}, {"text": "You will want to first look at the Java API whenever you have questions about how a core Java method is supposed to behave", "label": {"api": {"Java API": [[35, 42]]}}}, {"text": "To create an escaped URL or URI, use the java.net.URI class", "label": {"api": {"java.net.URI class": [[41, 58]]}}}, {"text": "On the other hand, if you just want to examine what sorts of fields are present, you can use the Element API for that, for example", "label": {"api": {"you can use the Element API for that": [[81, 116]]}}}, {"text": "You need to import the JavaFX Duration class instead", "label": {"api": {"JavaFX Duration class": [[23, 43]]}}}, {"text": "I'm not that much into JavaScript and HTML, but in the WebEngine Documentation you can see that there are a few callbacks for some JavaScript functions", "label": {"api": {"WebEngine Documentation": [[55, 77]]}}}, {"text": "You can use FocusListener class focusLost() method", "label": {"api": {"FocusListener": [[12, 24]]}}}, {"text": "This allow the board to be save by clone() and restored by arraycopy", "label": {"api": {"arraycopy": [[59, 67]]}}}, {"text": "The only real change with respect to your example code is that we check the result of Set.remove() to see if the element was actually removed", "label": {"api": {"Set.remove()": [[86, 97]]}}}, {"text": "for using the stream api you just need to proxying an Iterator from the source Stream to another Stream by StreamSupport#stream & Spliterators#spliterator(Iterator, long, int) , for example", "label": {"api": {"StreamSupport#stream": [[107, 126]], "Spliterators#spliterator(Iterator, long, int)": [[130, 174]]}}}, {"text": "The documentation for YearMonth does not have any advice for how to handle this", "label": {"api": {"documentation for YearMonth": [[4, 30]]}}}, {"text": "Long running tasks should not be executed in the EDT, use a SwingWorker or another Thread", "label": {"api": {"SwingWorker": [[60, 70]]}}}, {"text": "Indicated to study Swing's Threading Policy", "label": {"api": {"Swing's Threading Policy": [[19, 42]]}}}, {"text": "Use comparator that compares only the names", "label": {"api": {"comparator": [[4, 13]]}}}, {"text": "Furthermore, to solve the problem of the single values, you could use a StringBuilder which constructs your numbers and ignores the letters and commas", "label": {"api": {"StringBuilder": [[72, 84]]}}}, {"text": "entrySet() is a method of the java.util.Map interface whereas getValue() is a method of the java.util.Map.Entry interface", "label": {"api": {"java.util.Map": [[30, 42], [92, 104]], "java.util.Map.Entry": [[92, 110]]}}}, {"text": "Assuming b is a BufferedImage - the documentation of getSubimage says", "label": {"api": {"documentation of getSubimage": [[36, 63]]}}}, {"text": "It's just a call to Optional.orElse(), which returns the internal value if it's present, otherwise it returns the value passed in", "label": {"api": {"Optional.orElse()": [[20, 36]]}}}, {"text": "You can use a simple null check or Map.getOrDefault()", "label": {"api": {"Map.getOrDefault()": [[35, 52]]}}}, {"text": "As per Oracle doc says", "label": {"api": {"Oracle doc": [[7, 16]]}}}, {"text": "As per FileTime.toString() documentation the value is always presented as UTC time zone", "label": {"api": {"FileTime.toString() documentation": [[7, 39]]}}}, {"text": "And then simply Files.write() the bytes to the disk", "label": {"api": {"Files.write()": [[16, 28]]}}}, {"text": "Because you are not doing a copy of Calendar from with Calendar cal = from", "label": {"api": {"Calendar": [[36, 43], [55, 62]]}}}, {"text": "Just call Calendar.getInstance() each time you need a new Calendar", "label": {"api": {"Calendar": [[10, 17], [58, 65]]}}}, {"text": "As Ole V.V said in comments, you could have a strange behavior if this code is running just before midnigh, you could get a different \"date\" value with a Calendar.getInstance()", "label": {"api": {"Calendar": [[154, 161]]}}}, {"text": "To prevent that, you could clone() the instance, Calendar implements Cloneable", "label": {"api": {"Calendar": [[49, 56]], "Cloneable": [[69, 77]]}}}, {"text": "As per the documentation, it's also short-circuiting so therefore potentially more efficient than other methods", "label": {"api": {"As per the documentation": [[0, 23]]}}}, {"text": "You will first need a flatMap to create a stream of all InvoiceDetails in all Invoice in your list", "label": {"api": {"flatMap": [[22, 28]]}}}, {"text": "After that you can reduce with the variant of toMap that gets a merge method", "label": {"api": {"toMap": [[46, 50]]}}}, {"text": "This object contain a field children of type List witch as a size method", "label": {"api": {"List": [[45, 48]], "size method": [[61, 71]]}}}, {"text": "A ContextResolver for ObjectMapper is only required if you need to customize the ObjectMapper for the Jackson JSON provider", "label": {"api": {"ContextResolver": [[2, 16]]}}}, {"text": "But the ContextResolver won't do anything if the Jackson provider is not registered", "label": {"api": {"ContextResolver": [[8, 22]]}}}, {"text": "Otherwise you might be missing on options like valueOf(), EnumSet, EnumMap or values()", "label": {"api": {"valueOf()": [[47, 55]], "EnumSet": [[58, 64]], "EnumMap": [[67, 73]]}}}, {"text": "FileChannel documentation claims you can manually put file into FS cache", "label": {"api": {"FileChannel documentation": [[0, 24]]}}}, {"text": "In other hand BufferedReader supply you with excellent API to read file line-by-line, but BufferedReader documentation lack of any note about putting file into FS cache", "label": {"api": {"BufferedReader documentation": [[90, 117]]}}}, {"text": "There's a hint in the JavaDoc of RequestDispatcher", "label": {"api": {"RequestDispatcher": [[33, 49]]}}}, {"text": "So essentially, you can ask for the RequestDispatcher via the ServletContext, in which case you can only use absolute paths, or you can request it via the ServletRequest, in which case you can use paths relative to that request path", "label": {"api": {"RequestDispatcher": [[36, 52]]}}}, {"text": "It seems \"messy\" but not that much, as you said you're probably going to use a variant of indexOf(String str, int fromIndex) twice to get the indexes and then coloring using spannable", "label": {"api": {"indexOf(String str, int fromIndex)": [[90, 123]]}}}, {"text": "You can fix this by using peek() method prior to dequeueing, comparing the results, and only then dequeueing the smaller of the two elements, and moving it into the output", "label": {"api": {"peek()": [[26, 31]]}}}, {"text": "JavaFX CSS reference was also extremely useful to when I started styling using CSS", "label": {"api": {"JavaFX CSS reference": [[0, 19]]}}}, {"text": "Use row1.content.toString().replace(\"\\\"\",\"/\\\"\") to replace specific character instead of using String.replaceAll that use a different logic (with a regex)", "label": {"api": {"String.replaceAll": [[95, 111]]}}}, {"text": "With String.replaceAll as the javadoc says", "label": {"api": {"String.replaceAll": [[5, 21]]}}}, {"text": "Here is an example for numbers with NumberFormat", "label": {"api": {"NumberFormat": [[36, 47]]}}}, {"text": "Yet, as far as I know, Java does not support operator overloading and the  official documention does not say a word about it, hence my question", "label": {"api": {"official documention": [[75, 94]]}}}, {"text": "There are many ways to format a time with time zone in Java, String.format() is the least flexible of them", "label": {"api": {"String.format()": [[61, 75]]}}}, {"text": "If you insist on using String.format(), you can control the time zone in various ways", "label": {"api": {"String.format()": [[23, 37]]}}}, {"text": "Since a long, Long, or java.util.Date argument will use the default time zone of the JVM, you can change it using TimeZone.setDefault(TimeZone zone), however that is generally a bad idea, so I'd highly discourage you from doing this", "label": {"api": {"TimeZone.setDefault(TimeZone zone)": [[114, 147]]}}}, {"text": "Since a Calendar argument has a time zone, you can change your long millisecond argument to use that", "label": {"api": {"Calendar": [[8, 15]]}}}, {"text": "In Java 8, you can also use the new java.time objects", "label": {"api": {"java.time": [[36, 44]]}}}, {"text": "If you don't have to use String.format(), you should use new java.time objects in Java 8", "label": {"api": {"String.format()": [[25, 39]], "java.time": [[61, 69]]}}}, {"text": "Using ZonedDateTime to specify time zone", "label": {"api": {"ZonedDateTime": [[6, 18]]}}}, {"text": "Specifying time zone in the DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[28, 44]]}}}, {"text": "You can use java.beans.Introspector to obtain PropertyDescriptors", "label": {"api": {"java.beans.Introspector": [[12, 34]], "PropertyDescriptors": [[46, 64]]}}}, {"text": "getPrintableWidth() and getPrintableHeight() return their sizes in 1⁄72 inch", "label": {"api": {"getPrintableWidth()": [[0, 18]], "getPrintableHeight()": [[24, 43]]}}}, {"text": "To divide equivalent units, you can convert pixels to inches using the printResolution property of JobSettings", "label": {"api": {"printResolution": [[71, 85]]}}}, {"text": "Be aware that a Node’s getWidth() and getHeight() methods may return zero if it is not in a visible Stage, unless its applyCss() and layout() methods are called first, as described in the documentation of Node.applyCss()", "label": {"api": {"the documentation of Node.applyCss()": [[184, 219]]}}}, {"text": "Apart from the error that has already been flagged, you could reconsider your design and use the YearMonth class which seems better suited to your use case than LocalDate", "label": {"api": {"the YearMonth class": [[93, 111]]}}}, {"text": "Types.asElement, Elements.getPackageOf, Types.erasure and DeclaredType.getTypeArguments", "label": {"api": {"Types.asElement": [[0, 14]], "Elements.getPackageOf": [[17, 37]], "Types.erasure": [[40, 52]], "DeclaredType.getTypeArguments": [[58, 86]]}}}, {"text": "The documentation on GarbageCollectorMXBean.html#getCollectionTime() is sparse", "label": {"api": {"GarbageCollectorMXBean.html#getCollectionTime()": [[21, 67]]}}}, {"text": "But reading the CSS Reference Guide I see the structure", "label": {"api": {"CSS Reference Guide": [[16, 34]]}}}, {"text": "This comment is only stating, what can be derived from the documentation of the package and the individual classes", "label": {"api": {"documentation of the package": [[59, 86]]}}}, {"text": "The specification only tells you the semantic of SoftReference, WeakReference, and PhantomReference", "label": {"api": {"SoftReference": [[49, 61]], "WeakReference": [[64, 76]], "PhantomReference": [[83, 98]]}}}, {"text": "If you look closer at the javadoc for LinkedList, you can see that LinkedList does not define the iterator() method, but as you implement Iterable it should be there", "label": {"api": {"javadoc for LinkedList": [[26, 47]]}}}, {"text": "Apart from that, you can easily skip the second for-loop by using List.contains() and setting the flag according to the result", "label": {"api": {"List.contains()": [[66, 80]]}}}, {"text": "If you want to communicate some information from a background thread, you should use Platform.runLater call which posts work to that thread", "label": {"api": {"Platform.runLater": [[85, 101]]}}}, {"text": "You may store the Shape objects in a List, and have your panel draw every shape from this List", "label": {"api": {"Shape": [[18, 22]]}}}, {"text": "Note that Shape doesn't have things like a color for instance", "label": {"api": {"Shape": [[10, 14]]}}}, {"text": "If you need such things, create a wrapper class containing the Shape and other desired parameters, and use a list of this kind of objects instead of simple Shape objects", "label": {"api": {"Shape": [[63, 67], [156, 160]]}}}, {"text": "You can first create a DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[23, 39]]}}}, {"text": "You might try a third case using RSAPrivateCrtKeySpec to compare with", "label": {"api": {"RSAPrivateCrtKeySpec": [[33, 52]]}}}, {"text": "See the IIOMetadata class documentation for details", "label": {"api": {"IIOMetadata": [[8, 18]]}}}, {"text": "Without using Guava, you could use Collectors.groupingBy, see Federico Peralta Schaffner's answer", "label": {"api": {"Collectors.groupingBy": [[35, 55]]}}}, {"text": "Locking and unlocking could be done through acquiring and releasing a binary semaphore", "label": {"api": {"binary semaphore": [[70, 85]]}}}, {"text": "Alternatively, you could return a default value or generate one", "label": {"api": {"default value": [[34, 46]]}}}, {"text": "You can use Math.max() and Math.min()", "label": {"api": {"Math.max()": [[12, 21]], "Math.min()": [[27, 36]]}}}, {"text": "i was reading about Throwable class from https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html but i was not able to understand the chained exception facility", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html": [[41, 106]]}}}, {"text": "Try using BigInteger, something like this", "label": {"api": {"BigInteger": [[10, 19]]}}}, {"text": "According javadoc String split(regex) and split(regex, limit) work like expected", "label": {"api": {"split(regex)": [[25, 36]], "split(regex, limit)": [[42, 60]]}}}, {"text": "Read the Split doc, \"The limit parameter controls the number of times the pattern is applied\", so you can't with achieve it with split", "label": {"api": {"Split doc": [[9, 17]]}}}, {"text": "I'm guessing that your tiles occupy a GridLayout in BorderLayout.CENTER, the default layout and location for a JFrame", "label": {"api": {"JFrame": [[111, 116]]}}}, {"text": "You could try setResizable(false) on the enclosing JFrame to preclude the separation", "label": {"api": {"JFrame": [[51, 56]]}}}, {"text": "When you pack() the enclosing JFrame, it \"Causes this Window to be sized to fit the preferred size and layouts of its subcomponents.\" The example cited gets it's initial size from the SIZE of the icons comprising the tiles, but you can override getPreferredSize() to specify a different result", "label": {"api": {"JFrame": [[30, 35]], "pack()": [[9, 14]]}}}, {"text": "or similar (as File has no copy constructor, but does have a constructor accepting a pathname)", "label": {"api": {"constructor accepting a pathname": [[61, 92]]}}}, {"text": "This uses Collectors.collectingAndThen, which accepts a collector and then uses the result as the input of the given function", "label": {"api": {"Collectors.collectingAndThen": [[10, 37]]}}}, {"text": "If you don't really need random access, use ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[44, 64]]}}}, {"text": "If you don't need random access for writes but only need it for reads, use ConcurrentLinkedQueue for writes and copy it to a list from time to time if changes were made to the queue (in a separate thread), give this list to \"readers\"", "label": {"api": {"ConcurrentLinkedQueue": [[75, 95]]}}}, {"text": "Does not require explicit synchronization; gives a \"weakly consistent\" read view", "label": {"api": {"weakly consistent": [[52, 68]]}}}, {"text": "Use a map instead, ConcurrentHashMap if you don't care about ordering and want O(1) performance or ConcurrentSkipListMap if you do need ordering and are ok with O(logN) performance", "label": {"api": {"ConcurrentHashMap": [[19, 35]], "ConcurrentSkipListMap": [[99, 119]]}}}, {"text": "You need to have your Contact and ContactList classes implement Serializable", "label": {"api": {"Serializable": [[64, 75]]}}}, {"text": "Calling get requires an object on which to evaluate the field's value, see the field class docs", "label": {"api": {"the field class docs": [[75, 94]]}}}, {"text": "By reading the doc I found that you can create a RandomAccessFile instance first, then call getChannel on it", "label": {"api": {"RandomAccessFile": [[49, 64]], "getChannel": [[92, 101]]}}}, {"text": "The code snippets from here don't work because they cause an exception on password protected archives by default since the default Java ZipFile doesn't support password protections", "label": {"api": {"ZipFile": [[136, 142]]}}}, {"text": "You can chain comparators using thenComparing", "label": {"api": {"thenComparing": [[32, 44]]}}}, {"text": "Note that Java 8 introduced a reversed method for comparators which is slighty less verbose than Collections.reverseOrder", "label": {"api": {"reversed": [[30, 37]]}}}, {"text": "Now, some APIs do properly handle surrogate pairs, such as StringBuilder.reverse()", "label": {"api": {"StringBuilder.reverse()": [[59, 81]]}}}, {"text": "Assuming for the sake of the interview that you can't use this method (or, understandably, you can't recall on the spot whether it's safe or not), you can iterate over the code points of a String with String.codePoints()", "label": {"api": {"String.codePoints()": [[201, 219]]}}}, {"text": "As dimo414 mentioned, StringBuilder.reverse() properly handles surrogate pairs", "label": {"api": {"StringBuilder.reverse()": [[22, 44]]}}}, {"text": "This is not explicitly documented in the Alert class, though it is documented in the documentation for Stage", "label": {"api": {"documentation for Stage": [[85, 107]]}}}, {"text": "You should have a look at ConcurrentMap#computeIfAbsent which does that for you atomically", "label": {"api": {"ConcurrentMap#computeIfAbsent": [[26, 54]]}}}, {"text": "The solution is to use Arrays.deepEquals(), which will compare array elements at any depth", "label": {"api": {"Arrays.deepEquals()": [[23, 41]]}}}, {"text": "Your printf formats should reflect that", "label": {"api": {"printf": [[5, 10]]}}}, {"text": "Since the second printf uses %n, you already know how that works, so why is the first printf not using it", "label": {"api": {"printf": [[17, 22], [86, 91]]}}}, {"text": "Since printf does all the work for you, you code is simple", "label": {"api": {"printf": [[6, 11]]}}}, {"text": "Use Class.getResourceAsStream to get an InputStream", "label": {"api": {"Class.getResourceAsStream": [[4, 28]]}}}, {"text": "You can use CopyOnWriteArrayList instead of ArrayList", "label": {"api": {"CopyOnWriteArrayList": [[12, 31]]}}}, {"text": "Iterators of CopyOnWriteArrayList never throw ConcurrentModificationException", "label": {"api": {"CopyOnWriteArrayList": [[13, 32]]}}}, {"text": "field.get(c) will work just fine with this, since the get method takes an Object, so c will have a good enough type", "label": {"api": {"the get method takes an Object": [[50, 79]]}}}, {"text": "you can using Pattern#splitAsStream to split a string to let the Consumer to accept a String, for example", "label": {"api": {"Pattern#splitAsStream": [[14, 34]]}}}, {"text": "OR you can using String#replaceAll or String#join, for example", "label": {"api": {"String#replaceAll": [[17, 33]], "String#join": [[38, 48]]}}}, {"text": "One of the aspects of a standard HashSet<T> is that it is unordered", "label": {"api": {"HashSet<T>": [[33, 42]]}}}, {"text": "it is possible that the HashSet<T> will do a rehashing", "label": {"api": {"HashSet<T>": [[24, 33]]}}}, {"text": "There exists an extension of a Hashset<T>, the LinkedHashSet<T> which maintains the order of the elements in which they were inserted", "label": {"api": {"HashSet<T>": [[53, 62]], "LinkedHashSet<T>": [[47, 62]]}}}, {"text": "A TreeSet<T> on the other hand, uses a tree, and orders the elements according to an order relation (an object that is less than another object, is emitted before that element)", "label": {"api": {"TreeSet<T>": [[2, 11]]}}}, {"text": "Usually one uses a HashSet<T> to perform insertions, removal, etc", "label": {"api": {"HashSet<T>": [[19, 28]]}}}, {"text": "the documentation described the Collectors#mapping as", "label": {"api": {"Collectors#mapping": [[32, 49]]}}}, {"text": "OR using Collectors#summingLong instead", "label": {"api": {"Collectors#summingLong": [[9, 30]]}}}, {"text": "In Java, a List has a method size that returns the number of elements in the list", "label": {"api": {"method size": [[22, 32]]}}}, {"text": "In example FilterReader class, it design for extensibility, after you implement it in somewhere in your code outside java.io package that protected fields and methods will be private to other classes in your package", "label": {"api": {"FilterReader": [[11, 22]]}}}, {"text": "Sounds like a rule is actually a Predicate that is formed by and-ing other predicates", "label": {"api": {"Predicate": [[33, 41]]}}}, {"text": "This method creates a predicate (that represents one of your operations) based on a Function that will extract the property from either A, B or C (or future classes) and on a Predicate over that property", "label": {"api": {"Predicate": [[175, 183]], "Function": [[84, 91]]}}}, {"text": "It first creates a stream from the given array and then reduces this stream by applying the Predicate#and method to the operations", "label": {"api": {"Predicate": [[92, 100]], "Predicate#and": [[92, 104]]}}}, {"text": "You can check the Arrays#stream, Stream#reduce and Optional#orElse docs for details", "label": {"api": {"Arrays#stream": [[18, 30]], "Stream#reduce": [[33, 45]], "Optional#orElse": [[51, 65]]}}}, {"text": "The documentation for @PostConstruct includes the following language", "label": {"api": {"@PostConstruct": [[22, 35]]}}}, {"text": "By extension, when may a @PostConstruct-annotated method be static, and when must it be non-static", "label": {"api": {"@PostConstruct": [[25, 38]]}}}, {"text": "If you have a Java method that accepts a functional interface as an argument, you can pass an anonymous function in javascript", "label": {"api": {"functional interface": [[41, 60]]}}}, {"text": "A simple way is using LinkedHashSet which allows to contain unique elements only like HashSet (No Duplicates) and maintains insertion order", "label": {"api": {"LinkedHashSet": [[22, 34]]}}}, {"text": "The stax-api dependency has a javax.xml.namespace.QName class that conflicts with the one provided by the JRE (https://docs.oracle.com/javase/7/docs/api/javax/xml/namespace/QName.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/xml/namespace/QName.html": [[111, 182]]}}}, {"text": "This is a consequence of the specification of the hashCode() for Map.Entry, which requires the hash codes of the keys and values to be xor'd", "label": {"api": {"specification": [[29, 41]]}}}, {"text": "Here's an example using bitCount", "label": {"api": {"bitCount": [[24, 31]]}}}, {"text": "setHgap() and setVgap() for GridLayout", "label": {"api": {"GridLayout": [[28, 37]]}}}, {"text": "You can do this a lot more easily with an IntStream", "label": {"api": {"IntStream": [[42, 50]]}}}, {"text": "Every Component, such as JPanel, has a name field, and you can set it with setName()", "label": {"api": {"Component": [[6, 14]]}}}, {"text": "PreparedStatement#executeQuery() does not take a parameter and you should not be passing the query string", "label": {"api": {"PreparedStatement#executeQuery()": [[0, 31]], "Statement#executeQuery()": [[8, 31]]}}}, {"text": "This is a fairly common mistake made when using JDBC, partly because Statement#executeQuery() does take the query string as a parameter", "label": {"api": {"Statement#executeQuery()": [[69, 92]]}}}, {"text": "You may use replaceAll to replace ' with ''", "label": {"api": {"replaceAll": [[12, 21]]}}}, {"text": "According to Java documentation, since LinkedHashSet, is a implementation of Set the order will be according to insertion, so in your example it will be like {\"B\", \"C\", \"F\"}", "label": {"api": {"LinkedHashSet": [[39, 51]], "Set": [[49, 51], [77, 79]]}}}, {"text": "Your method can return a CompletableFuture wrapper of your return type", "label": {"api": {"CompletableFuture": [[25, 41]]}}}, {"text": "You can then use the then-prefixed methods of CompletableFuture to attach a callback function for the result when it's available", "label": {"api": {"CompletableFuture": [[46, 62]]}}}, {"text": "As to how to circumvect this, I think you should consider using a Supplier, which is just the factory you need", "label": {"api": {"Supplier": [[66, 73]]}}}, {"text": "One approach is to use a CustomMenuItem with a Control that lets you adjust the size", "label": {"api": {"CustomMenuItem": [[25, 38]], "Control": [[47, 53]]}}}, {"text": "The example below illustrates a ComboBox, which allows setVisibleRowCount(), and a ListView, which includes a prefWidthProperty and prefHeightProperty", "label": {"api": {"ComboBox": [[32, 39]], "ListView": [[83, 90]]}}}, {"text": "You can use java.awt.Robot", "label": {"api": {"java.awt.Robot": [[12, 25]]}}}, {"text": "The above will work for all plugins that supports the standard or \"plug-in neutral\" metadata format (most do)", "label": {"api": {"standard or \"plug-in neutral\" metadata format": [[54, 98]]}}}, {"text": "See the GridBagConstraints documentation", "label": {"api": {"GridBagConstraints documentation": [[8, 39]]}}}, {"text": "You can use a TextFormatter to filter out invalid operations on the text field", "label": {"api": {"TextFormatter": [[14, 26]]}}}, {"text": "A TextFormatter has a filter which filters changes to the text field; you can veto any changes by having the filter return null", "label": {"api": {"TextFormatter": [[2, 14]]}}}, {"text": "CompletableFuture adds the join() method, which is kind of a non-checked exception version of Future.get() (docs here)", "label": {"api": {"docs here": [[108, 116]]}}}, {"text": "For example Math.PI, you don't need to instantiate Math class to use the value of PI, for this reason it is static", "label": {"api": {"Math.PI": [[12, 18]]}}}, {"text": "As mentioned int comments, XOR will not work for this; however, you can use a HashSet to solve this", "label": {"api": {"HashSet": [[78, 84]]}}}, {"text": "As Andy Turner points out, you can use reflection to get the declared type of the field", "label": {"api": {"field": [[82, 86]]}}}, {"text": "You could get the threads to return a Future that you can check at the end", "label": {"api": {"Future": [[38, 43]]}}}, {"text": "It seems not to be wrong, but you could chain your calls using ifPresent", "label": {"api": {"ifPresent": [[63, 71]]}}}, {"text": "You should use Panel instead", "label": {"api": {"Panel": [[15, 19]]}}}, {"text": "The bundle name must be in the form of logging_LANG_COUNTRY", "label": {"api": {"bundle name": [[4, 14]]}}}, {"text": "Therefore my resource bundle name will be logging_en_US.properties", "label": {"api": {"bundle name": [[22, 32]]}}}, {"text": "Alternatively, if you don't want to do that you can resort to creating a custom formatter", "label": {"api": {"custom formatter": [[73, 88]]}}}, {"text": "I think in your case you can just change getMethod to getDeclaredMethod", "label": {"api": {"getMethod": [[41, 49]], "getDeclaredMethod": [[54, 70]]}}}, {"text": "getMethod only returns public methods", "label": {"api": {"getMethod": [[0, 8]]}}}, {"text": "getDeclaredMethod only includes methods which are declared and not inherited", "label": {"api": {"getDeclaredMethod": [[0, 16]]}}}, {"text": "When you call forEach on a Java List, you are invoking the List's forEach method inherited from Iterable", "label": {"api": {"Iterable": [[96, 103]]}}}, {"text": "Nashorn supports passing a script function whenever a @FunctionalInterface object is expected and so you can pass function as argument for the Consumer parameter", "label": {"api": {"Consumer": [[143, 150]]}}}, {"text": "but you can write and register you own MessageBodyWriter for any type", "label": {"api": {"MessageBodyWriter": [[39, 55]]}}}, {"text": "If you see the description of the ZoneId#getAvailableZoneIds method, then you know why", "label": {"api": {"ZoneId#getAvailableZoneIds": [[34, 59]]}}}, {"text": "Googling \"DataGramSocket Java\" reveals that it's just a standard Java library in the API", "label": {"api": {"the API": [[81, 87]]}}}, {"text": "Check out the link to the API to figure out which package it's in", "label": {"api": {"the API": [[22, 28]]}}}, {"text": "You can use the functional interface Function for that purpose", "label": {"api": {"Function": [[37, 44]]}}}, {"text": "The Function will take a Integer (your row) and return the discount code", "label": {"api": {"Function": [[4, 11]]}}}, {"text": "You could do this using ZonedDateTime from the java.time package", "label": {"api": {"ZonedDateTime": [[24, 36]]}}}, {"text": "This is enforced by the serialVersionUID", "label": {"api": {"serialVersionUID": [[24, 39]]}}}, {"text": "The serialization runtime associates with each serializable class a version number, called a serialVersionUID, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization", "label": {"api": {"serialVersionUID": [[93, 108]]}}}, {"text": "If some of it calls for clarification, you may want to check the API documentation first, or else revert in a comment here", "label": {"api": {"the API documentation": [[61, 81]]}}}, {"text": "You have to call find() before calling group()", "label": {"api": {"find()": [[17, 22]], "group()": [[39, 45]]}}}, {"text": "The find() method returns a boolean so that you can check if there is an occurrence", "label": {"api": {"find()": [[4, 9]]}}}, {"text": "If you would not check that with find() first you would get an java.lang.IllegalStateException", "label": {"api": {"find()": [[33, 38]]}}}, {"text": "If you have to search for multiple matches you call find() in a while loop", "label": {"api": {"find()": [[52, 57]]}}}, {"text": "Both caches should be transactional and obtained from the same instance of Connection class", "label": {"api": {"transactional": [[22, 34]]}}}, {"text": "If C:\\\\somewhere\\\\aesKey.dat contains the AES key, then you can read the file into a byte[] and directly create a Key from that, because a SecretKeySpec implements the Key interface", "label": {"api": {"SecretKeySpec": [[139, 151]]}}}, {"text": "Make sure that you import java.nio.file.*", "label": {"api": {"java.nio.file.*": [[26, 40]]}}}, {"text": "You can however do what the java.util.function interfaces do, and extend the interface with a simpler version, like how BinaryOperator<T> extends BiFunction<T,T,T>", "label": {"api": {"java.util.function": [[28, 45]], "BinaryOperator<T>": [[120, 136]], "BiFunction<T,T,T>": [[146, 162]]}}}, {"text": "ListIterator.remove only deletes the last item returned by next()", "label": {"api": {"ListIterator.remove only deletes the last item returned by next()": [[0, 64]]}}}, {"text": "You can use various synchronization idioms such as https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html to \"line the horses up at the gate before the race\"", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html": [[51, 132]]}}}, {"text": "The use of compute in putValue feels a little clunky, but ConcurrentHashMap guarantees the behavior, so it's whatever", "label": {"api": {"compute": [[11, 17]]}}}, {"text": "The remapping function returning null in computeIfPresent is just the correct way to do what you were already trying to do", "label": {"api": {"compute": [[41, 47]], "computeIfPresent": [[41, 56]]}}}, {"text": "One way you could break up the blocks is by converting the times into a Calendar and checking the HOUR_OF_DAY", "label": {"api": {"HOUR_OF_DAY": [[98, 108]]}}}, {"text": "You could just use an ArrayList", "label": {"api": {"ArrayList": [[22, 30]]}}}, {"text": "If Bar is an interface, you can create a Proxy object for that interface and return it", "label": {"api": {"Proxy": [[41, 45]]}}}, {"text": "Here's the javadoc for FileOutputStream class", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "Validating Input, InputVerifier is a good choice", "label": {"api": {"InputVerifier": [[18, 30]]}}}, {"text": "The getCharacter method only returns meaningful data for KEY_TYPED events, see javadoc (emphasis mine)", "label": {"api": {"see javadoc (emphasis mine)": [[75, 101]]}}}, {"text": "Just like the JFormattedTextField constructors, you can use the type Format to catch the NumberFormat type and the SimpleDateFormat type", "label": {"api": {"JFormattedTextField": [[14, 32]]}}}, {"text": "Use JOptionPane.PLAIN_MESSAGE to create a confirm dialog without an icon", "label": {"api": {"JOptionPane.PLAIN_MESSAGE": [[4, 28]]}}}, {"text": "and JAVA 8 CompletableFuture whenComplete has the same effect, so what's the difference in C#  ContinueWith listenablefuture CompletableFuture", "label": {"api": {"CompletableFuture": [[11, 27], [125, 141]]}}}, {"text": "The ImageIO.write method is useful for writing a loaded image to a HttpServletResponse OutputStream", "label": {"api": {"ImageIO.write": [[4, 16]]}}}, {"text": "You get IndexOutOfBoundsException here because array length is bigger than last index by 1 in example array have elements [1,2,3] indexation starts from 0 and for get last element you need index 2, not 3, otherwise you get exception", "label": {"api": {"IndexOutOfBoundsException": [[8, 32]]}}}, {"text": "In this example from javadoc ScriptException you will see additional methods that return line number, column name, etc", "label": {"api": {"ScriptException": [[29, 43]]}}}, {"text": "You need to read the entire line using nextLine() method then trim it from leading and trailing whitespace using trim() method", "label": {"api": {"nextLine() method": [[39, 55]], "trim() method": [[113, 125]]}}}, {"text": "A java.util.PriorityQueue (of Task instances) constructor can take a Comparator that can take into account the Task#Priority and Task#ID which means that the (priority) ties could be broken based on ID's which are (supposedly) unique", "label": {"api": {"constructor": [[46, 56]]}}}, {"text": "You should just work with the peek and remove API methods to achieve the operation you need while ensuring the time complexity (O(log n)) that the priority queue is designed for", "label": {"api": {"peek": [[30, 33]], "remove": [[39, 44]]}}}, {"text": "So can it be accessed on the event dispatching thread using SwingUtilities.invokeLater as mentioned in Swing's Threading Policy", "label": {"api": {"Swing's Threading Policy": [[103, 126]]}}}, {"text": "and chunk2 is lazily just like  as stream intermediate operations", "label": {"api": {"intermediate operations": [[42, 64]]}}}, {"text": "You should not use Math.random() for this task - instead use Random.nextInt(n), which is designed to properly return a uniform value in the desired range", "label": {"api": {"Random.nextInt(n)": [[61, 77]]}}}, {"text": "Java's Math.random() is documented to return numbers that \"are chosen pseudorandomly with (approximately) uniform distribution from\" the interval [0, 1)", "label": {"api": {"documented": [[24, 33]]}}}, {"text": "However, although that documentation specifies that it uses its own java.util.Random instance, it's not documented how it uses that instance to generate random numbers", "label": {"api": {"documented": [[104, 113]]}}}, {"text": "For example, it's not documented whether that method will call the nextDouble method, which is exactly specified for java.util.Random", "label": {"api": {"documented": [[22, 31]], "nextDouble": [[67, 76]]}}}, {"text": "You can find all the letters you may use in a format pattern string in the documentation of DateTimeFormatter", "label": {"api": {"the documentation of DateTimeFormatter": [[71, 108]]}}}, {"text": "Always check the docs first for questions like this", "label": {"api": {"Always check the docs first for questions like this": [[0, 50]]}}}, {"text": "String.trim() is the simplest way to remove unnecessary whitespace from the beginning or end of a string, so you can always just do a cleanup pass once you've read the file", "label": {"api": {"String.trim()": [[0, 12]]}}}, {"text": "Or you can do the trimming while reading the contents in - Java 8's Files.lines() stream makes this sort of transformation really easy", "label": {"api": {"Files.lines()": [[68, 80]]}}}, {"text": "You could detect if node is a COMMENT_NODE and see if it's data starts with <Context and replace reloadable=true with reloadable=false as in below code", "label": {"api": {"COMMENT_NODE": [[30, 41]]}}}, {"text": "Use Collectors.toMap with a merge function that keeps the car with the max price", "label": {"api": {"Collectors.toMap": [[4, 19]]}}}, {"text": "The System.in.read function return -1 on end-of-file (or end-of-input)", "label": {"api": {"System.in.read": [[4, 17]]}}}, {"text": "All of the mentioned plugins (to my knowledge) supports setting the endianness using the stream metadata sent to ImageWriter.write(...)", "label": {"api": {"ImageWriter.write(...)": [[113, 134]]}}}, {"text": "You should use the Files API to read from a file, and if you're on Windows your path will need to start with C:/, not /", "label": {"api": {"Files": [[19, 23]]}}}, {"text": "You can only use String(byte[], String)", "label": {"api": {"String(byte[], String)": [[17, 38]]}}}, {"text": "To quote File#listDir's documentation", "label": {"api": {"File#listDir's documentation": [[9, 36]]}}}, {"text": "The queue used in the implementation of SingleThreadedEventHandlingStrategy in 1.6.3 is a java.util.concurrent.LinkedBlockingQueue", "label": {"api": {"java.util.concurrent.LinkedBlockingQueue": [[90, 129]]}}}, {"text": "The constructor used is public LinkedBlockingQueue(int capacity) which creates a queue of fixed width", "label": {"api": {"public LinkedBlockingQueue(int capacity)": [[24, 63]]}}}, {"text": "If the maximum capacity is reached and a SessionMessageEvent instance is put on the queue, the thread putting on the event blocks until space becomes available in the queue (i.e", "label": {"api": {"put": [[73, 75], [102, 104]]}}}, {"text": "IF a short-circuiting terminal operation, e.g:anyMatch is invoked, the filter will be exit until the first satisfied element", "label": {"api": {"short-circuiting terminal operation": [[5, 39]]}}}, {"text": "IF a non-short-circuiting terminal operation, e.g:count, collect is invoked, the filter's behavior just like as yours", "label": {"api": {"short-circuiting terminal operation": [[9, 43]]}}}, {"text": "If you want you can also have a look at .max()", "label": {"api": {".max()": [[40, 45]]}}}, {"text": "Java 8 stream's .min() and .max()", "label": {"api": {".max()": [[27, 32]]}}}, {"text": "You could use getAttribute on Element to retrieve the values of attributes", "label": {"api": {"getAttribute": [[14, 25]], "Element": [[30, 36]]}}}, {"text": "The pattern a is used to parse AM/PM, which is not in the input String, that's why you get a parse error", "label": {"api": {"pattern a is used to parse AM/PM": [[4, 35]]}}}, {"text": "The input format matches an OffsetDateTime, which can be parsed with the respective built-in formatter DateTimeFormatter.ISO_OFFSET_DATE_TIME, so you can use this formatter in a deserializer object and register it in the module", "label": {"api": {"built-in formatter DateTimeFormatter.ISO_OFFSET_DATE_TIME": [[84, 140]]}}}, {"text": "If you want to know the exact algorithm, read BoxLayout’s documentation", "label": {"api": {"BoxLayout’s documentation": [[46, 70]]}}}, {"text": "You should probably read through JTextArea’s documentation to understand it better", "label": {"api": {"JTextArea’s documentation": [[33, 57]]}}}, {"text": "If you are willing to display the content of TxtDisplay on GUI, that implies TxtDisplay has to be a JTextField", "label": {"api": {"JTextField": [[100, 109]]}}}, {"text": "Look up your code you'll find String TxtDisplay; replace it by JTextField TxtDisplay;", "label": {"api": {"JTextField": [[63, 72]]}}}, {"text": "Once you do that you can access inner methods of class JTextField such as getText() and setText(String)", "label": {"api": {"JTextField": [[55, 64]]}}}, {"text": "I was wondering why when does the constructor of a LinkedHashMap that the client code can specify if is access ordered expect a loadFactor", "label": {"api": {"LinkedHashMap": [[51, 63]]}}}, {"text": "What you want to use is a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[26, 49]]}}}, {"text": "Combine that with e.g a Timer that resets it after a fixed delay, and you should have the solution to your problem", "label": {"api": {"Timer": [[24, 28]]}}}, {"text": "You need to specify multiline regex option (Oracle Documentation link) to make it apply to start of each line instead", "label": {"api": {"Oracle Documentation link": [[44, 68]]}}}, {"text": "A better solutions might involve Futures or ExecutorServices", "label": {"api": {"Futures": [[33, 39]], "ExecutorServices": [[44, 59]]}}}, {"text": "There is a handy comparing method in Comparator to save you having to manually write comparators", "label": {"api": {"comparing": [[17, 25]]}}}, {"text": "As Holger points out, since you are comparing an int, you might prefer to use comparingInt in place of comparing", "label": {"api": {"comparing": [[36, 44], [78, 86], [103, 111]], "comparingInt": [[78, 89]]}}}, {"text": "If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification", "label": {"api": {"serializable": [[5, 16]]}}}, {"text": "However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected InvalidClassExceptions during deserialization", "label": {"api": {"serializable": [[45, 56]]}}}, {"text": "Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value", "label": {"api": {"serializable": [[110, 121]]}}}, {"text": "String has an endsWith method", "label": {"api": {"endsWith": [[14, 21]]}}}, {"text": "You can get a character from the string using charAt, as long as the string is not empty", "label": {"api": {"charAt": [[46, 51]]}}}, {"text": "You can convert a character to upper case using Character.toUpperCase so that you can compare characters without worrying about what case they are in", "label": {"api": {"Character.toUpperCase": [[48, 68]]}}}, {"text": "You can use String.endsWith for both", "label": {"api": {"String.endsWith": [[12, 26]]}}}, {"text": "The Scanner object you are using has a method hasNextInt() so you can construct a simple while loop to figure out how many numbers there are", "label": {"api": {"hasNextInt()": [[46, 57]]}}}, {"text": "HttpServletRequest#startAsync() isn't useful for this", "label": {"api": {"HttpServletRequest#startAsync()": [[0, 30]]}}}, {"text": "There are other signatures for the read function, one which takes a File and one which takes an InputStream instead, so you can use either of the following", "label": {"api": {"one which takes a File": [[50, 71]], "which takes an InputStream instead": [[81, 114]]}}}, {"text": "Use IntStream.builder() to get an IntStream.Builder to which you can repeatedly add new int values", "label": {"api": {"IntStream.builder()": [[4, 22]], "IntStream.Builder": [[34, 50]]}}}, {"text": "Use a java.util.concurrent.ThreadPoolExecutor with a corePoolSize of 0 and a keepAliveTime of 0", "label": {"api": {"java.util.concurrent.ThreadPoolExecutor": [[6, 44]]}}}, {"text": "I've tried using GraphicsContext.clearRect() to clear the areas where the bottom shape is not, but that removes the background", "label": {"api": {"GraphicsContext.clearRect()": [[17, 43]]}}}, {"text": "the documentation Stream#collect has already mentioned", "label": {"api": {"Stream#collect": [[18, 31]]}}}, {"text": "which means the Stream#collect does two primary thing", "label": {"api": {"Stream#collect": [[16, 29]]}}}, {"text": "when creates a unordered stream by Stream#generate, then you can fetch different result on Collectors#toList, for example", "label": {"api": {"Stream#generate": [[35, 49]]}}}, {"text": "You can entirely eliminate all if statements by calling setMaximumFractionDigits()", "label": {"api": {"setMaximumFractionDigits()": [[56, 81]]}}}, {"text": "If you had wanted a format like \"0.000\" instead, also call setMinimumFractionDigits()", "label": {"api": {"setMinimumFractionDigits()": [[59, 84]]}}}, {"text": "Specify a pattern like \"#.###\" or \"0.000\" is actually just shorthand for calling the various setter methods of DecimalFormat", "label": {"api": {"setter methods": [[93, 106]]}}}, {"text": "The letters you can use are documented here", "label": {"api": {"documented here": [[28, 42]]}}}, {"text": "Also the implementation coming with the standard Java library is self balancing too (TreeSet at JavaAPI)", "label": {"api": {"TreeSet at JavaAPI": [[85, 102]]}}}, {"text": "Maybe you are also looking for a PriorityQueue (PriorityQueue at JavaAPI)", "label": {"api": {"PriorityQueue at JavaAPI": [[48, 71]]}}}, {"text": "You have imported java.util.zip.ZipFile and are attempting to call methods on it which do not exist", "label": {"api": {"java.util.zip.ZipFile": [[18, 38]]}}}, {"text": "I want to use Java formatter string to accomplish this but am only successful in accomplishing one of the above mention conditions but not both at once", "label": {"api": {"Java formatter string": [[14, 34]]}}}, {"text": "You should use Validator::validateProperty to check specifc properties", "label": {"api": {"Validator::validateProperty": [[15, 41]], "Validator::validate": [[15, 33]]}}}, {"text": "You can also group them and check it via Validator::validate (see here for tutorial) if there are more than one property", "label": {"api": {"Validator::validate": [[41, 59]]}}}, {"text": "Usually attempts to remove namespaces to perform a \"transformation\" is a sign of lack of understanding of how to handle XML but in general if you use SAX and want to alter the processed XML you can implement a filter https://docs.oracle.com/javase/8/docs/api/org/xml/sax/XMLFilter.html, starting with https://docs.oracle.com/javase/8/docs/api/org/xml/sax/helpers/XMLFilterImpl.html as a base clase and overriding the methods where you expect and want to strip namespaces", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/org/xml/sax/XMLFilter.html": [[217, 284]], "https://docs.oracle.com/javase/8/docs/api/org/xml/sax/helpers/XMLFilterImpl.html": [[301, 380]]}}}, {"text": "The above is possible since guava's Ordering implements java.util.Comparator so you can pass it as argument to comparing", "label": {"api": {"comparing": [[111, 119]]}}}, {"text": "Method.getParameterTypes() returns Class<?>[], so your typeClassz can only be a Class<?>, not a ParameterizedType", "label": {"api": {"Method.getParameterTypes()": [[0, 25]]}}}, {"text": "You should use getGenericParameterTypes() instead, which returns a Type[]", "label": {"api": {"getGenericParameterTypes()": [[15, 40]]}}}, {"text": "I'd recommend using a HashMap that stores the player's UUID and the current timestamp", "label": {"api": {"HashMap": [[22, 28]]}}}, {"text": "What you can do is use the Style as a regular AttributeSet, then use an ElementIterator to scan for the styled elements, since a Style’s name is stored under the AttributeSet.NameAttribute attribute key", "label": {"api": {"AttributeSet.NameAttribute": [[162, 187]]}}}, {"text": "You can use a TreeMap with a custom comparator (it sorts by the keys' natural ordering by default)", "label": {"api": {"TreeMap": [[14, 20]]}}}, {"text": "To use it with a custom Comaparator you simply pass the comparator into the constructor of the TreeMap", "label": {"api": {"TreeMap": [[95, 101]]}}}, {"text": "You can use a MouseListener instead", "label": {"api": {"MouseListener": [[14, 26]]}}}, {"text": "You can work with String.lastIndexOf(int) instead to determine the position of the file extension", "label": {"api": {"String.lastIndexOf(int)": [[18, 40]]}}}, {"text": "If you are going to mutate an existing Map<..., Boolean>, you can use  Collections.newSetFromMap", "label": {"api": {"Collections.newSetFromMap": [[71, 95]]}}}, {"text": "Use the java.sql.Date(long date) constructor and System.currentTimeMillis()", "label": {"api": {"java.sql.Date(long date)": [[8, 31]]}}}, {"text": "In general, you should should setup a logging.properties file", "label": {"api": {"logging.properties": [[38, 55]]}}}, {"text": "Supplier is used for a default constructor, but you can use any functional interface type (for instance one of the ones listed here", "label": {"api": {"Supplier": [[0, 7]]}}}, {"text": "Link) that matches the signature of the constructor you want to reference (for instance one that takes arguments)", "label": {"api": {"Link": [[0, 3]]}}}, {"text": "In the case of Supplier, you can call get(), to create a new instance", "label": {"api": {"Supplier": [[15, 22]]}}}, {"text": "As far as I understand I think you should use java.util.PriorityQueue instead of Array", "label": {"api": {"java.util.PriorityQueue": [[46, 68]]}}}, {"text": "You can use setModel with DefaultComboBoxModel which take an array instead like", "label": {"api": {"setModel": [[12, 19]]}}}, {"text": "You're calling split(NEEDLE)", "label": {"api": {"split(NEEDLE)": [[15, 27]]}}}, {"text": "You should call split(NEEDLE, -1)", "label": {"api": {"split(NEEDLE, -1)": [[16, 32]]}}}, {"text": "For a PrintWriter, flush is also called whenever a newline is printed (via println or manually via printf/print)", "label": {"api": {"PrintWriter": [[6, 16]]}}}, {"text": "You can use Table.rowMap() to get \"a view that associates each row key with the corresponding map from column keys to values\"; the view is a Map and its keySet() contains all of the Column keys for a given Row key", "label": {"api": {"Map": [[21, 23], [141, 143]], "keySet()": [[153, 160]]}}}, {"text": "Use an ExecutorService, specifically  it submit(Callable) method which returns a Future which get() or isDone() methods can be called to retrieve the result", "label": {"api": {"ExecutorService": [[7, 21]], "submit(Callable)": [[41, 56]], "Future": [[81, 86]], "get()": [[94, 98]], "isDone()": [[103, 110]]}}}, {"text": "You can use different flavors of ExecutorService in which you can queue processings which may (submit(Callable)) or may not (execute(Runnable)) return a result", "label": {"api": {"ExecutorService": [[33, 47]], "submit(Callable)": [[95, 110]], "execute(Runnable)": [[125, 141]]}}}, {"text": "You are comparing Pattern.splitAsStream(CharSequence) to Splitter.split(CharSequence) on a Splitter.on(char) instead of on a Splitter.onPattern(String)", "label": {"api": {"Pattern.splitAsStream(CharSequence)": [[18, 52]]}}}, {"text": "BufferedWriter has a newLine method for writing a newline sequence for the environment (e.g., using the line.separator property)", "label": {"api": {"newLine method": [[21, 34]]}}}, {"text": "These statements will handle the closing automatically for you", "label": {"api": {"automatically": [[41, 53]]}}}, {"text": "I found the solution, the problem was in Annotation @org.springframework.data.annotation.Transient once I changed to @javax.persistence.Transient it worked fine", "label": {"api": {"@javax.persistence.Transient": [[117, 144]]}}}]