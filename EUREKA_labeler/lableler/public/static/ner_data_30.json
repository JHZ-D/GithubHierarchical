[{"text": "Since Java 8 there is a class Optional that can be used to avoid a null return value, making the program safer", "label": {"api": {"Optional": [[30, 37]]}}}, {"text": "However, nothing in Java will force you to use Optional, nor is there a naming convention", "label": {"api": {"Optional": [[47, 54]]}}}, {"text": "} is the simplest to use as it doesn't require explicit unlock, unlike ReentrantLock", "label": {"api": {"ReentrantLock": [[71, 83]]}}}, {"text": "But the ReentrantLock allows you to get extended information (see its javadoc for more information", "label": {"api": {"ReentrantLock": [[8, 20]]}}}, {"text": "Performance-wise, ReentrantReadWriteLock will improve performance when you have few writes and many reads (as you don't need to lock when you're only reading), but you should take extra care when taking and releasing locks, as \"ownable synchronizers\" can deadlock your threads (read and write locks are not treated in the same manner)", "label": {"api": {"ReentrantReadWriteLock": [[18, 39]]}}}, {"text": "But if the data you want to read/write is a \"simple type\" (as described in the atomic package javadoc), you will get the best performance by using the AtomicInteger and the likes, as they use specific, optimized CPU instruction set such as compare-and-swap in SSE* set", "label": {"api": {"atomic package javadoc": [[79, 100]], "AtomicInteger": [[151, 163]]}}}, {"text": "In your case, makes the class NestedFoo comparable (https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html": [[52, 118]]}}}, {"text": "Then you can invoke the method Collections.sort (https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-) on your lists", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-": [[49, 137]]}}}, {"text": "Since modifiedItems.get returns a Boolean (which is not castable to a String), the signature that would be used is Boolean.valueOf(boolean), where the Boolean is outboxed to a primitive boolean", "label": {"api": {"Boolean.valueOf(boolean)": [[115, 138]]}}}, {"text": "You can use Class.cast", "label": {"api": {"Class.cast": [[12, 21]]}}}, {"text": "Alternatively you could create the samples dataseries in a Task, where you create the samples collection in a different thread and apply them all at once on task completion", "label": {"api": {"Task": [[59, 62]], "task completion": [[157, 171]]}}}, {"text": "findElements returns a List, not just any old Collection, so you could use a positional get(int)", "label": {"api": {"get(int)": [[88, 95]]}}}, {"text": "In the first case, you have to apply nullsFirst to the base comparator you want to use", "label": {"api": {"nullsFirst": [[37, 46]]}}}, {"text": "If you have the possibility of null names, you need to make sure that your key never returns a null, or that you apply nullsFirst to String.CASE_INSENSITIVE_ORDER", "label": {"api": {"nullsFirst": [[119, 128]], "String.CASE_INSENSITIVE_ORDER": [[133, 161]]}}}, {"text": "If you have both options (null references and null names), you will have to combine both versions and apply nullsFirst twice", "label": {"api": {"nullsFirst": [[108, 117]]}}}, {"text": "If you are chaining multiple comparisons like this, the outer nullsFirst, which ensures that null Persons get sorted properly, can be applied to the entire chain", "label": {"api": {"nullsFirst": [[62, 71]]}}}, {"text": "You might want to look at Arrays.asList() for the argument of setParameterTypes()", "label": {"api": {"Arrays.asList()": [[26, 40]]}}}, {"text": "You can use Collections.nCopies to create several copies of the same array, and then flat map them to a single array", "label": {"api": {"Collections.nCopies": [[12, 30]]}}}, {"text": "For example, can an ArrayList be passed to a Java Stream for parallel-processing of its elements", "label": {"api": {"Java Stream": [[45, 55]]}}}, {"text": "The java application that got started used an ExecutorService that did not got shotdown correctly and left zombie threads alive which prevented process termination", "label": {"api": {"ExecutorService": [[46, 60]]}}}, {"text": "Instead, you could use String.startsWith(String) and a series of if-else conditions", "label": {"api": {"String.startsWith(String)": [[23, 47]]}}}, {"text": "The problem with what you want is that TextArea is not built for this functionality, at least in JDK 8 (JDK 9 added public skinning API, e.g., TextAreaSkin)", "label": {"api": {"TextAreaSkin": [[143, 154]]}}}, {"text": "Specifically, its skin, TextAreaSkin does not facilitated a masking mechanism", "label": {"api": {"TextAreaSkin": [[24, 35]]}}}, {"text": "TextAreaSkin uses a group of Text nodes for its visuals, though only 1 is used in JDK 8", "label": {"api": {"TextAreaSkin": [[0, 11]]}}}, {"text": "You may find the Array class's accessor methods useful", "label": {"api": {"Array": [[17, 21]]}}}, {"text": "The documentation on Selector says the following", "label": {"api": {"documentation on Selector": [[4, 28]]}}}, {"text": "The happens-before relation is defined in the Java Language Specification, Chapter 17, as including the synchronizes-with relation", "label": {"api": {"happens-before relation": [[4, 26]]}}}, {"text": "From the Javadoc of PriorityQueue", "label": {"api": {"Javadoc of PriorityQueue": [[9, 32]]}}}, {"text": "You are on the right track, but instead of using charAt inside your for-loop, instead try something like this where you use charAt earlier on", "label": {"api": {"charAt": [[49, 54], [124, 129]]}}}, {"text": "Although you may have good reasons to create your own dialog mechanism, I would like to point out that JavaFX already has a standard way for dialogs", "label": {"api": {"standard way": [[124, 135]]}}}, {"text": "There are quite a few things in that direction in Java, but the closest would probably be the Java Scripting API which \"is used to embed scripts in your Java applications\"", "label": {"api": {"Java Scripting API": [[94, 111]]}}}, {"text": "I tried unmarmshalling by declared type with limited success", "label": {"api": {"unmarmshalling by declared type": [[8, 38]]}}}, {"text": "It can be injected through the remoteAgent execution parameter", "label": {"api": {"execution parameter": [[43, 61]]}}}, {"text": "A more robust solution will probably involve cloning the JdiDefaultExecutionControl and JdiInitiator implementations and extending them with remote connection capability", "label": {"api": {"JdiDefaultExecutionControl": [[57, 82]], "JdiInitiator": [[88, 99]]}}}, {"text": "A simple example would be instances of Runnable or Callable (or even FutureTask if you want to have the name \"task\" in it) for the tasks, and an ExecutorService to run them", "label": {"api": {"ExecutorService": [[145, 159]]}}}, {"text": "It looks you want to alter the zoom state of the WebView based on an event, so you should update the zoom property held by the WebView itself", "label": {"api": {"WebView": [[49, 55], [127, 133]], "zoom": [[31, 34], [101, 104]]}}}, {"text": "You may use the good old Java's ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[32, 49]]}}}, {"text": "If you go with the ThreadPoolExecutor, you are basically dividing your Array into smaller chunks that will each be processed by a Thread", "label": {"api": {"ThreadPoolExecutor": [[19, 36]]}}}, {"text": "You'll then instantiate your ExecutorService and execute your Worker Threads", "label": {"api": {"ExecutorService": [[29, 43]]}}}, {"text": "This solution uses an index list to help you use Collections.binarySearch()", "label": {"api": {"Collections.binarySearch()": [[49, 74]]}}}, {"text": "It's not functionColumnReturn, it's just functionReturn (4)", "label": {"api": {"functionReturn (4)": [[41, 58]]}}}, {"text": "Use a ScheduledExecutorService, and schedule a task to be run at your requested interval", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "You are calling the static FXMLLoader.load(URL) method", "label": {"api": {"FXMLLoader.load(URL)": [[27, 46]]}}}, {"text": "You need to invoke an instance load() method, e.g", "label": {"api": {"instance load() method": [[22, 43]]}}}, {"text": "Why don't you use the map method for this", "label": {"api": {"map": [[22, 24]]}}}, {"text": "Here I'm mapping the students stream to a stream of grades and then grouping them", "label": {"api": {"map": [[9, 11]]}}}, {"text": "I think that is good to point out that you don't need to use Arrays.asList for this", "label": {"api": {"Arrays.asList": [[61, 73]]}}}, {"text": "You can create a Stream of your students array directly with Arrays.stream", "label": {"api": {"Arrays.stream": [[61, 73]]}}}, {"text": "To create a PKCS12 the easy way, just use KeyStore as explained in its javadoc, which should be available in your IDE or on Oracle's website", "label": {"api": {"or on Oracle's website": [[118, 139]]}}}, {"text": "An InputStream is the raw method of getting information from a resource", "label": {"api": {"InputStream": [[3, 13]]}}}, {"text": "On the other hand, when you use String then it is for the sequence of characters", "label": {"api": {"String": [[32, 37]]}}}, {"text": "So, in case if you are reading just the text data or characters then it is okay if you use String but say, if you are using an image or any binary file then you have to take care of further processing and encodings", "label": {"api": {"String": [[91, 96]]}}}, {"text": "You can then use floorEntry and ceilingEntry to find the x coordinates that fall within your range", "label": {"api": {"floorEntry": [[17, 26]], "ceilingEntry": [[32, 43]], "ceiling": [[32, 38]], "floor": [[17, 21]]}}}, {"text": "Then for each TreeSet<Integer> set that you get, you can use ceiling and floor to get the appropriate entries", "label": {"api": {"ceiling": [[61, 67]], "floor": [[73, 77]]}}}, {"text": "But TreeSet also has a subset that will give you a range of values", "label": {"api": {"subset": [[23, 28]]}}}, {"text": "The floor and ceiling calls are log(n) I believe -- this is where you get the performance benefit because if you use a list, it would be O(n) to look that up", "label": {"api": {"ceiling": [[14, 20]], "floor": [[4, 8]]}}}, {"text": "I know that I could use BigDecimal or other classes but as I said I cannot modify the parameters of createEPoint(double lat, double lon)", "label": {"api": {"BigDecimal": [[24, 33]]}}}, {"text": "Here is an alternative using the method setCharAt", "label": {"api": {"setCharAt": [[40, 48]]}}}, {"text": "Rather than defining layouts in code as in this example, instead use a tool such as SceneBuilder to create the scene visually and save the layout as an FXML file, so that the layout is separated from your code (similarly place any styling in an external CSS file)", "label": {"api": {"FXML file": [[152, 160]]}}}, {"text": "But some DataSource implementations might provide said feature", "label": {"api": {"DataSource": [[9, 18]]}}}, {"text": "For example the Tomcat JDBC DataSource has a setInitSQL(String sql)-method", "label": {"api": {"DataSource": [[28, 37]]}}}, {"text": "You can use Class#cast", "label": {"api": {"Class#cast": [[12, 21]]}}}, {"text": "Create an appropiate Comparator that will compare two items according to your desired criteria", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "If at a later time you want to sort by different criteria, call Collections.sort() again with a different Comparator", "label": {"api": {"Comparator": [[106, 115]]}}}, {"text": "More than often, the subsequent step is to perform pattern matching within the contents and in this case, it’s better to use Scanner in the first place, which is capable of performing pattern matching while streaming the data, which can be done efficiently as the regex engine tells whether buffering more data could change the outcome of a match operation (see hitEnd() and requireEnd())", "label": {"api": {"Scanner": [[125, 131]], "hitEnd()": [[362, 369]], "requireEnd()": [[375, 386]]}}}, {"text": "Unfortunately, generating a stream of matches from a Scanner has only been added in Java 9, but see this answer for a back-port of that feature to Java 8", "label": {"api": {"Scanner": [[53, 59]], "Java 9": [[84, 89]]}}}, {"text": "You can do this with Math.round", "label": {"api": {"Math.round": [[21, 30]]}}}, {"text": "this has the append(CharSequence,int,int) method, which allows you to avoid unnecessarily creating substrings", "label": {"api": {"append(CharSequence,int,int)": [[13, 40]]}}}, {"text": "A Java UUID and a Mongodb UUID both implement the UUID standard", "label": {"api": {"UUID": [[7, 10], [26, 29], [50, 53]]}}}, {"text": "To convert a UUID into the String representation use toString", "label": {"api": {"UUID": [[13, 16]]}}}, {"text": "To check if a specific key exists in a Map you can use the containsKey method", "label": {"api": {"containsKey": [[59, 69]]}}}, {"text": "You can use URLEncoder ..", "label": {"api": {"URLEncoder": [[12, 21]]}}}, {"text": "like with Files#lines(Path, Charset)", "label": {"api": {"Files#lines(Path, Charset)": [[10, 35]]}}}, {"text": "You're iterating through (and printing) the list of cookies contained in the inbound HttpServletRequest, but you're adding the new cookie to the HttpServletResponse", "label": {"api": {"HttpServletResponse": [[145, 163]]}}}, {"text": "While the HttpServletResponse has an addCookie() method, it doesn't have a matching getCookies(), so you would need to work around this if your wish to see the cookies you have added to the response object", "label": {"api": {"HttpServletResponse": [[10, 28]]}}}, {"text": "You don't need a HttpServletResponseWrapper for GZIP compression", "label": {"api": {"HttpServletResponseWrapper": [[17, 42]]}}}, {"text": "It could be achieved with a WriterInterceptor from JAX-RS", "label": {"api": {"WriterInterceptor": [[28, 44]]}}}, {"text": "Then register the WriterInterceptor in your ResourceConfig / Application subclass", "label": {"api": {"WriterInterceptor": [[18, 34]], "Application": [[61, 71]]}}}, {"text": "Look at the Javadoc for Scanner", "label": {"api": {"Javadoc for Scanner": [[12, 30]]}}}, {"text": "If you really, really, really, want to do it via an array, and want to return a downsized array you need to allocate an array with the biggest size needed (a.length), keep the index of where to insert in the newArray and at the end create yet another array holding the amount of filtered entries, and then use System.arraycopy() to copy those elements into your array", "label": {"api": {"System.arraycopy()": [[310, 327]]}}}, {"text": "If you're compiling against Java 9, you should read up on layers - they give you a clean abstraction for loading an entirely new module graph", "label": {"api": {"layers": [[58, 63]]}}}, {"text": "The java.util.stream package documentation gives this definition for identity in the context of reduction", "label": {"api": {"java.util.stream": [[4, 19]]}}}, {"text": "Stream.reduce() and its primitive counterparts offer a similar definition", "label": {"api": {"Stream.reduce()": [[0, 14]]}}}, {"text": "From the Java System documentation", "label": {"api": {"Java System documentation": [[9, 33]]}}}, {"text": "A Future<> can be cancelled by calling cancel(mayInterruptIfRunning)", "label": {"api": {"cancel(mayInterruptIfRunning)": [[39, 67]]}}}, {"text": "Your code basically creates a synchronized set", "label": {"api": {"set": [[43, 45]], "synchronized set": [[30, 45]]}}}, {"text": "It only adds elements if it not already in the list, the very definition of a set", "label": {"api": {"set": [[78, 80]]}}}, {"text": "As I have written in an comment, exactly the same behaviour can be achieved with a synchronized set, which will also make sure that the element has not yet been added while locking the entire operation", "label": {"api": {"set": [[96, 98]], "synchronized set": [[83, 98]]}}}, {"text": "By using this synchronized set access and modification without usage of your utility class is ok", "label": {"api": {"set": [[27, 29]], "synchronized set": [[14, 29]]}}}, {"text": "If your code needs a list and not a set, and a LinkedHashSet isn't the option I would create a new synchronized list myself", "label": {"api": {"set": [[36, 38]]}}}, {"text": "String.split(String) use regular expression, [ and ] are both reserved character", "label": {"api": {"String.split(String)": [[0, 19]]}}}, {"text": "In particular, it looks like someone has forced every byte to a char value, instead of properly decoding the bytes using a Charset", "label": {"api": {"Charset": [[123, 129]]}}}, {"text": "The docs for DataOutputStream#writeUTF mentions that it uses a \"modified UTF-8 encoding.\" That link is in the original JavaDocs (I didn't just add it for this answer), and if you follow it, you get a page explaining that encoding", "label": {"api": {"DataOutputStream#writeUTF": [[13, 37]], "modified UTF-8": [[64, 77]]}}}, {"text": "PrintStream.println(Object) calls string.valueOf(Object) which calls the object's toString() method, and that gets printed", "label": {"api": {"PrintStream.println(Object)": [[0, 26]], "string.valueOf(Object)": [[34, 55]]}}}, {"text": "jewelsea pointed out that there is a way to embed javafx components inside Swing using JFXPanel", "label": {"api": {"JFXPanel": [[87, 94]]}}}, {"text": "So, yes, you can put a javafx Button in a JFrame, so long as you wrap that Button in a JFXPanel", "label": {"api": {"JFXPanel": [[87, 94]], "Button": [[30, 35], [75, 80]], "JFrame": [[42, 47]]}}}, {"text": "It's called SwingNode", "label": {"api": {"SwingNode": [[12, 20]]}}}, {"text": "So, yes, you can put a JButton in a javafx Stage, so long as you wrap that JButton in a SwingNode", "label": {"api": {"Button": [[24, 29], [76, 81]], "SwingNode": [[88, 96]], "JButton": [[23, 29], [75, 81]], "Stage": [[43, 47]]}}}, {"text": "To draw custom table cells, you need to provide your own implementation of a TableCellRenderer", "label": {"api": {"TableCellRenderer": [[77, 93]]}}}, {"text": "Your custom TableCellRenderer must only implement one method", "label": {"api": {"TableCellRenderer": [[12, 28]]}}}, {"text": "getTableCellRendererComponent, which must return a Component or JComponent", "label": {"api": {"TableCellRenderer": [[3, 19]], "Component": [[20, 28], [51, 59], [65, 73]], "JComponent": [[64, 73]]}}}, {"text": "Your TableCellRenderer can then return a custom JComponent which paints the circle depending on the cell value, which gets set beforehand", "label": {"api": {"TableCellRenderer": [[5, 21]], "Component": [[49, 57]], "JComponent": [[48, 57]]}}}, {"text": "If I start a forEach action on a ConcurrentHashMap, and other threads are still performing puts on this map, will I see new updates into other bins", "label": {"api": {"forEach": [[13, 19]]}}}, {"text": "The class-level API docs have this to say", "label": {"api": {"The class-level API docs": [[0, 23]]}}}, {"text": "You need to append your text with area.append(\"...\"); since area.setText(\"...\"); overrides the content", "label": {"api": {"append": [[12, 17], [39, 44]]}}}, {"text": "public void append(String str)", "label": {"api": {"append": [[12, 17]], "public void append(String str)": [[0, 29]]}}}, {"text": "public void setText(String t)", "label": {"api": {"public void setText(String t)": [[0, 28]]}}}, {"text": "Use isShowing method do determine if SecondaryStage is opened", "label": {"api": {"isShowing": [[4, 12]]}}}, {"text": "As you are using JavaFX, wrap \"the basic steps required to implement a watch service\" from that tutorial in a JavaFX Task", "label": {"api": {"Task": [[117, 120]]}}}, {"text": "Perhaps following the pattern from the Task javadoc \"A Task Which Returns Partial Results\" to feedback into your view any changes detected by the watch service", "label": {"api": {"Task": [[39, 42], [55, 58]]}}}, {"text": "Using HashMap is nice way to get this functionality into your program", "label": {"api": {"HashMap": [[6, 12]]}}}, {"text": "You need to write a Java agent and attach it dynamically to transform a class at load time", "label": {"api": {"a Java agent": [[18, 29]]}}}, {"text": "Use String#substring to find different portions of a String and then concatenate them together using the + operator", "label": {"api": {"String#substring": [[4, 19]]}}}, {"text": "don't split; simply call substring() twice, and give the required numbers", "label": {"api": {"substring()": [[25, 35]]}}}, {"text": "You can use String.replaceAll", "label": {"api": {"String.replaceAll": [[12, 28]]}}}, {"text": "Consider using Character.digit method instead of subtracting zero", "label": {"api": {"Character.digit": [[15, 29]]}}}, {"text": "That's fine for most cases, but a more efficient solution would be to use a ScheduledExecutorService, which is like the Timer you tried, only more modern", "label": {"api": {"ScheduledExecutorService": [[76, 99]]}}}, {"text": "Note the different API when you use strict mode, call parseHeader instead of just parse", "label": {"api": {"parseHeader": [[54, 64]]}}}, {"text": "One way to do it is to use String dimLabels = \"ARNDCQ\", and apply indexOf to it to get the index into the matrix", "label": {"api": {"indexOf": [[66, 72]]}}}, {"text": "I found some in-house Java code with a method defined to take an InputStream object as argument", "label": {"api": {"InputStream": [[65, 75]]}}}, {"text": "Elsewhere, this method is called using a RandomAccessFile object as an argument", "label": {"api": {"RandomAccessFile": [[41, 56]]}}}, {"text": "RandomAccessFile does not extend InputStream, and there is no wrapper or conversion at work", "label": {"api": {"InputStream": [[33, 43]], "RandomAccessFile": [[0, 15]]}}}, {"text": "Much later in the class where readDouble() is defined, there's a method overload that takes RandomAccessFile as input", "label": {"api": {"RandomAccessFile": [[92, 107]]}}}, {"text": "To ensure uniform distribution, you should use the nextInt(int bound) method", "label": {"api": {"nextInt(int bound)": [[51, 68]]}}}, {"text": "Looking at https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormatSymbols.html I cannot figure out what method would tell me about that space", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormatSymbols.html": [[11, 87]]}}}, {"text": "If you are talking about the automatic driver loading mechanism of JDBC, then look at the documentation of java.sql.DriverManager, specifically about the META-INF/services/java.sql.Driver file", "label": {"api": {"java.sql.DriverManager": [[107, 128]]}}}, {"text": "Here's the jacadoc of get method", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "If you want the referenced objects to be cloned, you have to have access to the clone method of the referenced objects", "label": {"api": {"clone": [[41, 45], [80, 84]]}}}, {"text": "Docs for atan2 say that you need to input the arguments in order (y,x)", "label": {"api": {"atan2": [[9, 13]]}}}, {"text": "Ever heard of ArrayList", "label": {"api": {"ArrayList": [[14, 22]]}}}, {"text": "An array has fixed size whereas ArrayList expands dynamically", "label": {"api": {"ArrayList": [[32, 40]]}}}, {"text": "ArrayList will grow as you add more and more numbers in to it", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "1) If you take a look at the ExecutorService Javadoc, the shutdown() method does not wait for threads to complete execution", "label": {"api": {"ExecutorService Javadoc": [[29, 51]]}}}, {"text": "If so, you might need to call repaint() and/or revalidate() on controller and/or controller.Log after changing the text", "label": {"api": {"repaint()": [[30, 38]], "revalidate()": [[47, 58]]}}}, {"text": "You should always use PreparedStatements", "label": {"api": {"PreparedStatements": [[22, 39]]}}}, {"text": "Collections class provides a lot of useful method, just like max and min", "label": {"api": {"Collections": [[0, 10]]}}}, {"text": "Since all you're doing to reading lines, use BufferedReader instead", "label": {"api": {"BufferedReader": [[45, 58]]}}}, {"text": "Of course, you could simplify the code immensely by using the newer NIO.2 classes added in Java 7, in particular the java.nio.file.Files class", "label": {"api": {"java.nio.file.Files": [[117, 135]]}}}, {"text": "Thread.sleep is a class method, not an instance method", "label": {"api": {"Thread.sleep": [[0, 11]]}}}, {"text": "If you want to override the AM/PM text, but otherwise retain normal formatting, use the DateFormatSymbols object", "label": {"api": {"DateFormatSymbols": [[88, 104]]}}}, {"text": "Using DateFormatSymbols ensures that the SimpleDateFormat can be used for both parsing and formatting", "label": {"api": {"DateFormatSymbols": [[6, 22]]}}}, {"text": "That's where you should use Hadoop HDFS's Path(URI aUri) and Java's ClassLoader.getResource method", "label": {"api": {"ClassLoader.getResource": [[68, 90]]}}}, {"text": "For this, we use SwingUtilities.invokeLater() where we then set the label's visibility", "label": {"api": {"SwingUtilities.invokeLater()": [[17, 44]]}}}, {"text": "\"If parameterTypes is null, it is treated as if it were an empty array\" so .getMethod(\"removeBondNative\") should give you the same result", "label": {"api": {"\"If parameterTypes is null, it is treated as if it were an empty array\"": [[0, 70]]}}}, {"text": "If you introspect it with Java's reflection API and manipulate PropertyDescriptors, you will notice that they delegate read/write operations to the getters and setters", "label": {"api": {"PropertyDescriptors": [[63, 81]]}}}, {"text": "now, since String.valueOf() returns a  String object then you are telling your code to remove a String of a list of chars..", "label": {"api": {"String.valueOf()": [[11, 26]]}}}, {"text": "As per Pattern API, \\s stands for a whitespace character", "label": {"api": {"Pattern API": [[7, 17]]}}}, {"text": "I am getting an XML External Entity Reference (XXE) vulnerability from the code scan audit(Veracode) while unmarshaling an Element", "label": {"api": {"Element": [[123, 129]]}}}, {"text": "If you are using Java 8, the Period accepts 2 LocalDate parameters (read more about it in the official documentation)", "label": {"api": {"official documentation": [[94, 115]]}}}, {"text": "A typical queue implementation for multithreaded applications is ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[65, 82]]}}}, {"text": "With ArrayBlockingQueue, the reading thread will wait for the other thread to write the value", "label": {"api": {"ArrayBlockingQueue": [[5, 22]]}}}, {"text": "You can make use of Class#getResourceAsStream(String)", "label": {"api": {"Class#getResourceAsStream(String)": [[20, 52]]}}}, {"text": "Ok I found what I was looking for, the KeyboardFocusManager, responsible for dispatching all KeyEvent to the focus elements", "label": {"api": {"KeyboardFocusManager": [[39, 58]]}}}, {"text": "Unfortunately, you can't call toInstant() on a java.sql.Date, because according to javadoc, it always throws an UnsupportedOperationException", "label": {"api": {"according to javadoc": [[70, 89]]}}}, {"text": "If you really want to set the time to midnight, though, you can use the with method and pass a LocalTime to it", "label": {"api": {"with method": [[72, 82]], "LocalTime": [[95, 103]]}}}, {"text": "It's a list of Writer which is used in order to send a message to all connected clients", "label": {"api": {"Writer": [[15, 20]]}}}, {"text": "You can find details in that method's API docs", "label": {"api": {"that method's API docs": [[24, 45]]}}}, {"text": "In java the most elegant way to compare things is the Comparator interface", "label": {"api": {"Comparator": [[54, 63]]}}}, {"text": "You can use flatMap", "label": {"api": {"flatMap": [[12, 18]]}}}, {"text": "If you want to throw a custom exception when the value is missing, use orElseThrow", "label": {"api": {"orElseThrow": [[71, 81]]}}}, {"text": "Or, of course you could just call get and let it throw a NoSuchElementException", "label": {"api": {"get": [[34, 36]]}}}, {"text": "https://docs.oracle.com/javase/tutorial/security/apisign/step2.html -- good entry point", "label": {"api": {"https://docs.oracle.com/javase/tutorial/security/apisign/step2.html": [[0, 66]]}}}, {"text": "From the Files#list() documentation", "label": {"api": {"Files#list() documentation": [[9, 34]]}}}, {"text": "But there is an alternative to get the highest value, you can use Arrays.sort", "label": {"api": {"Arrays.sort": [[66, 76]]}}}, {"text": "If you look at CompletableFuture (since Java 8), you'll notice that it has a vast amount of functionality allowing a lot more than just callbacks", "label": {"api": {"CompletableFuture": [[15, 31]]}}}, {"text": "Compare that to CompletionHandler (since Java 7), and the difference should be obvious", "label": {"api": {"CompletionHandler": [[16, 32]]}}}, {"text": "Nothing prevents you from using both, and it may be even necessary depending on what kind of APIs you're working with, but if you have a chance to use CompletableFuture, you really don't need to tack on a CompletionHandler", "label": {"api": {"CompletableFuture": [[151, 167]], "CompletionHandler": [[205, 221]]}}}, {"text": "From the JsonObjectBuilder interface, you can obtain your JsonObject in this way", "label": {"api": {"JsonObjectBuilder interface": [[9, 35]]}}}, {"text": "If you want to see them anyway, then cast your private key to RSAPrivateCrtKey and use the getters of that class", "label": {"api": {"RSAPrivateCrtKey": [[62, 77]]}}}, {"text": "You can read more about it in the official documentation", "label": {"api": {"in the official documentation": [[27, 55]]}}}, {"text": "As the BigInteger javadocs says", "label": {"api": {"BigInteger javadocs": [[7, 25]]}}}, {"text": "You're trying to set expectations on a final method", "label": {"api": {"final method": [[39, 50]]}}}, {"text": "If you can construct the Client with an AsynchronousByteChannel instead of a AsynchronousSocketChannel, you could use that instead", "label": {"api": {"AsynchronousByteChannel": [[40, 62]]}}}, {"text": "For that, you'd need something that actually knows how to read Zip files, such as Java's ZipFile", "label": {"api": {"ZipFile": [[89, 95]]}}}, {"text": "Java's URI class defines opaque URIs as follows (emphasis mine)", "label": {"api": {"URI": [[7, 9], [32, 34]]}}}, {"text": "A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character ('/')", "label": {"api": {"URI": [[2, 4]]}}}, {"text": "An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined", "label": {"api": {"URI": [[10, 12]]}}}, {"text": "True to the documentation, an opaque URI returns null for a query param", "label": {"api": {"URI": [[37, 39]]}}}, {"text": "Is this behavior specific to Java's URI implementation, or does the URI spec disallow query params in opaque URIs", "label": {"api": {"URI": [[36, 38], [68, 70], [109, 111]]}}}, {"text": "Malformed pattern \"60############\" using DecimalFormat", "label": {"api": {"DecimalFormat": [[41, 53]]}}}, {"text": "But if the need is having each number prefixed with \"60\", then the Excel number formats \\6\\0# or \"60\"# should be possible and should be translated into the DecimalFormat pattern '60'#", "label": {"api": {"DecimalFormat": [[156, 168]]}}}, {"text": "You have to use the nextLine method to read the full line", "label": {"api": {"nextLine": [[20, 27]], "next": [[20, 23]]}}}, {"text": "next will read until the first token (\"Chiquita\" in your case because its followed by a space character and is interpreted as a delimiter)", "label": {"api": {"next": [[0, 3]]}}}, {"text": "Always I did this kind of conversion I use trim() to remove this extra white spaces as follow", "label": {"api": {"trim()": [[43, 48]]}}}, {"text": "Se here http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String- how to avoid NumberFormatException using a regular expression to text you string before try to convert it to double", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-": [[8, 95]]}}}, {"text": "Both requested sorts could be implemented using Collections.sort(List<T>, Comparator<T>) where a different Comparator would be required for each sought sort", "label": {"api": {"Collections.sort(List<T>, Comparator<T>)": [[48, 87]]}}}, {"text": "You may use Mena's suggested \\p{Alnum} but with (?U) embedded flag option to reall match all Unicode letters and digits", "label": {"api": {"(?U) embedded flag option": [[48, 72]]}}}, {"text": "You are passing a varargs, translatable into an Integer[] as argument for your ArrayList#get invocation, which will not compile - see List API", "label": {"api": {"API": [[139, 141]]}}}, {"text": "Java provides a regex library to use called Pattern", "label": {"api": {"Pattern": [[44, 50]]}}}, {"text": "Use the regular expression /(.)\\1+/ and String#replaceAll() to match runs of two or more of the same character and then replace the match with the value of the first match group identified with $1 as follows", "label": {"api": {"String#replaceAll()": [[40, 58]]}}}, {"text": "Store your results in an ordered map, like a TreeMap", "label": {"api": {"TreeMap": [[45, 51]]}}}, {"text": "Instead of returning an array, you would return a SortedMap", "label": {"api": {"SortedMap": [[50, 58]]}}}, {"text": "The Set returned by keySet() will be sorted like the map itself", "label": {"api": {"keySet()": [[20, 27]]}}}, {"text": "To compare primitive double values, use Double.compare", "label": {"api": {"Double.compare": [[40, 53]]}}}, {"text": "If you're using Java 8, you may prefer to use some of the more advanced features of Comparator which make extending this code much simpler", "label": {"api": {"Comparator": [[84, 93]]}}}, {"text": "SceneBuilder 2.0 was the latest release from Oracle and it was before Java 8u40, which means that it doesn't contain controls like ButtonBar or Spinner that were added in 8u40", "label": {"api": {"added": [[162, 166]]}}}, {"text": "It revolves around the classes Path, Paths and Files", "label": {"api": {"Path": [[31, 34], [37, 40]], "Paths": [[37, 41]], "Files": [[47, 51]]}}}, {"text": "And you read it using methods from Files", "label": {"api": {"Files": [[35, 39]]}}}, {"text": "If you later need to use older methods which require a File object you can simply use the Path#toFile method (documentation)", "label": {"api": {"Path": [[90, 93]]}}}, {"text": "Method Integer.lowestOneBit(int i) is implemented as return i & -i;, with a comment saying it's from Section 2-1 of Hacker's Delight by Henry S", "label": {"api": {"Integer.lowestOneBit(int i)": [[7, 33]]}}}, {"text": "In the documentation of PriorityQueue you'll notice it states", "label": {"api": {"documentation of PriorityQueue": [[7, 36]]}}}, {"text": "Or if you just use buttons, you can create boolean field and set, it true if any of your control buttons touched and false if not", "label": {"api": {"boolean": [[43, 49]]}}}, {"text": "If you are reading the file in with a BufferedReader, then going line by line with the readLine() method will automatically exclude any line-termination characters", "label": {"api": {"readLine()": [[87, 96]]}}}, {"text": "I think, you wanted to use String.split() but did not know the syntax", "label": {"api": {"String.split()": [[27, 40]]}}}, {"text": "You can use a Condition and wait for the condition to become satisfied in a specified period in a guard thread", "label": {"api": {"Condition": [[14, 22]]}}}, {"text": "For instance, the initial value of totalDuration is likely to be Duration.UNKNOWN", "label": {"api": {"totalDuration": [[35, 47]]}}}, {"text": "You can deal with this by moving all code that depends on the MediaPlayer into a Runnable, and passing that Runnable to setOnReady", "label": {"api": {"setOnReady": [[120, 129]]}}}, {"text": "You can take a look at the javadocs for Thread.State to see what the various states mean in terms of the JVM", "label": {"api": {"Thread.State": [[40, 51]]}}}, {"text": "With Java 8, you can use a (more functional) alternative to the iterative solution by using Stream", "label": {"api": {"Stream": [[92, 97]]}}}, {"text": "See the Java Class API", "label": {"api": {"the Java Class API": [[4, 21]]}}}, {"text": "The code doesn't work because Java's Pattern (used for regex) has MULTILINE mode disabled by default", "label": {"api": {"MULTILINE": [[66, 74]]}}}, {"text": "Or otherwise setting the Pattern's configuration to use MULTILINE", "label": {"api": {"MULTILINE": [[56, 64]]}}}, {"text": "Or if you don't like to use external API, you can use RandomAccessFile from JDK", "label": {"api": {"RandomAccessFile": [[54, 69]]}}}, {"text": "As Thomas points out, if you really mean to be working with Class instances, you may want isAssignableFrom instead", "label": {"api": {"isAssignableFrom": [[90, 105]]}}}, {"text": "Explicitly use a user Thread with setDaemon(false)", "label": {"api": {"setDaemon(false)": [[34, 49]]}}}, {"text": "For the rest ProcessBuilder would be a more robust class for this task", "label": {"api": {"ProcessBuilder": [[13, 26]]}}}, {"text": "As you are using a JavaFX PieChart in a Swing application, you'll need to enclose the chart in a JFXPanel", "label": {"api": {"PieChart": [[26, 33]], "JFXPanel": [[97, 104]]}}}, {"text": "Anonymous loggers don't have a name which means you can't use the logger name as a formatter pattern", "label": {"api": {"formatter pattern": [[83, 99]]}}}, {"text": "The documentation recommends that you use named loggers if possible", "label": {"api": {"named loggers": [[42, 54]]}}}, {"text": "From the GLOBAL_LOGGER_NAME documentation", "label": {"api": {"GLOBAL_LOGGER_NAME": [[9, 26]]}}}, {"text": "From the getAnonymousLogger​() documentation", "label": {"api": {"getAnonymousLogger​()": [[9, 29]]}}}, {"text": "To improve this, what you want to do is create a StringBuilder, and construct the string in there", "label": {"api": {"StringBuilder": [[49, 61]]}}}, {"text": "The reason this is faster is because StringBuilder doesn't create a new string every time you append something", "label": {"api": {"StringBuilder": [[37, 49]]}}}, {"text": "When you use the nextInt method, it will throw an InputMismatchException if the input value is not a number, then you can use a try-catch block and a loop to validate", "label": {"api": {"nextInt": [[17, 23]]}}}, {"text": "Another alternative would be using the hasNextInt method", "label": {"api": {"hasNextInt": [[39, 48]]}}}, {"text": "It provide a LocalDate.plusDays(long) that return a copy of the instance", "label": {"api": {"LocalDate.plusDays(long)": [[13, 36]]}}}, {"text": "And you can get an instance using LocalDate.of(int, int, int) like", "label": {"api": {"LocalDate.of(int, int, int)": [[34, 60]]}}}, {"text": "and the result of Integer.valueOf(0) is cached, so you're actually synchronizing on the same object", "label": {"api": {"the result of Integer.valueOf(0) is cached": [[4, 45]]}}}, {"text": "It's documented in the JavaDoc for TreeMap (emphasis mine)", "label": {"api": {"the JavaDoc for TreeMap": [[19, 41]]}}}, {"text": "Note also that if one were to use the usual definition, the code could be rewritten to use Integer.compare(int,int) do a single comparison of key with array[mid] to determine whether key was less than, equal to, or greater than array[mid]", "label": {"api": {"Integer.compare(int,int)": [[91, 114]]}}}, {"text": "Implement equals and hashCode method in your DataEntry class and then use the contains method of list to check the existence of entry object", "label": {"api": {"equals": [[10, 15]], "hashCode": [[21, 28]], "contains": [[78, 85]]}}}, {"text": "by way of the JTable.setDefaultEditor(Class<?> columnClass, TableCellEditor editor) method", "label": {"api": {"JTable.setDefaultEditor(Class<?> columnClass, TableCellEditor editor)": [[14, 82]]}}}, {"text": "You should take a look at the Optional class", "label": {"api": {"Optional class": [[30, 43]]}}}, {"text": "Finally I used Optional Class to solve my problem", "label": {"api": {"Optional Class": [[15, 28]]}}}, {"text": "Here's the link to the documentation of ArrayList", "label": {"api": {"link to the documentation": [[11, 35]]}}}, {"text": "In particular, the only \"@-Rules\" listed as supported are @import and @font-face", "label": {"api": {"listed as supported": [[34, 52]]}}}, {"text": "The documentation of the built-in collectors explicitly mentions when a Collector is an unordered collector, e.g", "label": {"api": {"documentation of the built-in collectors": [[4, 43]]}}}, {"text": "for toSet() or groupingByConcurrent(…)", "label": {"api": {"toSet()": [[4, 10]], "groupingByConcurrent(…)": [[15, 37]]}}}, {"text": "A counter-example would be partitioningBy(predicate, toSet()) which does not preserve any order and likewise, a stream that itself is unordered, e.g", "label": {"api": {"toSet()": [[53, 59]]}}}, {"text": "The method  you're using is actually HashSet.contains(Object)", "label": {"api": {"HashSet.contains(Object)": [[37, 60]]}}}, {"text": "The complexity of HashSet.contains(Object) is O(1)", "label": {"api": {"HashSet.contains(Object)": [[18, 41]]}}}, {"text": "This might be the reason that is misleading you to believe that the cost for HashSet.contains(Object) is O(n)", "label": {"api": {"HashSet.contains(Object)": [[77, 100]]}}}, {"text": "If you want an easy alternative in Java look at the class java.lang.StringBuilder", "label": {"api": {"java.lang.StringBuilder": [[58, 80]]}}}, {"text": "If your goal is simply to infer whether your array contains a given value, override equals in the objects passed, wrap your array in a suitable Collection and invoke contains", "label": {"api": {"contains": [[51, 58], [166, 173]]}}}, {"text": "You want Collectors.groupingBy", "label": {"api": {"Collectors.groupingBy": [[9, 29]]}}}, {"text": "As you can see, Circle has no default style class", "label": {"api": {"Circle": [[16, 21]]}}}, {"text": "You can consider using a Type Selector, i.e", "label": {"api": {"Type Selector": [[25, 37]]}}}, {"text": "Use a ScheduledService instead", "label": {"api": {"ScheduledService": [[6, 21]]}}}, {"text": "My Annotation processor uses Compiler Tree API in tools.jar, and I've created a code scanner like @Hervian", "label": {"api": {"Compiler Tree API in tools.jar": [[29, 58]]}}}, {"text": "From the documentation of TextFormatter.getFilter()", "label": {"api": {"documentation of TextFormatter.getFilter()": [[9, 50]]}}}, {"text": "You have many functional interfaces to choose from, and you can create your own", "label": {"api": {"many functional interfaces to choose from": [[9, 49]]}}}, {"text": "The difference in case of an ArrayList is that you'll be using get(index) method to fetch an element from the arraylist", "label": {"api": {"get(index)": [[63, 72]]}}}, {"text": "I don't like using streams when referring to indexes, but you can use groupingBy and summingInt to accomplish this", "label": {"api": {"groupingBy": [[70, 79]], "summingInt": [[85, 94]]}}}, {"text": "LocalDate is available since Java 8", "label": {"api": {"LocalDate": [[0, 8]]}}}, {"text": "You can inject javax.batch.runtime.context.JobContext into your batchlet class, then call JobContext.getJobName() to get the job id", "label": {"api": {"JobContext.getJobName()": [[90, 112]]}}}, {"text": "Just use Files.newDirectoryStream", "label": {"api": {"Files.newDirectoryStream": [[9, 32]]}}}, {"text": "According to the Application class documentation (and this is also specified in other places in the JavaFX documentation)", "label": {"api": {"Application class documentation": [[17, 47]]}}}, {"text": "Alternatively, see if its possible for you to use the alternate version of waitFor() method where we provide the timeOut value", "label": {"api": {"alternate version": [[54, 70]]}}}, {"text": "whilst not documented explicitly, an exception is explicitly thrown for null keys, presumably because of the behavior of Map.computeIfAbsent that \"If the function returns null no mapping is recorded\", meaning elements would otherwise be dropped silently from the output", "label": {"api": {"Map.computeIfAbsent": [[121, 139]]}}}, {"text": "(*) This behavior isn't documented in the Java 8 Javadoc, but it was added for Java 9", "label": {"api": {"Java 8 Javadoc": [[42, 55]], "Java 9": [[79, 84]]}}}, {"text": "You can also use groupingBy in this case as there are 2 group posibilities (active and inactive employees)", "label": {"api": {"groupingBy": [[17, 26]]}}}, {"text": "You could use java.util.Random#nextBoolean()", "label": {"api": {"java.util.Random#nextBoolean()": [[14, 43]]}}}, {"text": "According to the Javadoc of javafx.concurrent.Task, Task implements Runnable, not Callable<T>", "label": {"api": {"javafx.concurrent.Task": [[28, 49]]}}}, {"text": "You should implement equals as an override of java.lang.Object's equals method, which means that your method needs to take Object as a parameter", "label": {"api": {"java.lang.Object's equals method": [[46, 77]]}}}, {"text": "A better way might be to implement a Comparator", "label": {"api": {"Comparator": [[37, 46]]}}}, {"text": "if there a way with CriteriaBuilder to know if two date is less then 12  month period when building my builder", "label": {"api": {"CriteriaBuilder": [[20, 34]]}}}, {"text": "Use the method lessThan(..) to replace the < operator", "label": {"api": {"lessThan(..)": [[15, 26]]}}}, {"text": "The same goes for the method lt(..)", "label": {"api": {"lt(..)": [[29, 34]]}}}, {"text": "Notice that the expression monthBetween < 12 returns a boolean itself, but The method and(..) accepts the Predicate as the parameter", "label": {"api": {"and(..)": [[86, 92]]}}}, {"text": "For further information, see Random.ints(long, int, int), IntStream and Collectors.joining()", "label": {"api": {"Random.ints(long, int, int)": [[29, 55]], "IntStream": [[58, 66]], "Collectors.joining()": [[72, 91]]}}}, {"text": "Check the javadoc of Numberformat for all the options", "label": {"api": {"Numberformat": [[21, 32]]}}}, {"text": "There is no pre-rolled solution, but it is possible to achieve thread-safe concurrency for simple values using a ConcurrentMap<K, Set<V>> which has Set<V> values made from ConcurrentMap<V, Boolean> using Collections.newSetFromMap(Map<V,Boolean>)", "label": {"api": {"Collections.newSetFromMap(Map<V,Boolean>)": [[204, 244]]}}}, {"text": "If you want your values to have a stable iteration order, you can use a ConcurrentSkipListSet to hold values instead", "label": {"api": {"ConcurrentSkipListSet": [[72, 92]]}}}, {"text": "This can be done with String.matches", "label": {"api": {"String.matches": [[22, 35]]}}}, {"text": "You can use a Map<Character, IntUnaryOperator>", "label": {"api": {"a Map<Character, IntUnaryOperator>": [[12, 45]]}}}, {"text": "I'd use the java8 LocalDateTime class server side and ignore timezones if that is what you want", "label": {"api": {"LocalDateTime": [[18, 30]]}}}, {"text": "LocalDateTime is made exactly for handling cases where you want to state dates (and times) without timezone information", "label": {"api": {"LocalDateTime": [[0, 12]]}}}, {"text": "Just make sure you send it to the client, and receive it from the client, as a LocalDateTime", "label": {"api": {"LocalDateTime": [[79, 91]]}}}, {"text": "In response to comments below, if you want to show the date to the user according to their local timezone, it might be better to store a ZonedDateTime in a standard timezone (for example, UTC) and store the  Locale of the users", "label": {"api": {"Locale": [[208, 213]]}}}, {"text": "You can then convert the dates to user-specific date formats using the Locale, which will keep DST and other timezone changes in mind", "label": {"api": {"Locale": [[71, 76]]}}}, {"text": "For converting the datetimes you could use a regional ZoneId", "label": {"api": {"ZoneId": [[54, 59]]}}}, {"text": "The Locale could still be useful for formatting", "label": {"api": {"Locale": [[4, 9]]}}}, {"text": "Look up the Java class Pattern for other variations", "label": {"api": {"Pattern": [[23, 29]]}}}, {"text": "Otherwise, per the FileHandler documentation the forward slash is replaced at runtime", "label": {"api": {"FileHandler documentation": [[19, 43]]}}}, {"text": "You can get it via getLocalPort()", "label": {"api": {"getLocalPort()": [[19, 32]]}}}, {"text": "Use AtomicInteger instead of an integer to keep track of coints", "label": {"api": {"AtomicInteger": [[4, 16]]}}}, {"text": "It provides atomic methods like, decrementAndGet and getAndSet(int newValue)", "label": {"api": {"decrementAndGet": [[33, 47]], "getAndSet(int newValue)": [[53, 75]]}}}, {"text": "If you expect all threads to finish before you print, you will need to use Thread.join()", "label": {"api": {"Thread.join()": [[75, 87]]}}}, {"text": "Using PropertyValueFactory is just an handy short cut to fill cells with members", "label": {"api": {"PropertyValueFactory": [[6, 25]]}}}, {"text": "for more information about all the available functional interfaces and what you can do with them check out the java.util.function package", "label": {"api": {"java.util.function": [[111, 128]]}}}, {"text": "A load plan or scenario execution can be triggered through the class RemoteRuntimeAgentInvoker from oracle.odi.runtime.agent.invocation", "label": {"api": {"RemoteRuntimeAgentInvoker": [[69, 93]]}}}, {"text": "To remove the middle elements in a single operation (method call) you could subclass java.util.LinkedList and then expose a call to List.removeRange(int, int)", "label": {"api": {"List.removeRange(int, int)": [[132, 157]]}}}, {"text": "The Pack200.Unpacker.unpack method writes to a JarOutputStream;  if you do that in a background thread, you can connect a new JarOutputStream to a JarInputStream using a pipe, and read from that", "label": {"api": {"Pack200.Unpacker.unpack": [[4, 26]]}}}, {"text": "This is because closing the JarOutputStream forces a call to its finish() method, but the JarInputStream on the other side of the pipe will never read that data", "label": {"api": {"finish()": [[65, 72]]}}}, {"text": "This means the JarInputStream will almost certainly be closed before finish() is called, causing finish() to generate an IOException due to a broken pipe", "label": {"api": {"finish()": [[69, 76], [97, 104]]}}}, {"text": "To resolve the second, we can override finish() in the JarOutputStream to do nothing", "label": {"api": {"finish()": [[39, 46]]}}}, {"text": "In your case, the responseX() methods take a Vector<String> as parameter, and returns an Integer, so the functional interface would be Function<Vector<String>, Integer>", "label": {"api": {"Function<Vector<String>, Integer>": [[135, 167]]}}}, {"text": "As illustrated in the last example seen here, the Animation Basics example TimelineEvents does this by adding a Circle and some Text to a StackPane, which centers its children by default", "label": {"api": {"StackPane": [[138, 146]]}}}, {"text": "Month in Calendar is zero based in cal.set(int,int,int)", "label": {"api": {"cal.set(int,int,int)": [[35, 54]]}}}, {"text": "Just use Path.resolve instead", "label": {"api": {"Path.resolve": [[9, 20]]}}}, {"text": "Besides the possibility to use utility methods defined in java.lang.reflect.Modifier, like isStatic(access), you can always test the presence of a bit using the bitwise and operator (&)", "label": {"api": {"isStatic(access)": [[91, 106]]}}}, {"text": "You can use FileChannel.lock and FileLock to get what you wanted", "label": {"api": {"FileChannel.lock": [[12, 27]], "FileLock": [[33, 40]]}}}, {"text": "If you are trying to match or search or index text, you should use a Collator configured properly for the desired locale", "label": {"api": {"Collator": [[69, 76]]}}}, {"text": "JPanel.add(Component) is defined in java.awt.Container.add(Component), where it is delegated to java.awt.Container.addImpl(Component, Object, int)", "label": {"api": {"java.awt.Container.addImpl(Component, Object, int)": [[96, 145]]}}}, {"text": "I have found javax.smartCard API smart Card API and WinSCard.dll API", "label": {"api": {"smart Card API": [[33, 46]]}}}, {"text": "Use HashMap<String, String> where the key is the items and the value is its category", "label": {"api": {"HashMap<String, String>": [[4, 26]]}}}, {"text": "You just need to use Supplier<Map> that will create LinkedHashMap for you using this version of overloaded methods groupingBy", "label": {"api": {"this version": [[80, 91]]}}}, {"text": "Which uses Map.merge method and is both shorter and more performant", "label": {"api": {"Map.merge": [[11, 19]]}}}, {"text": "The streamy sort of answer is probably to use something like findFirst", "label": {"api": {"findFirst": [[61, 69]]}}}, {"text": "Also, prefer the Path APIs instead of File - Java 7 introduced Path and it's a much safer, more robust File I/O utility", "label": {"api": {"Path APIs": [[17, 25]]}}}, {"text": "ExampleImpl implements Example and is loaded via ServiceLoader (thanks to SPI Fly)", "label": {"api": {"ServiceLoader": [[49, 61]]}}}, {"text": "If you are using Java 9, you can use the new immutable map static factory methods, as follows", "label": {"api": {"immutable map static factory methods": [[45, 80]]}}}, {"text": "If the \"@:\" is a consistent separator, and you're using Java 8+, you might find that String.join is your friend", "label": {"api": {"String.join": [[85, 95]]}}}, {"text": "Guessing a little bit from your variable names, but as a little background and just in case it's helpful, if you want/need to use a Stream you can also use Collectors.joining, which could look something like", "label": {"api": {"Collectors.joining": [[156, 173]]}}}, {"text": "String should be between two quotes 'name' instead of your way you have to use PreparedStatement instead to avoid syntax error or SQL Injection", "label": {"api": {"PreparedStatement": [[79, 95]]}}}, {"text": "Also note that instead of using Runnable, Timer and Thread it could be worth taking a look into the new Java 8 stuff, especially the interface Future and classes implementing it", "label": {"api": {"Future": [[143, 148]]}}}, {"text": "Perhaps IntToDoubleFunction is what you need", "label": {"api": {"IntToDoubleFunction": [[8, 26]]}}}, {"text": "You can walk the file tree recursively with a stream, for example like this", "label": {"api": {"walk the file tree recursively with a stream": [[8, 51]]}}}, {"text": "CompletableFuture.exceptionally can be used to continue when getting an exception in a CompletableFuture", "label": {"api": {"CompletableFuture.exceptionally": [[0, 30]]}}}, {"text": "What you are looking for is GatheringByteChannel.write(ByteBuffer[], ...), which is implemented by SocketChannel, DatagramSocketChannel, and FileChannel", "label": {"api": {"GatheringByteChannel.write(ByteBuffer[], ...)": [[28, 72]]}}}, {"text": "Per @OHGODSPIDERS, if you use the other 3 versions that I suggested, you will run into ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[87, 117]]}}}, {"text": "You may want to have a look at the Java service loader mechanism which seems close to what you want to do, e.g.", "label": {"api": {"Java service loader": [[35, 53]]}}}, {"text": "The LocalDate support comes from the jackson-datatype-jsr310 module", "label": {"api": {"LocalDate": [[4, 12]], "Date": [[9, 12]]}}}, {"text": "If you prefer to use Date instead of LocalDate, then you don't need any to add any dependency and you don't need to register any module either", "label": {"api": {"LocalDate": [[37, 45]], "Date": [[21, 24], [42, 45]]}}}, {"text": "Just use Date instead of LocalDate in the above examples", "label": {"api": {"LocalDate": [[25, 33]], "Date": [[9, 12], [30, 33]]}}}, {"text": "However I advise you to use LocalDate instead", "label": {"api": {"LocalDate": [[28, 36]], "Date": [[33, 36]]}}}, {"text": "Just take a Callable as argument", "label": {"api": {"Callable": [[12, 19]]}}}, {"text": "The Java Stream.forEach function has the serious limitation that it's impossible for its consumer to throw checked exceptions", "label": {"api": {"Stream.forEach": [[9, 22]]}}}, {"text": "However, findAny is a short-circuiting terminal operation", "label": {"api": {"findAny": [[9, 15]]}}}, {"text": "To iterate over a stream element-by-element, just call the iterator() method", "label": {"api": {"iterator()": [[59, 68]]}}}, {"text": "Observe that the signum() method may be more convenient for comparing big integers to zero", "label": {"api": {"signum()": [[17, 24]]}}}, {"text": "This uses the Map.merge method to concatenate the identifier values", "label": {"api": {"Map.merge": [[14, 22]]}}}, {"text": "Fortunately Java has class called ArrayList that has the functionality you are looking for", "label": {"api": {"ArrayList": [[34, 42]]}}}, {"text": "Your radio buttons should be placed in a ToggleGroup", "label": {"api": {"ToggleGroup": [[41, 51]]}}}, {"text": "Well...if you want to have several inputs in one dialog then you can use the JOptionPane.showConfirmDialog() method and supply it with a custom JPanel (some examples here)", "label": {"api": {"JOptionPane.showConfirmDialog()": [[77, 107]]}}}, {"text": "The problem with this approach is that you have to be sure about the type of the variable while casting otherwise it will throw ClassCastException", "label": {"api": {"ClassCastException": [[128, 145]]}}}, {"text": "Therefore, you need to use the BigInteger class, or at the very least long, to store the result", "label": {"api": {"BigInteger": [[31, 40]]}}}, {"text": "You can fix this by either ensuring that the label is wide enough, or by decreasing the number of decimal places displayed using a DecimalFormat", "label": {"api": {"DecimalFormat": [[131, 143]]}}}, {"text": "You can adjust the number of decimal places shown by increasing/decreasing the number of # characters in the DecimalFormat constructor argument", "label": {"api": {"DecimalFormat": [[109, 121]]}}}, {"text": "You need to move the static block into a @PostConstruct method so all of your injected values are present", "label": {"api": {"@PostConstruct": [[41, 54]]}}}, {"text": "Then lookup your property values from within that @PostConstruct method", "label": {"api": {"@PostConstruct": [[50, 63]]}}}, {"text": "Your question is rather about working with Java Map interface", "label": {"api": {"Map interface": [[48, 60]]}}}, {"text": "What you are looking for is the mapToInt method (assuming processToMarmalade returns an int)", "label": {"api": {"the mapToInt method": [[28, 46]]}}}, {"text": "Well Scanner has several methods to treat the user input", "label": {"api": {"Scanner": [[5, 11]]}}}, {"text": "One of the methods that you can use to check if the user input is an int is hasNextInt()", "label": {"api": {"hasNextInt()": [[76, 87]]}}}, {"text": "Another approach is to use hasNext(Pattern) method with a pattern that matches only alphabetic strings", "label": {"api": {"hasNext(Pattern)": [[27, 42]]}}}, {"text": "The java.time API's ZonedDateTime class automatically takes care of DST", "label": {"api": {"ZonedDateTime": [[20, 32]]}}}, {"text": "I am not sure if it will prevent Sonar alert but I'd rather use Class.forName(String) since it will proceed all the class initialisations that could be required", "label": {"api": {"Class.forName(String)": [[64, 84]]}}}, {"text": "Wrap your BufferedWriter in a PrintWriter and use the println() methods", "label": {"api": {"PrintWriter": [[30, 40]]}}}, {"text": "Apart from that you could use Java 8's Optional as a return value here", "label": {"api": {"Optional": [[39, 46]]}}}, {"text": "You can use Collectors.toMap as", "label": {"api": {"Collectors.toMap": [[12, 27]]}}}, {"text": "It prevents you from the nondeterministic behavior of the forEach which though with your current implementation(requirements) seems fine", "label": {"api": {"forEach": [[58, 64]]}}}, {"text": "You can use IntStream.map and re-use your Random instance to generate a random number from 0 to 9 inclusive, returning zero if it's in the first 60%, else the generated number", "label": {"api": {"IntStream.map": [[12, 24]]}}}, {"text": "Yes, you can get the process input using Process.getOutputStream() and its output using Process.getInputStream()", "label": {"api": {"Process.getOutputStream()": [[41, 65]], "Process.getInputStream()": [[88, 111]]}}}, {"text": "Please consider using Random instead, it has a method nextInt(arg) that returns random values in 0..arg-1", "label": {"api": {"Random": [[22, 27]]}}}, {"text": "If you can live with a Collection<String> instead of a List<String> in your result, then you could use Java 9's Collectors.flatMapping", "label": {"api": {"Collectors.flatMapping": [[112, 133]]}}}, {"text": "From the documentation", "label": {"api": {"From the documentation": [[0, 21]]}}}, {"text": "If you want a speedup, and you know roughly how big the ArrayList is going to be (like in your example), use the ArrayList constructor that lets you specify an initial array size", "label": {"api": {"ArrayList constructor": [[113, 133]]}}}, {"text": "doubleToLongBits, for example", "label": {"api": {"doubleToLongBits": [[0, 15]]}}}, {"text": "From the Javadoc of BufferedReader (emphasis added)", "label": {"api": {"BufferedReader": [[20, 33]]}}}, {"text": "It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders", "label": {"api": {"BufferedReader": [[36, 49]]}}}, {"text": "Try wrapping the FileReader in a BufferedReader", "label": {"api": {"BufferedReader": [[33, 46]]}}}, {"text": "If you don't want to get into regex, which could be difficult to read and write, a simple indexOf would suffice if that's all you really need", "label": {"api": {"indexOf": [[90, 96]]}}}, {"text": "The defintion of Double.MIN_VALUE gives the answer", "label": {"api": {"Double.MIN_VALUE": [[17, 32]]}}}, {"text": "So the smallest normal value is 1 * 2-1022, or Double.MIN_NORMAL", "label": {"api": {"Double.MIN_NORMAL": [[47, 63]]}}}, {"text": "You can accomplish the task at hand with the use of Stream.Concat", "label": {"api": {"Stream.Concat": [[52, 64]]}}}, {"text": "Then you can use Matcher and Pattern and maybe other tools to make it work in Java", "label": {"api": {"Matcher": [[17, 23]], "Pattern": [[29, 35]]}}}, {"text": "To avoid problem as this gender and SQL Injection it's better to use PreparedStatement instead", "label": {"api": {"PreparedStatement": [[69, 85]]}}}, {"text": "You can use the method remove(Object key, Object value), which will only remove the entry if the value is up-to-date, and the operation is atomic", "label": {"api": {"remove(Object key, Object value)": [[23, 54]]}}}, {"text": "Indeed, the documentation for filter states* that the predicate must be stateless", "label": {"api": {"filter": [[30, 35]], "stateless": [[72, 80]]}}}, {"text": "I will demonstrate one using Thread and CountDownLatch", "label": {"api": {"Thread": [[29, 34]], "CountDownLatch": [[40, 53]]}}}, {"text": "A CountDownLatch is used to block a thread's (or more than one) execution until the latch is released/broken, upon which the thread will continue", "label": {"api": {"CountDownLatch": [[2, 15]]}}}, {"text": "First a stream is used to find the sum, then the average is calculated and finally, Stream.min is used to find the minimum element of the stream, which is the one that is closest to the average", "label": {"api": {"Stream.min": [[84, 93]]}}}, {"text": "Stream.min receives a Comparator as an argument, which has the usual comparator semantics", "label": {"api": {"Stream.min": [[0, 9]], "Comparator": [[22, 31]]}}}, {"text": "Here I'm using Integer.compare to perform the comparison", "label": {"api": {"Integer.compare": [[15, 29]]}}}, {"text": "Note that Stream.min doesn't return the minimum number, but an Optional<Integer> instead", "label": {"api": {"Stream.min": [[10, 19]]}}}, {"text": "This is when the Optional.ifPresent method comes in handy", "label": {"api": {"Optional.ifPresent": [[17, 34]]}}}, {"text": "is above declared method instance of BiFunction", "label": {"api": {"BiFunction": [[37, 46]]}}}, {"text": "Simple, invoke toArray", "label": {"api": {"toArray": [[15, 21]]}}}, {"text": "This is all very easy if you use the BigInteger class", "label": {"api": {"BigInteger": [[37, 46]]}}}, {"text": "The class Integer is a wrapper of the int primitive type (https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html": [[58, 121]]}}}, {"text": "You can add a MouseMotionListener to the JFrame", "label": {"api": {"MouseMotionListener": [[14, 32]]}}}, {"text": "An easier way is to use Ellipse2D", "label": {"api": {"Ellipse2D": [[24, 32]]}}}, {"text": "Initialize the nested static class Ellipse2D.Double or Ellipse2D.Float with the bounds of your circle and call the method contains(x, y) to verify if the given point is inside the circle", "label": {"api": {"Ellipse2D": [[35, 43], [55, 63]]}}}, {"text": "You can use groupingBy to join the different permissions for the same roleName together", "label": {"api": {"groupingBy": [[12, 21]]}}}, {"text": "String or varchar type should be between two quotes 'some string', but this still not secure so to avoid Syntax errors (Like you have now) or SQL Injection it's better to use PreparedStatement", "label": {"api": {"PreparedStatement": [[175, 191]]}}}, {"text": "TreeSet), then the JSON array is sorted, according to the sort order of the Set", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used", "label": {"api": {"Comparator": [[63, 72]]}}}, {"text": "HashSet), then the JSON array is in the arbitrary order returned by the Set", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "Because you're implementing Set<Square>, you'd naturally expect the removeAll method to be removeAll(Collection<Square>), but unfortunately in the Set interface, the removeAll method is removeAll(Collection<?>), with a wildcard instead of the generic type parameter", "label": {"api": {"removeAll method is removeAll(Collection<?>)": [[166, 209]]}}}, {"text": "You want an EnumSet to be stored", "label": {"api": {"EnumSet": [[12, 18]]}}}, {"text": "Or having an EnumSet of several enum constants", "label": {"api": {"EnumSet": [[13, 19]]}}}, {"text": "EnumSet is a Set implementation havily optimized for enums, and providing building methods", "label": {"api": {"EnumSet": [[0, 6]]}}}, {"text": "As assylias said you should maybe take a look at LocalTime", "label": {"api": {"LocalTime": [[49, 57]]}}}, {"text": "And using a homemade DateTimeFormatter in order to format your desired input String", "label": {"api": {"DateTimeFormatter": [[21, 37]]}}}, {"text": "use an InputStreamReader along with the proper Charset or a custom CharsetDecoder", "label": {"api": {"InputStreamReader": [[7, 23]], "Charset": [[47, 53], [67, 73]], "CharsetDecoder": [[67, 80]]}}}, {"text": "Why don't you use a Map and a Set", "label": {"api": {"Map": [[20, 22]], "Set": [[30, 32]]}}}, {"text": "But you can apply unsigned arithmetic operations on both, longs and ints since JDK 8 (Go to Long (or Integer) javadoc page and search for \"unsigned\")", "label": {"api": {"Long": [[92, 95]]}}}, {"text": "wrap your nullable objects in Optional<T>, and use its methods to hide null checks", "label": {"api": {"Optional<T>": [[30, 40]]}}}, {"text": "Oracle's article on using Optional<T>", "label": {"api": {"Optional<T>": [[26, 36]]}}}, {"text": "The functionality in ProcessBuilder and  Runtime.getRuntime().exec() provides this", "label": {"api": {"ProcessBuilder": [[21, 34]], "Runtime.getRuntime().exec()": [[41, 67]]}}}, {"text": "I would implement this as a collection of Futures", "label": {"api": {"Future": [[42, 47]]}}}, {"text": "Each task would be a Future<String[]> and the \"main\" thread would compile all the results into the final array", "label": {"api": {"Future": [[21, 26]]}}}, {"text": "You could use Channels, but it’s shorter to use Files.copy", "label": {"api": {"Files.copy": [[48, 57]]}}}, {"text": "Ordinarily, calling setInstanceFollowRedirects would be sufficient", "label": {"api": {"setInstanceFollowRedirects": [[20, 45]]}}}, {"text": "Java considers that insecure (as it should), so it will never automatically follow that redirect, even if setInstanceFollowRedirects has been called", "label": {"api": {"setInstanceFollowRedirects": [[106, 131]]}}}, {"text": "Okay, good, we know of the index of the element in the JList, we can use ListModel#elementAt to get the physical element, which you could use to query the database, look up the properties, or, if you've done it correctly and embedded an actually object into the model, get the attributes", "label": {"api": {"ListModel#elementAt": [[73, 91]]}}}, {"text": "To use GetDirectBufferAddress() you must guarantee that pkt is direct (you can check this with isDirect())", "label": {"api": {"isDirect()": [[95, 104]]}}}, {"text": "The difference between direct and indirect ByteBuffer is clearly explained in the Java oficial doc", "label": {"api": {"oficial doc": [[87, 97]]}}}, {"text": "The class Number leads an almost hidden existence but is quite useful", "label": {"api": {"Number": [[10, 15]]}}}, {"text": "You could use a Semaphore to deal with this shared resource among many threads", "label": {"api": {"Semaphore": [[16, 24]]}}}, {"text": "As for which to use, is it actually a question of what you need, if you need to pass around a list i'd suggest you to use an  Immutable List", "label": {"api": {"Immutable List": [[126, 139]]}}}, {"text": "I have read the description of prepareStatement(String sql) and also lot of posts related to performance and caching of PreparedStatement and I am clear that database will parse and compile the query of the prepared statement so that for subsequent same queries, another round of parse and compile will not happen but I am not clear on whether", "label": {"api": {"prepareStatement(String sql)": [[31, 58]]}}}, {"text": "each invocation of prepareStatement(String sql) will result in a database call or not", "label": {"api": {"prepareStatement(String sql)": [[19, 46]]}}}, {"text": "each invocation of prepareStatement(String sql) will result in a database call then I don't understand what this line from docs means - \"A SQL statement with or without IN parameters can be pre-compiled and stored in a PreparedStatement object.\"", "label": {"api": {"prepareStatement(String sql)": [[19, 46]]}}}, {"text": "If you are using Java 8, you could collect all L values from all List<L>s in a single List<L> by Stream#flatMap", "label": {"api": {"Stream#flatMap": [[97, 110]]}}}, {"text": "Otherwise, a for-each approach with Collection#addAll can be applied", "label": {"api": {"Collection#addAll": [[36, 52]]}}}, {"text": "The Comparable.compareTo() contract states that", "label": {"api": {"Comparable.compareTo()": [[4, 25]]}}}, {"text": "Without much use for Java 8's functional idioms, I would simply go with Set#retainAll for each comparison (3 in total)", "label": {"api": {"Set#retainAll": [[72, 84]]}}}, {"text": "The same loop done using BigDecimal looks like this", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "The way to use <, >, == etc with BigDecimal, is to use the compareTo() method", "label": {"api": {"BigDecimal": [[33, 42]], "compareTo()": [[59, 69]]}}}, {"text": "Also notice that BigDecimal has predefined constants for 0, 1, and 10 (BigDecimal.ZERO, BigDecimal.ONE, and BigDecimal.TEN), and that creating BigDecimal integer values should use BigDecimal.valueOf(long val), rather than new BigDecimal(String val)", "label": {"api": {"BigDecimal": [[17, 26], [71, 80], [88, 97], [108, 117], [143, 152], [180, 189], [226, 235]], "BigDecimal.ZERO": [[71, 85]], "BigDecimal.ONE": [[88, 101]], "BigDecimal.TEN": [[108, 121]], "BigDecimal.valueOf(long val)": [[180, 207]], "new BigDecimal(String val)": [[222, 247]]}}}, {"text": "You can also use an already implemented method of ThreadLocalRandom#nextInt(int,int) which can be used like below", "label": {"api": {"ThreadLocalRandom#nextInt(int,int)": [[50, 83]]}}}, {"text": "You can use a LinkedHashMap and insert the elements in the order you want them to be replaced in", "label": {"api": {"LinkedHashMap": [[14, 26]]}}}, {"text": "This works, because a LinkedHashMap lets you iterate over its values in the order you inserted them in, while a HashMap will return them in an order which depends on the keys hashCode", "label": {"api": {"LinkedHashMap": [[22, 34]]}}}, {"text": "Your question regarding \"copying constructors\" is perhaps best addressed by reading up on the Clonable interface, but be aware of the differences between shallow and deep copies, and the implications for your classes and data structures", "label": {"api": {"Clonable interface": [[94, 111]]}}}, {"text": "You aren't using arrays in your code, you are using ArrayLists", "label": {"api": {"ArrayList": [[52, 60]]}}}, {"text": "The equivalent method  to length for ArrayList is .size()", "label": {"api": {"ArrayList": [[37, 45]]}}}, {"text": "You can also name them with (?<name>...) and then reference them with ${name}", "label": {"api": {"name them": [[13, 21]]}}}, {"text": "An alternative might be to use Objects.requireNonNull(...), which will throw a NullPointerException if argument is null", "label": {"api": {"Objects.requireNonNull(...)": [[31, 57]]}}}, {"text": "You should URL Encode your request", "label": {"api": {"URL Encode": [[11, 20]]}}}, {"text": "If you want to specify a file name, you need to use System.load(String), and not the System.loadLibrary(String) method", "label": {"api": {"System.load(String)": [[52, 70]], "System.loadLibrary(String)": [[85, 110]]}}}, {"text": "This is the perfect use case to consider a properties file", "label": {"api": {"properties": [[43, 52]]}}}, {"text": "Note that the documentation explicitly discourages from using functions with stateful behavior, as the results may be nondeterministic or incorrect when using a parallel stream", "label": {"api": {"explicitly discourages from using functions with stateful behavior": [[28, 93]]}}}, {"text": "when reading numbers from a random number generator, lines from a BufferedReader, or tokens from a Scanner(Java 9)", "label": {"api": {"reading numbers from a random number generator": [[5, 50]], "lines from a BufferedReader": [[53, 79]], "tokens from a Scanner(Java 9)": [[85, 113]]}}}, {"text": "According to its constructor, LambdaExpression is basically a combination of a List of strings and a ValueExpression", "label": {"api": {"its constructor": [[13, 27]]}}}, {"text": "There are two split methods - the second one  takes a limit argument that allows you to specify the maximum number of groups you want", "label": {"api": {"the second one ": [[30, 44]]}}}, {"text": "Load an instance of java.util.Properties with your styles, as shown here and here, so that each style is available as a String suitable for addAttribute()", "label": {"api": {"java.util.Properties": [[20, 39]]}}}, {"text": "Thread.currentThread().getStackTrace() method and receive an array of StackTraceElement, finally use them to receive a method name with a getMethodName() method", "label": {"api": {"StackTraceElement": [[70, 86]]}}}, {"text": "I have not tried it but using ZipInputStream you can read any InputStream that contains a ZIP file as data", "label": {"api": {"ZipInputStream": [[30, 43]]}}}, {"text": "Iterate through the entries and when you found the correct entry use theZipInputStreamto create another nestedZipInputStream`", "label": {"api": {"ZipInputStream": [[72, 85], [110, 123]]}}}, {"text": "Theoretically there is no limit how many ZipInputStreams you cascade into another", "label": {"api": {"ZipInputStream": [[41, 54]]}}}, {"text": "I was reading over the Javadoc for the TreeMap type and was surprised to see that it explicitly requires that TreeMap use a red/black tree as its internal implementation", "label": {"api": {"Javadoc for the TreeMap type": [[23, 50]]}}}, {"text": "If you look at Collections.sort, for example, there’s no mention of what sorting algorithm should be used", "label": {"api": {"Collections.sort": [[15, 30]]}}}, {"text": "The HashMap documentation doesn’t specify whether the internal representation uses chained hashing, linear probing, Robin Hood hashing, etc", "label": {"api": {"HashMap documentation": [[4, 24]]}}}, {"text": "With Java 9, you can throw in a filtering() collector to exclude employees without a join time", "label": {"api": {"filtering()": [[32, 42]]}}}, {"text": "The Set interface makes no promises on whether implementations permit null elements", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "Collectors.toSet() promises to return an implementation of Set but explicitly makes “no guarantees on the type, mutability, serializability, or thread-safety of the Set returned”", "label": {"api": {"Set": [[13, 15], [59, 61], [165, 167]], "Collectors.toSet()": [[0, 17]], "Collector": [[0, 8]]}}}, {"text": "The current implementation of Collectors.toSet() in OpenJDK always uses HashSet, which permits null elements, but this could change in the future and other implementations may do differently", "label": {"api": {"Set": [[43, 45], [76, 78]], "Collectors.toSet()": [[30, 47]], "Collector": [[30, 38]]}}}, {"text": "If a Set implementation prohibits null elements, it throws NullPointerException at various times, in particular during an attempt to add(null)", "label": {"api": {"Set": [[5, 7]], "add(null)": [[133, 141]]}}}, {"text": "It would seem that if Collectors.toSet() decided to use a null-intolerant Set implementation, calling stream.collect(Collectors.toSet()) on a Stream stream would throw", "label": {"api": {"Set": [[35, 37], [74, 76], [130, 132]], "Collectors.toSet()": [[22, 39], [117, 134]], "stream.collect(Collectors.toSet())": [[102, 135]], "Collector": [[22, 30], [117, 125]]}}}, {"text": "The specification of collect does not list any exceptions, nor does the specification of any of the Collector methods", "label": {"api": {"Collector": [[100, 108]]}}}, {"text": "If not, then I assume we should always ensure a stream contains no nulls before using Collectors.toSet() or be ready to handle NullPointerException", "label": {"api": {"Set": [[99, 101]], "Collectors.toSet()": [[86, 103]], "Collector": [[86, 94]]}}}, {"text": "(Is this exception alone enough though?) Alternatively, when this is unacceptable or hard, we can request a specific set implementation using code like Collectors.toCollection(HashSet::new)", "label": {"api": {"Set": [[180, 182]], "Collector": [[152, 160]]}}}, {"text": "However, the linked question does not address Collectors.toSet() at all", "label": {"api": {"Set": [[59, 61]], "Collectors.toSet()": [[46, 63]], "Collector": [[46, 54]]}}}, {"text": "How about single thread executor", "label": {"api": {"single thread executor": [[10, 31]]}}}, {"text": "TaskScheduler return a ScheduledFuture that you should save somewhere and it can be cancelled with cancel(...) method", "label": {"api": {"TaskScheduler": [[0, 12]], "ScheduledFuture": [[23, 37]], "cancel(...)": [[99, 109]]}}}, {"text": "you can use removeIf then use AnimalPrimaryDataPojoFilterList as the source in which case you'll need to invert your logic within the if block i.e", "label": {"api": {"removeIf": [[12, 19]]}}}, {"text": "Is it essentially an attempt to reanimate something similar to the deprecated Thread.destroy()", "label": {"api": {"Thread.destroy()": [[78, 93]]}}}, {"text": "You are violating the requirements of consistency with equals", "label": {"api": {"consistency with equals": [[38, 60]]}}}, {"text": "You are saying that null is equal to an instance with zero duration, which it is not, because zeroDuration.equals(null) is false (or, at least, it should be), and null.equals(zeroDuration) results in an exception", "label": {"api": {"it should be": [[144, 155]]}}}, {"text": "This is why I'm using the List.addAll method", "label": {"api": {"List.addAll": [[26, 36]]}}}, {"text": "I suggest you check the docs of List.addAll, Iterable.forEach and Map.forEach methods for further details", "label": {"api": {"List.addAll": [[32, 42]], "Iterable.forEach": [[45, 60]], "Map.forEach": [[66, 76]]}}}, {"text": "Take a look at the other predefined formatters and you will find that ISO_OFFSET_DATE_TIME is the right choice here", "label": {"api": {"the other predefined formatters": [[15, 45]]}}}, {"text": "Use the CSS property -fx-spacing (uses the <size> type)", "label": {"api": {"<size>": [[43, 48]]}}}, {"text": "I couldn't find any documentation on this property, however; even in the JavaFX CSS Reference Guide", "label": {"api": {"JavaFX CSS Reference Guide": [[73, 98]]}}}, {"text": "The best way is to remove the enum property from the current class, annotate that class with @Embeddable rather than @Entity, and in each project, create an entity class which embeds it and also declares its own project-specific enum property", "label": {"api": {"@Embeddable": [[93, 103]]}}}, {"text": "If you want O(1), you should use a HashSet instead of an ArrayList", "label": {"api": {"HashSet": [[35, 41]]}}}, {"text": "Let's say vertex 1 is connected to 2, 4 and 5, then at position 1 in your array, you would have a HashSet (2, 4, 5)", "label": {"api": {"HashSet": [[98, 104]]}}}, {"text": "Instead of updating the ObservableList<Integer> directly in your implementation of the call() method of your Task<Integer>, use updateValue() to publish the new value, as shown here for a Task<Canvas>", "label": {"api": {"Task<Integer>": [[109, 121]]}}}, {"text": "Assuming you know that the String age is a valid number (if you don't know it is a valid number you will have to add some code to check for this)", "label": {"api": {"String": [[27, 32]]}}}, {"text": "You can simply convert age using Integer.parseInt then add the int 10 and the convert the result back to a String using String.valueOf", "label": {"api": {"String": [[107, 112], [120, 125]], "Integer.parseInt": [[33, 48]], "int": [[63, 65]], "String.valueOf": [[120, 133]]}}}, {"text": "Instead, consider wrapping the buzz field using the AtomicReference class", "label": {"api": {"AtomicReference": [[52, 66]]}}}, {"text": "Once you get a match, you need to get element [2] of the split, and parse it into an int using Integer.parseInt(...) method", "label": {"api": {"Integer.parseInt(...)": [[95, 115]]}}}, {"text": "You can make use of Arrays.stream on int[] boxed and collected as List as", "label": {"api": {"Arrays.stream": [[20, 32]], "boxed": [[43, 47]]}}}, {"text": "You can use set method once you know the index of element you want to replace", "label": {"api": {"set": [[12, 14]]}}}, {"text": "Use the JOptionPane class to create a confirm dialog by using one of the showConfirmDialog() method to show a confirm dialog", "label": {"api": {"JOptionPane": [[8, 18]]}}}, {"text": "From what I've been able to determine so far, there is no single DecimalFormat pattern that can emulate Double.toString (which seems weird to me), however it can be done with two patterns and a magnitude range, as documented in the Double.toString(double) javadoc", "label": {"api": {"Double.toString(double) javadoc": [[232, 262]]}}}, {"text": "Simply turn your String into a List of Character, to then shuffle that list", "label": {"api": {"shuffle": [[58, 64]]}}}, {"text": "I'd use the DoubleUnaryOperator functional interface to perform the task at hand and also has the benefit of not boxing primitive types to their corresponding wrapper type or vice versa when performing the computation", "label": {"api": {"DoubleUnaryOperator": [[12, 30]]}}}, {"text": "This is because timer uses it's own background thread, but if you want to do any updates to the GUI, you need to be using the JavaFX GUI thread (a special thread JavaFX creates and handles)", "label": {"api": {"timer": [[16, 20]]}}}, {"text": "You can pass changes to JavaFX components to the special JavaFX thread by wrapping the changes in a Platform.runLater block", "label": {"api": {"Platform.runLater": [[100, 116]]}}}, {"text": "You can also use a JavaFX Timeline and not have to worry about the thread issues", "label": {"api": {"Timeline": [[26, 33]]}}}, {"text": "Note that the output will not be \"in different order\" because invokeAll returns \"A list of Futures representing the tasks, in the same sequential order as produced by the iterator for the given task list\"", "label": {"api": {"invokeAll returns \"A list of Futures representing the tasks, in the same sequential order as produced by the iterator for the given task list\"": [[62, 203]]}}}, {"text": "What you are looking for is not Runnable, but a Callable", "label": {"api": {"Callable": [[48, 55]]}}}, {"text": "Unlike Runnable, a Callable returns a value", "label": {"api": {"Callable": [[19, 26]]}}}, {"text": "This is usually used together with ExecutorService (a thread pool)", "label": {"api": {"ExecutorService": [[35, 49]]}}}, {"text": "The idea is, instead of calling Thread.start(), you submit the instaces of Callable to your ExecutorService instance with predefined number of threads", "label": {"api": {"Callable": [[75, 82]], "ExecutorService": [[92, 106]]}}}, {"text": "Each submission returns a Future object", "label": {"api": {"Future": [[26, 31]]}}}, {"text": "Future object allows you to wait for the return value of the Callable instances you have submitted to the ExecutorService", "label": {"api": {"Callable": [[61, 68]], "ExecutorService": [[106, 120]], "Future": [[0, 5]]}}}, {"text": "I would like him to click on the OK button of JavaFX Alert Dialogs, but I have not found a fx:id", "label": {"api": {"JavaFX Alert Dialogs": [[46, 65]]}}}, {"text": "For character arrays use @Size instead", "label": {"api": {"@Size": [[25, 29]]}}}, {"text": "From the Documentation of SocketAddress", "label": {"api": {"Documentation of SocketAddress": [[9, 38]]}}}, {"text": "From the Documentation of InetAddress", "label": {"api": {"Documentation of InetAddress": [[9, 36]]}}}, {"text": "What you are most probably looking for is an InetSocketAddress (a socket, bound to a specific IP/Hostname and port)", "label": {"api": {"InetSocketAddress": [[45, 61]]}}}, {"text": "You can use java.util.scanner to parse various data types from a stream relatively painlessly", "label": {"api": {"java.util.scanner": [[12, 28]]}}}, {"text": "You can check ioException to see if one has been suppressed", "label": {"api": {"ioException": [[14, 24]]}}}, {"text": "to prompt the user for where they want to save their text file and what to call it, you can use a FileChooser, which you can use like this", "label": {"api": {"FileChooser": [[98, 108]]}}}, {"text": "java.util.concurrent.atomic.AtomicInteger handles the synchronization to make most of the operations you would want to do on an integer into atomic operations for you", "label": {"api": {"java.util.concurrent.atomic.AtomicInteger": [[0, 40]]}}}, {"text": "In this case you could call getAndAdd(1), or getAndIncrement()", "label": {"api": {"getAndAdd(1)": [[28, 39]], "getAndIncrement()": [[45, 61]]}}}, {"text": "According to the docs, setScale(int, int), has not been recommended since Java 1.5, when enums were first introduced", "label": {"api": {"Java 1.5": [[74, 81]]}}}, {"text": "It was finally deprecated in Java 9", "label": {"api": {"Java 9": [[29, 34]]}}}, {"text": "You should call setScale(2, RoundingMode.HALF_EVEN) instead", "label": {"api": {"setScale(2, RoundingMode.HALF_EVEN)": [[16, 50]]}}}, {"text": "I am having to do stupid s**t like this to get urlEncoding to work like other libraries (iOS, Javascript..) because java.net.URLEncoder is buggy or not written to standard encoding", "label": {"api": {"java.net.URLEncoder": [[116, 134]]}}}, {"text": "I think you misunderstood the role of the URLEncoder", "label": {"api": {"URLEncoder": [[42, 51]]}}}, {"text": "The UrlEncoder implements the HTML Specifications for how to encode URLs in HTML forms", "label": {"api": {"UrlEncoder": [[4, 13]]}}}, {"text": "For a professional application, many people use java.util.logging, or Apache Log4J", "label": {"api": {"java.util.logging": [[48, 64]]}}}, {"text": "You can use JarFile#entries to get an enumeration of the ZIP file entries, than use a URLClassLoader to get the classes", "label": {"api": {"JarFile#entries": [[12, 26]], "URLClassLoader": [[86, 99]]}}}, {"text": "If you want each row to be a different size, you'll be needing to create an array of LinkedLists or similar data structure", "label": {"api": {"LinkedLists": [[85, 95]]}}}, {"text": "What if you were to sort the list using a Comparator and then iterate through the list once and see if any times overlap", "label": {"api": {"Comparator": [[42, 51]]}}}, {"text": "java.util.Arrays uses mergesort for objects that implement Comparable or use a Comparator", "label": {"api": {"Comparator": [[79, 88]]}}}, {"text": "Something like this with findFirst and orElse as", "label": {"api": {"findFirst": [[25, 33]], "orElse": [[39, 44]]}}}, {"text": "If you have a Path object, you can use the Path.getFileSystem() method to obtain the underlying file system object", "label": {"api": {"Path.getFileSystem()": [[43, 62]]}}}, {"text": "It has a FileSystem.supportedFileAttributeViews() method", "label": {"api": {"FileSystem.supportedFileAttributeViews()": [[9, 48]]}}}, {"text": "Math.ulp(double) is defined to return \"the positive distance between this floating-point value and the double value next larger in magnitude\" so the subtract proposition is false when the distance is different", "label": {"api": {"Math.ulp(double)": [[0, 15]]}}}, {"text": "DefaultConsumer is not a FunctionalInterface (and can't be", "label": {"api": {"FunctionalInterface": [[25, 43]]}}}, {"text": "If you're running Java 8, you can use the many new default methods of the Comparator interface to do it in one line", "label": {"api": {"Comparator": [[74, 83]]}}}, {"text": "Just added a counter to the Comparator to see how many times a String was converted to a BigInteger", "label": {"api": {"Comparator": [[28, 37]]}}}, {"text": "Scanner.next*() reads a stream until the next delimiter (the default is defined in Character.isWhitespace)", "label": {"api": {"Scanner.next*()": [[0, 14]], "Character.isWhitespace": [[83, 104]]}}}, {"text": "This solution uses the TreeSet.headSet method, which fits like a glove for what you are trying to do", "label": {"api": {"TreeSet.headSet": [[23, 37]]}}}, {"text": "You will need Subquery to achieve what you want if you need to stick with Criteria API", "label": {"api": {"Subquery": [[14, 21]]}}}, {"text": "Java provides a ThreadPoolExecutor for this", "label": {"api": {"ThreadPoolExecutor": [[16, 33]]}}}, {"text": "To answer your question, just take a look at the Object class reference page, and you'll see this", "label": {"api": {"Object class reference page": [[49, 75]]}}}, {"text": "You need to extend your task from either ResursiveTask or ResursiveAction and submit it to ForkJoinPool", "label": {"api": {"ResursiveTask": [[41, 53]], "ResursiveAction": [[58, 72]], "ForkJoinPool": [[91, 102]]}}}, {"text": "Once you have created your provider instance, it is recommended to get the name using the Provider.getName()", "label": {"api": {"Provider.getName()": [[90, 107]]}}}, {"text": "BufferedReader.readLine() is as fast as you need", "label": {"api": {"BufferedReader.readLine()": [[0, 24]]}}}, {"text": "since Socket#close() can itself throw an exception, you need to decide what do you want to do about it", "label": {"api": {"Socket#close()": [[6, 19]]}}}, {"text": "File doesn't have a printf method - you can however create a PrintStream from a file", "label": {"api": {"a PrintStream": [[59, 71]]}}}, {"text": "There are a lot of ways to accomplish this result, you can use replace() to get the number you want", "label": {"api": {"replace()": [[63, 71]]}}}, {"text": "The Javadocs of the classes in the JVM is available for download at Oracle or can be browsed online", "label": {"api": {"online": [[93, 98]]}}}, {"text": "As you said in your question, you \"installed\" the docs for your corresponding JDK, so instead of downloading it again or browsing it online, you can change to the \"installation directory\" of the doc-package and open the index-html file that should be there at its root", "label": {"api": {"online": [[133, 138]]}}}, {"text": "You should look up the Java Documentation for TreeMap", "label": {"api": {"Java Documentation for TreeMap": [[23, 52]]}}}, {"text": "There are two type of threads in ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[33, 50]]}}}, {"text": "Here is comprehensive description of ThreadPoolExecutor configuration parameters", "label": {"api": {"ThreadPoolExecutor": [[37, 54]]}}}, {"text": "Try it with the reduce method", "label": {"api": {"reduce": [[16, 21]]}}}, {"text": "In order to favor certain service implementations over others, I wrote a customizable version of java.util.ServiceLoader (adds priority and enabled/disabled flag to implementations via preference files for non-OSGi code)", "label": {"api": {"java.util.ServiceLoader": [[97, 119]]}}}, {"text": "The ParameterMetaData of a prepared statement and the ResultSetMetaData of a result set (also accessible from a prepared statement), specifically the getPrecision (and getScale) of these objects, or maybe even things like DatabaseMetadata.getColumns", "label": {"api": {"ParameterMetaData": [[4, 20]], "ResultSetMetaData": [[54, 70]], "DatabaseMetadata.getColumns": [[222, 248]]}}}, {"text": "You can use this method to copy files", "label": {"api": {"this method": [[12, 22]]}}}, {"text": "This uses Collectors.toMap to create the result TreeMap", "label": {"api": {"Collectors.toMap": [[10, 25]]}}}, {"text": "The List#removeAll() method is your friend", "label": {"api": {"List#removeAll()": [[4, 19]]}}}, {"text": "From the official Javadoc", "label": {"api": {"official Javadoc": [[9, 24]]}}}, {"text": "See the JavaFX CSS reference for info on this setting and how to use it", "label": {"api": {"JavaFX CSS reference": [[8, 27]]}}}, {"text": "There are numerous bubble shapes already created at iconmonstr.com, you can just use its interface to search for speech bubbles and select the shape you want, or you can define your own svg path for your custom shape if you have the tools (e.g", "label": {"api": {"path": [[190, 193]]}}}, {"text": "To extract the svg path from an existing svg file, open up the svg file, hope that it is encoded in a compact path string format, and if it is, just copy and paste the path part from the svg into your JavaFX css file", "label": {"api": {"path": [[19, 22], [110, 113], [168, 171]]}}}, {"text": "Another way to do this would be to programmatically construct a path which you would layer with the content by placing both in a StackPane", "label": {"api": {"path": [[64, 67]]}}}, {"text": "In a game I am working on in JavaFX, I have cards (Labels) with DropShadows", "label": {"api": {"Label": [[51, 55]], "DropShadow": [[64, 73]]}}}, {"text": "I've tried using Node#setCache(boolean), which works, but blurs the text in the label", "label": {"api": {"Node#setCache(boolean)": [[17, 38]]}}}, {"text": "Are there any other ways to prevent a DropShadow from leaving a trail", "label": {"api": {"DropShadow": [[38, 47]]}}}, {"text": "The Files#newBufferedReader method takes a mandatory second parameter which is a character set", "label": {"api": {"Files#newBufferedReader": [[4, 26]]}}}, {"text": "After the seeing the accepted answer, I noticed that Java 8 introduced a one argument version of Files#newBufferedReader which just takes a single path as input", "label": {"api": {"Files#newBufferedReader": [[97, 119]]}}}, {"text": "You could try with an custom XmlAdapter that can handle non initialized Hibernate's collection, something like", "label": {"api": {"XmlAdapter": [[29, 38]]}}}, {"text": "This depends on the Set implementation", "label": {"api": {"Set": [[20, 22]]}}}, {"text": "Set is just an interface that defines the methods and general behavior of implementing classes", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "You can use the map method of the stream to manipulate the content of your stream, something like the below code", "label": {"api": {"map": [[16, 18]]}}}, {"text": "The optional also has a map method that can be used when manipulating the stream", "label": {"api": {"map": [[24, 26]]}}}, {"text": "You'll get a NoSuchMethodError, this happens because Child call the parent's myMethod at runtime", "label": {"api": {"NoSuchMethodError": [[13, 29]]}}}, {"text": "Technically, j.u.c.Flow is much more simpler, it consists only of four simple interfaces, while other libraries provide dozens of classes and hundreds of operators", "label": {"api": {"four simple interfaces": [[66, 87]]}}}, {"text": "You could use SequentialTransition if you're able to determine all transitions in advance", "label": {"api": {"SequentialTransition": [[14, 33]]}}}, {"text": "Now your main thread schedules a task to execute after patience milliseconds", "label": {"api": {"schedules a task": [[21, 36]]}}}, {"text": "I've spotted a potential StackOverflowError while looking to User.toString() and Appointment.toString(), as both will call each other infinitely", "label": {"api": {"StackOverflowError": [[25, 42]]}}}, {"text": "From the Javadoc of ArrayList", "label": {"api": {"Javadoc of ArrayList": [[9, 28]]}}}, {"text": "The method executeUpdate(String sql) is inherited from Statement and directly executes the given SQL", "label": {"api": {"executeUpdate(String sql)": [[11, 35]], "Statement": [[55, 63]]}}}, {"text": "Instead you should call executeUpdate(), which will execute the SQL given at construction (Connection#prepareStatement(String sql)), and more important, consider the arguments passed to it via setString(...)", "label": {"api": {"Statement": [[109, 117]], "executeUpdate()": [[24, 38]], "Connection#prepareStatement(String sql)": [[91, 129]], "setString(...)": [[193, 206]]}}}, {"text": "The @XmlEnumValue annotation seems close to what I need, but only takes one value", "label": {"api": {"@XmlEnumValue": [[4, 16]]}}}, {"text": "You might use CompletableFuture.allOf to obtain a single completable future you can block on to wait only as long as needed for all of them to complete or timeout (so possibly wait shorter than the timeout - all tasks up to one second, not necessarily after one second) and then iterate over original futures to obtain their values if they are done", "label": {"api": {"CompletableFuture.allOf": [[14, 36]]}}}, {"text": "Cursor does not override equals(), so this method is not very useful", "label": {"api": {"Cursor": [[0, 5]]}}}, {"text": "Is it possible to perform a pre-order traversal/in-order traversal/post-order traversal/level-order traversal on a TreeMap in Java without any additional classes or libraries", "label": {"api": {"TreeMap": [[115, 121]]}}}, {"text": "From the java documentation for AbstractMethodError", "label": {"api": {"AbstractMethodError": [[32, 50]]}}}, {"text": "Please look at Arrays documentation, specifically deepEquals for verifying nested arrays", "label": {"api": {"Arrays": [[15, 20]], "deepEquals": [[50, 59]]}}}, {"text": "See Arrays.equals(Object[], Object[]) and implement equals() (and hashCode()) on your base class (I'm assuming all players inherit from the same Player class)", "label": {"api": {"Arrays.equals(Object[], Object[])": [[4, 36]]}}}, {"text": "Add two FileHandlers to your logger", "label": {"api": {"FileHandler": [[8, 18]]}}}, {"text": "Also see LogManager", "label": {"api": {"LogManager": [[9, 18]]}}}, {"text": "I think a Phaser will be useful here", "label": {"api": {"Phaser": [[10, 15]]}}}, {"text": "new Phaser(2) means the Phaser will wait for two arrive() calls before marking itself “terminated,” which will cause any methods awaiting advancement to return", "label": {"api": {"Phaser": [[4, 9], [24, 29]]}}}, {"text": "You are also able to get the controller using FXMLLoader#getController", "label": {"api": {"FXMLLoader#getController": [[46, 69]]}}}, {"text": "utilize findFirst like so", "label": {"api": {"findFirst": [[8, 16]]}}}, {"text": "Use Collections.sort and pass a Comparator to use the LocalDate for sorting", "label": {"api": {"Collections.sort": [[4, 19]]}}}, {"text": "see java.util.function & java.util.stream packages documentation", "label": {"api": {"java.util.function": [[4, 21]], "java.util.stream": [[25, 40]]}}}, {"text": "Mocking ScheduledExecutorService would really make testing my classes easier, but according to the mockito recommendations this seems a bad idea, as the logic of the mocked class can change in a way that it would be used in an incorrect way, but unit tests would still report success", "label": {"api": {"ScheduledExecutorService": [[8, 31]]}}}, {"text": "I'd like to follow the practical recommendations of this answer, but I am not sure that the contract of ScheduledExecutorService will always remain the same", "label": {"api": {"ScheduledExecutorService": [[104, 127]]}}}, {"text": "Can I assume that the contract for the existing methods of ScheduledExecutorService (or more generally, any other class in the JRE libs) will never change", "label": {"api": {"ScheduledExecutorService": [[59, 82]]}}}, {"text": "Use Logger.log in the MyLogger.log", "label": {"api": {"Logger.log": [[4, 13], [24, 33]]}}}, {"text": "If I'm working with Kotlin in the JVM I'm using the Java LinkedList source", "label": {"api": {"source": [[68, 73]]}}}, {"text": "Couple this with Java 8's Optional, and you can do this in single statement", "label": {"api": {"Optional": [[26, 33]]}}}, {"text": "Long is comparable to itself because it implements Comparable<Long>", "label": {"api": {"Long": [[0, 3], [62, 65]]}}}, {"text": "AtomicLong is not comparable to itself because it doesn't implement Comparable<AtomicLong>", "label": {"api": {"Long": [[6, 9], [85, 88]], "AtomicLong": [[0, 9], [79, 88]]}}}, {"text": "This means you cannot use Map.Entry.comparingByValue which takes a Comparable", "label": {"api": {"Map.Entry.comparingByValue": [[26, 51]]}}}, {"text": "Did you read the docs for DecimalFormat", "label": {"api": {"read the docs": [[8, 20]]}}}, {"text": "Curiously enough, this does not seem to be the case when mocking UriInfo", "label": {"api": {"UriInfo": [[65, 71]]}}}, {"text": "To create animations, or delays inside of Swing, you must use a javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[64, 80]]}}}, {"text": "To return from a spawned thread to the EDT, you must use SwingUtilities.invokeLater() or SwingUtilities.invokeAndWait()", "label": {"api": {"SwingUtilities.invokeLater()": [[57, 84]], "SwingUtilities.invokeAndWait()": [[89, 118]]}}}, {"text": "Using a SwingWorker is the preferred way to execute background tasks in Swing", "label": {"api": {"SwingWorker": [[8, 18]]}}}, {"text": "The following is a translation of your code to a working example, using a SwingWorker", "label": {"api": {"SwingWorker": [[74, 84]]}}}, {"text": "The \"Button 0\" through \"Button 100\" progress reports are published from the SwingWorker background task, for processing in the EDT", "label": {"api": {"SwingWorker": [[76, 86]]}}}, {"text": "You can stream and reduce them like this", "label": {"api": {"reduce": [[19, 24]]}}}, {"text": "An OutOfMemoryError means the JVM has run out of memory pre-allocated to it", "label": {"api": {"OutOfMemoryError": [[3, 18]]}}}, {"text": "Other Options is you can use readAllLines from File Object", "label": {"api": {"readAllLines": [[29, 40]]}}}, {"text": "Having said all of that, if you're on a modern version of Java, I'd use Files.newBufferedReader to create a Reader for the specified Path, defaulting to UTF-8 (which is probably what you want)", "label": {"api": {"Files.newBufferedReader": [[72, 94]]}}}, {"text": "Collection.equals refines the contract of Object.equals with additional stipulations", "label": {"api": {"Collection.equals": [[0, 16]]}}}, {"text": "List has a clear() method, which will clear it", "label": {"api": {"clear()": [[11, 17]]}}}, {"text": "Then you can use Class.forName to look up a particular Cat or Dog, pass it through isSubclass to make sure it implements Animal, look up a constructor, invoke it, and cast the resulting object to Animal", "label": {"api": {"Class.forName": [[17, 29]]}}}, {"text": "The main change that needs to happen is that instead of starting a new thread, the producer should notify (actually notifyAll) the threads running Even and Odd", "label": {"api": {"notify": [[99, 104], [116, 121]], "notifyAll": [[116, 124]]}}}, {"text": "Synchronization is done by the queue as well, as in a LinkedBlockingQueue or ArrayBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[54, 72]], "ArrayBlockingQueue": [[77, 94]]}}}, {"text": "You can use LocalDateTime instead", "label": {"api": {"LocalDateTime": [[12, 24]]}}}, {"text": "You can call g2d.getTransform() to get the current transformation matrix, then use its inverseTransform() method to transform a point from pixel coordinates on the canvas into logical coordinates in your current coordinate system", "label": {"api": {"g2d.getTransform()": [[13, 30]], "inverseTransform()": [[87, 104]]}}}, {"text": "java.lang.Class is a class which can take parameters, as per this syntax", "label": {"api": {"java.lang.Class": [[0, 14]]}}}, {"text": "This will call the JFrame's constructor that takes a String argument as the title", "label": {"api": {"JFrame's constructor": [[19, 38]]}}}, {"text": "You want a BiConsumer, not a Function, because a set-method does not return anything", "label": {"api": {"BiConsumer": [[11, 20]]}}}, {"text": "Take a look at your fetch type attribute", "label": {"api": {"fetch type": [[20, 29]]}}}, {"text": "If you have @ManyToOne and @OneToMany annotations in both of your entities, one of them should use lazy fetch type to avoid an infinite loop", "label": {"api": {"fetch type": [[104, 113]]}}}, {"text": "Notice that default fetch type is eager", "label": {"api": {"fetch type": [[20, 29]]}}}, {"text": "As per the merging of the values, there's a merge method in Map, which is definitely what you're looking for", "label": {"api": {"merge method": [[44, 55]]}}}, {"text": "MIME type application/octet-stream consists of bytes encoded in Base64", "label": {"api": {"Base64": [[64, 69]]}}}, {"text": "Use Base64 class for decoding", "label": {"api": {"Base64": [[4, 9]]}}}, {"text": "Set inputStream to an instance of FileInputStream constructed with a File argument (link)", "label": {"api": {"link": [[84, 87]]}}}, {"text": "SimpleDateFormat's javadoc lists all the options, including \"a\" for am/pm marker", "label": {"api": {"SimpleDateFormat's javadoc": [[0, 25]]}}}, {"text": "This class helps you to parse your string to java.util.Date (more info here)", "label": {"api": {"more info here": [[61, 74]]}}}, {"text": "In the Spring Data JPA - Reference Documentation, a criteria is defined by", "label": {"api": {"criteria": [[52, 59]]}}}, {"text": "Writing a criteria you actually define the where-clause of a query for a domain class", "label": {"api": {"criteria": [[10, 17]]}}}, {"text": "Specifications and predicates seem to have the same role", "label": {"api": {"predicate": [[19, 27]]}}}, {"text": "What is the difference between a criteria, a predicate and a specification", "label": {"api": {"criteria": [[33, 40]], "predicate": [[45, 53]]}}}, {"text": "Actually one should normalize text before comparing", "label": {"api": {"normalize": [[20, 28]]}}}, {"text": "If you search for .values() in Class Enum you may not find it because this method is added by the compiler", "label": {"api": {"Class Enum": [[31, 40]]}}}, {"text": "Double already implements Comparable, so you can use the zero-arg reverseOrder() overload", "label": {"api": {"reverseOrder()": [[66, 79]]}}}, {"text": "See various createTempDirectory methods in Files", "label": {"api": {"Files": [[43, 47]]}}}, {"text": "You have to use the isSelected method in the JCheckBox class to know the state of the checkbox", "label": {"api": {"isSelected": [[20, 29]]}}}, {"text": "And throwing a Throwable usually doesn't make much sense, since Error is a direct subclass of Throwable and its description reads", "label": {"api": {"Throwable": [[15, 23], [94, 102]], "Error": [[64, 68]]}}}, {"text": "An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch", "label": {"api": {"Throwable": [[26, 34]], "Error": [[3, 7]]}}}, {"text": "One approach is to render arbitrary content in a Canvas, as suggested here", "label": {"api": {"Canvas": [[49, 54]]}}}, {"text": "As a concrete example, jfreechart renders charts using jfreechart-fx, whose ChartViewer holds a ChartCanvas that extends Canvas", "label": {"api": {"Canvas": [[101, 106], [121, 126]]}}}, {"text": "see the Package java.util.function for picking the most appropriate functional interface for the task at hand or define your own if necessary", "label": {"api": {"Package java.util.function": [[8, 33]]}}}, {"text": "You have to set HBox.hgrow to ALWAYS or SOMETIMES (in the node) that the node can grow with the HBox", "label": {"api": {"HBox.hgrow": [[16, 25]], "ALWAYS": [[30, 35]], "SOMETIMES": [[40, 48]]}}}, {"text": "This is precisely what the relativize(Path) method does", "label": {"api": {"relativize(Path)": [[27, 42]]}}}, {"text": "If needed, you can override process(java.util.List) to get and process interim results", "label": {"api": {"process(java.util.List)": [[28, 50]]}}}, {"text": "A good way to do this is with Random#nextInt(int bound) + 1 (you need the + 1 because nextInt may return 0)", "label": {"api": {"Random#nextInt(int bound) + 1": [[30, 58]]}}}, {"text": "For scanning directories, you can use the Files api, which you're already doing, and for scanning JAR files, you should probably use the JarFile API", "label": {"api": {"JarFile": [[137, 143]]}}}, {"text": "You could use a StringBuilder instead, though", "label": {"api": {"StringBuilder": [[16, 28]]}}}, {"text": "To quote Arrays.asList's documentation", "label": {"api": {"Arrays.asList": [[9, 21]]}}}, {"text": "If roleIdList is a List<Long> and you want to get a List<Long> you have to use flatMap instead", "label": {"api": {"flatMap": [[79, 85]]}}}, {"text": "You can skip the first element", "label": {"api": {"skip": [[8, 11]]}}}, {"text": "Note that the skipped elements will still be traversed by the stream, so for a random access list such as ArrayList it is much more efficient to use a loop starting from the relevant index if this index is very large", "label": {"api": {"skip": [[14, 17]]}}}, {"text": "Because a Comparable is for comparing two elements a and b where a is the implementing Object", "label": {"api": {"Comparable": [[10, 19]]}}}, {"text": "If you're using Comparable then you don't need to pass a Comparator to the Arrays.sort method (it will use the instances themselves to perform the comparisons)", "label": {"api": {"Comparable": [[16, 25]]}}}, {"text": "Don't implement Comparable on a class unless there is a natural ordering for that class that will be sensible in most situations (sorting, finding smallest, largest etc)", "label": {"api": {"Comparable": [[16, 25]]}}}, {"text": "Also note that if you implement Comparable you likely should define equals and hashCode as well because the natural order is strongly recommended to be consistent with equals (see Comparable)", "label": {"api": {"Comparable": [[32, 41], [180, 189]]}}}, {"text": "Firstly Stream API doesn't even have a where method on it", "label": {"api": {"Stream API": [[8, 17]]}}}, {"text": "In your specific example, you know the stream isn't parallel, because Collection#stream returns a sequential stream", "label": {"api": {"Collection#stream": [[70, 86]]}}}, {"text": "with java 8 you can use the random Object's method ints", "label": {"api": {"ints": [[51, 54]]}}}, {"text": "Use Objects.equals() to perform a null-safe test using the objects' equals() method", "label": {"api": {"Objects.equals()": [[4, 19]]}}}, {"text": "For showing pages from the PHP Web Server you just need to use WebView", "label": {"api": {"WebView": [[63, 69]]}}}, {"text": "An example of how to use it in Swing is shown here or you may use JavaFX directly without Swing if you want, because WebView is a part of JavaFX", "label": {"api": {"WebView": [[117, 123]]}}}, {"text": "However, the paragraph at the bottom of the value-based classes definition says", "label": {"api": {"value-based classes": [[44, 62]]}}}, {"text": "Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided", "label": {"api": {"value-based classes": [[58, 76]]}}}, {"text": "See JavaDoc FXMLLoader.setController(Object controller)", "label": {"api": {"FXMLLoader.setController(Object controller)": [[12, 54]]}}}, {"text": "Following is quote from Oracle Javadoc page", "label": {"api": {"Oracle Javadoc page": [[24, 42]]}}}, {"text": "I didn't try it, but perhaps you could try setting that property and just launching your main app via the public Application.launch(appClass, args) API and perhaps the preloader will launch first", "label": {"api": {"Application.launch(appClass, args)": [[113, 146]]}}}, {"text": "I've used Predicate.and to compose the conditions", "label": {"api": {"Predicate.and": [[10, 22]]}}}, {"text": "You can add a component in a container at a specific index for this purpose, by using Container's add (Component comp, int index) method", "label": {"api": {"add (Component comp, int index)": [[98, 128]]}}}, {"text": "Java 8 added a StringJoiner class which does exactly what you want (the following code is in Java 9)", "label": {"api": {"StringJoiner": [[15, 26]]}}}, {"text": "You want to call hasNextLine first which will block and wait for user input", "label": {"api": {"hasNextLine": [[17, 27]]}}}, {"text": "Given you requirements, you can use Java 9's takeWhile", "label": {"api": {"takeWhile": [[45, 53]]}}}, {"text": "If you're using java 8 you can use a Collector", "label": {"api": {"Collector": [[37, 45]]}}}, {"text": "As Tavian mentioned in the comments, the best solution is Suppliers.memoize(serviceProvider::get), or some equivalent", "label": {"api": {"Supplier": [[58, 65]]}}}, {"text": "Suppliers (and Supplier) are in the Google utility library Guava, and since Java 8, Guava's Supplier extends the Java 8 functional interface Supplier, though Java 8 doesn't supply a Suppliers equivalent built-in", "label": {"api": {"Supplier": [[0, 7], [15, 22], [92, 99], [141, 148], [182, 189]]}}}, {"text": "The specification of serviceProvider::get is necessary to make Provider behave as a Supplier without an explicit adapter, even though they both specify exactly one method, a zero-arg T get()", "label": {"api": {"Supplier": [[84, 91]]}}}, {"text": "Unlike Google's other DI framework, Dagger, Supplier doesn't have a Lazy class to provide the local memoization you're looking for", "label": {"api": {"Supplier": [[44, 51]]}}}, {"text": "Though you could do the kind of \"check then set\" behavior that tmarwen offers in their updated answer, that strategy (as mentioned in their comment) is not thread-safe, while Suppliers.memoize is explicitly thread-safe", "label": {"api": {"Supplier": [[175, 182]]}}}, {"text": "To do that, use ProcessBuilder.inheritIO()", "label": {"api": {"ProcessBuilder.inheritIO()": [[16, 41]]}}}, {"text": "The ByteArrayOutputStream has a method called toByteArray(), so you could also do it like this", "label": {"api": {"toByteArray()": [[46, 58]]}}}, {"text": "If your requirement is to send out emails only after all items in a chunk have successfully completed, then you can move the emailing part to a ItemWriterListener.afterWrite(items)", "label": {"api": {"ItemWriterListener.afterWrite(items)": [[144, 179]]}}}, {"text": "Also, having a Synchronized list will not help in your case", "label": {"api": {"Synchronized list": [[15, 31]]}}}, {"text": "There are no bootstrap methods in your class file (usually) and you actually do not want to change the bootstrap method, which is the method metafactory within the class java.lang.invoke.LambdaMetafactory in your example", "label": {"api": {"metafactory": [[141, 151]]}}}, {"text": "The bsm argument must be a Handle whose owner is java/lang/invoke/LambdaMetafactory and the method must be either metafactory or altMetafactory", "label": {"api": {"metafactory": [[114, 124]], "altMetafactory": [[129, 142]]}}}, {"text": "If not, just pass everything to super.visitInvokeDynamicInsn (delegating to the writer unchanged), as it is a different use of the invokedynamic feature then (e.g., Java 9 will use it for string concatenation)", "label": {"api": {"invokedynamic feature": [[131, 151]]}}}, {"text": "When it is a lambda creation site, you can interpret the arguments according to the conventions specified in the documentation of LambdaMetafactory", "label": {"api": {"the documentation of LambdaMetafactory": [[109, 146]]}}}, {"text": "For more details, refer to LambdaMetafactory’s comprehensive documentation", "label": {"api": {"LambdaMetafactory’s comprehensive documentation": [[27, 73]]}}}, {"text": "I'd recommend that you proceed with whatever approach is most readable to you as most of the methods within the LocalDateTime API already return a new instance on each method invocation so there is a minimal performance deficit if any between the different ways you could accomplish the task at hand", "label": {"api": {"LocalDateTime": [[112, 124]]}}}, {"text": "for example, the truncateTo could be used to return the same result as your example with the use of minusNanos", "label": {"api": {"truncateTo": [[17, 26]]}}}, {"text": "If you don't use Spring MVC (for example, you are using Jersey), you can also solve this by using a  javax.servlet.Filter", "label": {"api": {"javax.servlet.Filter": [[101, 120]]}}}, {"text": "The key point appears to be that a TreeSet can only contain elements of a class which implement the Comparable interface", "label": {"api": {"Comparable": [[100, 109]]}}}, {"text": "If I understand your requirement you might be able to use JList#setLayoutOrientation(JList.VERTICAL)", "label": {"api": {"JList#setLayoutOrientation(JList.VERTICAL)": [[58, 99]]}}}, {"text": "You can store them with Properties.storeToXML​(OutputStream os, String comment) and load them with Properties.loadFromXML​(InputStream in)", "label": {"api": {"Properties.storeToXML​(OutputStream os, String comment)": [[24, 78]], "Properties.loadFromXML​(InputStream in)": [[99, 137]]}}}, {"text": "That code relies on toString() method of JavaFX's color class, which explicitly states", "label": {"api": {"which explicitly states": [[63, 85]]}}}, {"text": "Method matcher in the Pattern class accepts a CharSequence argument, so you need to pass a CharSequence (most likely a String) to it", "label": {"api": {"matcher": [[7, 13]]}}}, {"text": "If it's small then you can just read all lines, collect them into a single String and pass it to the matcher method", "label": {"api": {"matcher": [[101, 107]]}}}, {"text": "In your case you probably want a DoubleUnaryOperator which only operates on primitives, whereas a DoubleFunction<Double> will box/unbox the values", "label": {"api": {"a DoubleUnaryOperator": [[31, 51]]}}}, {"text": "Specifically for double->double use DoubleUnaryOperator instead, but in general you can always create your own interface if there is no suitable one", "label": {"api": {"DoubleUnaryOperator": [[36, 54]]}}}, {"text": "If you want better thread safety, use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[38, 57]]}}}, {"text": "If, for example, one thread adds items to a List, while another iterates, that will break any List implementation except CopyOnWriteArrayList, whether or not it's wrapped in Collections.synchronizedList()", "label": {"api": {"CopyOnWriteArrayList": [[121, 140]]}}}, {"text": "If you want to count how many char you have on each line, I recommend ArrayList", "label": {"api": {"ArrayList": [[70, 78]], "List": [[75, 78]]}}}, {"text": "Note that you can also you can use the char counter logic above with List too.See as follows", "label": {"api": {"List": [[69, 72]]}}}, {"text": "The docs for Scanner should describe what you need", "label": {"api": {"The docs for Scanner": [[0, 19]]}}}, {"text": "Consider using an UUID for the keys, it's extremely unlikely that a collision will occur", "label": {"api": {"UUID": [[18, 21]]}}}, {"text": "You have multiple options, one of which would be to use an implementation of Set as it is inherently collection that compels to uniqueness", "label": {"api": {"Set": [[77, 79]]}}}, {"text": "There are many more possible solutions, if you ask me, lambdas are the simplest one if you are obliged to use List, otherwise just use Set", "label": {"api": {"Set": [[135, 137]]}}}, {"text": "You should avoid any using of Thread#pause(), Thread#resume() and Thread.stop() especially Thread.stop()", "label": {"api": {"Thread#pause()": [[30, 43]], "Thread#resume()": [[46, 60]], "Thread.stop()": [[66, 78], [91, 103]]}}}, {"text": "Use the String.split() method", "label": {"api": {"String.split()": [[8, 21]]}}}, {"text": "You could just iterate through all of the members and insert them in a HashMap", "label": {"api": {"HashMap": [[71, 77]]}}}, {"text": "I used ArrayList in this example, but if you would like, I can rewrite it with a regular array", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "So lets say you have an ArrayList called members", "label": {"api": {"ArrayList": [[24, 32]]}}}, {"text": "A slightly different solution (using an ArrayList of ArrayList instead of an ArrayList of String[])", "label": {"api": {"ArrayList": [[40, 48], [53, 61], [77, 85]]}}}, {"text": "Printing the HashMap from the first solution will require some effort to print out the contents of the HashMap since it won't print the regular array nicely like it does for ArrayList", "label": {"api": {"HashMap": [[13, 19], [103, 109]], "ArrayList": [[174, 182]]}}}, {"text": "But I think instead of storing an ArrayList of ArrayList, you should just be storing it as an ArrayList of Member", "label": {"api": {"ArrayList": [[34, 42], [47, 55], [94, 102]]}}}, {"text": "An example of how you might define your ArrayList of Member object would be", "label": {"api": {"ArrayList": [[40, 48]]}}}, {"text": "I think you can do better by using Java Stream API (https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html": [[52, 121]]}}}, {"text": "Simply split the string on the separating space", "label": {"api": {"split": [[7, 11]]}}}, {"text": "You can also use indexOf and substring", "label": {"api": {"indexOf": [[17, 23]], "substring": [[29, 37]]}}}, {"text": "These are all common methods on the String class, and you should have been able to find them yourself, if you just read the documentation, i.e", "label": {"api": {"String": [[36, 41]]}}}, {"text": "the javadoc of String", "label": {"api": {"String": [[15, 20]]}}}, {"text": "CipherInputStream.read (your line 197) throws IOException, not BadPaddingException, therefore the exception is caught by the subsequent catch (IOException  ex)", "label": {"api": {"CipherInputStream.read": [[0, 21]]}}}, {"text": "Make an instance of StringBuilder before the loop, and call append method repeatedly to construct the output string", "label": {"api": {"StringBuilder": [[20, 32]]}}}, {"text": "An advantage of keeping a StringBuilder over printing-as-you-go approach is that you can go back and change the beginning or the middle of the string that you build before printing it", "label": {"api": {"StringBuilder": [[26, 38]]}}}, {"text": "Therefore you can specify a charset for your Scanner using the Scanner(InputStream source, String charsetName) constructor", "label": {"api": {"Scanner(InputStream source, String charsetName)": [[63, 109]]}}}, {"text": "The API you have linked (https://docs.oracle.com/javase/7/docs/api/), is basically an ordinary class library", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/": [[25, 66]]}}}, {"text": "Your code doesn't match your test string because String.matches() method returns true only when whole string matches by regex pattern", "label": {"api": {"String.matches()": [[49, 64]]}}}, {"text": "Do you understand what the first constructor parameter does", "label": {"api": {"first constructor parameter": [[27, 53]]}}}, {"text": "When getting a BindException, is there a way to get which port is used", "label": {"api": {"BindException": [[15, 27]]}}}, {"text": "Change input.next() with input.nextLine() to take whole line of input into consideration", "label": {"api": {"input.nextLine()": [[25, 40]]}}}, {"text": "Check out the java.time documentation for more details", "label": {"api": {"java.time": [[14, 22]]}}}, {"text": "Have a look at this implementation, using the java.time APIs for formatting and date manipulation", "label": {"api": {"java.time": [[46, 54]]}}}, {"text": "java.util.Date, like a lot of other classes in the JDK, overrides toString(), which allows you to control the string representation of your objects", "label": {"api": {"toString()": [[66, 75]]}}}, {"text": "with while (true) - break loop or with ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[39, 62]]}}}, {"text": "try to use String::replaceAll with some regex like this", "label": {"api": {"String::replaceAll": [[11, 28]]}}}, {"text": "That package is part of an exported, JDK-specific API, per https://docs.oracle.com/javase/9/docs/api/jdk.httpserver-summary.html", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/jdk.httpserver-summary.html": [[59, 127]]}}}, {"text": "Class::getDeclaredFields; Class::getSuperclass; and Field", "label": {"api": {"Class::getDeclaredFields": [[0, 23]], "Class::getSuperclass": [[26, 45]], "Field": [[18, 22], [52, 56]]}}}, {"text": "You can use MessageFormat like this", "label": {"api": {"MessageFormat": [[12, 24]]}}}, {"text": "The actual path separator can be retrieved by querying java.io.File::pathSeparator field", "label": {"api": {"java.io.File::pathSeparator": [[55, 81]]}}}, {"text": "Since you are coming from .NET, Java's DataInputStream is roughly equivalent to BinaryReader of .NET", "label": {"api": {"DataInputStream": [[39, 53]], "DataInput": [[39, 47]]}}}, {"text": "Just like its .NET equivalent, DataInputStream class and its main interface, DataInput, have no provision for determining if a primitive of any given type is available for retrieval at the current position of the stream", "label": {"api": {"DataInputStream": [[31, 45]], "DataInput": [[31, 39], [77, 85]]}}}, {"text": "The code that reads arrays of various types calls type-specific readXYZ methods of DataInput in a loop", "label": {"api": {"DataInput": [[83, 91]]}}}, {"text": "Above, bin is a BlockDataInputStream, which is another implementation of DataInput interface", "label": {"api": {"DataInputStream": [[21, 35]], "DataInput": [[21, 29], [73, 81]]}}}, {"text": "I am wondering if it would be better to simply call ZipEntry.getCrc() (if it returns something other than -1) rather than call computeCRC32()", "label": {"api": {"ZipEntry.getCrc()": [[52, 68]]}}}, {"text": "Is it possible for ZipEntry.getCrc() to return a value other than -1, and other than what computeCRC32() would calculate, for some ZIP entry, and to fully read through the malformed ZIP archive without any exception occurring", "label": {"api": {"ZipEntry.getCrc()": [[19, 35]]}}}, {"text": "You might want to make use of the example as provided in the Javadoc for ModuleLayer to get a ModuleLayer of your module named let's say one to find out the descriptor and further the set of requires object in its module dependencies", "label": {"api": {"ModuleLayer": [[73, 83], [94, 104]], "set of requires": [[184, 198]]}}}, {"text": "Or, if you're still stuck on a pre-Java 8 version, use the code in the Java 8 Javadoc", "label": {"api": {"Java 8 Javadoc": [[71, 84]]}}}, {"text": "If you want to check whether these files exist within the zip file, you can use Files.exist(path)", "label": {"api": {"Files.exist(path)": [[80, 96]]}}}, {"text": "Use BigInteger to avoid numeric limits of primitive int and long", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "This can be easily done with Java-8's Comparator utilities", "label": {"api": {"Comparator": [[38, 47]]}}}, {"text": "The value of the orientation tag can be acquired either using the ImageIO JPEG metadata or some third-party library", "label": {"api": {"ImageIO JPEG metadata": [[66, 86]]}}}, {"text": "If using the ImageIO JPEG metadata, be aware", "label": {"api": {"ImageIO JPEG metadata": [[13, 33]]}}}, {"text": "If you want to persist a value, place it in the ServletContext’s attributes", "label": {"api": {"ServletContext’s attributes": [[48, 74]]}}}, {"text": "Your number is larger than Integer.MAX_VALUE which means it simply does not fit into an int", "label": {"api": {"Integer.MAX_VALUE": [[27, 43]]}}}, {"text": "Use Long.parseLong instead", "label": {"api": {"Long.parseLong": [[4, 17]]}}}, {"text": "Looking at answers from high reputation users such as this it seems that it's appropriate to get a new DataSource object by querying the JNDI naming service on every single connection request", "label": {"api": {"DataSource": [[103, 112]]}}}, {"text": "In some of my own \"ConnectionManager\" utilty classes I used to keep a reference to the DataSource object as an instance variable", "label": {"api": {"DataSource": [[87, 96]]}}}, {"text": "So, is it an anti-pattern to keep around instances of DataSource objects in JDBC", "label": {"api": {"DataSource": [[54, 63]]}}}, {"text": "One way you might consider is creating an object that implements the Comparator interface and takes the index to sort on as a parameter", "label": {"api": {"Comparator": [[69, 78]]}}}, {"text": "If you then have a List<ObjectData> of your cities, let's call it cityList for the sake of example, you can sort it using Collections.sort(cityList, new DataComparator(2))", "label": {"api": {"Comparator": [[157, 166]]}}}, {"text": "You can accomplish the task at hand by creating a stream of the HashMap's entrySet then  filter, map and collect the result into a list", "label": {"api": {"filter": [[89, 94]], "map": [[97, 99]], "collect": [[105, 111]]}}}, {"text": "You can use Scanner to read the input from console", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "For holding a precision and being precise - as with financial software - BigDecimal is used", "label": {"api": {"BigDecimal": [[73, 82]]}}}, {"text": "Unfortunately with BigDecimal normal math operators are not available, but in general it is not as unsafe as with double", "label": {"api": {"BigDecimal": [[19, 28]]}}}, {"text": "I am wondering if I can instantiate the javax.crypto.KeyGenerator only once and then use this instance in a multithread environment", "label": {"api": {"javax.crypto.KeyGenerator": [[40, 64]]}}}, {"text": "I am trying to use JavaFX HTMLEditor in my application, but I seem to have run into a problem", "label": {"api": {"HTMLEditor": [[26, 35]]}}}, {"text": "You don’t need a StringBuffer, since you have String.join", "label": {"api": {"String.join": [[46, 56]]}}}, {"text": "Personally, for a diagnostic message, I wouldn’t even bother with String.join", "label": {"api": {"String.join": [[66, 76]]}}}, {"text": "You can use System.arraycopy() to perform the copying or to shift items within the array", "label": {"api": {"System.arraycopy()": [[12, 29]]}}}, {"text": "And because in your case PrintStream doesn't have an empty constructor only the ones you can find in Oracle help center  you will get compilation error", "label": {"api": {"Oracle help center": [[101, 118]]}}}, {"text": "This is a workaround for type erasure, because you can get the Collection<Integer> reflectively via Class.getGenericSuperclass() and Class.getGenericInterfaces() if the class is not generic (*)", "label": {"api": {"Class.getGenericSuperclass()": [[100, 127]]}}}, {"text": "My idea was to create a LinkedBlockingDeque (let's call it stepDeque) that gathers all steps that should be done in parallel", "label": {"api": {"LinkedBlockingDeque": [[24, 42]]}}}, {"text": "There are other containers, like ArrayList, that do not require you to know how many items you will need ahead of time", "label": {"api": {"ArrayList": [[33, 41]]}}}, {"text": "I can make the code work by creating an \"environment\" Hashtable, placing the name of the MyContextFactory class there (under the \"java.naming.factory.initial\" key) and then creating the InitialContext using the constructor that accepts a Hashtable environment", "label": {"api": {"InitialContext": [[186, 199]]}}}, {"text": "You have to use Matcher and call find like this", "label": {"api": {"Matcher": [[16, 22]], "find": [[33, 36]]}}}, {"text": "The Graphics2D.setPaint(Paint) method is part of the Graphics2D class, not the Graphics class", "label": {"api": {"Graphics2D.setPaint(Paint)": [[4, 29]]}}}, {"text": "The lambda expression p->p.price creates a Function that takes an BigDecimal and returns an BigDecimal (which is a Comparable)", "label": {"api": {"BigDecimal": [[66, 75], [92, 101]]}}}, {"text": "From the Comparable Javadocs", "label": {"api": {"Comparable Javadocs": [[9, 27]]}}}, {"text": "Follow the link and search for java.security.Permission", "label": {"api": {"Follow the link": [[0, 14]]}}}, {"text": "From the KeyEvent documentation", "label": {"api": {"KeyEvent documentation": [[9, 30]]}}}, {"text": "This is documented", "label": {"api": {"documented": [[8, 17]]}}}, {"text": "To check if a set is a superset of another, call containsAll instead", "label": {"api": {"containsAll": [[49, 59]]}}}, {"text": "You are not using a correct regex you have to use a Character classes like this [a-zA-Z]", "label": {"api": {"Character classes": [[52, 68]]}}}, {"text": "Since java.lang.Object is an implicit base class of MioPunto (because it is a base class of all Java objects), method MioPunto.toString() is an override of Object.toString() method", "label": {"api": {"Object.toString()": [[156, 172]]}}}, {"text": "Also, note that the method generate(Supplier<T> s) returns an infinite sequential stream, usually in cases like this you'll want to utilize limit to truncate the stream", "label": {"api": {"generate(Supplier<T> s)": [[27, 49]], "limit": [[140, 144]]}}}, {"text": "In the language standard there is no definition of how fields are internally ordered, each JVM implementation could do it differently, so without using an absolute identifier you can't reliably assign parameters to values", "label": {"api": {"no definition of how fields are internally ordered": [[34, 83]]}}}, {"text": "You can use an Iterator, changing your attack method to accept it as a parameter", "label": {"api": {"Iterator": [[15, 22]]}}}, {"text": "Or you can change your attack method to return a boolean indicating whether the bullet hit or not (instead of removing the bullet), and use the removeIf() method introduced in Java 8", "label": {"api": {"removeIf()": [[144, 153]]}}}, {"text": "You can use deepToString instead of toString", "label": {"api": {"deepToString": [[12, 23]]}}}, {"text": "I've found a reference to ligature support in the JavaFX API, but I don't know if this \"proves\" that there's support", "label": {"api": {"JavaFX API": [[50, 59]]}}}, {"text": "The easiest way to do this is with Java's ExecutorService class", "label": {"api": {"ExecutorService": [[42, 56]]}}}, {"text": "Instead, you could use the set method specified by the List interface", "label": {"api": {"set": [[27, 29]]}}}, {"text": "You could use Java's StreamTokenizer for this purpose", "label": {"api": {"StreamTokenizer": [[21, 35]]}}}, {"text": "I suggest you to use LinkedBlockingQueue which has a maximum fixed capacity", "label": {"api": {"LinkedBlockingQueue": [[21, 39]]}}}, {"text": "To check that all producers have finished their work you could use CompletableFuture which provides many helpful methods", "label": {"api": {"CompletableFuture": [[67, 83]]}}}, {"text": "PreparedStatement provide a setBytes method that allow you to insert a byte[] as a value", "label": {"api": {"setBytes": [[28, 35]]}}}, {"text": "You should create a PreparedStatement and use setBytes (https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setBytes-int-byte:A-)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setBytes-int-byte:A-": [[56, 149]]}}}, {"text": "You can check the SimpleDateFormat documentation, where it is stated that DD can range from 1 to 365", "label": {"api": {"SimpleDateFormat documentation": [[18, 47]]}}}, {"text": "listFiles will only return null \"this abstract pathname does not denote a directory\", so perhaps the best way to handle this situation is to throw an exception", "label": {"api": {"listFiles will only return null \"this abstract pathname does not denote a directory\"": [[0, 83]]}}}, {"text": "There already one in java.nio.file which fits this situation nicely, NotDirectoryException", "label": {"api": {"NotDirectoryException": [[69, 89]]}}}, {"text": "Your method already declares IOException as thrown and NotDirectoryException is a subclass so you don't need to change your method signature", "label": {"api": {"NotDirectoryException": [[55, 75]]}}}, {"text": "You may want to convert your Integer to a String using Integer.toBinaryString, then returning its length", "label": {"api": {"Integer.toBinaryString": [[55, 76]]}}}, {"text": "You can make use of the Stream#reduce() operation", "label": {"api": {"Stream#reduce()": [[24, 38]]}}}, {"text": "You can see it in Class TextField", "label": {"api": {"Class TextField": [[18, 32]]}}}, {"text": "ArrayList.remove()'s documentation states", "label": {"api": {"documentation states": [[21, 40]]}}}, {"text": "Is the Java JDK service provider java.util.ServiceLoader suitable", "label": {"api": {"java.util.ServiceLoader": [[33, 55]]}}}, {"text": "For example look at using a BlockingQueue rather than ArrayList", "label": {"api": {"BlockingQueue": [[28, 40]]}}}, {"text": "I would personaly use a TreeSet which does what you want", "label": {"api": {"TreeSet": [[24, 30]]}}}, {"text": "You can only add an item if it is not already present in the set which is always kept sorted", "label": {"api": {"add": [[13, 15]]}}}, {"text": "The javadoc for the Matcher.matches method determines if the whole String is a match", "label": {"api": {"Matcher.matches": [[20, 34]]}}}, {"text": "What you're looking for is something the Matcher.find and Matcher.group methods", "label": {"api": {"Matcher.find": [[41, 52]], "Matcher.group": [[58, 70]]}}}, {"text": "Phantom references are general replacement for finalize()", "label": {"api": {"Phantom references": [[0, 17]]}}}, {"text": "Using Phantom references is a bit laborious, you have to maintain own reference list and postmortem processing thread", "label": {"api": {"Phantom references": [[6, 23]]}}}, {"text": "This article explains and compares implementation of Java finalize() and Phantom references", "label": {"api": {"Phantom references": [[73, 90]]}}}, {"text": "Java 9 introduces the Cleaner and Cleanable utility classes which take care of wiring up phantom references to a queue and a cleaning thread draining that queue", "label": {"api": {"Cleaner": [[22, 28]]}}}, {"text": "As MadProgrammer has said; this can be achieved by using the TimerTask.cancel method from within your TimerTask.run method", "label": {"api": {"TimerTask.cancel": [[61, 76]], "TimerTask.run": [[102, 114]]}}}, {"text": "AWT's TrayIcon class has a method called displayMessage that shows a native OS message that in Windows 10 looks like this", "label": {"api": {"displayMessage": [[41, 54]]}}}, {"text": "AWT's TrayIcon class has a method called displayMessage that shows a native OS message that in Windows 10 looks like this", "label": {"api": {"displayMessage": [[41, 54]]}}}, {"text": "Upon a quick search, I found that the missing class belongs to JAF (activation.jar)", "label": {"api": {"JAF (activation.jar)": [[63, 82]]}}}, {"text": "Add javax.activation jar to your classpath and check whether this resolves your issue", "label": {"api": {"javax.activation": [[4, 19]]}}}, {"text": "You might want to take a look at StringBuilder", "label": {"api": {"StringBuilder": [[33, 45]]}}}, {"text": "the string s to the StringBuilder object", "label": {"api": {"StringBuilder": [[20, 32]]}}}, {"text": "Return the String generated from StringBuilder object", "label": {"api": {"StringBuilder": [[33, 45]]}}}, {"text": "I would recommend using the StringBuilder", "label": {"api": {"StringBuilder": [[28, 40]]}}}, {"text": "Iterator throws ConcurrentModificationException when the underlying list has been changed after the Iterator is created (search for fail-fast in ArrayList JavaDoc)", "label": {"api": {"ArrayList JavaDoc": [[145, 161]]}}}, {"text": "Use BufferedInputStream instead of BufferedReader", "label": {"api": {"BufferedInputStream": [[4, 22]]}}}, {"text": "From the Javadocs for getMethods", "label": {"api": {"Javadocs for getMethods": [[9, 31]]}}}, {"text": "However, if you seriously want to create a thread with more than 2GB stack, you may use a Thread constructor that accepts stackSize as an argument", "label": {"api": {"Thread constructor": [[90, 107]]}}}, {"text": "You can use Java's built in XML parser in the the javax.xml.parsers package to load the XML into a document, then loop over the NodeList to find the right attributes", "label": {"api": {"javax.xml.parsers": [[50, 66]], "NodeList": [[128, 135]]}}}, {"text": "If you catch Exception, Exception itself and all exceptions that are a subtype of Exception will be caught by that block", "label": {"api": {"Exception": [[13, 21], [24, 32], [82, 90]]}}}, {"text": "However, you will not catch those \"exceptions\" that are only a subtype of Throwable", "label": {"api": {"Throwable": [[74, 82]]}}}, {"text": "Not that neither catching Exception nor Throwable is a good practice", "label": {"api": {"Exception": [[26, 34]], "Throwable": [[40, 48]]}}}, {"text": "There's also the method isSortedAccordingTo which takes a Comparator", "label": {"api": {"Comparator": [[58, 67]]}}}, {"text": "I have some library code that uses File.deleteOnExit()", "label": {"api": {"File.deleteOnExit()": [[35, 53]]}}}, {"text": "Use an AtomicInteger instead of a Semaphore", "label": {"api": {"AtomicInteger": [[7, 19]]}}}, {"text": "AtomicInteger is good suggestion, but since java-8 there is LongAdder that is much better suited in high contended environments", "label": {"api": {"LongAdder": [[60, 68]]}}}, {"text": "A LongAdder when it fails to CAS (there is a spin lock inside), will create an array of the values that \"failed\" (limited to the number of CPU's if I remember correctly)", "label": {"api": {"LongAdder": [[2, 10]]}}}, {"text": "As you may have seen, you cannot use the readLine method of DataInputStream, because it is deprecated", "label": {"api": {"readLine method of DataInputStream": [[41, 74]]}}}, {"text": "Ideally, you should use the readUTF method instead, but you must make sure that the server is sending character data using DataOutputStream.writeUTF for this to work", "label": {"api": {"readUTF": [[28, 34]], "DataOutputStream.writeUTF": [[123, 147]]}}}, {"text": "Reading the documentation about the ServiceLoader utility class, I was not able to understand the following sentence", "label": {"api": {"ServiceLoader": [[36, 48]]}}}, {"text": "ArrayIndexOutOfBoundsException is thrown when an array is accessed at an invalid index", "label": {"api": {"ArrayIndexOutOfBoundsException": [[0, 29]]}}}, {"text": "You can find the Java SE API for Java SE 9 at https://docs.oracle.com/javase/9/docs/api/overview-summary.html", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/overview-summary.html": [[46, 108]]}}}, {"text": "Try this BigDecimal::toPlainString", "label": {"api": {"BigDecimal::toPlainString": [[9, 33]]}}}, {"text": "Since it's an ArrayList, just use Collection.removeIf", "label": {"api": {"Collection.removeIf": [[34, 52]]}}}, {"text": "This utilizes the Map.merge method, which is very useful for this cases", "label": {"api": {"Map.merge": [[18, 26]]}}}, {"text": "Then for every parameter in which you expect values back (IN OUT and OUT), you must register the out parameter with the registerOutParameter method before you execute it with execute()", "label": {"api": {"the registerOutParameter method": [[116, 146]]}}}, {"text": "to quote remove's javadoc (bolding added for emphasis)", "label": {"api": {"remove's javadoc": [[9, 24]]}}}, {"text": "Any Node that you want to display should be set to the graphicProperty of the cell, if you want to display more than one nodes, you can set a container node (a Parent) as graphic and add the nodes to this parent", "label": {"api": {"graphicProperty": [[55, 69]]}}}, {"text": "Add an \"ActionListener\"  to the text field", "label": {"api": {"ActionListener": [[8, 21]]}}}, {"text": "For this query you need to have a collection property of type @OneToMany", "label": {"api": {"@OneToMany": [[62, 71]]}}}, {"text": "Also I had to use Tuple instead of TicketTuple (referenced in this answer) because it was giving an IllegalArgumentException (argument type mismatch) when dealing with ticket_actions without a ticket, I don't know if you have this kind of possibility in your schema", "label": {"api": {"Tuple": [[18, 22], [41, 45]]}}}, {"text": "Not familiar with ada but a quick google on ada rendezvous suggests you may be looking for one of the BlockingQueue implementations, possibly SynchronousQueue", "label": {"api": {"BlockingQueue": [[102, 114]], "SynchronousQueue": [[142, 157]]}}}, {"text": "This is a concise solution using the Stream class", "label": {"api": {"Stream": [[37, 42]]}}}, {"text": "Note that the result is of type Set", "label": {"api": {"Set": [[32, 34]]}}}, {"text": "If you need a List, you can use this", "label": {"api": {"List": [[14, 17]]}}}, {"text": "Most solutions using Set do not guarantee this because most of them are not sorted", "label": {"api": {"Set": [[21, 23]]}}}, {"text": "I would also recommend looking into this GitHub Gist which discusses using KeyEvents to prevent JavaFX from transferring focus when the Tab key is pressed and the JavaFX KeyCode documentation for some additional ideas and implementation details", "label": {"api": {"JavaFX KeyCode documentation": [[163, 190]]}}}, {"text": "You could make your RadioButtons not focusable", "label": {"api": {"not focusable": [[33, 45]]}}}, {"text": "You can handle the key-event by adding an event filter rather than an event handler to the Scene, and consume the event", "label": {"api": {"event filter": [[42, 53]], "consume the event": [[102, 118]]}}}, {"text": "You can use format to pad left each number with spaces", "label": {"api": {"format": [[12, 17]]}}}, {"text": "Here's the source code", "label": {"api": {"code": [[18, 21]]}}}, {"text": "From the MethodHandle documentation", "label": {"api": {"MethodHandle documentation": [[9, 34]]}}}, {"text": "From Oracle Documentation, it says that invokeExact method Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match", "label": {"api": {"Oracle Documentation": [[5, 24]]}}}, {"text": "I am using java.util.logging to generate log files", "label": {"api": {"java.util.logging": [[11, 27]]}}}, {"text": "In the other you can check if indexOf returns -1 indicating that the alphabet doesn't contain the character", "label": {"api": {"indexOf": [[30, 36]]}}}, {"text": "The Comparator class allows you to impose an order on a List very cleanly", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "Either use Math.pow() or code your own function to do that", "label": {"api": {"Math.pow()": [[11, 20]]}}}, {"text": "the method addLast returns void whereas the return type of recursiveReverse  is a LinkedList<T>, rather what you want is", "label": {"api": {"addLast": [[11, 17]]}}}, {"text": "HashMaps are an implementation of a Hash Table", "label": {"api": {"HashMaps": [[0, 7]]}}}, {"text": "In a sense, HashMaps are indexed and that is what enables their good performance", "label": {"api": {"HashMaps": [[12, 19]]}}}, {"text": "However, they are not indexed in the manner you could obtain an item from index and the HashMap class will not ensure that order is retained; you will need to use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[165, 177]]}}}, {"text": "The annotation are probably because how closely Java Object's equals and hashCode are tied together", "label": {"api": {"equals": [[62, 67]], "hashCode": [[73, 80]]}}}, {"text": "The HashSet(int) constructor allows you specify its initial capacity", "label": {"api": {"HashSet(int)": [[4, 15]]}}}, {"text": "If you want to initialize its elements, you'll need to use the HashSet(Colletion) constructor", "label": {"api": {"HashSet(Colletion)": [[63, 80]]}}}, {"text": "Java use 16-bit characters (see note in the documentation)", "label": {"api": {"note": [[32, 35]]}}}, {"text": "To determine if character is a part of surrogate pair use Chracter::isSurrogate() method", "label": {"api": {"Chracter::isSurrogate()": [[58, 80]]}}}, {"text": "I would use an AtomicReference with its compareAndSet method", "label": {"api": {"AtomicReference": [[15, 29]]}}}, {"text": "Please also refer to Concurrency in JavaFX and JavaDoc - Task for further information", "label": {"api": {"JavaDoc - Task": [[47, 60]]}}}, {"text": "You can do this with Java 8's new functional interfaces and method references", "label": {"api": {"functional interfaces": [[34, 54]]}}}, {"text": "Use String.indexOf(String, int)", "label": {"api": {"String.indexOf(String, int)": [[4, 30]]}}}, {"text": "Java supports a multitude of InputStreams and OutputStreams which make way for an entire world of possibilities, including file reading and writing", "label": {"api": {"InputStreams": [[29, 40]], "OutputStreams": [[46, 58]]}}}, {"text": "The basic method of writing a file  is using a FileOutputStream, which   writes raw bytes to a given file", "label": {"api": {"FileOutputStream": [[47, 62]]}}}, {"text": "There are some objects like the PrintStream which automatically get the  bytes of the given string (or parsed  string if an object is passed) and write them to the output stream", "label": {"api": {"PrintStream": [[32, 42]]}}}, {"text": "I don't know how constrained you are regarding memory usage, but if you can use a LinkedHashMap instead of a HashMap (LinkedHashMap uses extra references to keep insertion order), then you could take advantage of its removeEldestEntry method", "label": {"api": {"removeEldestEntry": [[217, 233]]}}}, {"text": "We are keeping a reference to the original key, which we grab from the removeEldestEntry method's argument", "label": {"api": {"removeEldestEntry": [[71, 87]]}}}, {"text": "As to the removeEldestEntry method's return value, it is false, so that we don't allow the eldest entry to be removed (after all, we don't want the map to work as a cache)", "label": {"api": {"removeEldestEntry": [[10, 26]]}}}, {"text": "Now, with a common insertion-order LinkedHashMap, the removeEldestEntry method is automatically called by put and putAll (from removeEldestEntry method docs)", "label": {"api": {"removeEldestEntry": [[54, 70], [127, 143]]}}}, {"text": "Classes as LocalDateTime from the package java.time are value based classes", "label": {"api": {"value based classes": [[56, 74]]}}}, {"text": "Look into ServerSocket or RMI is full blown solution if you need extensive communications", "label": {"api": {"ServerSocket": [[10, 21]]}}}, {"text": "Otherwise, if you want to adapt a Collector to perform an additional finishing transformation then you're looking for a collectingAndThen", "label": {"api": {"collectingAndThen": [[120, 136]]}}}, {"text": "But if your intention is to create different storage space then you can use List<List<String>>(as mentioned already) and can access each element using get() method", "label": {"api": {"get() method": [[151, 162]]}}}, {"text": "Java 9 has a feature to support that - takeWhile", "label": {"api": {"takeWhile": [[39, 47]]}}}, {"text": "A java.util.Properties instance's attributes are directly addressable, e.g", "label": {"api": {"java.util.Properties": [[2, 21]]}}}, {"text": "Just use the usual properties format", "label": {"api": {"properties format": [[19, 35]]}}}, {"text": "The properties format allows continuation onto multiple lines", "label": {"api": {"properties format": [[4, 20]]}}}, {"text": "Iterator in an interface, and you need to implement each of the Iterator methods in MyIterator that you intend to call", "label": {"api": {"Iterator": [[0, 7], [64, 71], [86, 93]]}}}, {"text": "Looks like you can access keystores via an instance of java.security.KeyStore", "label": {"api": {"java.security.KeyStore": [[55, 76]]}}}, {"text": "You pass it a FileVisitor (usually a subclass of SimpleFileVisitor), each of whose methods can return a FileVisitResult", "label": {"api": {"FileVisitResult": [[104, 118]]}}}, {"text": "To skip a directory, simply return FileVisitResult.SKIP_SUBTREE", "label": {"api": {"FileVisitResult": [[35, 49]]}}}, {"text": "The Path class is the modern replacement for the obsolete File class", "label": {"api": {"Path": [[4, 7]]}}}, {"text": "If you absolutely need a File object, Path has a toFile() method", "label": {"api": {"Path": [[38, 41]]}}}, {"text": "Conversely, File has a toPath() method", "label": {"api": {"Path": [[25, 28]]}}}, {"text": "Otherwise, in theory you could just use a variant of String.getBytes() to get an array of bytes, and wrap the result into the mentioned (in the other answer) streams", "label": {"api": {"String.getBytes()": [[53, 69]]}}}, {"text": "Alternatively, you could just subclass Transition (this is a simple adaptation of the example in the docs)", "label": {"api": {"Transition": [[39, 48]]}}}, {"text": "as thrown by ArrayList, is not guaranteed to be thrown", "label": {"api": {"ArrayList": [[13, 21]]}}}, {"text": "The easiest solution would be to simply install a java.util.logging.ConsoleHandler on the root logger of your myproject", "label": {"api": {"install": [[40, 46]], "java.util.logging.ConsoleHandler": [[50, 81]]}}}, {"text": "Otherwise you can create a ServletContextListener and install a custom handler on the root logger of your project which formats and logs to the ServletContext.log methods", "label": {"api": {"install": [[54, 60]], "ServletContextListener": [[27, 48]], "ServletContext.log methods": [[144, 169]]}}}, {"text": "You can define a messageHandler property in your ButtonPane; something that handles a message simply has to \"do something with a String\", so it doesn't need to be specific to the LogPane, it can just be a Consumer<String>", "label": {"api": {"Consumer<String>": [[205, 220]]}}}, {"text": "The reason for that is the flatMap operation also being an intermediate operations with which (one of) the stateful short-circuiting intermediate operation takeWhile is used", "label": {"api": {"flatMap": [[27, 33]], "intermediate operations": [[59, 81]], "takeWhile": [[156, 164]]}}}, {"text": "The behavior of flatMap as pointed by Holger in this answer is certainly a reference one shouldn't miss out to understand the unexpected output for such short-circuiting operations", "label": {"api": {"flatMap": [[16, 22]]}}}, {"text": "Your expected result can be achieved by splitting these two intermediate operations by introducing a terminal operation to deterministically use an ordered stream further and performing them for a sample as", "label": {"api": {"intermediate operations": [[60, 82]]}}}, {"text": "Files.walkFileTree and the other methods of Files can do it", "label": {"api": {"Files.walkFileTree": [[0, 17]]}}}, {"text": "To prevent such exception you'll want to use OrElse to return the value if present else a provide a default value", "label": {"api": {"OrElse": [[45, 50]]}}}, {"text": "Obviously, Optional.get() is there for a reason but it's a mistake by the API designers and hence I'd recommend you always use orElse or orElseGet depending on the situation", "label": {"api": {"orElse": [[127, 132], [137, 142]], "orElseGet": [[137, 145]]}}}, {"text": "JTextArea has several constructors", "label": {"api": {"JTextArea": [[0, 8]]}}}, {"text": "textArea = new JTextArea(5, 20); See How to Use Text Areas for more details and examples", "label": {"api": {"JTextArea": [[15, 23]]}}}, {"text": "id is an Object and there is no getText() method in the Object class of the API", "label": {"api": {"Object": [[9, 14], [56, 61]]}}}, {"text": "Panes and Nodes aren't Windows, so trying to get an hwnd specific node doesn't seem to make a lot of sense", "label": {"api": {"Windows": [[23, 29]]}}}, {"text": "First of all, worth to mention that finalizers were deprecated in Java 9 in favour of the Cleaner", "label": {"api": {"Cleaner": [[90, 96]]}}}, {"text": "I would forego the JavaFX print package, and use JPS, specifically the DocFlavor.STRING.TEXT_PLAIN flavor", "label": {"api": {"DocFlavor.STRING.TEXT_PLAIN": [[71, 97]]}}}, {"text": "Use getResourceAsStream and the other Font.createFont method instead", "label": {"api": {"other Font.createFont method": [[32, 59]]}}}, {"text": "The Javadocs state that this will only happen if an input/output error occurs while getting user input", "label": {"api": {"The Javadocs state that this will only happen if an input/output error occurs": [[0, 76]]}}}, {"text": "You would be better off using a StringBuilder object, and calling its append method inside the loop", "label": {"api": {"StringBuilder": [[32, 44]]}}}, {"text": "You can, however, do a lookup to get the viewport from a CSS selector", "label": {"api": {"lookup": [[23, 28]]}}}, {"text": "You can use Collections#frequency to get the occurrences, and map the the object accordingly", "label": {"api": {"Collections#frequency": [[12, 32]]}}}, {"text": "If you want  to access the contends in descending order, you can use make a comparator that is opposite of Integer#compare", "label": {"api": {"Integer#compare": [[107, 121]]}}}, {"text": "If you do not wish to stream your key set (say you are accessing at different lines), you can use an Iterator instead", "label": {"api": {"Iterator": [[101, 108]]}}}, {"text": "Sure you can - the below should do the trick, using the forEach method of Stream", "label": {"api": {"forEach": [[56, 62]]}}}, {"text": "Also bear in mind that reaaaaally, for this, you should use forEachOrdered instead of forEach - forEach doesn't guarantee the order in which the items are processed, and for parallel streams this matters", "label": {"api": {"forEach": [[60, 66], [86, 92], [96, 102]], "forEachOrdered": [[60, 73]]}}}, {"text": "forEachOrdered guarantees that items are processed one-by-one", "label": {"api": {"forEach": [[0, 6]], "forEachOrdered": [[0, 13]]}}}, {"text": "You can omit the call to Stream, depending on your container - if it implements Iterable (most standard containers do), then you should use forEach on that rather than the stream (so contactos.forEach(...)", "label": {"api": {"forEach": [[140, 146], [193, 199]], "Iterable": [[80, 87]]}}}, {"text": "You also avoid the forEachOrdered issue above, as the items are processed \"in iteration order\"", "label": {"api": {"forEach": [[19, 25]], "forEachOrdered": [[19, 32]]}}}, {"text": "If you really want to do this with a single method, you could leverage the userData of the button; i.e.", "label": {"api": {"userData": [[75, 82]]}}}, {"text": "To insert List on JDBC you need to use loop, and call addBatch()", "label": {"api": {"addBatch()": [[54, 63]]}}}, {"text": "I noticed that you use Zero-width joiner(\\u200D) character to join emojis, you can split your String by this character", "label": {"api": {"split": [[83, 87]]}}}, {"text": "As written in Class.newInstance() documentation, InstantiationException is thrown if the class has no nullary constructor", "label": {"api": {"Class.newInstance() documentation": [[14, 46]]}}}, {"text": "One option is to limit yourself to Comparable", "label": {"api": {"Comparable": [[35, 44]]}}}, {"text": "Alternatively, you can allow the caller to supply their own Comparator", "label": {"api": {"Comparator": [[60, 69]]}}}, {"text": "Just read the version directly, using a jar URL", "label": {"api": {"jar URL": [[40, 46]]}}}, {"text": "If you’re reading the version from the .jar file’s manifest, you can just use a JarInputStream instead of a JarFile", "label": {"api": {"JarInputStream": [[80, 93]]}}}, {"text": "This will achieve what you desire if you are content with using ArrayLists", "label": {"api": {"ArrayLists": [[64, 73]]}}}, {"text": "Collections is a helpful Class that you can use to shuffle the list", "label": {"api": {"Collections": [[0, 10]]}}}, {"text": "You achieve what you are wanting to do, use a DefaultListModel", "label": {"api": {"DefaultListModel": [[46, 61]]}}}, {"text": "Use FileHandler(String, boolean) to construct your FileHandler, passing true for the append parameter", "label": {"api": {"FileHandler(String, boolean)": [[4, 31]]}}}, {"text": "Also, you must call the next() method on your result set to jump to the first row in the result set", "label": {"api": {"next()": [[24, 29]]}}}, {"text": "With additional next() calls you get to the following rows until you reach the end of the result set", "label": {"api": {"next()": [[16, 21]]}}}, {"text": "Don't use statement like this, it can cause syntax errors or SQL Injection instead use PreparedStatement", "label": {"api": {"PreparedStatement": [[87, 103]]}}}, {"text": "I wonder if there is a more elegant way to do this without a for-loop - maybe with Java 8 Stream", "label": {"api": {"Java 8 Stream": [[83, 95]]}}}, {"text": "you can use an IntStream.range to generate the indices and then operate on that", "label": {"api": {"IntStream.range": [[15, 29]]}}}, {"text": "You can use Arrays.setAll method", "label": {"api": {"Arrays.setAll": [[12, 24]]}}}, {"text": "You don't need to implement this behavior yourself - just use the built-in Collectors#groupingBy", "label": {"api": {"Collectors#groupingBy": [[75, 95]]}}}, {"text": "I recommend using a StringBuilder to store characters as you generate them", "label": {"api": {"StringBuilder": [[20, 32]]}}}, {"text": "Do not use Lists if you don't want duplicates", "label": {"api": {"List": [[11, 14]]}}}, {"text": "Look at the source code of List.contains if you're curious", "label": {"api": {"List": [[27, 30]]}}}, {"text": "The getContentType() method simpy", "label": {"api": {"getContentType()": [[4, 19]]}}}, {"text": "It uses a Scanner to take a users input", "label": {"api": {"Scanner": [[10, 16]]}}}, {"text": "NIO supports interruptible I/O, via InterruptibleChannel, although only in the rather useless way that the channel gets closed, due to the ludicrous Linux interrupt semantics", "label": {"api": {"InterruptibleChannel": [[36, 55]]}}}, {"text": "All you have to do is specify your User-Agent property using the URLConnection#setRequestProperty method", "label": {"api": {"URLConnection#setRequestProperty": [[65, 96]]}}}, {"text": "For an unnamed module, my guess is that you cannot retrieve a ModuleReference for it, but at least one can try calling configuration().modules() and see if they include an unnamed module", "label": {"api": {" configuration().modules()": [[118, 143]]}}}, {"text": "This is perfect for Optional", "label": {"api": {"Optional": [[20, 27]]}}}, {"text": "First, make a helper method to convert each of the possibly-blank fields to an Optional<String>", "label": {"api": {"Optional": [[79, 86]]}}}, {"text": "Then, I came upon the ForkJoinPool used in the standard way by using the CompletableFuture class when doing something like this", "label": {"api": {"ForkJoinPool": [[22, 33]]}}}, {"text": "In most tutorials and the Javadoc, the ForkJoinPool is described as \"a pool which contains threads waiting for tasks to run\"", "label": {"api": {"ForkJoinPool": [[39, 50]]}}}, {"text": "Also, the ForkJoinPool is usually the size of the cores of the users machine, or doubled if hyperthreading is supported", "label": {"api": {"ForkJoinPool": [[10, 21]]}}}, {"text": "What advantages does the ForkJoinPool give me over the traditional Thread when I want to run a task asynchronously", "label": {"api": {"ForkJoinPool": [[25, 36]]}}}, {"text": "You are violating every rule of a Comparator, but let's cut it down to size", "label": {"api": {"Comparator": [[34, 43]]}}}, {"text": "A Comparator must have no side-effects", "label": {"api": {"Comparator": [[2, 11]]}}}, {"text": "The ordering of a PriorityQueue is established as elements are added", "label": {"api": {"PriorityQueue": [[18, 30]]}}}, {"text": "Using the List API we can leverage the subList method as well as the addAll method to modify a particular section of a list and insert elements into a list at the specified position", "label": {"api": {"subList": [[39, 45]], "addAll": [[69, 74]]}}}, {"text": "Along with that, we utilise the String replace method to remove the redundant string representation of a list and finally convert the accumulator list into an array of strings", "label": {"api": {"replace": [[39, 45]]}}}, {"text": "You can use scanner.nextInt() method, it will take care of new line and space character", "label": {"api": {"method": [[30, 35]]}}}, {"text": "It was replaced years ago by Path and other classes in the java.nio.file package, like Files and Paths", "label": {"api": {"Path": [[29, 32], [97, 100]], "java.nio.file package": [[59, 79]]}}}, {"text": "For comparing the numeric part of a filename, you will need to write your own Comparator", "label": {"api": {"Comparator": [[78, 87]]}}}, {"text": "Scanner#next can never return null and if the user enters an empty string or a string containing whitespaces only then the method will block and wait for input to scan", "label": {"api": {"Scanner#next": [[0, 11]]}}}, {"text": "Instead of a busy wait loop use a WatchService on directory entries changing", "label": {"api": {"WatchService": [[34, 45]]}}}, {"text": "you can use IntStream.rangeClosed to generate the numbers and collect into a list", "label": {"api": {"IntStream.rangeClosed": [[12, 32]]}}}, {"text": "To center the text within the JLabel, use a constructor that specifies the horizontal alignment of the text it displays", "label": {"api": {"constructor": [[44, 54]]}}}, {"text": "Three of the six constructors accept an alignment", "label": {"api": {"constructor": [[17, 27]]}}}, {"text": "Note the javadoc for beforeExecute", "label": {"api": {"javadoc for beforeExecute": [[9, 33]]}}}, {"text": "Otherwise, the CompletableFuture completes exceptionally, which you can handle with its exceptionally method", "label": {"api": {"exceptionally": [[43, 55], [88, 100]]}}}, {"text": "You can use Objects.equals() for a null-safe compare", "label": {"api": {"Objects.equals()": [[12, 27]]}}}, {"text": "One is the call to Thread.start() by what will be the last thread entering the barrier, which happens-before any action in the started thread", "label": {"api": {"the last thread entering the barrier": [[50, 85]]}}}, {"text": "Then there is the actual call to CylicBarrier.await(), which happen[s]-before actions that are part of the barrier action", "label": {"api": {"happen[s]-before actions that are part of the barrier action": [[61, 120]]}}}, {"text": "See full Javadoc to learn what you can do with org.w3c.dom.Node", "label": {"api": {"full Javadoc": [[4, 15]]}}}, {"text": "Given your constraints, you can use the java.util.logging.FileHandler instead of the org.apache.juli.AsyncFileHandler", "label": {"api": {"java.util.logging.FileHandler": [[40, 68]]}}}, {"text": "I'm looking for an implemented class (in Java) which handles insertion, replacement and deletion of text for an existing file, just like StringBuilder does", "label": {"api": {"StringBuilder": [[137, 149]]}}}, {"text": "The reason I do not want to use a StringBuilder is that I want to avoid having all the file content in memory", "label": {"api": {"StringBuilder": [[34, 46]]}}}, {"text": "How do I configure these microservices to validate the token and insert a Principal in controller methods", "label": {"api": {"Principal": [[74, 82]]}}}, {"text": "The builder's appendValueReduced() method was designed to handle this case", "label": {"api": {"appendValueReduced()": [[14, 33]]}}}, {"text": "I am trying to get my .classpath file as an InputStream or File", "label": {"api": {"InputStream": [[44, 54]], "File": [[59, 62]]}}}, {"text": "If I have a class in the default package, I can simply use getResourceAsStream(\".classpath\")", "label": {"api": {"getResourceAsStream(\".classpath\")": [[59, 91]]}}}, {"text": "I attempted using the environment variable CLASSPATH, but that gave me the path to a nonexistent file (C:\\Program Files (x86)\\QuickTime\\QTSystem\\QTJava.zip)", "label": {"api": {"File": [[114, 117]]}}}, {"text": "I feel that there might be way which uses ClassLoader, but I can not find any such methods", "label": {"api": {"ClassLoader": [[42, 52]]}}}, {"text": "You also need to use the proper method for getting the selected text, such as JComboBox#getSelectedItem()", "label": {"api": {"JComboBox#getSelectedItem()": [[78, 104]]}}}, {"text": "As noted in the comments, this is only the case for the original Java date/time classes (java.util.Date, java.util.Calendar, ...)", "label": {"api": {"java.util.Date": [[89, 102]], "java.util.Calendar": [[105, 122]]}}}, {"text": "For classes in the (preferred) new date/time API that was introduced in Java 8 (java.time.LocalDate, ...), this behavior was changed to be more intuitive", "label": {"api": {"java.time.LocalDate": [[80, 98]]}}}, {"text": "You can only query the parser for a possible leap second flag", "label": {"api": {"query the parser": [[13, 28]]}}}, {"text": "I can not find anywhere that specificity explain what can be store inside of String[] cmdarray of Process exec(String[] cmdarray) method", "label": {"api": {"Process exec(String[] cmdarray)": [[98, 128]]}}}, {"text": "Call Arrays.sort on your data array before searching", "label": {"api": {"Arrays.sort": [[5, 15]]}}}, {"text": "Every thread instance has a ThreadGroup within it", "label": {"api": {"ThreadGroup": [[28, 38]]}}}, {"text": "Using this information, we can apply the ThreadGroup#parentOf(ThreadGroup) method to check if the current thread is the parent of the given thread", "label": {"api": {"ThreadGroup": [[41, 51], [62, 72]], "ThreadGroup#parentOf(ThreadGroup)": [[41, 73]]}}}, {"text": "You can also play around a bit with ThreadUtils.getAllThreadGroups() if you happen to have Appache commons lang on your build path", "label": {"api": {"ThreadGroup": [[54, 64]]}}}, {"text": "Yes, computeIfAbsent() is appropriate here", "label": {"api": {"computeIfAbsent": [[5, 19]]}}}, {"text": "extends Map<String, Properties>>, as per the documentation of computeIfAbsent", "label": {"api": {"computeIfAbsent": [[62, 76]]}}}, {"text": "You can use computeIfAbsent, but since you can't throw a checked exception from a Function<...> you'd have to put the try catch inside the lambda you pass to computeIfAbsent", "label": {"api": {"computeIfAbsent": [[12, 26], [158, 172]]}}}, {"text": "Returning null tells computeIfAbsent that no mapping should be made", "label": {"api": {"computeIfAbsent": [[21, 35]]}}}, {"text": "ModuleLayer Javadoc has an example just in the end of the class documentation", "label": {"api": {"ModuleLayer": [[0, 10]]}}}, {"text": "One way I could think of to get to know the names of the module present in a directory is via ModuleFinder.findAll() method", "label": {"api": {"ModuleFinder.findAll()": [[94, 115]]}}}, {"text": "Another way could be to make use of the ToolProvider and tweak the output stream to be able to store just the module name from", "label": {"api": {"ToolProvider": [[40, 51]]}}}, {"text": "Just use String.join to concatenate every String separated by the CharSequence you want (here a space) instead of that for loop", "label": {"api": {"String.join": [[9, 19]]}}}, {"text": "The documentation for the Scanner class has more detailed examples", "label": {"api": {"documentation for the Scanner class": [[4, 38]]}}}, {"text": "You can do it by using Map.computeIfAbsent in the outer map, along with Map.merge in the inner maps", "label": {"api": {"Map.computeIfAbsent": [[23, 41]], "Map.merge": [[72, 80]]}}}]