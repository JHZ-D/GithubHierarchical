[{"text":"You could use a ScheduledExecutorService for this","label":{"api":{"ScheduledExecutorService":[[16,39]]}}},{"text":"ReentrantLock or Semaphore could be used to ensure only one thread is refreshing the token","label":{"api":{"ReentrantLock":[[0,12]]}}},{"text":"The Java documentation regarding Character is pretty lengthy  and offers a lot of information regarding this subject","label":{"api":{}}},{"text":"You can use Class.getResourceAsStream or ClassLoader.getResourceAsStream; each will give return an InputStream for the resource","label":{"api":{"Class.getResourceAsStream":[[12,36]],"ClassLoader.getResourceAsStream":[[41,71]],"InputStream":[[99,109]]}}},{"text":"You will have to use BigInteger","label":{"api":{"BigInteger":[[21,30]]}}},{"text":"you will  need to use the predefined methods in the BigInteger class","label":{"api":{}}},{"text":"java.lang.OutOfMemoryError inherits from java.lang.Error which its documentation says","label":{"api":{"java.lang.OutOfMemoryError":[[0,25]],"java.lang.Error":[[41,55]]}}},{"text":"I want to create a memoized version of a given Supplier such that multiple threads can use it concurrently with the guarantee that the original supplier's get() is called at most once, and that all of the threads see that same result","label":{"api":{"Supplier":[[47,54]],"get()":[[155,159]]}}},{"text":"You're comparing the index of last character in the string to the required character, instead of the last character itself, which you can access with charAt","label":{"api":{"charAt":[[150,155]]}}},{"text":"create an init method in userService class, annotated with @PostConstruct","label":{"api":{"@PostConstruct":[[59,72]]}}},{"text":"Method annotated with @PostConstruct cannot have any arguments and is guaranteed to be started after class initialization (including dependency injections) and before the class is used","label":{"api":{"@PostConstruct":[[22,35]]}}},{"text":"I doubt that your second attempt (import java.util.stream;) works","label":{"api":{"java.util.stream":[[41,56]]}}},{"text":"Maybe you wanted to import java.util.stream.*;","label":{"api":{"java.util.stream.*":[[27,44]]}}},{"text":"Thus with an import java.util.*, you import classes like ArrayList, LinkedList and Random","label":{"api":{"java.util.*":[[20,30]],"ArrayList":[[57,65]],"LinkedList":[[68,77]],"Random":[[83,88]]}}},{"text":"The class Stream actually resides in the sub-package java.util.stream package and is not imported when you import java.util.*;","label":{"api":{"java.util.stream":[[53,68]],"java.util.*":[[114,124]]}}},{"text":"To import Stream, you can either import java.util.stream.*; (all classes within this package) or only import java.util.stream.Stream; (the FQDN of the class you need)","label":{"api":{"java.util.stream.*":[[40,57]],"java.util.stream.Stream":[[109,131]]}}},{"text":"In Java, you may implement a custom replacement logic using Matcher#appendReplacement() and just trim() the matcher.group(2) value","label":{"api":{"Matcher#appendReplacement()":[[60,86]],"trim()":[[97,102]],"matcher.group(2)":[[108,123]]}}},{"text":"Just pass a message when creating the RuntimeException","label":{"api":{"RuntimeException":[[38,53]]}}},{"text":"On the other hand you could have an Abstract Factory looking up \"real\" factories using javas ServiceLoader","label":{"api":{"ServiceLoader":[[93,105]]}}},{"text":"LocalDateTime::toString omits parts if zero","label":{"api":{"LocalDateTime::toString":[[0,22]]}}},{"text":"Use LocalDateTime::format instead of relying on toString()","label":{"api":{"LocalDateTime::format":[[4,24]],"toString()":[[48,57]]}}},{"text":"The Javadoc for Stream#forEach says","label":{"api":{"The Javadoc for Stream#forEach":[[0,29]]}}},{"text":"I know that if the code were using .parallelStream() instead of .stream() that it wouldn't be guaranteed to work, but since it is using a sequential stream (which the Javadoc doesn't say anything about), I'm not sure","label":{"api":{".parallelStream()":[[35,51]],".stream()":[[64,72]]}}},{"text":"Is this guaranteed to always work, or would that code need to be using .forEachOrdered() instead of .forEach() for it to be","label":{"api":{".forEachOrdered()":[[71,87]],".forEach()":[[100,109]]}}},{"text":"Or the Optional class","label":{"api":{}}},{"text":"Check the API of the nextInt method","label":{"api":{"API of the nextInt method":[[10,34]]}}},{"text":"Also there are some utilities in the Java standard library, such as Objects.requireNonNull()","label":{"api":{"Objects.requireNonNull()":[[68,91]]}}},{"text":"Calling submit(Callable) calls newTaskFor(), which returns a Runnable calling the Callable","label":{"api":{"submit(Callable)":[[8,23]],"newTaskFor()":[[31,42]]}}},{"text":"And that Runnable is then passed to execute()","label":{"api":{"execute()":[[36,44]]}}},{"text":"You cannot create a CharStream with  Arrays.stream(outputTwoChits)  as there is no overload in the Arrays class that takes a char[] and returns a CharStream (infact there is no CharStream at all) and doing Stream.of(outputTwoChits) would not provide what you'd expect in this particular case","label":{"api":{"Arrays.stream(outputTwoChits)":[[37,65]],"Arrays":[[99,104]],"CharStream":[[146,155]],"Stream.of(outputTwoChits)":[[206,230]]}}},{"text":"You can use the static method IntStream.range() which can be used as follows to create a Stream of indices and then use them to map the values in the charArray to a Character-stream","label":{"api":{"IntStream.range()":[[30,46]],"charArray":[[150,158]]}}},{"text":"From your code, it looks as though the way this works is that the selectedItem declares a dependency on the selectedIndex","label":{"api":{"selectedItem":[[66,77]],"selectedIndex":[[108,120]]}}},{"text":"When the user selects something, the selectedIndex is set directly (invalidating it and changing it), which causes the selectedItem to become invalid","label":{"api":{"selectedIndex":[[37,49]],"selectedItem":[[119,130]]}}},{"text":"However, the selectedItem is not explicitly changed until it is recomputed","label":{"api":{"selectedItem":[[13,24]]}}},{"text":"Finally, note that for multiple selection, the selectedItem and selectedIndex properties only reference the last selection","label":{"api":{"selectedItem":[[47,58]],"selectedIndex":[[64,76]]}}},{"text":"See the Javadocs for Observable and ObservableValue for more information on the difference between InvalidationListener and ChangeListener","label":{"api":{"Javadocs for Observable":[[8,30]],"ObservableValue":[[36,50]],"InvalidationListener":[[99,118]],"ChangeListener":[[124,137]]}}},{"text":"MimetypesFileTypeMap, but I found this useful class MimeTypes and I did a little trick adding an extensions Mapping like @Mindaugas Bernataviƒçius said, remember this return the default extension by MimeType but can be inaccurate","label":{"api":{"MimetypesFileTypeMap":[[0,19]],"MimeTypes":[[52,60]],"MimeType":[[198,205]]}}},{"text":"In Java, you can use the same regular expression and use the Java Regex API to find the match","label":{"api":{"Java Regex API":[[61,74]]}}},{"text":"A slightly more verbose - but generic-compatible way - of doing it is to extend AbstractList","label":{"api":{"AbstractList":[[80,91]]}}},{"text":"But if you work with an 8 bit 8859 encoding on the C++ side,  you should on the java side open the stream with the same encoding by using the appropriate charset parameter when opening the stream","label":{"api":{"appropriate charset":[[142,160]]}}},{"text":"Integer.TYPE is \"The Class instance representing the primitive type int.\" int has no constructors","label":{"api":{"Integer.TYPE":[[0,11]]}}},{"text":"You have to use nextLine to read the full line after a wrong input is given","label":{"api":{"nextLine":[[16,23]]}}},{"text":"setFloat throws NullPointerException because it expects primitive float and not a Float object","label":{"api":{"setFloat":[[0,7]],"NullPointerException":[[16,35]]}}},{"text":"You can try using setObject method instead - it allows using null values if needed","label":{"api":{"setObject":[[18,26]]}}},{"text":"java.lang.Character may conflict","label":{"api":{"java.lang.Character":[[0,18]]}}},{"text":"java.lang is always automatically imported so you have two classes with the same name that are conflicting","label":{"api":{"java.lang":[[0,8]]}}},{"text":"It's good practice to avoid using any class names that are already present in java.lang for that reason","label":{"api":{"java.lang":[[78,86]]}}},{"text":"I'd say, use a generic method, combined with the functional interfaces introduced in Java 8","label":{"api":{"functional interfaces":[[49,69]]}}},{"text":"You could stream the array, and filter using String::contains","label":{"api":{"String::contains":[[45,60]]}}},{"text":"From the Java API \"The class Date represents a specific instant in time, with millisecond precision.\" When you create a Date you automatically get a date with a time","label":{"api":{"\"The class Date represents a specific instant in time, with millisecond precision.\"":[[18,100]]}}},{"text":"We utilise the Stream::anyMatch method to search through the arrays and find any matching array with Arrays::equals","label":{"api":{"Stream::anyMatch":[[15,30]],"Arrays::equals":[[101,114]]}}},{"text":"Explicit output such as PrintStream#println and Throwable#printStackTrace is printed as expected, but when runtime exceptions such as ArrayIndexOutOfBoundsException are thrown which naturally are not caught and thus not explicitly printed, nothing is printed","label":{"api":{"PrintStream#println":[[24,42]],"Throwable#printStackTrace":[[48,72]],"ArrayIndexOutOfBoundsException":[[134,163]]}}},{"text":"I want to, for the development of a new Blocking Queue be able to know the thread origin of an object being used in the queue","label":{"api":{"new Blocking Queue":[[36,53]]}}},{"text":"Since the introduction of functional interfaces and method references in Java 8, there are hardly any duplicate code parts that cannot be avoided","label":{"api":{"functional interfaces":[[26,46]]}}},{"text":"You can use a Phaser to accomplish this","label":{"api":{"Phaser":[[14,19]]}}},{"text":"In Account, you need a method like this, using AtomicInteger.compareAndSet","label":{"api":{"AtomicInteger.compareAndSet":[[47,73]]}}},{"text":"The ClassCastException means the object is not an instance of AuthUserInfo, it could be wrapper or some 'Unknown' object","label":{"api":{"ClassCastException":[[4,21]],"AuthUserInfo":[[62,73]]}}},{"text":"In your custom authentication LoginModule implementation, where you have this ClassCastException, add the below  line before casting","label":{"api":{"LoginModule":[[30,40]],"ClassCastException":[[78,95]]}}},{"text":"You can use SimpleDateFormat class for parsing date","label":{"api":{"SimpleDateFormat":[[12,27]]}}},{"text":"I formed a key extractor by combining two functions Entity::getSubEntity and SubEntity::getAmount with Function#andThen","label":{"api":{"Entity::getSubEntity":[[52,71]],"SubEntity::getAmount":[[77,96]],"Function#andThen":[[103,118]]}}},{"text":"You can do it with a BiFunction","label":{"api":{"BiFunction":[[21,30]]}}},{"text":"Using the Persistence API's Query object, I am constructing the following query","label":{"api":{"Persistence API's Query object":[[10,39]]}}},{"text":"For Java, there is only workaround with :arg0 until annotation like NamedArg will be added to Room","label":{"api":{"NamedArg":[[68,75]]}}},{"text":"When playing a video using MediaPlayer and MediaView in JavaFX, when the player reaches the end of the video, the status of the player remains in PLAYING and this is documented on MediaPlayer.Status","label":{"api":{"MediaPlayer.Status":[[180,197]]}}},{"text":"You'll need Long::intValue rather than Long::valueOf as this function returns a Long type not int","label":{"api":{"Long::intValue":[[12,25]],"Long::valueOf":[[39,51]]}}},{"text":"Another approach using CountDownLatch","label":{"api":{"CountDownLatch":[[23,36]]}}},{"text":"You should consider using ProcessBuilder instead of Runtime exec","label":{"api":{"ProcessBuilder":[[26,39]]}}},{"text":"It uses the draw(Shape) method of Graphics2D for convenience, so that you can directly store Shape objects when reading the file","label":{"api":{"draw(Shape)":[[12,22]]}}},{"text":"Maybe ReadWriteLock is good for you","label":{"api":{"ReadWriteLock":[[6,18]]}}},{"text":"A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing","label":{"api":{"ReadWriteLock":[[2,14]]}}},{"text":"Have a look at SSLContext.init()","label":{"api":{"SSLContext.init()":[[15,31]]}}},{"text":"According to what you're telling, sounds like a concurrent queue instead of the HashMap(like LinkedBlockingQueue or (which I think it would work better) ConcurrentLinkedQueue) fit best there","label":{"api":{"LinkedBlockingQueue":[[93,111]],"ConcurrentLinkedQueue":[[153,173]]}}},{"text":"In the case of Java 8, this is https://docs.oracle.com/javase/8/docs/api/ for all of them","label":{"api":{"https://docs.oracle.com/javase/8/docs/api/":[[31,72]]}}}]