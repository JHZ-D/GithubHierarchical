[{"text":"Your generic type has a common base class - Comparable, therefore you can directly call the compareTo method on the objects and they should invoke that method to get the comparison result","label":{"api":{"Comparable":[[44,53]],"compareTo":[[92,100]]}}},{"text":"In general, I think creating controls by extending Control and using the inbuilt SkinBase class, is overkill for most apps","label":{"api":{"Control":[[51,57]],"SkinBase":[[81,88]]}}},{"text":"BufferedReader#readLine(0) treats '\\n', '\\r', and \"\\r\\n\" as line-separators","label":{"api":{"BufferedReader#readLine(0)":[[0,25]]}}},{"text":"I suspect that you want the read(char[] cbuf, int off, int len) method","label":{"api":{"read(char[] cbuf, int off, int len)":[[28,62]]}}},{"text":"On a last side note, java has an in-built TimeUnit enum, which can do these conversions, too","label":{"api":{"TimeUnit":[[42,49]]}}},{"text":"Thread#toString() returns \"a string representation of this thread, including the thread's name, priority, and thread group\"","label":{"api":{"Thread#toString()":[[0,16]]}}},{"text":"If not specified at thread creation time, the value of SecurityManager.getThreadGroup() is used, which by default is the current thread's thread group","label":{"api":{"SecurityManager.getThreadGroup()":[[55,86]]}}},{"text":"Due to the fact that Document implements the Map interface, that means it also inherits the default forEach method which takes a BiConsumer as a parameter","label":{"api":{"Map":[[45,47]],"forEach":[[100,106]],"BiConsumer":[[129,138]]}}},{"text":"Joda is not supported you have to use java.util.Date instead, so if you already use Joda or java.time library of Java 8 you have to convert it to java.util.Date in your case you can use","label":{"api":{"java.util.Date":[[38,51],[146,159]],"java.time":[[92,100]]}}},{"text":"But in your case converting org.joda.time.DateTime to java.util.Date not make any sense you can directly use java.util.Date","label":{"api":{"org.joda.time.DateTime":[[28,49]],"java.util.Date":[[54,67],[109,122]]}}},{"text":"You can use String::matches with a regex (\\d)\\1* like this","label":{"api":{"String::matches":[[12,26]]}}},{"text":"Your text file looks like tab delimited, you could read each line using BufferedReader and extract third column each time","label":{"api":{"BufferedReader":[[72,85]]}}},{"text":"If you are using Java 8+, You can use java.time.LocalDateTime  (or Instant...) instead of java.util.Date, which is incredibly easy","label":{"api":{"java.time.LocalDateTime":[[38,60]],"Instant":[[67,73]],"java.util.Date":[[90,103]]}}},{"text":"The format of versions is defined in ModuleDescriptor.Version API","label":{"api":{"ModuleDescriptor.Version":[[37,60]]}}},{"text":"The ThreadLocalRandom class was introduced in jdk 1.7","label":{"api":{"ThreadLocalRandom":[[4,20]]}}},{"text":"Each ForkJoinPool has a configured target parallelism","label":{"api":{"ForkJoinPool":[[5,16]],"parallelism":[[42,52]]}}},{"text":"if a worker thread is going to wait via a ManagedBlocker, the pool may start even more threads to compensate","label":{"api":{"ManagedBlocker":[[42,55]]}}},{"text":"The parallelism of the commonPool defaults to “number of CPU cores minus one”, so when incorporating the initiating non-pool thread as helper, the resulting parallelism will utilize all CPU cores","label":{"api":{"parallelism":[[4,14],[157,167]],"commonPool":[[23,32]]}}},{"text":"Therefore, you may use ForkJoinTask.getSurplusQueuedTaskCount() to get the current number of pending jobs that are unlikely to be stolen by other threads and split only when it is below a small threshold","label":{"api":{"ForkJoinTask.getSurplusQueuedTaskCount()":[[23,62]]}}},{"text":"You can stream your original list of objects, and then use the groupingBy collector","label":{"api":{"groupingBy":[[63,72]]}}},{"text":"First is to have recursive class structure, but you already have that with JSONObject","label":{"api":{"JSONObject":[[75,84]]}}},{"text":"To read in an image, use ImageIO","label":{"api":{"ImageIO":[[25,31]]}}},{"text":"HashMap need to allocate array of sufficient size in order to minimize hash collisions - it can happen that two or more objects that are not equal have the same hash code - probability of such situation depends on quality of hash function","label":{"api":{"HashMap":[[0,6]]}}},{"text":"However, you can use TreeMap which stores entries in tree structure that creates only such a number of nodes that is equal to number of entries i","label":{"api":{"TreeMap":[[21,27]]}}},{"text":"HashMap has complexity O(1), while TreeMap has complexity O(log n)","label":{"api":{"HashMap":[[0,6]],"TreeMap":[[35,41]]}}},{"text":"The argument for split is a regex","label":{"api":{"split":[[17,21]]}}},{"text":"If you don't want the argument for split to be a regex, use Pattern.quote to avoid escaping as @YCF_L suggested","label":{"api":{"split":[[35,39]],"Pattern.quote":[[60,72]]}}},{"text":"Try to use Pattern.quote to avoid escaping character by character, It will do that free for you","label":{"api":{"Pattern.quote":[[11,23]]}}},{"text":"From the documentation https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html","label":{"api":{}}},{"text":"Firstly,you have passed wrong object with second argument of Collectors.groupingBy","label":{"api":{"Collectors.groupingBy":[[61,81]]}}},{"text":"You might want to consider using a Java executor with a limited number of threads to avoid crushing your process or even OS","label":{"api":{}}},{"text":"you can turn the character being compared against to lowercase with Character.toLowerCase prior to comparison","label":{"api":{"Character.toLowerCase":[[68,88]]}}},{"text":"For those JVMs supporting Java Agents, the Instrumentation API offers everything needed, e.g","label":{"api":{"Instrumentation API":[[43,61]]}}},{"text":"to create directory within a directory use File.mkdirs(), like","label":{"api":{"File.mkdirs()":[[43,55]]}}},{"text":"I am of course using java.time, the modern Java date and time API","label":{"api":{"java.time":[[21,29]]}}},{"text":"I warmly recommend it over the outdated Calendar, SimpleDateFormat and Date","label":{"api":{"Calendar":[[40,47]],"SimpleDateFormat":[[50,65]],"Date":[[71,74]]}}},{"text":"Why not using java.time library","label":{"api":{"java.time":[[14,22]]}}},{"text":"If you are using Java 8, I'd recommend using the Optional class","label":{"api":{}}},{"text":"Given the fact the Stream.of returns, an ordered stream as stated in the documentation and none of the intermediate operations you've shown change this behavior we can, therefore, say that the returned iterator is guaranteed to provide the values 2, 3, 4 in order when enumerated because calling the iterator terminal operation on an ordered stream or sequence (e.g","label":{"api":{"Stream.of":[[19,27]]}}},{"text":"The closest to a guarantee that I have found so far ist the following statement in the package documentaion for java.util.stream","label":{"api":{"package documentaion for java.util.stream":[[87,127]]}}},{"text":"You can do it quite easily with the help of method  Class.getAnnotation(Class<A>)","label":{"api":{"Class.getAnnotation(Class<A>)":[[52,80]]}}},{"text":"You can use Cache.asMap() to treat your cache as a Map, thereby exposing additional functionality such as Map.put(), which returns the previously-mapped value","label":{"api":{"Cache.asMap()":[[12,24]],"Map.put()":[[106,114]]}}},{"text":"You might want to use putIfAbsent() instead","label":{"api":{"putIfAbsent()":[[22,34]]}}},{"text":"The backing array of an ArrayList is an Object[] (i.e","label":{"api":{"ArrayList":[[24,32]],"Object":[[40,45]]}}},{"text":"the element type of that array is the Object class, not any sub-class of Object), so you can put any reference type (as well as primitives, which get auto-boxed to their corresponding wrapper type) in it","label":{"api":{"Object":[[38,43],[73,78]]}}},{"text":"You can see the initialization of the backing array in the ArrayList constructor","label":{"api":{"ArrayList":[[59,67]]}}},{"text":"See the JavaDoc for Map.keySet()","label":{"api":{"Map.keySet()":[[20,31]]}}},{"text":"Another way would be by using the Collection.removeIf method","label":{"api":{"Collection.removeIf":[[34,52]]}}},{"text":"All non-word chars can be matched with \\W shorthand character class, and to make it Unicode-aware, all you need is pass the Pattern.UNICODE_CHARACTER_CLASS (or (?U) inline embedded flag option) to the regex compiler","label":{"api":{"Pattern.UNICODE_CHARACTER_CLASS":[[124,154]]}}},{"text":"One of the serialization formats is using Java's serialization mechanism via ObjectOutputStream","label":{"api":{"ObjectOutputStream":[[77,94]]}}},{"text":"Writer (of which FileWriter is a subclass) is documented to work in a stream-oriented model, vs","label":{"api":{"FileWriter":[[17,26]],"documented":[[46,55]]}}},{"text":"You're misunderstanding how Collectors.toMap works - it takes two functions, one that given an entry produces a new key, and one that given an entry produce a new value","label":{"api":{"Collectors.toMap":[[28,43]]}}},{"text":"If you absolutely must pass a File, copy your resource to a temporary file","label":{"api":{}}},{"text":"It is a better approach to test all the String throw functions like matches but that require you to know about regular expressions, it could be","label":{"api":{}}},{"text":"You can use Collectors.groupingBy() to partition your file content into chunks - you can collect them as a Collection<List<String>> or you can apply some processing while collecting all lines (e.g","label":{"api":{"Collectors.groupingBy()":[[12,34]],"Collection<List<String>>":[[107,130]]}}},{"text":"Collectors.groupingBy() allows me also to use different downstream collector","label":{"api":{"Collectors.groupingBy()":[[0,22]]}}},{"text":"By default Collectors.toList() is being used so my result is accumulated into a List<String> and I get Collection<List<String>> as a final result","label":{"api":{"Collectors.toList()":[[11,29]],"List<String>":[[80,91]],"Collection<List<String>>":[[103,126]]}}},{"text":"In this case I will use Collectors.summingInt() as my downstream function and the returned result is Collection<Integer>","label":{"api":{"Collectors.summingInt()":[[24,46]],"Collection<Integer>":[[101,119]]}}},{"text":"Collectors.groupingBy() returns a map where values are grouped by specific keys","label":{"api":{"Collectors.groupingBy()":[[0,22]]}}},{"text":"That's why in the end we call Map.values() to get a collection of the values this contained in this map","label":{"api":{"Map.values()":[[30,41]]}}},{"text":"noneMatch is true if no items in the stream (of values, here) satisfy the predicate","label":{"api":{"noneMatch":[[0,8]]}}},{"text":"In Javadoc of CompareVersion.compareTo(), you will see it is specified by Comparable.compareTo(), which has a javdoc of","label":{"api":{"CompareVersion.compareTo()":[[14,39]],"Comparable.compareTo()":[[74,95]]}}},{"text":"Usually, it's a servlet container (in an application server or Tomcat for instance), but in Java SE only environment it can be for instance Grizzly or even JDK HTTP server","label":{"api":{"JDK HTTP server":[[156,170]]}}},{"text":"I am in the progress of learning through Java 8 lambda expressions and would like to ask about the following piece of Java code relating to the peek method in the function interface that I have come across","label":{"api":{}}},{"text":"Return the double you get by calling doubleValue() on it","label":{"api":{"doubleValue()":[[37,49]]}}},{"text":"And when splitting, quote it using java.util.regex.Pattern#quote","label":{"api":{"java.util.regex.Pattern#quote":[[35,63]]}}},{"text":"The official documentation (archive) of containsAll only says \"Returns true if this list contains all of the elements of the specified collection.\"","label":{"api":{"official documentation":[[4,25]]}}},{"text":"Since Java 8 you can get the help of ChronoUnit","label":{"api":{"ChronoUnit":[[37,46]]}}},{"text":"To determine if the difference between your dates is 30 days use ChronoUnit.DAYS","label":{"api":{"ChronoUnit.DAYS":[[65,79]]}}},{"text":"For a real month use ChronoUnit.MONTHS","label":{"api":{"ChronoUnit.MONTHS":[[21,37]]}}},{"text":"It's because Set dosn't have get(int index) method like List","label":{"api":{"Set":[[13,15]],"get(int index)":[[29,42]]}}},{"text":"You could use either streams (such as in Aominè's answer) or the Map.merge method, this way","label":{"api":{"Map.merge method":[[65,80]]}}},{"text":"The specification for equals in this case, as quoted in the comment above, is Class String, method equals which says","label":{"api":{}}},{"text":"If I had to hazard a guess, it would likely be the KeyStore class","label":{"api":{"KeyStore":[[51,58]]}}},{"text":"Then, all the functions are reduced via the Function.andThen operator and finally, if the filters collections wasn't empty, the resulting composed function is executed with the currentRequest as an argument","label":{"api":{"Function.andThen":[[44,59]],"currentRequest":[[177,190]]}}},{"text":"It turns out, that since version 1.8 java already has this functionality built-in with the IntegerProperty class, but since its API somehow outscopes this question, let me give a minimalist example, too","label":{"api":{"IntegerProperty":[[91,105]]}}},{"text":"However, when you replace int value with IntContainer pointer (or IntegerProperty) and change the IntContainer's value, the modification will be visible for every instance holding a reference to the same IntContainer","label":{"api":{"IntContainer":[[41,52],[204,215]],"IntegerProperty":[[66,80]]}}},{"text":"If you don't know what size you need your array to be you should use an ArrayList, it can expand to the required size","label":{"api":{"ArrayList":[[72,80]]}}},{"text":"Date should be between two quotes 'startTime', beside your code can be a victim of syntax error or SQL Injection, so instead use PreparedStatement","label":{"api":{"PreparedStatement":[[129,145]]}}},{"text":"As your teacher wants you to find another solution, I propose to use a BufferedReader to read the file in single lines","label":{"api":{"BufferedReader":[[71,84]]}}},{"text":"For each line you can then use String#split() and finally convert the respective parts to the required type (Integer#parseInt() etc)","label":{"api":{"String#split()":[[31,44]],"Integer#parseInt()":[[109,126]]}}},{"text":"I want to print 0.5000 value in java therefor I try BigDecimal for this purpose but when i divide i get 0.5 with red color","label":{"api":{"BigDecimal":[[52,61]]}}},{"text":"Can i print 0.5000 using BigDecimal if not then why and why does 0.5 print in red font","label":{"api":{"BigDecimal":[[25,34]]}}},{"text":"The method getDateInstance is a static method that returns an Object, not an object that you are constructing","label":{"api":{"getDateInstance":[[11,25]]}}},{"text":"Always use right type setter (setString(...), setLong(...), ...) according to database column type","label":{"api":{"setString(...)":[[30,43]],"setLong(...)":[[46,57]]}}},{"text":"The boxing conversion uses Integer.valueOf implicitly, so there's no difference between the two","label":{"api":{"Integer.valueOf":[[27,41]]}}},{"text":"This is the same guarantee made by Integer.valueOf","label":{"api":{"Integer.valueOf":[[35,49]]}}},{"text":"You could tell us more about that message format, but it's likely you will need to use Java's ByteArrayInputStream (https://docs.oracle.com/javase/7/docs/api/java/io/ByteArrayInputStream.html)","label":{"api":{"ByteArrayInputStream":[[94,113]]}}},{"text":"If you want to return an array instead of a List, you can always use toArray() which all Lists implement","label":{"api":{"toArray()":[[69,77]]}}},{"text":"Also above I have made use of the Scanner method nextInt() rather than your Integer.parseInt solution, in the future you may want to look into pairing this with hasNextInt() that returns a boolean to ensure your program does not crash if the user inputs something other than an Integer","label":{"api":{"nextInt()":[[49,57]],"Integer.parseInt":[[76,91]],"hasNextInt()":[[161,172]]}}},{"text":"As we can see in Java 8, there are many methods named 'of', like Stream.of(), Optional.of(), and many libraries like actorOf in Akka","label":{"api":{"Stream.of()":[[65,75]],"Optional.of()":[[78,90]],"actorOf":[[117,123]]}}},{"text":"Or alternatively, you can use JAX-RS's ExceptionMapper","label":{"api":{"ExceptionMapper":[[39,53]]}}},{"text":"Math.rint is probably closest to what you're looking for","label":{"api":{"Math.rint":[[0,8]]}}},{"text":"Is there a way to examine/manipulate the elements of an SVGPath","label":{"api":{"SVGPath":[[56,62]]}}},{"text":"(In essence, I'd like to use SVGPath as an SVG path parser, instead of having to include Apache Batik or writing my own)","label":{"api":{"SVGPath":[[29,35]]}}},{"text":"KeyEvent::getKeyCode doesn't return the char you press on the keyboard","label":{"api":{"KeyEvent::getKeyCode":[[0,19]]}}},{"text":"When using KeyEvent::getKeyCode you have to use the KeyEvent key constants values predefined in the class","label":{"api":{"KeyEvent::getKeyCode":[[11,30]],"KeyEvent":[[52,59]]}}},{"text":"Or you can use KeyEvent::getKeyChar which \"returns the character associated with the key in this event\"","label":{"api":{"KeyEvent::getKeyChar":[[15,34]]}}},{"text":"ConcurrentModificationException usually relates to modifying the list while iterating through it within a loop","label":{"api":{"ConcurrentModificationException":[[0,30]]}}},{"text":"An instance of Integer will only show the instance variables and methods [ Oracle ]","label":{"api":{"Oracle":[[75,80]]}}},{"text":"Likewise, you could change your maximum search to start with - Double.MAX_VALUE so that your function continues working if passed a list of entirely negative numbers","label":{"api":{"Double.MAX_VALUE":[[63,78]]}}},{"text":"You can use Class.getEnclosingClass() to get the outer class","label":{"api":{"Class.getEnclosingClass()":[[12,36]]}}},{"text":"When you add a component to a JFrame, it is added to that frame's content pane, which by default has a BorderLayout","label":{"api":{"BorderLayout":[[103,114]]}}},{"text":"BorderLayout accommodates up to five child components, but if you add a component without specifying a position then it goes to the center position, replacing any component previously assigned there","label":{"api":{"BorderLayout":[[0,11]]}}},{"text":"If you want to be able to place an unbounded number of components in your frame, then you need a different layout manager for the frame's content pane, such as FlowLayout or BoxLayout","label":{"api":{"FlowLayout":[[160,169]],"BoxLayout":[[174,182]]}}},{"text":"Remember, a thread may call lock() on the ReadLock multiple times, which will only take one actual lock, but each call to lock() must be matched by a call to unlock() before the actual lock is released","label":{"api":{"lock()":[[28,33],[122,127]],"unlock()":[[158,165]]}}},{"text":"You can make use of the Collectors.filtering API introduced since Java-9 for this","label":{"api":{"Collectors.filtering":[[24,43]]}}},{"text":"InheritableThreadLocal javadoc and InheritableThreadLocalSecurityContextHolderStrategy source code might bring additional value to the understanding","label":{"api":{"InheritableThreadLocal":[[0,21]],"InheritableThreadLocalSecurityContextHolderStrategy":[[35,85]]}}},{"text":"Use Set.removeIf() and String.startsWith()","label":{"api":{"Set.removeIf()":[[4,17]],"String.startsWith()":[[23,41]]}}},{"text":"The idea is to customize the SSLSocketFactory ( http://cxf.apache.org/docs/tls-configuration.html#TLSConfiguration-ClientTLSParameters ) with your own implementation, and this one must create Sockets that come with your own HandshakeCompletedListener","label":{"api":{"SSLSocketFactory":[[29,44]],"#TLSConfiguration-ClientTLSParameters":[[97,133]],"Sockets":[[192,198]],"HandshakeCompletedListener":[[224,249]]}}},{"text":"See https://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferStrategy.html for reference","label":{"api":{}}},{"text":"You need nested loops if you wish each element of the inner Lists to be printed on a separate line","label":{"api":{}}},{"text":"This uses the Map.merge method to accumulate equal values by counting its occurrences","label":{"api":{"Map.merge":[[14,22]]}}},{"text":"You can construct a TimeZone instance for any offset, using SimpleTimeZone","label":{"api":{"TimeZone":[[20,27]],"SimpleTimeZone":[[60,73]]}}},{"text":"The TimeZone class is long outdated together with the classes you would usually use it with; Calendar, GregorianCalendar, DateFormat and SimpleDateFormat","label":{"api":{"TimeZone":[[4,11]],"GregorianCalendar":[[103,119]],"DateFormat":[[122,131]],"SimpleDateFormat":[[137,152]]}}},{"text":"For a ZoneId with constant offset, we create an instance of ZoneOffset, one of the two subclasses of ZoneId","label":{"api":{"ZoneOffset":[[60,69]]}}},{"text":"A ZoneOffset only has precision of seconds, not milliseconds, which is fine for your case of 14 400 000 milliseconds","label":{"api":{"ZoneOffset":[[2,11]]}}},{"text":"Only if you need to pass an old-fashioned TimeZone object to some legacy API that you cannot change or don’t want to change just now, convert the ZoneId we got above","label":{"api":{"TimeZone":[[42,49]]}}},{"text":"This will give you a TimeZone with display name GMT+04:00 and (of course) an offset of 4 hours","label":{"api":{"TimeZone":[[21,28]]}}},{"text":"Beware, however, that if TimeZone doesn’t recognize the time zone you are trying to convert to (a likely case if your offset was some odd number of seconds), it will tacitly give you GMT (just one of the problems with the old classes)","label":{"api":{"TimeZone":[[25,32]]}}},{"text":"So you should probably check the TimeZone object you got, for example like this","label":{"api":{"TimeZone":[[33,40]]}}},{"text":"You can use @XmlElement as show below","label":{"api":{"@XmlElement":[[12,22]]}}},{"text":"Alternatively you can annotate the getters with @XmlElement (then the @XmlAccessorType annotation is not required)","label":{"api":{"@XmlElement":[[48,58]],"@XmlAccessorType":[[70,85]]}}},{"text":"Please take a look at the java.util.stream package docs, where there's extensive information about streams and how to use them properly (i.e","label":{"api":{"java.util.stream package":[[26,49]]}}},{"text":"You are calling next() so iterator makes two steps","label":{"api":{"next()":[[16,21]]}}},{"text":"If you want to perform more actions on the String returned by iterator.next() you need to store this value in a variable and do these operations with the use of this variable","label":{"api":{"String":[[43,48]],"iterator.next()":[[62,76]]}}},{"text":"You want the asSubclass method of Class","label":{"api":{"asSubclass method of Class":[[13,38]]}}},{"text":"You can use the getFields() method if the Class, although I recommend you a simpler method if the class have so little properties, you can just use the or operation to achieve this","label":{"api":{"getFields()":[[16,26]]}}},{"text":"Using the getFields() method","label":{"api":{"getFields()":[[10,20]]}}},{"text":"From the documentation for System.currentTimeMillis()","label":{"api":{"the documentation for System.currentTimeMillis()":[[5,52]]}}},{"text":"You'll need to enumerate over the entrySet like this","label":{"api":{"entrySet":[[34,41]]}}},{"text":"The one I find most idiomatic and expressive is Map.forEach","label":{"api":{"Map.forEach":[[48,58]]}}},{"text":"Jsoup's Jsoup.connect(String url) method uses blocking URL.openConnection() method","label":{"api":{"Jsoup.connect(String url)":[[8,32]],"URL.openConnection()":[[55,74]]}}},{"text":"contains doesn't use regex","label":{"api":{}}},{"text":"You may want to look at matches instead","label":{"api":{}}},{"text":"If you're trying to read whitespace-separated values, the easiest solution is probably just to use Scanner.next or one of the other next..","label":{"api":{"Scanner.next":[[99,110]]}}},{"text":"functions (other than nextLine, like Scanner.nextInt, or Scanner.nextDouble in your case)","label":{"api":{"Scanner.nextInt":[[37,51]],"Scanner.nextDouble":[[57,74]]}}},{"text":"Now look at the API documentation of the java.sql.Date class","label":{"api":{"the API documentation of the java.sql.Date class":[[12,59]]}}},{"text":"To extend it you need to specify a generic interface that implements Comparable","label":{"api":{"Comparable":[[69,78]]}}},{"text":"AbstractA does not implement Comparable","label":{"api":{"Comparable":[[29,38]]}}},{"text":"If you want A to implement Comparable you need to add it as an implements clause","label":{"api":{"Comparable":[[27,36]]}}},{"text":"Is something wrong in the way I understood Stream().map()","label":{"api":{"Stream().map()":[[43,56]]}}},{"text":"We can use Collectors.flatMapping  collector added in Java-9","label":{"api":{"Collectors.flatMapping":[[11,32]]}}},{"text":"You can use a regular expression to extract the portions of the text, and then build a text flow with different colored text elements in it","label":{"api":{"regular expression":[[14,31]]}}},{"text":"Use a Timeline, to control when to play and pause your animation","label":{"api":{"Timeline":[[6,13]]}}},{"text":"The problem is when I go to check the inventory of a certain item with Collections.frequency it continues to say that there is zero of that item","label":{"api":{"Collections.frequency":[[71,91]]}}},{"text":"There is only one class which is inherited by default is Object class","label":{"api":{"Object":[[57,62]]}}},{"text":"Check out https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone() to see that Object itself implements no interfaces","label":{"api":{}}},{"text":"My preference would be to use Files.lines to get a stream containing each line of the file, then split each line based on the delimiter","label":{"api":{"Files.lines":[[30,40]]}}},{"text":"File I/O is easier with the methods in the Files class","label":{"api":{"the Files class":[[39,53]]}}},{"text":"You can subclass JFileChooser, and customize the dialog in its createDialog method","label":{"api":{"JFileChooser":[[17,28]],"createDialog":[[63,74]]}}},{"text":"However, \"a list without duplicates\" is the definition of a set","label":{"api":{}}},{"text":"orElseGet takes a Supplier, However you're doing t -> ..","label":{"api":{"Supplier":[[18,25]]}}},{"text":"which does not satisfy the function descriptor of the Supplier functional interface","label":{"api":{"Supplier":[[54,61]]}}},{"text":"The answer is that replaceAll method takes a regualar expression String which has its own meaning of \\ character so you have to escape it twice","label":{"api":{}}},{"text":"This can be done by casting Random.nextInt() to a byte, which returns a random number from 0 up to but not including the parameter","label":{"api":{"Random.nextInt()":[[28,43]]}}},{"text":"I feel that it's possible to get over using flatMap again, but I can't figure out","label":{"api":{"flatMap":[[44,50]]}}},{"text":"Java provides String.format() with various options to format both text and numbers","label":{"api":{"String.format()":[[14,28]]}}},{"text":"You'll have better results if you retain its original precision and then use System.out.format() to display it to the user","label":{"api":{"System.out.format()":[[77,95]]}}},{"text":"koneksi.getConnection() returns a Connection , you can't cast it to a Statement, but you can get one by calling createStatement() on the Connection","label":{"api":{"koneksi.getConnection()":[[0,22]],"createStatement()":[[112,128]]}}},{"text":"ArrayList doesn't support adding multiple object of same type in one go and that's the reason you are getting compile time error","label":{"api":{"ArrayList":[[0,8]]}}},{"text":"Math.round is not an opposite of Math.floor; Math.ceil is","label":{"api":{"Math.floor":[[33,42]],"Math.ceil":[[45,53]]}}},{"text":"seems what you're missing is Pattern.quote, if argument must be read literally, indeed split argument is a regex","label":{"api":{"Pattern.quote":[[29,41]]}}},{"text":"First convert the view index to a model index using JTable.convertRowIndexToModel(rowSelected)","label":{"api":{"JTable.convertRowIndexToModel(rowSelected)":[[52,93]]}}},{"text":"The java.util.function.Function interface was introduced in java 8","label":{"api":{"java.util.function.Function":[[4,30]]}}},{"text":"You could take a look at java.util.function package's javadocs and the java tutorial sections about lambdas and method references for further reference","label":{"api":{"java.util.function package's javadocs":[[25,61]]}}},{"text":"Use CountDownLatch this way","label":{"api":{"CountDownLatch":[[4,17]]}}},{"text":"Use CountDownLatch this way","label":{"api":{"CountDownLatch":[[4,17]]}}},{"text":"Similar to first option but using AtomicInteger","label":{"api":{"AtomicInteger":[[34,46]]}}},{"text":"I do not have code ready for you, but I think your best approach is to convert ANTLR's ParseTree into a Swing JTree by linking Swing TreeNodes together","label":{"api":{"JTree":[[110,114]],"TreeNode":[[133,140]]}}},{"text":"You can use a combination of a groupingBy collector and the summingInt collector like this","label":{"api":{"groupingBy":[[31,40]],"summingInt":[[60,69]]}}},{"text":"In this case, I've specifically used the summingInt collector due to the fact that the counting() collector returns a Long type and since you want the map values as  Integer's then the summingInt collector is the most appropriate","label":{"api":{"summingInt":[[41,50],[185,194]],"counting()":[[87,96]]}}},{"text":"This uses Java 9's List.of","label":{"api":{"List.of":[[19,25]]}}},{"text":"Besides, it also uses the List.contains method, which checks if a given object belongs to the list by means of the Objects.equals method, which in turn uses the equals method (taking care of nulls)","label":{"api":{"List.contains":[[26,38]],"Objects.equals":[[115,128]]}}},{"text":"If you look at the Javadoc for Period.between(), it tells you that the end date is exclusive (meaning","label":{"api":{"Period.between()":[[31,46]]}}},{"text":"The wrapper types for int and float both extend Number, so you could, instead, have a Number array","label":{"api":{}}},{"text":"You should be using the javafx.scene.input.MouseEvent instead of java.awt.event.MouseEvent as you are using JavaFX","label":{"api":{"javafx.scene.input.MouseEvent":[[24,52]],"java.awt.event.MouseEvent":[[65,89]]}}},{"text":"Since you're explicitly looking for a value, you can use Stream#findAny() instead","label":{"api":{"Stream#findAny()":[[57,72]]}}},{"text":"Currently, you're calling this sort method instead of this, specifying your comparator hence the issue","label":{"api":{"this sort":[[26,34]]}}},{"text":"To add an entry, instead of using Map.put, use Map.computeIfAbsent","label":{"api":{"Map.put":[[34,40]],"Map.computeIfAbsent":[[47,65]]}}},{"text":"System.out.println(r) will only print nonsense because it calls Object.toString()","label":{"api":{"System.out.println(r)":[[0,20]],"Object.toString()":[[64,80]]}}},{"text":"Just create an executor service, store it as a field and submit each task as runnable","label":{"api":{"executor service":[[15,30]]}}},{"text":"This way, you'll get a completable future result which allows you to add listeners and do any further processing","label":{"api":{"completable future":[[23,40]]}}},{"text":"This uses List.subList, which returns a sublist view backed by the original list","label":{"api":{"List.subList":[[10,21]]}}},{"text":"you need use BigInteger , it take the memory dinamicaly so he dont have limit","label":{"api":{"BigInteger":[[13,22]]}}},{"text":"Create a static class level HashMap of DiscountStrategy","label":{"api":{"HashMap":[[28,34]],"DiscountStrategy":[[39,54]]}}},{"text":"If you consult this Oracle page, it seems that there are 3 main packages","label":{"api":{"Oracle page":[[20,30]]}}},{"text":"I read the SwingWorker documentation and from what I understand from this and other documents is that the execute() method is suppose to \"start the thread\" (or puts it in a worker thread)","label":{"api":{"SwingWorker documentation":[[11,35]],"execute()":[[106,114]]}}},{"text":"BTW isEqual() compares the instants in time only, not the zones at all, which is why it didn’t care","label":{"api":{"isEqual()":[[4,12]]}}},{"text":"spliterator() is a terminal operation that consumes the input stream, but you can pass the Spliterator to StreamSupport.stream to construct a stream with exactly the same properties","label":{"api":{"spliterator()":[[0,12]],"Spliterator":[[91,101]],"StreamSupport.stream":[[106,125]]}}},{"text":"In practice, the current stream implementation will return different Spliterator implementations depending on whether the stream is parallel or not","label":{"api":{"Spliterator":[[69,79]]}}},{"text":"This implies that recreating the stream as a parallel stream may end up with a stream that is incapable of doing parallel processing when the original stream wasn’t already parallel before calling spliterator()","label":{"api":{"spliterator()":[[197,209]]}}},{"text":"Calling parallel() before spliterator() to get a parallel capable stream that may still run sequentially if you decide to do so, works in a lot of cases","label":{"api":{"parallel()":[[8,17]],"spliterator()":[[26,38]]}}},{"text":"Even if you conclude that your collector’s workload is already high enough to deserve parallel processing, it might be that the incoming stream has operations like skip, limit or distinct (on an ordered stream), which often run worse in parallel and would require an entirely different threshold","label":{"api":{"skip":[[164,167]],"limit":[[170,174]],"distinct":[[179,186]]}}},{"text":"You don’t even need to add an option to your method’s signature as the caller can already make the decision by calling parallel() or sequential() on the stream before passing it to your method, and you can respect that by simply not changing the mode","label":{"api":{"parallel()":[[119,128]],"sequential()":[[133,144]]}}},{"text":"System.out.println(a / 0); throws an ArithmeticException because you cannot divide by 0","label":{"api":{"System.out.println(a / 0)":[[0,24]],"ArithmeticException":[[37,55]]}}},{"text":"Parallel streams use ForkJoinPool under the hood, and variable a is shared between multiple threads without any synchronization, that's why the result is non-deterministic","label":{"api":{"ForkJoinPool":[[21,32]]}}},{"text":"If you do not want duplicates on your list you could use HashSet","label":{"api":{"HashSet":[[57,63]]}}},{"text":"ArrayList allow us store duplicate Object on it","label":{"api":{"ArrayList":[[0,8]]}}},{"text":"The layout pane that allows you the most control is the GridPane","label":{"api":{"GridPane":[[56,63]]}}},{"text":"So, while it's possible there may be easier ways to do this, using a GridPane as the root and placing the HBox in the only cell at 0,0 allows you to control how the HBox is resized","label":{"api":{"GridPane":[[69,76]]}}},{"text":"Just to point my experience with this, it seems using a recursive background Task for potentially long computations, such as scanning the Whole local drive like in my example, it's very memory consuming - also because I stored some results of this background computation in static local variables to access them faster","label":{"api":{"Task":[[77,80]]}}},{"text":"the result was a data-structure (ObservableList) with over 5000+ instances of a custom class to represent that specific data computed and then the OutOfMemoryError message or the background thread just going like in 'stand-by' without any advice after running for long time (waiting for garbage collection?)","label":{"api":{"ObservableList":[[33,46]],"OutOfMemoryError":[[147,162]]}}},{"text":"You can use toMillis() method in FileTime","label":{"api":{"toMillis()":[[12,21]],"FileTime":[[33,40]]}}},{"text":"I suggest you take a look at the formatter specification","label":{"api":{}}},{"text":"Check Collection.removeIf method docs for further reference","label":{"api":{"Collection.removeIf":[[6,24]]}}},{"text":"Instead, implement AutoCloseable on the class and ensure the documentation makes clear that instances must be closed when the code is done with the instance","label":{"api":{"AutoCloseable":[[19,31]]}}},{"text":"AutoCloseable makes it compatible with the try-with-resources statement, which makes it easy for consumers of your class to close it correctly","label":{"api":{"AutoCloseable":[[0,12]]}}},{"text":"This is what the various JDK classes that need to do cleanup do (for instance, FileWriter)","label":{"api":{"FileWriter":[[79,88]]}}},{"text":"The javadoc page does not provide any hint on how to do this","label":{"api":{"javadoc page":[[4,15]]}}},{"text":"Java's String.split method splits not by character, but by a regex","label":{"api":{"String.split":[[7,18]]}}},{"text":"Another variant of YCF_L's answer would be using the Pattern API","label":{"api":{"Pattern":[[53,59]]}}},{"text":"You can use a LocalDateTime if you don't want to work with time zones","label":{"api":{"LocalDateTime":[[14,26]]}}},{"text":"You have to use PreparedStatement to avoid syntax error or SQL Injection, In your case it's better also to use batch like this","label":{"api":{"PreparedStatement":[[16,32]]}}},{"text":"Close, but you need to use getGenericParameterTypes, as well as getDeclaredConstructors (since your constructor is not public)","label":{"api":{"getGenericParameterTypes":[[27,50]],"getDeclaredConstructors":[[64,86]]}}},{"text":"For instance, in the case that the argument is a type variable, getActualTypeArguments()[0] will return an instance of TypeVariable instead of Class<...>","label":{"api":{"getActualTypeArguments()":[[64,87]],"TypeVariable":[[119,130]]}}},{"text":"I'm reading the Java Doc about the WeakHashMap  and I get the basic concept","label":{"api":{"WeakHashMap":[[35,45]]}}},{"text":"Just use List","label":{"api":{"List":[[9,12]]}}},{"text":"If you are using Java 8, Then you can use java.time library and you can just use","label":{"api":{"java.time":[[42,50]]}}},{"text":"I would try something simple, like CompletableFuture","label":{"api":{"CompletableFuture":[[35,51]]}}},{"text":"If you want to catch any possible type of input, you'll want to use a DocumentListener","label":{"api":{"DocumentListener":[[70,85]]}}},{"text":"If you're wondering how to use a DocumentListener, here is some code that shows how to use it on a JTextField","label":{"api":{"DocumentListener":[[33,48]],"JTextField":[[99,108]]}}},{"text":"If you implement the tolerance in the compareTo / compare method, then any key lookups / inserts will \"snap\" to an existing key that's within tolerance","label":{"api":{"compareTo":[[38,46]],"compare":[[50,56]]}}},{"text":"https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/awt/event/InputEvent.java#L95 - just it is not very tasteful to hardcode it as 16, the documentation suggests usage of these BUTTONx_MASK fields (https://docs.oracle.com/javase/7/docs/api/java/awt/Robot.html#mousePress(int) ), and the source locally suggest the usage of BUTTONx_DOWN_MASK (scroll a couple lines upwards)","label":{"api":{}}},{"text":"If you want to start 10 threads, and have the 5 ServiceTask threads wait for the 5 ValidationTask threads to complete, then use a CountDownLatch, give it to both ValidationTask and ServiceTask","label":{"api":{"ServiceTask":[[48,58],[181,191]],"ValidationTask":[[83,96],[162,175]],"CountDownLatch":[[130,143]]}}},{"text":"flatMap should help you","label":{"api":{"flatMap":[[0,6]]}}},{"text":"You can use multiple map like this","label":{"api":{}}},{"text":"Or in one map","label":{"api":{}}},{"text":"If you are on Java 8 or higher, starting from Guava 21.0, you have the Optional.toJavaUtil() instance method, which transforms your Guava Optional instance into a java.util.Optional one, and also the Optional.fromJavaUtil static method, which creates a Guava Optional instance from a java.util.Optional one","label":{"api":{"Optional.toJavaUtil()":[[71,91]],"java.util.Optional":[[163,180],[284,301]],"Optional.fromJavaUtil":[[200,220]]}}},{"text":"You can use them to let java.util.Optional take a function that invokes your method in its Optional.map method, applying its own semantics (it won't throw NullPointerException if the function returns null, but an empty java.util.Optional instead)","label":{"api":{"java.util.Optional":[[24,41],[219,236]],"Optional.map":[[91,102]],"NullPointerException":[[155,174]]}}},{"text":"Then, if you need it, convert this mapped java.util.Optional back to a Guava Optional via the Optional.fromJavaUtil method","label":{"api":{"java.util.Optional":[[42,59]],"Optional.fromJavaUtil":[[94,114]]}}},{"text":"Use an ArrayList and add to it all lines after \"LABS\" and before \"HOMEWORK\", then use IntStream#sum to combine the numbers and divide by List#size to get the average","label":{"api":{"ArrayList":[[7,15]],"IntStream#sum":[[86,98]],"List#size":[[137,145]]}}},{"text":"The reason the result is false is stated clearly in the String.equals() documentation","label":{"api":{"String.equals()":[[56,70]]}}},{"text":"String and StringBuilder both implement CharSequence, so you can use String.contentEquals() instead","label":{"api":{"StringBuilder":[[11,23]],"CharSequence":[[40,51]],"String.contentEquals()":[[69,90]]}}},{"text":"One option is to use Stream.iterate()","label":{"api":{"Stream.iterate()":[[21,36]]}}},{"text":"Or, if you don't want to use Java 9 features, you can write a method similar to Stream.iterate(), but make it produce a finite Stream","label":{"api":{"Stream.iterate()":[[80,95]]}}},{"text":"As Holger commented, all of this is not necessary if you are using Java 9, which has a Stream.iterate variant that produces a finite Stream","label":{"api":{"Stream.iterate":[[87,100]]}}},{"text":"You'd need to convert your stream to a Spliterator and then adapt this spliterator to a custom one that partially-reduces some elements according to your logic (in your example it would need to count equal elements until a different element appears)","label":{"api":{"Spliterator":[[39,49]]}}},{"text":"So this spliterator extends Spliterators.AbstractSpliterator and also implements Consumer","label":{"api":{"Spliterators.AbstractSpliterator":[[28,59]],"Consumer":[[81,88]]}}},{"text":"At this point, a TokenBag instance is created with the token and the count and is immediately pushed to the Consumer<","label":{"api":{"TokenBag":[[17,24]],"Consumer":[[108,115]]}}},{"text":"The counterpart of Calendar.add(int field, int amount) is LocalDateTime.plus(long amountToAdd, TemporalUnit unit), but it needs a TemporalUnit instead of int","label":{"api":{"Calendar.add(int field, int amount)":[[19,53]],"LocalDateTime.plus(long amountToAdd, TemporalUnit unit)":[[58,112]],"TemporalUnit":[[130,141]]}}},{"text":"But when you need to keep the method signature you need to map the \"Calendar-Fields\" like Calendar.MONTH to a TemporalUnit","label":{"api":{"Calendar.MONTH":[[90,103]],"TemporalUnit":[[110,121]]}}},{"text":"As said by this answer, the lookup modes must include the private access to be accepted by the LambdaMetaFactory","label":{"api":{"lookup modes":[[28,39]],"private access":[[58,71]],"LambdaMetaFactory":[[95,111]]}}},{"text":"Starting with Java 9, there is the method privateLookupIn(Class, MethodHandles.Lookup) to attempt to get a lookup object with private access to another class","label":{"api":{"privateLookupIn(Class, MethodHandles.Lookup)":[[42,85]],"private access":[[126,139]]}}},{"text":"With a global ActionListener for your buttons you can then switch the content corresponding to the clicked button","label":{"api":{"ActionListener":[[14,27]]}}},{"text":"And Last thing is to define a mapper for the request so it can map those results to the desired entity, if the query uses different attributes names other than the ones in the entity, using  @SqlResultSetMapping","label":{"api":{"@SqlResultSetMapping":[[191,210]]}}},{"text":"That's at least insofar as paintImmediately is specified to do what's implied","label":{"api":{}}},{"text":"Note that this one is also implemented in BCDUtil in Java Card","label":{"api":{"BCDUtil":[[42,48]]}}},{"text":"Well, we know that  RandomAccess is a marker interface, and the documentation says","label":{"api":{"RandomAccess":[[20,31]]}}},{"text":"Thus, it makes total sense to me that ArrayList implements RandomAccess interface as internally elements are stored in an array, which can be randomly accessed","label":{"api":{"ArrayList":[[38,46]],"RandomAccess":[[59,70]]}}},{"text":"However, if you will see the internal implementation of ArrayDeque which also stores elements in an array, but it does not implements RandomAccess, was it intended or it was done some explicit reason which I am not aware of","label":{"api":{"ArrayDeque":[[56,65]],"RandomAccess":[[134,145]]}}},{"text":"I was expecting the javax.script package to provide code that would accomplish this, but I can't for the life of me see how","label":{"api":{"javax.script":[[20,31]]}}},{"text":"If the pooled threads have no task, they are in state WAITING, meaning they have nothing to do besides wait for a signal for something to happen (in this case, waiting for a task to be submitted)","label":{"api":{"WAITING":[[54,60]]}}},{"text":"Integer.parseInt(String s) has the argument type String, not char as returned by number.charAt(i)","label":{"api":{"Integer.parseInt(String s)":[[0,25]],"number.charAt(i)":[[81,96]]}}},{"text":"Have a look at StringBuilder which is an efficient way to concatenate strings","label":{"api":{"StringBuilder":[[15,27]]}}},{"text":"But it is no bug, too, because this behaviour is described in the API","label":{"api":{"described in the API":[[49,68]]}}},{"text":"java.util.Date not have plusMinutes","label":{"api":{"java.util.Date":[[0,13]]}}},{"text":"It can be better if you use Java 8, with java.time library","label":{"api":{"java.time":[[41,49]]}}},{"text":"You can do it using Map.computeIfAbsent","label":{"api":{"Map.computeIfAbsent":[[20,38]]}}},{"text":"FXCollections.observableArrayList(Collection) copies the elements of the parameter to the ObservableList created","label":{"api":{"FXCollections.observableArrayList(Collection)":[[0,44]],"ObservableList":[[90,103]]}}},{"text":"Even if you use FXCollections.observableList(List) which uses the object passed as parameter as a backing list, modifying the backing list does not trigger change events for the ObservableList","label":{"api":{"FXCollections.observableList(List)":[[16,49]],"ObservableList":[[178,191]]}}},{"text":"You can use Files to implement it in the easy way","label":{"api":{}}},{"text":"the collector has to provide a supplier for the container to accumulate the elements, without any hints about the stream characteristics, even if they are known in advance like in the Stream.of(item) example, which is known to have a single element","label":{"api":{"Stream.of(item)":[[184,198]]}}},{"text":"A collector could provide a supplier for an intermediate type that gets converted to a different result type at the end, which could add to memory efficiency, but would require additional CPU time","label":{"api":{"provide a supplier":[[18,35]]}}},{"text":"But, as mentioned by Sotirios in the comments, and also mentioned in the Map.compute doc, it is better to use Map.merge here, as follows(ref)","label":{"api":{"Map.compute":[[73,83]],"Map.merge":[[110,118]]}}},{"text":"If you check OpenJDK9 source code, you can see that retainAll() uses AbstractCollection.contains(Object o)","label":{"api":{"retainAll()":[[52,62]],"AbstractCollection.contains(Object o)":[[69,105]]}}},{"text":"To read its output, read from its input stream","label":{"api":{}}},{"text":"Collectors.toMap works by transforming each element of the stream into the keys (this is the 1st argument word -> word, which means we leave the word as is, so that it will be the key of the map), and by transforming each element of the stream into the values (this is the 2nd argument word -> new Pair<>(word, 1), which means that we've found the word for the first time, so we're creating a new Pair instance for that word with a count of 1)","label":{"api":{"Collectors.toMap":[[0,15]]}}},{"text":"This uses Map.merge and has similar semantics as the previous code","label":{"api":{"Map.merge":[[10,18]]}}},{"text":"As a few folks have pointed out, you're calling readLine on your reader too many times, and discarding the output","label":{"api":{"readLine":[[48,55]]}}},{"text":"So reader.readLine() != null, for example, reads new data from the stream, checks that it isn't null, and then immediately gets rid of it since you haven't stored it in a variable","label":{"api":{"reader.readLine()":[[3,19]]}}},{"text":"You can simply use LocalDate API for your DriversLicense class as shown below","label":{"api":{"LocalDate":[[19,27]],"DriversLicense":[[42,55]]}}},{"text":"For formatting double/float, there is a DecimalFormat class","label":{"api":{}}},{"text":"Then, you can use Java's Scanner class to read individual items and put them into a list","label":{"api":{}}},{"text":"Another option is to use a HTMLDocument#insertBeforeEnd(...) (Java Platform SE 8)","label":{"api":{"HTMLDocument#insertBeforeEnd(...)":[[27,59]]}}},{"text":"Use an interface and create an InvocationHandler","label":{"api":{"InvocationHandler":[[31,47]]}}},{"text":"filter method should be called on Stream object","label":{"api":{"filter":[[0,5]],"Stream":[[34,39]]}}},{"text":"Also you should not create empty ArrayList to collect results","label":{"api":{"ArrayList":[[33,41]]}}},{"text":"Use Stream.collect with appropriate collector","label":{"api":{"Stream.collect":[[4,17]]}}},{"text":"If findAll returns Iterable, firstly you need convert it to stream","label":{"api":{"Iterable":[[19,26]]}}},{"text":"What about Collectors.groupingBy()","label":{"api":{"Collectors.groupingBy()":[[11,33]]}}},{"text":"I'm trying to establish a MethodHandle that has a general purpose filter for the return values, by using the MethodHandles.filterReturnValue() to do the work","label":{"api":{"MethodHandle":[[26,37]],"MethodHandles.filterReturnValue()":[[109,141]]}}},{"text":"However, this isn't apparently allowed in the MethodHandles.filterReturnValue() call","label":{"api":{"MethodHandles.filterReturnValue()":[[46,78]]}}},{"text":"It seems that MethodHandles.filterReturnValue() is inappropriate for this purpose","label":{"api":{"MethodHandles.filterReturnValue()":[[14,46]]}}},{"text":"I've tried to get my head around MethodHandleProxies or even LamdaMetafactory, but they are tough to understand from the javadoc and meager examples found online","label":{"api":{"MethodHandleProxies":[[33,51]],"LamdaMetafactory":[[61,76]]}}},{"text":"The newInstance() method returns its type argument, here an E, so the compiler knows that it will return the correct type","label":{"api":{"newInstance()":[[4,16]]}}},{"text":"You can use matcher.lookingAt with a simple regex \\\\W that means a non-word character (that includes non letters and non digits) like this","label":{"api":{"matcher.lookingAt":[[12,28]]}}},{"text":"Also, there's no reason to call toLowerCase on the parameters to compareTo when you can easily call compareToIgnoreCase","label":{"api":{"toLowerCase":[[32,42]],"compareTo":[[65,73]],"compareToIgnoreCase":[[100,118]]}}},{"text":"You can specify how you would like the order arranged by creating a Comparator to handle how to order the data","label":{"api":{"Comparator":[[68,77]]}}},{"text":"Integer.valueOf(String s, int radix) will take a String as an input and attempt to convert it to the corresponding integer, where radix is the base of the number","label":{"api":{"Integer.valueOf(String s, int radix)":[[0,35]]}}},{"text":"Integer.toString(int i, int raxis) will take an int as an input and return a string representation in the specified radix","label":{"api":{"Integer.toString(int i, int raxis)":[[0,33]]}}},{"text":"From the documentation for Statement","label":{"api":{"documentation for Statement":[[9,35]]}}},{"text":"There is the connecting timeout value passed to connect method, and there is the reading timeout set using setSoTimeout method","label":{"api":{"setSoTimeout":[[107,118]]}}},{"text":"See the Java API documentation for DecimalFormat for more details","label":{"api":{"the Java API documentation for DecimalFormat":[[4,47]]}}},{"text":"The ArrayList.sort method does take a comparator which can be used to specify the sorting criteria, but as mentioned on the documentation page, passing it a null comparator is also valid","label":{"api":{"ArrayList.sort":[[4,17]]}}},{"text":"And as you can see from the Integer documentation, Integer implements Comparable<Integer>, so it has a natural ordering","label":{"api":{"Integer documentation":[[28,48]],"Comparable<Integer>":[[70,88]]}}},{"text":"replaceAll() matches using a regular expression","label":{"api":{"replaceAll()":[[0,11]]}}},{"text":"replace() matches using plain text","label":{"api":{"replace()":[[0,8]]}}},{"text":"Watch out, as List<T>.Get(int i) will give the element present at index i of the list, not the Team with ID i","label":{"api":{"List<T>.Get(int i)":[[14,31]]}}},{"text":"List<T>.Set(int i, T elem) replaces the Team at index i, for the Team elem, so it shouldn't be what you want to be doing, as points, the thing you want to change, can be changed directly on the instance already present in the list","label":{"api":{"List<T>.Set(int i, T elem)":[[0,25]]}}},{"text":"Use DocumentListener interface","label":{"api":{"DocumentListener":[[4,19]]}}},{"text":"Then you can use lastIndexOf (index of the last occurrence of given character) and then substring from that index position","label":{"api":{"lastIndexOf":[[17,27]]}}},{"text":"Sure, you can use ArrayList#set(int index, E element) and replace the last element with the index arraylist.size() -1 while iterating over it","label":{"api":{"ArrayList#set(int index, E element)":[[18,52]]}}},{"text":"Since Java 8, there's a new constructor that has a Comparator for argument","label":{"api":{}}},{"text":"The socket is timing out on the Java Server because the dartlang client is never writing a newline at the end of its message and the Java Server is using the readline method to read","label":{"api":{"readline":[[158,165]]}}},{"text":"You can keep a cache of these images with the help of SoftReference","label":{"api":{"SoftReference":[[54,66]]}}},{"text":"Looking at the example in the docs, you can have a JsonArrayBuilder, to which you can add your JsonObjects, like","label":{"api":{"JsonArrayBuilder":[[51,66]],"JsonObjects":[[95,105]]}}},{"text":"The default capacity of HashSet is 16, which means all your values end up in the bucket char value % 16 which turns out to be alphabetical order for your example","label":{"api":{"HashSet":[[24,30]]}}},{"text":"The entrySet() method you used for the iteration returns a Set view of the mappings inside the map","label":{"api":{"entrySet()":[[4,13]]}}},{"text":"But you can use Class.forName(String className) function","label":{"api":{"Class.forName(String className)":[[16,46]]}}},{"text":"Very simple solution would be is to implement a Comparator interface for your Class that would compare your class based on the properties of your interest","label":{"api":{"Comparator":[[48,57]]}}},{"text":"Then compare the instances for equality using your Comparator","label":{"api":{"Comparator":[[51,60]]}}},{"text":"This check is necessary, because otherwise object could be initialized multiple times","label":{"api":{"check":[[5,9]]}}},{"text":"You can easily check that","label":{"api":{"check":[[15,19]]}}},{"text":"Then remove that check and see what happens","label":{"api":{"check":[[17,21]]}}},{"text":"Also notice that it's not only a check - it's also a set (check)","label":{"api":{"check":[[33,37],[58,62]]}}},{"text":"I will be using JoinRowSet to join two tables (they are on different DB servers)","label":{"api":{"JoinRowSet":[[16,25]]}}},{"text":"It is possible to place components using GridBagLayout and a for loop and set different sizes, here is a working example","label":{"api":{"GridBagLayout":[[41,53]]}}},{"text":"More info on how to use GridBagLayout","label":{"api":{"GridBagLayout":[[24,36]]}}},{"text":"There is no way to do so, but you can use LinkedList or implement your own solution (Ziakad was right in the comment section when he stated this should be put into the Vector class","label":{"api":{"LinkedList":[[42,51]]}}},{"text":"Since you say it's a List, you can use subList() to split it","label":{"api":{"subList()":[[39,47]]}}},{"text":"You can do the conditional increment atomically with respect to the map by using computeIfAbsent()","label":{"api":{"computeIfAbsent()":[[81,97]]}}},{"text":"You need to use the javax.ws.rs.core.Form class","label":{"api":{"javax.ws.rs.core.Form":[[20,40]]}}},{"text":"Also use interfaces (List) in method signatures, not implementations (ArrayList)","label":{"api":{"List":[[21,24]],"ArrayList":[[70,78]]}}},{"text":"Or even replaceAll() as Andy Turner suggested","label":{"api":{"replaceAll()":[[8,19]]}}},{"text":"FunctionalInterface are available from JDK 8","label":{"api":{"FunctionalInterface":[[0,18]]}}},{"text":"With streams, you could use Collectors.groupingBy along with Collectors.mapping","label":{"api":{"Collectors.groupingBy":[[28,48]],"Collectors.mapping":[[61,78]]}}},{"text":"This uses Collectors.collectingAndThen, which first collects and then transforms the result","label":{"api":{"Collectors.collectingAndThen":[[10,37]]}}},{"text":"This variant uses Iterable.forEach to iterate the list and Map.computeIfAbsent to group transformed addresses by student name","label":{"api":{"Iterable.forEach":[[18,33]],"Map.computeIfAbsent":[[59,77]]}}},{"text":"For the concatenation, use either + or use a StringBuilder","label":{"api":{"StringBuilder":[[45,57]]}}},{"text":"I am sure you are familiar with List#get(int)","label":{"api":{"List#get(int)":[[32,44]]}}},{"text":"Just use ThreadLocalRandom#nextInt(int)","label":{"api":{"ThreadLocalRandom#nextInt(int)":[[9,38]]}}},{"text":"You could try to flush the buffered streams","label":{"api":{"flush":[[17,21]]}}},{"text":"You can use BigInteger's getLowestSetBit and clearBit methods","label":{"api":{"getLowestSetBit":[[25,39]],"clearBit":[[45,52]]}}},{"text":"Functional programming in Java is backed by functional interfaces (interfaces with only one abstract method) and lamdas","label":{"api":{"Function":[[0,7]]}}},{"text":"You can use Function / DoubleFunction those interfaces has one abstract method Function#apply","label":{"api":{"Function":[[12,19],[79,86]],"DoubleFunction":[[23,36]]}}},{"text":"From stream package description","label":{"api":{"description":[[20,30]]}}},{"text":"In Java 9, the documentation of the Stream.collect(Supplier, BiConsumer, BiConsumer) method has been updated and now it explicitly mentions that you should fold elements from the second result container into the first one","label":{"api":{"Stream.collect(Supplier, BiConsumer, BiConsumer)":[[36,83]]}}},{"text":"The javadoc for Map.put() says that the method","label":{"api":{"javadoc for Map.put()":[[4,24]]}}},{"text":"Since Java EE 7 and Servlet API 3.1 (Tomcat 8) you can use HttpServletRequest.changeSessionId() to achieve such behaviour","label":{"api":{"HttpServletRequest.changeSessionId()":[[59,94]]}}},{"text":"Since Java 9, we can provide a Function to Matcher#replaceAll(Function<MatchResult,​String> replacer)","label":{"api":{"Matcher#replaceAll(Function<MatchResult,​String> replacer)":[[43,100]]}}},{"text":"We can fully customize this behaviour since we have a hold on MatchResult","label":{"api":{"MatchResult":[[62,72]]}}},{"text":"Class.isInstance is the dynamic equivalent of the instanceof static operator, while Class.cast is the same as statically casting","label":{"api":{"Class.isInstance":[[0,15]],"Class.cast":[[84,93]]}}},{"text":"If you'd simply look at the Point API, you'd have your answer","label":{"api":{"Point API":[[28,36]]}}},{"text":"Start by googling \"java point\" which should give you a link to https://docs.oracle.com/javase/8/docs/api/java/awt/Point.html","label":{"api":{}}},{"text":"When you click on x, you will see that it is public","label":{"api":{}}},{"text":"con.getMetaData retrieves the number, types and properties of this ResultSet object's columns","label":{"api":{"con.getMetaData":[[0,14]],"ResultSet":[[67,75]]}}},{"text":"You can use a joining collector","label":{"api":{"joining":[[14,20]]}}},{"text":"another variant of joining the characters of a given element within the array with the delimiter ,","label":{"api":{"joining":[[19,25]]}}},{"text":"IntStream#forEach returns nothing (void), so you cannot return any data from within it","label":{"api":{"IntStream#forEach":[[0,16]]}}},{"text":"This uses Collectors.toMap, which works by merging a new person with an old person that's already in the map, and by merging we mean adding the addresses","label":{"api":{"Collectors.toMap":[[10,25]]}}},{"text":"you cannot add more elements to it, you can use Arrays.asList(), instead of creating an ArrayList","label":{"api":{"Arrays.asList()":[[48,62]],"ArrayList":[[88,96]]}}},{"text":"If the lists must be resizable, then use the ArrayList​(Collection<","label":{"api":{"ArrayList":[[45,53]]}}},{"text":"There is no easy solution to this since reading from streams is a blocking operation, one trick I saw implemented in EHCache/Terracotta is using 2 threads instead of 1, one thread will do the actual reading from the stream(Callable),while another thread will setup an executor service and submit the first thread(task) (using Future)","label":{"api":{"Future":[[326,331]]}}},{"text":"But you can use TreeSet https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html","label":{"api":{}}},{"text":"Natural order on Strings set is lexicographical (https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo-java.lang.String-)","label":{"api":{}}},{"text":"If you need to maintain an order you can use SortedSets like TreeSet (documentation) (for specific order) or LinkedHashSet (documentation) (for insertion order)","label":{"api":{"SortedSet":[[45,53]]}}},{"text":"For more on this, you may find it more helpful to read the Iterator documentation","label":{"api":{"Iterator documentation":[[59,80]]}}},{"text":"In a TreeMap and a TreeSet, is it okay for compareTo() and equals() be based off of two different fields","label":{"api":{"TreeMap":[[5,11]],"TreeSet":[[19,25]],"compareTo()":[[43,53]],"equals()":[[59,66]]}}},{"text":"If the input is not an int value, then Scanner's nextInt() (look here for API) method throws InputMismatchException, which you can catch and then ask the user to re-enter the 'country code' again as shown below","label":{"api":{"nextInt()":[[49,57]],"InputMismatchException":[[93,114]]}}},{"text":"However, it might be better to just use a StringJoiner instead of the StringBuilder, it does exactly what you want if initialized with (\" \", \"\\\"\", \"\\\"\")","label":{"api":{"StringJoiner":[[42,53]],"StringBuilder":[[70,82]]}}},{"text":"However, the documentation for List indicates that its sort method only accepts a Comparator","label":{"api":{"documentation for List":[[13,34]]}}},{"text":"Simple - use subList","label":{"api":{"subList":[[13,19]]}}},{"text":"If you look at the JavaDoc for the constructor you used, you will that it \"Constructs a new Scanner that produces values scanned from the specified string.\" What you want is Scanner#Scanner(File source), \"...a new Scanner that produces values scanned from the specified file\"","label":{"api":{"Scanner#Scanner(File source)":[[174,201]]}}},{"text":"A work around is to use Scanner#nextLine and parse accordingly","label":{"api":{"Scanner#nextLine":[[24,39]]}}},{"text":"If you look at the reflection library, you'll see that the return type of Class.getConstructor() is Constructor, which doesn't have any methods that can accept a instance - its only relevant method is newInstance(), which doesn't accept a target instance; it creates one","label":{"api":{"Class.getConstructor()":[[74,95]],"Constructor":[[100,110]],"newInstance()":[[201,213]]}}},{"text":"On the other hand, the return type of Class.getMethod() is Method, whose first parameter is the instance","label":{"api":{"Class.getMethod()":[[38,54]],"Method":[[59,64]]}}},{"text":"A Constructor is not a Method","label":{"api":{"Constructor":[[2,12]],"Method":[[23,28]]}}},{"text":"Java provides a way to convert it to an InputStream","label":{"api":{"InputStream":[[40,50]]}}},{"text":"For example in Java, according to the answers to this question, you could use java.net.URLDecoder","label":{"api":{"java.net.URLDecoder":[[78,96]]}}},{"text":"I've checked about the API documents on https://docs.oracle.com/javase/9/docs/api/index.html?java/lang/String.html and the return is \"StringBuilder\", so I should write the code like","label":{"api":{"StringBuilder":[[134,146]]}}},{"text":"By calling Stream#of with a single T[], Java defaults to the vararg factory method, creating a Stream<T> rather than a Stream<T[]>","label":{"api":{"Stream#of":[[11,19]],"Stream<T>":[[95,103]],"Stream<T[]>":[[119,129]]}}},{"text":"you should use BigDecimal for monetary purposes, not doubles","label":{"api":{"BigDecimal":[[15,24]]}}},{"text":"As far as I understand, Solrj can handle Date attribute but can't handle LocalDate","label":{"api":{"Date":[[41,44]],"LocalDate":[[73,81]]}}},{"text":"I tried to create and register custom converters following this for conversion between LocalDate and String but it doesn't work","label":{"api":{"LocalDate":[[87,95]]}}},{"text":"Moreover when I tried to use org.joda.time.LocalDate or org.springframework.data.geo.Point I have found that even converters specified in org.springframework.data.solr.core.convert.SolrCustomConversions do not work","label":{"api":{"org.joda.time.LocalDate":[[29,51]],"org.springframework.data.geo.Point":[[56,89]],"org.springframework.data.solr.core.convert.SolrCustomConversions":[[138,201]]}}},{"text":"When I declare my Callable.call() method to throw Exception, the compiler (both Eclipse Neon and Oracle's javax 1.8.0_131 with -Xlint:all) remains silent, but when I declare it to throw IOException, the compiler sees that this can never happen","label":{"api":{"Callable.call()":[[18,32]],"IOException":[[186,196]]}}},{"text":"I understand that Callable.call() is declared to throw Exception, but I can make my implementation throw less than the interface allows","label":{"api":{"Callable.call()":[[18,32]]}}},{"text":"It's quite easy to look this all up in the API, but here are the bits that may be less than self-explanatory","label":{"api":{"API":[[43,45]]}}},{"text":"Our lambda takes every String, and splits it along your specified delimiters (I converted your delim string to a regular expression)","label":{"api":{"splits":[[35,40]]}}},{"text":"Although I came up with this myself, an almost identical line is used in the common usage examples of the API","label":{"api":{"used in the common usage examples of the API":[[65,108]]}}},{"text":"For this argument, we provide Function.identity() (statically imported to match the collectors, which are in turn statically imported to match the style with which they're used in examples in the API)","label":{"api":{"Function.identity()":[[30,48]],"API":[[196,198]]}}},{"text":"Consider using the static Enum valueOf() method","label":{"api":{"valueOf()":[[31,39]]}}},{"text":"True, you can use trimToSize to get rid of this wasted space, but only after the fact","label":{"api":{"trimToSize":[[18,27]]}}},{"text":"Note also that you might find Arrays.copyOf easier to work with than System.arraycopy for the purposes of resizing an array, because it takes fewer parameters and is type-safe","label":{"api":{"Arrays.copyOf":[[30,42]],"System.arraycopy":[[69,84]]}}},{"text":"You can use trim() method of String class to remove all preceding and succeeding white spaces","label":{"api":{"trim()":[[12,17]]}}},{"text":"Now, if you want to iterate your outer and inner maps and print their key/value pairs you could use the Map.forEach method","label":{"api":{"Map.forEach":[[104,114]]}}},{"text":"Try to use Prepared Statement so you can use setArray like this","label":{"api":{"Prepared Statement":[[11,28]],"setArray":[[45,52]]}}},{"text":"Then create your Prepared Statement and set the array","label":{"api":{"Prepared Statement":[[17,34]]}}},{"text":"However, if I understand what you really want, you could use an AtomicInteger and incrementAndGet() (instead of get() and change your other methods as necessary)","label":{"api":{"AtomicInteger":[[64,76]],"incrementAndGet()":[[82,98]],"get()":[[112,116]]}}},{"text":"The trigonometric functions in java.lang.Math require inputs in radians, rather than degrees","label":{"api":{"java.lang.Math":[[31,44]]}}},{"text":"This can be done using the toRadians function","label":{"api":{"toRadians":[[27,35]]}}},{"text":"You'll need to convert your answers back to degrees, using the toDegrees function","label":{"api":{"toDegrees":[[63,71]]}}},{"text":"You can still get what you want with substring(), but the key is splitting the date string into tokens first","label":{"api":{"substring()":[[37,47]]}}},{"text":"You can use Collectors.partitioningBy","label":{"api":{"Collectors.partitioningBy":[[12,36]]}}},{"text":"I had problems with them when shutting down tomcat so replaced the thread implementations with a ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[97,120]]}}},{"text":"Java's RandomAccessFile has two useful methods, getFilePointer() and length()","label":{"api":{"RandomAccessFile":[[7,22]],"getFilePointer()":[[48,63]],"length()":[[69,76]]}}},{"text":"Whenever getFilePointer() is less than length(), there is data available to read","label":{"api":{"getFilePointer()":[[9,24]],"length()":[[39,46]]}}},{"text":"You could use a ArrayDeque, you can add/remove at both end","label":{"api":{"ArrayDeque":[[16,25]]}}},{"text":"The average method returns an OptionalDouble","label":{"api":{"OptionalDouble":[[30,43]]}}},{"text":"Finally, you need to use completePendingCommand() to complete the transaction and a FileOutputStream to write the file","label":{"api":{"completePendingCommand()":[[25,48]],"FileOutputStream":[[84,99]]}}},{"text":"To add a ContextMenu to a HBox, you can use the Node.setOnContextMenuRequested(...) method to receive an event when the ContextMenu is requested","label":{"api":{"ContextMenu":[[9,19],[120,130]],"Node.setOnContextMenuRequested(...)":[[48,82]]}}},{"text":"Read this for more information","label":{"api":{}}},{"text":"The best idea for running tasks in parallel is to use Executor Service with Completable Future","label":{"api":{"Completable Future":[[76,93]]}}},{"text":"Instead, try using the Future interface to keep track of thread completion","label":{"api":{}}},{"text":"For example when each thread signals to the progress wheel that it has finished the progress wheel can call Future.isDone() on any other tasks that have been previously called to determine if it should stop","label":{"api":{"Future.isDone()":[[108,122]]}}},{"text":"Another advantage of using the Future interface is that you can catch any exceptions or errors (e.g","label":{"api":{"Future":[[31,36]]}}},{"text":"In core Java libraries, an example of the simulated self-type usage is the Enum class","label":{"api":{"Enum":[[75,78]]}}},{"text":"But, I suggest you can directly get the list of users by grouping by userName using Java streams (Collectors.groupingBy) as shown below in a single line","label":{"api":{"userName":[[69,76]],"Collectors.groupingBy":[[98,118]]}}},{"text":"The ResultSet API offers getters that work with column names, such as getString(String)","label":{"api":{"ResultSet API":[[4,16]],"getString(String)":[[70,86]]}}},{"text":"Here is Java 8 IntStream soltuion","label":{"api":{"IntStream":[[15,23]]}}},{"text":"The readLine() method only reads up to the newline","label":{"api":{"readLine()":[[4,13]]}}},{"text":"See the contract of DataInput#readLine","label":{"api":{"DataInput#readLine":[[20,37]]}}},{"text":"You should be checking for a null result from readLine() to detect end-of-file, not looking at dins.available()","label":{"api":{"readLine()":[[46,55]],"dins.available()":[[95,110]]}}},{"text":"DataInputStream#readLine has been deprecated since JDK 1.1","label":{"api":{"DataInputStream#readLine":[[0,23]]}}},{"text":"Use a GridPane layout because it enables you to create a flexible grid of rows and columns in which to lay out controls","label":{"api":{"GridPane":[[6,13]]}}},{"text":"A BitSet would do too","label":{"api":{"BitSet":[[2,7]]}}},{"text":"As @veljkost explained, the default value for the allocationSize is 50","label":{"api":{"allocationSize":[[50,63]]}}},{"text":"This can be fed directly to Class.forName(String,boolean,ClassLoader)","label":{"api":{"Class.forName(String,boolean,ClassLoader)":[[28,68]]}}},{"text":"Starting with Java 9, there is java.lang.invoke.MethodHandles.Lookup.defineClass(byte[]), a standard method define a class within another class’ context, but it requires non-standard ways, e.g","label":{"api":{"java.lang.invoke.MethodHandles.Lookup.defineClass(byte[])":[[31,87]]}}},{"text":"For a Java Agent, there’s also the option to dump the class file(s) into a temporary Jar file and add it to the bootstrap class path programmatically, if it doesn’t mind that this involves I/O","label":{"api":{}}},{"text":"I DO NOT recommend this, but because of any reason if you can't change the original class (to a singleton), you can consider the below approach which calls the createEntity(entityManager) inside @PostConstruct method","label":{"api":{"createEntity(entityManager)":[[160,186]],"@PostConstruct":[[195,208]]}}},{"text":"The access override is needed because we’re invoking a protected method, but being a protected method, it’s still part of the API, which exists in all implementations and won’t go away in future versions","label":{"api":{"a protected method":[[53,70],[83,100]]}}},{"text":"You should design the run method so that it can determine for itself when to terminate, for example by polling the state of an AtomicBoolean","label":{"api":{"AtomicBoolean":[[127,139]]}}},{"text":"For example, there is the Files.walk method that allows you to iterate over all files in the folder","label":{"api":{"Files.walk":[[26,35]]}}},{"text":"To read, write and rename a file there are Files.readAllLines, Files.write and Files.move methods respectively","label":{"api":{"Files.readAllLines":[[43,60]],"Files.write":[[63,73]],"Files.move":[[79,88]]}}},{"text":"This time, using java.lang.String.split, the result does not include the trailing empty String","label":{"api":{"java.lang.String.split":[[17,38]]}}},{"text":"For one thing, there is the computeIfAbsent method which does exactly what your fetchA method does","label":{"api":{"computeIfAbsent":[[28,42]]}}},{"text":"You should to use Platform.runLater","label":{"api":{"Platform.runLater":[[18,34]]}}},{"text":"You may want to consider using Platform.exit() instead of System.exit though","label":{"api":{"Platform.exit()":[[31,45]]}}},{"text":"You could use Collectors.groupingBy and filter them into a stream","label":{"api":{"Collectors.groupingBy":[[14,34]]}}},{"text":"The documentation for Arrays.stream doesn't explicitly say the returned stream is ordered, but it does mention","label":{"api":{"Arrays.stream":[[22,34]]}}},{"text":"But currently, Arrays.stream does this too","label":{"api":{"Arrays.stream":[[15,27]]}}},{"text":"If you want another key, see UUID which can help you generate unique keys for your Firebase database without having to use the push() method","label":{"api":{"UUID":[[29,32]],"Firebase":[[83,90]],"push()":[[127,132]]}}},{"text":"Just read the file line by line and remove the char sequence with java regex, then write them to a new file","label":{"api":{}}},{"text":"From what I understood from String documentation, matches method should only return true if my URL matches exactly my specialChars charSequence, which isn't what I want","label":{"api":{"String documentation":[[28,47]],"specialChars":[[118,129]],"charSequence":[[131,142]]}}},{"text":"But I can't find any other method to do what I'm trying to achieve on the String documentation","label":{"api":{"String documentation":[[74,93]]}}},{"text":"As the Properties.store javadoc says","label":{"api":{"Properties.store":[[7,22]]}}},{"text":"If the list is modified occasionally then you could use a ReadWriteLock or other access control mechanism","label":{"api":{"ReadWriteLock":[[58,70]]}}},{"text":"If charSequence is null, then using String::valueOf will return the text \"null\" which is different to a null reference and hence your condition won't work","label":{"api":{"charSequence":[[3,14]],"String::valueOf":[[36,50]]}}},{"text":"Then, instead of doing all of this in a thread that sleeps for 24 hours, instead consider doing this inside a single static method, encapsulating a call to that in a TimerTask or something similar, and using a Timer or equivalent to schedule things","label":{"api":{"TimerTask":[[166,174]],"Timer":[[210,214]]}}},{"text":"Each line is stored in a CharBuffer (which implements CharSequence) and contains multiple integers and floating point numbers at fixed positions","label":{"api":{"CharBuffer":[[25,34]],"CharSequence":[[54,65]]}}},{"text":"In a first version I used String.substring​(int beginIndex, int endIndex) with Integer.parseInt​(String s) and Double.parseDouble​(String s)","label":{"api":{"String.substring​(int beginIndex, int endIndex)":[[26,72]],"Integer.parseInt​(String s)":[[79,105]],"Double.parseDouble​(String s)":[[111,139]]}}},{"text":"The garbage collector was eating up a lot of resources because of the creation of dozens of temporary String objects multiple times per line","label":{"api":{"String":[[102,107]]}}},{"text":"After I switched to Integer.parseInt​(CharSequence s, int beginIndex, int endIndex, int radix) I got a major performance increase","label":{"api":{"Integer.parseInt​(CharSequence s, int beginIndex, int endIndex, int radix)":[[20,93]]}}},{"text":"It can parse the number directly from the CharBuffer","label":{"api":{"CharBuffer":[[42,51]]}}},{"text":"Does anyone know a method or library which provides floating parsing on CharSequence and offsets instead of String","label":{"api":{"CharSequence":[[72,83]],"String":[[108,113]]}}},{"text":"I want to use JavaFX WebEngine in such a way that I can execute Javascript code in order to fill one form and click submit button on the website I opened","label":{"api":{"JavaFX WebEngine":[[14,29]]}}},{"text":"You can use Integer#valueOf","label":{"api":{"Integer#valueOf":[[12,26]]}}},{"text":"Derive the new font and then use it","label":{"api":{"Derive the new font":[[0,18]]}}},{"text":"I am looking at https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility and having trouble understanding what this means - \"All actions in a thread happen-before any other thread successfully returns from a join on that thread.\" Can I please get an example on what this means and what is the happen-before guarantee in the example","label":{"api":{}}},{"text":"Add the elements of one map to the other one at a time using Map.merge","label":{"api":{"Map.merge":[[61,69]]}}},{"text":"the only constructor for Character is Character(char) but you are invoking Character(String)","label":{"api":{"Character(char)":[[38,52]],"Character(String)":[[75,91]]}}},{"text":"Use Integer.compare instead, in the same way that you correctly used Double.compare in PostingsEntry.compareTo","label":{"api":{"Integer.compare":[[4,18]],"Double.compare":[[69,82]],"PostingsEntry.compareTo":[[87,109]]}}},{"text":"It sounds like you might want to use the ServicerLoader interface, which has been available since Java 6","label":{"api":{"ServicerLoader":[[41,54]]}}},{"text":"You could use a TableView for this","label":{"api":{"TableView":[[16,24]]}}},{"text":"Here is also a good tutorial on the TableView","label":{"api":{"TableView":[[36,44]]}}},{"text":"Since you apparently don’t have experience with DateFormats or DateTimeFormatters, I’m going to suggest a much simpler approach","label":{"api":{"DateFormats":[[48,58]],"DateTimeFormatter":[[63,79]]}}},{"text":"You can also use an implicit Formatter","label":{"api":{"Formatter":[[29,37]]}}},{"text":"From the java.lang.reflect.Method docs","label":{"api":{"java.lang.reflect.Method":[[9,32]]}}},{"text":"@exception InvocationTargetException if the underlying method throws an exception","label":{"api":{"InvocationTargetException":[[11,35]]}}},{"text":"You are catching an InvocationTargetException, it will be thrown with a RuntimeException cause","label":{"api":{"InvocationTargetException":[[20,44]],"RuntimeException":[[72,87]]}}},{"text":"You can use List::contains to filter using a list of Strings","label":{"api":{"List::contains":[[12,25]]}}},{"text":"Using a Scanner is much more appropriate and faster in this case","label":{"api":{"Scanner":[[8,14]]}}},{"text":"Here's an example with java.util.logging","label":{"api":{"java.util.logging":[[23,39]]}}},{"text":"Here's an example of Formatter that will only display the message of any Exception","label":{"api":{"Formatter":[[21,29]]}}},{"text":"Using Field[] fields = YourClassName.class.getFields(); returns all class fields as java.lang.reflect.Field","label":{"api":{"YourClassName.class.getFields()":[[23,53]],"java.lang.reflect.Field":[[84,106]]}}},{"text":"You can check if field is public using Field.getModifiers() and Modifier.isPublic(Modifier)","label":{"api":{"Field.getModifiers()":[[39,58]],"Modifier.isPublic(Modifier)":[[64,90]]}}},{"text":"You can get the field value using Object Field.get()","label":{"api":{"Object Field.get()":[[34,51]]}}},{"text":"As demonstrated by this answer, a HashSet of the same content can exhibit a different order for its elements, depending on its actual capacity (a function of the set’s history) or actual Java runtime version, despite the contained elements have a well defined hashCode() implementation","label":{"api":{"HashSet":[[34,40]],"hashCode()":[[260,269]]}}},{"text":"HashMap#get(Object) it is not feasible to avoid it entirely","label":{"api":{"HashMap#get(Object)":[[0,18]]}}},{"text":"Stream's map method requires a Function that takes in exactly one parameter and returns something else","label":{"api":{"map method":[[9,18]]}}},{"text":"If you can use Java 9, you can achieve your goal with Collectors.flatMapping","label":{"api":{"Collectors.flatMapping":[[54,75]]}}},{"text":"Try using the CountedCompleter class","label":{"api":{"CountedCompleter":[[14,29]]}}},{"text":"In you case, you can use mapToDouble (there is no mapToFloat method)","label":{"api":{"mapToDouble":[[25,35]],"mapToFloat":[[50,59]]}}},{"text":"removeIf is a convenient Java 8 method to remove all of the elements that satisfy the given predicate","label":{"api":{"removeIf":[[0,7]]}}},{"text":"Therefore, we should make removeRecursively return true if after the children.removeIf call the children list is empty","label":{"api":{"removeRecursively":[[26,42]],"children.removeIf":[[69,85]]}}},{"text":"From the docs for the ECGenParameterSpec constructor","label":{"api":{"ECGenParameterSpec":[[22,39]]}}},{"text":"As for enumerating various algorithms, I believe what you are after is java.security.Security.getProviders(String filter)","label":{"api":{"java.security.Security.getProviders(String filter)":[[71,120]]}}},{"text":"As for ECGenParameterSpec, its only internal member is the single String object that you pass to it","label":{"api":{"ECGenParameterSpec":[[7,24]]}}},{"text":"Well, it implements AlgorithmParameterSpec, which (from the docs)","label":{"api":{"AlgorithmParameterSpec":[[20,41]]}}},{"text":"As far as I am aware, these are only available as the two constants of NamedParameterSpec","label":{"api":{"NamedParameterSpec":[[71,88]]}}},{"text":"Your code calls the remove() method inherited from the Container class - you want to manipulate the table model used by your table","label":{"api":{"remove()":[[20,27]]}}},{"text":"You should really be looking into System.nanoTime (and stick to that) - that is the best you can get in the JVM AFAIK","label":{"api":{"System.nanoTime":[[34,48]]}}},{"text":"There are two things to keep in mind though, first is that each call to System.nanoTime has a performance implication as well, on average it takes (on my, close to your CPU and JVM-9) 25 ns per call","label":{"api":{"System.nanoTime":[[72,86]]}}},{"text":"The last point is that System.nanoTime has nano-second precision, but not nano-second accuracy","label":{"api":{"System.nanoTime":[[23,37]]}}},{"text":"Since System.nanoTime returns a value that is arbitrary, there isn't something to compare it with, unless other call to System.nanoTime, thus","label":{"api":{"System.nanoTime":[[6,20],[120,134]]}}},{"text":"Use System.nanoTime, there isn't something faster or more fine-grained","label":{"api":{"System.nanoTime":[[4,18]]}}},{"text":"Alternatively, check out javax.json.stream","label":{"api":{"javax.json.stream":[[25,41]]}}},{"text":"Now you no longer block forever on synchronized, but can use tryLock(long, TimeUnit) to timeout and prevent deadlocks","label":{"api":{"tryLock(long, TimeUnit)":[[61,83]]}}},{"text":"writer.write(i) writes a character represented by the lower 16 bits of the provided int argument to the stream, not the string representation of that integer","label":{"api":{"writer.write(i)":[[0,14]]}}},{"text":"For instance, the following program checks if a String is an instance of the interface CharSequence (which it is)","label":{"api":{"String":[[48,53]],"CharSequence":[[87,98]]}}},{"text":"The sorted intermediate operation can take a Comparator instance which in this case is","label":{"api":{}}},{"text":"You may also want to look at the toMap method for further information on how it works","label":{"api":{"toMap":[[33,37]]}}},{"text":"If you want to use built-in facility to do this, have a look at File.createTempFile()","label":{"api":{"File.createTempFile()":[[64,84]]}}},{"text":"The Properties API doesn't provide such a feature","label":{"api":{"Properties API":[[4,17]]}}},{"text":"The contract for distinct() reads","label":{"api":{"distinct()":[[17,26]]}}},{"text":"You can use Java 8 Collectors.collectingAndThen() method","label":{"api":{"Collectors.collectingAndThen()":[[19,48]]}}},{"text":"Key interface is ServerEndpoint","label":{"api":{"ServerEndpoint":[[17,30]]}}},{"text":"As to why the trailing slash disappears from your file paths, that's part of how File#toString() is supposed to work","label":{"api":{"File#toString()":[[81,95]]}}},{"text":"According to the docs, File#toString() returns the same string as File#getPath()","label":{"api":{"File#toString()":[[23,37]],"File#getPath()":[[66,79]]}}},{"text":"The docs for that method, in turn, say","label":{"api":{}}},{"text":"According to this Value-based classes rule, it might produce unpredictable results in case of deserialization","label":{"api":{}}},{"text":"First create a Scanner object for user input, then use the example code you've already got where cart.add(item) adds the user input item, and loop each item for user input quantity","label":{"api":{"Scanner":[[15,21]],"cart.add(item)":[[97,110]]}}},{"text":"Make the PrintWriter auto-flushable using the appropriate constructor and call println to include a line-feed character","label":{"api":{}}},{"text":"One test case executes bash -c echo Hello via ProcessBuilder","label":{"api":{"ProcessBuilder":[[46,59]]}}},{"text":"ProcessBuilder.start() eventually returns normally","label":{"api":{"ProcessBuilder.start()":[[0,21]]}}},{"text":"Even if the child process was hung, ProcessBuilder.start() should return and then I can read from Process.getInputStream()","label":{"api":{"ProcessBuilder.start()":[[36,57]],"Process.getInputStream()":[[98,121]]}}},{"text":"The general approach is that you have to create a ListModel which wraps the Vector and then you configure the JList to use this model","label":{"api":{"ListModel":[[50,58]],"Vector":[[76,81]],"JList":[[110,114]]}}},{"text":"No it is not guaranteed unless you use a fair lock  with a condition rather than a wait/notify","label":{"api":{}}},{"text":"Per Javadoc on HashMap, you can do","label":{"api":{"Javadoc on HashMap":[[4,21]]}}},{"text":"Use find() instead","label":{"api":{"find()":[[4,9]]}}},{"text":"Collectors class provides Collectors.groupingBy(keyProvider, downstream) you can use to group by a pair of values","label":{"api":{"Collectors.groupingBy(keyProvider, downstream)":[[26,71]]}}},{"text":"To pair two values you can either use AbstractMap.SimpleEntry or you can implement your own Pair<T,K> class that represents a pair of two values (it's worth mentioning that you will have to implement hashCode() and equals(object) methods in your Pair class if you want to use it as a key in a hash map)","label":{"api":{"AbstractMap.SimpleEntry":[[38,60]],"Pair<T,K>":[[92,100]],"hashCode()":[[200,209]],"equals(object)":[[215,228]]}}},{"text":"In this example I have used AbstractMap.SimpleEntry to represent a pair of Country and street","label":{"api":{"AbstractMap.SimpleEntry":[[28,50]]}}},{"text":"You can add a listener to the locationProperty, and redirect it if the new location matches a URL you want to redirect","label":{"api":{"locationProperty":[[30,45]]}}},{"text":"I see no good reason to use Byte rather than byte in your array","label":{"api":{"Byte":[[28,31]]}}},{"text":"Bindings.format can be used for this purpose","label":{"api":{"Bindings.format":[[0,14]]}}},{"text":"Example remove(int) - java.util.AbstractList","label":{"api":{"remove(int)":[[8,18]],"java.util.AbstractList":[[22,43]]}}},{"text":"In your case the Queue will also be better than LinkedList, so look at ConcurrentLinkedQueue provided by concurrent package","label":{"api":{"ConcurrentLinkedQueue":[[71,91]]}}},{"text":"A better way to address your issue is defining a javax.persistence.AttributeConverter and using it with @Convert","label":{"api":{"javax.persistence.AttributeConverter":[[49,84]],"@Convert":[[104,111]]}}},{"text":"Then declare  a PaymentStatuses status in your entity and annotate it with @Convert by specifying the AttributeConverter implementation class","label":{"api":{"PaymentStatuses":[[16,30]],"@Convert":[[75,82]],"AttributeConverter":[[102,119]]}}},{"text":"Have you tried java.lang.reflect.Proxy and java.lang.reflect.InvocationHandler","label":{"api":{"java.lang.reflect.Proxy":[[15,37]],"java.lang.reflect.InvocationHandler":[[43,77]]}}},{"text":"If you can catch the exception, you can loop through the lines and print them yourself using the getStackTrace() method","label":{"api":{"getStackTrace()":[[97,111]]}}},{"text":"Instead of re-inventing the wheel, you should use a StringJoiner to join the strings together","label":{"api":{"StringJoiner":[[52,63]]}}},{"text":"Speaking of improvement, we could rewrite the method by using a thread pool with ExecutorService","label":{"api":{"ExecutorService":[[81,95]]}}},{"text":"I have simply transformed the Thread variables into Runnable ones, passed them to ExecutorService#submit and called Future#get","label":{"api":{"Thread":[[30,35]],"Runnable":[[52,59]],"ExecutorService#submit":[[82,103]],"Future#get":[[116,125]]}}},{"text":"One option is to use a simple XPath expression","label":{"api":{"XPath":[[30,34]]}}},{"text":"You can use the XPath classes provided in java.xml.xpath like so","label":{"api":{"XPath":[[16,20]],"java.xml.xpath":[[42,55]]}}},{"text":"You'll need to have your XML doc as some kind of InputSource object, such as an org.w3c.dom.Document","label":{"api":{"InputSource":[[49,59]],"org.w3c.dom.Document":[[80,99]]}}},{"text":"I would argue that it is not possible to write a function that can determine if a lambda is stateless or not","label":{"api":{"stateless":[[92,100]]}}},{"text":"Looking for example at the filter method of the Stream API, the javadoc states that the parameter must be \"a [...] stateless predicate\" and also links to the API's definition of stateless","label":{"api":{"stateless":[[115,123],[178,186]]}}},{"text":"If there was a way to determine if the parameter of the filter (or any other) method was stateless or not, the Stream class would have included the possibility to throw an IllegalArgumentException in case the parameter was a stateful lambda","label":{"api":{"stateless":[[89,97]],"IllegalArgumentException":[[172,195]]}}},{"text":"As this has not been implemented and only a warning was added to the javadocs, one can conclude that there is no way write a function that can determine if a lambda lambda is stateless","label":{"api":{"stateless":[[175,183]]}}},{"text":"The CopyFunction functional interface is pretty much the same as BinaryOperator except that BinaryOperator doesn't throw an exception","label":{"api":{"CopyFunction":[[4,15]],"BinaryOperator":[[65,78],[92,105]]}}},{"text":"If you want to handle exceptions within a function, you can use the BinaryOperator instead","label":{"api":{"BinaryOperator":[[68,81]]}}},{"text":"If you are lucky some of these classes implement AutoClosable but sometimes you just have to be careful and inspect the existing methods to notice that there is a close, destroy or shutdown method (or what ever the author decided to name it)","label":{"api":{"AutoClosable":[[49,60]]}}},{"text":"If you really want a list of Random numbers from 1-50 then you can use Random::nextInt to get a random number like this","label":{"api":{"Random::nextInt":[[71,85]]}}},{"text":"or even easier using Random::ints in Java 8","label":{"api":{"Random::ints":[[21,32]]}}},{"text":"Use a functional interface such as Runnable and a method reference","label":{"api":{"functional interface":[[6,25]],"Runnable":[[35,42]]}}},{"text":"The exact functional interface you'll want will depend on your use case","label":{"api":{"functional interface":[[10,29]]}}},{"text":"Have a look in the package java.util.function to find the one you need","label":{"api":{"java.util.function":[[27,44]]}}},{"text":"The reason of why list.stream().count() works but list.stream().sum() doesn't is because list.stream() returns a Stream<Integer> and there is a Stream::count method, but there isn't a Stream::sum or Stream::average","label":{"api":{"list.stream().count()":[[18,38]],"list.stream().sum()":[[50,68]],"list.stream()":[[89,101]],"Stream<Integer>":[[113,127]],"Stream::count":[[144,156]],"Stream::sum":[[184,194]],"Stream::average":[[199,213]]}}},{"text":"To get the sum and avg first you have to map each integer value in the Stream<Integer> that you get when you do list.stream() to an IntStream","label":{"api":{"Stream<Integer>":[[71,85]],"list.stream()":[[112,124]],"IntStream":[[132,140]]}}},{"text":"This can be done using the Stream::mapToInt method","label":{"api":{"Stream::mapToInt":[[27,42]]}}},{"text":"Doing this you can use the methods IntStream::sum and IntStream::average","label":{"api":{"IntStream::sum":[[35,48]],"IntStream::average":[[54,71]]}}},{"text":"Or even better, you can use the IntStream::summaryStatistics to get the sum, count and avg together (also the min and the max value)","label":{"api":{"IntStream::summaryStatistics":[[32,59]]}}},{"text":"To sort the values you can use the Stream::sorted method","label":{"api":{"Stream::sorted":[[35,48]]}}},{"text":"You can wrap the immutable vavr collection in an atomically updatable AtomicReference, and use one of its update methods to atomically update the reference to the immutable collection","label":{"api":{"AtomicReference":[[70,84]]}}},{"text":"Make sure you read the javadoc of AtomicReference if you are going to use them in other scenarios, as there are some requirements on the update functions that need to be respected to get correct behavior","label":{"api":{"AtomicReference":[[34,48]]}}},{"text":"However, it doesn't explain how to run it from Java with ScriptEngine","label":{"api":{"ScriptEngine":[[57,68]]}}},{"text":"I've tried to list all available ScriptEngineFactories with this code","label":{"api":{"ScriptEngineFactories":[[33,53]]}}},{"text":"In Java-8 you can use BiFunction to do it","label":{"api":{"BiFunction":[[22,31]]}}},{"text":"If we look at the official documentation we find that the only way how to negate something is by using bracket expressions","label":{"api":{}}},{"text":"Or, you can use an Executor and a Callable","label":{"api":{"Executor":[[19,26]],"Callable":[[34,41]]}}},{"text":"If you just want to convert the entries to lists but don't really care about changing the type of the collection then you can use map.replaceAll","label":{"api":{"map.replaceAll":[[130,143]]}}},{"text":"Also you do not have to explicitly close the result set, the prepared statement does it as it owns the result set","label":{"api":{}}},{"text":"But this can be done with core Java since version 8 - Stream API can do this and much more","label":{"api":{}}},{"text":"Since you're using the old API, turn on strict mode by calling setLenient(false) on the Calendar associated with the DateFormat you're using","label":{"api":{"setLenient(false)":[[63,79]],"Calendar":[[88,95]],"DateFormat":[[117,126]]}}},{"text":"This uses java.time.LocalTime and java.time.format.DateTimeFormatter for the conversion and should be capable of replacing everything inside your if statment","label":{"api":{"java.time.LocalTime":[[10,28]],"java.time.format.DateTimeFormatter":[[34,67]]}}},{"text":"Javadoc of RuntimeException says","label":{"api":{"RuntimeException":[[11,26]]}}},{"text":"RuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine","label":{"api":{"RuntimeException":[[0,15]]}}},{"text":"You can do it without regex, using split","label":{"api":{"split":[[35,39]]}}},{"text":"If you look up Scanner you will see an example to parse using a regex, I like that method better since with a regex you can validate the whole string at once but since that was not in the questions code I didn't use that method","label":{"api":{"Scanner":[[15,21]]}}},{"text":"As the specification states, “If a registered reference becomes unreachable itself, then it will never be enqueued”","label":{"api":{"the specification":[[3,19]]}}},{"text":"All that the specification makes clear, is, that as long as a reference object has not been enqueued, there is no reference from the queue to the reference object","label":{"api":{"the specification":[[9,25]]}}},{"text":"IntegerProperty inherits a lot of useful methods, including asString","label":{"api":{"asString":[[60,67]]}}},{"text":"The documentation of Period#between states the following","label":{"api":{"Period#between":[[21,34]]}}},{"text":"You can use the overload of Collectors.joining that takes prefix and suffix parameters","label":{"api":{"Collectors.joining":[[28,45]]}}},{"text":"A more secure and versatile solution involves using a PreparedStatement","label":{"api":{"PreparedStatement":[[54,70]]}}},{"text":"Well, the extreme values are Double.MIN_VALUE and Double.MAX_VALUE","label":{"api":{"Double.MIN_VALUE":[[29,44]],"Double.MAX_VALUE":[[50,65]]}}},{"text":"You can use streams in combination with the groupingBy collector","label":{"api":{"groupingBy":[[44,53]]}}},{"text":"Use File#exists and File#createNewFile","label":{"api":{"File#exists":[[4,14]],"File#createNewFile":[[20,37]]}}},{"text":"I suggest you to use the CubicCurve class which represents a cubic Bézier parametric curve segment and has control points","label":{"api":{"CubicCurve":[[25,34]]}}},{"text":"In your case, you need to do the correct check for String equality with String.equals() method","label":{"api":{"String.equals()":[[72,86]]}}},{"text":"I would recommend using ArrayList for dynamic array","label":{"api":{"ArrayList":[[24,32]]}}},{"text":"If you want to have your own interface, you can always wrap a java.util.Queue in your own Queue","label":{"api":{"java.util.Queue":[[62,76]]}}},{"text":"A solution would be to use the 2dRectangle class and simply check the X and Y coordinates of the rectangle to know what side it collided on","label":{"api":{"2dRectangle":[[31,41]]}}},{"text":"This uses the Stream.collect method","label":{"api":{"Stream.collect":[[14,27]]}}},{"text":"If you take a look at list of available constructors of this class in Java API documentation here, you'll notice that the one taking long as argument will be chosen","label":{"api":{"in Java API documentation here":[[67,96]]}}},{"text":"With the JAXP and SAX based Transformers you can however avoid the use of an intermediary file and simply set up some handlers (https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/sax/SAXTransformerFactory.html) e.g","label":{"api":{}}},{"text":"The documentation for ImageIO.read states that the InputStream argument is wrapped in an ImageInputStream","label":{"api":{"documentation for ImageIO.read":[[4,33]],"InputStream":[[51,61]],"ImageInputStream":[[89,104]]}}},{"text":"I don’t think you can safely assume that it only reads as far as it needs to;  it may read ahead farther, for caching purposes, or perhaps in order to know what to return from its length() method","label":{"api":{"length()":[[180,187]]}}},{"text":"The details of the serialization methods’ signatures are described in the documentation for Serializable","label":{"api":{"documentation for Serializable":[[74,103]]}}},{"text":"The InputStream class is an abstract class","label":{"api":{"InputStream class":[[4,20]]}}},{"text":"Depending on how your data is generated, it may be beneficial to additionally override other methods of the InputStream class","label":{"api":{"InputStream class":[[108,124]]}}},{"text":"Particularly, the read(byte[] b, int off, int len) method that reads an array of bytes from the source","label":{"api":{"read(byte[] b, int off, int len) method":[[18,56]]}}},{"text":"You could chain all these tasks one after another consistently calling .thenCompose","label":{"api":{".thenCompose":[[71,82]]}}},{"text":"Use new FileWriter(\"C:\\\\Users\\\\flori\\\\workspace\\\\Projet_Q2\\\\src\\\\json.json\", true) if you want to append","label":{"api":{"FileWriter(\"C:\\\\Users\\\\flori\\\\workspace\\\\Projet_Q2\\\\src\\\\json.json\", true)":[[8,81]]}}},{"text":"(to then pass an instance of such a CopyingWriter to the ctor of BufferedWriter)","label":{"api":{"CopyingWriter":[[36,48]],"BufferedWriter":[[65,78]]}}},{"text":"When you invalidate the session, doesn't mean that the reference of the session become null","label":{"api":{"invalidate":[[9,18]]}}},{"text":"When you invalidate, it just remove all the data inside it and itself gets removed from the session pool","label":{"api":{"invalidate":[[9,18]]}}},{"text":"So when you ask for the session in current context, you don't receive any session as the session invalidated","label":{"api":{"invalidate":[[97,106]]}}},{"text":"It uses the useful Optional.stream() method, which was added in JDK 9","label":{"api":{"Optional.stream()":[[19,35]]}}},{"text":"If your byte arrays, converted from hex in the file, are big-endian as is conventional, to convert a positive big-endian byte array to BigInteger look at the javadoc for BigInteger for the constructor that takes an int sign for positive and a big-endian byte array for magnitude","label":{"api":{"BigInteger":[[135,144]],"the javadoc for BigInteger":[[154,179]]}}},{"text":"Instead you can use the BigInteger constructor that takes a string and radix, using 16 as radix","label":{"api":{"BigInteger constructor that takes a string and radix":[[24,75]]}}},{"text":"Use Platform.runLater with a Runnable parameter that contains the code for updating the UI","label":{"api":{"Platform.runLater":[[4,20]]}}},{"text":"See Arrays which would come handy here","label":{"api":{"Arrays":[[4,9]]}}},{"text":"If you are using Java 8 you can use java.time library","label":{"api":{"java.time":[[36,44]]}}},{"text":"The BigDecimal rounding features several RoundingModes, including those rounding up (away from zero) or towards positive infinity","label":{"api":{"BigDecimal":[[4,13]],"RoundingMode":[[41,52]]}}},{"text":"If that's what you need, you can perform rounding by calling setScale as follows","label":{"api":{"setScale":[[61,68]]}}},{"text":"The .toBigDecimal() extension is available since Kotlin 1.2","label":{"api":{".toBigDecimal()":[[4,18]]}}},{"text":"It's a short-circuiting terminal operation","label":{"api":{}}},{"text":"The built-in PriorityQueue has constructors for creating a queue using Comparable objects, and for creating a queue using a Comparator","label":{"api":{"PriorityQueue":[[13,25]],"Comparable":[[71,80]],"Comparator":[[124,133]]}}},{"text":"PriorityQueue() - orders its elements according to their natural ordering","label":{"api":{"PriorityQueue()":[[0,14]]}}},{"text":"The easiest way to implement your own class with similar semantics, is to always use a Comparator, and just use the natural comparator when none is provided","label":{"api":{"Comparator":[[87,96]]}}},{"text":"If you want to ensure you get compilation error if creating the collection on an object that is not Comparable without supplying a Comparator, you can guard against that by using factory methods","label":{"api":{"Comparable":[[100,109]],"Comparator":[[131,140]]}}},{"text":"One of Arrays.sort overloads accepts Comparator as the second parameter, in which you can implement your own custom comparison function to determine whether a string should be placed before or after another simply by implementing the compare method","label":{"api":{"Arrays.sort":[[7,17]],"Comparator":[[37,46]],"compare":[[234,240]]}}},{"text":"The Process returned by ProcessBuilder is run asynchronously in the background (it's a separate process), so as soon as you call .start() you can have the servlet respond","label":{"api":{"Process":[[4,10],[24,30]],".start()":[[129,136]]}}},{"text":"If you're seeing the subprocess never finish that would be because you're not reading its output, which you must do in order for the process to continue","label":{"api":{"output":[[90,95]]}}},{"text":"There is a  method called Integer#parseInt(String) which returns an int representation of a given String (if possible)","label":{"api":{"Integer#parseInt(String)":[[26,49]]}}},{"text":"If you want to change it back to a String, use String#valueOf(int)","label":{"api":{"String#valueOf(int)":[[47,65]]}}},{"text":"It won't allow you to send an int[] into the toArray method, because that method accepts an array of a type parameter, which must be a reference type, not a primitive type such as int","label":{"api":{"toArray method":[[45,58]]}}},{"text":"You can use Arrays.setAll to copy the elements into an array you've created","label":{"api":{"Arrays.setAll":[[12,24]]}}},{"text":"There are overloads of Arrays.setAll for setting long[], double[], and T[] arrays, as well as corresponding parallelSetAll methods that are parallel versions of each method","label":{"api":{"Arrays.setAll":[[23,35]],"parallelSetAll":[[108,121]]}}},{"text":"Then you can call setParseBigDecimal and set it to true so that parse returns a BigDecimal","label":{"api":{"setParseBigDecimal":[[18,35]],"BigDecimal":[[80,89]]}}},{"text":"Use the List method subList(from, to)","label":{"api":{"subList(from, to)":[[20,36]]}}},{"text":"For Java 8 you can use DateTimeFormatter which is threadsafe","label":{"api":{"DateTimeFormatter":[[23,39]]}}},{"text":"If the window itself does not have room to display the JLabel’s new text, you probably should call the window’s pack() method after changing the text","label":{"api":{"pack()":[[112,117]]}}},{"text":"This is typically done with a CardLayout, which lets you place several components on top of each other, with only one of them visible at any given moment","label":{"api":{"CardLayout":[[30,39]]}}},{"text":"Since you want to show no text at all, initially, you would add an empty JLabel as the first component in the CardLayout, so it is shown by default","label":{"api":{"CardLayout":[[110,119]]}}},{"text":"They are just unique identifiers for each component (“card”) in the CardLayout","label":{"api":{"CardLayout":[[68,77]]}}},{"text":"The reason I think it should be infinite is that according to the documentation here (https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#replaceAll-java.lang.String-) a call to replaceAll will reset the matcher (This method first resets this matcher","label":{"api":{}}},{"text":"An easier approach would be to abandon the Scanner altogether, let java.nio.io.Files to the reading for you and then just handle each line","label":{"api":{"java.nio.io.Files":[[67,83]]}}},{"text":"As per the Java SE 8 Documentation, the BufferedWriter class has the following methods of its own(w.r.t writing data)","label":{"api":{"Java SE 8 Documentation":[[11,33]],"BufferedWriter":[[40,53]]}}},{"text":"write(String str) in Writer calls write(String str, int off, int len), which is overridden in BufferedWriter","label":{"api":{"write(String str)":[[0,16]],"write(String str, int off, int len)":[[34,68]],"BufferedWriter":[[94,107]]}}},{"text":"The problem I'm facing is that after relocation to a different package, when trying to call the native methods from that library, I get UnsatisfiedLinkError","label":{"api":{"UnsatisfiedLinkError":[[136,155]]}}},{"text":"I compared JVM-MANAGEMENT-MIB.mib for Java 6 and Java 8 and I have found no difference","label":{"api":{"JVM-MANAGEMENT-MIB.mib":[[11,32]]}}},{"text":"By calling Map#get() you are getting the value and not the key","label":{"api":{"Map#get()":[[11,19]]}}},{"text":"Instead you can use BigInteger#pow() to get rid of overflow","label":{"api":{"BigInteger#pow()":[[20,35]]}}},{"text":"JavaFX's Tab class provides a setOnClosed method to add an event handler that is executed when the tab has been closed","label":{"api":{"Tab":[[9,11]],"setOnClosed":[[30,40]]}}},{"text":"What I haven't achieved yet is to add multiple event handlers, since calling setOnClosed a second time \"overwrites\" the event handler set on the first call","label":{"api":{"setOnClosed":[[77,87]]}}},{"text":"a String is a built-in class that will not allow you to add your own methods to it, and in addition it is also a final class, so it won't allow you to subclass it either","label":{"api":{"String":[[2,7]]}}},{"text":"It seems this can only be done using annotations processor (https://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html)","label":{"api":{}}},{"text":"Interface ThreadMXBean which was introduced in java 5, comes handy in such scenario","label":{"api":{"ThreadMXBean":[[10,21]]}}},{"text":"You can find ThreadInfo for a thread using ThreadMxBean::getThreadInfo, it takes thread id as input","label":{"api":{"ThreadInfo":[[13,22]],"ThreadMxBean::getThreadInfo":[[43,69]]}}},{"text":"ThreadInfo has a method getLockName() which returns a string representing the monitor object on which a thread is blocked on","label":{"api":{"ThreadInfo":[[0,9]],"getLockName()":[[24,36]]}}},{"text":"HashSet does not preserve the insertion order but List does","label":{"api":{"HashSet":[[0,6]],"List":[[50,53]]}}},{"text":"You can try with LinkedHashSet instead","label":{"api":{"LinkedHashSet":[[17,29]]}}},{"text":"An other alternative is to use a TreeSet","label":{"api":{"TreeSet":[[33,39]]}}},{"text":"The sort is made using the method compareTo (provided by the Comparable interface)","label":{"api":{"compareTo":[[34,42]],"Comparable":[[61,70]]}}},{"text":"This might help","label":{"api":{}}},{"text":"Since this is just a temporary file, consider using the File.createTempFile method","label":{"api":{"File.createTempFile":[[56,74]]}}},{"text":"To keep only the number, you can use String::replaceAll which use regular expression like this","label":{"api":{"String::replaceAll":[[37,54]]}}},{"text":"The Executors.newWorkStealingPool() produces a ForkJoinPool","label":{"api":{"Executors.newWorkStealingPool()":[[4,34]],"ForkJoinPool":[[47,58]]}}},{"text":"The ForkJoinPool class does not implement the ScheduledExecutorService interface so you cannot cast it to a ScheduledExecutorService","label":{"api":{"ForkJoinPool":[[4,15]],"ScheduledExecutorService":[[46,69],[108,131]]}}},{"text":"Furthermore the ForkJoinPool and ScheduledExecutorService are fundamentally different thread pools","label":{"api":{"ForkJoinPool":[[16,27]],"ScheduledExecutorService":[[33,56]]}}},{"text":"If you need to schedule a task to execute once every second stick with a ScheduledExecutorService, since it is suitable for your use case","label":{"api":{"ScheduledExecutorService":[[73,96]]}}},{"text":"ForkJoinPools are intended to use in cases where you have many small units of work divided among many threads, not for when you want to regularly execute something","label":{"api":{"ForkJoinPool":[[0,11]]}}},{"text":"chooser.getSelectedFile() already returns File, so you can call listFiles() directly on its return value","label":{"api":{"chooser.getSelectedFile()":[[0,24]],"listFiles()":[[64,74]]}}},{"text":"Just as List#of, Set#of, and Map#ofEntries allow us to create unmodifiable implementations in Java 9, the copyOf methods provide a convenient way to create unmodifiable implementations from existing Collections and Maps (depending on the method, as Map#copyOf accepts a Map) in Java 10","label":{"api":{"List#of":[[8,14]],"Set#of":[[17,22]],"Map#ofEntries":[[29,41]]}}},{"text":"It is however recommended to use ThreadLocalRandom in a multi-threaded program (for better performance), and it doesn't hurt in a single-threaded program, so general recommendation is to use that, which means Random should never be a Spring bean","label":{"api":{"ThreadLocalRandom":[[33,49]]}}},{"text":"Math.pow(double a, double b) doesn't accept a string as its first argument","label":{"api":{"Math.pow(double a, double b)":[[0,27]]}}},{"text":"Try to run execution of this method in separate Task","label":{"api":{"Task":[[48,51]]}}},{"text":"Ideally, for the clean code sake, you should create a separate ToCSVTask class with this logic and submit it to ExecutorService - you may google the cleanest way how to do it","label":{"api":{"ToCSVTask":[[63,71]],"ExecutorService":[[112,126]]}}},{"text":"I am having a hard time figuring out how to do the same for asynchronously-loaded values (using CompletableFuture)","label":{"api":{"CompletableFuture":[[96,112]]}}},{"text":"Specifically, I want a mechanism that will return a CompletableFuture that will return a cached value if available; otherwise, calculate and cache the value","label":{"api":{"CompletableFuture":[[52,68]]}}},{"text":"I'm afraid that if I use Supplier<CompletableFuture<Integer>> cache = Suppliers.memoize() then the supplier will cache the CompletableFuture but consumers will re-run the pipeline every time","label":{"api":{"Supplier<CompletableFuture<Integer>>":[[25,60]],"Suppliers.memoize()":[[70,88]],"CompletableFuture":[[123,139]]}}},{"text":"You may want to just use the same classes in the java.util.jar package that the jar command uses","label":{"api":{"java.util.jar package":[[49,69]]}}},{"text":"You can use the ThreadPoolExecutor & Executors(factory) in Java to create Thread pools to which you can submit your read & write tasks","label":{"api":{"ThreadPoolExecutor":[[16,33]],"Executors(factory)":[[37,54]]}}},{"text":"If you want to add a day to a LocalDateTime, use plusDays","label":{"api":{"plusDays":[[49,56]]}}},{"text":"If you need different units of time, convert accordingly with TimeUnit","label":{"api":{"TimeUnit":[[62,69]]}}},{"text":"I'm trying to create a DateTimeFormatter to match the following example (it's actually slightly more complex than this but that shouldn't matter)","label":{"api":{"DateTimeFormatter":[[23,39]]}}},{"text":"It appears to be failing on the colon between 17:45 and DateTimeFormatterBuilder.appendLiteral doesn't give any clues","label":{"api":{"DateTimeFormatterBuilder.appendLiteral":[[56,93]]}}},{"text":"Use the LocalTime class","label":{"api":{"LocalTime":[[8,16]]}}},{"text":"CompletableFuture.completedFuture() returns a CompletedFuture that is already completed with the given value","label":{"api":{"CompletableFuture.completedFuture()":[[0,34]],"CompletedFuture":[[46,60]]}}},{"text":"Java 9 provides CompletableFuture.failedFuture​(Throwable ex) that does exactly that","label":{"api":{"CompletableFuture.failedFuture​(Throwable ex)":[[16,60]]}}},{"text":"You can use Platform.startup for this purpose","label":{"api":{"Platform.startup":[[12,27]]}}},{"text":"Note that you're only allowed to use Platform.startup and/or Application.launch once in your application","label":{"api":{"Platform.startup":[[37,52]],"Application.launch":[[61,78]]}}},{"text":"With Java NIO Path objects","label":{"api":{"Java NIO Path":[[5,17]]}}},{"text":"This uses Collectors.toMap, which expects a function that extracts the key of the map from the elements of the stream (here this would be A::getId, which extracts the id of A), a function that transforms each element of the stream to the values of the map (here it would be A::new, which references the copy constructor) and a merge function that combines two values of the map that have the same key (here this would be A::merge, which is only called when the map already contains an entry for the same key)","label":{"api":{"Collectors.toMap":[[10,25]],"A::getId":[[138,145]],"A::new":[[274,279]],"A::merge":[[421,428]]}}},{"text":"You can verify this by going to their documentation page (for example StringProperty) and scrolling down to where it says \"Methods inherited from class java.lang.Object\"","label":{"api":{"StringProperty":[[70,83]],"java.lang.Object":[[152,167]]}}},{"text":"Look at the method signature for addAll()","label":{"api":{"addAll()":[[33,40]]}}},{"text":"This would be a lot easier if your Appointment class took a Date object in the constructor; then your comparator would simply be","label":{"api":{}}},{"text":"The second argument is a long, not a Long","label":{"api":{}}},{"text":"The answer to your question is in the Files.lines javadoc","label":{"api":{"Files.lines":[[38,48]]}}},{"text":"Repeated use of the same literal string does not create a memory overhead, since all literal strings in Java source code are interned","label":{"api":{}}},{"text":"One way to do it to make Event comparable by date and make use of TreeSets floor method","label":{"api":{"floor":[[75,79]]}}},{"text":"Then in Timeseries class instead of List use TreeSet<Event> x and pad it wit a null entry to make floor return it if there is no previous value","label":{"api":{"TreeSet<Event>":[[45,58]],"floor":[[98,102]]}}},{"text":"It was replaced by the ProcessBuilder class a long time ago","label":{"api":{"ProcessBuilder class":[[23,42]]}}},{"text":"The simplest way to encode bits into byte array is via BitSet","label":{"api":{"BitSet":[[55,60]]}}},{"text":"The List javadocs mentions that Lists are ordered","label":{"api":{"List javadocs":[[4,16]]}}},{"text":"A running test which filters by filename across folders (without any helper method)","label":{"api":{"filter":[[21,26]]}}},{"text":"The predicate in your filter method is what makes the difference alongside flatMap as @Ernest refers to that flattens all the File elements into one list","label":{"api":{"predicate":[[4,12]],"filter":[[22,27]]}}},{"text":"But I can't just create one because the Class class has no public constructor (see https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html)","label":{"api":{}}},{"text":"Since you are intercepting Class.forName and assuming it is indeed intercepting something, you don't need to find the class, you already have it in your param1.getResult()","label":{"api":{"Class.forName":[[27,39]],"param1.getResult()":[[153,170]]}}},{"text":"Ofcourse, I can use java.exec to call the command, but that is the worst case scenario","label":{"api":{"java.exec":[[20,28]]}}},{"text":"The class HashSet is not an indexed collection","label":{"api":{"HashSet":[[10,16]]}}},{"text":"Wrap it in a java.io.PushbackReader, and push the temporarily read data back with the unread() method","label":{"api":{"java.io.PushbackReader":[[13,34]],"unread()":[[86,93]]}}},{"text":"Wrap it in a java.io.BufferedReader and use the mark() and reset() methods","label":{"api":{"java.io.BufferedReader":[[13,34]],"mark()":[[48,53]],"reset()":[[59,65]]}}},{"text":"If they come from each MyObject instance, you could try using Collectors.groupingBy along with Collectors.mapping instead of Collectors.toMap","label":{"api":{"MyObject":[[23,30]],"Collectors.groupingBy":[[62,82]],"Collectors.mapping":[[95,112]],"Collectors.toMap":[[125,140]]}}},{"text":"It isn't a good idea to post-modify generated code, but you could look into building a set of custom Comparators, which exist outside the class, such that you can use Comparatar.compare(T object1, T object2) to compare them","label":{"api":{"Comparatar.compare(T object1, T object2)":[[167,206]]}}},{"text":"You could use a static AtomicInteger","label":{"api":{"AtomicInteger":[[23,35]]}}},{"text":"An AtomicInteger does not need synchronization","label":{"api":{"AtomicInteger":[[3,15]]}}},{"text":"Attempting that will raise ClassCastException","label":{"api":{"ClassCastException":[[27,44]]}}},{"text":"Make use of Comparator.comparingLong()","label":{"api":{"Comparator.comparingLong()":[[12,37]]}}},{"text":"You can wrap the orignal string in Optional.ofNullable","label":{"api":{"Optional.ofNullable":[[35,53]]}}},{"text":"They are not waiting on a lock, but rather on a Condition object","label":{"api":{"Condition":[[48,56]]}}},{"text":"You need Collectors.groupingBy to group the values by a key and apply mapping to the downstream by Collectors.mapping","label":{"api":{"Collectors.groupingBy":[[9,29]],"Collectors.mapping":[[99,116]]}}},{"text":"CopyOnWriteArrayList is the perfect example; extremely inefficient on mutations, but perfect if you perform mostly traversals","label":{"api":{"CopyOnWriteArrayList":[[0,19]]}}},{"text":"But it is recommended to control the number of threads by using some executor service implementation","label":{"api":{}}},{"text":"In your example, there's no reason to create threads yourself; you can simply utilize HttpClient#sendAsync","label":{"api":{"HttpClient#sendAsync":[[86,105]]}}},{"text":"The thing is, a List<String[][]> isn't a 3d array","label":{"api":{"List<String[][]>":[[16,31]]}}},{"text":"It is a List of 2d arrays","label":{"api":{"List":[[8,11]]}}},{"text":"So when you do a Collections.shuffle(list) you're only shuffling the order of the 2d arrays, not their content","label":{"api":{"Collections.shuffle(list)":[[17,41]]}}},{"text":"Imagine the List as a house, and the String[][] as their residents","label":{"api":{"List":[[12,15]]}}},{"text":"With Collections.shuffle(asList) you're just shuffling the order of the houses, but their residents are still the same","label":{"api":{"Collections.shuffle(asList)":[[5,31]]}}},{"text":"No, because the Collections interface is only applied to objects like lists, queues deque and such","label":{"api":{"Collections":[[16,26]]}}},{"text":"So Collections.shuffle won't work the way you want to on arrays","label":{"api":{"Collections.shuffle":[[3,21]]}}},{"text":"There is a function that makes arrays behave like lists, Arrays.asLists","label":{"api":{"Arrays.asLists":[[57,70]]}}},{"text":"If you Collections.shuffle QuestionBank you'll randomize the order of questions, and if you randomize THAT question, you'll randomize the order of their answers","label":{"api":{"Collections.shuffle":[[7,25]],"QuestionBank":[[27,38]]}}},{"text":"Matcher.end() is consistent with these","label":{"api":{"Matcher.end()":[[0,12]]}}},{"text":"You may also be interested in this pattern, which is quite similar (though not exactly the same) as what you are trying to do here","label":{"api":{}}},{"text":"Avoid starting Threads directly","label":{"api":{"Thread":[[15,20]]}}},{"text":"Consider an ExecutorService instead as shown below","label":{"api":{"ExecutorService":[[12,26]]}}},{"text":"Explore the Executors API for details on how to create an ExecutorService instance","label":{"api":{"Executors":[[12,20]],"ExecutorService":[[58,72]]}}},{"text":"In Java SE and in a Servlet container, you can use an ExecutorService for your long running task","label":{"api":{"ExecutorService":[[54,68]]}}},{"text":"In a Java EE container, you should use a ManagedExecutorService instead","label":{"api":{"ExecutorService":[[48,62]]}}},{"text":"I'm creating an access-ordered LinkedHashMap by using its overloaded constructor","label":{"api":{"overloaded constructor":[[58,79]]}}},{"text":"You can use String.join as following","label":{"api":{"String.join":[[12,22]]}}},{"text":"Once Instance implements Iterable, you will be able to iterate over the values","label":{"api":{"Iterable":[[25,32]]}}},{"text":"Collectors.toMap expects two Functions","label":{"api":{"Collectors.toMap":[[0,15]],"Functions":[[29,37]]}}},{"text":"You can use Map's getOrDefault method","label":{"api":{"getOrDefault":[[18,29]]}}},{"text":"Anyway, a better approach will be to split each line into an array of strings using String#split print the first strings, since it is the bowler name and then convert the last 3 into integers","label":{"api":{"String#split":[[84,95]]}}},{"text":"You can also use Scanner#nextInt() and Scanner#nextString() methods, since the structure of the file is known","label":{"api":{"Scanner#nextInt()":[[17,33]],"Scanner#nextString()":[[39,58]]}}},{"text":"You can construct your own Collector using Collector.of(...), like this","label":{"api":{"Collector":[[27,35]],"Collector.of(...)":[[43,59]]}}},{"text":"All you need is collectingAndThen","label":{"api":{"collectingAndThen":[[16,32]]}}},{"text":"You could use StringJoiner for this","label":{"api":{"StringJoiner":[[14,25]]}}},{"text":"You could find more about how to use StringJoiner here","label":{"api":{"StringJoiner":[[37,48]]}}},{"text":"I assume that you're using method #setRequestProperty(String, String) from class java.net.URLConnect, or its derived classes, and your code does not compile","label":{"api":{"#setRequestProperty(String, String)":[[34,68]],"java.net.URLConnect":[[81,99]]}}},{"text":"Because the signature of your validate methods are the same you can map a Function<String, Boolean> to a string like so","label":{"api":{"Function<String, Boolean>":[[74,98]]}}},{"text":"In Java, use a Deque when you want stack functionality","label":{"api":{"Deque":[[15,19]]}}},{"text":"Currently I am using CompletableFuture.handle(BiFunction) (see below) but I would like to use CompletableFuture.handleAsync(BiFunction, Executor), but I cannot figure out how to provide the vertx event loop thread to the second parameter in this method call","label":{"api":{"CompletableFuture.handle(BiFunction)":[[21,56]],"CompletableFuture.handleAsync(BiFunction, Executor)":[[94,144]]}}},{"text":"The string \"i\" is not a valid representation of a BigInteger","label":{"api":{"BigInteger":[[50,59]]}}},{"text":"As there is no constructor taking a single int parameter in the BigInteger class, you can use String.valueOf to return the string representation of the integer i","label":{"api":{"BigInteger":[[64,73]],"String.valueOf":[[94,107]]}}},{"text":"We are setting the parameter via setTimeStamp API of the PreparedStatement class.The error that we are seeing on execution of the above select query is as follows","label":{"api":{"setTimeStamp":[[33,44]],"PreparedStatement":[[57,73]]}}},{"text":"Can you try with setDate()","label":{"api":{"setDate()":[[17,25]]}}},{"text":"First of all, you should override findClass instead of loadClass","label":{"api":{"findClass":[[34,42]]}}},{"text":"Using the default implementation of loadClass, your findClass method can stay that simple","label":{"api":{"findClass":[[52,60]]}}},{"text":"let the findClass method trigger the instrumentation for the requested class","label":{"api":{"findClass":[[8,16]]}}},{"text":"you can just use String::split which take a regex, and you can use this regex (?=and|or) to split","label":{"api":{"String::split":[[17,29]]}}},{"text":"This has nothing to do with the Java built-in LinkedList, except in concept","label":{"api":{"LinkedList":[[46,55]]}}},{"text":"They usually start with singly-linked lists, as illustrated on Wikipedia, and will then cover other types of linked lists, such as doubly-linked lists (which is how the built-in LinkedList is implemented)","label":{"api":{"LinkedList":[[178,187]]}}},{"text":"In a full list implementation, the nodes are internal to a List class (like is done by LinkedList), but for simple/early implementations, only the ListNode class exists, and a list is represented by the reference to the \"head\" / first node of the list","label":{"api":{"LinkedList":[[87,96]]}}},{"text":"However, the intended approach for playing short sounds like the one you have is to use an AudioClip, instead of a MediaPlayer","label":{"api":{"AudioClip":[[91,99]]}}},{"text":"Unless I am unaware of an undocumented feature of the Java string.split() function (documentation here), your split function parameter is trying to split the string by the entire value \" , \\\\s ( )\", which is not literally present in the operand string","label":{"api":{"string.split()":[[59,72]],"documentation here":[[84,101]]}}},{"text":"You might want to make use of timestamps, taking advantage of System.currentTimeMillis(), which will give you elapsed milliseconds since 1 Jan 1970","label":{"api":{"System.currentTimeMillis()":[[62,87]]}}},{"text":"i.e., bindingSet.size() is large, prefer using StringBuilder or StringBuffer as these would give faster performance","label":{"api":{"bindingSet.size()":[[6,22]],"StringBuilder":[[47,59]],"StringBuffer":[[64,75]]}}},{"text":"You can use Field.getModifiers() to get the field modifiers","label":{"api":{"Field.getModifiers()":[[12,31]]}}},{"text":"You can then use Modifier.is* to find out","label":{"api":{"Modifier.is*":[[17,28]]}}},{"text":"You claim that \"there isn't a publicly constructable list entry\", but it's not true, there are JDK's SimpleImmutableEntry and Guava's Maps.immutableEntry you can use here (and they fit better than more generic Pair, which, in fact, cannot be found in both JDK or Guava","label":{"api":{"SimpleImmutableEntry":[[101,120]],"Maps.immutableEntry":[[134,152]]}}},{"text":"Rahter than using a Node object, why don't you use a LinkedList","label":{"api":{"LinkedList":[[53,62]]}}},{"text":"If the precision is really important, use BigDecimal","label":{"api":{"BigDecimal":[[42,51]]}}},{"text":"Since Java 11, you could use a static method InputStream.nullInputStream()","label":{"api":{"InputStream.nullInputStream()":[[45,73]]}}},{"text":"Figure out which logging back end you are using and just add an appender that serializes that thing to an ObjectOputStream and read it later at your leisure","label":{"api":{"ObjectOputStream":[[106,121]]}}},{"text":"The documentation for Task is very thorough so I would give that a read","label":{"api":{"documentation for Task":[[4,25]]}}},{"text":"Strongly consider an ExecutorService instead","label":{"api":{"ExecutorService":[[21,35]]}}},{"text":"This is almost identical to this answer, except I'm using the Map.entry() method to create the pairs and am putting the integers as the keys","label":{"api":{"Map.entry()":[[62,72]]}}},{"text":"You could explictly use a FileInputStream and an InputStreamReader using StandardCharsets.UTF_8, but it's probably simpler to use Files.newBufferedReader","label":{"api":{"FileInputStream":[[26,40]],"InputStreamReader":[[49,65]],"StandardCharsets.UTF_8":[[73,94]],"Files.newBufferedReader":[[130,152]]}}},{"text":"It's worth getting to know the Files class as it has a bunch of convenience methods like this","label":{"api":{"Files":[[31,35]]}}},{"text":"You can use String::matches with this regex (?i)searchWord.* not the (?i) which mean case-insensitive","label":{"api":{"String::matches":[[12,26]],"searchWord.*":[[48,59]]}}},{"text":"I used Use Pattern::quote to escape the special characters in your input","label":{"api":{"Pattern::quote":[[11,24]]}}},{"text":"String has a very useful regionMatches method with an ignoreCase parameter, so you can check if a region of a string matches another string case insensitively","label":{"api":{"regionMatches":[[25,37]],"ignoreCase":[[54,63]]}}},{"text":"See here for details about ResultSets","label":{"api":{"details about ResultSets":[[13,36]]}}},{"text":"You can convert your array to a List then use List::contains to check if the list contain the code or not","label":{"api":{"List::contains":[[46,59]]}}},{"text":"It is a public static object defined in java awt's Color","label":{"api":{"Color":[[51,55]]}}},{"text":"So you can access it as Color.GREEN","label":{"api":{"Color.GREEN":[[24,34]]}}},{"text":"This uses the Collection.removeAll method","label":{"api":{"Collection.removeAll":[[14,33]]}}},{"text":"Replace the other list with a java.util.Set","label":{"api":{"java.util.Set":[[30,42]]}}},{"text":"The documentation of PhantomReference says","label":{"api":{"PhantomReference":[[21,36]]}}},{"text":"It’s not clear why this has been specified and the get() method of PhantomReference has been overridden to always return null, exactly to disallow taking any benefit from the fact that this reference has not been cleared","label":{"api":{"get() method":[[51,62]],"PhantomReference":[[67,82]]}}},{"text":"An instance of interface for calling given MethodHandle can be generated with LambdaMetafactory.metafactory()","label":{"api":{"MethodHandle":[[43,54]],"LambdaMetafactory.metafactory()":[[78,108]]}}},{"text":"Have a look at the API docs for Java SE","label":{"api":{"Java SE":[[32,38]]}}},{"text":"The only way I think you could fulfil your requirement would be by means of a close handler supplied to the Stream.onClose method","label":{"api":{"Stream.onClose":[[108,121]]}}},{"text":"Note that we're passing the closeAll close handler to the Stream.onClose method","label":{"api":{"Stream.onClose":[[58,71]]}}},{"text":"I recommend Files with its many useful functions","label":{"api":{"Files":[[12,16]]}}},{"text":"ipStringToBytes converts an IPv4 or IPv6 address into raw bytes and uses that to call bytesToInetAddress which calls InetAddress.getByAddress which returns uses a raw IP address","label":{"api":{"ipStringToBytes":[[0,14]],"bytesToInetAddress":[[86,103]],"InetAddress.getByAddress":[[117,140]]}}},{"text":"As it was already suggested - using Comparator<Card> is the right way to solve your problem","label":{"api":{"Comparator<Card>":[[36,51]]}}},{"text":"Actually, Timestamp inherits those methods from Date, and those are deprecated since Java 1.1","label":{"api":{"Timestamp":[[10,18]]}}},{"text":"If that's not the exact format you need, check in the javadoc how to get different formats","label":{"api":{}}},{"text":"I'd upgrade that to using an Ellipse2D","label":{"api":{"Ellipse2D":[[29,37]]}}},{"text":"Since the ellipse implements Shape, it inherits the contains(Point2D) method","label":{"api":{"contains(Point2D)":[[52,68]]}}},{"text":"In your case here as you are writing a standalone Java program and as your file is loacted in the resources folder, you can use CLassLoader to read the file as a stream","label":{"api":{"CLassLoader":[[128,138]]}}},{"text":"But you can also use Stream's allMatch method, which does that for you","label":{"api":{"Stream's allMatch":[[21,37]]}}},{"text":"Check out the specification for nullable","label":{"api":{"specification for nullable":[[14,39]]}}},{"text":"Using the old java.util.Calendar and java.util.Date","label":{"api":{"java.util.Calendar":[[14,31]],"java.util.Date":[[37,50]]}}},{"text":"Here array equality can be determined with Arrays.equals(int[], int[]) and String with String.equals","label":{"api":{"Arrays.equals(int[], int[])":[[43,69]],"String.equals":[[87,99]]}}},{"text":"Array type encoding from the API documentation","label":{"api":{"API documentation":[[29,45]]}}},{"text":"Use the Collections.disjoint method instead","label":{"api":{"Collections.disjoint":[[8,27]]}}},{"text":"You can argue me that there already exists a constructor ArrayList(int initialCapacity) which \"constructs an empty list with the specified initial capacity\" (source at the same page) - I am aware this conflicts my idea, but honestly","label":{"api":{"ArrayList(int initialCapacity)":[[57,86]]}}},{"text":"- add it to the ArrayList using Arrays.asList(array) which calls System.arraycopy just once, or we can ensureCapacity","label":{"api":{"Arrays.asList(array)":[[32,51]],"System.arraycopy":[[65,80]],"ensureCapacity":[[103,116]]}}},{"text":"The first thing, your agent has to do, is registering a ClassFileTransformer","label":{"api":{"registering a ClassFileTransformer":[[42,75]]}}},{"text":"Here's what the API documentation has to say about System.lineSeparator","label":{"api":{"System.lineSeparator":[[51,70]]}}},{"text":"It always returns the same value - the initial value of the system property line.separator","label":{"api":{"line.separator":[[76,89]]}}},{"text":"The kotlin.math.round's documentation says","label":{"api":{"kotlin.math.round":[[4,20]]}}},{"text":"Rounds the given value x towards the closest integer with ties rounded towards even integer","label":{"api":{}}},{"text":"So 152.5 is equally distant to 152 and 153, hence it is rounded to the closes even integer, i.e., 152","label":{"api":{}}},{"text":"On the other hand, Java's round says","label":{"api":{"round":[[26,30]]}}},{"text":"Returns the closest long [or int, depending on the supplied argument] to the argument, with ties rounding to positive infinity","label":{"api":{"round":[[97,101]]}}},{"text":"Looking at kotlin.math.round source code, that function is just delegating the operation to Java's Math.rint(x)","label":{"api":{"kotlin.math.round":[[11,27]],"Math.rint(x)":[[99,110]]}}},{"text":"You can parse it with this format","label":{"api":{"format":[[27,32]]}}},{"text":"If you want to print out a date in this format you have to use java.time.OffsetDateTime, like so","label":{"api":{"format":[[40,45]],"java.time.OffsetDateTime":[[63,86]]}}},{"text":"insertElementAt inserts the given element at the given index, and shifts all the elements after it","label":{"api":{"insertElementAt":[[0,14]]}}},{"text":"set, on the other hand, just overwrites the element at the given index","label":{"api":{"set":[[0,2]]}}},{"text":"The call to insertElementAt inserts an \"e\" between the \"b\" and the \"c\"","label":{"api":{"insertElementAt":[[12,26]]}}},{"text":"The call to set overwrites that \"e\" with an \"f\"","label":{"api":{"set":[[12,14]]}}},{"text":"You can do this with CompletableFuture","label":{"api":{"CompletableFuture":[[21,37]]}}},{"text":"In particular, its thenCombine method, which waits for two tasks to complete","label":{"api":{"thenCombine":[[19,29]]}}},{"text":"These methods will all execute on the ForkJoinPool.commonPool()","label":{"api":{"ForkJoinPool.commonPool()":[[38,62]]}}},{"text":"You can control where they run if you pass in optional Executors","label":{"api":{"Executors":[[55,63]]}}},{"text":"I have a java.net.ServerSocket that is am using to listen for connections","label":{"api":{"java.net.ServerSocket":[[9,29]]}}},{"text":"I am using it's accept() method in order to obtain connections from clients and then handle them appropriately","label":{"api":{"accept()":[[16,23]]}}},{"text":"I am worried that between the time the ServerSocket.accept() method returns and it is called again that a request for a connection could have been missed","label":{"api":{"ServerSocket.accept()":[[39,59]]}}},{"text":"The way I am implementing it currently creates a new thread in the handleClient method, but even this takes time (especially since this is being run on a Raspberry Pi), I am worried that if a connection is requested while the handleClient method is being executed then it may be rejected because accept() is not being run","label":{"api":{"handleClient":[[67,78],[226,237]],"accept()":[[296,303]]}}},{"text":"Use a CountDownLatch","label":{"api":{"CountDownLatch":[[6,19]]}}},{"text":"Looking in the docs, it suggests that toDays() might only consider to second precision","label":{"api":{"in the docs":[[8,18]],"toDays()":[[38,45]]}}},{"text":"Have a look into Instrumentation::appendToBootstrapClassLoaderSearch for doing so","label":{"api":{"Instrumentation::appendToBootstrapClassLoaderSearch":[[17,67]]}}},{"text":"Keep a handle on the Future that is returned when you schedule something on the ScheduledExecutor","label":{"api":{"ScheduledExecutor":[[80,96]]}}},{"text":"Instead of trying to change the execution time, you can cancel the future and re-schedule it","label":{"api":{"cancel":[[56,61]]}}},{"text":"I've just upgraded some projects from Java 6 to Java 8 and one class was implementing Connection interface","label":{"api":{"Connection":[[86,95]]}}},{"text":"Now Connection interface seems to have more methods but I don't want to implement all missing methods, for example","label":{"api":{"Connection":[[4,13]]}}},{"text":"Connection.getConnectionTimeOut() and so on","label":{"api":{"Connection.getConnectionTimeOut()":[[0,32]]}}},{"text":"It has been deprecated in Java 9","label":{"api":{}}},{"text":"Use Integer.parseInt​(String s) instead, or Integer.valueOf​(String s) if you insists on boxing the value (a waste in this case)","label":{"api":{"Integer.parseInt​(String s)":[[4,30]],"Integer.valueOf​(String s)":[[44,69]]}}},{"text":"This leaves results unmodified if the sort fails, because the sort() method copies the list elements to an array, sorts the array, then copies the elements back","label":{"api":{"sort()":[[62,67]]}}},{"text":"Note that without doing this you will get an UnsupportedClassVersionError even if the code is technically valid because the minimum Java version required is included in the compiled bytecode, and this defaults to the current version of the java compiler","label":{"api":{"UnsupportedClassVersionError":[[45,72]]}}},{"text":"That is deprecated, with good reason","label":{"api":{"deprecated":[[8,17]]}}},{"text":"Try to use ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[11,34]]}}},{"text":"For example, first of all create a ScheduledExecutorService","label":{"api":{"ScheduledExecutorService":[[35,58]]}}},{"text":"(more about java.util.logging.Level)","label":{"api":{"java.util.logging.Level":[[12,34]]}}},{"text":"The string.split() with the regex \"[^\\\\] \" removes the last character as well, which I want to avoid","label":{"api":{"string.split()":[[4,17]]}}},{"text":"Then simply map each entry to a new CodeToBrands instance","label":{"api":{"map":[[12,14]],"CodeToBrands":[[36,47]]}}},{"text":"You could do it in one pass using Collectors.toMap","label":{"api":{"Collectors.toMap":[[34,49]]}}},{"text":"I ran across the AtomicReference class and was wondering if this could be a good way of creating a Singleton that is mutable and could be replaced for testing","label":{"api":{"AtomicReference":[[17,31]]}}},{"text":"So I would not ignore the Z and use the proper type","label":{"api":{}}},{"text":"scan.nextInt() - It scans the next token of the input as in int i.e, each call to nextInt gets an input integer from the console","label":{"api":{"scan.nextInt()":[[0,13]]}}},{"text":"From Java document (https://docs.oracle.com/javase/8/docs/api/javax/crypto/Mac.html)","label":{"api":{}}},{"text":"If your inputs are instances of java.util.Date, then just use the methods before, after and equals to compare the dates","label":{"api":{}}},{"text":"The best suitable class for you is BitSet","label":{"api":{"BitSet":[[35,40]]}}},{"text":"The bits of a BitSet are indexed by nonnegative integers","label":{"api":{"BitSet":[[14,19]]}}},{"text":"One BitSet may be used to modify the contents of another BitSet through logical AND, logical inclusive OR, and logical exclusive OR operations","label":{"api":{"BitSet":[[4,9],[57,62]]}}},{"text":"You have entered parameters to setInt() incorrectly","label":{"api":{"setInt()":[[31,38]]}}},{"text":"When you type in something that nextInt() can't handle, that method throws an InputMismatchException before the execution reaches the division expression","label":{"api":{"nextInt()":[[32,40]],"InputMismatchException":[[78,99]]}}},{"text":"Also, when a Scanner method that consumes input throws that exception, it doesn't consume the offending input, the loop repeats, and nextInt() throws an exception on the same input, causing the infinite loop","label":{"api":{"nextInt()":[[133,141]]}}},{"text":"The nextInt() javadocs","label":{"api":{"nextInt()":[[4,12]]}}},{"text":"The command switch -Djava.util.logging.ConsoleHandler.level=FINE just adds a system property entry","label":{"api":{"Djava.util.logging.ConsoleHandler.level":[[20,58]]}}},{"text":"Instead, all of the logging properties are managed by the LogManager","label":{"api":{"LogManager":[[58,67]]}}},{"text":"Here is a self contained program to show how you the LogManager can change settings","label":{"api":{"LogManager":[[53,62]]}}},{"text":"Like @Andreas pointed out, you are going to create a new properties file with the adjusted parameters and set the system property to have the LogManager use the new properties file with your desired settings","label":{"api":{"system property":[[114,128]],"LogManager":[[142,151]]}}},{"text":"Use trim method it will remove extra space form string","label":{"api":{"trim":[[4,7]]}}},{"text":"The problem here is that the hashCode of an array does not depend on the contents, but on the reference","label":{"api":{"content":[[73,79]]}}},{"text":"The solution that probably takes the least effort is replacing the arrays with ArrayLists, which do base their hashCode on the content","label":{"api":{"ArrayList":[[79,87]],"hashCode":[[111,118]],"content":[[127,133]]}}},{"text":"The contract for Map.Entry does not make any commitments in that area so you should not make any assumptions either","label":{"api":{"Map.Entry":[[17,25]]}}},{"text":"These Map.Entry objects are valid only for the duration of the iteration; ..","label":{"api":{"Map.Entry":[[6,14]]}}},{"text":"For this reason, if you wish to store Key-Value pairs derived from a Map.Entry then you should take copies","label":{"api":{"Map.Entry":[[69,77]]}}},{"text":"ResourceBundle.getBundle(String baseName) relies on the classloader and not directly the file system to find the resource","label":{"api":{"ResourceBundle.getBundle(String baseName)":[[0,40]]}}},{"text":"What you look for is PropertyResourceBundle","label":{"api":{"PropertyResourceBundle":[[21,42]]}}},{"text":"the straight forward answer here - use a Map","label":{"api":{"Map":[[41,43]]}}},{"text":"I'd like to create a CompletableFuture that has already completed exceptionally","label":{"api":{"CompletableFuture":[[21,37]]}}},{"text":"In Java SE, the typical / intended usage of the SPI is via the LoginContext class, which, by default, lazily instantiates and initializes each of its configured modules once, just before delegating to their login method","label":{"api":{"LoginContext":[[63,74]],"configured":[[150,159]]}}},{"text":"Augment threads' call stacks with those principals, so that authorization can later on be carried out at the granularity scale of individual call stack frames, based on both the principals' and the particular code's trustworthiness (is the ProtectionDomain originating from http://example.com, signed by \"Fred\" and \"Alice\", and containing the class declaring the particular invocation of method foo(), granted the specified Permission, when executed on behalf of the entity identified by Principals {\"Gill\", \"HR Manager\"}?)","label":{"api":{"Augment":[[0,6]],"call stacks":[[17,27]],"authorization":[[60,72]],"trustworthiness":[[216,230]]}}},{"text":"1    If we distanced ourselves from the web apps sphere a bit, we could view either of the LoginContext (if associated with one or multiple threads) and AccessControlContext (combined with an authenticated Subject's Principals first, so as to carry meaningful authorization semantics) as a kind of session","label":{"api":{"LoginContext":[[91,102]],"AccessControlContext":[[153,172]],"authorization":[[260,272]]}}},{"text":"All the possible ways whereby those can be tied into some web application (framework), however, have nothing to do with standard JAAS; e.g., in a Servlet setting, where authentication and authorization are application-managed, one could attach a LoginContext or its encapsulated Subject as an attribute to an HttpSession or HttpServletRequest; or the Servlet container itself could employ the AccessControlContext under the covers in order to associate principals established during container-managed authentication with the thread(s) servicing a request (and by extension the request itself)","label":{"api":{"authorization":[[188,200]],"LoginContext":[[246,257]],"HttpSession":[[309,319]],"HttpServletRequest":[[324,341]],"AccessControlContext":[[393,412]]}}},{"text":"You should use hasNextInt, which will allow you to check if the next token in the stream can be parsed as an int","label":{"api":{"hasNextInt":[[15,24]]}}},{"text":"You could use a ScheduledExecutorService, but if it's a single threaded program with one purpose it's probably unnecessary","label":{"api":{"ScheduledExecutorService":[[16,39]]}}},{"text":"You should use Stream.mapToInt in order to get an IntStream instance","label":{"api":{"Stream.mapToInt":[[15,29]]}}},{"text":"If you ever used stream API, then the parallel operations are also done in this thread pool","label":{"api":{"stream API":[[17,26]]}}},{"text":"Base64.Decoder and GZIPInputStream (look at the wrap method on the former and the constructors on the latter),  the decompress method can be overloaded as follows","label":{"api":{"Base64.Decoder":[[0,13]],"GZIPInputStream":[[19,33]]}}},{"text":"From the Javadoc of Statement","label":{"api":{}}},{"text":"I mean is there any RoundingMode constant describing exactly what Math.round(arg) does","label":{"api":{"RoundingMode":[[20,31]],"Math.round(arg)":[[66,80]]}}},{"text":"I understand that Math.round does not formally use any RoundingMode class/object","label":{"api":{"Math.round":[[18,27]],"RoundingMode":[[55,66]]}}},{"text":"There is a partial analogy - in situations like 1.5, -1,5 etc ties are broken just as in RoundingMode.CEILING (\"towards positive infinity\")","label":{"api":{"RoundingMode.CEILING":[[89,108]]}}},{"text":"But RoundingMode.CEILING analogy cannot work for other arguments (1.7, -1.1), so it cannot be a 100% analogy","label":{"api":{"RoundingMode.CEILING":[[4,23]]}}},{"text":"So I found absolutely no 100% analogy in all RoundingMode constants which makes me think I was inattentive somewhere","label":{"api":{"RoundingMode":[[45,56]]}}},{"text":"List of constants in RoundingMode class shall have constants for all widely-used rounding modes, right","label":{"api":{"RoundingMode":[[21,32]]}}},{"text":"So why there is no 100% analogy in RoundingMode class","label":{"api":{"RoundingMode":[[35,46]]}}},{"text":"Here is the comparison table for RoundingMode class constants and their behaviour","label":{"api":{"comparison table":[[12,27]],"RoundingMode":[[33,44]]}}},{"text":"Math.floor(arg) method behaves exactly like RoundingMode.FLOOR, Math.ceil(arg) behaves exactly like RoundingMode.CEILING","label":{"api":{"Math.floor(arg)":[[0,14]],"RoundingMode.FLOOR":[[44,61]],"Math.ceil(arg)":[[64,77]],"RoundingMode.CEILING":[[100,119]]}}},{"text":"You interrupt the thread with mThread.interrupt()","label":{"api":{"mThread.interrupt()":[[30,48]]}}},{"text":"You can change the context via in(Class) but this will change the access modes and cause the LambdaMetaFactory to reject the lookup object","label":{"api":{"in(Class)":[[31,39]],"LambdaMetaFactory":[[93,109]]}}},{"text":"I was reading about WeakReference and SoftReference","label":{"api":{"WeakReference":[[20,32]],"SoftReference":[[38,50]]}}},{"text":"How is WeakReference / SoftReference impacting/assisting the garbage collection here","label":{"api":{"WeakReference":[[7,19]],"SoftReference":[[23,35]]}}},{"text":"Vendor independently one can use the DatabaseMetaData with its getExportedKeys and getImportedKeys on all tables","label":{"api":{"DatabaseMetaData":[[37,52]],"getExportedKeys":[[63,77]],"getImportedKeys":[[83,97]]}}},{"text":"There's also File.pathSeparator if you want to manually build paths","label":{"api":{"File.pathSeparator":[[13,30]]}}},{"text":"ZoneId then queries the IANA Time Zone Database - see spec","label":{"api":{}}},{"text":"This is essentially javax.servlet.http.HttpServletResponse.sendError(int) with a special \"error status code\" of -1","label":{"api":{"javax.servlet.http.HttpServletResponse.sendError(int)":[[20,72]]}}},{"text":"You can use JLabel to display images","label":{"api":{"JLabel":[[12,17]]}}},{"text":"After upgrading from Java 9 to 10, links to the JDK no longer work when generating documentation with the Javadoc tool (e.g., for a file importing java.util.Optional, {@link Optional} renders as Optional instead of as Optional; same issue with @see, @param, @return, and anywhere else you normally see Javadoc links)","label":{"api":{"Java 9":[[21,26]],"Optional":[[157,164],[174,181],[195,202],[218,225]]}}},{"text":"Java 8 has one","label":{"api":{}}},{"text":"Java 9 has one","label":{"api":{}}},{"text":"Java 10 does not (404 error)","label":{"api":{}}},{"text":"Apparently, the Javadoc tool now outputs a text file named element-list instead of package-list for modularized projects, but it seems like that isn't provided either (nor for Java 9, but it is available for early-access builds of Java 11)","label":{"api":{}}},{"text":"The copy of the API that is posted at https://docs.oracle.com/javase/10/docs/api/overview-summary.html seems to be blocking the \"element-list\" file, giving a 404","label":{"api":{}}},{"text":"The LocalDateTime class does not support time zones; you can use ZonedDateTime instead","label":{"api":{"LocalDateTime":[[4,16]],"ZonedDateTime":[[65,77]]}}},{"text":"Also, in real code, you should be using AtomicInteger","label":{"api":{"AtomicInteger":[[40,52]]}}},{"text":"As alex440 and markspace have already mentioned, the Java method Arrays.sort() is of type void, so it does not return a value as you'll find in the oracle spec for your specific case of Arrays.sort(int[])","label":{"api":{"Arrays.sort()":[[65,77]],"Arrays.sort(int[])":[[186,203]]}}},{"text":"It can be achieved with a single line of code (using UUID)","label":{"api":{"UUID":[[53,56]]}}},{"text":"When you create the second Stage you have to call initOwner and initModality with Modality.WINDOW_MODAL","label":{"api":{"initOwner":[[50,58]],"initModality":[[64,75]],"Modality.WINDOW_MODAL":[[82,102]]}}},{"text":"If you're using Java 8 or later, better use LocalDate instead of java.util.Date","label":{"api":{"LocalDate":[[44,52]],"java.util.Date":[[65,78]]}}},{"text":"Compare LocalDate objects with methods isBefore, isEqual, and isAfter","label":{"api":{"LocalDate":[[8,16]],"isBefore":[[39,46]],"isEqual":[[49,55]],"isAfter":[[62,68]]}}},{"text":"If you're using earlier version or you just prefer using Date for some reason, you need a Calendar instance to do that","label":{"api":{"Calendar":[[90,97]]}}},{"text":"Insertion order for words with equal frequency is handled by Stream#sorted, since that is a stable sort","label":{"api":{"Stream#sorted":[[61,73]]}}},{"text":"The actual methods you can call and fields you can access in your code are exactly what you'll find in javax.swing in the Java documentation corresponding to the class you're looking at","label":{"api":{"javax.swing":[[103,113]]}}},{"text":"For example, if you have a JFrame, you can find all the methods in javax.swing.JFrame","label":{"api":{"javax.swing.JFrame":[[67,84]]}}},{"text":"For example, if you have a JFrame, you might see a background property in Netbeans, and you can find setBackground and getBackground in the documentation","label":{"api":{"setBackground":[[101,113]],"getBackground":[[119,131]]}}},{"text":"Events are a bit more complicated - for example, all the mouseX events correspond roughly to addMouseListener and addMouseMotionListener, where the corresponding MouseListener and MouseMotionListener parameters has the mouseClicked, mouseEntered, etc","label":{"api":{"addMouseListener":[[93,108]],"addMouseMotionListener":[[114,135]],"MouseListener":[[162,174]],"MouseMotionListener":[[180,198]],"mouseClicked":[[219,230]],"mouseEntered":[[233,244]]}}},{"text":"If you mean AWT, I imagine something similar would apply for that (but just taken from the java.awt package instead)","label":{"api":{"the java.awt package":[[87,106]]}}},{"text":"That's not to say every method appears in some form in the NetBeans UI - it wouldn't make sense for something like update to appear there, since that's something you need to decide when to call yourself during runtime","label":{"api":{"NetBeans":[[59,66]],"update":[[115,120]]}}},{"text":"Looking at leifg's answer on this similar question, you can use two sets, one for duplicates and one for everything else, and you can Set#add(E), which \"returns true if this set did not already contain the specified element,\" to determine whether or not the element is a duplicate","label":{"api":{"Set#add(E)":[[134,143]]}}},{"text":"Use the Arrays class to do this for you","label":{"api":{"Arrays":[[8,13]]}}},{"text":"Or programmatically with Background by setBackground","label":{"api":{"Background":[[25,34],[42,51]]}}},{"text":"It is actually not that difficult, create an instance of the built-in https://docs.oracle.com/javase/8/docs/api/java/net/URLClassLoader.html and point it to your directory","label":{"api":{}}},{"text":"Take a look at the renameTo() method from java.io.File","label":{"api":{"renameTo()":[[19,28]],"java.io.File":[[42,53]]}}},{"text":"Alternatively, since you are using an ExecutorService and not a simple Executor, you can create a Callable instead of a Runnable, and use ExecutorService.submit rather than execute, so you don’t need a try/catch at all","label":{"api":{"ExecutorService":[[38,52]],"ExecutorService.submit":[[138,159]]}}},{"text":"The IntSummaryStatistics class together with Java 8's Stream API may be less verbose than dealing with min, max, sum and avg calculation manually","label":{"api":{"IntSummaryStatistics":[[4,23]]}}},{"text":"You can use Stream.flatMap(...) to iterate each map entry from the list of maps","label":{"api":{"Stream.flatMap(...)":[[12,30]]}}},{"text":"If you use Properties consecutive calls to load will add several properties files","label":{"api":{"Properties":[[11,20]]}}},{"text":"If you use ResourceBundle, actually a PropertyResourceBundle, one could create ones own ResourceBundle and delegate to the actual properties files","label":{"api":{"ResourceBundle":[[11,24],[46,59],[88,101]]}}},{"text":"In order to prevent trying wrong bundles for some requested key, one could preload all properties files, for instance as one large ListResourceBundle","label":{"api":{"ResourceBundle":[[135,148]]}}},{"text":"When StopWatchDial is a Component, one can stack them using a JLayeredPane","label":{"api":{"JLayeredPane":[[62,73]]}}},{"text":"Have a look at the documentation of Properties, showing that internally there's a hash table, and hash tables don't maintain the ordering of elements, but guarantee that there are no duplicate keys","label":{"api":{"Properties":[[36,45]]}}},{"text":"(as @oldcurmudgeon mentioned) java.util.Optional it also has a map function","label":{"api":{"java.util.Optional":[[30,47]]}}},{"text":"Use Statement.executeUpdate(String) instead","label":{"api":{"Statement.executeUpdate(String)":[[4,34]]}}},{"text":"If the teacher allows you to use regular expression patterns, then the transformation code could be much shorter","label":{"api":{"regular expression patterns":[[33,59]]}}},{"text":"new String(byte[] bytes) uses the platform's default charset and should generally be avoided","label":{"api":{"new String(byte[] bytes)":[[0,23]]}}},{"text":"Instead, use new String(byte[] bytes, Charset charset) and specify the encoding of your encrypted data","label":{"api":{"new String(byte[] bytes, Charset charset)":[[13,53]]}}}]