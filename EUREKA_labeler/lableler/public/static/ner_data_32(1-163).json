[{"text":"You can find out the default charset on a platform by calling Charset.defaultCharset(), so check it on your local server and use that charset in the code","label":{"api":{"Charset.defaultCharset()":[[62,85]]}}},{"text":"During your configuration time (login and before firing the threads) you can use something like an AtomicInteger, initializing it with new AtomicInteger(0) and calling getAndIncrement() to assign the possition of the thread, in the range [0-500) and then when you fire the threads sleep 300.0 * id / 500.0 milliseconds to execute the task/petition","label":{"api":{"AtomicInteger":[[99,111]],"AtomicInteger(0)":[[139,154]],"getAndIncrement()":[[168,184]]}}},{"text":"You can check the thread type with SwingUtils.isEventDispatchThread() method","label":{"api":{"SwingUtils.isEventDispatchThread()":[[35,68]]}}},{"text":"When you're copying old array to new array, you use the new capacity size, which is 20 and temp has only 10 elements, therefore an ArrayIndexOutOfBoundsException is thrown when it tries to copy next elements","label":{"api":{"ArrayIndexOutOfBoundsException":[[131,160]]}}},{"text":"java's RSA key generation code accepts an instance of SecureRandom which the Oracle providers use to generate the candidate primes for RSA","label":{"api":{"RSA key generation code":[[7,29]],"SecureRandom":[[54,65]]}}},{"text":"You can subclass SecureRandom (I think) to provide a class that uses the password to seed a deterministic, repeatable sequence of random numbers such that every time you call KeyPairGenerator","label":{"api":{"SecureRandom":[[17,28]],"KeyPairGenerator":[[175,190]]}}},{"text":"The bouncycastle library includes an example, FixedSecureRandom, that can be used as a model","label":{"api":{"FixedSecureRandom":[[46,62]]}}},{"text":"FixedSecureRandom is not secure, it simply returns the pre-supplied bytes directly as output","label":{"api":{"SecureRandom":[[5,16]]}}},{"text":"Perhaps you can merge FixedSecureRandom with one of the other CSPRNGs in the org.bouncycastle.crypto.prng package","label":{"api":{"FixedSecureRandom":[[22,38]],"org.bouncycastle.crypto.prng":[[77,104]]}}},{"text":"Since String::replaceAll consumes regular expression you need to convert your search and replacement strings into regular expressions first","label":{"api":{"String::replaceAll":[[6,23]]}}},{"text":"If you want to access the remote file line-by-line, you can convert it to Reader using InputStreamReader","label":{"api":{"Reader":[[74,79]],"InputStreamReader":[[87,103]]}}},{"text":"The ZipFile class can be used for working with zip files","label":{"api":{"ZipFile":[[4,10]]}}},{"text":"The class documentation describes exactly what type of object will be returned for each XPathConstant field","label":{"api":{"class documentation":[[4,22]],"XPathConstant":[[88,100]]}}},{"text":"Since you just want the string value of the node, you can use the two-argument evaluate method instead, omitting the XPathConstants value","label":{"api":{"two-argument evaluate method":[[66,93]],"XPathConstants":[[117,130]]}}},{"text":"shuffle() the list then use the first 20","label":{"api":{"shuffle()":[[0,8]]}}},{"text":"The best way to read float value in Java, where you can control the endian order, is to use a ByteBuffer","label":{"api":{"ByteBuffer":[[94,103]]}}},{"text":"As the documentation of Serializable states","label":{"api":{"the documentation of Serializable":[[3,35]]}}},{"text":"You can use String's replaceAll","label":{"api":{"replaceAll":[[21,30]]}}},{"text":"For more details on how to construct a regex, see the documentation of Pattern","label":{"api":{"Pattern":[[71,77]]}}},{"text":"I am trying to use the ExecutorCompletionService - https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html, to try and perform concurrent calls to two different dependent packages","label":{"api":{"ExecutorCompletionService":[[23,47]],"xecutorCompletionService.html":[[115,143]]}}},{"text":"There are a number of thread-safe collections in java.util.collect.concurrent that you might consider, otherwise you'll need to ensure you use synchronized blocks or methods anywhere you're working with this list","label":{"api":{"java.util.collect.concurrent":[[49,76]]}}},{"text":"Create two different ModelManagers, one that opens and listens to a ServerSocket, and one that uses a Socket in getLatestTemperatureData() to connect to the other one","label":{"api":{"ModelManagers":[[21,33]],"ServerSocket":[[68,79]],"Socket":[[102,107]],"getLatestTemperatureData()":[[112,137]]}}},{"text":"The glossary defines \"equivalence relation\" as reflexive (\"a.relation(a) is always true\"), symmetric (a1.relation(a2) == a2.relation(a1)) and transitive (a1.relation(a2) && a2.relation(a3) implies a1.relation(a3)) - and refers to Object.equals()' docs","label":{"api":{"Object.equals()' docs":[[230,250]]}}},{"text":"The most common example of this is a TreeSet with a custom Comparator","label":{"api":{"TreeSet":[[37,43]]}}},{"text":"Java SE also makes mention of this kind of situation when it's talking about ordering which is inconsistent with equals (see TreeSet)","label":{"api":{"TreeSet":[[125,131]]}}},{"text":"(See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal","label":{"api":{"TreeSet":[[171,177]],"compareTo":[[231,239]]}}},{"text":"Since, for example, Double.compareTo expects a Double argument, it throws an exception when you pass it an Integer","label":{"api":{"Double.compareTo":[[20,35]]}}},{"text":"When you call compareTo on the Comparable, it actually calls the method compareTo(Object) which attempts to cast the argument to a Double and then pass it to Double.compareTo(Double)","label":{"api":{"compareTo":[[14,22]],"compareTo(Object)":[[72,88]],"Double.compareTo(Double)":[[158,181]]}}},{"text":"For this, you could use Scanner.findAll (available since Java 9) with a proper regex","label":{"api":{"Scanner.findAll":[[24,38]]}}},{"text":"Scanner.findAll returns a Stream<MatchResult> and MatchResult.group() returns the matched String","label":{"api":{"Scanner.findAll":[[0,14]],"Stream<MatchResult>":[[26,44]],"MatchResult.group()":[[50,68]]}}},{"text":"If you want to initialize Date instances from a formatted string with both date and time then time codes should be added to the SimpleDateFormat pattern to parse strings in that format","label":{"api":{"Date":[[26,29]],"SimpleDateFormat":[[128,143]]}}},{"text":"If you want to simply set the hour, minute, and second on the current date then use a Calendar instance and set fields on it accordingly","label":{"api":{"Calendar":[[86,93]]}}},{"text":"And next output the Date in a particular format","label":{"api":{"Date":[[20,23]]}}},{"text":"Your particular example looks like preconditions which are generally easier to write with Objects.requireNonNull","label":{"api":{"Objects.requireNonNull":[[90,111]]}}},{"text":"This is easily achieved using the map function from Stream","label":{"api":{"Stream":[[52,57]]}}},{"text":"But you can change it using the @Entity annotation to (almost) whatever you like","label":{"api":{"@Entity":[[32,38]]}}},{"text":"Java allows you to pass an array of say Integer or Double to a method that expects an array of Number objects","label":{"api":{"Number":[[95,100]]}}},{"text":"Therefore one simple solution would be to change your search method accept Number objects - to then call its doubleValue() method when comparing values","label":{"api":{"Number":[[75,80]],"doubleValue()":[[109,121]]}}},{"text":"As the javadoc of parse(String source, ParsePosition pos) says","label":{"api":{"parse(String source, ParsePosition pos)":[[18,56]]}}},{"text":"Clients may insist on strict adherence to the format by calling setLenient(false)","label":{"api":{"setLenient(false)":[[64,80]]}}},{"text":"To check if a string contains a date in a specific format, use a java.time.format.DateTimeFormatter","label":{"api":{"java.time.format.DateTimeFormatter":[[65,98]]}}},{"text":"Your Comparator breaks the comparator contract","label":{"api":{"Comparator":[[5,14]]}}},{"text":"But, if you want to have a custom comparator generated dinamically, or cannot/want to override equals and hashcode, you can use the functions comparing and thenComparing that provides the java Comparator","label":{"api":{"Comparator":[[193,202]]}}},{"text":"This comparator however is not null safe, you need to pass Comparator.nullsFirst(Comparator.naturalOrder()) as second argument to allow the comparation of nulls","label":{"api":{"Comparator.nullsFirst(Comparator.naturalOrder())":[[59,106]]}}},{"text":"If you are only storing non-negative Integer values, from 0 up to some limit (SET_SIZE), and your set is not sparely populated, you might want to consider using a BitSet instead","label":{"api":{"BitSet":[[163,168]]}}},{"text":"A BitSet stores the presence or absence of each value as a single bit","label":{"api":{"BitSet":[[2,7]]}}},{"text":"Therefore, the memory requirement of BitSet is a function of the largest integer ever stored in the set; a BitSet that can store all the Integer values from 0 to 20 million only takes 2.5 million bytes of storage","label":{"api":{"BitSet":[[37,42],[107,112]]}}},{"text":"If each entry takes 32 bytes, then after the 78125 entries have been stored in the HashSet<Integer>, it would take more memory than a BitSet of 20 million bits","label":{"api":{"HashSet<Integer>":[[83,98]],"BitSet":[[134,139]]}}},{"text":"You may want to consider a Semaphore for this problem","label":{"api":{"Semaphore":[[27,35]]}}},{"text":"For work to be done you need to move it outside of the user interface thread and use a mechanism to update it","label":{"api":{"update it":[[100,108]]}}},{"text":"You need to use Driver.getPropertyInfo​(String url, Properties info)","label":{"api":{"Driver.getPropertyInfo​(String url, Properties info)":[[16,67]]}}},{"text":"For writing the Java object i am using the SocketChannerl.write API","label":{"api":{"SocketChannerl.write":[[43,62]]}}},{"text":"A very easy standard Java method from String - trim()","label":{"api":{"trim()":[[47,52]]}}},{"text":"If it does - implement a null check before calling trim()","label":{"api":{"trim()":[[51,56]]}}},{"text":"If you have some kind of plugin system and are looking for modules that interface with your code which may have been provided at runtime, then you should use the ServiceLoader API, i.e.","label":{"api":{"the ServiceLoader API":[[158,178]]}}},{"text":"Note that if you want to retain some java object rather than the QuerySolution, you can use the Stream.map method to transform your solution before aggregation into an array","label":{"api":{"QuerySolution":[[65,77]],"Stream.map":[[96,105]]}}},{"text":"wait releases the monitor held on the object which wait is invoked on, but not any other monitors","label":{"api":{"wait":[[0,3],[51,54]]}}},{"text":"The thread releases ownership of this monitor and waits [...]","label":{"api":{"wait":[[50,53]]}}},{"text":"At b.wait(), the current thread releases b's monitor, but not a's monitor","label":{"api":{"b.wait()":[[3,10]]}}},{"text":"If t.join() is implemented using t.wait() internally, then t's monitor is released while waiting, but not any other monitor","label":{"api":{"t.join()":[[3,10]],"t.wait()":[[33,40]]}}},{"text":"If Thread used a private final Object monitor; to wait on instead, we could say that join released no monitors, even if it used wait internally without us knowing","label":{"api":{"wait":[[50,53],[128,131]]}}},{"text":"There would be no reason to document the implementation detail of using wait, because the monitor would be inaccessible to us, so we would not need to know about it","label":{"api":{"wait":[[72,75]]}}},{"text":"The reason that we know join uses wait internally is that the people who originally wrote the method chose a monitor which is accessible to us","label":{"api":{"wait":[[34,37]]}}},{"text":"join is not really supposed to release monitors from our perspective, just wait for a thread to complete, but an implementation was chosen which required us to know more about it than we should","label":{"api":{"wait":[[75,78]]}}},{"text":"For any JComponent such as a JTextField, use JComponent.requestFocusInWindow()","label":{"api":{"JComponent":[[8,17]],"JTextField":[[29,38]],"JComponent.requestFocusInWindow()":[[45,77]]}}},{"text":"You want to check Locale and build something that works for your use case","label":{"api":{"Locale":[[18,23]]}}},{"text":"The following is a quick example to showcase how to use Locale to achieve the desired behavior","label":{"api":{"Locale":[[56,61]]}}},{"text":"If you would like to read up more to understand how stages work I would reccomend this article https://docs.oracle.com/javase/8/javafx/api/javafx/stage/Stage.html","label":{"api":{}}},{"text":"To \"pass a method\" in Java 8, you need a matching functional interface, i.e","label":{"api":{"functional interface":[[50,69]]}}},{"text":"You can use one of the standard methods in the java.util.function package, or you can write your own","label":{"api":{"java.util.function":[[47,64]]}}},{"text":"Since your parameters are different type, you can use BiFunction, or you could create your own like this","label":{"api":{"BiFunction":[[54,63]]}}},{"text":"Just to maintain the contract and the behavior is enforced byComparable incase of natural ordering","label":{"api":{"Comparable":[[61,70]]}}},{"text":"This can be folded into StringBuilder.append(String s, int start, int end)","label":{"api":{"StringBuilder.append(String s, int start, int end)":[[24,73]]}}},{"text":"Use scanner's hasNextLine and it's other variants before trying to get the token with next*","label":{"api":{"hasNextLine":[[14,24]]}}},{"text":"The String class in Java is immutable, meaning that once a String object is created whatever operation you perform on it won't change the object's value but, instead, it will return a new String which is the result of the method you invoked (toLowerCase in this case)","label":{"api":{"String":[[4,9],[59,64],[188,193]]}}},{"text":"The flag set by interrupt() may not be observable to us, particularly when the thread is blocking","label":{"api":{"interrupt()":[[16,26]]}}},{"text":"The PreparedStatement#executeQuery() method does not take any parameters","label":{"api":{"PreparedStatement#executeQuery()":[[4,35]]}}},{"text":"Here's an example of how to generate one using UUID.randomUUID","label":{"api":{"UUID.randomUUID":[[47,61]]}}},{"text":"You need to write your own logic using Deflater to compress the data, and you need to implement an InputStream, where you should implement at least the read(), read(byte[] b, int off, int len), and close() methods","label":{"api":{"Deflater":[[39,46]],"InputStream":[[99,109]],"read()":[[152,157]],"read(byte[] b, int off, int len)":[[160,191]],"close()":[[198,204]]}}},{"text":"In java.util.Formatter (as opposed to java.util.logging.Formatter),  you can supply a Locale argument to the constructor, so you can specify the ROOT locale if you want","label":{"api":{"java.util.Formatter":[[3,21]],"java.util.logging.Formatter":[[38,64]]}}},{"text":"If you want to take \"ooxoo\" and turn it into ['o','o','x','o','o'], you can use the toCharArray method on strings","label":{"api":{"toCharArray":[[84,94]]}}},{"text":"For Integer values (and other types that implement the Comparable interface), you can use the Comparator#naturalOrder comparator as the last argument","label":{"api":{"Comparator#naturalOrder":[[94,116]]}}},{"text":"You also always have the option to create a reversed comparator from that, for example","label":{"api":{"reversed comparator":[[44,62]]}}},{"text":"The latter can easily be handled by passing a Comparator#nullsFirst or Comparator#nullsLast comparator to the outer method, but you have to be aware of that","label":{"api":{"Comparator#nullsFirst":[[46,66]],"Comparator#nullsLast":[[71,90]]}}},{"text":"The difference here is that the thing (Supplier) we're passing to the method will stay () -> dontCallMe(), it does not become () -> \"why oh why\" - only when you call get does it actually evaluate what's going on there and does dontCallMe actually get called","label":{"api":{"Supplier":[[39,46]],"dontCallMe()":[[93,104]],"become ()":[[119,127]]}}},{"text":"useDelimiter takes a regular expression","label":{"api":{"useDelimiter":[[0,11]]}}},{"text":"As precisely pointed by @Ivar in comments, also note that the pattern for months is uppercase M","label":{"api":{"the pattern for months is uppercase M":[[58,94]]}}},{"text":"If you are using java.time it can be more helpful","label":{"api":{"java.time":[[17,25]]}}},{"text":"The method replaceAll(..) returns the new String itself with replacement and you need to assign it to a variable","label":{"api":{"replaceAll(..)":[[11,24]]}}},{"text":"I'm surprised that this has not been suggested yet, but this is a good scenario to use AtomicInteger","label":{"api":{"AtomicInteger":[[87,99]]}}},{"text":"You can utilise the useDelimiter method like so","label":{"api":{"useDelimiter":[[20,31]]}}},{"text":"Since you already have a Path, you can use Path#toFile, and then check if the file is a directory with File#isDirectory","label":{"api":{"Path":[[25,28]],"Path#toFile":[[43,53]],"File#isDirectory":[[103,118]]}}},{"text":"Or even simpler with Files#isDirectory","label":{"api":{"Files#isDirectory":[[21,37]]}}},{"text":"You can use a java.time.format.DateTimeFormatterBuilder to build a formatter with optional parts, where each optional part is a DateTimeFormatter that can parse one of those formats","label":{"api":{"java.time.format.DateTimeFormatterBuilder":[[14,54]],"DateTimeFormatter":[[128,144]]}}},{"text":"The value 1520877600 seems to be in seconds since unix epoch, so you can use the ChronoField.INSTANT_SECONDS field","label":{"api":{"ChronoField.INSTANT_SECONDS":[[81,107]]}}},{"text":"Anyway, as you want the year and month values, the best choice is to parse directly to a java.time.YearMonth, which in turn can be used to get the correspondent int values for year and month","label":{"api":{"java.time.YearMonth":[[89,107]]}}},{"text":"For this I would recommend to use Map, with group name as a key and ArrayList as value","label":{"api":{"Map":[[34,36]],"ArrayList":[[68,76]]}}},{"text":"Your current approach is succinct, yet uses a TreeMap when all you need is a TreeSet","label":{"api":{"TreeMap":[[46,52]],"TreeSet":[[77,83]]}}},{"text":"Also, TreeSet still has O(nlogn) time complexity because it uses a TreeMap as its backing structure","label":{"api":{"TreeSet":[[6,12]]}}},{"text":"The usage of TreeSet has 3 disadvantages","label":{"api":{"TreeSet":[[13,19]]}}},{"text":"After all, according to the docs, a TreeSet<E> has a constructor that accepts an argument of type Comparator<","label":{"api":{"according to the docs":[[11,31]],"TreeSet<E>":[[36,45]]}}},{"text":"How can I use merge method https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#merge-K-V-java.util.function.BiFunction- to do the same","label":{"api":{}}},{"text":"If you use a Collections.synchronizedMap, for example, you can just do synchronized (map) {...} any time you need to do more than a single method call","label":{"api":{"Collections.synchronizedMap":[[13,39]]}}},{"text":"In the case of add, the equivalent version to removing with an index, is List::add(int, E) (see javadoc for details)","label":{"api":{"javadoc for details":[[96,114]]}}},{"text":"If the object does not override toString() Object.toString() is called","label":{"api":{"toString()":[[32,41]],"Object.toString()":[[43,59]]}}},{"text":"You can use Random.ints(n) to generate n random numbers","label":{"api":{"Random.ints(n)":[[12,25]]}}},{"text":"If you want to use a different source of randomness, you can override Random.next(bits) to supply bits from a custom source instead of from the built-in generator","label":{"api":{"Random.next(bits)":[[70,86]]}}},{"text":"Given two LocalTime parameters in Java, I want to be able to compare the two times are see if they are equal (same time)","label":{"api":{"LocalTime":[[10,18]]}}},{"text":"However, if I use following Java code, the symlink working directory resolves to the real path","label":{"api":{"real path":[[85,93]]}}},{"text":"Instead, I would like to run the command in the absolute path","label":{"api":{"absolute path":[[48,60]]}}},{"text":"Try Java Stream","label":{"api":{"Stream":[[9,14]]}}},{"text":"String#trim() only removes all characters equal to or less than the space character (\\u0020), but there are many more characters that are \"whitespace\"","label":{"api":{"String#trim()":[[0,12]]}}},{"text":"Have you given a look at DigestUtils and MessageDigest","label":{"api":{"DigestUtils":[[25,35]],"MessageDigest":[[41,53]]}}},{"text":"You can shorten it slightly by comparing the values of getAuthority(), which returns everything between the scheme and path","label":{"api":{"getAuthority()":[[55,68]]}}},{"text":"Starting with Java 9, you can replace new AbstractMap.SimpleImmutableEntry<>(…) with Map.entry(…)","label":{"api":{"AbstractMap.SimpleImmutableEntry<>(…)":[[42,78]],"Map.entry(…)":[[85,96]]}}},{"text":"Use FindBugs to locate spurious integer reference comparisons and replace them with Integer.equals -- that is the proper way to fix the problems you're encountering","label":{"api":{"FindBugs":[[4,11]],"Integer.equals":[[84,97]]}}},{"text":"You can use the overload of Collectors.toMap that accepts a Supplier for the Map","label":{"api":{"the overload of Collectors.toMap":[[12,43]]}}},{"text":"Here's a one-liner using the Arrays utility class","label":{"api":{"Arrays":[[29,34]]}}},{"text":"You use of Set#contains does not look right to me","label":{"api":{"Set#contains":[[11,22]]}}},{"text":"Now, as to your specific problem, the best way to check whether there is a common element in two lists, is by using the Collections.disjoint method, available since Java 1.5","label":{"api":{"Collections.disjoint":[[120,139]]}}},{"text":"I just read about Java 9 module system and I'd like to ask about ServiceLoader","label":{"api":{"ServiceLoader":[[65,77]]}}},{"text":"You can use flatMap to get from a stream of maps to a stream of entries like so","label":{"api":{"flatMap":[[12,18]]}}},{"text":"Unlike nextLine() the nextDouble() doesn't set the position to the beginning of the next line","label":{"api":{"nextLine()":[[7,16]],"nextDouble()":[[22,33]]}}},{"text":"Here is a Link to the documentation","label":{"api":{"Link":[[10,13]]}}},{"text":"Look at the Runtime class","label":{"api":{}}},{"text":"This is how features like javax.annotation.security.RolesAllowed are implemented","label":{"api":{"javax.annotation.security.RolesAllowed":[[26,63]]}}},{"text":"First one would be to Task to implement Comparator interface","label":{"api":{"Comparator":[[40,49]]}}},{"text":"Second would be to pass a Comparator to your sort methods","label":{"api":{"Comparator":[[26,35]]}}},{"text":"If you want to input a multiline text you can make use of the useDelimiter(String pattern) function","label":{"api":{"useDelimiter(String pattern)":[[62,89]]}}},{"text":"If you use executors, then you can provide a ThreadFactory, that creates the threads with the right interrupt() method","label":{"api":{"ThreadFactory":[[45,57]],"interrupt()":[[100,110]]}}},{"text":"Then, use Collectors.groupingBy along with Collectors.mapping","label":{"api":{"Collectors.groupingBy":[[10,30]],"Collectors.mapping":[[43,60]]}}},{"text":"This method is preferred but you won't be able to inspect this at the time of filtering","label":{"api":{"filter":[[78,83]]}}},{"text":"Another option would be to create a custom filter that modifies the current message by prepending the score and returning true","label":{"api":{"filter":[[43,48]],"modifies":[[55,62]],"current message":[[68,82]]}}},{"text":"Then install the filter on the handler in use or install it on every logger that is generating log records","label":{"api":{"filter":[[17,22]],"handler":[[31,37]],"every logger":[[63,74]]}}},{"text":"As the JavaDoc of CompletableFuture.allOf() indicates","label":{"api":{"the JavaDoc of CompletableFuture.allOf()":[[3,42]]}}},{"text":"Note that in your particular case, if you only have 2 futures, it is probably simpler to use thenCombine() which gives you access to the 2 results more easily","label":{"api":{"thenCombine()":[[93,105]]}}},{"text":"This can be done with the ArrayList copy constructor, e.g.","label":{"api":{"ArrayList copy constructor":[[26,51]]}}},{"text":"See the contract for compareAndSet(int expect,int update)","label":{"api":{"compareAndSet(int expect,int update)":[[21,56]]}}},{"text":"In Java 8, you can use a java.time.format.DateTimeFormatter with lots of optional sections - delimited by []","label":{"api":{"java.time.format.DateTimeFormatter":[[25,58]]}}},{"text":"Note that there's a difference between HH and hh","label":{"api":{}}},{"text":"You can either loop through the array rearranging the positions or simply use some class that already does this for you, such as a linked list for example, which implements the remove(int index) method","label":{"api":{"remove(int index)":[[177,193]]}}},{"text":"The answer to your problem is to utilise BigInteger","label":{"api":{"BigInteger":[[41,50]]}}},{"text":"Note,  you should only call Optional.get() if you're sure there will be a value present in the Optional<T> otherwise it's better to utilise orElse or orElseGet to unwrap the value if present else provide a default value","label":{"api":{"Optional.get()":[[28,41]],"Optional<T>":[[95,105]],"orElse":[[140,145]],"orElseGet":[[150,158]]}}},{"text":"See the Optional<T> API for more details","label":{"api":{"Optional<T>":[[8,18]]}}},{"text":"See this post about the Optional<T> type if you're unfamiliar with it","label":{"api":{"Optional<T>":[[24,34]]}}},{"text":"Arrays::sort, like many other methods that accept generic types, is overloaded to support primitive types, see the JavaDocs","label":{"api":{"Arrays::sort":[[0,11]],"the JavaDocs":[[111,122]]}}},{"text":"Use toInstant(), then compare the results, like so","label":{"api":{"toInstant()":[[4,14]]}}},{"text":"If you want to wait for the thread to finish, call the join method","label":{"api":{"join":[[55,58]]}}},{"text":"Arrays.asList() returns a fixed-size list backed by the specified array","label":{"api":{"Arrays.asList()":[[0,14]]}}},{"text":"Split the string using the literal \"CODES\" to get the first half, then use a regular expression matcher to iterate over the codes","label":{"api":{"a regular expression matcher":[[75,102]]}}},{"text":"You could use Arrays.stream()","label":{"api":{"Arrays.stream()":[[14,28]]}}},{"text":"The Stream<double[][]>.min() function returns an Optional<double[]>","label":{"api":{"Stream<double[][]>.min()":[[4,27]],"Optional<double[]>":[[49,66]]}}},{"text":"Than you need to check for the existence of a minimum with Optional<double[]>.isPresent() before you can call Optional<double[]>.get()","label":{"api":{"Optional<double[]>.isPresent()":[[59,88]],"Optional<double[]>.get()":[[110,133]]}}},{"text":"The List.replaceAll(...) method replaces each element of the list by applying the given UnaryOperator","label":{"api":{"List.replaceAll(...)":[[4,23]],"UnaryOperator":[[88,100]]}}},{"text":"You can use the Supplier functional interface and a method reference to the default constructor","label":{"api":{"Supplier":[[16,23]],"functional interface":[[25,44]]}}},{"text":"To instantiate a new object, call Supplier.get","label":{"api":{"Supplier.get":[[34,45]]}}},{"text":"If your constructors require arguments, you'll need to use another functional interface","label":{"api":{"functional interface":[[67,86]]}}},{"text":"For one- and two-argument constructors, you can use Function and BiFunction respectively","label":{"api":{"Function":[[52,59]],"BiFunction":[[65,74]]}}},{"text":"Any more and you'll need to define your own functional interface","label":{"api":{"functional interface":[[44,63]]}}},{"text":"and then use Function.apply to get the instance","label":{"api":{"Function.apply":[[13,26]]}}},{"text":"Yes, LinkedList's remove method effectively shifts indices of elements beyond what is removed","label":{"api":{"LinkedList's remove method":[[5,30]]}}},{"text":"Have a look at the ServiceLoader class which is built into the JDK","label":{"api":{"ServiceLoader":[[19,31]]}}},{"text":"Now a JDK9 module can directly declare its services, but they can still be discovered via ServiceLoader, so this approach has a level of future proofing too","label":{"api":{"ServiceLoader":[[90,102]]}}}]