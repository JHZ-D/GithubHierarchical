[{"text": "You can find out the default charset on a platform by calling Charset.defaultCharset(), so check it on your local server and use that charset in the code", "label": {"api": {"Charset.defaultCharset()": [[62, 85]]}}}, {"text": "During your configuration time (login and before firing the threads) you can use something like an AtomicInteger, initializing it with new AtomicInteger(0) and calling getAndIncrement() to assign the possition of the thread, in the range [0-500) and then when you fire the threads sleep 300.0 * id / 500.0 milliseconds to execute the task/petition", "label": {"api": {"AtomicInteger": [[99, 111], [139, 151]]}}}, {"text": "You can check the thread type with SwingUtils.isEventDispatchThread() method", "label": {"api": {"SwingUtils.isEventDispatchThread()": [[35, 68]]}}}, {"text": "When you're copying old array to new array, you use the new capacity size, which is 20 and temp has only 10 elements, therefore an ArrayIndexOutOfBoundsException is thrown when it tries to copy next elements", "label": {"api": {"ArrayIndexOutOfBoundsException": [[131, 160]]}}}, {"text": "java's RSA key generation code accepts an instance of SecureRandom which the Oracle providers use to generate the candidate primes for RSA", "label": {"api": {"RSA key generation code": [[7, 29]], "SecureRandom": [[54, 65]]}}}, {"text": "You can subclass SecureRandom (I think) to provide a class that uses the password to seed a deterministic, repeatable sequence of random numbers such that every time you call KeyPairGenerator", "label": {"api": {"SecureRandom": [[17, 28]]}}}, {"text": "The bouncycastle library includes an example, FixedSecureRandom, that can be used as a model", "label": {"api": {"SecureRandom": [[51, 62]]}}}, {"text": "FixedSecureRandom is not secure, it simply returns the pre-supplied bytes directly as output", "label": {"api": {"SecureRandom": [[5, 16]]}}}, {"text": "Perhaps you can merge FixedSecureRandom with one of the other CSPRNGs in the org.bouncycastle.crypto.prng package", "label": {"api": {"SecureRandom": [[27, 38]]}}}, {"text": "Since String::replaceAll consumes regular expression you need to convert your search and replacement strings into regular expressions first", "label": {"api": {"String::replaceAll": [[6, 23]]}}}, {"text": "If you want to access the remote file line-by-line, you can convert it to Reader using InputStreamReader", "label": {"api": {"Reader": [[74, 79], [98, 103]], "InputStreamReader": [[87, 103]]}}}, {"text": "The ZipFile class can be used for working with zip files", "label": {"api": {"ZipFile": [[4, 10]]}}}, {"text": "The class documentation describes exactly what type of object will be returned for each XPathConstant field", "label": {"api": {"class documentation": [[4, 22]]}}}, {"text": "Since you just want the string value of the node, you can use the two-argument evaluate method instead, omitting the XPathConstants value", "label": {"api": {"two-argument evaluate method": [[66, 93]]}}}, {"text": "shuffle() the list then use the first 20", "label": {"api": {"shuffle()": [[0, 8]]}}}, {"text": "The best way to read float value in Java, where you can control the endian order, is to use a ByteBuffer", "label": {"api": {"ByteBuffer": [[94, 103]]}}}, {"text": "As the documentation of Serializable states", "label": {"api": {"the documentation of Serializable": [[3, 35]]}}}, {"text": "You can use String's replaceAll", "label": {"api": {"replaceAll": [[21, 30]]}}}, {"text": "For more details on how to construct a regex, see the documentation of Pattern", "label": {"api": {"Pattern": [[71, 77]]}}}, {"text": "I am trying to use the ExecutorCompletionService - https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html, to try and perform concurrent calls to two different dependent packages", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html": [[51, 143]]}}}, {"text": "There are a number of thread-safe collections in java.util.collect.concurrent that you might consider, otherwise you'll need to ensure you use synchronized blocks or methods anywhere you're working with this list", "label": {"api": {"java.util.collect.concurrent": [[49, 76]]}}}, {"text": "Create two different ModelManagers, one that opens and listens to a ServerSocket, and one that uses a Socket in getLatestTemperatureData() to connect to the other one", "label": {"api": {"ServerSocket": [[68, 79]], "Socket": [[74, 79], [102, 107]]}}}, {"text": "The glossary defines \"equivalence relation\" as reflexive (\"a.relation(a) is always true\"), symmetric (a1.relation(a2) == a2.relation(a1)) and transitive (a1.relation(a2) && a2.relation(a3) implies a1.relation(a3)) - and refers to Object.equals()' docs", "label": {"api": {"Object.equals()' docs": [[230, 250]]}}}, {"text": "The most common example of this is a TreeSet with a custom Comparator", "label": {"api": {"TreeSet": [[37, 43]]}}}, {"text": "Java SE also makes mention of this kind of situation when it's talking about ordering which is inconsistent with equals (see TreeSet)", "label": {"api": {"TreeSet": [[125, 131]]}}}, {"text": "(See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal", "label": {"api": {"TreeSet": [[171, 177]]}}}, {"text": "Since, for example, Double.compareTo expects a Double argument, it throws an exception when you pass it an Integer", "label": {"api": {"Double.compareTo": [[20, 35]]}}}, {"text": "When you call compareTo on the Comparable, it actually calls the method compareTo(Object) which attempts to cast the argument to a Double and then pass it to Double.compareTo(Double)", "label": {"api": {"Double.compareTo": [[158, 173]]}}}, {"text": "For this, you could use Scanner.findAll (available since Java 9) with a proper regex", "label": {"api": {"Scanner.findAll": [[24, 38]]}}}, {"text": "Scanner.findAll returns a Stream<MatchResult> and MatchResult.group() returns the matched String", "label": {"api": {"Scanner.findAll": [[0, 14]]}}}, {"text": "If you want to initialize Date instances from a formatted string with both date and time then time codes should be added to the SimpleDateFormat pattern to parse strings in that format", "label": {"api": {"Date": [[26, 29], [134, 137]], "SimpleDateFormat": [[128, 143]]}}}, {"text": "If you want to simply set the hour, minute, and second on the current date then use a Calendar instance and set fields on it accordingly", "label": {"api": {"Calendar": [[86, 93]]}}}, {"text": "And next output the Date in a particular format", "label": {"api": {"Date": [[20, 23]]}}}, {"text": "Your particular example looks like preconditions which are generally easier to write with Objects.requireNonNull", "label": {"api": {"Objects.requireNonNull": [[90, 111]]}}}, {"text": "This is easily achieved using the map function from Stream", "label": {"api": {"Stream": [[52, 57]]}}}, {"text": "But you can change it using the @Entity annotation to (almost) whatever you like", "label": {"api": {"@Entity": [[32, 38]]}}}, {"text": "Java allows you to pass an array of say Integer or Double to a method that expects an array of Number objects", "label": {"api": {"Number": [[95, 100]]}}}, {"text": "Therefore one simple solution would be to change your search method accept Number objects - to then call its doubleValue() method when comparing values", "label": {"api": {"Number": [[75, 80]]}}}, {"text": "As the javadoc of parse(String source, ParsePosition pos) says", "label": {"api": {"parse(String source, ParsePosition pos)": [[18, 56]]}}}, {"text": "Clients may insist on strict adherence to the format by calling setLenient(false)", "label": {"api": {"setLenient(false)": [[64, 80]]}}}, {"text": "To check if a string contains a date in a specific format, use a java.time.format.DateTimeFormatter", "label": {"api": {"java.time.format.DateTimeFormatter": [[65, 98]]}}}, {"text": "Your Comparator breaks the comparator contract", "label": {"api": {"Comparator": [[5, 14]]}}}, {"text": "But, if you want to have a custom comparator generated dinamically, or cannot/want to override equals and hashcode, you can use the functions comparing and thenComparing that provides the java Comparator", "label": {"api": {"Comparator": [[193, 202]]}}}, {"text": "This comparator however is not null safe, you need to pass Comparator.nullsFirst(Comparator.naturalOrder()) as second argument to allow the comparation of nulls", "label": {"api": {"Comparator": [[59, 68], [81, 90]]}}}, {"text": "If you are only storing non-negative Integer values, from 0 up to some limit (SET_SIZE), and your set is not sparely populated, you might want to consider using a BitSet instead", "label": {"api": {"BitSet": [[163, 168]]}}}, {"text": "A BitSet stores the presence or absence of each value as a single bit", "label": {"api": {"BitSet": [[2, 7]]}}}, {"text": "Therefore, the memory requirement of BitSet is a function of the largest integer ever stored in the set; a BitSet that can store all the Integer values from 0 to 20 million only takes 2.5 million bytes of storage", "label": {"api": {"BitSet": [[37, 42], [107, 112]]}}}, {"text": "If each entry takes 32 bytes, then after the 78125 entries have been stored in the HashSet<Integer>, it would take more memory than a BitSet of 20 million bits", "label": {"api": {"BitSet": [[134, 139]]}}}, {"text": "You may want to consider a Semaphore for this problem", "label": {"api": {"Semaphore": [[27, 35]]}}}, {"text": "For work to be done you need to move it outside of the user interface thread and use a mechanism to update it", "label": {"api": {"update it": [[100, 108]]}}}, {"text": "You need to use Driver.getPropertyInfo​(String url, Properties info)", "label": {"api": {"Driver.getPropertyInfo​(String url, Properties info)": [[16, 67]]}}}, {"text": "For writing the Java object i am using the SocketChannerl.write API", "label": {"api": {"SocketChannerl.write": [[43, 62]]}}}, {"text": "A very easy standard Java method from String - trim()", "label": {"api": {"trim()": [[47, 52]]}}}, {"text": "If it does - implement a null check before calling trim()", "label": {"api": {"trim()": [[51, 56]]}}}, {"text": "If you have some kind of plugin system and are looking for modules that interface with your code which may have been provided at runtime, then you should use the ServiceLoader API, i.e.", "label": {"api": {"the ServiceLoader API": [[158, 178]]}}}, {"text": "Note that if you want to retain some java object rather than the QuerySolution, you can use the Stream.map method to transform your solution before aggregation into an array", "label": {"api": {"Stream.map": [[96, 105]]}}}, {"text": "wait releases the monitor held on the object which wait is invoked on, but not any other monitors", "label": {"api": {"wait": [[0, 3], [51, 54]]}}}, {"text": "The thread releases ownership of this monitor and waits [...]", "label": {"api": {"wait": [[50, 53]]}}}, {"text": "At b.wait(), the current thread releases b's monitor, but not a's monitor", "label": {"api": {"wait": [[5, 8]]}}}, {"text": "If t.join() is implemented using t.wait() internally, then t's monitor is released while waiting, but not any other monitor", "label": {"api": {"wait": [[35, 38], [89, 92]]}}}, {"text": "If Thread used a private final Object monitor; to wait on instead, we could say that join released no monitors, even if it used wait internally without us knowing", "label": {"api": {"wait": [[50, 53], [128, 131]]}}}, {"text": "There would be no reason to document the implementation detail of using wait, because the monitor would be inaccessible to us, so we would not need to know about it", "label": {"api": {"wait": [[72, 75]]}}}, {"text": "The reason that we know join uses wait internally is that the people who originally wrote the method chose a monitor which is accessible to us", "label": {"api": {"wait": [[34, 37]]}}}, {"text": "join is not really supposed to release monitors from our perspective, just wait for a thread to complete, but an implementation was chosen which required us to know more about it than we should", "label": {"api": {"wait": [[75, 78]]}}}, {"text": "For any JComponent such as a JTextField, use JComponent.requestFocusInWindow()", "label": {"api": {"JComponent.requestFocusInWindow()": [[45, 77]]}}}, {"text": "You want to check Locale and build something that works for your use case", "label": {"api": {"Locale": [[18, 23]]}}}, {"text": "The following is a quick example to showcase how to use Locale to achieve the desired behavior", "label": {"api": {"Locale": [[56, 61]]}}}, {"text": "If you would like to read up more to understand how stages work I would reccomend this article https://docs.oracle.com/javase/8/javafx/api/javafx/stage/Stage.html", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/stage/Stage.html": [[95, 161]]}}}, {"text": "To \"pass a method\" in Java 8, you need a matching functional interface, i.e", "label": {"api": {"functional interface": [[50, 69]]}}}, {"text": "You can use one of the standard methods in the java.util.function package, or you can write your own", "label": {"api": {"java.util.function": [[47, 64]]}}}, {"text": "Since your parameters are different type, you can use BiFunction, or you could create your own like this", "label": {"api": {"BiFunction": [[54, 63]]}}}, {"text": "Just to maintain the contract and the behavior is enforced byComparable incase of natural ordering", "label": {"api": {"Comparable": [[61, 70]]}}}, {"text": "This can be folded into StringBuilder.append(String s, int start, int end)", "label": {"api": {"StringBuilder.append(String s, int start, int end)": [[24, 73]]}}}, {"text": "Use scanner's hasNextLine and it's other variants before trying to get the token with next*", "label": {"api": {"hasNextLine": [[14, 24]]}}}, {"text": "The String class in Java is immutable, meaning that once a String object is created whatever operation you perform on it won't change the object's value but, instead, it will return a new String which is the result of the method you invoked (toLowerCase in this case)", "label": {"api": {"String": [[4, 9], [59, 64], [188, 193]]}}}, {"text": "The flag set by interrupt() may not be observable to us, particularly when the thread is blocking", "label": {"api": {"interrupt()": [[16, 26]]}}}, {"text": "The PreparedStatement#executeQuery() method does not take any parameters", "label": {"api": {"PreparedStatement#executeQuery()": [[4, 35]]}}}, {"text": "Here's an example of how to generate one using UUID.randomUUID", "label": {"api": {"UUID.randomUUID": [[47, 61]]}}}, {"text": "You need to write your own logic using Deflater to compress the data, and you need to implement an InputStream, where you should implement at least the read(), read(byte[] b, int off, int len), and close() methods", "label": {"api": {"Deflater": [[39, 46]], "InputStream": [[99, 109]], "read()": [[152, 157]], "read(byte[] b, int off, int len)": [[160, 191]], "close()": [[198, 204]]}}}, {"text": "In java.util.Formatter (as opposed to java.util.logging.Formatter),  you can supply a Locale argument to the constructor, so you can specify the ROOT locale if you want", "label": {"api": {"java.util.Formatter": [[3, 21]]}}}, {"text": "If you want to take \"ooxoo\" and turn it into ['o','o','x','o','o'], you can use the toCharArray method on strings", "label": {"api": {"toCharArray": [[84, 94]]}}}, {"text": "For Integer values (and other types that implement the Comparable interface), you can use the Comparator#naturalOrder comparator as the last argument", "label": {"api": {"Comparator#naturalOrder": [[94, 116]]}}}, {"text": "You also always have the option to create a reversed comparator from that, for example", "label": {"api": {"reversed comparator": [[44, 62]]}}}, {"text": "The latter can easily be handled by passing a Comparator#nullsFirst or Comparator#nullsLast comparator to the outer method, but you have to be aware of that", "label": {"api": {"Comparator#nullsFirst": [[46, 66]], "Comparator#nullsLast": [[71, 90]]}}}, {"text": "The difference here is that the thing (Supplier) we're passing to the method will stay () -> dontCallMe(), it does not become () -> \"why oh why\" - only when you call get does it actually evaluate what's going on there and does dontCallMe actually get called", "label": {"api": {"Supplier": [[39, 46]]}}}, {"text": "useDelimiter takes a regular expression", "label": {"api": {"useDelimiter": [[0, 11]]}}}, {"text": "As precisely pointed by @Ivar in comments, also note that the pattern for months is uppercase M", "label": {"api": {"the pattern for months is uppercase M": [[58, 94]]}}}, {"text": "If you are using java.time it can be more helpful", "label": {"api": {"java.time": [[17, 25]]}}}, {"text": "The method replaceAll(..) returns the new String itself with replacement and you need to assign it to a variable", "label": {"api": {"replaceAll(..)": [[11, 24]]}}}, {"text": "I'm surprised that this has not been suggested yet, but this is a good scenario to use AtomicInteger", "label": {"api": {"AtomicInteger": [[87, 99]]}}}, {"text": "You can utilise the useDelimiter method like so", "label": {"api": {"useDelimiter": [[20, 31]]}}}, {"text": "Since you already have a Path, you can use Path#toFile, and then check if the file is a directory with File#isDirectory", "label": {"api": {"Path": [[25, 28], [43, 46]], "Path#toFile": [[43, 53]], "File#isDirectory": [[103, 118]]}}}, {"text": "Or even simpler with Files#isDirectory", "label": {"api": {"Files#isDirectory": [[21, 37]]}}}, {"text": "You can use a java.time.format.DateTimeFormatterBuilder to build a formatter with optional parts, where each optional part is a DateTimeFormatter that can parse one of those formats", "label": {"api": {"java.time.format.DateTimeFormatterBuilder": [[14, 54]]}}}, {"text": "The value 1520877600 seems to be in seconds since unix epoch, so you can use the ChronoField.INSTANT_SECONDS field", "label": {"api": {"ChronoField.INSTANT_SECONDS": [[81, 107]]}}}, {"text": "Anyway, as you want the year and month values, the best choice is to parse directly to a java.time.YearMonth, which in turn can be used to get the correspondent int values for year and month", "label": {"api": {"java.time.YearMonth": [[89, 107]]}}}, {"text": "For this I would recommend to use Map, with group name as a key and ArrayList as value", "label": {"api": {"Map": [[34, 36]]}}}, {"text": "Your current approach is succinct, yet uses a TreeMap when all you need is a TreeSet", "label": {"api": {"TreeSet": [[77, 83]]}}}, {"text": "Also, TreeSet still has O(nlogn) time complexity because it uses a TreeMap as its backing structure", "label": {"api": {"TreeSet": [[6, 12]]}}}, {"text": "The usage of TreeSet has 3 disadvantages", "label": {"api": {"TreeSet": [[13, 19]]}}}, {"text": "After all, according to the docs, a TreeSet<E> has a constructor that accepts an argument of type Comparator<", "label": {"api": {"according to the docs": [[11, 31]]}}}, {"text": "How can I use merge method https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#merge-K-V-java.util.function.BiFunction- to do the same", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#merge-K-V-java.util.function.BiFunction-": [[27, 152]]}}}, {"text": "If you use a Collections.synchronizedMap, for example, you can just do synchronized (map) {...} any time you need to do more than a single method call", "label": {"api": {"Collections.synchronizedMap": [[13, 39]]}}}, {"text": "In the case of add, the equivalent version to removing with an index, is List::add(int, E) (see javadoc for details)", "label": {"api": {"javadoc for details": [[96, 114]]}}}, {"text": "If the object does not override toString() Object.toString() is called", "label": {"api": {"Object.toString()": [[43, 59]]}}}, {"text": "You can use Random.ints(n) to generate n random numbers", "label": {"api": {"Random.ints(n)": [[12, 25]]}}}, {"text": "If you want to use a different source of randomness, you can override Random.next(bits) to supply bits from a custom source instead of from the built-in generator", "label": {"api": {"Random.next(bits)": [[70, 86]]}}}, {"text": "Given two LocalTime parameters in Java, I want to be able to compare the two times are see if they are equal (same time)", "label": {"api": {"LocalTime": [[10, 18]]}}}, {"text": "However, if I use following Java code, the symlink working directory resolves to the real path", "label": {"api": {"real path": [[85, 93]]}}}, {"text": "Instead, I would like to run the command in the absolute path", "label": {"api": {"absolute path": [[48, 60]]}}}, {"text": "Try Java Stream", "label": {"api": {"Stream": [[9, 14]]}}}, {"text": "String#trim() only removes all characters equal to or less than the space character (\\u0020), but there are many more characters that are \"whitespace\"", "label": {"api": {"String#trim()": [[0, 12]]}}}, {"text": "Have you given a look at DigestUtils and MessageDigest", "label": {"api": {"MessageDigest": [[41, 53]]}}}, {"text": "You can shorten it slightly by comparing the values of getAuthority(), which returns everything between the scheme and path", "label": {"api": {"getAuthority()": [[55, 68]]}}}, {"text": "Starting with Java 9, you can replace new AbstractMap.SimpleImmutableEntry<>(…) with Map.entry(…)", "label": {"api": {"Map.entry(…)": [[85, 96]]}}}, {"text": "Use FindBugs to locate spurious integer reference comparisons and replace them with Integer.equals -- that is the proper way to fix the problems you're encountering", "label": {"api": {"Integer.equals": [[84, 97]]}}}, {"text": "You can use the overload of Collectors.toMap that accepts a Supplier for the Map", "label": {"api": {"the overload of Collectors.toMap": [[12, 43]]}}}, {"text": "Here's a one-liner using the Arrays utility class", "label": {"api": {"Arrays": [[29, 34]]}}}, {"text": "You use of Set#contains does not look right to me", "label": {"api": {"Set#contains": [[11, 22]]}}}, {"text": "Now, as to your specific problem, the best way to check whether there is a common element in two lists, is by using the Collections.disjoint method, available since Java 1.5", "label": {"api": {"Collections.disjoint": [[120, 139]]}}}, {"text": "I just read about Java 9 module system and I'd like to ask about ServiceLoader", "label": {"api": {"ServiceLoader": [[65, 77]]}}}, {"text": "You can use flatMap to get from a stream of maps to a stream of entries like so", "label": {"api": {"flatMap": [[12, 18]]}}}, {"text": "Unlike nextLine() the nextDouble() doesn't set the position to the beginning of the next line", "label": {"api": {"nextLine()": [[7, 16]], "nextDouble()": [[22, 33]]}}}, {"text": "Here is a Link to the documentation", "label": {"api": {"Link": [[10, 13]]}}}, {"text": "Look at the Runtime class", "label": {"api": {"Runtime": [[12, 18]]}}}, {"text": "This is how features like javax.annotation.security.RolesAllowed are implemented", "label": {"api": {"javax.annotation.security.RolesAllowed": [[26, 63]]}}}, {"text": "First one would be to Task to implement Comparator interface", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "Second would be to pass a Comparator to your sort methods", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "If you want to input a multiline text you can make use of the useDelimiter(String pattern) function", "label": {"api": {"useDelimiter(String pattern)": [[62, 89]]}}}, {"text": "If you use executors, then you can provide a ThreadFactory, that creates the threads with the right interrupt() method", "label": {"api": {"ThreadFactory": [[45, 57]]}}}, {"text": "Then, use Collectors.groupingBy along with Collectors.mapping", "label": {"api": {"Collectors.groupingBy": [[10, 30]], "Collectors.mapping": [[43, 60]]}}}, {"text": "This method is preferred but you won't be able to inspect this at the time of filtering", "label": {"api": {"filter": [[78, 83]]}}}, {"text": "Another option would be to create a custom filter that modifies the current message by prepending the score and returning true", "label": {"api": {"filter": [[43, 48]], "modifies": [[55, 62]], "current message": [[68, 82]]}}}, {"text": "Then install the filter on the handler in use or install it on every logger that is generating log records", "label": {"api": {"filter": [[17, 22]], "handler": [[31, 37]], "every logger": [[63, 74]]}}}, {"text": "As the JavaDoc of CompletableFuture.allOf() indicates", "label": {"api": {"the JavaDoc of CompletableFuture.allOf()": [[3, 42]]}}}, {"text": "Note that in your particular case, if you only have 2 futures, it is probably simpler to use thenCombine() which gives you access to the 2 results more easily", "label": {"api": {"thenCombine()": [[93, 105]]}}}, {"text": "This can be done with the ArrayList copy constructor, e.g.", "label": {"api": {"ArrayList copy constructor": [[26, 51]]}}}, {"text": "See the contract for compareAndSet(int expect,int update)", "label": {"api": {"compareAndSet(int expect,int update)": [[21, 56]]}}}, {"text": "In Java 8, you can use a java.time.format.DateTimeFormatter with lots of optional sections - delimited by []", "label": {"api": {"java.time.format.DateTimeFormatter": [[25, 58]]}}}, {"text": "Note that there's a difference between HH and hh", "label": {"api": {"there's a difference between HH and hh": [[10, 47]]}}}, {"text": "You can either loop through the array rearranging the positions or simply use some class that already does this for you, such as a linked list for example, which implements the remove(int index) method", "label": {"api": {"such as a linked list for example": [[121, 153]]}}}, {"text": "The answer to your problem is to utilise BigInteger", "label": {"api": {"BigInteger": [[41, 50]]}}}, {"text": "Note,  you should only call Optional.get() if you're sure there will be a value present in the Optional<T> otherwise it's better to utilise orElse or orElseGet to unwrap the value if present else provide a default value", "label": {"api": {"Optional<T>": [[95, 105]]}}}, {"text": "See the Optional<T> API for more details", "label": {"api": {"Optional<T>": [[8, 18]]}}}, {"text": "See this post about the Optional<T> type if you're unfamiliar with it", "label": {"api": {"Optional<T>": [[24, 34]]}}}, {"text": "Arrays::sort, like many other methods that accept generic types, is overloaded to support primitive types, see the JavaDocs", "label": {"api": {"the JavaDocs": [[111, 122]]}}}, {"text": "Use toInstant(), then compare the results, like so", "label": {"api": {"toInstant()": [[4, 14]]}}}, {"text": "If you want to wait for the thread to finish, call the join method", "label": {"api": {"join": [[55, 58]]}}}, {"text": "Arrays.asList() returns a fixed-size list backed by the specified array", "label": {"api": {"Arrays.asList()": [[0, 14]]}}}, {"text": "Split the string using the literal \"CODES\" to get the first half, then use a regular expression matcher to iterate over the codes", "label": {"api": {"a regular expression matcher": [[75, 102]]}}}, {"text": "You could use Arrays.stream()", "label": {"api": {"Arrays.stream()": [[14, 28]]}}}, {"text": "The Stream<double[][]>.min() function returns an Optional<double[]>", "label": {"api": {"Optional<double[]>": [[49, 66]]}}}, {"text": "Than you need to check for the existence of a minimum with Optional<double[]>.isPresent() before you can call Optional<double[]>.get()", "label": {"api": {"Optional<double[]>": [[59, 76], [110, 127]]}}}, {"text": "The List.replaceAll(...) method replaces each element of the list by applying the given UnaryOperator", "label": {"api": {"List.replaceAll(...)": [[4, 23]]}}}, {"text": "You can use the Supplier functional interface and a method reference to the default constructor", "label": {"api": {"Supplier": [[16, 23]], "functional interface": [[25, 44]]}}}, {"text": "To instantiate a new object, call Supplier.get", "label": {"api": {"Supplier": [[34, 41]], "Supplier.get": [[34, 45]]}}}, {"text": "If your constructors require arguments, you'll need to use another functional interface", "label": {"api": {"functional interface": [[67, 86]]}}}, {"text": "For one- and two-argument constructors, you can use Function and BiFunction respectively", "label": {"api": {"Function": [[52, 59], [67, 74]], "BiFunction": [[65, 74]]}}}, {"text": "Any more and you'll need to define your own functional interface", "label": {"api": {"functional interface": [[44, 63]]}}}, {"text": "and then use Function.apply to get the instance", "label": {"api": {"Function": [[13, 20]], "Function.apply": [[13, 26]]}}}, {"text": "Yes, LinkedList's remove method effectively shifts indices of elements beyond what is removed", "label": {"api": {"LinkedList's remove method": [[5, 30]]}}}, {"text": "Have a look at the ServiceLoader class which is built into the JDK", "label": {"api": {"ServiceLoader": [[19, 31]]}}}, {"text": "Now a JDK9 module can directly declare its services, but they can still be discovered via ServiceLoader, so this approach has a level of future proofing too", "label": {"api": {"ServiceLoader": [[90, 102]]}}}, {"text": "That is what toString shows by default", "label": {"api": {"toString": [[13, 20]]}}}, {"text": "You may want to override toString on your PlsWork-class for example as follows", "label": {"api": {"toString": [[25, 32]]}}}, {"text": "Then call request.getContextPath", "label": {"api": {"request.getContextPath": [[10, 31]]}}}, {"text": "getLocalHost() is a method of InetAddress and can't be just called without such an instance", "label": {"api": {"InetAddress": [[30, 40]]}}}, {"text": "java InetAddress.getLocalHost(); returns 127.0.0.1 ..", "label": {"api": {"InetAddress": [[5, 15]]}}}, {"text": "Further, you can use transferTo to transfer all remaining data from an InputStream to an OutputStream, without the need to implement a copying routine", "label": {"api": {"transferTo": [[21, 30]]}}}, {"text": "We could do this similar to the solution above, just replacing ZipOutputStream with DeflaterOutputStream, but there’s another alternative, using DeflaterInputStream to compress the data right when reading", "label": {"api": {"DeflaterInputStream": [[145, 163]]}}}, {"text": "I would introduce a new List<String> of available options for a current player", "label": {"api": {"List<String>": [[24, 35]]}}}, {"text": "Once a player chooses a piece it could be easily removed from the set by calling remove", "label": {"api": {"remove": [[49, 54], [81, 86]]}}}, {"text": "Also you could validate the choice by calling the contains method on the set", "label": {"api": {"contains": [[50, 57]]}}}, {"text": "You can use a java.sql.PreparedStatement to insert a blob into your database", "label": {"api": {"java.sql.PreparedStatement": [[14, 39]]}}}, {"text": "If you look up into the java.util.stream.Stream JavaDoc you can see that there is a few terminal operations, like forEach, collect, toArray, etc", "label": {"api": {"java.util.stream.Stream JavaDoc": [[24, 54]]}}}, {"text": "The Scanner API should help you out", "label": {"api": {"Scanner API": [[4, 14]]}}}, {"text": "addFirst is provided by the Deque interface", "label": {"api": {"addFirst": [[0, 7]], "Deque": [[28, 32]]}}}, {"text": "One solution is to define optimal as a Deque instead", "label": {"api": {"Deque": [[39, 43]]}}}, {"text": "If you're wondering exactly how to use it, read the documentation of DataInputStream#readUTF for reading and DataOutputStream#writeUTF for writing", "label": {"api": {"DataInputStream#readUTF": [[69, 91]], "DataOutputStream#writeUTF": [[109, 133]]}}}, {"text": "As has been mentioned, you need to compare String equality using the String.equals(Object anObject) - alternatively you may use others methods (compareTo), but the == operator will not suffice (See here why)", "label": {"api": {"String.equals(Object anObject)": [[69, 98]]}}}, {"text": "The javadoc of Statement says", "label": {"api": {"Statement": [[15, 23]]}}}, {"text": "All execution methods in the Statement interface implicitly close a current ResultSet object of the statement if an open one exists", "label": {"api": {"Statement": [[29, 37]]}}}, {"text": "Use a different Statement object to execute the update", "label": {"api": {"Statement": [[16, 24]]}}}, {"text": "You are using the default version of the parse method, it has the default formatter of 2007-12-03T10:15:30+01:00[Europe/Paris]", "label": {"api": {"parse method": [[41, 52]]}}}, {"text": "You need to pass a correct DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[27, 43]]}}}, {"text": "To me the RFC_1123_DATE_TIME seems the closest to your format, but it's not a match, so you will need to create your own", "label": {"api": {"RFC_1123_DATE_TIME": [[10, 27]]}}}, {"text": "Instead, use another constructor that lets you specify the length of the data", "label": {"api": {"another constructor": [[13, 31]]}}}, {"text": "This is due to the fail-fast feature", "label": {"api": {"fail-fast": [[19, 27]]}}}, {"text": "The iterators returned by this class's iterator and listIterator methods are fail-fast", "label": {"api": {"fail-fast": [[77, 85]]}}}, {"text": "There is no need to write your own getMessage since there is already one in the parent class Throwable.getMessage() - which you simply inherit anyway", "label": {"api": {"Throwable.getMessage()": [[93, 114]]}}}, {"text": "Each AudioInputStream has an AudioFormat object, which you can get via the format() method", "label": {"api": {"format()": [[75, 82]]}}}, {"text": "The method ScheduledExecutorService.scheduleAtFixedRate returns a ScheduledFuture<?> - this allows you to cancel the task", "label": {"api": {"ScheduledExecutorService.scheduleAtFixedRate": [[11, 54]]}}}, {"text": "What getBytes called with no arguments returns will depend on your system", "label": {"api": {"getBytes": [[5, 12]]}}}, {"text": "Encodes this String into a sequence of bytes using the platform's default charset, storing the result into a new byte array", "label": {"api": {"String": [[13, 18]]}}}, {"text": "There are overloads of getBytes that let you specify what encoding to use", "label": {"api": {"getBytes": [[23, 30]]}}}, {"text": "If you want to access the number of code points in a string, you can use codePointCount; to access the code points, you can use the codePoints stream", "label": {"api": {"codePointCount": [[73, 86]], "codePoints": [[132, 141]]}}}, {"text": "String has a couple of other code-point-related methods as well, just search the JavaDoc for \"codepoint\"", "label": {"api": {"String": [[0, 5]]}}}, {"text": "All that is related to String, specifically; once you convert to a byte array, you're potentially using an encoding other than UTF-16", "label": {"api": {"String": [[23, 28]]}}}, {"text": "ConcurrentHashMap is useful also in Scala for handling state in a thread safe manner", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "I simply would go with Optional.orElseGet and an explicit cast in between", "label": {"api": {"Optional.orElseGet": [[23, 40]]}}}, {"text": "Use trim() to eliminate extra spaces at the beginning or the end of a string", "label": {"api": {"trim()": [[4, 9]]}}}, {"text": "You can use a combination of String#trim and equals", "label": {"api": {"String#trim": [[29, 39]]}}}, {"text": "If you want to change it at runtime, you can use the java.util.TimeZone.setDefault()", "label": {"api": {"java.util.TimeZone.setDefault()": [[53, 83]]}}}, {"text": "I'd say a simple solution would be to use an IntStream", "label": {"api": {"IntStream": [[45, 53]]}}}, {"text": "Filtering out null elements will prevent this from throwing a NullPointerException", "label": {"api": {"NullPointerException": [[62, 81]]}}}, {"text": "From the Map Documentation you can see you can use keySet() to recover the Set of all keys in your Map, which, in your case, will contain your only key", "label": {"api": {"Map Documentation": [[9, 25]]}}}, {"text": "In Java 8, change return type to Optional<T>, then return Optional.of(...) or Optional.empty()", "label": {"api": {"Optional<T>": [[33, 43]], "Optional.of(...)": [[58, 73]], "Optional.empty()": [[78, 93]]}}}, {"text": "The caller can then call returnValue.isPresent(), and if true can call returnValue.get() to get the actual value", "label": {"api": {"returnValue.isPresent()": [[25, 47]], "returnValue.get()": [[71, 87]]}}}, {"text": "I am experimenting with CompletableFuture in making async API calls", "label": {"api": {"CompletableFuture": [[24, 40]], "Future": [[35, 40]]}}}, {"text": "I am trying to understand the implication of ignoring the response from a Future", "label": {"api": {"Future": [[74, 79]]}}}, {"text": "But in case we have no CompletableFuture.get() call to retrieve the response, I assume that the response is never being accessed in the code", "label": {"api": {"CompletableFuture": [[23, 39]], "Future": [[34, 39]], "CompletableFuture.get()": [[23, 45]]}}}, {"text": "Are there any specific caveats/safety checks which I should be aware of when I ignore the response from the CompletableFuture", "label": {"api": {"CompletableFuture": [[108, 124]], "Future": [[119, 124]]}}}, {"text": "However, if you're not locked into using an ArrayList for storage, you're probably better off using a PriorityQueue which will naturally keep the elements in priority order", "label": {"api": {"PriorityQueue": [[102, 114]]}}}, {"text": "First of all, it is to say, that the method Class.getResource(String) does not specify any support for handling \"..\" in the path", "label": {"api": {"Class.getResource(String)": [[44, 68]]}}}, {"text": "There are both Java API and native interface for doing that", "label": {"api": {"Java API": [[15, 22]]}}}, {"text": "The Iterator classes are good candidates to illustrate the difference between these two exceptions", "label": {"api": {"Iterator": [[4, 11]]}}}, {"text": "Iterator implements remove() in a default method by throwing a UnsupportedOperationException", "label": {"api": {"Iterator": [[0, 7]]}}}, {"text": "About implementations, we can see that the Iterator implementation used by the ArrayList class overrides remove() to support it", "label": {"api": {"Iterator": [[43, 50]], "ArrayList": [[79, 87]]}}}, {"text": "The text is rendered with a Text node (https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html#text) so use -fx-fill and/or -fx-stroke", "label": {"api": {"https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html#text": [[39, 114]]}}}, {"text": "So add the @Valid annotation on the parameter(s) that you want to validate such as", "label": {"api": {"@Valid": [[11, 16]]}}}, {"text": "AudioSystem.getAudioInputStream expects a stream which conforms to a supported AudioFileFormat, which means it must conform to a known type", "label": {"api": {"AudioFileFormat": [[79, 93]], "known type": [[129, 138]]}}}, {"text": "If the length is not known, it can specified as AudioSystem.NOT_SPECIFIED", "label": {"api": {"AudioSystem.NOT_SPECIFIED": [[48, 72]]}}}, {"text": "Frustratingly, neither the constructor documentation nor the class documentation mentions this, but the other constructor’s documentation does", "label": {"api": {"other constructor’s documentation": [[104, 136]]}}}, {"text": "Perhaps, this is now easier for you to write in JPQL, but why not just run a SQL query through EntityManager.createNativeQuery(String, Class)", "label": {"api": {"EntityManager.createNativeQuery(String, Class)": [[95, 140]]}}}, {"text": "As it says in the documentation", "label": {"api": {"As it says in the documentation": [[0, 30]]}}}, {"text": "Shut down the executor (executor.shutdown()), or reuse it", "label": {"api": {"executor.shutdown()": [[24, 42]]}}}, {"text": "The generator function is required to produce \"a new array of the desired type and the provided length.\" If you don't comply with the spec, behavior is undefined", "label": {"api": {"required": [[26, 33]]}}}, {"text": "Call .trim(..) on the variable that contains the word “\\ncontainer” before checking if it’s in your “variables” list", "label": {"api": {".trim(..)": [[5, 13]]}}}, {"text": "Look at the setTwoDigitYearStart method with yy as the year term", "label": {"api": {"setTwoDigitYearStart": [[12, 31]]}}}, {"text": "It's fairly easy, you just need to create the file as normal, then call Files.setOwner()", "label": {"api": {"Files.setOwner()": [[72, 87]]}}}, {"text": "Alternatively, create a file with Files.createFile(), and then make sure you pass in a file attribute with the expected owner", "label": {"api": {"Files.createFile()": [[34, 51]]}}}, {"text": "See the GridPane documentation, which explains this all completely", "label": {"api": {"GridPane documentation": [[8, 29]]}}}, {"text": "TreeMap sorts the entries by key, not by value", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "Use a LinkedHashMap instead, because stores the entries according to the order they were inserted", "label": {"api": {"LinkedHashMap": [[6, 18]]}}}, {"text": "To emulate this, it might be a good idea to just divide populationCount by 500 and use ThreadLocalRandom#nextGaussian to determine how much to increment populationCount by, allowing you to rid yourself of the for-loop", "label": {"api": {"ThreadLocalRandom#nextGaussian": [[87, 116]]}}}, {"text": "From What I've read on the java documentation, a HashSet doesn't guarantee sorting on the elements in the set", "label": {"api": {"HashSet": [[49, 55]]}}}, {"text": "However if you were to implement instead as a SortedSet it should allow for ordering of the elements, but you may possibly need to make a comparator for it as well", "label": {"api": {"SortedSet": [[46, 54]]}}}, {"text": "Both above solutions gives you an idea about your problem, In case You you want to add multiple ArrayList in one shot, you can use ArrayList::addAll like this", "label": {"api": {"ArrayList::addAll": [[131, 147]]}}}, {"text": "Java-9 solution, using regex Pattern with two capture groups and a MatchResults stream", "label": {"api": {"Pattern": [[29, 35]], "MatchResults stream": [[67, 85]]}}}, {"text": "The easiest method would be to sort the array using Arrays.sort method", "label": {"api": {"Arrays.sort": [[52, 62]]}}}, {"text": "I would write it with Map#put and Map#getOrDefault", "label": {"api": {"Map#put": [[22, 28]], "Map#getOrDefault": [[34, 49]]}}}, {"text": "Your solution can cause SQL Injection or Syntax error, instead use PreparedStatement it is more secure and more helpful", "label": {"api": {"PreparedStatement": [[67, 83]]}}}, {"text": "This uses Map.computeIfAbsent to create a new innerMap and put it in the outerMap if not present (the key being personId), and also to create a new innerList and put it in the innerMap if not present (the key being date)", "label": {"api": {"Map.computeIfAbsent": [[10, 28]]}}}, {"text": "Even the new LocalDateTime with DateTimeFormatter do not provide a string representation of the long", "label": {"api": {"LocalDateTime": [[13, 25]], "DateTimeFormatter": [[32, 48]]}}}, {"text": "Browsing stack has led to believe I should implement an extractor, but based on the examples provided I have no idea how to do this for my specific problem", "label": {"api": {"extractor": [[56, 64]]}}}, {"text": "As an aside, don't use map to perform debugging work, instead utilise peek", "label": {"api": {"peek": [[70, 73]]}}}, {"text": "You can use Predicate's default method and for this purpose", "label": {"api": {"Predicate's default method and": [[12, 41]]}}}, {"text": "You can implement the visitFileFailed method and return FileVisitResult.SKIP_SUBTREE to skip the directory when running into an AccessDeniedException", "label": {"api": {"visitFileFailed": [[22, 36]]}}}, {"text": "Second, the most efficient way to compare array equality is probably Arrays.equals or Arrays.deepEquals, as they might be more optimized for the target machine", "label": {"api": {"Arrays.equals": [[69, 81]], "Arrays.deepEquals": [[86, 102]]}}}, {"text": "You can use Long.compare like this", "label": {"api": {"Long.compare": [[12, 23]]}}}, {"text": "Here's one with Files.write", "label": {"api": {"Files.write": [[16, 26]]}}}, {"text": "Using capital Y means something called a \"week year\", which is different than year", "label": {"api": {"\"week year\"": [[41, 51]]}}}, {"text": "If you need to manipulate the string value, if it is present before returning it, use map method", "label": {"api": {"method": [[90, 95]]}}}, {"text": "If input is empty the method returns default value - \"NOT_FOUND\", otherwise capitalized part of the string is returned", "label": {"api": {"method": [[22, 27]]}}}, {"text": "Notice that in the JDK, the pull() operation of Queue will do get and delete", "label": {"api": {"in the JDK": [[12, 21]]}}}, {"text": "you will need to implement a Timer that invokes tasks every x seconds", "label": {"api": {"Timer": [[29, 33]]}}}, {"text": "You could achieve this by using the TextFlow component", "label": {"api": {"TextFlow": [[36, 43]]}}}, {"text": "It works by passing objects to your TextFlow such as TextField, Text etc", "label": {"api": {"TextFlow": [[36, 43]]}}}, {"text": "Then, you could choose whether a TextField object you are adding to the TextFlow is editable or not", "label": {"api": {"TextFlow": [[72, 79]]}}}, {"text": "java.lang.annotatino.Annotation is somewhat special", "label": {"api": {"java.lang.annotatino.Annotation": [[0, 30]]}}}, {"text": "In this case an IdentityHashMap is a good fit", "label": {"api": {"IdentityHashMap": [[16, 30]]}}}, {"text": "Here is the  Oracle Java documentation considering the PrintStream class, which is accessed through the System.out call (out is a PrintStream there)", "label": {"api": {"Oracle Java documentation": [[13, 37]]}}}, {"text": "As @Tree suggested in comments, one can use the java.text.Collator for a case-insensitive and locale-sensitive String comparison", "label": {"api": {"java.text.Collator": [[48, 65]]}}}, {"text": "You can use Math.log(double d) to compute the value for all real numbers greater than 0", "label": {"api": {"Math.log(double d)": [[12, 29]]}}}, {"text": "If you want to represent a void-returning method taking parameters then look into Consumer or BiConsumer or a specific specialization of it", "label": {"api": {"Consumer": [[82, 89], [96, 103]], "BiConsumer": [[94, 103]], "specific specialization of it": [[110, 138]]}}}, {"text": "If you want to represent a method that does take parameters, consider using Consumer and BiConsumer", "label": {"api": {"Consumer": [[76, 83], [91, 98]], "BiConsumer": [[89, 98]]}}}, {"text": "Or maybe you are asking how to convert from a Consumer to a Runnable, try this", "label": {"api": {"Consumer": [[46, 53]]}}}, {"text": "Use an AnimationTimer to listen for updates", "label": {"api": {"AnimationTimer": [[7, 20]]}}}, {"text": "From the EntityManager javadoc", "label": {"api": {"EntityManager javadoc": [[9, 29]]}}}, {"text": "Actually, Scanner has this handy overload of next(String pattern) that throws an InputMismatchException automatically if the input does not match a pattern", "label": {"api": {"pattern": [[57, 63], [148, 154]]}}}, {"text": "[a-zA-Z] is the pattern used here", "label": {"api": {"pattern": [[16, 22]]}}}, {"text": "Use a memory mapped ByteBuffer for maximum efficiency", "label": {"api": {"ByteBuffer": [[20, 29]]}}}, {"text": "But for simplicity, in a previous job we needed something acts like OSGI without using OSGI, we built API using serviceLoader and created an interface for our module (in your case job) each jar will have a class which will implement the interface", "label": {"api": {"serviceLoader": [[112, 124]]}}}, {"text": "This solution uses Collectors.groupingBy and Collectors.mapping to create the desired Map instance", "label": {"api": {"Collectors.groupingBy": [[19, 39]], "Collectors.mapping": [[45, 62]]}}}, {"text": "However, I find the stream-based solution a little bit convoluted, because when you pair authors and book types in Map.Entry instances, you then have to use Map.Entry methods in the Collectors.groupingBy part, thus losing the initial semantics of your solution, as well as some readability..", "label": {"api": {"Collectors.groupingBy": [[182, 202]]}}}, {"text": "From Serializable JavaDocs", "label": {"api": {"Serializable JavaDocs": [[5, 25]]}}}, {"text": "Collections.binarySearch method provides exactly the feature you are looking for", "label": {"api": {"Collections.binarySearch": [[0, 23]]}}}, {"text": "You can use String.chars to get an IntStream, then just rely on the fact that char is really just an integer under the hood and do a bit of arithmetic", "label": {"api": {"String.chars": [[12, 23]]}}}, {"text": "But, I think you should consider using built-in tools, like Scheduled thread pool", "label": {"api": {"Scheduled thread pool": [[60, 80]]}}}, {"text": "I am basically looking for a recursive getSuperclass() and getInterfaces() method, collecting the whole class hierarchy", "label": {"api": {"getSuperclass()": [[39, 53]], "getInterfaces()": [[59, 73]]}}}, {"text": "I don't know about others but I prefer using ArrayLists", "label": {"api": {"ArrayLists": [[45, 54]]}}}, {"text": "See the documentation for Java 7 and the tutorial for javase for more information", "label": {"api": {"documentation for Java 7": [[8, 31]]}}}, {"text": "Spend some time reading the JSE API pages", "label": {"api": {"JSE API": [[28, 34]]}}}, {"text": "If the rectangle begins responding to the arrow keys, then you may simply need to call requestFocusInWindow() on your Gameseeting panel after the frame has become visible", "label": {"api": {"requestFocusInWindow()": [[87, 108]]}}}, {"text": "The code would need to test for the VK_NUMPAD8 code", "label": {"api": {"VK_NUMPAD8": [[36, 45]]}}}, {"text": "You're looking for the toMap collector", "label": {"api": {"toMap collector": [[23, 37]]}}}, {"text": "I suggest using a CopyOnWriteArrayList for this", "label": {"api": {"CopyOnWriteArrayList": [[18, 37]]}}}, {"text": "At the startup of your software you query the database to find out the name of the column, for example with ResultSetMetaData or using the DB specific queries", "label": {"api": {"ResultSetMetaData": [[108, 124]]}}}, {"text": "Do select * from Student and from the resulting ResultSet call getMetaData() to obtain a ResultSetMetaData instance", "label": {"api": {"getMetaData()": [[63, 75]], "ResultSetMetaData": [[89, 105]]}}}, {"text": "Use getColumnName() to get the table's actual column names", "label": {"api": {"getColumnName()": [[4, 18]]}}}, {"text": "You can use the split function to achieve this", "label": {"api": {"split": [[16, 20]]}}}, {"text": "Please note that the parameter of split is a regex expression, so be cautious with passing things like \".\"", "label": {"api": {"split": [[34, 38]]}}}, {"text": "Assuming you have a multiple line output - you may want to use multiple calls to the split method", "label": {"api": {"split": [[85, 89]]}}}, {"text": "There is no signature with a Comparator for arrays of primitives", "label": {"api": {"Comparator": [[29, 38]]}}}, {"text": "You can use the fill method from the Array class", "label": {"api": {"fill": [[16, 19]]}}}, {"text": "Alternatively, use a different Uri parser, such as java.net.URL, which coincidentally also has a toURI() method", "label": {"api": {"java.net.URL": [[51, 62]], "toURI()": [[97, 103]]}}}, {"text": "or for what ever reason you don't want to override equals and hashcode you can do it with the toMap collector", "label": {"api": {"the toMap collector": [[90, 108]]}}}, {"text": "You're looking for Comparator#thenComparing", "label": {"api": {"Comparator#thenComparing": [[19, 42]]}}}, {"text": "Note that I used String#split for this example, as it works with the example data you provided, but I'm not aware of the actual syntax of the line", "label": {"api": {"String#split": [[17, 28]]}}}, {"text": "I would suggest using a LinkedTransferQueue from the java.util.concurrent package", "label": {"api": {"LinkedTransferQueue": [[24, 42]]}}}, {"text": "A more streamlined approach, but somewhat more complex to implement, is to use a SwingWorker", "label": {"api": {"SwingWorker": [[81, 91]]}}}, {"text": "I cannot try it out right now, but on touchscreen I would expect, that the same approach is working by using SwipeEvents", "label": {"api": {"SwipeEvent": [[109, 118]]}}}, {"text": "Here is documentation", "label": {"api": {"Here is documentation": [[0, 20]]}}}, {"text": "If so, that's easier, since the curve OID is present in the \"X.509\" encoding of an EC public key, which is actually the SubjectPublicKeyInfo structure from X.509 (replicated in PKIX, see rfc5280 #4.1 and rfc3279 #2.3.5 but skip the parts about explicit parameters, everybody uses the namedCurve=OID option) which is the encoding for JCA public keys, for both Sun/Oracle/OpenJDK and BC implementations (and all algorithms not just ECC)", "label": {"api": {"the encoding for JCA public keys": [[316, 347]]}}}, {"text": "Based on the documentation of FileNameExtensionFilter SE8 and FileNameExtensionFilter SE7  the constructor should accept your usage attempt", "label": {"api": {"FileNameExtensionFilter SE8": [[30, 56]], "FileNameExtensionFilter SE7": [[62, 88]]}}}, {"text": "You were on the right track with DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[33, 49]]}}}, {"text": "Rather than use DateTimeFormatter.parse, you can pass this formatter to LocalTime.parse which will effectively discard the date portion of the timestamp", "label": {"api": {"DateTimeFormatter": [[16, 32]], "DateTimeFormatter.parse": [[16, 38]], "LocalTime.parse": [[72, 86]]}}}, {"text": "You can then use Comparable.compareTo to see whether it's in the ranges you've given", "label": {"api": {"Comparable.compareTo": [[17, 36]]}}}, {"text": "If your ranges were exclusive rather than inclusive, you could have used LocalTime.isAfter and LocalTime.isBefore which would have resulted in slightly nicer looking code", "label": {"api": {"LocalTime.isAfter": [[73, 89]], "LocalTime.isBefore": [[95, 112]]}}}, {"text": "However I would recommend using an IntPredicate, because this allows you to pass the testValue from handleSomethingto the predicate", "label": {"api": {"IntPredicate": [[35, 46]]}}}, {"text": "I have tried ProcessBuilder, Runtime  and Apache ANT", "label": {"api": {"ProcessBuilder": [[13, 26]], "Runtime": [[29, 35]]}}}, {"text": "From the javadoc of ExecutorService class", "label": {"api": {"javadoc of ExecutorService class": [[9, 40]]}}}, {"text": "You can achieve what you want by means of Collectors.toMap", "label": {"api": {"Collectors.toMap": [[42, 57]]}}}, {"text": "For the merge function (Collectors.toMap 3rd argument), I've used (e1, e2) -> e1, meaning that we'll keep the values already present in the map when there are equal keys", "label": {"api": {"Collectors.toMap": [[24, 39]]}}}, {"text": "I am looking at the Polyline class from JavaFX", "label": {"api": {"Polyline": [[20, 27]]}}}, {"text": "It inherits quite a few APIs from the Node class", "label": {"api": {"Node": [[38, 41]]}}}, {"text": "There is an API called contains that takes in  x and y coordinates and determines if the given point lies within the polyline", "label": {"api": {"contains": [[23, 30]]}}}, {"text": "Use a ZipFile instead, since it allows random access to the zip entries, so it is faster, and it allows reading the entries in random order", "label": {"api": {"ZipFile": [[6, 12]]}}}, {"text": "You can create a custom implementation of the SelectionModel which you'd need to share between both lists and in which implement the selection constraints", "label": {"api": {"SelectionModel": [[46, 59]]}}}, {"text": "Failure to do this will cause undefined results", "label": {"api": {"undefined": [[30, 38]]}}}, {"text": "Note that the getSelectedRow() method returns -1 if no row is selected (documentation here)", "label": {"api": {"documentation here": [[72, 89]]}}}, {"text": "Searching Google for \"Java initializeFrom\" results in several usages (example, example)", "label": {"api": {"example": [[70, 76], [79, 85]]}}}, {"text": "I found a solution using Collector.of()", "label": {"api": {"Collector.of()": [[25, 38]]}}}, {"text": "According to the contract for a Set in Java, \"it is not permissible for a set to contain itself as an element\" (source)", "label": {"api": {"source": [[112, 117]]}}}, {"text": "You can use https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html to get a priority queue in Java", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html": [[12, 81]]}}}, {"text": "You can use String::replaceAll like this", "label": {"api": {"String::replaceAll": [[12, 29]]}}}, {"text": "Besides, you were not using Optional.map and Optional.orElseThrow correctly", "label": {"api": {"Optional.map": [[28, 39]], "Optional.orElseThrow": [[45, 64]]}}}, {"text": "You used a wrong field for TemporalAdjusters.dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek) since ordinal is the week within the month but you used ALIGNED_DAY_OF_WEEK_IN_MONTH¹", "label": {"api": {"TemporalAdjusters.dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek)": [[27, 94]], "ALIGNED_DAY_OF_WEEK_IN_MONTH": [[152, 179]]}}}, {"text": "For this you need WeekFields, the most common is WeekFields.ISO", "label": {"api": {"WeekFields": [[18, 27], [49, 58]], "WeekFields.ISO": [[49, 62]]}}}, {"text": "Now you can create a ChronoField for week of month with WeekFields.ISO.weekOfMonth();", "label": {"api": {"WeekFields": [[56, 65]], "WeekFields.ISO": [[56, 69]]}}}, {"text": "ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH is the n-th day in a week which doesn't start with a fixed DAY_OF_WEEK like Monday but with the first day of the month", "label": {"api": {"ALIGNED_DAY_OF_WEEK_IN_MONTH": [[12, 39]], "ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH": [[0, 39]]}}}, {"text": "You can force a flush by calling flush() or just closing it", "label": {"api": {"flush()": [[33, 39]]}}}, {"text": "Reentrant Lock ( https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html ) has a feature to state the strength of locking by a particular Thread which is based on the value of 'hold count'", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html": [[17, 103]]}}}, {"text": "The API documentation for that method explains it", "label": {"api": {"API documentation for that method": [[4, 36]]}}}, {"text": "You need to escape the \\ characters and Desktop.open(File) is how I would use the operating system to open a given file with its' default application for that file type", "label": {"api": {"Desktop.open(File)": [[40, 57]]}}}, {"text": "You can do it with Collectors.toMap", "label": {"api": {"Collectors.toMap": [[19, 34]]}}}, {"text": "If you also need to preserve encounter order of elements, you can use the overloaded version of Collectors.toMap that accepts a Supplier for the returned map", "label": {"api": {"Collectors.toMap": [[96, 111]]}}}, {"text": "This approach uses the Map.merge method", "label": {"api": {"Map.merge": [[23, 31]]}}}, {"text": "From the documentation of ConcurrentHashMap#computeIfAbsent", "label": {"api": {"ConcurrentHashMap#computeIfAbsent": [[26, 58]]}}}, {"text": "You could either use a JavaFX Service (https://docs.oracle.com/javase/8/javafx/api/javafx/concurrent/Service.html) or create a Task (https://docs.oracle.com/javase/8/javafx/api/javafx/concurrent/Task.html) that you submit manually with a new Thread or using an Executor, for example from Executors.newCachedThreadPool()", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/concurrent/Service.html": [[39, 112]], "https://docs.oracle.com/javase/8/javafx/api/javafx/concurrent/Task.html": [[133, 203]]}}}, {"text": "Reading the JDK documentation I found the PipeInputStream and the PipeOutputStream which seemed a good alternative, e.g", "label": {"api": {"PipeInputStream": [[42, 56]], "PipeOutputStream": [[66, 81]]}}}, {"text": "(which is what my interpretation of your description is) Then you will only see the one item in your HashMap because you only added one item when you only call AddNodeDetails once", "label": {"api": {"Map": [[105, 107]]}}}, {"text": "For printing the Map, I hope you are using Java 8 by now :) If so, you can print a Map using forEach + lambda expression", "label": {"api": {"Map": [[17, 19], [83, 85]]}}}, {"text": "Currently looking at the direct solutions, SynchronousQueue  seems to be the most simplified approach", "label": {"api": {"SynchronousQueue": [[43, 58]]}}}, {"text": "I was wondering if it is possible to add Buttons to a Canvas", "label": {"api": {"Buttons": [[41, 47]], "Canvas": [[54, 59]]}}}, {"text": "I am using a StackPane as the parent and I put the Canvas inside of it", "label": {"api": {"Canvas": [[51, 56]], "StackPane": [[13, 21]]}}}, {"text": "Note also I used the isEmpty() method, which is marginally cleaner, imho", "label": {"api": {"isEmpty()": [[21, 29]]}}}, {"text": "It states in the Javadoc for Object.hashCode", "label": {"api": {"Javadoc for Object.hashCode": [[17, 43]]}}}, {"text": "We can see that the Collectors class contains factory methods for many common aggregation operations", "label": {"api": {"Collectors": [[20, 29]]}}}, {"text": "take for example IntStream, this has a sum(),    average() , max() and min() respectively", "label": {"api": {"IntStream": [[17, 25]]}}}, {"text": "Same goes for DoubleStream and LongStream", "label": {"api": {"DoubleStream": [[14, 25]], "LongStream": [[31, 40]]}}}, {"text": "Every now and then I see people using the methods which belong to the Collectors class and specialized stream methods interchangeably", "label": {"api": {"Collectors": [[70, 79]]}}}, {"text": "or use the factory methods in the Collectors class", "label": {"api": {"Collectors": [[34, 43]]}}}, {"text": "For example, there are groupingBy collectors that accept a downstream collector, collectingAndThen, partitioningBy, flatMapping (java-9) et al", "label": {"api": {"groupingBy": [[23, 32]], "collectingAndThen": [[81, 97]], "partitioningBy": [[100, 113]], "flatMapping": [[116, 126]]}}}, {"text": "To return an unmodifiable view of your List throung Collections.unmodifiableList(...)", "label": {"api": {"Collections.unmodifiableList(...)": [[52, 84]]}}}, {"text": "What you can do is use WeakReferences, in order to allow garbage-collection of objects, if only WeakReferences to this object exist", "label": {"api": {"WeakReferences": [[23, 36], [96, 109]]}}}, {"text": "You can use Math#abs(standing for absolute value) which converts any negative number into a positive number", "label": {"api": {"Math#abs": [[12, 19]]}}}, {"text": "This can be done using Math.abs(int).Check the link", "label": {"api": {"link": [[47, 50]]}}}, {"text": "constructs a Scanner with the literal text \"wins.txt\", not the contents of the file \"wins.txt\"", "label": {"api": {"with the literal text \"wins.txt\"": [[21, 52]]}}}, {"text": "To read a file with a Scanner, the easiest way for you is probably to construct it using a File object..", "label": {"api": {"construct it using a File object": [[70, 101]]}}}, {"text": "Separate the input into an array using String#split(regex)", "label": {"api": {"String#split(regex)": [[39, 57]]}}}, {"text": "Check the color input using String#equalsIgnoreCase(String)", "label": {"api": {"String#equalsIgnoreCase(String)": [[28, 58]]}}}, {"text": "Parse the number input using Integer#parseInt(String)", "label": {"api": {"Integer#parseInt(String)": [[29, 52]]}}}, {"text": "The ConcurrentModificationException is thrown when calling String value = it.next();", "label": {"api": {"ConcurrentModificationException": [[4, 34]]}}}, {"text": "You can however fix this, but you'll need a ListIterator<String> to do so", "label": {"api": {"ListIterator<String>": [[44, 63]]}}}, {"text": "I have an instance of object that implements Iterator interface", "label": {"api": {"Iterator": [[45, 52]]}}}, {"text": "How to convert it to an Iterator that would return a List of objects with a predefined size (a batch) each time next() is called", "label": {"api": {"Iterator": [[24, 31]]}}}, {"text": "Don't reinvent the wheel, use the built-in https://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html": [[43, 108]]}}}, {"text": "There exist a placeholder class to \"represent\" a Void", "label": {"api": {"Void": [[49, 52]]}}}, {"text": "However, SpringLayout is", "label": {"api": {"SpringLayout": [[9, 20]]}}}, {"text": "SpringLayout is cumbersome to use, so it’s not usually a good choice, but there are some things it can do that other layouts can’t", "label": {"api": {"SpringLayout": [[0, 11]]}}}, {"text": "If by inaccessible you're referring to \"not readable\", then I reckon you can use Files#isReadable; from its documentation", "label": {"api": {"Files#isReadable": [[81, 96]]}}}, {"text": "The Application.launch(...) method creates an instance of the application class, and (after some other work) calls start() on it", "label": {"api": {"Application.launch(...)": [[4, 26]]}}}, {"text": "In your code, you first create an instance of your application class Circles, call drawCircles() on it, and then you call Application.launch(...)", "label": {"api": {"Application.launch(...)": [[122, 144]]}}}, {"text": "You can utilize the positional queries if necessary, this is using the number on which position on which the element could be find for example", "label": {"api": {"positional queries": [[20, 37]]}}}, {"text": "You explicitly tell Stream.of(T t) that you want a Stream<String[]>, i.e", "label": {"api": {"Stream.of(T t)": [[20, 33]]}}}, {"text": "You can use StringBuilder's insert to insert characters at a certain index", "label": {"api": {"insert": [[28, 33], [38, 43]]}}}, {"text": "This won't work since Task is not reusable as stated in the documentation", "label": {"api": {"as stated in the documentation": [[43, 72]]}}}, {"text": "When I referred to the java class hierarchy, I found that the Vector class is the parent of the Stack class", "label": {"api": {"hierarchy": [[34, 42]]}}}, {"text": "More specifically, is there any reason not to use the Property<T> classes from the javafx package", "label": {"api": {"Property<T>": [[54, 64]]}}}, {"text": "The application in question is not very computation intensive, so I can deal with the overhead of the Property<T> classes", "label": {"api": {"Property<T>": [[102, 112]]}}}, {"text": "bind()ing values to one another provides a great deal of flexibility and would help with the control flow in my application, but it doesn't feel right to use a UI package in my business logic layer", "label": {"api": {"bind()": [[0, 5]]}}}, {"text": "Why are the Property<T> classes in the javafx.beans package in the first place and not in java.util", "label": {"api": {"Property<T>": [[12, 22]]}}}, {"text": "If you want this not to be the case then you could consider using an IdentityHashMap which uses the object reference to compare for equality", "label": {"api": {"IdentityHashMap": [[69, 83]]}}}, {"text": "Conversely, if this behaviour is what you want for some reason, you can use IdentityHashMap, which will always use an object's memory address to determine if it's equality to another, regardless of its type", "label": {"api": {"IdentityHashMap": [[76, 90]]}}}, {"text": "Be careful with using IdentityHashMap with String keys though - because of string interning, 2 equivalent strings constructed (from literals) in different places in the code will in fact point to the same piece of memory, so will be reference identical", "label": {"api": {"IdentityHashMap": [[22, 36]], "string interning": [[75, 90]]}}}, {"text": "Checking connectivity using TCP Sampler is not the best idea, I would recommend going for JSR223 Sampler and Socket class instead", "label": {"api": {"Socket": [[109, 114]]}}}, {"text": "The API documentation of InputStream::mark(int readlimit) and InputStream::reset() is clear about subsequent read calls - the InputStream can be reset as long as mark is supported and no more then readlimit bytes have been read", "label": {"api": {"InputStream::mark(int readlimit)": [[25, 56]], "InputStream::reset()": [[62, 81]]}}}, {"text": "You need to use MultivaluedMap, not a HashMap for the params", "label": {"api": {"MultivaluedMap": [[16, 29]]}}}, {"text": "java.io.NotSerializableException is thrown when your object is not serializable that means your object or any non-transient property of that object does not implement the Serializable interface", "label": {"api": {"Serializable": [[11, 22], [171, 182]], "NotSerializableException": [[8, 31]]}}}, {"text": "And in your case, DataPackage is not Serializable", "label": {"api": {"Serializable": [[37, 48]]}}}, {"text": "Serializable is a marker interface  which basically tells JVM that any instance of the Serializable type can be serialized", "label": {"api": {"Serializable": [[0, 11], [87, 98]]}}}, {"text": "Here you can go through the docs of Serializable and NotSerializableException", "label": {"api": {"Serializable": [[36, 47], [56, 67]], "NotSerializableException": [[53, 76]]}}}, {"text": "Your class should implement the Serializable interface", "label": {"api": {"Serializable": [[32, 43]]}}}, {"text": "So I would consider making this class generic to force object to implement Serializable interface", "label": {"api": {"Serializable": [[75, 86]]}}}, {"text": "for example if you try to serialize a DataPackage that contains a ByteBuffer(which is not Serializable) like this", "label": {"api": {"Serializable": [[90, 101]]}}}, {"text": "If you dont want to use generics than make object of type Serializable like this", "label": {"api": {"Serializable": [[58, 69]]}}}, {"text": "I see that  EnumSet.of() returns an instance of an object of the type EnumSet", "label": {"api": {"EnumSet": [[12, 18], [70, 76]]}}}, {"text": "How can you get an instance of the abstract type EnumSet, when you have not subclassed it", "label": {"api": {"EnumSet": [[49, 55]]}}}, {"text": "Convert Graphics2D instance to a RenderedImage interface", "label": {"api": {"RenderedImage": [[33, 45]]}}}, {"text": "Write the graphics object to a known image format via ImageIO", "label": {"api": {"ImageIO": [[54, 60]]}}}, {"text": "Note that it is possible to combine the steps of writing via ImageIO and exporting to the response output stream", "label": {"api": {"ImageIO": [[61, 67]]}}}, {"text": "When overriding equals(), make sure you understand the equals() hashCode() contract", "label": {"api": {"the equals() hashCode() contract": [[51, 82]]}}}, {"text": "If the behavior does not satisfy your needs, you can implement javax.servlet.Filter and declare a bean for your implementation", "label": {"api": {"javax.servlet.Filter": [[63, 82]]}}}, {"text": "You can use Comparator methods introduced in Java 8 and use a method reference e.g.", "label": {"api": {"Comparator": [[12, 21]]}}}, {"text": "I would suggest that you use the ExecutorService class", "label": {"api": {"ExecutorService class": [[33, 53]]}}}, {"text": "I encountered the following behavior while using a ByteBuffer", "label": {"api": {"ByteBuffer": [[51, 60]]}}}, {"text": "The UTF-16 encoding is specifically documented to produce a Byte Order Mark", "label": {"api": {"specifically documented": [[23, 45]]}}}, {"text": "Depending on the purpose why do you need to pass the constructor you may consider passing the instance of Supplier instead (JavaDoc - https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html": [[134, 207]]}}}, {"text": "That being said, NewStringUTF() requires an input string in modified UTF-8 format", "label": {"api": {"modified UTF-8": [[60, 73]]}}}, {"text": "However, GetUserNameA() outputs ANSI format (hence the A in its name), not in UTF-8, let alone modified UTF-8", "label": {"api": {"modified UTF-8": [[95, 108]]}}}, {"text": "Windows has no concept of modified UTF-8 at all", "label": {"api": {"modified UTF-8": [[26, 39]]}}}, {"text": "The Java.type function is a Nashorn extension, which means it is only available when the script is ran on Nashorn", "label": {"api": {"Nashorn": [[28, 34], [106, 112]]}}}, {"text": "This section describes how to access Java from a script interpreted by the Nashorn engine", "label": {"api": {"Nashorn": [[75, 81]]}}}, {"text": "Nashorn is the Oracle JDK implementation of a javascript engine", "label": {"api": {"Nashorn": [[0, 6]]}}}, {"text": "But Java and javascript are separate languages, so there is no reason other javascript engines would have to provide the same Java interop capabilities (not every JS runtime is strapped to a JVM, like Nashorn is)", "label": {"api": {"Nashorn": [[201, 207]]}}}, {"text": "When capturing elapsed time as a Duration, I only care about whole seconds resolution", "label": {"api": {"Duration": [[33, 40]]}}}, {"text": "How do I drop the fractional second from a Duration object", "label": {"api": {"Duration": [[43, 50]]}}}, {"text": "But I do not see one on Duration", "label": {"api": {"Duration": [[24, 31]]}}}, {"text": "To parse AM/PM hours, you need to use \"hh\" (clock hour of am/pm, values from 1 to 12 - check the javadoc)", "label": {"api": {"check the javadoc": [[87, 103]]}}}, {"text": "The JAX-RS documentation ( https://docs.oracle.com/javaee/7/api/javax/ws/rs/container/ContainerRequestFilter.html ) seems to imply that the filter should be working on sub-resources", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/ws/rs/container/ContainerRequestFilter.html": [[27, 112]]}}}, {"text": "See Files for a non-exhaustive list of file-related operations, including the Files.lines() method to get a Stream<String> of all lines in a (text) file", "label": {"api": {"Files": [[4, 8], [78, 82]], "Files.lines()": [[78, 90]]}}}, {"text": "You are using wait() wrongly", "label": {"api": {"wait()": [[14, 19]]}}}, {"text": "The BigInteger constructor you're using takes a maximum bit length", "label": {"api": {"BigInteger constructor you're using": [[4, 38]]}}}, {"text": "Using File you can get a list of all files in a directory", "label": {"api": {"File": [[6, 9]]}}}, {"text": "Now, I am assuming that your V=int or Integer You can use a Stream in the nifty Java 8 to sum each set in the list, then store each sum in a List", "label": {"api": {"Stream": [[60, 65]]}}}, {"text": "3) If so, use Robot's createScreenCapture() to get a BufferedImage of the whole screen", "label": {"api": {"Robot": [[14, 18]]}}}, {"text": "But if you want to get rid of the final if you could use Optional for the last part", "label": {"api": {"Optional": [[57, 64]]}}}, {"text": "You can use String.format()", "label": {"api": {"String.format()": [[12, 26]]}}}, {"text": "You can use a TextFormatter that filters out any changes to the text that do not result in something beginning with a $ sign", "label": {"api": {"TextFormatter": [[14, 26]]}}}, {"text": "Have a look at the docs of Files#find", "label": {"api": {"Files#find": [[27, 36]]}}}, {"text": "Consider using a ThreadLocal<SimpleDateFormat>", "label": {"api": {"ThreadLocal<SimpleDateFormat>": [[17, 45]]}}}, {"text": "As the Instream-javadocs state IntStream.generate seems to Return[..] an infinite sequential unordered stream, whatever that means", "label": {"api": {"Instream-javadocs": [[7, 23]]}}}, {"text": "Button does not contain a onClick property", "label": {"api": {"Button": [[0, 5]]}}}, {"text": "If the code followed the Java conventions, there should be the annotation @Override on top of the Two.display() method to explicit this behavior to other developers and to the Compiler who's check if the method already exists in the parent object", "label": {"api": {"@Override": [[74, 82]]}}}, {"text": "You can't do it with your current approach, instead you can use the toMap collector", "label": {"api": {"toMap": [[68, 72]]}}}, {"text": "This uses Stream.concat to merge collection1 and collection2 together into a single Stream<A>", "label": {"api": {"Stream.concat": [[10, 22]]}}}, {"text": "We then call the toMap collector where the first Function.identity() selects the elements of the source as the keys i.e A and the second Function.identity() also selects the elements of the source as the values; again A, so at this point, you can visualise the data as Map<A, A>", "label": {"api": {"toMap": [[17, 21]], "Function.identity()": [[49, 67], [137, 155]]}}}, {"text": "once we've collected the elements to a Map<A, A>, we then call the values() method to retrieve a Collection<A>, this then enables us to create a stream from it with the stream() method and further enables us to sort the streams elements with the sorted method and finally collect it to a List<A> with the toList collector", "label": {"api": {"toList": [[305, 310]]}}}, {"text": "The answer given by James_D works perfectly for this using FutureTask", "label": {"api": {"FutureTask": [[59, 68]]}}}, {"text": "CompletableFuture (added in Java 8)", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "Both FutureTask and CompletableFuture will work for you", "label": {"api": {"FutureTask": [[5, 14]], "CompletableFuture": [[20, 36]]}}}, {"text": "I prefer CompletableFuture because it it provides more options (if needed) and the join() method doesn't throw checked exceptions like get() does", "label": {"api": {"CompletableFuture": [[9, 25]]}}}, {"text": "However, CompletableFuture is a Future (just like FutureTask) and so you can still use get() with a CompletableFuture", "label": {"api": {"FutureTask": [[50, 59]], "CompletableFuture": [[9, 25], [100, 116]]}}}, {"text": "Each class loaded by a ClassLoader has a ProtectionDomain+CodeSource associated with it", "label": {"api": {"ProtectionDomain": [[41, 56]], "CodeSource": [[58, 67]]}}}, {"text": "These are somewhat coarse -- a CodeSource represents where a class came from, but it's not a pointer to an individual .class file or anything -- it's to a directory or a JAR", "label": {"api": {"CodeSource": [[31, 40]]}}}, {"text": "Any class or script that has an identifiable ProtectionDomain+CodeSource can be whitelisted/blacklisted by your Policy", "label": {"api": {"ProtectionDomain": [[45, 60]], "CodeSource": [[62, 71]]}}}, {"text": "The exception (kinda) to this is, of course, is AccessController.doPrivileged with Permission arguments", "label": {"api": {"AccessController.doPrivileged": [[48, 76]]}}}, {"text": "But that code could, in theory, call AccessController.doPrivileged with just the callback", "label": {"api": {"AccessController.doPrivileged": [[37, 65]]}}}, {"text": "That method signature means \"don't check my entire call stack for permissions; just look up my ProtectionDomain+CodeSource in the Policy file and see what it says.\" So if you're running truly untrusted code, you better make sure that a", "label": {"api": {"ProtectionDomain": [[95, 110]], "CodeSource": [[112, 121]]}}}, {"text": "it has a ProtectionDomain+CodeSource different from your trusted application, and b", "label": {"api": {"ProtectionDomain": [[9, 24]], "CodeSource": [[26, 35]]}}}, {"text": "data from your user’s environment, static calls in the System class can provide this", "label": {"api": {"System": [[55, 60]]}}}, {"text": "You shouldn't use Optional<T> to solely replace the if statement as it's no better and doesn't gain you any benefit", "label": {"api": {"Optional<T>": [[18, 28]]}}}, {"text": "Assuming you've made this change, you can then leverage the Optional<T> type", "label": {"api": {"Optional<T>": [[60, 70]]}}}, {"text": "see the Optional<T> class to familiarise your self with the API and the methods that are available", "label": {"api": {"Optional<T>": [[8, 18]]}}}, {"text": "It's because CompletableFuture.supplyAsync(Supplier) uses the common ForkJoinPool in which tasks are automatically terminated once the program (the main thread) terminates", "label": {"api": {"CompletableFuture.supplyAsync(Supplier)": [[13, 51]], "common ForkJoinPool": [[62, 80]]}}}, {"text": "Its documentation seems to be pretty clear", "label": {"api": {"Its documentation": [[0, 16]]}}}, {"text": "You will probably want to look into String's toCharArray() (String's Java Doc) as well as how a char is used with ASCII values", "label": {"api": {"String's Java Doc": [[60, 76]]}}}, {"text": "If you really want this data to be packed into a jar file, then you could also unpack it at runtime with java.util.jar API", "label": {"api": {"java.util.jar API": [[105, 121]]}}}, {"text": "You can use Character.toUpperCase() method for this", "label": {"api": {"Character.toUpperCase()": [[12, 34]]}}}, {"text": "You need #buildFromEncoded if you want to feed in pre-encoded strings", "label": {"api": {"#buildFromEncoded": [[9, 25]]}}}, {"text": "The logarithmic complexity is reffered to the the Java TreeSet", "label": {"api": {"Java TreeSet": [[50, 61]]}}}, {"text": "This, the way you handle it, can give you a NumberFormatException", "label": {"api": {"NumberFormatException": [[44, 64]]}}}, {"text": "A ExcelTableModel similar to the javax.swing.table.DefaultTableModel", "label": {"api": {"javax.swing.table.DefaultTableModel": [[33, 67]]}}}, {"text": "However, do look into StringBuilder on how to use it to avoid creating a lot of memory in the Heap", "label": {"api": {"StringBuilder": [[22, 34]]}}}, {"text": "It is present here because it is method from AbstractButton but its value is always set to false", "label": {"api": {"AbstractButton": [[45, 58]]}}}, {"text": "To solve problem in your case, use ActionEvent.getActionCommand() intead", "label": {"api": {"ActionEvent.getActionCommand()": [[35, 64]]}}}, {"text": "You can do this with String.endsWith", "label": {"api": {"String.endsWith": [[21, 35]]}}}, {"text": "Or with Matcher.find", "label": {"api": {"Matcher.find": [[8, 19]]}}}, {"text": "If you want your regex to match the entire string from start to end, you can use the Pattern.DOTALL flag to change the behavior of the dot expression (.) to match any character including newlines", "label": {"api": {"Pattern.DOTALL": [[85, 98]]}}}, {"text": "DOTALL can be specified with an embedded flag (?s) or as an option to Pattern.compile", "label": {"api": {"Pattern.compile": [[70, 84]]}}}, {"text": "When you create a ThreadPoolExecutor by Executors.newFixedThreadPool, it will create a default ThreadFactory and this default ThreadFactory creates Thread with name like pool-x-thread-y", "label": {"api": {"ThreadFactory": [[95, 107], [126, 138]]}}}, {"text": "You can custom a ThreadFactory and use it construct the thread pool", "label": {"api": {"ThreadFactory": [[17, 29]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html provides information how to use Spliterator, when the size() is known/allowed", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html": [[0, 67]]}}}, {"text": "Your comparator is invalid as it returns a boolean whereas the expected return type is an int", "label": {"api": {"comparator": [[5, 14]]}}}, {"text": "From the documentation of Deque", "label": {"api": {"Deque": [[26, 30]]}}}, {"text": "A Deque does not support random access retrieval, as it's essentially a double-ended queue", "label": {"api": {"Deque": [[2, 6]]}}}, {"text": "If all you're interested in are the elements at the head and tail, then use a Deque", "label": {"api": {"Deque": [[78, 82]]}}}, {"text": "If you refuse to use anything other than a Deque, then it's possible to poll elements (storing them in another Deque) until you reach the index you're interested in", "label": {"api": {"Deque": [[43, 47], [111, 115]]}}}, {"text": "Set the appropriate Shape on the clip property of the front Node", "label": {"api": {"clip property": [[33, 45]]}}}, {"text": "Javadoc from the clip property", "label": {"api": {"clip property": [[17, 29]]}}}, {"text": "In java 8 you can use the new java.time api", "label": {"api": {"java.time": [[30, 38]]}}}, {"text": "Because AtomicInteger provides additional methods like public final int getAndSet(int newValue) for operations that must be atomic", "label": {"api": {"public final int getAndSet(int newValue)": [[55, 94]]}}}, {"text": "What you need is a Sempahore (https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html": [[30, 106]]}}}, {"text": "The first two arguments of getTables are catalog and schemaPattern", "label": {"api": {"getTables": [[27, 35]]}}}, {"text": "If you need strict fair order for accessing critical section you should probably take a look at java.util.concurrent package which holds some primitives which has fair option, like ReentrantLock", "label": {"api": {"ReentrantLock": [[181, 193]]}}}, {"text": "There is the Math.nextUp method", "label": {"api": {"the Math.nextUp method": [[9, 30]]}}}, {"text": "The JTable API has a method to get the number of selected rows", "label": {"api": {"JTable API": [[4, 13]]}}}, {"text": "Because you have an ArrayList<String[]>, you can use Collection#removeIf to remove null (or empty) elements in the List", "label": {"api": {"Collection#removeIf": [[53, 71]]}}}, {"text": "Since JOptionPane::showInputDialog in most cases returns String (except the one that requires lots of arguments to help it return a correct object type), it's better to use the String in the subsequent flow", "label": {"api": {"JOptionPane::showInputDialog": [[6, 33]], "one": [[76, 78]]}}}, {"text": "Yes, the Process class has destroy() and destroyForcibly() methods to kill the running process", "label": {"api": {"Process": [[9, 15]], "destroy()": [[27, 35]], "destroyForcibly()": [[41, 57]]}}}, {"text": "Starting in Java 9 the ProcessHandle class was added which also has methods of the same name", "label": {"api": {"Process": [[23, 29]], "ProcessHandle": [[23, 35]]}}}, {"text": "If you have the pid but don't have the Process object, you can get a ProcessHandle for a running process given its pid using the ProcessHandle.of(long pid) method but if you started the Process yourself it is easier to just use the Process object that was returned from ProcessBuilder.start() or get the ProcessHandle from it using the Process.toHandle() method", "label": {"api": {"Process": [[39, 45], [69, 75], [129, 135], [186, 192], [232, 238], [270, 276], [304, 310], [336, 342]], "ProcessHandle": [[69, 81], [129, 141], [304, 316]], "ProcessHandle.of(long pid)": [[129, 154]], "Process.toHandle()": [[336, 353]]}}}, {"text": "It seems to be fine to use TableColumn#setResizable(false) method together", "label": {"api": {"TableColumn#setResizable(false)": [[27, 57]]}}}, {"text": "An alternative to BufferWriter is Files.write(Path, byte[], OpenOption...) if you aim at writing to a file only once", "label": {"api": {"Files.write(Path, byte[], OpenOption...)": [[34, 73]]}}}, {"text": "I'd just like to add that Java has the StringBuilder.reverse() method, which also operates on a character array in place", "label": {"api": {"StringBuilder.reverse()": [[39, 61]]}}}, {"text": "One way to get raw input is to use a java.util.Scanner", "label": {"api": {"java.util.Scanner": [[37, 53]]}}}, {"text": "I suggest to use a ThreadPoolExecutor with 2 fixed threads and a PriorityBlockingQueue to solve this problem", "label": {"api": {"ThreadPoolExecutor": [[19, 36]], "PriorityBlockingQueue": [[65, 85]]}}}, {"text": "A ThreadPoolExecutor with 2 fixed threads can make sure that at any moment, there is at most 2 task running", "label": {"api": {"ThreadPoolExecutor": [[2, 19]]}}}, {"text": "The other tasks will be put in this PriorityBlockingQueue, and the thread pool will retrieve tasks from the queue based on a custom Comparator", "label": {"api": {"PriorityBlockingQueue": [[36, 56]], "Comparator": [[132, 141]]}}}, {"text": "a context listener, which is invoked once on application startup to notify your application that the context has been initialized", "label": {"api": {"context listener": [[2, 17]]}}}, {"text": "To guard against that happening, you should check null explicitly like you did with Strings, or use the new Objects.equals method in Java 8", "label": {"api": {"Objects.equals": [[108, 121]]}}}, {"text": "You can use EnumSet for doing the work", "label": {"api": {"EnumSet": [[12, 18]]}}}, {"text": "You can also use a NavigableMap", "label": {"api": {"NavigableMap": [[19, 30]]}}}, {"text": "A BlockingQueue can solve this problem", "label": {"api": {"BlockingQueue": [[2, 14]]}}}, {"text": "You can use String.replace", "label": {"api": {"String.replace": [[12, 25]]}}}, {"text": "Use the Introspector / BeanInfo API", "label": {"api": {"Introspector": [[8, 19]]}}}, {"text": "Standard java has implementation named CompletableFuture", "label": {"api": {"CompletableFuture": [[39, 55]]}}}, {"text": "You may have to bump through a char[] array populated from the String, and for each element, do the following from the Character class", "label": {"api": {"String": [[63, 68]]}}}, {"text": "invoke codePointAt(char[] a, int index) call, and then use the returned int to call isAlphabetic(int codePoint), and then maybe isDigit(int codePoint) and then if either of those are true, compare against the other database, and if both are false, you are probably dealing with a punctuation mark or symbol that are different in the two character sets, and can probably be ignored", "label": {"api": {"codePointAt(char[] a, int index)": [[7, 38]], "isAlphabetic(int codePoint)": [[84, 110]], "isDigit(int codePoint)": [[128, 149]]}}}, {"text": "To make your comparison more robust, you will also probably want to check isWhitespace(int codePoint) as a common issue I see is when people cut and paste from say a Microsoft Word document or a web page that includes a non-breaking space (U+00A0) and the database contains a regular space (U+0020)", "label": {"api": {"isWhitespace(int codePoint)": [[74, 100]]}}}, {"text": "By the way, you can use the Comparator.comparing(...) instead of anonymous class, for example", "label": {"api": {"Comparator.comparing(...)": [[28, 52]]}}}, {"text": "Java 8 has introduced the Visitor-based Files.walkFileTree() api which is a lot easier to master", "label": {"api": {"Files.walkFileTree()": [[40, 59]]}}}, {"text": "You should also prefer java.time classes to the ones you're currently using if you're on Java 8 or above", "label": {"api": {"java.time": [[23, 31]]}}}, {"text": "I wanted to mention the java 9's Matcher.replaceAll lambda extension", "label": {"api": {"Matcher.replaceAll": [[33, 50]]}}}, {"text": "I want to crop a centered 400x400 pixel square out of the center of it using BufferedImage#getSubimage(...)", "label": {"api": {"BufferedImage#getSubimage(...)": [[77, 106]]}}}, {"text": "OutOfMemoryError is thrown when your JVM runs out of heap memory", "label": {"api": {"OutOfMemoryError": [[0, 15]]}}}, {"text": "To get the text of the capture group, you need to use the Pattern and Matcher classes", "label": {"api": {"Pattern": [[58, 64]], "Matcher": [[70, 76]]}}}, {"text": "You can use java.math.BigInteger", "label": {"api": {"java.math.BigInteger": [[12, 31]]}}}, {"text": "A method like Arrays.binarySearch() that returns the index of a value within an array", "label": {"api": {"Arrays.binarySearch()": [[14, 34]]}}}, {"text": "More modern APIs tend to return an Optional<> to provide compile-time enforcement of the concept that there may not be a result (as well as differentiating between \"no result\" and \"the result is null)", "label": {"api": {"Optional<>": [[35, 44]]}}}, {"text": "My guess is that you running them with preparedStatement.executeQuery() (which is for SELECT queries and expects to return a ResultSet) rather than preparedStatement.execute() which can be used on any type of query", "label": {"api": {"preparedStatement.execute()": [[148, 174]]}}}, {"text": "Although the String.split(String regex) function specifies that it takes a regular expression as a parameter, that does not stop you from escaping any special characters and splitting on a literal string", "label": {"api": {"String.split(String regex)": [[13, 38]]}}}, {"text": "To escape special characters in a regular expression, you can make use of the Pattern.quote(String s) function, or you can escape the individual characters using backslashes \\\\", "label": {"api": {"Pattern.quote(String s)": [[78, 100]]}}}, {"text": "Using ListIterator<T> for this issue is pretty weird, however here is the solution which iterates the list twice", "label": {"api": {"ListIterator<T>": [[6, 20]]}}}, {"text": "Here we go without using the Collections class", "label": {"api": {"Collections": [[29, 39]]}}}, {"text": "The method ListIterator<E> listIterator(int index) provides a ListIterator starting on the index", "label": {"api": {"ListIterator<E> listIterator(int index)": [[11, 49]]}}}, {"text": "You can use a fair ReentrantLock", "label": {"api": {"ReentrantLock": [[19, 31]]}}}, {"text": "When you call signal(), the longest waiting thread will be signalled first", "label": {"api": {"signal()": [[14, 21]]}}}, {"text": "Use the overloaded List.toArray() method that specifies the return type of the array", "label": {"api": {"List.toArray()": [[19, 32]]}}}, {"text": "You can simply pass your list and a Predicate<T> representing the criteria to the method", "label": {"api": {"Predicate<T>": [[36, 47]]}}}, {"text": "Simply use DateFormat#parse", "label": {"api": {"DateFormat#parse": [[11, 26]]}}}, {"text": "To reach 10^18th term, you need to use BigInteger class of Java", "label": {"api": {"BigInteger": [[39, 48]]}}}, {"text": "This is even specified (as part of the contract, as an implementation specification) in the documentation of the AbstractMap class (which most Map implementations are based on)", "label": {"api": {"documentation of the AbstractMap class": [[92, 129]]}}}, {"text": "As stated in the documentation of the Map interface", "label": {"api": {"documentation of the Map interface": [[17, 50]]}}}, {"text": "and specifically, the documentation of the Map#values() method", "label": {"api": {"documentation of the Map#values() method": [[22, 61]]}}}, {"text": "You can create a dynamic proxy", "label": {"api": {"dynamic proxy": [[17, 29]]}}}, {"text": "You need a DateTimeFormatter to format the date like this", "label": {"api": {"DateTimeFormatter": [[11, 27]]}}}, {"text": "Then you need two LocalDateTimes", "label": {"api": {"LocalDateTime": [[18, 30]]}}}, {"text": "Now you can create a loop that prints out the start date and then changes it (It's immutable, but you can recycle the variable.) via the date's method .plusSeconds() to get to the next second (Or do you indeed want millisecond resolution?), print out, rinse and repeat, until the two dates are equal", "label": {"api": {".plusSeconds()": [[151, 164]]}}}, {"text": "Use the java.nio.file package instead", "label": {"api": {"java.nio.file package": [[8, 28]]}}}, {"text": "The correct way to redirect a ProcessBuilder’s output is with its redirectOutput method", "label": {"api": {"redirectOutput": [[66, 79]]}}}, {"text": "Check the Boolean javadoc for reference", "label": {"api": {"Boolean javadoc": [[10, 24]]}}}, {"text": "Also, take a look to the constructor javadoc", "label": {"api": {"constructor javadoc": [[25, 43]]}}}, {"text": "This overload of the comparing method will throw an exception if the passed in key extractor function is null or the property extracted is null", "label": {"api": {"comparing": [[21, 29]]}}}, {"text": "Just look in the Arrays class, almost every method there has overloads for all kinds of arrays", "label": {"api": {"Arrays": [[17, 22]]}}}, {"text": "By the way, do you know there is a handy method called Arrays.toString", "label": {"api": {"Arrays": [[55, 60]]}}}, {"text": "You can use Array.get() to index an array without knowing its type", "label": {"api": {"Array.get()": [[12, 22]]}}}, {"text": "InputMismatchException was thrown when calling Scanner.nextInt, you shoud catch it immediatly", "label": {"api": {"Scanner.nextInt": [[47, 61]]}}}, {"text": "You propably want  to create your owncomputeIfAbsent instead getOrDefault", "label": {"api": {"computeIfAbsent": [[37, 51]], "getOrDefault": [[61, 72]]}}}, {"text": "Files class is your friend dear", "label": {"api": {"Files": [[0, 4]]}}}, {"text": "It uses the POSIX printable character class", "label": {"api": {"POSIX printable character class": [[12, 42]]}}}, {"text": "If you need Unicode support, create the String with the utf-8 character set argument, and construct a Pattern with the UNICODE_CHARACTER_CLASS flag and use the same regex as above", "label": {"api": {"UNICODE_CHARACTER_CLASS": [[119, 141]]}}}, {"text": "You can use Future.get with a timeout", "label": {"api": {"Future.get": [[12, 21]]}}}, {"text": "See the documentation for ExecutorService#shutdown", "label": {"api": {"documentation for ExecutorService#shutdown": [[8, 49]]}}}, {"text": "Map.replaceAll() should work", "label": {"api": {"Map.replaceAll()": [[0, 15]]}}}, {"text": "You can record a value related to the button in userData when the button is created and access that saved value whenever you have a reference to the button", "label": {"api": {"userData": [[48, 55]]}}}, {"text": "If you need to associate multiple pieces of data with a given node, then you can use the node.getProperties() API, but, for your question, usage of the node userData property is probably all you need", "label": {"api": {"userData": [[157, 164]], "node.getProperties()": [[89, 108]]}}}, {"text": "That way you can use the Button.setOnAction() method", "label": {"api": {"Button.setOnAction()": [[25, 44]]}}}, {"text": "You can use a timer to schedule tasks, but for schedules that are set several days in the future, you first need to answer if your application will be running that long", "label": {"api": {"timer": [[14, 18]]}}}, {"text": "List<E>.addAll() which takes a Collection<", "label": {"api": {"List<E>.addAll()": [[0, 15]]}}}, {"text": "This can be done either by XML declaration in /WebContent/WEB-INF/web.xml or by @WebServlet annotation", "label": {"api": {"@WebServlet": [[80, 90]]}}}, {"text": "I see that you already use @WebServlet so you have to add urlPatterns element", "label": {"api": {"@WebServlet": [[27, 37]], "urlPatterns": [[58, 68]]}}}, {"text": "If Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID) returns a different string then the salt parameter of the PBEParameterSpec constructor will be different", "label": {"api": {"PBEParameterSpec": [[145, 160]]}}}, {"text": "This is not dependent on Stream.collect, but on the individual Collector", "label": {"api": {"Collector": [[63, 71]]}}}, {"text": "Collectors.toList() will return an empty ArrayList", "label": {"api": {"Collector": [[0, 8]]}}}, {"text": "That said, there's no reason someone couldn't use a weird Collector to return null in certain circumstances", "label": {"api": {"Collector": [[58, 66]]}}}, {"text": "So the Collector is the thing you need to remember to check", "label": {"api": {"Collector": [[7, 15]]}}}, {"text": "I believe all of the Collectors available out-of-the-box will return empty collections, as you'd expect", "label": {"api": {"Collector": [[21, 29]], "Collectors available out-of-the-box": [[21, 55]]}}}, {"text": "See the doc of SimpleDateFormat and try this", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "Let WritableImage do this for you", "label": {"api": {"WritableImage": [[4, 16]]}}}, {"text": "ImageView has a viewport property that allows you to choose the part of the image to display and GraphicsContext provides an overloaded version of the drawImage method to draw a part of the image to the Canvas", "label": {"api": {"viewport property": [[16, 32]]}}}, {"text": "You can use a Condition and a share flag", "label": {"api": {"Condition": [[14, 22]]}}}, {"text": "The general strategy is to have more jobs than worker threads to enable work-stealing, see for example ForkJoinTask.getSurplusQueuedTaskCount(), which can be used to implement such an adaptive strategy", "label": {"api": {"ForkJoinTask.getSurplusQueuedTaskCount()": [[103, 142]]}}}, {"text": "If you have the possibility to change the Map implementation of unordered, use something thread safe like a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[108, 124]]}}}, {"text": "That's exactly what ConcurrentModificationException prevented", "label": {"api": {"ConcurrentModificationException": [[20, 50]]}}}, {"text": "And if some another thread calls notify() and woke up the the thread T1, T1 will again gain access to lock on msg object", "label": {"api": {"notify()": [[33, 40]]}}}, {"text": "On notify() ( from javadocs)", "label": {"api": {"notify()": [[3, 10]]}}}, {"text": "Another way to achieve it is to use Java's ConcurrentMap in order to guarantee thread-safety", "label": {"api": {"ConcurrentMap": [[43, 55]]}}}, {"text": "Starting from Java 8, you could also take advantage from computeIfAbsent, which will only calculate the UUID if the key is absent", "label": {"api": {"computeIfAbsent": [[57, 71]]}}}, {"text": "There is, however, a far more elegant solution than the code you currently have, relying on SimpleDateFormat's week year (Y instead of y) pattern", "label": {"api": {"SimpleDateFormat": [[92, 107]]}}}, {"text": "either change your code to read the output from tar -- see Process.getInputStream() -- or change the command (by removing v) so it doesn't produce (non-error) output", "label": {"api": {"Process.getInputStream()": [[59, 82]]}}}, {"text": "As noted in the javadoc, ProcessBuilder is preferred since Java 5", "label": {"api": {"ProcessBuilder": [[25, 38]]}}}, {"text": "You can call floatValue() to get a float representation of your Long (or any Number for that matter)", "label": {"api": {"floatValue()": [[13, 24]]}}}, {"text": "Look the documentation, the only thing that can impact time of put and get is the hashCode implementation", "label": {"api": {"Look the documentation": [[0, 21]]}}}, {"text": "This will depend on your libraries but a standard javax.servlet.ServletRequest class has a Map<String, String[]> getParameterMap() method", "label": {"api": {"Map<String, String[]> getParameterMap()": [[91, 129]]}}}, {"text": "Specyfing correct input Charset should solve your problem", "label": {"api": {"Charset": [[24, 30]]}}}, {"text": "I'd say the CurrentLinkedQueue", "label": {"api": {"CurrentLinkedQueue": [[12, 29]]}}}, {"text": "If you have very very high load, you may want to consider a LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[60, 78]]}}}, {"text": "If you want to implement an Iterator that requires a resource to be closed at the end of iteration, you should encapsulate that in an object implementing Iterable and AutoCloseable", "label": {"api": {"Iterator": [[28, 35]], "Iterable": [[154, 161]], "AutoCloseable": [[167, 179]]}}}, {"text": "You can catch the exception, and then throw an unchecked RuntimeException", "label": {"api": {"RuntimeException": [[57, 72]]}}}, {"text": "In addition to implementing Iterator, you implement AutoCloseable, and document that your iterator must be closed after use", "label": {"api": {"AutoCloseable": [[52, 64]]}}}, {"text": "The solution is to specify more fully what these hidden parameters are by supplying an OAEPParameterSpec to the Cipher.init(...) method as in the following example", "label": {"api": {"OAEPParameterSpec": [[87, 103]]}}}, {"text": "The extra args to printf are only used if they are referenced by format specifiers (like %s) in your format string", "label": {"api": {"printf": [[18, 23]]}}}, {"text": "If the code were System.out.printf(\"number1 + number2 = %d\", result) you would then see the argument injected into the string in place of the %d format specifier", "label": {"api": {"printf": [[28, 33]]}}}, {"text": "Look at  InputStream's read() method without parameter", "label": {"api": {"InputStream's read()": [[9, 28]]}}}, {"text": "Reader's read() method without a parameter also returns an int", "label": {"api": {"Reader's read()": [[0, 14]]}}}, {"text": "You could use the UnaryOperator<T> but you have to define beforehand what type you're expecting", "label": {"api": {"UnaryOperator<T>": [[18, 33]]}}}, {"text": "I would suggest you use a Map instead of an Array", "label": {"api": {"Map": [[26, 28]]}}}, {"text": "HashSet also works quite well (as pointed out by Johannes Kuhn)", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "putNextEntry() - Begins writing a new ZIP file entry and positions the stream to the start of the entry data", "label": {"api": {"putNextEntry()": [[0, 13]]}}}, {"text": "write() - Writes an array of bytes to the current ZIP entry data", "label": {"api": {"write()": [[0, 6]]}}}, {"text": "closeEntry() - Closes the current ZIP entry and positions the stream for writing the next entry", "label": {"api": {"closeEntry()": [[0, 11]]}}}, {"text": "This call is optional, since calling putNextEntry() for the next entry automatically closes the current entry if still active", "label": {"api": {"putNextEntry()": [[37, 50]]}}}, {"text": "In JDK-9 there is a takeWhile and dropWhile methods where the former returns a stream consisting of the longest prefix of elements taken from a stream that match a given predicate", "label": {"api": {"takeWhile": [[20, 28]], "dropWhile": [[34, 42]]}}}, {"text": "Assuming the element to remove does not exist in the list the takeWhile will consume all the elements and the dropWhile will drop all the elements and when we merge these two streams we get back the initial elements", "label": {"api": {"takeWhile": [[62, 70]], "dropWhile": [[110, 118]]}}}, {"text": "Some languages, such as C++ has (as std::list, doubly-linked), as well as Java (as LinkedList<T>, doubly-linked)", "label": {"api": {"as well as Java": [[63, 77]]}}}, {"text": "Link to API", "label": {"api": {"API": [[8, 10]]}}}, {"text": "There is also Collection.sort(list, comparator) which allows you to provide your own comparator", "label": {"api": {"comparator": [[36, 45], [85, 94]]}}}, {"text": "Here is the API", "label": {"api": {"API": [[12, 14]]}}}, {"text": "Finally, do note that List#sort() was introduced only in Java 8", "label": {"api": {"introduced": [[38, 47]]}}}, {"text": "To make proper use of threads, you should consider creating an executor service", "label": {"api": {"executor service": [[63, 78]]}}}, {"text": "Later on, you may want to replace execute() with submit() to get a Future object", "label": {"api": {"Future": [[67, 72]]}}}, {"text": "Or even better, use a CompletableFuture", "label": {"api": {"Future": [[33, 38]], "CompletableFuture": [[22, 38]]}}}, {"text": "From the JavaDoc of java.util.Comparator", "label": {"api": {"JavaDoc of java.util.Comparator": [[9, 39]]}}}, {"text": "So let's look at the JavaDoc of java.util.Collection#remove", "label": {"api": {"JavaDoc of java.util.Collection#remove": [[21, 58]]}}}, {"text": "Here's an example of using Pattern to perform the replacements in bulk", "label": {"api": {"Pattern": [[27, 33]]}}}, {"text": "The way your map is structured and the output you want to achieve, it is better to use nested loops for better performance", "label": {"api": {"map": [[13, 15]]}}}, {"text": "However usage of forEach is discouraged, use map and collect this way", "label": {"api": {"map": [[45, 47]], "collect": [[53, 59]]}}}, {"text": "My preferred way of doing it (which may or may not be the best) would be to convert my 84 strings into a stream (with Arrays.stream() or list.stream(), depending how the strings are actually stored) and then do Collectors.joining(\",\")", "label": {"api": {"Collectors.joining(\",\")": [[211, 233]]}}}, {"text": "You could also use StringJoiner to build the String", "label": {"api": {"StringJoiner": [[19, 30]]}}}, {"text": "Collectors.joining() or String.join() (which internally uses StringJoiner anyway)", "label": {"api": {"StringJoiner": [[61, 72]]}}}, {"text": "See String#substring and String#split", "label": {"api": {"String#substring": [[4, 19]], "String#split": [[25, 36]]}}}, {"text": "In java there is a BigInteger class that can solves this task easily", "label": {"api": {"BigInteger": [[19, 28]]}}}, {"text": "Class<> is used when you want to use reflection to do something with the specific class type that you're interested in", "label": {"api": {"Class<>": [[0, 6]]}}}, {"text": "You could inject BeanManager", "label": {"api": {"BeanManager": [[17, 27]]}}}, {"text": "Then you can get the beans from the CDI container", "label": {"api": {"get the beans": [[13, 25]]}}}, {"text": "If it is not possible the best solution could be to use a Semaphore or ExecutorServices", "label": {"api": {"Semaphore": [[58, 66]], "ExecutorServices": [[71, 86]]}}}, {"text": "If for some reason you REALLY NEED to fix the source port then you could probably write a custom javax.net.SocketFactory implementation that you can hard code the source port", "label": {"api": {"javax.net.SocketFactory": [[97, 119]]}}}, {"text": "One approach is to construct a simple regular expression to match your strings", "label": {"api": {"regular expression": [[38, 55]]}}}, {"text": "If that's not the case, you can use a lambda instead, and/or use one of the other standard functional interfaces or create your own", "label": {"api": {"standard functional interfaces": [[82, 111]]}}}, {"text": "To bind a value to a particular thread, you can use a ThreadLocal variable", "label": {"api": {"ThreadLocal": [[54, 64]]}}}, {"text": "Java generics were added after initial implementations of collections; Stack is from Java 1.0 - and rather then break existing code when they added generics, it was decided to add classes that duplicate functionality (but provide a consistent API)", "label": {"api": {"Stack": [[71, 75]]}}}, {"text": "That is why you should prefer a Deque - it provides an API consistent with all of the other Java Collections", "label": {"api": {"Deque": [[32, 36]]}}}, {"text": "Does the couchbase bucket object have something similar to what an EntityManager in JPA has with its flush operation", "label": {"api": {"EntityManager": [[67, 79]]}}}, {"text": "For more info please follow the link", "label": {"api": {"link": [[32, 35]]}}}, {"text": "You can use Set collection to store the chars from the char sequence, Set allows only unique entries, so you will be golden", "label": {"api": {"Set": [[12, 14], [70, 72]]}}}, {"text": "As guys mentioned in comments and suggestions that's true, we need to preserve ordering and not all Set implementations do that", "label": {"api": {"Set": [[100, 102]]}}}, {"text": "Use .next() instead of .nextLine() as you only need a single word, not a sentence because the Scanner.nextInt method does not consume the last newline character", "label": {"api": {".next()": [[4, 10]], "Scanner.nextInt": [[94, 108]]}}}, {"text": "An alternative approach is just to sort the array first, then to get the min loop from 0 to < array.length - 1 and for the max from array.length - 1 to 1", "label": {"api": {"sort": [[35, 38]]}}}, {"text": "Because it's how ServletRequest works", "label": {"api": {"ServletRequest": [[17, 30]]}}}, {"text": "Behind the scene @RequestParam is using ServletRequest#getParameter", "label": {"api": {"ServletRequest": [[40, 53]], "ServletRequest#getParameter": [[40, 66]]}}}, {"text": "If there is a multiple value for instance same key in query and post data then it returns the first value in the array returned by getParameterValues", "label": {"api": {"getParameterValues": [[131, 148]]}}}, {"text": "Furthermore you are using multipart/form-data content type so spring handle it with DefaultMultipartHttpServletRequest where parameters found in the body are returned first", "label": {"api": {"ServletRequest": [[104, 117]]}}}, {"text": "It uses Selector.select() to read with a timeout", "label": {"api": {"Selector.select()": [[8, 24]]}}}, {"text": "You can do this with SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[21, 36]]}}}, {"text": "You can instantiate a Class object using Class.newInstance()", "label": {"api": {"Class.newInstance()": [[41, 59]]}}}, {"text": "Noting that I tried the solutions mentioned here and in the official document but with no success", "label": {"api": {"official document": [[60, 76]]}}}, {"text": "You can access to the listening port with the HTTPServletRequest object, see its getLocalPort method", "label": {"api": {"HTTPServletRequest": [[46, 63]], "getLocalPort": [[81, 92]]}}}, {"text": "Thread.getStackTrace() returns StackTraceElement[]", "label": {"api": {"Thread.getStackTrace()": [[0, 21]]}}}, {"text": "While this is not the case, remember that you can throw and catch Throwable instances, and apart from Exceptions there are Errors", "label": {"api": {"Throwable": [[66, 74]], "Errors": [[123, 128]]}}}, {"text": "So your try-catch would not have caught an Error or any Throwable other than Exception", "label": {"api": {"Throwable": [[56, 64]]}}}, {"text": "If you want the JScrollBars are always displayed, you need to create your JScrollPane using the JScrollPanel(Component, int vsbPolicy, int hsbPolicy) constructor as shown in the code below", "label": {"api": {"JScrollPanel(Component, int vsbPolicy, int hsbPolicy)": [[96, 148]]}}}, {"text": "To see the annotation that you've added, you'd need to get the method first, and then use Method#getDeclaredAnnotations()", "label": {"api": {"Method#getDeclaredAnnotations()": [[90, 120]]}}}, {"text": "can it be retrieved from the Garbage Collector GarbageCollectorMXBean", "label": {"api": {"GarbageCollectorMXBean": [[47, 68]]}}}, {"text": "You can use Robot class", "label": {"api": {"Robot": [[12, 16]]}}}, {"text": "You can do pretty much everything with Robot class as simulation", "label": {"api": {"Robot": [[39, 43]]}}}, {"text": "You can achieve that by using the Collections.reverse(List<T>) method", "label": {"api": {"Collections.reverse(List<T>)": [[34, 61]]}}}, {"text": "It would be simpler just to call String.replace instead, as that doesn't use regular expressions", "label": {"api": {"String.replace": [[33, 46]]}}}, {"text": "The constructor Formatter(String) [https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#Formatter(java.lang.String)], throws a FileNotFound exception [https://docs.oracle.com/javase/7/docs/api/java/io/FileNotFoundException.html], a checked exception [https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions], so you have to catch it or re-throw it", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#Formatter(java.lang.String)]": [[35, 129]], "https://docs.oracle.com/javase/7/docs/api/java/io/FileNotFoundException.html]": [[165, 241]]}}}, {"text": "The max value an integer can hold is roughly 2 billion (2,147,483,648)", "label": {"api": {"is roughly 2 billion (2,147,483,648)": [[34, 69]]}}}, {"text": "Then when creating the AsyncTask, pass your Activity (this) into the constructor of the Async task, but keep it as a WeakReference", "label": {"api": {"WeakReference": [[117, 129]]}}}, {"text": "You can use putIfAbsent and compute since Java 8", "label": {"api": {"putIfAbsent": [[12, 22]], "compute": [[28, 34]]}}}, {"text": "That will do the work, using only standard java classes (java.io.Console)", "label": {"api": {"java.io.Console": [[57, 71]]}}}, {"text": "The documentation of the scheduleAtFixedRate() and scheduleWithFixedDelay() methods of the Java ScheduledExecutorService, says that, for any scheduled task, \"If any execution of the task encounters an exception, subsequent executions are suppressed.\"", "label": {"api": {"ScheduledExecutorService": [[96, 119]]}}}, {"text": "Please refer to the official documentation for the details", "label": {"api": {"the official documentation": [[16, 41]]}}}, {"text": "Here's a complete example, extracting the value using regex-matching and building a HashMap (the appropriate map for key-value pairs)", "label": {"api": {"regex-matching": [[54, 67]]}}}, {"text": "I have found that the -fx-background-insets controls the size between values separated by commas, as the documentation sais", "label": {"api": {"-fx-background-insets": [[22, 42]]}}}, {"text": "However, if you wish to save the objects in an array I recommend you to use ArrayList  in this case (as static field in Flat class) (documentation) instead of an array because of the fixed size of arrays in java, you'll have to create an array with fixed initial size and in the Flat constructor you should check if the array is full, you should create bigger array, copy the old one, and add the new object", "label": {"api": {"(documentation)": [[132, 146]]}}}, {"text": "For your purposes you should use class DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[39, 55]]}}}, {"text": "How to compare FileTime and LocalDateTime objects in Java", "label": {"api": {"FileTime": [[15, 22]], "LocalDateTime": [[28, 40]]}}}, {"text": "I want to compare a FileTime object from a file (Files.getLastModifiedTime(item)) with the current time (LocalDateTime.now())", "label": {"api": {"FileTime": [[20, 27]], "LocalDateTime": [[105, 117]]}}}, {"text": "Contract for equals if well-defined in java spec", "label": {"api": {"java spec": [[39, 47]]}}}, {"text": "You can combine both reduction into single one using toMap like this", "label": {"api": {"toMap": [[53, 57]]}}}, {"text": "If you want to  control the concurrent query behaviour, better use ExecutorService", "label": {"api": {"ExecutorService": [[67, 81]]}}}, {"text": "On the documentation for Java's ExecutionService, there's an example method to shut down an executor service and it looks like this", "label": {"api": {"Java's ExecutionService": [[25, 47]]}}}, {"text": "But first, it seems your file is using non-US number formatting (1000,00, not 1000.00), so you should use NumberFormat with correct Locale to parse the number, instead of Double.parseDouble which parses Java-syntax numbers", "label": {"api": {"NumberFormat": [[106, 117]], "Double.parseDouble": [[171, 188]]}}}, {"text": "For debugging, I want a way to discover, for a running JVM at a given moment, all the names and all the values of all the properties maintained in the java.security.Security class", "label": {"api": {"java.security.Security": [[151, 172]]}}}, {"text": "If I know the name of a property, I can find its current value using getProperty", "label": {"api": {"getProperty": [[69, 79]]}}}, {"text": "Initial settings for the properties can be made in configuration files, but settings can later be added and changed dynamically, using setProperty", "label": {"api": {"setProperty": [[135, 145]]}}}, {"text": "Express the color as 3 float values from 0.0 - 1.0", "label": {"api": {"color as 3 float values from 0.0 - 1.0": [[12, 49]]}}}, {"text": "Express the color as an int, with 24 bits affected", "label": {"api": {"color as an int, with 24 bits affected": [[12, 49]]}}}, {"text": "Express the color as 3 ints 0-255 each, red/green/blue", "label": {"api": {"color as 3 ints 0-255 each, red/green/blue": [[12, 53]]}}}, {"text": "Check the Color constructor", "label": {"api": {"Color constructor": [[10, 26]]}}}, {"text": "By the way, you can use other Color constructor such as", "label": {"api": {"Color constructor": [[30, 46]]}}}, {"text": "There's no need to use a Stream for this when you can use Set#containsAll", "label": {"api": {"Set#containsAll": [[58, 72]]}}}, {"text": "Well You will search for everyplace for a Thread Safe for a ZipInputStream", "label": {"api": {"InputStream": [[63, 73]]}}}, {"text": "But the downside of this that none of the InputStream implementations in Java are thread-safe", "label": {"api": {"InputStream": [[42, 52]]}}}, {"text": "How about something like this where you check if the individual grade contains a / and deal with that case separately", "label": {"api": {"contains": [[70, 77]]}}}, {"text": "The contract for Object says that equal objects must have the same hash code", "label": {"api": {"contract for Object": [[4, 22]]}}}, {"text": "Then use String#replaceAll() to get rid of characters which are creating issue.You can take help from printable ASCII range", "label": {"api": {"String#replaceAll()": [[9, 27]]}}}, {"text": "One way is to use Arrays.copy() to pass a copy to the method", "label": {"api": {"Arrays.copy()": [[18, 30]]}}}, {"text": "Since there are two asynchronous calls involved, one way to do this is to use a CompletableFuture", "label": {"api": {"CompletableFuture": [[80, 96]]}}}, {"text": "Calendar#get gets a field value", "label": {"api": {"Calendar#get": [[0, 11]]}}}, {"text": "Calendar.JANUARY is not a field number, it's a potential field value", "label": {"api": {"Calendar.JANUARY": [[0, 15]]}}}, {"text": "While get takes an int, and Calendar.JANUARY is an int, they're ints in different domains", "label": {"api": {"Calendar.JANUARY": [[28, 43]]}}}, {"text": "The DataOutputStream.writeDouble uses Double.doubleToLongBits to create a IEEE 754 floating-point \"double format\" bit layout", "label": {"api": {"Double.doubleToLongBits": [[38, 60]]}}}, {"text": "The Scanner class has a constructor taking a String", "label": {"api": {"Scanner": [[4, 10]], "String": [[45, 50]]}}}, {"text": "How to feed a CharSequence object to a new Scanner", "label": {"api": {"Scanner": [[43, 49]], "CharSequence": [[14, 25]]}}}, {"text": "I could first generate a String from the CharSequence, but that is inefficient and rather silly", "label": {"api": {"CharSequence": [[41, 52]], "String": [[25, 30]]}}}, {"text": "I looking for a way to access the CharSequence directly from the Scanner", "label": {"api": {"Scanner": [[65, 71]], "CharSequence": [[34, 45]]}}}, {"text": "The Scanner class also takes a Readable in a constructor", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "Can a CharSequence be presented as a Readable", "label": {"api": {"CharSequence": [[6, 17]]}}}, {"text": "So, the workaround calling CharSequence::toString as seen in the Question is indeed the way to go", "label": {"api": {"CharSequence::toString": [[27, 48]]}}}, {"text": "Is there some way to determine which of two BigDecimal objects is the lower (smaller) number that is simpler than an if or a ternary operator calling BigDecimal::compareTo", "label": {"api": {"BigDecimal": [[44, 53], [150, 159]], "BigDecimal::compareTo": [[150, 170]]}}}, {"text": "If you are on Java-8 you can parse the string using ZonedDateTime class something like", "label": {"api": {"ZonedDateTime": [[52, 64]]}}}, {"text": "and use containsAll", "label": {"api": {"containsAll": [[8, 18]]}}}, {"text": "The HttpCookie has setMaxAge(long expiry) sets the maximum age of the cookie in seconds", "label": {"api": {"HttpCookie": [[4, 13]], "setMaxAge(long expiry)": [[19, 40]]}}}, {"text": "As you can see at both the source code of HttpCookie, where is MAX_AGE_UNSPECIFIED, and the getMaxAge() method documentation that the default value is set to -1", "label": {"api": {"HttpCookie": [[42, 51]], "getMaxAge()": [[92, 102]]}}}, {"text": "setMaxAge(long expiry) states the following", "label": {"api": {"setMaxAge(long expiry)": [[0, 21]]}}}, {"text": "I'm using the method drawLine to draw lines in a JPanel", "label": {"api": {"drawLine": [[21, 28]]}}}, {"text": "The FXML doesn't have an import statement for javafx.scene.layout.BorderPane", "label": {"api": {"import statement": [[25, 40]], "javafx.scene.layout.BorderPane": [[46, 75]]}}}, {"text": "Assume it makes no sense to have duplicate names in the array, the best way is to find the name in a Set<T> of names", "label": {"api": {"Set<T>": [[101, 106]]}}}, {"text": "Convert the array to List and include it in the constructor of HashSet<T> as soon as it accepts any collection", "label": {"api": {"Set<T>": [[67, 72]], "HashSet<T>": [[63, 72]]}}}, {"text": "Use simply only the static method Collectors.toList()", "label": {"api": {"Collectors.toList()": [[34, 52]]}}}, {"text": "You should use listFiles instead fo list() (provided you have the security rights to do so), otherwise you are stuck with the file names", "label": {"api": {"listFiles": [[15, 23]]}}}, {"text": "MethodHandles.Lookup.defineClass appears to be the blessed replacement", "label": {"api": {"MethodHandles.Lookup.defineClass": [[0, 31]]}}}, {"text": "I recommend you use a fairly simple method BigInteger::toString(int radix) which returns the String representation in the given radix", "label": {"api": {"BigInteger::toString(int radix)": [[43, 73]]}}}, {"text": "If you read the JavaDoc for String.split() that only takes one argument, you'll see that it suppresses trailing empty strings obtained after splitting", "label": {"api": {"JavaDoc for String.split() that only takes one argument": [[16, 70]]}}}, {"text": "Thread.sleep(long millis) is a static method that lets the current thread (which is, the thread that this method is being called from) sleep for the specified number of milliseconds", "label": {"api": {"Thread.sleep(long millis)": [[0, 24]]}}}, {"text": "Furthermore it's better to use a url as location to load the fxml, since this allows you to use resources relative to the document location (attribute values with prefix @)", "label": {"api": {"attribute values with prefix @": [[141, 170]]}}}, {"text": "You could return a CompletableFuture which provides lots of ways to chain asynchronous actions", "label": {"api": {"CompletableFuture": [[19, 35]]}}}, {"text": "You can use Class.forname() to get a class using the string name https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#forName(java.lang.String)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#forName(java.lang.String)": [[65, 152]]}}}, {"text": "You can use Properties class to read and write to config files", "label": {"api": {"Properties": [[12, 21]]}}}, {"text": "One possible solution would be the use of Pattern and Matcher", "label": {"api": {"Pattern": [[42, 48]], "Matcher": [[54, 60]]}}}, {"text": "This code uses java.util.StringTokenizer, shipped with the JRE", "label": {"api": {"java.util.StringTokenizer": [[15, 39]]}}}, {"text": "You can use onEndOfMedia() hook", "label": {"api": {"onEndOfMedia()": [[12, 25]]}}}, {"text": "This is similar to how Java 8 defined Function interface", "label": {"api": {"Function": [[38, 45]]}}}, {"text": "The constructor of ArrayList used in that code takes a Collection, which a Set is", "label": {"api": {"constructor of ArrayList": [[4, 27]]}}}, {"text": "match any character, including newlines, would be to use the Pattern.DOTALL flag (see the manual), but if you cannot use the flags with Pattern.compile(), as you said, you have to write them inside the regex", "label": {"api": {"the manual": [[86, 95]]}}}, {"text": "List#of, Set#of, Map#of with several overloaded methods to avoid calling the varargs one", "label": {"api": {"List#of": [[0, 6]], "Set#of": [[9, 14]], "Map#of": [[17, 22]]}}}, {"text": "In case of Map, for varargs, you have to use Map#ofEntries", "label": {"api": {"Map#of": [[45, 50]], "Map#ofEntries": [[45, 57]]}}}, {"text": "And if you wanted your Set to be immutable, you had to wrap it inside an immutable set from Collections#unmodifiableSet", "label": {"api": {"Collections#unmodifiableSet": [[92, 118]]}}}, {"text": "For Map, you may use a trick creating an anonymous class that extended a Map implementation, and then wrap it inside Collections#unmodifiableMap", "label": {"api": {"Collections#unmodifiableMap": [[117, 143]]}}}, {"text": "In any case, macros do not provide deferred execution to save you from actually constructing the string, as Java8 Logger class does by using lambda expressions", "label": {"api": {"Logger": [[114, 119]]}}}, {"text": "Otherwise in certain log levels, the program would crash", "label": {"api": {"levels": [[25, 30]]}}}, {"text": "This class provides support for logging levels automatically, so you do not need to create a custom implementation of them", "label": {"api": {"levels": [[40, 45]]}}}, {"text": "You can use standard ProcessBuilder for this propose", "label": {"api": {"ProcessBuilder": [[21, 34]]}}}, {"text": "This makes use of the comparingDouble() method which was new in Java 8", "label": {"api": {"comparingDouble()": [[22, 38]]}}}, {"text": "To execute a method after the values are injected use @javax.annotation.PostConstruct", "label": {"api": {"@javax.annotation.PostConstruct": [[54, 84]]}}}, {"text": "The documentation of RollbackException (https://docs.oracle.com/javaee/7/api/javax/persistence/RollbackException.html) mentions", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/persistence/RollbackException.html": [[40, 116]]}}}, {"text": "It means, if you want to work with the 4th element, you have to call Iterator::next() four times", "label": {"api": {"Iterator::next()": [[69, 84]]}}}, {"text": "A situation there are only 3 or fewer elements in the iterator may happen, so you have to check against Iterator::hasNext(), otherwise when there is no more element and you call next() again, the NoSuchElementException is thrown", "label": {"api": {"Iterator::hasNext()": [[104, 122]], "NoSuchElementException": [[196, 217]]}}}, {"text": "Sadly, this method doesn't accept BiConsumer<T,U> as an argument to consume not only the element but also its index - that's why this trick", "label": {"api": {"BiConsumer<T,U>": [[34, 48]]}}}, {"text": "You can then return a properly sized array by using something as simple as java.util.Arrays.copyOf(...), e.g", "label": {"api": {"java.util.Arrays.copyOf(...)": [[75, 102]]}}}, {"text": "For a global impact you can use LogManager.reset() as your call to disable logging and to re-enable logging you can LogManager.readConfiguration()", "label": {"api": {"LogManager.reset()": [[32, 49]], "LogManager.readConfiguration()": [[116, 145]]}}}, {"text": "The OperatingSystemMXBean allows you to query the system load", "label": {"api": {"OperatingSystemMXBean": [[4, 24]]}}}, {"text": "Because every data type in Java extends Object, you can just use an object array", "label": {"api": {"Object": [[40, 45]]}}}, {"text": "You need to create a new array when creating a new Robot instance, e.g., using Arrays.copyOf", "label": {"api": {"Arrays.copyOf": [[79, 91]]}}}, {"text": "See the JavaDoc for more details", "label": {"api": {"the JavaDoc for more details": [[4, 31]]}}}, {"text": "For more detail look into the Java API", "label": {"api": {"Java API": [[30, 37]]}}}, {"text": "Styling a range of DateCells can be achieved by using cell factory", "label": {"api": {"DateCell": [[19, 26]], "cell factory": [[54, 65]]}}}, {"text": "Alternatively you could use css and have the button toggle a PeseudoClass", "label": {"api": {"PeseudoClass": [[61, 72]]}}}, {"text": "In case it's String, you can try to match it with a defined constant like π or e and use their defined value in Java such as Math.PI", "label": {"api": {"Math.PI": [[125, 131]]}}}, {"text": "You could use a map structure to store pairs", "label": {"api": {"map": [[16, 18]]}}}, {"text": "Use nextToken instead of nextElement", "label": {"api": {"nextElement": [[25, 35]]}}}, {"text": "The documentation of nextElement says", "label": {"api": {"nextElement": [[21, 31]]}}}, {"text": "You can control and manipulate a single (or multiple) DateCell using cell factory", "label": {"api": {"DateCell": [[54, 61]], "cell factory": [[69, 80]]}}}, {"text": "You should override the toString method", "label": {"api": {"toString method": [[24, 38]]}}}, {"text": "The documentation of the java.util.stream package has a lot of information about this", "label": {"api": {"documentation of the java.util.stream package": [[4, 48]]}}}, {"text": "If you are asking what other Comparator<String> there are in the String class, the answer is that there is none", "label": {"api": {"String": [[40, 45], [65, 70]]}}}, {"text": "The String class as of Java 8 has only one Comparator<String>", "label": {"api": {"String": [[4, 9], [54, 59]]}}}, {"text": "Every Comparator<String> will work there", "label": {"api": {"String": [[17, 22]]}}}, {"text": "Javadoc of ServiceLoader says", "label": {"api": {"ServiceLoader": [[11, 23]]}}}, {"text": "java.lang.Number is a class; specifically, an abstract class", "label": {"api": {"java.lang.Number": [[0, 15]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/jdk/api/jpda/jdi/com/sun/jdi/request/StepRequest.html Java Docs says \"Step to the next available location\"", "label": {"api": {"https://docs.oracle.com/javase/7/docs/jdk/api/jpda/jdi/com/sun/jdi/request/StepRequest.html": [[0, 90]]}}}, {"text": "Use the groupingBy collector with counting as the downstream collector", "label": {"api": {"groupingBy": [[8, 17]], "counting": [[34, 41]]}}}, {"text": "Note, the above will yield a Map<String, Long> but if you really want Map<String, Integer> then use the summingInt collector as the downstream", "label": {"api": {"summingInt": [[104, 113]]}}}, {"text": "The exception is thrown upon call on an API method, such as persist()", "label": {"api": {"persist()": [[60, 68]]}}}, {"text": "If you are using java.time you can use LocalTime where you can use isBefore and isAfter like so", "label": {"api": {"java.time": [[17, 25]], "LocalTime": [[39, 47]], "isBefore": [[67, 74]], "isAfter": [[80, 86]]}}}, {"text": "You can fix by using this overridden version of indexOf() inside your while loop", "label": {"api": {"indexOf()": [[48, 56]]}}}, {"text": "while loop to avoid having to repeat the call to indexOf()", "label": {"api": {"indexOf()": [[49, 57]]}}}, {"text": "toArray takes an implementation of the IntFunction interface", "label": {"api": {"toArray": [[0, 6]]}}}, {"text": "- 100 by default - This is used as the backlog parameter for ServerSocket.bind", "label": {"api": {"ServerSocket.bind": [[61, 77]]}}}, {"text": "Use BigDecimal and setScale() to round", "label": {"api": {"setScale()": [[19, 28]]}}}, {"text": "Since Kotlin 1.3 was released there is no need to use Java's java.util.Random which would restrict your code to the JVM", "label": {"api": {"java.util.Random": [[61, 76]]}}}, {"text": "For more information, see Reduction operations paragraph", "label": {"api": {"Reduction operations": [[26, 45]]}}}, {"text": "The reduce function you are using is taking a BinaryOperator, which has takes two T objects as arguments and returns a T object", "label": {"api": {"reduce function you are using": [[4, 32]], "reduce function": [[4, 18]]}}}, {"text": "What you want is this reduce function, which works with an accumulator, here is how to use it (see Eran's answer)", "label": {"api": {"reduce function": [[22, 36]]}}}, {"text": "However, there is indeed a class that represents a date and a time without a time zone, which is LocalDateTime", "label": {"api": {"LocalDateTime": [[97, 109]]}}}, {"text": "You can use LocalDateTime.ofEpochSecond to create one from a numeric timestamp", "label": {"api": {"LocalDateTime": [[12, 24]], "LocalDateTime.ofEpochSecond": [[12, 38]]}}}, {"text": "Hard to say without known the specific use case or some code but you could use an external AtomicInteger to keep the track of the deep length", "label": {"api": {"AtomicInteger": [[91, 103]]}}}, {"text": "I believe you meant to use isLetter, not isAlphabetic", "label": {"api": {"isLetter": [[27, 34]], "isAlphabetic": [[41, 52]]}}}, {"text": "You can refer to the documentation to read more about the different methods available on the Scanner class", "label": {"api": {"to the documentation": [[14, 33]]}}}, {"text": "try passing an array as suggested on javadocs", "label": {"api": {"passing an array": [[4, 19]]}}}, {"text": "You can use replaceAll() to merge all values with the other map like this", "label": {"api": {"replaceAll()": [[12, 23]]}}}, {"text": "It is more straightforward to do this with the 3-argument version of toMap collector", "label": {"api": {"3-argument version of toMap collector": [[47, 83]]}}}, {"text": "Without multithreading your application will 'stop' the moment you click your \"link\" button because the call to ServerSocket#accept", "label": {"api": {"ServerSocket#accept": [[112, 130]]}}}, {"text": "My prefered way is to create a custom class which only handles the ServerSocket#accept method and delegates incoming connections to another thread which takes care of the rest", "label": {"api": {"ServerSocket#accept": [[67, 85]]}}}, {"text": "You should consider working through the orcale concurrency tutorial and definitly take a look at ExecutorServices because they are an incredible framework to handle threadpools with ease", "label": {"api": {"ExecutorServices": [[97, 112]]}}}, {"text": "You need to execute PrepatedStatement.executeQuery(), not Statement.executeQuery(String)", "label": {"api": {"PrepatedStatement.executeQuery()": [[20, 51]], "Statement.executeQuery(String)": [[58, 87]]}}}, {"text": "Consider the example HTML from the HTMLDocument documentation", "label": {"api": {"the HTMLDocument documentation": [[31, 60]]}}}, {"text": "You can use a BigDecimal number instead of double", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "BigDecimal can represent any number with the choosen precision", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "A good and yet simple example is StringBuilder", "label": {"api": {"StringBuilder": [[33, 45]]}}}, {"text": "It is often implemented with a fluent interface - a typical example is Stream<T>", "label": {"api": {"Stream<T>": [[71, 79]]}}}, {"text": "Just like the javadoc of getResource says", "label": {"api": {"getResource": [[25, 35]]}}}, {"text": "Download it yourself from wherever you can get it, and configure the DocumentBuilder to look for it there by providing an EntityResolver to DocumentBuilder.setEntityResolver()", "label": {"api": {"DocumentBuilder.setEntityResolver()": [[140, 174]]}}}, {"text": "Take a look at the return of ServerSocket::accept", "label": {"api": {"ServerSocket::accept": [[29, 48]]}}}, {"text": "What is happening here is that the mergeSort is assuming the object implements Comparable and calls it's compareTo method", "label": {"api": {"Comparable": [[79, 88]]}}}, {"text": "This assumption will cause a fail fast ClassCastException so it's not a bad assumption", "label": {"api": {"ClassCastException": [[39, 56]]}}}, {"text": "In most cases the object will implement Comparable so it is safe", "label": {"api": {"Comparable": [[40, 49]]}}}, {"text": "Back before JavaFX 2, there used to be a boolean ligatures property on javafx.scene.text.Font that claimed to control whether ligatures were used, but that doesn't appear to be there anymore", "label": {"api": {"doesn't appear to be there anymore": [[156, 189]]}}}, {"text": "A regular expression Pattern is an excellent class to use for this kind of task", "label": {"api": {"Pattern": [[21, 27]]}}}, {"text": "In the most basic form the String class already offers a matches method", "label": {"api": {"matches": [[57, 63]]}}}, {"text": "If you need to compare multiple strings creating a separate Pattern and new Matchers might be more efficient as it avoids reinterpretation of the pattern", "label": {"api": {"Pattern": [[60, 66]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/lang/NumberFormatException.html will see it subclasses RuntimeException", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/NumberFormatException.html": [[0, 77]]}}}, {"text": "But how might I refer to the java.util.ArrayList that we all know and love in the same class", "label": {"api": {"java.util.ArrayList": [[29, 47]]}}}, {"text": "Set a custom JsonSerialize and format it there, with SimpleDateFormat this way", "label": {"api": {"SimpleDateFormat": [[53, 68]]}}}, {"text": "Also, is you are using Java 8 there is DateTimeFormatter which is thread-safe (as @Philippe Marschall pointed out)", "label": {"api": {"DateTimeFormatter": [[39, 55]]}}}, {"text": "According to the documentation Scanner#nextInt() attempts to parse a given String to an integer", "label": {"api": {"Scanner#nextInt()": [[31, 47]]}}}, {"text": "a TreeSet), you could simply use the subSet overload which takes inclusivity parameters", "label": {"api": {"subSet overload which takes inclusivity parameters": [[37, 86]]}}}, {"text": "If you want to read all the bytes you can use the java.nio.file.Files utility class", "label": {"api": {"java.nio.file.Files": [[50, 68]]}}}, {"text": "Since you are using UTF you should be using String#codePoinst() method to iterate over the code points instead of the characters", "label": {"api": {"String#codePoinst()": [[44, 62]]}}}, {"text": "I'm not sure what you want exactly, but how about GraphicsDevice or DisplayMode", "label": {"api": {"GraphicsDevice": [[50, 63]], "DisplayMode": [[68, 78]]}}}, {"text": "GraphicsDevice is obtainable by", "label": {"api": {"GraphicsDevice": [[0, 13]]}}}, {"text": "Then you can get DisplayMode by", "label": {"api": {"DisplayMode": [[17, 27]]}}}, {"text": "Bind the properties of your transition to the values of your model with a calculation from the Bindings class", "label": {"api": {"Bindings": [[95, 102]]}}}, {"text": "If you wish more control over formatting then you can convert the instant to a ZonedDateTime (or better to an OffsetDateTime) and use a dedicated DateTimeFormatter", "label": {"api": {"to an OffsetDateTime": [[104, 123]]}}}, {"text": "JavaFX component TextArea inherits the method setText(String value) from TextInputControl and its documentations sais", "label": {"api": {"TextArea": [[17, 24]], "setText(String value)": [[46, 66]], "TextInputControl": [[73, 88]]}}}, {"text": "To just insert a new line (update, append) the text, you have to use the method appendText(String value) inherited as well", "label": {"api": {"appendText(String value)": [[80, 103]]}}}, {"text": "To scroll to the end, you have to implement a listener which is triggered by any text change (setText(), appendText()) and perform the scroll using the method setScrollTop(double value)", "label": {"api": {"setScrollTop(double value)": [[159, 184]]}}}, {"text": "If all Character has a unique id, you can put them into a java.util.HashMap", "label": {"api": {"java.util.HashMap": [[58, 74]]}}}, {"text": "If you are using Java 8, You can use anyMatch which will return true if it is found else false", "label": {"api": {"anyMatch": [[37, 44]]}}}, {"text": "One possible solution using Java 8 anyMatch(...)", "label": {"api": {"anyMatch(...)": [[35, 47]]}}}, {"text": "You can create in the same XML file an ArrayList containing these Labels by the id reference, using the fx:define and fx:reference tags", "label": {"api": {"fx:define": [[104, 112]], "fx:reference": [[118, 129]]}}}, {"text": "Source at the official Oracle documentation", "label": {"api": {"Oracle documentation": [[23, 42]]}}}, {"text": "The <fx:define> element is used to create objects that exist outside of the object hierarchy but may need to be referred to elsewhere", "label": {"api": {"fx:define": [[5, 13]]}}}, {"text": "The <fx:reference> element creates a new reference to an existing element", "label": {"api": {"fx:reference": [[5, 16]]}}}, {"text": "or as suggested by @shmosel, you can avoid the ternary operator with the use of getOrDefault", "label": {"api": {"getOrDefault": [[80, 91]]}}}, {"text": "You can do this using a CompletableFuture", "label": {"api": {"CompletableFuture": [[24, 40]]}}}, {"text": "A simple solution would be to use the Actions API", "label": {"api": {"Actions": [[38, 44]]}}}, {"text": "It's simple, create a JTable using constructor new JTable(Vector rowData, Vector columnNames), where rowData is the data for the new table and columnNames is names of each column", "label": {"api": {"JTable": [[22, 27], [51, 56]], "new JTable(Vector rowData, Vector columnNames)": [[47, 92]]}}}, {"text": "Check the reference", "label": {"api": {"reference": [[10, 18]]}}}, {"text": "super T> mapper) and then use the method min() to get the minimum value", "label": {"api": {"min()": [[41, 45]]}}}, {"text": "This method requires no parameters since it works with IntStream instead and integers are compared directly", "label": {"api": {"IntStream": [[55, 63]]}}}, {"text": "If you want to send collections of POJOs, you need to wrap it in GenericEntity", "label": {"api": {"GenericEntity": [[65, 77]]}}}, {"text": "The reason is that it uses the BigDecimal equals method to compare bar fields and BigDecimal's equals differentiate 2.0 from 2.00 (usingFieldByFieldElementComparator javadoc states that fields are compared with equals)", "label": {"api": {"BigDecimal's equals": [[82, 100]]}}}, {"text": "where BIG_DECIMAL_COMPARATOR is a Comparator<BigDecimal> implemented by calling BigDecimal's compareTo method, see org.assertj.core.util.BigDecimalComparator", "label": {"api": {"compareTo": [[93, 101]]}}}, {"text": "While you can make it work using Map<Integer, List<String>> (for example), that's cumbersome and doesn't look clean", "label": {"api": {"List": [[46, 49]]}}}, {"text": "List is a better data structure for this task", "label": {"api": {"List": [[0, 3]]}}}, {"text": "For example check out the AnimationTimer in Javafx", "label": {"api": {"AnimationTimer in Javafx": [[26, 49]]}}}, {"text": "JavaFX comes with interpolators", "label": {"api": {"JavaFX comes with interpolators": [[0, 30]]}}}, {"text": "One simple solution I can think of rapidly would be to use the stream function available for collections (https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#stream--) and then use the filter function (https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-) on your map of students + opted subjects to filter out non-chosen subjects out of a list containing all available subjects", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#stream--": [[106, 181]], "https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-": [[218, 324]]}}}, {"text": "You can Stream your ObjectTest elements, map them to an IntStream and call the max() method to compute the maximum value", "label": {"api": {"IntStream": [[56, 64]]}}}, {"text": "To avoid funkyness with how your strings are split, it's usually safer to just use the multi-paramter version of Runtime.exec", "label": {"api": {"multi-paramter version of Runtime.exec": [[87, 124]]}}}, {"text": "(1) Java AtomicInteger or AtomicLong", "label": {"api": {"AtomicInteger": [[9, 21]], "AtomicLong": [[26, 35]]}}}, {"text": "(2) Java Semaphore", "label": {"api": {"Semaphore": [[9, 17]]}}}, {"text": "For (2) have a look at the Comparator interface in the javadocs as well as the methods in the Collections class, in particolar the sort method", "label": {"api": {"Collections": [[94, 104]]}}}, {"text": "Java already has Collections.frequency which will do exactly that", "label": {"api": {"Collections.frequency": [[17, 37]]}}}, {"text": "You can use Stream.anyMatch()", "label": {"api": {"Stream.anyMatch()": [[12, 28]]}}}, {"text": "I suggest using Java's Duration class", "label": {"api": {"Duration": [[23, 30]]}}}, {"text": "But first, you need to transform your strings into date objects, so that it can be calculated with Duration", "label": {"api": {"Duration": [[99, 106]]}}}, {"text": "If you need the binary output from the encryption method as a string, you can use java.util.Base64 to encode it as such", "label": {"api": {"java.util.Base64": [[82, 97]]}}}, {"text": "The equals() method that you are trying to override takes in an Object as a parameter, not a Point object", "label": {"api": {"equals() method that you are trying to override": [[4, 50]]}}}, {"text": "You can achieve this by adding a Document Listener to your JTextField", "label": {"api": {"Document Listener": [[33, 49]]}}}, {"text": "With Java 8 you could use Collectors.toMap() to provide a merge function that merges the List of NTM as you have duplicate keys in your maps", "label": {"api": {"Collectors.toMap()": [[26, 43]]}}}, {"text": "Since you are reading from the inside of a WAR (acm.war) or JAR (acm.jar) you need ZipInputStream or JarInputStream", "label": {"api": {"ZipInputStream": [[83, 96]], "JarInputStream": [[101, 114]]}}}, {"text": "The certificate and key used for an SSLContext server is selected by the KeyManager it is initialized with", "label": {"api": {"KeyManager": [[73, 82]]}}}, {"text": "If you want to manually select the certificate and/or key you can implement your own KeyManager and place your code in", "label": {"api": {"KeyManager": [[85, 94]]}}}, {"text": "If you implement the first method in a way that it returns the alias of the key/certificate in the key store you can delegate the second to an existing KeyManager instance", "label": {"api": {"KeyManager": [[152, 161]]}}}, {"text": "The Stream-API doesn't provide the iteration mechanism like the Iterator does, for this you have to use the Iterator<User>", "label": {"api": {"Iterator": [[64, 71], [108, 115]]}}}, {"text": "Now get an Iterator<User> and iterate through", "label": {"api": {"Iterator": [[11, 18]]}}}, {"text": "Since System.lineSeparator() is platform dependent, as per docs", "label": {"api": {"System.lineSeparator()": [[6, 27]]}}}, {"text": "The ServletRequest also provides the method java.lang.String getRemoteAddr() see https://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getRemoteAddr() for more details", "label": {"api": {"https://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getRemoteAddr()": [[81, 166]]}}}, {"text": "I would add all balls to a list and then shuffle the list", "label": {"api": {"shuffle the list": [[41, 56]]}}}, {"text": "You can use JavaFX's FilteredList, which accepts a Predicate", "label": {"api": {"FilteredList": [[21, 32]], "Predicate": [[51, 59]]}}}, {"text": "Using the FilteredList you don't need to re-read the log records, as the filter is applied immediately on the existing items", "label": {"api": {"FilteredList": [[10, 21]]}}}, {"text": "Simply have your classes implement Serializable and you'll be ready to write your objects to files (and read them back, of course) whenever you want", "label": {"api": {"Serializable": [[35, 46]]}}}, {"text": "Implementing Serializable correctly (in a way that won't come back around to bite you) is a somewhat daunting subject", "label": {"api": {"Serializable": [[13, 24]]}}}, {"text": "UUID::randomUUID is a method reference to the randomUUID method on UUID", "label": {"api": {"randomUUID": [[6, 15], [46, 55]]}}}, {"text": "Generate accepts a Supplier, and UUID.randomUUID fufills that Functional Interface", "label": {"api": {"randomUUID": [[38, 47]], "Generate": [[0, 7]], "Supplier": [[19, 26]], "Functional Interface": [[62, 81]]}}}, {"text": "If you use java.time.LocalDate then this is the solution", "label": {"api": {"java.time.LocalDate": [[11, 29]]}}}, {"text": "If you are using Java8+, I would strongly suggest to use java.time library, if not, then you can use ThreeTen Backport library which is equivalent to java.time API", "label": {"api": {"java.time": [[57, 65], [150, 158]]}}}, {"text": "The basic mistake here is that you are using Java's own getClass(), which has nothing to do with JSoup and returns a Class object", "label": {"api": {"getClass()": [[56, 65]], "Class": [[59, 63], [117, 121]]}}}, {"text": "As @Michael suggested, using the Collections.emptyList() is a better choice than new ArrayList<>()", "label": {"api": {"Collections.emptyList()": [[33, 55]]}}}, {"text": "You have to implement Iterable<String> to your StringList like this", "label": {"api": {"Iterable<String>": [[22, 37]]}}}, {"text": "You can use the parse method of the formatter, which will give you a TemporalAccessor, and then get the year field from that", "label": {"api": {"TemporalAccessor": [[69, 84]]}}}, {"text": "This is trivial with Java's Set mechanics", "label": {"api": {"Set": [[28, 30]]}}}, {"text": "The only way to modify an HttpServletRequest is to wrap it", "label": {"api": {"wrap": [[51, 54]]}}}, {"text": "You can use java.util.ArrayList, for example, create an ArrayList for vowels", "label": {"api": {"java.util.ArrayList": [[12, 30]]}}}, {"text": "First, you should be using a PreparedStatement; this will help you to avoid syntax errors (which are hard to see when concatenating Java Strings) among other things", "label": {"api": {"PreparedStatement": [[29, 45]]}}}, {"text": "Here's an example using a PreparedStatement", "label": {"api": {"PreparedStatement": [[26, 42]]}}}, {"text": "You may use the String.split(String delimiter) method", "label": {"api": {"String.split(String delimiter)": [[16, 45]]}}}, {"text": "Use merge function", "label": {"api": {"merge": [[4, 8]]}}}, {"text": "This solution internally uses the merge method which basically says if the specified key is not already associated with a value or is associated with null, associates it with the given non-null value", "label": {"api": {"merge": [[34, 38]]}}}, {"text": "The easiest way to solve this problem is to use HashMap  instead of using ArrayList", "label": {"api": {"HashMap": [[48, 54]], "ArrayList": [[74, 82]]}}}, {"text": "Following is modified code using HashMap", "label": {"api": {"HashMap": [[33, 39]]}}}, {"text": "The Class type has no public constructor, so you can't instantiate one using the typical new syntax", "label": {"api": {"Class": [[4, 8]]}}}, {"text": "You have to rely on the compiler to resolve class literals like IntTag.class or obtain instances via functions like Object.getClass", "label": {"api": {"Class": [[126, 130]], "Object.getClass": [[116, 130]]}}}, {"text": "The ObservableList<Screen> returned by Screen.getScreens() changes when the (visual) bounds of a Screen changes", "label": {"api": {"Screen.getScreens()": [[39, 57]]}}}, {"text": "There is a difference between lowercase hashtable, which is a generally defined data structure, and the java Hashtable class, which is a synchronized implementation of hashtable in Java that predates the HashMap and HashSet classes", "label": {"api": {"Hashtable": [[109, 117]]}}}, {"text": "HashSet does not use the Hashtable class at all", "label": {"api": {"Hashtable": [[25, 33]]}}}, {"text": "Hashtable should rarely if ever be used in contemporary code", "label": {"api": {"Hashtable": [[0, 8]]}}}, {"text": "As per the javadocs for Hashtable", "label": {"api": {"Hashtable": [[24, 32]], "javadocs for Hashtable": [[11, 32]]}}}, {"text": "If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable", "label": {"api": {"Hashtable": [[92, 100]]}}}, {"text": "If a thread-safe highly-concurrent implementation is desired, then it is recommended to use ConcurrentHashMap in place of Hashtable", "label": {"api": {"Hashtable": [[122, 130]]}}}, {"text": "javax.validation.ValidationException is a pretty standard choice", "label": {"api": {"javax.validation.ValidationException": [[0, 35]]}}}, {"text": "The InputStream that you get back from the SerialPort follows the same rules that a normal InputStream does, which means that is.read() is a blocking call", "label": {"api": {"InputStream": [[4, 14], [91, 101]]}}}, {"text": "I was reading this excellent answer on grabbing Java garbage collection activity info and noticed that the GarbageCollectorMXBean doesn't have any data about what type of collection it was (Minor, Major, Full, etc.)", "label": {"api": {"GarbageCollectorMXBean": [[107, 128]]}}}, {"text": "The notification's UserData will contain an instance of the type GarbageCollectionNotificationInfo", "label": {"api": {"GarbageCollectionNotificationInfo": [[65, 97]]}}}, {"text": "The attribute GcAction will tell you if it was major or minor, and GcCause will tell you the GC event cause", "label": {"api": {"GcAction": [[14, 21]], "GcCause": [[67, 73]]}}}, {"text": "Java offers EnumSet which is a set specialized to work with enums effectively", "label": {"api": {"EnumSet": [[12, 18]]}}}, {"text": "Behold the LinkedHashSet, which maintains both uniqueness and order", "label": {"api": {"LinkedHashSet": [[11, 23]]}}}, {"text": "yes\" in flexible but it had no real effect, because in GAE Standard you would use com.google.appengine.api.ThreadManager and as you said Google will do anything for us but in GAE Flexible you have to manage your own threads with usual Java's class Thread or whatever you want to use", "label": {"api": {"usual Java's class Thread or whatever you want to use": [[229, 281]]}}}, {"text": "Use getRealPath() of ServletContext to get the path of the deployed WAR folder structure on the server file system ServletContext#getRealPath()", "label": {"api": {"ServletContext#getRealPath()": [[115, 142]]}}}, {"text": "What you are doing is using the method PrintStream.print(Object)", "label": {"api": {"PrintStream.print(Object)": [[39, 63]]}}}, {"text": "The string produced by the String.valueOf(Object) method is translated into bytes according to the platform's default character encoding, and these bytes are written in exactly the manner of the write(int) method", "label": {"api": {"String.valueOf(Object)": [[27, 48]]}}}, {"text": "It will internally use String.valueOf(Object) on the parameter", "label": {"api": {"String.valueOf(Object)": [[23, 44]]}}}, {"text": "newSingleThreadExecutor() and its defaultThreadFactory() create non-daemon threads", "label": {"api": {"defaultThreadFactory()": [[34, 55]]}}}, {"text": "I'm aware of the non-interference requirement, but it seems to be talking about modification from one of the stream operations (\"stream pipelines whose source might not be concurrent should never modify the stream's data source\"), not necessarily externally", "label": {"api": {"non-interference": [[17, 32]]}}}, {"text": "As I stated in the title, is it possible to run WebEngine in another thread than FX Application Thread", "label": {"api": {"WebEngine": [[48, 56]]}}}, {"text": "For getting rid of trailing zero, you can use DecimalFormat and its method setMinimumFractionDigits(0)", "label": {"api": {"setMinimumFractionDigits": [[75, 98]]}}}, {"text": "\"Generate JavaDoc\" is a way of parsing your JavaDoc comments and generating HTML which can browsed separately or hosted on a web page, just like the classes from the JDK have", "label": {"api": {"just like the classes from the JDK have": [[135, 173]]}}}, {"text": "Use this overload of groupingBy which accepts a downstream collector", "label": {"api": {"groupingBy": [[21, 30]]}}}, {"text": "1 - Convert using File.toPath", "label": {"api": {"File.toPath": [[18, 28]]}}}, {"text": "The Cashier thread only terminates after being interrupted (which occurs after Thread.interrupt is invoked directly or via another function like ExecutorService.shutdownNow)", "label": {"api": {"Thread.interrupt": [[79, 94]], "ExecutorService.shutdownNow": [[145, 171]]}}}, {"text": "While it's possible to model this using wait and notify as you've done, it's simpler to implement a producer-consumer workflow using a BlockingQueue", "label": {"api": {"BlockingQueue": [[135, 147]]}}}, {"text": "Have your producer thread(s) put elements into the queue and have consumer thread(s) take from the queue", "label": {"api": {"put": [[29, 31]], "take": [[85, 88]]}}}, {"text": "Thread#join declared that it throws an InterruptedException", "label": {"api": {"Thread#join": [[0, 10]]}}}, {"text": "Well, the ArrayIndexOutOfBoundsException error means that you attempted to access an index that is not found in your array - in this case index 1 (meaning your array contains a single value at the first (0) index)", "label": {"api": {"ArrayIndexOutOfBoundsException": [[10, 39]]}}}, {"text": "It uses the ImageView(String url) constructor which will load the Image for you", "label": {"api": {"ImageView(String url)": [[12, 32]]}}}, {"text": "ifPresent has a void return type so performing return ResponseEntity.ok(grocery); will not work as you've already witnessed", "label": {"api": {"ifPresent": [[0, 8]]}}}, {"text": "That said, Optional has an isPresent() method which you can use", "label": {"api": {"isPresent()": [[27, 37]]}}}, {"text": "(any subclass of RuntimeException will do)", "label": {"api": {"RuntimeException": [[17, 32]]}}}, {"text": "Or use two-argument Comparator.comparing()", "label": {"api": {"Comparator.comparing()": [[20, 41]]}}}, {"text": "According to Collections definition, methods like max and min have the following signature", "label": {"api": {"Collections definition": [[13, 34]]}}}, {"text": "Another way to avoid this problem is to use BigDecimal, which uses more precise floating point math", "label": {"api": {"BigDecimal": [[44, 53]]}}}, {"text": "A similar answer (specifically Eric Weilnau's answer to a related question) recommends The need for BigDecimal to illustrate why BigDecimal helps here", "label": {"api": {"BigDecimal": [[100, 109], [129, 138]]}}}, {"text": "Another option would be to use the LineNumberReader API", "label": {"api": {"LineNumberReader": [[35, 50]]}}}, {"text": "You can check the ElementKind in order to dispatch on its concrete type", "label": {"api": {"Element": [[18, 24]]}}}, {"text": "After that you know its an ExecutableElement and can cast it to one", "label": {"api": {"ExecutableElement": [[27, 43]], "Element": [[37, 43]]}}}, {"text": "See ExecutableElement, and Element for more details", "label": {"api": {"ExecutableElement": [[4, 20]], "Element": [[14, 20], [27, 33]]}}}, {"text": "A Worker has the running property", "label": {"api": {"running": [[17, 23]]}}}, {"text": "Take a look at java.util.stream.IntStream interface documentation for more features", "label": {"api": {"java.util.stream.IntStream": [[15, 40]]}}}, {"text": "If you need it to be thread-safe, you should probably change the int to an AtomicInteger", "label": {"api": {"AtomicInteger": [[75, 87]]}}}, {"text": "You could use one of the synchronization classes such as CountDownLatch", "label": {"api": {"CountDownLatch": [[57, 70]]}}}, {"text": "Use Timers to have the labels being shown after some time", "label": {"api": {"Timers": [[4, 9]]}}}, {"text": "You could also just insert code that pauses your app for a certain amount of time like Thread.sleep, but this would render your app entirely unresponsive as long as the app waits", "label": {"api": {"Thread.sleep": [[87, 98]]}}}, {"text": "That part can be unit tested by using ByteArrayOutputStream and ByteArrayInputStream instead, so refactor the code so you can test the writing/reading logic using byte streams when unit testing, but file streams when running code", "label": {"api": {"ByteArrayOutputStream": [[38, 58]], "ByteArrayInputStream": [[64, 83]]}}}, {"text": "The KeyStore may be loaded from a stream, there's an example for that in KeyStore Javadoc", "label": {"api": {"KeyStore Javadoc": [[73, 88]]}}}, {"text": "You can synchronize on the Object, or return some kind of Lock if you prefer", "label": {"api": {"Lock": [[58, 61]]}}}, {"text": "Define your method to take a Collection<String> as Collection<T> is the super interface for Set<T> and List<T>", "label": {"api": {"Collection<T>": [[51, 63]]}}}, {"text": "The common interface for ArrayList, LinkedList and HashSet is java.util.Collection", "label": {"api": {"java.util.Collection": [[62, 81]]}}}, {"text": "Instead, use the java.nio.file package, which will not only return full file paths, but will also provide you with useful information if your attempt to list the files fails", "label": {"api": {"java.nio.file package": [[17, 37]]}}}, {"text": "You could use Java's Preferences API, that's its purpose", "label": {"api": {"Preferences": [[21, 31]]}}}, {"text": "H2's docs say to use PreparedStatement.setBinaryStream", "label": {"api": {"PreparedStatement.setBinaryStream": [[21, 53]]}}}, {"text": "You can inject ResourceInfo into the exception mapper to get the resource method", "label": {"api": {"ResourceInfo": [[15, 26]]}}}, {"text": "I have a LinkedList of objects, and a pointer to an object of the LinkedList which I want to delete", "label": {"api": {"LinkedList": [[9, 18], [66, 75]]}}}, {"text": "There is a method remove(object o), which can be used to do delete an object, but as the documentation describes, it checks for all the elements one by one, and chooses the one object, which is the same semantically", "label": {"api": {"remove(object o)": [[18, 33]]}}}, {"text": "Since I have a pointer to the object I want to delete, I should be able to delete it in O(1) time, since the LinkedList is a doubly linked list", "label": {"api": {"LinkedList": [[109, 118]]}}}, {"text": "Is there any other way to do so without implementing my own LinkedList class", "label": {"api": {"LinkedList": [[60, 69]]}}}, {"text": "You can delete an object if you keep a ListIterator<E> object positioned at the item that you would like to remove by calling remove() on the iterator, but it does not help much, because your iterator would get invalidated the moment the list is modified", "label": {"api": {"remove()": [[126, 133]]}}}, {"text": "I took this technique from the java.util.Collections class", "label": {"api": {"java.util.Collections class": [[31, 57]]}}}, {"text": "You can use Objects.equals", "label": {"api": {"Objects.equals": [[12, 25]]}}}, {"text": "If the client exists, just add the article to his list", "label": {"api": {"add": [[27, 29]]}}}, {"text": "If he doesn't create a new list and add to it", "label": {"api": {"add": [[36, 38]]}}}, {"text": "Note that Java 8's computeIfAbsent would make this whole block go away, and produce much more elegant code", "label": {"api": {"computeIfAbsent": [[19, 33]]}}}, {"text": "Use an AffineTransform translate instance", "label": {"api": {"AffineTransform translate instance": [[7, 40]]}}}, {"text": "You need the to add all the values to the Set<E> in just one iteration which ensures you by its definition, that the values will be distinct", "label": {"api": {"Set<E>": [[42, 47]]}}}, {"text": "Use the LinkedHashSet<E> to maintain the order", "label": {"api": {"Set<E>": [[18, 23]], "LinkedHashSet<E>": [[8, 23]], "HashSet<E>": [[14, 23]]}}}, {"text": "Otherwise, HashSet<E> will do the job as well", "label": {"api": {"Set<E>": [[15, 20]], "HashSet<E>": [[11, 20]]}}}, {"text": "Instead of using timer.scheduleAtFixedRate use the method timer.schedule", "label": {"api": {"timer.schedule": [[17, 30], [58, 71]]}}}, {"text": "There is not a very big difference, but mouseClicked happens when", "label": {"api": {"mouseClicked": [[40, 51]]}}}, {"text": "So if you click outside your application, drag the mouse on the application and release it you have a mouseReleased event, but you don't have a mouseClicked event, because it was pressed outside the application", "label": {"api": {"mouseClicked": [[144, 155]], "mouseReleased": [[102, 114]]}}}, {"text": "Use the Supplier functional interface to do this", "label": {"api": {"Supplier": [[8, 15]]}}}, {"text": "Looking through its documentation, we can see the getString method can take either a column index or a column label, but mentions nothing about wildcard searches such as *", "label": {"api": {"column index": [[85, 96]], "column label": [[103, 114]]}}}, {"text": "If you don't know anything about the columns in the database, you can use the getMetadata() method to obtain information about the columns (including the column names)", "label": {"api": {"getMetadata()": [[78, 90]]}}}, {"text": "[RecursiveTask is] A recursive result-bearing ForkJoinTask", "label": {"api": {"RecursiveTask": [[1, 13]]}}}, {"text": "[RecursiveAction is] A recursive resultless ForkJoinTask", "label": {"api": {"RecursiveAction": [[1, 15]]}}}, {"text": "Although technically, RecursiveAction does return a value, it's just always null, because it's a ForkJoinTask<Void>, and that's the only possible value of Void", "label": {"api": {"RecursiveAction": [[22, 36]]}}}, {"text": "Further, you can check out the Collectors API and experiment with it and/or see the Guide to Java 8’s Collectors", "label": {"api": {"Collectors API": [[31, 44]]}}}, {"text": "Set a Text node’s fill to an ImagePattern", "label": {"api": {"Text node": [[6, 14]], "fill": [[18, 21]], "ImagePattern": [[29, 40]]}}}, {"text": "What you are probably looking for is method.getDeclaringClass()", "label": {"api": {"method.getDeclaringClass()": [[37, 62]]}}}, {"text": "This uses the toArray method of List to convert it into an array", "label": {"api": {"toArray": [[14, 20]]}}}, {"text": "In that case, you can use a bounded queue and set up an appropriate rejection handler using ThreadPoolExecutor directly", "label": {"api": {"ThreadPoolExecutor": [[92, 109]]}}}, {"text": "In this case the instruction typically refers to LambdaMetafactory.metafactory or LambdaMetafactory.altMetafactory as a bootstrap method", "label": {"api": {"LambdaMetafactory.metafactory": [[49, 77]], "LambdaMetafactory.altMetafactory": [[82, 113]]}}}, {"text": "Note that when you don’t implement Collector, but rather construct one by passing the functions to Collector.of(…), you never need to specify that characteristic, as it will be injected based on whether you specified a finisher function or not", "label": {"api": {"Collector.of(…)": [[99, 113]]}}}, {"text": "Functionally MethodHandleProxies::asInterfaceInstance seems like a good fit", "label": {"api": {"MethodHandleProxies::asInterfaceInstance": [[13, 52]]}}}, {"text": "But if you want to genericize it, you can with a Class instance and reflection, using getConstructor to get a relevant constructor, and then calling its newInstance method", "label": {"api": {"getConstructor": [[86, 99]], "newInstance": [[153, 163]]}}}, {"text": "The getRawOffset method, as described in the documentation, returns the raw offset value (without DST if applicable) of the current date, in terms of milliseconds", "label": {"api": {"as described in the documentation": [[25, 57]]}}}, {"text": "Also, modern Java should no longer use java.util.TimeZone, but rather should prefer the improved java.time APIs instead", "label": {"api": {"improved java.time APIs": [[88, 110]]}}}, {"text": "It can be more easier if you are using java.time API of Java 8+, where you can use LocalDate.of and set whatever you want", "label": {"api": {"java.time": [[39, 47]], "LocalDate.of": [[83, 94]]}}}, {"text": "Here, you will use the overload of Collectors.toMap that takes a key mapper, a value mapper, and a merge function", "label": {"api": {"the overload of Collectors.toMap that takes a key mapper, a value mapper, and a merge function": [[19, 112]]}}}, {"text": "This uses Map::merge to perform the work", "label": {"api": {"Map::merge": [[10, 19]]}}}, {"text": "Map::merge basically says if the specified key a.getId() is not already associated with a value or is associated with null, associates it with the given non-null value", "label": {"api": {"Map::merge": [[0, 9]]}}}, {"text": "You can use this overload of the remove method", "label": {"api": {"remove": [[33, 38]]}}}, {"text": "I have a use case where it would be useful to use reflection to get the parameter and return value types of Function objects1", "label": {"api": {"Function": [[108, 115]]}}}, {"text": "For more information about String formatter rules, check its official documentation", "label": {"api": {"its official documentation": [[57, 82]]}}}, {"text": "You set the rejected excecution policy to have the caller run the task", "label": {"api": {"excecution policy": [[21, 37]]}}}, {"text": "The Scanner class implements the Closable interface - i.e., it opens a resource, and you should call the close() method yourself, so, generally speaking, Eclipse does the right thing and produces a warning here", "label": {"api": {"Scanner": [[4, 10]], "Closable": [[33, 40]], "close()": [[105, 111]]}}}, {"text": "However, in this specific case, keyboard is a Scanner that refers to System.in - the standard input descriptor", "label": {"api": {"Scanner": [[46, 52]]}}}, {"text": "Especially after checking its specification further demonstrating your point", "label": {"api": {"specification": [[30, 42]]}}}, {"text": "Yes, you're looking for the Runnable interface which has a single method taking no parameters and has a void return type", "label": {"api": {"Runnable": [[28, 35]]}}}, {"text": "You might want to consider using a Map instead or building a custom object where you store name and location and than put that object into an array or List", "label": {"api": {"Map": [[35, 37]]}}}, {"text": "In case of a web application, the Webcontainer might have set some SecurityManager (https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html) to block write access to the local file system", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html": [[84, 155]]}}}, {"text": "You can also configure the Connection when you open it using DriverManager.getConnection(String, Properties) by using the Properties argument", "label": {"api": {"DriverManager.getConnection(String, Properties)": [[61, 107]]}}}, {"text": "As k/K/h/H influence a too, now everything might work with ssa", "label": {"api": {"k/K/h/H": [[3, 9]]}}}, {"text": "There's no join method on arrays, instead you can use the stream API's joining collector", "label": {"api": {"joining": [[71, 77]]}}}, {"text": "Rather than removing things from the queue until you find one that meets your criteria, you can use the iterator to search", "label": {"api": {"iterator": [[104, 111]]}}}]