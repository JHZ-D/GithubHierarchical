[{"text": "Understand that the iterator will not return items in any particular order, so if you want the smallest item that's greater than or equal to some value, you still have to iterate over the entire collection", "label": {"api": {"iterator": [[20, 27]]}}}, {"text": "An alternative is to change both to lowerCase or upperCase and then compare", "label": {"api": {"lowerCase": [[36, 44]], "upperCase": [[49, 57]]}}}, {"text": "Consider to use RecursiveTask or RecursiveAction in conjunction with ForkJoinPool", "label": {"api": {"RecursiveTask": [[16, 28]], "RecursiveAction": [[33, 47]], "ForkJoinPool": [[69, 80]]}}}, {"text": "If you peek into the java-doc you'll actually see that nextInt() returns int as the method name suggests", "label": {"api": {"java-doc": [[21, 28]], "nextInt()": [[55, 63]]}}}, {"text": "In your specific example, the value returned from nextInt() is widened to a double as every int can fit into a double type", "label": {"api": {"nextInt()": [[50, 58]]}}}, {"text": "You can create a Filter that changes the request URL from /index.html to /dev/index.html or /prod/index.html as needed", "label": {"api": {"Filter": [[17, 22]]}}}, {"text": "Of course there is another way, you can get the source of the event with EventObject.getSource", "label": {"api": {"EventObject.getSource": [[73, 93]]}}}, {"text": "Collections.sort() accepts a List, but you are trying to pass a Set to it, thus an error occurs", "label": {"api": {"Collections.sort()": [[0, 17]]}}}, {"text": "According to the example given in the question, it's better to use a TreeSet", "label": {"api": {"TreeSet": [[69, 75]]}}}, {"text": "TreeSet elements will be ordered according to the Book.compareTo(...) method implementation", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "What you are looking for is java.rmi.MarshalledObject", "label": {"api": {"java.rmi.MarshalledObject": [[28, 52]]}}}, {"text": "Java memory visibility documentation says that", "label": {"api": {"memory visibility documentation": [[5, 35]]}}}, {"text": "Your Set does not implement the java.util.Collection interface", "label": {"api": {"java.util.Collection interface": [[32, 61]]}}}, {"text": "ElementType specifies the target of the annotation, which can be the following", "label": {"api": {"ElementType": [[0, 10]]}}}, {"text": "The last thing we have to do is to implement the validation itself which implies creating a class which implements ConstraintValidator interface", "label": {"api": {"ConstraintValidator": [[115, 133]]}}}, {"text": "An easier way to do this would be to use a HashMap and store the integer as the key and the String as the value", "label": {"api": {"HashMap": [[43, 49]]}}}, {"text": "You're missing a return statement for the function (player) -> {...} but if you don't want to return a value then use the Consumer interface", "label": {"api": {"Consumer": [[122, 129]]}}}, {"text": "That said, I'd recommend using the interfaces already in place instead of creating your own exact copy of them", "label": {"api": {"interfaces already in place": [[35, 61]]}}}, {"text": "Convert the strings to integers and compare them with Integer.compare or similar", "label": {"api": {"Integer.compare": [[54, 68]]}}}, {"text": "Since you operate at compile-time, you cannot necessarily rely on Class instances", "label": {"api": {"Class": [[66, 70]]}}}, {"text": "Instead, there is another representation for compile-time types, called TypeMirror", "label": {"api": {"TypeMirror": [[72, 81]]}}}, {"text": "We can get the TypeMirror of an Element through Element#asType()", "label": {"api": {"TypeMirror": [[15, 24]], "Element": [[32, 38], [48, 54]], "Element#asType()": [[48, 63]]}}}, {"text": "There is no way to obtain a Class object from a TypeMirror for the aforementioned reason", "label": {"api": {"Class": [[28, 32]], "TypeMirror": [[48, 57]]}}}, {"text": "In order to check whether the second argument is a String, we need to convert String.class into a TypeMirror", "label": {"api": {"TypeMirror": [[98, 107]]}}}, {"text": "Method Elements#getTypeElement(CharSequence name) gives us a TypeMirror, given a cannonical name", "label": {"api": {"TypeMirror": [[61, 70]], "Element": [[7, 13], [23, 29]], "Elements#getTypeElement(CharSequence name)": [[7, 48]]}}}, {"text": "We can get the canonical name of a Class instance through Class#getCanonicalName()", "label": {"api": {"Class": [[35, 39], [58, 62]], "Class#getCanonicalName()": [[58, 81]]}}}, {"text": "As an option, before scanning the input, you can use a Scanner.hasNextInt() method in order to check whether the input is a valid Integer", "label": {"api": {"Scanner.hasNextInt()": [[55, 74]]}}}, {"text": "The primary idea is to obtain a constructor (1), make it accessible (2) via AccessibleObject#setAccessible and invoke it (3)", "label": {"api": {"AccessibleObject#setAccessible": [[76, 105]]}}}, {"text": "You must flush() the stream before you exit the application", "label": {"api": {"flush()": [[9, 15]]}}}, {"text": "By \"content\" it most likely means the backing TextInputControl.Content and the source code of TextField seems to confirm this", "label": {"api": {"TextInputControl.Content": [[46, 69]]}}}, {"text": "Use NumberFormat#parse(String, ParsePosition)", "label": {"api": {"NumberFormat#parse(String, ParsePosition)": [[4, 44]]}}}, {"text": "Take into account that ObjectA would also inherit from 'Object' class, as by definition  it's a must by every Java object, even if you don't the call 'super()' method by yourself, it would be done behind the scenes", "label": {"api": {"'Object' class": [[55, 68]]}}}, {"text": "You could use a TreeSet", "label": {"api": {"TreeSet": [[16, 22]]}}}, {"text": "You can still (referring to @Strikeskids answer) use a TreeSet if you extend your comparison with a unique part", "label": {"api": {"TreeSet": [[55, 61]]}}}, {"text": "a) works like your constructor and the returned List<T> has methods get(int index) and set(int index, T value)", "label": {"api": {"List<T>": [[48, 54]], "get(int index)": [[68, 81]], "set(int index, T value)": [[87, 109]]}}}, {"text": "Optional, and especially its map() method, are well suited for this kind of situation", "label": {"api": {"Optional": [[0, 7]], "map()": [[29, 33]]}}}, {"text": "The (new) Java Time API can handle larger fractions of a second - and also convert easily between different time zones", "label": {"api": {"Java Time API": [[10, 22]]}}}, {"text": "We can use Class#getDeclaredFields() to get all fields as Field[]", "label": {"api": {"Class#getDeclaredFields()": [[11, 35]]}}}, {"text": "With Field#getAnnotations(), we can get all annotations of one specific field as Annotation[]", "label": {"api": {"Field#getAnnotations()": [[5, 26]]}}}, {"text": "Below is a sample implementation using Java 8 Streams and Predicates", "label": {"api": {"Streams": [[46, 52]], "Predicates": [[58, 67]]}}}, {"text": "Please keep in mind though that Collectors.toList() does not guarantee that the returned List is mutable", "label": {"api": {"Collectors.toList() does not guarantee that the returned List is mutable": [[32, 103]]}}}, {"text": "Take for example LocalDate.withYear which is an instance method which returns a new immutable LocalDate", "label": {"api": {"LocalDate.withYear": [[17, 34]]}}}, {"text": "You use a one-argument Stream.reduce(accumulator) version that has the following signature", "label": {"api": {"Stream.reduce(accumulator)": [[23, 48]]}}}, {"text": "I propose you to use a three-argument version of the Stream.reduce(...) method instead", "label": {"api": {"Stream.reduce(...)": [[53, 70]]}}}, {"text": "BufferedWriter's documentation does not describe its thread safety; the package-level documentation says nothing either", "label": {"api": {"BufferedWriter's documentation": [[0, 29]], "package-level documentation": [[72, 98]]}}}, {"text": "Put the call of reversed() inside thenComparing", "label": {"api": {"reversed()": [[16, 25]]}}}, {"text": "There are examples for this in the Java core APIs, see for example UnsupportedOperationException - this one has a slightly different meaning though, it is used for optional methods that some implementations of certain collection-types implement and some don't", "label": {"api": {"UnsupportedOperationException": [[67, 95]]}}}, {"text": "Pass and store an instance of DoubleFunction<T> in the constructor of the graph", "label": {"api": {"DoubleFunction<T>": [[30, 46]]}}}, {"text": "You might want to consider HashSet", "label": {"api": {"HashSet": [[27, 33]]}}}, {"text": "That being said, in your code you are comparing the iterator with the CourseInfo, you need to compare the element pointed by the iterator instead by using next()", "label": {"api": {"next()": [[155, 160]]}}}, {"text": "Also, next() is required in order to advance the iterator (thanks to Code-Apprentice for the suggestion) otherwise you could end up in an infinite loop in i.hasNext()", "label": {"api": {"next()": [[6, 11]]}}}, {"text": "To get a path relative to other path import use relativize of java Path", "label": {"api": {"Path": [[67, 70]]}}}, {"text": "parseHexBinary is documented to take the input as defined by xsd:hexBinary", "label": {"api": {"parseHexBinary is documented": [[0, 27]]}}}, {"text": "The method Long.numberOfLeadingZeros(long i) can be used for that", "label": {"api": {"Long.numberOfLeadingZeros(long i)": [[11, 43]]}}}, {"text": "According to the Javadoc for java.lang.ProcessBuilder", "label": {"api": {"java.lang.ProcessBuilder": [[29, 52]]}}}, {"text": "For your specific problem, I really suggest refactoring your solution to use the Java Semaphore class", "label": {"api": {"Java Semaphore class": [[81, 100]]}}}, {"text": "You could try to benefit from otherwise discouraged side-effects", "label": {"api": {"side-effects": [[52, 63]]}}}, {"text": "And here is a workaround using AtomicInteger which allows you to continue the streaming after performing the map(..)", "label": {"api": {"AtomicInteger": [[31, 43]]}}}, {"text": "The simplest fix is to use replace() instead of replaceAll()", "label": {"api": {"replace()": [[27, 35]], "replaceAll()": [[48, 59]]}}}, {"text": "replace() replaces all occurences of the given plain text", "label": {"api": {"replace()": [[0, 8]]}}}, {"text": "replaceAll() replaces all occurences of the given regex", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "Since some of your replacements have special meaning in regex (specifically the dot ., which means any character), you cant use replaceAll() as you are currently (you'd have to escape the dot)", "label": {"api": {"replaceAll()": [[128, 139]]}}}, {"text": "It's common, and quite reasonable, to assume that replace() replaces one occurrence and replaceAll() replaces all occurrences", "label": {"api": {"replace()": [[50, 58]], "replaceAll()": [[88, 99]]}}}, {"text": "Executing long running task in the EDT is generally a bad idea - use SwingWorker instead  ,see example Improve Application Performance With SwingWorker", "label": {"api": {"SwingWorker": [[69, 79], [140, 150]]}}}, {"text": "The class java.sql.ConnectionBuilder exists since Java 9, so my best guess is that running in JDK 9 or higher triggers some new Spring mechanism", "label": {"api": {"java.sql.ConnectionBuilder": [[10, 35]]}}}, {"text": "A use-case for Math.hypot", "label": {"api": {"Math.hypot": [[15, 24]]}}}, {"text": "You need to escape all regex metacharacters (in this case $, { and }) (try using http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#quote(java.lang.String) ) or use a different method that substitutes a string for a string, not a regex for a string", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#quote(java.lang.String)": [[81, 173]]}}}, {"text": "Your are violating the contract of filter by passing an interfering predicate", "label": {"api": {"contract of filter": [[23, 40]]}}}, {"text": "You can use isFocusOwner()", "label": {"api": {"isFocusOwner()": [[12, 25]]}}}, {"text": "this should be settable in NumberFormat  with setMaximumIntegerDigits, because you can associate a customized format with a formatted text field by using the JFormattedTextField constructor that takes a Format as an argument", "label": {"api": {"NumberFormat": [[27, 38]], "setMaximumIntegerDigits": [[46, 68]], "JFormattedTextField": [[158, 176]]}}}, {"text": "Collections is a collection of static methods, that operate or return an object of type Collection", "label": {"api": {"Collections": [[0, 10]], "Collection": [[0, 9], [88, 97]]}}}, {"text": "Collection  represents a group of objects, known as its elements", "label": {"api": {"Collection": [[0, 9]]}}}, {"text": "As per the KeyStore JavaDocs", "label": {"api": {"KeyStore JavaDocs": [[11, 27]]}}}, {"text": "You don't add newly created MenuItem to the Menu", "label": {"api": {"MenuItem": [[28, 35]], "Menu": [[28, 31], [44, 47]]}}}, {"text": "Create a temporary variable to let insert the newly created MenuItem", "label": {"api": {"MenuItem": [[60, 67]], "Menu": [[60, 63]]}}}, {"text": "Alternatively, you might want to store these created MenuItem to a separate List and handle them later", "label": {"api": {"MenuItem": [[53, 60]], "Menu": [[53, 56]]}}}, {"text": "This feature is not a responsibility of LocalDate class which is an immutable date-time object that represents a date", "label": {"api": {"LocalDate": [[40, 48]]}}}, {"text": "To generate or parse strings, use the DateTimeFormatter class", "label": {"api": {"DateTimeFormatter": [[38, 54]]}}}, {"text": "Back to LocalDate, use the same pattern", "label": {"api": {"LocalDate": [[8, 16]]}}}, {"text": "But the new dateParsed will again be converted to its default String representation since LocalDate overrides toString() method", "label": {"api": {"LocalDate": [[90, 98]], "toString()": [[110, 119]]}}}, {"text": "To sort ascending, you may simply call the reversed version of your Comparator", "label": {"api": {"reversed": [[43, 50]]}}}, {"text": "scheduleAtFixedRate takes a TimerTask as it's first parameter", "label": {"api": {"scheduleAtFixedRate": [[0, 18]], "TimerTask": [[28, 36]]}}}, {"text": "You're passing it a TextTimer, which is presumably not a TimerTask", "label": {"api": {"TimerTask": [[57, 65]]}}}, {"text": "You can split the string by line breaks", "label": {"api": {"split": [[8, 12]]}}}, {"text": "String[] values = paths.split(\"\\n\")", "label": {"api": {"split": [[24, 28]]}}}, {"text": "One way to skip the case sensitivity of the String is to use equalsIgnoreCase which basically compares two Strings, ignoring case considerations", "label": {"api": {"equalsIgnoreCase": [[61, 76]]}}}, {"text": "Another way is to capitalize the status before comparison by using toUpperCase() method, something like this", "label": {"api": {"toUpperCase()": [[67, 79]]}}}, {"text": "But what if I use AtomicInteger - does it make any difference and is it a good and safe way with no side effects compared to the previous one", "label": {"api": {"AtomicInteger": [[18, 30]]}}}, {"text": "Please, don't match AtomicInteger with multi-threading issue", "label": {"api": {"AtomicInteger": [[20, 32]]}}}, {"text": "KeyFrame has a constructor that can accept event handler", "label": {"api": {"KeyFrame": [[0, 7]]}}}, {"text": "To change colors add a event handler to the (last) KeyFrame", "label": {"api": {"KeyFrame": [[51, 58]]}}}, {"text": "Subclasses of Application can override the getClasses() to register a set of root resource, provider and feature classes used by the application", "label": {"api": {"Class": [[46, 50]]}}}, {"text": "Set<Class<?>> means a Set that holds Classes of unknown types (it's expressed by the", "label": {"api": {"Class": [[4, 8], [37, 41]]}}}, {"text": "There's the isAnonymousClass method on Class, so", "label": {"api": {"isAnonymousClass method": [[12, 34]]}}}, {"text": "Writers are used for writing characters, not bytes", "label": {"api": {"Writer": [[0, 5]]}}}, {"text": "To write bytes, you should use some flavor of OutputStream", "label": {"api": {"OutputStream": [[46, 57]]}}}, {"text": "See Writer or OutputStream", "label": {"api": {"Writer": [[4, 9]], "OutputStream": [[14, 25]]}}}, {"text": "But if all you want is to write a byte array to a file, Files class provides a  Files.write method that does just that", "label": {"api": {"Files.write": [[80, 90]]}}}, {"text": "You can loop through every Map in the List and get the entrySet of each, something like this", "label": {"api": {"entrySet": [[55, 62]]}}}, {"text": "Moreover, if you want a particular Key itself in the Map at a particular index in the List, you can create a method and use the keySet like this for example", "label": {"api": {"keySet": [[128, 133]]}}}, {"text": "You can look at the inferred generic type using by using the function getGenericSuperclass and then getActualTypeArguments Here's an example", "label": {"api": {"getGenericSuperclass": [[70, 89]], "getActualTypeArguments": [[100, 121]]}}}, {"text": "Let us take a look at the definition of Stream#toArray(...)", "label": {"api": {"definition of Stream#toArray(...)": [[26, 58]]}}}, {"text": "In Double object documentation it only have two constructors, one taking a double value and one taking a string value", "label": {"api": {"Double object documentation": [[3, 29]]}}}, {"text": "PropertySources are loaded with java.util.ServiceLoader, so you need to define it according to the specs documented at https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html": [[119, 188]]}}}, {"text": "To do that use a SwingWorker", "label": {"api": {"SwingWorker": [[17, 27]]}}}, {"text": "Once you did, you can create multiple SwingWorkers to do the work", "label": {"api": {"SwingWorker": [[38, 48]]}}}, {"text": "java.awt.Robot has a method called createScreenCapture that will give you a BufferedImage of an arbitrary rectangle on the screen", "label": {"api": {"createScreenCapture": [[35, 53]]}}}, {"text": "The textbook solution would probably be to use the setCharacterStream method instead", "label": {"api": {"setCharacterStream": [[51, 68]]}}}, {"text": "It becomes a Predicate<String>", "label": {"api": {"Predicate<String>": [[13, 29]]}}}, {"text": "In that case, use Function<String, String>", "label": {"api": {"Function<String, String>": [[18, 41]]}}}, {"text": "ResultSetMetaData provides SQL types and java class names", "label": {"api": {"ResultSetMetaData": [[0, 16]]}}}, {"text": "A bit detective job - you have to click through the source codes of LinkedList<E> which extends AbstractSequentialList<E> which extends AbstractList<E> which finally extends AbstractCollection<E> (source code) class where is overridden Object::toString method responsible for the String-alike representation of all the element", "label": {"api": {"LinkedList<E>": [[68, 80]], "AbstractSequentialList<E>": [[96, 120]], "AbstractList<E>": [[136, 150]]}}}, {"text": "Note that the read() method you used returns a byte, not a char, so calling write((char) c) should have been just write(c)", "label": {"api": {"read()": [[14, 19]], "write(c)": [[114, 121]]}}}, {"text": "In arrays you use the [] operator to index an element in the array, and the parallel operations using ArrayList are get and set", "label": {"api": {"get": [[116, 118]], "set": [[124, 126]]}}}, {"text": "You need to split String to characters and a Map<Character, Integer> you will store these characters and their number of occurrences", "label": {"api": {"Map<Character, Integer>": [[45, 67]]}}}, {"text": "I suggest you use LinkedHashMap<Character, Integer> which assures the order of the insertion", "label": {"api": {"Map<Character, Integer>": [[28, 50]], "LinkedHashMap<Character, Integer>": [[18, 50]]}}}, {"text": "According to the Java documentation for File class", "label": {"api": {"documentation for File class": [[22, 49]]}}}, {"text": "If you are using Swing, try method javax.swing.JList#getSelectedValue to get value from JList object", "label": {"api": {"javax.swing.JList#getSelectedValue": [[35, 68]]}}}, {"text": "If you want them to exit gracefully you will have to implement a shutdown hook and use the Process.waitFor to wait  until the external process has terminated", "label": {"api": {"shutdown hook": [[65, 77]], "Process.waitFor": [[91, 105]]}}}, {"text": "In alternative you could destroy the external processes with Process.destroy which is Java implementation dependent", "label": {"api": {"Process.destroy": [[61, 75]]}}}, {"text": "I also tried to generate unique keys using UUID Class but is more easy for me to use only numbers for my recipes", "label": {"api": {"UUID Class": [[43, 52]]}}}, {"text": "You can just set the frame's contentpane to the panel that you want to draw, with JFrame.setContentPane()", "label": {"api": {"JFrame.setContentPane()": [[82, 104]]}}}, {"text": "The first question you linked suggests using Class.getResource(\"/images/yourImageName.extension\");", "label": {"api": {"Class.getResource(\"/images/yourImageName.extension\");": [[45, 97]]}}}, {"text": "In your case, you probably need the closely related Class.getResourceAsStream(\"/images/yourImageName.extension\"); which returns a InputStream which you can then pass to BufferedReader and the rest of your logic to read the file can be the same", "label": {"api": {"Class.getResourceAsStream(\"/images/yourImageName.extension\");": [[52, 112]]}}}, {"text": "In this case, and as per documentation, allMatch returns a boolean, and thus final execution of your stream is required to calculate that boolean", "label": {"api": {"allMatch": [[40, 47]]}}}, {"text": "This is the point also where you provide a Predicate limiting your resulting Stream", "label": {"api": {"Predicate": [[43, 51]]}}}, {"text": "This is a short-circuiting terminal operation", "label": {"api": {"short-circuiting terminal operation": [[10, 44]]}}}, {"text": "Stream::generate(Supplier<T> s) says that it returns", "label": {"api": {"Stream::generate(Supplier<T> s)": [[0, 30]], "Supplier<T>": [[17, 27]]}}}, {"text": "3rd dot of Stream package documentation", "label": {"api": {"3rd dot": [[0, 6]]}}}, {"text": "As long as the execution inside the supplied Supplier<T>, the stream pipeline continues", "label": {"api": {"Supplier<T>": [[45, 55]]}}}, {"text": "The much simpler and straightforward way would be to use BufferedReader's method lines() which gives you a finite Stream of the lines coming from the buffered reader", "label": {"api": {"BufferedReader's method lines()": [[57, 87]]}}}, {"text": "As Turing85 noted in the comments (and later in a full-fledged answer), Java's java.util.UUID class implements RFC 4122", "label": {"api": {"java.util.UUID": [[79, 92]]}}}, {"text": "Rather than using an InvalidationListener use a javafx.beans.value.ChangeListener", "label": {"api": {"javafx.beans.value.ChangeListener": [[48, 80]]}}}, {"text": "You can probably use HttpUrlConnection to make put request to your artifactory instance", "label": {"api": {"HttpUrlConnection": [[21, 37]]}}}, {"text": "Given a Consumer<String> fn, you can call the referenced method with fn.accept(\"abc\")", "label": {"api": {"fn.accept(\"abc\")": [[69, 84]]}}}, {"text": "findAny() takes no argument - so you typically use it on a stream that has a filter to check if there are any elements left after filtering", "label": {"api": {"findAny() takes no argument": [[0, 26]]}}}, {"text": "But for your use case, it would make more sense to use anyMatch instead", "label": {"api": {"to use anyMatch instead": [[48, 70]]}}}, {"text": "Another possibility is to use Files.write() if all data can be written in one operation", "label": {"api": {"Files.write()": [[30, 42]]}}}, {"text": "You could try using Map with handles unique values", "label": {"api": {"Map": [[20, 22]]}}}, {"text": "This method works in the same manner as the AsynchronousByteChannel.write(ByteBuffer) method, except that bytes are written starting at the given file position", "label": {"api": {"AsynchronousByteChannel.write(ByteBuffer)": [[44, 84]]}}}, {"text": "So it says it behaves just like AsynchronousByteChannel.write(ByteBuffer) which redirects you to Future<Integer> write(ByteBuffer src)", "label": {"api": {"AsynchronousByteChannel.write(ByteBuffer)": [[32, 72]], "Future<Integer> write(ByteBuffer src)": [[97, 133]]}}}, {"text": "A solution using  java 8 IntStream", "label": {"api": {"IntStream": [[25, 33]]}}}, {"text": "The key with the StampedLock class is that the readLock() is not exclusive, whereas the writeLock() is exclusive", "label": {"api": {"StampedLock": [[17, 27]]}}}, {"text": "The best idea I've seen is to use a FileChannel to map the serialized object into memory using an always persistent JVM and then have the second JVM read from that FileChannel to deserialize the object", "label": {"api": {"FileChannel": [[36, 46], [164, 174]]}}}, {"text": "You should write an annotation processor", "label": {"api": {"annotation processor": [[20, 39]]}}}, {"text": "An annotation processor can generate new Java files and, more relevantly for your case, issue compile-time warnings", "label": {"api": {"annotation processor": [[3, 22]]}}}, {"text": "If regular javac or your annotation processor issues any warnings, then compilation fails", "label": {"api": {"annotation processor": [[25, 44]]}}}, {"text": "Your annotation processor's logic is specific to your @Annotate annotation and is simple", "label": {"api": {"annotation processor": [[5, 24]]}}}, {"text": "However, you may do it", "label": {"api": {"you may do it": [[9, 21]]}}}, {"text": "That said you're looking for this overload of reduce", "label": {"api": {"this overload of reduce": [[29, 51]]}}}, {"text": "You can use a positive lookbehind and a positive lookahead (find \"lookahead\" and \"lookbehind\" on the linked page)", "label": {"api": {"a positive lookbehind and a positive lookahead": [[12, 57]]}}}, {"text": "A more concise alternative would be to use a PrintWriter with auto-flush", "label": {"api": {"PrintWriter with auto-flush": [[45, 71]]}}}, {"text": "You need call shutdown explictly to terminate the threads in the pool", "label": {"api": {"shutdown": [[14, 21]]}}}, {"text": "After this, the jvm can shutdown", "label": {"api": {"shutdown": [[24, 31]]}}}, {"text": "Read the value from the file only once and initialize it to an AtomicInteger", "label": {"api": {"AtomicInteger": [[63, 75]]}}}, {"text": "Strings are compared lexicographical (colloquially alphabetically), not numerically", "label": {"api": {"compared lexicographical": [[12, 35]]}}}, {"text": "If you want to compare the numerical values you'll need to parse the strings into numbers, for instance with Double.valueOf()", "label": {"api": {"Double.valueOf()": [[109, 124]]}}}, {"text": "What is the equivalent of File.createNewFile() in java.nio.file API (Java 7+)", "label": {"api": {"File.createNewFile()": [[26, 45]], "java.nio.file": [[50, 62]]}}}, {"text": "All actual file operations are in the Files class", "label": {"api": {"in the Files class": [[31, 48]]}}}, {"text": "In that case you need to use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[29, 41]]}}}, {"text": "Just use endsWith", "label": {"api": {"endsWith": [[9, 16]]}}}, {"text": "Note that the ConcurrentHashMap Javadoc explicitly states that this is atomic", "label": {"api": {"the ConcurrentHashMap Javadoc explicitly states": [[10, 56]]}}}, {"text": "I think that class ProcessBuilder would be better idea, you can put arguments and control process and this is preferred way by Oracle since 1.5", "label": {"api": {"ProcessBuilder": [[19, 32]]}}}, {"text": "Note, BTW, that ArrayDeque is a Collection, so you could use the much more elegant removeIf", "label": {"api": {"removeIf": [[83, 90]]}}}, {"text": "You can use the java.nio classes in combination with Java 8's stream", "label": {"api": {"java.nio": [[16, 23]], "stream": [[62, 67]]}}}, {"text": "If you must get it into another Map, just use Map.putAll()", "label": {"api": {"Map.putAll()": [[46, 57]]}}}, {"text": "ServletOutputStream.isReady() javadoc says the following", "label": {"api": {"ServletOutputStream.isReady() javadoc says the following": [[0, 55]]}}}, {"text": "The documentation for Module.getResourceAsStream explains the encapsulation rules", "label": {"api": {"The documentation for Module.getResourceAsStream": [[0, 47]]}}}, {"text": "The only checked exception that your try block throws is not a ParseException, which is what a SimpleDateFormat would throw, but a DateTimeParseException, which is what LocalDate.parse throws, and a DateTimeParseException is not a ParseException", "label": {"api": {"LocalDate.parse": [[169, 183]], "DateTimeParseException": [[131, 152], [199, 220]]}}}, {"text": "Just catch DateTimeParseException instead", "label": {"api": {"DateTimeParseException": [[11, 32]]}}}, {"text": "InterruptedException does not extend RuntimeException, you have to handle the declared exception using the try-catch block when calling walk()", "label": {"api": {"InterruptedException": [[0, 19]]}}}, {"text": "ScheduledExecutorService is designed for this purpose", "label": {"api": {"ScheduledExecutorService": [[0, 23]]}}}, {"text": "As you can see replace() calls multiple other methods and iterates throughout the entire String, while trim() simply iterates over the beginning and ending of the String until the character isn't a white space", "label": {"api": {"replace()": [[15, 23]], "trim()": [[103, 108]]}}}, {"text": "So in the single respect of trying to only remove white space before and after a word, trim() is more efficient", "label": {"api": {"trim()": [[87, 92]]}}}, {"text": "One neat way of showing this is to print System.identityHashCode in both classes, and seeing that both the Father and the Chilld constructors relate to the same memory address", "label": {"api": {"System.identityHashCode": [[41, 63]]}}}, {"text": "a DefaultListModel and then modify the ListModel with its methods", "label": {"api": {"DefaultListModel": [[2, 17]]}}}, {"text": "You could use a HashMap", "label": {"api": {"HashMap": [[16, 22]]}}}, {"text": "Since the mnemonicParsing property is true for the item, underscores receive special treatment", "label": {"api": {"mnemonicParsing": [[10, 24]]}}}, {"text": "You can create a common close function where You just need to pass Node", "label": {"api": {"Node": [[67, 70]]}}}, {"text": "Node can be Button, ComboBox, TextField etc", "label": {"api": {"Node": [[0, 3]]}}}, {"text": "Every class has an instance of java.lang.Class that represents it in the current classloader", "label": {"api": {"java.lang.Class": [[31, 45]]}}}, {"text": "A CountDownLatch or CompletableFuture can be used to wait for a condition asynchronously", "label": {"api": {"CountDownLatch": [[2, 15]], "CompletableFuture": [[20, 36]]}}}, {"text": "We can use method List#subList(int fromIndex, int toIndex) to achieve what you want", "label": {"api": {"List#subList(int fromIndex, int toIndex)": [[18, 57]]}}}, {"text": "As another way to increment a static shared counter in multiple threads safely, you can turn to AtomicLong", "label": {"api": {"AtomicLong": [[96, 105]]}}}, {"text": "Unless you explicitly start a new thread either by instantiating one, using an executor or resorting to some third party library that does one of the two for you (such as most GUI libraries do so that the UI doesn't block the whole thing, like you said), the whole program runs on a single thread like you said", "label": {"api": {"instantiating one": [[51, 67]], "executor": [[79, 86]]}}}, {"text": "There might be non-obvious exceptions (such as using streams, which resort to a common executor) but this is the general rule", "label": {"api": {"executor": [[87, 94]], "streams": [[53, 59]]}}}, {"text": "In conjunction with the description of nextBytes which states that it constructs the target bytes array from one call to nextInt for each 4 bytes in the target byte array, this leads to different results for your code", "label": {"api": {"nextBytes": [[39, 47]]}}}, {"text": "So I build my own scripts using DatabaseMetaData [getTables()] to create the tables, without the foreign keys", "label": {"api": {"[getTables()]": [[49, 61]]}}}, {"text": "If the dataset is large it's better to read it using BufferedReader and only remember the last encountered a and x", "label": {"api": {"BufferedReader": [[53, 66]]}}}, {"text": "Allows for accessing the overall model as a java.util.Map", "label": {"api": {"java.util.Map": [[44, 56]]}}}, {"text": "You can use only one Model which contains more data distinct with a unique key because the Model is based on the java.util.Map - as the documentation says.", "label": {"api": {"java.util.Map": [[113, 125]]}}}, {"text": "Before the call to FileUtils.listFiles(), check if the root File object is actually a directory and it exists (or if it's a file but not a directory) by File.isDirectory() or File.isFile()", "label": {"api": {"File.isDirectory()": [[153, 170]], "File.isFile()": [[175, 187]]}}}, {"text": "There is a nice brief example in the documentation of ArrayStoreException", "label": {"api": {"the documentation of ArrayStoreException": [[33, 72]]}}}, {"text": "You may however be better of using a listener to the rotate property, applying localToParent as transformation and setting the properties of curve to the results provided", "label": {"api": {"localToParent": [[79, 91]]}}}, {"text": "Bindings.length returns a IntegerBinding containing the length of the sting value in a StringProperty", "label": {"api": {"Bindings.length": [[0, 14]]}}}, {"text": "You can also probably add the JFileChooser's buttons for zooming in/out as an accessory", "label": {"api": {"accessory": [[78, 86]]}}}, {"text": "You need to use a java.sql.Date", "label": {"api": {"java.sql.Date": [[18, 30]]}}}, {"text": "This is actually pretty common, and even the JDK has such methods - consider, e.g., List#get", "label": {"api": {"List#get": [[84, 91]]}}}, {"text": "If you want to use Thread.currentThread() you can inspect the thread's stack trace, which will allow you to determine what's running", "label": {"api": {"stack trace": [[71, 81]]}}}, {"text": "If your methods have no arguments, consider using Runnable or Callable to wrap your methods", "label": {"api": {"Runnable": [[50, 57]], "Callable": [[62, 69]]}}}, {"text": "Runnable has no return value, and Callable has a return value", "label": {"api": {"Runnable": [[0, 7]], "Callable": [[34, 41]]}}}, {"text": "You can also use Pattern.DOTALL mode as well", "label": {"api": {"Pattern.DOTALL": [[17, 30]]}}}, {"text": "You need to at least call getResponseCode()", "label": {"api": {"getResponseCode()": [[26, 42]]}}}, {"text": "I suggest you to avoid reading input in that way, use Scanner instead", "label": {"api": {"Scanner": [[54, 60]]}}}, {"text": "You could use a intermediate helper method, which accepts a Supplier<R> but no input", "label": {"api": {"Supplier<R>": [[60, 70]]}}}, {"text": "To call your REST service from your GWT app you can either use relative URLs or you determine the context path at runtime on server side (see ServletContext.getContextPath()) and pass this path to your GWT application (e.g", "label": {"api": {"ServletContext.getContextPath()": [[142, 172]]}}}, {"text": "Because generics do not work with primitives, and objects cannot be compared with greater-than and less-than operators, we must instead restrict the input types to Comparables (things which can be compared) so that we can use the compareTo method instead", "label": {"api": {"Comparables": [[164, 174]], "compareTo": [[230, 238]]}}}, {"text": "will autobox the primitives to Integers (which do implement Comparable<Integer>) and return 2", "label": {"api": {"Integers": [[31, 38]]}}}, {"text": "Java doesn't have operator overloading, but the equivalent would be to limit the code to Ts that implement the Comparable interface", "label": {"api": {"Comparable": [[111, 120]]}}}, {"text": "Or, alternatively, allow the caller to pass a custom Comparator", "label": {"api": {"Comparator": [[53, 62]]}}}, {"text": "The snippet uses Class#getDeclaredField(String) as suggested by @aszro in the comments", "label": {"api": {"Class#getDeclaredField(String)": [[17, 46]]}}}, {"text": "See javadoc of SecurityManager.checkExec​(String cmd) for description of permission check", "label": {"api": {"SecurityManager.checkExec​(String cmd)": [[15, 52]]}}}, {"text": "To respond to your comment, using a method which returns other than a URL solves your problem - see Reading a resource file from within jar", "label": {"api": {"URL": [[70, 72]]}}}, {"text": "You can use the JAX-RS's UriBuilder", "label": {"api": {"UriBuilder": [[25, 34]]}}}, {"text": "Arrays already have a method binarySearch you can just use", "label": {"api": {"Arrays": [[0, 5]], "binarySearch": [[29, 40]]}}}, {"text": "Create a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[9, 29]]}}}, {"text": "Encapsulate the ByteArrayOutputStream in an ObjectOutputStream", "label": {"api": {"ByteArrayOutputStream": [[16, 36]], "ObjectOutputStream": [[44, 61]]}}}, {"text": "Write all the attributes in the ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[32, 49]]}}}, {"text": "Use the method toByteArray() to convert all the attributes into bytes", "label": {"api": {"toByteArray()": [[15, 27]]}}}, {"text": "For example you can use Arrays#hashCode(…) for the simplest solution, or use MessageDigest for a better solution", "label": {"api": {"Arrays#hashCode(…)": [[24, 41]], "MessageDigest": [[77, 89]]}}}, {"text": "java.net.URLConnection has been a part of Java since Java 1.0 and (without knowing why you're trying to shell out for this) it's almost definitely the right tool here", "label": {"api": {"java.net.URLConnection": [[0, 21]]}}}, {"text": "Whenever you want to mix 2D and 3D (and camera) you have to use a SubScene container for the 3D content", "label": {"api": {"container": [[75, 83]]}}}, {"text": "If you have a BorderPane container, you can perfectly add the subScene to its center", "label": {"api": {"container": [[25, 33]]}}}, {"text": "Thus, you should verify that the markSupported() method of the InputStream returned by classLoader.getResourceAsStream() actually returns true", "label": {"api": {"markSupported() method": [[33, 54]]}}}, {"text": "Looking into AbstractJDBCTestElement.setArgument() function I fail to see Types.Array clause so my expectation is that you not be able to implement this using built-in JMeter JDBC Test Elements", "label": {"api": {"Types.Array": [[74, 84]]}}}, {"text": "You acquire and release ReentrantLock with lock() and unlock(), not with synchronized", "label": {"api": {"lock()": [[43, 48], [56, 61]], "unlock()": [[54, 61]]}}}, {"text": "A monitor is released when leaving a synchronized block or method or when a thread holding the monitor wait()s on it, but notify() and notifyAll() do not release the monitor", "label": {"api": {"wait()s": [[103, 109]], "notify()": [[122, 129]], "notifyAll()": [[135, 145]]}}}, {"text": "It might be wise to place a call to onSpinWait outside the synchronized block but inside the while loop in the consumer, in Java 9 or later", "label": {"api": {"onSpinWait": [[36, 45]]}}}, {"text": "In earlier versions, yield might be appropriate", "label": {"api": {"yield": [[21, 25]]}}}, {"text": "Because a LinkedBlockingDeque is a concurrent data structure we don't need any synchronized blocks or wait or notify here", "label": {"api": {"LinkedBlockingDeque": [[10, 28]]}}}, {"text": "There are ways you could achieve that, either by introducing wait() and notify() again, by using Semaphores, or other means, but I'll leave that be since it isn't clear you even wanted it", "label": {"api": {"notify()": [[72, 79]]}}}, {"text": "Check out Java hashCode() on Wikipedia and public int hashCode() in Oracle's documentation to learn how to implement a \"hashable\" object", "label": {"api": {"public int hashCode()": [[43, 63]]}}}, {"text": "The Bindings.createDoubleBinding method takes, in addition to its Callable<Double>, a vararg of Observable representing the dependencies of the binding", "label": {"api": {"Bindings.createDoubleBinding": [[4, 31]]}}}, {"text": "Use a Writer to write text files", "label": {"api": {"Writer": [[6, 11]]}}}, {"text": "Better yet, use a PrintWriter", "label": {"api": {"Writer": [[23, 28]], "PrintWriter": [[18, 28]]}}}, {"text": "TextArea.getParagraphs returns a list containing a String for every line", "label": {"api": {"TextArea.getParagraphs": [[0, 21]]}}}, {"text": "The \"%,d\" part you are trying to print is no ordinary String, it is part of the Formatter", "label": {"api": {"Formatter": [[80, 88]]}}}, {"text": "In order to see what it does we need to take a look at the Formatter docs", "label": {"api": {"Formatter": [[59, 67]]}}}, {"text": "That means that the Formatter takes an integer and displays that according to your desired format", "label": {"api": {"Formatter": [[20, 28]]}}}, {"text": "I have tried using AttributeOverride on MyEntity, but it doesn't do anything", "label": {"api": {"AttributeOverride": [[19, 35]]}}}, {"text": "It would work if I would move the AttributeOverride annotation on the embedded field, but I cannot modify the superclass", "label": {"api": {"AttributeOverride": [[34, 50]]}}}, {"text": "I have a problem when I try to implement a thenApply() method which takes a Function as parameter, similar to what CompletableFuture has and therefore returns a promise with another type", "label": {"api": {"CompletableFuture": [[115, 131]]}}}, {"text": "The version of executeQuery accepting a string is a holdover from Statement (API design problem)", "label": {"api": {"Statement": [[66, 74]]}}}, {"text": "You want the one without parameters, which is provided by PreparedStatement", "label": {"api": {"Statement": [[66, 74]], "provided by PreparedStatement": [[46, 74]]}}}, {"text": "You want Regular Expressions and the Java Pattern class (https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html": [[57, 126]]}}}, {"text": "Would Thread.sleep() be more efficient than Thread.onSpinWait​()", "label": {"api": {"Thread.sleep()": [[6, 19]], "Thread.onSpinWait​()": [[44, 63]]}}}, {"text": "I get the feeling that I am misusing the CompletableFuture API", "label": {"api": {"CompletableFuture": [[41, 57]]}}}, {"text": "When invoking CompletableFuture.exceptionally() I routinely find myself needing to invoke another asynchronous process, which means that exceptionally() returns CompletableFuture<CompletableFuture<T>> instead of CompletableFuture<T>", "label": {"api": {"CompletableFuture": [[14, 30], [161, 177], [179, 195], [212, 228]]}}}, {"text": "I want each section to take care of converting its own return type from a CompletableFuture to a synchronous value", "label": {"api": {"CompletableFuture": [[74, 90]]}}}, {"text": "PatternSyntaxException is a RuntimeException which is thrown when there's any syntax error in regex", "label": {"api": {"PatternSyntaxException": [[0, 21]]}}}, {"text": "Thus here you are catching PatternSyntaxException because you are explicitly throwing PatternSyntaxException here", "label": {"api": {"PatternSyntaxException": [[27, 48], [86, 107]]}}}, {"text": "The specification of notify() says", "label": {"api": {"The specification of notify()": [[0, 28]]}}}, {"text": "hasNextDouble returns false if the next token can't be interpreted as a double, so you can break that loop by entering something that's not a number", "label": {"api": {"hasNextDouble": [[0, 12]]}}}, {"text": "You should open the device before using it", "label": {"api": {"open": [[11, 14]]}}}, {"text": "It has a constructor where you can specify the initial capacity you need so with ArrayLists it will look like", "label": {"api": {"constructor": [[9, 19]]}}}, {"text": "Or better yet - use the modern Files#lines", "label": {"api": {"Files#lines": [[31, 41]]}}}, {"text": "This sounds like the use of a ReadWriteLock would be appropiate", "label": {"api": {"ReadWriteLock": [[30, 42]]}}}, {"text": "Because of this, an IndexOutOfBoundsException is thrown", "label": {"api": {"IndexOutOfBoundsException": [[20, 44]]}}}, {"text": "You can parse string to object them format it with DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[51, 67]]}}}, {"text": "Note that Locale has 3 constructors", "label": {"api": {"Locale": [[10, 15]], "3 constructors": [[21, 34]]}}}, {"text": "You can also use the Locale.forLanguageTag(String languageTag) method", "label": {"api": {"Locale": [[21, 26]], "Locale.forLanguageTag(String languageTag)": [[21, 61]]}}}, {"text": "There is no method for getting a Locale from a \"fr_FR\" string (with '_' separator), which means that the string returned by toString() cannot be used to re-create the Locale", "label": {"api": {"Locale": [[33, 38], [167, 172]], "toString()": [[124, 133]]}}}, {"text": "You must use toLanguageTag() to get a string for that purpose", "label": {"api": {"toLanguageTag()": [[13, 27]]}}}, {"text": "You should use System.getenv(), for example", "label": {"api": {"System.getenv()": [[15, 29]]}}}, {"text": "This is totally different from what you might get with log.info(String.format(\"The value is", "label": {"api": {"format": [[71, 76]]}}}, {"text": "I don't really need to know what the right format is, so much as WHY the format for log messages in Slf4j is NOT the same as the format for java.lang.String#format and whether that's actually still a valid reason in Java, what, 10", "label": {"api": {"format": [[43, 48], [73, 78], [129, 134], [157, 162]]}}}, {"text": "For starting an external process java platform gives you an java.lang.ProcessBuilder", "label": {"api": {"java.lang.ProcessBuilder": [[60, 83]]}}}, {"text": "Also there is a possible alternative CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[37, 56]]}}}, {"text": "Looks like you need to use ExecutorService#shutdownNow in case you don't want to wait and finish all the work and you'll receive a list with the tasks that weren't executed", "label": {"api": {"ExecutorService#shutdownNow": [[27, 53]]}}}, {"text": "You may use ExecutionService#awaitTermination (with different parameters than 45 seconds) if you want/need to provide a time to wait for the tasks to finish", "label": {"api": {"ExecutionService#awaitTermination": [[12, 44]]}}}, {"text": "You should be able to use invokeAndWait for this", "label": {"api": {"invokeAndWait": [[26, 38]]}}}, {"text": "invokeAndWait already implements this for you, though, so it should work", "label": {"api": {"invokeAndWait": [[0, 12]]}}}, {"text": "Since Java 7 you can use the walkTreeFile() to control how deep you want to go down the tree, and what to do with each file you found (with an appropriate FileVisitor)", "label": {"api": {"walkTreeFile()": [[29, 42]], "FileVisitor": [[155, 165]]}}}, {"text": "When you call ZipInputStream.getNextEntry() it positions the stream at the start of the next entry of data, in this case you want the data when it's a sub zip file", "label": {"api": {"ZipInputStream.getNextEntry()": [[14, 42]]}}}, {"text": "Aside from the check-and-fix (so add the protocol from code if it is missing) approach shown in the other answer already, I would point at openStream()", "label": {"api": {"openStream()": [[139, 150]]}}}, {"text": "If you want to translate a double to 64-bits, you can use long Double.doubleToLongBits(double value), and double Double.longBitsToDouble(long bits) to convert it back", "label": {"api": {"long Double.doubleToLongBits(double value)": [[58, 99]], "double Double.longBitsToDouble(long bits)": [[106, 146]]}}}, {"text": "If you want to convert 32-bit values to Float values and back, the corresponding functions are floatToIntBits(...) and intBitsToFloat(...)", "label": {"api": {"Float": [[40, 44], [128, 132]]}}}, {"text": "Unpacking, use a DataInputStream and readFloat()", "label": {"api": {"Float": [[41, 45]]}}}, {"text": "GridPane allows you to specify row and column indices for it's children", "label": {"api": {"GridPane": [[0, 7]]}}}, {"text": "VBox/HBox allow you to place nodes next to each other vertically/horizontally", "label": {"api": {"VBox": [[0, 3]], "HBox": [[5, 8]]}}}, {"text": "AnchorPane allows you to specify distances from the sides where a node should be placed", "label": {"api": {"AnchorPane": [[0, 9]]}}}, {"text": "Depending on your required constraints a AnchorPane containing (possibly nested) HBoxes and VBoxes could reproduce the desired layout, but using GridPane, if it works for you, is much simpler", "label": {"api": {"GridPane": [[145, 152]], "VBox": [[92, 95]], "HBox": [[81, 84]], "AnchorPane": [[41, 50]]}}}, {"text": "Both can be done using String.split", "label": {"api": {"String.split": [[23, 34]]}}}, {"text": "Calling javafx.concurrent.Service.cancel() will cancel any currently running Task, making it throw an InterruptedException", "label": {"api": {"javafx.concurrent.Service.cancel()": [[8, 41]]}}}, {"text": "If additional cleanup is required one can provide Task.onCancelled() event handler", "label": {"api": {"Task.onCancelled()": [[50, 67]]}}}, {"text": "You're using Thread.sleep() to simulate calculations, but calling Future.cancel() when inside Thread.sleep() terminates the task immediately because Future.cancel() calls Thread.interrupt() inside, and Thread.sleep() checks for interruption flag, which you most likely don't do in your real code", "label": {"api": {"Thread.sleep()": [[13, 26], [94, 107], [202, 215]], "Future.cancel()": [[66, 80], [149, 163]]}}}, {"text": "In the original MCVE, I wasn't able to reproduce the behavior even after replacing Thread.sleep() with a loop", "label": {"api": {"Thread.sleep()": [[83, 96]]}}}, {"text": "I propose that you forgo cancelation completely, and instead use a simple volatile field to store the value of the last selected item", "label": {"api": {"volatile": [[74, 81]]}}}, {"text": "JDBC driver needs to implement java.sql.Driver interface (e.g", "label": {"api": {"java.sql.Driver": [[31, 45]]}}}, {"text": "JDBC 4.0 uses Service Provider mechanism to locate JDBC drivers without doing reflection directly", "label": {"api": {"Service Provider": [[14, 29]]}}}, {"text": "To remove the currently traversed element from the underlying collection use Iterator.remove() method e.g", "label": {"api": {"Iterator.remove()": [[77, 93]]}}}, {"text": "The optional true argument sets the file writer to append mode", "label": {"api": {"append mode": [[51, 61]]}}}, {"text": "If you want to read a file you can use the Scanner class", "label": {"api": {"Scanner": [[43, 49]]}}}, {"text": "Then access it via ClassLoader.getResourceAsStream", "label": {"api": {"ClassLoader.getResourceAsStream": [[19, 49]]}}}, {"text": "Note that ExecutorService.awaitTermination doesn't throw an exception if it times out; it just returns false", "label": {"api": {"ExecutorService.awaitTermination": [[10, 41]]}}}, {"text": "String.chars() returns a stream of the chars in the String", "label": {"api": {"String.chars()": [[0, 13]]}}}, {"text": "Stream.reduce() reduces the values inside the stream down to one single value, using 0 as identity value and the lambda expression (runningSum,c) -> runningSum * 10 + c -'0' as accumulator", "label": {"api": {"Stream.reduce()": [[0, 14]]}}}, {"text": "The lambda expression (runningSum,c) -> runningSum * 10 + c -'0' gets turned into a BinaryOperator instance by the Java compiler", "label": {"api": {"BinaryOperator": [[84, 97]]}}}, {"text": "Please see https://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html and the static block in the source code of DriverManager class at https://github.com/JetBrains/jdk8u_jdk/blob/master/src/share/classes/java/sql/DriverManager.java", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html": [[11, 79]]}}}, {"text": "The method Collectors.toCollection takes a Supplier that returns the desired Collection, not the Collection itself", "label": {"api": {"Collectors.toCollection": [[11, 33]], "Supplier": [[43, 50]], "Collection": [[24, 33], [77, 86], [97, 106]], "Collector": [[11, 19]]}}}, {"text": "Then in order to collect them into a SortedSet via Streams you could do", "label": {"api": {"SortedSet": [[37, 45]], "Stream": [[51, 56]]}}}, {"text": "Note that I don't use Stream.sorted here", "label": {"api": {"Stream": [[22, 27]], "Stream.sorted": [[22, 34]]}}}, {"text": "It is actually detrimental if you were to use Stream.sorted because it adds work that doesn't help the end result", "label": {"api": {"Stream": [[46, 51]], "Stream.sorted": [[46, 58]]}}}, {"text": "The Stream would sort its elements and then later start adding them to the TreeSet which will also sort the elements", "label": {"api": {"Stream": [[4, 9]], "TreeSet": [[75, 81]]}}}, {"text": "That said, there are cases where using Stream.sorted would be beneficial", "label": {"api": {"Stream": [[39, 44]], "Stream.sorted": [[39, 51]]}}}, {"text": "when Stream.collect returns a Collection that guarantees insertion order", "label": {"api": {"Collection": [[30, 39]], "Stream": [[5, 10]], "Stream.collect": [[5, 18]]}}}, {"text": "A LinkedHashSet, as well as any implementation of List, guarantee insertion order", "label": {"api": {"LinkedHashSet": [[2, 14]], "List": [[50, 53]]}}}, {"text": "It is not enough that the end Collection guarantees insertion order", "label": {"api": {"Collection": [[30, 39]]}}}, {"text": "The Collector being used must not have unordered as a characteristic", "label": {"api": {"Collector": [[4, 12]], "unordered": [[39, 47]], "characteristic": [[54, 67]]}}}, {"text": "This is the case with the Collectors returned by Collectors.toCollection and Collectors.toList", "label": {"api": {"Collectors.toCollection": [[49, 71]], "Collection": [[62, 71]], "List": [[90, 93]], "Collector": [[26, 34], [49, 57], [77, 85]], "Collectors.toList": [[77, 93]]}}}, {"text": "It is not the case when using Collectors.toSet", "label": {"api": {"Collector": [[30, 38]], "Collectors.toSet": [[30, 45]]}}}, {"text": "groupingBy will do the job if you help it", "label": {"api": {"groupingBy": [[0, 9]]}}}, {"text": "you might find an equivalent version of this in the Javadoc for groupingBy", "label": {"api": {"groupingBy": [[64, 73]]}}}, {"text": "You don't need a separate remove and contains call for a correctly-implemented collection", "label": {"api": {"for a correctly-implemented collection": [[51, 88]]}}}, {"text": "The only solution I've been able to find is to override Component.contains(int,int) to return false (described here, shown here), but why that works and doesn't seem to break anything else is mysterious", "label": {"api": {"Component.contains(int,int)": [[56, 82]]}}}, {"text": "Also, since you use inheritIO(), there is no output to copy, so getInputStream() is a null input stream", "label": {"api": {"null input stream": [[86, 102]]}}}, {"text": "To load a regular file use the FileInputStream or the Files utility class", "label": {"api": {"Files": [[54, 58]]}}}, {"text": "To send a POST request using JAX-RS Client, you call buildPost(Entity<?> entity), where entity is the POST content", "label": {"api": {"Client": [[36, 41]], "buildPost(Entity<?> entity)": [[53, 79]], "Entity": [[63, 68]]}}}, {"text": "The Entity has many useful helper methods, e.g", "label": {"api": {"Entity": [[4, 9]]}}}, {"text": "createBufferStrategy returns void (or, well, doesn't return anything)", "label": {"api": {"createBufferStrategy": [[0, 19]]}}}, {"text": "If you don't want to do it that way and accept everything it comes in the url string, then I recommend you using split method", "label": {"api": {"split method": [[113, 124]]}}}, {"text": "Use the cell factory to define the rendering behavior of the cell", "label": {"api": {"cell factory": [[8, 19]]}}}, {"text": "The cell value factory only defines the populating behavior", "label": {"api": {"cell value factory": [[4, 21]]}}}, {"text": "The first code snippet uses Instream.range to generate the indices of the source array, then within the mapToObj operation it skips the necessary amount of elements and retains only the necessary amount of elements", "label": {"api": {"Instream.range": [[28, 41]], "mapToObj": [[104, 111]]}}}, {"text": "Then with map we join the elements in each group as well as calculating the summation of them and then as for getting it in the format we want, finally, we join the strings with the joining collector", "label": {"api": {"joining": [[182, 188]]}}}, {"text": "The second code snippet does the same but instead of joining the strings with the joining collector, simply prints them to the console", "label": {"api": {"joining": [[53, 59], [82, 88]]}}}, {"text": "In Java System.nanoTime()'s monotonic implementation on Linux relies on the fact that CLOCK_MONOTONIC is available on the OS", "label": {"api": {"System.nanoTime()": [[8, 24]]}}}, {"text": "Questions like this discuss the limitations to the logic used by the String::trim method", "label": {"api": {"String::trim": [[69, 80]]}}}, {"text": "The “not allowed” system cursor will be used by default, if your dragOver handler does not call DragEvent.acceptTransferModes", "label": {"api": {"dragOver handler": [[65, 80]], "DragEvent.acceptTransferModes": [[96, 124]]}}}, {"text": "Is there any way to use System.currentTimeMillis() as utility in thymeleaf", "label": {"api": {"System.currentTimeMillis()": [[24, 49]]}}}, {"text": "Is there any way to access System.currentTimeMillis() utility without having custom dialect utility/expression", "label": {"api": {"System.currentTimeMillis()": [[27, 52]]}}}, {"text": "Calling toUri() on a Path yields the URI you want", "label": {"api": {"toUri()": [[8, 14]], "Path": [[21, 24]]}}}, {"text": "If you can't or don't want to for whatever reason, then you can convert a File into a Path using File.toPath() (and vice versa using Path.toFile())", "label": {"api": {"Path": [[86, 89], [104, 107], [133, 136]], "File.toPath()": [[97, 109]], "Path.toFile()": [[133, 145]]}}}, {"text": "Flush the output by calling PrintStream#flush after printing the data, or change the constructor arguments to auto-flush", "label": {"api": {"change the constructor arguments to auto-flush": [[74, 119]]}}}, {"text": "Alternatively consider using an AtomicLong instead, in this example you might not need the synchronized keyword (depending on what the code in //..", "label": {"api": {"AtomicLong": [[32, 41]]}}}, {"text": "Methods like addAndGet perform their changes to the value stored atomically", "label": {"api": {"addAndGet": [[13, 21]]}}}, {"text": "If you have an extreme large number of users ,you may want to use HashMap", "label": {"api": {"HashMap": [[66, 72]]}}}, {"text": "You can use Set to add the elements and check whether its unique", "label": {"api": {"Set": [[12, 14]]}}}, {"text": "Everytime when you add the element in the Set using add function if the same element is added again, it will return true", "label": {"api": {"Set": [[42, 44]]}}}, {"text": "As per Math.sin's documentation, its argument should be given in radians, no degrees", "label": {"api": {"Math.sin": [[7, 14]]}}}, {"text": "You can use Math.toRandians to convert those degrees to Randians", "label": {"api": {"Math.toRandians": [[12, 26]]}}}, {"text": "Note this class has to implement ConstraintValidator<A extends Annotation, T>", "label": {"api": {"ConstraintValidator<A extends Annotation, T>": [[33, 76]]}}}, {"text": "Otherwise, they might be confused with InputStream, String, File, Serializable etc", "label": {"api": {"InputStream": [[39, 49]], "String": [[52, 57]], "File": [[60, 63]], "Serializable": [[66, 77]]}}}, {"text": "The java.sql.Connection interface does not have a method to start a transaction", "label": {"api": {"java.sql.Connection interface": [[4, 32]]}}}, {"text": "the javadoc of javax.mail.Folder", "label": {"api": {"javax.mail.Folder": [[15, 31]]}}}, {"text": "A TreeSet is an implementation of Set, which explicitly forbids duplicate entries by design", "label": {"api": {"Set": [[6, 8], [34, 36]]}}}, {"text": "ArrayList), and sort it at the end by calling Collections.sort(myList, Comparator.comparing(myData -> myData.ExpDtTm));", "label": {"api": {"Collections.sort(myList, Comparator.comparing(myData -> myData.ExpDtTm));": [[46, 118]]}}}, {"text": "You can make it ThreadLocal", "label": {"api": {"ThreadLocal": [[16, 26]]}}}, {"text": "You could even use IntStream.of and avoid boxing the values even once", "label": {"api": {"IntStream.of": [[19, 30]]}}}, {"text": "To put data into the database the Hibernate way use the EntityManager interface", "label": {"api": {"EntityManager": [[56, 68]]}}}, {"text": "You need to use a ZoneId appropriate to the region (you may try with ZoneId.systemDefault() for a start)", "label": {"api": {"ZoneId": [[18, 23], [69, 74]], "ZoneId.systemDefault()": [[69, 90]]}}}, {"text": "If you don't want to use Stream API you can use a HashSet (or other collections that implement the Set interface)", "label": {"api": {"HashSet": [[50, 56]], "Set": [[54, 56], [99, 101]]}}}, {"text": "I want to have this same function, except in the form of a Java Functional Interface", "label": {"api": {"Java Functional Interface": [[59, 83]]}}}, {"text": "You can use String::chars to get an IntStream from the word, then map each int to a String and collect with a joining collector", "label": {"api": {"String::chars": [[12, 24]], "IntStream": [[36, 44]], "joining collector": [[110, 126]]}}}, {"text": "Since the Conversation class doesn't implement the Serializable interface as well the static analyzers usually complain that all the fields must be either Serializable or transient even if the class is never explicitly serialized or deserialized", "label": {"api": {"Serializable": [[51, 62], [155, 166]]}}}, {"text": "If you plan, make Conversation implement Serializable and treat its fields in the same way", "label": {"api": {"Serializable": [[41, 52]]}}}, {"text": "In Java the main way to make code work in parallel is to create a Thread with a new Runnable as a constructor parameter", "label": {"api": {"Thread": [[66, 71]], "Runnable": [[84, 91]]}}}, {"text": "You then need to start it", "label": {"api": {"start": [[17, 21]]}}}, {"text": "The removeIf method should do the trick", "label": {"api": {"removeIf": [[4, 11]]}}}, {"text": "I have a problem like the one exposed at JavaFX indeterminate progress bar while doing a process , but I use a javafx dialog Alert in order to show a dialog with inside a progress bar using a code like this", "label": {"api": {"javafx dialog Alert": [[111, 129]]}}}, {"text": "That's because you are not following JDK documentation guidelines, from Comprarable", "label": {"api": {"Comprarable": [[72, 82]]}}}, {"text": "It's the behavior of Map::put(K key, V value) method", "label": {"api": {"Map::put(K key, V value)": [[21, 44]]}}}, {"text": "Now the NavigableMap::headMap(K toKey, boolean inclusive) which returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey (taken from the documentation)", "label": {"api": {"NavigableMap::headMap(K toKey, boolean inclusive)": [[8, 56]]}}}, {"text": "You are getting a Property, and more precisely an ObjectProperty", "label": {"api": {"Property": [[18, 25], [56, 63]], "ObjectProperty": [[50, 63]]}}}, {"text": "To get the value, just call get()", "label": {"api": {"get()": [[28, 32]]}}}, {"text": "Here's a small example using Stream.generate (also an infinite stream) which shows this order of operations", "label": {"api": {"Stream.generate": [[29, 43]]}}}, {"text": "Also, some streams such as those created using a Stream.Builder will require a data structure to put their elements in", "label": {"api": {"Stream.Builder": [[49, 62]]}}}, {"text": "Note also the alternative .filter(Predicate.isEqual(aIDetailsDto.getResult().getIdNo())), which will also evaluate the argument expression only once, but is the only variant handling the case that it evaluated to null, by then accepting  onlynull elements (see Predicate.isEqual(…))", "label": {"api": {"Predicate.isEqual(…)": [[261, 280]]}}}, {"text": "To add this array elements into a Map, you just need to use a loop to iterate over all the key, value pairs and add them to the a Map", "label": {"api": {"Map": [[34, 36], [130, 132]]}}}, {"text": "From the documentation of Format Strings for String#format", "label": {"api": {"String#format": [[45, 57]]}}}, {"text": "Also your current approach can be simplified using the Stream.peek() method", "label": {"api": {"Stream.peek()": [[55, 67]]}}}, {"text": "Stream::count is the terminal operation which closes the Stream, so no more pipelines can proceed", "label": {"api": {"Stream::count": [[0, 12]], "terminal": [[21, 28]]}}}, {"text": "Yet, you might achieve the same result with Stream::peek which works the same like Stream::forEach with an exception that it doesn't close the Stream but returns the same unmodified one (@Lino was faster)", "label": {"api": {"Stream::peek": [[44, 55]]}}}, {"text": "Stream::flatMap returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element (from the documentation)", "label": {"api": {"Stream::flatMap": [[0, 14]]}}}, {"text": "If your system supports it, you can use the AWT Robot class, i.e", "label": {"api": {"Robot": [[48, 52]]}}}, {"text": "its method createScreenCapture to create a screenshot", "label": {"api": {"createScreenCapture": [[11, 29]]}}}, {"text": "implementing a custom Composite, recording the incoming data, but it would be much more complicated to implement than using Robot and undergo the same restrictions, i.e", "label": {"api": {"Robot": [[124, 128]]}}}, {"text": "There is its variation called BiConsumer<T, U> which turns 2 inputs into void", "label": {"api": {"BiConsumer<T, U>": [[30, 45]]}}}, {"text": "What you are looking for is the Consumer", "label": {"api": {"Consumer": [[32, 39]]}}}, {"text": "Just use Files.copy()", "label": {"api": {"Files.copy()": [[9, 20]]}}}, {"text": "If so, you should be able to get what you are looking for using request.getQueryString()", "label": {"api": {"request.getQueryString()": [[64, 87]]}}}, {"text": "From the ResultSet javadoc", "label": {"api": {"ResultSet javadoc": [[9, 25]]}}}, {"text": "Using removeIf can be easy in java 8 as follows", "label": {"api": {"removeIf": [[6, 13]]}}}, {"text": "getVirtualServerName has been added in ServletContext in Servlet 3.1", "label": {"api": {"getVirtualServerName": [[0, 19]]}}}, {"text": "Please, take a careful look at the PathSegment documentation", "label": {"api": {"PathSegment documentation": [[35, 59]]}}}, {"text": "The matrix parameters are stored in MultivaluedMap", "label": {"api": {"MultivaluedMap": [[36, 49]]}}}, {"text": "Its only implementation is MultivaluedHashMap", "label": {"api": {"MultivaluedHashMap": [[27, 44]]}}}, {"text": "You can use Runtime.exec to execute net use \\\\192.168.0.7\\Share\\photos your-password /user:your-domain\\your-user-name /persistent:yes /savecred", "label": {"api": {"Runtime.exec": [[12, 23]]}}}, {"text": "For sanity purposes, I would recommend using deleteOnExit(); as you create files and directories", "label": {"api": {"as you create files and directories": [[61, 95]]}}}, {"text": "What you could do is write an agent which calls Security.setProperty() (at JVM startup) invoked by a -javaagent commandline option", "label": {"api": {"an agent": [[27, 34]]}}}, {"text": "From DataLine.stop()'s javadoc", "label": {"api": {"DataLine.stop()'s javadoc": [[5, 29]]}}}, {"text": "Make use of Map.computeIfAbsent()", "label": {"api": {"Map.computeIfAbsent()": [[12, 32]]}}}, {"text": "The Math.random() method generates a number in the range [0, 1)", "label": {"api": {"Math.random() method": [[4, 23]]}}}, {"text": "In Java 8+ you can use Files.find()", "label": {"api": {"Files.find()": [[23, 34]]}}}, {"text": "You can also use a PathMatcher which supports glob and regex matching", "label": {"api": {"PathMatcher": [[19, 29]], "glob and regex matching": [[46, 68]]}}}, {"text": "Actually in java 7 or above you can just use the Files to achieve the folder moving even there is a conflict, which means the target folder already exists", "label": {"api": {"Files": [[49, 53]]}}}, {"text": "If you truely want something minimalistic, have a look at Java's ServiceLoader class", "label": {"api": {"ServiceLoader": [[65, 77]]}}}, {"text": "If the stream is unordered, you'll have to order the stream by ways like Stream.sorted()", "label": {"api": {"Stream.sorted()": [[73, 87]]}}}, {"text": "Use the static method Array.asList(T...a) from java.util.Arrays package", "label": {"api": {"java.util.Arrays": [[47, 62]]}}}, {"text": "The problem is that Integer.toHexString(int) drops the leading zero if the (unsigned) byte value is 15 or less", "label": {"api": {"Integer.toHexString(int)": [[20, 43]]}}}, {"text": "Specifically for ResultSet.getType(), the returned value of 1003 is the value of constant ResultSet.TYPE_FORWARD_ONLY (see this documentation page for the values)", "label": {"api": {"ResultSet.getType()": [[17, 35]], "ResultSet.TYPE_FORWARD_ONLY": [[90, 116]], "this documentation page": [[123, 145]]}}}, {"text": "Float.POSITIVE_INFINITY is a static field on the Float class, true", "label": {"api": {"Float.POSITIVE_INFINITY": [[0, 22]]}}}, {"text": "I have the use case, where I want to bind multiple ObservableValues onto one Observable, as I am actually not interested, what the value change is, I only need a means to get notified when it changes", "label": {"api": {"Observable": [[51, 60], [77, 86]]}}}, {"text": "So this is the Observable binding, I came up", "label": {"api": {"Observable": [[15, 24]]}}}, {"text": "However when I handle the BooleanBinding from above as ObservableValue, I can add a ChangeListener", "label": {"api": {"Observable": [[55, 64]]}}}, {"text": "The InvalidationListener is only called once, when the Observable becomes invalid, it then does not change back to valid, so that it could become valid again", "label": {"api": {"Observable": [[55, 64]]}}}, {"text": "With a ChangeListener however the new value is forced to be computed, hence the ObservableValue becomes valid again", "label": {"api": {"Observable": [[80, 89]]}}}, {"text": "Based on this observation, is there any use case where I actually can use an Observable", "label": {"api": {"Observable": [[77, 86]]}}}, {"text": "options in Introduction to FXML | JavaFX 10", "label": {"api": {"Introduction to FXML | JavaFX 10": [[11, 42]]}}}, {"text": "I was also having issues using the DefaultProperty annotation as well for some reason", "label": {"api": {"DefaultProperty": [[35, 49]]}}}, {"text": "System.out.println(Object) method will be called, so according to doc", "label": {"api": {"System.out.println(Object)": [[0, 25]]}}}, {"text": "You can use InputStream.available(), like this", "label": {"api": {"InputStream.available()": [[12, 34]]}}}, {"text": "It doesn't work because Instant expects the input to be in UTC", "label": {"api": {"Instant": [[24, 30]]}}}, {"text": "Use OffsetDateTime to parse your string", "label": {"api": {"OffsetDateTime": [[4, 17]]}}}, {"text": "Then adjust into UTC by extracting an Instant", "label": {"api": {"Instant": [[38, 44]]}}}, {"text": "So, you are essentially getting the default value of DAY_OF_WEEK which is 7 (reference) - also the value of dow variable, therefore dow - 1 will always be 6 and dows.get(6) will always return SATURDAY", "label": {"api": {"reference": [[77, 85]]}}}, {"text": "You can replace your entire program with a few lines that use ProcessBuilder", "label": {"api": {"ProcessBuilder": [[62, 75]]}}}, {"text": "The other solution that requires Java 8 is not applicable for me also as my current min API is 25 but ChronoUnit requires API 26", "label": {"api": {"ChronoUnit": [[102, 111]]}}}, {"text": "We want to use the new compute function from ConcurrentHashMap which is only available from java 8", "label": {"api": {"compute function": [[23, 38]]}}}, {"text": "Hmm, maybe I am missing something here, but if you iterate all completables and call their CompletableFuture#get then by definition you will finish the iteration when all futures have completed", "label": {"api": {"CompletableFuture#get": [[91, 111]]}}}, {"text": "Since you are just converting from int to a new type T, why don't you just try to pass in a lambda functional interface to do the conversion as follows", "label": {"api": {"functional interface": [[99, 118]]}}}, {"text": "Better have some provision to delete temp files, for instance creating them in a specific directory, see Files", "label": {"api": {"Files": [[105, 109]]}}}, {"text": "The readObject method in ObjectInputStream returns an Object reference to the correct type", "label": {"api": {"readObject method in ObjectInputStream": [[4, 41]]}}}, {"text": "If you must make it generic, then you must have a type witness, a Class, which can perform the dynamically typed cast for you, so that the type can be checked at compile time by the compiler and at run time by Class.cast", "label": {"api": {"Class.cast": [[210, 219]]}}}, {"text": "You can achieve that with the static String.format method", "label": {"api": {"String.format": [[37, 49]]}}}, {"text": "ByteBuffer says that it could be either direct or non-direct", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "Here we are using a BufferedReader", "label": {"api": {"BufferedReader": [[20, 33]]}}}, {"text": "Or is the entire file loaded in-memory and then read line-by-line by BufferedReader", "label": {"api": {"BufferedReader": [[69, 82]]}}}, {"text": "This will be controversial, but I would use peek()", "label": {"api": {"peek()": [[44, 49]]}}}, {"text": "IMO, this use case invalidates many of the arguments against using peek() for state modification, since it's essentially side-effect free (assuming elements are no longer accessible from the stream source)", "label": {"api": {"peek()": [[67, 72]]}}}, {"text": "It definitely complies with the only strict requirement of non-interference", "label": {"api": {"non-interference": [[59, 74]]}}}, {"text": "You can make use of Pattern.quote() if you find this easier to read", "label": {"api": {"Pattern.quote()": [[20, 34]]}}}, {"text": "Also Byte is an object in the Java API and byte is an primitive type (See this)", "label": {"api": {"Java API": [[30, 37]]}}}, {"text": "But the use of peek in productive code is a bit controversial", "label": {"api": {"peek": [[15, 18]]}}}, {"text": "Since getNodeValue() returns null in case it encounters an XML element", "label": {"api": {"getNodeValue()": [[6, 19]]}}}, {"text": "In the Java world, assuming DOM means W3C DOM, you have two options, either create a default Transformer https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/Transformer.html with TransformerFactory.newInstance() and use it to feed your DOM node as a DOMSource to the transform method https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/Transformer.html#transform-javax.xml.transform.Source-javax.xml.transform.Result, with a proper Result like a StreamResult over a StringWriter so that you can then have the result as a String", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/Transformer.html": [[105, 182], [294, 371]], "https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/Transformer.html#transform-javax.xml.transform.Source-javax.xml.transform.Result": [[294, 435]]}}}, {"text": "Or use the LSSerializer https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/LSSerializer.html which has a method writeToString https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/LSSerializer.html#writeToString-org.w3c.dom.Node-", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/LSSerializer.html": [[24, 97], [132, 205]], "https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/LSSerializer.html#writeToString-org.w3c.dom.Node-": [[132, 237]]}}}, {"text": "Creating an LSSerializer requires you to create an https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/DOMImplementationLS.html or cast a DOMImplementation to DOMImplementationLS", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/ls/DOMImplementationLS.html": [[51, 131]]}}}, {"text": "If you happen to use Java 8 then you can achieve that by using the Map.values() and Collection.removeIf()", "label": {"api": {"Map.values()": [[67, 78]], "Collection.removeIf()": [[84, 104]]}}}, {"text": "That would not break the contract of clone", "label": {"api": {"contract": [[25, 32]]}}}, {"text": "The contract is very loose", "label": {"api": {"contract": [[4, 11]]}}}, {"text": "Arrays do not implement Comparable (it would make no sense for them)", "label": {"api": {"Comparable": [[24, 33]]}}}, {"text": "In order to put anything into a TreeMap, you must either provide a Comparator for it (using this constructor), or it must implement Comparable", "label": {"api": {"Comparable": [[132, 141]], "TreeMap": [[32, 38]], "Comparator": [[67, 76]], "this constructor": [[92, 107]]}}}, {"text": "Use Java NIO's ByteBuffer and its ByteBuffer.wrap(byte[]) method (drawback", "label": {"api": {"ByteBuffer": [[15, 24], [34, 43]], "ByteBuffer.wrap(byte[])": [[34, 56]]}}}, {"text": "Create a custom (preferably immutable) wrapper over byte[], and use this class as a key for your HashMap/TreeMap (though, if you do not need sorting, do not use TreeMap for performance reasons)", "label": {"api": {"TreeMap": [[105, 111], [161, 167]]}}}, {"text": "The reason is that your key doesn't implement Comparable", "label": {"api": {"Comparable": [[46, 55]]}}}, {"text": "The advantage behind this is that you don't have to set a Comparator in each TreeMap that you will instantiate using the constructor", "label": {"api": {"TreeMap": [[77, 83]]}}}, {"text": "Consuder the use of an ExecutorService", "label": {"api": {"ExecutorService": [[23, 37]]}}}, {"text": "Add a ChangeListener to the focused property of Node (which TableView inherits)", "label": {"api": {"focused property": [[28, 43]]}}}, {"text": "Then, when the new value of said property is false, retrieve the SelectionModel from the TableView's selectionModel property and call clearSelection()", "label": {"api": {"selectionModel property": [[101, 123]], "clearSelection()": [[134, 149]]}}}, {"text": "You can use Collections.synchronizedList(list) if all you need is a simple invocation Sycnchronization", "label": {"api": {"Collections.synchronizedList(list)": [[12, 45]]}}}, {"text": "I was surprised not to see an answer involving the use of a CopyOnWriteArrayList or Guava's ImmutableList so I thought that I would add such an answer here", "label": {"api": {"CopyOnWriteArrayList": [[60, 79]]}}}, {"text": "Firstly, if your use case is such that you only have a few additions relative to many reads, consider using the CopyOnWriteArrayList to solve the concurrent list traversal problem", "label": {"api": {"CopyOnWriteArrayList": [[112, 131]]}}}, {"text": "Method synchronization could solve your issue, but CopyOnWriteArrayList will likely have better performance if the number of concurrent accesses \"vastly\" exceeds the number of writes, as per that class's Javadoc", "label": {"api": {"CopyOnWriteArrayList": [[51, 70]]}}}, {"text": "Your write_int method writes using RandomAccessFile.write(), which writes a byte to the file", "label": {"api": {"RandomAccessFile.write()": [[35, 58]]}}}, {"text": "If I am reading the documentation for ContainerRequestFilter correctly you need to add '@PreMatching' annotation to your class here", "label": {"api": {"documentation for ContainerRequestFilter": [[20, 59]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/util/Map.html but essentially, a map is a Java object which relates a \"key\" to a \"value\", and does not allow duplicates", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html": [[0, 59]]}}}, {"text": "It provides a set of serializers and deserializers for for the java.time types", "label": {"api": {"java.time": [[63, 71]]}}}, {"text": "If the SerializationFeature.WRITE_DATES_AS_TIMESTAMPS is disabled, java.time types will be serialized in standard ISO-8601 string representations", "label": {"api": {"java.time": [[67, 75]]}}}, {"text": "A non-stream approach using Map::merge", "label": {"api": {"Map::merge": [[28, 37]]}}}, {"text": "The original exception and information may be lost but the PrintWriter#checkError() method does still provide a way to check if something went wrong", "label": {"api": {"PrintWriter#checkError()": [[59, 82]]}}}, {"text": "Note that the PrintWriter#checkError() method also flushes the stream before checking if an error occured", "label": {"api": {"PrintWriter#checkError()": [[14, 37]]}}}, {"text": "First of all a huge thanks to Leviand who mentioned InputStream#available in their answer which got me something that actually appears to work", "label": {"api": {"InputStream#available": [[52, 72]]}}}, {"text": "The idea is that at the point in time I am looking for, Process#isAlive should return false as the Stream takes longer to process than the Process processes (if that makes sense) while there should be no characters readable from the InputStream, so InputStream#available should return 0", "label": {"api": {"InputStream#available": [[249, 269]]}}}, {"text": "If it is about raw speed, you can make it marginally faster by letting it create fixed-size arrays first (copyOfRange() accepts \"outlier\" to argument), and truncate the last element separately when needed, using some modulo check perhaps", "label": {"api": {"copyOfRange()": [[106, 118]]}}}, {"text": "You could use java.beans.Statement for this, which will do unboxing", "label": {"api": {"java.beans.Statement": [[14, 33]]}}}, {"text": "if you actually want to apply some merging logic in the case of a key collision and get back, as a result, a collection of services then use the toMap collector as follows", "label": {"api": {"toMap": [[145, 149]]}}}, {"text": "Either way, you would use Double.parseDouble to convert each CSV field, except the date field, which can be parsed with Instant.parse", "label": {"api": {"Double.parseDouble": [[26, 43]], "Instant.parse": [[120, 132]]}}}, {"text": "All the annotation from javax.inject which is understood as JSR330 including these named annotations is just an API, i.e", "label": {"api": {"javax.inject": [[24, 35]]}}}, {"text": "you can use the Collection::removeIf method which removes all of the elements of the source collection that satisfy the given predicate", "label": {"api": {"Collection::removeIf": [[16, 35]]}}}, {"text": "First of all, what you are doing is wrong besides the use of the Streams API or not", "label": {"api": {"Streams API": [[65, 75]]}}}, {"text": "The reassignment of values to a null is only visible inside the scope of the method, it will never leak out and that holds true either using the Streams API or not", "label": {"api": {"Streams API": [[145, 155]]}}}, {"text": "When you are confronted to mutating a source collection using the new Streams API, you simply can not, as a stream pipeline is simply a run-once pass over a data source (in your example values)", "label": {"api": {"Streams API": [[70, 80]]}}}, {"text": "Now, you are left with the other solutions, amongst them, removing manually the negative numbers through the list's iterator or use a declarative wrapper Collection#removeIf describing what elements to remove from the collection", "label": {"api": {"Collection#removeIf": [[154, 172]]}}}, {"text": "HttpServletRequest methods are listed here, but I'm not sure which can be used as properties and furthermore, how it can be (hopefully) easily shown from the template", "label": {"api": {"HttpServletRequest": [[0, 17]]}}}, {"text": "Once LoggingFeature uses Logger, the logging can be configured in the logging.properties file", "label": {"api": {"Logger": [[25, 30]]}}}, {"text": "Many usecases need this dynamic sizing behaviour, so Java has an interface for the List concept", "label": {"api": {"has an interface for the List concept": [[58, 94]]}}}, {"text": "ArrayList is one of several implementations of List, LinkedList is another", "label": {"api": {"ArrayList": [[0, 8]], "LinkedList": [[53, 62]]}}}, {"text": "The problem is Optional::orElseGet(null) which accepts a Supplier<T> and throws the NullPointerException", "label": {"api": {"Optional::orElseGet(null)": [[15, 39]], "Supplier<T>": [[57, 67]]}}}, {"text": "Use the Optional::orElse(null) which accepts T which is String in your case", "label": {"api": {"Optional::orElse(null)": [[8, 29]]}}}, {"text": "Just create an ExecutorService, and call its invokeAny method", "label": {"api": {"create an ExecutorService": [[5, 29]], "invokeAny": [[45, 53]]}}}, {"text": "If you insist on using CompletableFuture, you can use its get and cancel methods", "label": {"api": {"get": [[58, 60]], "cancel": [[66, 71]]}}}, {"text": "To do the whole thing in the background, submit the invokeAny call to the same ExecutorService, but make sure the ExecutorService is not single threaded", "label": {"api": {"invokeAny": [[52, 60]]}}}, {"text": "Executors.newFixedThreadPool(2), Executors.newWorkStealingPool(), Executors.newCachedThreadPool, or even ForkJoinPool.commonPool()", "label": {"api": {"Executors.newFixedThreadPool(2)": [[0, 30]], "Executors.newWorkStealingPool()": [[33, 63]], "Executors.newCachedThreadPool": [[66, 94]], "ForkJoinPool.commonPool()": [[105, 129]]}}}, {"text": "For the CompletableFuture approach, I just noticed that as of Java 9, CompletableFuture adds an orTimeout method", "label": {"api": {"orTimeout": [[96, 104]]}}}, {"text": "There is no need to use the method Comparator::reverse", "label": {"api": {"Comparator::reverse": [[35, 53]]}}}, {"text": "As an alternative to @Sweeper's answer, consider using the Arrays.copyOf() method, as suggested in this answer", "label": {"api": {"copyOf()": [[66, 73]]}}}, {"text": "Note that the copyOf() method is type-safe whereas the clone() method isn't", "label": {"api": {"copyOf()": [[14, 21]]}}}, {"text": "As you may know Properties Class is a file with a set of key value pairs", "label": {"api": {"Properties Class": [[16, 31]]}}}, {"text": "I would create another constructor accepting Supplier<Integer>", "label": {"api": {"Supplier<Integer>": [[45, 61]]}}}, {"text": "The method Supplier::get() returns the value", "label": {"api": {"Supplier::get()": [[11, 25]]}}}, {"text": "The List<E> extends AbstractList<E>", "label": {"api": {"List<E>": [[4, 10], [28, 34]], "AbstractList<E>": [[20, 34]]}}}, {"text": "This is supported using java.nio.file.FileSystems", "label": {"api": {"java.nio.file.FileSystems": [[24, 48]]}}}, {"text": "There Package javax.xml.stream is my favorite", "label": {"api": {"Package javax.xml.stream": [[6, 29]]}}}, {"text": "In the other answers, you can find explanation why your Comparator doesn't work - in short, your returning 1 at the end makes the Comparator inconsistent (compare(a,b) != -compare(b,a))", "label": {"api": {"Comparator": [[56, 65], [130, 139]]}}}, {"text": "Direct Comparator implementations are hard to both write and read", "label": {"api": {"Comparator": [[7, 16]]}}}, {"text": "That's why in Java 8, you can use the functional approach using various Comparator methods", "label": {"api": {"Comparator": [[72, 81]], "Comparator methods": [[72, 89]]}}}, {"text": "Translating your Comparator to the functional approach yields", "label": {"api": {"Comparator": [[17, 26]]}}}, {"text": "I believe this approach is much more readable than all the direct Comparator implementations", "label": {"api": {"Comparator": [[66, 75]]}}}, {"text": "If you wanted to achieve the same result as in Elliot's solution (which additionally sorts the strings not prefixed with \"Hi\" in a natural order), you'd need the following property1Comparator", "label": {"api": {"Comparator": [[181, 190]]}}}, {"text": "This is implemented by WeekFields.ISO", "label": {"api": {"WeekFields.ISO": [[23, 36]]}}}, {"text": "Wrap your array to ByteArrayInputStream and pass the stream to XMLInputFactory.createXMLEventReader to create SAX parser (or to any other InputStream-consuming method)", "label": {"api": {"ByteArrayInputStream": [[19, 38]]}}}, {"text": "The List#add() method returns a boolean value, which would be true if the addition were successful", "label": {"api": {"List#add()": [[4, 13]]}}}, {"text": "Spring Data class HashOperations works on the similar principle as HashMap", "label": {"api": {"HashMap": [[67, 73]]}}}, {"text": "According to the java API the Integer class implements Comparable, so why am I getting this error", "label": {"api": {"java API": [[17, 24]]}}}, {"text": "See MultiResolutionImage in Java 9", "label": {"api": {"MultiResolutionImage": [[4, 23]]}}}, {"text": "However, I would suggest to improve the rendering logic to keep the GrowableDataBuffer at a constant size by using the method GraphicsContext.drawImage(Image img, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh) which allows you to define the source and destination areas, i.e", "label": {"api": {"GraphicsContext.drawImage(Image img, double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh)": [[126, 249]]}}}, {"text": "The Object API says for hashCode()", "label": {"api": {"Object API": [[4, 13]]}}}, {"text": "If you call System.identityHashCode(map) instead of map.hashCode() you'll see the object reference does not change no matter how many times you call put on it", "label": {"api": {"System.identityHashCode(map)": [[12, 39]], "map.hashCode()": [[52, 65]]}}}, {"text": "Consider using SAXParser", "label": {"api": {"SAXParser": [[15, 23]]}}}, {"text": "It is generally better to use a SAXParser for larger files because the data is not stored in memory and discards most elements after they have been processed", "label": {"api": {"SAXParser": [[32, 40]]}}}, {"text": "Moreover, you have to call scan.nextLine(); to consume the line itself, because Scanner::nextInt doesn't terminate the line the same Scanner::nextLine does", "label": {"api": {"Scanner::nextInt": [[80, 95]], "Scanner::nextLine": [[133, 149]]}}}, {"text": "The JavaDocs on getConnectTimeout and getReadTimeout both list 0 as a return option but say nothing about -1", "label": {"api": {"getConnectTimeout": [[16, 32]], "getReadTimeout": [[38, 51]]}}}, {"text": "This uses Collections.binarySearch", "label": {"api": {"Collections.binarySearch": [[10, 33]]}}}, {"text": "The RoundingMode HALF_EVEN rounds toward the even neighbor only when the value is equidistant between possible rounding targets", "label": {"api": {"RoundingMode HALF_EVEN": [[4, 25]]}}}, {"text": "The value mapper should be a function, i.e.", "label": {"api": {"The value mapper should be a function": [[0, 36]]}}}, {"text": "You can utilise both the minusYears and minusMonth methods to do the job", "label": {"api": {"minusYears": [[25, 34]], "minusMonth": [[40, 49]]}}}, {"text": "If this not helps - instead of SpringBoot tools in this particular piece of code use pure callable statement to localize the problem", "label": {"api": {"callable statement": [[90, 107]]}}}, {"text": "Use class ProcessBuilder", "label": {"api": {"ProcessBuilder": [[10, 23]]}}}, {"text": "Runtime.exec() also works, but ProcessBuilder is better", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "With getBasicRemote() your messages are sent Synchronously", "label": {"api": {"getBasicRemote()": [[5, 20]]}}}, {"text": "With getAsyncRemote() your messages are sent Asynchronously", "label": {"api": {"getAsyncRemote()": [[5, 20]]}}}, {"text": "The way to solve this is either use a synchronization aid (maybe a CountDownLatch) which will block your main thread or rethink the sequence of events that happen in your program", "label": {"api": {"CountDownLatch": [[67, 80]]}}}, {"text": "When calling a static LocalDate.of() method you can't use the new operator", "label": {"api": {"LocalDate.of()": [[22, 35]]}}}, {"text": "You can do this with regluar expressions", "label": {"api": {"regluar expressions": [[21, 39]]}}}, {"text": "I was wondering if it's possible to rewrite nested for loops using java.utils.stream in Java 8", "label": {"api": {"java.utils.stream": [[67, 83]]}}}, {"text": "As you already knew that queue is a collection that gives us FIFO by adding (to the last) and polling (from the head/first)", "label": {"api": {"queue": [[25, 29]]}}}, {"text": "Which it also means there is no guarantee that you can use it to locate its index/position in the queue", "label": {"api": {"queue": [[98, 102]]}}}, {"text": "If you really need something like that, instead you can try List  to achieve the same effect as follows using add(E e) and remove(0) and indexOf(Object o)", "label": {"api": {"List": [[60, 63]]}}}, {"text": "However, queue implements Iterable so you could iterate over the structure", "label": {"api": {"Iterable": [[26, 33]]}}}, {"text": "You will find the @NamedQueries annotation and the others you mention(@Entity, @Table, @NamedQuery) in the java persistence api", "label": {"api": {"@NamedQueries": [[18, 30]]}}}, {"text": "Use String#replace() coupled with String#trim() to remove any uncaught white space", "label": {"api": {"String#replace()": [[4, 19]], "String#trim()": [[34, 46]]}}}, {"text": "You can use ChronoUnit.DAYS.between to calculate the number of days between the dates, then use Stream.min to get the lowest value", "label": {"api": {"Stream.min": [[96, 105]]}}}, {"text": "Thankfully that method is going away Soon™, so the likelihood of seeing leaks using that is at least a little bit reduced", "label": {"api": {"that method is going away Soon™": [[11, 41]]}}}, {"text": "The Calendar.getTime() method returns a Date object, which you then printed in your code", "label": {"api": {"Date": [[40, 43]]}}}, {"text": "The problem is that the Date class does not contain any notion of a timezone even though you had specified a timezone with the Calendar.getInstance() call", "label": {"api": {"Date": [[24, 27]]}}}, {"text": "Thus, in order to print a Date object in a specific timezone, you have to use the SimpleDateFormat class, where you must call SimpleDateFormat.setTimeZone() to specify the timezone before you print", "label": {"api": {"Date": [[26, 29], [88, 91], [132, 135]], "SimpleDateFormat": [[82, 97], [126, 141]]}}}, {"text": "This is because Date object doesn't have timezone as part of its state, and getTime() actually returns a date which corresponds to the JVM's timezone, instead you need SimpleDateFormat to format and print the date in your required timezone", "label": {"api": {"Date": [[16, 19], [174, 177]], "SimpleDateFormat": [[168, 183]]}}}, {"text": "Then, the method uses getSurplusQueuedTaskCount() to determine the number of locally enqueued tasks which have not been picked up by other worker threads", "label": {"api": {"getSurplusQueuedTaskCount()": [[22, 48]]}}}, {"text": "After the local processing, it iterates over the tasks and uses tryUnfork() to identify jobs which have not been stolen by other worker threads and process them locally", "label": {"api": {"tryUnfork()": [[64, 74]]}}}, {"text": "Since your path contain spaces (and might contain special characters too), you should consider using ProcessBuilder to construct your command", "label": {"api": {"ProcessBuilder": [[101, 114]]}}}, {"text": "Moreover, the constructor of the ProcessBuilder is the command to execute but you can also change the working directory using the directory method", "label": {"api": {"ProcessBuilder": [[33, 46]], "directory": [[110, 118], [130, 138]]}}}, {"text": "Locale.getDisplayCountry() returns the country name in a form that's appropriate to show to the user in their locale", "label": {"api": {"Locale.getDisplayCountry()": [[0, 25]]}}}, {"text": "The problem is that your calls to subList() don't create new lists", "label": {"api": {"subList()": [[34, 42]]}}}, {"text": "Using the ArrayList(Collection) constructor will create a copy of the sub-list", "label": {"api": {"ArrayList(Collection)": [[10, 30]]}}}, {"text": "OBJ.openStream(); sends a GET request (see java.net.URL.openStream), since it opens an input stream for reading the contents of that URL", "label": {"api": {"java.net.URL.openStream": [[43, 65]]}}}, {"text": "Since CapsLock needs to be polled anyway, it makes sense to use javax.swing.Timer, which both executes an action regularly and ensures that action is run in the proper thread (the AWT event dispatch thread)", "label": {"api": {"javax.swing.Timer": [[64, 80]]}}}, {"text": "The closest Java SE has to offer is ChoiceFormat", "label": {"api": {"ChoiceFormat": [[36, 47]]}}}, {"text": "The easiest way to use a ChoiceFormat is by using MessageFormat’s string representation of it", "label": {"api": {"ChoiceFormat": [[25, 36]], "MessageFormat": [[50, 62]]}}}, {"text": "The code will throw LinkageError in runtime if you use methods introduced in JDBC 4+", "label": {"api": {"LinkageError": [[20, 31]]}}}, {"text": "Using Gson library combined with java 8 Optional you can do something like this", "label": {"api": {"Optional": [[40, 47]]}}}, {"text": "The second parameter of Collectors.toMap takes a Function that takes the stream type and maps it to the value type of the new Map", "label": {"api": {"second parameter of Collectors.toMap": [[4, 39]]}}}, {"text": "The Java KeyAgreement class does support a version of generateSecret() that will return a Key object, but you have to pass the algorithm string \"TlsPremasterSecret\" (anything else will be rejected by the P11ECDHKeyAgreement class)", "label": {"api": {"version of generateSecret() that will return a Key object": [[43, 99]]}}}, {"text": "java.nio.Files.createSymbolicLink is used to create a symbolic link", "label": {"api": {"java.nio.Files.createSymbolicLink": [[0, 32]]}}}, {"text": "You can use Stream.map() method to parse the Strings then sort the list", "label": {"api": {"Stream.map() method": [[12, 30]]}}}, {"text": "Use the java.text.Normalizer class", "label": {"api": {"java.text.Normalizer": [[8, 27]]}}}, {"text": "This can be done with a Semaphore, CyclicBarrier, or Phaser", "label": {"api": {"Semaphore": [[24, 32]], "CyclicBarrier": [[35, 47]], "Phaser": [[53, 58]]}}}, {"text": "From the definition of Stream API from its package info is obvious that their usage has to be non-interfering, stateless and without side-effects - thus I can't imagine how you would achieve this using this API", "label": {"api": {"package info": [[43, 54]]}}}, {"text": "It is possible since JPA 2.1 version, please read about NamedStoredProcedureQuery anotation", "label": {"api": {"NamedStoredProcedureQuery": [[56, 80]]}}}, {"text": "But it seems to me that you use some specific JPA implementation or some framework (possibly Spring Data JPA?), because @Query annotation is not a part of JPA specification; so it's difficult to me to provide concrete code snippet for your case", "label": {"api": {"JPA specification": [[155, 171]]}}}, {"text": "The entrySet() returns a Set of Map.Entry instances", "label": {"api": {"Map.Entry": [[32, 40]]}}}, {"text": "So your lookup fails, as objects of type Map.Entry<Integer, String> can never be equal to instances of Integer", "label": {"api": {"Map.Entry": [[41, 49]]}}}, {"text": "Use the Arrays utility class", "label": {"api": {"Arrays": [[8, 13]]}}}, {"text": "You could use Comparator.comparing(Function, Comparator) like this", "label": {"api": {"Comparator.comparing(Function, Comparator)": [[14, 55]]}}}, {"text": "HashMap is the most known and common implementation of Map", "label": {"api": {"HashMap": [[0, 6]], "Map": [[4, 6], [55, 57]]}}}, {"text": "If you want to persist the order in which the elements have been put to the Map, you need to use LinkedHashMap implementation", "label": {"api": {"HashMap": [[103, 109]], "Map": [[76, 78], [107, 109]], "LinkedHashMap": [[97, 109]]}}}, {"text": "These are TitledBorders (a class implementing the Border interface", "label": {"api": {"TitledBorder": [[10, 21]]}}}, {"text": "In your example screenshot there are 2 JPanels, each with a TitledBorder", "label": {"api": {"TitledBorder": [[60, 71]]}}}, {"text": "This confusion is one of many reasons the File class is considered obsolete (though not deprecated), and has been replaced by the Path class", "label": {"api": {"Path": [[130, 133]]}}}, {"text": "One way to do this is to open a FileInputStream, wrap it in a BufferedInputStream, and use that BufferInputStream’s transferTo method", "label": {"api": {"transferTo": [[116, 125]]}}}, {"text": "You can use Character.isAlphabetic to work out whether its a special character or not", "label": {"api": {"Character.isAlphabetic": [[12, 33]]}}}, {"text": "You can use String.charAt to get the last character", "label": {"api": {"String.charAt": [[12, 24]]}}}, {"text": "To do this properly, either use threadsafe versions (see Collections.synchronizedMap or ConcurrentHashMap), or manually synchronize your checks on the same monitor", "label": {"api": {"Collections.synchronizedMap": [[57, 83]], "ConcurrentHashMap": [[88, 104]]}}}, {"text": "You can use String.replace()", "label": {"api": {"String.replace()": [[12, 27]]}}}, {"text": "System.out.println(b); prints 65 because in System.out::print(int x) the x is understood as an integer", "label": {"api": {"System.out::print(int x)": [[44, 67]]}}}, {"text": "System.out.write(b); prints A because in System.out::write(int b) the b is understood as a byte", "label": {"api": {"System.out::write(int b)": [[41, 64]]}}}, {"text": "The most readable way is Map.computeIfAbsent", "label": {"api": {"Map.computeIfAbsent": [[25, 43]]}}}, {"text": "The drop shadow has a shadow blur kernel of 10 pixels (JavaFX CSS documentation)", "label": {"api": {"JavaFX CSS documentation": [[55, 78]]}}}, {"text": "This special interface is annotated with @FunctionalInterface  and could be expressed as a lambda expression", "label": {"api": {"@FunctionalInterface": [[41, 60]]}}}, {"text": "The source is stored as Spliterator<T> in AbstractPipeline (line 123)", "label": {"api": {"Spliterator<T>": [[24, 37]]}}}, {"text": "Since you have tagged java-8 , you can make you of Optional class", "label": {"api": {"Optional": [[51, 58]]}}}, {"text": "If you write divide explicitly, it will work the same way as it does in Java", "label": {"api": {"divide": [[13, 18]]}}}, {"text": "The scale of the result is the same as the scale of this (divident), and for rounding the RoundingMode.HALF_EVEN rounding mode is used", "label": {"api": {"divide": [[58, 63]]}}}, {"text": "The Java 8 Stream.collect method has the following signature", "label": {"api": {"Stream.collect": [[11, 24]]}}}, {"text": "If you insist on using the Comparator only, use Comparator::nullsFirst instead", "label": {"api": {"Comparator::nullsFirst": [[48, 69]]}}}, {"text": "Comparator::nullsFirst returns a null-friendly comparator that considers null to be less than non-null", "label": {"api": {"Comparator::nullsFirst": [[0, 21]]}}}, {"text": "Comparator::nullsLast returns a null-friendly comparator that considers null to be greater than non-null", "label": {"api": {"Comparator::nullsLast": [[0, 20]]}}}, {"text": "Therefore you have to provide an GCMParameterSpec", "label": {"api": {"GCMParameterSpec": [[33, 48]]}}}, {"text": "BigDecimal::setScale return BigDecimal not a double, You have to use BigDecimal::doubleValue() to get the double value, like this", "label": {"api": {"BigDecimal::setScale": [[0, 19]], "BigDecimal::doubleValue()": [[69, 93]]}}}, {"text": "You can do the toArray() method", "label": {"api": {"toArray()": [[15, 23]]}}}, {"text": "ErrorType (https://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/ErrorType.html) means that some kind of class or Interface etc isn't written correctly and can't be modelled", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/ErrorType.html": [[11, 88]]}}}, {"text": "Use ListView.scrollTo for this purpose", "label": {"api": {"ListView.scrollTo": [[4, 20]]}}}, {"text": "This could for example be an ExecutorService created by one of the methods of Executors, for example Executors.newSingleThreadPool()", "label": {"api": {"Executors": [[78, 86], [101, 109]]}}}, {"text": "You could also use a ForkJoinPool, for example the common pool returned by ForkJoinPool.commonPool(), but it could also be as basic as using a lambda that creates a new thread for each runnable passed", "label": {"api": {"ForkJoinPool": [[21, 32], [75, 86]]}}}, {"text": "If you create an Executor specifically for calling abort using Executors.newSingleThreadPool(), you will need to shut it down eventually otherwise you are leaking threads, but if the abort clean up tasks asynchronously add new tasks, there is no clearly defined moment that you can shutdown the executor service (or you may have shut it down too soon)", "label": {"api": {"Executors": [[63, 71]]}}}, {"text": "From the official documentation (which you should have read btw)", "label": {"api": {"the official documentation": [[5, 30]]}}}, {"text": "I've managed to solve the problem thanks to @Slaw's suggestion (Wraping the code in a SwingWorker, a class that I did not know)", "label": {"api": {"SwingWorker": [[86, 96]]}}}, {"text": "Collectors.groupingBy() may help you", "label": {"api": {"Collectors.groupingBy()": [[0, 22]]}}}, {"text": "You can use java.util.function.Consumer", "label": {"api": {"java.util.function.Consumer": [[12, 38]]}}}, {"text": "Your conditions are avoiding x == 0 so you might be able to simplify by using 0 or absolute value with Math.abs()", "label": {"api": {"Math.abs()": [[103, 112]]}}}, {"text": "As per Creating New Arrays tutorial use the methods on java.lang.reflect.Array", "label": {"api": {"java.lang.reflect.Array": [[55, 77]]}}}, {"text": "See Using an XML Catalog with a Java library that uses JAXP internally for details on how to use a CatalogResolver (or org.apache.xml.resolver.tools.CatalogResolver)", "label": {"api": {"CatalogResolver": [[99, 113], [149, 163]]}}}, {"text": "Java provides SecureRandom class that could be initialized with byte[] array of virtually unlimited size", "label": {"api": {"SecureRandom": [[14, 25]]}}}, {"text": "You could then pass an instance of SecureRandom to Collections.shuffle to complete the task", "label": {"api": {"SecureRandom": [[35, 46]]}}}, {"text": "You can use https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A- to convert the byte array into the hexadecimal representation you're after", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary-byte:A-": [[12, 113]]}}}, {"text": "Another way of doing it is to pass your working directory as a File to the Runtime's exec method with the following signature", "label": {"api": {"exec method": [[85, 95]]}}}, {"text": "The Window.pack() method causes your frame to resize which will cause all your child elements to resize to their preferred sizes", "label": {"api": {"Window.pack() method": [[4, 23]]}}}, {"text": "A function that takes two arguments is a BiFunction", "label": {"api": {"BiFunction": [[41, 50]]}}}, {"text": "A function that takes no arguments is a Supplier", "label": {"api": {"Supplier": [[40, 47]]}}}, {"text": "I would convert both lists to a set (list1 > set1 and list2 > set2), HashSet if the order is irrelevant or TreeSet if you need the objects in order", "label": {"api": {"HashSet": [[69, 75]], "TreeSet": [[107, 113]]}}}, {"text": "Then you can simply use removeAll() items of set1 from set2, like", "label": {"api": {"removeAll()": [[24, 34]]}}}, {"text": "Scanner.hasNextLine() blocks waiting for input until either a line is available or the end of the input is reached", "label": {"api": {"Scanner.hasNextLine()": [[0, 20]]}}}, {"text": "When Thread.sleep throws InterruptedException (due to being interrupted while sleeping), it clears the interrupt flag", "label": {"api": {"Thread.sleep": [[5, 16]]}}}, {"text": "A little off-topic but if you must store unique elements, you normally go for a Set", "label": {"api": {"Set": [[80, 82]]}}}, {"text": "Pattern.compile().matcher().find() - the method Matcher::find attempts to find the next *subsequence of the input sequence that matches the pattern", "label": {"api": {"Matcher::find": [[48, 60]]}}}, {"text": "s.matches(\"^[12]|^[4]{2}\") - The method String::matches tells whether or not this string matches the given regular expression", "label": {"api": {"String::matches": [[40, 54]]}}}, {"text": "Here is the fix, create a custom TableCellEditor for all the cells that are in column 1 (Role column)", "label": {"api": {"TableCellEditor": [[33, 47]]}}}, {"text": "You might want to start with Optional instead and perform the Stream inside the Optional::map method", "label": {"api": {"Optional::map": [[80, 92]]}}}, {"text": "The simplest solution would be to use Arrays.asList + List.contains", "label": {"api": {"Arrays.asList": [[38, 50]], "List.contains": [[54, 66]]}}}, {"text": "equalsIgnoreCase is not possible here)", "label": {"api": {"equalsIgnoreCase": [[0, 15]]}}}, {"text": "The correct way to do this is with ListModel", "label": {"api": {"ListModel": [[35, 43]]}}}, {"text": "Pay close attention to the section on Creating a ListModel", "label": {"api": {"ListModel": [[49, 57]]}}}, {"text": "Every class is automatically a subclass of the Object class in Java", "label": {"api": {"Object class": [[47, 58]]}}}, {"text": "The default component used in a renderer is a JLabel, so call JLabel.setHorizontalTextPosition(SwingConstants.WHATEVER)", "label": {"api": {"JLabel.setHorizontalTextPosition(SwingConstants.WHATEVER)": [[62, 118]]}}}, {"text": "Use scale to divide BigDecimal", "label": {"api": {"divide": [[13, 18]]}}}, {"text": "Check out the Java API to understand Java classes and functions", "label": {"api": {"Java API": [[14, 21]]}}}, {"text": "A function that takes two arguments of the same type and returns an object of the same type is known as a BinaryOperator", "label": {"api": {"BinaryOperator": [[106, 119]]}}}, {"text": "Instead of expecting your classes to supply a doSomething, have them supply a BinaryOperator<Integer>", "label": {"api": {"BinaryOperator": [[78, 91]]}}}, {"text": "I then call values() (a function on HashMap that returns the values in the HashMap as a Collection) and [0] returns the first element in that Collection", "label": {"api": {"values()": [[12, 19]]}}}, {"text": "You can turn chars to strign via new String() but thats not an only error in this code", "label": {"api": {"new String()": [[33, 44]]}}}, {"text": "You should read your data with the Class.getResource or Class.getResourceAsStream method", "label": {"api": {"Class.getResource": [[35, 51], [56, 72]], "Class.getResourceAsStream": [[56, 80]]}}}, {"text": "By reading the docs of replaceAll, we can see that it does this", "label": {"api": {"replaceAll": [[23, 32]]}}}, {"text": "The word all in replaceAll kind of suggests that it does something different from Replace, but I think that's just to distinguish it from replaceFirst and replaceLast", "label": {"api": {"replaceAll": [[16, 25]]}}}, {"text": "If that is actually the case, it is an invalid regex, causing PatternSyntaxException when used", "label": {"api": {"Pattern": [[62, 68]]}}}, {"text": "Regex also uses \\ to escape special characters, as documented in the javadoc for Pattern, and it means", "label": {"api": {"Pattern": [[81, 87]]}}}, {"text": "Cloning is supported for arrays as they implement the Cloneable interface", "label": {"api": {"Cloneable": [[54, 62]]}}}, {"text": "This is because readUTF (and therefore writeUTF) may not do what you think it does; from DataInput documentation, referenced by the DataInputStream", "label": {"api": {"DataInput documentation": [[89, 111]]}}}, {"text": "If you want to work with the Person in case the List<Person> is empty, use Optional", "label": {"api": {"Optional": [[75, 82]]}}}, {"text": "Since a LocalDateTime is immutable, according to its Javadoc there is no real reason to clone it", "label": {"api": {"according to its Javadoc": [[36, 59]]}}}, {"text": "You can use java.util.Map to maintain the mapping dynamically", "label": {"api": {"java.util.Map": [[12, 24]]}}}, {"text": "or you can use Map.of() factory method", "label": {"api": {"Map.of()": [[15, 22]]}}}, {"text": "What I thought should happen is that if two threads will try to write to the db at the same time, one thread will reach the update operation before the other, the second thread should wait 10 seconds and then throw PessimisticLockException", "label": {"api": {"PessimisticLockException": [[215, 238]]}}}, {"text": "I expected that in the second request the transaction will wait until the timeout set and then throw the PessimisticLockException, but instead it deadlocks forever", "label": {"api": {"PessimisticLockException": [[105, 128]]}}}, {"text": "The method System.out::write works a bit different than System.out::println from a snippet above, because it accepts int as argument and print's its value according to the ASCII table", "label": {"api": {"System.out::write": [[11, 27]]}}}, {"text": "Or if you prefer Streams, you can use IntStream.iterate1", "label": {"api": {"IntStream.iterate": [[38, 54]]}}}, {"text": "A java-8 solution with streams, where Intstream.iterate() has the following signature with only 2 args", "label": {"api": {"Intstream.iterate()": [[38, 56]]}}}, {"text": "One approach could be you use a CountDownLatch – have the finalizer block on it and the consumer call countdown after consume()", "label": {"api": {"CountDownLatch": [[32, 45]]}}}, {"text": "submit(Callable<T> task) using Callable<T> which has method call() returning T", "label": {"api": {"submit(Callable<T> task)": [[0, 23]], "Callable<T>": [[7, 17], [31, 41]], "call()": [[60, 65]]}}}, {"text": "submit(Runnable task) usnig Runnable which has method run() returning nothing (void)", "label": {"api": {"submit(Runnable task)": [[0, 20]], "Runnable": [[7, 14], [28, 35]], "run()": [[54, 58]]}}}, {"text": "To compare, try the same with Runnable and you see it's method's return type is void", "label": {"api": {"Runnable": [[30, 37]]}}}, {"text": "The getProtocol() method of URL does what you want", "label": {"api": {"getProtocol()": [[4, 16]], "URL": [[28, 30]]}}}, {"text": "Oracle have a tutorial on parsing URLs that you might want to read too", "label": {"api": {"URL": [[34, 36]]}}}, {"text": "You can use replace", "label": {"api": {"replace": [[12, 18]]}}}, {"text": "Use replaceAll to replace [ and ] with empty string", "label": {"api": {"replaceAll": [[4, 13]]}}}, {"text": "Arrays class has a method for this", "label": {"api": {"method": [[19, 24]]}}}, {"text": "But in documentation JDK 8, it is written that default size is 21 based on 32 default capacity and load factor", "label": {"api": {"JDK 8": [[21, 25]]}}}, {"text": "The Java API documentation for the exception says", "label": {"api": {"Java API documentation for the exception": [[4, 43]]}}}, {"text": "About ArrayIndexOutOfBoundsException, you take a look here, in the documentation", "label": {"api": {"here, in the documentation": [[54, 79]]}}}, {"text": "You should be using ButtonGroup, put all of your JRadioButtons in it and then loop through buttonGroup.getElements() to find which JRadioButton is selected", "label": {"api": {"ButtonGroup": [[20, 30]]}}}, {"text": "You want to use a feature that only exists since Java 1.8 in Java 1.7", "label": {"api": {"exists since Java 1.8": [[36, 56]]}}}, {"text": "Use getDeclaredAnnotations and filter the result, e.g.", "label": {"api": {"getDeclaredAnnotations": [[4, 25]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html  <-- try ZonedDateTime or just util.Date", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html": [[0, 69]]}}}, {"text": "In this case, you can use getGenericReturnType, because the generic return type is present in the class file", "label": {"api": {"getGenericReturnType": [[26, 45]]}}}, {"text": "There isn't any API for traversing instances of java.lang.reflect.Type like a tree, but you could write one", "label": {"api": {"java.lang.reflect.Type": [[48, 69]]}}}, {"text": "Timer (Java Platform SE 7 )", "label": {"api": {"Timer (Java Platform SE 7 )": [[0, 26]]}}}, {"text": "Use the doubleValue() method of Number", "label": {"api": {"doubleValue()": [[8, 20]]}}}, {"text": "You could also simplify this with streams", "label": {"api": {"streams": [[34, 40]]}}}, {"text": "This uses Map.merge to fill the map with the count of each element", "label": {"api": {"Map.merge": [[10, 18]]}}}, {"text": "Then, Collection.removeIf is used on the values of the map, in order to remove the entries whose value is greater than 1", "label": {"api": {"Collection.removeIf": [[6, 24]]}}}, {"text": "You need to implement the Comparable interface", "label": {"api": {"Comparable": [[26, 35]]}}}, {"text": "To start with, the javadoc for WeakHashMap has the following note", "label": {"api": {"javadoc for WeakHashMap": [[19, 41]]}}}, {"text": "You should start with a loop to print rsmd.getColumnLabel(int column) for each column index", "label": {"api": {"rsmd.getColumnLabel(int column)": [[38, 68]]}}}, {"text": "However, if this is a continual process, processed in batches of 5000, where there might be rollover entries from one of the lists, use a Deque instead", "label": {"api": {"Deque": [[138, 142]]}}}, {"text": "As an alternative to @NJ's answer, you could use new Java 8 Comparator.comparing factory, where you can provide a function that extracts the values to be used when comparing objects", "label": {"api": {"Comparator.comparing": [[60, 79]]}}}, {"text": "For example, Iterable and Serializable have no superinterface at all, so there isn't one that all interfaces have in common", "label": {"api": {"Iterable": [[13, 20]], "Serializable": [[26, 37]]}}}, {"text": "For example purposes I created a simple lookup that uses System.currentTimeMillis()", "label": {"api": {"System.currentTimeMillis()": [[57, 82]]}}}, {"text": "A prominent example would be AbstractList", "label": {"api": {"AbstractList": [[29, 40]]}}}, {"text": "immutable lists introduced in Java 9), then this is useful because in case you're looping over the returned array, you would not want to process the extra elements, in which case you can stop the iterator at the first null element", "label": {"api": {"immutable lists introduced in Java 9": [[0, 35]]}}}, {"text": "Both String and Date implement the Comparable interface, so you can do something like this", "label": {"api": {"Comparable": [[35, 44]]}}}, {"text": "You could also create a Comparator", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "Also, you are creating a compareTo method without Patient implementing Comparable", "label": {"api": {"Comparable": [[71, 80]]}}}, {"text": "Then override the compareTo method declared in Comparable", "label": {"api": {"Comparable": [[47, 56]]}}}, {"text": "You would find out about this exception by using Future.get", "label": {"api": {"Future.get": [[49, 58]]}}}, {"text": "If you want to update the list in place rather than making a new list, you can use List.replaceAll", "label": {"api": {"List.replaceAll": [[83, 97]]}}}, {"text": "Use Class.getResource to access files bundled in an application", "label": {"api": {"Class.getResource": [[4, 20]]}}}, {"text": "Looking at the Javadoc of URL.toURI() you'll see", "label": {"api": {"URL.toURI()": [[26, 36]], "URI": [[32, 34]]}}}, {"text": "Returns a URI equivalent to this URL", "label": {"api": {"URI": [[10, 12]]}}}, {"text": "This method functions in the same way as new URI (this.toString())", "label": {"api": {"URI": [[45, 47]]}}}, {"text": "The method is the same as calling the URI(String) constructor which is where the possible URISyntaxException is coming from", "label": {"api": {"URI": [[38, 40], [90, 92]], "URI(String)": [[38, 48]], "URISyntaxException": [[90, 107]]}}}, {"text": "However, if you look at the URI class you'll find a static factory method", "label": {"api": {"URI": [[28, 30]]}}}, {"text": "Creates a URI by parsing the given string", "label": {"api": {"URI": [[10, 12]]}}}, {"text": "This convenience factory method works as if by invoking the URI(String) constructor; any URISyntaxException thrown by the constructor is caught and wrapped in a new IllegalArgumentException object, which is then thrown", "label": {"api": {"URI": [[60, 62], [89, 91]], "URI(String)": [[60, 70]], "URISyntaxException": [[89, 106]], "IllegalArgumentException": [[165, 188]]}}}, {"text": "This means both URL.toURI() and URI.create(String) call new URI(String)", "label": {"api": {"URL.toURI()": [[16, 26]], "URI": [[22, 24], [32, 34], [60, 62]], "URI.create(String)": [[32, 49]], "URI(String)": [[60, 70]]}}}, {"text": "The difference being that URI.create(String) throws the unchecked IllegalArgumentException which means you don't have to use try-catch blocks everywhere", "label": {"api": {"URI": [[26, 28]], "URI.create(String)": [[26, 43]], "IllegalArgumentException": [[66, 89]]}}}, {"text": "any efficient strategy must allow you to search that map (in an array/random access based approach), so maps implementing the NavigableMap, such as TreeMap will be a better choice", "label": {"api": {"TreeMap": [[148, 154]]}}}, {"text": "TreeMaps are also sorted, so you could implement some way of \"binary search\" to identify timestamps from the last n seconds", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "the low hanging fruit is to simply change from HashMap to TreeMap, with clever searching for interval boundaries", "label": {"api": {"TreeMap": [[58, 64]]}}}, {"text": "You can do what you want using Stream.flatMap(Function)", "label": {"api": {"Stream.flatMap(Function)": [[31, 54]]}}}, {"text": "This one uses the StreamSupport class and Collector interface", "label": {"api": {"StreamSupport": [[18, 30]], "Collector": [[42, 50]]}}}, {"text": "A ZipInputStream is a single stream of data, it cannot be split", "label": {"api": {"ZipInputStream": [[2, 15]]}}}, {"text": "If you want multi-threaded unzipping, you need to use ZipFile", "label": {"api": {"ZipFile": [[54, 60]]}}}, {"text": "You might also want to check out this answer, which uses FileSystem to access the zip file content, for a true Java 8 experience", "label": {"api": {"FileSystem": [[57, 66]]}}}, {"text": "If the JAR file has a main attribute Automatic-Module-Name (see Main Attributes) then the attribute's value is the module name, otherwise the module name is derived from the name of the JAR file as specified in ModuleFinder.of(Path...)", "label": {"api": {"ModuleFinder.of(Path...)": [[211, 234]]}}}, {"text": "In my opinion, the most simple way is like follows, using Lists and the Collections.shuffle() method", "label": {"api": {"Lists": [[58, 62]], "Collections.shuffle()": [[72, 92]]}}}, {"text": "Or you could implement the Initializable interface", "label": {"api": {"Initializable": [[27, 39]]}}}, {"text": "While this answer and this answer state that there are no spurious interrupts, and hence my code will never fail, the Java docs does not seem to address this", "label": {"api": {"the Java docs": [[114, 126]]}}}, {"text": "Creating threads isn't enough, you need to start them as well", "label": {"api": {"start": [[43, 47]]}}}, {"text": "The name createThreads becomes inaccurate if you both create and start threads (3) within the method", "label": {"api": {"start": [[65, 69]]}}}, {"text": "Either rename it to createAndStartThreads or create two separate methods createThreads and startThreads which is more preferable since a method should take a single responsibility", "label": {"api": {"start": [[91, 95]]}}}, {"text": "You could then use the DateTimeFormatter class to format the time into the desired format", "label": {"api": {"DateTimeFormatter": [[23, 39]]}}}, {"text": "It's called Collections.sort check it out", "label": {"api": {"check it out": [[29, 40]]}}}, {"text": "You might be interested in the summaryStatistics() method", "label": {"api": {"summaryStatistics()": [[31, 49]]}}}, {"text": "Your method could return an instance of IntSummaryStatistics to carry the minimum and maximum (and other information)", "label": {"api": {"IntSummaryStatistics": [[40, 59]]}}}, {"text": "Whether you want a ZonedDateTime, LocalDateTime, OffsetDateTime, or LocalDate, the syntax is really the same, and all revolves around applying the milliseconds to an Instant first using Instant.ofEpochMilli(m)", "label": {"api": {"ZonedDateTime": [[19, 31]], "LocalDateTime": [[34, 46]], "OffsetDateTime": [[49, 62]], "LocalDate": [[34, 42], [68, 76]], "Instant": [[166, 172], [186, 192]], "Instant.ofEpochMilli(m)": [[186, 208]]}}}, {"text": "Printing the Instant itself would produce", "label": {"api": {"Instant": [[13, 19]]}}}, {"text": "A FilteredList will update whenever it's Predicate changes or whenever it detects a change in the source ObservableList", "label": {"api": {"update": [[20, 25]]}}}, {"text": "The type of event you want to fire is an update event", "label": {"api": {"update": [[41, 46]]}}}, {"text": "This event signifies one or more elements have been updated (e.g", "label": {"api": {"update": [[52, 57]]}}}, {"text": "This factory method takes a Callback that accepts an element of the ObservableList and returns an Observable[]", "label": {"api": {"Callback": [[28, 35]]}}}, {"text": "The Observables in the array will be listened to for invalidation events and, when detected, will cause the ObservableList to fire an update change", "label": {"api": {"update": [[134, 139]]}}}, {"text": "If you want to fire updates when the status changes you should use", "label": {"api": {"update": [[20, 25]]}}}, {"text": "You can add more Observables to the array if you wish for updates to be fired for more than just changes to the status property", "label": {"api": {"update": [[58, 63]]}}}, {"text": "However, I manage to \"reverse engineer\" it from the available code and tested it using the Callback extractor", "label": {"api": {"Callback": [[91, 98]]}}}, {"text": "To avoid duplicated key problem, you can also add merge function as", "label": {"api": {"merge function": [[50, 63]]}}}, {"text": "To read a cert use java.security.cert.CertificateFactory", "label": {"api": {"java.security.cert.CertificateFactory": [[19, 55]]}}}, {"text": "(This can also handle a chain, as either just a sequence of certs which it calls PkiPath, or a (trivial) PKCS7 message which is standard and usually called p7b or p7c.) Either give it the correct PEM format, or the correct binary/DER format; the latter is easier because it is just base64-decoding the JWT x5c format (as you are now doing, before you put it in a keyspec which is wrong, but java.util.Base64.Decoder doesn't require the base64 in bytes, it can take a String)", "label": {"api": {"java.util.Base64.Decoder": [[391, 414]]}}}, {"text": "I'm trying to test each case in the ErrorListener(fatal error, error and warning), but I can't find any documentation on what causes any of them", "label": {"api": {"ErrorListener": [[36, 48]]}}}, {"text": "The code I have, uses the same ErrorListener in TransfomerFactory and in Transformer", "label": {"api": {"ErrorListener": [[31, 43]]}}}, {"text": "ZipFileSystem is an abstraction of the underlying zip file, allowing you to treat it in the same way as any other implementation of FileSystem", "label": {"api": {"FileSystem": [[3, 12], [132, 141]]}}}, {"text": "With ZipFileSystem this is the equivalent of moving a file from one directory to another, and the code works for any implementation of FileSystem", "label": {"api": {"FileSystem": [[8, 17], [135, 144]]}}}, {"text": "So ZipFileSystem provides you the benefits of higher abstraction, but has downsides such as memory usage, less control with the details of zip files and so on", "label": {"api": {"FileSystem": [[6, 15]]}}}, {"text": "I suggest using a CompletableFuture added in Java 8 and add a callback to it", "label": {"api": {"CompletableFuture": [[18, 34]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/jdk/api/jpda/jdi/com/sun/jdi/request/EventRequestManager.html can handle", "label": {"api": {"https://docs.oracle.com/javase/7/docs/jdk/api/jpda/jdi/com/sun/jdi/request/EventRequestManager.html": [[0, 98]]}}}, {"text": "To access files inside a jar file (also works outside of jar, it searches from the classpath) you can use Class.getResource() (and getResourceAsStream())", "label": {"api": {"Class.getResource()": [[106, 124]]}}}, {"text": "If all the classes have a no-arg method called run(), then make all the classes implement Runnable, and then declare Map value to be a Runnable", "label": {"api": {"Runnable": [[90, 97], [135, 142]]}}}, {"text": "If you want to defer the construction of the object until inside the loop, use a Supplier", "label": {"api": {"Supplier": [[81, 88]]}}}, {"text": "Files.newBufferedReader / Files.newBufferedWriter(f.toPath()), ...)", "label": {"api": {"newBufferedWriter": [[32, 48]]}}}, {"text": "If you look at the javadoc of newBufferedWriter you see the following", "label": {"api": {"newBufferedWriter": [[30, 46]]}}}, {"text": "If no options are present then this method works as if the CREATE, TRUNCATE_EXISTING, and WRITE options are present", "label": {"api": {"CREATE": [[59, 64]], "TRUNCATE_EXISTING": [[67, 83]], "WRITE": [[90, 94]]}}}, {"text": "In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing regular-file to a size of 0 if it exists", "label": {"api": {"regular-file": [[122, 133]]}}}, {"text": "Now if you use Files.newBufferedWriter and you just alter the OpenOption to say SYNC or something other then TRUNCATE_EXISTING, the reader is able to load the properties again regardless of which initialization comes first, e.g", "label": {"api": {"newBufferedWriter": [[21, 37]], "TRUNCATE_EXISTING": [[109, 125]], "SYNC": [[80, 83]]}}}, {"text": "The first thing you need to do is for your class to implement the Comparable Interface", "label": {"api": {"Comparable Interface": [[66, 85]]}}}, {"text": "Just using the valueMapper in Collectors.toMap to merge values in two different maps easily", "label": {"api": {"Collectors.toMap": [[30, 45]]}}}, {"text": "Later I realised that I don't know if the solution is considered as \"clean\", since using ObservaleList from the FXCollections is like using partly JavaFX but at the same time not using it", "label": {"api": {"FXCollections": [[112, 124]]}}}, {"text": "Is it ok to use FXCollections and mixing them with let's say AWT or in the Spring framework or any other framework which has nothing to do with JavaFX", "label": {"api": {"FXCollections": [[16, 28]], "AWT": [[61, 63]]}}}, {"text": "Is it considered clean using FXCollections in projects that have nothing in common with JavaFX", "label": {"api": {"FXCollections": [[29, 41]]}}}, {"text": "Stateful map operations are discouraged and you shouldn't use them, even for sequential streams", "label": {"api": {"Stateful map operations are discouraged": [[0, 38]]}}}, {"text": "You might have a look to AtomicInteger and more generally all Atomic types from java default packages", "label": {"api": {"AtomicInteger": [[25, 37]]}}}, {"text": "You can use printf's format specifiers to print the number in the format you want", "label": {"api": {"format specifiers": [[21, 37]]}}}, {"text": "Reuse it and add the condition to ConstraintValidator::isValid method", "label": {"api": {"ConstraintValidator::isValid": [[34, 61]]}}}, {"text": "In Java, the way to iterate over these is with BreakIterator.getCharacterInstance(Locale)", "label": {"api": {"BreakIterator.getCharacterInstance(Locale)": [[47, 88]]}}}, {"text": "The best way to do it is to use non blocking IO API provided by NIO API", "label": {"api": {"NIO API": [[64, 70]]}}}, {"text": "As already mentioned in the comments, the Hashtable is considered obsolete", "label": {"api": {"Hashtable": [[42, 50]]}}}, {"text": "Its replacement is HashMap", "label": {"api": {"HashMap": [[19, 25]]}}}, {"text": "If you wish make HashMap synchronized the same way the Hashtable does, use the Collections::synchronizedMap decorator on it", "label": {"api": {"Hashtable": [[55, 63]], "HashMap": [[17, 23]], "Collections::synchronizedMap": [[79, 106]]}}}, {"text": "The structure of your Hashtable looks a bit unclear", "label": {"api": {"Hashtable": [[22, 30]]}}}, {"text": "Take a look at the replace method for strings", "label": {"api": {"replace": [[19, 25]]}}}, {"text": "And to add the number tag, you could use a regex replace", "label": {"api": {"replace": [[49, 55]]}}}, {"text": "The replaceAll method and a regex like [0-9]+, depending on what your numbers look like, can do that", "label": {"api": {"replace": [[4, 10]], "replaceAll": [[4, 13]]}}}, {"text": "There are several standard attributes which may be present (though custom attributes are allowed and in fact are common)", "label": {"api": {"standard attributes": [[18, 36]]}}}, {"text": "Use a PreparedStatement with", "label": {"api": {"PreparedStatement": [[6, 22]]}}}, {"text": "I know I can use ModuleFinder.of(Path) but my requirement is to derive it without any file-system IO", "label": {"api": {"ModuleFinder.of(Path)": [[17, 37]]}}}, {"text": "The whole problem can be solved with two instances of ExecutorSevice", "label": {"api": {"ExecutorSevice": [[54, 67]]}}}, {"text": "Just have a fixed thread pool at one side (A), and submit tasks to a single threaded one at the other side (B)", "label": {"api": {"fixed thread pool": [[12, 28]], "single threaded": [[69, 83]]}}}, {"text": "A file's length() represents it's size, you can just sort by it", "label": {"api": {"length()": [[9, 16]]}}}, {"text": "See the documentation for URL.openConnection()", "label": {"api": {"URL.openConnection()": [[26, 45]]}}}, {"text": "The second option would best be done by using a custom cell factory", "label": {"api": {"cell factory": [[55, 66]]}}}, {"text": "Such a method can use the Integer.numberOfTrailingZeros(...) method", "label": {"api": {"Integer.numberOfTrailingZeros(...)": [[26, 59]]}}}, {"text": "You can use a ExecutorService with a single thread, it will handle this for you", "label": {"api": {"ExecutorService with a single thread": [[14, 49]]}}}, {"text": "If you want to retrieve a substring within string which is between two other substrings then you can use the Quotation constructs ( \\\\Q and \\\\E ) within your regular-expression string", "label": {"api": {"Quotation constructs": [[109, 128]]}}}, {"text": "What you place between the Quotation constructs is entirely up to you, it's all a matter of how accurate you want to be with what substring you retrieve especially if you already know what the full input string is going to contain", "label": {"api": {"Quotation constructs": [[27, 46]]}}}, {"text": "The line sourceChannel = new FileInputStream(source).getChannel(); does not complete successfully if new FileInputStream(source) throws a FileNotFoundException, of which the FileInputStream JavaDoc says", "label": {"api": {"FileInputStream JavaDoc": [[174, 196]]}}}, {"text": "If you want to call doSomeWork asynchronouly and the next procedure of startWork does not rely on the result of doSomeWork, you can take use of some concurrent framework, for example, Executor", "label": {"api": {"Executor": [[184, 191]]}}}, {"text": "Since Connection and PreparedStatement implement the AutoCloseable interface they will be closed automatically when the try block ends", "label": {"api": {"AutoCloseable": [[53, 65]]}}}, {"text": "This happens every few seconds for multiple indices from my Java client using HttpURLConnection", "label": {"api": {"HttpURLConnection": [[78, 94]]}}}, {"text": "You can create java.util.Stream<JsonNode> with", "label": {"api": {"create java.util.Stream<JsonNode> with": [[8, 45]]}}}, {"text": "As a Timeline inherits from Animation, you can use setOnFinished to define an action to occur at the end of the timeline", "label": {"api": {"Timeline": [[5, 12]], "setOnFinished": [[51, 63]]}}}, {"text": "The real power of Optional are the following methods", "label": {"api": {"Optional": [[18, 25]]}}}, {"text": "You switch to double to calculate the sum of digits, when it looks like BigInteger.divideAndRemainder is what you need", "label": {"api": {"BigInteger.divideAndRemainder": [[72, 100]]}}}, {"text": "This error means the elements in the parameter Collection of method Collections.max should implement interface Comparable", "label": {"api": {"Comparable": [[111, 120]]}}}, {"text": "Another solution that might be cleaner is to shutdown your ExecutorService and wait for its termination", "label": {"api": {"ExecutorService": [[59, 73]]}}}, {"text": "I would assume that you already use a customized ExecutorService in your DAO since the common pool used by default by CompletableFuture is not suitable for IO tasks", "label": {"api": {"ExecutorService": [[49, 63]]}}}, {"text": "Otherwise, you should look into the factory methods in Executors", "label": {"api": {"Executors": [[55, 63]]}}}, {"text": "So, once you have submitted all your tasks, you should call ExecutorService.shutdown(), followed by awaitTermination(), on the main thread", "label": {"api": {"ExecutorService": [[60, 74]], "ExecutorService.shutdown()": [[60, 85]], "awaitTermination()": [[100, 117]]}}}, {"text": "If you absolutely expect there always to be a value, then use Optional::orElseThrow to throw an Exception if a null appears", "label": {"api": {"Optional::orElseThrow": [[62, 82]], "Optional::orElse": [[62, 77]]}}}, {"text": "If you expect a null to possibly arrive, and have an alternative instance available as a fall-back option, use Optional::orElse", "label": {"api": {"Optional::orElse": [[111, 126]]}}}, {"text": "If the fall-back instance is not on hand, but you have a function to call to provide a fall-back instance, use Optional::orElseGet", "label": {"api": {"Optional::orElse": [[111, 126]], "Optional::orElseGet": [[111, 129]]}}}, {"text": "If you don’t care about receiving a null, and want to do nothing when a null arrives, use Optional::ifPresent", "label": {"api": {"Optional::ifPresent": [[90, 108]]}}}, {"text": "If you only care if a value arrives that meets some requirement, use Optional::filter", "label": {"api": {"Optional::filter": [[69, 84]]}}}, {"text": "Pass a Predicate defining your requirement", "label": {"api": {"Predicate": [[7, 15]]}}}, {"text": "Note that the IntStream is able to create an array of primitives since it is a sequence of primitive int-valued elements", "label": {"api": {"IntStream": [[14, 22]]}}}, {"text": "its method IntStream::toArray reutrns int[]", "label": {"api": {"IntStream": [[11, 19]], "IntStream::toArray": [[11, 28]]}}}, {"text": "There is needed to use a method IntStream::mapToObj which maps int to an object - then the Stream<int[]> is returned and the method Stream::toArray(IntFunction<A[]> generator) converting to array with parameter has to be used since you cannot convert Object[] to int[][]", "label": {"api": {"IntStream": [[32, 40]], "IntStream::mapToObj": [[32, 50]], "Stream<int[]>": [[91, 103]], "Stream::toArray(IntFunction<A[]> generator)": [[132, 174]]}}}, {"text": "I recommend looking through the javadoc of ScheduledService to get familiar with it's capabilities", "label": {"api": {"ScheduledService": [[43, 58]]}}}, {"text": "If you take a closer look at that method, you will find the answer to your question - from the JDK 10 Javadoc (emphasis mine)", "label": {"api": {"the JDK 10 Javadoc": [[91, 108]]}}}, {"text": "For example, this method from the JDK mutates an existing list, but its intent and documentation are very clear", "label": {"api": {"this method": [[13, 23]]}}}, {"text": "The easiest way to do this is by converting the data to the less ambiguous LocalDate and LocalDateTime types", "label": {"api": {"LocalDate": [[75, 83], [89, 97]], "LocalDateTime": [[89, 101]]}}}, {"text": "Mind you as I said before I don't see the reason why you would not want to use Java components (for example Java 9 and onward has a native HTTP client https://docs.oracle.com/javase/9/docs/api/jdk/incubator/http/HttpClient.html) but hey I suppose that this is for some sort of assignment so what you need to use may be limited in term of options", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/jdk/incubator/http/HttpClient.html": [[151, 226]]}}}, {"text": "Actually with ProcessBuilder and its directory(File directory), we can easily set the working directory", "label": {"api": {"ProcessBuilder": [[14, 27]], "directory(File directory)": [[37, 61]]}}}, {"text": "You can rename directory using java.nio.file.Files.move method and then copy the files with Files.walkFileTree", "label": {"api": {"java.nio.file.Files.move": [[31, 54]]}}}, {"text": "It's most probably the thread id generated by a custom ThreadFactory, just like", "label": {"api": {"ThreadFactory": [[55, 67]]}}}, {"text": "In order to solve your problem, you have to use a SwingWorker", "label": {"api": {"SwingWorker": [[50, 60]]}}}, {"text": "How do I use SwingWorker in Java", "label": {"api": {"SwingWorker": [[13, 23]]}}}, {"text": "In order to give you one more hand to find the solution you are looking for, i have created an SSCCE, using a SwingWorker that does something \"heavy\"", "label": {"api": {"SwingWorker": [[110, 120]]}}}, {"text": "I was wondering whether Class instances are immutable", "label": {"api": {"Class": [[24, 28]]}}}, {"text": "Ideally, I would like to populate the set with Class instances to avoid unnecessary calls to Class.forName() when I need to access the classe via reflection", "label": {"api": {"Class": [[47, 51], [93, 97]], "Class.forName()": [[93, 107]]}}}, {"text": "Hence I was wondering if I could use Class instances right away", "label": {"api": {"Class": [[37, 41]]}}}, {"text": "Because there's no System.out.println(Car) method, the Java compiler picks the closest match it can, which is System.out.println(Object)", "label": {"api": {"System.out.println(Object)": [[110, 135]]}}}, {"text": "That calls String.valueOf on what you pass in to get the string version of it to print", "label": {"api": {"String.valueOf": [[11, 24]]}}}, {"text": "String.valueOf uses the toString method of your object to get the string", "label": {"api": {"String.valueOf": [[0, 13]]}}}, {"text": "Note that this now uses String.indexOf and not the List indexOf method that you were using before", "label": {"api": {"String.indexOf": [[24, 37]]}}}, {"text": "You can read the whole line instead and separate it using the split function of the String class", "label": {"api": {"split": [[62, 66]]}}}, {"text": "Split returns an array with all the numbers in it then parse each token with Integer.parseInt() to convert it from String to Integer", "label": {"api": {"Integer.parseInt()": [[77, 94]]}}}, {"text": "I completed your code to reproduce your issue, but it works using invokeWithArguments", "label": {"api": {"invokeWithArguments": [[66, 84]]}}}, {"text": "Any class can override hashCode() to return whatever it wants, so yes", "label": {"api": {"hashCode()": [[23, 32]]}}}, {"text": "You can use either scheduleWithFixedDelay() or scheduleAtFixedRate() depending upon your use case", "label": {"api": {"scheduleWithFixedDelay()": [[19, 42]], "scheduleAtFixedRate()": [[47, 67]]}}}, {"text": "You could use Collectors.groupingBy()", "label": {"api": {"Collectors.groupingBy()": [[14, 36]]}}}, {"text": "Both for-loops might be compressed into two Stream::filter methods", "label": {"api": {"Stream::filter": [[44, 57]]}}}, {"text": "You can use two CountDownLatch for communication between the child and main thread", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "I have defined a pattern string and I use string.matches(pattern) as follows", "label": {"api": {"string.matches(pattern)": [[42, 64]]}}}, {"text": "According with JTextFieldDocumentation the method setHorizontalAlignment is expecting an int argument, try this", "label": {"api": {"JTextFieldDocumentation": [[15, 37]]}}}, {"text": "You can create a Duration object using the ofMillis method", "label": {"api": {"Duration": [[17, 24]], "ofMillis": [[43, 50]]}}}, {"text": "I try use my first filter in FilteredList but of course it doesn't work", "label": {"api": {"FilteredList": [[29, 40]]}}}, {"text": "This ignores one line break, see \\R", "label": {"api": {"line break, see \\R": [[17, 34]]}}}, {"text": "I think a better way to do this is with a BufferedReader", "label": {"api": {"BufferedReader": [[42, 55]]}}}, {"text": "The idea here is to build a temporary object in the searchByTitle method and passing it to the List.indexOf method having the Photo class that overrides Object.equals", "label": {"api": {"List.indexOf": [[95, 106]], "Object.equals": [[153, 165]]}}}, {"text": "By simply using the Security.setProperty() method I was able to connect to an SSL server using a certificate signed with MD5WithRSA", "label": {"api": {"Security.setProperty()": [[20, 41]]}}}, {"text": "I copies the values of the two security properties from the JAVA_HOME/lib/security/java.security file and removed MD5 from the disabled algorithms, then called Security.setProperty() with the modified list", "label": {"api": {"Security.setProperty()": [[160, 181]]}}}, {"text": "You can use Collections.frequency while iterating the list to print the number of occurrences of each word in the list", "label": {"api": {"Collections.frequency": [[12, 32]]}}}, {"text": "Create java.util.logging.Filter that looks for the WARNING level message", "label": {"api": {"java.util.logging.Filter": [[7, 30]], "WARNING": [[51, 57]]}}}, {"text": "Install that filter on a Handler of the root logger", "label": {"api": {"Handler": [[25, 31]]}}}, {"text": "You get LocalDate objects from many static methods listed in the javadoc", "label": {"api": {"in the javadoc": [[58, 71]]}}}, {"text": "For example, you could have a method which takes a NavigableSet (for example a TreeSet), and use its subSet method", "label": {"api": {"subSet method": [[101, 113]]}}}, {"text": "Integer.compare(int x, int y) can do all of this for you", "label": {"api": {"Integer.compare(int x, int y)": [[0, 28]]}}}, {"text": "In Java you can use method Float.intBitsToFloat(int)", "label": {"api": {"Float.intBitsToFloat(int)": [[27, 51]]}}}, {"text": "You can use Math.nextUp(float) to get the next float number", "label": {"api": {"Math.nextUp(float)": [[12, 29]]}}}, {"text": "Collect the data directly to a TreeMap by using the overloaded toMap(keyMapper, valueMapper, mergeFunction, mapSupplier) method that allows you to specify which Map to create (4th parameter)", "label": {"api": {"toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)": [[63, 119]]}}}, {"text": "Yes, use a CountDownLatch with count 1", "label": {"api": {"CountDownLatch": [[11, 24]]}}}, {"text": "According to the Javadoc for Logger.info, it expects a Supplier<String>, and you're giving it a Supplier<Double>", "label": {"api": {"the Javadoc for Logger.info": [[13, 39]]}}}, {"text": "Using the javax.ws.rs.container.ContainerRequestFilter interface makes it very simple", "label": {"api": {"javax.ws.rs.container.ContainerRequestFilter": [[10, 53]]}}}, {"text": "If you want a circular collection of any number of elements, the easiest would be to extend ArrayDeque with the methods you want", "label": {"api": {"ArrayDeque": [[92, 101]], "Deque": [[97, 101]]}}}, {"text": "This allows you to still use all the normal Deque methods for adding and removing elements to/from the collection", "label": {"api": {"Deque": [[44, 48]]}}}, {"text": "Finally, as already mentioned the RequestDispatcher is used to either forward to another resource or include content from another resource - its not a redirect", "label": {"api": {"RequestDispatcher": [[34, 50]]}}}, {"text": "The request dispatcher can be acquired either from ServletContext or from ServletRequest; note the difference between the two ways of getting the dispatcher", "label": {"api": {"ServletContext": [[51, 64]], "ServletRequest": [[74, 87]]}}}, {"text": "List class already provides a convenient method ( toArray ) for converting itself to an array", "label": {"api": {"toArray": [[50, 56]]}}}, {"text": "You can just use the toCharArray method of the String class", "label": {"api": {"toCharArray": [[21, 31]]}}}, {"text": "Implement Comparable interface for the Student class and implement the method int compareTo(T o)", "label": {"api": {"Comparable interface": [[10, 29]]}}}, {"text": "Enum in Java is the base class for all enumeration types", "label": {"api": {"Enum": [[0, 3]]}}}, {"text": "Just like one can hold reference of object of any class using the reference of type Object, one can refer to an enumeration type using the reference of type Enum", "label": {"api": {"Enum": [[157, 160]]}}}, {"text": "I guess this would be the equivalent to CompletionStage.applyToEither", "label": {"api": {"applyToEither": [[56, 68]]}}}, {"text": "That gives you an immutable Set instead of one which can be ordered", "label": {"api": {"immutable Set": [[18, 30]]}}}, {"text": "You could use a specific implementation that does, such as a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[61, 73]]}}}, {"text": "Instead, have a look at the Properties class which provides pretty much what you want", "label": {"api": {"Properties": [[28, 37]]}}}, {"text": "You can use the replaceAll() method", "label": {"api": {"replaceAll()": [[16, 27]]}}}, {"text": "Luckily, there is a method on String called replaceAll() that takes a Regular Expression", "label": {"api": {"replaceAll()": [[44, 55]]}}}, {"text": "You need to call the repaint() method after making the changes", "label": {"api": {"repaint()": [[21, 29]]}}}, {"text": "getInt, getDate, and getString are ResultSet methods, not  PreparedStatement methods", "label": {"api": {"ResultSet": [[35, 43]]}}}, {"text": "Your code can be improved by making use of TreeSet (instead of PriorityQueue and Stack)", "label": {"api": {"TreeSet": [[43, 49]]}}}, {"text": "Note that I'm using a comparator that sorts the TreeSet of entries by value in descending order and then by key", "label": {"api": {"TreeSet": [[48, 54]]}}}, {"text": "The TreeSet.pollLast() method is the equivalent of PriorityQueue.poll() method", "label": {"api": {"TreeSet": [[4, 10]], "TreeSet.pollLast()": [[4, 21]]}}}, {"text": "For example, you could wrap your long timestamps into AtomicLong instances", "label": {"api": {"AtomicLong": [[54, 63]]}}}, {"text": "So the proposed best practice by Oracle itself for shutting down an ExecutorService would be the following", "label": {"api": {"Oracle itself": [[33, 45]]}}}, {"text": "Do not create and shutdown executor every time, use a singleton cached thread pool", "label": {"api": {"cached thread pool": [[64, 81]]}}}, {"text": "From the documentation for Collection.stream", "label": {"api": {"Collection.stream": [[27, 43]]}}}, {"text": "From the documentation for Arrays.stream", "label": {"api": {"Arrays.stream": [[27, 39]]}}}, {"text": "If you're able to use Java 9, you can use the new process API to get a list of all processes with ProcessHandle.allProcesses() and search for ones that match your program, but otherwise you'd need to resort to platform-dependent behavior", "label": {"api": {"ProcessHandle.allProcesses()": [[98, 125]]}}}, {"text": "An alternative method (not requiring Java 9) would be to use a FileLock", "label": {"api": {"FileLock": [[63, 70]]}}}, {"text": "Setting append to true in the FileWriter", "label": {"api": {"Setting append to true in the FileWriter": [[0, 39]]}}}, {"text": "By \"Error Handler\" I assume you mean JMS ExceptionListener", "label": {"api": {"ExceptionListener": [[41, 57]]}}}, {"text": "If that is true, it's worth noting that the ExceptionListener is only invoked when an exception for the corresponding Connection cannot be delivered any other way", "label": {"api": {"ExceptionListener": [[44, 60]]}}}, {"text": "java.time.LocalDate, which provides the plus(long, TemporalUnit) method", "label": {"api": {"plus(long, TemporalUnit)": [[40, 63]]}}}, {"text": "Another option, rather than creating a separate boolean variable, is to use the status property of Animation", "label": {"api": {"status property": [[80, 94]]}}}, {"text": "If you look at the documentation of String(byte[],Charset) you'll see", "label": {"api": {"String(byte[],Charset)": [[36, 57]]}}}, {"text": "The reason is that the value of s2 is used as \"intern\"", "label": {"api": {"\"intern\"": [[46, 53]]}}}, {"text": "Thus, you can just use the String.compareTo() method to compare the strings", "label": {"api": {"String.compareTo()": [[27, 44]]}}}, {"text": "Predicate<T> interface in Java, that uses a <", "label": {"api": {"Predicate<T>": [[0, 11]]}}}, {"text": "The database connection is accessible through a DataSource that defers connection management to a ConnectionPool", "label": {"api": {"DataSource": [[48, 57]]}}}, {"text": "To learn more about FXML in JavaFX, see Introduction to FXML", "label": {"api": {"Introduction to FXML": [[40, 59]]}}}, {"text": "You can use Stream's flatMap method", "label": {"api": {"Stream's flatMap method": [[12, 34]]}}}, {"text": "I am reading the Condition Documentation from Java and I have a misunderstanding", "label": {"api": {"Condition Documentation": [[17, 39]]}}}, {"text": "Use Collections.sort(List, Comparator) and provide your own comparator that gives your desired order", "label": {"api": {"Collections.sort(List, Comparator)": [[4, 37]]}}}, {"text": "You could use the JPA javax.persistence.Tuple result set which, since Hibernate ORM 5.2.11 works for native SQL", "label": {"api": {"javax.persistence.Tuple": [[22, 44]]}}}, {"text": "I came across the documentation of ServiceLoader and am unclear as to what use cases it suits", "label": {"api": {"the documentation of ServiceLoader": [[14, 47]]}}}, {"text": "The docs for the annotation type @XmlElements has this example", "label": {"api": {"@XmlElements": [[33, 44]]}}}, {"text": "Then an variant of the annotation @XmlElements would be applied to the List items in class Foo", "label": {"api": {"@XmlElements": [[34, 45]]}}}, {"text": "I think you can use type of Object.class and then use XmlAnyElement", "label": {"api": {"XmlAnyElement": [[54, 66]]}}}, {"text": "Since Java 9, there's a Matcher.replaceAll method taking a callback function as a parameter", "label": {"api": {"Matcher.replaceAll method taking a callback function": [[24, 75]]}}}, {"text": "The easiest way would be to use String.split() but you can also look into StringTokenizer", "label": {"api": {"String.split()": [[32, 45]], "StringTokenizer": [[74, 88]]}}}, {"text": "Now if we check javadocs for IntStream we can see that there isn't method collect which accepts an instance of Collector", "label": {"api": {"method": [[67, 72]]}}}, {"text": "On the contrary there is the following method", "label": {"api": {"method": [[39, 44]]}}}, {"text": "This could be done using boxed() method which just performs this conversion", "label": {"api": {"method": [[33, 38]]}}}, {"text": "Also, the Arrays class contains a useful toString method already defined", "label": {"api": {"Arrays": [[10, 15]]}}}, {"text": "You can do that with Class.isAssignableFrom(Class)", "label": {"api": {"Class.isAssignableFrom(Class)": [[21, 49]]}}}, {"text": "Ah well, just found out that Java 9 added the or(...)-method which is precisely what I wanted (which is not available in Java 8, that's why I had no clue)", "label": {"api": {"or(...)": [[46, 52]]}}}, {"text": "You might want to use Files#walk for this", "label": {"api": {"Files#walk": [[22, 31]]}}}, {"text": "The java.beans package has the classes Statement and Expression which can perform the necessary lookup with sub-type rules", "label": {"api": {"Statement": [[39, 47]], "Expression": [[53, 62]]}}}, {"text": "The documentation of the execute method describes the special pseudo method name \"new\" for invoking a constructor", "label": {"api": {"execute method": [[25, 38]]}}}, {"text": "replaceAll replaces all positive matches of the regular expression in the first parameter with the contents of the second parameter", "label": {"api": {"replaceAll": [[0, 9]]}}}, {"text": "\\D is regex for anything that is not a digit", "label": {"api": {"regex": [[6, 10]]}}}, {"text": "Java 8 allows to get the member from a MethodHandle via MethodHandles.Lookup.revealDirect(…)", "label": {"api": {"MethodHandles.Lookup.revealDirect(…)": [[56, 91]]}}}, {"text": "the javadoc of ReentrantLock, it specifically answers this question in the 3rd paragraph", "label": {"api": {"ReentrantLock": [[15, 27]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html) that provides guaranteed atomic operations, or to create your own data structure and implement a synchronized method for updating that data structure", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html": [[0, 93]]}}}, {"text": "1) Regroup your conditions in Predicates", "label": {"api": {"Predicate": [[30, 38]]}}}, {"text": "2) Use Stream#reduce and Predicate#or to create a single Predicate which is the result of all your predicates connected by logic OR operators", "label": {"api": {"Predicate": [[25, 33], [57, 65]], "Stream#reduce": [[7, 19]], "Predicate#or": [[25, 36]]}}}, {"text": "3) Use the result of Predicate#test in your if statement", "label": {"api": {"Predicate": [[21, 29]], "Predicate#test": [[21, 34]]}}}, {"text": "I noticed that java.time.Duration has method parse which is used by Jackson to deserialize duration strings", "label": {"api": {"parse": [[45, 49]]}}}, {"text": "You could parse both lines at a time and slice them into subgroups using a regular expression and Matcher", "label": {"api": {"Matcher": [[98, 104]]}}}, {"text": "I recommended to use 'java.util.Set'", "label": {"api": {"'java.util.Set'": [[21, 35]]}}}, {"text": "orElse takes a value (a String in your case), not a Supplier", "label": {"api": {"orElse": [[0, 5]]}}}, {"text": "The Comparator.compare method has to return int", "label": {"api": {"Comparator.compare": [[4, 21]]}}}, {"text": "Instead, use Long.compare, which returns int", "label": {"api": {"Long.compare": [[13, 24]]}}}, {"text": "The underlying 'problem' here is that java.sql.Timestamp, while extending java.util.Date, doesn't store milliseconds in the designated field (fastTime, equivalent to Unix time), but in a separate field nanos", "label": {"api": {"java.sql.Timestamp": [[38, 55]], "java.util.Date": [[74, 87]]}}}, {"text": "The after method only considers the fastTime field (which makes sense, since it can be used on all Date objects)", "label": {"api": {"after": [[4, 8]]}}}, {"text": "Therefore, after() and before() are not reliable in this case; the solution is to use getTime() (which is overloaded for Timestamp to provide the correct value) on both dates and compare those", "label": {"api": {"after": [[11, 15]]}}}, {"text": "[...] There is no requirement that a thread that releases a permit must have acquired that permit by calling acquire()", "label": {"api": {"acquire()": [[109, 117]]}}}, {"text": "This means you can use getDeclaredMethod() to get a method reference by calling", "label": {"api": {"getDeclaredMethod()": [[23, 41]]}}}, {"text": "The equivalent data structure in Java is also called LinkedList<E>", "label": {"api": {"LinkedList<E>": [[53, 65]]}}}, {"text": "However, ListIterator<E> on a standard List<E> might be cleaner to use", "label": {"api": {"ListIterator<E>": [[9, 23]]}}}, {"text": "It is explicitly defined by the Thread class", "label": {"api": {"explicitly defined by the Thread class": [[6, 43]]}}}, {"text": "The Java CharSequence is a simple abstraction, that allows methods with simple needs to accept a String, CharBuffer, Segment, StringBuffer, or StringBuilder without having to convert the others to String first", "label": {"api": {"CharSequence": [[9, 20]]}}}, {"text": "Use \"dropWhile\" from Java 9", "label": {"api": {"dropWhile": [[5, 13]]}}}, {"text": "You shouldn't have brought up the cases with a terminal operation forEach(list::remove) because list::remove is an interfering function and it violates the \"non-interference\" principle for terminal actions", "label": {"api": {"\"non-interference\"": [[156, 173]]}}}, {"text": "PreparedStatement#executeQuery does not take any parameters; just call it with no parameters", "label": {"api": {"PreparedStatement#executeQuery": [[0, 29]]}}}, {"text": "but that will break if the method is passed something like a TreeMap, which per the general Java Map contract is free to reject null keys with a NPE", "label": {"api": {"free to reject null keys with a NPE": [[113, 147]]}}}, {"text": "In your case, you can this error because the @Singleton annotation is not enough to create a binding", "label": {"api": {"@Singleton": [[45, 54]]}}}, {"text": "SeedStack does a lot of bindings for you by scanning the classpath and finding classes of interest (for instance @Path-annotated classes are JAX-RS resources automatically bound by the REST module)", "label": {"api": {"@Path": [[113, 117]]}}}, {"text": "Note that I kept the @Singleton annotation since you wanted a singleton in the first place", "label": {"api": {"@Singleton": [[21, 30]]}}}, {"text": "As explained here Oracle Documentation, the ObjectCollectedException is thrown, when some action on an object is not possible because that object is already garbage collected (deleted)", "label": {"api": {"Oracle Documentation": [[18, 37]]}}}, {"text": "findById returns an Optional<Document>, not a Document", "label": {"api": {"Optional<Document>": [[20, 37]]}}}, {"text": "If you must use a test double, you'd be better off writing a \"fake\", but there's no reason to do so when Java has ByteArrayInputStream built in", "label": {"api": {"ByteArrayInputStream": [[114, 133]]}}}, {"text": "That means that you can simulate a BlobInputStream by creating a real ByteArrayInputStream and delegating the overridable methods to it", "label": {"api": {"ByteArrayInputStream": [[70, 89]]}}}, {"text": "If, for example, your code takes the BlobInputStream and runs parsing or error correction code, you can factor out a method handleInputStream(InputStream) and pass in your own ByteArrayInputStream to test it heavily", "label": {"api": {"ByteArrayInputStream": [[176, 195]]}}}, {"text": "I wonder why nobody suggested to use a Popup for this", "label": {"api": {"Popup": [[39, 43]]}}}, {"text": "The last line there basically says that the tokenizer should treat an end of line (EOL) as special character (see the API doc)", "label": {"api": {"API doc": [[118, 124]]}}}, {"text": "You could use Collections.sort() along with a custom comparator which compares the integer prefix of each filename, like below on your ArrayList files", "label": {"api": {"Collections.sort()": [[14, 31]]}}}, {"text": "Its a Runnable with an empty run definition", "label": {"api": {"Runnable": [[6, 13]]}}}, {"text": "To make it more readable, there are Collection::addAll and Collection::removeAll to use in this situation, your code can be", "label": {"api": {"Collection::addAll": [[36, 53]], "Collection::removeAll": [[59, 79]]}}}, {"text": "I can define the number of partitions via configuration or implement a PartitionMapper to do that", "label": {"api": {"PartitionMapper": [[71, 85]]}}}, {"text": "Then, there are the JobContext and StepContext injectables to provide context information to my processing", "label": {"api": {"JobContext": [[20, 29]], "StepContext": [[35, 45]]}}}, {"text": "hh is for 1-12 hour format, use HH for 0-23 hour format, see SimpleDateFormat docs", "label": {"api": {"SimpleDateFormat": [[61, 76]]}}}, {"text": "Older classes like SimpleDateFormat or Calendar are lenient by default so they are silently fixing the date by moving it forward by the overflowing field offset", "label": {"api": {"SimpleDateFormat": [[19, 34]], "lenient": [[52, 58]]}}}, {"text": "The use function calls the close() method, which closes the entire stream, rather than closeEntry(), which closes just the current entry", "label": {"api": {"close()": [[27, 33]], "closeEntry()": [[87, 98]]}}}, {"text": "where Users is an interface representing a users database and UserNonExistent is a RuntimeException", "label": {"api": {"RuntimeException": [[83, 98]]}}}, {"text": "If you have a Joda-Time DateTime, then use toLocalDate() and toLocalDateTime(...)", "label": {"api": {"toLocalDate()": [[43, 55]]}}}, {"text": "a java.sql.Date, then use toLocalDate() and atStartOfDay()", "label": {"api": {"toLocalDate()": [[26, 38]], "atStartOfDay()": [[44, 57]]}}}, {"text": "If you have a java.sql.Timestamp, use toLocalDateTime() and truncatedTo(...)", "label": {"api": {"toLocalDateTime()": [[38, 54]], "truncatedTo(...)": [[60, 75]]}}}, {"text": "If you have a java.util.Date, use toInstant(), atZone(...), toLocalDate(), and atStartOfDay()", "label": {"api": {"toLocalDate()": [[60, 72]], "atStartOfDay()": [[79, 92]], "toInstant()": [[34, 44]], "atZone(...)": [[47, 57]]}}}, {"text": "Specifically as documented in the superclass Key it is an ASN.1 (DER) encoding of PKCS#8 = Public-Key Cryptography Standard #8, Private Key Information Syntax", "label": {"api": {"as documented in the superclass Key": [[13, 47]]}}}, {"text": "In both cases, if you want only the privatekey number, cast to java.security.interfaces.ECPrivateKey and use getS()", "label": {"api": {"java.security.interfaces.ECPrivateKey": [[63, 99]]}}}, {"text": "If you call SctpChannel.open(socketAddress,1,1) with socket address for the remote end it effectively open channel and connects to remote end (see open documentation", "label": {"api": {"open documentation": [[147, 164]]}}}, {"text": "Conversion is done for you in doubleValue()", "label": {"api": {"doubleValue()": [[30, 42]]}}}, {"text": "If you need to bind the items property then your ObservableList will either need to be held in an implementation of ObservableValue<ObservableList<E>> or an ObservableListValue<E>", "label": {"api": {"ObservableListValue<E>": [[157, 178]]}}}, {"text": "In order for an ObservableList to observe the properties of its elements, and thus be capable of firing update events, it must be created with FXCollections.observableArrayList(Callback)", "label": {"api": {"FXCollections.observableArrayList(Callback)": [[143, 185]]}}}, {"text": "Another cleaner but more advance choice could be the use of ProcessBuilder", "label": {"api": {"ProcessBuilder": [[60, 73]]}}}, {"text": "A Pattern is used to split stringProfile on whitespace characters which have a digit behind and ahead them", "label": {"api": {"Pattern": [[2, 8]]}}}, {"text": "Using the wording of the documentation of the Pattern class the used pattern looks for a whitespace character (\\\\s) which is preceded ((?<=\\\\d) = look behind) and succeeded ((?=\\\\d) = look ahead) by one digit (\\\\d)", "label": {"api": {"Pattern": [[46, 52]]}}}, {"text": "These looks have zero-width, thus they are evaluated for capturing (matching) but are not part of the matched sequence (Matcher.group())", "label": {"api": {"Matcher.group()": [[120, 134]]}}}, {"text": "Use the Set collection and its method Set::contains insde streaming the split array with the space (\" \") delimiter", "label": {"api": {"Set": [[8, 10], [38, 40]], "Set::contains": [[38, 50]]}}}, {"text": "They're redundant unless you activate multiline mode, in which case ^ and $ would match the beginning and end of individual lines instead of the whole input", "label": {"api": {"multiline mode": [[38, 51]]}}}, {"text": "You can activate multiline mode while using String#matches by using the embedded flag expression (?m) inside the regex (usually at the beginning)", "label": {"api": {"multiline mode": [[17, 30]], "String#matches": [[44, 57]]}}}, {"text": "Your equals implementation is incorrect", "label": {"api": {"equals": [[5, 10]]}}}, {"text": "equals has a specific contract; that code attempts to violate that contract", "label": {"api": {"equals": [[0, 5]]}}}, {"text": "The equals method implements an equivalence relation on non-null object references", "label": {"api": {"equals": [[4, 9]]}}}, {"text": "for any non-null reference value x, x.equals(x) should return true", "label": {"api": {"equals": [[38, 43]]}}}, {"text": "for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true", "label": {"api": {"equals": [[45, 50], [91, 96]]}}}, {"text": "for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true", "label": {"api": {"equals": [[52, 57], [81, 86], [112, 117]]}}}, {"text": "for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified", "label": {"api": {"equals": [[69, 74], [166, 171]]}}}, {"text": "For any non-null reference value x, x.equals(null) should return false", "label": {"api": {"equals": [[38, 43]]}}}, {"text": "There's no way to make an instance of your Sign class equals to a string", "label": {"api": {"equals": [[54, 59]]}}}, {"text": "Note that the method Object::equals is irrelevant to do with this operator/instruction", "label": {"api": {"Object::equals": [[21, 34]]}}}, {"text": "Quoting the javadoc for read()", "label": {"api": {"read()": [[24, 29]]}}}, {"text": "always always always, when you call some read() method that returns such a value, your code absolutely must check the result to ensure that (the expected) data was actually received by reading", "label": {"api": {"read()": [[41, 46]]}}}, {"text": "Using the Arrays class, which has useful methods for working with arrays, a simplified String implementation might look like this", "label": {"api": {"Arrays": [[10, 15]]}}}, {"text": "The type of function you can give to me here is specified by the Consumer interface, which is a functional interface", "label": {"api": {"Consumer": [[65, 72]]}}}, {"text": "This creates a lambda function that implements the functional interface Consumer<String>, and passes that to my method for subsequent callback", "label": {"api": {"Consumer": [[72, 79]]}}}, {"text": "Since you are using Java 1.7 you could use FileSystem API, which will save you time", "label": {"api": {"FileSystem API": [[43, 56]]}}}, {"text": "You have a lot of options, for example Future, or attaching a callback to your listener (so listener calls the callback after it completes)", "label": {"api": {"Future": [[39, 44]]}}}, {"text": "Sometimes threads coordinate by the use of higher-level synchronization objects (e.g., BlockingQueue) that might use wait/notify (or something equivalent to wait/notify) in their implementation", "label": {"api": {"something equivalent to wait/notify": [[133, 167]]}}}, {"text": "Use java.lang.reflect.Method.getDeclaringClass() to find in which class the given method is declared", "label": {"api": {"java.lang.reflect.Method.getDeclaringClass()": [[4, 47]]}}}, {"text": "In Java8+ just use java.util.Base64 which supports both variants now common", "label": {"api": {"java.util.Base64": [[19, 34]]}}}, {"text": "You can create a map with a String and DoubleBinaryOperator or an IntBinaryOperator depends on the type you want like so", "label": {"api": {"DoubleBinaryOperator": [[39, 58]], "IntBinaryOperator": [[66, 82]]}}}, {"text": "For example, you could add a List<StringBuilder>", "label": {"api": {"List<StringBuilder>": [[29, 47]]}}}, {"text": "As a starting point, see the documentation for the JavaCompiler class", "label": {"api": {"documentation for the JavaCompiler class": [[29, 68]]}}}, {"text": "Just use Files.copy", "label": {"api": {"Files.copy": [[9, 18]]}}}, {"text": "Don't do .write(buffer); write the amount you actually read", "label": {"api": {"write the amount": [[25, 40]]}}}, {"text": "This is what userdataStream.read returns you", "label": {"api": {"returns you": [[33, 43]]}}}, {"text": "Additionally, using JDK 8's removeIf method would make your code much simpler", "label": {"api": {"removeIf": [[28, 35]]}}}, {"text": "The Set implementation probably calls t.hashCode() and since arrays don't override the Object.hashCode method, the same object will have the same hashcode", "label": {"api": {"Object.hashCode": [[87, 101]]}}}, {"text": "To get an array's hash code correctly, you should call Arrays.hashCode", "label": {"api": {"Arrays.hashCode": [[55, 69]]}}}, {"text": "The Dialog API requires you to set a result converter callback if the type is not Void or ButtonType", "label": {"api": {"Dialog API": [[4, 13]]}}}, {"text": "Here the topN TreeMap behaves as a priority queue of size N (though we add up to N+1 elements)", "label": {"api": {"TreeMap": [[14, 20]]}}}, {"text": "First we put the entry into the topN map, then, if the map has more than N entries, we immediately invoke the pollLastEntry method on it, which removes the entry with the lowest priority (according to the order of the keys of the TreeMap)", "label": {"api": {"TreeMap": [[230, 236]], "pollLastEntry": [[110, 122]]}}}, {"text": "Note that I'm using a comparator that first sorts the TreeMap<Map.Entry<K, V>, K> by values V in descending order, and then by keys K", "label": {"api": {"TreeMap": [[54, 60]]}}}, {"text": "Since starting with a character, Character.toLowerCase might be suitable", "label": {"api": {"Character.toLowerCase": [[33, 53]]}}}, {"text": "If you go to its public api, you can see that this class has a setTimeZone method (which it inherits from java.text.DateFormat class)", "label": {"api": {"public api": [[17, 26]]}}}, {"text": "use AtomicInteger instead of the volatile int", "label": {"api": {"AtomicInteger": [[4, 16]]}}}, {"text": "The contains method uses the elements' equals method", "label": {"api": {"equals": [[39, 44]]}}}, {"text": "equals takes an Obejct argument", "label": {"api": {"equals": [[0, 5]]}}}, {"text": "Using the @Override annotation would have, in fact, caused a compilation error on this method and made the mistake clearer", "label": {"api": {"@Override": [[10, 18]]}}}, {"text": "You might actually want to consult the constructors to see what fits for your code", "label": {"api": {"constructors": [[39, 50]]}}}]