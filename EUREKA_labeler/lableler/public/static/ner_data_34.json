[{"text": "ProcessBuilder's constructor takes in a command and each subsequent String is treated as argument for the first String, recognized as the main command", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "On my side, I was able to run an arbitrary command without the help of ProcessBuilder, using Runtime.getRuntime().exec(...) instead, like this", "label": {"api": {"ProcessBuilder": [[71, 84]], "Runtime.getRuntime().exec(...)": [[93, 122]]}}}, {"text": "If you really need to use ProcessBuilder, the same behaviour can be achieved by defining your Process this way", "label": {"api": {"ProcessBuilder": [[26, 39]]}}}, {"text": "You can use DayOfWeek enum", "label": {"api": {"DayOfWeek": [[12, 20]]}}}, {"text": "You can also remove nested if-else statement and use DayOfWeek enum to display \"Today is xyz-day\"", "label": {"api": {"DayOfWeek": [[53, 61]]}}}, {"text": "You could use JavaFX Timeline", "label": {"api": {"Timeline": [[21, 28]]}}}, {"text": "The app below demos one way to use Timeline", "label": {"api": {"Timeline": [[35, 42]]}}}, {"text": "When you make a HashSet of ints, it uses Integer's hashCode() method, which just returns the int", "label": {"api": {"Integer's hashCode()": [[41, 60]]}}}, {"text": "But for double, Double's hashCode() method is much more complicated, because of the way doubles are represented in memory", "label": {"api": {"Double's hashCode()": [[16, 34]]}}}, {"text": "You could use the Collector from Collectors.collectingAndThen to perform an additional finishing transformation", "label": {"api": {"Collectors.collectingAndThen": [[33, 60]]}}}, {"text": "This is done by using the InetSocketAddress constructor that only takes a port number", "label": {"api": {"constructor": [[44, 54]]}}}, {"text": "While perhaps not the best performing solution, I'd just create a LinkedHashSet that will remove duplicates (while retaining the original order of the first appearances of every element) and then convert it back to a List", "label": {"api": {"LinkedHashSet": [[66, 78]]}}}, {"text": "You can use a List and Collections.shuffle", "label": {"api": {"Collections.shuffle": [[23, 41]]}}}, {"text": "Use setScale(...), something like that", "label": {"api": {"setScale(...)": [[4, 16]]}}}, {"text": "When parsing a value through YearQuarter.parse(text, formatter), I want values with leading zeros for the quarter to be rejected (via the standard DateTimeParseException)", "label": {"api": {"DateTimeParseException": [[147, 168]]}}}, {"text": "My first attempt was to use DateTimeFormatter.ofPattern(\"Q'Q'yy\")", "label": {"api": {"DateTimeFormatter": [[28, 44]]}}}, {"text": "However, these reject the input with a DateTimeParseException", "label": {"api": {"DateTimeParseException": [[39, 60]]}}}, {"text": "How can I construct a DateTimeFormatter to parse a YearQuarter in my desired format while rejecting values with more than one digit for the quarter", "label": {"api": {"DateTimeFormatter": [[22, 38]]}}}, {"text": "You should definitely look into using a PreparedStatement, if appropriate", "label": {"api": {"PreparedStatement": [[40, 56]]}}}, {"text": "You aren't going to transform the Stream<MenuAlertNotification> to a Stream<Boolean>, so don't use map which is supposed to be a non-interfering, stateless operation", "label": {"api": {"map": [[99, 101]], "non-interfering": [[129, 143]], "stateless": [[146, 154]]}}}, {"text": "If you want to preserve the order that put was called in, you should use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[75, 87]]}}}, {"text": "I believe you want the charAt() method", "label": {"api": {"charAt()": [[23, 30]]}}}, {"text": "You can also utilize the lastIndexOf method to check if there is any other char that matches the first letter", "label": {"api": {"lastIndexOf": [[25, 35]]}}}, {"text": "use the Supplier interface", "label": {"api": {"Supplier": [[8, 15]]}}}, {"text": "Alternatively, you could also use a Function, or implement your own factory interface to stick to the constructor injection", "label": {"api": {"Function": [[36, 43]]}}}, {"text": "Other data structures exist, such as the Set That already filter duplicate entries", "label": {"api": {"Set": [[41, 43]]}}}, {"text": "Set checks the equals method of the objects being inserted against the elements in the Set", "label": {"api": {"Set": [[0, 2], [87, 89]]}}}, {"text": "there is Files.readAllLines() that you could use", "label": {"api": {"Files.readAllLines()": [[9, 28]]}}}, {"text": "Using process.getInputStream(), you could obtain what Vim wrote to the terminal during its operation, but that would just amount to a garble of characters, as Vim is using special ANSI escape sequences to control the terminal, position the cursor, etc", "label": {"api": {"getInputStream()": [[14, 29]]}}}, {"text": "You should rectify your SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "A very simple approach is passing a StringBuilder - a mutable object which could be modified by the caller", "label": {"api": {"StringBuilder": [[36, 48]]}}}, {"text": "The caller would have to provide a non-null StringBuilder, like this", "label": {"api": {"StringBuilder": [[44, 56]]}}}, {"text": "You can do this with a SequentialTransition", "label": {"api": {"SequentialTransition": [[23, 42]]}}}, {"text": "Just use Random.nextInt() to get a random number up to 6, and use that to choose one image of the 6 for each die side", "label": {"api": {"Random.nextInt()": [[9, 24]]}}}, {"text": "However when I declare a main method an call launch from the Application class, the program still works", "label": {"api": {"Application": [[61, 71]]}}}, {"text": "The documentation of Application says, that the JavaFX runtime is creating an instance of the Application class and calls the init method", "label": {"api": {"Application": [[21, 31], [94, 104]]}}}, {"text": "Java provides many other ways to achieve thread-safety (Lock, CountDownLatch, Semaphore, ...), but since you are referring to an AtomicInteger, I believe AtomicInteger.compareAndSet() is more accurate to what you were asking", "label": {"api": {"Lock": [[56, 59]], "CountDownLatch": [[62, 75]], "Semaphore": [[78, 86]], "AtomicInteger.compareAndSet()": [[154, 182]]}}}, {"text": "As the Iterator.remove() javadoc notes the behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method", "label": {"api": {"Iterator.remove()": [[7, 23]]}}}, {"text": "Anyway, it does that resolution using the JavaFileManager.list call", "label": {"api": {"JavaFileManager.list": [[42, 61]]}}}, {"text": "Override a ForwardingJavaFileManager and pass that into getTask and have it lookup the resource and return it", "label": {"api": {"ForwardingJavaFileManager": [[11, 35]], "getTask": [[56, 62]]}}}, {"text": "Alternative solution using Collections.max", "label": {"api": {"Collections.max": [[27, 41]]}}}, {"text": "Keep in mind that Collections.max throws NoSuchElementException if the collection is empty", "label": {"api": {"Collections.max": [[18, 32]]}}}, {"text": "The only way to do asynchrony in Java8 is by using the CompletionStage API", "label": {"api": {"API": [[71, 73]]}}}, {"text": "This API can either use the common Fork/Join pool or you can hook up your own ExecutorService with it", "label": {"api": {"API": [[5, 7]]}}}, {"text": "What you want to do is get the an instance of secure random using the old algorithm using SecureRandom.getInstance", "label": {"api": {"SecureRandom.getInstance": [[90, 113]]}}}, {"text": "There is not a way to do it exactly the way you want it -- ConcurrentHashMap is not in and of itself, lock-free", "label": {"api": {"ConcurrentHashMap": [[59, 75]]}}}, {"text": "However, you can do it atomically without having to do any explicit lock management by using the java.util.Map.computeIfAbsent function", "label": {"api": {"java.util.Map.computeIfAbsent": [[97, 125]]}}}, {"text": "If you want to be able to terminate the JavaFX application from anywhere, use Platform.exit()", "label": {"api": {"Platform.exit()": [[78, 92]]}}}, {"text": "Another way is to close all the open windows as long as Platform.isImplicitExit() returns true (see Platform.setImplicitExit(boolean)); it looks like this may have been what you were trying to do in the first place", "label": {"api": {"Platform.isImplicitExit()": [[56, 80]], "Platform.setImplicitExit(boolean)": [[100, 132]]}}}, {"text": "You are applying Set semantics to non-Set collection objects, so results are arbitrary if the input PriorityQueues contain duplicate elements", "label": {"api": {"Set": [[17, 19], [38, 40]], "PriorityQueue": [[100, 112]]}}}, {"text": "For better performance, you should use a real Set", "label": {"api": {"Set": [[46, 48]]}}}, {"text": "The standard Collection classes, including PriorityQueue, all implement retainAll(c), which is the equivalent of a \"set intersection\"", "label": {"api": {"Collection": [[13, 22]], "PriorityQueue": [[43, 55]], "retainAll(c)": [[72, 83]]}}}, {"text": "The implementation uses c.contains(o), so c should be a HashSet object, resulting in O(m+n) performance", "label": {"api": {"Set": [[60, 62]], "HashSet": [[56, 62]]}}}, {"text": "The standard Collection classes, including PriorityQueue, all implement removeAll(c), which is the equivalent to an \"asymmetric set difference\"", "label": {"api": {"Collection": [[13, 22]], "PriorityQueue": [[43, 55]]}}}, {"text": "The implementation uses c.contains(), so c should be a HashSet object, resulting in O(m+n) performance", "label": {"api": {"Set": [[59, 61]], "HashSet": [[55, 61]]}}}, {"text": "The standard Set classes all implement addAll(c), which is the equivalent to a \"set union\"", "label": {"api": {"Set": [[13, 15]], "addAll(c)": [[39, 47]]}}}, {"text": "Using a HashSet results in O(m+n) performance", "label": {"api": {"Set": [[12, 14]], "HashSet": [[8, 14]]}}}, {"text": "The contains() method will use the equals() method to compare the objects, and the equals() method of HashMap is defined as follow", "label": {"api": {"defined as follow": [[113, 129]]}}}, {"text": "Java's Inflater class will decompress what has been compressed by Python's zlib.compress()", "label": {"api": {"Inflater": [[7, 14]]}}}, {"text": "Implementing an interface gives you another option of using a Proxy, but you cannot specify your own base class", "label": {"api": {"Proxy": [[62, 66]]}}}, {"text": "Instead, consider using a StringBuilder for the output, which you can convert into a char array when you're done", "label": {"api": {"StringBuilder": [[26, 38]]}}}, {"text": "Why doesn't forEach method in java not show a compiler error when a Function type argument is passed instead of Consumer", "label": {"api": {"forEach": [[12, 18]]}}}, {"text": "You can input it with a Scanner, and then append the file name to it using Path#get", "label": {"api": {"Scanner": [[24, 30]], "Path#get": [[75, 82]]}}}, {"text": "Scanner provides many methods to validate the user's input", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "You could start a separate thread that sends messages, and for instance make it wait n seconds between messages; n would range from your lower limit, for instance 60 if you want to simulate a car every minute, to your higher limit; maybe 3 if you want to simulate 20 cars per minute", "label": {"api": {"thread": [[27, 32]]}}}, {"text": "The problem is that you return player.getId() before the AsyncTask finishes its background work of insertion; you must wait until it delivers you the correct result of insertion, and here is a suggested solution using the thread-safe CountDownLatch which pauses the the execution of the subsequent code using .await() method until count of the CountDownLatch reaches 0; where it decrements by 1 each time .countDown() is invoked", "label": {"api": {"CountDownLatch": [[234, 247], [344, 357]]}}}, {"text": "the problem is that EMPTY_MAP is a raw type (Map), if you use emptyMap it should work fine", "label": {"api": {"emptyMap": [[62, 69]]}}}, {"text": "As per Math.cos documentation", "label": {"api": {"Math.cos documentation": [[7, 28]]}}}, {"text": "Try using JavaFx Polygon", "label": {"api": {"Polygon": [[17, 23]]}}}, {"text": "Polygon extends shape  which has some functions you may find useful like subtract and union", "label": {"api": {"Polygon": [[0, 6]], "shape": [[16, 20]], "subtract": [[73, 80]], "union": [[86, 90]]}}}, {"text": "I found a base Java list and an Android class index but it seems quite tedious to go back and forth between both lists and having to click on each class to have the full path", "label": {"api": {"a base Java list": [[8, 23]]}}}, {"text": "You could instead use a Semaphore with one permit which would allow you to do the same thing but in a simpler way", "label": {"api": {"a Semaphore": [[22, 32]]}}}, {"text": "When the GeneratedValue.strategy is not explicitly specified as in the example, it defaults to AUTO, and the docs for GenerationType.AUTO state this", "label": {"api": {"docs for GenerationType.AUTO": [[109, 136]]}}}, {"text": "I'm trying to deserialize XML data into a Java content tree using JAXB, validating the XML data as it is unmarshalled", "label": {"api": {"JAXB": [[66, 69]]}}}, {"text": "Files#lines already returns a Stream<String>", "label": {"api": {"Files#lines": [[0, 10]]}}}, {"text": "Why not use a Scanner and then split and parse", "label": {"api": {"split": [[31, 35]]}}}, {"text": "Instead of using int Integer::parseInt(String s), you should use Integer Integer::valueOf(String s), so you don't have to call boxed() or rely on auto-boxing", "label": {"api": {"int Integer::parseInt(String s)": [[17, 47]], "Integer Integer::valueOf(String s)": [[65, 98]]}}}, {"text": "The string in the second (optional) pair of braces is a standard time zone id, as understood by java.util.TimeZone.getTimeZone(String)", "label": {"api": {"java.util.TimeZone.getTimeZone(String)": [[96, 133]]}}}, {"text": "But there is an overload of binarySearch that takes a Comparator, so that the algorithm can assume that it's sorted the same way that the Comparator defines the order", "label": {"api": {"overload of binarySearch that takes a Comparator": [[16, 63]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html but I don't understand how I can apply it", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html": [[0, 81]]}}}, {"text": "Or, with the Pattern.splitAsStream", "label": {"api": {"Pattern.splitAsStream": [[13, 33]]}}}, {"text": "Instead store the path you've followed so far in either a java.util.BitSet (where you store each path pixel in element y*width + x of the BitSet) or you can simply use the red area of the picture that you've colored in to store the path", "label": {"api": {"java.util.BitSet": [[58, 73]]}}}, {"text": "You know how wide the \" AND \" is, so just use StringBuilder#delete", "label": {"api": {"StringBuilder#delete": [[46, 65]]}}}, {"text": "Or, if you're about to turn it into a String anyway, use StringBuilder#substring", "label": {"api": {"StringBuilder#substring": [[57, 79]]}}}, {"text": "If you need a thread-safe HashMap, you may use the Hashtable class instead", "label": {"api": {"Hashtable": [[51, 59]]}}}, {"text": "Unlike the new collection implementations, Hashtable is synchronized", "label": {"api": {"Hashtable": [[43, 51]]}}}, {"text": "If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable, says the javadoc about Hashtable", "label": {"api": {"Hashtable": [[92, 100], [126, 134]]}}}, {"text": "Collections.synchronizedXxx() or ConcurrentHashMap, that worked for the opener of this question", "label": {"api": {"ConcurrentHashMap": [[33, 49]]}}}, {"text": "public static Response.ResponseBuilder status(int status) method returns a ResponseBuilder", "label": {"api": {"ResponseBuilder": [[23, 37], [75, 89]]}}}, {"text": "Response cannot be instantiated directly", "label": {"api": {"Response": [[0, 7]]}}}, {"text": "Inspect the Response constructor summary in the class documentation", "label": {"api": {"Response": [[12, 19]], "constructor summary": [[21, 39]]}}}, {"text": "You will find a single protected constructor, which cannot be invoked directly from your code", "label": {"api": {"single protected constructor": [[16, 43]]}}}, {"text": "Instead, you must use one of the Response static methods to obtain a ResponseBuilder instance and then obtain a Response from that", "label": {"api": {"Response": [[33, 40], [69, 76], [112, 119]], "static methods": [[42, 55]], "ResponseBuilder": [[69, 83]]}}}, {"text": "ResponseBuilder allows you to control how the Response is built, defining a status code, an entity, response headers, cookies, etc", "label": {"api": {"Response": [[0, 7], [46, 53]], "ResponseBuilder": [[0, 14]]}}}, {"text": "Once you are done, you invoke build() and it will return a Response instance", "label": {"api": {"Response": [[59, 66]], "build()": [[30, 36]]}}}, {"text": "Another well-known example of the Builder design pattern usage is the StringBuilder class", "label": {"api": {"StringBuilder": [[70, 82]]}}}, {"text": "You could make Slick2D support \"zlib\" compression by using the InfalterInputStream instead of its subclass GZIPInputStream, if the latest version of Slick2D doesn't already support it", "label": {"api": {"InfalterInputStream": [[63, 81]], "GZIPInputStream": [[107, 121]]}}}, {"text": "Just use Collector.of(Supplier, BiConsumer, BinaryOperator, [Function,] Characteristics...) for those cases", "label": {"api": {"Collector.of(Supplier, BiConsumer, BinaryOperator, [Function,] Characteristics...)": [[9, 90]]}}}, {"text": "The line .level = FINEST determines the level of the root logger", "label": {"api": {"level": [[10, 14], [40, 44]]}}}, {"text": "The java.util.logging.FileHandler.level=FINEST line determines the lowest level that will be published to the output file", "label": {"api": {"level": [[34, 38], [74, 78]]}}}, {"text": "For instance, java.util.logging.ConsoleHandler.level = CONFIG will only publish records CONFIG and higher to the console", "label": {"api": {"level": [[47, 51]]}}}, {"text": "I wonder why ToDoubleBiFunction doesn't extend BiFunction", "label": {"api": {"ToDoubleBiFunction": [[13, 30]], "BiFunction": [[21, 30], [47, 56]]}}}, {"text": "The Class.newInstance method bypasses the call to a default constructor, and hence possible thrown exceptions (bad practice)", "label": {"api": {"Class.newInstance": [[4, 20]]}}}, {"text": "This can be achieved using methods like Font.canDisplayUpTo(String)", "label": {"api": {"Font.canDisplayUpTo(String)": [[40, 66]]}}}, {"text": "Month as an enum is present in Java time API also which can be directly used", "label": {"api": {"Java time API": [[31, 43]]}}}, {"text": "You can use filter which only keeps String[] that contains non-empty strings", "label": {"api": {"filter": [[12, 17]]}}}, {"text": "There isn't really something in standard Java that does this for you, except maybe using javax.sql.rowset.WebRowSet and one of its writeXml methods, but that is a very specific and verbose format", "label": {"api": {"javax.sql.rowset.WebRowSet": [[89, 114]]}}}, {"text": "To use a ListIterator to traverse forward and replace some items, using the set() method", "label": {"api": {"ListIterator": [[9, 20]], "set()": [[76, 80]]}}}, {"text": "You are not overriding the equals in the Object class(Object.equals)", "label": {"api": {"Object.equals": [[54, 66]]}}}, {"text": "These classes have not been removed, see the JavaDoc for javax.naming and javax.xml.namespace", "label": {"api": {"javax.naming": [[57, 68]], "javax.xml.namespace": [[74, 92]]}}}, {"text": "Using the Comparable interface, you can call the compareTo method to get that behavior", "label": {"api": {"compareTo": [[49, 57]]}}}, {"text": "Since recent migration to Java 10, we are also considering replacing Joda-Time by java.time classes in our codebase", "label": {"api": {"java.time": [[82, 90]]}}}, {"text": "Run again the code you will get a ClassCastException saying that it is trying to convert org.joda.time.LocalDate to java.time.LocalDate", "label": {"api": {"java.time": [[116, 124]]}}}, {"text": "Even if your matrices are large enough that using a loop is causing performance degradation, it would be better to use a ThreadPoolExecutor or similar to start tasks which handle multiple elements of the matrices than to use threads directly", "label": {"api": {"ThreadPoolExecutor": [[121, 138]]}}}, {"text": "One of the Java 9 features I've tested is the List.of() to create an unmodifiable list", "label": {"api": {"List.of()": [[46, 54]]}}}, {"text": "Quoting the JavaDoc of Stream#peek()", "label": {"api": {"Stream#peek()": [[23, 35]]}}}, {"text": "It's a method which, underneath the scenes, provides the terminal operation of a Stream through a Consumer", "label": {"api": {"terminal operation of a Stream": [[57, 86]]}}}, {"text": "java.text.Format does not have method parse, so the code does not compile", "label": {"api": {"java.text.Format": [[0, 15]]}}}, {"text": "You can refer it by java.text.DateFormat", "label": {"api": {"java.text.DateFormat": [[20, 39]]}}}, {"text": "Use java.text.DateFormat instead", "label": {"api": {"java.text.DateFormat": [[4, 23]]}}}, {"text": "Calling File#createNewFile is safe, assuming the path is valid and you have write permissions on it", "label": {"api": {"File#createNewFile": [[8, 25]]}}}, {"text": "You could use orElse to retrieve the actual double value wrapped by the OptionalDouble", "label": {"api": {"orElse": [[14, 19]]}}}, {"text": "You can simply use Collectors.toMap()", "label": {"api": {"Collectors.toMap()": [[19, 36]]}}}, {"text": "Have you written a class with those two properties specifying an Hour-like (maybe Calendar) type", "label": {"api": {"Calendar": [[82, 89]]}}}, {"text": "With that said, Predicate has an and method which you can use to chain conditions together", "label": {"api": {"Predicate has an and method": [[16, 42]]}}}, {"text": "From the documentation for Iterator", "label": {"api": {"the documentation for Iterator": [[5, 34]]}}}, {"text": "Here is an MCVE that uses Timeline", "label": {"api": {"Timeline": [[26, 33]]}}}, {"text": "To get different durations use @fabian Timeline example", "label": {"api": {"Timeline": [[39, 46]]}}}, {"text": "Or you can use ZonedDateTime since java8", "label": {"api": {"ZonedDateTime": [[15, 27]]}}}, {"text": "The default radix is 10, you can specify the radix with BigInteger​(String val, int radix), try", "label": {"api": {"BigInteger​(String val, int radix)": [[56, 89]]}}}, {"text": "All I did was adjusting the signature of the parseKeysAscending method, so that it conforms to what Comparator.comparing actually expects", "label": {"api": {"Comparator.comparing": [[100, 119]]}}}, {"text": "Java 7 added the java.util.Objects class with several utility methods", "label": {"api": {"java.util.Objects": [[17, 33]]}}}, {"text": "One of these, Objects.hashCode returns a int hash value for the single passed Object", "label": {"api": {"Objects.hashCode": [[14, 29]]}}}, {"text": "How is this different than just calling the superclass method Object::hashCode on the original object", "label": {"api": {"Object::hashCode": [[62, 77]]}}}, {"text": "Since Java8, you can use java.time.LocalDateTime", "label": {"api": {"java.time.LocalDateTime": [[25, 47]]}}}, {"text": "A java.time solution using ZonedDateTime.until", "label": {"api": {"ZonedDateTime.until": [[27, 45]]}}}, {"text": "When you are passing in a lambda to the thread, you are not creating a subclass of Thread, instead you are passing in the FunctionalInterface of Runnable and calling a constructor of Thread", "label": {"api": {"Runnable": [[145, 152]]}}}, {"text": "When you attempt to call Sleep, the context of your scope is a combination of Runnable + your class (you can call default methods if the Runnable interface had them), not Thread", "label": {"api": {"Runnable": [[78, 85], [137, 144]]}}}, {"text": "Runnable does not have sleep() defined, but Thread does", "label": {"api": {"Runnable": [[0, 7]]}}}, {"text": "In the iText 7 API documentation of PdfWriter, you can read that the constructor takes an OutputStream", "label": {"api": {"OutputStream": [[90, 101]]}}}, {"text": "This can be any OutputStream, like a  FileOutputStream or a ByteArrayOutputStream", "label": {"api": {"OutputStream": [[16, 27], [42, 53], [69, 80]], "FileOutputStream": [[38, 53]], "ByteArrayOutputStream": [[60, 80]]}}}, {"text": "Depending on the case you may want to use either a LinkedHashMap or a TreeMap", "label": {"api": {"LinkedHashMap": [[51, 63]], "TreeMap": [[70, 76]]}}}, {"text": "I'm providing some InputStream to the consumer and am using aquire in the read-method providing one byte at a time only", "label": {"api": {"read": [[74, 77]]}}}, {"text": "I've already read about the \"downsides\" of RateLimiter regarding bursts and such, but don't see if and how this explains my problem", "label": {"api": {"read": [[7, 10], [13, 16]]}}}, {"text": "The Javadoc of dropWhile states", "label": {"api": {"dropWhile": [[15, 23]]}}}, {"text": "The dropWhile method, introduced in Java 9, will remove the longest starting set of elements that match the predicate", "label": {"api": {"dropWhile method": [[4, 19]]}}}, {"text": "To use BigInteger correctly, you need to its methods https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html", "label": {"api": {"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html": [[53, 138]]}}}, {"text": "Not exactly, but Java 7 added the ForkJoinPool, which was specifically meant to execute decomposed subtasks (parts of a larger task) in parallel", "label": {"api": {"ForkJoinPool": [[34, 45]]}}}, {"text": "Java 5 also added the ThreadPoolExecutor, which isn't specifically for running decomposed subtasks, but it could still be used for it with a little more work", "label": {"api": {"ThreadPoolExecutor": [[22, 39]]}}}, {"text": "I highly recommend you read through the rules given in the Math.pow(double, double) Javadoc", "label": {"api": {"Math.pow(double, double) Javadoc": [[59, 90]]}}}, {"text": "To make sure a class is initialized, call Class.forName(String name, boolean initialize, ClassLoader loader) with a true value for the initialize parameter", "label": {"api": {"Class.forName(String name, boolean initialize, ClassLoader loader)": [[42, 107]]}}}, {"text": "BigInteger(byte[]) takes the two's-complement binary representation while bigInt.fromArray() takes an array of digits with a default base of 10", "label": {"api": {"BigInteger(byte[])": [[0, 17]]}}}, {"text": "The class_ip@312b1dae is retured by the default Object#toString(), you need override it in class_ip, for example", "label": {"api": {"Object#toString()": [[48, 64]]}}}, {"text": "Since your filename is not a valid URL relative to the classpath root, the getResouce method returns null (as documented)", "label": {"api": {"documented": [[110, 119]]}}}, {"text": "However, the Applet class is deprecated", "label": {"api": {"the Applet class is deprecated": [[9, 38]]}}}, {"text": "You should play sounds using the javax.sound.sampled package", "label": {"api": {"javax.sound.sampled package": [[33, 59]]}}}, {"text": "You can create a java.time.Instant instance from the time you collected", "label": {"api": {"java.time.Instant": [[17, 33]]}}}, {"text": "Instead of an Array for students, you might consider using a Collection, like a ArrayList or a Hashset", "label": {"api": {"Collection": [[61, 70]], "ArrayList": [[80, 88]], "Hashset": [[95, 101]]}}}, {"text": "The java scripting API uses AccessController.doPrivileged() to run the script, so depending on context there are could be any restrictions done", "label": {"api": {"AccessController.doPrivileged()": [[28, 58]]}}}, {"text": "Enum.valueOf(Class<T> enumType, String name) tries to create an enum of type enumType with the given name (see Enum.valueOf javadoc)", "label": {"api": {"see Enum.valueOf javadoc": [[107, 130]]}}}, {"text": "What you actually need is called BlockingQueue", "label": {"api": {"BlockingQueue": [[33, 45]]}}}, {"text": "Both BlockingQueue and Semaphore are token containers (places in Petri Net terminology) and so both can be used for synchronization of parallel processes (threads)", "label": {"api": {"BlockingQueue": [[5, 17]]}}}, {"text": "By design, Semaphore holds indistinguishable tokens, and BlockingQueue holds colored tokens, represented as references to arbitrary objects", "label": {"api": {"BlockingQueue": [[57, 69]]}}}, {"text": "BlockingQueue::put corresponds to  Semaphore::release, and  BlockingQueue::take corresponds to Semaphore::aquire", "label": {"api": {"BlockingQueue": [[0, 12], [60, 72]]}}}, {"text": "You should use Class#getName instead", "label": {"api": {"Class#getName": [[15, 27]]}}}, {"text": "What you can do is use a TextFormatter and use listeners instead of binding", "label": {"api": {"TextFormatter": [[25, 37]]}}}, {"text": "It then passes the bytes to one of the defineClass methods, every class loader inherits", "label": {"api": {"defineClass": [[39, 49]]}}}, {"text": "What happens within defineClass, is implementation specific", "label": {"api": {"defineClass": [[20, 30]]}}}, {"text": "Use JavaFX Color", "label": {"api": {"Color": [[11, 15]]}}}, {"text": "For item 2, I am trying to make use of HostNameVerifier implementation", "label": {"api": {"HostNameVerifier": [[39, 54]]}}}, {"text": "My expectation was that MyHostNameVerifier#verify will always be invoked, and I can make certain checks there", "label": {"api": {"HostNameVerifier": [[26, 41]]}}}, {"text": "However, I have observed that HostNameVerifier#verify method is called only if I used IP address of the site, or only if the hostname does not match with Subject of certificate or any of the Subject Alternate Names", "label": {"api": {"HostNameVerifier": [[30, 45]]}}}, {"text": "HostNameVerifier#verify is not called in below cases", "label": {"api": {"HostNameVerifier": [[0, 15]]}}}, {"text": "Runtime.exec() is different in that you start the process but it's up to you to read it's output from the Process that gets returned", "label": {"api": {"Runtime.exec()": [[0, 13]], "Process": [[106, 112]]}}}, {"text": "Use the JEditorPane’s Document object", "label": {"api": {"Document object": [[22, 36]]}}}, {"text": "Full quote of the javadoc of shutdown()", "label": {"api": {"shutdown()": [[29, 38]]}}}, {"text": "Use awaitTermination to do that", "label": {"api": {"awaitTermination": [[4, 19]]}}}, {"text": "If you don't want queued tasks to execute, call shutdownNow()", "label": {"api": {"shutdownNow()": [[48, 60]]}}}, {"text": "Use awaitTermination to do that", "label": {"api": {"awaitTermination": [[4, 19]]}}}, {"text": "This implementation cancels tasks via Thread.interrupt(), so any task that fails to respond to interrupts may never terminate", "label": {"api": {"Thread.interrupt()": [[38, 55]]}}}, {"text": "Use Character.toChars(int) to convert from a code point to representing characters", "label": {"api": {"Character.toChars(int)": [[4, 25]]}}}, {"text": "One way to do is to use DateTimeFormatter.ofLocalizedDate() factory method which returns a locale specific date format for the ISO chronology", "label": {"api": {"DateTimeFormatter.ofLocalizedDate()": [[24, 58]]}}}, {"text": "You need to implement the AttributeConverter interface", "label": {"api": {"AttributeConverter": [[26, 43]]}}}, {"text": "Java offers the KeyEvent class for key codes but they're not applicable here, are they", "label": {"api": {"KeyEvent": [[16, 23]]}}}, {"text": "FileInputStream.read() reads a byte of data", "label": {"api": {"FileInputStream.read()": [[0, 21]]}}}, {"text": "The String indexOf function won't work here as a solution to your problem since it is meant to provide you with the index of the first occurrence of the required substring(a particular character in this case)", "label": {"api": {"indexOf": [[11, 17]]}}}, {"text": "The simple example is the Files.lines method in the Java API itself", "label": {"api": {"Files.lines": [[26, 36]]}}}, {"text": "First, you could make the Queue handle Comparable objects", "label": {"api": {"Comparable": [[39, 48]]}}}, {"text": "or, if you don't want to impose this natural ordering on the Customer class, the Queue class can take a Comparator, such as Comparator.comparingInt(Customer::getNetWorth()) when its constructed", "label": {"api": {"Comparator": [[104, 113], [124, 133]]}}}, {"text": "Example from the doc", "label": {"api": {"Example": [[0, 6]]}}}, {"text": "The two calls to s.forEach utilise the same stream hence the exception in the first example whereas the call to the stream() method --> numbers.stream() generates (yields) a new stream each time hence doesnt throw a \"java.lang.IllegalStateException", "label": {"api": {"stream()": [[116, 123], [144, 151]]}}}, {"text": "if you want to use multiple time use Supplier for this", "label": {"api": {"Supplier": [[37, 44]]}}}, {"text": "Use Collection.removeIf(), you will remove all elements from the list, that are matching given criteria", "label": {"api": {"Collection.removeIf()": [[4, 24]]}}}, {"text": "I am putting the results of a Java 11 stream into a Collectors.toMap(keyMapper, valueMapper) collector", "label": {"api": {"Collectors.toMap(keyMapper, valueMapper)": [[52, 91]]}}}, {"text": "As the Dialog documentation and DialogPane documentation explain, you do want to create a custom ButtonType, simply by using the ButtonType constructors", "label": {"api": {"Dialog documentation": [[7, 26]], "DialogPane documentation": [[32, 55]]}}}, {"text": "call initOwner with the parent Window", "label": {"api": {"initOwner": [[5, 13]]}}}, {"text": "You'd better use Cache#asMap() view and change value inside ConcurrentMap#compute(K, BiFunction<K, V, V>) method", "label": {"api": {"ConcurrentMap#compute(K, BiFunction<K, V, V>)": [[60, 104]]}}}, {"text": "This is detailed at java.text.MessageFormat", "label": {"api": {"java.text.MessageFormat": [[20, 42]]}}}, {"text": "The string you pass to MessageFormat.format() is a pattern", "label": {"api": {"MessageFormat.format()": [[23, 44]]}}}, {"text": "The # subformat is described at java.text.DecimalFormat", "label": {"api": {"java.text.DecimalFormat": [[32, 54]]}}}, {"text": "It simply means to not use fraction digits, only display it as an integer, and if it is not an integer, it will be rounded (using the RoundingMode.HALF_EVEN mode)", "label": {"api": {"RoundingMode.HALF_EVEN": [[134, 155]]}}}, {"text": "Bit operations are fast for it, since it's a sign-magnitude value and the magnitude is stored packed just as you'd expect, just make sure that you use the relevant BigInteger bitwise methods rather than implementing your own", "label": {"api": {"the relevant BigInteger bitwise methods": [[151, 189]]}}}, {"text": "In java one can iterate through all GrahicsEnvironment's fonts", "label": {"api": {"GrahicsEnvironment's fonts": [[36, 61]]}}}, {"text": "If precision is a real problem for you, you should look at using BigDecimal", "label": {"api": {"BigDecimal": [[65, 74]]}}}, {"text": "You should use PreparedStatement to set parameter for safe", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "So you should just use the appropriate constructor", "label": {"api": {"appropriate constructor": [[27, 49]]}}}, {"text": "Furthermore, if you want your map to work as a LRU cache, you can create your own class that extends LinkedHashMap and overrides the removeEldestEntry method", "label": {"api": {"removeEldestEntry": [[133, 149]]}}}, {"text": "The removeEldestEntry(Map.Entry) method may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map", "label": {"api": {"removeEldestEntry": [[4, 20]]}}}, {"text": "MethodHandles.Lookup.defineClass generates a new class from a byte array at runtime", "label": {"api": {"MethodHandles.Lookup.defineClass": [[0, 31]]}}}, {"text": "Take a look at the javadoc of the HashMap and specifically the method Hashmap.computeIfAbsent", "label": {"api": {"Hashmap.computeIfAbsent": [[70, 92]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#substring-int-int- could be your friend", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#substring-int-int-": [[0, 81]]}}}, {"text": "You can use limit after filter", "label": {"api": {"limit": [[12, 16]]}}}, {"text": "This will stop the stream after 100 items have been found after filtering (limit is a short-circuiting stream operation)", "label": {"api": {"limit": [[75, 79]]}}}, {"text": "Use ProcessBuilder instead", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "But you can't simply use count() on Stream", "label": {"api": {"count() on Stream": [[25, 41]]}}}, {"text": "Take a look at the printf format string specification and you should find what you need", "label": {"api": {"format string specification": [[26, 52]]}}}, {"text": "If you're not doing this for homework, and you need performance for a real-world use, use Java's built-in bitwise methods in the Integer class, which use very, very fast CPU instructions on CPUs that have them", "label": {"api": {"the Integer class": [[125, 141]]}}}, {"text": "Since CourseStatus is an enum (not Enum), it is automatically Comparable, so to add a secondary sort order by status, you call thenComparing()", "label": {"api": {"thenComparing()": [[127, 141]]}}}, {"text": "You can either change the request to send valid JSON – in which case Viet's answer should work, or change the Resource to consume form-encoded data and then extract it using FormParam, i.e.", "label": {"api": {"FormParam": [[174, 182]]}}}, {"text": "Using streams (introduced in Java 8) you can get the sum writing one line", "label": {"api": {"streams": [[6, 12]]}}}, {"text": "No, @OneToMany just indicates the static entity relationship that underneath the hood is translated into foreign keys etc., together with some hints about eager/lazy retrieval, cascading of updates/deletes", "label": {"api": {"@OneToMany": [[4, 13]]}}}, {"text": "matches() requires XPath 2.0, but javax.xml.xpath in Java 8 supports only XPath 1.0", "label": {"api": {"javax.xml.xpath": [[34, 48]]}}}, {"text": "See GlyphVector#getOutline(float, float) for more details", "label": {"api": {"GlyphVector#getOutline(float, float)": [[4, 39]]}}}, {"text": "You can, however, use Class.getResourceAsStream to copy the certificates to a new file", "label": {"api": {"Class.getResourceAsStream": [[22, 46]]}}}, {"text": "Count down by using PauseTransition", "label": {"api": {"PauseTransition": [[20, 34]]}}}, {"text": "Alternatively you could use Timeline", "label": {"api": {"Timeline": [[28, 35]]}}}, {"text": "The pattern I have used matches one or multiple whitespace characters - see The JavaDocs of Pattern for details and other options", "label": {"api": {"The JavaDocs of Pattern": [[76, 98]]}}}, {"text": "The getStatus() method was only added in Servlet version 3.0, you have version 2.5 specified in the JUnit testing section in your pom", "label": {"api": {"getStatus()": [[4, 14]]}}}, {"text": "If your task is a Runnable, not Callable, it will return a Void, so as you have pointed out, there is no point in checking the result", "label": {"api": {"Runnable": [[18, 25]], "Callable": [[32, 39]]}}}, {"text": "The main advantages of CompletableFuture are the methods that allow you to handle exceptions, and further process the data", "label": {"api": {"Future": [[34, 39]]}}}, {"text": "It also has methods wo wait for all and single task to complete from a set of ComplatableFuture tasks", "label": {"api": {"Future": [[89, 94]]}}}, {"text": "get() method works same as for Future class though", "label": {"api": {"Future": [[31, 36]]}}}, {"text": "But if you want for the to complete before going further, then you can use CompletableFuture.allOf()", "label": {"api": {"Future": [[86, 91]]}}}, {"text": "Use local date, the problem is that when dates are involved, java tries to convert the date to the server timezone, since the is no time zone specified, it takes the hour ad UTC and then converts, LocalDate does not contain the timezone info, so, the date will be parsed as is", "label": {"api": {"local date": [[4, 13]]}}}, {"text": "Sorry, forgot to mention, to handle local date time you need to use jackson-datatype-jsr310", "label": {"api": {"local date": [[36, 45]]}}}, {"text": "You can use the endsWith() function", "label": {"api": {"endsWith()": [[16, 25]]}}}, {"text": "A Java Instant has very useful methods to compare two instant with each other, namely isAfter() and isBefore()", "label": {"api": {"Instant": [[7, 13]], "isAfter()": [[86, 94]], "isBefore()": [[100, 109]]}}}, {"text": "For instance, at present time (Instant.now()), at most parts in the world, it's 12/10/2018, at some however, it's already 13/10/2018 (Samoa), and at others it's 11/10/2018 (the US Minor Outlying Islands, only one minute left)", "label": {"api": {"Instant": [[31, 37]]}}}, {"text": "For counting words, you can use Map.merge", "label": {"api": {"Map.merge": [[32, 40]]}}}, {"text": "I would use groupingBy in two separate streaming operations", "label": {"api": {"groupingBy": [[12, 21]]}}}, {"text": "This solution doesn't use streams, but Java 8's Map.computeIfAbsent method instead", "label": {"api": {"Map.computeIfAbsent": [[48, 66]]}}}, {"text": "To get the enum from a String you can use the valueOf() method", "label": {"api": {"valueOf()": [[46, 54]]}}}, {"text": "SecondsTime is a float, which will call the overloaded version of round() which returns an int", "label": {"api": {"round()": [[66, 72]]}}}, {"text": "That process is asynchronous, and even if GC has \"cleared\" your keys, WeakHashMap still has a strong reference to the value", "label": {"api": {"WeakHashMap": [[70, 80]]}}}, {"text": "You call any other method on the WeakHashMap - that will do the needed clean-up", "label": {"api": {"WeakHashMap": [[33, 43]]}}}, {"text": "A better option (see camickr comment) is to animate using swing Timer", "label": {"api": {"Timer": [[64, 68]]}}}, {"text": "You can use EnumMap here", "label": {"api": {"EnumMap": [[12, 18]]}}}, {"text": "So here a version without Java 8 goodies like streams, collectors and new map methods like Map.compute()", "label": {"api": {"Map.compute()": [[91, 103]]}}}, {"text": "Instead simply read from System.in as a String and use the method .equalsIgnoreCase() so it will match either an upper case Y/N or lower case y/n", "label": {"api": {".equalsIgnoreCase()": [[66, 84]]}}}, {"text": "If you cannot use a List you can use Arrays.copyOf() and i to copy as many elements as the user inputted to a new Array", "label": {"api": {"Arrays.copyOf()": [[37, 51]]}}}, {"text": "Why doesn't oracle or tutorialspoint say anything about how methods are implemented", "label": {"api": {"oracle": [[12, 17]]}}}, {"text": "If only the last character is changing for messages starting with \"10.0.0\", you could use startsWith() for the other cases than \"Help\"", "label": {"api": {"startsWith()": [[90, 101]]}}}, {"text": "You probably want to use System.out.print() first", "label": {"api": {"System.out.print()": [[25, 42]]}}}, {"text": "A related example from another project is a custom TrustManager implementation I used to handle revocation status for our internal CA PKI", "label": {"api": {"TrustManager": [[51, 62]]}}}, {"text": "I'd like to create a JavaFX application with MenuBar and I want my application to look more native-like, so I set useSystemMenuBarProperty to true", "label": {"api": {"MenuBar": [[45, 51], [123, 129]], "useSystemMenuBarProperty": [[114, 137]]}}}, {"text": "JSONObject implements the Map interface, so you can use the same way you'd use for Map to generate the list of keys", "label": {"api": {"JSONObject": [[0, 9]]}}}, {"text": "In particular, you can use the .keySet() or .entrySet() method", "label": {"api": {".keySet()": [[31, 39]], ".entrySet()": [[44, 54]]}}}, {"text": "You could use Optional.ofNullable and repeatedly map the value into another, unless you encouter null on the way, and then get the final value orElse null", "label": {"api": {"Optional.ofNullable": [[14, 32]], "map": [[49, 51]], "orElse": [[143, 148]]}}}, {"text": "ProcessBuilder replaced Runtime.exec many years ago", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "ProcessBuilder passes arguments directly to a process;  since you don’t build a command string yourself, there is no possibility of inadvertently executing a second command", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "Instead, use a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[15, 35]]}}}, {"text": "I have come across CompoundEdit, a Swing class that has a list of edit actions from a text editor", "label": {"api": {"CompoundEdit": [[19, 30]]}}}, {"text": "So, if I create a MyEdit class that extends CompoundEdit, MyEdit should have access to the list of edits", "label": {"api": {"CompoundEdit": [[44, 55]]}}}, {"text": "And this is an extract of the CompoundEdit.java code", "label": {"api": {"CompoundEdit": [[30, 41]]}}}, {"text": "The java.net.HttpURLConnection class allows you to set a connect timeout and a read timeout", "label": {"api": {"java.net.HttpURLConnection": [[4, 29]]}}}, {"text": "You could use the indexOf and substring functions instead to extract the numbers", "label": {"api": {"indexOf": [[18, 24]], "substring": [[30, 38]]}}}, {"text": "Why not utilize Lists and instantiate an ArrayList so that you don't have to worry about extra/undefined elements in your collection", "label": {"api": {"Lists": [[16, 20]], "ArrayList": [[41, 49]]}}}, {"text": "Use two ArrayLists, one with objects to remove and use removeAll method", "label": {"api": {"removeAll method": [[55, 70]]}}}, {"text": "Maybe you want ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[15, 34]]}}}, {"text": "When you declare new KeyListener() { ..", "label": {"api": {"KeyListener": [[21, 31]]}}}, {"text": "} you're creating what's known as an anonymous inner class that extends KeyListener and creates an unnamed instance of it (hence anonymous)", "label": {"api": {"KeyListener": [[72, 82]]}}}, {"text": "The error is complaining that your anonymous inner class, displayed as <anonymous DisplayerDeluxe$1>, is neither abstract nor does it implement the method keyReleased(java.awt.event.KeyEvent) as described in java.awt.event.KeyListener", "label": {"api": {"KeyListener": [[223, 233]]}}}, {"text": "KeyListener is an interface that contracts implementors to provide 3 methods", "label": {"api": {"KeyListener": [[0, 10]]}}}, {"text": "Thread.join method works only if the thread has started, else it does nothing", "label": {"api": {"Thread.join": [[0, 10]]}}}, {"text": "So you must reorder your code, but if you just move the join method after start, when starting the first thread by calling CounterThread.start, the main thread will wait until the started thread has finished, blocked in the Thread.join method, and only then will continue to starting the second one", "label": {"api": {"Thread.join": [[224, 234]]}}}, {"text": "Correct thread-safe implementation of getGaugeLazy using ConcurrentHashMap and computeIfAbsent", "label": {"api": {"ConcurrentHashMap": [[57, 73]], "computeIfAbsent": [[79, 93]]}}}, {"text": "One way to do it would be to register a new shutdown hook thread using Runtime.addShutdownHook", "label": {"api": {"Runtime.addShutdownHook": [[71, 93]]}}}, {"text": "If you can use a ThreadPoolExecutor directly rather than an ExecutorService from Executors1, then there's perhaps a more standard/supported way to start all the core threads immediately", "label": {"api": {"ThreadPoolExecutor": [[17, 34]]}}}, {"text": "The above uses prestartAllCoreThreads()", "label": {"api": {"prestartAllCoreThreads()": [[15, 38]]}}}, {"text": "Note that, currently, the implementation of Executors.newFixedThreadPool(int) creates a ThreadPoolExecutor in the exact same manner as above", "label": {"api": {"ThreadPoolExecutor": [[88, 105]]}}}, {"text": "This means you could technically cast the ExecutorService returned by the factory method to a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[94, 111]]}}}, {"text": "There's nothing in the documentation that guarantees it will be a ThreadPoolExecutor, however", "label": {"api": {"ThreadPoolExecutor": [[66, 83]]}}}, {"text": "ThreadPoolExecutor implements ExecutorService but provides more functionality", "label": {"api": {"ThreadPoolExecutor": [[0, 17]]}}}, {"text": "Also, many of the factory methods in Executors either returns a ThreadPoolExecutor directly or a wrapper that delegates to one", "label": {"api": {"ThreadPoolExecutor": [[64, 81]]}}}, {"text": "Use  Connection.isClosed() instead of while( null== conn)", "label": {"api": {"Connection.isClosed()": [[5, 25]]}}}, {"text": "You can add XmlSchema annotation in your document class to make it work with xmlns attribute", "label": {"api": {"XmlSchema": [[12, 20]]}}}, {"text": "One thing you can use is String.join()", "label": {"api": {"String.join()": [[25, 37]]}}}, {"text": "Now, String's compareTo claims to use \"lexicographic ordering,\" but it really just uses numeric ordering, so that may be good enough for what you're doing", "label": {"api": {"compareTo": [[14, 22]]}}}, {"text": "There may be one I don't know of, or you may have to create one-character strings to do the comparison (with a Collator), which will (for instance) correctly identify that the à in \"voilà\" should be before any of the other letters in it", "label": {"api": {"Collator": [[111, 118]]}}}, {"text": "See second paragraph in the javadoc of java.util.Date", "label": {"api": {"java.util.Date": [[39, 52]]}}}, {"text": "As of JDK 1.1, the Calendar class should be used to convert between dates and time fields and the DateFormat class should be used to format and parse date strings", "label": {"api": {"Calendar": [[19, 26]], "DateFormat": [[98, 107]]}}}, {"text": "Ability to specify time zone (using Calendar)", "label": {"api": {"Calendar": [[36, 43]]}}}, {"text": "Ability to use non-Gregorian calendar (using Calendar)", "label": {"api": {"Calendar": [[45, 52]]}}}, {"text": "Ability to use localized formatting and parsing of date strings (using DateFormat)", "label": {"api": {"DateFormat": [[71, 80]]}}}, {"text": "There are Math.nextUp and Math.nextDown, both overloaded for both float and double parameters", "label": {"api": {"Math.nextUp": [[10, 20]], "Math.nextDown": [[26, 38]]}}}, {"text": "The issue is that Character.getNumericValue() converts a character to a number, using particular rules explained here", "label": {"api": {"explained here": [[103, 116]]}}}, {"text": "This is not supported by https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#parseLong(java.lang.String)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html#parseLong(java.lang.String)": [[25, 113]]}}}, {"text": "Consider using JDialog container", "label": {"api": {"JDialog": [[15, 21]]}}}, {"text": "When it is undecorated, you can change its opacity", "label": {"api": {"undecorated": [[11, 21]], "opacity": [[43, 49]]}}}, {"text": "I don't have exact numbers from point of view of the performance but I would use the Java 8 Time API to solve this issue", "label": {"api": {"Java 8 Time API": [[85, 99]]}}}, {"text": "You'd then use the index to remove the player with some in inbuilt methods", "label": {"api": {"methods": [[67, 73]]}}}, {"text": "See the Runtime API to register a shutdown hook - basically use a Thread to call a method when JVM is terminated (normally or through an interrupt such as CTRL + C)", "label": {"api": {"Runtime API": [[8, 18]]}}}, {"text": "You can use JDK's Math.round", "label": {"api": {"Math.round": [[18, 27]]}}}, {"text": "We can see that the hashCode of the key is used to select the bucket, and then it's a linear search within that bucket for the entry", "label": {"api": {"hashCode": [[20, 27]]}}}, {"text": "NumberFormat.getNumberInstance() \"Returns a general-purpose number format for the current default FORMAT locale.\" You can adjust the rounding mode and the number of digits as desired", "label": {"api": {"NumberFormat.getNumberInstance()": [[0, 31]]}}}, {"text": "The invokeAll method can be used for RecursiveTasks", "label": {"api": {"invokeAll": [[4, 12]], "RecursiveTask": [[37, 49]]}}}, {"text": "It takes two ForkJoinTasks as parameters, and because RecursiveTask extends ForkJoinTask, a RecursiveTask can be used as a ForkJoinTask", "label": {"api": {"RecursiveTask": [[54, 66], [92, 104]], "ForkJoinTask": [[13, 24], [76, 87], [123, 134]]}}}, {"text": "As for getting the results, invokeAll doesn't return anything, so you're not going to get the information that way", "label": {"api": {"invokeAll": [[28, 36]]}}}, {"text": "What you can do is call the join method on each of your RecursiveTasks", "label": {"api": {"RecursiveTask": [[56, 68]], "join": [[28, 31]]}}}, {"text": "Because you know that both tasks have completed when invokeAll returns, the join method will return very quickly", "label": {"api": {"invokeAll": [[53, 61]], "join": [[76, 79]]}}}, {"text": "However, at this point, you may as well just do the thing you were doing originally, calling compute and join", "label": {"api": {"join": [[105, 108]]}}}, {"text": "Using invokeAll is a bit clumsy when you only have two tasks and you need both of their results", "label": {"api": {"invokeAll": [[6, 14]]}}}, {"text": "The three-argument Stream.reduce is more flexible", "label": {"api": {"Stream.reduce": [[19, 31]]}}}, {"text": "in comparison with the two-argument IntStream.reduce that accepts and returns only int values", "label": {"api": {"Stream.reduce": [[39, 51]], "IntStream.reduce": [[36, 51]]}}}, {"text": "Note, that both approaches above will result in an exception if the source is empty, so if you want to handle that then you can use isPresent or some of the other Optional methods as such of orElse et al", "label": {"api": {"Optional": [[163, 170]]}}}, {"text": "If you want the initial value to be true, use the constructor which takes a boolean", "label": {"api": {"the constructor which takes a boolean": [[46, 82]]}}}, {"text": "The class java.util.Locale is declared as final, which means that nothing can extend it", "label": {"api": {"java.util.Locale": [[10, 25]]}}}, {"text": "In that case, I believe what you're looking for is a ConcurrentSkipListSet, which is essentially a concurrent TreeSet", "label": {"api": {"ConcurrentSkipListSet": [[53, 73]]}}}, {"text": "You can use ConcurrentSkipListSet#headSet.size() or ConcurrentSkipListSet#tailSet.size() to get the amount of elements greater/less than (or equal to) a single element where you can pass in a custom Comparator", "label": {"api": {"ConcurrentSkipListSet": [[12, 32], [52, 72]]}}}, {"text": "The easiest approach would probably be to use Arrays#asList", "label": {"api": {"Arrays#asList": [[46, 58]]}}}, {"text": "If you're using Java 9 or above, you could also use the slightly more elegant List#of", "label": {"api": {"List#of": [[78, 84]]}}}, {"text": "I would use the https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html": [[16, 96]]}}}, {"text": "Also, I'll just point out you should probably avoid this API and use the java.time APIs instead", "label": {"api": {"java.time": [[73, 81]]}}}, {"text": "Your main problem is the delimiter string you're passing to Scanner.useDelimiter()", "label": {"api": {"Scanner.useDelimiter()": [[60, 81]]}}}, {"text": "String.split() is enough", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "I came to know that in Java, LinkedList class implements both Deque and List interfaces", "label": {"api": {"LinkedList class implements both Deque and List": [[29, 75]]}}}, {"text": "For example, List interface has the following methods", "label": {"api": {"the following methods": [[32, 52]]}}}, {"text": "But Queue has only the following", "label": {"api": {"has only the following": [[10, 31]]}}}, {"text": "If you need a Queue, you never write", "label": {"api": {"Queue": [[14, 18]]}}}, {"text": "Now you only have access to the 6 Queue methods (and all the Collection methods)", "label": {"api": {"Queue": [[34, 38]], "Collection": [[61, 70]]}}}, {"text": "So, even though LinkedList implements more methods, you no longer have access to them", "label": {"api": {"LinkedList": [[16, 25]]}}}, {"text": "So, if you need a Queue, you choose the implementation of the Queue interface that best suits the performance, storage, and access characteristics you need, e.g", "label": {"api": {"Queue": [[18, 22], [62, 66]]}}}, {"text": "LinkedList uses more memory, but it shrinks when queue is emptied", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "ArrayDeque uses less memory, but it doesn't shrink", "label": {"api": {"ArrayDeque": [[0, 9]]}}}, {"text": "PriorityQueue is a non-FIFO queue with element priority", "label": {"api": {"Queue": [[8, 12]], "PriorityQueue": [[0, 12]]}}}, {"text": "ConcurrentLinkedQueue, ConcurrentLinkedDeque supports multi-threaded concurrent access", "label": {"api": {"Queue": [[16, 20]], "ConcurrentLinkedQueue": [[0, 20]], "ConcurrentLinkedDeque": [[23, 43]]}}}, {"text": "A LinkedList behaves like a List", "label": {"api": {"LinkedList": [[2, 11]]}}}, {"text": "A LinkedList behaves like a Deque", "label": {"api": {"LinkedList": [[2, 11]]}}}, {"text": "A LinkedList behaves like a Queue", "label": {"api": {"Queue": [[28, 32]], "LinkedList": [[2, 11]]}}}, {"text": "But just because LinkedList behaves like all of those, doesn't mean that List behaves like a Queue or that Queue behaves like a List", "label": {"api": {"Queue": [[93, 97], [107, 111]], "LinkedList": [[17, 26]]}}}, {"text": "The contract of Deque doesn't explicitly mention that implementors will never ever be able to add/remove/check elements at any given index", "label": {"api": {"The contract of Deque": [[0, 20]]}}}, {"text": "You're catching the wrong exception - if the input isn't an int, an InputMismatchException will be thrown", "label": {"api": {"InputMismatchException": [[68, 89]]}}}, {"text": "But regardless, this can be made easier by using hasNextInt()", "label": {"api": {"hasNextInt()": [[49, 60]]}}}, {"text": "According to the documentation Media constructor expects string in URI format, so you should use", "label": {"api": {"URI": [[67, 69]]}}}, {"text": "You can use JSONObject.getJSONArray() to access the array as a JSONArray object, then use .getInt() to retrieve the values", "label": {"api": {"JSONObject.getJSONArray()": [[12, 36]]}}}, {"text": "Check the Scanner Javadoc for examples", "label": {"api": {"Scanner Javadoc": [[10, 24]]}}}, {"text": "Whenever you build a String from parts, in the good case you end up using StringBuilder, or in a slightly worse case StringBuffer, and in the worst case you end up concatenating two strings, then throw them away, and repeat - lots of allocations and garbage collection in this case", "label": {"api": {"StringBuilder": [[74, 86]], "StringBuffer": [[117, 128]]}}}, {"text": "JLS12 still mentions StringBuffer by name for optimization (but hopefully StringBuilder is used internally, as similar technique)", "label": {"api": {"StringBuilder": [[74, 86]], "StringBuffer": [[21, 32]]}}}, {"text": "To increase the performance of repeated string concatenation, a Java compiler may use the StringBuffer class or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression", "label": {"api": {"StringBuffer": [[90, 101]]}}}, {"text": "In the particular case of having a List<String> and later using String.join() on it, StringJoiner contains the particular StringBuilder object which is going to be used", "label": {"api": {"StringBuilder": [[122, 134]]}}}, {"text": "If that's not the case, or if you want to be safe, you could create a copy with Arrays.copyOf", "label": {"api": {"Arrays.copyOf": [[80, 92]]}}}, {"text": "Instead of handling exactly those sentences, you could try to detect a common pattern and devise a Regular Expression to handle that pattern", "label": {"api": {"pattern": [[78, 84], [133, 139]]}}}, {"text": "Try to solve it using Robot object", "label": {"api": {"Robot": [[22, 26]]}}}, {"text": "Check JOptionPane.showConfirmDialog response and compare with JOptionPane.YES_NO_OPTION", "label": {"api": {"JOptionPane.showConfirmDialog": [[6, 34]]}}}, {"text": "Your example definitely violates the non interference requirement", "label": {"api": {"non interference requirement": [[37, 64]]}}}, {"text": "A column is sorted according to the column’s class, which is defined by the model’s getColumnClass method", "label": {"api": {"getColumnClass method": [[84, 104]]}}}, {"text": "If you don’t override the getColumnClass method in your model, every column’s type is Object.class, which means its contents are sorted by their string forms", "label": {"api": {"getColumnClass method": [[26, 46]], "string forms": [[145, 156]]}}}, {"text": "You will need to write a TableModel class which overrides the getColumnClass method", "label": {"api": {"getColumnClass method": [[62, 82]]}}}, {"text": "Quoting javadoc of PriorityQueue", "label": {"api": {"PriorityQueue": [[19, 31]]}}}, {"text": "If most of the time you are just adding at the end and removing from the start then any implementation of Deque would do", "label": {"api": {"Deque": [[106, 110]]}}}, {"text": "So ArrayDeque or LinkedList are probably your best candidates", "label": {"api": {"Deque": [[8, 12]], "ArrayDeque": [[3, 12]], "LinkedList": [[17, 26]]}}}, {"text": "ArrayDeque is backed by an array and can therefore be accessed quickly by index with O(1) complexity but it has the downside that adding can be slower than LinkedList because sometimes the backing array needs to be resized", "label": {"api": {"Deque": [[5, 9]], "ArrayDeque": [[0, 9]], "LinkedList": [[156, 165]]}}}, {"text": "LinkedList is just a linked-list so growing/shrinking it is consistently O(1) but accessing by index is not because to find the nth entry is O(n)", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "One can use a RandomAccessFile", "label": {"api": {"RandomAccessFile": [[14, 29]]}}}, {"text": "While a FileHandler is a quick solution to log files, it is actually rather annoying to use, duo the fact that it accepts its logging properties (like the target file) from the system properties, instead of a contructor", "label": {"api": {"FileHandler": [[8, 18]]}}}, {"text": "Use the Optional.map() method", "label": {"api": {"Optional.map()": [[8, 21]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#stream-int:A- there are more, but this is the one accepting an array of ints", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#stream-int:A-": [[0, 76]]}}}, {"text": "when you write System.ou.println(...), you are invoking println on a PrintStream, which no one imports when writing a 'Hello World'", "label": {"api": {"PrintStream": [[69, 79]]}}}, {"text": "If it is the same machine (jvm and python script), you can leverage ProcessBuilder class itself to execute script directly", "label": {"api": {"ProcessBuilder": [[68, 81]]}}}, {"text": "I think a way to handle this is to use a StringJoiner you can do something like", "label": {"api": {"StringJoiner": [[41, 52]]}}}, {"text": "In Java 11 you could even ditch the nested loop and replace it by the String#repeat(int) to repeat the string", "label": {"api": {"String#repeat(int)": [[70, 87]]}}}, {"text": "According to this SO answer and the ScriptObjectMirror API docs you should be able to use the obj.to(int[].class) method to extract the internal integer array from the proxy object", "label": {"api": {"ScriptObjectMirror API docs": [[36, 62]]}}}, {"text": "This method streams over all files and adds every file by using addAttachment()", "label": {"api": {"streams": [[12, 18]]}}}, {"text": "If you need to format a Timestamp you can use SimpleDateFormat on what you get back from getTimestamp() to format the string any way you need to", "label": {"api": {"SimpleDateFormat": [[46, 61]]}}}, {"text": "I'd use a ReentrantLock https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html then you can just synchronize a block rather than the whole method", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html": [[24, 110]]}}}, {"text": "In your case the writer-thread could have a queue with only relevant information (the strings to output), and the producer-thread will put strings into that queue", "label": {"api": {"queue": [[44, 48], [157, 161]]}}}, {"text": "I recommend to read through the concurrent package to learn about the tools Java offers", "label": {"api": {"concurrent package": [[32, 49]]}}}, {"text": "groupingBy() does exactly this", "label": {"api": {"groupingBy()": [[0, 11]]}}}, {"text": "I was learning Stream.limit() says", "label": {"api": {"Stream.limit()": [[15, 28]]}}}, {"text": "Something I would also do is use more efficient input streams, like a BufferedInputStream", "label": {"api": {"BufferedInputStream": [[70, 88]]}}}, {"text": "We need to inject it as a javax.inject.Provider so that we can lazy retrieve it", "label": {"api": {"javax.inject.Provider": [[26, 46]]}}}, {"text": "With the javax.inject.Provider, we get the actual service by calling get()", "label": {"api": {"javax.inject.Provider": [[9, 29]]}}}, {"text": "If you're using JavaFX, you could use the Screen class to get the visual bounds of the primary screen and manually move/resize the stage", "label": {"api": {"the Screen class": [[38, 53]]}}}, {"text": "I recommend you to check the documentation of LocalDate class", "label": {"api": {"LocalDate": [[46, 54]]}}}, {"text": "Secondly, concatenating strings in a loop is inefficient, and it's better to use a StringBuilder", "label": {"api": {"StringBuilder": [[83, 95]]}}}, {"text": "Alternatively, you could just use replaceAll() with a regular expression", "label": {"api": {"replaceAll()": [[34, 45]]}}}, {"text": "Hashmaps do not preserve ordering", "label": {"api": {"Hashmaps": [[0, 7]]}}}, {"text": "Look at using LinkedHashMaps instead", "label": {"api": {"LinkedHashMaps": [[14, 27]]}}}, {"text": "The class you should be using is ZonedDateTime; as it has full time-zone support(including daylight savings)", "label": {"api": {"ZonedDateTime": [[33, 45]]}}}, {"text": "According to the documentation those are constants which identify the fields to return when querying that object", "label": {"api": {"According to the documentation": [[0, 29]]}}}, {"text": "That's because CrudRepository#findAll returns an Iterable and not a List", "label": {"api": {"Iterable": [[49, 56]], "List": [[68, 71]]}}}, {"text": "So, you either (1) change the method signature to return an Iterable as well or you  (2) copy the elements to a List and return it", "label": {"api": {"Iterable": [[60, 67]], "List": [[112, 115]]}}}, {"text": "(1) Return Iterable", "label": {"api": {"Iterable": [[11, 18]]}}}, {"text": "(2) Copy the elements to a List and return the list", "label": {"api": {"List": [[27, 30]]}}}, {"text": "With Java10+, you could have used an inbuilt capability copyOf for creating an unmodifiable list, like this", "label": {"api": {"copyOf": [[56, 61]]}}}, {"text": "Also, the current list that you're creating using Collector.collectingAndThen is actually immutable as mentioned in the documentation as well", "label": {"api": {"Collector.collectingAndThen": [[50, 76]]}}}, {"text": "Here's from the javadoc for Pattern", "label": {"api": {"javadoc for Pattern": [[16, 34]]}}}, {"text": "First, your methods can be simplified by using the null-safe Objects helper methods added in Java 7", "label": {"api": {"Objects": [[61, 67]]}}}, {"text": "The first bullet point of Memory Consistency Properties is", "label": {"api": {"Memory Consistency Properties": [[26, 54]]}}}, {"text": "I would like to suggest another design and using nio-API and stream-API", "label": {"api": {"nio-API": [[49, 55]], "stream-API": [[61, 70]]}}}, {"text": "The attribute out is effectively a PrintStream, which offers (besides other methods) the following two", "label": {"api": {"PrintStream": [[35, 45]]}}}, {"text": "A more robust solution, that relies only on the strings themselves could be to use Arrays#hashCode", "label": {"api": {"Arrays#hashCode": [[83, 97]]}}}, {"text": "You could use BigInteger", "label": {"api": {"BigInteger": [[14, 23]]}}}, {"text": "With Long.compareUnsigned (and other methods that treat longs as unsigned), bit tricks aren't essential anymore", "label": {"api": {"Long.compareUnsigned": [[5, 24]]}}}, {"text": "Instead you can use Character.getNumericValue() to get the int value", "label": {"api": {"Character.getNumericValue()": [[20, 46]]}}}, {"text": "You can do this very easily by just calling nextInt()", "label": {"api": {"nextInt()": [[44, 52]]}}}, {"text": "When you turn to the javadoc for String.join() you find", "label": {"api": {"String.join()": [[33, 45]]}}}, {"text": "We can try using BigDecimal#pow instead, since BigDecimal has arbitrary length, only limited by memory", "label": {"api": {"BigDecimal#pow": [[17, 30]]}}}, {"text": "Integer is not good choice to do mathematical calculation, please consider using Double for more precision", "label": {"api": {"Double": [[81, 86]]}}}, {"text": "Since you just want to turn that char array into a string as-is, try using the String class' constructor which does just that", "label": {"api": {"String class' constructor": [[79, 103]]}}}, {"text": "The GraphicsDevice.getIDstring() method provides such a String", "label": {"api": {"GraphicsDevice.getIDstring()": [[4, 31]]}}}, {"text": "Collections can automatically give you an iterator, so there's no need to convert it to an ArrayList to get this", "label": {"api": {"Collections can automatically give you an iterator": [[0, 49]]}}}, {"text": "Note that count() returns a long", "label": {"api": {"count()": [[10, 16]]}}}, {"text": "the MyForm in my picture is maybe created at runtime using a for-each inside another JPanel, and therefore I expect to have a Component in order to call add on the JPanel", "label": {"api": {"Component": [[126, 134]]}}}, {"text": "here), and id is a Long", "label": {"api": {"Long": [[19, 22]]}}}, {"text": "The Long class wraps a value of the primitive type long in an object", "label": {"api": {"Long": [[4, 7]]}}}, {"text": "The tokenize() method uses each character of a String as delimiter", "label": {"api": {"tokenize()": [[4, 13]]}}}, {"text": "Note that you do not get empty elements (that would be there in between % and and 2 and C) because tokenize() discards these empty strings when a delimiter appears twice in  succession", "label": {"api": {"tokenize()": [[99, 108]]}}}, {"text": "tokenize uses any of the delimiters, as per StringTokenizer.tokenize", "label": {"api": {"StringTokenizer.tokenize": [[44, 67]]}}}, {"text": "If you are using Java 8 or above and actually you are handling date and time, then I think you should have a try at LocalDate.parse and as to your problem then you can achieve it easily as", "label": {"api": {"LocalDate.parse": [[116, 130]]}}}, {"text": "To remove the oldest student from your TreeSet, you can use the pollLast method, which does exactly what you want", "label": {"api": {"pollLast": [[64, 71]]}}}, {"text": "In Java, use lastIndexOf", "label": {"api": {"lastIndexOf": [[13, 23]]}}}, {"text": "You can use a Java Timer, here is an example", "label": {"api": {"Timer": [[19, 23]]}}}, {"text": "You can use System.exit to stop the JVM entirely from any thread, or Thread.setDaemon(true) to mark your thread as a daemon which means it will not stop the JVM from exiting", "label": {"api": {"System.exit": [[12, 22]], "Thread.setDaemon(true)": [[69, 90]]}}}, {"text": "You can just enumerate all the possible passwords containing letters and digits by counting from 0 to infinity and converting the number toString with base 36", "label": {"api": {"toString": [[137, 144]]}}}, {"text": "Here, toString works for a base up to 36, using [0-9a-z], i.e", "label": {"api": {"toString": [[6, 13]]}}}, {"text": "One problem with this approach is that -- as with all representations of numbers -- leading zeros will be omitted, thus Long.toString will never produce a password starting with 0 (except 0 itself)", "label": {"api": {"toString": [[125, 132]]}}}, {"text": "If you already have the Question in the database, know its ID, but want to avoid getting it completely you can use the getReference() method, which returns a proxy for your Entity", "label": {"api": {"getReference()": [[119, 132]]}}}, {"text": "If you are using a Spring Data JpaRepository there is a similar method, awkwardly named getOne() which does essentially the same thing (it calls the EntityManager.getReference())", "label": {"api": {"getReference()": [[163, 176]]}}}, {"text": "Inside the loop you use the overload indexOf(String str, int fromIndex)", "label": {"api": {"indexOf(String str, int fromIndex)": [[37, 70]]}}}, {"text": "Given this we are going to iterate over scanner input line by line, converting individual line into ﻿﻿Atleticar object and adding them to atleticari using List#add method", "label": {"api": {"List#add": [[155, 162]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#max(java.util.Collection) for reference and https://docs.oracle.com/javase/8/docs/api/java/time/Period.html for the Period class", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#max(java.util.Collection)": [[4, 97]], "https://docs.oracle.com/javase/8/docs/api/java/time/Period.html": [[117, 179]]}}}, {"text": "Another example using Java 8 features - BiFunction interface with lambda expression", "label": {"api": {"BiFunction": [[40, 49]]}}}, {"text": "As per DecimalFormat docs # is used to conditionally show the digit", "label": {"api": {"DecimalFormat docs": [[7, 24]]}}}, {"text": "An example of something useful before the decimal, so you can see formats before the decimal can work is 0 which formats a digit but does not drop zeros, and can also be used in the DecimalFormat", "label": {"api": {"DecimalFormat": [[182, 194]]}}}, {"text": "Patterns like 0, # and more are defined in DecimalFormat", "label": {"api": {"DecimalFormat": [[43, 55]]}}}, {"text": "Or, even more elegantly, using Java 8's Map#computeIfAbsent", "label": {"api": {"Map#computeIfAbsent": [[40, 58]]}}}, {"text": "The easiest way to remove the the Backspace/Delete feature from a JTextField is with a custom DocumentFilter", "label": {"api": {"DocumentFilter": [[94, 107]]}}}, {"text": "You will notice that when the JTextField's setFocusTraversalKeysEnabled property is set to boolean true you will not be able to detect when the TAB key is hit and this is because the TAB key is always consumed by the KeyboardFocusManager", "label": {"api": {"KeyboardFocusManager": [[217, 236]]}}}, {"text": "For this final step I'm using JDK 9's Map.entry(K k, V v) static method, but I could have used any other container, i.e", "label": {"api": {"Map.entry(K k, V v)": [[38, 56]]}}}, {"text": "For the first collector I'm using your exact code to collect to a Map, while for the second collector I'm using Collectors.mapping along with Collectors.toList, using Function.andThen to compose your func1 and func2 functions for the mapping step", "label": {"api": {"Collectors.mapping": [[112, 129]], "Collectors.toList": [[142, 158]], "Function.andThen": [[167, 182]]}}}, {"text": "Again, I'm using jdk9's Map.entry(K k, V v) static method", "label": {"api": {"Map.entry(K k, V v)": [[24, 42]]}}}, {"text": "Also, looking on the entrySet() Javadoc", "label": {"api": {"entrySet() Javadoc": [[21, 38]]}}}, {"text": "You could use Calendar class and work with millis only", "label": {"api": {"Calendar": [[14, 21]]}}}, {"text": "You can get Date object using getTime() method when you need", "label": {"api": {"Date": [[12, 15]]}}}, {"text": "The line where the Scanner is waiting for an input is not used for printing", "label": {"api": {"Scanner": [[19, 25]]}}}, {"text": "You shold use Thread.interrupt()", "label": {"api": {"Thread.interrupt()": [[14, 31]]}}}, {"text": "This uses @SuppressWarnings to suppress the unchecked warnings", "label": {"api": {"@SuppressWarnings": [[10, 26]]}}}, {"text": "It's good practice to apply @SuppressWarnings to the narrowest scope possible so as to avoid suppressing other, useful warnings", "label": {"api": {"@SuppressWarnings": [[28, 44]]}}}, {"text": "One way to handle this is to install a NamespaceContext, but for reasons which continue to elude me, Java SE has no public standard implementation of NamespaceContext, which makes setting it a chore", "label": {"api": {"install a NamespaceContext": [[29, 54]]}}}, {"text": "If you’re using DocumentBuilderFactory, remember to call setNamespaceAware(true) on it before creating a DocumentBuilder", "label": {"api": {"DocumentBuilderFactory": [[16, 37]], "setNamespaceAware(true)": [[57, 79]]}}}, {"text": "For a JMenuItem, instead of a listener, you should use an Action (which is a more capable form of ActionListener)", "label": {"api": {"Action": [[58, 63], [98, 103]]}}}, {"text": "For JCheckBoxMenuItems and JRadioButtonMenuItems, just as with regular JMenuItems, the Action’s actionPerformed method is called when the user activates the menu item", "label": {"api": {"Action": [[87, 92]]}}}, {"text": "You can check the new state from within your Action", "label": {"api": {"Action": [[45, 50]]}}}, {"text": "Note that Action.SELECTED_KEY only works if you set it to true or false before you install the Action", "label": {"api": {"Action": [[10, 15], [95, 100]]}}}, {"text": "For example, if you set an Action that has a null value for SELECTED_KEY on a JToggleButton, the JToggleButton will not update its selected state in any way", "label": {"api": {"Action": [[27, 32]]}}}, {"text": "Similarly, any time the JToggleButton's selected state changes it will only set the value back on the Action if the Action has a non-null value for SELECTED_KEY", "label": {"api": {"Action": [[102, 107], [116, 121]]}}}, {"text": "For all other JMenuItems, use ActionListener", "label": {"api": {"Action": [[30, 35]]}}}, {"text": "The above actually applies to all descendants of AbstractButton as well as JMenuItem and its descendant classes", "label": {"api": {"AbstractButton": [[49, 62]]}}}, {"text": "For JButtons, use an Action", "label": {"api": {"Action": [[21, 26]]}}}, {"text": "For JToggleButtons, JCheckBoxes, and JRadioButtons, use an Action and check its SELECTED_KEY value", "label": {"api": {"Action": [[59, 64]]}}}, {"text": "If you aren’t willing to use Actions, use ActionListener for JButtons, and use ItemListener for JToggleButtons, JCheckBoxes, and JRadioButtons", "label": {"api": {"Action": [[29, 34], [42, 47]]}}}, {"text": "Although you said that symlinks could be ignored, note that such cases can be easily covered using Files.isSymbolicLink()", "label": {"api": {"Files.isSymbolicLink()": [[99, 120]]}}}, {"text": "It is possible to reassign standard input/output streams using System.setIn() and System.setOut() methods", "label": {"api": {"System.setIn()": [[63, 76]], "System.setOut()": [[82, 96]]}}}, {"text": "And for the JPanel part, you just have to let to plugins a way (an API surely) that lets them change the displayed panel of the JFrame (with JFrame::setContentPane)", "label": {"api": {"JFrame::setContentPane": [[141, 162]]}}}, {"text": "It will provide you with a set of serializers and deserializers for JSR-310 datatypes", "label": {"api": {"datatypes": [[76, 84]]}}}, {"text": "You can use CyclicBarrier", "label": {"api": {"CyclicBarrier": [[12, 24]]}}}, {"text": "You can first create a StringBuilder with the string in the ArrayList, then call setCharAt", "label": {"api": {"StringBuilder": [[23, 35]]}}}, {"text": "You could also use Pattern.quote for that second level of escaping (the one for the regex)", "label": {"api": {"Pattern.quote": [[19, 31]]}}}, {"text": "Use the graphicTextGapProperty", "label": {"api": {"graphicTextGapProperty": [[8, 29]]}}}, {"text": "Considering the algorithm is meant to multiply large numbers, I chose the BigInt type which is backed by Java BigInteger", "label": {"api": {"BigInteger": [[110, 119]]}}}, {"text": "Given that BigInteger is internally represented as an int[], if I can calculate m2 in terms of the int[], I can use bit shifting to extract the lower and higher halves of the number", "label": {"api": {"BigInteger": [[11, 20]]}}}, {"text": "There is an existing question that shows how to implement using arithmetic on BigInteger, but not bit shifting", "label": {"api": {"BigInteger": [[78, 87]]}}}, {"text": "Yes, you can merge the two conditions by using the partitioningBy collector as follows", "label": {"api": {"partitioningBy": [[51, 64]]}}}, {"text": "This essentially uses the partitioningBy collector to organise the elements in such a way that all the elements passing the criteria info.getDate().getTime() < date.getTime() aswell as where it's false i.e", "label": {"api": {"partitioningBy": [[26, 39]]}}}, {"text": "Further, we utilise the collectingAndThen collector to apply a finishing function upon the Map<Boolean, List<T>> returned by the partitioningBy collector, in this case we concatenate the result of the applying the logic of", "label": {"api": {"partitioningBy": [[129, 142]], "collectingAndThen": [[24, 40]]}}}, {"text": "Finally, we collect the result into a ArrayList implementation with the toCollection collector", "label": {"api": {"toCollection": [[72, 83]]}}}, {"text": "If you need to transfer byte[] around write it and read it using InputStream.read() and OutputStream.write()", "label": {"api": {"InputStream.read()": [[65, 82]], "OutputStream.write()": [[88, 107]]}}}, {"text": "For more information, see the official documentation for Color", "label": {"api": {"official documentation for Color": [[30, 61]]}}}, {"text": "Next, a ListIterator (and an Iterator) has its initial position before the first element, which is where the add method adds the element", "label": {"api": {"the add method": [[105, 118]]}}}, {"text": "To indentify duplicates, no method I know of is better suited than Collectors.groupingBy()", "label": {"api": {"Collectors.groupingBy()": [[67, 89]]}}}, {"text": "I really like @bakcsa83 answer, but I would use Timeline", "label": {"api": {"Timeline": [[48, 55]]}}}, {"text": "I am developing some code that will eventually be multithreaded, using a thread pool Executor", "label": {"api": {"Executor": [[85, 92]]}}}, {"text": "To do that, I need an Executor that is safe to use with non thread-safe code", "label": {"api": {"Executor": [[22, 29]]}}}, {"text": "I think that means I need an Executor that is single-threaded", "label": {"api": {"Executor": [[29, 36]]}}}, {"text": "Does the JRE provide such an Executor", "label": {"api": {"Executor": [[29, 36]]}}}, {"text": "Or is it possible to configure one of its Executors to operate in that mode", "label": {"api": {"Executor": [[42, 49]]}}}, {"text": "However, some of my code must interact with an Executor, or perhaps an ExecutorService, because it is about scheduling and resubmission of tasks, and it will do so in a non-trivial manner", "label": {"api": {"Executor": [[47, 54], [71, 78]], "ExecutorService": [[71, 85]]}}}, {"text": "Annotation retention can be specified as SOURCE, so they won't be kept after compilation", "label": {"api": {"retention": [[11, 19]]}}}, {"text": "Operation in.read(buffer) takes some time, because your program waits for I/O to return the next character", "label": {"api": {"read": [[13, 16]]}}}, {"text": "You could also read characters in chunks (there is overloaded read method in InputStream which can read some number of characters) and add maybe some delay between reads", "label": {"api": {"read": [[15, 18], [62, 65], [99, 102], [164, 167]]}}}, {"text": "Use Objects.equals(d1, d2)", "label": {"api": {"Objects.equals(d1, d2)": [[4, 25]]}}}, {"text": "Use computeIfAbsent() to initialise a List for the id if one doesn't exist already, then just add the value to that", "label": {"api": {"computeIfAbsent()": [[4, 20]]}}}, {"text": "You can pass scrollbar policies into the constructor when you create the new scrollpane", "label": {"api": {"the constructor": [[37, 51]]}}}, {"text": "You do that by calling filter()", "label": {"api": {"filter()": [[23, 30]]}}}, {"text": "The reason why you read 255 (in first case) despite writing -1 can be seen in the documentation of OutputStream.write(int) (emphasis mine)", "label": {"api": {"OutputStream.write(int)": [[99, 121]]}}}, {"text": "FileOutputStream gives no indication of changing that behavior", "label": {"api": {"FileOutputStream": [[0, 15]]}}}, {"text": "Basically, InputStream.read and OutputStream.write(int) use ints to allow the use of unsigned \"bytes\"", "label": {"api": {"OutputStream.write(int)": [[32, 54]], "InputStream.read": [[11, 26]]}}}, {"text": "From the documentation of InputStream.read (emphasis mine)", "label": {"api": {"InputStream.read": [[26, 41]]}}}, {"text": "If you have a single profile you're targeting that you want to get the category of, you can use a findFirst or findAny to get the profile you want and then get the category from the resulting Optional", "label": {"api": {"findFirst": [[98, 106]], "findAny": [[111, 117]], "Optional": [[192, 199]]}}}, {"text": "Note that findFirst returns an Optional", "label": {"api": {"findFirst": [[10, 18]], "Optional": [[31, 38]]}}}, {"text": "For the specific case of a stream of consecutive integers you could replace iterate and limit with range", "label": {"api": {"range": [[99, 103]]}}}, {"text": "Aside, an alternate way of iterating and combining limit with Java9+ is using IntStream.iterate with an IntPredicate as", "label": {"api": {"IntStream.iterate": [[78, 94]]}}}, {"text": "In YYYY-MM-DD pattern Y is a week year and D is day in a year as per SimpleDateFormat javadoc", "label": {"api": {"SimpleDateFormat javadoc": [[69, 92]]}}}, {"text": "In this we use the LocalDate class to parse the entered date (given in the format dd/MM/yyyy), adjust the month with TemporalAdjusters, and then use withDayOfMonth to set which day of next month we want", "label": {"api": {"LocalDate": [[19, 27]], "TemporalAdjusters": [[117, 133]]}}}, {"text": "What you can do is use a Cleaner", "label": {"api": {"Cleaner": [[25, 31]]}}}, {"text": "One advantage of using a Cleaner is you can call it to clean up deterministically, but if you forget or fail to do so, the GC will call it after it runs", "label": {"api": {"Cleaner": [[25, 31]]}}}, {"text": "You can implement a set that uses identity instead of equality by using the JDK's IdentityHashMap with a dummy value shared between all keys, in a similar way that HashSet is based on HashMap", "label": {"api": {"IdentityHashMap": [[82, 96]]}}}, {"text": "If possible I want to use a ThreadPoolExecutor to control the amount of threads that is getting started during the process", "label": {"api": {"ThreadPoolExecutor": [[28, 45]]}}}, {"text": "Let's make use of Map.get(Object) here, and the fact that it will return null if the key doesn't exist", "label": {"api": {"Map.get(Object)": [[18, 32]]}}}, {"text": "You can use a Set which does not allow duplicates, and simply use the addAll() method to add all the elements of the List's to the Set", "label": {"api": {"Set": [[14, 16], [131, 133]]}}}, {"text": "Further reading of the docs would have lead you to File#createNewFile which is described as doing", "label": {"api": {"File#createNewFile": [[51, 68]]}}}, {"text": "You could use ZonedDateTime.withZoneSameInstant() method to move from UTC to Paris time", "label": {"api": {"ZonedDateTime.withZoneSameInstant()": [[14, 48]]}}}, {"text": "If you want a one-liner, you can use the readAllLines method", "label": {"api": {"readAllLines method": [[41, 59]]}}}, {"text": "You can do that using System.arraycopy (See this answer)", "label": {"api": {"System.arraycopy": [[22, 37]]}}}, {"text": "the javadoc of base class URLConnection", "label": {"api": {"URLConnection": [[26, 38]]}}}, {"text": "Any call to a method that requires the response will automatically call connect for you, as documented in the connect() method", "label": {"api": {"connect()": [[110, 118]]}}}, {"text": "URLConnection objects go through two phases", "label": {"api": {"URLConnection": [[0, 12]]}}}, {"text": "The HttpClient introduced experimentally in Java 9 is now stable in Java 11, but not surprisingly, very few projects seem to actually use it", "label": {"api": {"HttpClient": [[4, 13]]}}}, {"text": "How would you do that using the HttpClient, without of course, logging it manually in every single call", "label": {"api": {"HttpClient": [[32, 41]]}}}, {"text": "You can use the method ints instead", "label": {"api": {"ints": [[23, 26]]}}}, {"text": "Note that ints takes the lower bound (inclusive) and upper bound (exclusive) of the range in which you want to generate numbers, so if you want numbers between 0 and 3 inclusive then you need to specify (0, 4) as the arguments", "label": {"api": {"ints": [[10, 13]]}}}, {"text": "Use String's replaceAll method and replace the - with \"\" (empty string)", "label": {"api": {"replaceAll method": [[13, 29]]}}}, {"text": "To avoid eagerly evaluating else-branches, use orElseGet, which takes an instance of the functional interface Supplier", "label": {"api": {"orElseGet": [[47, 55]]}}}, {"text": "Hulk is right, and you should use AtomicInteger for your time count", "label": {"api": {"AtomicInteger": [[34, 46]]}}}, {"text": "You can have an AtomicBoolean flag that lets the TimerTask know if the player is playing or not", "label": {"api": {"AtomicBoolean": [[16, 28]]}}}, {"text": "This data structure is a Set", "label": {"api": {"Set": [[25, 27]]}}}, {"text": "I am using the MessageDigest API for this", "label": {"api": {"MessageDigest API": [[15, 31]]}}}, {"text": "You can use iText (and possibly instance of class Robot) for example", "label": {"api": {"Robot": [[50, 54]]}}}, {"text": "Use iText and instance of Class Robot if you want to save an image of the scroll pane to a pdf file, otherwise you can just use iText", "label": {"api": {"Robot": [[32, 36]]}}}, {"text": "Which will create a filter out all the elements that occur more than once using Collections::frequency", "label": {"api": {"Collections::frequency": [[80, 101]]}}}, {"text": "Use a java.util.Set to store the selected indexed, for exmaple, java.util.HashSet", "label": {"api": {"java.util.HashSet": [[64, 80]]}}}, {"text": "Collections#binarySearch searches a List for the same type of value that the list holds", "label": {"api": {"Collections#binarySearch": [[0, 23]]}}}, {"text": "If you only need a view of the 2 parts of the initial List you can use List.subList(), but remember that this you made any change on the initial list, they will be seen on list1 and list2 as they are only views", "label": {"api": {"List.subList()": [[71, 84]]}}}, {"text": "First of all, a function that accepts one argument and returns a boolean should implement Java 8 Predicate", "label": {"api": {"Java 8 Predicate": [[90, 105]]}}}, {"text": "There is no print method in the PrintWriter class that accepts those arguments", "label": {"api": {"PrintWriter": [[32, 42]]}}}, {"text": "I'm assuming you wanted to use the printf() method, which accepts", "label": {"api": {"printf()": [[35, 42]]}}}, {"text": "Another method, Files.write(Path,Iterable,Charset,OpenOption...), can be used to write CharSequences directly (a String is a CharSequence)", "label": {"api": {"Files.write(Path,Iterable,Charset,OpenOption...)": [[16, 63]]}}}, {"text": "In fact, javadocs for Stream state it clearly", "label": {"api": {"javadocs for Stream": [[9, 27]]}}}, {"text": "If we look at the documentation of Optional.ofNullable(), it returns an object of the type static <T> Optional<T> ofNullable(T value) which signifies that it is internally type casting, but the documentation says it return type is Optional", "label": {"api": {"Optional.ofNullable()": [[35, 55]]}}}, {"text": "You could use some more high-level constructs from the concurrency package, such as a Semaphore", "label": {"api": {"Semaphore": [[86, 94]]}}}, {"text": "So you'd set up the Semaphore with a single \"permit\" before your loop, pass it to your threads, and then all of them would try to \"acquire\" that permit (which only one of them can do, the others will fail at that)", "label": {"api": {"Semaphore": [[20, 28]]}}}, {"text": "Even Semaphore is kind of low-level, usually you can find something even more tailored to your actual application, such as blocking queues or concurrent collections", "label": {"api": {"Semaphore": [[5, 13]]}}}, {"text": "What you need is Character.getNumericValue", "label": {"api": {"Character.getNumericValue": [[17, 41]]}}}, {"text": "You may be getting that mixed up with the Random class constructor, which takes a long as a seed value, meaning your results will be pseudorandom and by consequence, repeatable", "label": {"api": {"Random": [[42, 47]]}}}, {"text": "If you wanted a number between 0 and 99 I actually would recommend that you use Random", "label": {"api": {"Random": [[80, 85]]}}}, {"text": "Multiplying floats gets dicey very quickly, since Math.random() only produces a floating-point number", "label": {"api": {"Math.random()": [[50, 62]]}}}, {"text": "In your case, given you are executing a SQL statement, there is a method in the Statement class (setQueryTimeout) which achieves what you appear to be after without over-engineering timeouts by other means", "label": {"api": {"setQueryTimeout": [[97, 111]]}}}, {"text": "You will get a ConcurrentModificationException - if you're lucky", "label": {"api": {"ConcurrentModificationException": [[15, 45]]}}}, {"text": "Well, I tried with both ArrayList and Vector and both of them gave me ConcurrentModificationException", "label": {"api": {"ArrayList": [[24, 32]], "Vector": [[38, 43]], "ConcurrentModificationException": [[70, 100]]}}}, {"text": "However CopyOnWriteArrayList works fine", "label": {"api": {"ArrayList": [[19, 27]], "CopyOnWriteArrayList": [[8, 27]]}}}, {"text": "If you use a mutable object, such as a StringBuilder and change its data instead, you'll see the behavior you expect", "label": {"api": {"StringBuilder": [[39, 51]]}}}, {"text": "That's the job of a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[20, 32]]}}}, {"text": "Try using GenericGenerator and GeneratedValue in your code", "label": {"api": {"GeneratedValue": [[31, 44]]}}}, {"text": "If you are in JEE >= JEE 7 there is ServletContext.getServletRegistrations()", "label": {"api": {"ServletContext.getServletRegistrations()": [[36, 75]]}}}, {"text": "These have a getMappings() method that gets you the URL mappings for that servlet", "label": {"api": {"getMappings()": [[13, 25]]}}}, {"text": "Calling Application.launch() twice should result in an exception", "label": {"api": {"Application.launch()": [[8, 27]]}}}, {"text": "From Application.launch() API docs", "label": {"api": {"Application.launch()": [[5, 24]]}}}, {"text": "this is usually done by synchronized methods, or ReentrantLocks", "label": {"api": {"ReentrantLocks": [[49, 62]]}}}, {"text": "Use the subList() method of LinkedList", "label": {"api": {"subList()": [[8, 16]]}}}, {"text": "You can alternatively do it using Arrays.streamas", "label": {"api": {"Arrays.stream": [[34, 46]]}}}, {"text": "I see the code below from Java8 Condition,and I have a question", "label": {"api": {"Java8 Condition": [[26, 40]]}}}, {"text": "This KeyEvent and MouseEvent inherit from InputEvent", "label": {"api": {"InputEvent": [[42, 51]]}}}, {"text": "Use MessageFormat for replacing {0}", "label": {"api": {"MessageFormat": [[4, 16]]}}}, {"text": "%tT resolves to %tH:%tM:%tS as per Formatter Date/Time Conversions javadoc", "label": {"api": {"Formatter Date/Time Conversions javadoc": [[35, 73]]}}}, {"text": "Equivalent would be HH:mm:ss pattern as per DateTimeFormatter javadoc", "label": {"api": {"DateTimeFormatter javadoc": [[44, 68]]}}}, {"text": "The correct way to handle missing values in a map is computeIfAbsent() which is a new method on Map available since Java 8", "label": {"api": {"computeIfAbsent()": [[53, 69]]}}}, {"text": "Then, if the value is null, map to a default value (\"[]\"), else computeIfAbsent() returns the actual value", "label": {"api": {"computeIfAbsent()": [[64, 80]]}}}, {"text": "A much easier approach would be to utilize the JDK's LinkedHashSet that both guarantees a single instance of each value and preserves the order of insertion", "label": {"api": {"LinkedHashSet": [[53, 65]]}}}, {"text": "The Javadoc for ConcurrentSkipListMap.compute(K, BiFunction) states", "label": {"api": {"ConcurrentSkipListMap.compute(K, BiFunction)": [[16, 59]]}}}, {"text": "And if that still isn't enough and you need arbitrary length integers, BigInteger is available", "label": {"api": {"BigInteger": [[71, 80]]}}}, {"text": "Similarly, with EJB one could use TransactionAttributeType#REQUIRES_NEW", "label": {"api": {"TransactionAttributeType#REQUIRES_NEW": [[34, 70]]}}}, {"text": "You need a different variant", "label": {"api": {"different variant": [[11, 27]]}}}, {"text": "Date.getTimezoneOffset() is the offset between UTC and the default timezone (thus 0 in your case), nothing to do with the time zone you used to configure the parser", "label": {"api": {"offset between UTC and the default timezone": [[32, 74]]}}}, {"text": "Use the new File NIO.2 API instead of the old antiquated File I/O API", "label": {"api": {"File": [[12, 15], [57, 60]]}}}, {"text": "This means that you should use Files.delete(Path path) and Files.move(Path source, Path target) instead, since they will throw exception if operation fails, explaining why, rather than just return an uninformative false value like the old File methods do", "label": {"api": {"Files.delete(Path path)": [[31, 53]], "Files.move(Path source, Path target)": [[59, 94]], "File": [[31, 34], [59, 62], [239, 242]]}}}, {"text": "I came across a nCopies code somewhere and not being familiar with this funciton, I looked up the Oracle Docs and noticed that the definition says", "label": {"api": {"Oracle Docs": [[98, 108]]}}}, {"text": "Or you can call boxed() to convert the IntStream to a Stream<Integer>", "label": {"api": {"boxed()": [[16, 22]]}}}, {"text": "I'm trying to use JDK 11 HttpClient to make requests through a corporate proxy which requires authentication by login and password", "label": {"api": {"HttpClient": [[25, 34]]}}}, {"text": "HttpClient does not use the provided authenticator", "label": {"api": {"HttpClient": [[0, 9]]}}}, {"text": "You can use a two-argument Comparator.comparing overload, for example", "label": {"api": {"Comparator.comparing": [[27, 46]]}}}, {"text": "JPA's EntityManager#find doesn't accept arrays as key but Object", "label": {"api": {"EntityManager#find": [[6, 23]]}}}, {"text": "You can achieve this using EmbeddedId for instance", "label": {"api": {"EmbeddedId": [[27, 36]]}}}, {"text": "and use it as @EmbeddedId in your entity", "label": {"api": {"EmbeddedId": [[15, 24]]}}}, {"text": "Declare a new int[] array to hold all the numbers and then use System.arraycopy() to copy the smaller arrays into the result array", "label": {"api": {"System.arraycopy()": [[63, 80]]}}}, {"text": "When you construct the kml element, using createElement() it creates an element that is bound to the \"no namespace\"", "label": {"api": {"createElement()": [[42, 56]]}}}, {"text": "When you create an element that you want to be bound to a namespace, use the createElementNS() method, as indicated in the JavaDoc comments for createElement()", "label": {"api": {"createElement()": [[144, 158]]}}}, {"text": "You could Map each character to and integer, which represents the number of occurrences in the string, then check if should be added or ignored (check comments on the code for more info)", "label": {"api": {"Map": [[10, 12]]}}}, {"text": "If you look at the doco for list.sort() you'll see that it sorts using the supplied comparator", "label": {"api": {"list.sort()": [[28, 38]]}}}, {"text": "Collections.sort() on the other hand, will sort the list according to the natural ordering of its elements (as specified by your implementation of Comparable)", "label": {"api": {"Collections.sort()": [[0, 17]]}}}, {"text": "According to the original documentation the compareTo method on a String returns a positive number, a negative number or a zero based on the lexicographical ordering", "label": {"api": {"original documentation": [[17, 38]]}}}, {"text": "The DateFormat#parse() methods throws a ParseException", "label": {"api": {"DateFormat#parse()": [[4, 21]]}}}, {"text": "In the FileChannel Documentation, it says", "label": {"api": {"FileChannel Documentation": [[7, 31]]}}}, {"text": "You can use List.removeAll(Collection)", "label": {"api": {"List.removeAll(Collection)": [[12, 37]]}}}, {"text": "A take on it (slightly similar to the answer by Aomine) would be to strip the strings of the characters that makes String#compareTo() fail, in this case ('{' and '}')", "label": {"api": {"String#compareTo()": [[115, 132]]}}}, {"text": "If efficiency is truly important here, I would loop through the characters, like String#compareTo() does, as suggested by ETO", "label": {"api": {"String#compareTo()": [[81, 98]]}}}, {"text": "Parse into a MonthDay and add the year", "label": {"api": {"MonthDay": [[13, 20]]}}}, {"text": "Change the Locale as appropriate", "label": {"api": {"Locale": [[11, 16]]}}}, {"text": "By default it uses NumberFormat.getNumberInstance(locale) for number format", "label": {"api": {"NumberFormat": [[19, 30]]}}}, {"text": "If you want something else than the default number format of your local, you can extend StringToDoubleConverter and override getFormat method to return customized NumberFormat", "label": {"api": {"NumberFormat": [[163, 174]]}}}, {"text": "You can simply use the replace() method", "label": {"api": {"replace()": [[23, 31]]}}}, {"text": "So, execute scrollPane.setHvalue(0.5) within the ChangeListener callback instead", "label": {"api": {"ChangeListener": [[49, 62]]}}}, {"text": "If you are using SQL database it most likely will be SQLException", "label": {"api": {"SQLException": [[53, 64]]}}}, {"text": "CompletableFuture is an interface representing a result that gets calculated in a separate thread (in this case, a call to currentPlayer.getPlayerMove())", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "and then at places where you were calling the method makeRESTServiceGetCall, you can simply apply the above implementation as", "label": {"api": {"apply": [[92, 96]]}}}, {"text": "Using a ProcessBuilder, you should be able to call Process.waitFor() to wait for the command to finish", "label": {"api": {"ProcessBuilder": [[8, 21]]}}}, {"text": "Parse into a LocalDateTime, then get the Duration between that and the current time, and convert it to seconds", "label": {"api": {"LocalDateTime": [[13, 25]], "Duration": [[41, 48]], "convert it to seconds": [[89, 109]]}}}, {"text": "If you want to have an open set of subclasses instead, to be potentially extended after compiling the code, you should look at the Service Provider concept and the ServiceLoader class", "label": {"api": {"ServiceLoader": [[164, 176]]}}}, {"text": "If you want to pass an Icon to showConfirmDialog, you need to use the 6 argument overload", "label": {"api": {"use the 6 argument overload": [[62, 88]]}}}, {"text": "As the javadoc of JFrame says", "label": {"api": {"JFrame": [[18, 23]]}}}, {"text": "The default content pane will have a BorderLayout manager set on it", "label": {"api": {"BorderLayout": [[37, 48]]}}}, {"text": "Javadoc of BorderLayout says", "label": {"api": {"BorderLayout": [[11, 22]]}}}, {"text": "As a convenience, BorderLayout interprets the absence of a string specification the same as the constant CENTER", "label": {"api": {"BorderLayout": [[18, 29]]}}}, {"text": "Since you call the 1-arg version of add(), all your JLabels are added with BorderLayout.CENTER, and so the last one wins, and the BorderLayout manager then auto-positions it at left-center", "label": {"api": {"BorderLayout": [[75, 86], [130, 141]]}}}, {"text": "According to the docs for Instant under the implementation notes", "label": {"api": {"Instant": [[26, 32]]}}}, {"text": "You can configure this via setContinueExistingPeriodicTasksAfterShutdownPolicy", "label": {"api": {"setContinueExistingPeriodicTasksAfterShutdownPolicy": [[27, 77]]}}}, {"text": "You can return javax.ws.rs.core.Response, with that you can control the HTTP code and response object you want to return", "label": {"api": {"javax.ws.rs.core.Response": [[15, 39]]}}}, {"text": "Why not use a StringBuilder and the substring method", "label": {"api": {"substring": [[36, 44]]}}}, {"text": "MultivaluedMap, which seems to be very similar to Apache's one (almost identical as I see)", "label": {"api": {"MultivaluedMap": [[0, 13]]}}}, {"text": "For more information, please check https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#read(byte[])", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#read(byte[])": [[35, 113]]}}}, {"text": "For the first question, you can use the findFirst() method", "label": {"api": {"findFirst() method": [[40, 57]]}}}, {"text": "Be aware that the findFirst() method returns an optional", "label": {"api": {"findFirst() method": [[18, 35]], "optional": [[48, 55]]}}}, {"text": "The stream transformation is performed by an Encoder class that returns a StreamingOutput which is then passed to the Response object", "label": {"api": {"StreamingOutput": [[74, 88]]}}}, {"text": "Since StreamingOutput does not implement AutoCloseable, connection leaks may occur when the output is only partially consumed", "label": {"api": {"StreamingOutput": [[6, 20]]}}}, {"text": "Java's Collection has no such method as get()", "label": {"api": {"Collection": [[7, 16]]}}}, {"text": "Map.containsValue() will have a linear time as you are iterating blindly over all the map values", "label": {"api": {"Map.containsValue()": [[0, 18]]}}}, {"text": "To take advantage of a hash lookup you should check the keys with Map.containsKey()", "label": {"api": {"Map.containsKey()": [[66, 82]]}}}, {"text": "The builder you are looking for is a StringBUilder", "label": {"api": {"StringBUilder": [[37, 49]]}}}, {"text": "Additionally you should look at the skipBytes method of your reader", "label": {"api": {"skipBytes": [[36, 44]]}}}, {"text": "You can use Stream.mapToDouble to convert it into a DoubleStream and then use DoubleStream.sum", "label": {"api": {"Stream.mapToDouble": [[12, 29]], "DoubleStream.sum": [[78, 93]]}}}, {"text": "If not using ThreadPool you must wait (join) the created Thread yourself, see the join method; there are some overloading", "label": {"api": {"join method": [[82, 92]]}}}, {"text": "You can get all explanation in the javadoc about ThreadPoolExecutor which offers you this kind of management", "label": {"api": {"ThreadPoolExecutor": [[49, 66]]}}}, {"text": "Files.newBufferedReader(Path) states that it uses UTF-8 if the encoding is not specified", "label": {"api": {"Files.newBufferedReader(Path)": [[0, 28]]}}}, {"text": "You are implementing the Iterator interface, not the Iterable interface", "label": {"api": {"Iterator": [[25, 32]], "Iterable": [[53, 60]]}}}, {"text": "If you make your class implement an Iterable, you'll be able to use the enhanced for loop syntax", "label": {"api": {"Iterable": [[36, 43]]}}}, {"text": "Use the newer Path, Paths, Files for such tasks", "label": {"api": {"Path, Paths, Files": [[14, 31]]}}}, {"text": "From the documentation of Charset", "label": {"api": {"documentation of Charset": [[9, 32]]}}}, {"text": "From the documentation of the File.length, it returns", "label": {"api": {"File.length": [[30, 40]]}}}, {"text": "System.getProperty() is for getting system properties", "label": {"api": {"System.getProperty()": [[0, 19]]}}}, {"text": "You do not have such a system property defined, so System.getProperty() returns null", "label": {"api": {"System.getProperty()": [[51, 70]]}}}, {"text": "If you just want to print the path, you should simply omit the System.getProperty() call", "label": {"api": {"System.getProperty()": [[63, 82]]}}}, {"text": "One way is to inject a Class type into your container and call isInstance", "label": {"api": {"isInstance": [[63, 72]]}}}, {"text": "The execution time of isInstance is actually quite fast", "label": {"api": {"isInstance": [[22, 31]]}}}, {"text": "There's an interesting article which experimentally compares the speeds of a try-catch with unsafe cast to an isInstance solution", "label": {"api": {"isInstance": [[110, 119]]}}}, {"text": "Use ScriptEngineManager.getBindings().put(String name, Object value) to put existing objects in the engine scope", "label": {"api": {"ScriptEngineManager.getBindings().put(String name, Object value)": [[4, 67]]}}}, {"text": "Alternatively with Java9 and above you can use Stream.ofNullable and update as", "label": {"api": {"Stream.ofNullable": [[47, 63]]}}}, {"text": "withClasspathResourceMapping uses ClassLoader#getResource", "label": {"api": {"ClassLoader#getResource": [[34, 56]]}}}, {"text": "You can use #getDeclaredFields() and iterate over them", "label": {"api": {"#getDeclaredFields()": [[12, 31]]}}}, {"text": "To only get the superclass fields you would need to call #getSuperclass()  first", "label": {"api": {"#getSuperclass()": [[57, 72]]}}}, {"text": "The class CompletableFuture is the perfect candidate for doing such a thing", "label": {"api": {"CompletableFuture": [[10, 26]]}}}, {"text": "Types of Writer that support the ability to read back include the CharArrayWriter and the StringWriter, which allow you to read the contents as a char[] and a String, respectively", "label": {"api": {"CharArrayWriter": [[66, 80]], "StringWriter": [[90, 101]]}}}, {"text": "You can use FileVisitor class to traverse and read one file at a time", "label": {"api": {"FileVisitor": [[12, 22]]}}}, {"text": "Use Files.html#walkFileTree method to visit files in directory", "label": {"api": {"Files.html#walkFileTree": [[4, 26]]}}}, {"text": "You might use Path.list for this, it will return you a stream which is a lazy evaluated", "label": {"api": {"Path.list": [[14, 22]]}}}, {"text": "For that you would need to synchronize or use a CopyOnWriteArrayList instead", "label": {"api": {"CopyOnWriteArrayList": [[48, 67]]}}}, {"text": "BlockingQueue has this functionality in the drainTo method", "label": {"api": {"drainTo": [[44, 50]]}}}, {"text": "You either want to return that array rather than a string if it acceptable to find multiple files or take the first file from the array and use something like File#getAbsolutePath ()", "label": {"api": {"File#getAbsolutePath ()": [[159, 181]]}}}, {"text": "The problem here is that your String was created from bytes, using an incorrect charset that assumes one byte is one character, like like ISO 8559-1", "label": {"api": {"ISO 8559-1": [[138, 147]]}}}, {"text": "There is a specific interface for this purpose that implements the publish subscribe pattern called ListModel (as mentioned in the comments), providing a mechanism for the graphics components to get redrawn when needed", "label": {"api": {"ListModel": [[100, 108]], "List": [[100, 103]]}}}, {"text": "List interface isn't designed to provide such a mechanism", "label": {"api": {"List": [[0, 3]]}}}, {"text": "DefaultListModel is a built-in implementation of the ListModel", "label": {"api": {"ListModel": [[7, 15], [53, 61]], "List": [[7, 10], [53, 56]], "DefaultListModel": [[0, 15]]}}}, {"text": "You can send URL also in a new header name and then use getHeaders to get specific header", "label": {"api": {"getHeaders": [[56, 65]]}}}, {"text": "You can just inject UriInfo into the interceptor", "label": {"api": {"UriInfo": [[20, 26]]}}}, {"text": "To avoid duplicating predicates, you should rather use BiPredicate<T,U> which accepts one more parameter and produces a Boolean as well", "label": {"api": {"BiPredicate<T,U>": [[55, 70]]}}}, {"text": "Use the @XmlMixed JAXB annotation instead of @XmlValue to indicate that the element is mixed content", "label": {"api": {"@XmlMixed": [[8, 16]]}}}, {"text": "So when you have (int) (Math.random()*12-3), inside the inner parentheses, the result will be a double, which you cast to an int", "label": {"api": {"Math.random()": [[24, 36]]}}}, {"text": "This truncates the decimal places, so unless Math.random() * 12 returns exactly 0 (And then once you subtract 3 to get exactly -3), Math.random() * 12 -3, will return at the lowest 2.{...}, and it will get truncated to -2", "label": {"api": {"Math.random()": [[45, 57], [132, 144]]}}}, {"text": "I would use the following and as you have strange rules regarding the imports, I hide that one for Comparator deliberately", "label": {"api": {"Comparator": [[99, 108]]}}}, {"text": "If Comparator would be an internal interface/class I could understand it, but it's an essential interface", "label": {"api": {"Comparator": [[3, 12]]}}}, {"text": "my solution does not require you to use an import to java.util.Comparator", "label": {"api": {"Comparator": [[63, 72]], "java.util.Comparator": [[53, 72]]}}}, {"text": "getDeclaredFields() and iterate over them to filter out interested fields", "label": {"api": {"getDeclaredFields()": [[0, 18]]}}}, {"text": "If it's just the name of a field that you require, it is Field.getName() what you want", "label": {"api": {"Field.getName()": [[57, 71]]}}}, {"text": "The PrintWriter only really writes when they are closed (close) or flushed (flush or maybe when it thinks it is time ;-))", "label": {"api": {"PrintWriter": [[4, 14]], "close": [[49, 53], [57, 61]], "flush": [[67, 71], [76, 80]]}}}, {"text": "Try to use try-with-resources whenever possible, that way you do not need to think about closing/flushing a stream or writer", "label": {"api": {"flush": [[97, 101]]}}}, {"text": "try-with-resources takes care that AutoClosable-implementations are closed automatically at the end of the try-block", "label": {"api": {"close": [[68, 72]], "AutoClosable": [[35, 46]]}}}, {"text": "you may also want to lookup the Files-API", "label": {"api": {"Files-API": [[32, 40]]}}}, {"text": "Maybe using Files.lines is something for you", "label": {"api": {"Files.lines": [[12, 22]]}}}, {"text": "You can use the JMSPasswordCredential annotation", "label": {"api": {"JMSPasswordCredential annotation": [[16, 47]]}}}, {"text": "Before you start running off re-inventing the wheel (and probably the whole car), you should by investigating something BufferStrategy, which provides direct drawing capabilities to a \"paged flipping\" algorithm", "label": {"api": {"BufferStrategy": [[120, 133]]}}}, {"text": "BufferStrategy is limited, as you can't mix it with Swing components, as Swing uses a different rendering approach", "label": {"api": {"BufferStrategy": [[0, 13]]}}}, {"text": "You \"could\" also use a couple of BufferedImages, which act as pages, and manually swap them, which is essentially what BufferStrategy does any way, but if you're using Swing, Swing is already double buffered, so you might be just spinning wheels for the want to look cool", "label": {"api": {"BufferStrategy": [[119, 132]]}}}, {"text": "Another approach you could take is the toMap way; i.e", "label": {"api": {"toMap": [[39, 43]]}}}, {"text": "Queues have special methods which allow it to return null instead of throw an exception", "label": {"api": {"special methods": [[12, 26]]}}}, {"text": "This is useful in the case of a BlockingQueue, which should block until a value appears, or throw an exception", "label": {"api": {"BlockingQueue": [[32, 44]]}}}, {"text": "With Java 8 time API it would be easy to achieve the result using DateTimeFormatter and LocalDate", "label": {"api": {"Java 8 time": [[5, 15]], "DateTimeFormatter": [[66, 82]], "LocalDate": [[88, 96]]}}}, {"text": "You shall use Stream.findFirst with an Optional.orElse like", "label": {"api": {"Stream.findFirst": [[14, 29]], "Optional.orElse": [[39, 53]]}}}, {"text": "The above uses the Stream.map to map the stream of DataStructure to a corresponding stream of value", "label": {"api": {"Stream.map": [[19, 28]]}}}, {"text": "If you're on Java 9+, you can use Collectors.flatMapping like this", "label": {"api": {"Collectors.flatMapping": [[34, 55]]}}}, {"text": "LocalDate in fact implements Comparable<ChronoLocalDate> as well as ChronoLocalDate and by implementing those two, every instance of it is of course comparable to another LocalDate instance", "label": {"api": {"ChronoLocalDate": [[40, 54], [68, 82]]}}}, {"text": "You can have a look at the JavaDocs for LocalDate on Oracle's website", "label": {"api": {"JavaDocs for LocalDate": [[27, 48]]}}}, {"text": "ChronoLocalDate is an interface that is implemented by different types of calendars in order to make them all comparable to each other", "label": {"api": {"ChronoLocalDate": [[0, 14]]}}}, {"text": "That is because there are JapaneseDate, ThaiBuddhistDate, HijrahDate and at least one more", "label": {"api": {"JapaneseDate": [[26, 37]], "ThaiBuddhistDate": [[40, 55]], "HijrahDate": [[58, 67]]}}}, {"text": "See the documentation of the Future<V> Interface", "label": {"api": {"Future<V>": [[29, 37]]}}}, {"text": "I found a solution using AffineTransform to scale and translate", "label": {"api": {"AffineTransform": [[25, 39]]}}}, {"text": "tx being an AffineTransform which scales and translates", "label": {"api": {"AffineTransform": [[12, 26]]}}}, {"text": "I create a BufferedImage with Robot and try to apply FFT algorithm from rosetta code on the DataBufferInt generated by the Robot but it's fail in the fft method and I don't know why", "label": {"api": {"BufferedImage": [[11, 23]], "Robot": [[30, 34], [123, 127]], "DataBufferInt": [[92, 104]]}}}, {"text": "Though Aomine's suggested solution seems to be correct, you can alternatively improve your code readability and simplify it defining a BinaryOperator<Genuineness> as", "label": {"api": {"BinaryOperator<Genuineness>": [[135, 161]]}}}, {"text": "With Java8+, you can use Map.merge", "label": {"api": {"Map.merge": [[25, 33]]}}}, {"text": "This is because String.split()", "label": {"api": {"String.split()": [[16, 29]]}}}, {"text": "If you read the documentation, then you'll find that the javadoc of getName() states", "label": {"api": {"getName()": [[68, 76]]}}}, {"text": "getName() returns the fully qualified name of the class", "label": {"api": {"getName()": [[0, 8]]}}}, {"text": "If you don't want that, call getSimpleName()", "label": {"api": {"getSimpleName()": [[29, 43]]}}}, {"text": "BufferedWriter cannot write doubles, see the API specification", "label": {"api": {"API specification": [[45, 61]]}}}, {"text": "Methods getHours(), getMinutes() and other are from Date class and based on documentation they interpret it by local timezone Date.getHours()", "label": {"api": {"Date.getHours()": [[126, 140]]}}}, {"text": "If you need to achieve unique values-only, you should use Set", "label": {"api": {"Set": [[58, 60]]}}}, {"text": "From the Scanner.next() method javadoc", "label": {"api": {"Scanner.next() method javadoc": [[9, 37]]}}}, {"text": "or use Scanner.nextLine()", "label": {"api": {"Scanner.nextLine()": [[7, 24]]}}}, {"text": "Here is JavaDoc for the Scanner class, could you please check it, to broadly understand how it works", "label": {"api": {"class": [[32, 36]]}}}, {"text": "Java8 Optional class is a container can save null value.We can use it to check if an Integer object is null", "label": {"api": {"Java8 Optional": [[0, 13]]}}}, {"text": "Conveniently, Java's BigInteger class already includes this algorithm for you", "label": {"api": {"BigInteger": [[21, 30]]}}}, {"text": "The Stream::generate is not suitable for this issue", "label": {"api": {"Stream::generate": [[4, 19]]}}}, {"text": "You might want to use rather IntStream::range", "label": {"api": {"IntStream::range": [[29, 44]]}}}, {"text": "Another solution might be using the IntStream.iterate where you can control the increment comfortably using the IntUnaryOperator", "label": {"api": {"IntStream.iterate": [[36, 52]], "IntUnaryOperator": [[112, 127]]}}}, {"text": "As said, the Stream::generate is suitable for the constant streams or random elements", "label": {"api": {"Stream::generate": [[13, 28]]}}}, {"text": "Specify a Locale, to determine the human language used in translating name of month and such", "label": {"api": {"Locale": [[10, 15]]}}}, {"text": "If they need to be unique you can use a Set", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "Or java 8+ you can use the ints() method to get a Stream and collect it to a Set", "label": {"api": {"Set": [[77, 79]], "ints()": [[27, 32]]}}}, {"text": "Standard library has a method Collections.disjoint that helps by determining if two collections have any elements in common", "label": {"api": {"Collections.disjoint": [[30, 49]]}}}, {"text": "In the case of Optional.empty() it makes sense to cache the value as that is immutable", "label": {"api": {"Optional.empty()": [[15, 30]]}}}, {"text": "There is already the Optional::ifPresent method that accepts a Consumer", "label": {"api": {"Optional::ifPresent": [[21, 39]], "Consumer": [[63, 70]], "Optional": [[21, 28]]}}}, {"text": "In Java 8, the only way is to use Optional::map, to map the entity to itself and use it as peek method", "label": {"api": {"Optional::map": [[34, 46]], "Optional": [[34, 41]]}}}, {"text": "and used comfortably with Optional", "label": {"api": {"Optional": [[26, 33]]}}}, {"text": "Declare your list as an ObservableList then add a listener to it which contains all the necessary updates to your controls", "label": {"api": {"ObservableList": [[24, 37]]}}}, {"text": "For this usage, How to Use Tool Tips suggests overriding the getToolTipText() method of the enclosing JComponent", "label": {"api": {"JComponent": [[102, 111]]}}}, {"text": "Take a look at the Java String#replaceAll method", "label": {"api": {"String#replaceAll": [[24, 40]]}}}, {"text": "The regular expression \"(cc.*?)d\" will match the first d anywhere after a cc, and then, because of the reluctant quantifier *?, won't match subsequent instances of d", "label": {"api": {"reluctant quantifier": [[103, 122]]}}}, {"text": "You can use the capturing group ((...)) to take note of what preceded the d, and then reference that in your replacement string", "label": {"api": {"capturing group": [[16, 30]]}}}, {"text": "A couple notes on terminology—Set is a distinct data structure from List, where the former is unordered and does not allow duplicates, while the latter is a basic, linear collection, that's generally ordered, and allows duplicates", "label": {"api": {"Set": [[30, 32]], "List": [[68, 71]]}}}, {"text": "Set is probably the appropriate data structure here", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "That said, it seems that your code is relying on the List API, so we can follow that along", "label": {"api": {"List": [[53, 56]]}}}, {"text": "Note that you should, in general, code to the interface (List), rather than the specific class (ArrayList)", "label": {"api": {"List": [[57, 60], [101, 104]]}}}, {"text": "Additionally, consider using the Arrays.asList shorthand method for initializing a list (note that this returns an immutable list)", "label": {"api": {"List": [[42, 45]], "Arrays.asList": [[33, 45]]}}}, {"text": "Finally, note that a HashSet eliminates duplicates by checking if both objects have the same hashCode", "label": {"api": {"Set": [[25, 27]], "hashCode": [[93, 100]]}}}, {"text": "Lists containing the same elements are still not considered to be the same list unless the elements appear in the same order, and will typically not be treated as duplicates", "label": {"api": {"List": [[0, 3]], "same order": [[114, 123]]}}}, {"text": "Sets, however, implement equals and hashCode in such a way that two sets containing exactly the same elements are considered equal (order doesn't matter)", "label": {"api": {"Set": [[0, 2]], "hashCode": [[36, 43]], "equals": [[25, 30]]}}}, {"text": "You can simulate these steps using a Stream, and using method references to convert to and from the Set, as below", "label": {"api": {"Set": [[100, 102]], "Stream": [[37, 42]]}}}, {"text": "I believe you want the split() method", "label": {"api": {"split()": [[23, 29]]}}}, {"text": "You can use Collections#addAll to directly add all the elements from the Array produced by split to the List", "label": {"api": {"Collections#addAll": [[12, 29]]}}}, {"text": "You can use a different specification of a map called SortedMap", "label": {"api": {"SortedMap": [[54, 62]]}}}, {"text": "getMethod accepts 2 parameters", "label": {"api": {"getMethod": [[0, 8]]}}}, {"text": "If you want to print an array you have to iterate over all elements or you can use the method toString of Arrays", "label": {"api": {"toString": [[94, 101]]}}}, {"text": "The url you're seeing is encoded, in Java you can get the unencoded URL with URLDecoder.decode", "label": {"api": {"URLDecoder.decode": [[77, 93]]}}}, {"text": "You can use expression binding in the fxml", "label": {"api": {"expression binding": [[12, 29]]}}}, {"text": "Fortunately, Java makes this really easy with the idea of adjusters and TemporalAdjusters.firstDayOfNextMonth()", "label": {"api": {"TemporalAdjusters.firstDayOfNextMonth()": [[72, 110]]}}}, {"text": "As the the documentation says, Deque can be used as a FIFO (First-In-First-Out) queue and it can be used as a LIFO (Last-In-First-Out) stack as well", "label": {"api": {"Deque": [[31, 35]]}}}, {"text": "Alternatively, StringBuilder has a delete method", "label": {"api": {"delete": [[35, 40]]}}}, {"text": "So would start here Java API", "label": {"api": {"Java API": [[20, 27]]}}}, {"text": "If you want just don't close&reopen the file each time, you can use some lower-level file-specific API like RandomAccessFile which can be reset using seek(0)", "label": {"api": {"RandomAccessFile": [[108, 123]]}}}, {"text": "The parameters to Collectors.toMap should be functions that convert the input to your desired output", "label": {"api": {"Collectors.toMap": [[18, 33]]}}}, {"text": "When iterating a HashSet, the iteration order is generally the order of the hash of the object, which is generally not too useful if you want a predictable order", "label": {"api": {"HashSet": [[17, 23]]}}}, {"text": "If sane ordering is important you would generally need to use a TreeSet which iterates in sorted order but at a cost because maintaining the sorted order adds to the complexity of the process", "label": {"api": {"TreeSet": [[64, 70]]}}}, {"text": "A LinkedHashSet can be used as a middle-ground solution to the seemingly insane ordering of a HashSet by ensuring that the iteration order is at least consistent by using the insertion order", "label": {"api": {"HashSet": [[8, 14], [94, 100]], "LinkedHashSet": [[2, 14]]}}}, {"text": "You may want to look into my other posts using toMap collectors to get familiar with it and ofcourse the API doc", "label": {"api": {"ofcourse the API doc": [[92, 111]]}}}, {"text": "Instead of using Collections.sort(factors) (or factors.sort(null)), you can use a Stream to sort and then collect it to String using Collectors.joining", "label": {"api": {"factors.sort(null)": [[47, 64]]}}}, {"text": "If you're really smart you might consider using the Java JDK 8 functional interfaces", "label": {"api": {"8 functional interfaces": [[61, 83]]}}}, {"text": "Use the String#trim() method to remove the trailing whitespace(s)", "label": {"api": {"String#trim()": [[8, 20]]}}}, {"text": "The Big Decimal documentation can be found here instead", "label": {"api": {"instead": [[48, 54]]}}}, {"text": "I think you should look at https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html and get an idea for the behavior of a linked list initially", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html": [[27, 93]]}}}, {"text": "You have to implement Comparable for the Student class or sort it directly using a custom Comparator", "label": {"api": {"Comparable": [[22, 31]], "Comparator": [[90, 99]]}}}, {"text": "Or dynamically from within your application, using System.setProperty()", "label": {"api": {"System.setProperty()": [[51, 70]]}}}, {"text": "If you just want the List of uniques then you can use Stream.distinct as", "label": {"api": {"Stream.distinct": [[54, 68]]}}}, {"text": "If you really are willing to get a boolean though from the Predicate, you can use its test method", "label": {"api": {"test": [[86, 89]], "Predicate": [[59, 67]]}}}, {"text": "Predicate on the other hand is just a FunctionalInterface, that you've represented using a lambda expression", "label": {"api": {"Predicate": [[0, 8]], "FunctionalInterface": [[38, 56]]}}}, {"text": "Which will invoke the toString() implemented in the AbstractMap base class", "label": {"api": {"AbstractMap": [[52, 62]]}}}, {"text": "Instead, you could iterate the entrySet() of your map object manually, pull keys, values, and write those into your file", "label": {"api": {"entrySet()": [[31, 40]]}}}, {"text": "You may want to use a Path, then call its parents the number of times you need", "label": {"api": {"Path": [[22, 25]]}}}, {"text": "I just got corrected in another question and would recomment you as well to instead use java.time.LocalDate for createDt attribute", "label": {"api": {"java.time.LocalDate": [[88, 106]]}}}, {"text": "You are trying to call Arrays.asList() on things, which is already a List", "label": {"api": {"Arrays.asList()": [[23, 37]]}}}, {"text": "But the between method truncates fractional units", "label": {"api": {"between method": [[8, 21]]}}}, {"text": "The split method of String class in Java takes regular expressions, and regular expressions in Java have the or operator similar to if", "label": {"api": {"split": [[4, 8]]}}}, {"text": "So instead of splitting on a single character like a space, you can split on several different things like coma and space, just a space, and a period", "label": {"api": {"split": [[14, 18], [68, 72]]}}}, {"text": "when split receives it as a parameter", "label": {"api": {"split": [[5, 9]]}}}, {"text": "So this will split the string on anything that is not a word", "label": {"api": {"split": [[13, 17]]}}}, {"text": "So no matter which solution you use - replaceAll suggested by Spara, word search using Matcher suggested by nemanja228, or the split in my answer, there will always be copies of the original string created, and the original will not be changed, so you just need to keep a reference to it to preserve it for future use (don't change the variable that holds it)", "label": {"api": {"split": [[127, 131]]}}}, {"text": "You cannot create it as generic as you are looking for since a Map is not a Collection", "label": {"api": {"Map": [[63, 65]], "Collection": [[76, 85]]}}}, {"text": "And of course Collection..", "label": {"api": {"Collection": [[14, 23]]}}}, {"text": "collectionList signifies var args for Collection type", "label": {"api": {"Collection": [[38, 47]]}}}, {"text": "You could construct a BigInteger object from the string and then compare that BigInteger to Integer.MAX_VALUE", "label": {"api": {"BigInteger": [[22, 31], [78, 87]]}}}, {"text": "See https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.14.1 and https://docs.oracle.com/javase/10/docs/api/java/lang/String.html#charAt(int)", "label": {"api": {"https://docs.oracle.com/javase/10/docs/api/java/lang/String.html#charAt(int)": [[82, 157]]}}}, {"text": "By default Java will run the main class in a single process, on the same thread", "label": {"api": {"thread": [[73, 78]]}}}, {"text": "You can set the hours to the same in both with myTime.withHour(0), than you have left only the minutes and seconds that differ and you are able to come these 2 times", "label": {"api": {"myTime.withHour(0)": [[47, 64]]}}}, {"text": "Consider using Objects.isNull() instead of the '== null' you have throughout your code", "label": {"api": {"Objects.isNull()": [[15, 30]]}}}, {"text": "The StandardCopyOption enumeration type defines the standard options", "label": {"api": {"CopyOption": [[12, 21]]}}}, {"text": "CopyOption is just an empty interface, StandardCopyOption is an enum which implements CopyOption and contains the standard options eg", "label": {"api": {"CopyOption": [[0, 9], [47, 56], [86, 95]]}}}, {"text": "if you really need an Object[] you could convert your List<Object> using .toArray()", "label": {"api": {".toArray()": [[73, 82]]}}}, {"text": "For this, you have to use method List::addAll which passes all the elements from the List to another one", "label": {"api": {"List::addAll": [[33, 44]], "List::add": [[33, 41]]}}}, {"text": "You have used List::add which adds an element to the list as is - in your case the added element was a new entire List and not its elements", "label": {"api": {"List::add": [[14, 22]]}}}, {"text": "Array list insertion is amortized constant time, with the caveat that if it reaches a certain capacity, it will double the size of its internal array and copy over all of the previous values it had to keep track of, which is O(k), where k is the size of the current list", "label": {"api": {"amortized constant time": [[24, 46]]}}}, {"text": "On the other hand, perhaps you could implement your class for all Comparables", "label": {"api": {"Comparables": [[66, 76]]}}}, {"text": "You could possibly use Stream.noneMatch here as", "label": {"api": {"Stream.noneMatch": [[23, 38]]}}}, {"text": "You are probably looking to use Collectors.groupingBy to group the List<DataMap> by consultedOn and further grouping it by consultedBy attribute and their count as", "label": {"api": {"Collectors.groupingBy": [[32, 52]]}}}, {"text": "In the past, I was using the function snapshot which was fast but that forced me to compute the evaluation inside a JavaFX thread; therefore, blocking my entire GUI by putting to much computations in GUI threads", "label": {"api": {"snapshot": [[38, 45]]}}}, {"text": "This current solution allows me to put the computations inside a Service but it is really slow", "label": {"api": {"Service": [[65, 71]]}}}, {"text": "String#matches matches the entire String, so if there is a single character that does not match, it will return false", "label": {"api": {"String#matches": [[0, 13]]}}}, {"text": "Instead of add(index, element) you should use set(index, element)", "label": {"api": {"add(index, element)": [[11, 29]], "set(index, element)": [[46, 64]]}}}, {"text": "Also, as noted in comments, while implementing your own Bubble Sort or Selection Sort or whichever this is is a great exercise, in all practical applications you should use one of the several built-in sorting methods instead, such as Collections.sort", "label": {"api": {"Collections.sort": [[234, 249]]}}}, {"text": "You can get it using Collectors.groupingBy the id attribute and then counting its occurrences as", "label": {"api": {"Collectors.groupingBy": [[21, 41]], "counting": [[69, 76]]}}}, {"text": "The javadoc of nextClearBit says", "label": {"api": {"nextClearBit": [[15, 26]]}}}, {"text": "If you want to know how BitSet works and what it does, read its Javadoc and look at the source", "label": {"api": {"BitSet": [[24, 29]]}}}, {"text": "The problem is that String#contains does not accept a regular expression", "label": {"api": {"String#contains": [[20, 34]]}}}, {"text": "Which will utilize the method addAll to add all the elements returned by the recursive calls", "label": {"api": {"addAll": [[30, 35]]}}}, {"text": "Then you can toLowerCase() to convert the sentence to lowercase, and then split() to create the Array", "label": {"api": {"toLowerCase()": [[13, 25]], "split()": [[74, 80]]}}}, {"text": "You only have to use distinct() and sorted() to create a stream of unique values in alphabetical order", "label": {"api": {"distinct()": [[21, 30]], "sorted()": [[36, 43]]}}}, {"text": "They should either be Comparable (of the same type", "label": {"api": {"Comparable": [[22, 31]]}}}, {"text": "both Integers and Strings are comparable, but you can't just sort a list that contains both out of the box), or you should use an explicit Comparator of the right type", "label": {"api": {"Comparator": [[139, 148]]}}}, {"text": "A quick search in the java documentation for Comparable reveals", "label": {"api": {"java documentation for Comparable": [[22, 54]]}}}, {"text": "One way to address this is to use a BigInteger instead of an int", "label": {"api": {"BigInteger": [[36, 45]]}}}, {"text": "You can use Long.parseUnsignedLong in Java to get the same result", "label": {"api": {"Long.parseUnsignedLong": [[12, 33]]}}}, {"text": "The application's context path can be determined within a ServletContextListener from  ServletContext.getContextPath()", "label": {"api": {"ServletContextListener": [[58, 79]], "ServletContext.getContextPath()": [[87, 117]]}}}, {"text": "For this case, you should use AtomicInteger instead of int, and change methods", "label": {"api": {"AtomicInteger": [[30, 42]]}}}, {"text": "There are better ways to deal with byte arrays using an overloaded doFinal", "label": {"api": {"doFinal": [[67, 73]]}}}, {"text": "Even a basic Timer is better", "label": {"api": {"Timer": [[13, 17]]}}}, {"text": "You can still invoke setEnabled() on the ChartPanel itself to leverage the JPanel UI delegate", "label": {"api": {"setEnabled()": [[21, 32]]}}}, {"text": "JavaFX' Application) not be shown as runnable by IntelliJ", "label": {"api": {"Application": [[8, 18]]}}}, {"text": "When a JTextPane sees an <img> tag, it will check if the image exists in a cache, and if not, it will try to read the image from the url", "label": {"api": {"JTextPane": [[7, 15]]}}}, {"text": "The html library used by JTextPane does not support base64 encoded image data in the <img> tag, so we will need to do it in a different way", "label": {"api": {"JTextPane": [[25, 33]]}}}, {"text": "Let's add the image to the cache and show it in a JTextPane", "label": {"api": {"JTextPane": [[50, 58]]}}}, {"text": "First you want to convert the image into a BufferedImage", "label": {"api": {"BufferedImage": [[43, 55]]}}}, {"text": "This can be done using the ImageIO class", "label": {"api": {"ImageIO": [[27, 33]]}}}, {"text": "If you are reading the image from a file, you can pass a File to the read function instead of the input stream", "label": {"api": {"File": [[57, 60]]}}}, {"text": "Now that we have the image as a BufferedImage, we can write a function that adds it to the cache", "label": {"api": {"BufferedImage": [[32, 44]]}}}, {"text": "Avoid using crazy characters in this name, as new Url(url) may throw a MalformedURLException if it is not a valid url", "label": {"api": {"MalformedURLException": [[71, 91]]}}}, {"text": "We can now use it with JTextPane", "label": {"api": {"JTextPane": [[23, 31]]}}}, {"text": "If the image in the cache is changed by using saveImageToCache with a previously known name, you will need to update the JTextPane in some way, such as calling setText", "label": {"api": {"JTextPane": [[121, 129]]}}}, {"text": "You can also clear the cache by calling setContentType or by replacing the JTextPane with a new object", "label": {"api": {"JTextPane": [[75, 83]]}}}, {"text": "This works as the cache is stored in the JTextPane", "label": {"api": {"JTextPane": [[41, 49]]}}}, {"text": "I'm aware that I could run something like the id shell command and parse its output in Java, but I've also stumbled upon the UnixSystem class, which gives me an array of all gids the current user belongs to", "label": {"api": {"UnixSystem": [[125, 134]]}}}, {"text": "It's ambiguous because the static and non-static toString() methods are both compatible with the functional signature Integer -> String", "label": {"api": {"static": [[27, 32], [42, 47]], "non-static": [[38, 47]]}}}, {"text": "Use a ByteBuffer", "label": {"api": {"ByteBuffer": [[6, 15]]}}}, {"text": "On another note, there's probably a better way to do this using java.nio.file API, some few examples here and here etc.", "label": {"api": {"java.nio.file": [[64, 76]]}}}, {"text": "Maybe an exception  , achem, an Error killed them", "label": {"api": {"Error": [[32, 36]]}}}, {"text": "You don't need to cast using TypedQuery", "label": {"api": {"TypedQuery": [[29, 38]]}}}, {"text": "To achieve what you want, you need to update the character attributes of the selection by using the method setCharacterAttributes provided by the Document", "label": {"api": {"setCharacterAttributes": [[107, 128]]}}}, {"text": "You can use InputStream.transferTo(OutputStream ) method and start with default BufferedOutputStream size of 8196", "label": {"api": {"InputStream.transferTo(OutputStream )": [[12, 48]]}}}, {"text": "There are already classes that you could use instead, like AtomicInteger, or similar, but slightly different LongAdder", "label": {"api": {"AtomicInteger": [[59, 71]], "LongAdder": [[109, 117]]}}}, {"text": "You could use a CountDownLatch (see example 3 here) to ensure all requests are over before printing the contents", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "Arrays.asList returns a fixed-size of array, which is a direct subclass of AbstractList and apparently does not support add and remove functions.", "label": {"api": {"Arrays.asList": [[0, 12]], "AbstractList": [[75, 86]]}}}, {"text": "You could try ArrayList instead of Arrays.asList if you intend to perform add or remove functions later; both of them are types of List but have different implementations", "label": {"api": {"Arrays.asList": [[35, 47]], "ArrayList": [[14, 22]]}}}, {"text": "Better seems to use a FilterWriter as base class, as that is its purpose", "label": {"api": {"FilterWriter": [[22, 33]]}}}, {"text": "Then at end, you can use the default sorter, which will sort alphabetically", "label": {"api": {"sorter": [[37, 42]]}}}, {"text": "ANd if you still want this method to return a sorted string, instead of a sorted list, you can do it this way, using Join method", "label": {"api": {"Join method": [[117, 127]]}}}, {"text": "MyInvocationHandler implements InvocationHandler interface", "label": {"api": {"InvocationHandler": [[2, 18], [31, 47]]}}}, {"text": "The method returns the inferred Class and the original String (possibly slightly modified -- surrounding whitespace trimmed, etc.) in a Map.Entry<Class, String>", "label": {"api": {"Map.Entry<Class, String>": [[136, 159]]}}}, {"text": "I'd like to format a Period using a pattern like YY years, MM months, DD days", "label": {"api": {"Period": [[21, 26]]}}}, {"text": "There's a PeriodFormatter in Joda time", "label": {"api": {"Period": [[10, 15]]}}}, {"text": "One solution is to simply use String.format", "label": {"api": {"String.format": [[30, 42]]}}}, {"text": "If your really need to use the features of DateTimeFormatter, you can use a temporary LocalDate, but this is a kind of hack that distort the semantic of LocalDate", "label": {"api": {"DateTimeFormatter": [[43, 59]], "LocalDate": [[86, 94], [153, 161]]}}}, {"text": "See the manual", "label": {"api": {"manual": [[8, 13]]}}}, {"text": "I've found how to search for all fields and variables of a type that implements a given interface, in my case AutoCloseable", "label": {"api": {"AutoCloseable": [[110, 122]]}}}, {"text": "My current way to do this is first creating a filter for classes that implement AutoCloseable", "label": {"api": {"AutoCloseable": [[80, 92]]}}}, {"text": "class $Class$ implements $Interface$ {} where $Interface$ is filtered with text=AutoCloseable", "label": {"api": {"AutoCloseable": [[80, 92]]}}}, {"text": "After saving that filter as \"AutoCloseableFilter\", I use another filter that uses it", "label": {"api": {"AutoCloseable": [[29, 41]]}}}, {"text": "$FieldType$ where $FieldType$ is filtered with reference=AutoCloseableFilter", "label": {"api": {"AutoCloseable": [[57, 69]]}}}, {"text": "I am building an application that is running in the background and provides access to a control panel (JavaFX Dialog) by clicking on the icon on the SystemTray", "label": {"api": {"SystemTray": [[149, 158]]}}}, {"text": "Look into BigInteger", "label": {"api": {"BigInteger": [[10, 19]]}}}, {"text": "As your data structure allows for storing binary numbers of arbitrary size, BigInteger allows for storing integer numbers of arbitrary size", "label": {"api": {"BigInteger": [[76, 85]]}}}, {"text": "As you are able to convert your list of bits to String, you might want to use this constructor public BigInteger​(String val, int radix)", "label": {"api": {"BigInteger": [[102, 111]], "public BigInteger​(String val, int radix)": [[95, 135]]}}}, {"text": "Use a TreeMap with a custom Comparator", "label": {"api": {"TreeMap": [[6, 12]], "Comparator": [[28, 37]]}}}, {"text": "By default, the String Comparator compares Strings lexicographically and this is the reason why you see an order like this {\"1\", \"10\", \"11\", ..., \"2\", \"20\"}", "label": {"api": {"Comparator": [[23, 32]]}}}, {"text": "Because I assume your key will always be a double, this Comparator should work", "label": {"api": {"Comparator": [[56, 65]]}}}, {"text": "You could utilize the Stream API and collect the result to an array, rather than use a traditional for loop", "label": {"api": {"Stream": [[22, 27]]}}}, {"text": "The first line defines a Function which takes a String and returns an Integer", "label": {"api": {"Function": [[25, 32]]}}}, {"text": "Arrays.stream() simply creates a Stream from the array", "label": {"api": {"Stream": [[33, 38]]}}}, {"text": "toArray() finally collect the Stream into an array", "label": {"api": {"Stream": [[30, 35]]}}}, {"text": "Now let's look at its docs for Java 9", "label": {"api": {"its docs": [[18, 25]]}}}, {"text": "Use the system tool provider or service loader mechanisms to locate system tools as well as user-installed tools", "label": {"api": {"system tool provider": [[8, 27]], "service loader": [[32, 45]]}}}, {"text": "Things were different in Java 8, though", "label": {"api": {"were different": [[7, 20]]}}}, {"text": "Leaving aside how your code will receive table name, and parameter values for prepared statement, you can obtain column information by calling Connection.getMetaData().getColumns(...)", "label": {"api": {"Connection.getMetaData().getColumns(...)": [[143, 182]]}}}, {"text": "For every column, corresponding row in the ResultSet will contain a column DATA_TYPE with an int corresponding to one of the java.sql.Types", "label": {"api": {"java.sql.Types": [[125, 138]]}}}, {"text": "The DatabaseMetaData interface has a lot of useful methods for getting details about a particular database", "label": {"api": {"DatabaseMetaData": [[4, 19]]}}}, {"text": "Just use String#replace(), this replaces vartest in your line17 string with mynewstring, ofcourse this can be whatever you want", "label": {"api": {"String#replace()": [[9, 24]]}}}, {"text": "As an alternative to synchronization, you can also use a compareAndSet", "label": {"api": {"compareAndSet": [[57, 69]]}}}, {"text": "The return value of compareAndSet indicates whether the value was changed or not", "label": {"api": {"compareAndSet": [[20, 32]]}}}, {"text": "This seems like an interview question about Collections", "label": {"api": {"Collections": [[44, 54]]}}}, {"text": "Now, Collections.reverseOrder is a Comparator that inverts the normal order, > becomes < and vice versa", "label": {"api": {"Collections": [[5, 15]]}}}, {"text": "First, the threads used by Executors.newSingleThreadExecutor() are non-daemon threads", "label": {"api": {"non-daemon": [[67, 76]]}}}, {"text": "As the documentation of Thread mentions, non-daemon threads will keep the JVM alive", "label": {"api": {"non-daemon": [[41, 50]]}}}, {"text": "When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class)", "label": {"api": {"non-daemon": [[65, 74]]}}}, {"text": "If you want to try and terminate the ExecutorService immediately you must use ExecutorService.shutdownNow()", "label": {"api": {"ExecutorService.shutdownNow()": [[78, 106]]}}}, {"text": "An example on the JDK8 version of it", "label": {"api": {"JDK8": [[18, 21]]}}}, {"text": "String#replace does not support regex, it will try to replace your string literally, note the Pattern.LITERAL in the source code of String#replace", "label": {"api": {"String#replace": [[0, 13], [132, 145]], "Pattern.LITERAL": [[94, 108]]}}}, {"text": "The method you're looking for is String#replaceAll or String#replaceFirst, both of these take regex as input", "label": {"api": {"String#replace": [[33, 46], [54, 67]], "String#replaceAll": [[33, 49]], "String#replaceFirst": [[54, 72]]}}}, {"text": "How about the Locale.getISOLanguages() which covers ISO 639", "label": {"api": {"Locale.getISOLanguages()": [[14, 37]]}}}, {"text": "Then there are Map.computeIfAbsent, computeIfPresent, merge if you want to update the map", "label": {"api": {"Map.computeIfAbsent, computeIfPresent, merge": [[15, 58]]}}}, {"text": "In accordance with DateTimeFormatter API, part of the time should be in uppercase and consist of 2 letters (PM instead of p)", "label": {"api": {"DateTimeFormatter API": [[19, 39]]}}}, {"text": "Use ProcessBuilder instead", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "The call to inheritIO() will make the process’s output show in the Java program’s output, so there is no need to read and print the Process’s InputStream", "label": {"api": {"inheritIO()": [[12, 22]]}}}, {"text": "If you want the list without the element to keep updating, you can create a view of the list by extending AbstractList", "label": {"api": {"AbstractList": [[106, 117]]}}}, {"text": "Use StringBuilder to construct just one String instead of String[] array", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "We can implement that using a dedicated semaphore for each \"road\", or segment, where each user takes a permit, after first making sure none of the other segments have permits in use", "label": {"api": {"semaphore": [[40, 48]]}}}, {"text": "Here's an implementation of a such a concept, using a background thread that manages a set of read/write locks, making sure only one segment has a write lock available at a time", "label": {"api": {"read/write locks": [[94, 109]]}}}, {"text": "Use SET instead of list", "label": {"api": {"SET": [[4, 6]]}}}, {"text": "And then use Class::instance in the T build() method", "label": {"api": {"Class::instance": [[13, 27]]}}}, {"text": "The DateTimeFormatter class includes a number of predefined formats, including a few ISO formats", "label": {"api": {"class": [[22, 26]]}}}, {"text": "Waiting for CompletableFutureis done by calling its method  get()", "label": {"api": {"get()": [[60, 64]]}}}, {"text": "You are afraid that \"Calling join() or get() only blocks the thread that the CompletableFuture is running in...\" - this can only happen when join() or get() are called from a method called from CompletableFuture", "label": {"api": {"get()": [[39, 43], [151, 155]]}}}, {"text": "and only then call join() or get()", "label": {"api": {"get()": [[29, 33]]}}}, {"text": "From the documentation of Files.isHidden(Path) (emphasis mine)", "label": {"api": {"Files.isHidden(Path)": [[26, 45]]}}}, {"text": "The method Files.isHidden(Path) simply forwards the call to the argument's FileSystem's provider", "label": {"api": {"Files.isHidden(Path)": [[11, 30]]}}}, {"text": "In case of the widely used Hotspot/OpenJDK environment (and likely also in IBM’s JVM), this is implemented by creating an instance of a special, non-public subclass of Reference, a Finalizer, right when an object, whose class has a non-trivial finalize() method, is created", "label": {"api": {"Reference": [[168, 176]]}}}, {"text": "From the javadoc https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html#writeUTF-java.lang.String- with emphasis added", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html#writeUTF-java.lang.String-": [[17, 114]]}}}, {"text": "forEach() as a Consumer as the one and only parameter therefore you need to give an implemention of the method accept() which returns void so on the second example you're implementing a method with the given assinature static boolean method(int)", "label": {"api": {"Consumer": [[15, 22]]}}}, {"text": "Per the documentation of Future ( https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get() ), if you try and get the result of the execution and the execution threw an exception, then an ExecutionException will be thrown to signal that something went wrong inside the future", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get()": [[34, 113]]}}}, {"text": "See also javadoc of Logger.getLogger()", "label": {"api": {"Logger.getLogger()": [[20, 37]]}}}, {"text": "You could possibly do that using Optional.orElseGet which expects  a Supplier as", "label": {"api": {"Optional.orElseGet": [[33, 50]]}}}, {"text": "If you want the newly parsed items to the new array String[], use the Stream::toArray with the generator to get a correct type of array", "label": {"api": {"Stream::toArray": [[70, 84]]}}}, {"text": "I have already found a great fix for my problem on Stack Overflow thanks to dasblinkenlight's link type conversions", "label": {"api": {"type conversions": [[99, 114]]}}}, {"text": "Use the method HttpServletRequest::getParameterMap to receive the Map of the passed parameters for the further iteration and validation", "label": {"api": {"HttpServletRequest::getParameterMap": [[15, 49]]}}}, {"text": "It's not entirely clear to me from your question of your exact problem so my suggestion might not be applicable for you scenario, but could you set an uncaught exception handler", "label": {"api": {"uncaught exception handler": [[151, 176]]}}}, {"text": "I have a question regarding Java 8's Optional, the purpose of which is to tackle NullPointerException exceptions", "label": {"api": {"Optional": [[37, 44]]}}}, {"text": "Why would people opt for Optional instead of normal if-else for null checking", "label": {"api": {"Optional": [[25, 32]]}}}, {"text": "From the EntityManager.getReference() documentation", "label": {"api": {"EntityManager.getReference()": [[9, 36]]}}}, {"text": "Math#pow takes two doubles", "label": {"api": {"Math#pow": [[0, 7]]}}}, {"text": "Since Java 9, there is Optional.or", "label": {"api": {"Optional.or": [[23, 33]]}}}, {"text": "You need to use the remove() method", "label": {"api": {"remove()": [[20, 27]]}}}, {"text": "You want to use the getMessage() method", "label": {"api": {"getMessage()": [[20, 31]]}}}, {"text": "There is a helper class HttpServletResponseWrapper designed for that purpose", "label": {"api": {"HttpServletResponseWrapper": [[24, 49]]}}}, {"text": "The Java Security Manager method checkMemberAccess() had a parameter that contained the class that Reflection was being called on", "label": {"api": {"checkMemberAccess()": [[33, 51]]}}}, {"text": "There are no parameters in checkPermission() that are similar to those in checkMemberAccess()", "label": {"api": {"checkMemberAccess()": [[74, 92]]}}}, {"text": "In a Security Manager, how do I get the Reflection target class without the checkMemberAccess() method", "label": {"api": {"checkMemberAccess()": [[76, 94]]}}}, {"text": "I won't delve too much on getResourceAsStream, the javadoc will do better explanation, but", "label": {"api": {"the javadoc will do better explanation": [[47, 84]]}}}, {"text": "Constructor of Java's BigInteger expects the number in 2's complement binary representation, while Go's big.Int.SetBytes() expects an unsigned integer value (in big-endian byte order)", "label": {"api": {"BigInteger": [[22, 31]]}}}, {"text": "You can then parse into a ZonedDateTime before changing the zone to whatever you want", "label": {"api": {"ZonedDateTime": [[26, 38]]}}}, {"text": "This is the exact reason why the Objects::nonNull API exists", "label": {"api": {"Objects::nonNull": [[33, 48]]}}}, {"text": "From java doc of BigDecimal", "label": {"api": {"BigDecimal": [[17, 26]]}}}, {"text": "You are dividing miles by gallons without defining the scale and retrieving this error, because you are using the method public BigDecimal divide(BigDecimal divisor) that is using un unlimited precision", "label": {"api": {"BigDecimal": [[128, 137], [146, 155]]}}}, {"text": "Returns a BigDecimal whose value is (this / divisor), and whose preferred scale is (this.scale() - divisor.scale()); if the exact quotient cannot be represented (because it has a non-terminating decimal expansion) an ArithmeticException is thrown", "label": {"api": {"BigDecimal": [[10, 19]]}}}, {"text": "Use divide(BigDecimal divisor, int scale, RoundingMode roundingMode) instead", "label": {"api": {"BigDecimal": [[11, 20]], "divide(BigDecimal divisor, int scale, RoundingMode roundingMode)": [[4, 67]]}}}, {"text": "Returns a BigDecimal whose value is (this / divisor), and whose scale is as specified", "label": {"api": {"BigDecimal": [[10, 19]]}}}, {"text": "With that said, consider using the SwingWorker for long running tasks (i.e", "label": {"api": {"SwingWorker": [[35, 45]]}}}, {"text": "As, for example, java.nio.file.StandardCopyOption", "label": {"api": {"java.nio.file.StandardCopyOption": [[17, 48]]}}}, {"text": "As, for example, java.util.Collections.emptySet or java.util.stream.collectors.toSet", "label": {"api": {"java.util.Collections.emptySet": [[17, 46]], "java.util.stream.collectors.toSet": [[51, 83]]}}}, {"text": "A good example of this is String.CASE_INSENSITIVE_ORDER, which is a constant of Comparator<String> that does what its name says", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[26, 54]]}}}, {"text": "However, Java cipher.updateAAD uses byteArray which is signed byte array", "label": {"api": {"cipher.updateAAD": [[14, 29]]}}}, {"text": "This is an example from the documentation, using java.nio.file.Files", "label": {"api": {"from the documentation": [[19, 40]]}}}, {"text": "I am using the read() method and I have also changed the indices of the substring", "label": {"api": {"read()": [[15, 20]]}}}, {"text": "You can also take a look at this answer here, which suggests using read() instead, to read your string character by character", "label": {"api": {"read()": [[67, 72]]}}}, {"text": "Use the getDeclaredConstructor method to pass in the parameter types expected in the constructor to find", "label": {"api": {"getDeclaredConstructor method": [[8, 36]]}}}, {"text": "If you want to use a HashMap or a HashSet, you'll need to override the hashCode() method so that objects that are equal have the same hash code", "label": {"api": {"hashCode()": [[71, 80]]}}}, {"text": "You can sort it using Stream.sorted as", "label": {"api": {"Stream.sorted": [[22, 34]]}}}, {"text": "As for generating the indices look into IntStream.range", "label": {"api": {"IntStream.range": [[40, 54]]}}}, {"text": "4 is exclusive, IntStream.rangeClosed(startInc, endInc) enables one to generate indices from startInc to endInc inclusive", "label": {"api": {"IntStream.range": [[16, 30]], "IntStream.rangeClosed(startInc, endInc)": [[16, 54]]}}}, {"text": "The problem is, after calling the copy constructor, they both share the same Date instance, which is mutable (via its setTime method)", "label": {"api": {"setTime method": [[118, 131]]}}}, {"text": "If the Date object itself (not the Employee property) is changed by calling its setTime method, we can see the effect", "label": {"api": {"setTime method": [[80, 93]]}}}, {"text": "if the list is structurally modified at any time after the iterator is created, in any way except through the Iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[174, 204]]}}}, {"text": "If you want to maintain insertion ordering then use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[52, 64]]}}}, {"text": "Then you can use TreeMap or pass a comparator to TreeMap", "label": {"api": {"TreeMap": [[17, 23], [49, 55]]}}}, {"text": "See documentation here of LinkedHashMap and TreeMap", "label": {"api": {"LinkedHashMap": [[26, 38]], "TreeMap": [[44, 50]]}}}, {"text": "If you take a look at Throwable class java doc https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html you will see that the getStackTraceElement is removed from the class which is the reason why you are getting this error", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html": [[47, 112]]}}}, {"text": "As mentioned by Demozo, use https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html": [[28, 95]]}}}, {"text": "You cannot apply the @Pattern annotation to something (java.util.UUID) that is not a CharSequence", "label": {"api": {"@Pattern": [[21, 28]], "java.util.UUID": [[55, 68]], "CharSequence": [[85, 96]]}}}, {"text": "From the @Pattern annotation documentation (emphesizes mine)", "label": {"api": {"@Pattern": [[9, 16]]}}}, {"text": "Now, create a validator which implements ConstraintValidator<ValidUuid, UUID> and override the methods performing the validation itself", "label": {"api": {"ConstraintValidator<ValidUuid, UUID>": [[41, 76]]}}}, {"text": "Assuming you have to avoid Streams you can go back to old  java.io.File.listFiles() method", "label": {"api": {"java.io.File.listFiles()": [[59, 82]]}}}, {"text": "You can use a Future in particular the method V get(long timeout, TimeUnit unit)", "label": {"api": {"V get(long timeout, TimeUnit unit)": [[46, 79]]}}}, {"text": "Pattern.split() documentation says", "label": {"api": {"Pattern.split()": [[0, 14]]}}}, {"text": "The JavaDoc of SSLEngine has a note about concurrency at the end of the class description", "label": {"api": {"JavaDoc of SSLEngine": [[4, 23]]}}}, {"text": "First of all, the current value is not a long, but rather a double as per return type of Math.random()", "label": {"api": {"Math.random()": [[89, 101]]}}}, {"text": "You can create an IntStream of the matrix using flatMapToInt then use filter and count as earlier", "label": {"api": {"flatMapToInt": [[48, 59]]}}}, {"text": "This is fine since you collect the Stream into a Map, which is an interface", "label": {"api": {"Map": [[49, 51]]}}}, {"text": "The Spring has no influence to which implementation will be used on the stream collecting, thus you have to specify that HashMap will be used (and not TreeMap for instance...)", "label": {"api": {"Map": [[125, 127], [155, 157]]}}}, {"text": "Here you \"Cannot instantiate the type Map\" - it needs implementation and it's not the Spring's responsibility to provide one", "label": {"api": {"Map": [[38, 40]]}}}, {"text": "The Java Flight Recorder API contains two annotations TransitionFrom and TransitionTo but the documentation is very light on how they should be used", "label": {"api": {"TransitionFrom": [[54, 67]], "TransitionTo": [[73, 84]]}}}, {"text": "You'll want to use Scanner#nextInt() instead", "label": {"api": {"Scanner#nextInt()": [[19, 35]]}}}, {"text": "For a class to be a viable target for a foreach loop, it must implement the built-in Iterable, seen at java.lang.Iterable", "label": {"api": {"java.lang.Iterable": [[103, 120]]}}}, {"text": "In Java, you may create two Condition objects from the single lock, one condition for notify consumers, and another - for notify producers", "label": {"api": {"Condition": [[28, 36]]}}}, {"text": "As from the Java-Doc of the Class (here from Java 7)", "label": {"api": {"Java-Doc of the Class": [[12, 32]]}}}, {"text": "The java.lang.Class object, representing your type is created lazy, within the ClassLoader", "label": {"api": {"ClassLoader": [[79, 89]]}}}, {"text": "Upon referenzing a specific type, the ClassLoader checks whether or not the Class is already loaded and if not, loads it", "label": {"api": {"ClassLoader": [[38, 48]]}}}, {"text": "If the java language had different subtypes for the java.lang.Class, the ClassLoader would have to instantiate the correct subtype of the Class, corresponding to what would be needed", "label": {"api": {"ClassLoader": [[73, 83]]}}}, {"text": "How is the ClassLoader supposed to know which Class-instance is connected to your Type", "label": {"api": {"ClassLoader": [[11, 21]]}}}, {"text": "Normally a class is instantiated through the ClassLoader", "label": {"api": {"ClassLoader": [[45, 55]]}}}, {"text": "Imagine a InvocationHandler for example", "label": {"api": {"InvocationHandler": [[10, 26]]}}}, {"text": "This is because if the scanner reads something that is not an integer, it will not consume the input, as documented", "label": {"api": {"documented": [[105, 114]]}}}, {"text": "You can use Class.isAssignableFrom(Class) to check the hierarchy in inheritance", "label": {"api": {"Class.isAssignableFrom(Class)": [[12, 40]]}}}, {"text": "From the Javadoc of Files.list", "label": {"api": {"Files.list": [[20, 29]]}}}, {"text": "Using Stream can make it simpler and more concise", "label": {"api": {"Stream": [[6, 11]]}}}, {"text": "Instead, you should use ceil", "label": {"api": {"ceil": [[24, 27]]}}}, {"text": "If the instrumented classes have been loaded by the application class loader, you can use Instrumentation.appendToSystemClassLoaderSearch(JarFile) to add your Cheat.jar to the search path, to make the classes available", "label": {"api": {"Instrumentation.appendToSystemClassLoaderSearch(JarFile)": [[90, 145]]}}}, {"text": "If they follow the standard parent delegation model, you can use appendToBootstrapClassLoaderSearch(JarFile) to make your classes available to all these class loaders", "label": {"api": {"appendToBootstrapClassLoaderSearch(JarFile)": [[65, 107]]}}}, {"text": "One way to resolve that would be to use IntStream with the help of flatMapToInt as", "label": {"api": {"flatMapToInt": [[67, 78]]}}}, {"text": "Use a flatMapToInt instead", "label": {"api": {"flatMapToInt": [[6, 17]]}}}, {"text": "Additionally, to handle a default case(return 0 here) use Map.getOrDefault as in", "label": {"api": {"Map.getOrDefault": [[58, 73]]}}}, {"text": "The documentation for getLocalName() says", "label": {"api": {"getLocalName()": [[22, 35]]}}}, {"text": "And the documentation for setAttribute says", "label": {"api": {"setAttribute": [[26, 37]]}}}, {"text": "To set an attribute with a qualified name and namespace URI, use the setAttributeNS method", "label": {"api": {"setAttribute": [[69, 80]], "setAttributeNS": [[69, 82]]}}}, {"text": "So, setting an attribute value will not set the local name unless you explicitly set a namespaced attribute with setAttributeNS", "label": {"api": {"setAttribute": [[113, 124]], "setAttributeNS": [[113, 126]]}}}, {"text": "Use a Swing Timer or (better) a SwingWorker to perform the sorting, in steps, and publish() the interm partial sort results for display", "label": {"api": {"Timer": [[12, 16]], "SwingWorker": [[32, 42]], "publish()": [[82, 90]]}}}, {"text": "The code gets the values of makes and stores them in a Set collection, and then populates the combo box", "label": {"api": {"Set": [[55, 57]]}}}, {"text": "Here are tutorials on using Set collection and using Generics", "label": {"api": {"Set": [[28, 30]]}}}, {"text": "If you use the ProcessBuilder class, you can launch a process with an argument list, not just an argument string", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "The ProcessBuilder class provides a mechanism for that as well", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "As an example, we can get the type of a field using Field.getType()", "label": {"api": {"Field.getType()": [[52, 66]]}}}, {"text": "The problem is that String.CASE_INSENSITIVE_ORDER is actually a Comparator<String>, and the above code will only get us Comparator.class", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[20, 48]]}}}, {"text": "Type and its uses were added in Java 1.5 (along with generics) for this type of situation", "label": {"api": {"and its uses": [[5, 16]]}}}, {"text": "We could instead use the method Field.getGenericType()", "label": {"api": {"Field.getGenericType()": [[32, 53]]}}}, {"text": "In this case, it would return an instance of ParameterizedType, with Comparator.class as its raw type and String.class in its type arguments", "label": {"api": {"ParameterizedType": [[45, 61]]}}}, {"text": "I would suggest to use java.time package to deal with date and time", "label": {"api": {"java.time": [[23, 31]]}}}, {"text": "In a classic WAR, I'd build a servlet that retrieves the remote PDF as InputStream and returns the same PDF as OutputStream, is possible to do so in Apache Camel", "label": {"api": {"InputStream": [[71, 81]], "OutputStream": [[111, 122]]}}}, {"text": "In Java 9, you could use the new method Objects.requireNonNullElse(T,T)", "label": {"api": {"Objects.requireNonNullElse(T,T)": [[40, 70]]}}}]