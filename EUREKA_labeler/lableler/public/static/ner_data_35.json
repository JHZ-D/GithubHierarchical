[{"text": "Another option would be to use the Optional monad", "label": {"api": {"monad": [[44, 48]]}}}, {"text": "You might even use orElseGet instead of that if statement if your objective is to build (and return) a value, instead of executing a side effect", "label": {"api": {"orElseGet": [[19, 27]]}}}, {"text": "can use Objects.equals", "label": {"api": {"Objects.equals": [[8, 21]]}}}, {"text": ".docx with MS WORD or whatever application the system has associated to the file) then you can use the Desktop.getDesktop().open() method", "label": {"api": {"Desktop.getDesktop().open()": [[103, 129]]}}}, {"text": "This method should go hand in hand with the Desktop.isDesktopSupported() method so as to ensure the Desktop Class is supported on the current platform", "label": {"api": {"Desktop.isDesktopSupported()": [[44, 71]]}}}, {"text": "You can use Stream.skip()", "label": {"api": {"Stream.skip()": [[12, 24]]}}}, {"text": "Java 7 String.split", "label": {"api": {"Java 7 String.split": [[0, 18]]}}}, {"text": "By the way, with a JDBC-4.2-compliant driver, you could also retrieve your java.time-type directly, see also a related post here on SO", "label": {"api": {"retrieve your java.time-type directly": [[61, 97]]}}}, {"text": "It contains a META-INF/services/org.eclipse.jetty.http.HttpFieldPreEncoder entry, which, according to the jar service provider interface specification, must contain the name of a class in the same .jar file which implements the interface org.eclipse.jetty.http.HttpFieldPreEncoder", "label": {"api": {"jar service provider interface specification": [[106, 149]]}}}, {"text": "Starting from Java 9, you can use the Scanner.tokens method, which returns a Stream<String> that consists only of, well, tokens, thus ignoring all whitespaces", "label": {"api": {"Scanner.tokens": [[38, 51]]}}}, {"text": "You can do a binary search with a custom comparator to find the insertion point, as long as you maintain the order", "label": {"api": {"binary search": [[13, 25]]}}}, {"text": "Using Character's built-in methods will help you write this condition in a clearer, bug-free way", "label": {"api": {"Character": [[6, 14]]}}}, {"text": "You just have to write your own class extending MetalProgressBarUI (if you're using Metal) and overriding getBox(Rectangle), which is the method that stores the position of the box in the given rectangle", "label": {"api": {"getBox(Rectangle)": [[106, 122]]}}}, {"text": "Use JProgressBar.setUI to apply the UI to your progress bar", "label": {"api": {"JProgressBar.setUI": [[4, 21]]}}}, {"text": "As a quick example, check out the jdk.shell module documentation", "label": {"api": {"jdk.shell module documentation": [[34, 63]]}}}, {"text": "You can also skip the File object altogether by asking the resource directly as an InputStream with ResourceAsStream method", "label": {"api": {"ResourceAsStream": [[100, 115]]}}}, {"text": "java.lang.Object has no a methods declared (2), while the anonymous class returned by the class instance creation expression new Object() { public void a() {} } does (1)", "label": {"api": {"java.lang.Object": [[0, 15]]}}}, {"text": "I assume that you don't want to use java.util.Date or its replacement java.time.LocalDate, probably because it is an assignment", "label": {"api": {"java.time.LocalDate": [[70, 88]]}}}, {"text": "You can read this in Java Api Javadoc", "label": {"api": {"Java Api Javadoc": [[21, 36]]}}}, {"text": "I just saw, that the InputStream (link to Java 11 API) class has a method read(byte[] b) to read the data stream byte wise", "label": {"api": {"link to Java 11 API": [[34, 52]], "link to Java 11 API)": [[34, 53]]}}}, {"text": "Further I saw, that the BufferedInputStream (link to Java 11 API) does not have an own implementation of read(byte[] b)", "label": {"api": {"link to Java 11 API": [[45, 63]], "link to Java 11 API)": [[45, 64]]}}}, {"text": "Use Timeline#setOnFinished method", "label": {"api": {"Timeline#setOnFinished": [[4, 25]]}}}, {"text": "Use a Swing Timer (javax.swing.Timer)", "label": {"api": {"javax.swing.Timer": [[19, 35]]}}}, {"text": "Your custom action listener should perform the action, but set a timestamp or some kind of date value to the current moment", "label": {"api": {"timestamp": [[65, 73]]}}}, {"text": "In parallel, you should have a heartbeat event, which periodically (frequently) runs and compares the current moment with the timestamp set by the last button click", "label": {"api": {"timestamp": [[126, 134]]}}}, {"text": "Iterable is an interface, a special reference type in Java that defines a contract of methods that must be implemented by all classes that implement it", "label": {"api": {"Iterable": [[0, 7]]}}}, {"text": "In the case of Iterable, there is one such method, iterator", "label": {"api": {"Iterable": [[15, 22]], "iterator": [[51, 58]]}}}, {"text": "For this reason, trying to add implements Iterable<Name> to your class without specifying an implementation for the iterator() method results in a compilation error", "label": {"api": {"Iterable": [[42, 49]], "iterator": [[116, 123]]}}}, {"text": "If you store Name objects in the Register class inside a list (or any other Collection data structure) this could be as simple as using the iterator method of the list", "label": {"api": {"iterator": [[140, 147]], "Collection": [[76, 85]]}}}, {"text": "This works because in this case the List class already contains an implementation for the iterator() method, and so it can be called directly", "label": {"api": {"iterator": [[90, 97]]}}}, {"text": "So, I switched to using Robot Class and it worked", "label": {"api": {"Robot Class": [[24, 34]]}}}, {"text": "Use a Swing Timer to drive the animation", "label": {"api": {"Timer": [[12, 16]]}}}, {"text": "You can use Java's java.awt.Robot class to control mouse and keyboard on the screen", "label": {"api": {"java.awt.Robot": [[19, 32]]}}}, {"text": "This is done by using @ (see Introduction to FXML)", "label": {"api": {"Introduction to FXML": [[29, 48]]}}}, {"text": "Java has java.util.ServiceLoader for exactly this sort of thing", "label": {"api": {"java.util.ServiceLoader": [[9, 31]]}}}, {"text": "You should use DateTimeFormatter and the new classes in java.time instead of the old SimpleDateFormat api", "label": {"api": {"DateTimeFormatter": [[15, 31]], "java.time": [[56, 64]]}}}, {"text": "map of IntStream can only map an int value to another int value", "label": {"api": {"map": [[0, 2], [26, 28]]}}}, {"text": "It accepts an IntUnaryOperator (which accepts an int and returns an int) as the mapper function, and returns an IntStream", "label": {"api": {"map": [[80, 82]]}}}, {"text": "On the other hand, mapToObj allows you to map an int value to any reference type, and thus transform the IntStream to a Stream<SomeReferenceType>", "label": {"api": {"mapToObj": [[19, 26]], "map": [[19, 21], [42, 44]]}}}, {"text": "extends U> (which accepts an int and returns a reference type) as the mapper function, and returns a Stream<U>", "label": {"api": {"map": [[70, 72]]}}}, {"text": "Use mapToObj instead", "label": {"api": {"mapToObj": [[4, 11]]}}}, {"text": "Alternatively, you could use IntStream.boxed as", "label": {"api": {"IntStream.boxed": [[29, 43]]}}}, {"text": "Yes, boxed() uses Integer.valueOf which can retrieve some Integer instances from a cache", "label": {"api": {"boxed()": [[5, 11]], "Integer.valueOf": [[18, 32]]}}}, {"text": "So you should either use the version with boxed() (preferably), or use Integer.valueOf instead of new Integer()", "label": {"api": {"boxed()": [[42, 48]], "Integer.valueOf": [[71, 85]]}}}, {"text": "Note that boxed() is in fact shorthand for mapToObj(Integer::valueOf)", "label": {"api": {"boxed()": [[10, 16]]}}}, {"text": "All you need to do is just declare the set and use the addAll()", "label": {"api": {"addAll()": [[55, 62]]}}}, {"text": "Look into BinaryOperator which represents an operation upon two operands of the same type, producing a result of the same type as the operands", "label": {"api": {"BinaryOperator": [[10, 23]]}}}, {"text": "BiFunction is also another option as it represents a function that accepts two arguments and produces a result", "label": {"api": {"BiFunction": [[0, 9]]}}}, {"text": "Because org.bson.Document implements java.util.Map, you can look at How to convert XML to java.util.Map and vice versa as a potential solution", "label": {"api": {"java.util.Map": [[37, 49], [90, 102]]}}}, {"text": "Use @ConvertGroup from Bean Validation 1.1 (JSR-349)", "label": {"api": {"@ConvertGroup": [[4, 16]]}}}, {"text": "Note that this might not be exactly the same in models where the tasks are backed by reusable worker threads, such as when using an ExecutorService to wait for a result, and using CompletableFuture.join() to block until the result is available", "label": {"api": {"CompletableFuture.join()": [[180, 203]]}}}, {"text": "Java's Stack is a very old class, introduced back in JDK 1.0", "label": {"api": {"Stack": [[7, 11]]}}}, {"text": "It extends Vector, and all it's data manipulation methods are synchronized, creating a very sizeable performance overhead", "label": {"api": {"Vector": [[11, 16]]}}}, {"text": "The modern ArrayDeque provides the same functionality without the synchronization overhead", "label": {"api": {"ArrayDeque": [[11, 20]]}}}, {"text": "The compiler will be perfectly fine with any interface meeting the requirements", "label": {"api": {"the requirements": [[63, 78]]}}}, {"text": "You can take a look at how Hive does it in HeapMemoryMonitor class which calls MemoryPoolMXBean.setUsageThreshold() method after multiple checks are done", "label": {"api": {"MemoryPoolMXBean.setUsageThreshold()": [[79, 114]]}}}, {"text": "Looking at its javadoc shows that this method exists, but since Java 9", "label": {"api": {"its javadoc": [[11, 21]]}}}, {"text": "This uses Map.computeIfAbsent, which either returns the set mapped to that color or puts an empty LinkedHashSet into the map if there's nothing mapped to that color yet, then adds the apple to the set", "label": {"api": {"Map.computeIfAbsent": [[10, 28]]}}}, {"text": "With java 11, you can use the new method String.repeat", "label": {"api": {"String.repeat": [[41, 53]]}}}, {"text": "Get the model from the list itself (via getModel())", "label": {"api": {"getModel()": [[40, 49]]}}}, {"text": "Remove all elements from the model (vis removeAllElements())", "label": {"api": {"removeAllElements()": [[40, 58]]}}}, {"text": "Basically, instead of using a HashSet you now want to use a HashMap to count the number of occurrences of each string", "label": {"api": {"HashSet": [[30, 36]], "HashMap": [[60, 66]]}}}, {"text": "A generic utility of what you're trying to acheieve in both the questions would be using Collections.frequency as", "label": {"api": {"Collections.frequency": [[89, 109]]}}}, {"text": "This would be an O(n^2) approach since its using Collections.frequency which iterates over the entire collection again to get the frequency", "label": {"api": {"Collections.frequency": [[49, 69]]}}}, {"text": "You can use  Map#computeIfAbsent to achieve what you are trying to do", "label": {"api": {"Map#computeIfAbsent": [[13, 31]]}}}, {"text": "You could possibly use Optional.ofNullable(since lack of key in a Map would return null) along with Optional.orElseGet (to make the service call when the value isn't present in the Map) in your Stream.map operation as", "label": {"api": {"Optional.ofNullable": [[23, 41]], "Optional.orElseGet": [[100, 117]]}}}, {"text": "If you want to put in the cache as well, you could simply use Map.putIfAbsent to put if not present as", "label": {"api": {"Map.putIfAbsent": [[62, 76]]}}}, {"text": "Although JDBC version 4.2 supports JDK version 1.8.x, the new (for today) JDBC version 4.3 supports JDK version 9", "label": {"api": {"supports": [[26, 33], [91, 98]]}}}, {"text": "So, we wait new version of the JDBC, which supports JDK 11, then wait until MySQL supports new version of JDBC driver", "label": {"api": {"supports": [[43, 50], [82, 89]]}}}, {"text": "Slash symbol is a file separator", "label": {"api": {"file separator": [[18, 31]]}}}, {"text": "Normally what you try to accomplish is done with Thread.join()", "label": {"api": {"Thread.join()": [[49, 61]]}}}, {"text": "compareTo gets Object because you implement Comparable, rather than generic Comparable<Student>", "label": {"api": {"Comparable<Student>": [[76, 94]]}}}, {"text": "As per Buffer.position()", "label": {"api": {"Buffer.position()": [[7, 23]]}}}, {"text": "This theoretically can happen if you invoke the three-argument newInstance method with name of a factory class which itself attempts to call newInstance", "label": {"api": {"three-argument newInstance method": [[48, 80]]}}}, {"text": "You are able to use 2 Streams using Stream::reduce to get a point with a minimum and a point with a maximum", "label": {"api": {"Stream::reduce": [[36, 49]]}}}, {"text": "Then, statistics for both x and y are merged into a List by means of the JDK 9 List.of factory method that accepts two elements", "label": {"api": {"List.of": [[79, 85]]}}}, {"text": "You could use one of provided implementations of a java.util.concurrent.BlockingQueue interface instead of writing your own code e.g", "label": {"api": {"java.util.concurrent.BlockingQueue": [[51, 84]]}}}, {"text": "Use a Timer filed", "label": {"api": {"Timer": [[6, 10]]}}}, {"text": "A Predicate<T> which you're currently using represents a predicate (boolean-valued function) of one argument", "label": {"api": {"Predicate<T>": [[2, 13]]}}}, {"text": "You're looking for a BiPredicate<T,U> which essentially represents a predicate (boolean-valued function) of two arguments", "label": {"api": {"BiPredicate<T,U>": [[21, 36]]}}}, {"text": "I'm writing a Swing application and trying to make a menu where each menu item has its own action", "label": {"api": {"menu item": [[69, 77]], "action": [[91, 96]]}}}, {"text": "There is a constructor https://docs.oracle.com/javase/8/docs/api/org/xml/sax/InputSource.html#InputSource-java.lang.String- that takes a system id e.g", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/org/xml/sax/InputSource.html#InputSource-java.lang.String-": [[23, 122]]}}}, {"text": "Use a RowFilter", "label": {"api": {"RowFilter": [[6, 14]]}}}, {"text": "You install a RowFilter on a TableRowSorter", "label": {"api": {"RowFilter": [[14, 22]], "TableRowSorter": [[29, 42]]}}}, {"text": "There is nothing in Liberty Batch or the spec to prevent you from starting a new job instance via the JobOperator start() method, or, using the Liberty Batch REST API, via a POST /ibm/api/batch/jobinstances/ because some similar job instance already exists", "label": {"api": {"start()": [[114, 120]]}}}, {"text": "It seems odd that there's nothing returned from this operation yet streamResult now has, for lack of a better word, data", "label": {"api": {"operation": [[53, 61]]}}}, {"text": "use skip(1) on the stream to discard the first element", "label": {"api": {"skip(1)": [[4, 10]]}}}, {"text": "groupingBy collector with counting() as downstream", "label": {"api": {"groupingBy": [[0, 9]], "counting()": [[26, 35]]}}}, {"text": "The Stream.anyMatch method takes a Predicate, not a BiPredicate", "label": {"api": {"Stream.anyMatch": [[4, 18]]}}}, {"text": "In the first case (queuing) this can be easily solved by using an ExecutorService configured to have no more than n threads", "label": {"api": {"ExecutorService": [[66, 80]]}}}, {"text": "Read the javadoc of Iterator", "label": {"api": {"javadoc of Iterator": [[9, 27]]}}}, {"text": "by using Class.getResourceAsStream()", "label": {"api": {"Class.getResourceAsStream()": [[9, 35]]}}}, {"text": "Replace java.util.HashMap class with the java.util.Map interface", "label": {"api": {"java.util.Map": [[41, 53]]}}}, {"text": "One way to do it would be to use StringTokenizer", "label": {"api": {"StringTokenizer": [[33, 47]]}}}, {"text": "You can use Collection.stream with flatMap as", "label": {"api": {"Collection.stream": [[12, 28]]}}}, {"text": "Because List<E> is defined in a generic way, so too must its implementors be, and thus ArrayList<E> uses the same generic type declared by the interface", "label": {"api": {"List<E>": [[8, 14], [92, 98]], "ArrayList<E>": [[87, 98]]}}}, {"text": "If you are interested to implement your own mechanism, you can take a look at UUID which can help you generate unique keys for your Firebase database nodes without having to use the push() method", "label": {"api": {"UUID": [[78, 81]]}}}, {"text": "To check that, just try to bind() your ServerSocket on that port", "label": {"api": {"bind()": [[27, 32]]}}}, {"text": "Then you can get the assigned port with getLocalPort()", "label": {"api": {"getLocalPort()": [[40, 53]]}}}, {"text": "This also influences, the Provider#getService(type, algorithm) call, rendering it useless in case you want to check for \"AES/GCM/NoPadding\", i.e", "label": {"api": {"Provider#getService(type, algorithm)": [[26, 61]]}}}, {"text": "If you want you can change this to use Streams, which might be more efficient and shorter", "label": {"api": {"Streams": [[39, 45]]}}}, {"text": "Your run method takes a Runnable instance, and that explains why run(new R()) works with the R implementation", "label": {"api": {"Runnable": [[24, 31]]}}}, {"text": "It can fit the signature of a Supplier<Runnable> (or similar functional interfaces), but R::new cannot be used as a Runnable implemented with your R class", "label": {"api": {"Runnable": [[39, 46], [116, 123]]}}}, {"text": "Because the compiler can make a Runnable out of the constructor call, and that would be equivalent to this lambda expression version", "label": {"api": {"Runnable": [[32, 39]]}}}, {"text": "But, as you can notice, the Runnable created with R::new does just call new R() in its run method body", "label": {"api": {"Runnable": [[28, 35]]}}}, {"text": "I would consider using IdentityHashMap", "label": {"api": {"IdentityHashMap": [[23, 37]]}}}, {"text": "You should use Map.computeIfAbsent", "label": {"api": {"Map.computeIfAbsent": [[15, 33]]}}}, {"text": "Map.computeIfAbsent is equivalent to this code", "label": {"api": {"Map.computeIfAbsent": [[0, 18]]}}}, {"text": "via ZipOutputStream) is not an option", "label": {"api": {"ZipOutputStream": [[4, 18]]}}}, {"text": "As per Using Customized Type Mappings you should create a User class by implementing SQLData interface", "label": {"api": {"SQLData": [[85, 91]]}}}, {"text": "and then use Connection.setTypeMap() to setup the mapping for new User type", "label": {"api": {"Connection.setTypeMap()": [[13, 35]]}}}, {"text": "Instead they are using a kind of an error flag which I can read invoking the method boolean checkError() (API link)", "label": {"api": {"API link": [[106, 113]]}}}, {"text": "Assuming function.getList() returns String use the JTextField.setText() and revalidate component", "label": {"api": {"JTextField.setText()": [[51, 70]]}}}, {"text": "You could redirect System.out by calling System.setOut() with your own PrintWriter backed by StringWriter but please don't do it, it's a hack", "label": {"api": {"System.setOut()": [[41, 55]]}}}, {"text": "Instead of using JOptionPane.showMessageDialog() to display the predefined dialog create a new JDialog object yourself and prevent user closing with setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE)", "label": {"api": {"JDialog": [[95, 101], [174, 180]], "setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE)": [[149, 201]]}}}, {"text": "You are trying to create  Set with int primitives, (Arrays.stream \"returns a sequential IntStream with the specified Array as its source\") and a Set<int> is not allowed", "label": {"api": {"Arrays.stream": [[52, 64]]}}}, {"text": "invoke will always return a new Object", "label": {"api": {"invoke": [[0, 5]]}}}, {"text": "during wrapping, it does not use Boolean.valueOf(boolean)", "label": {"api": {"Boolean.valueOf(boolean)": [[33, 56]]}}}, {"text": "The usual way to iterate a NamingEnumeration is with hasMore() and next()", "label": {"api": {"hasMore()": [[53, 61]], "next()": [[67, 72]], "Enumeration": [[33, 43]]}}}, {"text": "The \"enhanced for statement (sometimes called the \"for-each loop\" statement)\" cannot be used for them because they implement Enumeration instead of the Iterable-interface", "label": {"api": {"Enumeration": [[125, 135]], "Iterable": [[152, 159]]}}}, {"text": "The reason for this is mostly historic, NamingEnumeration exists since Java 1.3, Iterable since Java 1.5", "label": {"api": {"Enumeration": [[46, 56]], "Iterable": [[81, 88]]}}}, {"text": "You can use this overload of reduce", "label": {"api": {"reduce": [[29, 34]]}}}, {"text": "Since FileUtils.listFilesAndDirs(directory, TrueFileFilter.TRUE, TrueFileFilter.TRUE) will recursively visit all sub directories in directory you most likely want to replace it with Files.walk(Path, FileVisitOption...) method", "label": {"api": {"Files.walk(Path, FileVisitOption...)": [[182, 217]]}}}, {"text": "Note that as of JDK 11, you can also check that a String is blank (either empty or contains only whitespace) using the String::isBlank", "label": {"api": {"String::isBlank": [[119, 133]]}}}, {"text": "You can leverage the fact that ConcurrentHashMap.compute executes atomically", "label": {"api": {"ConcurrentHashMap.compute executes atomically": [[31, 75]]}}}, {"text": "Is there already in the JDK or another lib an enum like the month one or something similar to do that easily", "label": {"api": {"the month one": [[56, 68]]}}}, {"text": "Chain the predicates according to the conditions using Predicate::and returning a new Predicate", "label": {"api": {"Predicate::and": [[55, 68]]}}}, {"text": "Reduce the entries of a map to a new Predicate<FooBar> using chaining these Predicates with Predicate::and, for which their Supplier<Boolean> returns true (the condition is valid)", "label": {"api": {"Predicate::and": [[92, 105]]}}}, {"text": "The apiNote for the Files.walk explicitly reads this", "label": {"api": {"Files.walk": [[20, 29]]}}}, {"text": "So y[0] where y is a SpecialList instance just won't work", "label": {"api": {"List": [[28, 31]]}}}, {"text": "If it could work, List (or at least ArrayList or other implementions where direct addressing is cheap) would probably have that feature", "label": {"api": {"List": [[18, 21], [41, 44]], "ArrayList": [[36, 44]]}}}, {"text": "(Which is a good thing or a bad thing depending on your point of view...) Instead, you'll have to provide get and set methods or similar, just like List does", "label": {"api": {"List": [[148, 151]], "get": [[106, 108]], "set": [[114, 116]]}}}, {"text": "This FileNameMap is internally used by method URLConnection.guessContentTypeFromName(String)", "label": {"api": {"URLConnection.guessContentTypeFromName(String)": [[46, 91]]}}}, {"text": "A more robust approach would involve using the built in Java enumeration for days of the week", "label": {"api": {"Java enumeration": [[56, 71]]}}}, {"text": "As per Matcher.groupCount() javadoc", "label": {"api": {"Matcher.groupCount()": [[7, 26]]}}}, {"text": "You shall further use Stream.flatMap as", "label": {"api": {"Stream.flatMap": [[22, 35]]}}}, {"text": "I would recommend to use the Executors#cachedThreadPool if the size of clients isn't defined", "label": {"api": {"Executors#cachedThreadPool": [[29, 54]]}}}, {"text": "So if you aren't sure that you exactly for example need 5 threads you shouldn't use the Executors#fixedThreadPool", "label": {"api": {"Executors#fixedThreadPool": [[88, 112]]}}}, {"text": "You can use DateTimeFormatter to parse into a LocalDateTime", "label": {"api": {"DateTimeFormatter": [[12, 28]], "LocalDateTime": [[46, 58]]}}}, {"text": "You then zone that LocalDateTime to UTC before converting to the Calcutta zone with ZonedDateTime.withZoneSameInstant", "label": {"api": {"LocalDateTime": [[19, 31]], "ZonedDateTime.withZoneSameInstant": [[84, 116]]}}}, {"text": "there is IntPredicate that you have to use when working with int and Predicate that you have to use when working with Object", "label": {"api": {"IntPredicate": [[9, 20]]}}}, {"text": "On way to write your filter function would be to use OptionalInt and IntPredicate", "label": {"api": {"IntPredicate": [[69, 80]], "OptionalInt": [[53, 63]]}}}, {"text": "It could be a (int v) -> v > 5 meaning that it's an instance of IntPredicate and things will go smoothly here", "label": {"api": {"IntPredicate": [[64, 75]]}}}, {"text": "You can get it from System.lineSeparator() instead of hardcoding", "label": {"api": {"System.lineSeparator()": [[20, 41]]}}}, {"text": "or use PrintWriter.println(int) which will output the line separator after the value", "label": {"api": {"PrintWriter.println(int)": [[7, 30]]}}}, {"text": "In your case Response is an abstract class", "label": {"api": {"Response": [[13, 20]]}}}, {"text": "It also provides a concrete instance method getHeaders() which the designers think should probably always be the same (again after Java 8 this could have been a default interface method)", "label": {"api": {"getHeaders()": [[44, 55]]}}}, {"text": "There are a few other classes which probably exist for similar reasons, as support classes for the API", "label": {"api": {"few other classes": [[12, 28]]}}}, {"text": "As you see, you can recover the generated PK value using PreparedStatement.getGeneratedKeys()", "label": {"api": {"PreparedStatement.getGeneratedKeys()": [[57, 92]]}}}, {"text": "You should use the Integer#parseInt method", "label": {"api": {"Integer#parseInt": [[19, 34]]}}}, {"text": "The Integer#parseInt takes a String and converts it into the primitive int if it is a valid number", "label": {"api": {"Integer#parseInt": [[4, 19]]}}}, {"text": "If the number isn't valid a NumberFormatException will be thrown", "label": {"api": {"NumberFormatException": [[28, 48]]}}}, {"text": "IntStream#map consumes an IntUnaryOperator which represents an operation on a single int-valued operand that produces an int-valued result thus the result is an IntStream, however IntStream does not have the collect overload you're attempt to use, which means you have a couple of options; i.e", "label": {"api": {"IntStream#map": [[0, 12]]}}}, {"text": "either use IntStream#collect", "label": {"api": {"IntStream#collect": [[11, 27]]}}}, {"text": "The Stream.collect expects a BiConsumer as an argument, which has a accept method with voidreturn type", "label": {"api": {"Stream.collect": [[4, 17]]}}}, {"text": "You could rely on the Character class and its isDigit() method for that", "label": {"api": {"Character": [[22, 30]]}}}, {"text": "This uses Arrays.setAll to accomplish the task", "label": {"api": {"Arrays.setAll": [[10, 22]]}}}, {"text": "This happens because the read() method of the FilterInputStream (DataInput is his son) reads just the next avaliable byte", "label": {"api": {"just the next avaliable byte": [[93, 120]]}}}, {"text": "Unfortunately there is no dedicated function defined on Java's Charset to determine if it contains special characters", "label": {"api": {"Charset": [[63, 69]]}}}, {"text": "This is a Kotlin solution, so if you have a Java Charset some casting might be necessary", "label": {"api": {"Charset": [[49, 55]]}}}, {"text": "You could use Collectors.filtering", "label": {"api": {"Collectors.filtering": [[14, 33]]}}}, {"text": "I think Collectors.filtering fits your exact use case", "label": {"api": {"Collectors.filtering": [[8, 27]]}}}, {"text": "Note that in this case, using Collectors.filtering as a downstream collector is not the same as using Stream.filter before collecting", "label": {"api": {"Collectors.filtering": [[30, 49]]}}}, {"text": "From Collectors.filtering docs", "label": {"api": {"Collectors.filtering": [[5, 24]]}}}, {"text": "I believe the forEach approach along with Map.merge would be much simpler and appropriate for the current use case", "label": {"api": {"Map.merge": [[42, 50]]}}}, {"text": "Map.merge also uses BiFunction (parent of BinaryOperator as used in toMap), hence you could correlate the merge function here to your existing desired functionality easily", "label": {"api": {"Map.merge": [[0, 8]]}}}, {"text": "You don't want to split but to use a Matcher", "label": {"api": {"Matcher": [[37, 43]]}}}, {"text": "Shouldn't need a library assuming you aren't attempting anything fancy, https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html should get you up and going in ~15 min", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html": [[72, 137]]}}}, {"text": "Use the Character class and its various method", "label": {"api": {"Character": [[8, 16]]}}}, {"text": "Character.isLetter should do the job (isAlphabetic(int) works only for code point)", "label": {"api": {"Character": [[0, 8]]}}}, {"text": "See String.join() and String.split() for more info", "label": {"api": {"String.join()": [[4, 16]], "String.split()": [[22, 35]]}}}, {"text": "With such a large number of entries and threads, you can help the implementation perform better by telling it the expected sizing of such via a constructor", "label": {"api": {"constructor": [[144, 154]]}}}, {"text": "If I had access to the raw SSLSocket then I could configure it to require a client certificate and then call startHandshake() to force renegotiation", "label": {"api": {"startHandshake()": [[109, 124]]}}}, {"text": "An alternative to StringWriter would be CharArrayWriter, which has a writeTo​(Writer out), which eliminates the need to implement a manual copying loop and might be even more efficient", "label": {"api": {"CharArrayWriter": [[40, 54]], "writeTo​(Writer out)": [[69, 88]]}}}, {"text": "obtainedList is a List<String>, result is a List<Integer> they are never equals", "label": {"api": {"equals": [[73, 78]]}}}, {"text": "The method equals of java.util.List does the following", "label": {"api": {"equals": [[11, 16]]}}}, {"text": "e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order", "label": {"api": {"equals": [[3, 8]]}}}, {"text": "This definition ensures that the equals method works properly across different implementations of the List interface", "label": {"api": {"equals": [[33, 38]]}}}, {"text": "In your case the String \"5\" doesn't equals the Integer 5, so the test fails", "label": {"api": {"equals": [[36, 41]]}}}, {"text": "Convert to Instant and compare using Instant.isAfter() method", "label": {"api": {"Instant.isAfter()": [[37, 53]]}}}, {"text": "The problem is that reverse() changes the StringBuilder itself", "label": {"api": {"reverse()": [[20, 28]]}}}, {"text": "Note that the if(sb.length == 0) is not necessary, as if it is empty, sb.reverse().toString().equals(x) will still return true", "label": {"api": {"reverse()": [[73, 81]]}}}, {"text": "Use max or min instead", "label": {"api": {"max": [[4, 6]], "min": [[11, 13]]}}}, {"text": "java.util.ArrayList collection is the easiest choice, it will store all new objects and dynamical adjust size", "label": {"api": {"java.util.ArrayList": [[0, 18]]}}}, {"text": "ArrayList has method set, which you should use in your case", "label": {"api": {"set": [[21, 23]]}}}, {"text": "According Java documentation of ArrayList (ArrayList), you should use \"add\" function in order to insert a new element to the ArrayList, which means your code should look something like this", "label": {"api": {"ArrayList": [[32, 40], [43, 51], [125, 133]]}}}, {"text": "I am assuming that the type of the variable \"animals\" is ArrayList when T is an interface of abstract class of Animal", "label": {"api": {"ArrayList": [[57, 65]]}}}, {"text": "Now, if your intention is just to add new objects to the ArrayList without any other logic (like removing duplicates), you would like to just check the type of the Object and decide what class you should create and add the ArrayList", "label": {"api": {"ArrayList": [[57, 65], [223, 231]]}}}, {"text": "Either use java.util.BigInteger or switch from calculating value to approximating it e.g", "label": {"api": {"java.util.BigInteger": [[11, 30]]}}}, {"text": "If it might change while you are reading it, you must make chain a thread-safe collection (like ConcurrentLinkedDeque or CopyOnWriteArrayList), or implement thread safety yourself, which is probably more complex than you intended the code to be", "label": {"api": {"ConcurrentLinkedDeque": [[96, 116]], "CopyOnWriteArrayList": [[121, 140]]}}}, {"text": "You can simply use XPath to extract the elements you want from the xml", "label": {"api": {"XPath": [[19, 23]]}}}, {"text": "You can use CSS styling to apply a style to an element when :focused", "label": {"api": {"CSS styling": [[12, 22]]}}}, {"text": "Use String formatter - define a \"template\" with the fixed structure of the string, and the format specifier", "label": {"api": {"String formatter": [[4, 19]]}}}, {"text": "One way around the problem would be to use a ReentrantLock with a fair ordering policy instead of using a synchronized block", "label": {"api": {"ReentrantLock": [[45, 57]], "fair ordering policy": [[66, 85]]}}}, {"text": "The usual convention in Java is to write bytes using OutputStream", "label": {"api": {"OutputStream": [[53, 64]]}}}, {"text": "If you plan to use sockets you can check Socket.getOutputStream() method", "label": {"api": {"OutputStream": [[51, 62]], "Socket.getOutputStream()": [[41, 64]]}}}, {"text": "Closing the returned OutputStream will close the associated socket", "label": {"api": {"OutputStream": [[21, 32]]}}}, {"text": "More information about OutputStreamWriter can be found in the Javadoc", "label": {"api": {"can be found in the Javadoc": [[42, 68]]}}}, {"text": "The CellEditor interface does not mention focus handling for stopCellEditing", "label": {"api": {"stopCellEditing": [[61, 75]]}}}, {"text": "You might want to look into IP multicasting using MulticastSocket, but it requires the network to support it", "label": {"api": {"MulticastSocket": [[50, 64]]}}}, {"text": "A Collection is a good way to solve this problem", "label": {"api": {"Collection": [[2, 11]]}}}, {"text": "nextLine() returns a String, as said in the javadoc of Scanner", "label": {"api": {"javadoc of Scanner": [[44, 61]]}}}, {"text": "Also, Runnable seems like a more appropriate interface than Callable, since you are not returning a value", "label": {"api": {"Runnable": [[6, 13]], "Callable": [[60, 67]]}}}, {"text": "Call revalidate() after you add all the widgets to recalculate the layout of the container (in your case a JFrame)", "label": {"api": {"revalidate()": [[5, 16]]}}}, {"text": "see ProcessBuilder Javadoc", "label": {"api": {"ProcessBuilder Javadoc": [[4, 25]]}}}, {"text": "It's in the documentation for ConcurrentHashMap", "label": {"api": {"documentation for ConcurrentHashMap": [[12, 46]]}}}, {"text": "As for other ConcurrentMaps, the only other implementation ConcurrentSkipListMap, does not allow null either", "label": {"api": {"the only other implementation ConcurrentSkipListMap, does not allow null either": [[29, 107]]}}}, {"text": "By the way, I think that there is no correct answer since the only constructor of Stack takes no parameters, so there is no way to initialize the stack with a size of 50", "label": {"api": {"only constructor": [[62, 77]]}}}, {"text": "If you want write your own the security layer in your servlet application, you can create a Filter class that will read the token from the Authorization request header, make an HTTP request to the token introspection endpoint to validate the token and then it can call the user info endpoint (the userInfoUri URL from your Spring Boot config) and get information about the user making the processed request", "label": {"api": {"Filter": [[92, 97]]}}}, {"text": "You can give a try to java.nio in order to append content to an existing file (if you are using Java 7 or above), maybe you can do something like this", "label": {"api": {"java.nio": [[22, 29]]}}}, {"text": "The power function is provided by the Math.pow() method", "label": {"api": {"Math.pow()": [[38, 47]]}}}, {"text": "You can store colors and weights in a LinkedHashMap but only insert the values that have a weight assigned", "label": {"api": {"LinkedHashMap": [[38, 50]]}}}, {"text": "As of Java 8 this can be accomplished seamlessly with Collectors.groupingBy", "label": {"api": {"Collectors.groupingBy": [[54, 74]]}}}, {"text": "One solution would be to declare myFunc as UnaryOperator<Float>", "label": {"api": {"UnaryOperator<Float>": [[43, 62]]}}}, {"text": "I do not think this is a strange requirement for function merging streams, because standard Map.merge does exactly that", "label": {"api": {"Map.merge": [[92, 100]]}}}, {"text": "For example by using asynchronous file or socket channels you can read from multiple files/sockets at once", "label": {"api": {"file": [[34, 37], [85, 88]], "socket": [[42, 47], [91, 96]]}}}, {"text": "the problem can be reproduced only by repeatedly calling APIs using an AsyncResponse; calling other endpoints does not trigger this behaviour", "label": {"api": {"AsyncResponse": [[71, 83]]}}}, {"text": "Add thenComparing() to your comparator chain to create a secondary sort order", "label": {"api": {"thenComparing()": [[4, 18]]}}}, {"text": "So if AsyncContext::complete closes the response and I need to write the response within the asynchronous context, how do I implement a multi-step response in which some steps are blocking with non-blocking sections in-between them", "label": {"api": {"AsyncContext::complete": [[6, 27]]}}}, {"text": "One possible data structure for this is ConcurrentLinked Queue", "label": {"api": {"ConcurrentLinked Queue": [[40, 61]]}}}, {"text": "You can use Modifier#isStatic for that, for example", "label": {"api": {"Modifier#isStatic": [[12, 28]]}}}, {"text": "The HashSet.add method will not add a value if it is already present", "label": {"api": {"HashSet.add method": [[4, 21]]}}}, {"text": "You seem to be looking for the sum operation and not count which would need you to convert the Stream to IntStream mostly", "label": {"api": {"IntStream": [[105, 113]]}}}, {"text": "One way to go is with JOptionPane.showInputDialog", "label": {"api": {"JOptionPane.showInputDialog": [[22, 48]]}}}, {"text": "The trick is to use java.time.format.FormatStyle.LONG", "label": {"api": {"java.time.format.FormatStyle.LONG": [[20, 52]]}}}, {"text": "If you didn't return null sentinels values, and instead used Optionals, you could do", "label": {"api": {"Optional": [[61, 68]]}}}, {"text": "I think you can use the API substring(int startIndex, int endIndex)", "label": {"api": {"substring": [[28, 36]]}}}, {"text": "For more detail, you can refer substring", "label": {"api": {"substring": [[31, 39]]}}}, {"text": "Using Javas Map.merge, but ignoring duplicates in the value and also just concatenating the values", "label": {"api": {"Map.merge": [[12, 20]]}}}, {"text": "From the Javadoc of mapToLong", "label": {"api": {"Javadoc of mapToLong": [[9, 28]]}}}, {"text": "You can use Field.get() to obtain the field value and then cast it to List", "label": {"api": {"Field.get()": [[12, 22]]}}}, {"text": "There is a method called isEmpty() in the interface List", "label": {"api": {"isEmpty()": [[25, 33]]}}}, {"text": "Actually I am using the PreparedStatement object to create the batches, but without the \"insert only if new row\" logic", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "Integer.valueOf(String) is used to parse a number literal from text, not to evaluate arbitrary expression", "label": {"api": {"Integer.valueOf(String)": [[0, 22]]}}}, {"text": "The Stream API is built around the Spliterator interface which can provide characteristics of the source data, e.g", "label": {"api": {"Spliterator": [[35, 45]]}}}, {"text": "Of course, since Java 8, you could acquire a Spliterator yourself, to examine these characteristics, but that would change your loop solution to a non-trivial thing and also imply repeating the work already done with the Stream API", "label": {"api": {"Spliterator": [[45, 55]]}}}, {"text": "There’s also another interesting difference between Spliterator based Stream solutions and conventional loops, using an Iterator when iterating over something other than an array", "label": {"api": {"Spliterator": [[52, 62]]}}}, {"text": "In contrast, the Spliterator has a single traversal method, boolean tryAdvance(Consumer<", "label": {"api": {"Spliterator": [[17, 27]]}}}, {"text": "I think you are looking for List.containsAll()", "label": {"api": {"List.containsAll()": [[28, 45]]}}}, {"text": "List.equals() only returns true if both Lists contain the same elements in the same order", "label": {"api": {"List.equals()": [[0, 12]]}}}, {"text": "Thus I suggest looking into lambdas, based on Function, see here", "label": {"api": {"Function": [[46, 53]]}}}, {"text": "You can use lambdas here as well if you'll define your interface as Functional Interface", "label": {"api": {"Functional Interface": [[68, 87]]}}}, {"text": "In (Java) reactive programming, what is the difference between a Future<T> and a (Project Reactor) Mono<T>", "label": {"api": {"Future<T>": [[65, 73]]}}}, {"text": "If you need to change arrays as much as it seems, you're better off using a List or Map", "label": {"api": {"List": [[76, 79]], "Map": [[84, 86]]}}}, {"text": "I would suggest using a HashMap if you want to easily link one object to another", "label": {"api": {"Map": [[28, 30]], "HashMap": [[24, 30]]}}}, {"text": "HashMaps are similar in concept to associative arrays from other languages, where you have a key -> value relationship", "label": {"api": {"Map": [[4, 6]], "HashMap": [[0, 6]]}}}, {"text": "And of course, there is also difference regarding the interface you intend to \"use\", be it a Function or Supplier (that second method reference example would be a supplier for example)", "label": {"api": {"Function": [[93, 100]], "Supplier": [[105, 112]]}}}, {"text": "You should be able to catch the java.lang.UnsatisfiedLinkError exception thrown by the java.lang.System.load(String) method", "label": {"api": {"java.lang.System.load(String)": [[87, 115]]}}}, {"text": "Socket is a client socket for connecting to a server", "label": {"api": {"Socket": [[0, 5]]}}}, {"text": "To open a listening socket to accept clients, you need to use ServerSocket instead, which will open a port if it is not already open, and will fail if the port is already in use", "label": {"api": {"Socket": [[68, 73]], "ServerSocket": [[62, 73]]}}}, {"text": "Executors.newCachedThreadPool() which experiences a thread spike", "label": {"api": {"Executors.newCachedThreadPool()": [[0, 30]]}}}, {"text": "In the Java standard library, a LinkedHashSet is the same as HashSet but with predictable iteration order (insertion-order)", "label": {"api": {"LinkedHashSet": [[32, 44]], "HashSet": [[38, 44], [61, 67]]}}}, {"text": "I need an IdentityHashSet (which uses object-identity or reference-equality, instead of object-equality) with predictable iteration order (insertion-order)", "label": {"api": {"HashSet": [[18, 24]]}}}, {"text": "While there is no IdentityHashSet in Java's standard library, you can easily create one using the available IdentityHashMap with the following statement", "label": {"api": {"HashSet": [[26, 32]], "IdentityHashMap": [[108, 122]], "HashMap": [[116, 122]]}}}, {"text": "This is almost the same implementation used in Guava's Sets.newIdentityHashSet(); but this has the unspecified, generally chaotic ordering of HashMap keys (and HashSet elements)", "label": {"api": {"HashSet": [[71, 77], [160, 166]], "HashMap": [[142, 148]]}}}, {"text": "My searches for an implementation of an IdentityLinkedHashSet had no results, so I decided to implement it myself", "label": {"api": {"LinkedHashSet": [[48, 60]], "HashSet": [[54, 60]]}}}, {"text": "One useful result which I found was this answer, which suggests to use an identity-wrapper class in composition with LinkedHashSet", "label": {"api": {"LinkedHashSet": [[117, 129]], "HashSet": [[123, 129]]}}}, {"text": "You can then populate this list with new containers using ArrayList.add(E e), combined with a for loop or some other construct", "label": {"api": {"ArrayList.add(E e)": [[58, 75]]}}}, {"text": "Likewise, you can access any particular container using ArrayList.get(int index) (if you know the index) or ArrayList.indexOf(Object o) (if you have a reference to a specific container)", "label": {"api": {"ArrayList.get(int index)": [[56, 79]], "ArrayList.indexOf(Object o)": [[108, 134]]}}}, {"text": "You can use appendOffset rather than appendOffsetId", "label": {"api": {"appendOffset": [[12, 23], [37, 48]]}}}, {"text": "You could use a LinkedHashMap, and make sure to ensure to insert the fruits into the map in the order from least to most expensive since it maintains insertion order, unlike the regular HashMap", "label": {"api": {"LinkedHashMap": [[16, 28]], "HashMap": [[22, 28], [186, 192]]}}}, {"text": "You should use a TreeMap and specify the order you would like in a custom comparator", "label": {"api": {"TreeMap": [[17, 23]]}}}, {"text": "Object.wait() functionality is implemented with JVM_MonitorWait native method, as per ThreadReference javadoc", "label": {"api": {"Object.wait()": [[0, 12]]}}}, {"text": "JDBC exposes java.sql.Connection and relate classes so the database projects can implement drivers for Java", "label": {"api": {"java.sql.Connection": [[13, 31]]}}}, {"text": "As per Robot() constructor javadoc", "label": {"api": {"Robot()": [[7, 13]]}}}, {"text": "Take a look at Map javadoc which lists all the methods in Map interface and what is their role", "label": {"api": {"Map javadoc": [[15, 25]]}}}, {"text": "Alternative approach which stores the side lengths in a double array, sides, and deals with possible invalid input in getSides()", "label": {"api": {"double": [[56, 61]]}}}, {"text": "What might help you in your problem would be @PostConstruct", "label": {"api": {"@PostConstruct": [[45, 58]]}}}, {"text": "Use the addHyperlinkListener(HyperlinkListener) method to capture events related to the user clicking the link", "label": {"api": {"addHyperlinkListener(HyperlinkListener)": [[8, 46]]}}}, {"text": "Let's begin by assuming we are using ConcurrentHashMap, a version of HashMap that has more predictable and intuitive memory consistency effects when accessed in parallel", "label": {"api": {"ConcurrentHashMap": [[37, 53]]}}}, {"text": "If you're using Java 8 or later, using ConcurrentHashMap's implementation of the computeIfAbsent method will keep other threads out while the new value is being computed and stored", "label": {"api": {"ConcurrentHashMap": [[39, 55]], "computeIfAbsent": [[81, 95]]}}}, {"text": "You need either collection elements to implement java.lang.Comparable or a separate java.lang.Comparator object", "label": {"api": {"java.lang.Comparable": [[49, 68]], "java.lang.Comparator": [[84, 103]]}}}, {"text": "You have already created a java.lang.Comparator with below (c1, c2) lambda", "label": {"api": {"java.lang.Comparator": [[27, 46]]}}}, {"text": "Or using List.sort", "label": {"api": {"List.sort": [[9, 17]]}}}, {"text": "According to the ResultSet JavaDoc", "label": {"api": {"ResultSet": [[17, 25]]}}}, {"text": "A ResultSet cursor is initially positioned before the first row; the first call to the method next makes the first row the current row; the second call makes the second row the current row, and so on", "label": {"api": {"ResultSet": [[2, 10]]}}}, {"text": "Take a look at how Collectors.averagingDouble or Collectors.averagingInt is implemented", "label": {"api": {"Collectors.averagingDouble": [[19, 44]], "Collectors.averagingInt": [[49, 71]]}}}, {"text": "Having that, the problem boils down to writing a simple Collector<Product, AccumulationType, BigDecimal>", "label": {"api": {"Collector<Product, AccumulationType, BigDecimal>": [[56, 103]]}}}, {"text": "This solution is based on ConcurrentHashMap#computeIfAbsent, with two assumptions", "label": {"api": {"ConcurrentHashMap#computeIfAbsent": [[26, 58]]}}}, {"text": "The default behavior is documented in Runtime#addShutdownHook", "label": {"api": {"Runtime#addShutdownHook": [[38, 60]]}}}, {"text": "There is Process.pid() method available since Java 9", "label": {"api": {"Process.pid()": [[9, 21]]}}}, {"text": "You could use LocalTime and Duration although you will need a custom format to parse time with single hour digit", "label": {"api": {"LocalTime": [[14, 22]], "Duration": [[28, 35]]}}}, {"text": "Here are the docs for the ByteArrayOutputStream, which your loop should write to, which you can in-turn write to a file", "label": {"api": {"ByteArrayOutputStream": [[26, 46]]}}}, {"text": "This overload of drawImage allows you to specify the portion of the source image to draw directly", "label": {"api": {"This overload of drawImage": [[0, 25]]}}}, {"text": "You will have floating point arithmetic issues due to the subtraction however, so you should use BigDecimal instead of double", "label": {"api": {"BigDecimal": [[97, 106]]}}}, {"text": "Then, you could use the above method to reduce your List<Travellers> by using Collectors.toMap", "label": {"api": {"Collectors.toMap": [[78, 93]]}}}, {"text": "To remove such instances, we're using the Collection.removeIf method", "label": {"api": {"Collection.removeIf": [[42, 60]]}}}, {"text": "There are others that you can find in the java.util.function package, and you choose or write a particular functional interface based on what signature your particular method has", "label": {"api": {"java.util.function package": [[42, 67]]}}}, {"text": "See java.util.function package for more information", "label": {"api": {"java.util.function package": [[4, 29]]}}}, {"text": "You can map lines to a custom Money type and then use Collectors.groupingBy and Collectors.summingInt", "label": {"api": {"Collectors.groupingBy": [[54, 74]], "Collectors.summingInt": [[80, 100]]}}}, {"text": "Most likely you are missing jdk.localedata module", "label": {"api": {"jdk.localedata module": [[28, 48]]}}}, {"text": "Because a GeneralPath can have one of two different winding rules, ShapeUtils must include it in the corresponding implementation of equal(), seen here", "label": {"api": {"GeneralPath": [[10, 20]]}}}, {"text": "Similarly, SerialUtils must include the attribute when serializing a GeneralPath, as seen here", "label": {"api": {"GeneralPath": [[69, 79]]}}}, {"text": "Consider a combination of java.util.ServiceLoader and AutoService, so you can just write ServiceLoader.load(ClassInterface.class) and get an Iterable<ClassInterface>", "label": {"api": {"java.util.ServiceLoader": [[26, 48]]}}}, {"text": "Please see String.CASE_INSENSITIVE_ORDER for further details", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[11, 39]]}}}, {"text": "The most common one is Comparable<T>", "label": {"api": {"Comparable<T>": [[23, 35]]}}}, {"text": "You are supposed to use PreparedStatement with bind parameters as explained in the Using Prepared Statements tutorial", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "All classes have a toString() method because they inherit Object#toString, so it is actually \"implemented\"", "label": {"api": {"Object#toString": [[58, 72]]}}}, {"text": "As per ResultSet.next() each call to this method moves to the next record in the result set until false is returned indicating that there are no more results", "label": {"api": {"ResultSet.next()": [[7, 22]]}}}, {"text": "The easiest way would be to create a list of String[] and use Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[62, 82]]}}}, {"text": "After connecting, the program then receives the input from the scanner, transforms it using some custom logic and finally redirects the transformed output to the standard out using the Robot class", "label": {"api": {"Robot": [[185, 189]]}}}, {"text": "However, when wrapping this JAR/BAT file as a windows service (using JSW Community Edition or YAJSW) the program will function perfectly, but will not output the \"mimicked\" keystrokes performed by the Robot.class", "label": {"api": {"Robot": [[201, 205]]}}}, {"text": "I even used JNA libraries with the sendInput() method (as replacement for the Robot class) to create the keystrokes as close to the OS level as possbile, but this didn't work also..", "label": {"api": {"Robot": [[78, 82]]}}}, {"text": "You should look at ProcessBuilder; you can specify where the output goes e.g", "label": {"api": {"ProcessBuilder": [[19, 32]]}}}, {"text": "Path, Paths and especially Files are very handy classes", "label": {"api": {"Files": [[27, 31]]}}}, {"text": "The drawRect method is part of Graphics not Canvas so you need to look into how canvas.paint() and canvas.getGraphics() work", "label": {"api": {"Graphics": [[31, 38], [109, 116]], "Canvas": [[44, 49]], "canvas.paint()": [[80, 93]], "canvas.getGraphics()": [[99, 118]]}}}, {"text": "This is happening because, internally, Spring is making use of SimpleClientHttpResponse.getStatusText() which is internally relying on HttpUrlConnection.getResponseMessage()", "label": {"api": {"HttpUrlConnection.getResponseMessage()": [[135, 172]]}}}, {"text": "You could simplify the whole construct by using Collectors.toMap", "label": {"api": {"Collectors.toMap": [[48, 63]]}}}, {"text": "Switch to Runtime.exec(String[]) to avoid problems in quoting the arguments", "label": {"api": {"Runtime.exec(String[])": [[10, 31]]}}}, {"text": "If I read the Oracle documentation correctly, the std inputs and outputs are directed to pipes by default but the ProcessBuilder has an easy method for you to explicitly set output (or input) to a file on your system or something else", "label": {"api": {"set output (or input) to a file on your system or something else": [[170, 233]]}}}, {"text": "Use CHM's atomic computeIfAbsent() method and you won't have to worry about synchronization", "label": {"api": {"computeIfAbsent()": [[17, 33]]}}}, {"text": "If you use a JEditorPane, you can display the content as HTML", "label": {"api": {"JEditorPane": [[13, 23]]}}}, {"text": "The getDayOfMonth method returns the day of the month, from 1 to 31", "label": {"api": {"getDayOfMonth": [[4, 16]]}}}, {"text": "The simplest is to use Collections#reverse and String#join", "label": {"api": {"Collections#reverse": [[23, 41]], "String#join": [[47, 57]]}}}, {"text": "If you don't want to modify the list by calling Collections.reverse(List<?> list) on it, iterate the list in reverse", "label": {"api": {"Collections.reverse(List<?> list)": [[48, 80]]}}}, {"text": "If you don't know the list type, use a ListIterator to iterate the list backwards without loss of performance, e.g", "label": {"api": {"ListIterator": [[39, 50]]}}}, {"text": "To join the values separated by commas, use a StringJoiner (Java 8+)", "label": {"api": {"StringJoiner": [[46, 57]]}}}, {"text": "If you are not sorting the ArraList, you can simply call the sort method with a comparator (see javadoc https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html": [[104, 169]]}}}, {"text": "int index=Collections.indexOfSubList(list , sublist);   from Collections.indexOfSubList   and check the implementation there", "label": {"api": {"Collections.indexOfSubList": [[10, 35], [61, 86]]}}}, {"text": "Using the public API (Introspector.getBeanInfo) solve the problem", "label": {"api": {"Introspector.getBeanInfo": [[22, 45]]}}}, {"text": "You can use Array#getLength", "label": {"api": {"Array#getLength": [[12, 26]]}}}, {"text": "Also don't forget that passing an Object that is not an array to Array#getLength will result in IllegalArgumentException", "label": {"api": {"Array#getLength": [[65, 79]]}}}, {"text": "If you need to fail fast before invoking Array#getLength you can check if the argument is actually array", "label": {"api": {"Array#getLength": [[41, 55]]}}}, {"text": "Java 8 introduced a common fork-join pool, and the number of threads in this pool is usually equal to the number of cores on your machine", "label": {"api": {"common fork-join pool": [[20, 40]]}}}, {"text": "That has not been necessary for many years, because JDBC drivers are located using the service provider process", "label": {"api": {"service provider": [[87, 102]]}}}, {"text": "If you want to print the name of the method you are in, you could use something like getEnclosingMethod() or get the current stack trace, depending on what you need", "label": {"api": {"getEnclosingMethod()": [[85, 104]]}}}, {"text": "Java's java.util.LinkedList manages the next and previous pointers internally", "label": {"api": {"java.util.LinkedList": [[7, 26]]}}}, {"text": "You are adding 5 nodes to this LinkedList, and nowhere are you removing the duplicates", "label": {"api": {"removing": [[63, 70]]}}}, {"text": "Use Collectors.toCollection for different Set implementation", "label": {"api": {"Collectors.toCollection": [[4, 26]]}}}, {"text": "From Java SE 8 onwards i would like to suggest using the java.time API", "label": {"api": {"java.time": [[57, 65]]}}}, {"text": "For Android users, java.time is added in API 26+", "label": {"api": {"java.time": [[19, 27]]}}}, {"text": "Using the java.time API calculating the duration between 2 date times is very easy", "label": {"api": {"java.time": [[10, 18]]}}}, {"text": "If the java.time API is not available for your project, because for example your project is not yet on API level 26, then i would recommend using the ThreeTen Android Backport API as suggested by @Ole V.V in the comments below", "label": {"api": {"java.time": [[7, 15]]}}}, {"text": "The Syntax is pretty much the same as the java.time API", "label": {"api": {"java.time": [[42, 50]]}}}, {"text": "Another difference is you need to import the java.time classes from the org.threeten.bp package (not the java.time package)", "label": {"api": {"java.time": [[45, 53], [105, 113]]}}}, {"text": "Wouldn't it be easier to use an array of char, pass said array into a for each structure, and then use the replaceAll​(String regex, String replacement) method on your String", "label": {"api": {"replaceAll​(String regex, String replacement)": [[107, 151]]}}}, {"text": "In Java, it is called a UUID", "label": {"api": {"UUID": [[24, 27]]}}}, {"text": "The string you have the is partially url encoded, try using URLDecoder", "label": {"api": {"URLDecoder": [[60, 69]]}}}, {"text": "You can use an OverlayLayout here", "label": {"api": {"OverlayLayout": [[15, 27]]}}}, {"text": "You can use the class Class for that (see-> https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html": [[44, 105]]}}}, {"text": "I tried to use Java's Stream#reduce", "label": {"api": {"Stream#reduce": [[22, 34]]}}}, {"text": "The constructor you chose, String(byte[] encoded, int offset, int length), uses the default platform encoding to convert bytes to characters", "label": {"api": {"String(byte[] encoded, int offset, int length),": [[27, 73]]}}}, {"text": "For example, the String constructor String(byte[] encoded, int offset, int length, Charset encoding) can be used like this", "label": {"api": {"String(byte[] encoded, int offset, int length, Charset encoding)": [[36, 99]]}}}, {"text": "You can look into the UUID class for this, or even go as far as something like snowflakes", "label": {"api": {"UUID": [[22, 25]]}}}, {"text": "The thenCompose method does exactly that", "label": {"api": {"thenCompose": [[4, 14]]}}}, {"text": "Also have a look at the difference between thenCompose and thenComposeAsync", "label": {"api": {"thenCompose": [[43, 53], [59, 69]]}}}, {"text": "I'm not sure of this, but you may be a more talented Java programmer than I am, but I don't know why you're using CSVReader instead of Scanner (Scanner API)", "label": {"api": {"(Scanner API)": [[143, 155]]}}}, {"text": "it is possible to solve the problem without division, using Integer.numberOfTrailingZeros(number)", "label": {"api": {"Integer.numberOfTrailingZeros(number)": [[60, 96]]}}}, {"text": "Java 8 offers this as CompletableFuture.allOf(CompletableFuture...), which mimics Promise.all; there is also CompletableFuture.anyOf(CompletableFuture...) to mimic Promise.race in Javascript", "label": {"api": {"CompletableFuture.allOf(CompletableFuture...)": [[22, 66]], "CompletableFuture.anyOf(CompletableFuture...)": [[109, 153]]}}}, {"text": "You can use the partitioningBy Collector to group by a boolean value without the prior map call", "label": {"api": {"the partitioningBy Collector": [[12, 39]]}}}, {"text": "The downstream collector can be the summarizingInt Collector to collect sum and average (plus a few others you may not need", "label": {"api": {"summarizingInt Collector": [[36, 59]]}}}, {"text": "It relies on building a compound filter, aka Predicate, using the and(...) helper method", "label": {"api": {"Predicate": [[45, 53]], "and(...)": [[66, 73]]}}}, {"text": "From the Javadoc for Matcher, we can see that the appendReplacement and appendTail methods use only StringBuffer", "label": {"api": {"Javadoc for Matcher": [[9, 27]]}}}, {"text": "reduce is actually calling apply of BiFunction (from which BinaryOperator extends)", "label": {"api": {"reduce": [[0, 5]], "apply of BiFunction": [[27, 45]], "BinaryOperator": [[59, 72]]}}}, {"text": "java.util.Currency provides the necessary information", "label": {"api": {"java.util.Currency": [[0, 17]]}}}, {"text": "A reasonable approach to print currency values without the currency sign in pure Java code is to get a general-purpose NumberFormat instance and configure it to use the number of digits defined by the appropriate Currency object", "label": {"api": {"NumberFormat": [[119, 130]]}}}, {"text": "If you need a specific currency as opposed to the default currency of the locale you use, use the String override of Currency.getInstance() instead and provide the appropriate currency code", "label": {"api": {"the String override of Currency.getInstance()": [[94, 138]]}}}, {"text": "Additionally due to the nature of BinaryOperator<T> it makes more sense to put something like minBy and maxBy there, which doesn't really make so much sense to put into a BiFunction<T, U, R>", "label": {"api": {"minBy": [[94, 98]], "maxBy": [[104, 108]]}}}, {"text": "If you want to use https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/stream/StreamSource.html#StreamSource-java.lang.String- then a valid local absolute file URI would be e.g", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/stream/StreamSource.html#StreamSource-java.lang.String-": [[19, 135]]}}}, {"text": "Then, since JDK 9, string concatenation gets compiled using invokedynamic referring to java.lang.invoke.StringConcatFactory which is not present in Java 8", "label": {"api": {"java.lang.invoke.StringConcatFactory": [[87, 122]]}}}, {"text": "Use String.replaceAll with regex", "label": {"api": {"String.replaceAll": [[4, 20]]}}}, {"text": "But a ByteBuffer can be useful in parsing this kind of data", "label": {"api": {"a ByteBuffer": [[4, 15]]}}}, {"text": "Is there flatMap analogy in Cactoos library", "label": {"api": {"flatMap": [[9, 15]]}}}, {"text": "I need exactly what flatMap can, but without streams", "label": {"api": {"flatMap": [[20, 26]]}}}, {"text": "The flatMap() operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream", "label": {"api": {"flatMap": [[4, 10]]}}}, {"text": "if I have some values in list, and each value has children items, and I want to get all items from each value, I can use flatMap", "label": {"api": {"flatMap": [[121, 127]]}}}, {"text": "You can use the DELETE_ON_CLOSE option", "label": {"api": {"DELETE_ON_CLOSE": [[16, 30]]}}}, {"text": "I can use NetworkInterface.getNetworkInterfaces() to get all the interfaces installed on my machine, but I cannot determine which interface the computer is using to access the internet", "label": {"api": {"NetworkInterface.getNetworkInterfaces()": [[10, 48]]}}}, {"text": "With SAX you need to implement a content handler with certain methods and this also implies that you need to maintain the state of the event stream", "label": {"api": {"certain methods": [[54, 68]]}}}, {"text": "You can also use Collectors#groupingBy for this purpose", "label": {"api": {"Collectors#groupingBy": [[17, 37]]}}}, {"text": "If the names are not unique, the result won't be the same as you expect so in that case we need to use Collectors.toMap and use the mergeFunction to retain only the second non-unique entry", "label": {"api": {"Collectors.toMap": [[103, 118]]}}}, {"text": "Here is the link for the documentation for java.nio.Files", "label": {"api": {"java.nio.Files": [[43, 56]]}}}, {"text": "You could implement the custom collector, see example in this article", "label": {"api": {"collector": [[31, 39]]}}}, {"text": "You're calling Writer.write(int) which writes a single character to the writer", "label": {"api": {"Writer.write(int)": [[15, 31]]}}}, {"text": "If you talk about JAVA 7 https://docs.oracle.com/javase/7/docs/api/ is the documentation", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/": [[25, 66]]}}}, {"text": "Your compareTo always returns 0, so that means that you are considering all ComparableSphere objects equal to each other, according to the compareTo contract", "label": {"api": {"the compareTo contract": [[135, 156]]}}}, {"text": "You want to use Scanner#nextLine() to get the order code, and String#substring(int beginIndex, int endIndex) to get the individual numbers", "label": {"api": {"Scanner#nextLine()": [[16, 33]], "String#substring(int beginIndex, int endIndex)": [[62, 107]]}}}, {"text": "You can convert the numbers from String to int using Integer.praseInt(String s)", "label": {"api": {"Integer.praseInt(String s)": [[53, 78]]}}}, {"text": "Just make sure your stream is boxed", "label": {"api": {"boxed": [[30, 34]]}}}, {"text": "Note that if you're doing this not for self-education but to actually use it in some production code, you might want to consider the built-in Collectors.joining collector", "label": {"api": {"Collectors.joining": [[142, 159]]}}}, {"text": "Additionally, there is the String.join method, which also works for a collection of CharSequences", "label": {"api": {"String.join": [[27, 37]]}}}, {"text": "Have a look at how Java implements toString", "label": {"api": {"Have a look at how Java implements": [[0, 33]]}}}, {"text": "Collectors.averagingInt accepts a ToIntFunction, of which the return type of the operation collect is bound to the type of Stream, which is raw", "label": {"api": {"Collectors.averagingInt": [[0, 22]]}}}, {"text": "Stream.forEach accepts a Consumer, which is directly bound to the type of the Stream", "label": {"api": {"Stream.forEach": [[0, 13]]}}}, {"text": "You should take care of the way you are using the nextLine method of Scanner", "label": {"api": {"Scanner": [[69, 75]]}}}, {"text": "I suggest you refactor your loop on the scanner using the method hasNextLine of Scanner", "label": {"api": {"Scanner": [[80, 86]]}}}, {"text": "The flatMapping API in Collectors was introduced with Java-9", "label": {"api": {"flatMapping API in Collectors": [[4, 32]]}}}, {"text": "You can add @UniqueConstraint to the @Table in your Location entity and specify which column(s) must all be in a unique combination (example given in the linked documentation)", "label": {"api": {"@UniqueConstraint": [[12, 28]]}}}, {"text": "One way would be to use Process.waitFor()", "label": {"api": {"Process.waitFor()": [[24, 40]]}}}, {"text": "You can get the same representation as in python by using Byte.toUnsignedInt()", "label": {"api": {"Byte.toUnsignedInt()": [[58, 77]]}}}, {"text": "I also started using methods from the java.util.Properties Javadocs which proved very helpful and simplified many areas", "label": {"api": {"java.util.Properties Javadocs": [[38, 66]]}}}, {"text": "You have to use the overload of Collectors.toMap that accepts a merge function", "label": {"api": {"Collectors.toMap": [[32, 47]]}}}, {"text": "Java Pattern class docs", "label": {"api": {"Java Pattern class docs": [[0, 22]]}}}, {"text": "Unfortunately, TimeZone.getTimeZone(String ID) returns", "label": {"api": {"TimeZone.getTimeZone(String ID)": [[15, 45]], "TimeZone": [[15, 22], [27, 34]]}}}, {"text": "the specified TimeZone, or the GMT zone if the given ID cannot be understood", "label": {"api": {"TimeZone": [[14, 21]]}}}, {"text": "See the javadoc of TimeZone for valid ID syntax", "label": {"api": {"TimeZone": [[19, 26]]}}}, {"text": "For the 16th to 21th(?), which are dates, you might be able to use DateFormat's parse(String) method; although, I'm clueless on how to help the compiler to get the used format or if it can do it properly by itself", "label": {"api": {"DateFormat's parse(String)": [[67, 92]]}}}, {"text": "For the 22th to 27th(?), the Integers, you should be able to use Integer's parse(String) method, or possibly through Double's and then convert back to an Integer or an int", "label": {"api": {"Integer's parse(String)": [[65, 87]]}}}, {"text": "You should also familiarize yourself with the documentation for the Scanner class as well as the rest of the documentation for the standard Java APIs", "label": {"api": {"the documentation for the Scanner class": [[42, 80]]}}}, {"text": "I have literally never used this, but it is mentioned in the documentation of Formatter", "label": {"api": {"Formatter": [[78, 86]]}}}, {"text": "You can create a stream of String using the method lines of BufferedReader", "label": {"api": {"lines": [[51, 55]]}}}, {"text": "Returns a Stream, the elements of which are lines read from this BufferedReader", "label": {"api": {"lines": [[44, 48]]}}}, {"text": "Based on the API, I think you want", "label": {"api": {"API": [[13, 15]]}}}, {"text": "A MultivaluedMap is", "label": {"api": {"MultivaluedMap": [[2, 15]], "Map": [[13, 15]]}}}, {"text": "A Map is", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "So in a MultivaluedMap you can insert 0, 1, 2, 3 or more objects related to the same key", "label": {"api": {"MultivaluedMap": [[8, 21]], "Map": [[19, 21]]}}}, {"text": "In a Map you can insert exactly 1 object related to a key", "label": {"api": {"Map": [[5, 7]]}}}, {"text": "Another scenario is a Map holding all products buyed by a user", "label": {"api": {"Map": [[22, 24]]}}}, {"text": "Personally I see this as a flaw in the source code of the writer, which should have used something along the lines of Pattern.quote(String) to escape all characters before inserting it", "label": {"api": {"Pattern.quote(String)": [[118, 138]]}}}, {"text": "A HashSet can be iterated through quickly and provides efficient lookups", "label": {"api": {"HashSet": [[2, 8]]}}}, {"text": "The findAny method doesn't find all the elements; it finds just one element", "label": {"api": {"findAny method": [[4, 17]]}}}, {"text": "But the peek method doesn't execute its action on an element until the element is consumed by the terminal action", "label": {"api": {"peek method": [[8, 18]]}}}, {"text": "The findAny method is short-circuiting, so peek's action will only be called for that element found by findAny", "label": {"api": {"findAny method": [[4, 17]]}}}, {"text": "One is printed by the peek method, and you print the second, which is the value inside the Optional returned by findAny", "label": {"api": {"peek method": [[22, 32]]}}}, {"text": "You could use a BlockingQueue to define the tasks", "label": {"api": {"BlockingQueue": [[16, 28]]}}}, {"text": "Have one thread create the tasks and add them to the queue using put, which blocks until there's space in the queue", "label": {"api": {"put": [[65, 67]]}}}, {"text": "One way to do this is to put N \"poison pills\" on the queue when the generating thread has created all of the tasks", "label": {"api": {"put": [[25, 27]]}}}, {"text": "Since each thread can only read at most one poison pill (because it exits after it reads it), and you put N poison pills in the queue, you'll ensure that each of your N threads will see exactly one poison pill", "label": {"api": {"put": [[102, 104]]}}}, {"text": "There are lots of ways to do this, but I think the simplest way in JMS 1.1 is using the javax.jms.QueueRequestor", "label": {"api": {"javax.jms.QueueRequestor": [[88, 111]]}}}, {"text": "Define how threads for the pool are created by specifying a ThreadFactory", "label": {"api": {"ThreadFactory": [[60, 72]]}}}, {"text": "Sure, a ThreadFactory can be expressed by a lambda", "label": {"api": {"ThreadFactory": [[8, 20]]}}}, {"text": "I'd advise reading the docs of ThreadPoolExecutor and Executors", "label": {"api": {"ThreadPoolExecutor": [[31, 48]], "Executors": [[54, 62]]}}}, {"text": "I'm trying to create a simple message using SOAP", "label": {"api": {"SOAP": [[44, 47]]}}}, {"text": "The above code iterates the input map map and for each element t of each one of its List values l, it uses Map.computeIfAbsent to create the result", "label": {"api": {"Map.computeIfAbsent": [[107, 125]]}}}, {"text": "Map.computeIfAbsent returns the value if there's an entry for the given key, or creates the entry and returns the value specified by its second argument d -> new ArrayList<>() (here d stands for a dummy argument that we don't need in order to create a new, empty list)", "label": {"api": {"Map.computeIfAbsent": [[0, 18]]}}}, {"text": "Then, the key k is added to the list returned by Map.computeIfAbsent", "label": {"api": {"Map.computeIfAbsent": [[49, 67]]}}}, {"text": "To specify how long a task takes, use Duration", "label": {"api": {"Duration": [[38, 45]]}}}, {"text": "According to the documentation (https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html#combobox), The arrow-button is a StackPane, so I would assume the following would work", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html#combobox": [[32, 118]]}}}, {"text": "Probably, the easiest way to approach this, is to use BlockingQueue", "label": {"api": {"BlockingQueue": [[54, 66]]}}}, {"text": "The LocalDateTime class has a minusYears() method which", "label": {"api": {"LocalDateTime": [[4, 16]], "minusYears()": [[30, 41]]}}}, {"text": "Returns a copy of this LocalDateTime with the specified number of years subtracted", "label": {"api": {"LocalDateTime": [[23, 35]]}}}, {"text": "Since the other answers already addressed the ways you can solve the problem in java-8, with this solution you can use the all new Collectors.filtering introduced in java-9.So just leaving it here for future reference", "label": {"api": {"Collectors.filtering": [[131, 150]]}}}, {"text": "You can use StandardCharsets.UTF_16LE for specifying the encoding rather than the string; this saves you from one exception to handle", "label": {"api": {"StandardCharsets.UTF_16LE": [[12, 36]]}}}, {"text": "From java 9 on, the Cleaner has moved to into java.lang.ref (detailed here)", "label": {"api": {"detailed here)": [[61, 74]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/io/File.html and look for the specific static field separator", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/io/File.html": [[0, 58]]}}}, {"text": "Use Path with Files", "label": {"api": {"Path": [[4, 7]], "Files": [[14, 18]], "File": [[14, 17]]}}}, {"text": "This class is a generalisation of File which is only for pure file system files", "label": {"api": {"File": [[34, 37]]}}}, {"text": "For established File using APIs one can use Path.toFile() and File.toPath()", "label": {"api": {"Path": [[44, 47], [69, 72]], "File": [[16, 19], [51, 54], [62, 65]]}}}, {"text": "Paths.get is very versatile, also due to the Posix compatibility of Windows (accepting / besides \\)", "label": {"api": {"Path": [[0, 3]]}}}, {"text": "The old File you can use", "label": {"api": {"File": [[8, 11]]}}}, {"text": "For a path which can point to different file systems", "label": {"api": {"file systems": [[40, 51]]}}}, {"text": "In general Path is a nifty class storing the name parts, the file system", "label": {"api": {"Path": [[11, 14]]}}}, {"text": "A cleaner way would be to use Stream.max as", "label": {"api": {"Stream.max": [[30, 39]]}}}, {"text": "As implied by the comments, your only hope is that by adding a UncaughtExceptionHandler you find a way to have your code being notified about exceptions in other places", "label": {"api": {"UncaughtExceptionHandler": [[63, 86]]}}}, {"text": "You can use Collection.removeIf as", "label": {"api": {"Collection.removeIf": [[12, 30]]}}}, {"text": "You have to enumerate the actual interfaces separately, using NetworkInterface.getNetworkInterfaces() and NetworkInterface.getInetAddresses()", "label": {"api": {"NetworkInterface.getNetworkInterfaces()": [[62, 100]], "NetworkInterface.getInetAddresses()": [[106, 140]]}}}, {"text": "The other method, getInterfaceAddresses(), returns a list of java.net.InterfaceAddress instances", "label": {"api": {"java.net.InterfaceAddress": [[61, 85]]}}}, {"text": "With Java 9+, you can use Map.entry as", "label": {"api": {"Map.entry": [[26, 34]]}}}, {"text": "Use the nextInt(to) function to get a result", "label": {"api": {"nextInt(to)": [[8, 18]]}}}, {"text": "As has been mentioned several times already, Java has a BigDecimal class which will handle very large numbers and very small numbers", "label": {"api": {"BigDecimal": [[56, 65]]}}}, {"text": "This is, for example, used for Collections.sort(List<T> list)", "label": {"api": {"Collections.sort(List<T> list)": [[31, 60]]}}}, {"text": "This provides the benefit that the implementation support future code that conforms to the List interface", "label": {"api": {"List interface": [[91, 104]]}}}, {"text": "First of all, the duration should not be a Date, it should be a java.time.Duration", "label": {"api": {"java.time.Duration": [[64, 81]]}}}, {"text": "There are multiple ways to sort a List in Java, one of them being Collections.sort(List), but in this case it looks like you are trying to retrieve the maximum value from the list, so there's no need to add the extra overhead", "label": {"api": {"Collections.sort(List)": [[66, 87]]}}}, {"text": "JB Nizet suggested using Collections.max(List)", "label": {"api": {"Collections.max(List)": [[25, 45]]}}}, {"text": "Is there any difference in using SuspendThread from a JVMTI agent and using the plain Java thread.suspend()", "label": {"api": {"thread.suspend()": [[91, 106]]}}}, {"text": "the class Class and also at class literals", "label": {"api": {"the class Class": [[0, 14]]}}}, {"text": "The List.add function lets you insert an item at a particular position", "label": {"api": {"List.add": [[4, 11]]}}}, {"text": "Looking at ClassLoader.getSystemClassLoader() in Java 8 shows that it returs a ClassLoader-instance, not a URLClassLoader-instance", "label": {"api": {"ClassLoader.getSystemClassLoader() in Java 8": [[11, 54]]}}}, {"text": "The same is true for ClassLoader.getSystemClassLoader() in Java 11", "label": {"api": {"ClassLoader.getSystemClassLoader() in Java 11": [[21, 65]]}}}, {"text": "If Session is an AutoCloseable, you could use a try-with-resources", "label": {"api": {"AutoCloseable": [[17, 29]]}}}, {"text": "If it is not, you could use Optional to your advantage", "label": {"api": {"Optional": [[28, 35]]}}}, {"text": "However, you can use ScheduledExecutorService, which is in the base Java environment", "label": {"api": {"ScheduledExecutorService": [[21, 44]]}}}, {"text": "You can just use IntStream.concat() so solve this", "label": {"api": {"IntStream.concat()": [[17, 34]]}}}, {"text": "You also should use IntStream.rangeClosed() instead of IntStream.range() if you want 129 and 200 to be part of the result", "label": {"api": {"IntStream.rangeClosed()": [[20, 42]], "IntStream.range()": [[55, 71]]}}}, {"text": "nextInt(int origin, int bound)", "label": {"api": {"nextInt(int origin, int bound)": [[0, 29]]}}}, {"text": "A simpler representation of the same using Map.putIfAbsent and forEach  would be", "label": {"api": {"Map.putIfAbsent": [[43, 57]]}}}, {"text": "Since your method is void you can manually start a new thread from incomingRequest method using, for example, CompletableFuture", "label": {"api": {"CompletableFuture": [[110, 126]]}}}, {"text": "Or, try with returning CompletableFuture from your method, like so", "label": {"api": {"CompletableFuture": [[23, 39]]}}}, {"text": "JTextField by default allows the user to enter text into it", "label": {"api": {"JTextField": [[0, 9]]}}}, {"text": "Writing to a text file in java is accomplished via one of the Writer classes, for example class FileWriter", "label": {"api": {"FileWriter": [[96, 105]]}}}, {"text": "If you take a look at the Javadocs for the ArrayList class, there are some methods that will be helpful for you", "label": {"api": {"Javadocs for the ArrayList": [[26, 51]]}}}, {"text": "In order to do so you need to provide an EventHandler interface implementation, for example", "label": {"api": {"EventHandler": [[41, 52]]}}}, {"text": "First you need to add runtime retention to your annotations so they can be read using reflection", "label": {"api": {"runtime retention": [[22, 38]]}}}, {"text": "Also, setMaxResults() (JPQLs version of LIMIT) doesn't seem valid for DELETE statements", "label": {"api": {"setMaxResults()": [[6, 20]]}}}, {"text": "However, if you just use String.getBytes() without any arguments to get the byte[] then the return value will depend on the system default encoding", "label": {"api": {"String.getBytes()": [[25, 41]]}}}, {"text": "Yes, you can use scheduleWithFixedDelay", "label": {"api": {"scheduleWithFixedDelay": [[17, 38]]}}}, {"text": "The Java library for Zip files has an option in ZipEntry for getExtra() that returns either byte[] or null", "label": {"api": {"getExtra()": [[61, 70]]}}}, {"text": "I'm aware of this question about archive attributes linked to getExtra() but it doesn't explain what else the field is used for", "label": {"api": {"getExtra()": [[62, 71]]}}}, {"text": "The answer can be found in the first two links in the java.util.zip package documentation", "label": {"api": {"the java.util.zip package documentation": [[50, 88]]}}}, {"text": "As an alternative, if System.identityHashCode is used elsewhere in your class such that results need to be consistent, you can take a replacement ToIntFunction in your constructor, and have the default implementation pass System.identityHashCode as a reference to a static method", "label": {"api": {"ToIntFunction": [[146, 158]], "System.identityHashCode": [[22, 44], [222, 244]]}}}, {"text": "But for your question, note in particular that ArrayList defines a method trimToSize() that isn't defined in List", "label": {"api": {"trimToSize()": [[74, 85]]}}}, {"text": "If you declared myList as above, you would not be able to invoke myList.trimToSize()", "label": {"api": {"trimToSize()": [[72, 83]]}}}, {"text": "The documentation found here doesn't list this as a throw for the two argument signature of the remove function", "label": {"api": {"found here": [[18, 27]]}}}, {"text": "If you further don't want to modify the Set, you can use Set.of with Java-9+ as", "label": {"api": {"Set.of": [[57, 62]]}}}, {"text": "or else you can use Collections.addAll as in", "label": {"api": {"Collections.addAll": [[20, 37]]}}}, {"text": "See the the official java docs as @Arnaud pointed out in the comments", "label": {"api": {"the official java docs": [[8, 29]]}}}, {"text": "You should leverage FileVisitor from NIO2", "label": {"api": {"FileVisitor": [[20, 30]]}}}, {"text": "The console() method doesn't have a method like printf(), it returns an object that has a printf() method", "label": {"api": {"console() method": [[4, 19]]}}}, {"text": "Specifically, the console() method returns a Console object", "label": {"api": {"console() method": [[18, 33]], "Console": [[45, 51]]}}}, {"text": "System has a method console() which grants access to the console associate with the JVM", "label": {"api": {"console()": [[20, 28]]}}}, {"text": "Otherwise if you want to convert all the entities maybe you could use a custom XmlResolver for undeclared entities", "label": {"api": {"XmlResolver": [[79, 89]]}}}, {"text": "To query tables and their columns in a database-agnostic way using JDBC, call conn.getMetaData()", "label": {"api": {"conn.getMetaData()": [[78, 95]]}}}, {"text": "Then use getTables(String catalog, String schemaPattern, String tableNamePattern, String\\[\\] types) to query table information", "label": {"api": {"getTables(String catalog, String schemaPattern, String tableNamePattern, String\\[\\] types)": [[9, 98]]}}}, {"text": "Use getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) to query column information", "label": {"api": {"getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)": [[4, 102]]}}}, {"text": "See javadoc of DatabaseMetaData for other available methods", "label": {"api": {"DatabaseMetaData": [[15, 30]]}}}, {"text": "You could use Optional#orElse() to sub in an empty string if the string doesn’t exist, then use StringUtils.isBlank() on the result", "label": {"api": {"Optional#orElse()": [[14, 30]]}}}, {"text": "You can benefit from computeIfAbsent", "label": {"api": {"computeIfAbsent": [[21, 35]]}}}, {"text": "If you're JDK is modern -- read 8+, you can use java.time.DateFormat as follows", "label": {"api": {"modern -- read 8+": [[17, 33]]}}}, {"text": "The obvious implementation would be for that method to directly accept a SessionToken; but you might also consider that Authenticator is a functional interface and therefore can be represented as a Supplier<SessionToken>", "label": {"api": {"functional interface": [[139, 158]], "Supplier<SessionToken>": [[198, 219]]}}}, {"text": "Either way, if you replace the Client dependency on Authenticator with either SessionToken or Supplier<SessionToken>, you can break the circular dependency", "label": {"api": {"Supplier<SessionToken>": [[94, 115]]}}}, {"text": "3- ConcurrentHashMap maybe", "label": {"api": {"ConcurrentHashMap": [[3, 19]]}}}, {"text": "Use BitSet.or(BitSet) to include all elements of the bit set passed as argument into the current bit set", "label": {"api": {"BitSet.or(BitSet)": [[4, 20]]}}}, {"text": "ConcurrentHashMap.mappingCount() returns a long which means it can represent more than Integer.MAX_VALUE entries", "label": {"api": {"ConcurrentHashMap.mappingCount()": [[0, 31]]}}}, {"text": "Using Collections.disjoint which returns true iff the two specified collections have no elements in common", "label": {"api": {"Collections.disjoint": [[6, 25]]}}}, {"text": "Because Query.getResultList() returns a raw type List it will break stream pipeline which is heavily based on generic type information", "label": {"api": {"Query.getResultList()": [[8, 28]]}}}, {"text": "Use a TypedQuery<String> instead of a Query", "label": {"api": {"TypedQuery<String>": [[6, 23]]}}}, {"text": "To change the configuration you need to cancel the current scheduling and create new one using Future object of task scheduler", "label": {"api": {"Future": [[95, 100]]}}}, {"text": "Why not just pipe a ZipInputStream directly into a GZIPOutputStream", "label": {"api": {"ZipInputStream": [[20, 33]], "GZIPOutputStream": [[51, 66]]}}}, {"text": "This solution takes advantage of Java 9’s incredibly useful InputStream#transferTo(OutputStream)", "label": {"api": {"InputStream#transferTo(OutputStream)": [[60, 95]]}}}, {"text": "You can add the @Override annotation to guard against accidental mistake like that", "label": {"api": {"@Override": [[16, 24]]}}}, {"text": "Use the Random class and generate a number between 1 and the end", "label": {"api": {"Random": [[8, 13]]}}}, {"text": "You can use String.indexOf method", "label": {"api": {"String.indexOf": [[12, 25]]}}}, {"text": "Maybe what you actually want is to use a Predicate", "label": {"api": {"Predicate": [[41, 49]]}}}, {"text": "Say I use a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[12, 29]]}}}, {"text": "I want to submit Callable tasks to it which will read the file & using regex search for desired search term", "label": {"api": {"Callable": [[17, 24]]}}}, {"text": "The 3 on the first line indicates how many lines you need to read, so you should use that information rather than only relying on hasNextLine(), which is not using all the information provided to you", "label": {"api": {"hasNextLine()": [[130, 142]]}}}, {"text": "If you do want to use hasNextLine() in a while loop, you need to skip the first line with the 3, outside the while loop", "label": {"api": {"hasNextLine()": [[22, 34]]}}}, {"text": "To add on to @AmitBera's answer - Executors.newCachedThreadPool() creates a practically unbounded thread pool (see the explanation by the \"Queueing\" section in the API doc)", "label": {"api": {"the API doc": [[160, 170]]}}}, {"text": "There is solution with stream api using Collectors::averagingDouble", "label": {"api": {"Collectors::averagingDouble": [[40, 66]]}}}, {"text": "On subsequent executions of your Runnable, a different thread will be accessing a different ThreadLocal", "label": {"api": {"ThreadLocal": [[92, 102]]}}}, {"text": "So you certainly can use ThreadLocal within a single run of the Runnable", "label": {"api": {"ThreadLocal": [[25, 35]]}}}, {"text": "But it is not likely to be useful, as generally the purpose of a ThreadLocal is to hold a value for a while", "label": {"api": {"ThreadLocal": [[65, 75]]}}}, {"text": "So, no, generally it does not make sense to use a ThreadLocal with a thread pool", "label": {"api": {"ThreadLocal": [[50, 60]]}}}, {"text": "Reading JSON Data Using a Parser", "label": {"api": {"Reading JSON Data Using a Parser": [[0, 31]]}}}, {"text": "If you don't want to use Date, you can simply use the modulus operator with a bit of clever arithmetics", "label": {"api": {"Date": [[25, 28]]}}}, {"text": "System#currentTimeMillis returns the amount of milliseconds that have passed since January 1, 1970, midnight (00:00)", "label": {"api": {"System#currentTimeMillis": [[0, 23]]}}}, {"text": "String#lastIndexOf and String#substring are your friends here", "label": {"api": {"String#lastIndexOf": [[0, 17]], "String#substring": [[23, 38]]}}}, {"text": "If you don't want to use String#lastIndexOf, you can loop through the string and substring it at every space until you don't have any left", "label": {"api": {"String#lastIndexOf": [[25, 42]]}}}, {"text": "You are splitting the original string at every space and storing the substrings in an array using the String#split method", "label": {"api": {"String#split": [[102, 113]]}}}, {"text": "Use Writer.append() instead of Writer.write()", "label": {"api": {"Writer.append()": [[4, 18]], "Writer.write()": [[31, 44]]}}}, {"text": "Since Java 8, the java.time package has been the optimal way to do all date/time related things", "label": {"api": {"java.time": [[18, 26]]}}}, {"text": "Cast Integer to int - remove(int index)", "label": {"api": {"remove(int index)": [[22, 38]]}}}, {"text": "Also, after Java-8 is highly recommended to treat database connections as AutoClosables", "label": {"api": {"AutoClosables": [[74, 86]]}}}, {"text": "I want to use the (newish) java.nio.Files api as it has quite an elegant set of methods for working with files and directories", "label": {"api": {"java.nio.Files": [[27, 40]]}}}, {"text": "Obviously I can do this using some other class or library (like Commons IO) but the build in java.nio.Files is quite nice", "label": {"api": {"java.nio.Files": [[93, 106]]}}}, {"text": "Let's look again at the Java SE API language regarding iteration order in the Map contract", "label": {"api": {"Map": [[78, 80]]}}}, {"text": "Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not", "label": {"api": {"Map": [[39, 41], [115, 117]], "HashMap": [[111, 117]]}}}, {"text": "Since it is explicitly stated that HashMap iterators do not have an order, it cannot be assumed that the iteration will be stable even between calls to the same method, let alone between calls to the different methods keySet() and values()", "label": {"api": {"Map": [[39, 41]], "HashMap": [[35, 41]]}}}, {"text": "Helpfully, Map has a method entrySet() that does exactly what you need", "label": {"api": {"Map": [[11, 13]], "entrySet()": [[28, 37]]}}}, {"text": "There is stream way with flatMapping from java-9", "label": {"api": {"flatMapping": [[25, 35]]}}}, {"text": "Consult with java.util.Scanner javadoc, and you will find that next() always returns String", "label": {"api": {"java.util.Scanner": [[13, 29]], "next()": [[63, 68]]}}}, {"text": "At the same time java.util.Scanner has lots of methods to get values of specific types", "label": {"api": {"java.util.Scanner": [[17, 33]]}}}, {"text": "nextBoolean(), nextByte(), etc", "label": {"api": {"nextBoolean()": [[0, 12]], "nextByte()": [[15, 24]]}}}, {"text": "You can use ReentrantReadWriteLock to handle this type of scenario", "label": {"api": {"ReentrantReadWriteLock": [[12, 33]]}}}, {"text": "MDC must be set per-thread basis as it uses a ThreadLocal internally to remember the values", "label": {"api": {"ThreadLocal": [[46, 56]], "Thread": [[46, 51]]}}}, {"text": "If you are using Thread directly or ExecutoService you must ensure that MDC value is set directly before your Runnable runs", "label": {"api": {"Thread": [[17, 22]], "ExecutoService": [[36, 49]]}}}, {"text": "This answer uses Java Streams", "label": {"api": {"Java Streams": [[17, 28]]}}}, {"text": "This one takes each (Integer, User) pair and creates an (Integer, UserV2) pair", "label": {"api": {"This one": [[0, 7]]}}}, {"text": "You can use the add(int index, E element) to insert an element at the specified position", "label": {"api": {"add(int index, E element)": [[16, 40]]}}}, {"text": "But in your case the list is not already populated, so you should use add(E element) otherwise you'll get IndexOutOfBoundsException because the index will be bigger than the current size of the list", "label": {"api": {"add(E element)": [[70, 83]]}}}, {"text": "My \"second\" answer is not for Criteria but rather the CriteriaBuilder which I wouldn't recommend for small use cases but for use cases where a query needs to be created dynamically with changing conditions coming from users or other applications", "label": {"api": {"CriteriaBuilder": [[54, 68]]}}}, {"text": "You can get an array of cookies from HttpServletRequest's getCookies() method", "label": {"api": {"Cookie": [[61, 66]]}}}, {"text": "We can not delete the cookie using the Cookie object though", "label": {"api": {"Cookie": [[39, 44]]}}}, {"text": "I think answer for your question is here - https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html#add(E)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html#add(E)": [[43, 118]]}}}, {"text": "You can do it with Collectors.collectingAndThen", "label": {"api": {"Collectors.collectingAndThen": [[19, 46]]}}}, {"text": "You could use Random.ints", "label": {"api": {"Random.ints": [[14, 24]]}}}, {"text": "ints will produce a stream of ints between 0 and max, distinct makes sure that there are no duplicates, and limit to get exactly how many you want", "label": {"api": {"distinct": [[54, 61]], "limit": [[108, 112]]}}}, {"text": "Another approach apart from what others have done can be to use Interface Predicate<T> whose default method test(T t) can be used to evaluate values greater than 3", "label": {"api": {"Interface Predicate<T>": [[64, 85]]}}}, {"text": "Or if you’re feeling fancy, using streams", "label": {"api": {"streams": [[34, 40]]}}}, {"text": "Starting from version 1.8.0 SLF4J is modularized and uses the ServiceLoader mechanism to find its logging backend", "label": {"api": {"ServiceLoader": [[62, 74]]}}}, {"text": "Also rather than re-inventing the wheel, you can make use of the already existing java-8's LocalTime to find the number of seconds for a particular time", "label": {"api": {"LocalTime": [[91, 99]]}}}, {"text": "But you could get PathIterator from the Path2D.Double and using that PathIterator to return the geometry of their boundary", "label": {"api": {"get PathIterator": [[14, 29]], "PathIterator": [[18, 29], [69, 80]]}}}, {"text": "I would probably feed my threadPool from a DelayQueue to limit yourself to 10 per minute", "label": {"api": {"DelayQueue": [[43, 52]]}}}, {"text": "Your code does not guarantee which thread will call System.out first", "label": {"api": {"System.out": [[52, 61]]}}}, {"text": "The Comparator interface is a functional interface, so any lambda expression or method reference whose method signature conforms to the functional interface may be used", "label": {"api": {"Comparator interface": [[4, 23]]}}}, {"text": "The method reference Integer::compare refers to Integer's compare method, and that method's signature matches, so the compiler allows this method reference to resolve to a Comparator instance", "label": {"api": {"Integer's compare method": [[48, 71]]}}}, {"text": "As you will know, InputStreamReader will read the provided InputStream and decode its bytes into characters", "label": {"api": {"InputStreamReader": [[18, 34]]}}}, {"text": "The InputStreamReader, though, will fail to decode it, as it expects to be running windows-1252, showing ¢ (this is the 162nd windows-1252 character)", "label": {"api": {"InputStreamReader": [[4, 20]]}}}, {"text": "The InputStreamReader, though, will fail to decode it, as it expects to be running UTF-8, showing � (code 65533)", "label": {"api": {"InputStreamReader": [[4, 20]]}}}, {"text": "The InputStreamReader will show ó as expected", "label": {"api": {"InputStreamReader": [[4, 20]]}}}, {"text": "Scanner#nextInt() only reads the integer, but does not read the newline \"\\n\"; you will need to consume the newline using Scanner#nextLine", "label": {"api": {"Scanner#nextLine": [[121, 136]]}}}, {"text": "Convert input string to list of character, then use Collections.swap method and back to string again", "label": {"api": {"Collections.swap": [[52, 67]]}}}, {"text": "The only valid operations for an iterator are increment and dereference (although the Java Iterator combines the two in its next() method)", "label": {"api": {"next()": [[124, 129]], "Iterator": [[91, 98]]}}}, {"text": "But those are the same semantics as Optional", "label": {"api": {"Optional": [[36, 43]]}}}, {"text": "an Optional can either be empty or have a valid object reference", "label": {"api": {"Optional": [[3, 10]]}}}, {"text": "So, create an Optional from the Iterator and use that as your \"unmodifiable iterator\"", "label": {"api": {"Optional": [[14, 21]], "Iterator": [[32, 39]]}}}, {"text": "This has the additional benefit that the Optional is no longer tied to the collection, so the collection can be safely changed without changing which object the Optional refers to", "label": {"api": {"Optional": [[41, 48], [161, 168]]}}}, {"text": "A good example is the Java List interface", "label": {"api": {"List": [[27, 30]]}}}, {"text": "How that really happens is not expressed in that interface, and for users of that List interface, it also doesn't matter (too much)", "label": {"api": {"List": [[82, 85]]}}}, {"text": "I've implemented the following solution which uses the producer/consumer pattern using BlockingQueue and ExecutorService", "label": {"api": {"BlockingQueue": [[87, 99]], "ExecutorService": [[105, 119]]}}}, {"text": "The main thread (producer) instantiates a BlockingQueue for each of the worker threads (consumers) and a boolean volatile variable \"terminated\" to signal to the working threads when all data has been generated and they should terminate execution (escaping from the while loop, empty the queue and write the remaining data on jdbc connection)", "label": {"api": {"BlockingQueue": [[42, 54]]}}}, {"text": "The producer produces different data for each thread using the two BlockingQueue blockingQueue1 and blockingQueue2", "label": {"api": {"BlockingQueue": [[67, 79]]}}}, {"text": "Each thread is instantiated with a specific String type (1 and 2), thus it can know from which BlockingQueue it needs to read data", "label": {"api": {"BlockingQueue": [[95, 107]]}}}, {"text": "You can parse the bits into integer with Integer.parseInt(s, radix)", "label": {"api": {"Integer.parseInt(s, radix)": [[41, 66]]}}}, {"text": "As some have answered, that's because the API doc says so", "label": {"api": {"the API doc says so": [[38, 56]]}}}, {"text": "You are looking for the compute method, also added in Java 8", "label": {"api": {"compute": [[24, 30]]}}}, {"text": "That method takes in the key you are using, as well as a BiFunction to compute what the new value should be, based on the key and the existing value", "label": {"api": {"compute": [[71, 77]]}}}, {"text": "As holger mentioned as well, you can simply use Map.merge as", "label": {"api": {"Map.merge": [[48, 56]]}}}, {"text": "You should be able to use the overload of LocalDate.minus() that takes a TemporalUnit", "label": {"api": {"LocalDate.minus()": [[42, 58]]}}}, {"text": "This solution requires that your configuration file has the time units declared to conform with the constants in the ChronoUnit enum", "label": {"api": {"ChronoUnit": [[117, 126]]}}}, {"text": "See for example, ClassFileTransformer", "label": {"api": {"ClassFileTransformer": [[17, 36]]}}}, {"text": "Additional background is available from the Comparator javadoc", "label": {"api": {"the Comparator javadoc": [[40, 61]]}}}, {"text": "Take a look at the documentation for Object", "label": {"api": {"Object": [[37, 42]]}}}, {"text": "Note that you will (somewhat ironically) get burned by ConcurrentHashMap; this assumption may not hold due to the fact that any modifications to this class would put the state of the size in flux", "label": {"api": {"ConcurrentHashMap": [[55, 71]]}}}, {"text": "Although it's a tree not a list, a TreeSet meets the requirements of being sorted, efficiently O(log(n)) searchable and you can get subsets out of it", "label": {"api": {"TreeSet": [[35, 41]], "subsets": [[132, 138]]}}}, {"text": "It'll be better if you declare it as a SortedSet", "label": {"api": {"SortedSet": [[39, 47]]}}}, {"text": "Since the TreeSet class implements NavigableSet interface, it has the functionalities of both - the NavigableSet as well as the SortedSet", "label": {"api": {"TreeSet": [[10, 16]]}}}, {"text": "The TreeSet uses a self-balancing binary search tree, more specifically a Red-Black tree", "label": {"api": {"TreeSet": [[4, 10]]}}}, {"text": "The contains() method is used to check if a given element is present in a given TreeSet", "label": {"api": {"TreeSet": [[80, 86]]}}}, {"text": "Instead of synchronized keyword, maybe you can use ReentrantLock(which is more flexible and powerful)", "label": {"api": {"ReentrantLock": [[51, 63]]}}}, {"text": "The class Files provides line oriented functions", "label": {"api": {"Files": [[10, 14]]}}}, {"text": "From the Comparator JavaDoc (emphesizes mine)", "label": {"api": {"Comparator": [[9, 18]]}}}, {"text": "Comparator::nullsFirst is a comparator that considers null to be less than non-null, and compares non-null objects with the supplied Comparator", "label": {"api": {"Comparator": [[0, 9], [133, 142]], "Comparator::nullsFirst": [[0, 21]]}}}, {"text": "Comparator::nullsLast is a comparator that considers null to be greater than non-null, and compares non-null objects with the supplied Comparator", "label": {"api": {"Comparator": [[0, 9], [135, 144]], "Comparator::nullsLast": [[0, 20]]}}}, {"text": "Basically anyMatch() expects Predicate as input not String", "label": {"api": {"anyMatch()": [[10, 19]]}}}, {"text": "Both PriorityQueue and TreeMap order elements in natural order, so having a Comparator to drive that in the absence of your elements implementing Comparable can be desirable", "label": {"api": {"in natural order": [[46, 61]]}}}, {"text": "The Collection interface requires a type ..", "label": {"api": {"Collection": [[4, 13]]}}}, {"text": "What benefit does Collection<Int> have over Collection<Any> (which is the same but allows for all types)", "label": {"api": {"Collection": [[18, 27], [44, 53]]}}}, {"text": "Assuming you want to keep using Scanner, you can just set the locale to Locale.US with useLocale", "label": {"api": {"useLocale": [[87, 95]]}}}, {"text": "There is a fundamental property of await (which applies to the intrinsic locking via synchronized and using Object.wait as well), you have to understand", "label": {"api": {"Object.wait": [[108, 118]]}}}, {"text": "This makes checking the condition in a loop the standard idiom of using await, as documented in the Condition interface, as well as Object.wait for the case of using the intrinsic monitor, just for completeness", "label": {"api": {"the Condition interface": [[96, 118]], "Object.wait": [[132, 142]]}}}, {"text": "There is suitable method summaryStatistics from IntStream", "label": {"api": {"summaryStatistics": [[25, 41]]}}}, {"text": "As pointed out in the comment, check out NavigableMap", "label": {"api": {"NavigableMap": [[41, 52]]}}}, {"text": "I suspect you're asking just for the object for the key below, in which case NavigableMap.floorKey(K) should find what you seek", "label": {"api": {"NavigableMap.floorKey(K)": [[77, 100]]}}}, {"text": "The Driver implementation is com.sap.db.jdbc.Driver", "label": {"api": {"Driver": [[4, 9], [45, 50]]}}}, {"text": "You need to extend javax.ws.rs.core.Application", "label": {"api": {"javax.ws.rs.core.Application": [[19, 46]]}}}, {"text": "Try using the DateTimeFormatter class introduced in Java 8, avoid using the SimpleDateFormat", "label": {"api": {"DateTimeFormatter": [[14, 30]]}}}, {"text": "The DateTimeFormatter in Java 8 is immutable and thread-safe alternative to  SimpleDateFormat", "label": {"api": {"DateTimeFormatter": [[4, 20]]}}}, {"text": "When a Thread reaches the end of its required code body, it does not execute a second time, even after an invocation of Thread#start", "label": {"api": {"it does not execute a second time": [[57, 89]]}}}, {"text": "Using the java.time package", "label": {"api": {"java.time": [[10, 18]]}}}, {"text": "I am converting a user-input of freely inserted date-time (year, month, day, hour, minute) to a LocalDateTime and then, according to the timezone of the user, to a ZonedDateTime", "label": {"api": {"LocalDateTime": [[96, 108]], "ZonedDateTime": [[164, 176]]}}}, {"text": "According to the documentation of atZone(), the resulting time of the conversion is the summer-time 03:30 GMT+3 (emphasis mine)", "label": {"api": {"the documentation of atZone()": [[13, 41]]}}}, {"text": "To throw an exception when there is a gap or overlap, use ZonedDateTime.ofStrict(LocalDateTime, ZoneOffset, ZoneId)", "label": {"api": {"LocalDateTime": [[81, 93]], "ZonedDateTime": [[58, 70]]}}}, {"text": "It seems to me all I would need is a LocalDateTime and ZoneId", "label": {"api": {"LocalDateTime": [[37, 49]]}}}, {"text": "Otherwise, each time I convert to ZonedDateTime, how do I know whether to use the offset of GMT+2 or GMT+3", "label": {"api": {"ZonedDateTime": [[34, 46]]}}}, {"text": "The type of a field and be obtained with Field.getType", "label": {"api": {"Field.getType": [[41, 53]]}}}, {"text": "Arrays can be identified by Class.isArray", "label": {"api": {"Class.isArray": [[28, 40]]}}}, {"text": "To get the type of object in the array Class.getComponentType can be used", "label": {"api": {"Class.getComponentType": [[39, 60]]}}}, {"text": "That is Java's doubly-linked list implementation", "label": {"api": {"That is Java's doubly-linked list implementation": [[0, 47]]}}}, {"text": "Your ArrayList<Student> student=new ArrayList<Student>(); does not belong there", "label": {"api": {"List": [[10, 13], [41, 44]]}}}, {"text": "You could loop a List of Student objects in the StudentBody object", "label": {"api": {"List": [[17, 20]]}}}, {"text": "Or you could use a Map, where the key is a UniversityId object and the value is a Student object", "label": {"api": {"Map": [[19, 21]]}}}, {"text": "These dozen types do not share an interface nor abstract class other than Object", "label": {"api": {"Object": [[74, 79]]}}}, {"text": "XPointer::deref ⇒ x where x is an object recognized as its original type, a Dog, a Truck, or a Sculpture or even another XPointer object, rather than a mere Object object", "label": {"api": {"Object": [[157, 162]]}}}, {"text": "The Optional type is the simplest case of two types", "label": {"api": {"Optional": [[4, 11]]}}}, {"text": "Use Collectors.toSet() as a downstream in groupingBy", "label": {"api": {"groupingBy": [[42, 51]]}}}, {"text": "Use the static methods Period::parse(CharSequence text) and Duration.parse(CharSequence text) with their default formats (PnDTnHnMn.nS for Duration and  PnYnMnD for Period) since they don't provide a way to translate custom expression like that", "label": {"api": {"Period::parse(CharSequence text)": [[23, 54]], "Duration.parse(CharSequence text)": [[60, 92]]}}}, {"text": "You wont be able to load multiple db entities at once unless you are using an EntityManager, or have set custom database functions inside your database", "label": {"api": {"EntityManager": [[78, 90]]}}}, {"text": "As it was mentioned in comments in java9 you can use ifPresentOrElse", "label": {"api": {"ifPresentOrElse": [[53, 67]]}}}, {"text": "Implementation of ifPresentOrElse if pretty simple using if else statement", "label": {"api": {"ifPresentOrElse": [[18, 32]]}}}, {"text": "The reason that it actually worked for uppercase F, is that the letter F is part of the floating point literal, as mentioned by the documentation of Double.parseDouble(String) which in turn refers to Double.valueOf(String), which in turn refers to the Java Language Specification § 3.10.2, which refers to this token as the FloatTypeSuffix token", "label": {"api": {"Double.parseDouble(String)": [[149, 174]], "Double.valueOf(String)": [[200, 221]]}}}, {"text": "Use YearMonth class", "label": {"api": {"YearMonth": [[4, 12]]}}}, {"text": "The documentation for this exception states", "label": {"api": {"The documentation for this exception": [[0, 35]]}}}, {"text": "The DateTimeFormatter JavaDoc explicitly states that when I use the OOOO pattern in my formatter, the full form of localized timezone should be used (emphasis mine)", "label": {"api": {"DateTimeFormatter JavaDoc": [[4, 28]]}}}, {"text": "So, you could use LinkedList or some other JDK collection", "label": {"api": {"LinkedList": [[18, 27]]}}}, {"text": "Please take a look on the link for more info about flatMap", "label": {"api": {"link": [[26, 29]]}}}, {"text": "Read the docs for Priorities", "label": {"api": {"Priorities": [[18, 27]]}}}, {"text": "By default, when the @Priority annotation is absent on a component, for which a priority should be applied, the USER priority value is used", "label": {"api": {"USER": [[112, 115]]}}}, {"text": "The USER holds a value of 5000", "label": {"api": {"USER": [[4, 7]], "5000": [[26, 29]]}}}, {"text": "So if you leave off the @Priority, the filter will be called after there other filters, as 2 and 3 are less than 5000", "label": {"api": {"5000": [[113, 116]]}}}, {"text": "A good solution is using a ByteBuffer, either on a byte array or InputStream", "label": {"api": {"ByteBuffer": [[27, 36]]}}}, {"text": "While developing with a ByteBuffer is makes sense to check the read position", "label": {"api": {"ByteBuffer": [[24, 33]]}}}, {"text": "Reference to String.join and its relevant implementation and Collectors.joining and its functionality", "label": {"api": {"String.join": [[13, 23]], "Collectors.joining": [[61, 78]]}}}, {"text": "Use try-with-resources to automatically close open resources and OutputStream.flush - to flush the data to the stream", "label": {"api": {"OutputStream.flush": [[65, 82]]}}}, {"text": "I ask this because class Thread has multiple constructors", "label": {"api": {"Thread": [[25, 30]]}}}, {"text": "There is split method", "label": {"api": {"split": [[9, 13]]}}}, {"text": "Arrays.asList() returns a list that is fixed-size and backed by the array you pass so you can't add or remove elements because that would mean changing the array as well", "label": {"api": {"fixed-size and backed by the array you pass": [[39, 81]]}}}, {"text": "Basically, I want to set an SSLContext based on JAVA_OPTS if they exist; otherwise just use the \"Default\" context", "label": {"api": {"\"Default\" context": [[96, 112]]}}}, {"text": "According to the documentation for Instant, the minimum Instant is -1000000000-01-01T00:00Z, so the year is -1000000000 and the timezone is UTC", "label": {"api": {"documentation for Instant": [[17, 41]]}}}, {"text": "atOffset returns an OffsetDateTime which has a different Min/Max", "label": {"api": {"OffsetDateTime": [[20, 33]]}}}, {"text": "The minimum supported OffsetDateTime, '-999999999-01-01T00:00:00+18:00'", "label": {"api": {"OffsetDateTime": [[22, 35]]}}}, {"text": "The maximum supported OffsetDateTime, '+999999999-12-31T23:59:59.999999999-18:00'", "label": {"api": {"OffsetDateTime": [[22, 35]]}}}, {"text": "The javadoc mentions that these min/max values are derived from LocalDateTime along with the max zone offsets, which appears to be why they don't match up to Instant", "label": {"api": {"LocalDateTime": [[64, 76]], "Instant": [[158, 164]]}}}, {"text": "The reason Instant has an extra year both ways, per documentation of Instant", "label": {"api": {"Instant": [[11, 17], [69, 75]]}}}, {"text": "This is one year earlier than the minimum LocalDateTime", "label": {"api": {"LocalDateTime": [[42, 54]]}}}, {"text": "Covers the edge case where a LocalDateTime + Offset results in a time from the previous year", "label": {"api": {"LocalDateTime": [[29, 41]]}}}, {"text": "The max practical value would be the minimum OffsetDateTime converted to an Instant, as everything prior to that date is a buffer for which there is no equivalent OffsetDateTime", "label": {"api": {"OffsetDateTime": [[45, 58], [163, 176]], "Instant": [[76, 82]]}}}, {"text": "The name of the property is not listed in the official documentation but when you list the properties, you will easily its current value", "label": {"api": {"the official documentation": [[42, 67]]}}}, {"text": "You are using Lock.tryLock()", "label": {"api": {"Lock.tryLock()": [[14, 27]]}}}, {"text": "The method you want to call in this situation is Lock.lock()", "label": {"api": {"Lock.lock()": [[49, 59]]}}}, {"text": "However, since your method is already throwing InterruptedException you might as well use Lock.lockInterruptibly()", "label": {"api": {"Lock.lockInterruptibly()": [[90, 113]]}}}, {"text": "You can use Duration and toMinutes() method", "label": {"api": {"Duration": [[12, 19]]}}}, {"text": "Use a CompletableFuture", "label": {"api": {"CompletableFuture": [[6, 22]]}}}, {"text": "Also needs to be mentioned that in java8 an Optional was introduced, that help to avoid null checking", "label": {"api": {"Optional": [[44, 51]]}}}, {"text": "Then to get a readable string call Arrays.toString()", "label": {"api": {"Arrays.toString()": [[35, 51]]}}}, {"text": "You are using java.awt.Robot which needs a graphical, non-headless environment to work correctly while the database servers doesn't provide it", "label": {"api": {"java.awt.Robot": [[14, 27]]}}}, {"text": "Look at extractor in FXCollection for complex Objects", "label": {"api": {"Look at extractor in FXCollection for complex Objects": [[0, 52]]}}}, {"text": "I would probably use AnimationTimer", "label": {"api": {"AnimationTimer": [[21, 34]]}}}, {"text": "This is done with Timeline", "label": {"api": {"Timeline": [[18, 25]]}}}, {"text": "I am aware of java.lang.ProcessBuilder class", "label": {"api": {"java.lang.ProcessBuilder": [[14, 37]]}}}, {"text": "Use one or more of the Set methods addAll, removeAll, and/or retainAll to exercise set operations such as union, intersection, and difference", "label": {"api": {"Set": [[23, 25]]}}}, {"text": "You can do this using a regular expression", "label": {"api": {"regular expression": [[24, 41]]}}}, {"text": "use InetAddress.getByName(IPv4) for string IP input, you do not need the byte array", "label": {"api": {"InetAddress.getByName(IPv4)": [[4, 30]]}}}, {"text": "Learning Kotlin, I'm trying to understand how Java's Comparator interface works - mainly the compare() function so I can utilize it", "label": {"api": {"Comparator": [[53, 62]]}}}, {"text": "And there is no sense in defining your \"own\" comparator for int, Int, or Integer, as these classes already define their natural order, so there is already Integer.compare() for example", "label": {"api": {"Integer.compare()": [[155, 171]]}}}, {"text": "To display the elements of the array use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[41, 57]]}}}, {"text": "You can get all lines from file using Files.readAllLines() from java8", "label": {"api": {"Files.readAllLines()": [[38, 57]]}}}, {"text": "However, your Task can place the pixel data itself in a non-JavaFX value object like an IntBuffer, which the application thread can then pass to setPixels", "label": {"api": {"IntBuffer": [[88, 96]]}}}, {"text": "Since the compareTo method is declared in the java.lang.Comparable<T> interface, the usage of Bounded Type Parameters can constrain your a and b arguments in order to accept only objects which implement the interface itself", "label": {"api": {"java.lang.Comparable<T>": [[46, 68]]}}}, {"text": "Use the flatMap method which will, if present, replace the Optional with another Optional, using the supplied Function", "label": {"api": {"the flatMap method": [[4, 21]]}}}, {"text": "Then, you can use orElse that will, if present, return the value or else the default value you supply", "label": {"api": {"orElse": [[18, 23]]}}}, {"text": "Taking a look at https://docs.oracle.com/javase/7/docs/api/java/lang/NumberFormatException.html will show that a NumberFormatException is a RunTimeException and therefore doesn't always have to be caught", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/NumberFormatException.html": [[17, 94]]}}}, {"text": "To execute a bash script, use ProcessBuilder", "label": {"api": {"ProcessBuilder": [[30, 43]]}}}, {"text": "To set environment variables, call environment()", "label": {"api": {"environment()": [[35, 47]]}}}, {"text": "The Java replace method takes 2 parameters - the character you want to replace, and the character you're replacing it with", "label": {"api": {"Java replace method": [[4, 22]]}}}, {"text": "the javadoc of DateTimeFormatter, specifies", "label": {"api": {"DateTimeFormatter": [[15, 31]]}}}, {"text": "According to it's JavaDoc documentation it expects the following format", "label": {"api": {"JavaDoc documentation": [[18, 38]]}}}, {"text": "Have a look on the docs about setX(), setTranslateX(), setLayoutX()", "label": {"api": {"setX()": [[30, 35]], "setTranslateX()": [[38, 52]], "setLayoutX()": [[55, 66]]}}}, {"text": "As the documentation of WeakReference specifies", "label": {"api": {"the documentation of WeakReference": [[3, 36]]}}}, {"text": "Or use Map.computeIfAbsent() that is designed for this requirement", "label": {"api": {"Map.computeIfAbsent()": [[7, 27]]}}}, {"text": "LinkedList does not have method append, you can use add, addLast", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "Also, please avoid using raw type, use LinkedList<Integer> instead", "label": {"api": {"LinkedList": [[39, 48]]}}}, {"text": "Using LocalDate.of(int year, int month, int dayOfMonth) from java8 you can create two dates and find the difference", "label": {"api": {"LocalDate.of(int year, int month, int dayOfMonth)": [[6, 54]]}}}, {"text": "Period has such methods as .getYears(), .getMonths() etc", "label": {"api": {"Period": [[0, 5]]}}}, {"text": "If you are using java 11 you can use repeat() method like", "label": {"api": {"repeat()": [[37, 44]]}}}, {"text": "To get interpolated string you can also use MessageFormat class", "label": {"api": {"MessageFormat": [[44, 56]]}}}, {"text": "Thread.sleep(long millis, int nanos) sleeps both milliseconds and nanoseconds", "label": {"api": {"Thread.sleep(long millis, int nanos)": [[0, 35]]}}}, {"text": "If you need a double within [least, bound) range you can use the ThreadLoacalRandom.nextDouble(least, bound) method", "label": {"api": {"ThreadLoacalRandom.nextDouble(least, bound)": [[65, 107]]}}}, {"text": "If no such key, add one, and put as its value a new empty List of teams to which you have added the team in question", "label": {"api": {"List": [[58, 61]]}}}, {"text": "If there is such a key, retrieve its value, a List, and then add the team in question to that list", "label": {"api": {"List": [[46, 49]]}}}, {"text": "Study the JavaDoc for the Map and List interfaces", "label": {"api": {"Map": [[26, 28]], "List": [[34, 37]]}}}, {"text": "So a league object holds a Map object", "label": {"api": {"Map": [[27, 29]]}}}, {"text": "Being a key in a map means each division name will lead you to a List object, a collection of teams", "label": {"api": {"List": [[65, 68]]}}}, {"text": "A List keeps items in the order in which they are added", "label": {"api": {"List": [[2, 5]]}}}, {"text": "Note in this diagram how one of the List objects is empty, meaning it has not yet had any teams assigned", "label": {"api": {"List": [[36, 39]]}}}, {"text": "We see in this diagram that the “division-z” key in the map has not yet been assigned any List object at all, so it points to nothing, null", "label": {"api": {"List": [[90, 93]]}}}, {"text": "You can use Optional::ofNullable from Java 8 like so", "label": {"api": {"Optional::ofNullable": [[12, 31]]}}}, {"text": "You can make use of TemporalAdjusters", "label": {"api": {"TemporalAdjusters": [[20, 36]]}}}, {"text": "The object System.out is an instance of java.io.PrintStream", "label": {"api": {"java.io.PrintStream": [[40, 58]]}}}, {"text": "System.out is a PrintStream", "label": {"api": {"PrintStream": [[16, 26]]}}}, {"text": "The docs for PrintStream say", "label": {"api": {"PrintStream": [[13, 23]]}}}, {"text": "Unlike other output streams, a PrintStream never throws an IOException; instead, exceptional situations merely set an internal flag that can be tested via the checkError method", "label": {"api": {"PrintStream": [[31, 41]]}}}, {"text": "You can check System.out.checkError() to see if an error has occurred", "label": {"api": {"System.out.checkError()": [[14, 36]]}}}, {"text": "If you want your program to exit with a nonzero status, you can use System.exit", "label": {"api": {"System.exit": [[68, 78]]}}}, {"text": "You can also build your string with a StringBuilder and then call", "label": {"api": {"StringBuilder": [[38, 50]]}}}, {"text": "1425412525412545 might fit in a long, certainly not an int, and maybe you should use BigInteger on principle, to cover the full 16 bytes", "label": {"api": {"BigInteger": [[85, 94]]}}}, {"text": "To provide more control over the exact format, you should use NumberFormat instead", "label": {"api": {"NumberFormat": [[62, 73]]}}}, {"text": "you want to do something like this, which utilises Collectors.groupingBy()", "label": {"api": {"Collectors.groupingBy()": [[51, 73]]}}}, {"text": "All of these servers provide an implementation of the Java(™) EE 7 Specification APIs", "label": {"api": {"Java(™) EE 7 Specification APIs": [[54, 84]]}}}, {"text": "Arrays.print is found in the same java.utils.* namespace as Scanner - it's up to you whether to use that or loop through the array and print each value manually", "label": {"api": {"Arrays.print": [[0, 11]]}}}, {"text": "You can use the LocalTime class to store your time, and add n minutes to it", "label": {"api": {"LocalTime": [[16, 24]]}}}, {"text": "To store \"15 minutes\", you can use the Duration class", "label": {"api": {"Duration": [[39, 46]]}}}, {"text": "It would be easier to read if you use String.format() and single quotes  to generate the a tag", "label": {"api": {"String.format()": [[38, 52]]}}}, {"text": "One way to do it in Java is to use one of URLEncoder's encode methods", "label": {"api": {"URLEncoder": [[42, 51]]}}}, {"text": "Saying all the above the method should be written using java.time.Month as", "label": {"api": {"java.time.Month": [[56, 70]]}}}, {"text": "Check substring(int beginIndex) and substring(int beginIndex, int endIndex)", "label": {"api": {"substring(int beginIndex)": [[6, 30]], "substring(int beginIndex, int endIndex)": [[36, 74]]}}}, {"text": "This can be done in a single statement using removeIf()", "label": {"api": {"removeIf()": [[45, 54]]}}}, {"text": "I was thinking the regex is incorrect or not supported by Freemarker, but the docs link directly to OracleRegexPattern docs so I think that's OK", "label": {"api": {"OracleRegexPattern docs": [[100, 122]]}}}, {"text": "You can get a list of all Fields in each class and then compare two Fields' values only if they have the same name", "label": {"api": {"Fields": [[26, 31], [68, 73]]}}}, {"text": "You need to use Thread.join after you start the first addition thread, so that the main thread will wait until the addition thread has completed fully and only then the subtraction thread will be started", "label": {"api": {"Thread.join": [[16, 26]]}}}, {"text": "You could on the other hand use List.replaceAll as", "label": {"api": {"List.replaceAll": [[32, 46]]}}}, {"text": "Here's the javadoc of parse() method and this is what it says", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "Look at the Javadoc for TreeSet()", "label": {"api": {"Javadoc for TreeSet()": [[12, 32]]}}}, {"text": "You need to use ProcessBuilder to define output instead of using cmd > redirect operator", "label": {"api": {"ProcessBuilder": [[16, 29]]}}}, {"text": "With Java-9 and above you could simply chain such Optionals using Optional.or as", "label": {"api": {"Optional.or": [[66, 76]]}}}, {"text": "If you need more control, then you would be better off putting a af:chooseDate into a af:popup and launch it your self using af:showPopupBehavior for triggerType click and aignId set the the input field", "label": {"api": {"af:chooseDate": [[65, 77]], "af:popup": [[86, 93]], "af:showPopupBehavior": [[125, 144]]}}}, {"text": "Experiment with different values of align attribute as explained in the tag docs", "label": {"api": {"tag docs": [[72, 79]]}}}, {"text": "When you call the forEach method, that is a terminal operation on the stream", "label": {"api": {"the forEach method": [[14, 31]]}}}, {"text": "Use the map method", "label": {"api": {"the map method": [[4, 17]]}}}, {"text": "The basic data structures that are key/value lookups are just Java Maps (usually the LinkedHashMap implementation in Groovy)", "label": {"api": {"Map": [[67, 69], [95, 97]]}}}, {"text": "Your first-level association seems to be something like a Map<Integer, Employee>", "label": {"api": {"Map": [[58, 60]]}}}, {"text": "According to https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html the Stack class is derived like this", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html": [[13, 74]]}}}, {"text": "I suggest you read up on the Scanner", "label": {"api": {"Scanner": [[29, 35]]}}}, {"text": "In that case, we can always use Map#keySet() method to list all properties and we do not need any String[] to keep them", "label": {"api": {"Map#keySet()": [[32, 43]]}}}, {"text": "A way to sort this out would be to convert the Part into an InputStream and convert that into a byte[], which is understood by a SerialBlob, which is usable as a Blob - a bit of a long route", "label": {"api": {"SerialBlob": [[129, 138]]}}}, {"text": "The easiest way in Java 8 or later is with Collection#removeIf", "label": {"api": {"Collection#removeIf": [[43, 61]]}}}, {"text": "Use a TreeSet, which by default uses compareTo(), unlike a HashSet, which uses equals() and hashCode()", "label": {"api": {"TreeSet": [[6, 12]], "HashSet": [[59, 65]]}}}, {"text": "Take a look at CompletableFuture, available since Java 8", "label": {"api": {"CompletableFuture": [[15, 31]]}}}, {"text": "You can do this using a StringTokenizer that will extract words based on a list of delimiters", "label": {"api": {"StringTokenizer": [[24, 38]]}}}, {"text": "The main drawback of this implementation is that StringTokenizer requires you to list all the delimiters by hand", "label": {"api": {"StringTokenizer": [[49, 63]]}}}, {"text": "said, you should use a Set<E>", "label": {"api": {"Set<E>": [[23, 28]]}}}, {"text": "The implementing class HashSet<E> actually uses a HashMap<K,V> under the hood, as mentioned by Ole V.V., but using a Set<E> in your code is the better approach IMO, because your problem does not require the values", "label": {"api": {"Set<E>": [[27, 32], [117, 122]], "HashSet<E>": [[23, 32]]}}}, {"text": "You can use thenCompose()", "label": {"api": {"thenCompose()": [[12, 24]]}}}, {"text": "If you want a timeout while waiting for an event you need to use WatchService.poll(long,TimeUnit)", "label": {"api": {"WatchService.poll(long,TimeUnit)": [[65, 96]]}}}, {"text": "It also returns an Optional rather than using a Consumer", "label": {"api": {"Optional": [[19, 26]]}}}, {"text": "As an aside, your code uses take() and checks if it returns null", "label": {"api": {"take()": [[28, 33]]}}}, {"text": "Have a look at BigDecimal instead", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "From the documentation for Arrays.binarySearch", "label": {"api": {"Arrays.binarySearch": [[27, 45]]}}}, {"text": "It looks to me like it's impossible to include Integer.MAX_VALUE and Long.MAX_VALUE as possible random values when you create an IntStream or LongStream using bounds with the java.util.Random class", "label": {"api": {"java.util.Random": [[175, 190]]}}}, {"text": "But in the doc of Class DateTimeFormatter in Predefined Formatters section, I can't see any formatter that matches the SWAPI dates example", "label": {"api": {"Class DateTimeFormatter": [[18, 40]]}}}, {"text": "For your implementation of KeyListener..", "label": {"api": {"KeyListener": [[27, 37]]}}}, {"text": "Besides using java.nio as suggested by @Basil, simply wrapping the FileReader by a BufferedReader should achieve a significant speedup", "label": {"api": {"BufferedReader": [[83, 96]]}}}, {"text": "There is a difference between replace and replaceFirst", "label": {"api": {"replace": [[30, 36], [42, 48]], "replaceFirst": [[42, 53]]}}}, {"text": "See how replace accepts a plain old target whereas replaceFirst accepts a regex", "label": {"api": {"replace": [[8, 14], [51, 57]], "replaceFirst": [[51, 62]]}}}, {"text": "replace doesn't treat the strings you pass in as regexes", "label": {"api": {"replace": [[0, 6]]}}}, {"text": "If you want to use replace, just use \"(\"", "label": {"api": {"replace": [[19, 25]]}}}, {"text": "Perhaps something as simple as a java.util.concurrent.LinkedTransferQueue would work just as well, and be less error-prone", "label": {"api": {"java.util.concurrent.LinkedTransferQueue": [[33, 72]]}}}, {"text": "The matches() method check for full string match so instead of that use find() method which checks for subsequence match", "label": {"api": {"matches()": [[4, 12]], "find()": [[72, 77]]}}}, {"text": "Finally, you can use group() method to get matched subsequence string", "label": {"api": {"group()": [[21, 27]]}}}, {"text": "To get TreeMap<Integer, Double> ratings you can use stream api with groupingBy and summingDouble as a downstream", "label": {"api": {"groupingBy": [[68, 77]], "summingDouble": [[83, 95]]}}}, {"text": "Have you tried adding an event filter for javafx.scene.input.KeyEvent that consumes the event", "label": {"api": {"consumes the event": [[75, 92]]}}}, {"text": "Use Blob.length() instead", "label": {"api": {"Blob.length()": [[4, 16]]}}}, {"text": "To get file name only you can use Path.getFileName", "label": {"api": {"Path.getFileName": [[34, 49]]}}}, {"text": "You can also use listFiles(FileFilter filter)", "label": {"api": {"listFiles(FileFilter filter)": [[17, 44]]}}}, {"text": "I would suggest to change the Layout and use a BorderPane", "label": {"api": {"BorderPane": [[47, 56]]}}}, {"text": "Using Jackson-XML-Mapper, the NIO-API and the Stream-API you can achieve your goal with few lines of code", "label": {"api": {"NIO-API": [[30, 36]], "Stream-API": [[46, 55]]}}}, {"text": "In JDBC terms \"insert\" equivalent is update therefore you need to choose Update Statement from the \"Query Type\" dropdown", "label": {"api": {"update": [[37, 42]]}}}, {"text": "To write exactly the correct number of bytes you can use DataOutputStream", "label": {"api": {"DataOutputStream": [[57, 72]]}}}, {"text": "No coming to why SimpleDateFormat is working, there is a method called setLenient(boolean lenient) if you pass hour which is greater than 12 without mentioning a in the pattern and AM/PM in the date string  an java.text.ParseException", "label": {"api": {"setLenient(boolean lenient)": [[71, 97]]}}}, {"text": "As you can see in the documentation, the date and time patterns of SimpleDateFormat don't provide things like 26th", "label": {"api": {"in the documentation": [[15, 34]]}}}, {"text": "You can use Map.of() from java9 that returns an immutable map", "label": {"api": {"Map.of()": [[12, 19]]}}}, {"text": "Open HotSpotDiagnosticMXBean and call dumpHeap() method", "label": {"api": {"HotSpotDiagnosticMXBean": [[5, 27]], "dumpHeap() method": [[38, 54]]}}}, {"text": "Then you can use Math.round(float a) that returns int and assign it to mark", "label": {"api": {"Math.round(float a)": [[17, 35]]}}}, {"text": "You can use Optional::orElse to return a default value", "label": {"api": {"Optional::orElse": [[12, 27]]}}}, {"text": "Use the comparator chain and reversed()", "label": {"api": {"reversed()": [[29, 38]]}}}, {"text": "Just call .reversed() on your Comparator", "label": {"api": {".reversed()": [[10, 20]]}}}, {"text": "awaitTermination \"Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first\" (copied from comments, thanks ptomli)", "label": {"api": {"awaitTermination": [[0, 15]]}}}, {"text": "This also validates the date using DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[35, 51]]}}}, {"text": "Note when you are using Collectors.toMap you can get IllegalStateException if you have duplicate keys", "label": {"api": {"Collectors.toMap": [[24, 39]]}}}, {"text": "You can use toMap(keyMapper, valueMapper, mergeFunction) instead", "label": {"api": {"toMap(keyMapper, valueMapper, mergeFunction)": [[12, 55]]}}}, {"text": "If the call takes a long time, the methods should return a Future (or a similar object) and be made asynchronously", "label": {"api": {"Future": [[59, 64]]}}}, {"text": "at Oracle where you can find tutorials how to set up a RESTful service on the server side or how you can access resources as a client", "label": {"api": {"as a client": [[122, 132]]}}}, {"text": "Then word.substring(a+1, b) will throw an error", "label": {"api": {"error": [[42, 46]]}}}, {"text": "You can try using createDirectories if you also want the parent directories to be created", "label": {"api": {"createDirectories": [[18, 34]]}}}, {"text": "You will need to use java.util.Date", "label": {"api": {"java.util.Date": [[21, 34]]}}}, {"text": "There is retainAll method that retains only the elements in this collection that are contained in the specified collection", "label": {"api": {"retainAll": [[9, 17]]}}}, {"text": "If the values are non-negative, one can immediately use a BitSet instead of a Set<Integer>", "label": {"api": {"BitSet": [[58, 63]]}}}, {"text": "Use a BitSet constructor with a probable capacity (like 10_000)", "label": {"api": {"BitSet": [[6, 11]]}}}, {"text": "I have looked into its documentation and found out how the XMLInputFactory instance is created (Link here)", "label": {"api": {"Link here": [[96, 104]]}}}, {"text": "The File constructor does not support prefixes for the pathname parameter", "label": {"api": {"constructor": [[9, 19]], "File": [[4, 7]]}}}, {"text": "That is the reason why the usage of prefixed pathname results in FileNotFoundException", "label": {"api": {"File": [[65, 68]]}}}, {"text": "The JDK classes URL and URI supports the usage of prefixes such as in file://ftp.yoyodyne.com/pub/files/foobar.txt or in http://java.sun.com/j2se/1.3/", "label": {"api": {"URL": [[16, 18]], "URI": [[24, 26]]}}}, {"text": "It is noteworthy that the File on one hand, and the different resource abstractions (the Spring one, the URL and URI) on the other one,  that they represents quite different concepts", "label": {"api": {"URL": [[105, 107]], "URI": [[113, 115]], "File": [[26, 29]]}}}, {"text": "But I wanted to mention the new classes Path, Paths, and Files", "label": {"api": {"Path, Paths, and Files": [[40, 61]]}}}, {"text": "In addition to that I would also mention that it looks like you trying to re-implement DataInputStream", "label": {"api": {"DataInputStream": [[87, 101]]}}}, {"text": "All you need to do is convert the string to a number in base 36 (Integer.valueOf, Integer.parseUnsignedInt), add one to it, and convert it to an upper case base-36 string (Integer.toString plus converting that to upper case)", "label": {"api": {"Integer.valueOf": [[65, 79]], "Integer.parseUnsignedInt": [[82, 105]], "Integer.toString": [[172, 187]]}}}, {"text": "You can create Consumer for each method", "label": {"api": {"Consumer": [[15, 22]]}}}, {"text": "You could use Java 9+ Collectors.flatMapping", "label": {"api": {"Collectors.flatMapping": [[22, 43]]}}}, {"text": "And yet another Java8+ way is to just not use streams, but use Map.computeIfAbsent instead", "label": {"api": {"Map.computeIfAbsent": [[63, 81]]}}}, {"text": "You can use Java Stream", "label": {"api": {"Java Stream": [[12, 22]]}}}, {"text": "(ORIGINAL ANSWER) Maybe an ExecutorService could help you", "label": {"api": {"ExecutorService": [[27, 41]]}}}, {"text": "You can either create an own ListCell for that to add some more data in the view or use the same as for the items", "label": {"api": {"ListCell": [[29, 36]]}}}, {"text": "If you are trying to access the standard JMS correlation ID, use \"JMSCorrelationID='\" + correlationID + \"'\" - see https://docs.oracle.com/javaee/6/api/javax/jms/Message.html for a full description of Message Selectors, search for \"Message header field references\"", "label": {"api": {"https://docs.oracle.com/javaee/6/api/javax/jms/Message.html": [[114, 172]]}}}, {"text": "Another one would be explicitly calling pack()", "label": {"api": {"pack()": [[40, 45]]}}}, {"text": "This can be done using Files.readAllBytes, this created a byte array directly from a file, and doesn't try to read it as an image", "label": {"api": {"Files.readAllBytes": [[23, 40]]}}}, {"text": "Collections sort is applicable with \"comparable\" Object (extends Comparable)", "label": {"api": {"sort": [[12, 15]]}}}, {"text": "or you can send sort method with second parameter with your own Comparator", "label": {"api": {"sort": [[16, 19]]}}}, {"text": "This is also used when using Collection.sort()", "label": {"api": {"Collection.sort()": [[29, 45]]}}}, {"text": "An initial attempt would be using Path as suitable", "label": {"api": {"Path": [[34, 37]]}}}, {"text": "The closest you could get would be to use a JMS QueueBrowser and iterate over the messages to count them", "label": {"api": {"JMS QueueBrowser": [[44, 59]]}}}, {"text": "Use the JMS API call receiveNoWait()", "label": {"api": {"receiveNoWait()": [[21, 35]]}}}, {"text": "From Java 8 upwards you can use the Duration class", "label": {"api": {"Duration": [[36, 43]]}}}, {"text": "With Collectors.partitioningBy you can get Map<Boolean, List<String>>", "label": {"api": {"Collectors.partitioningBy": [[5, 29]]}}}, {"text": "For example, UUID.randomUUID().toString() generates a type 4 UUID that can be used for naming files uniquely", "label": {"api": {"UUID.randomUUID().toString()": [[13, 40]]}}}, {"text": "You can use the stage.setX() and stage.setY() methods to set the window position manually", "label": {"api": {"stage.setX()": [[16, 27]], "stage.setY()": [[33, 44]]}}}, {"text": "One such class is, not surprisingly, the javafx.scene.control.Alert class", "label": {"api": {"javafx.scene.control.Alert": [[41, 66]]}}}, {"text": "Which uses IntStream::range to create a Stream of integers from 0 to a.length and then if the element of a at that index is odd, it will print it out", "label": {"api": {"IntStream::range": [[11, 26]]}}}, {"text": "Look at getArray with a mapping from SQL type to java class", "label": {"api": {"getArray": [[8, 15]]}}}, {"text": "You can use the inline embedded flag expression for multiline mode, (?m) and the embedded DOTALL flags, (?s) together", "label": {"api": {"embedded flag expression for multiline mode": [[23, 65]], "embedded DOTALL flags": [[81, 101]]}}}, {"text": "You could try using Java 8s functional interfaces like Function<T,R> and Lambdas", "label": {"api": {"Function<T,R>": [[55, 67]]}}}, {"text": "Use flatMapToInt instead of flatMap", "label": {"api": {"flatMapToInt": [[4, 15]]}}}, {"text": "The major thing in produces=\"text/html, ..., ...\" is MessageBodyWriter interface", "label": {"api": {"MessageBodyWriter": [[53, 69]]}}}, {"text": "https://docs.oracle.com/javaee/6/api/javax/persistence/GenerationType.html#AUTO states that the persistence provider will choose the most appropriate solution", "label": {"api": {"https://docs.oracle.com/javaee/6/api/javax/persistence/GenerationType.html#AUTO": [[0, 78]]}}}, {"text": "You can use Duration class to get the duration between two LocalTime values", "label": {"api": {"Duration": [[12, 19]]}}}, {"text": "You can implement a custom TemporalUnit that is based on an arbitrary (positive) Duration", "label": {"api": {"TemporalUnit": [[27, 38]], "Duration": [[81, 88]]}}}, {"text": "You can then use it like you use any built-in ChronoUnit, e.g", "label": {"api": {"ChronoUnit": [[46, 55]]}}}, {"text": "The BitSet \"implements  a vector of bits that grows as needed.\"", "label": {"api": {"\"implements  a vector of bits that grows as needed.\"": [[11, 62]]}}}, {"text": "A straightforward approach is to use ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[37, 63]]}}}, {"text": "All you need to do is use substring()", "label": {"api": {"substring()": [[26, 36]]}}}, {"text": "TableModelEvent contains row and column number and type of modification", "label": {"api": {"TableModelEvent": [[0, 14]]}}}, {"text": "If your string is potentially null, consider using StringUtils.trim() - the null-safe version of String.trim()", "label": {"api": {"String.trim()": [[97, 109]]}}}, {"text": "In Java 8, you can use Math.toIntExact and Arrays.stream to construct a nice one-liner", "label": {"api": {"Math.toIntExact": [[23, 37]], "Arrays.stream": [[43, 55]]}}}, {"text": "GSON has a builder that takes a Reader object", "label": {"api": {"Reader": [[32, 37]]}}}, {"text": "fromJson(Reader json, Class classOfT)", "label": {"api": {"Reader": [[9, 14]]}}}, {"text": "This means you can create a Reader from a URL and then pass it to Gson to consume the stream and do the deserialisation", "label": {"api": {"Reader": [[28, 33]]}}}, {"text": "You should almost always use a Collator for dictionary based sorting", "label": {"api": {"Collator for dictionary based sorting": [[31, 67]]}}}, {"text": "You can directly call the default sort method on the list like this", "label": {"api": {"sort": [[34, 37]]}}}, {"text": "See Arrays class in the Java library", "label": {"api": {"Java library": [[24, 35]]}}}, {"text": "With Java 7, a close() method has been added to URLClassLoader, which is exactly what OP was asking for", "label": {"api": {"close()": [[15, 21]]}}}, {"text": "However I want to provide alternatives using Java 8 Streams, that will give you more benefit if it is part of a pipeline for further processing", "label": {"api": {"Java 8 Streams": [[45, 58]]}}}, {"text": "Here's an alternate approach to modifying the TableCellRenderer of a table's JTableHeader", "label": {"api": {"JTableHeader": [[77, 88]]}}}, {"text": "Try Vector.toArray(new String[0])", "label": {"api": {"Vector.toArray(new String[0])": [[4, 32]]}}}, {"text": "I think that you should not override get(K key) method in your implementation, because of the reasons specified by Ed Staub in his comment and because you will break the contract of Map interface (this can potentially lead to some hard-to-find bugs)", "label": {"api": {"contract": [[170, 177]]}}}, {"text": "In Java 8, use Map.getOrDefault", "label": {"api": {"Map.getOrDefault": [[15, 30]]}}}, {"text": "Set.copyOf() returns an unmodifiable Set containing the elements of the given Collection", "label": {"api": {"Set.copyOf()": [[0, 11]]}}}, {"text": "Use java.lang.Character class methods", "label": {"api": {"java.lang.Character": [[4, 22]]}}}, {"text": "You have to list all of your subclasses in @XmlSeeAlso annotation of your parent class", "label": {"api": {"@XmlSeeAlso": [[43, 53]]}}}, {"text": "The annotation is called @WebListener", "label": {"api": {"@WebListener": [[25, 36]]}}}, {"text": "And you still have to implement ServletContextListener", "label": {"api": {"ServletContextListener": [[32, 53]]}}}, {"text": "See the Throwable.printStackTrace() documentation", "label": {"api": {"Throwable.printStackTrace() documentation": [[8, 48]]}}}, {"text": "First, see java.lang.annotation.Inherited", "label": {"api": {"java.lang.annotation.Inherited": [[11, 40]]}}}, {"text": "Note that, depending on the underlying implementation, the java.lang.Thread.State of a thread that is blocked in a native method may be reported as RUNNABLE, where A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor", "label": {"api": {"java.lang.Thread.State": [[59, 80]]}}}, {"text": "What would be the behavior of a Java program on getting OutOfMemoryError", "label": {"api": {"OutOfMemoryError": [[56, 71]]}}}, {"text": "java.util.TimeZone.setDefault() can be used to set a default time zone to be returned by getDefault()", "label": {"api": {"java.util.TimeZone.setDefault()": [[0, 30]]}}}, {"text": "How about using Boolean.parseBoolean() to do the conversion, like this", "label": {"api": {"Boolean.parseBoolean()": [[16, 37]]}}}, {"text": "or use isSurrogate, isLowSurrogate and isHighSurrogate methods of Character object to prevent alteration of a single char within the pair", "label": {"api": {"isSurrogate": [[7, 17]], "isLowSurrogate": [[20, 33]], "isHighSurrogate": [[39, 53]]}}}, {"text": "Since Java 8 there is a method in the standard library which does the exact thing that is showed in Chris' answer", "label": {"api": {"method in the standard library": [[24, 53]]}}}, {"text": "After calling shutdown on a ExecutorService, no new Task will be accepted", "label": {"api": {"no new Task will be accepted": [[45, 72]]}}}, {"text": "However, with Java 8 ForkJoinPool.awaitQuiescence was introduced", "label": {"api": {"ForkJoinPool.awaitQuiescence": [[21, 48]]}}}, {"text": "Be aware that ImageIO by default uses temporary files as cache when creating ImageInputStreams and ImageOutputStreams", "label": {"api": {"ImageInputStreams": [[77, 93]], "ImageOutputStreams": [[99, 116]]}}}, {"text": "This can be switched off by calling ImageIO.setUseCache(false)", "label": {"api": {"ImageIO.setUseCache(false)": [[36, 61]]}}}, {"text": "I am working with an application that is experiencing painting issues on some users computers when the mouse passes over the tabs in a JTabbedPane", "label": {"api": {"JTabbedPane": [[135, 145]]}}}, {"text": "They also occasionally have similar issues on other interactive components like JButtons", "label": {"api": {"JButton": [[80, 86]]}}}, {"text": "In particular, if you override paintComponent() and \"do not honor the opaque property, you will likely see visual artifacts.\" Finally, the default opacity setting of some components varies by Look & Feel, so the effect may be platform dependent", "label": {"api": {"paintComponent()": [[31, 46]]}}}, {"text": "You can use a CountDownLatch", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "If you need it for calculations, use java.lang.Math", "label": {"api": {"java.lang.Math": [[37, 50]]}}}, {"text": "However, types do inherit the annotations of their superclass if those annotations are @Inherited", "label": {"api": {"@Inherited": [[87, 96]]}}}, {"text": "Updated example; see also CellRendererPane and Make your apps fly", "label": {"api": {"CellRendererPane": [[26, 41]]}}}, {"text": "getTime() retrieves the milliseconds since Jan 1, 1970 GMT passed to the constructor", "label": {"api": {"getTime()": [[0, 8]]}}}, {"text": "I recommend initializing thread locals, in a ServletRequestListener", "label": {"api": {"thread locals": [[25, 37]], "ServletRequestListener": [[45, 66]]}}}, {"text": "ServletRequestListener has 2 methods", "label": {"api": {"ServletRequestListener": [[0, 21]]}}}, {"text": "Snapshot does not work with (invisible) WebView nodes", "label": {"api": {"WebView": [[40, 46]]}}}, {"text": "When taking a snapshot of a scene that contains a WebView node, wait for at least 2 frames before issuing the snapshot command", "label": {"api": {"WebView": [[50, 56]], "snapshot": [[14, 21], [110, 117]]}}}, {"text": "This can be done by using a counter in an AnimationTimer to skip 2 pulses and take the snapshot on the 3rd pulse", "label": {"api": {"snapshot": [[87, 94]], "AnimationTimer": [[42, 55]]}}}, {"text": "Once you have got your snapshot, you can convert the image to an awt BufferedImage and encode the image to format like png or jpg, using ImageIO", "label": {"api": {"snapshot": [[23, 30]], "BufferedImage": [[69, 81]], "ImageIO": [[137, 143]]}}}, {"text": "ImageIO is a decent, but reasonably basic, image processing API", "label": {"api": {"ImageIO": [[0, 6]]}}}, {"text": "Unsurprisingly, the output is false, thus breaking symmetry", "label": {"api": {"breaking symmetry": [[42, 58]]}}}, {"text": "I agree with previous answers that your code is not thread safe and while using ConcurrentHashMap would solve your problem, this is the perfect use case for ThreadLocal", "label": {"api": {"ThreadLocal": [[157, 167]]}}}, {"text": "A short introduction for ThreadLocal", "label": {"api": {"ThreadLocal": [[25, 35]]}}}, {"text": "ThreadLocal will internally hold a different instance of a class for each thread that accesses the ThreadLocal, therefor solving any concurrency issues", "label": {"api": {"ThreadLocal": [[0, 10], [99, 109]]}}}, {"text": "Additionally (depending on situation this could be good/bad), the value stored in a ThreadLocal can only be accessed by the thread that populated that value in the first place", "label": {"api": {"ThreadLocal": [[84, 94]]}}}, {"text": "If it is the first time the current thread is accessing ThreadLocal, the value will be null", "label": {"api": {"ThreadLocal": [[56, 66]]}}}, {"text": "Simple example of ThreadLocal that holds String values", "label": {"api": {"ThreadLocal": [[18, 28]]}}}, {"text": "You can also use System.lineSeparator()", "label": {"api": {"System.lineSeparator()": [[17, 38]]}}}, {"text": "You can use the .charAt(int) function with Strings to retrieve the char value at any index", "label": {"api": {".charAt(int)": [[16, 27]]}}}, {"text": "If you want to convert the String to a char array, try calling .toCharArray() on the String", "label": {"api": {".toCharArray()": [[63, 76]]}}}, {"text": "You can use the .charAt(int) function with Strings to retrieve the char value at any index", "label": {"api": {".charAt(int)": [[16, 27]]}}}, {"text": "If you want to convert the String to a char array, try calling .toCharArray() on the String", "label": {"api": {".toCharArray()": [[63, 76]]}}}, {"text": "I also wanted to share a really cool and handy link which I found that gives a reference to all the Javax constants in one place - https://docs.oracle.com/javaee/7/api/constant-values.html", "label": {"api": {"https://docs.oracle.com/javaee/7/api/constant-values.html": [[131, 187]]}}}, {"text": "Use a BlockingQueue, whose put() and take() methods are blocking calls", "label": {"api": {"BlockingQueue": [[6, 18]], "put()": [[27, 31]], "take()": [[37, 42]]}}}, {"text": "Neither the producers nor the consumers need to be Callable; Runnable will do", "label": {"api": {"Callable": [[51, 58]]}}}, {"text": "Using an Executor to tie it all together is a good idea", "label": {"api": {"Executor": [[9, 16]]}}}, {"text": "However, I cannot find a way in Java to return this as some sort of Time object within Java", "label": {"api": {"Time": [[68, 71]]}}}, {"text": "I believe ReentrantReadWriteLock (Java 5+) is just made for your requirements", "label": {"api": {"ReentrantReadWriteLock": [[10, 31]]}}}, {"text": "This is not supported by SimpleDateFormat until Java 7", "label": {"api": {"Java 7": [[48, 53]]}}}, {"text": "So, if you can upgrade to Java 7, then you can use the X to represent that time zone notation", "label": {"api": {"Java 7": [[26, 31]]}}}, {"text": "On Java 6 you would need to do some pattern matching and replacing on the JSON string first to replace the -07:00 part by the RFC 822 notation -0700 so that you can use Z", "label": {"api": {"Java 6": [[3, 8]]}}}, {"text": "java.lang.String.split splits on regular expressions, and", "label": {"api": {"java.lang.String.split": [[0, 21]]}}}, {"text": "You can join to the threads", "label": {"api": {"join": [[8, 11]]}}}, {"text": "The join blocks until the thread completes", "label": {"api": {"join": [[4, 7]]}}}, {"text": "Note that join throws an InterruptedException", "label": {"api": {"join": [[10, 13]]}}}, {"text": "You can use Threadf#join method for this purpose", "label": {"api": {"Threadf#join": [[12, 23]]}}}, {"text": "Store the Thread-objects into some collection (like a List or a Set), then loop through the collection once the threads are started and call join() on the Threads", "label": {"api": {"join()": [[141, 146]]}}}, {"text": "Another possibility is the CountDownLatch object, which is useful for simple situations", "label": {"api": {"CountDownLatch": [[27, 40]]}}}, {"text": "Upon completion of its task, each thread calls CountDownLatch.countDown() which decrements the internal counter", "label": {"api": {"CountDownLatch": [[47, 60]]}}}, {"text": "The main thread, after starting all others, should do the CountDownLatch.await() blocking call", "label": {"api": {"CountDownLatch": [[58, 71]]}}}, {"text": "The way how to check if restrictions apply is documented in the method Cipher.getMaxAllowedKeyLength", "label": {"api": {"Cipher.getMaxAllowedKeyLength": [[71, 99]]}}}, {"text": "I think it is better practice to use System.nanoTime() instead of System.currentTimeMillis(), as currentTimeMillis() relies on what time the system's clock is set to, which can be changed", "label": {"api": {"System.nanoTime()": [[37, 53]], "System.currentTimeMillis()": [[66, 91]]}}}, {"text": "Or is it due to Java's implementation of java.net.Socket class", "label": {"api": {"java.net.Socket": [[41, 55]]}}}, {"text": "JTable's JavaDoc has this to say about it", "label": {"api": {"JTable's JavaDoc": [[0, 15]]}}}, {"text": "JTable offers the methods convertColumnIndexToModel() and convertColumnIndexToView() that you can use to translate column numbers from one to the other", "label": {"api": {"convertColumnIndexToModel()": [[26, 52]], "convertColumnIndexToView()": [[58, 83]]}}}, {"text": "To start, look at the JavaCompiler API", "label": {"api": {"JavaCompiler API": [[22, 37]]}}}, {"text": "It may be worth mentioning that the AbstractProcessor (which is suggested by the javadoc of the Process class as a subclass which could be used by implementors) throws IllegalStateException if its init method is called more than once", "label": {"api": {"AbstractProcessor": [[36, 52]], "javadoc of the Process class": [[81, 108]], "init method": [[197, 207]]}}}, {"text": "You may also use the constructor taking a ModalityType like in this answer as this constructor is also new two Java 6 and supports unowned dialogs", "label": {"api": {"this constructor": [[78, 93]]}}}, {"text": "But you don’t need to create a subclass of JDialog to use this constructor", "label": {"api": {"this constructor": [[58, 73]]}}}, {"text": "Set the timeout on the socket and then catch java.net.SocketTimeoutException", "label": {"api": {"timeout on the socket": [[8, 28]]}}}, {"text": "instead of integer counter, or AtomicInteger or whatever, I've used an ExecutorService and each submitted task use a Semaphore shared across each file of one drive", "label": {"api": {"Semaphore": [[117, 125]]}}}, {"text": "If you are using Connection pool library like c3p0 then you can safely user CachedRowSet and its implementation CachedRowSetImpl", "label": {"api": {"CachedRowSet": [[76, 87], [112, 123]], "CachedRowSetImpl": [[112, 127]]}}}, {"text": "A CachedRowSet object is a disconnected rowset, which means that it makes use of a connection to its data source only briefly", "label": {"api": {"CachedRowSet": [[2, 13]]}}}, {"text": "The rest of the time, a CachedRowSet object is disconnected, including while its data is being modified", "label": {"api": {"CachedRowSet": [[24, 35]]}}}, {"text": "After creating your ServerSocket, you could add a ShutdownHook to close it on JVM termination, something like this", "label": {"api": {"ShutdownHook": [[50, 61]]}}}, {"text": "Invoking ServerSocket#close will terminate the blocking ServerSocket.accept call, causing it to throw a SocketException", "label": {"api": {"ServerSocket#close": [[9, 26]], "ServerSocket.accept": [[56, 74]]}}}, {"text": "If you are picking random array elements that need to be unpredictable, you should use java.security.SecureRandom rather than Random", "label": {"api": {"java.security.SecureRandom": [[87, 112]]}}}, {"text": "Not sure why, but using the @Resource annotation worked for me", "label": {"api": {"@Resource": [[28, 36]]}}}, {"text": "I've tried a simple Application in Netbeans that displays the Charset.defaultCharset(), and it returns \"UTF-8\"", "label": {"api": {"Charset.defaultCharset()": [[62, 85]]}}}, {"text": "You can use the SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "I aware this is an old question, but what about using Future.isDone()", "label": {"api": {"Future.isDone()": [[54, 68]]}}}, {"text": "You can use Double.compare; It compares the two specified double values", "label": {"api": {"Double.compare": [[12, 25]]}}}, {"text": "What you should do instead is to take a closer look at BigDecimal", "label": {"api": {"BigDecimal": [[55, 64]]}}}, {"text": "Perhaps, by reading the generated class into byte[] and using Classloader.defineClass(..) to resolve/construct a Class object", "label": {"api": {"Classloader.defineClass(..)": [[62, 88]]}}}, {"text": "JOptionPane.showInputDialog may be good enough if you are willing to leave how exactly the options are presented up to the UI", "label": {"api": {"JOptionPane.showInputDialog": [[0, 26]]}}}, {"text": "The Toolkit method getMenuShortcutKeyMask() is useful in this context", "label": {"api": {"getMenuShortcutKeyMask()": [[19, 42]]}}}, {"text": "With Java 8+ you can use the ints method of Random to get an IntStream of random values then distinct and limit to reduce the stream to a number of unique random values", "label": {"api": {"ints": [[29, 32]], "IntStream": [[61, 69]], "distinct": [[93, 100]], "limit": [[106, 110]]}}}, {"text": "If you want all (or a large amount) of the numbers in a range in a random order it might be more efficient to add all of the numbers to a list, shuffle it, and take the first n because the above example is currently implemented by generating random numbers in the range requested and passing them through a set (similarly to Rob Kielty's answer), which may require generating many more than the amount passed to limit because the probability of a generating a new unique number decreases with each one found", "label": {"api": {"limit": [[412, 416]]}}}, {"text": "First you need to explicitly flush the JSP writer via JspWriter#flush(), so that all preceding JSP template output really gets written to the writer of the servlet response", "label": {"api": {"JspWriter#flush()": [[54, 70]]}}}, {"text": "Then you can just pass ServletResponse#getWriter() to Throwable#printStackTrace()", "label": {"api": {"ServletResponse#getWriter()": [[23, 49]], "Throwable#printStackTrace()": [[54, 80]]}}}, {"text": "In Java, how would one employ PathIterator to iterate through the line segments that constrain an Area", "label": {"api": {"PathIterator": [[30, 41]], "Area": [[98, 101]]}}}, {"text": "The Area is bound only by lines (but curve support wouldn't hurt)", "label": {"api": {"Area": [[4, 7]]}}}, {"text": "Note that we're reading the process output line by line into our StringBuilder", "label": {"api": {"StringBuilder": [[65, 77]]}}}, {"text": "The ProcessBuilder class let's us submit the program name and the number of arguments to its constructor", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "You actually need to use the Desktop Java Class", "label": {"api": {"Desktop": [[29, 35]]}}}, {"text": "To include the trailing empty strings, use the other implementation of split", "label": {"api": {"split": [[71, 75]]}}}, {"text": "See KeyEvent API doc - notes section", "label": {"api": {"KeyEvent API doc": [[4, 19]]}}}, {"text": "The use of a Character#isISOControl is a good thing", "label": {"api": {"a Character#isISOControl": [[11, 34]]}}}, {"text": "And second, you can use GenericEntity to serialize a list", "label": {"api": {"GenericEntity": [[24, 36]]}}}, {"text": "And there are ways to get the size of a screen, too, such as those in http://docs.oracle.com/javase/6/docs/api/java/awt/Toolkit.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/awt/Toolkit.html": [[70, 131]]}}}, {"text": "You can use Character.toString(char)", "label": {"api": {"Character.toString(char)": [[12, 35]]}}}, {"text": "Note that this method simply returns a call to String.valueOf(char), which also works", "label": {"api": {"String.valueOf(char)": [[47, 66]]}}}, {"text": "String.valueOf(char) \"gets in the back door\" by wrapping the char in a single-element array and passing it to the package private constructor String(char[], boolean), which avoids the array copy", "label": {"api": {"String.valueOf(char)": [[0, 19]]}}}, {"text": "Use ImageIO.read(URL) or ImageIO.read(File) instead", "label": {"api": {"ImageIO.read(URL)": [[4, 20]], "ImageIO.read(File)": [[25, 42]]}}}, {"text": "Alternately, add a MediaTracker to the image being loaded asynchronously by the Toolkit and wait until it is completely loaded", "label": {"api": {"MediaTracker": [[19, 30]], "Toolkit": [[80, 86]]}}}, {"text": "See, for example, the Set.hashCode contract", "label": {"api": {"Set.hashCode": [[22, 33]]}}}, {"text": "On the other hand here's the contract of List.hashCode", "label": {"api": {"List.hashCode": [[41, 53]]}}}, {"text": "JPA relies on the ordinal() method when using the EnumType.ORDINAL modifier on your @Enumerated annotation", "label": {"api": {"EnumType.ORDINAL": [[50, 65]]}}}, {"text": "If you are using a MappedByteBuffer, then you might as well map the entire file in one go", "label": {"api": {"ByteBuffer": [[25, 34]]}}}, {"text": "Your more detailed, complex approach so far (and the corresponding answers here) are more suitable to a traditional ByteBuffer, in which you control explicitly what is read into memory from disk", "label": {"api": {"ByteBuffer": [[116, 125]]}}}, {"text": "The whole pattern represents a character class, [...], that contains a \\p{Punct} POSIX character class, the && intersection operator and [^...] negated character class", "label": {"api": {"POSIX character class": [[81, 101]], "intersection operator": [[111, 131]]}}}, {"text": "Both HashMap and ArrayList can be considered as array in PHP", "label": {"api": {"HashMap": [[5, 11]], "ArrayList": [[17, 25]]}}}, {"text": "ArrayList is indexed by number, and HashMap is collection of key value pairs - PHP does not differentiate those two situations", "label": {"api": {"HashMap": [[36, 42]], "ArrayList": [[0, 8]]}}}, {"text": "This particular declaration says that there is an ArrayList (number indexed array) and all its element are of type HashMap", "label": {"api": {"HashMap": [[115, 121]], "ArrayList": [[50, 58]]}}}, {"text": "For each HashMap, which is a collection of key/value pairs, the keys are of type String, and values are of type Object", "label": {"api": {"HashMap": [[9, 15]]}}}, {"text": "You can check this doc for more information", "label": {"api": {"this doc": [[14, 21]]}}}, {"text": "In Java, you have to use a Pattern and a Matcher from the java.util.regex package", "label": {"api": {"java.util.regex": [[58, 72]]}}}, {"text": "This is a pretty old question, but you could always implement your own Transport using the JavaMail API", "label": {"api": {"JavaMail API": [[91, 102]]}}}, {"text": "With your own transport, you could just configure it according to this documentation", "label": {"api": {"this documentation": [[66, 83]]}}}, {"text": "But today I read a little about RowSet and CachedRowset and I realized they can serve my purposes better", "label": {"api": {"CachedRowset": [[43, 54]]}}}, {"text": "See Networking Properties for more details on configuring behavior of the various classes of the java.net package", "label": {"api": {"Networking Properties": [[4, 24]]}}}, {"text": "If the Shape is meant to appear in another component, register the class containing that component as a TableModelListener using the addTableModelListener() method of your TableModel", "label": {"api": {"addTableModelListener()": [[133, 155]]}}}, {"text": "You would need to use reflection to instantiate a backing array T[] using Array.newInstance()", "label": {"api": {"Array.newInstance()": [[74, 92]]}}}, {"text": "I did this once with a Socket and a ServerSocket", "label": {"api": {"ServerSocket": [[36, 47]]}}}, {"text": "First, when you start your application, make a ServerSocket listen on some port, for example 4004", "label": {"api": {"ServerSocket": [[47, 58]]}}}, {"text": "If an instance is currently running, you might want to notify it by connecting a TCP Socket (which guarantees that your connection arrives; UDP doesn't)", "label": {"api": {"TCP Socket": [[81, 90]]}}}, {"text": "Java 7 introduced java.nio.file.Path as a possible replacement for java.io.File", "label": {"api": {"java.nio.file.Path": [[18, 35]]}}}, {"text": "Instead of relying on it read the documentation for JAXBContext.newInstance(...), see this answer and the comments below", "label": {"api": {"JAXBContext.newInstance(...)": [[52, 79]]}}}, {"text": "DefaultMutableTreeNode supports several traversals, using any one of them to reach your goal is left (no pun intended, it's by the api :) to the user", "label": {"api": {"DefaultMutableTreeNode": [[0, 21]]}}}, {"text": "The easiest way to check is to use File.canWrite()", "label": {"api": {"File.canWrite()": [[35, 49]]}}}, {"text": "Also, the ActionEvent#getActionCommand() returns the command string associated with the action not extacly the text of command-component", "label": {"api": {"ActionEvent#getActionCommand()": [[10, 39]]}}}, {"text": "One way is to first convert it into a Date using SimpleDateFormat and its parse method (The javadoc will explain the format you need)", "label": {"api": {"SimpleDateFormat": [[49, 64]]}}}, {"text": "If you want to get more rows in the local memory than usual, you may consider CachedRowSet", "label": {"api": {"CachedRowSet": [[78, 89]]}}}]