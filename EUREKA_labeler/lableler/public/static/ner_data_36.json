[{"text": "These numbers come from the official Boolean API", "label": {"api": {"Boolean API": [[37, 47]]}}}, {"text": "They're apparently short-cutting calling the Java core Boolean class hashCode() results", "label": {"api": {"Boolean class hashCode() results": [[55, 86]]}}}, {"text": "See the API docs for Container.add", "label": {"api": {"Container.add": [[21, 33]]}}}, {"text": "I noticed a few packages related to trees, such as these", "label": {"api": {"these": [[51, 55]]}}}, {"text": "You need to use Collection<Part> parts = request.getParts(); method to read request params", "label": {"api": {"request": [[41, 47], [76, 82]]}}}, {"text": "However, for TCP, if you override the service method in the servlet and handle the \"CONNECT\" verb, you can then read from and write to the input and output streams", "label": {"api": {"service": [[38, 44]]}}}, {"text": "You can use the Java Timer class to schedule such (or any) task at a fixed rate (5-10 secs in your case)", "label": {"api": {"Timer": [[21, 25]]}}}, {"text": "You can use Java Timer for scheduling", "label": {"api": {"Timer": [[17, 21]]}}}, {"text": "To reload/refresh the URL, you can initiate a java HTTP request by using java.net.HttpUrlConnection", "label": {"api": {"java.net.HttpUrlConnection": [[73, 98]]}}}, {"text": "This is why sometimes no data is written in the file if you didn't call flush method", "label": {"api": {"flush": [[72, 76]]}}}, {"text": "Calling flush method will cause the data to be written in the file even the buffer is not filled completely", "label": {"api": {"flush": [[8, 12]]}}}, {"text": "A LinkedList in Java works just as you would expect it to do", "label": {"api": {"LinkedList": [[2, 11]], "List": [[8, 11]]}}}, {"text": "If you use the official Collections LinkedList then it will indeed be a a bunch of object connected to each other by having a 'next' and sometimes 'previous'", "label": {"api": {"LinkedList": [[36, 45]], "List": [[42, 45]]}}}, {"text": "And yes, it has a get(int index) method which is surprising because it would not be very efficient as you would need to start at the beginning and count your way up the list to find the indexth entry and this is not what LinkedLists are good at", "label": {"api": {"LinkedList": [[221, 230]], "List": [[227, 230]]}}}, {"text": "The reason it is there is because LinkedList implements the List interface", "label": {"api": {"LinkedList": [[34, 43]], "List": [[40, 43], [60, 63]]}}}, {"text": "However, you would probably try to avoid using a LinkedList when most of your access to it is through the get(int index) method as that would clearly be most inefficient", "label": {"api": {"LinkedList": [[49, 58]], "List": [[55, 58]]}}}, {"text": "You would be perhaps better to use an ArrayList", "label": {"api": {"List": [[43, 46]], "ArrayList": [[38, 46]]}}}, {"text": "You should use Connection.setAutoCommit(false) to disable auto-commit and Connection.commit() and Connection.rollback()", "label": {"api": {"Connection.setAutoCommit(false)": [[15, 45]], "Connection.commit()": [[74, 92]], "Connection.rollback()": [[98, 118]]}}}, {"text": "For this particular problem, you should look at using a NumberFormat instead (e.g", "label": {"api": {"NumberFormat": [[56, 67]]}}}, {"text": "DecimalFormat) - but again, I'd strongly advise you to do this as part of recompiling on Java 1.3, or upgrading to a more recent version of Java", "label": {"api": {"DecimalFormat": [[0, 12]]}}}, {"text": "Use URL.toURI() (Android doc) method", "label": {"api": {"URL.toURI()": [[4, 14]]}}}, {"text": "Make sure to handle relevant exception, such as URISyntaxException", "label": {"api": {"URISyntaxException": [[48, 65]]}}}, {"text": "You set the position using the (inherited) Buffer.position(int newPosition) method", "label": {"api": {"Buffer.position(int newPosition)": [[43, 74]]}}}, {"text": "Combine Random.nextBytes(byte[]) with BigInteger(byte[])", "label": {"api": {"Random.nextBytes(byte[])": [[8, 31]], "BigInteger(byte[])": [[38, 55]]}}}, {"text": "String.trim() is your friend", "label": {"api": {"String.trim()": [[0, 12]]}}}, {"text": "In the future, I highly recommend checking the Java String methods in the API", "label": {"api": {"API": [[74, 76]]}}}, {"text": "ServerSocket doesn't have that method", "label": {"api": {"ServerSocket": [[0, 11]], "Socket": [[6, 11]]}}}, {"text": "Note how this is actually using the return value of ServerSocket.accept(), which is a Socket - and Socket does have those methods", "label": {"api": {"ServerSocket": [[52, 63]], "Socket": [[58, 63], [86, 91], [99, 104]]}}}, {"text": "the compiler told you exactly what you were doing wrong - trying to call a getOutputStream method on ServerSocket", "label": {"api": {"ServerSocket": [[101, 112]], "Socket": [[107, 112]]}}}, {"text": "Your immediate first port of call after seeing that compiler error should have been the Javadoc for ServerSocket - which would have allowed you to confirm that it really didn't exist", "label": {"api": {"ServerSocket": [[100, 111]], "Socket": [[106, 111]]}}}, {"text": "There is no getOutputStream method for the ServerSocket class, link here", "label": {"api": {"link here": [[63, 71]]}}}, {"text": "and then you'll find that the Socket class does have the method you're after", "label": {"api": {"the method you're after": [[53, 75]]}}}, {"text": "I've tried using KeyboardFocusManager to listen for input focus changes, and then calling scrollRectToVisible", "label": {"api": {"KeyboardFocusManager": [[17, 36]], "scrollRectToVisible": [[90, 108]]}}}, {"text": "It does get the focus change notifications, but the call to scrollRectToVisible doesn't appear to have any effect", "label": {"api": {"scrollRectToVisible": [[60, 78]]}}}, {"text": "In my app (which is too complex to show here), scrollRectToVisible works about half the time when I tab into something outside of the viewport", "label": {"api": {"scrollRectToVisible": [[47, 65]]}}}, {"text": "You should use a FileHandler", "label": {"api": {"FileHandler": [[17, 27]]}}}, {"text": "You need to get the JTable's selection model (using getSelectionModel()) and add a ListSelectionListener to this model", "label": {"api": {"getSelectionModel()": [[52, 70]]}}}, {"text": "Make sure to use convertRowIndexToModel to convert the index of the selected row to an index in the table model", "label": {"api": {"convertRowIndexToModel": [[17, 38]]}}}, {"text": "You could also use BufferedReader", "label": {"api": {"BufferedReader": [[19, 32]]}}}, {"text": "Void is an uninstantiable placeholder class, so it's a good choice for variables which will only ever be null", "label": {"api": {"an uninstantiable placeholder class": [[8, 42]]}}}, {"text": "That isn't a valid argument for constructing an InputStreamReader", "label": {"api": {"InputStreamReader": [[48, 64]]}}}, {"text": "You need to create the InputStream and pass that to the InputStreamReader", "label": {"api": {"InputStreamReader": [[56, 72]]}}}, {"text": "However, the best way to do this is to use a FileReader", "label": {"api": {"FileReader": [[45, 54]]}}}, {"text": "Better yet, stop reinventing the wheel and writing nasty boilerplate code and just use the built-in ObjectOutputStream and ObjectInputStream classes that the language provides to do this sort of thing", "label": {"api": {"ObjectOutputStream": [[100, 117]], "ObjectInputStream": [[123, 139]]}}}, {"text": "you can check these links for Threads & Progress Bar in Java", "label": {"api": {"Threads": [[30, 36]]}}}, {"text": "AudioSystem.getAudioFileFormat() will return all the data you need about a WAV file, or any other supported by the standart java library", "label": {"api": {"AudioSystem.getAudioFileFormat()": [[0, 31]]}}}, {"text": "ImageIO.read() will load the file into a BufferedImage and you can get all the properties from it", "label": {"api": {"BufferedImage": [[41, 53]]}}}, {"text": "You can use BufferedImage, as shown in this example", "label": {"api": {"BufferedImage": [[12, 24]]}}}, {"text": "The example cited updates the image's underlying WritableRaster using an int array of color components, but setRGB() is convenient if the color is already available", "label": {"api": {"WritableRaster": [[49, 62]], "setRGB()": [[108, 115]]}}}, {"text": "You could use a WatchService to watch for changes on the file (I think) or just periodically check to see if the file has changed", "label": {"api": {"WatchService": [[16, 27]]}}}, {"text": "Class.forName loads a driver class", "label": {"api": {"Class.forName": [[0, 12]]}}}, {"text": "Which is part of the Java Persistence API", "label": {"api": {"Java Persistence API": [[21, 40]]}}}, {"text": "For writing to a file see the FileWriter class", "label": {"api": {"FileWriter": [[30, 39]]}}}, {"text": "I would recommend reading the javadoc of ThreadPoolExecutor with great attention, because the behavior of such a pool regarding to queuing is important to understand if you want to avoid problems", "label": {"api": {"javadoc of ThreadPoolExecutor": [[30, 58]]}}}, {"text": "The JDK has Executors, which provides factory methods which should give you correctly configured pools", "label": {"api": {"Executors": [[12, 20]]}}}, {"text": "I would probably subclass a BlockingQueue such as the ArrayBlockingQueue and add a simple CountDownLatch which is initialized to the threshold value and enables the various take/remove methods when reaching 0", "label": {"api": {"ArrayBlockingQueue": [[54, 71]]}}}, {"text": "For more information see the JDK API for this constructor", "label": {"api": {"JDK API for this constructor": [[29, 56]]}}}, {"text": "If this is about listening for user scrolls, you can do it by adding a MouseWheelListener to your control", "label": {"api": {"MouseWheelListener": [[71, 88]]}}}, {"text": "You can do this with the Desktop.browse(URI) method", "label": {"api": {"Desktop.browse(URI)": [[25, 43]]}}}, {"text": "Invoking setModel() on the table should be sufficient, but you might call fireTableStructureChanged() on the model explicitly as a way to help sort things out", "label": {"api": {"setModel()": [[9, 18]]}}}, {"text": "Based on what i understand from your code, I will probably recommend the use of SwingWorker", "label": {"api": {"SwingWorker": [[80, 90]]}}}, {"text": "I know you do not have any cost expensive code but you using SwingWorker, you will be able to update your GUI more easily", "label": {"api": {"SwingWorker": [[61, 71]]}}}, {"text": "In the documentation for SecureRandom it says", "label": {"api": {"documentation for SecureRandom": [[7, 36]]}}}, {"text": "I would use a ConcurrentLinkedQueue<Listener> which is made for this kind of problems", "label": {"api": {"ConcurrentLinkedQueue<Listener>": [[14, 44]]}}}, {"text": "If you have a stream, you can use http://docs.oracle.com/javase/1.4.2/docs/api/java/io/FilterInputStream.html or http://docs.oracle.com/javase/1.4.2/docs/api/java/io/FilterOutputStream.html to redirect the streamcontent to your client and the file at the same time", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/io/FilterInputStream.html": [[34, 108]], "http://docs.oracle.com/javase/1.4.2/docs/api/java/io/FilterOutputStream.html": [[113, 188]]}}}, {"text": "You can use BitSet", "label": {"api": {"BitSet": [[12, 17]]}}}, {"text": "And then write a full byte array using FileOutputStream#write(byte\\[\\]) like that", "label": {"api": {"FileOutputStream#write(byte\\[\\])": [[39, 70]]}}}, {"text": "StandardWatchEventKinds.ENTRY_MODIFY is the event you are looking for", "label": {"api": {"StandardWatchEventKinds.ENTRY_MODIFY": [[0, 35]]}}}, {"text": "Alternatively, you may be able to use getSubimage() on the BufferedImage returned by the getImage method of PImage", "label": {"api": {"getSubimage()": [[38, 50]]}}}, {"text": "If Game is an interface or implements an interface with the method act() you can use Proxy for that", "label": {"api": {"Proxy": [[85, 89]]}}}, {"text": "If you can code against interface, then you may use Java dynamic proxy to create a proxy object which overrides the behavior, like the example below", "label": {"api": {"Java dynamic proxy": [[52, 69]]}}}, {"text": "I can't believe there's no BitSet solution", "label": {"api": {"BitSet": [[27, 32]]}}}, {"text": "A BitSet is an abstraction over a set of bits so we don't have to use boolean[] for more advanced interactions anymore, because it already contains most of the needed methods", "label": {"api": {"BitSet": [[2, 7]]}}}, {"text": "For your particular case, I'd use cardinality()", "label": {"api": {"cardinality()": [[34, 46]]}}}, {"text": "Since Java 9, it is possible to use Map.of(...), like so", "label": {"api": {"Map.of(...)": [[36, 46]]}}}, {"text": "You need to use setResizeWeight to get the left and right take the extra space or reduce in size on JFrame resize, sample code below", "label": {"api": {"setResizeWeight": [[16, 30]]}}}, {"text": "Java Doc for setResizeWeight", "label": {"api": {"setResizeWeight": [[13, 27]]}}}, {"text": "You can use toCharArray() method of String class", "label": {"api": {"toCharArray()": [[12, 24]]}}}, {"text": "You can use BigDecimal.unscaledValue()", "label": {"api": {"BigDecimal.unscaledValue()": [[12, 37]]}}}, {"text": "In case you're restricted to legacy java.util.Date and java.util.Calendar APIs, you need to take into account that the timestamps are interpreted in milliseconds, not seconds", "label": {"api": {"java.util.Date": [[36, 49]]}}}, {"text": "the constructor of java.util.Date and finally use SimpleDateFormat to convert a java.util.Date to java.lang.String in the desired date format pattern, if necessary with a predefined time zone (otherwise it would use the system default time zone, which is not GMT/UTC per se and thus the formatted time might be off)", "label": {"api": {"java.util.Date": [[19, 32], [80, 93]], "SimpleDateFormat": [[50, 65]], "default time zone": [[227, 243]]}}}, {"text": "In case you're already on Java8, there's a LocalDateTime#ofEpochSecond() which allows you to feed epoch seconds directly without the need for multiplying into milliseconds flavor", "label": {"api": {"LocalDateTime#ofEpochSecond()": [[43, 71]]}}}, {"text": "As Matthew says in a comment, you should read the API", "label": {"api": {"the API": [[46, 52]]}}}, {"text": "If you check the Java API for InputStream, you'll see that the 'return' value for InputStream.read(byte[], int, int) is described as", "label": {"api": {"check the Java API for InputStream": [[7, 40]]}}}, {"text": "But, for the record, if you really only need one byte at a time, the InputStream.read() method will do the trick", "label": {"api": {"InputStream.read()": [[69, 86]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/lang/String.html shows how these methods function and gives you other options as well..", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[0, 61]]}}}, {"text": "The methods Calendar.getTimeInMillis() and Date.getTime() both return milliseconds since 1.1.1970", "label": {"api": {"Calendar.getTimeInMillis()": [[12, 37]], "Date.getTime()": [[43, 56]]}}}, {"text": "Note that the month field of Calendar is zero-based, i.e", "label": {"api": {"month field of Calendar": [[14, 36]]}}}, {"text": "Regarding implementing the cache you can choose http://docs.oracle.com/javase/6/docs/api/java/util/WeakHashMap.html or you can have bounded LRU cache implemented", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/WeakHashMap.html": [[48, 114]]}}}, {"text": "Rather than use any synchronization primitives I'd recommend using something like the AtomicInteger class to leverage a CAS (compare-and-swap) operation for your anti-concurrency strategy", "label": {"api": {"AtomicInteger": [[86, 98]]}}}, {"text": "A much cleaner and scalable way to do this is to use a thread pool created by the Executors class", "label": {"api": {"Executors": [[82, 90]]}}}, {"text": "Java has the ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[13, 33]]}}}, {"text": "I believe StringWriter is what you're looking for", "label": {"api": {"StringWriter": [[10, 21]]}}}, {"text": "Use Collections.shuffle() on the List and remove() the first four or five", "label": {"api": {"Collections.shuffle()": [[4, 24]]}}}, {"text": "Set Graphics2D.setComposite(AlphaComposite) prior to drawing the Image", "label": {"api": {"Graphics2D.setComposite(AlphaComposite)": [[4, 42]]}}}, {"text": "Use a Scanner to parse the file data", "label": {"api": {"Scanner": [[6, 12]]}}}, {"text": "Note that Scanner.next returns the next token separated by white space (the default delimiter), so your file data must be formatted that way", "label": {"api": {"Scanner": [[10, 16]], "Scanner.next": [[10, 21]]}}}, {"text": "I would use Collections.shuffle() and a sublist", "label": {"api": {"Collections.shuffle()": [[12, 32]]}}}, {"text": "This has been deprecated since 1998 (see JDK 1.3 TimeZone)", "label": {"api": {"JDK 1.3 TimeZone": [[41, 56]]}}}, {"text": "The parse(String) method of DocumentBuilder is expecting an URL as the parameter, not the XML content as a String", "label": {"api": {"parse(String)": [[4, 16]]}}}, {"text": "You need to write a FilterInputStream to filter the data before the SAX parser gets it", "label": {"api": {"FilterInputStream": [[20, 36]]}}}, {"text": "You can create a class which implements HttpSessionListner interface and, implement sessionCreated(HttpSessionEvent se) and sessionDestroyed(HttpSessionEvent se) methods", "label": {"api": {"HttpSessionListner": [[40, 57]], "sessionCreated(HttpSessionEvent se)": [[84, 118]], "sessionDestroyed(HttpSessionEvent se)": [[124, 160]], "HttpSessionEvent": [[99, 114], [141, 156]]}}}, {"text": "You can get the session from HttpSessionEvent's getSession() method", "label": {"api": {"HttpSessionEvent": [[29, 44]], "getSession()": [[48, 59]]}}}, {"text": "In Java EE applications (like GAE) you usually do things like that in the contextInitialized method of a ServletContextListener that you declare in your web.xml", "label": {"api": {"ServletContextListener": [[105, 126]]}}}, {"text": "The string.split(String regex) method should do what you need", "label": {"api": {"split(String regex)": [[11, 29]]}}}, {"text": "Hi all I need to do some text measuring using java.awt.font.FontRenderContext, however this class requires me to supply a graphics object", "label": {"api": {"java.awt.font.FontRenderContext": [[46, 76]]}}}, {"text": "TextLayout may be useful in this context", "label": {"api": {"TextLayout": [[0, 9]]}}}, {"text": "Bytecode can easily be rewritten \"on disc\" before loading, or at runtime using the instrumentation API and -javaagent", "label": {"api": {"instrumentation API": [[83, 101]]}}}, {"text": "However, you can use Arrays.asList instead to accomplish the same", "label": {"api": {"Arrays.asList": [[21, 33]]}}}, {"text": "Then, in the event handler for your 'set read only' button, loop over that collection and call setReadOnly() on each File", "label": {"api": {"setReadOnly()": [[95, 107]]}}}, {"text": "There doesn't seem to be any information readily available apart from the recommendation that a PersistenceService implementation \"provides methods to get the current storage usage and limits and to request more storage\", but I can't find any such methods in the javadocs..", "label": {"api": {"provides methods to get the current storage usage and limits and to request more storage": [[131, 218]]}}}, {"text": "The FileContents class has getMaxLength and setMaxLength methods but the descriptions of these are ambiguous and seem to imply (to me) that the client app can set the max length", "label": {"api": {"FileContents": [[4, 15]]}}}, {"text": "Alternatively, and this is probably the best approach, use the new standard feature for this that comes with Java 7, WatchService, as discussed here", "label": {"api": {"WatchService": [[117, 128]]}}}, {"text": "To tackle this requirement I used a BitSet", "label": {"api": {"BitSet": [[36, 41]]}}}, {"text": "The method nextClearBit() can find the next available value", "label": {"api": {"nextClearBit()": [[11, 24]]}}}, {"text": "Which can't be managed with a BitSet (it would, by itself, consume around 600Mb, plus be limited to int - 32 bits signed - range)", "label": {"api": {"BitSet": [[30, 35]]}}}, {"text": "In addition to @mKorbel's informative links and @Shakedown's comment, consider using SwingWorker to periodically rendevous with your middle tier and update your TreeModel, perhaps in response to a Timer", "label": {"api": {"SwingWorker": [[85, 95]], "Timer": [[197, 201]]}}}, {"text": "See Method.getGenericParameterTypes for example", "label": {"api": {"Method.getGenericParameterTypes": [[4, 34]]}}}, {"text": "In plain Java, the thing to do in a situation like that is to create an interface-based proxy that handles the method invocation and delegates to the original object (or not)", "label": {"api": {"interface-based proxy": [[72, 92]]}}}, {"text": "The following methods are available on java.lang.Class", "label": {"api": {"java.lang.Class": [[39, 53]]}}}, {"text": "Whenever you need date along with timezone information use Calendar instead", "label": {"api": {"Calendar": [[59, 66]]}}}, {"text": "For arrays, use java.lang.reflect.Array instead of java.lang.reflect.Field", "label": {"api": {"java.lang.reflect.Array": [[16, 38]]}}}, {"text": "Check out java.util.concurrent, it has what you're looking for", "label": {"api": {"java.util.concurrent": [[10, 29]]}}}, {"text": "Besides synchronization with ReentrantReadWriteLock, AtomicReferences, and Collections.synchronizedList may help you", "label": {"api": {"ReentrantReadWriteLock": [[29, 50]], "AtomicReferences": [[53, 68]], "Collections.synchronizedList": [[75, 102]]}}}, {"text": "Chop your String up into lengths of 8 and call Byte#parseByte", "label": {"api": {"Byte#parseByte": [[47, 60]]}}}, {"text": "JTabbedPane is already implemented for you", "label": {"api": {"JTabbedPane": [[0, 10]]}}}, {"text": "See ArrayList for more available methods", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "The most practical thing to use in this case are Stacks or Deques", "label": {"api": {"Stacks": [[49, 54]], "Deques": [[59, 64]]}}}, {"text": "Stacks do things pretty much the same way Deques do, but Deques are actually a bit more flexible and preferred over Stacks in coding", "label": {"api": {"Stacks": [[0, 5], [116, 121]], "Deques": [[42, 47], [57, 62]]}}}, {"text": "Unless your data is already in binary form, I wouldn't use DataInputStream", "label": {"api": {"DataInputStream": [[59, 73]]}}}, {"text": "The example below uses BufferedReader to compose org.jscience.mathematics.function.Polynomial", "label": {"api": {"BufferedReader": [[23, 36]]}}}, {"text": "As stated in Arrays.equals(byte[],byte[]) documentation", "label": {"api": {"Arrays.equals(byte[],byte[]) documentation": [[13, 54]]}}}, {"text": "Put a breakpoint on the execute() method of the Lifecycle implementation of your JSF implementation", "label": {"api": {"execute()": [[24, 32]], "Lifecycle": [[48, 56]]}}}, {"text": "To hook on render response as well, put another beakpoint on render() method of the same Lifecycle implementation", "label": {"api": {"Lifecycle": [[89, 97]], "render()": [[61, 68]]}}}, {"text": "In Mojarra, the Lifecycle implementation is the com.sun.faces.lifecycle.LifecycleImpl class", "label": {"api": {"Lifecycle": [[16, 24], [72, 80]]}}}, {"text": "As already mentioned, it's better to use java.util.Timer, but you can also use setRepeats() before starting", "label": {"api": {"setRepeats()": [[79, 90]]}}}, {"text": "The toString() method from objects returns soemthing like the class name plus a hashcode (see http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html#toString%28%29)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html#toString%28%29": [[94, 174]]}}}, {"text": "I have used the Stack implementation many times", "label": {"api": {"Stack": [[16, 20]]}}}, {"text": "Is there another Stack class available (by a different name perhaps) that is the one to choose", "label": {"api": {"Stack": [[17, 21]]}}}, {"text": "I mean, ok implementing a stack arround another existing data structure is easy, but I would expect there is an existing Stack to use", "label": {"api": {"Stack": [[121, 125]]}}}, {"text": "LinkedList implements push and pop methods", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "See also other Deque implementations", "label": {"api": {"Deque": [[15, 19]]}}}, {"text": "You can use LinkedList which implements the Deque interface and allows pushing and popping", "label": {"api": {"LinkedList": [[12, 21]]}}}, {"text": "In the approach shown below, the desired text is imaged using TextLayout using a suitably large Font size and scaled to fill the component", "label": {"api": {"TextLayout": [[62, 71]]}}}, {"text": "The simplest possible solution in Java EE 6 is to use @Asynchronous annotation on your EJB method (or the whole class)", "label": {"api": {"@Asynchronous": [[54, 66]]}}}, {"text": "As a side note - in Servlets you can also use asynchronous execution", "label": {"api": {"Servlets": [[20, 27]]}}}, {"text": "You can try sizing your panels with setPreferredSize() and company", "label": {"api": {"setPreferredSize()": [[36, 53]]}}}, {"text": "You could use the SimpleDateFormatter to parse the String", "label": {"api": {"SimpleDateFormatter": [[18, 36]]}}}, {"text": "for each unexplored children in the node, retrieve a thread from the thread pool (perhaps using a Semaphore)", "label": {"api": {"Semaphore": [[98, 106]]}}}, {"text": "This is usually achieved by calling requestFocusInWindow()", "label": {"api": {"requestFocusInWindow()": [[36, 57]]}}}, {"text": "You need to call getSelectedFile() on the JFileChooser once it has returned, so change your code to", "label": {"api": {"JFileChooser": [[42, 53]]}}}, {"text": "It looks like this can't be done without altering the reading thread to poll using InputStream.available() and sleep for a short perdiod when there are no bytes available, all the while checking some flag to see if the thread should end", "label": {"api": {"InputStream.available()": [[83, 105]]}}}, {"text": "I disagree with @Andrew Thompson answer, use Window rather than some 'OverLayable Whatever', but in this case this container will be always on the Top, over Swing Container", "label": {"api": {"Window": [[45, 50]]}}}, {"text": "contains checks to see if the list contains the actual thing you handed it", "label": {"api": {"contains": [[0, 7], [35, 42]]}}}, {"text": "contains can't magically guess that it's supposed to look at a given property on the Paragem instances to compare the string", "label": {"api": {"contains": [[0, 7]]}}}, {"text": "You should pre-compile your XPath expression to a XPathExpression, using XPath.compile", "label": {"api": {"XPathExpression": [[50, 64]], "XPath.compile": [[73, 85]]}}}, {"text": "Then call XPathExpression.evaluate", "label": {"api": {"XPathExpression": [[10, 24]], "XPathExpression.evaluate": [[10, 33]]}}}, {"text": "Have a look at SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "I have a list which will store Number objects", "label": {"api": {"Number": [[31, 36]]}}}, {"text": "The list will be populated by parsing a list of strings, where each string may represent any subclass of Number", "label": {"api": {"Number": [[105, 110]]}}}, {"text": "Yes, any class can implement Iterable", "label": {"api": {"Iterable": [[29, 36]]}}}, {"text": "You may also want to implement ListIterator, which is intended specifically for lists", "label": {"api": {"ListIterator": [[31, 42]]}}}, {"text": "You can just create your own class that implements Iterator<T>", "label": {"api": {"Iterator<T>": [[51, 61]]}}}, {"text": "You would then implement Iterable<E> in your collection class and return an new instance of your iterator class from the iterator() method", "label": {"api": {"Iterable<E>": [[25, 35]]}}}, {"text": "You should probably also implement higher collection interfaces, such as List<E>", "label": {"api": {"List<E>": [[73, 79]]}}}, {"text": "You can define your own Iterator class by implementing the three methods of the Iterator interface", "label": {"api": {"Iterator interface": [[80, 97]]}}}, {"text": "you can implement it to just throw an UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[38, 66]]}}}, {"text": "Once you do implement an iterator class, it's usually helpful to have the list class implement Iterable", "label": {"api": {"Iterable": [[95, 102]]}}}, {"text": "If you don't know how many bytes you will read, set the progress bar to indeterminate mode and it will animate itself showing that \"some\" progress is occurring", "label": {"api": {"indeterminate mode": [[72, 89]]}}}, {"text": "Before answering your question, I strongly encourage you to look into ExecutorServices such as for instance the ThreadPoolExecutor", "label": {"api": {"ExecutorServices": [[70, 85]], "ThreadPoolExecutor": [[112, 129]]}}}, {"text": "If you make two objects, and let JPA persist them automatically, then you'll get two rows in the database", "label": {"api": {"persist": [[37, 43]]}}}, {"text": "don't make two objects, or don't let JPA persist them automatically", "label": {"api": {"persist": [[41, 47]]}}}, {"text": "You would probably want a WeakHashMap (scoped to the current request, perhaps by being referred to by local variables), keyed by name, where Parents can look up their new Child's name to see if the Child already exists", "label": {"api": {"WeakHashMap": [[26, 36]]}}}, {"text": "To avoid having JPA persist the objects automatically, drop the cascade and use persist to manually add the objects to the context immediately after creation", "label": {"api": {"persist": [[20, 26], [80, 86]]}}}, {"text": "Since a persistence context is basically a tricked-out WeakHashMap attached to a database, these approaches are pretty similar when it comes down to it", "label": {"api": {"WeakHashMap": [[55, 65]], "persist": [[8, 14]]}}}, {"text": "However, although this method will work in a J2SE application, Persistence.createEntityManagerFactory is not guaranteed to work in J2EE", "label": {"api": {"Persistence.createEntityManagerFactory": [[63, 100]]}}}, {"text": "Store it in a hashtable, tree or other data structure with a fast lookup time, that is O(log n) or better", "label": {"api": {"hashtable": [[14, 22]], "tree": [[25, 28]]}}}, {"text": "I would stick with the standard DataOutputStream which can write primitive types to the output in a portable way", "label": {"api": {"DataOutputStream": [[32, 47]]}}}, {"text": "It has writeLong, writeInt", "label": {"api": {"writeLong": [[7, 15]], "writeInt": [[18, 25]]}}}, {"text": "With these methods you can write out your data, then later load it with DataInputStream's readLong and readInt", "label": {"api": {"DataInputStream": [[72, 86]], "readLong": [[90, 97]], "readInt": [[103, 109]]}}}, {"text": "Write them to a ByteArrayOutputStream, pre-allocate if you know the whole size beforehand", "label": {"api": {"ByteArrayOutputStream": [[16, 36]]}}}, {"text": "You probably want to take a look at the ScriptEngine", "label": {"api": {"ScriptEngine": [[40, 51]]}}}, {"text": "Calling FileInputStream.available continuously may acquire a lock (implementation dependent), which may not be released in a fair manner", "label": {"api": {"available": [[24, 32]]}}}, {"text": "In any case, available is the wrong method", "label": {"api": {"available": [[13, 21]]}}}, {"text": "It only returning an estimate of the number of bytes available without blocking", "label": {"api": {"available": [[53, 61]]}}}, {"text": "The decorator should just record the number of bytes available", "label": {"api": {"available": [[53, 61]]}}}, {"text": "Now a URL spec in a <property> task should point to a javaspec'd property file, so I don't think a jar will work", "label": {"api": {"javaspec'd property file": [[54, 77]]}}}, {"text": "JApplet is a descendant of java.awt.Panel that also acts as a Swing container so it can be used almost interchangeably with other containers like JFrame and JPanel", "label": {"api": {"JApplet": [[0, 6]]}}}, {"text": "A Java TreeMap is a \"Red-Black tree based NavigableMap implementation\", so insert and search take O(lg n) time per operation and iterating through it is O(n)", "label": {"api": {"TreeMap": [[7, 13]]}}}, {"text": "This can be done in lock-free manner by using AtomicReference as instance holder", "label": {"api": {"AtomicReference": [[46, 60]]}}}, {"text": "But you can also use Scanner#nextDouble()", "label": {"api": {"Scanner#nextDouble()": [[21, 40]]}}}, {"text": "You can use File#createTempFile() wherein you specify the prefix, suffix and folder", "label": {"api": {"File#createTempFile()": [[12, 32]]}}}, {"text": "I already tried using ServletContext.getResource(java.lang.String) with the name of the resource (\"jdbc/MyDatasource\"), but Tomcat complains that the name doesn't begin with a '/'", "label": {"api": {"ServletContext.getResource(java.lang.String)": [[22, 65]]}}}, {"text": "Your BankAccount class should implement the java.lang.Comparable<BankAccount> interface, it appears this is not the case in your code", "label": {"api": {"java.lang.Comparable<BankAccount>": [[44, 76]]}}}, {"text": "Indeed, Collection.sort is taking a collection of Comparable<T> as an argument", "label": {"api": {"Collection.sort": [[8, 22]]}}}, {"text": "I'm loading potentially large images using a javax.imageio.ImageReader for thumbnail generation in a GUI, and when the user navigates to a different folder (on the Swing thread) I'd like to be able to interrupt the thumbnail generator's thread without waiting for the current image to finish loading", "label": {"api": {"javax.imageio.ImageReader": [[45, 69]]}}}, {"text": "If you want to run clean every 10 second, you can use Timer class", "label": {"api": {"Timer": [[54, 58]]}}}, {"text": "It can only be caused if FacesContext#getCurrentInstance() returned null", "label": {"api": {"FacesContext#getCurrentInstance()": [[25, 57]]}}}, {"text": "See also its javadoc", "label": {"api": {"its javadoc": [[9, 19]]}}}, {"text": "That FacesContext#getCurrentInstance() returns null can in turn only be caused if that line of code is not been executed inside the JSF context, i.e", "label": {"api": {"FacesContext#getCurrentInstance()": [[5, 37]]}}}, {"text": "The ECMAScript (JavaScript) engine of the ScriptEngine can do the calculations line by line", "label": {"api": {"ScriptEngine": [[42, 53]]}}}, {"text": "Since you know the secret key, what you need is a SecretKeyFactory", "label": {"api": {"SecretKeyFactory": [[50, 65]]}}}, {"text": "Get an instance for your algorithm (DESede), and then call its generateSecret méthode with an instance of DESedeKeySpec as argument", "label": {"api": {"DESedeKeySpec": [[106, 118]]}}}, {"text": "As I said, DESedeKeySpec must be used with the DESede algorithm", "label": {"api": {"DESedeKeySpec": [[11, 23]]}}}, {"text": "You just need to ensure that these resources are \"loaded from the classpath\", rather than being loaded from the current working directory", "label": {"api": {"loaded from the classpath": [[50, 74]]}}}, {"text": "I would use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[12, 31]]}}}, {"text": "By default @OneToMany and @ManyToMany relationships are lazy loaded which means that, for better performance, you'll get data fetched only when you want to access it for the first time", "label": {"api": {"lazy loaded": [[56, 66]]}}}, {"text": "You should either put your invocation code within the active transaction or change the collection to be eager instead of lazy", "label": {"api": {"eager": [[104, 108]]}}}, {"text": "Its javadoc contains a useful example", "label": {"api": {"Its javadoc": [[0, 10]]}}}, {"text": "I don't know a ready tool, but you could easily (a single class probably) write your own unzip tool in Java using the classes from java.util.zip, e.g", "label": {"api": {"java.util.zip": [[131, 143]]}}}, {"text": "the ZipFile class", "label": {"api": {"ZipFile": [[4, 10]]}}}, {"text": "You want to look at ZipInputStream and its brother ZipOutputStream if you want to build a tool yourself", "label": {"api": {"ZipInputStream": [[20, 33]]}}}, {"text": "The replaceAll method is operating against Regular Expressions", "label": {"api": {"replace": [[4, 10]]}}}, {"text": "You're probably just wanting to use the \"replace\" method, which despite its name, does replace all occurrences", "label": {"api": {"replace": [[41, 47], [87, 93]]}}}, {"text": "You can use the preferences API for the actual preferences implementation", "label": {"api": {"API": [[28, 30]]}}}, {"text": "If so, launch it using Java Web Start & use the SingleInstanceService of the JNLP API to show the '\"welcome\" dialogue box'", "label": {"api": {"SingleInstanceService": [[48, 68]]}}}, {"text": "of the SingleInstanceService for more details, the code is available for download", "label": {"api": {"SingleInstanceService": [[7, 27]]}}}, {"text": "The JDK provides a Queue interface and a number of implementations, which can be found in the \"All Known Implementing Classes\" section of the Queue documentation", "label": {"api": {"Queue documentation": [[142, 160]]}}}, {"text": "For your purposes, a LinkedList should probably be good enough", "label": {"api": {"LinkedList": [[21, 30]]}}}, {"text": "Something like a LinkedBlockingQueue should do nicely", "label": {"api": {"LinkedBlockingQueue": [[17, 35]]}}}, {"text": "Looks like you are trying to apply log4j style configuration to java.util.logging", "label": {"api": {"config": [[47, 52]]}}}, {"text": "If you want to create multiple FileHandlers with different formatters then you have to use the config option to install each FileHandler", "label": {"api": {"config": [[95, 100]]}}}, {"text": "Create a config class", "label": {"api": {"config": [[9, 14]]}}}, {"text": "You have to use the %g option to distinguish rotated logs and %u to deal with conflicts", "label": {"api": {"%g": [[20, 21]]}}}, {"text": "Thus if three processes were all trying to log to fred%u.%g.txt then they might end up using fred0.0.txt, fred1.0.txt, fred2.0.txt as the first file in their rotating sequences", "label": {"api": {"%g": [[57, 58]]}}}, {"text": "Create your JSpinner with a SpinnerNumberModel with the desired minimum and maximum values", "label": {"api": {"SpinnerNumberModel": [[28, 45]]}}}, {"text": "According to http://docs.oracle.com/javase/6/docs/api/java/lang/String.html, replace() takes chars instead of Strings", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[13, 74]]}}}, {"text": "Maybe you'd rather use URL.openStream() which would work on any kind of URL, including remote ones", "label": {"api": {"URL.openStream()": [[23, 38]]}}}, {"text": "Since Java 1.6, you're able to use a NavigableSet", "label": {"api": {"NavigableSet": [[37, 48]]}}}, {"text": "An example class from the Java Core libraries that implements such behavior is RepaintManager", "label": {"api": {"RepaintManager": [[79, 92]]}}}, {"text": "Scanner with its methods nextLong() and nextString() and PrintWriter with its print() methods seams to be what you are looking for", "label": {"api": {"Scanner": [[0, 6]], "PrintWriter": [[57, 67]]}}}, {"text": "To read and write a binary file, you could use ObjectInputStream with its readLong() and (String)readObject() methods and ObjectOutputStream with its writeLong() and writeObject() methods", "label": {"api": {"ObjectInputStream": [[47, 63]], "ObjectOutputStream": [[122, 139]]}}}, {"text": "Use a SwingWorker, and see Concurrency in Swing for more details", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "Have you tried looking at a Cyclic Barrier", "label": {"api": {"Cyclic Barrier": [[28, 41]]}}}, {"text": "You need to stick all your tasks in a queue, then feed the queue to a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[70, 87]]}}}, {"text": "See Reentrantlock docs for more about fairness", "label": {"api": {"Reentrantlock": [[4, 16]]}}}, {"text": "Probably even better alternative would be using a Queue", "label": {"api": {"Queue": [[50, 54]]}}}, {"text": "Try to use Preferences and its systemRoot() or userRoot() methods to obtain system-wide or user-specific preferences", "label": {"api": {"Preferences": [[11, 21]], "systemRoot()": [[31, 42]], "userRoot()": [[47, 56]]}}}, {"text": "The equals() method has a well-defined contract, and your proposed implementation violates it", "label": {"api": {"a well-defined contract,": [[24, 47]]}}}, {"text": "Your use cases sound like they could be satisfied with a NavigableMap, where keys are integers, and values are instances of your class", "label": {"api": {"NavigableMap": [[57, 68]]}}}, {"text": "It sounds like you probably want DataInputStream", "label": {"api": {"DataInputStream": [[33, 47]]}}}, {"text": "How can I display a single Urdu character in a JTextPane", "label": {"api": {"JTextPane": [[47, 55]]}}}, {"text": "Display it in my text component (JTextPane)", "label": {"api": {"JTextPane": [[33, 41]]}}}, {"text": "You'd likely want to create an actual File, and use something like file.getCanonicalPath() or .getAbsolutePath depending on your needs", "label": {"api": {"File": [[38, 41]], "file.getCanonicalPath()": [[67, 89]], ".getAbsolutePath": [[94, 109]]}}}, {"text": "Creating a FileInputStream directly from the path bypasses the ability to query the actual file", "label": {"api": {"File": [[11, 14]]}}}, {"text": "You can still create the FileInputStream using the File-based constructor", "label": {"api": {"File": [[25, 28], [51, 54]], "File-based constructor": [[51, 72]]}}}, {"text": "This depends on how you are creating your JAXBContext", "label": {"api": {"JAXBContext": [[42, 52]]}}}, {"text": "The newInstance method can be called with an explicit list of all your classes, the documentation for that method also gives a similar example", "label": {"api": {"newInstance method": [[4, 21]]}}}, {"text": "Subclasses of referenced classes nor @XmlTransient referenced classes are not registered with JAXBContext", "label": {"api": {"JAXBContext": [[94, 104]]}}}, {"text": "For example, in the following Java code, if you do newInstance(Foo.class), the newly created JAXBContext will recognize both Foo and Bar, but not Zot or FooBar", "label": {"api": {"JAXBContext": [[93, 103]]}}}, {"text": "If you know at least the package names of potential jaxb classes you could also create a context given a context path", "label": {"api": {"create a context given a context path": [[80, 116]]}}}, {"text": "You need to either implement public int compareTo(Person personA, Person personB), or alter your Comparable<Element> class's method definition to be public int compareTo(Element other); to override the core Comparable class's compareTo method", "label": {"api": {"compareTo method": [[226, 241]]}}}, {"text": "If you add @Override to a method that you're not actually overriding from a superclass (such as your two-argument compareTo method), then it will be a compiler error", "label": {"api": {"compareTo method": [[114, 129]]}}}, {"text": "Have the AccountManager class implement java.util.Observable", "label": {"api": {"java.util.Observable": [[40, 59]]}}}, {"text": "Have the GUI classes implement java.util.Observer", "label": {"api": {"java.util.Observer": [[31, 48]]}}}, {"text": "Call addObserver() on AccountManager for each of the GUI classes", "label": {"api": {"addObserver()": [[5, 17]]}}}, {"text": "Use a Reader when working with strings", "label": {"api": {"Reader": [[6, 11]]}}}, {"text": "InputStreams are really meant for binary data", "label": {"api": {"InputStream": [[0, 10]]}}}, {"text": "FileInputStream  for example, implements the Object#finalize() method, to call the Closeable#close() method", "label": {"api": {"FileInputStream": [[0, 14]]}}}, {"text": "What you can do, though, is to use Runtime.addShutdownHook()—it will add yet another layer of safety nets to your application, giving you a chance to close the connection gracefully on exit", "label": {"api": {"Runtime.addShutdownHook()": [[35, 59]]}}}, {"text": "You can use DecimalFormat to parse and format decimal numbers", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "There is perhaps a very little known API called java.awt.Desktop that allows launching of default applications on many platforms", "label": {"api": {"java.awt.Desktop": [[48, 63]]}}}, {"text": "The exception you are getting here is because you are using the wrong constructor for QName, you should specify both the namespace URI and the local name of the element as parameters", "label": {"api": {"QName": [[86, 90]]}}}, {"text": "JTextArea has an append(String) method", "label": {"api": {"append(String)": [[17, 30]]}}}, {"text": "You can make use of ImageIO in order to load the image from an URL and then write it to a file", "label": {"api": {"ImageIO": [[20, 26]]}}}, {"text": "The error tells me that the LDAP requires a DirContext", "label": {"api": {"DirContext": [[44, 53]]}}}, {"text": "How can I get the SimpleNamingContextBuilder to create and use such a DirContext", "label": {"api": {"DirContext": [[70, 79]]}}}, {"text": "I suspect you mean java.util.Iterator<E>", "label": {"api": {"java.util.Iterator<E>": [[19, 39]]}}}, {"text": "For example, Look at the signature of the copy method", "label": {"api": {"copy": [[42, 45]]}}}, {"text": "3) I tried to use shutdownhook as explained in this post, but that's not working for me", "label": {"api": {"shutdownhook": [[18, 29]]}}}, {"text": "The code inside the shutdownhook is getting executed only after the java & child processes are done with their work", "label": {"api": {"shutdownhook": [[20, 31]]}}}, {"text": "So, calling process.destroy() inside shutdownhook is not useful here", "label": {"api": {"shutdownhook": [[37, 48]]}}}, {"text": "This seems obvious, as the JVM is still running in my case, it won't call shutdownhooks until it starts it's shutdown sequence", "label": {"api": {"shutdownhook": [[74, 85]]}}}, {"text": "Your best bet is to see what happens with your specific JVM, via Runtime's totalMemory and maxMemory", "label": {"api": {"totalMemory": [[75, 85]], "maxMemory": [[91, 99]]}}}, {"text": "Although not very explicitly expressed, the intent of the JDBC methods is to execute a single SQL statement", "label": {"api": {"a single SQL statement": [[85, 106]]}}}, {"text": "The retrieval of multiple resultsets is for (very rare) single(!) statements or stored procedures which return multiple resultsets (as explained in the javadoc of Statement#execute)", "label": {"api": {"Statement#execute": [[163, 179]]}}}, {"text": "The dir argument in FilenameFilter#accept() represents the parent directory the file was found in, not the file itself as you seem to expect", "label": {"api": {"FilenameFilter#accept()": [[20, 42]]}}}, {"text": "Secondly, try to construct MimetypesFileTypeMap with explicit mime-type file specification", "label": {"api": {"explicit mime-type file specification": [[53, 89]], "construct": [[17, 25]]}}}, {"text": "In that case, get stream from plugin and construct your MimetypesFileTypeMap with that stream", "label": {"api": {"construct": [[41, 49]]}}}, {"text": "The first one is a JToolTip", "label": {"api": {"JToolTip": [[19, 26]]}}}, {"text": "The second one seems to be a JToolTip as well, but with formatted code and a different background color, at least from the screenshot you have linked to", "label": {"api": {"JToolTip": [[29, 36]]}}}, {"text": "This looks like you want a Map, not an array", "label": {"api": {"Map": [[27, 29]]}}}, {"text": "You can look at the examples in HashMap", "label": {"api": {"Map": [[36, 38]], "HashMap": [[32, 38]]}}}, {"text": "The agent class has the premain hook for instrumentation", "label": {"api": {"premain": [[24, 30]]}}}, {"text": "As per the API doc, the sendRedirect call does a temporary redirect", "label": {"api": {"API doc": [[11, 17]]}}}, {"text": "A Timer object could work well for this, either java.util.Timer if general Java or javax.swing.Timer if a Swing GUI", "label": {"api": {"java.util.Timer": [[48, 62]], "javax.swing.Timer": [[83, 99]]}}}, {"text": "If I'm reading your question properly, what you'll want to do is set a static size for your JButtons by using the functions for JComponents See JavaDoc link here", "label": {"api": {"See JavaDoc link here": [[140, 160]]}}}, {"text": "You need to use an iterator to traverse the collections and then use the iterator.remove() to remove items from a collection while you are traversing it", "label": {"api": {"iterator": [[19, 26], [73, 80]], "iterator.remove()": [[73, 89]]}}}, {"text": "Another approach might be to use a java.lang.Integer, which also represents an int and is a proper Object so gets passed by reference", "label": {"api": {"java.lang.Integer": [[35, 51]]}}}, {"text": "If that doesn't work, you're probably stuck using @XmlJavaTypeAdaptor and XmlAdaptor<Foo, YourAdaptedFoo>, but that's really nasty", "label": {"api": {"@XmlJavaTypeAdaptor": [[50, 68]], "XmlAdaptor<Foo, YourAdaptedFoo>": [[74, 104]]}}}, {"text": "Try using a HttpURLConnection, it should follow redirects automatically", "label": {"api": {"HttpURLConnection": [[12, 28]]}}}, {"text": "Use the version of PrinterJob.setPrintable() that takes a PageFormat argument", "label": {"api": {"PrinterJob.setPrintable()": [[19, 43]]}}}, {"text": "In the PageFormat, set the paper's imageable area have no border (x=0, y=0, width=paper's width, height=paper's height)", "label": {"api": {"imageable area": [[35, 48]]}}}, {"text": "You might want to feed that through PrinterJob.validatePage(), which", "label": {"api": {"PrinterJob.validatePage()": [[36, 60]]}}}, {"text": "For example, the returned PageFormat could have its imageable area adjusted to fit within the physical area of the paper that is used by the current printer", "label": {"api": {"imageable area": [[52, 65]]}}}, {"text": "You should be dealing with the input stream in a separate Thread - and let it block waiting for input", "label": {"api": {"Thread": [[58, 63]], "block": [[78, 82]]}}}, {"text": "It will not use any resources while it blocks", "label": {"api": {"block": [[39, 43]]}}}, {"text": "The getSerialNumber() method returns a BigInteger object, according to the X509Certificate API", "label": {"api": {"X509Certificate API": [[75, 93]]}}}, {"text": "System.exit() should be used with care, as discussed here and here", "label": {"api": {"System.exit()": [[0, 12]]}}}, {"text": "A way to avoid this is to override your getPreferredSize() function and return your preferred size", "label": {"api": {"getPreferredSize()": [[40, 57]]}}}, {"text": "You can use StringTokenizer with comma as separator, then loop nextToken() 1000 times", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "The related class java.text.MessageFormat may be useful in composing your check box's text", "label": {"api": {"java.text.MessageFormat": [[18, 40]]}}}, {"text": "Starting Java 5.0, you can use Thread.currentThread().getStackTrace() to get a current stack trace", "label": {"api": {"Thread.currentThread().getStackTrace()": [[31, 68]]}}}, {"text": "You should try to parse the numbers using NumberFormat class", "label": {"api": {"NumberFormat": [[42, 53]]}}}, {"text": "Well, there's File.list()", "label": {"api": {"File.list()": [[14, 24]]}}}, {"text": "In order to circumvent that, use the other File.list(FilenameFilter filter) method that will enable you to filter out directories from the listing", "label": {"api": {"File.list(FilenameFilter filter)": [[43, 74]]}}}, {"text": "If your value is immutable, java.util.Optional looks like a great option", "label": {"api": {"java.util.Optional": [[28, 45]]}}}, {"text": "Now, you might be able to implement a Dynamic MBean (see a great explanatory example here) and use reflection to gather up-to-date information of the managed class", "label": {"api": {"Dynamic MBean": [[38, 50]]}}}, {"text": "However, you can work around it with BigInteger", "label": {"api": {"BigInteger": [[37, 46]]}}}, {"text": "You can use a DecimalFormat to fix the example of \"10.0\"", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "It looks like the Properties.load() happily loads in binary garbage unless it finds an invalid \\uxxxx escape character", "label": {"api": {"Properties.load()": [[18, 34]]}}}, {"text": "I just looked at the docs for the text format of properties files, and I'm confused how to tell if a .properties file is valid", "label": {"api": {"the text format of properties files": [[30, 64]]}}}, {"text": "Check this page", "label": {"api": {"page": [[11, 14]]}}}, {"text": "You can determine how many digits a number has by using Math.log10() (remember to Math.abs() if you're going to be dealing with negatives)", "label": {"api": {"Math.log10()": [[56, 67]], "Math.abs()": [[82, 91]]}}}, {"text": "Using the modulo operator with Math.pow() can give you the last x digits of a number", "label": {"api": {"Math.pow()": [[31, 40]]}}}, {"text": "In addition to a_horse_with_no_name's answer (which relies on PreparedStatement.setBinaryStream(...) API), there're at least two more options for BLOBs, and 3 more for CLOBs and NCLOBs", "label": {"api": {"PreparedStatement.setBinaryStream(...)": [[62, 99]]}}}, {"text": "From the documentation for TreeMap", "label": {"api": {"documentation for TreeMap": [[9, 33]]}}}, {"text": "See the docs for synchronizedSortedMap", "label": {"api": {"docs for synchronizedSortedMap": [[8, 37]]}}}, {"text": "You can use Collections.synchronizedSet() or synchronizedMap() to add the synchronization around individual methods, but thread safety isn't really a property of a data structue but of an application", "label": {"api": {"Collections.synchronizedSet()": [[12, 40]]}}}, {"text": "A java.util.concurrent.ConcurrentSkipListMap might be of interest", "label": {"api": {"java.util.concurrent.ConcurrentSkipListMap": [[2, 43]]}}}, {"text": "Then you can use JTextArea.insert(String str, int pos) to insert text at that position", "label": {"api": {"JTextArea.insert(String str, int pos)": [[17, 53]]}}}, {"text": "JFileChooser.getSelectedFile() return the File object", "label": {"api": {"JFileChooser.getSelectedFile()": [[0, 29]]}}}, {"text": "You can calculate the totalMemory() and freeMemory() on the heap before and after allocation, and get an estimate that way", "label": {"api": {"You can calculate the totalMemory() and freeMemory()": [[0, 51]]}}}, {"text": "Using Runtime#totalMemory and Runtime#gc should be able to get you a very close approximation", "label": {"api": {"Runtime#totalMemory": [[6, 24]], "Runtime#gc": [[30, 39]]}}}, {"text": "Matcher.matches() requires your pattern to match the entire input (thus you would need to surround the pattern with .* for it to match), whereas Matcher.find() searches the input string for the first (and then subsequent) substring that matches your pattern", "label": {"api": {"Matcher.matches()": [[0, 16]], "Matcher.find()": [[145, 158]]}}}, {"text": "You also can use an ArrayList", "label": {"api": {"ArrayList": [[20, 28]]}}}, {"text": "The first parameter is the index you want to add the new item and the second one is your number", "label": {"api": {"add": [[45, 47]]}}}, {"text": "See the add method", "label": {"api": {"add": [[8, 10]]}}}, {"text": "Then you could call remove(Object), which Stack inherits from Vector, passing in the Card you wanted removed", "label": {"api": {"remove(Object)": [[20, 33]]}}}, {"text": "StringBuilder has a many overloaded methods called append", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "If you wish to index into the corresponding TableModel you need to convert this value using convertRowIndexToModel", "label": {"api": {"convertRowIndexToModel": [[92, 113]]}}}, {"text": "As far as I can tell ThreadLocal API was designed to do what you describe", "label": {"api": {"ThreadLocal": [[21, 31]]}}}, {"text": "Also note you could use String.valueOf instead of doing || \"null\" yourself, i.e", "label": {"api": {"String.valueOf": [[24, 37]]}}}, {"text": "using localized decimal separator) then you could parse with a NumberFormat instead and catch ParseException", "label": {"api": {"NumberFormat": [[63, 74]]}}}, {"text": "Look into something called StringBuffer", "label": {"api": {"StringBuffer": [[27, 38]]}}}, {"text": "StringBuffer has a method which will allow you to reverse the String", "label": {"api": {"StringBuffer": [[0, 11]]}}}, {"text": "JTable and JComboBox have respectively AbstractTableModel and ComboBoxModel", "label": {"api": {"AbstractTableModel": [[39, 56]], "ComboBoxModel": [[62, 74]]}}}, {"text": "I would just use a thread pool, and more specifically a thread pool executor", "label": {"api": {"thread pool executor": [[56, 75]]}}}, {"text": "In JSF 1.x, you need to get the HttpServletResponse by ExternalContext#getResponse() and then invoke setStatus() on it", "label": {"api": {"HttpServletResponse": [[32, 50]], "ExternalContext#getResponse()": [[55, 83]], "setStatus()": [[101, 111]]}}}, {"text": "You may also want to use BlockingQueue and pass both of those to each thread", "label": {"api": {"BlockingQueue": [[25, 37]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/lang/ClassLoader.html#getResource%28java.lang.String%29, and include the compiler error message next time you have such a question", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/ClassLoader.html#getResource%28java.lang.String%29": [[4, 104]]}}}, {"text": "The problem is that getStudents returns a Set object (a HashSet, to be specific)", "label": {"api": {"HashSet": [[56, 62]]}}}, {"text": "HashSet, in turn, inherits a toString() method from AbstractCollection which behaves as follows", "label": {"api": {"HashSet": [[0, 6]], "AbstractCollection": [[52, 69]]}}}, {"text": "I know that is possible define an uncaught exception for a group of thread (ThreadGroup) and i'm actually using it, but i want to define a global uncaught exception for threads that don't have defined their own uncaught exception handler or that are not associated to a group of threads that have a default exception handler defined", "label": {"api": {"ThreadGroup": [[76, 86]]}}}, {"text": "This is a static method on the Thread class called setDefaultUncaughtExceptionHandler", "label": {"api": {"setDefaultUncaughtExceptionHandler": [[51, 84]]}}}, {"text": "In the docs for isValid() it says", "label": {"api": {"isValid()": [[16, 24]]}}}, {"text": "The method setDefaultButton() may allow you to use the button without scrolling or hiding data under a floating component", "label": {"api": {"setDefaultButton()": [[11, 28]]}}}, {"text": "So, I suspect that the toString method, as documented, replaces malformed-input and unmappable-character sequences with the default replacement string for the platform's default character set", "label": {"api": {"documented": [[43, 52]]}}}, {"text": "You want to call String#indexOf(int), which will give you the index of the character", "label": {"api": {"String#indexOf(int)": [[17, 35]]}}}, {"text": "String#charAt(int) returns the character at the given index", "label": {"api": {"String#charAt(int)": [[0, 17]]}}}, {"text": "Use a JToggleButton as shown in Swing JToolbarButton pressing", "label": {"api": {"JToggleButton": [[6, 18]]}}}, {"text": "Probably your input is a Scanner, so just use nextLine() to get a line of text", "label": {"api": {"Scanner": [[25, 31]], "nextLine()": [[46, 55]]}}}, {"text": "If I understand your question correctly, you want to add an ItemListener", "label": {"api": {"add an ItemListener": [[53, 71]]}}}, {"text": "@ManagedBean just declares that a certain bean is managed by JSF (makes it available to expression language among others)", "label": {"api": {"@ManagedBean": [[0, 11]]}}}, {"text": "@ViewScoped lets you declare a specific scope the bean will live in", "label": {"api": {"@ViewScoped": [[0, 10]]}}}, {"text": "The default (when you don't specify any scope) is @RequestScoped, which means your bean will live through a single request and will then be destroyed", "label": {"api": {"@RequestScoped": [[50, 63]]}}}, {"text": "Other scopes are @SessionScoped and @ApplicationScoped", "label": {"api": {"@SessionScoped": [[17, 30]], "@ApplicationScoped": [[36, 53]]}}}, {"text": "@ViewScoped will keep living as long as you post back a page to itself", "label": {"api": {"@ViewScoped": [[0, 10]]}}}, {"text": "The XMLEventWriter has a convenient add(XMLEventWriter) method for bridging a reader to a writer, making this super-simple", "label": {"api": {"XMLEventWriter": [[4, 17], [40, 53]], "add(XMLEventWriter)": [[36, 54]]}}}, {"text": "Just use an ExecutorService and queue up tasks using submit", "label": {"api": {"ExecutorService": [[12, 26]]}}}, {"text": "Consider using a Map, in which you can store key-value pairs", "label": {"api": {"Map": [[17, 19]]}}}, {"text": "See the Map javadoc", "label": {"api": {"Map": [[8, 10]]}}}, {"text": "In Java, you can do that with Double.longBitsToDouble, and then convert back with Double.doubleToLongBits", "label": {"api": {"Double.longBitsToDouble": [[30, 52]], "Double.doubleToLongBits": [[82, 104]]}}}, {"text": "If you want your integers and doubles to have a certain length then I suggest you use NumberFormat to format your numbers instead of cutting off their string representation", "label": {"api": {"NumberFormat": [[86, 97]]}}}, {"text": "All instances of javax.swing.Timer share a single thread; use as many as otherwise make sense in your program", "label": {"api": {"javax.swing.Timer": [[17, 33]]}}}, {"text": "That and the Javadocs API's", "label": {"api": {"Javadocs API's": [[13, 26]]}}}, {"text": "In general though, if you wan't to find an element, just use indexOf and be sure to implement equals properly", "label": {"api": {"indexOf": [[61, 67]]}}}, {"text": "If you want to read object into your program, then you have to use ObjectInputStream, not ObjectOutputStream", "label": {"api": {"ObjectInputStream": [[67, 83]], "ObjectOutputStream": [[90, 107]]}}}, {"text": "The API documentation for readObject does not state that it will return null or throw an exception if EOF is reached", "label": {"api": {"readObject": [[26, 35]]}}}, {"text": "You may also want to read API docs on ObjectInputStream and ObjectOutputStream", "label": {"api": {"ObjectInputStream": [[38, 54]], "ObjectOutputStream": [[60, 77]]}}}, {"text": "If you want to parse their textual bodies, which are essentially Strings, then you'd need to grab String based methods instead such as substring(), indexOf(), replaceAll(), etc", "label": {"api": {"String based methods": [[98, 117]]}}}, {"text": "FileTreeModel is an example that implements TreeModel for a typical hierarchical file system", "label": {"api": {"TreeModel": [[4, 12], [44, 52]]}}}, {"text": "Given that ScriptEngineManager and ScriptEngine are part of the JDK and Android SDK is not the same thing as the JDK I would say that you can't use these classes to work with JavaScript under Android", "label": {"api": {"ScriptEngineManager": [[11, 29]], "ScriptEngine": [[11, 22], [35, 46]]}}}, {"text": "The following code renders a JFXPanel inside a JFrame", "label": {"api": {"JFXPanel": [[29, 36]]}}}, {"text": "The JFXPanel contains a WebView which loads google.com", "label": {"api": {"JFXPanel": [[4, 11]], "WebView": [[24, 30]]}}}, {"text": "However, at least on my machine, the WebView feels rather sloppy", "label": {"api": {"WebView": [[37, 43]]}}}, {"text": "You can use Object.clone() which is a standard way of creating a copy of existing object", "label": {"api": {"Object.clone()": [[12, 25]]}}}, {"text": "Then you can use the Integer(String s) constructor to parse your string objects", "label": {"api": {"Integer(String s)": [[21, 37]]}}}, {"text": "Creating a thread is expensive, try to create a limited number of threads and reuse them among requests (in java see ExecutorService for example)", "label": {"api": {"ExecutorService": [[117, 131]]}}}, {"text": "Use the read() method in a loop until the character is %", "label": {"api": {"read()": [[8, 13]]}}}, {"text": "No, XMLStreamReader allows you to get the text content of a text only xml node with getElementText(), to get the full content you will have to read the file yourself and grab the elements and reconstruct the XML", "label": {"api": {"getElementText()": [[84, 99]]}}}, {"text": "it is based on SimpleDateFormat and that does not support sub-millisecond formats, so microseconds can not be reported", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "For simply scanning input, take a look at the Scanner class", "label": {"api": {"Scanner": [[46, 52]]}}}, {"text": "If you just need to scan numbers from console, you can use the Scanner class and the use the nextInt() method like below", "label": {"api": {"Scanner": [[63, 69]], "nextInt()": [[93, 101]]}}}, {"text": "The lazy/inefficient way to do this is with Integer#toBinaryString", "label": {"api": {"Integer#toBinaryString": [[44, 65]]}}}, {"text": "It will remove all leading zeros from positive numbers for you, all you have to do is call String#length and divide by 8", "label": {"api": {"String#length": [[91, 103]]}}}, {"text": "Have you tried calling revalidate() instead of validate()", "label": {"api": {"revalidate()": [[23, 34]]}}}, {"text": "Use the String(byte[], Charset) or String(byte[], String) constructor", "label": {"api": {"String(byte[], Charset)": [[8, 30]], "String(byte[], String)": [[35, 56]]}}}, {"text": "The String class has a few constructors that accept an array of bytes, including one that takes an array of bytes and a String representation of a charset and another that takes a Charset object", "label": {"api": {"String class": [[4, 15]], "one that takes an array of bytes and a String representation of a charset": [[81, 153]], "another that takes a Charset object": [[159, 193]]}}}, {"text": "A Map might be a good backing structure—it keeps your values and indices in paired groups", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "Have a look at using the Java Calendar class, specifically, the .get(Calendar.HOUR) and .get(Calendar.MINUTE) methods", "label": {"api": {"Calendar": [[30, 37], [69, 76], [93, 100]]}}}, {"text": "Don't store the hour and minute values though, either store an instance of the Calendar class, or store the current UNIX timestamp, and compare those, obtaining the hours and minutes after performing the subtraction", "label": {"api": {"Calendar": [[79, 86]]}}}, {"text": "A better way to do this would be to use an ArrayList, although of course, that won't help you if you want to learn how to use Object arrays", "label": {"api": {"ArrayList": [[43, 51]]}}}, {"text": "Simply implement the PropertyChangeListener interface in the other frame and add the listener to the worker, as shown in ProgressMonitorDemo", "label": {"api": {"PropertyChangeListener": [[21, 42]]}}}, {"text": "First of all, the link you provided contains a JFrame not JPanel", "label": {"api": {"JFrame": [[47, 52]], "JPanel": [[58, 63]], "Frame": [[48, 52]]}}}, {"text": "Second, pass the title as a parameter to the JFrame constructor once you create it JFrame(String title)", "label": {"api": {"JFrame": [[45, 50], [83, 88]], "JFrame(String title)": [[83, 102]], "Frame": [[46, 50], [84, 88]]}}}, {"text": "or use the method setTitle(String title) inherited from class Frame", "label": {"api": {"setTitle(String title)": [[18, 39]], "Frame": [[62, 66]]}}}, {"text": "Use Math.pow(2,x) if you like, but realize that it operates on doubles, not ints, so will give you a floating-point answer that will probably cause an exception when you try to cast the result as an integer", "label": {"api": {"Math.pow(2,x)": [[4, 16]]}}}, {"text": "there is also BigInteger.pow(), which returns a BigInteger", "label": {"api": {"BigInteger.pow()": [[14, 29]]}}}, {"text": "After that you'll want to use ImageIO.write() to save the file to disk", "label": {"api": {"ImageIO.write()": [[30, 44]]}}}, {"text": "The Proxy class only supports proxying interfaces, not classes", "label": {"api": {"Proxy": [[4, 8]]}}}, {"text": "Instead, use a single foreach loop and use printf with it's format strings for the formatting", "label": {"api": {"printf": [[43, 48]], "format strings": [[60, 73]]}}}, {"text": "In regards to sorting, you can use Array.sort(Object[] a, Comparator c), where you would have a Comparator for each of Title, Author and Pages, that would be used to sort the array appropriately", "label": {"api": {"Array.sort(Object[] a, Comparator c)": [[35, 70]], "Comparator": [[58, 67], [96, 105]]}}}, {"text": "Here an enhanced excerpt from the javadoc for Integer.parseInt(String, int)", "label": {"api": {"javadoc for Integer.parseInt(String, int)": [[34, 74]]}}}, {"text": "For java.io.EOFException check this link http://docs.oracle.com/javase/1.4.2/docs/api/java/io/EOFException.html", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/io/EOFException.html": [[41, 110]]}}}, {"text": "Use the ProcessBuilder java class for this", "label": {"api": {"ProcessBuilder": [[8, 21]]}}}, {"text": "Have a look at HashSet and the Set interface", "label": {"api": {"HashSet": [[15, 21]]}}}, {"text": "You could use the following sequence to change Properties load the properties with load(), setProperty(key,value) and finally call store() to write it back", "label": {"api": {"Properties": [[47, 56]]}}}, {"text": "Could you use xml-properties instead", "label": {"api": {"xml-properties": [[14, 27]]}}}, {"text": "(Check the Connection Javadoc)", "label": {"api": {"Connection": [[11, 20]]}}}, {"text": "The \"dot\" is called a period; hence it's VK_PERIOD", "label": {"api": {"VK_PERIOD": [[41, 49]]}}}, {"text": "VK_PERIOD should do what you need", "label": {"api": {"VK_PERIOD": [[0, 8]]}}}, {"text": "Consider using ArrayList<Number> for holding both Double and Integer, since Number is the parent class of both Double and Integer", "label": {"api": {"Number": [[25, 30], [76, 81]]}}}, {"text": "To prevent you can use a file lock (get it via a channel from the stream)", "label": {"api": {"file lock": [[25, 33]]}}}, {"text": "BigDecimal offers many rounding options", "label": {"api": {"rounding options": [[23, 38]]}}}, {"text": "However, in the source of java.lang.Reference, I see that they employ this pattern instead", "label": {"api": {"java.lang.Reference": [[26, 44]]}}}, {"text": "Also consider BasicArrowButton", "label": {"api": {"BasicArrowButton": [[14, 29]]}}}, {"text": "As suggested in How to Use Internal Frames, \"Usually, you add internal frames to a desktop pane.\" This allows you to use activateFrame() to indicate that a frame has focus", "label": {"api": {"activateFrame()": [[121, 135]]}}}, {"text": "In this example, a javax.swing.Action is used to select frames from a menu via setSelected()", "label": {"api": {"javax.swing.Action": [[19, 36]], "setSelected()": [[79, 91]]}}}, {"text": "Instead, one should use Collator, like this", "label": {"api": {"Collator": [[24, 31]]}}}, {"text": "To fix this, one would use RuleBasedCollator with specific set of rules that will work for the equality case", "label": {"api": {"Collator": [[36, 43]], "RuleBasedCollator": [[27, 43]]}}}, {"text": "Use a map implementation, like HashMap", "label": {"api": {"map implementation, like HashMap": [[6, 37]]}}}, {"text": "Since you didn't specify the date, only the hour, you actually created a Date object with default values, as specified in the DateFormat API (which SimpleDateFormat implements)", "label": {"api": {"DateFormat API": [[126, 139]]}}}, {"text": "equal elements in the same order), use the static methods in the Arrays class", "label": {"api": {"Arrays": [[65, 70]]}}}, {"text": "Your Marshaller is required to provide an option for formatted output", "label": {"api": {"Marshaller": [[5, 14]]}}}, {"text": "In GridLayout, \"The container is divided into equal-sized rectangles.\" You can add an empty, transparent component in places you want to appear empty, e.g", "label": {"api": {"GridLayout": [[3, 12]]}}}, {"text": "See also GridBagLayout and Using Layout Managers", "label": {"api": {"GridBagLayout": [[9, 21]]}}}, {"text": "If you want a quick and very-dirty fix, though, you could start playing games with JPanel.getComponentAt()", "label": {"api": {"JPanel.getComponentAt()": [[83, 105]]}}}, {"text": "The space between grid squares is given by your GridLayout object", "label": {"api": {"is given by your GridLayout object": [[31, 64]]}}}, {"text": "If this is text data (assuming you're using FileReader) then you're better off using a BufferedReader", "label": {"api": {"BufferedReader": [[87, 100]]}}}, {"text": "Best and canonical approach would be to use Java NIO memory mapped files", "label": {"api": {"Java NIO memory mapped files": [[44, 71]]}}}, {"text": "Use MappedByteBuffer.force() on each write to insure the consumer process flushes the dirty page files", "label": {"api": {"MappedByteBuffer.force()": [[4, 27]]}}}, {"text": "I can't see any drawbacks in making String.indexOf part of the interface CharSequence", "label": {"api": {"String.indexOf": [[36, 49]], "CharSequence": [[73, 84]]}}}, {"text": "It still serves as documentation, especially if you do not use a generic RuntimeException, but something more specific like IllegalArgumentException or UnsupportedOperationException or IndexOutOfBoundsException and also add some JavaDoc as to when that would happen", "label": {"api": {"UnsupportedOperationException": [[152, 180]], "IndexOutOfBoundsException": [[185, 209]]}}}, {"text": "There is another constructor that allows you to specify the encoding", "label": {"api": {"another constructor": [[9, 27]]}}}, {"text": "You see the unexpected behavior because you don't obey the contract for List.get()", "label": {"api": {"List.get()": [[72, 81]]}}}, {"text": "You may have a look at the Map class to store the phone numbers and add accessors for home, office and mobile phone entries", "label": {"api": {"Map": [[27, 29]]}}}, {"text": "The stack trace is leading you to a call to Float#valueOf(String) on line 270 of ShowInfoQuif.java", "label": {"api": {"Float#valueOf(String)": [[44, 64]]}}}, {"text": "The String argument that is being passed to Float#valueOf(String) is not in a recognized floating point number format", "label": {"api": {"Float#valueOf(String)": [[44, 64]]}}}, {"text": "It might help to log the string using Log#d(String, String) before calling Float#valueOf(String)", "label": {"api": {"Float#valueOf(String)": [[75, 95]]}}}, {"text": "The canonical way is to just use the inherited GenericServlet#getInitParameter() in the argumentless init() method (and remove any init(config) method)", "label": {"api": {"GenericServlet#getInitParameter()": [[47, 79]], "init()": [[101, 106]]}}}, {"text": "You have to use one of the constructors for Object", "label": {"api": {"constructors for Object": [[27, 49]]}}}, {"text": "According to the JSTL specification there is a class named LocaleSupport that implements the bundle lookup and may be used by any tag handler implementation that needs to produce localized messages", "label": {"api": {"LocaleSupport": [[59, 71]]}}}, {"text": "Yes; see Process#getOutputStream() to get the \"standard input\" (stdin) stream for a Process object", "label": {"api": {"Process#getOutputStream()": [[9, 33]], "Process": [[9, 15], [84, 90]]}}}, {"text": "The ProcessBuilder class even has a way to set the working directory for Processes it produces", "label": {"api": {"Process": [[4, 10], [73, 79]], "ProcessBuilder class": [[4, 23]], "set the working directory": [[43, 67]]}}}, {"text": "If you need to be able to stop a thread sitting in an accept loop, you can just call setSoTimeout so that the accept call can complete without waiting for an actual connection to happen", "label": {"api": {"setSoTimeout": [[85, 96]], "accept": [[54, 59], [110, 115]]}}}, {"text": "Groups and capturing in java.util.regex.Pattern", "label": {"api": {"Groups and capturing in java.util.regex.Pattern": [[0, 46]]}}}, {"text": "The constructor argument of the process builder is the command to execute", "label": {"api": {"constructor": [[4, 14]]}}}, {"text": "You want to set the working directory", "label": {"api": {"directory": [[28, 36]]}}}, {"text": "You can that it via the directory method", "label": {"api": {"directory": [[24, 32]]}}}, {"text": "You could substring it, and then call Integer.parseInt on the result", "label": {"api": {"substring": [[10, 18]], "Integer.parseInt": [[38, 53]]}}}, {"text": "Look into using an ArrayList", "label": {"api": {"ArrayList": [[19, 27]], "List": [[24, 27]]}}}, {"text": "This is an implementation of the List interface that is backed by an array", "label": {"api": {"List": [[33, 36]]}}}, {"text": "Start with an ArrayList and then you can call toArray() to get an actual array", "label": {"api": {"ArrayList": [[14, 22]], "toArray()": [[46, 54]]}}}, {"text": "You should use an ArrayList instead", "label": {"api": {"ArrayList": [[18, 26]]}}}, {"text": "Use a collection, like a List implementation (like ArrayList), instead of an array", "label": {"api": {"List": [[25, 28], [56, 59]], "ArrayList": [[51, 59]]}}}, {"text": "I think you would be look at String class, there are multiple ways to do it", "label": {"api": {"String": [[29, 34]]}}}, {"text": "Since you are not on the EDT, you can use SwingUtilities#invokeLater to safely perform your action on the EDT", "label": {"api": {"SwingUtilities#invokeLater": [[42, 67]]}}}, {"text": "The Servlet specification provides your web application with a special ServletContext-specific working directory which has read, write and delete permissions according to the standard security policy of Tomcat", "label": {"api": {"ServletContext": [[71, 84]]}}}, {"text": "Rather than using a low level wait/notify approach, and to avoid busy waiting with a volatile, you can use a CountDownLatch", "label": {"api": {"CountDownLatch": [[109, 122]]}}}, {"text": "A good example would be the iterator returned on a read-only collection - such as the one returned by Collections.unmodifiableCollection()", "label": {"api": {"Collections.unmodifiableCollection()": [[102, 137]]}}}, {"text": "This just means that it's optional for implementations of Iterator", "label": {"api": {"Iterator": [[58, 65]]}}}, {"text": "Some implementations provide functionality to support it, while others might throw an UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[86, 114]]}}}, {"text": "In your case, you're using an Iterator that does support that operation, so it's fine", "label": {"api": {"Iterator": [[30, 37]]}}}, {"text": "That's because arrays don't override Object.toString(), whose documentation explains what you're seeing", "label": {"api": {"Object.toString()": [[37, 53]]}}}, {"text": "To get a String representation of an array's contents, you can use Arrays.toString(Object[])", "label": {"api": {"Arrays.toString(Object[])": [[67, 91]]}}}, {"text": "I have a JDBC query that will generate a huge ResultSet which cannot be stored in memory", "label": {"api": {"ResultSet": [[46, 54]]}}}, {"text": "Is it recommanded to use obserber pattern by making the class with JDBC query as Observable", "label": {"api": {"Observable": [[81, 90]]}}}, {"text": "Or should I make that class an Iterator", "label": {"api": {"Iterator": [[31, 38]]}}}, {"text": "To prevent this, you must call responseComplete() on the FacesContext", "label": {"api": {"responseComplete()": [[31, 48]]}}}, {"text": "This should be done by calling responseComplete on the FacesContext", "label": {"api": {"responseComplete": [[31, 46]]}}}, {"text": "For the case of repeating a single character (not a String), you could use Arrays.fill", "label": {"api": {"Arrays.fill": [[75, 85]]}}}, {"text": "With Java you can use a SimpleDateFormat to parse a Date from a String", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "The HttpServletRequest exposes a method, getPathInfo(), which gives you information about the request URL after the servlet path itself", "label": {"api": {"getPathInfo()": [[41, 53]]}}}, {"text": "You could map your servlet to /Servlet/* and then get the ID with getPathInfo()", "label": {"api": {"getPathInfo()": [[66, 78]]}}}, {"text": "I parse the input with NumberFormat, but it is evil and allow almost anything", "label": {"api": {"NumberFormat": [[23, 34]]}}}, {"text": "load expects ISO 8859-1 encoding, as noted in the docs", "label": {"api": {"noted in the docs": [[37, 53]]}}}, {"text": "Have you considered using ResourceBundle", "label": {"api": {"ResourceBundle": [[26, 39]]}}}, {"text": "When you call Future.get() it will throw your exception wrapped in a ExecutionException", "label": {"api": {"Future.get()": [[14, 25]], "ExecutionException": [[69, 86]]}}}, {"text": "Creating a PKCS#12 is easy - that can be done by writing KeyStore \"PKCS12\" instance, add the certificate and keys and then save it to a file using the store(...) method", "label": {"api": {"KeyStore": [[57, 64]]}}}, {"text": "I think it's appropriate to use XSLT transform in your case (much less boilerplate code) Look at TransformerFactory and java api for xml processing", "label": {"api": {"TransformerFactory": [[97, 114]]}}}, {"text": "Check the documentation for Node", "label": {"api": {"Node": [[28, 31]]}}}, {"text": "Each node has a method getChildNodes", "label": {"api": {"Node": [[31, 34]], "getChildNodes": [[23, 35]]}}}, {"text": "You need to first call statement.executeUpdate() it will return the number of rows affected, most of the time you want to check that this is equal to 1 for INSERT and more than ZERO for UPDATE and DELETE", "label": {"api": {"statement.executeUpdate()": [[23, 47]]}}}, {"text": "If the operation takes a significant amount of time compared to lock management, using a read-write lock to eliminate the serialization bottleneck will improve performance greatly", "label": {"api": {"read-write lock": [[89, 103]]}}}, {"text": "If that's the case, you'll need to profile on the target system to see whether a synchronized block or a read-write lock is faster", "label": {"api": {"read-write lock": [[105, 119]]}}}, {"text": "It, and others like values(), valueOf(), and ordinal(), come from the Enum class", "label": {"api": {"others like values(), valueOf(), and ordinal(), come from the Enum class": [[8, 79]]}}}, {"text": "name() is defined in Enum class which satisfies your interface contract so you don't have to define name() unless of course you want to override the default behavior", "label": {"api": {"name()": [[0, 5], [100, 105]]}}}, {"text": "See the Iterator.remove() documentation", "label": {"api": {"Iterator.remove() documentation": [[8, 38]]}}}, {"text": "You probably should use a List rather than an array", "label": {"api": {"List": [[26, 29]]}}}, {"text": "For very large integers you may want to use the BigInteger class (or BigDecimal), as the values may exceed the limits of Integer", "label": {"api": {"BigInteger": [[48, 57]], "BigDecimal": [[69, 78]]}}}, {"text": "Because StyledDocument extends Document, you may be able use an implementation thereof using JTextField's setDocument() method", "label": {"api": {"StyledDocument": [[8, 21]], "Document": [[14, 21], [31, 38], [109, 116]], "setDocument()": [[106, 118]]}}}, {"text": "You should be able to create a custom exception class that extends the Exception class, for example", "label": {"api": {"Exception": [[71, 79]]}}}, {"text": "As a careful programmer will often throw an exception for a special occurrence, it worth mentioning some general purpose exceptions like IllegalArgumentException and IllegalStateException and UnsupportedOperationException", "label": {"api": {"IllegalStateException": [[166, 186]]}}}, {"text": "Use getPassword() instead of getText() method", "label": {"api": {"getPassword()": [[4, 16]]}}}, {"text": "In case for numbers bigger than MAX_LONG (~2^31) you should provide them as byte arrays using this constructor with the string representation of the number (\"1234.56\")", "label": {"api": {"this constructor": [[94, 109]]}}}, {"text": "Do you know about Comparator", "label": {"api": {"Comparator": [[18, 27]]}}}, {"text": "Once you have an instance of Comparator, you can pass it to sorting methods, such as Collections.sort", "label": {"api": {"Comparator": [[29, 38]]}}}, {"text": "So, one approach would be to write a Comparator<String> whose compare method uses a regex to extract the two Strings' number portions, and then does a numerical comparison", "label": {"api": {"Comparator": [[37, 46]]}}}, {"text": "Use ImageIO write method", "label": {"api": {"ImageIO": [[4, 10]]}}}, {"text": "Then, you can write the resulting BufferedImage with ImageIO.write() method", "label": {"api": {"ImageIO.write()": [[53, 67]]}}}, {"text": "In terms of the check itself, you could store the values in the DB using the to string method in DateFormat, and when you perform the check revert the string to a Date using the String constructor and compare", "label": {"api": {"DateFormat": [[97, 106]]}}}, {"text": "Write a Comparator that compares first with origin and then secondly with destination", "label": {"api": {"Comparator": [[8, 17]]}}}, {"text": "Use the comparator to sort the List using Collections.sort(List, Comparator)", "label": {"api": {"Comparator": [[65, 74]]}}}, {"text": "If you can push the data not in the file but into a OutputStream (or maybe write simulataneously to both FileOutputStream and other shared PipedOutputStream), this would be the easiest solution", "label": {"api": {"PipedOutputStream": [[139, 155]]}}}, {"text": "Use PipedOutputStream and PipedInputStream", "label": {"api": {"PipedOutputStream": [[4, 20]], "PipedInputStream": [[26, 41]]}}}, {"text": "Basically your downloader thread will write every bit of data it gets to the PipedOutputStream", "label": {"api": {"PipedOutputStream": [[77, 93]]}}}, {"text": "Or you can use java.nio", "label": {"api": {"java.nio": [[15, 22]]}}}, {"text": "I opted to create a utility that wraps a EntityManagerFactory in a java.lang.reflect.Proxy that implements an AutoCloseable version of the interface", "label": {"api": {"java.lang.reflect.Proxy": [[67, 89]], "AutoCloseable": [[110, 122]]}}}, {"text": "The invocation handler then intercepts calls to createEntityManager() so it can return proxied versions of the underlying EntityManager instances that also implement AutoCloseable", "label": {"api": {"AutoCloseable": [[166, 178]]}}}, {"text": "An InputStream reads bytes, and a Reader reads characters", "label": {"api": {"InputStream": [[3, 13]], "Reader": [[34, 39]]}}}, {"text": "If you know that the byte stream is representing characters, you can use an InputStreamReader to use the InputStream as a Reader", "label": {"api": {"InputStream": [[76, 86], [105, 115]], "Reader": [[87, 92], [122, 127]], "InputStreamReader": [[76, 92]]}}}, {"text": "Perhaps you could wrap the buffer in your own custom (anonymous?) InputStream since you only need to implement the read() method", "label": {"api": {"InputStream": [[66, 76]], "read()": [[115, 120]]}}}, {"text": "If you want a per-thread value, make a static ThreadLocal<T>", "label": {"api": {"ThreadLocal<T>": [[46, 59]]}}}, {"text": "If you need a variable having independent value on a thread basis, have a look at ThreadLocal", "label": {"api": {"ThreadLocal": [[82, 92]]}}}, {"text": "One option is to iterate through each method from getDeclaredMethods(), first checking the name of the method to see if that's the one you want to call, then checking if the number of actual parameters matches the number of formal parameters, and lastly, if both of those are true, iterating through its actual parameters and checking if the parameter class is assignable from your formal parameter class", "label": {"api": {"getDeclaredMethods()": [[50, 69]]}}}, {"text": "Using Java 8 Comparator.comparing", "label": {"api": {"Comparator.comparing": [[13, 32]]}}}, {"text": "Since I am using the Arrays.binarySearch", "label": {"api": {"Arrays.binarySearch": [[21, 39]]}}}, {"text": "Make use of the containsAll method in the Collection interface", "label": {"api": {"containsAll": [[16, 26]]}}}, {"text": "I'm not clear on your question, but I think that getComponentZOrder would be useful", "label": {"api": {"getComponentZOrder": [[49, 66]]}}}, {"text": "From Tree Map API", "label": {"api": {"Tree Map API": [[5, 16]]}}}, {"text": "NIO allows you to directly transfer data within kernel memory - I'm not sure if it exactly overlaps with .NET's memory stream", "label": {"api": {"NIO": [[0, 2]]}}}, {"text": "ByteArrayInputStream and ByteArrayOutputStream is what you are looking for", "label": {"api": {"ByteArrayInputStream": [[0, 19]], "ByteArrayOutputStream": [[25, 45]]}}}, {"text": "For ByteArrayOutputStream, the array will grow automatically as you write data to the stream", "label": {"api": {"ByteArrayOutputStream": [[4, 24]]}}}, {"text": "While append() was thread safe with respect to the EDT, append() in Java 7 is not", "label": {"api": {"append()": [[6, 13], [56, 63]]}}}, {"text": "Appends using invokeLater() will be processed in the order in which they are enqueued", "label": {"api": {"invokeLater()": [[14, 26]], "enqueued": [[77, 84]]}}}, {"text": "From the documentation for Runtime.loadLibrary(String), which is called by System.loadLibrary(String)", "label": {"api": {"Runtime.loadLibrary(String)": [[27, 53]]}}}, {"text": "Use the setSoTimeout() method to set a timeout for receiving a datagram", "label": {"api": {"setSoTimeout()": [[8, 21]]}}}, {"text": "Then, as per the documentation for recieve(), it will throw a SocketTimeoutException if your timeout has elapsed, allowing you to continue with your program", "label": {"api": {"recieve()": [[35, 43]]}}}, {"text": "Yes, just use the getCause() method which is inherited from Throwable (and thus available on every exception and error)", "label": {"api": {"getCause()": [[18, 27]], "Throwable": [[60, 68]]}}}, {"text": "Month in the Calendar class is from 0-11, where 0 is January", "label": {"api": {"from 0-11": [[31, 39]]}}}, {"text": "ArrayList has a indexOf() method", "label": {"api": {"indexOf() method": [[16, 31]]}}}, {"text": "Take a look at Formatter javadoc", "label": {"api": {"Formatter": [[15, 23]]}}}, {"text": "Yes, use System.out.printf, which uses a format string to specify and format it's output", "label": {"api": {"System.out.printf": [[9, 25]], "format string": [[41, 53]]}}}, {"text": "Set the spinner to use a SpinnerDateModel", "label": {"api": {"SpinnerDateModel": [[25, 40]]}}}, {"text": "Tooltips work perfectly well with JTree", "label": {"api": {"JTree": [[34, 38]]}}}, {"text": "In particular, a JTree may have \"a different tooltip based on where the mouse is.\" Registration enables getToolTipText() to \"properly display tooltips of its renderers.\" See How to Use Trees", "label": {"api": {"JTree": [[17, 21]], "different tooltip": [[35, 51]], "getToolTipText()": [[104, 119]]}}}, {"text": "Check out String replaceAll", "label": {"api": {"String replaceAll": [[10, 26]]}}}, {"text": "If entity E1 is a managed entity you can make it detached invoking (very reasonable named) method EntityManager#detach(E1)", "label": {"api": {"EntityManager#detach(E1)": [[98, 121]]}}}, {"text": "You can also use EntityManager#clear() which will clear whole PersistenceContext and effectively making all managed entities detached", "label": {"api": {"EntityManager#clear()": [[17, 37]]}}}, {"text": "You may try  Collections.copy method", "label": {"api": {"Collections.copy": [[13, 28]]}}}, {"text": "Use key Listener", "label": {"api": {"key Listener": [[4, 15]]}}}, {"text": "I want to create a simple test application with a JEditorPane displaying some HTML content and a button which makes the selected text bold", "label": {"api": {"JEditorPane": [[50, 60]]}}}, {"text": "The HTMLEditorKit already provides the necessary action for this button so I was able to use it with complicated code like this", "label": {"api": {"HTMLEditorKit": [[4, 16]]}}}, {"text": "The only official method I found for retrieving the actions seems to be this getActions() method of JEditorPane which just returns an array", "label": {"api": {"JEditorPane": [[100, 110]], "getActions()": [[77, 88]]}}}, {"text": "JFileChooser's getSelectedFile() method, returns a File object", "label": {"api": {"File": [[1, 4], [26, 29], [51, 54]]}}}, {"text": "Quoting CharSequence Javadoc", "label": {"api": {"CharSequence": [[8, 19]]}}}, {"text": "This interface does not refine the general contracts of the equals and hashCode methods", "label": {"api": {"equals": [[60, 65]], "hashCode": [[71, 78]]}}}, {"text": "The result of testing two objects that implement CharSequence for equality is therefore, in general, undefined", "label": {"api": {"CharSequence": [[49, 60]]}}}, {"text": "It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map", "label": {"api": {"CharSequence": [[47, 58]]}}}, {"text": "JWS not only provides an x-plat SingleInstanceService, but it also (from memory) pops the application toFront() on newActivation(String[])", "label": {"api": {"SingleInstanceService": [[32, 52]], "toFront()": [[102, 110]], "newActivation(String[])": [[115, 137]]}}}, {"text": "Yet, different flavors of Java VMs perform runtime-optimizations in different ways, see for instance the note on the reliability of stack traces in the docs", "label": {"api": {"stack traces": [[132, 143]]}}}, {"text": "If you want to restrict this, you've to add a synchronized lock to the method or to let the servlet implement the (deprecated!) SingleThreadModel interface", "label": {"api": {"SingleThreadModel": [[128, 144]]}}}, {"text": "Your comparator violates the transitivity requirement", "label": {"api": {"transitivity requirement": [[29, 52]]}}}, {"text": "Using the createElementNS and createAttributeNS methods will result in namespace declarations being created, but you need to understand XML namespaces", "label": {"api": {"createElementNS": [[10, 24]], "createAttributeNS": [[30, 46]]}}}, {"text": "ArrayList is unique in its naming standards", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "I was facing with this problem some time ago and I found java.util.LinkedList is best for my case", "label": {"api": {"java.util.LinkedList": [[57, 76]]}}}, {"text": "Simply create a reference to the file, and call the delete() method", "label": {"api": {"delete()": [[52, 59]]}}}, {"text": "There are also methods on the File class that allow you to create temporary files", "label": {"api": {"the File class": [[26, 39]], "create temporary files": [[59, 80]]}}}, {"text": "The delete on exit functions should be avoided, as noted by Alexander's comment, and this bug/proposed fix on the Oracle support pages", "label": {"api": {"delete on exit functions": [[4, 27]]}}}, {"text": "All file access (reading, writing, deleting) is run through a SecurityManager, so if the user under which your application is running doesn't have the necessary security rights to the file in question, these operations may fail", "label": {"api": {"SecurityManager": [[62, 76]]}}}, {"text": "You seem resistant against passing in the Class object, but it's the only way to use the method getEnumConstants()", "label": {"api": {"getEnumConstants()": [[96, 113]]}}}, {"text": "See the Javadocs on BoxLayout and the Java tutorial on BoxLayout for details", "label": {"api": {"the Javadocs on BoxLayout": [[4, 28]]}}}, {"text": "Use a RandomAccessFile", "label": {"api": {"RandomAccessFile": [[6, 21]]}}}, {"text": "If not, I'd strongly recommend using Scanner instead", "label": {"api": {"Scanner": [[37, 43]]}}}, {"text": "HashMap is not neither sorted nor order, you can use TreeMap", "label": {"api": {"TreeMap": [[53, 59]]}}}, {"text": "It doesn't extend a class - it implements the Serializable interface, which is basically just a marker interface to say \"I'm fine to be serialized\"", "label": {"api": {"Serializable": [[46, 57]]}}}, {"text": "You could write a method that will do the conversion using the parseInt method on each element", "label": {"api": {"parseInt": [[63, 70]]}}}, {"text": "Use JTable.getRowSorter() to get the RowSorter", "label": {"api": {"JTable.getRowSorter()": [[4, 24]]}}}, {"text": "Then call getSortKey()", "label": {"api": {"getSortKey()": [[10, 21]], "SortKey": [[13, 19]]}}}, {"text": "The SortKey will tell you what you want to know", "label": {"api": {"SortKey": [[4, 10]]}}}, {"text": "As stated on SwingWorker docs", "label": {"api": {"SwingWorker": [[13, 23]]}}}, {"text": "Have you looked at AffineTransform", "label": {"api": {"AffineTransform": [[19, 33]]}}}, {"text": "You would be better off using an implementation of List, for example an ArrayList", "label": {"api": {"ArrayList": [[72, 80]]}}}, {"text": "Use the getInputStream()-method", "label": {"api": {"getInputStream()-method": [[8, 30]]}}}, {"text": "For IPC in a single JVM, you can look into java.util.concurrent package, such as ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[81, 101]]}}}, {"text": "With regard to the latter, use EventObject.getSource to determine which component fired the event", "label": {"api": {"EventObject.getSource": [[31, 51]]}}}, {"text": "You most likely want to use a Date or a Calendar as your data type to hold the instance", "label": {"api": {"Date": [[30, 33]], "Calendar": [[40, 47]]}}}, {"text": "You can then choose to display the date using a DateFormat, which you could configure exactly as you stated - probably a SimpleDateFormat", "label": {"api": {"Date": [[48, 51], [127, 130]], "DateFormat": [[48, 57], [127, 136]], "SimpleDateFormat": [[121, 136]]}}}, {"text": "You can either keep the month, day, and year of a date in three different integers, create your own object encapsulating these three integers, or use the Date object", "label": {"api": {"Date": [[154, 157]]}}}, {"text": "You would need to spawn off a new Thread for that portion of logic that involves the 10 minute wait, allowing your loop to continue uninterrupted", "label": {"api": {"Thread": [[34, 39]]}}}, {"text": "Also consider using a TimerTask and Timer (which creates the Thread for you)", "label": {"api": {"Thread": [[61, 66]], "TimerTask": [[22, 30]], "Timer": [[22, 26], [36, 40]]}}}, {"text": "Yes, ObjectOutputStream can serialize a complex tree of objects as long as all objects in this tree implement Serializable", "label": {"api": {"ObjectOutputStream": [[5, 22]], "Serializable": [[110, 121]]}}}, {"text": "SAX – You create one using the SAXParserFactory helper class", "label": {"api": {"SAX": [[0, 2], [31, 33]], "SAXParserFactory": [[31, 46]]}}}, {"text": "It's also fairly difficult to use because it's used by passing a bunch of callback for the parser to invoke you have to keep track of where you are in the document yourself, and with StAX being available there's pretty much no reason to use it", "label": {"api": {"StAX": [[183, 186]]}}}, {"text": "DOM – You create a parser using a DocumentBuilderFactory", "label": {"api": {"DOM": [[0, 2]], "DocumentBuilderFactory": [[34, 55]]}}}, {"text": "There's two fairly popular alternative DOM-style APIs that are more Java-like, JDOM and dom4j", "label": {"api": {"DOM": [[39, 41], [80, 82]]}}}, {"text": "StAX – the new kid on the block, Java-specific, and my personal favourite", "label": {"api": {"StAX": [[0, 3]]}}}, {"text": "This makes it much faster than DOM while much easier to wrap your head around", "label": {"api": {"DOM": [[31, 33]]}}}, {"text": "You start by using XMLInputFactory to read XML and XMLOutputFactory to write it", "label": {"api": {"XMLInputFactory": [[19, 33]], "XMLOutputFactory": [[51, 66]]}}}, {"text": "I believe it uses JAXB for this, also a part of the standard library", "label": {"api": {"JAXB": [[18, 21]]}}}, {"text": "JAXB will serialise a Java object automatically based on annotations on the class and its fields / properties that control the serialisation", "label": {"api": {"JAXB": [[0, 3]]}}}, {"text": "To obtain a collection of only the unique elements from a list, you can just add all the elements to a Set", "label": {"api": {"Set": [[103, 105]]}}}, {"text": "It seems your question is unrelated to LinkedList", "label": {"api": {"LinkedList": [[39, 48]]}}}, {"text": "This is necessary because of Type Erasure, which means T will have no meaning at runtime (Array.newInstance takes a Class object representing the array's element type for the same reason)", "label": {"api": {"Array.newInstance": [[90, 106]]}}}, {"text": "Check the API for more exit operations", "label": {"api": {"API": [[10, 12]]}}}, {"text": "You can simulate mouse presses and mouse actions by using the Robot class", "label": {"api": {"Robot": [[62, 66]]}}}, {"text": "You should use an Border for that, more specifictly you should use BorderFactory.createEmptyBorder(int top, int left, int bottom, int right)", "label": {"api": {"BorderFactory.createEmptyBorder(int top, int left, int bottom, int right)": [[67, 139]]}}}, {"text": "Write your entire project in a .NET language and use the SerialPort class built in with .NET", "label": {"api": {"SerialPort": [[57, 66]]}}}, {"text": "Write your entire project in java and use the SerialPort class built in with java", "label": {"api": {"SerialPort": [[46, 55]]}}}, {"text": "At most, you might consider using StringBuilder or MessageFormat in your setText() invocation", "label": {"api": {"StringBuilder": [[34, 46]], "MessageFormat": [[51, 63]]}}}, {"text": "Rather than using an ArrayList, use a BlockingQueue of some description (e.g", "label": {"api": {"BlockingQueue": [[38, 50]]}}}, {"text": "You could simply add a Thread.sleep(100) to your loop while waiting for input", "label": {"api": {"add a Thread.sleep(100) to your loop": [[17, 52]]}}}, {"text": "You can use the Timer class with the method", "label": {"api": {"Timer": [[16, 20]]}}}, {"text": "Read the ExecutorService#shutdownNow() javadoc", "label": {"api": {"ExecutorService#shutdownNow()": [[9, 37]]}}}, {"text": "For example, typical implementations will cancel via Thread.interrupt(), so any task that fails to respond to interrupts may never terminate", "label": {"api": {"Thread.interrupt()": [[53, 70]]}}}, {"text": "So, you need to regularly check Thread#isInterrupted() inside the call() yourself", "label": {"api": {"Thread#isInterrupted()": [[32, 53]]}}}, {"text": "You could also use an implementation of Map, for example a TreeMap, using the character as the Key and the number as the Value", "label": {"api": {"Map": [[40, 42], [63, 65]], "TreeMap": [[59, 65]]}}}, {"text": "Instead of creating new threads, you should at least use a thread pool (see Executor for further details)", "label": {"api": {"Executor": [[76, 83]]}}}, {"text": "This is the generic version of toArray() which in your case will return a float[][]", "label": {"api": {"toArray()": [[31, 39]]}}}, {"text": "The method you're trying to override has the following signature", "label": {"api": {"method": [[4, 9]]}}}, {"text": "To override it, your method's argument therefore has to be of type Object, not String", "label": {"api": {"method": [[21, 26]]}}}, {"text": "One approach would be to render the existing image and drawing into a BufferedImage, as shown in this example that overlays text on a logo", "label": {"api": {"BufferedImage": [[70, 82]]}}}, {"text": "Once the image is complete, use ImageIO.write() to save it in the desired format", "label": {"api": {"ImageIO.write()": [[32, 46]]}}}, {"text": "If you insist on writing your own RTF reader, the correct approach would be for you to extend  FilterInputStream and handle the RTF metadata in its implementation", "label": {"api": {"FilterInputStream": [[95, 111]]}}}, {"text": "Alternatively you can use EnumSet", "label": {"api": {"EnumSet": [[26, 32]]}}}, {"text": "Seems you want array of ordinal positions of your emum's values (why would anybody use an Array instead of right Collection nowadays?)", "label": {"api": {"ordinal": [[24, 30]]}}}, {"text": "If so, what you're looking for is an associative array, which in Java is modelled as a Map", "label": {"api": {"Map": [[87, 89]]}}}, {"text": "So you can use some Map<type, Integer> to achieve what you want (preferably an EnumMap which is optimized for using Enum keys)", "label": {"api": {"Map": [[20, 22], [83, 85]]}}}, {"text": "After calling setDefaultCloseOperation(DO_NOTHING_ON_CLOSE), add a WindowListener or WindowAdapter and in the windowClosing(WindowEvent) method, pop a JOptionPane", "label": {"api": {"WindowListener": [[67, 80]], "JOptionPane": [[151, 161]]}}}, {"text": "If you are using Java 7, there is the relativize method of the Path class that does what you need", "label": {"api": {"relativize method": [[38, 54]]}}}, {"text": "NumberFormat is probably the best way to go", "label": {"api": {"NumberFormat": [[0, 11]]}}}, {"text": "look at Arrays.sort(T[], Comparator<", "label": {"api": {"Comparator": [[25, 34]]}}}, {"text": "super T>), as well as the Comparator interface", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "Alternatively, you could use an Iterator and its remove() method, which would handle this for you automatically", "label": {"api": {"Iterator": [[32, 39]]}}}, {"text": "Looking at the documentation (UploadedFile and File) for both classes, here's one solution", "label": {"api": {"File": [[38, 41], [47, 50]]}}}, {"text": "Since you can access the InputStream of the UploadedFile, you can read in  the data of the uploaded file and write it to a temporary location or another location that your application can manage", "label": {"api": {"File": [[52, 55]]}}}, {"text": "Rename operation is platform dependent, it may or may not succeed, no guarantee", "label": {"api": {"platform dependent": [[20, 37]]}}}, {"text": "Have a look at Timer and TimerTask classes", "label": {"api": {"Timer": [[15, 19], [25, 29]], "TimerTask": [[25, 33]]}}}, {"text": "See Desktop.open(File) for a way to open a PDF across different platforms", "label": {"api": {"Desktop.open(File)": [[4, 21]]}}}, {"text": "Read the long disclaimer on the deprecated Thread#stop method", "label": {"api": {"long disclaimer on the deprecated Thread#stop method": [[9, 60]]}}}, {"text": "Or you can use thread pool that is part of JDK, such as ExecutorService", "label": {"api": {"ExecutorService": [[56, 70]]}}}, {"text": "To obtain the Graphical bound, use TextLayout.getBounds instead", "label": {"api": {"TextLayout.getBounds": [[35, 54]]}}}, {"text": "You have to update the model object", "label": {"api": {"model": [[23, 27]]}}}, {"text": "Please note though, that not all annotations are available at runtime - it depends on their retention policy", "label": {"api": {"retention policy": [[92, 107]]}}}, {"text": "If @NotNull has a retention policy of RUNTIME, then it's fine, otherwise you'd have to do something at compile time", "label": {"api": {"retention policy": [[18, 33]]}}}, {"text": "The endsWith method of the String class looks for a string and not a pattern at the end of another string", "label": {"api": {"endsWith": [[4, 11]]}}}, {"text": "iText's Jpeg class requires a URL in its constructor to locate an image/jpg that you want to add to the PDF file", "label": {"api": {"URL": [[30, 32]]}}}, {"text": "When I set this URL to the absolute file path of my JPG file, I get a MalformedURLException claiming unknown protocol", "label": {"api": {"URL": [[16, 18], [79, 81]]}}}, {"text": "Is there any hack/circumvention to this, or do I have to host this JPG somewhere and have the URL find it over the net", "label": {"api": {"URL": [[94, 96]]}}}, {"text": "The URL does properly escape the string (thus \"\\\" are converted to \"\\ \\\", etc.)", "label": {"api": {"URL": [[4, 6]]}}}, {"text": "If you want quick ways to pop a general dialog box then look at JOptionPane", "label": {"api": {"JOptionPane": [[64, 74]]}}}, {"text": "Though you probably really want to look at the JOptionPane.showXxxDialog static methods", "label": {"api": {"JOptionPane": [[47, 57]]}}}, {"text": "All the dialogs produced by the java web start application can be produced using the JOptionPane class", "label": {"api": {"JOptionPane": [[85, 95]]}}}, {"text": "As far as I can see from MySQL docs, java.sql.Timestamp should just work if you read it from or write it to a TIMESTAMP field in the database", "label": {"api": {"java.sql.Timestamp": [[37, 54]], "read": [[80, 83]], "write": [[96, 100]]}}}, {"text": "I would prefer not to use String.trim to check for existence of whitespace", "label": {"api": {"String.trim": [[26, 36]]}}}, {"text": "Or taking a cue from String.trim's implementation, you could use character comparison rather than Character.isWhitespace()", "label": {"api": {"String.trim": [[21, 31]]}}}, {"text": "This is related to how PrintWriter.println() generates the Line break depending of the Operating System", "label": {"api": {"PrintWriter.println()": [[23, 43]]}}}, {"text": "You can use Java's SimpleDateFormat to easily convert to a Date instance", "label": {"api": {"SimpleDateFormat": [[19, 34]], "Date": [[25, 28], [59, 62]]}}}, {"text": "Also, if you have fixed sizes and lengths, you can most likely get away with a .substring method, it is less complex", "label": {"api": {".substring": [[79, 88]]}}}, {"text": "Consult the JScrollPane documentation for these methods", "label": {"api": {"JScrollPane documentation": [[12, 36]]}}}, {"text": "This is because you're calling equals() on the array instances themselves instead of their Class object", "label": {"api": {"equals()": [[31, 38]]}}}, {"text": "The default implementation of equals() is defined by Object.equals(Object)", "label": {"api": {"Object.equals(Object)": [[53, 73]]}}}, {"text": "Check the ResultSet documentation", "label": {"api": {"ResultSet documentation": [[10, 32]]}}}, {"text": "If the objects are beans, then you can use the java.beans API", "label": {"api": {"java.beans API": [[47, 60]]}}}, {"text": "It lets you query what the fields of the bean are, via Introspector", "label": {"api": {"Introspector": [[55, 66]]}}}, {"text": "See the documentation for java.net.URLConnection", "label": {"api": {"the documentation for java.net.URLConnection": [[4, 47]]}}}, {"text": "Implement Cloneable and use this.clone(), just like any other variable", "label": {"api": {"Cloneable": [[10, 18]]}}}, {"text": "I've used Callable ( http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Callable.html) to implement callbacks/functors in java", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Callable.html": [[21, 99]]}}}, {"text": "In Java 8, the java.util.function.Consumer class does exactly what you want", "label": {"api": {"the java.util.function.Consumer class": [[11, 47]]}}}, {"text": "Method class has its place when one needs to use reflection, which is much slower than regular method call", "label": {"api": {"Method": [[0, 5]]}}}, {"text": "MethodHandler is part of JSR 292", "label": {"api": {"Method": [[0, 5]], "MethodHandler": [[0, 12]]}}}, {"text": "I do know that, relative to the workarounds to this issue, Array.newInstance() is an expensive method to call", "label": {"api": {"Array.newInstance()": [[59, 77]]}}}, {"text": "You may write a filter and check whether a session attribute is exists in the session object", "label": {"api": {"filter": [[16, 21]]}}}, {"text": "On your FileOutputStream constructor, you need to add the boolean append parameter", "label": {"api": {"constructor": [[25, 35]]}}}, {"text": "Try RandomAccessFile if your trying to write at certain byte offsets", "label": {"api": {"RandomAccessFile": [[4, 19]]}}}, {"text": "intern method is part of standard Java String API", "label": {"api": {"intern": [[0, 5]]}}}, {"text": "I am having trouble using Iterator in java", "label": {"api": {"Iterator": [[26, 33]]}}}, {"text": "You can either get hold of a new Iterator instance or use ListIterator interface which allows you to look backwards using previous()", "label": {"api": {"ListIterator": [[58, 69]]}}}, {"text": "To get 4 buttons underneath each other, put them in a single column GridLayout", "label": {"api": {"GridLayout": [[68, 77]]}}}, {"text": "To get then to move relative to the RHS of the frame, put the (panel with the GridLayout) into the EAST constraint of a BorderLayout", "label": {"api": {"GridLayout": [[78, 87]], "BorderLayout": [[120, 131]]}}}, {"text": "You could use the LinkedHashMap for your propose", "label": {"api": {"LinkedHashMap": [[18, 30]]}}}, {"text": "Or you can keep the rows in memory(such as in a Set) to avoid duplicate rows, but this is not applicable when there are too many rows", "label": {"api": {"Set": [[48, 50]]}}}, {"text": "This can be done by adding a ComponentListener to the Component that you use as your output card", "label": {"api": {"ComponentListener": [[29, 45]]}}}, {"text": "This way you can override the componentShown method so that it calls your custom refresh method", "label": {"api": {"componentShown": [[30, 43]]}}}, {"text": "If you have a dedicated data model then you could use the Observer / Observable pattern to notify changed from an internal model, or you could hard-code the model to call refresh whenever it is changed", "label": {"api": {"Observer": [[58, 65]], "Observable": [[69, 78]]}}}, {"text": "I believe the java.text.DecimalFormat class is what you need", "label": {"api": {"java.text.DecimalFormat": [[14, 36]]}}}, {"text": "The DecimalFormat could also be of assistance here", "label": {"api": {"DecimalFormat": [[4, 16]]}}}, {"text": "There are also WindowEvents that are triggered whenever the state is changed and a WindowListener interface that handles these triggers.In this case, you might use", "label": {"api": {"WindowEvents": [[15, 26]], "WindowListener": [[83, 96]]}}}, {"text": "URI encoding the password (and preferably the user name as well) should work just fine", "label": {"api": {"URI encoding": [[0, 11]]}}}, {"text": "For hardware acceleration, you need to use the VolatileImage class", "label": {"api": {"VolatileImage": [[47, 59]]}}}, {"text": "In JSF, validation should absolutely not be done inside a managed bean action method, but inside a fullworthy Validator implementation", "label": {"api": {"Validator": [[110, 118]]}}}, {"text": "for Component.requestFocus() state", "label": {"api": {"Component.requestFocus()": [[4, 27]]}}}, {"text": "Because the focus behavior of this method is platform-dependent, developers are strongly encouraged to use requestFocusInWindow when possible", "label": {"api": {"requestFocusInWindow": [[107, 126]]}}}, {"text": "This is needed since the first argument to replaceAll() is a regular expression, and { has a special meaning in Java regular expressions (it's a repetition operator, hence the error message)", "label": {"api": {"replaceAll()": [[43, 54]], "regular expression": [[61, 78], [117, 134]]}}}, {"text": "You could print through a PrintStream", "label": {"api": {"PrintStream": [[26, 36]]}}}, {"text": "To write text (rather than raw bytes) to a file you should consider using FileWriter", "label": {"api": {"FileWriter": [[74, 83]]}}}, {"text": "You should also wrap it in a BufferedWriter which will then give you the newLine method", "label": {"api": {"BufferedWriter": [[29, 42]], "newLine": [[73, 79]]}}}, {"text": "To write each word on a new line, use String.split to break your text into an array of words", "label": {"api": {"String.split": [[38, 49]]}}}, {"text": "The solution is to use BigInteger.pow()", "label": {"api": {"BigInteger.pow()": [[23, 38]]}}}, {"text": "Instead, use BigInteger or BigDecimal for your calculation", "label": {"api": {"BigInteger": [[13, 22]], "BigDecimal": [[27, 36]]}}}, {"text": "Instead, I use some higher-level construct from the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[52, 71]]}}}, {"text": "If you want examples, take a look at Arrays", "label": {"api": {"Arrays": [[37, 42]]}}}, {"text": "One way to do what you're trying to do is to use a Matcher and a loop", "label": {"api": {"Matcher": [[51, 57]]}}}, {"text": "The documentation of the String.split() method mention that the trailing empty string are skipped", "label": {"api": {"String.split()": [[25, 38]]}}}, {"text": "Is there any thread-safe substitute for java.io.OutputStreamWriter in the JDK or some third party library", "label": {"api": {"java.io.OutputStreamWriter": [[40, 65]]}}}, {"text": "In the absence of strict requirements about happens-before relationships and point in time correctness, the sensible thing to do in modern java is usually just use a ConcurrentMap", "label": {"api": {"ConcurrentMap": [[166, 178]]}}}, {"text": "You can either implement the Comparator interface, as shown in How to Use Tables", "label": {"api": {"Comparator": [[29, 38]]}}}, {"text": "Sorting and Filtering, or implement the Comparable Interface, as shown in the  class Value of this example", "label": {"api": {"Comparable": [[40, 49]]}}}, {"text": "As @kleopatra's answer notes, the Comparator must be applied in the context of the table's RowSorter, while an implementation of Comparable would affect the natural ordering", "label": {"api": {"Comparator": [[34, 43]], "Comparable": [[129, 138]]}}}, {"text": "They exist in JSE as well, e.g., Map.Entry", "label": {"api": {"Map.Entry": [[33, 41]]}}}, {"text": "Alternatively you could let your object implement the Externalizable interface but this requires you to implement both the readExternal and writeExternal methods, so you still end up serializing the object yourself", "label": {"api": {"Externalizable": [[54, 67]]}}}, {"text": "Perhaps a NavigableMap will do what you want, depending on what the condition is", "label": {"api": {"NavigableMap": [[10, 21]]}}}, {"text": "RandomAccessFile if you are on Java 1.4 or above", "label": {"api": {"RandomAccessFile": [[0, 15]]}}}, {"text": "Better you use SwingWorker", "label": {"api": {"SwingWorker": [[15, 25]]}}}, {"text": "Date is a concrete date", "label": {"api": {"Date": [[0, 3]]}}}, {"text": "Calendar is a tool for working with dates", "label": {"api": {"Calendar": [[0, 7]]}}}, {"text": "To check at runtime, you need an instance of a class, so that you can use isAssignableFrom", "label": {"api": {"isAssignableFrom": [[74, 89]]}}}, {"text": "An alternative solution would be to use TreeMap's headMap method", "label": {"api": {"headMap": [[50, 56]]}}}, {"text": "If the word exists in the TreeMap, then the size() of its head map is equal to the index of the word in the dictionary", "label": {"api": {"size()": [[44, 49]]}}}, {"text": "Have you considered putting you elements into a HashSet instead", "label": {"api": {"HashSet": [[48, 54]]}}}, {"text": "If you have duplicates you could construct HashMap that has the value as the key and the count as the value", "label": {"api": {"HashMap": [[43, 49]]}}}, {"text": "Your class voilates the joint contract on equals() and hashCode()", "label": {"api": {"equals()": [[42, 49]], "hashCode()": [[55, 64]]}}}, {"text": "To fix, override hashCode() [for example, to simply return this.id]", "label": {"api": {"hashCode()": [[17, 26]]}}}, {"text": "The javax.servlet.request.X509Certificate request attribute should return an array of java.security.cert.X509Certificate", "label": {"api": {"java.security.cert.X509Certificate": [[86, 119]]}}}, {"text": "From http://docs.oracle.com/javase/6/docs/api/java/text/DecimalFormat.html stems the following \"explanation.\" One wonders", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/DecimalFormat.html": [[5, 73]]}}}, {"text": "You can get further information in the Java 8 API Documentation, which may be newer than the one you were looking at so far", "label": {"api": {"Java 8 API Documentation": [[39, 62]]}}}, {"text": "Instead of KeyListener, I'd recommend adding Action instances to your JPopupMenu", "label": {"api": {"JPopupMenu": [[70, 79]]}}}, {"text": "Use setComponentPopupMenu() to add the popup to your panel", "label": {"api": {"setComponentPopupMenu()": [[4, 26]]}}}, {"text": "You can find more on the methods of URLConnection() here", "label": {"api": {"URLConnection()": [[36, 50]]}}}, {"text": "See this related question and also the API for BufferStrategy", "label": {"api": {"BufferStrategy": [[47, 60]]}}}, {"text": "However, a more literal answer to your question is that Java provides an interface for String-like objects, java.lang.CharSequence, and many parts of the standard Java libraries have been updated to accept CharSequence where appropriate", "label": {"api": {"java.lang.CharSequence": [[108, 129]]}}}, {"text": "To dynamically get the port number of the current HTTP servlet request, you need to use HttpServletRequest#getServerPort() or HttpServletRequest#getLocalPort() instead, depending on which port number exactly you'd like to obtain", "label": {"api": {"HttpServletRequest#getServerPort()": [[88, 121]], "HttpServletRequest#getLocalPort()": [[126, 158]]}}}, {"text": "Please note that you'd normally use HttpServletRequest#getContextPath() to obtain the context name", "label": {"api": {"HttpServletRequest#getContextPath()": [[36, 70]]}}}, {"text": "If you need arbitrary precision you should be using BigDecimal instead", "label": {"api": {"BigDecimal": [[52, 61]]}}}, {"text": "The \"right\" date type totally depends on your application; however, java.util.Calendar is generally accepted as the replacement for java.util.Date as it provides more functionality (especially regarding extraction of individual date elements like year, month, etc)", "label": {"api": {"java.util.Calendar": [[68, 85]], "java.util.Date": [[132, 145]]}}}, {"text": "In reality, Date can be much easier to use for certain situations (and is the one used by Java's own DateFormat classes), so it's a judgement call", "label": {"api": {"DateFormat": [[101, 110]]}}}, {"text": "Their least upper bound of JButton and JRadioButton is AbstractButton", "label": {"api": {"AbstractButton": [[55, 68]]}}}, {"text": "JRadioButton does not extend JButton", "label": {"api": {"JRadioButton": [[0, 11]]}}}, {"text": "Knowing that you are dealing with a UTF-8 byte array, you'll definitely want to use the String constructor that accepts a charset name", "label": {"api": {"String constructor that accepts a charset name": [[88, 133]]}}}, {"text": "Note that it throws UnsupportedEncodingException which you'll have to handle", "label": {"api": {"UnsupportedEncodingException": [[20, 47]]}}}, {"text": "According to the class documentation", "label": {"api": {"the class documentation": [[13, 35]]}}}, {"text": "What happens if AtomicInteger reaches Integer.MAX_VALUE and is incremented", "label": {"api": {"AtomicInteger": [[16, 28]]}}}, {"text": "Don't use Timer, try ScheduledExecutorService instead", "label": {"api": {"ScheduledExecutorService": [[21, 44]]}}}, {"text": "Combine a call to Executors.newSingleThreadScheduledExecutor with a custom ThreadFactory that creates the thread with the group you want", "label": {"api": {"Executors.newSingleThreadScheduledExecutor": [[18, 59]], "ThreadFactory": [[75, 87]]}}}, {"text": "Use HttpServletResponse.encodeURL() to append jsessionid to your URL, but it is considered harmful", "label": {"api": {"HttpServletResponse.encodeURL()": [[4, 34]]}}}, {"text": "Why you don't take a look in java.util.BlockingQueue", "label": {"api": {"java.util.BlockingQueue": [[29, 51]]}}}, {"text": "Particularly take a look at java.util.LinkedBlockingQueue, where if you specify the queue's capacity in the constructor, then the queue will block", "label": {"api": {"java.util.LinkedBlockingQueue": [[28, 56]]}}}, {"text": "Also, the condition to wait on is checked in an if conditional, but it should ideally be checked in a while loop to avoid spurious wakeups", "label": {"api": {"spurious wakeups": [[122, 137]]}}}, {"text": "In general an object can be removed in two ways from an ArrayList (or generally any List), by index (remove(int)) and by object (remove(Object))", "label": {"api": {"ArrayList": [[56, 64]], "List": [[61, 64], [84, 87]], "remove(int)": [[101, 111]], "remove(Object)": [[129, 142]]}}}, {"text": "Add an equals(Object) method to your ArrayTest class", "label": {"api": {"equals(Object)": [[7, 20]]}}}, {"text": "That will allow ArrayList.remove(Object) to identify the correct object", "label": {"api": {"ArrayList": [[16, 24]], "List": [[21, 24]], "remove(Object)": [[26, 39]], "ArrayList.remove(Object)": [[16, 39]]}}}, {"text": "You should use String.toCharArray()", "label": {"api": {"String.toCharArray()": [[15, 34]]}}}, {"text": "You can use the toCharArray() method to get a char array from your String", "label": {"api": {"toCharArray()": [[16, 28]]}}}, {"text": "If you need to split with a given delimiter to determine the array lines, you use first the Split method on the String, then use toCharArray to create your 2 dimensional array", "label": {"api": {"Split": [[92, 96]]}}}, {"text": "Read the docs here", "label": {"api": {"Read the docs here": [[0, 17]]}}}, {"text": "See the class java.util.jar.JarOutputStream (and many examples of usage on the web)", "label": {"api": {"java.util.jar.JarOutputStream": [[14, 42]]}}}, {"text": "Compiling your Java source files into Class files on the fly is a separate task, fraught with its own complications, but the class javax.tools.JavaCompiler is a good starting point", "label": {"api": {"javax.tools.JavaCompiler": [[131, 154]]}}}, {"text": "I'm building an HTML editor using JEditorPane, but I'm getting some inconsistent performance issues with Foreground Actions", "label": {"api": {"JEditorPane": [[34, 44]]}}}, {"text": "If you need different sort orders, it's easier to implement multiple comparators (Comparator<Paint>) and pass the appropriate one to the sort() function", "label": {"api": {"Comparator<Paint>": [[82, 98]], "sort()": [[137, 142]]}}}, {"text": "You can use reflection for this; see the documentation for java.lang.reflect.Field", "label": {"api": {"the documentation for java.lang.reflect.Field": [[37, 81]]}}}, {"text": "You can use java.lang.management.MemoryUsage to determine the used memory, and total memory available", "label": {"api": {"java.lang.management.MemoryUsage": [[12, 43]]}}}, {"text": "From the Java documentation for Files.setOwner(File, UserPrincipal)", "label": {"api": {"Files.setOwner(File, UserPrincipal)": [[32, 66]]}}}, {"text": "Completely untested, but have you tried NetworkInterface.isVirtual()", "label": {"api": {"NetworkInterface": [[40, 55]], "isVirtual()": [[57, 67]]}}}, {"text": "Assuming there are no invariants involving both hash maps or some other state variables you can simply use ConcurrentHashMap to accomplish this", "label": {"api": {"ConcurrentHashMap": [[107, 123]]}}}, {"text": "in classes BufferedImage and AffineTransform", "label": {"api": {"BufferedImage": [[11, 23]], "AffineTransform": [[29, 43]]}}}, {"text": "Class has a method on it called newInstance for creating instances of that class", "label": {"api": {"newInstance": [[32, 42]]}}}, {"text": "You might also look into the whole java.lang.reflect package", "label": {"api": {"java.lang.reflect package": [[35, 59]]}}}, {"text": "Use a JTable instead (for what is apparently tabular information)", "label": {"api": {"JTable": [[6, 11]]}}}, {"text": "Also, in order to make your life easier and avoid the padding hell, use String.format with it's syntax", "label": {"api": {"String.format": [[72, 84]], "syntax": [[96, 101]]}}}, {"text": "For this purpose, use Character.MIN_VALUE", "label": {"api": {"Character.MIN_VALUE": [[22, 40]]}}}, {"text": "In what situations is annotation javax.annotation.security.DenyAll useful", "label": {"api": {"javax.annotation.security.DenyAll": [[33, 65]]}}}, {"text": "If you want a generic solution to the problem you would have to extract getters and setters into an interface and then use a Proxy to either intercept all methods starting with set or have them annotated(and process annotations in your Handler) and then either do nothing or preferrably throw an UnsupportedOperationException", "label": {"api": {"Proxy": [[125, 129]]}}}, {"text": "You could easily use a Proxy for this (java.lang.reflect.Proxy), then you just look at the invoked method name (check if it starts with set, roughly)", "label": {"api": {"Proxy": [[23, 27], [57, 61]]}}}, {"text": "You can do this using java.util.concurrency.ExecutorService", "label": {"api": {"java.util.concurrency.ExecutorService": [[22, 58]]}}}, {"text": "If the instance of your class should only be used by one thread at a time then you could use a BlockingQueue with a size of one", "label": {"api": {"BlockingQueue": [[95, 107]]}}}, {"text": "When done it would put it back in the BlockingQueue letting the next thread get the class", "label": {"api": {"BlockingQueue": [[38, 50]]}}}, {"text": "You could create a thread-local cache to avoid sharing cached instances with different threads", "label": {"api": {"thread-local": [[19, 30]]}}}, {"text": "You can do this primitively with SwingUtilities.invokeAndWait(Runnable) or SwingUtilities.invokeLater(Runnable)", "label": {"api": {"SwingUtilities.invokeAndWait(Runnable)": [[33, 70]], "SwingUtilities.invokeLater(Runnable)": [[75, 110]]}}}, {"text": "Or you can use the higher-level framework provided by the SwingWorker class", "label": {"api": {"SwingWorker": [[58, 68]]}}}, {"text": "With JPA 2.0 you can do same also to field where key of the map is persisted with MapKeyColumn annotation", "label": {"api": {"MapKeyColumn": [[82, 93]]}}}, {"text": "(EDIT Also, since there's no method to parse XML from a Reader, you need to wrap the reader in an InputSource)", "label": {"api": {"InputSource": [[98, 108]]}}}, {"text": "Btw there is a high level File class for doing high level operations", "label": {"api": {"File": [[26, 29]]}}}, {"text": "You could just create a PDF file, and opening it with the Desktop class", "label": {"api": {"Desktop": [[58, 64]]}}}, {"text": "Make a List<JInternalFrame> and check isSelected() as you iterate though it", "label": {"api": {"isSelected()": [[38, 49]]}}}, {"text": "Use JDekstopPane.getSelectedFrame()  method (From doc", "label": {"api": {"JDekstopPane.getSelectedFrame()": [[4, 34]]}}}, {"text": "In your code you need an InternalFrameListener (API) (Tutorial) and listen to activate/deactivate events", "label": {"api": {"API": [[48, 50]]}}}, {"text": "System.gc() is just a hint to the JVM that garbage collection is suggested, however Java is running it at its own will", "label": {"api": {"System.gc()": [[0, 10]]}}}, {"text": "The + sign in the context of strings is the concatenation operator", "label": {"api": {"concatenation operator": [[44, 65]]}}}, {"text": "The same listener can be added to several components, and the component triggering the event is available using the event's getSource() or getComponent() method", "label": {"api": {"getSource()": [[124, 134]], "getComponent()": [[139, 152]]}}}, {"text": "If so, you should consider using EnumMap", "label": {"api": {"EnumMap": [[33, 39]]}}}, {"text": "You can call requestFocusInWindow() for the textfield you want focus", "label": {"api": {"requestFocusInWindow()": [[13, 34]]}}}, {"text": "I suggest you use the Timer class to easily schedule the execution of code periodically", "label": {"api": {"Timer": [[22, 26]]}}}, {"text": "startElement() has a argument called attributes", "label": {"api": {"startElement()": [[0, 13]]}}}, {"text": "the @Override and the @SuppressWarnings from the Java specs", "label": {"api": {"@Override": [[4, 12]], "@SuppressWarnings": [[22, 38]]}}}, {"text": "You will probably want to look at Java's Math package", "label": {"api": {"Math package": [[41, 52]]}}}, {"text": "If having enough precision for really really large numbers is important to you, you may also want to look into classes such as BigDecimal or BigInteger", "label": {"api": {"BigDecimal": [[127, 136]], "BigInteger": [[141, 150]]}}}, {"text": "Is your supervisor familiar with a BitSet", "label": {"api": {"BitSet": [[35, 40]]}}}, {"text": "However, using a BitSet, you won't need to worry about dealing with the combination of 2 longs", "label": {"api": {"BitSet": [[17, 22]]}}}, {"text": "BitSet also provides methods for all the common bit operations", "label": {"api": {"BitSet": [[0, 5]]}}}, {"text": "I think what you're missing is how the abstract concept of the Graph is modeled by your use of the Map", "label": {"api": {"Map": [[99, 101]]}}}, {"text": "Study the  Map interface to see what methods are available", "label": {"api": {"Map": [[11, 13]]}}}, {"text": "Use Integer.parseInt(String, int radix)", "label": {"api": {"Integer.parseInt(String, int radix)": [[4, 38]]}}}, {"text": "(Take a look at SQLite, for example.) Other possibilities, depending on how much data you're talking about, are XML files (for which there are several APIs you could use) and Properties persisted to files", "label": {"api": {"Properties": [[175, 184]]}}}, {"text": "Another way is with Arrays.setAll, or Arrays.fill", "label": {"api": {"Arrays.setAll": [[20, 32]], "Arrays.fill": [[38, 48]]}}}, {"text": "If you know the number of threads that should read the buffer, a better solution would be to use two CountDownLatch", "label": {"api": {"CountDownLatch": [[101, 114]]}}}, {"text": "In the get method, call CountDownLatch.countDown() on that latch after the reading is finished", "label": {"api": {"CountDownLatch": [[24, 37]]}}}, {"text": "I think a CountdownLatch ( http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/CountDownLatch.html ) would help", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/CountDownLatch.html": [[27, 107]]}}}, {"text": "An alternative would be to use the string Formatter, give it a try to see if it performs better", "label": {"api": {"Formatter": [[42, 50]]}}}, {"text": "See ConcurrentModificationException and modCount in AbstractList", "label": {"api": {"ConcurrentModificationException": [[4, 34]], "modCount": [[40, 47]], "AbstractList": [[52, 63]]}}}, {"text": "See how to encode URL to avoid special characters in java and URLEncoder#encode(String, String)", "label": {"api": {"URLEncoder#encode(String, String)": [[62, 94]]}}}, {"text": "You can use the URLEncoder class to encode a string so that url.openStream() works", "label": {"api": {"URLEncoder": [[16, 25]]}}}, {"text": "If you know the number of threads, you can use a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[49, 61]]}}}, {"text": "Every time you must build some synchronization mechanism, be sure to check the package java.util.concurrent", "label": {"api": {"java.util.concurrent": [[87, 106]]}}}, {"text": "Call Class.getGenericInterfaces() to get the interfaces implemented by your class, with generic type information", "label": {"api": {"Class.getGenericInterfaces()": [[5, 32]]}}}, {"text": "The first result should be a Type instance representing IMaxHeap<T>", "label": {"api": {"Type": [[29, 32]]}}}, {"text": "Cast that to a ParameterizedType", "label": {"api": {"Type": [[28, 31]], "ParameterizedType": [[15, 31]]}}}, {"text": "Call ParameterizedType.getActualTypeArguments() on that", "label": {"api": {"Type": [[18, 21], [32, 35]], "ParameterizedType": [[5, 21]], "ParameterizedType.getActualTypeArguments()": [[5, 46]]}}}, {"text": "You will get a Type representing T", "label": {"api": {"Type": [[15, 18]]}}}, {"text": "I would use HashSets (and retainAll) then, which would make the whole check O(n) (for each element in the first set lookup if it exists (contains()), which is O(1) for HashSet)", "label": {"api": {"retainAll": [[26, 34]]}}}, {"text": "You can do it using an Iterator or you can do it with a special version of for", "label": {"api": {"Iterator": [[23, 30]]}}}, {"text": "Take a look at the java.util.concurrent classes", "label": {"api": {"java.util.concurrent": [[19, 38]]}}}, {"text": "For instance, both threads know about an instance of BlockingQueue<Foo>", "label": {"api": {"BlockingQueue<Foo>": [[53, 70]]}}}, {"text": "Use the contains functions", "label": {"api": {"contains": [[8, 15]]}}}, {"text": "It's to be achieved by HttpServletResponse#sendRedirect()", "label": {"api": {"HttpServletResponse#sendRedirect()": [[23, 56]]}}}, {"text": "Check the java.util package's JavaDoc for more details", "label": {"api": {"java.util": [[10, 18]]}}}, {"text": "If you are using Java 7, you can initialize a random byte array with Random.nextBytes(byte[]) then use the static BitSet.valueOf(byte[]) method to create a BitSet from the same byte array", "label": {"api": {"Random.nextBytes(byte[])": [[69, 92]], "BitSet.valueOf(byte[])": [[114, 135]]}}}, {"text": "Adding the following as the last thing in init() seems to help (but is not totally reliable)", "label": {"api": {"not totally reliable": [[71, 90]]}}}, {"text": "You should use System.nanoTime() as this is more accurate for timing (you should never get a diff of 0)", "label": {"api": {"System.nanoTime()": [[15, 31]]}}}, {"text": "If you look at the documentation for BufferedWriter you'll see no corresponding method to the way you were calling write (whoops, I missed the inherited methods, silly me!)", "label": {"api": {"BufferedWriter": [[37, 50]]}}}, {"text": "You can use StringReader class from java.io package", "label": {"api": {"StringReader": [[12, 23]]}}}, {"text": "Or you can simply create a FileReader and return that", "label": {"api": {"FileReader": [[27, 36]]}}}, {"text": "In java 8 you can use Collection.removeIf", "label": {"api": {"Collection.removeIf": [[22, 40]]}}}, {"text": "In the Servlet side, use either HttpServletRequest#getParts() or Commons FileUpload to extract the parts from the request", "label": {"api": {"HttpServletRequest#getParts()": [[32, 60]]}}}, {"text": "While playing around with double string formatting, I noticed that, at least on my locale, the strings produced by a default DecimalFormat object are different than the ones generated by Double.toString() when it comes to special cases like Infinity and NaN", "label": {"api": {"DecimalFormat": [[125, 137]], "Double.toString()": [[187, 203]]}}}, {"text": "Since for some of my applications I prefer the 7-bit ASCII representations (\"Be liberal in what you accept, be conservative in what you produce\"), is there some way to force the strings produced by DecimalFormat to match those produced by Double.toString()", "label": {"api": {"DecimalFormat": [[198, 210]], "Double.toString()": [[239, 255]]}}}, {"text": "One way might be to provide a DecimalFormatSymbols of my own, but it seems that I'd have to set all related fields myself, which sounds somewhat fragile", "label": {"api": {"DecimalFormat": [[30, 42]], "DecimalFormatSymbols": [[30, 49]]}}}, {"text": "You can specify the classloader to use as an additional parameter to getBundle", "label": {"api": {"getBundle": [[69, 77]]}}}, {"text": "JTable relies on its TableModel to determine what to display", "label": {"api": {"JTable": [[0, 5]]}}}, {"text": "Have you tried RoundingMode.FLOOR", "label": {"api": {"RoundingMode.FLOOR": [[15, 32]]}}}, {"text": "From the javadocs of the BigDecimal class", "label": {"api": {"javadocs of the BigDecimal class": [[9, 40]]}}}, {"text": "Looks like I should use java.net.Socket#setSocketImplFactory() method", "label": {"api": {"java.net.Socket#setSocketImplFactory()": [[24, 61]]}}}, {"text": "What about Runtime.totalMemory() (of course if you have permissions, or security is disabled)", "label": {"api": {"Runtime.totalMemory()": [[11, 31]]}}}, {"text": "You should be able to subclass the Reader class, implementing your own versions of the read(char, int, int) and close() methods", "label": {"api": {"Reader": [[35, 40]]}}}, {"text": "Yes, you can embed a JavaFX GUI into the Swing-based JApplet", "label": {"api": {"JApplet": [[53, 59]]}}}, {"text": "You can do this by using the JFXPanel - it is essentially an adaptor between Swing and JavaFX panels", "label": {"api": {"JFXPanel": [[29, 36]]}}}, {"text": "Look to the Graphics2D methods such as rotate(), scale() & translate() - as well as the more general translate(AffineTransform) method", "label": {"api": {"Graphics2D": [[12, 21]], "rotate()": [[39, 46]], "scale()": [[49, 55]], "translate()": [[59, 69]], "translate(AffineTransform)": [[101, 126]], "AffineTransform": [[111, 125]]}}}, {"text": "See Transforming Shapes, Text, and Images in the Java tutorial for more details and working examples, especially of using an AffineTransform (which can concatenate scale, rotate, transform & shear operations)", "label": {"api": {"AffineTransform": [[125, 139]]}}}, {"text": "The Graphics object passed to Swing components in paintComponent(Graphics) will generally be a Graphics2D instance, and can be cast to one", "label": {"api": {"Graphics2D": [[95, 104]]}}}, {"text": "To get a Graphics2D instance from a BufferedImage, call createGraphics()", "label": {"api": {"Graphics2D": [[9, 18]], "BufferedImage": [[36, 48]], "createGraphics()": [[56, 71]]}}}, {"text": "You would want to do a executeBatch() here which is similar to approach #1", "label": {"api": {"executeBatch()": [[23, 36]]}}}, {"text": "You need to use the reset() method after you received an object to make it update again", "label": {"api": {"reset()": [[20, 26]]}}}, {"text": "In the above code, I'm using the arraycopy method to copy a range of 5 numbers starting from index 5, to index 4 in the array, and then simply set a 4 in the last position", "label": {"api": {"arraycopy": [[33, 41]]}}}, {"text": "Notice that using arraycopy is much faster than copying the values in a loop, since it's usually implemented as a native operation which copies memory positions", "label": {"api": {"arraycopy": [[18, 26]]}}}, {"text": "LinkedList you used already implements Queue interface", "label": {"api": {"LinkedList": [[0, 9]], "Queue": [[39, 43]]}}}, {"text": "An other solution may be to transform your array into a list thanks to the asList method and simply use the remove and add methods", "label": {"api": {"asList": [[75, 80]], "remove": [[108, 113]], "add": [[119, 121]]}}}, {"text": "As so often, the Java 5 extensions from the java.util.concurrent package are a huge help here", "label": {"api": {"java.util.concurrent": [[44, 63]]}}}, {"text": "You should use the ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[19, 45]]}}}, {"text": "You can use a Scanner to parse the data", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "Write a Comparator for each attribute you want to order by", "label": {"api": {"Comparator": [[8, 17]]}}}, {"text": "If you want to reverse the ordering, you can use Collections.reverseOrder", "label": {"api": {"Collections.reverseOrder": [[49, 72]]}}}, {"text": "Put your data into an ArrayList, and use Collections.sort with the appropriate Comparator to achieve the desired ordering", "label": {"api": {"Comparator": [[79, 88]], "ArrayList": [[22, 30]], "Collections.sort": [[41, 56]]}}}, {"text": "If you carefully study API documentation for ConcurrentModificationException you'll most likely discover that adding listeners in initScroll1/2 is unsafe since it interferes with iteration performed within notifyChangingListeners", "label": {"api": {"API documentation for ConcurrentModificationException": [[23, 75]]}}}, {"text": "Parameterize your query using a PreparedStatement", "label": {"api": {"PreparedStatement": [[32, 48]]}}}, {"text": "As for speed, the StringBuilder class was added for the purpose of faster string manipulation", "label": {"api": {"StringBuilder": [[18, 30]]}}}, {"text": "You could use the CopyOnWriteArrayList which is thread safe", "label": {"api": {"CopyOnWriteArrayList": [[18, 37]]}}}, {"text": "See the JavaDoc for java.sql.Statement", "label": {"api": {"java.sql.Statement": [[20, 37]]}}}, {"text": "t1 and t2 are objects of the class Thread", "label": {"api": {"Thread": [[35, 40]]}}}, {"text": "try passing DateFormat.MEDIUM or DateFormat.SHORT instead of DateFormat.DEFAULT", "label": {"api": {"DateFormat.MEDIUM": [[12, 28]], "DateFormat.SHORT": [[33, 48]], "DateFormat.DEFAULT": [[61, 78]]}}}, {"text": "Essentially I need a way to initiate sub-microsecond thread sleeps as parknanos does", "label": {"api": {"parknanos": [[70, 78]]}}}, {"text": "ByteArrayInputStream and ByteArrayOutputStream to the rescue", "label": {"api": {"ByteArrayInputStream": [[0, 19]], "ByteArrayOutputStream": [[25, 45]]}}}, {"text": "The javadoc for ConcurrentModificationException contains the answer", "label": {"api": {"ConcurrentModificationException": [[16, 46]]}}}, {"text": "If the Thread is actually waiting for something, you should call the method Thread.interrupt() to interrupt the thread", "label": {"api": {"Thread.interrupt()": [[76, 93]]}}}, {"text": "If you are waiting on something, I assumed you had to catch the InterruptedException, didn't you", "label": {"api": {"InterruptedException": [[64, 83]]}}}, {"text": "See How to Use Key Bindings, then use that knowledge in conjunction with requestFocusInWindow()", "label": {"api": {"requestFocusInWindow()": [[73, 94]]}}}, {"text": "See also setMnemonic(char) for buttons and setAccelerator(KeyStroke) for menu items", "label": {"api": {"setMnemonic(char)": [[9, 25]], "setAccelerator(KeyStroke)": [[43, 67]]}}}, {"text": "Or more generally, constructing those controls using an Action that has the values configured", "label": {"api": {"Action": [[56, 61]]}}}, {"text": "The non-Spring way to handle this is to write a class that implements ServletContextListener and do your cleanup in its contextDestroyed method", "label": {"api": {"ServletContextListener": [[70, 91]]}}}, {"text": "Arrays.asList(T...) may be what you're looking for", "label": {"api": {"Arrays.asList(T...)": [[0, 18]]}}}, {"text": "For AbstractButton derivatives you set mnemonic directly with setMnemonic", "label": {"api": {"setMnemonic": [[62, 72]]}}}, {"text": "So the only thing wrong in your code is that you entered wrong argument in the call to setLabelFor", "label": {"api": {"setLabelFor": [[87, 97]]}}}, {"text": "I've found it helpful to use TextLayout, shown here, as one can condition the FontRenderContext with both isAntiAliased and usesFractionalMetrics", "label": {"api": {"TextLayout": [[29, 38]], "FontRenderContext": [[78, 94]]}}}, {"text": "If you want to remove characters which are not alphabets you can use replaceAll to replace them with nothing", "label": {"api": {"replaceAll": [[69, 78]]}}}, {"text": "FileWriter takes an optional boolean argument which specifies whether it should append to or overwrite the existing content", "label": {"api": {"optional boolean argument": [[20, 44]]}}}, {"text": "Consider using java.util.Properties and it's load() and store() methods", "label": {"api": {"java.util.Properties": [[15, 34]]}}}, {"text": "use TreeMap.tailMap() for it", "label": {"api": {"TreeMap.tailMap()": [[4, 20]]}}}, {"text": "The closest thing would be subclassing Number, but + doesn't work with it", "label": {"api": {"Number": [[39, 44]]}}}, {"text": "You can use two SimpleDateFormats", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "You want to use Class as the key type", "label": {"api": {"Class": [[16, 20]]}}}, {"text": "Where as using Class will use the type of Block as the key", "label": {"api": {"Class": [[15, 19]]}}}, {"text": "That is what getSource() is for, which is a method MenuEvent inherits from EventObject", "label": {"api": {"getSource()": [[13, 23]]}}}, {"text": "You have to create a key class (equality is treated as Point)", "label": {"api": {"Point": [[55, 59]]}}}, {"text": "If it is an int, you might want to parse your String to int with Integer.parseInt(), or use Scanner with nextInt() instead of BufferedReader to retrieve an int directly from your file", "label": {"api": {"Integer.parseInt()": [[65, 82]], "Scanner": [[92, 98]], "nextInt()": [[105, 113]]}}}, {"text": "An IllegalAccessException is thrown when an application tries to reflectively create an instance (other than an array), set or get a field, or invoke a method, but the currently executing method does not have access to the definition of the specified class, field, method or constructor", "label": {"api": {"IllegalAccessException": [[3, 24]]}}}, {"text": "If you are using the Java built-in support for splash screens (as specified in SplashScreen Javadoc) then you need to use a command line switch, or better yet, modify your MANIFEST file in order to reference your Splash Screen", "label": {"api": {"SplashScreen Javadoc": [[79, 98]]}}}, {"text": "Then during painting you can use this property as alpha in AlphaComposite", "label": {"api": {"AlphaComposite": [[59, 72]]}}}, {"text": "Here you can find some examples for AlphaComposite", "label": {"api": {"AlphaComposite": [[36, 49]]}}}, {"text": "getResource expects the resource to be on the classpath", "label": {"api": {"getResource": [[0, 10]]}}}, {"text": "If you want to read from a random file, use a File, or use the ImageIcon constructor that takes a file name", "label": {"api": {"File": [[46, 49]], "ImageIcon constructor that takes a file name": [[63, 106]]}}}, {"text": "When using a custom TableCellEditor, the only way to get the Point from the mouse click is the isCellEditable(EventObject e) method in CellEditor", "label": {"api": {"isCellEditable(EventObject e)": [[95, 123]]}}}, {"text": "I have tried with findComponentAt(Point p) but it returns null for me", "label": {"api": {"findComponentAt(Point p)": [[18, 41]]}}}, {"text": "findComponentAt() returns null because \"there is no child component at the requested point.\" MyCellPanel is located on a CellRendererPane used by JTable to speed rendering", "label": {"api": {"findComponentAt()": [[0, 16]], "CellRendererPane": [[121, 136]]}}}, {"text": "According to the documentation for FileInputStream, \"If the named file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading then a FileNotFoundException is thrown.\" (emphasis mine)  The file may be locked or in use by another application", "label": {"api": {"FileInputStream": [[35, 49]]}}}, {"text": "Of course, if you absolutely need to leave your properties files as is, you could write your own URIResolver with saxon that could read a properties file and return it AS xml to the XSL", "label": {"api": {"URIResolver": [[97, 107]]}}}, {"text": "Take a look for example at http://docs.oracle.com/javase/1.5.0/docs/api/java/nio/channels/FileChannel.html", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/nio/channels/FileChannel.html": [[27, 105]]}}}, {"text": "It sounds like you're using a ConcurrentHashMap when what you really need is something like a concurrent queue — say, a LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[120, 138]]}}}, {"text": "PixelGrabber is what you want", "label": {"api": {"PixelGrabber": [[0, 11]]}}}, {"text": "If you're looking for a data structure that implicitly forbids duplicates, use a Set", "label": {"api": {"Set": [[81, 83]]}}}, {"text": "Something like contains might be of interest", "label": {"api": {"contains": [[15, 22]]}}}, {"text": "In order to test for the occurence of substrings, you can use indexOf() (docs)", "label": {"api": {"indexOf() (docs)": [[62, 77]]}}}, {"text": "I believe you are looking for ServletContext.getRealPath(String path)", "label": {"api": {"ServletContext.getRealPath(String path)": [[30, 68]]}}}, {"text": "As noticed, sockets have a timeout already", "label": {"api": {"timeout": [[27, 33]]}}}, {"text": "You can use the FutureTask Java API to do that", "label": {"api": {"FutureTask": [[16, 25]]}}}, {"text": "String.replace() takes a CharSequence, not a regex", "label": {"api": {"String.replace()": [[0, 15]]}}}, {"text": "You're probably looking for replaceAll() or replaceFirst()", "label": {"api": {"replaceAll()": [[28, 39]], "replaceFirst()": [[44, 57]]}}}, {"text": "For example exec(String command, String[] envp)", "label": {"api": {"exec(String command, String[] envp)": [[12, 46]]}}}, {"text": "You could use Class.getMethod() to get the Method object, and then Method.call() to invoke the method", "label": {"api": {"Class.getMethod()": [[14, 30]], "Method.call()": [[67, 79]]}}}, {"text": "getMethod() will throw NoSuchMethodException if the class doesn't have a method with the requested name and signature", "label": {"api": {"NoSuchMethodException": [[23, 43]]}}}, {"text": "You should also use nanoTime() rather then currentTimeMillis() since the letter is susceptible to errors due to changes in local clock (e.g", "label": {"api": {"nanoTime()": [[20, 29]]}}}, {"text": "S is only to be used for milliseconds", "label": {"api": {"milliseconds": [[25, 36]]}}}, {"text": "There is however another way to pass contextual data between EJBs, interceptors and lifecycle callbacks using the TransactionSynchronizationRegistry", "label": {"api": {"TransactionSynchronizationRegistry": [[114, 147]]}}}, {"text": "javax.transaction.TransactionSynchronizationRegistry holds a Map-like structure and can be used to pass state inside a transaction", "label": {"api": {"TransactionSynchronizationRegistry": [[18, 51]]}}}, {"text": "The TransactionSynchronizationRegistry (TSR) can be directly injected into an Interceptor", "label": {"api": {"TransactionSynchronizationRegistry": [[4, 37]]}}}, {"text": "The example there uses @Resource injection to obtain the TransactionSynchronizationRegistry, but it can also be looked up from the InitialContext like this", "label": {"api": {"TransactionSynchronizationRegistry": [[57, 90]]}}}, {"text": "Your class should implement Clonable interface", "label": {"api": {"Clonable": [[28, 35]]}}}, {"text": "The reason that other implementations throw the CloneNotSupportedException is that it is part of the existing clone() method of Object", "label": {"api": {"clone() method of Object": [[110, 133]]}}}, {"text": "I think you're looking for the Formatter class, which does printf-style formatting for Java", "label": {"api": {"Formatter": [[31, 39]]}}}, {"text": "The Method.invoke() method takes the object the method is being invoked on as the first argument", "label": {"api": {"Method.invoke()": [[4, 18]]}}}, {"text": "Also, if you can target Java 7, use Frame.setShape() instead as it is now officially part of the API", "label": {"api": {"Frame.setShape()": [[36, 51]]}}}, {"text": "If you are using Swing you can use JFrame setDefaultCloseOperation to change the default behavior of the Window close", "label": {"api": {"JFrame setDefaultCloseOperation": [[35, 65]]}}}, {"text": "Or you can terminate the JVM process by using System.exit(0)", "label": {"api": {"System.exit(0)": [[46, 59]]}}}, {"text": "There is a main method in the applet runner (assuming it's implemented in Java; it need not be) but the applet doesn't work that way; it gets loaded/instantiated from a file and then it proceeds along its lifecycle through initialization, starting, operating, stopping, and finally being destroyed", "label": {"api": {"initialization": [[223, 236]], "starting": [[239, 246]], "stopping": [[260, 267]], "destroyed": [[288, 296]]}}}, {"text": "The code that sends it through these states is hidden from the applet's view; it just knows its in an environment that can run applets", "label": {"api": {"environment": [[102, 112]]}}}, {"text": "As an alternative, if there's not a specific reason to use Math.random(), use Random.nextInt()", "label": {"api": {"Random.nextInt()": [[78, 93]]}}}, {"text": "You can use ProcessBuilder class to check if the application already exists", "label": {"api": {"ProcessBuilder": [[12, 25]]}}}, {"text": "The base Enum class already has a name() method", "label": {"api": {"name() method": [[34, 46]]}}}, {"text": "You need to execute exec() method of Runtime that returns Process instance or use ProcessBuilder class methods", "label": {"api": {"ProcessBuilder": [[82, 95]]}}}, {"text": "Ask the master table what its selected row is (getSelectedRow())", "label": {"api": {"getSelectedRow()": [[47, 62]]}}}, {"text": "Convert this view row index to a model row index (convertRowIndexToModel())", "label": {"api": {"convertRowIndexToModel()": [[50, 73]]}}}, {"text": "wait() causes the thread to block, which would not be acceptable in all environments", "label": {"api": {"wait()": [[0, 5]]}}}, {"text": "the InterruptedException on await() should be handled either by the caller or by doing something more sensible in await()", "label": {"api": {"wait()": [[29, 34], [115, 120]]}}}, {"text": "You should instead get the mime type by ServletContext#getMimeType()", "label": {"api": {"ServletContext#getMimeType()": [[40, 67]]}}}, {"text": "XMLEncoder encodes 'Java Beans'", "label": {"api": {"XMLEncoder": [[0, 9]]}}}, {"text": "If you dig down deep enough, you'll find some variety of ServerSocket at the bottom of it all", "label": {"api": {"ServerSocket": [[57, 68]]}}}, {"text": "Use the split method like so", "label": {"api": {"split": [[8, 12]]}}}, {"text": "Because you are overriding Thread.run() method", "label": {"api": {"Thread.run()": [[27, 38]]}}}, {"text": "Here is the implementation of Thread.run()", "label": {"api": {"Thread.run()": [[30, 41]]}}}, {"text": "Each of those are following a certain DateFormat", "label": {"api": {"DateFormat": [[38, 47]]}}}, {"text": "Prepare a chain (chain of responsibility pattern) of predefined DateFormat handlers and pass the date String's you have into the chain", "label": {"api": {"DateFormat": [[64, 73]]}}}, {"text": "java.awt.Graphics has a drawRect method that does just that", "label": {"api": {"drawRect": [[24, 31]]}}}, {"text": "You might be interested in java.util.Random", "label": {"api": {"java.util.Random": [[27, 42]]}}}, {"text": "You can inspect the content-type header once you're requested the resource, using, for example, the HttpURLConnection class", "label": {"api": {"HttpURLConnection class": [[100, 122]]}}}, {"text": "You can use the HttpURLConnection.setRequestMethod(\"HEAD\") before you issue the request", "label": {"api": {"HttpURLConnection.setRequestMethod(\"HEAD\")": [[16, 57]]}}}, {"text": "Then issue the request with URLConnection.connect() and then use URLConnection.getContentType() which reads the HTTP headers", "label": {"api": {"URLConnection.connect()": [[28, 50]], "URLConnection.getContentType()": [[65, 94]]}}}, {"text": "You can also use a GET request and inspect the resulting stream using URLConnection.guessContentTypeFromStream() which will inspect the actual bytes and try to guess what the stream represents", "label": {"api": {"URLConnection.guessContentTypeFromStream()": [[70, 111]]}}}, {"text": "This is from the Comparator docs", "label": {"api": {"Comparator": [[17, 26]]}}}, {"text": "From the Long docs", "label": {"api": {"Long docs": [[9, 17]]}}}, {"text": "You should look at ArrayList, Vector or even LinkedList for the functionality you seek", "label": {"api": {"ArrayList": [[19, 27]], "Vector": [[30, 35]], "LinkedList": [[45, 54]]}}}, {"text": "Here's a tutorial explaining how to use an ArrayList", "label": {"api": {"ArrayList": [[43, 51]]}}}, {"text": "the ArrayList will take care of growing an internal array for storing its elements, and as you keep adding elements to it, it will keep growing automatically to accommodate them", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "You have created a process, and then immediately destroyed it", "label": {"api": {"destroy": [[49, 55]]}}}, {"text": "Try calling .waitFor() instead (or just let it run)", "label": {"api": {".waitFor()": [[12, 21]]}}}, {"text": "The get method of the HashMap accepts an Object, regardless of the generic type", "label": {"api": {"get method of the HashMap": [[4, 28]]}}}, {"text": "Use a ProgressMonitorInputStream", "label": {"api": {"ProgressMonitorInputStream": [[6, 31]]}}}, {"text": "PS:IMHO using scanner instead of buffered stream will be easier", "label": {"api": {"scanner": [[14, 20]]}}}, {"text": "From the Map.Entry JavaDocs (emphasis added)", "label": {"api": {"the Map.Entry JavaDocs": [[5, 26]]}}}, {"text": "Try a TimerTask or ThreadExecutor (look at the scheduled implementation)", "label": {"api": {"ThreadExecutor": [[19, 32]]}}}, {"text": "You can use the methods of DatabaseMetaData to find the number and names of a table's attributes", "label": {"api": {"DatabaseMetaData": [[27, 42]]}}}, {"text": "http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuffer.html (this is Java 1.5)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuffer.html": [[0, 71]]}}}, {"text": "You can use StringTokenizer to split into strings delimited by whitespace", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "Then write a loop to process the strings to replace the parentheses", "label": {"api": {"replace": [[44, 50]]}}}, {"text": "it may be that the defaultWriteObject can only write the non-static and non-transient fields of the current class", "label": {"api": {"the defaultWriteObject can only write the non-static and non-transient fields of the current class": [[15, 112]]}}}, {"text": "If so, then when you need fine-grained control over serialization of a Java object, implement the Externalizable interface", "label": {"api": {"Externalizable": [[98, 111]]}}}, {"text": "Try calling Clip.loop(int) (or DataLine.start() - implemented by Clip)", "label": {"api": {"Clip.loop(int)": [[12, 25]], "DataLine.start()": [[31, 46]]}}}, {"text": "You can use a comparator that sorts the characters before checking them for equality", "label": {"api": {"comparator": [[14, 23]]}}}, {"text": "Then use this comparator as you traverse through the list and copy the matching elements to a new list", "label": {"api": {"comparator": [[14, 23]]}}}, {"text": "You may use Window#dispose() method  to release all of the native screen resources, subcomponents, and all of its owned children", "label": {"api": {"Window#dispose()": [[12, 27]]}}}, {"text": "You might also use EXIT_ON_CLOSE, but it is better to explicitly clean up any running threads, then when the last GUI element becomes invisible, the EDT & JRE will end", "label": {"api": {"EXIT_ON_CLOSE": [[19, 31]]}}}, {"text": "You can use System.out.printf (same as System.out.format) and a format string (\"%s\" is the format specifier for a string) to both make it look more fluid and also format your output the way you want", "label": {"api": {"System.out.printf": [[12, 28]], "format string": [[64, 76]]}}}, {"text": "Since you're sorting an array, you should use Arrays.sort", "label": {"api": {"Arrays.sort": [[46, 56]]}}}, {"text": "You can use Set<E>, which does not contain duplicates", "label": {"api": {"Set<E>": [[12, 17]]}}}, {"text": "You can look at the Java 6 API, but you won't be satisfied with that until you look at the source code for yourself - check the file /jdk/src/share/classes/java/util/Arrays.java in the source code directory", "label": {"api": {"look at the Java 6 API": [[8, 29]]}}}, {"text": "The answer is to create a shutdown hook via Runtime's addShutdownHook  method, like this", "label": {"api": {"Runtime": [[44, 50]], "addShutdownHook": [[54, 68]]}}}, {"text": "And as Harry Joy pointed out, you can tell swing how this element should be rendered by using a ListCellRenderer", "label": {"api": {"ListCellRenderer": [[96, 111]]}}}, {"text": "If you already have the file's contents in a byte array byte[] you can simply use the appropriate constructor String(byte[], Charset)", "label": {"api": {"constructor String(byte[], Charset)": [[98, 132]]}}}, {"text": "From the documentation of HashMap.put(K, V)", "label": {"api": {"HashMap.put(K, V)": [[26, 42]]}}}, {"text": "And yes, getClickCount() returns the number of clicks associated with the event, so it seems appropriate to check if it's a double or a simple click", "label": {"api": {"getClickCount()": [[9, 23]]}}}, {"text": "There is also a small code snippet in the Future documentation", "label": {"api": {"Future documentation": [[42, 61]]}}}, {"text": "Create a couple of sub-classes that extend InputVerifier that implement basic verification rules, and attach the to your text fields", "label": {"api": {"InputVerifier": [[43, 55]]}}}, {"text": "The request headers are in JSF available by ExternalContext#getRequestHeaderMap()", "label": {"api": {"ExternalContext#getRequestHeaderMap()": [[44, 80]]}}}, {"text": "You could use a NumberFormat and specify the maximum number of integer digits with setMaximumIntegerDigits", "label": {"api": {"setMaximumIntegerDigits": [[83, 105]], "Format": [[22, 27]]}}}, {"text": "The Format should guarantee that the inserted String satisfy the format", "label": {"api": {"Format": [[4, 9]]}}}, {"text": "Look at this Javadoc for Window (Java AWT)", "label": {"api": {"this Javadoc for Window": [[8, 30]]}}}, {"text": "You can use String.format to define the output you like, e.g", "label": {"api": {"String.format": [[12, 24]]}}}, {"text": "Take a look at the String.substring() method", "label": {"api": {"String.substring()": [[19, 36]]}}}, {"text": "Take a look at the java.lang.BigInteger class", "label": {"api": {"java.lang.BigInteger": [[19, 38]]}}}, {"text": "You can see this in the declaration of addAll", "label": {"api": {"declaration of addAll": [[24, 44]]}}}, {"text": "You need to use the other Integer.parseInt() method", "label": {"api": {"Integer.parseInt()": [[26, 43]]}}}, {"text": "If you really need to get them to be resolved by the JSF resource handler, so that you can use them in something like <h:graphicImage library=\"uploads\" name=\"foo.png>, then you need to implement a custom ResourceHandler", "label": {"api": {"ResourceHandler": [[204, 218]]}}}, {"text": "Just read the javadocs, starting at ResourceHandler, and peek around in Mojarra's own ResourceHandlerImpl and ResourceImpl source codes to get the idea", "label": {"api": {"ResourceHandler": [[36, 50], [86, 100]]}}}, {"text": "I suppose you could also create a new SoftReference to the newly created instance in the constructor, and collect those in a static list", "label": {"api": {"SoftReference": [[38, 50]]}}}, {"text": "This is not just an Android thing, the Java SDK has the same recommendation", "label": {"api": {"Java SDK has the same recommendation": [[39, 74]]}}}, {"text": "If you want to compare strings in java use String.equals", "label": {"api": {"String.equals": [[43, 55]]}}}, {"text": "For example, the one that is returned by Arrays.asList() does not and this is the method used by StructuredSelection.toList()", "label": {"api": {"Arrays.asList()": [[41, 55]]}}}, {"text": "If you edit the database row not using the JPA you should invoke EntityManager#refresh(-) using the entity fetched by find(-) as a parameter or invoke EntityManager#clear(-) and then invoke the find(-) again", "label": {"api": {"EntityManager#refresh(-)": [[65, 88]], "EntityManager#clear(-)": [[151, 172]]}}}, {"text": "You can use the ExecutorService class to manage the workers", "label": {"api": {"ExecutorService": [[16, 30]]}}}, {"text": "To create a custom cursor, use the java.awt.Toolkit.createCustomCursor method", "label": {"api": {"java.awt.Toolkit.createCustomCursor": [[35, 69]]}}}, {"text": "Then the \"correct\" way is using DecimalFormat", "label": {"api": {"DecimalFormat": [[32, 44]]}}}, {"text": "If that's an issue, you can just call fmt.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.ROOT))", "label": {"api": {"DecimalFormat": [[45, 57], [70, 82]]}}}, {"text": "You can use JDK security API", "label": {"api": {"JDK security API": [[12, 27]]}}}]