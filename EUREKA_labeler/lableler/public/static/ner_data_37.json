[{"text": "The annotations seems to have a dispatcherTypes attribute to support this, so the following should work", "label": {"api": {"dispatcherTypes": [[32, 46]]}}}, {"text": "NumberFormat.parse(), as implemented in DecimalFormat only seems to produce Double and Long objects, with quite a few issues when some of the notations mentioned above are used", "label": {"api": {"NumberFormat.parse()": [[0, 19]], "DecimalFormat": [[40, 52]]}}}, {"text": "Why not just wrap them in a call to File#exists()", "label": {"api": {"File#exists()": [[36, 48]]}}}, {"text": "Use the other method toArray() of List class", "label": {"api": {"toArray()": [[21, 29]]}}}, {"text": "Java's Double class lets you construct and take apart Double values into its constituent pieces", "label": {"api": {"Double": [[7, 12], [54, 59]]}}}, {"text": "You can iterate over all possible long values and then use Double.longBitsToDouble() to get a double for each possible 64-bit combination", "label": {"api": {"Double.longBitsToDouble()": [[59, 83]]}}}, {"text": "You would use Float.intBitsToFloat() in this case", "label": {"api": {"Float.intBitsToFloat()": [[14, 35]]}}}, {"text": "The spec is http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html": [[12, 80]]}}}, {"text": "Look in the javadocs for the Pattern class", "label": {"api": {"Pattern": [[29, 35]]}}}, {"text": "The documentation for Pattern says in the \"Unicode Support\" section", "label": {"api": {"documentation for Pattern": [[4, 28]]}}}, {"text": "The documentation for UnicodeBlock.forName states", "label": {"api": {"documentation for UnicodeBlock.forName": [[4, 41]]}}}, {"text": "I have a Java Swing application which has a JTextField inside it", "label": {"api": {"JTextField": [[44, 53]]}}}, {"text": "Have HSFrame implement ComponentListener and put your resize code in public void componentResized(ComponentEvent e)", "label": {"api": {"ComponentListener": [[23, 39]]}}}, {"text": "From the TreeSet Javadoc", "label": {"api": {"TreeSet Javadoc": [[9, 23]]}}}, {"text": "Sometimes they come from JAR archives, sometimes they come from the internet, sometimes they are constructed on the fly by a program, and so on", "label": {"api": {"from the internet": [[59, 75]]}}}, {"text": "A class could come from any source that can provide the binary data needed to define it", "label": {"api": {"to define it": [[75, 86]]}}}, {"text": "How about File#createNewFile()", "label": {"api": {"File#createNewFile()": [[10, 29]]}}}, {"text": "If you're using Java 7, you can also use Files.createFile(Path), as in this example from the Java tutorial", "label": {"api": {"Files.createFile(Path)": [[41, 62]]}}}, {"text": "You can use printf", "label": {"api": {"printf": [[12, 17]]}}}, {"text": "You can as well create a String with such formatting, using String#format", "label": {"api": {"String#format": [[60, 72]]}}}, {"text": "Make your code from the run() method into a Runnable and submit it for execution to an Executor", "label": {"api": {"Runnable": [[44, 51]], "Executor": [[87, 94]]}}}, {"text": "If you want to reuse the same thread for other computations, use a thread pool, see for example Executors.newFixedThreadPool() and other factory methods in Executors", "label": {"api": {"Executor": [[96, 103], [156, 163]], "Executors.newFixedThreadPool()": [[96, 125]]}}}, {"text": "In this case use a SingleThreadExecutor and submit your Runnables", "label": {"api": {"SingleThreadExecutor": [[19, 38]]}}}, {"text": "Fron the java online docs", "label": {"api": {"java online docs": [[9, 24]]}}}, {"text": "Also you can imitate the concept of CountDownLatch in your application to dismiss the cursor", "label": {"api": {"CountDownLatch": [[36, 49]]}}}, {"text": "Moreover, the Shop class should have a way of notifying observers when a property is changed – take a look at PropertyChangeSupport", "label": {"api": {"PropertyChangeSupport": [[110, 130]]}}}, {"text": "Sounds like you need a FileOutputStream", "label": {"api": {"FileOutputStream": [[23, 38]]}}}, {"text": "Note the write() method that takes a byte array", "label": {"api": {"write()": [[9, 15]]}}}, {"text": "Use a FileOutputStream", "label": {"api": {"FileOutputStream": [[6, 21]]}}}, {"text": "These constants are inherited from SwingConstants", "label": {"api": {"constants": [[6, 14]]}}}, {"text": "There is a Krb5LoginModule which you can specify using the com.sun.management.jmxremote.login.config property to enable Kerberos for the JMX connector", "label": {"api": {"Krb5LoginModule": [[11, 25]]}}}, {"text": "ArrayList is fine", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "In regular expressions groups are captured using paranthesis", "label": {"api": {"group": [[23, 27]]}}}, {"text": "If the regexp matches, you can get the captured groups as follows", "label": {"api": {"group": [[48, 52]]}}}, {"text": "For example, anything you want to know about the Integer Class is documented in detail", "label": {"api": {"Integer Class": [[49, 61]]}}}, {"text": "Instead of adding directly Components to the JFrame, use a JPanel as container with the desired LayoutManager", "label": {"api": {"LayoutManager": [[96, 108]]}}}, {"text": "Basically in Swing the LayoutManager is responsible for laying out the children Components (establishing their position and their size), so every container component you use inside your app, should be configured with the appropiate LayoutManager", "label": {"api": {"LayoutManager": [[23, 35], [232, 244]]}}}, {"text": "You can do it calling setRowSelectionInterval", "label": {"api": {"setRowSelectionInterval": [[22, 44]]}}}, {"text": "You can check the length of the path from selPath to the tree root by first calling the getPath() method of selPath and computing its length", "label": {"api": {"getPath()": [[88, 96]]}}}, {"text": "You can use a pattern with SimpleDateFormat and get whatever format you like", "label": {"api": {"SimpleDateFormat": [[27, 42]]}}}, {"text": "Use BigInteger or BigDecimal", "label": {"api": {"BigInteger": [[4, 13]], "BigDecimal": [[18, 27]]}}}, {"text": "They include methods transferFrom and transferTo, which might be able to do it more efficiently than you could in Java", "label": {"api": {"transferFrom": [[21, 32]], "transferTo": [[38, 47]]}}}, {"text": "I've looked into java.awt.datatransfer but there doesn't seem to be any way I could hook a callback onto the system event whenever data is copied to the clipboard", "label": {"api": {"java.awt.datatransfer": [[17, 37]]}}}, {"text": "I hate to answer without fully testing it, but the grails-executor plugin docs state that the callAsync method returns a java.util.concurrent.Future object", "label": {"api": {"java.util.concurrent.Future object": [[121, 154]]}}}, {"text": "From the HTMLEditorKit API", "label": {"api": {"HTMLEditorKit": [[9, 21]]}}}, {"text": "CriteriaBuilder has an and(Predicate...) method", "label": {"api": {"and(Predicate...)": [[23, 39]]}}}, {"text": "JPA @Entity and @Column annotations are used in domain objects, and the problematic fields look like this", "label": {"api": {"@Entity": [[4, 10]], "@Column": [[16, 22]]}}}, {"text": "Specifically, what can I use in Objective C which has the same functionality as the MessageDigest class", "label": {"api": {"MessageDigest class": [[84, 102]]}}}, {"text": "You didn't mention which framework you are using but assuming you are using HttpServlet you can use getServletContext method to retrieve the ServletContext and then you can retrieve context parameters by getInitParameter(String) method", "label": {"api": {"HttpServlet": [[76, 86]], "ServletContext": [[103, 116], [141, 154]], "getServletContext method": [[100, 123]]}}}, {"text": "You can read more about HttpServlet, ServletContext and getServletContext method", "label": {"api": {"HttpServlet": [[24, 34]], "ServletContext": [[37, 50], [59, 72]], "getServletContext method": [[56, 79]]}}}, {"text": "Wrap the call in a Future and invoke get with timeout", "label": {"api": {"Future": [[19, 24]], "get with timeout": [[37, 52]]}}}, {"text": "You should try using Timers", "label": {"api": {"Timers": [[21, 26]]}}}, {"text": "If you really, really want to seek to anywhere in the file then try looking at RandomAccessFile", "label": {"api": {"RandomAccessFile": [[79, 94]]}}}, {"text": "If the goal is to prevent modification, maybe one or more of the \"unmodifiable\" methods like  unmodifiableMap in java.util.Collections would help", "label": {"api": {"unmodifiableMap": [[94, 108]]}}}, {"text": "The implementation of equals() method of class Long illustrates why", "label": {"api": {"equals()": [[22, 29]], "Long": [[47, 50]]}}}, {"text": "Take a look at setAlignmentX and setAlignmentY of JComponent", "label": {"api": {"JComponent": [[50, 59]]}}}, {"text": "When you call the constructor for JDialog, you need to pass in the JFrame that owns it", "label": {"api": {"constructor": [[18, 28]]}}}, {"text": "This constructor is useful, because it allows you to specify it as a modal dialog", "label": {"api": {"constructor": [[5, 15]]}}}, {"text": "From the API docs", "label": {"api": {"the API docs": [[5, 16]]}}}, {"text": "Use a ListModel, for example DefaultListModel", "label": {"api": {"ListModel": [[6, 14], [36, 44]], "DefaultListModel": [[29, 44]]}}}, {"text": "It will fire the \"fire\" the correct events to the JList so that it updates when objects are added to or removed from the model", "label": {"api": {"JList": [[50, 54]]}}}, {"text": "For the \"wrap problem\" just use the JList(ListModel) constructor it will use the JList.VERTICAL property that renders the list like you want", "label": {"api": {"ListModel": [[42, 50]], "JList": [[36, 40], [81, 85]], "JList(ListModel)": [[36, 51]], "JList.VERTICAL": [[81, 94]]}}}, {"text": "It really seemed like Utilities.drawTabbedText() was promising, but I couldn't figure out what it needed as input", "label": {"api": {"Utilities.drawTabbedText()": [[22, 47]]}}}, {"text": "The java.util.UUID class generates only versions 3 (name-based, via method nameUUIDFromBytes(byte[] name)) and 4 (entirely random, via method randomUUID()) UUIDs", "label": {"api": {"java.util.UUID class": [[4, 23]]}}}, {"text": "If you access it from multiple threads, then it'd better be an AtomicBoolean in both cases", "label": {"api": {"AtomicBoolean": [[63, 75]]}}}, {"text": "Get the current Font, use deriveFont to get a new Font similar to the current one but with a new style, and apply the new font", "label": {"api": {"deriveFont": [[26, 35]]}}}, {"text": "As an alternative, you might look at the StyledEditorKit actions available to JEditorPane", "label": {"api": {"JEditorPane": [[78, 88]]}}}, {"text": "You can load resources from within the jar the applet class is in using Class#getResource to get a URL you can open, or using Class#getResourceAsStream to do it all in one", "label": {"api": {"Class#getResource": [[72, 88], [126, 142]], "Class#getResourceAsStream": [[126, 150]]}}}, {"text": "If you're using Swing, simply set the icon of a JButton", "label": {"api": {"JButton": [[48, 54]]}}}, {"text": "A Image object containing the level background (photo)", "label": {"api": {"Image": [[2, 6]]}}}, {"text": "Each item should have an Image, dimensions on the level screen (X,Y,Width,Height) and some kind of state (visible, highlighted, etc.)", "label": {"api": {"Image": [[25, 29]]}}}, {"text": "Make a class which extends Canvas", "label": {"api": {"Canvas": [[27, 32]]}}}, {"text": "Override it's paint method", "label": {"api": {"paint": [[14, 18]]}}}, {"text": "In this paint method use drawImage method go through your level data object (specified in step 1) and draw the background (room) and all the items in their respective coordinates", "label": {"api": {"Image": [[29, 33]], "paint": [[8, 12]], "drawImage": [[25, 33]]}}}, {"text": "Implement a MouseListener", "label": {"api": {"MouseListener": [[12, 24]]}}}, {"text": "If it is - do appropriate action (for example increase score and set visible = false for that item) and update your canvas with repaint", "label": {"api": {"paint": [[130, 134]], "repaint": [[128, 134]]}}}, {"text": "This will trigger the paint method again drawing all the changes on your canvas", "label": {"api": {"paint": [[22, 26]]}}}, {"text": "Register a MouseListener on your Canvas with addMouseListener to tie it all together", "label": {"api": {"Canvas": [[33, 38]], "MouseListener": [[11, 23], [48, 60]], "addMouseListener": [[45, 60]]}}}, {"text": "See the javadoc for Thread", "label": {"api": {"Thread": [[20, 25]]}}}, {"text": "JRE emulation reference says isInstance() is not supported", "label": {"api": {"isInstance()": [[29, 40]]}}}, {"text": "There is a method entries", "label": {"api": {"entries": [[18, 24]]}}}, {"text": "If you're looking for a simple node.js style event loop in Java, ThreadPoolExecutor is a good start", "label": {"api": {"ThreadPoolExecutor": [[65, 82]]}}}, {"text": "Take a look at the Executors factory mentioned in the javadoc for ThreadPoolExecutor, particularly Executors.newSingleThreadExecutor()", "label": {"api": {"ThreadPoolExecutor": [[66, 83]], "Executors": [[19, 27], [99, 107]], "Executors.newSingleThreadExecutor()": [[99, 133]]}}}, {"text": "For async IO, tasks handling blocking activity need to split of a Thread (or Executor) and use a Future to submit the result back to the event loop", "label": {"api": {"Future": [[97, 102]]}}}, {"text": "You can always use Arrays.sort() for sorting the elements in an array according to a given Comparator, in this case you'll need to craft the comparator to suit your needs", "label": {"api": {"Arrays.sort()": [[19, 31]], "Comparator": [[91, 100]]}}}, {"text": "Your comboboxes will need to implement the ItemListener interface and register themselves as listeners to the appropriate component(s)", "label": {"api": {"ItemListener": [[43, 54]]}}}, {"text": "Of course, the JComboBoxes must implement ItemListener for detecting the event and updating the appropriate elements in the GUI", "label": {"api": {"ItemListener": [[42, 53]]}}}, {"text": "The easiest way to extend DefaultComboBoxModel", "label": {"api": {"DefaultComboBoxModel": [[26, 45]]}}}, {"text": "If you only wish to query based on TObject id, use HashMap HashMap<String,List<TStructureRow>.Store List against the id of TObject.You can retrieve list of all TStructureRow corresponding to a particular TObject id in (theoretically)constant average time", "label": {"api": {"HashMap": [[51, 57], [59, 65]]}}}, {"text": "You could answer to your own question by reading the javadocs for HashMap", "label": {"api": {"javadocs for HashMap": [[53, 72]]}}}, {"text": "Use a WindowAdapter and override only methods you need", "label": {"api": {"WindowAdapter": [[6, 18]]}}}, {"text": "In the API docs of WindowListener there is a class WindowAdapter mentioned as implementing the interface", "label": {"api": {"WindowListener": [[19, 32]], "WindowAdapter": [[51, 63]]}}}, {"text": "Try with paintComponent instead", "label": {"api": {"paintComponent": [[9, 22]]}}}, {"text": "Its javadoc has an easy to understand example", "label": {"api": {"Its javadoc": [[0, 10]]}}}, {"text": "You should take a look at the ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[30, 50]]}}}, {"text": "You can then iterate through each string you have and use the Byte.parseByte() method", "label": {"api": {"Byte.parseByte()": [[62, 77]]}}}, {"text": "You can than add it to the ByteArrayOutputStream by using the write method", "label": {"api": {"ByteArrayOutputStream": [[27, 47]], "write": [[62, 66]]}}}, {"text": "Once you will have converted all the Strings, you can use the ByteArrayOutputStream's toByteArray() method", "label": {"api": {"ByteArrayOutputStream": [[62, 82]], "toByteArray()": [[86, 98]]}}}, {"text": "The width specification is the minimum, not the maximum", "label": {"api": {"width specification is the minimum": [[4, 37]]}}}, {"text": "I found the following in the javadoc for java.util.Formatter (emphasis mine)", "label": {"api": {"java.util.Formatter": [[41, 59]]}}}, {"text": "System.out is a PrintStream", "label": {"api": {"PrintStream": [[16, 26]]}}}, {"text": "PrintStream.printf(formatString, args) is actually a convenience method call to PrintStream.format(formatString, args);", "label": {"api": {"PrintStream": [[0, 10], [80, 90]]}}}, {"text": "This is a call to PrintStream.format(formatString, args) which uses a Formatter to format the results and append them to the PrintStream", "label": {"api": {"PrintStream": [[18, 28], [125, 135]], "Formatter": [[70, 78]]}}}, {"text": "This method also uses a Formatter and returns a new string with the formatted results of the format string and args", "label": {"api": {"Formatter": [[24, 32]]}}}, {"text": "System.console() is a Console", "label": {"api": {"Console": [[22, 28]]}}}, {"text": "Console.format(format, args) uses a Formatter to display a formatted string to the console", "label": {"api": {"Formatter": [[36, 44]], "Console": [[0, 6]]}}}, {"text": "This creates an instance of a Formatter using the string buffer passed in", "label": {"api": {"Formatter": [[30, 38]]}}}, {"text": "If you use this call then you will have to use the out() method to get the Appendable written to by the Formatter", "label": {"api": {"Formatter": [[104, 112]]}}}, {"text": "These are two concreate formatters for numbers that do not use the Formatter class", "label": {"api": {"Formatter": [[67, 75]]}}}, {"text": "DecimalFormat and NumerFormat both have a format method which takes a double or Number and returns them formatted as a string according to the definition of those classes", "label": {"api": {"DecimalFormat": [[0, 12]], "NumerFormat": [[18, 28]]}}}, {"text": "As far as I can tell, the Formatter does not use them", "label": {"api": {"Formatter": [[26, 34]]}}}, {"text": "You need to use .compareTo(), which is provided by the Comparable interface", "label": {"api": {".compareTo()": [[16, 27]]}}}, {"text": "If you're reading from a file, ProgressMonitorInputStream may be convenient", "label": {"api": {"ProgressMonitorInputStream": [[31, 56]]}}}, {"text": "You could use the default comparator using Collections#sort provided that you use numbers of the form 01 and 02 and not 1 and 2", "label": {"api": {"Collections#sort": [[43, 58]]}}}, {"text": "If your goal is to center a component, then a GridBagLayout will do the job nicely", "label": {"api": {"GridBagLayout": [[46, 58]]}}}, {"text": "GridBagLayout will create a single cell that fills the panel", "label": {"api": {"GridBagLayout": [[0, 12]]}}}, {"text": "I'd suggest to use a JToggleButton instead.For information on using them see How to Use Buttons, Check Boxes, and Radio Buttons,a section in The Java Tutorial", "label": {"api": {"JToggleButton": [[21, 33]]}}}, {"text": "Then look to the Font methods for the createFont(int,InputStream) method", "label": {"api": {"createFont(int,InputStream)": [[38, 64]]}}}, {"text": "The article on bubble sort on Wikipedia contains pseudo code and also some optimized versions", "label": {"api": {"sort": [[22, 25]]}}}, {"text": "Bubble sort is one of the most obvious sorting algorithms, but not exactly the most efficient", "label": {"api": {"sort": [[7, 10], [39, 42]]}}}, {"text": "Why don't you let the platform do the sort", "label": {"api": {"sort": [[38, 41]]}}}, {"text": "java.util.Collections contains a sort method that lets you supply your own Comparator", "label": {"api": {"sort": [[33, 36]], "Comparator": [[75, 84]]}}}, {"text": "Using a BufferedReader to read you should achieve good performance", "label": {"api": {"BufferedReader": [[8, 21]]}}}, {"text": "these special files are found by ServiceLoader utility and enable the alternate implementation to be automatically loaded", "label": {"api": {"ServiceLoader": [[33, 45]]}}}, {"text": "You can implement for example a Timer that fire every 60 seconds and if the time is 12 AM download the file", "label": {"api": {"Timer": [[32, 36]]}}}, {"text": "Override the paintComponent method of your panel so you can custom draw", "label": {"api": {"paintComponent": [[13, 26]]}}}, {"text": "You should build a TrustManager that wraps the default trust manager, catches the CertificiateExpiredException and ignores it", "label": {"api": {"CertificiateExpiredException": [[82, 109]]}}}, {"text": "The trust managers throw CertificateExceptions (see subclasses for details) when something is wrong with a certificate", "label": {"api": {"CertificateException": [[25, 44]]}}}, {"text": "SwingWorker is a built-in mechanism for executing long running tasks on a background thread so the EDT is not blocked", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "You run into a StackOverflowError (ironic, isn't it?) if you try to do that", "label": {"api": {"StackOverflowError": [[15, 32]]}}}, {"text": "Usually SwingWorker is used for these tasks", "label": {"api": {"SwingWorker": [[8, 18]]}}}, {"text": "I have time as  a \"2011-12-03 12:00:19\" how to convert it in \"Fri 2 December 2011 \" ,I know this http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html ,But gives me Error", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html": [[97, 168]]}}}, {"text": "See documentation for Serializable interface as well as ObjectInputStream and ObjectOutputStream", "label": {"api": {"Serializable": [[22, 33]], "ObjectInputStream": [[56, 72]], "ObjectOutputStream": [[78, 95]]}}}, {"text": "I've now written a HttpServlet for the pop-up to circumvent this problem", "label": {"api": {"HttpServlet": [[19, 29]]}}}, {"text": "Since the file to which it's forwarding is ending with *.jsp, it's not affected by the FacesServlet and no strange header gets appended", "label": {"api": {"FacesServlet": [[87, 98]]}}}, {"text": "I am using the  Java Debug Interface API to write the custom programs for debugging the Java applications I write", "label": {"api": {"Java Debug Interface API": [[16, 39]]}}}, {"text": "Use the String.split() function to break your String in different strings, based on the separator", "label": {"api": {"String.split()": [[8, 21]]}}}, {"text": "For more info on Java's regex support see the Pattern class", "label": {"api": {"Pattern class": [[46, 58]]}}}, {"text": "If you never need to use both ClientSimple and ClientAdvanced in the same application you can declare Client as @MappedSuperclass rather than @Entity", "label": {"api": {"@MappedSuperclass": [[112, 128]]}}}, {"text": "This is the name that should appear within @Entity annotation as the value of the name attribute", "label": {"api": {"@Entity": [[43, 49]]}}}, {"text": "Invoking FileSystemView.getFileSystemView() repeatedly may be a problem, as suggested here and profiled here", "label": {"api": {"FileSystemView.getFileSystemView()": [[9, 42]]}}}, {"text": "After that, you can check whether these methods occur in the EDT by invoking SwingUtilities.isEventDispatchThread() prior to their execution (this is just for verification)", "label": {"api": {"SwingUtilities.isEventDispatchThread()": [[77, 114]]}}}, {"text": "There are a bunch of reasons why the error occurs, the most obvious one being http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/OutOfMemoryError.html", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/OutOfMemoryError.html": [[78, 153]]}}}, {"text": "you should use equals() instead of operator==", "label": {"api": {"equals()": [[15, 22]]}}}, {"text": "The symbol ∏ is a capital π, or Math.PI in Java", "label": {"api": {"Math.PI": [[32, 38]]}}}, {"text": "If you really want to do this anyway, have a look at the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[57, 80]]}}}, {"text": "The differences between the Java and .NET memory model need to be taken into account though", "label": {"api": {"Java": [[28, 31]]}}}, {"text": "This usually involves using the Interlocked functions (in Java), VolatileRead / VolatileWrite or explicit memory barrier", "label": {"api": {"Java": [[58, 61]]}}}, {"text": "One practical case where the .NET memory model makes difference to Java one is described on the IKVM.NET blog", "label": {"api": {"Java": [[67, 70]]}}}, {"text": "Locking works the same way as in Java", "label": {"api": {"Java": [[33, 36]]}}}, {"text": "Safe publication - The first two scenarios (locks and volatile) work identical to the Java counterparts", "label": {"api": {"Java": [[86, 89]]}}}, {"text": "You need to call yourFrame.pack() after .add()", "label": {"api": {"pack()": [[27, 32]]}}}, {"text": "You can use retainAll method and get the intersection of your two sets", "label": {"api": {"retainAll": [[12, 20]]}}}, {"text": "Wouldn't Collections.disjoint(A, B) work", "label": {"api": {"Collections.disjoint(A, B)": [[9, 34]]}}}, {"text": "The JSP uses ServletContext.getResourceAsStream(), which doesn't do the same thing as Class.getResourceAsStream()", "label": {"api": {"ServletContext.getResourceAsStream()": [[13, 48]]}}}, {"text": "You can use EnumType.STRING which will store the value as String in the database", "label": {"api": {"EnumType.STRING": [[12, 26]]}}}, {"text": "But using native ENUM require you to define the columnDefinition using @Column annotation which need all your roles to be harcoded there, you see", "label": {"api": {"@Column": [[71, 77]]}}}, {"text": "If you wish to zoom for better readability, that means you have a lot of information in the frame, In this case, I'd suggest you to organize the informations in your frame accordingly and use a JTabbedPane rather than going for a zoomed frame", "label": {"api": {"JTabbedPane": [[194, 204]]}}}, {"text": "Not sure I've understood the question properly, but I feel that it's a right place to use a Map", "label": {"api": {"Map": [[92, 94]]}}}, {"text": "You can find more info about Maps in the Java documentation", "label": {"api": {"Map": [[29, 31]]}}}, {"text": "For more information look at http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html": [[29, 97]]}}}, {"text": "I've heard there is a collection called LinkedHashMap, but I haven't found anything like it for a set", "label": {"api": {"LinkedHashMap": [[40, 52]]}}}, {"text": "treeset is an ordered set, but you can't access via an items index, just iterate through or go to beginning/end", "label": {"api": {"treeset": [[0, 6]]}}}, {"text": "A normal HashSet's iterator is quite random, a TreeSet does it by sort order, a LinkedHashSet iterator iterates by insert order", "label": {"api": {"LinkedHashSet": [[80, 92]]}}}, {"text": "You can't replace an element in a LinkedHashSet, however", "label": {"api": {"LinkedHashSet": [[34, 46]]}}}, {"text": "Take a look at the Java standard API doc", "label": {"api": {"Java standard API doc": [[19, 39]]}}}, {"text": "Right next to LinkedHashMap, there is a LinkedHashSet", "label": {"api": {"LinkedHashMap": [[14, 26]], "LinkedHashSet": [[40, 52]]}}}, {"text": "But note that the order in those is the insertion order, not the natural order of the elements", "label": {"api": {"natural order": [[65, 77]]}}}, {"text": "There is also an interface SortedSet implemented by TreeSet and ConcurrentSkipListSet", "label": {"api": {"SortedSet": [[27, 35]], "TreeSet": [[52, 58]], "ConcurrentSkipListSet": [[64, 84]]}}}, {"text": "Both allow iteration in the natural order of their elements or a Comparator, but not random access or insertion order", "label": {"api": {"natural order": [[28, 40]], "Comparator": [[65, 74]]}}}, {"text": "DecimalFormat should do what you need", "label": {"api": {"DecimalFormat": [[0, 12]]}}}, {"text": "But you could use the getTime() function in JavaScript which returns the milliseconds since 1 January 1970 00:00:00 UTC and initializes the Java Date object with this value", "label": {"api": {"Date object": [[145, 155]]}}}, {"text": "I'm currently using the FileOutputStream's write(byte\\[\\]) method", "label": {"api": {"FileOutputStream": [[24, 39]], "write(byte\\[\\]) method": [[43, 64]]}}}, {"text": "I'm also experimenting with wrapping the FileOutputStream in a BufferedOutputStream, including using the constructor that accepts a buffer size as a parameter", "label": {"api": {"FileOutputStream": [[41, 56]], "BufferedOutputStream": [[63, 82]], "the constructor that accepts a buffer size as a parameter": [[101, 157]]}}}, {"text": "It appears that using the BufferedOutputStream is tending toward slightly better performance, but I've only just begun to experiment with different buffer sizes", "label": {"api": {"BufferedOutputStream": [[26, 45]]}}}, {"text": "Consider using URLEncoder and URLDecoder", "label": {"api": {"URLEncoder": [[15, 24]], "URLDecoder": [[30, 39]]}}}, {"text": "The HttpServletResponse#encodeURL() method has actually a misleading name", "label": {"api": {"HttpServletResponse#encodeURL()": [[4, 34]]}}}, {"text": "In the servlet side, you need URLEncoder#encode() instead", "label": {"api": {"URLEncoder#encode()": [[30, 48]]}}}, {"text": "You're confused between Java SE (for which a JVM can be an implementation, like OpenJDK's HotSpot) and Java EE which has GlassFish as the reference implementation (hence its presence in the SDK) and JBoss, Geronimo, etc..", "label": {"api": {"Java EE": [[103, 109]]}}}, {"text": "Java EE requires Java SE, so a JVM is indeed required by any application server, GlassFish included", "label": {"api": {"Java EE": [[0, 6]]}}}, {"text": "Some Java EE SDK bundles come with a JVM in case you don't already have one", "label": {"api": {"Java EE": [[5, 11]]}}}, {"text": "One can use Java SE (which defines a large set of API's) without Java EE if you don't need a \"container\" to abstract away the integration to databases for instance or provide services such as resource injection or more generally scalability across multiple users", "label": {"api": {"Java EE": [[65, 71]], "large set of API's": [[37, 54]]}}}, {"text": "You can use the serializable interface in Java to create persistent objects that you can save and reload from disk", "label": {"api": {"serializable": [[16, 27]]}}}, {"text": "If the file resides on your classpath (this includes the path where your classes are deployed), you can access vía the ClassLoader method getSystemResource", "label": {"api": {"getSystemResource": [[138, 154]]}}}, {"text": "I would recommend using a SynchronousQueue which will block the event until the processer is ready for it", "label": {"api": {"SynchronousQueue": [[26, 41]]}}}, {"text": "will be handled by the SynchronousQueue", "label": {"api": {"SynchronousQueue": [[23, 38]]}}}, {"text": "On session creation (in HttpSessionListener#sessionCreated(), for example)", "label": {"api": {"HttpSessionListener#sessionCreated()": [[24, 59]]}}}, {"text": "On preprocessing of the JSP request (in HttpServlet#doGet(), for example)", "label": {"api": {"HttpServlet#doGet()": [[40, 58]]}}}, {"text": "On postprocessing of the form submit (in HttpServlet#doPost(), for example)", "label": {"api": {"HttpServlet#doPost()": [[41, 60]]}}}, {"text": "You could call umount using Runtime.exec", "label": {"api": {"Runtime.exec": [[28, 39]]}}}, {"text": "You have no need to pass the System.out to the showDetails() method", "label": {"api": {"System.out": [[29, 38]]}}}, {"text": "Read about System.out", "label": {"api": {"System.out": [[11, 20]]}}}, {"text": "Look at the doc of System.out", "label": {"api": {"doc of System.out": [[12, 28]]}}}, {"text": "Use List<E>#add(int, E) to specify the position at which an element will be added to a list", "label": {"api": {"List<E>#add(int, E)": [[4, 22]]}}}, {"text": "My design decision for wrapping this in a Future was so that I can re-use it in multiple activities with the added bonus of killing it when necessary", "label": {"api": {"Future": [[42, 47]]}}}, {"text": "And if you need to kill the location update for whatever reason (if your user switches out of your activity, etc), this will kill the AsyncTask as well as the associated Future task", "label": {"api": {"Future": [[170, 175]]}}}, {"text": "Perhaps because length() comes from the CharSequence interface", "label": {"api": {"CharSequence interface": [[40, 61]]}}}, {"text": "The java.awt.Polygon class has a number of contains(...) methods if you use Polygon objects to represent your polygon", "label": {"api": {"Polygon": [[13, 19], [76, 82]]}}}, {"text": "You should use a PreparedStatement, and set each field parametrically", "label": {"api": {"PreparedStatement": [[17, 33]]}}}, {"text": "You can write your own ClassLoader subclass, and use its loadClass() instead of the default one", "label": {"api": {"ClassLoader": [[23, 33]]}}}, {"text": "For reference, this short example examines a transformed Polygon using the contains() method", "label": {"api": {"Polygon": [[57, 63]], "contains()": [[75, 84]]}}}, {"text": "Use System.getenv(String), not System.getProperty(String), to retrieve environment vars", "label": {"api": {"System.getenv(String)": [[4, 24]], "System.getProperty(String)": [[31, 56]]}}}, {"text": "Using the example given in the documentation for ClassLoader I am able to load a class which is in the same package as ${it}", "label": {"api": {"documentation for ClassLoader": [[31, 59]]}}}, {"text": "The JNI API has a method called NewDirectByteBuffer which is declared as", "label": {"api": {"ByteBuffer": [[41, 50]]}}}, {"text": "What it does is take a region of memory, described by a void* pointing to the top of it and a length, and creates a ByteBuffer wrapping it", "label": {"api": {"ByteBuffer": [[116, 125]]}}}, {"text": "ByteBuffer has a pretty rich API", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "You should read Java's .equals() documentation carefully, it is a fundamental part to understand", "label": {"api": {".equals() documentation": [[23, 45]]}}}, {"text": "To go the other way you'd use JTextPane.viewToModel", "label": {"api": {"JTextPane.viewToModel": [[30, 50]]}}}, {"text": "You could use a Set instead of an array of ints, it could delete your duplications automatic", "label": {"api": {"Set": [[16, 18]]}}}, {"text": "More than implements your own Set you could write a wrapper over an int and overwrite your equals and hashcode methods, finding the way where your permutations are equals", "label": {"api": {"Set": [[30, 32]]}}}, {"text": "It could give you a better way to find your permutations in the Set", "label": {"api": {"Set": [[64, 66]]}}}, {"text": "The easiest method to remove duplicate elements is to add the contents to a Set which won't allow duplicates and then add the Set back to an ArrayList as an example below", "label": {"api": {"Set": [[76, 78], [126, 128]]}}}, {"text": "I'd ignore the line feeds and let JTextArea do its thing with print()", "label": {"api": {"print()": [[62, 68]]}}}, {"text": "If each invoice will be a different length, maybe you can separate them into individual text areas and append() each Printable to a Book", "label": {"api": {"Book": [[132, 135]]}}}, {"text": "Hashtable.contains() tries to find an entry with an equal value", "label": {"api": {"Hashtable.contains()": [[0, 19]]}}}, {"text": "I think you can use HttpURLConnection to download, and Process to run it", "label": {"api": {"Process": [[55, 61]]}}}, {"text": "Check MessageFormat out", "label": {"api": {"MessageFormat": [[6, 18]]}}}, {"text": "You can combine it with ResourceBundle getString method to read the message from your properties files through its key and output the formatted, dynamically filled message", "label": {"api": {"ResourceBundle": [[24, 37]]}}}, {"text": "You can do this with a java.text.DecimalFormat object", "label": {"api": {"java.text.DecimalFormat": [[23, 45]]}}}, {"text": "In Java one obvious example is java.util.Comparator", "label": {"api": {"java.util.Comparator": [[31, 50]]}}}, {"text": "It would be better to use JFormattedTextField", "label": {"api": {"JFormattedTextField": [[26, 44]]}}}, {"text": "Specifically, the JFormattedTextField class adds a formatter and an object value to the features inherited from the JTextField class", "label": {"api": {"JFormattedTextField": [[18, 36]]}}}, {"text": "It's the Class instance for the interface, I", "label": {"api": {"Class": [[9, 13]]}}}, {"text": "Type.class is syntactic sugar for obtaining object Class object via Class.forName()", "label": {"api": {"Class": [[51, 55], [68, 72]], "Class.forName()": [[68, 82]]}}}, {"text": "I would use a ThreadPoolExecutor to manage the threads", "label": {"api": {"ThreadPoolExecutor": [[14, 31]]}}}, {"text": "With Scanner, you can do", "label": {"api": {"Scanner": [[5, 11]]}}}, {"text": "Scanner scan = new Scanner(new File(myPath), myEncoding) and then scan.nextLine() which returns a String", "label": {"api": {"Scanner": [[0, 6], [19, 25]]}}}, {"text": "Note that you can access environment variables from your Java code by using System.getenv()", "label": {"api": {"System.getenv()": [[76, 90]]}}}, {"text": "The toArray() method will turn your list of strings (java.util.List<String>) into an array of String objects", "label": {"api": {"toArray()": [[4, 12]]}}}, {"text": "So just loop over list and create an array of String and pass that array or more easy way to use .toArray(new String[collection.size()]) method of Collection class", "label": {"api": {".toArray(new String[collection.size()])": [[97, 135]]}}}, {"text": "Consider using this constructor, which allows you to explicitly specify which symbols you are using", "label": {"api": {"constructor": [[20, 30]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "Spring provides ReloadableResourceBundleMessageSource that can reload the properties file  through the cacheSeconds setting.It support the properties files in the format of *.properties and the XML format used by  Properties.loadFromXML()", "label": {"api": {"Properties.loadFromXML()": [[214, 237]]}}}, {"text": "Is it possible for you to use gc.createCompatibleImage()", "label": {"api": {"gc.createCompatibleImage()": [[30, 55]]}}}, {"text": "If you are using ArrayList, you may want to change it to a CopyOnWriteArrayList, or ConcurrentLinkedQueue", "label": {"api": {"CopyOnWriteArrayList": [[59, 78]], "ConcurrentLinkedQueue": [[84, 104]]}}}, {"text": "For reference, one other framework that may serve as a model (if not a solution) is UndoManager, which supports a limited number of edits", "label": {"api": {"UndoManager": [[84, 94]]}}}, {"text": "It's part of the javax.swing.undo package, one of several core Text Component Features", "label": {"api": {"javax.swing.undo": [[17, 32]]}}}, {"text": "Pretty easy to do this using the SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[33, 48]]}}}, {"text": "Well if the structure of the plain text files are well-formed, why not use the Java DOM API (or JDOM) combined with a DOCTYPE to create a DOM Object", "label": {"api": {"DOM API": [[84, 90]]}}}, {"text": "You can, however, substitute the wrapper java.lang.Character, as in", "label": {"api": {"java.lang.Character": [[41, 59]]}}}, {"text": "By using an InputStreamReader and specifying your charset, like so", "label": {"api": {"InputStreamReader": [[12, 28]]}}}, {"text": "Create a TimerTask which would query this \"queue\" every 1 minute, pick up the Runnable/Callable jobs and submit them to the ExecutorService", "label": {"api": {"TimerTask": [[9, 17]], "Runnable": [[78, 85]], "Callable": [[87, 94]], "ExecutorService": [[124, 138]]}}}, {"text": "See the Thread.holdsLock(Object) method", "label": {"api": {"Thread.holdsLock(Object)": [[8, 31]]}}}, {"text": "MimeMessage does have the method getRecipients() which has an input parameter of type Message.RecipientType", "label": {"api": {"MimeMessage": [[0, 10]], "getRecipients()": [[33, 47]], "Message.RecipientType": [[86, 106]]}}}, {"text": "The way you've described your use-case, why not consider the HashMap, or some other Map based implementation", "label": {"api": {"HashMap": [[61, 67]], "Map": [[65, 67], [84, 86]]}}}, {"text": "LinkedHashMap - a container of key-value pairs that maintains the order of their insertion", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "Looks like in Java 7 and above on Windows, you can use Path#toRealPath(NOFOLLOW_LINKS) and it would be more correct than getCanonicalFile() in the presence of symlinks", "label": {"api": {"Path#toRealPath(NOFOLLOW_LINKS)": [[55, 85]]}}}, {"text": "By using compareToIgnoreCase, http://docs.oracle.com/javase/1.3/docs/api/java/lang/String.html#compareToIgnoreCase%28java.lang.String%29 you should be able to do what you want", "label": {"api": {"http://docs.oracle.com/javase/1.3/docs/api/java/lang/String.html#compareToIgnoreCase%28java.lang.String%29": [[30, 135]]}}}, {"text": "Traditionally, you can develop your own logic to compare strings held by an ArrayList", "label": {"api": {"ArrayList": [[76, 84]]}}}, {"text": "Why shouldn't be used some direct and convenient ways like a SortedSet as shown below with a case insensitive comparator?", "label": {"api": {"case insensitive comparator": [[93, 119]]}}}, {"text": "I would use ProcessBuilder.redirectErrorStream(true) which allows you to read one stream in the current thread", "label": {"api": {"ProcessBuilder.redirectErrorStream(true)": [[12, 51]]}}}, {"text": "There are various methods in java.lang.Runtime that will let you inspect how much memory you have", "label": {"api": {"methods": [[18, 24]]}}}, {"text": "If you try to implement in Java, you can try to create a Thread for your job, and let the thread sleep for a period", "label": {"api": {"Thread": [[57, 62]]}}}, {"text": "And also you can use Timer class, which could also let you create a thread", "label": {"api": {"Timer": [[21, 25]]}}}, {"text": "The fmt:setLocale tag sets the locale for the pages LocalizationContext which is then used by fmt:message, fmt:formatNumber, fmt:parseNumber, fmt:formatDate, and fmt:parseDate", "label": {"api": {"LocalizationContext": [[52, 70]]}}}, {"text": "You can use BigDecimal for this purpose", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "BigDecimal helps you to aware this problem", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "Here is code sample with BigDecimal", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "By this link you can find many examples with usage of BigDecimal class", "label": {"api": {"BigDecimal": [[54, 63]]}}}, {"text": "But, BigDecimal could be what you are looking for", "label": {"api": {"BigDecimal": [[5, 14]]}}}, {"text": "You should use Vector(int size, int incr) when you want to control, what size for Vector will be set after it overflows", "label": {"api": {"Vector": [[15, 20], [82, 87]]}}}, {"text": "You should use Vector(Collection c) when you want to fill it with values from another Collection", "label": {"api": {"Vector": [[15, 20]]}}}, {"text": "Follow this link for further information", "label": {"api": {"this link": [[7, 15]]}}}, {"text": "Please note that in the most cases you should use ArrayList, not Vector", "label": {"api": {"ArrayList": [[50, 58]], "Vector": [[65, 70]]}}}, {"text": "Vector has its method synchronized, you won't need that always", "label": {"api": {"Vector": [[0, 5]]}}}, {"text": "If you want to create a String use StringBuilder instead", "label": {"api": {"StringBuilder": [[35, 47]]}}}, {"text": "Java has the java.text.DateFormat class to format dates", "label": {"api": {"java.text.DateFormat": [[13, 32]]}}}, {"text": "Use Enum's name() method", "label": {"api": {"name()": [[11, 16]]}}}, {"text": "The good news is that you can achieve the correct result with java.net.URI class", "label": {"api": {"java.net.URI": [[62, 73]]}}}, {"text": "If you want microsecond accuracy, you might want to look at JSR-310, or java.sql.Timestamp as a bit of a hack - but don't expect any of the built-in classes such as Calendar and DateFormat to handle anything beyond milliseconds", "label": {"api": {"java.sql.Timestamp": [[72, 89]]}}}, {"text": "for benchmarking) you should use System.nanoTime, but that should only be used for stopwatch-like use cases - it doesn't give you the \"current wallclock time\" in a meaningful way", "label": {"api": {"System.nanoTime": [[33, 47]]}}}, {"text": "To measure time in microseconds you need to use the System.nanoTime() function which will return a time in microseconds based on the most accurate clock available to your system", "label": {"api": {"System": [[52, 57]]}}}, {"text": "To the user this acts in pretty much the same way as System.currentTimeMilis() does for milliseconds, you simply define your start and end times and then negate the difference to find out how long an action took", "label": {"api": {"System": [[53, 58]]}}}, {"text": "All of the above information is available from the Java API documentation for System", "label": {"api": {"System": [[78, 83]]}}}, {"text": "Not supported in the default HTML editor kit", "label": {"api": {"HTML editor kit": [[29, 43]]}}}, {"text": "What you might need to do is to create each rectangle as a JPanel", "label": {"api": {"JPanel": [[59, 64]]}}}, {"text": "You can then use the GridLayout to create your grid and then set the background of the JPanel as shown here", "label": {"api": {"JPanel": [[87, 92]], "GridLayout": [[21, 30]]}}}, {"text": "You can also put a JLabel in each JPanel and use the setIcon() method as shown here", "label": {"api": {"JPanel": [[34, 39]], "JLabel": [[19, 24]], "setIcon()": [[53, 61]]}}}, {"text": "You could use the getComponents and the use the instanceOf keyword as shown here", "label": {"api": {"getComponents": [[18, 30]]}}}, {"text": "The .class keyword get the Class object represent both primitive types and class types, while the .TYPE field of the wrapper primitive class allows you to get the Class of the primitive type which that object wraps", "label": {"api": {"Class": [[27, 31], [163, 167]]}}}, {"text": "If you attempt to add a duplicate item, the method will return false and the data structure will remain unchanged", "label": {"api": {"add": [[18, 20]]}}}, {"text": "Instead of using an ArrayList, why wouldn't you use a Set implementation (likely a HashSet)", "label": {"api": {"Set": [[54, 56], [87, 89]], "HashSet": [[83, 89]]}}}, {"text": "You'll get constant-time lookup, no sorting needed", "label": {"api": {"constant-time lookup": [[11, 30]]}}}, {"text": "Since I think Java6 there is actually the DatatypeConverter class which is part of JAXB", "label": {"api": {"DatatypeConverter": [[42, 58]]}}}, {"text": "[EDIT]  If you want the user to be able to enter an \"unlimited\" number of integers, then an ArrayList<Integer> would be more ideal", "label": {"api": {"ArrayList<Integer>": [[92, 109]]}}}, {"text": "I suggest you to define some properties into your JPanel extended class, and use PropertyChangeListener to listen the occured changes and enable/disable relative buttons", "label": {"api": {"PropertyChangeListener": [[81, 102]]}}}, {"text": "You can add a property to a JComponent using putClientProperty method", "label": {"api": {"putClientProperty": [[45, 61]]}}}, {"text": "Then add a PropertyChangeListener that when is notified enable/disable the ok button", "label": {"api": {"PropertyChangeListener": [[11, 32]]}}}, {"text": "Look at ServletContextListener", "label": {"api": {"ServletContextListener": [[8, 29]]}}}, {"text": "Looks like instead of JOptionPane.showConfirmDialog you are going to have to use JOptionPane.showOptionDialog, which lets you supply your own texts as an array", "label": {"api": {"JOptionPane.showOptionDialog": [[81, 108]]}}}, {"text": "Then use Properties.load(InputStream) to load it", "label": {"api": {"Properties.load(InputStream)": [[9, 36]]}}}, {"text": "Nimbus supports per-instance overrides of LAF properties, in your context something like", "label": {"api": {"per-instance overrides of LAF properties": [[16, 55]]}}}, {"text": "The core of the problem is that this Java code evaluates to false because ZERO has a scale of 0 and the new BigDecimal has a non-zero scale", "label": {"api": {"scale": [[85, 89], [134, 138]]}}}, {"text": "See the Character docs for more information", "label": {"api": {"Character docs": [[8, 21]]}}}, {"text": "You can use String.format", "label": {"api": {"String.format": [[12, 24]]}}}, {"text": "Use substring method like this:", "label": {"api": {"substring method": [[4, 19]]}}}, {"text": "Soneone told me that AtomicInteger is implemented using JNI, so it is much faster than synchonization", "label": {"api": {"AtomicInteger": [[21, 33]]}}}, {"text": "Another way would be to use a LinkedHashMap which does preserve insertion/iteration order", "label": {"api": {"LinkedHashMap": [[30, 42]]}}}, {"text": "The javadoc for ContentHandler.characters() says this", "label": {"api": {"ContentHandler.characters()": [[16, 42]]}}}, {"text": "I suspect you want Class.newInstance()", "label": {"api": {"Class.newInstance()": [[19, 37]]}}}, {"text": "Note that newInstance() will always try to call a parameterless constructor - if you need to pass any arguments, use getConstructors() to find the constructors declared by that class, then invoke the appropriate one", "label": {"api": {"getConstructors()": [[117, 133]]}}}, {"text": "Look at the javadoc of SimpleDateFormat and look at what the m represents", "label": {"api": {"SimpleDateFormat": [[23, 38]]}}}, {"text": "Try this if you are using Java 8", "label": {"api": {"Java 8": [[26, 31]]}}}, {"text": "You can use Date, Calendar, GregorianCalendar,SimpleDateFormat` etc classes to deal with date-time in Java", "label": {"api": {"Calendar": [[18, 25], [37, 44]], "GregorianCalendar": [[28, 44]], "SimpleDateFormat`": [[46, 62]]}}}, {"text": "Here is the API for Document.remove(int, int)", "label": {"api": {"Document.remove(int, int)": [[20, 44]]}}}, {"text": "Look at its javadoc", "label": {"api": {"its javadoc": [[8, 18]]}}}, {"text": "Take a look at the documentation of ArrayList<E> and List<E>, which is the interface", "label": {"api": {"ArrayList<E>": [[36, 47]], "List<E>": [[41, 47], [53, 59]]}}}, {"text": "The easiest way is to put your data in vectors, and then construct a Vector from the data, and then construct a DefaultTableModel with that data", "label": {"api": {"DefaultTableModel": [[112, 128]]}}}, {"text": "in a SwingWorker) and at the start of it, call modalDialog.setVisible(true)", "label": {"api": {"SwingWorker": [[5, 15]]}}}, {"text": "You can use SocketChannel and configureBlocking(false)", "label": {"api": {"SocketChannel": [[12, 24]], "configureBlocking(false)": [[30, 53]]}}}, {"text": "If you have more than one non-blocking I/O channel and you intend to use them all from a single thread you will probably find Selector very useful, too", "label": {"api": {"Selector": [[126, 133]]}}}, {"text": "See also Arrays.equals()", "label": {"api": {"Arrays.equals()": [[9, 23]]}}}, {"text": "I'd suggest an ItemListener", "label": {"api": {"ItemListener": [[15, 26]]}}}, {"text": "A thread for each client is unnecessary; use java.nio classes for asynchronous I/O instead", "label": {"api": {"java.nio": [[45, 52]]}}}, {"text": "If you want main to wait for other threads before exiting, use Thread#join to join them", "label": {"api": {"Thread#join": [[63, 73]]}}}, {"text": "The SwingWorker has additional methods process() and done() which are automatically executed in the event dispatch thread", "label": {"api": {"SwingWorker": [[4, 14]], "process()": [[39, 47]], "done()": [[53, 58]]}}}, {"text": "If you're going to be executing a bunch of different distinct tasks – as opposed to trying to split one big task into multiple smaller tasks running in parallel, you might want to use an Executor", "label": {"api": {"Executor": [[187, 194]]}}}, {"text": "Unfortunately, a clean and efficient way to be notified of filesystem events (WatchService) was introduced only in Java 7", "label": {"api": {"WatchService": [[78, 89]]}}}, {"text": "If you cannot use that, the best way is probably to use ProcessBuilder to invoke tail -f on the logfile and read from the process's STDOUT in an endless loop, which will block whenever there are no events", "label": {"api": {"ProcessBuilder": [[56, 69]]}}}, {"text": "Use XPath - also readily available through standard Java APIs", "label": {"api": {"standard Java APIs": [[43, 60]]}}}, {"text": "There are plenty of static methods in the Arrays class", "label": {"api": {"Arrays": [[42, 47]]}}}, {"text": "I just want to add that arrays have a representation in the reflection API - java.lang.reflect.Array", "label": {"api": {"java.lang.reflect.Array": [[77, 99]]}}}, {"text": "To actually do this, unless you really want to implement it yourself, it'll probably be easiest to use the java.util.zip class, in particular the Deflater class and its deflate method", "label": {"api": {"java.util.zip": [[107, 119]], "Deflater": [[146, 153]]}}}, {"text": "Java7 ships with a default Path implementation for local files", "label": {"api": {"Path": [[27, 30]]}}}, {"text": "Is there a Path implementation for URLs", "label": {"api": {"Path": [[11, 14]]}}}, {"text": "see setImageObserver in ImageIcon", "label": {"api": {"setImageObserver": [[4, 19]]}}}, {"text": "The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch", "label": {"api": {"Exception": [[10, 18]]}}}, {"text": "Creating meta language with Java, see also ScriptEngineFactory", "label": {"api": {"ScriptEngineFactory": [[43, 61]]}}}, {"text": "First I would suggest to use symbolic names instead of \"magic values\" things like this", "label": {"api": {"symbolic names": [[29, 42]]}}}, {"text": "In this case it's really doesn't matter if you use if or a switch-case...but most important the code will be more readable by using symbolic names", "label": {"api": {"symbolic names": [[132, 145]]}}}, {"text": "It means that the second parameter should be a Class which class extends the APIResponse", "label": {"api": {"Class": [[47, 51]]}}}, {"text": "The second argument is an instance of type Class that corresponds to a subclass of APIResponse (or to APIResponse itself)", "label": {"api": {"Class": [[43, 47]]}}}, {"text": "I think you don't need to make persistence.xml editable since you can provide additional properties when calling Persistence.createEntityManagerFactory() (or using similar Hibernate-specific mechanisms)", "label": {"api": {"Persistence.createEntityManagerFactory()": [[113, 152]]}}}, {"text": "Just call setSelectedFile method before showing the dialog", "label": {"api": {"setSelectedFile": [[10, 24]]}}}, {"text": "I don't immediately see anything in your code that's doing anti-aliasing on purpose (it's frequently a useful technique) but I'm not sure what the Graphics2D defaults are so you might want to check that out and possibly explicitly turn anti-aliasing off (see the discussion at the top of the documentation page)", "label": {"api": {"the documentation page": [[288, 309]]}}}, {"text": "But this is incorrect, because Set.contains() may throw a NullPointerException if the Set implementation itself does not permit null elements", "label": {"api": {"Set.contains()": [[31, 44]]}}}, {"text": "Check Arrays.deepEquals() method", "label": {"api": {"Arrays.deepEquals()": [[6, 24]]}}}, {"text": "You can use the GridLayout for this, when you set the number of columns to 1", "label": {"api": {"GridLayout": [[16, 25]]}}}, {"text": "There is also the BoxLayout, which should give this effect when you use the PAGE_LAYOUT or Y_AXIS orientations", "label": {"api": {"BoxLayout": [[18, 26]]}}}, {"text": "Here is some sample code for BoxLayout", "label": {"api": {"BoxLayout": [[29, 37]]}}}, {"text": "If you try to set the BoxLayout on the JFrame directly, you will get a \"BoxLayout can't be shared\" error", "label": {"api": {"BoxLayout": [[22, 30], [72, 80]]}}}, {"text": "There are many examples in the JDK (Collections being one notable example) and the apache commons libraries of this pattern working very well", "label": {"api": {"Collections": [[36, 46]]}}}, {"text": "You can use an AdjustmentListener to condtion scrolling, as shown in this example", "label": {"api": {"AdjustmentListener": [[15, 32]]}}}, {"text": "You will need to create your own Custom Comparator (Take a look here)", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "If a WeakReference is the only reference to an object, and you want the object to hang around, you should probably be using a SoftReference instead", "label": {"api": {"WeakReference": [[5, 17]], "SoftReference": [[126, 138]]}}}, {"text": "WeakReferences are best used in cases where there will be other references to the object, but you can't (or don't want to have to) detect when those other references are no longer used", "label": {"api": {"WeakReference": [[0, 12]]}}}, {"text": "Then, the other reference will prevent the object from being garbage collected, and the WeakReference will just be another way of getting to the same object", "label": {"api": {"WeakReference": [[88, 100]]}}}, {"text": "WeakHashMap is a perfect way of holding these references", "label": {"api": {"WeakHashMap": [[0, 10]]}}}, {"text": "the key in the WeakHashMap is only weakly held, and so when the key is garbage collected, the value can be removed from the Map too, and hence be garbage collected", "label": {"api": {"WeakHashMap": [[15, 25]]}}}, {"text": "A WeakReference will point to the object while it is still alive, but point to \"null\" once the original object has been garbage collected", "label": {"api": {"WeakReference": [[2, 14]]}}}, {"text": "See flush() for more info", "label": {"api": {"flush()": [[4, 10]]}}}, {"text": "Use URLConnection setConnectTimeout and setReadTimeout methods", "label": {"api": {"setConnectTimeout": [[18, 34]], "setReadTimeout": [[40, 53]]}}}, {"text": "For animation, use an EDT-friendly utility class, such as javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[58, 74]]}}}, {"text": "Combine that sample code with the Swing JTree tutorial and a reference to the TreeSelectionListener interface (which is the equivalent of the ListSelectionListener which I used in my answer since that code uses a JList instead of a JTree) and you should be able to complete your requirement", "label": {"api": {"TreeSelectionListener": [[78, 98]]}}}, {"text": "See the ImageIO class which contains methods for reading and writing BufferedImages and RenderedImages to/from various input/output streams", "label": {"api": {"ImageIO class": [[8, 20]], "reading": [[49, 55]], "BufferedImage": [[69, 81]], "RenderedImage": [[88, 100]]}}}, {"text": "Use the constructor JTextArea(String text) on creating it", "label": {"api": {"JTextArea(String text)": [[20, 41]]}}}, {"text": "Remember that checks for equality in Java regarding Strings should use the String.equals() method", "label": {"api": {"String.equals()": [[75, 89]]}}}, {"text": "Since JSF 2.0 the above is by the way convenienced with the UIComponent#visitTree() method which follows the visitor pattern so that you just have to make a single call", "label": {"api": {"UIComponent#visitTree()": [[60, 82]]}}}, {"text": "Java has something similar called the finalize method", "label": {"api": {"finalize": [[38, 45]]}}}, {"text": "You can use PhantomReferences to do something like this", "label": {"api": {"PhantomReference": [[12, 27]]}}}, {"text": "Keep a PhantomReference to the interface object", "label": {"api": {"PhantomReference": [[7, 22]]}}}, {"text": "Once the PhantomReference comes up on its ReferenceQueue you know for sure that the expensive object is not being used through an interface object (even allowing for finalisation)", "label": {"api": {"PhantomReference": [[9, 24]]}}}, {"text": "Note that putAll() and addAll() are both optional methods in Map and Set", "label": {"api": {"putAll()": [[10, 17]], "addAll()": [[23, 30]]}}}, {"text": "Consequently (and in order to get O(1) lookup), I'd recommend using HashMap and HashSet", "label": {"api": {"HashMap": [[68, 74]], "HashSet": [[80, 86]]}}}, {"text": "Note that because neither HashSet or HashMap are synchronised you will need to look for some other solution if you want thread-safe code", "label": {"api": {"HashMap": [[37, 43]], "HashSet": [[26, 32]]}}}, {"text": "You can do this with a stream fairly easily", "label": {"api": {"stream": [[23, 28]]}}}, {"text": "This splits the maps into their Entrys and then joins them with a Collector which resolves duplicates by adding both values to a new HashSet", "label": {"api": {"Collector": [[66, 74]], "resolves duplicates": [[82, 100]]}}}, {"text": "The third parameter for Collectors.toMap is not necessary if there are no duplicate keys", "label": {"api": {"Collector": [[24, 32]], "Collectors.toMap": [[24, 39]]}}}, {"text": "There is another Collectors.toMap with a fourth parameter that lets you decide the type of the Map collected into", "label": {"api": {"Collector": [[17, 25]], "Collectors.toMap": [[17, 32]]}}}, {"text": "You can use a StringBuilder", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "First create a StringBuilder and fill it characters just containing spaces and end of lines", "label": {"api": {"StringBuilder": [[15, 27]]}}}, {"text": "Don't forget to count the newline characters, or do said method line for line, and add the lines together using another StringBuilder", "label": {"api": {"StringBuilder": [[120, 132]]}}}, {"text": "Also, since java 1.5, Class.getMethod(String, Class...) is a varargs method, so you don't need the java cruft that both the question and other answer has, ie", "label": {"api": {"Class.getMethod(String, Class...)": [[22, 54]]}}}, {"text": "Look into using an AsyncTask or a Handler with a Runnable to run your network stuff on another thread", "label": {"api": {"Runnable": [[49, 56]]}}}, {"text": "The HttpSession interface does not specify what the Object.toString() should rerurn for a session object", "label": {"api": {"HttpSession interface": [[4, 24]]}}}, {"text": "You should use getCreationTime() and similar methods to access the session timestamps and other attributes", "label": {"api": {"getCreationTime()": [[15, 31]]}}}, {"text": "The javadoc says that getCreationTime() doesn't work for a session that has been invalidated", "label": {"api": {"getCreationTime()": [[22, 38]]}}}, {"text": "Take a look at the URLEncoder class", "label": {"api": {"URLEncoder": [[19, 28]]}}}, {"text": "isDigit is a static method of the Character class", "label": {"api": {"isDigit": [[0, 6]], "Character": [[34, 42]]}}}, {"text": "Implement the Observer interface in your GUI component, and let your task extend Observable", "label": {"api": {"Observer": [[14, 21]], "Observable": [[81, 90]]}}}, {"text": "Use pack(), which \"Causes this Window to be sized to fit the preferred size and layouts of its subcomponents.\" An sscce may be helpful, too", "label": {"api": {"pack()": [[4, 9]]}}}, {"text": "An instance of DecimalFormat may be help control extreme size variability", "label": {"api": {"DecimalFormat": [[15, 27]]}}}, {"text": "Any reason why you wouldn't use another, more open format like 7zip (for compression), or plain Zip (for universal compatibility)", "label": {"api": {"Zip": [[96, 98]]}}}, {"text": "It looks like it's got some of the functionality, this is what RandomAccessFile.getChannel() returns", "label": {"api": {"RandomAccessFile.getChannel()": [[63, 91]]}}}, {"text": "You can set an uncaught exception handler on the thread via Thread.setUncaughtExceptionHandler(), which will handle any exceptions that are not handled within your code", "label": {"api": {"Thread.setUncaughtExceptionHandler()": [[60, 95]]}}}, {"text": "Also, if you want a handler for all threads, you can call Thread.setDefaultUncaughtExceptionHandler which is a static method to provide a handler for threads when there isn't one specifically for it", "label": {"api": {"Thread.setDefaultUncaughtExceptionHandler": [[58, 98]]}}}, {"text": "Void is a class like any other, so a function returning Void has to return a reference (such as null)", "label": {"api": {"Void": [[0, 3], [56, 59]]}}}, {"text": "In fact, Void is final and uninstantiable, which means that null is the only thing that a function returning Void could return", "label": {"api": {"Void": [[9, 12], [109, 112]]}}}, {"text": "If you're wondering about possible uses for Void, see Uses for the Java Void Reference Type", "label": {"api": {"Void": [[44, 47], [72, 75]]}}}, {"text": "Is Java's XPath API what you need", "label": {"api": {"Java's XPath API": [[3, 18]]}}}, {"text": "You can use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "You should take a look at SwingWorker and do it in the background", "label": {"api": {"SwingWorker": [[26, 36]]}}}, {"text": "you can look at the JavaDoc to see how to load a file/resource using an input stream, using Class.getResourceAsString(), the file needs to be on the classpath usually in the default package of your .war ( ie in the root of /lib ) with the .class files", "label": {"api": {"Class.getResourceAsString()": [[92, 118]]}}}, {"text": "One particular enhancement, which also lends itself to limited number of requests, is something called a ThreadPool", "label": {"api": {"ThreadPool": [[105, 114]]}}}, {"text": "Does anyone have any real life use cases where someone had to make a non-trivial implementation of the Java Document interface", "label": {"api": {"Document": [[108, 115]]}}}, {"text": "You could always use a .properties file in the classpath using the foo.bar.baz notation", "label": {"api": {".properties": [[23, 33]]}}}, {"text": "See EventQueue for more details", "label": {"api": {"EventQueue": [[4, 13]]}}}, {"text": "Note that SwingWorker is designed specifically for this kind of use-case", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "I would use a ProgressMonitor", "label": {"api": {"ProgressMonitor": [[14, 28]]}}}, {"text": "A workaround might be to use JAXB as your XML serializer which is bundled with Java 1.6", "label": {"api": {"JAXB": [[29, 32]]}}}, {"text": "It supports an @XmlTransient annotation", "label": {"api": {"@XmlTransient": [[15, 27]]}}}, {"text": "the java.beans.Transient annotation", "label": {"api": {"java.beans.Transient annotation": [[4, 34]]}}}, {"text": "Note that you can use it on the getters and the setters but not on the fields unlike javax.persistence.Transient (JPA)", "label": {"api": {"javax.persistence.Transient": [[85, 111]]}}}, {"text": "I would suggest using regular expressions (the Pattern class) rather than StringTokenizer for this", "label": {"api": {"the Pattern class": [[43, 59]]}}}, {"text": "You can override access type for specific field using @Access annotation (or @AccessType for old versions of Hibernate)", "label": {"api": {"@Access": [[54, 60], [77, 83]]}}}, {"text": "JTextAre has append(str) method to append string to it", "label": {"api": {"append(str)": [[13, 23]]}}}, {"text": "For chat area it will be good to use JTextPane instead of JTextArea, cause it allows to draw coloring string and emotions images", "label": {"api": {"JTextPane": [[37, 45]]}}}, {"text": "java.util.Stack and java.util.Queue (choose one of the implementations for Queue)", "label": {"api": {"java.util.Stack": [[0, 14]], "java.util.Queue": [[20, 34]]}}}, {"text": "Else, you may use a TreeSet, and have a comparator that compares by fitness first, and then by identity hash code if the fitnesses are equal (or by any other distinct property)", "label": {"api": {"identity hash code": [[95, 112]]}}}, {"text": "The javadoc for Double.NaN says it all", "label": {"api": {"javadoc for Double.NaN": [[4, 25]]}}}, {"text": "A comment mentions Runnable and Callable, IMO Runnable is specifically for threads (and the base interface isn't generic)", "label": {"api": {"Runnable": [[19, 26], [46, 53]], "Callable": [[32, 39]]}}}, {"text": "Callable is a better choice, but I'd expect enough other hooks would be added to handle SQL-/JDBC-specific functionality that I'd use something app-specific", "label": {"api": {"Callable": [[0, 7]]}}}, {"text": "Note that a JarEntry representing a directory (folder) must end with a slash (\"/\") in order to be treated as such; otherwise it will be considered a plain file", "label": {"api": {"JarEntry": [[12, 19]]}}}, {"text": "Alternatively, call setTitleAt to set the title of a specific tab to null", "label": {"api": {"setTitleAt": [[20, 29]]}}}, {"text": "Read the Java tutorial about generics to learn more", "label": {"api": {"Java tutorial about generics": [[9, 36]]}}}, {"text": "Try using Math.round(double) on the number after scaling it up, then scaling it back down", "label": {"api": {"Math.round(double)": [[10, 27]]}}}, {"text": "You can also use BigDecimal if you want to get really heavyweight", "label": {"api": {"BigDecimal": [[17, 26]]}}}, {"text": "A way to do so, is to pass an InputSource, instead of the URL, to the parse method", "label": {"api": {"InputSource": [[30, 40]]}}}, {"text": "The majority of dynamic data structures that are commonly used in Java reside in the Collections package", "label": {"api": {"the Collections package": [[81, 103]]}}}, {"text": "This API is very similar to using Java's own ZipInputStream", "label": {"api": {"ZipInputStream": [[45, 58]]}}}, {"text": "For example, I would like to add a function to java.lang.String, recompile it and use it for my project", "label": {"api": {"java.lang.String": [[47, 62]]}}}, {"text": "HashSet) and a map (i.e", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "To determine whether a tag is an actual tag, you would use the contains method of the set (O(1) for HashSet)", "label": {"api": {"HashSet": [[100, 106]]}}}, {"text": "If it is not, get the real tag by using get(alias) on the map (O(1) for HashMap)", "label": {"api": {"HashMap": [[72, 78]]}}}, {"text": "Consider using Objects.equals (in Java 7), or Objects.equal (in Guava) or an EqualsBuilder (in apache commons-lang)", "label": {"api": {"Objects.equals": [[15, 28]]}}}, {"text": "If you're sure you have an array, you could use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[48, 64]]}}}, {"text": "I'm not able to understand the internal sorting that is taking place in PriorityQueue", "label": {"api": {"PriorityQueue": [[72, 84]]}}}, {"text": "The java.lang.CharSequence interface (which java.lang.String implements), allows more compact representations of Strings than UTF-16", "label": {"api": {"java.lang.CharSequence": [[4, 25]]}}}, {"text": "You can use the package level annotation javax.xml.bind.annotation.XmlSchema to accomplish this", "label": {"api": {"javax.xml.bind.annotation.XmlSchema": [[41, 75]]}}}, {"text": "If you would prefer you can also do this on a class-by-class basis using the javax.xml.bind.annotation.XmlType annotation or on a field-by-field basis using the javax.xml.bind.annotation.XmlElement annotation", "label": {"api": {"javax.xml.bind.annotation.XmlType": [[77, 109]], "javax.xml.bind.annotation.XmlElement": [[161, 196]]}}}, {"text": "Everything in Java that can be thrown must derive from java.lang.Throwable", "label": {"api": {"java.lang.Throwable": [[55, 73]]}}}, {"text": "As it is, if you receive an already created file you can still move it using File.renameTo()", "label": {"api": {"File.renameTo()": [[77, 91]]}}}, {"text": "You haven't given us a lot to work with there, but my guess would be that urlToProps is null, since Class#getResource returns null if the resource isn't found, but you have no defensive check in the pictured code", "label": {"api": {"Class#getResource": [[100, 116]]}}}, {"text": "You can use StringBufferInputStream, but as you have an array of Strings, you might need to concatenate all of them first, or use a SequenceInputStream generating all the sub input streams..", "label": {"api": {"StringBufferInputStream": [[12, 34]], "SequenceInputStream": [[132, 150]]}}}, {"text": "By the way, StringBufferInputStream is deprecated, so might want to use the ByteArrayInputStream and String.getBytes(...) methods instead", "label": {"api": {"StringBufferInputStream": [[12, 34]]}}}, {"text": "You should read about Java servlets and servlet containers", "label": {"api": {"servlet": [[27, 33], [40, 46]]}}}, {"text": "Start by implementing a simple servlet that returns \"Hello world\" string", "label": {"api": {"servlet": [[31, 37]]}}}, {"text": "Here is the shortest upload/download servlet ever", "label": {"api": {"servlet": [[37, 43]]}}}, {"text": "You need to filter those out so that you're only iterating over the children that are elements, or parse the XML in a mode where white-space only text nodes inside <deviceInfo> elements are ignored", "label": {"api": {"ignored": [[190, 196]]}}}, {"text": "create the map, add the single key-value pair, and then make it unmodifiable using Collections.unmodifiableMap()", "label": {"api": {"Collections.unmodifiableMap()": [[83, 111]]}}}, {"text": "I do not recommend changing a static variable from multiple threads just to avoid carrying it in the class instance, but if that's what you want to do, see ThreadLocal", "label": {"api": {"ThreadLocal": [[156, 166]]}}}, {"text": "You are looking for the pow function of java.lang.Math", "label": {"api": {"pow": [[24, 26]], "java.lang.Math": [[40, 53]]}}}, {"text": "You can use Math.pow(value, power)", "label": {"api": {"pow": [[17, 19], [28, 30]]}}}, {"text": "If you intend to change the URL in the browser address bar from /yyy/xxx/* to /xxx/*, then you need to use HttpServletResponse#sendRedirect() instead of RequestDispatcher#forward()", "label": {"api": {"HttpServletResponse#sendRedirect()": [[107, 140]], "RequestDispatcher#forward()": [[153, 179]]}}}, {"text": "Have a look at SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "You use a SimpleDateFormat to parse your text", "label": {"api": {"SimpleDateFormat": [[10, 25]]}}}, {"text": "Alternatively you can use Class.getConstructor (then Constructor.newInstance), this way you can provide the arguments, but the exception problem is still there", "label": {"api": {"Class.getConstructor": [[26, 45]]}}}, {"text": "Check reference for optimal settings", "label": {"api": {"reference": [[6, 14]]}}}, {"text": "Not sure about the Spring part as I don't use it, but in JSF you can use an @ApplicationScoped @ManagedBean whose eager attribtue is set to true", "label": {"api": {"@ApplicationScoped": [[76, 93]], "@ManagedBean": [[95, 106]], "eager": [[114, 118]]}}}, {"text": "Check out Swing Dialogs (mainly focused on JOptionPane, as mentioned by @mcfinnigan)", "label": {"api": {"JOptionPane": [[43, 53]]}}}, {"text": "The documentation for String.intern() explicitly says", "label": {"api": {"documentation for String.intern()": [[4, 36]]}}}, {"text": "You cannot use @GeneratedValue on String property", "label": {"api": {"@GeneratedValue": [[15, 29]]}}}, {"text": "Take a look at Properties.list", "label": {"api": {"Properties.list": [[15, 29]]}}}, {"text": "To read properties from a file use Properties.load", "label": {"api": {"Properties.load": [[35, 49]]}}}, {"text": "Unfortunately there's no standard Java API to just add or remove a property from a file - you'll have first to load the whole file into a Properties instance and then save it back into the file after you made the required changes using Properties.setProperty", "label": {"api": {"Properties.setProperty": [[236, 257]]}}}, {"text": "java.util.Properties has load and store methods that will read and write the properties for you", "label": {"api": {"java.util.Properties": [[0, 19]]}}}, {"text": "Use the Stream.Available() method", "label": {"api": {"Stream.Available()": [[8, 25]]}}}, {"text": "You can use the InputStream.available() method to check how many bytes have currently arrived on the socket's input stream", "label": {"api": {"InputStream.available()": [[16, 38]]}}}, {"text": "See the group() and group(int) docs", "label": {"api": {"group()": [[8, 14]], "group(int)": [[20, 29]]}}}, {"text": "See the API docs", "label": {"api": {"API docs": [[8, 15]]}}}, {"text": "Use TreeSet.iterator() to get an iterator in ascending order and call next() K times", "label": {"api": {"TreeSet.iterator()": [[4, 21]]}}}, {"text": "Alternatively, you may be able (in some cases) to use the TreeSet's tailSet method and a modified binary search to try to find the kth element", "label": {"api": {"tailSet": [[68, 74]]}}}, {"text": "Specifically, look at the first and last elements of the TreeSet, then (if possible given the contents) pick some element that is halfway between the two and pass it as an argument to tailSet to get a view of the elements of the set after the midpoint", "label": {"api": {"tailSet": [[184, 190]]}}}, {"text": "Using the number of elements in the tailSet, you could then decide whether you've found the element, or whether to explore the left or right halves of the tree", "label": {"api": {"tailSet": [[36, 42]]}}}, {"text": "However, I don't know the internal complexity of the tailSet methods, so this could be actually be worse than the order statistic tree", "label": {"api": {"tailSet": [[53, 59]]}}}, {"text": "Replace @JoinColumn with @PrimaryKeyJoinColumn", "label": {"api": {"@PrimaryKeyJoinColumn": [[25, 45]]}}}, {"text": "According to JsDoc reference arguments of request are following", "label": {"api": {"JsDoc reference": [[13, 27]]}}}, {"text": "Try using the setText(String) method with an empty string argument", "label": {"api": {"setText(String)": [[14, 28]]}}}, {"text": "Look at the Math class from java.lang package", "label": {"api": {"Math": [[12, 15]]}}}, {"text": "Try this (reference)", "label": {"api": {"reference": [[10, 18]]}}}, {"text": "For more information about utilisation see Oracle HTMLEditorKit documentation and this O'Reilly PDF that contains interesting examples", "label": {"api": {"Oracle HTMLEditorKit documentation": [[43, 76]]}}}, {"text": "StreamTokenizer is fast, although I haven't used the quoteChar() feature", "label": {"api": {"StreamTokenizer": [[0, 14]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html check for the usage of getResource and getresourceAsStream methods", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html": [[0, 60]]}}}, {"text": "To produce concatenated messages  - have a look at MessageFormat class", "label": {"api": {"MessageFormat": [[51, 63]]}}}, {"text": "Also, if what you want is to simply read or write a JPEG file, take a look at the ImageIO class, there are plenty of useful methods in there", "label": {"api": {"ImageIO": [[82, 88]]}}}, {"text": "How about storing the whole object as a file via ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[49, 66]]}}}, {"text": "You can use String.split(String regex)", "label": {"api": {"String.split(String regex)": [[12, 37]]}}}, {"text": "You can also use a Matcher and a Pattern for a more general approach", "label": {"api": {"Matcher": [[19, 25]], "Pattern": [[33, 39]]}}}, {"text": "See the Robot class from AWT", "label": {"api": {"Robot": [[8, 12]]}}}, {"text": "See this demo of Robot class", "label": {"api": {"Robot": [[17, 21]]}}}, {"text": "Take a look at Robot class", "label": {"api": {"Robot": [[15, 19]]}}}, {"text": "Here is a simple example of mouseMove", "label": {"api": {"mouseMove": [[28, 36]]}}}, {"text": "You can use an idiom like the below which breaks the comparison into clear sections by field, only requires one test per field, and uses the signum method to produce the return values", "label": {"api": {"signum": [[141, 146]]}}}, {"text": "I'm not completely sure what you are asking, but you can layer a secure socket on an existing normal (non-secure) socket by using the SSLSocketFactory.createSocket() method", "label": {"api": {"SSLSocketFactory.createSocket()": [[134, 164]]}}}, {"text": "Invoke the table's scrollRectToVisible() method; pass it the Rectangle returned by getCellRect() for the desired row", "label": {"api": {"scrollRectToVisible()": [[19, 39]], "getCellRect()": [[83, 95]]}}}, {"text": "http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/event/KeyEvent.html, not raw characters", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/event/KeyEvent.html": [[0, 72]]}}}, {"text": "The simplest is to use console.nextLine() instead of .next()", "label": {"api": {"console.nextLine()": [[23, 40]]}}}, {"text": "Alternatively, you could use console.nextLine(Pattern pattern) and provide a pattern which is a regular expression that matches your desired input", "label": {"api": {"console.nextLine(Pattern pattern)": [[29, 61]]}}}, {"text": "The ButtonGroup#getElements method gives you an enumeration of AbstractButton instances", "label": {"api": {"ButtonGroup#getElements": [[4, 26]]}}}, {"text": "The AbstractButton#getActionCommand allows you to retrieve the action command and the AbstractButton#getSelected allows you to alter the selection", "label": {"api": {"AbstractButton#getActionCommand": [[4, 34]], "AbstractButton#getSelected": [[86, 111]]}}}, {"text": "As far as I know, java.util.Hashtable synchronizes each and every method in the java.util.Map interface, while Collections.synchronizedMap(hash_map) returns a wrapper object containing synchronized methods delegating calls to the actual hash_map (correct me if I am wrong)", "label": {"api": {"java.util.Hashtable": [[18, 36]], "java.util.Map": [[80, 92]], "Collections.synchronizedMap(hash_map)": [[111, 147]]}}}, {"text": "Will this be equal to simply using a normal java.util.Hashtable", "label": {"api": {"java.util.Hashtable": [[44, 62]]}}}, {"text": "You can use Stream.limit()", "label": {"api": {"Stream.limit()": [[12, 25]]}}}, {"text": "See the Java EE 7 Json specification", "label": {"api": {"Java EE 7 Json specification": [[8, 35]]}}}, {"text": "You can use an AtomicInteger object to maintain a thread safe counter", "label": {"api": {"AtomicInteger": [[15, 27]]}}}, {"text": "Then use getAndIncrement() when you need the next integer", "label": {"api": {"getAndIncrement()": [[9, 25]]}}}, {"text": "To get all nodes with key greater or equal to a given key you can use TreeMap.TailMap", "label": {"api": {"TreeMap.TailMap": [[70, 84]]}}}, {"text": "Take a look at the String.split method, which will help you split each line on space", "label": {"api": {"String.split": [[19, 30]]}}}, {"text": "Finally, call ArrayList.add to add it to your list", "label": {"api": {"ArrayList.add": [[14, 26]]}}}, {"text": "The Timer threads are created by the java.util.Timer", "label": {"api": {"java.util.Timer": [[37, 51]]}}}, {"text": "Take a look at the String class which has methods to give you its length and to find the charAt a certain index", "label": {"api": {"String": [[19, 24]], "length": [[66, 71]], "charAt": [[89, 94]]}}}, {"text": "Threads have more than 4 states", "label": {"api": {"states": [[25, 30]]}}}, {"text": "Note that if you're looking to execute a task at a set interval, I highly recommend using the Executors framework", "label": {"api": {"Executors": [[94, 102]]}}}, {"text": "Take a look at the String class which has methods to give you its length and to find the charAt at each index", "label": {"api": {"String": [[19, 24]], "length": [[66, 71]], "charAt": [[89, 94]]}}}, {"text": "Not quite, but you can use a NavigableMap.subMap to implement this", "label": {"api": {"NavigableMap.subMap": [[29, 47]]}}}, {"text": "Yes, it is possible using JOptionPane.showOptionDialog()", "label": {"api": {"JOptionPane.showOptionDialog()": [[26, 55]]}}}, {"text": "the PrivateKey class", "label": {"api": {"PrivateKey": [[4, 13]]}}}, {"text": "And as it turns out, there is nothing that lets you clear the private information of a PrivateKey from memory, because there's no API that lets you wipe the bytes that form the corresponding information", "label": {"api": {"PrivateKey": [[87, 96]]}}}, {"text": "If you are looking to search data by a range of keys then you can use navigable map", "label": {"api": {"navigable map": [[70, 82]]}}}, {"text": "To convert an array to a list use Arrays.asList", "label": {"api": {"Arrays.asList": [[34, 46]]}}}, {"text": "The sort() method from Collections can help you sort your ArrayList", "label": {"api": {"Collections": [[23, 33]]}}}, {"text": "Use the retainAll() method of Set", "label": {"api": {"retainAll()": [[8, 18]], "Set": [[30, 32]]}}}, {"text": "The javadoc of retainAll() says it's exactly what you want", "label": {"api": {"retainAll()": [[15, 25]]}}}, {"text": "Use the varStatus attribute, which references an object of type LoopTagStatus", "label": {"api": {"LoopTagStatus": [[64, 76]]}}}, {"text": "Use addAll instead of add, in order to add all elements from the list into your set", "label": {"api": {"addAll": [[4, 9]]}}}, {"text": "Override the insertString method of the document in the JTextPane so that it doesn't insert any more characters once the maximum has been reached", "label": {"api": {"insertString": [[13, 24]]}}}, {"text": "You can use the java.util.Timer class to schedule tasks on a background worker thread", "label": {"api": {"java.util.Timer": [[16, 30]]}}}, {"text": "Have a look at ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[15, 38]]}}}, {"text": "If you don't want to replace the user's chosen Look & Feel, you can just replace the UI delegate with one derived from BasicProgressBarUI", "label": {"api": {"BasicProgressBarUI": [[119, 136]]}}}, {"text": "The closest thing you can get hold of will be the default X509TrustManager using the default TrustManagerFactory", "label": {"api": {"TrustManagerFactory": [[93, 111]]}}}, {"text": "The logic in sun.security.ssl.DefaultSSLContextImpl (not part of the public API) is to initialise the TrustManagerFactory with a KeyStore obtained from the TrustManagerFactoryImpl (which is not part for the public API either)", "label": {"api": {"TrustManagerFactory": [[102, 120], [156, 174]]}}}, {"text": "This is consistent with the behaviour of TrustManagerFactory with tmf.init(null)", "label": {"api": {"TrustManagerFactory": [[41, 59]]}}}, {"text": "Indeed, the implementation (with tmf.init(null)) ends up doing the same, as shown in TrustManagerFactoryImpl (engineInit also calls getCacertsKeyStore when the keystore parameter is null)", "label": {"api": {"TrustManagerFactory": [[85, 103]]}}}, {"text": "You should start navigating on the filesystem, create a Runnable/Callable implementation to what you would like to do with these files and fore every file found submit it to a ThreadPool (you can create one from the Executors class)", "label": {"api": {"Executors": [[216, 224]]}}}, {"text": "This can be achieved by invoking revalidate and then issuing a repaint request (to remove any visual artifacts)", "label": {"api": {"revalidate": [[33, 42]]}}}, {"text": "use getSelectedValuesList instead", "label": {"api": {"getSelectedValuesList": [[4, 24]]}}}, {"text": "So, use public List<E> getSelectedValuesList()", "label": {"api": {"getSelectedValuesList": [[23, 43]]}}}, {"text": "Please use getSelectedValuesList", "label": {"api": {"getSelectedValuesList": [[11, 31]]}}}, {"text": "Here is the link to the API documentation getSelectedValuesList", "label": {"api": {"getSelectedValuesList": [[42, 62]]}}}, {"text": "You could make your own implementation of Writer that wraps an existing Writer / OutputStream, and replaces \"\\n\" with \"\\r\\n\" on the fly while writing", "label": {"api": {"Writer": [[42, 47], [72, 77]]}}}, {"text": "A simple example you could look at would be BoundedRangeModel", "label": {"api": {"BoundedRangeModel": [[44, 60]]}}}, {"text": "To add a new cookie, use HttpServletResponse.addCookie(Cookie)", "label": {"api": {"HttpServletResponse.addCookie(Cookie)": [[25, 61]], "Cookie": [[48, 53], [55, 60]]}}}, {"text": "The Cookie is pretty much a key value pair taking a name and value as strings on construction", "label": {"api": {"Cookie": [[4, 9]]}}}, {"text": "Look at the return value from Process.waitFor()", "label": {"api": {"Process.waitFor()": [[30, 46]]}}}, {"text": "It sounds like you probably want a HashMap..", "label": {"api": {"HashMap": [[35, 41]]}}}, {"text": "It's not clear what you're doing with NSMutableDictionary, but if it's simple key/value lookup, then some implementation of Map (whether it's HashMap or something else) is appropriate", "label": {"api": {"HashMap": [[142, 148]]}}}, {"text": "I assume rst is a ResultSet", "label": {"api": {"ResultSet": [[18, 26]]}}}, {"text": "Make sure you are using getBigDecimal rather than Double.parseDouble(rst.getString(5))", "label": {"api": {"getBigDecimal": [[24, 36]]}}}, {"text": "You can use the List.addAll() method", "label": {"api": {"List.addAll()": [[16, 28]]}}}, {"text": "Returns an unmodifiable List containing the elements of the given Collection, in its iteration order", "label": {"api": {"unmodifiable List": [[11, 27]]}}}, {"text": "Take a look on HttpURLConnection", "label": {"api": {"HttpURLConnection": [[15, 31]]}}}, {"text": "Or http://docs.oracle.com/javase/6/docs/api/java/util/SortedSet.html if you need sort-order.", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/SortedSet.html": [[3, 67]]}}}, {"text": "What about deriving from http://docs.oracle.com/javase/6/docs/api/java/util/TreeSet.html, it will allow you to pass in a Comparator at construction time", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/TreeSet.html": [[25, 87]]}}}, {"text": "Since node.insertBefore(newChild, null) doesn't work, but is the same as node.appendChild(newChild), the workaround is to simply call appendChild() when you would otherwise have called insertBefore() with a null refChild parameter", "label": {"api": {"node.insertBefore(newChild, null)": [[6, 38]], "node.appendChild(newChild)": [[73, 98]]}}}, {"text": "Not sure why you need to lock down every access to your static member but consider using AtomicReference and it's getAndSet() method for better performance", "label": {"api": {"AtomicReference and it's getAndSet() method": [[89, 131]]}}}, {"text": "It is in JavaSE 7 and JavaSE6/5/1.4.2, since 'DOM Level 2'", "label": {"api": {"JavaSE 7": [[9, 16]]}}}, {"text": "If that's the case, then make sure that your Map is a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[54, 66]]}}}, {"text": "The root Exception class accepts a String custom message, as do (as far as I can tell) all of derivative classes", "label": {"api": {"Exception": [[9, 17]]}}}, {"text": "If none of those are really satisfactory, then you can create an extension of Exception (or RuntimeException etc) and maintain the custom message constructor", "label": {"api": {"Exception": [[78, 86], [99, 107]]}}}, {"text": "Is it possible to handle a ViewExpiredException inside a portlet to display an appropriate error page", "label": {"api": {"ViewExpiredException": [[27, 46]]}}}, {"text": "Use a DecimalFormatter", "label": {"api": {"DecimalFormatter": [[6, 21]]}}}, {"text": "You use the String.format() method", "label": {"api": {"String.format()": [[12, 26]]}}}, {"text": "If you want to know whether a Car is-a Vehicle, use Class#isAssignableFrom", "label": {"api": {"Class#isAssignableFrom": [[52, 73]]}}}, {"text": "Many Swing bugs, quirks and other shortcomings can be worked around using SwingUtilities.invokeLater(Runnable)", "label": {"api": {"SwingUtilities.invokeLater(Runnable)": [[74, 109]]}}}, {"text": "This also solves the same problem with JTree.setSelectionPaths(TreePath[])", "label": {"api": {"JTree.setSelectionPaths(TreePath[])": [[39, 73]]}}}, {"text": "This can now be done in a single line using Java 8 Streams", "label": {"api": {"Java 8 Streams": [[44, 57]]}}}, {"text": "The preferred way to specify a size for your component is to set their preferred size before adding components to their container", "label": {"api": {"preferred size": [[71, 84]]}}}, {"text": "BufferedInputStream doesn't load all the file into memory, it only uses an internal buffer, in your case of size 1024 bytes = 1kb", "label": {"api": {"BufferedInputStream": [[0, 18]]}}}, {"text": "what you are thinking about maybe is a ByteArrayOutputStream, where data is saved in memory", "label": {"api": {"ByteArrayOutputStream": [[39, 59]]}}}, {"text": "1) Implement the required methods of SwingWorker", "label": {"api": {"SwingWorker": [[37, 47]]}}}, {"text": "Here is one approach using a CountDownLatch to keep the main-thread waiting", "label": {"api": {"CountDownLatch": [[29, 42]]}}}, {"text": "The problem likely has to do with the formatting of the SQL query; use a PreparedStatement instead of formatting it manually", "label": {"api": {"PreparedStatement": [[73, 89]]}}}, {"text": "[Edit] Note that the PreparedStatement#setDate() method requires a java.sql.Date, so you may need to convert the date type returned by your date chooser into one of those, e.g.", "label": {"api": {"PreparedStatement": [[21, 37]], "PreparedStatement#setDate()": [[21, 47]], "java.sql.Date": [[67, 79]]}}}, {"text": "It is square brackets that denote character classes, whereas curly braces are used for something else entirely (the repetition operator)", "label": {"api": {"character classes": [[34, 50]]}}}, {"text": "Try using JOptionPane.showMessageDialog(...) with a JList component argument whose elements are sourced from your list, for example", "label": {"api": {"JOptionPane.showMessageDialog(...)": [[10, 43]]}}}, {"text": "You can use a combination of ZipFile or ZipInputStream and java.io file operations to read the necessary data from the zip, create temp files and play those using MediaPlayer", "label": {"api": {"ZipFile": [[29, 35]], "ZipInputStream": [[40, 53]]}}}, {"text": "I didn't use ZipInputStream simply because there's a little more logic involved and I was going for brevity", "label": {"api": {"ZipInputStream": [[13, 26]]}}}, {"text": "You have to check every entry to see if it's what you're looking for with ZipInputStream, whereas ZipFile allows you to just ask for what you want by name", "label": {"api": {"ZipFile": [[98, 104]], "ZipInputStream": [[74, 87]]}}}, {"text": "PApplet extends java's Applet class and uses a Frame to add contents into", "label": {"api": {"Frame": [[47, 51]]}}}, {"text": "The wiring between the components can benefit from the brevity of the class EventHandler, http://docs.oracle.com/javase/6/docs/api/java/beans/EventHandler.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/beans/EventHandler.html": [[90, 158]]}}}, {"text": "One work-around is to use a CountdownLatch as done in the question Waiting for a cancelled future to actually finish", "label": {"api": {"CountdownLatch": [[28, 41]]}}}, {"text": "The quick and dirty way to get started is to use a thread pool, such as one returned by Executors.newCachedThreadPool()", "label": {"api": {"Executors.newCachedThreadPool()": [[88, 118]]}}}, {"text": "Then create tasks that implement Runnable and submit() them to your thread pool", "label": {"api": {"Runnable": [[33, 40]]}}}, {"text": "So while it's possible to catch them, it's strongly discouraged", "label": {"api": {"it's strongly discouraged": [[38, 62]]}}}, {"text": "To ensure the whole area of your viewport is covered, call setFillsViewportHeight(true) on your table", "label": {"api": {"setFillsViewportHeight(true)": [[59, 86]]}}}, {"text": "If you are using Java 7, you can use the WatchService API", "label": {"api": {"WatchService API": [[41, 56]]}}}, {"text": "\"In a multi-screen environment, the GraphicsConfiguration objects can be used to render components on multiple screens.\"—GraphicsDevice", "label": {"api": {"GraphicsConfiguration": [[36, 56]], "GraphicsDevice": [[121, 134]]}}}, {"text": "If you are using DOM for parsing, see the DocumentBuilderFactory.setExpandEntityReferences() method", "label": {"api": {"DocumentBuilderFactory.setExpandEntityReferences()": [[42, 91]]}}}, {"text": "I've used a Transformer in the past", "label": {"api": {"Transformer": [[12, 22]]}}}, {"text": "Use a StringReader", "label": {"api": {"StringReader": [[6, 17]]}}}, {"text": "Use the following method random.nextInt(upperBound)", "label": {"api": {"random.nextInt(upperBound)": [[25, 50]]}}}, {"text": "For example in LinkedList, http://docs.oracle.com/javase/1.5.0/docs/api/java/util/LinkedList.html, there is a Method Summary section and a section for inherited methods, like \"Methods inherited from interface java.util.List\"", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/LinkedList.html": [[27, 96]]}}}, {"text": "When I do a java.net.URLConnection.connect() it gives me java.net.UnknownHostException when the server is down", "label": {"api": {"java.net.URLConnection.connect()": [[12, 43]], "java.net.UnknownHostException": [[57, 85]]}}}, {"text": "However, I've found out that if my internet connection is down, the function also throws me a java.net.UnknownHostException", "label": {"api": {"java.net.UnknownHostException": [[94, 122]]}}}, {"text": "You could also use the SortedMap interface (TreeMap impl.) which orders inserted entries by the natural ordering of keys (or a provided Comparator)", "label": {"api": {"TreeMap": [[44, 50]]}}}, {"text": "Unless you use a http://docs.oracle.com/javase/6/docs/api/java/util/SortedMap.html, in which case you could get the first and last key.", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/SortedMap.html": [[17, 81]]}}}, {"text": "Then use the method AtomicLong#set(long) to reset the value", "label": {"api": {"AtomicLong#set(long)": [[20, 39]]}}}, {"text": "you have access to InvocationContext inside an interceptor which exposes all required attributes", "label": {"api": {"InvocationContext": [[19, 35]]}}}, {"text": "Consider using getMaximumWindowBounds()", "label": {"api": {"getMaximumWindowBounds()": [[15, 38]]}}}, {"text": "GridLayout draws the components to maximum size available", "label": {"api": {"GridLayout": [[0, 9]]}}}, {"text": "You may use Class.isInstance() method - This method is the dynamic equivalent of the Java language instanceof operator", "label": {"api": {"Class.isInstance()": [[12, 29]]}}}, {"text": "Given a Scope, is there a function that can generate a unique variable name such that a variable declaration for the unique name could be inserted in scope and the resulting source code/CompilationUnitTree would still compile", "label": {"api": {"Scope": [[8, 12]], "CompilationUnitTree": [[186, 204]]}}}, {"text": "So you could use ProcessBuilder to create OS process which goes something like \"tail -f  yourLogFile.txt\"", "label": {"api": {"ProcessBuilder": [[17, 30]], "Process": [[17, 23]]}}}, {"text": "And then read the OutputStream of the returned Process", "label": {"api": {"Process": [[47, 53]]}}}, {"text": "Nowadays, with java 8, you should use ZonedDateTime in your form dto", "label": {"api": {"ZonedDateTime": [[38, 50]]}}}, {"text": "\"2019-03-27T22:05:42.763Z\") to a ZonedDateTime", "label": {"api": {"ZonedDateTime": [[33, 45]]}}}, {"text": "However the method Date.toISOString always set the timezone to utc, so your deserialized ZonedDateTime zone will always be set to UTC", "label": {"api": {"ZonedDateTime": [[89, 101]]}}}, {"text": "You can call setLenient(false) to catch that kind of error sometimes", "label": {"api": {"setLenient(false)": [[13, 29]]}}}, {"text": "The documentation advises you to call clear() first, but you may instead prefer to call clear(Calendar.MILLISECOND) to keep time-zone information intact", "label": {"api": {"clear()": [[38, 44]]}}}, {"text": "In Java 7, you can use the letter X to represent an ISO 8601 time zone", "label": {"api": {"Java 7": [[3, 8]], "ISO 8601 time zone": [[52, 69]]}}}, {"text": "They may be prepended with IDs of the parent NamingContainer components", "label": {"api": {"NamingContainer": [[45, 59]]}}}, {"text": "For comparison, you can get the menu item's KeyStroke via getAccelerator() or from any KeyEvent via KeyStroke.getKeyStrokeForEvent()", "label": {"api": {"getAccelerator()": [[58, 73]], "KeyStroke.getKeyStrokeForEvent()": [[100, 131]]}}}, {"text": "In addition to @mKorbel's excellent advice, consider using a java.util.Queue for your snake segments", "label": {"api": {"java.util.Queue": [[61, 75]]}}}, {"text": "However, just looking at the PrintServiceLookup API docs, I wonder why you are using PrintServiceLookup.lookupDefaultPrintService()", "label": {"api": {"PrintServiceLookup API docs": [[29, 55]]}}}, {"text": "The DocFlavor documentation says you can specify a MIMEtype of \"application/postscript\" to direct the system to give you a PrintService which accepts PostScript language data", "label": {"api": {"DocFlavor documentation": [[4, 26]]}}}, {"text": "In fact, there appears to be a predefined DocFlavour.BYTE_ARRAY POSTSCRIPT class which might be a useful parameter for you", "label": {"api": {"DocFlavour.BYTE_ARRAY POSTSCRIPT": [[42, 73]]}}}, {"text": "Try setting the OutputKeys.INDENT property to the value \"yes\"", "label": {"api": {"OutputKeys.INDENT": [[16, 32]]}}}, {"text": "Looking at the docs for the Arrays class, you'll see there's an overload of toString() for every primitive array type", "label": {"api": {"Arrays": [[28, 33]]}}}, {"text": "Is there a reason you can't use Message.getJMSMessageID()", "label": {"api": {"Message.getJMSMessageID()": [[32, 56]]}}}, {"text": "If there is, AtomicLong.incrementAndGet() should be all it takes", "label": {"api": {"AtomicLong.incrementAndGet()": [[13, 40]]}}}, {"text": "Also, if you're doing calculations with currency, you should take a look at BigDecimal to avoid weird rounding errors later down the road", "label": {"api": {"BigDecimal": [[76, 85]]}}}, {"text": "myRow.get('ColumnName'); is already in ResultSet, see getObject(String columnLabel)", "label": {"api": {"getObject(String columnLabel)": [[54, 82]]}}}, {"text": "I think you want to be using a ServerSocket and not a regular socket", "label": {"api": {"ServerSocket": [[31, 42]]}}}, {"text": "You could use Java's Random class to generate random integers", "label": {"api": {"Random": [[21, 26]]}}}, {"text": "The request is here the HttpServletRequest which you can obtain in the JSF context from the ExternalContext#getRequest() or, actually better, inside a Filter by just downcasting the ServletRequest argument", "label": {"api": {"HttpServletRequest": [[24, 41]], "ExternalContext#getRequest()": [[92, 119]]}}}, {"text": "The TimeUnit class provides factory methods that simplifies most of your work", "label": {"api": {"TimeUnit": [[4, 11]]}}}, {"text": "Then you would sort the array of pairs using Arrays.sort(Object[])", "label": {"api": {"Arrays.sort(Object[])": [[45, 65]]}}}, {"text": "HashMap is a collection to store (key,value) pairs and According to the documentation of HashMap the keys are always unique", "label": {"api": {"HashMap": [[0, 6], [89, 95]]}}}, {"text": "I would consider using a SortedMap instead of a List here", "label": {"api": {"SortedMap": [[25, 33]]}}}, {"text": "The StandardCategoryToolTipGenerator sets the MessageFormat ArgumentIndex values to the series, category and value", "label": {"api": {"MessageFormat": [[46, 58]]}}}, {"text": "Make a custom FileSystemView, use it as the argument to one of the JFileChooser constructors that accepts an FSV.", "label": {"api": {"FileSystemView": [[14, 27]], "JFileChooser constructors": [[67, 91]]}}}, {"text": "Set a FileView and override the isTraversable method so that it returns true only for the directory you want the user to see", "label": {"api": {"FileView": [[6, 13]], "isTraversable": [[32, 44]]}}}, {"text": "Refer to Javadoc for the split method taking two arguments for details", "label": {"api": {"split": [[25, 29]]}}}, {"text": "When calling String.split(String), it calls String.split(String, 0) and that discards trailing empty strings (as the docs say it), when calling String.split(String, n) with n < 0 it won't discard anything", "label": {"api": {"split": [[20, 24], [51, 55], [151, 155]]}}}, {"text": "The Java ByteBuffer is big-endian by default; however, the C# BitConverter is architecture-dependant, and may be checked through its IsLittleEndian static property", "label": {"api": {"ByteBuffer": [[9, 18]]}}}, {"text": "You can implement a javax.servlet.Filter and configure it in the web.xml file (<filter> and <filter-mapping> tags)", "label": {"api": {"javax.servlet.Filter": [[20, 39]]}}}, {"text": "Here is an example using Box", "label": {"api": {"Box": [[25, 27]]}}}, {"text": "Just use String.replace to do literal replacements", "label": {"api": {"String.replace": [[9, 22]]}}}, {"text": "You need to create a Filter wherein you wrap the ServletResponse argument with a custom HttpServletResponseWrapper implementation wherein you override the getOutputStream() and getWriter() to return a custom ServletOutputStream implementation wherein you copy the written byte(s) in the base abstract OutputStream#write(int b) method", "label": {"api": {"HttpServletResponseWrapper": [[88, 113]], "ServletOutputStream": [[208, 226]], "OutputStream#write(int b)": [[301, 325]]}}}, {"text": "Then, you pass the wrapped custom HttpServletResponseWrapper to the FilterChain#doFilter() call instead and finally you should be able to get the copied response after the the call", "label": {"api": {"HttpServletResponseWrapper": [[34, 59]]}}}, {"text": "The custom HttpServletResponseWrapper", "label": {"api": {"HttpServletResponseWrapper": [[11, 36]]}}}, {"text": "The custom ServletOutputStream", "label": {"api": {"ServletOutputStream": [[11, 29]]}}}, {"text": "Just use ResultSet.getDate instead of getString - you should almost always avoid unnecessary transformations; they're a recipe for a disaster", "label": {"api": {"ResultSet.getDate": [[9, 25]]}}}, {"text": "SwingWorker#setProgress throws an IllegalArgumentException if the argument isn't from 0 to 100", "label": {"api": {"SwingWorker#setProgress": [[0, 22]]}}}, {"text": "All that tutorial is saying that you need a KeyStroke, some key Object, and an Action to create a key binding", "label": {"api": {"Action": [[79, 84]]}}}, {"text": "To create your KeyStroke, take a look at the static helper methods, they should explain how to get the correct KeyStroke you need", "label": {"api": {"helper methods": [[52, 65]]}}}, {"text": "The last thing you need is to create your Action", "label": {"api": {"Action": [[42, 47]]}}}, {"text": "I would suggest extending AbstractAction since it already implements many of the methods of Action for you", "label": {"api": {"AbstractAction": [[26, 39]], "Action": [[34, 39], [92, 97]]}}}, {"text": "Instead, I would recommend using a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[35, 48]]}}}, {"text": "In my opinion, the most significant benefit of a ProcessBuilder is that it can redirect the standard error of the process into the same stream as the standard output", "label": {"api": {"ProcessBuilder": [[49, 62]]}}}, {"text": "It should be possible to write a method that takes the command line to run as a String array parameter, runs the command line using a ProcessBuilder and returns whether a line 3 was  among the output from that command", "label": {"api": {"ProcessBuilder": [[134, 147]]}}}, {"text": "Why does HttpServletRequest.getRemoteAddr() return null sometimes", "label": {"api": {"HttpServletRequest.getRemoteAddr()": [[9, 42]]}}}, {"text": "I think you should also have a look at the NameSpaceContext", "label": {"api": {"NameSpaceContext": [[43, 58]]}}}, {"text": "I don't know how you load your document, but if you're using a XMLStreamReader then you can retrieve a NameSpaceContext from it that holds exactly the information you need", "label": {"api": {"NameSpaceContext": [[103, 118]]}}}, {"text": "Here you can see where you can retrieve the NameSpaceContext in other ways", "label": {"api": {"NameSpaceContext": [[44, 59]]}}}, {"text": "I would read up on Java Patterns and in particular capturing text in a group", "label": {"api": {"Patterns": [[24, 31]]}}}, {"text": "If you really want to go this way, then you should probably use a ConcurrentMap or ConcurrentList, and use a single-thread ScheduledExecutorService, which would wake iterate through the list and remove older sessions every X minutes", "label": {"api": {"single-thread ScheduledExecutorService": [[109, 146]]}}}, {"text": "In Java8 or higher version, this can be done with YearMonth", "label": {"api": {"YearMonth": [[50, 58]]}}}, {"text": "But how should I use AsynchronousServerSocketChannel", "label": {"api": {"AsynchronousServerSocketChannel": [[21, 51]]}}}, {"text": "Any suggestions on how to write a simple asynchronous server using AsynchronousServerSocketChannel", "label": {"api": {"AsynchronousServerSocketChannel": [[67, 97]]}}}, {"text": "You can tune how threads are handled, see the AsynchronousChannelGroup API docs for more information", "label": {"api": {"AsynchronousChannelGroup API docs": [[46, 78]]}}}, {"text": "Would still recommend you to have a look at the Timer class", "label": {"api": {"Timer": [[48, 52]]}}}, {"text": "You can create a Timer, which created a thread to close down your server", "label": {"api": {"Timer": [[17, 21]]}}}, {"text": "You can make your connection as a final variable and then use synchronised access to it to close it once Timer thread kicks in", "label": {"api": {"Timer": [[105, 109]]}}}, {"text": "You can use setSoTimeout for that", "label": {"api": {"setSoTimeout": [[12, 23]]}}}, {"text": "The exact procedure is laid out in the Javadoc of the URL constructor", "label": {"api": {"URL constructor": [[54, 68]]}}}, {"text": "Hi all I understand that if we read bytes from an InputStream and we have finished reading all the bytes (or we do not intend to read to the end of stream), we must call close() to release system resources associated with the stream", "label": {"api": {"InputStream": [[50, 60]], "close()": [[170, 176]], "read": [[31, 34], [83, 86], [129, 132]]}}}, {"text": "Now I was wondering if I read bytes and it throws a java.io.IOException, am I still required to call close() to release system resources associated with the stream", "label": {"api": {"close()": [[101, 107]], "read": [[25, 28]], "java.io.IOException": [[52, 70]]}}}, {"text": "Or is it true that on errors, streams are closed automatically so we do not have to call close()", "label": {"api": {"close()": [[89, 95]]}}}, {"text": "See the Pattern documentation for more details (and alternatives to \\p{Alpha})", "label": {"api": {"Pattern documentation": [[8, 28]]}}}, {"text": "You should use a higher-level concurrency mechanism, such as CountDownLatch", "label": {"api": {"CountDownLatch": [[61, 74]]}}}, {"text": "You would want to use a CountDownLatch with a value of 4", "label": {"api": {"CountDownLatch": [[24, 37]]}}}, {"text": "Let me guess, you're getting a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[31, 61]]}}}, {"text": "Using the Java Compiler Tree API, one can traverse the leaf tree of a TreePath and its children using a TreeVisitor", "label": {"api": {"TreeVisitor": [[104, 114]]}}}, {"text": "Is there a TreeVisitor implementation that visits all \"nodes\" in evaluation order", "label": {"api": {"TreeVisitor": [[11, 21]]}}}, {"text": "Is there a TreeVisitor that will visit the BinaryTree for 8 * 2 followed by the BinaryTree for 7 - (8 * 2), then the BinaryTree for (7 - (8 * 2)) + 10", "label": {"api": {"TreeVisitor": [[11, 21]], "BinaryTree": [[43, 52], [80, 89], [117, 126]]}}}, {"text": "Look at the JavaDoc for the multiline flag (m), the dot-all flag (s), and the comments flag (x)", "label": {"api": {"multiline flag (m)": [[28, 45]], "dot-all flag (s)": [[52, 67]], "comments flag (x)": [[78, 94]]}}}, {"text": "An easy way is to use Pattern class instead of just using the matches() method", "label": {"api": {"Pattern": [[22, 28]]}}}, {"text": "You might use a (single column) GridLayout or BoxLayout for this", "label": {"api": {"GridLayout": [[32, 41]], "BoxLayout": [[46, 54]]}}}, {"text": "java.text.ParseException seems the most appropriate", "label": {"api": {"java.text.ParseException": [[0, 23]]}}}, {"text": "Just use Collections.reverseOrder() to get a comparator that compares in the reverse order of the natural ordering", "label": {"api": {"Collections.reverseOrder()": [[9, 34]]}}}, {"text": "Take a look at java.net.URI which can be used as a replacement of evil java.net.URL", "label": {"api": {"java.net.URI": [[15, 26]]}}}, {"text": "Isn't java.net.URI what you're looking for", "label": {"api": {"java.net.URI": [[6, 17]]}}}, {"text": "The #{some condition} can at its simplest be a combination of FacesContext#isPostback() and FacesContext#isValidationFalied()", "label": {"api": {"FacesContext#isPostback()": [[62, 86]], "FacesContext#isValidationFalied()": [[92, 124]]}}}, {"text": "BigInteger is one way to do it", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "With little googling I found ThreadMXBean interface which seems to have what you need, as well as a usage example", "label": {"api": {"ThreadMXBean interface": [[29, 50]]}}}, {"text": "If you use a TreeMap as the underlying types, everything will automatically be numerically sorted", "label": {"api": {"TreeMap": [[13, 19]]}}}, {"text": "Then the easiest way is to use an explicit lock (ReentrantLock) and call its tryLock() method", "label": {"api": {"ReentrantLock": [[49, 61]]}}}, {"text": "Then I go over to look at the String JavaDoc, and it doesn't show a constructor with that type of signature.", "label": {"api": {"String JavaDoc": [[30, 43]]}}}, {"text": "According to some random version of the Java documentation, there is no public constructor for String that has the signature that you posted", "label": {"api": {"some random version of the Java documentation": [[13, 57]]}}}, {"text": "I would prefer to use Set over HashMap as HashMap need key-value & Sets talks about UNIQUENESS", "label": {"api": {"Set": [[22, 24], [67, 69]]}}}, {"text": "Sets don't allow duplicates..", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "InvocationTargetException is just a wrapper for an exception that's thrown within a dynamic invocation", "label": {"api": {"InvocationTargetException": [[0, 24]]}}}, {"text": "The true problem is the NullPointerException that it's wrapping", "label": {"api": {"NullPointerException": [[24, 43]]}}}, {"text": "If you are storing a large number of booleans, consider using a BitSet", "label": {"api": {"BitSet": [[64, 69]]}}}, {"text": "Simply use a JPopupMenu for the dropdown", "label": {"api": {"JPopupMenu": [[13, 22]]}}}, {"text": "JPopupMenu internally will handle painting at and beyond the edges", "label": {"api": {"JPopupMenu": [[0, 9]]}}}, {"text": "Each socket has a getInetAddress() method which returns the IP address of the client connected to it", "label": {"api": {"getInetAddress()": [[18, 33]]}}}, {"text": "If you're only dealing with non-negative integers, the toCharArray() method should be suitable for you", "label": {"api": {"toCharArray()": [[55, 67]]}}}, {"text": "The String class has a neat method for doing this, toCharArray()", "label": {"api": {"toCharArray()": [[51, 63]]}}}, {"text": "First of all, calling interrupt() may not actually set the interrupted status, please see here in javadocs the exact conditions, sometimes it will just throw an InterruptedException", "label": {"api": {"here in javadocs": [[90, 105]]}}}, {"text": "The JavaDocs to Field.get() state it would throw an IllegalArgumentException in this case", "label": {"api": {"Field.get()": [[16, 26]]}}}, {"text": "A little bit nicer even is the ProcessBuilder API", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "Even better than passing a lock object to the sender and receiver, and writing your own synchronization logic, use a concurrent queue, like SynchronousQueue", "label": {"api": {"SynchronousQueue": [[140, 155]]}}}, {"text": "Use the poll and add methods to move the elements from the head to the tail of the Queue", "label": {"api": {"poll": [[8, 11]], "add": [[17, 19]]}}}, {"text": "The MemoryMXBean can give you a fair amount of information about the current memory usage", "label": {"api": {"MemoryMXBean": [[4, 15]]}}}, {"text": "Use the Collections#shuffle method to shuffle your original list, and return a list with the first 15 elements", "label": {"api": {"Collections#shuffle": [[8, 26]]}}}, {"text": "You can use targetEntity property in the relationship annotation", "label": {"api": {"targetEntity": [[12, 23]]}}}, {"text": "you can't mix both approaches (except if you use the @AccessType annotation)", "label": {"api": {"@AccessType": [[53, 63]]}}}, {"text": "I am aware that if we close() an java.io.OutputStream, it may throw an IOException when there are hard disk errors", "label": {"api": {"close()": [[22, 28]], "java.io.OutputStream": [[33, 52]]}}}, {"text": "As for java.io.InputStream, Javamex states that", "label": {"api": {"java.io.InputStream": [[7, 25]]}}}, {"text": "Now I was wondering exactly under what circumstances will a java.io.InputStream (or sub class) for a local file (network access not needed) ever throw an exception when we call close()", "label": {"api": {"close()": [[177, 183]], "java.io.InputStream": [[60, 78]]}}}, {"text": "Internally double numbers are always stored the same way but you can of course use a formater like DecimalFormat to return 9 decimal points from your double number", "label": {"api": {"DecimalFormat": [[99, 111]]}}}, {"text": "As an aside, canDisplay(int) may help determine if a particular code point has a glyph in a given Font", "label": {"api": {"canDisplay(int)": [[13, 27]]}}}, {"text": "The easiest way to produce this kind of output is to use String.format() - its format string syntax supports padding as well as date and time formatting", "label": {"api": {"String.format()": [[57, 71]], "format string syntax": [[79, 98]]}}}, {"text": "If your code (.jar/.class) resides in RAM and not on a file system, you'll need to provide your own class loader", "label": {"api": {"class loader": [[100, 111]]}}}, {"text": "You should create first an instance of Random", "label": {"api": {"Random": [[39, 44]]}}}, {"text": "Talking about the data structure to store your generated random consider using java.util.Set for storing unique set of numbers", "label": {"api": {"java.util.Set": [[79, 91]]}}}, {"text": "TO check whether a number already exists in Set use Set#contains(Object o) method", "label": {"api": {"Set#contains(Object o)": [[52, 73]]}}}, {"text": "Use a TimerTask with a Timer", "label": {"api": {"TimerTask": [[6, 14]], "Timer": [[6, 10], [23, 27]]}}}, {"text": "The easiest way to check whether v is a NaN is by using Double.isNaN(v)", "label": {"api": {"Double.isNaN(v)": [[56, 70]]}}}, {"text": "Your current layout manager (GridLayout) is being created with 3 rows and a single column", "label": {"api": {"GridLayout": [[29, 38]]}}}, {"text": "Worse still, GridLayout will aportion space equally amongst all 3 components, meaning that your buttons will stretch in both directions, which is almost certainly not what you require", "label": {"api": {"GridLayout": [[13, 22]]}}}, {"text": "For simple layouts I tend to favour BorderLayout or FlowLayout", "label": {"api": {"BorderLayout": [[36, 47]], "FlowLayout": [[52, 61]]}}}, {"text": "For more complex layouts I lean towards GridBagLayout although there are others who prefer MigLayout", "label": {"api": {"GridBagLayout": [[40, 52]]}}}, {"text": "However, if you're in a JavaEE system, youc an use EJB TransactionAttribute", "label": {"api": {"TransactionAttribute": [[55, 74]]}}}, {"text": "Your problem is that null references should not be equals to anything, as the equals contract states", "label": {"api": {"equals contract": [[78, 92]]}}}, {"text": "This will in turn provide a meaningful equals for the list, as its contract states", "label": {"api": {"as its contract states": [[60, 81]]}}}, {"text": "You can use the utilities methods from SwingUtilties", "label": {"api": {"SwingUtilties": [[39, 51]]}}}, {"text": "I will probably get burned, but you can also use an ArrayBlockingQueue for this", "label": {"api": {"ArrayBlockingQueue": [[52, 69]]}}}, {"text": "I would use two semaphores", "label": {"api": {"semaphores": [[16, 25]]}}}, {"text": "Use Class.getResourceAsStream() or Class.getResource()", "label": {"api": {"Class.getResourceAsStream()": [[4, 30]], "Class.getResource()": [[35, 53]]}}}, {"text": "If you use the built-in Preferences class, the values will be automatically saved in the appropriate place on the user's system", "label": {"api": {"Preferences": [[24, 34]]}}}, {"text": "Adding to lwburk's solution, to convert a DOM Node to string form, you can use a Transformer", "label": {"api": {"Transformer": [[81, 91]]}}}, {"text": "Also consider using a JTable, which (of course) has inbuilt support for columns and rows", "label": {"api": {"JTable": [[22, 27]]}}}, {"text": "The AtomicBoolean acts as a test-and-set lock preventing multiple threads concurrently running the pressed event callback", "label": {"api": {"AtomicBoolean": [[4, 16]]}}}, {"text": "They are pretty flexible - for more of an idea of what you can do with them check out the API", "label": {"api": {"the API": [[86, 92]]}}}, {"text": "But now I look at your code more closely, it seems you need a 'yes/no' answer, which is better suited to a JOptionPane.showConfirmDialog(Component,Object)", "label": {"api": {"JOptionPane.showConfirmDialog(Component,Object)": [[107, 153]]}}}, {"text": "For more information on the syntax of format strings, see http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax": [[58, 129]]}}}, {"text": "If an object does not implement Comparable you can write an implementation of Comparator to achieve the same effect", "label": {"api": {"Comparator": [[78, 87]]}}}, {"text": "Comparator is, in fact, the example given in the wikipedia arctile about functors in Java", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "If the an object is not Comparable it can still be sorted by Collections.sort(Collection, Comparator) by providing a relevant Comparator implementation", "label": {"api": {"Comparator": [[90, 99], [126, 135]]}}}, {"text": "The interface Comparator is an example of a functor", "label": {"api": {"Comparator": [[14, 23]]}}}, {"text": "The getResource() method uses the same loading rules as defined by the ClassLoader for the class", "label": {"api": {"ClassLoader": [[71, 81]]}}}, {"text": "You can even use a http://docs.oracle.com/javase/6/docs/api/java/awt/SystemColor.html (for theming), like SystemColor.info", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/awt/SystemColor.html": [[19, 84]]}}}, {"text": "For a trusted applet, access the Clipboard in the same way as you might with an application", "label": {"api": {"Clipboard": [[33, 41]]}}}, {"text": "For a sand-boxed applet deployed in a Plug-In 2 JRE1, it is possible to deploy the applet using Java Web Start and use the services of the JNLP API's ClipboardService to enable paste functionality", "label": {"api": {"Clipboard": [[150, 158]], "ClipboardService": [[150, 165]]}}}, {"text": "of the ClipboardService", "label": {"api": {"Clipboard": [[7, 15]], "ClipboardService": [[7, 22]]}}}, {"text": "If you're not interested in reading the response at all you can just use URL.openStream() to create a connection and then immediately close the socket (or ignore it and let it time out, if you feel like being mean to the server)", "label": {"api": {"URL.openStream()": [[73, 88]]}}}, {"text": "You can do a similar thing in Java by using the Robot.createScreenCapture method to capture the screen and display this image in a full-screen window (see Frame.setUndecorated)", "label": {"api": {"Robot.createScreenCapture": [[48, 72]], "Frame.setUndecorated": [[155, 174]]}}}, {"text": "The 1.4 version had only a constructor from double but the 1.5 version had both, the int and the double constructors", "label": {"api": {"1.4 version": [[4, 14]], "1.5 version": [[59, 69]]}}}, {"text": "Possibility to affect this came with EJB 3.1 TimerConfig", "label": {"api": {"TimerConfig": [[45, 55]]}}}, {"text": "java.awt.Desktop has been introduced in Java 6", "label": {"api": {"in Java 6": [[37, 45]]}}}, {"text": "Also, if you're new to Java, the API docs (or Javadoc) are your best friend", "label": {"api": {"API docs": [[33, 40]]}}}, {"text": "For more details refer to java.nio.file.StandardOpenOption", "label": {"api": {"java.nio.file.StandardOpenOption": [[26, 57]]}}}, {"text": "Add a call to rewind() right after the loop", "label": {"api": {"rewind()": [[14, 21]]}}}, {"text": "Collections.addAll is what you want", "label": {"api": {"Collections.addAll": [[0, 17]]}}}, {"text": "Another option is to pass the list into the constructor using Arrays.asList like this", "label": {"api": {"Arrays.asList": [[62, 74]]}}}, {"text": "If, however, you are good with the arrayList being fixed-length, you can go with the creation as simple as list = Arrays.asList(...)", "label": {"api": {"Arrays.asList": [[114, 126]]}}}, {"text": "Arrays.asList specification states that it returns a fixed-length list which acts as a bridge to the passed array, which could be not what you need", "label": {"api": {"Arrays.asList": [[0, 12]], "Arrays.asList specification": [[0, 26]]}}}, {"text": "@OneToOne is what you're looking for", "label": {"api": {"@OneToOne": [[0, 8]]}}}, {"text": "Use a SimpleDateFormat (or joda-time DateTimeFormatter)", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "You may not need an interceptor for getting hold of this header, if you are using JAX-WS(recommended with CXF), you can get to this using @WebParam annotation with header attribute set to true", "label": {"api": {"@WebParam": [[138, 146]]}}}, {"text": "Try a Array of LinkedLists", "label": {"api": {"LinkedList": [[15, 24]]}}}, {"text": "You can retrieve the length of the file with File#length(), which will return a value in bytes, so you need to divide this by 1024*1024 to get its value in mb", "label": {"api": {"File#length()": [[45, 57]]}}}, {"text": "Since Java 7 you can use java.nio.file.Files.size(Path p)", "label": {"api": {"java.nio.file.Files.size(Path p)": [[25, 56]]}}}, {"text": "As of Java 8, you can convert the Collection into a Stream and use anyMatch as in the following example", "label": {"api": {"anyMatch": [[67, 74]]}}}, {"text": "You can use String#matches method like this", "label": {"api": {"String#matches": [[12, 25]]}}}, {"text": "Refer to Arrays.binarySearch for more information", "label": {"api": {"Arrays.binarySearch": [[9, 27]]}}}, {"text": "If you need to do anything more complicated than this, I would recommend looking at the Pattern and Matcher classes and learning how to do some regular expressions", "label": {"api": {"Pattern": [[88, 94]], "Matcher": [[100, 106]]}}}, {"text": "If you use Java 8 or above, you can rely on the Stream API to do such thing", "label": {"api": {"Stream API": [[48, 57]]}}}, {"text": "Assuming that you have a big array of big String to test you could also launch the search in parallel by calling parallel(), the code would then be", "label": {"api": {"parallel()": [[113, 122]]}}}, {"text": "ConcurrentLinkedQueue claims to be", "label": {"api": {"ConcurrentLinkedQueue": [[0, 20]]}}}, {"text": "Paul is right about ConcurrentLinkedQueue and the \"wait-free\" means that thread concurrency control is not done using locks, but still, you will always pay some price for contention", "label": {"api": {"ConcurrentLinkedQueue": [[20, 40]]}}}, {"text": "You may also want to look at ConcurrentHashMap because I'm not sure a list is what you're looking for", "label": {"api": {"ConcurrentHashMap": [[29, 45]]}}}, {"text": "If you want to be more adventurous, you might find some non-locking synchronization primitives in java.util.concurrent.atomic", "label": {"api": {"java.util.concurrent.atomic": [[98, 124]]}}}, {"text": "You could also use the UUID class", "label": {"api": {"UUID": [[23, 26]]}}}, {"text": "As @user47900 pointed out, you can obviously use the SuppressWarnings annotation to get around a single warning but they usually need to be defined per class and cannot cover all inner classes nor packages", "label": {"api": {"SuppressWarnings": [[53, 68]]}}}, {"text": "I'd use a StringBuilder for this", "label": {"api": {"StringBuilder": [[10, 22]]}}}, {"text": "The ProcessBuilder class in the Java standard library supports creating processes and reading their output", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "Have you considered Java's built-in Process class", "label": {"api": {"Process": [[36, 42]]}}}, {"text": "One potential problem is that your implementation of Comparable is not consistent with equals(), as the latter relies (implicitly) on the super-class implementation", "label": {"api": {"Comparable": [[53, 62]]}}}, {"text": "You might be interested in using a Scanner with a custom delimiter (set using useDelimiter)", "label": {"api": {"Scanner": [[35, 41]], "useDelimiter": [[78, 89]]}}}, {"text": "using the JDialog(Frame,String,boolean) constructor", "label": {"api": {"JDialog(Frame,String,boolean)": [[10, 38]]}}}, {"text": "Wait need not be on Runnable", "label": {"api": {"Runnable": [[20, 27]]}}}, {"text": "That is why notify() is on Object  and not on Runnable", "label": {"api": {"Object": [[27, 32]], "Runnable": [[46, 53]]}}}, {"text": "In other words, what you were missing were the Class.isInstance and Class.cast methods", "label": {"api": {"Class.isInstance": [[47, 62]], "Class.cast": [[68, 77]]}}}, {"text": "Use DataInputStream to read the type of data you want if it fits the conversions (i.e", "label": {"api": {"DataInputStream": [[4, 18]]}}}, {"text": "when reading an int check the endianess used by DataNIputStream matches your platform), wrapped around a ByteArrayInputStream directly fed by your byte array", "label": {"api": {"ByteArrayInputStream": [[105, 124]]}}}, {"text": "See the documentation for SimpleDateFormat to get your patterns right", "label": {"api": {"documentation for SimpleDateFormat": [[8, 41]]}}}, {"text": "The answer could be simply to put the key data as bytes into a SecretKeySpec like this", "label": {"api": {"SecretKeySpec": [[63, 75]]}}}, {"text": "Note that SecretKeySpec implements the Key interface, so you can use it directly in a Cipher.init() method", "label": {"api": {"SecretKeySpec": [[10, 22]]}}}, {"text": "JComponent for complete custom rendering, JPanel for custom rendering combined with components", "label": {"api": {"JComponent": [[0, 9]], "JPanel": [[42, 47]]}}}, {"text": "It sounds like the JComponent would be better suited to this use-case", "label": {"api": {"JComponent": [[19, 28]]}}}, {"text": "You could try using the HttpURLConnection's getContentLength() method", "label": {"api": {"getContentLength()": [[44, 61]]}}}, {"text": "You can do it with String[] split(String regex)", "label": {"api": {"String[] split(String regex)": [[19, 46]]}}}, {"text": "Take a look at java.io.File and try searching for topics about working with files in Java for information about how to go about accessing a directory and obtaining a list of the files it contains", "label": {"api": {"java.io.File": [[15, 26]]}}}, {"text": "Try using String#relaceAll(regex,replacement); untested, but this should work", "label": {"api": {"String#relaceAll(regex,replacement)": [[10, 44]]}}}, {"text": "What can you do with an OutputStream", "label": {"api": {"OutputStream": [[24, 35]]}}}, {"text": "Perhaps on the other hand, you're not directly calling write on the OutputStream yourself, but passing this stream into the flatworm library (which will in turn write output to it)", "label": {"api": {"OutputStream": [[68, 79]]}}}, {"text": "That might be a ByteArrayOutputStream, which (after the flatworm method has returned) you can inspect to get the bytes written", "label": {"api": {"OutputStream": [[25, 36]]}}}, {"text": "So far I've tried using jythonc, unfortunately to no success, and now im trying to use the java Runtime and java Process to execute the python script", "label": {"api": {"Runtime": [[96, 102]], "Process": [[113, 119]]}}}, {"text": "The following example (from the javadocs) demonstrates how to create a scrollable ResultSet", "label": {"api": {"the javadocs": [[28, 39]]}}}, {"text": "This can be done with a standard SortedMap", "label": {"api": {"SortedMap": [[33, 41]]}}}, {"text": "The put method in HashMap returns the previous value associated with the key, it doesn't return the HashMap itself", "label": {"api": {"put": [[4, 6]]}}}, {"text": "That aside, List.contains uses equals for comparisons, and AbstractMap.equals, inherited by HashMap,  tests for the two maps having the same mappings, not being the same instance", "label": {"api": {"List.contains": [[12, 24]], "AbstractMap.equals": [[59, 76]]}}}, {"text": "The documentation for Map (an interface that TreeMap implements) tells you this", "label": {"api": {"documentation for Map": [[4, 24]]}}}, {"text": "You can however use SocketChannel.open() from java.nio to open the socket, FileChannel.open() to open the file and then FileChannel.transferTo() method to transfer all file's data to the socket", "label": {"api": {"SocketChannel.open()": [[20, 39]], "java.nio": [[46, 53]], "FileChannel.open()": [[75, 92]], "FileChannel.transferTo()": [[120, 143]]}}}, {"text": "Here we use a List of List objects as suggested there", "label": {"api": {"List": [[14, 17], [22, 25]]}}}, {"text": "So to convert it to a Java date, parse the string as a long and use the Date(long) constructor", "label": {"api": {"parse the string as a long": [[33, 58]], "Date(long) constructor": [[72, 93]]}}}, {"text": "Then you can use a DateFormat implementation like SimpleDateFormat or similar to format it; you might also use a Calendar object for handling timezones and such", "label": {"api": {"SimpleDateFormat": [[50, 65]], "Calendar": [[113, 120]]}}}, {"text": "SwingWorker would be more reliable", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "As @mre notes, SwingWorker also makes it easy to report interim results, as shown here", "label": {"api": {"SwingWorker": [[15, 25]]}}}, {"text": "You can use isDirectory and isFile", "label": {"api": {"isDirectory": [[12, 22]], "isFile": [[28, 33]]}}}, {"text": "Some people recommend java.util.Scanner while others recommend java.io.BufferedReader, and I'm sure there's plenty of other recommendations", "label": {"api": {"java.util.Scanner": [[22, 38]], "java.io.BufferedReader": [[63, 84]]}}}, {"text": "Use Date class instead", "label": {"api": {"Date": [[4, 7]]}}}, {"text": "It has methods like after(), which is way better than your compare implementations", "label": {"api": {"after()": [[20, 26]]}}}, {"text": "It sounds like the Java class that will suit you best is a FileWriter", "label": {"api": {"FileWriter": [[59, 68]]}}}, {"text": "However, if you are writing a file with Key=Value lines, then the Properties class might end up being the better choice", "label": {"api": {"Properties": [[66, 75]]}}}, {"text": "I think a Set is probably the best way to go..", "label": {"api": {"Set": [[10, 12]]}}}, {"text": "I would use a Set<T> - probably a HashSet<T>", "label": {"api": {"Set<T>": [[14, 19], [38, 43]]}}}, {"text": "To preserve order, use LinkedHashSet<T>", "label": {"api": {"Set<T>": [[33, 38]]}}}, {"text": "Also, reference SimpleDateFormat documentation for the list of acceptable parse expressions", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "See description of class Formatter", "label": {"api": {"Formatter": [[25, 33]]}}}, {"text": "There are two Graphics.drawString() methods", "label": {"api": {"Graphics.drawString()": [[14, 34]]}}}, {"text": "One accepts a String as a first argument and the other accepts an AttributedCharacterIterator", "label": {"api": {"AttributedCharacterIterator": [[66, 92]]}}}, {"text": "Have a look at Java swing tutorial and ListView API reference - Its an implementation of <html> list - <ol><li>", "label": {"api": {"ListView": [[39, 46]]}}}, {"text": "Once selected, you can browse() the URI", "label": {"api": {"browse()": [[23, 30]]}}}, {"text": "You can use JEditorPane for your editor component and addHyperlinkListener() to listen for events related to the link", "label": {"api": {"JEditorPane": [[12, 22]], "addHyperlinkListener()": [[54, 75]]}}}, {"text": "You can however, use the new Thread(Runnable runnable) constructor, something like this", "label": {"api": {"new Thread(Runnable runnable)": [[25, 53]]}}}, {"text": "You might have to just loop through and collect all the \"types\" strings with a StringBuilder and put them in a single TableRow", "label": {"api": {"StringBuilder": [[79, 91]]}}}, {"text": "Use @Deprecated on method", "label": {"api": {"@Deprecated": [[4, 14]]}}}, {"text": "To add to the classpath, create your own URLClassLoader and use that to find the class you want to load, then call its start method reflectively", "label": {"api": {"URLClassLoader": [[41, 54]], "find": [[72, 75]]}}}, {"text": "Use BuffereReader.readLine() to read the file line by line  (note that using the BufferedReader is actually more complicated because you cannot jump back)", "label": {"api": {"BuffereReader.readLine()": [[4, 27]]}}}, {"text": "Or for more flexibility RandomAccessFile", "label": {"api": {"RandomAccessFile": [[24, 39]]}}}, {"text": "You can use BufferedReader to read a file line by line, Pattern to check the line against a regular expression, and Queue to store previous lines", "label": {"api": {"BufferedReader": [[12, 25]], "Pattern": [[56, 62]], "Queue": [[116, 120]]}}}, {"text": "You can get the Document of the text pane to make tightly controlled changes such as these", "label": {"api": {"get": [[8, 10]], "Document": [[16, 23]]}}}, {"text": "The Document also has some useful events of its own that you can listen for", "label": {"api": {"Document": [[4, 11]]}}}, {"text": "Assuming you are using Swing and a JFrame, call setResizable(false)", "label": {"api": {"setResizable(false)": [[48, 66]]}}}, {"text": "By default, equals() compares the references", "label": {"api": {"compares the references": [[21, 43]]}}}, {"text": "In any case, you can always test this, very easily - with isDaemon()", "label": {"api": {"isDaemon()": [[58, 67]]}}}, {"text": "You can use the setGroupingUsed() method, but that won't make the format reject the number, it will just stop parsing at the first separator", "label": {"api": {"setGroupingUsed()": [[16, 32]]}}}, {"text": "Turn off grouping by calling setGroupingUsed", "label": {"api": {"setGroupingUsed": [[29, 43]]}}}, {"text": "You can use the @Table-annotation to set the table name for the entity in JPA", "label": {"api": {"@Table": [[16, 21]]}}}, {"text": "You can (and should) use the Preferences API for that", "label": {"api": {"Preferences API": [[29, 43]]}}}, {"text": "Considering that shutdown() is likely to do a lot of cleanup and garbage collection, it's not exactly clear why restarting would be better than accquiring a new Executor, perhaps you should look into the tutorials about extending ThreadPoolExecutor with a pause / resume set of methods instead of adding the ability to un-shutdown", "label": {"api": {"about extending ThreadPoolExecutor with a pause / resume set of methods": [[214, 284]]}}}, {"text": "Declare your ExecutorService as a member to your class and reuse it as you want", "label": {"api": {"ExecutorService": [[13, 27]]}}}, {"text": "Instead of using the DefaultTableModel implied by your JTable constructor, create your own implementation of AbstractTableModel, as shown in How to Use Tables", "label": {"api": {"DefaultTableModel": [[21, 37]], "AbstractTableModel": [[109, 126]]}}}, {"text": "Do the job in the contextInitialized() method of a custom ServletContextListener class", "label": {"api": {"ServletContextListener": [[58, 79]]}}}, {"text": "You need to add a MouseMotionListener to your component", "label": {"api": {"MouseMotionListener": [[18, 36]]}}}, {"text": "The mouseDragged method will be called when the user moves the mouse whilst holding a mouse button down", "label": {"api": {"mouseDragged": [[4, 15]]}}}, {"text": "In your case, since Integer.hashCode() is equal to the actual number, you can just plug your mappings into a TreeMap, and they will be sorted accordingly", "label": {"api": {"Integer.hashCode()": [[20, 37]]}}}, {"text": "In your case may be a custom ClassLoader implementation, especially the findLibrary(..) and loadLibrary(..) methods", "label": {"api": {"ClassLoader": [[29, 39]]}}}, {"text": "Since you care mostly about re-usability of your solution, you would get the biggest \"bang for the buck\" if you implement your own Comparator", "label": {"api": {"Comparator": [[131, 140]]}}}, {"text": "Take a look at ArrayList and Collection.sort() method", "label": {"api": {"ArrayList": [[15, 23]], "Collection.sort()": [[29, 45]]}}}, {"text": "The nearest way to launch something would be via http://docs.oracle.com/javase/6/docs/api/java/awt/Desktop.html but that either does an open(File f) or browse(URI)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/awt/Desktop.html": [[49, 110]]}}}, {"text": "You can however use CDI annotations (@Named, @Inject and likes) in JSF 1.2", "label": {"api": {"@Named": [[37, 42]], "@Inject": [[45, 51]]}}}, {"text": "CDI will cover the most what JSF 2.0 offers as managed bean annotations, including the three main scopes @RequestScoped, @SessionScoped and @ApplicationScoped", "label": {"api": {"@RequestScoped": [[105, 118]], "@SessionScoped": [[121, 134]], "@ApplicationScoped": [[140, 157]]}}}, {"text": "CDI does only not offer a fullworthy equivalent of the JSF 2.0 @ViewScoped annotation", "label": {"api": {"@ViewScoped": [[63, 73]]}}}, {"text": "Closest what it offers is the @ConversationScoped, but you'd need to manually start and end the injected Conversation", "label": {"api": {"@ConversationScoped": [[30, 48]], "Conversation": [[31, 42], [105, 116]]}}}, {"text": "I recommend you use a HashSet<Character> instead", "label": {"api": {"HashSet<Character>": [[22, 39]]}}}, {"text": "You can just add and call contains in a straightforward and efficient way", "label": {"api": {"add": [[13, 15]], "contains": [[26, 33]]}}}, {"text": "You could use a BitSet to store whether or not a character has been guessed", "label": {"api": {"BitSet": [[16, 21]]}}}, {"text": "The solution is almost the same in either case, you use the newInstance method on the Class object", "label": {"api": {"newInstance": [[60, 70]]}}}, {"text": "If you need constructor args you can use the Class getConstructor method and from there the Constructor newInstance(...) method", "label": {"api": {"newInstance": [[104, 114]], "getConstructor": [[51, 64]], "newInstance(...)": [[104, 119]]}}}, {"text": "For exponents, use the Math.exp() or Math.pow() method", "label": {"api": {"Math.exp()": [[23, 32]], "Math.pow()": [[37, 46]]}}}, {"text": "Have you looked at SwingWorker", "label": {"api": {"SwingWorker": [[19, 29]]}}}, {"text": "Be careful when adding long periods of time, 1 day is not always 24 hours (daylight savings-type adjustments, leap seconds and so on), Calendar is recommended for that", "label": {"api": {"Calendar": [[135, 142]]}}}, {"text": "The reason is that split's parameter is a regular expression, so \"^\" means the beginning of a line", "label": {"api": {"regular expression": [[42, 59]]}}}, {"text": "All GUI changes need to be made through the use of the SwingUtilities.invokeLater method", "label": {"api": {"SwingUtilities.invokeLater": [[55, 80]]}}}, {"text": "Use a JSpinner with a SpinnerNumberModel instead", "label": {"api": {"JSpinner": [[6, 13]], "SpinnerNumberModel": [[22, 39]]}}}, {"text": "Take a look at HashSet", "label": {"api": {"HashSet": [[15, 21]]}}}, {"text": "Note that in order for objects to work with HashSet, they need to provide correct implementations of hashCode and equals methods of the java.lang.Object class", "label": {"api": {"HashSet": [[44, 50]]}}}, {"text": "If you want to retrieve elements sorted by key use the TreeMap instead", "label": {"api": {"TreeMap": [[55, 61]]}}}, {"text": "Here I've used the Date class which is much better for storing dates than plain Strings", "label": {"api": {"Date": [[19, 22]]}}}, {"text": "You might find it easier if you store your deck of cards in an ArrayDeque", "label": {"api": {"ArrayDeque": [[63, 72]]}}}, {"text": "You could use remove(int index)", "label": {"api": {"remove(int index)": [[14, 30]]}}}, {"text": "This uses java.security.Principal.getName() which returns String", "label": {"api": {"java.security.Principal.getName()": [[10, 42]]}}}, {"text": "This solution makes use of Java's Formatter class, which is a big help for all your string formatting needs", "label": {"api": {"Formatter": [[34, 42]]}}}, {"text": "You will need to first split the string (using String.split) and then format it", "label": {"api": {"String.split": [[47, 58]]}}}, {"text": "One way to do it is to define a FilterOutputStream that you wrap the file stream in, which keeps an internal counter that it increments on every write, and after reaching a set threshold, starts throwing Exceptions or simply ignores the writes", "label": {"api": {"FilterOutputStream": [[32, 49]]}}}, {"text": "Java has a special class of Exceptions called RuntimeExceptions", "label": {"api": {"RuntimeExceptions": [[46, 62]]}}}, {"text": "A NullPointerException is a RuntimeException, and consequently, does not need to be explicitly declared in the method signature", "label": {"api": {"NullPointerException": [[2, 21]]}}}, {"text": "using the OutputStreamWriter(OutputStream,encoding) constructor", "label": {"api": {"OutputStreamWriter(OutputStream,encoding)": [[10, 50]]}}}, {"text": "If you have a Line2D for your line segment, and a Point2D for the center of the circle, then just check if line.ptSegDist(center) <= radius", "label": {"api": {"Line2D": [[14, 19]], "Point2D": [[50, 56]]}}}, {"text": "See Documentation here", "label": {"api": {"See Documentation here": [[0, 21]]}}}, {"text": "this is an ArrayList", "label": {"api": {"ArrayList": [[11, 19]]}}}, {"text": "Use getResourceAsStream(String) (docs) if you want to read in a resource on the classpath", "label": {"api": {"getResourceAsStream(String) (docs)": [[4, 37]]}}}, {"text": "The replaceAll method returns a new String object, leaving the original object unmodified", "label": {"api": {"replaceAll": [[4, 13]]}}}, {"text": "Another, more dynamic, possibility would be to use the java.lang.reflect.Proxy class of the jdk", "label": {"api": {"java.lang.reflect.Proxy": [[55, 77]]}}}, {"text": "As Voo points out in a comment, however, code can often be written in terms of putIfAbsent (which is designed to represent a larger atomic operation)", "label": {"api": {"putIfAbsent": [[79, 89]]}}}, {"text": "Pay close attention to the contract from the javadoc", "label": {"api": {"contract from the javadoc": [[27, 51]]}}}, {"text": "I suspect what you want is ByteArrayOutputStream which allows you to write to a stream in memory instead of writing to disk", "label": {"api": {"ByteArrayOutputStream": [[27, 47]]}}}, {"text": "RowFilter.orFilter() and RowFilter.andFilter() seem apropos; each includes examples, and each accepts an arbitrary number of arguments", "label": {"api": {"RowFilter.orFilter()": [[0, 19]], "RowFilter.andFilter()": [[25, 45]]}}}, {"text": "One possibility is to call Thread.currentThread() at the start of main(), and hold on to the reference", "label": {"api": {"Thread.currentThread()": [[27, 48]]}}}, {"text": "It seems that the main thread has an id of 1 as indicated by Thread.getId()", "label": {"api": {"Thread.getId()": [[61, 74]]}}}, {"text": "Try to flush the file after each iteration", "label": {"api": {"flush": [[7, 11]]}}}, {"text": "The two methods can very easily be implemented in terms of Arrays.deepHashCode() and Arrays.deepEquals()", "label": {"api": {"Arrays.deepHashCode()": [[59, 79]], "Arrays.deepEquals()": [[85, 103]]}}}, {"text": "Plus it's pretty simple, using the Proxy class", "label": {"api": {"Proxy": [[35, 39]]}}}, {"text": "Your best bet is probably the ServiceLoader mechanism", "label": {"api": {"ServiceLoader": [[30, 42]]}}}, {"text": "You make your implementation of the interfaces available to ServiceLoader by listing them in a special file in the META-INF directory in your jar file; see the javadoc for details", "label": {"api": {"ServiceLoader": [[60, 72]]}}}, {"text": "If ConcurrentLinkedQueue.remove(item) returns false, this means that item didn't compare equal to any of the queue's entries", "label": {"api": {"ConcurrentLinkedQueue.remove(item)": [[3, 36]]}}}, {"text": "ConcurrentLinkedQueue.remove(item) would only remove one of them", "label": {"api": {"ConcurrentLinkedQueue.remove(item)": [[0, 33]]}}}, {"text": "You could use the Class.isInstance method", "label": {"api": {"Class.isInstance": [[18, 33]]}}}, {"text": "You can use java.lang.reflect.Array#getLength", "label": {"api": {"java.lang.reflect.Array#getLength": [[12, 44]]}}}, {"text": "You may need to call Number#doubleValue() on the Number instance", "label": {"api": {"Number#doubleValue()": [[21, 40]]}}}, {"text": "or, if there's no interface available, which looks to be the the Graphics class, extend it and be sure to override every method", "label": {"api": {"Graphics": [[65, 72]]}}}, {"text": "With an ArrayList, you could get the index of the first occurence of -1 and use the set method to add your new value at that index", "label": {"api": {"set": [[84, 86]]}}}, {"text": "I think you have to write your own custom json de/serializer for the Class class", "label": {"api": {"Class class": [[69, 79]]}}}, {"text": "If you need to report results while this action is taking place, either use the SwingWorker class, or update the component using the SwingUtilities class, in particular, invokeLater", "label": {"api": {"SwingWorker": [[80, 90]], "SwingUtilities": [[133, 146]], "invokeLater": [[170, 180]]}}}, {"text": "Another option is to use a ReentrantReadWriteLock to control both reading and writing", "label": {"api": {"ReentrantReadWriteLock": [[27, 48]]}}}, {"text": "Another way is to write a listener (such as a ChangeListener) that sends out an event whenever b.getTheUserInput() has new output, then have the label add the listener and change its text when an event is received", "label": {"api": {"ChangeListener": [[46, 59]]}}}, {"text": "ActionEvent.getActionCommand()/getSource() with if/else statements to select the correct action", "label": {"api": {"ActionEvent.getActionCommand()": [[0, 29]], "getSource()": [[31, 41]]}}}, {"text": "As per the setCursor documentation \"This cursor image is displayed when the contains method for this component returns true for the current cursor location, and this Component is visible, displayable, and enabled", "label": {"api": {"setCursor documentation": [[11, 33]]}}}, {"text": "You can use java.awt.Toolkit.getScreenResolution() to get the pixel density and then scale your spacing accordingly", "label": {"api": {"java.awt.Toolkit.getScreenResolution()": [[12, 49]]}}}, {"text": "You also might find java.awt.GraphicsConfiguration.getNormalizingTransform() useful; it allows you to work in a coordinate system where 72 units is 1 physical inch", "label": {"api": {"java.awt.GraphicsConfiguration.getNormalizingTransform()": [[20, 75]]}}}, {"text": "How can I schedule multiple tasks using java.util.Timer", "label": {"api": {"java.util.Timer": [[40, 54]]}}}, {"text": "You can implement your own javax.servlet.ServletContextListener to be notified when your application is being shutdown and shutdown the pool from the listener", "label": {"api": {"javax.servlet.ServletContextListener": [[27, 62]]}}}, {"text": "You could use a thread pool and execute the tasks concurrently which might speed things up quite a bit, but something like this is never going to run in a second or two", "label": {"api": {"thread pool": [[16, 26]]}}}, {"text": "You can use Statement or PreparedStatement to fetch data from database and then you can get that data stored in ResultSet", "label": {"api": {"Statement": [[12, 20], [33, 41]], "ResultSet": [[112, 120]]}}}, {"text": "Now you can iterate through the results in ResultSet", "label": {"api": {"ResultSet": [[43, 51]]}}}, {"text": "setChooserPanels method of JColorChooser to do this", "label": {"api": {"setChooserPanels": [[0, 15]]}}}, {"text": "See File.listFiles() to get the files in a directory", "label": {"api": {"File.listFiles()": [[4, 19]]}}}, {"text": "If I look into the Java API docs http://docs.oracle.com/javase/6/docs/api/ I find the javax.sql.DataSource interface with a getConnection() method", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/": [[33, 73]]}}}, {"text": "You can use java.text.NumberFormat for parsing", "label": {"api": {"java.text.NumberFormat": [[12, 33]]}}}, {"text": "Since you mentioned in your question using jdk1.7 , you should really look into the interface BasicFileAttributes on method lastAccessTime()", "label": {"api": {"lastAccessTime()": [[124, 139]]}}}, {"text": "Note, that the equals method has a pretty strong contract associated with it, which you are to fulfill", "label": {"api": {"pretty strong contract": [[35, 56]]}}}, {"text": "You can use the JLabel.setIcon() to place an image on the JPanel as shown here", "label": {"api": {"JLabel.setIcon()": [[16, 31]]}}}, {"text": "...and then read about StringBuilder", "label": {"api": {"StringBuilder": [[23, 35]]}}}, {"text": "What you can do is use a StringBuilder like so", "label": {"api": {"StringBuilder": [[25, 37]]}}}, {"text": "As shown in How to Use Scroll Panes, you can use the component's scrollRectToVisible() method to scroll to an arbitrary Rectangle", "label": {"api": {"scrollRectToVisible()": [[65, 85]]}}}, {"text": "In Java, you can use the blocking methods on a BlockingQueue to pass tasks from the producers (that create the jobs) to the consumer (the single worker thread)", "label": {"api": {"BlockingQueue": [[47, 59]]}}}, {"text": "Run, do not walk to your friendly Javadocs and look up ExecutorService, especially Executors.newSingleThreadExecutor()", "label": {"api": {"ExecutorService": [[55, 69]], "Executors.newSingleThreadExecutor()": [[83, 117]]}}}, {"text": "Are you looking for java.util.concurrent.Executor", "label": {"api": {"java.util.concurrent.Executor": [[20, 48]]}}}, {"text": "So, in your Android app, first encode the String into UTF-8 bytes using getBytes(\"UTF-8\")", "label": {"api": {"getBytes(\"UTF-8\")": [[72, 88]]}}}, {"text": "Is this method what you're looking for", "label": {"api": {"this method": [[3, 13]]}}}, {"text": "If you need to modify a sequence of characters, use StringBuilder, which supports setCharAt(int, char), insert(int, char), and append(char)", "label": {"api": {"StringBuilder": [[52, 64]]}}}, {"text": "You can use new StringBuilder(myString) to convert a String to a StringBuilder, and stringBuilder.toString() to convert back", "label": {"api": {"StringBuilder": [[16, 28], [65, 77]]}}}, {"text": "If your method modifies the values you cant use String as that is immutable, you can use StringBuilder instead", "label": {"api": {"StringBuilder": [[89, 101]]}}}, {"text": "If your methods already rely on char arrays and you need the offsets you can use a CharBuffer to wrap an array", "label": {"api": {"CharBuffer": [[83, 92]]}}}, {"text": "Instead of rolling your own, at least consider using something like LinkedBlockingQueue or something else from java.util.concurrent", "label": {"api": {"LinkedBlockingQueue": [[68, 86]], "java.util.concurrent": [[111, 130]]}}}, {"text": "In that case, you can check ResultSet.wasNull()", "label": {"api": {"ResultSet.wasNull()": [[28, 46]]}}}, {"text": "Depending on the way your data is ordered and read, you could even use String.split to get everything into one type (i.e", "label": {"api": {"String.split": [[71, 82]]}}}, {"text": "For example, there's a method in java.lang.Math called ulp() which, given a double, returns the distance between that double and the next; i.e., the smallest possible difference between that number and any other", "label": {"api": {"ulp()": [[55, 59]]}}}, {"text": "In that case, do the same computation, but use the first number multiplied by 0.01 instead of ulp() as the largest acceptable distance", "label": {"api": {"ulp()": [[94, 98]]}}}, {"text": "This can be achieved using either GridBagLayout as mentioned by AVD1 or BoxLayout", "label": {"api": {"GridBagLayout": [[34, 46]], "BoxLayout": [[72, 80]]}}}, {"text": "Read this really good lecture before proceeding any further", "label": {"api": {"this really good lecture": [[5, 28]]}}}, {"text": "If you must avoid writing your own, you could use the String(byte\\[\\] buf, int offset,int length) constructor to make Java string bypassing CharBuffer, and parse it to complete the conversion", "label": {"api": {"String(byte\\[\\] buf, int offset,int length)": [[54, 96]]}}}, {"text": "The correct one is Datasource from javax.sql", "label": {"api": {"Datasource": [[19, 28]]}}}, {"text": "setConnectTimeout() and setReadTimeout()", "label": {"api": {"setConnectTimeout()": [[0, 18]], "setReadTimeout()": [[24, 39]]}}}, {"text": "using one of the constructors that allows appending, e.g.", "label": {"api": {"constructors that allows appending": [[17, 50]]}}}, {"text": "One thing you could do would be to normalise the character into the NFKD form, which breaks all characters down to their most basic elements, such as base letters and combining marks, then filter out just the ASCII characters", "label": {"api": {"normalise": [[35, 43]]}}}, {"text": "With the java Normalizer you can split ä into a + combining diacritic mark", "label": {"api": {"Normalizer": [[14, 23]]}}}, {"text": "If you are using a BufferedImage, this previous SO post should provide helpful", "label": {"api": {"BufferedImage": [[19, 31]]}}}, {"text": "Spring MVC uses implementations of the PropertyEditorSupport for this", "label": {"api": {"PropertyEditorSupport": [[39, 59]]}}}, {"text": "Your problem is that java uses radians and not degrees", "label": {"api": {"not degrees": [[43, 53]]}}}, {"text": "Take a look at Math.round()", "label": {"api": {"Math.round()": [[15, 26]]}}}, {"text": "The java security manager lets you do things like this through policies", "label": {"api": {"security manager": [[9, 24]]}}}, {"text": "If the text can be all one color, call setForeground(Color)", "label": {"api": {"setForeground(Color)": [[39, 58]]}}}, {"text": "Otherwise use a styled text component such as a JEditorPane or JTextPane", "label": {"api": {"JEditorPane": [[48, 58]], "JTextPane": [[63, 71]]}}}, {"text": "According to their respective docs, java.util.calendar, joda, and DATEPART all return an integer between 1 and 53 indicating the week", "label": {"api": {"java.util.calendar": [[36, 53]]}}}, {"text": "Make CustomPrompt extends JDialog, have it's constructor call super passing the owner Window and the desired ModalityType", "label": {"api": {"JDialog": [[26, 32]], "ModalityType": [[109, 120]]}}}, {"text": "You must use the @MapsId annotation on the two ManyToOne associations", "label": {"api": {"@MapsId": [[17, 23]]}}}, {"text": "Also take a look at the ExecutorService that allows you to submit Runnables and have them executed", "label": {"api": {"ExecutorService": [[24, 38]]}}}, {"text": "Properties implements Map which has a keySet() method which returns a Set with all keys", "label": {"api": {"Properties": [[0, 9]], "Map": [[22, 24]], "keySet()": [[38, 45]], "Set": [[41, 43], [70, 72]]}}}, {"text": "The Set in turn has a toArray() method which allows you to get the values as a plain array", "label": {"api": {"Set": [[4, 6]], "toArray()": [[22, 30]]}}}, {"text": "See the SimpleDateFormat javadoc for a reference", "label": {"api": {"SimpleDateFormat javadoc": [[8, 31]]}}}, {"text": "I've not tested it, but the idea of using a ScheduledExecutorService should be what you're after", "label": {"api": {"ScheduledExecutorService": [[44, 67]]}}}, {"text": "Also note that a Double is a Number, so it has the method intValue, which you can use to get the value as a primitive int", "label": {"api": {"so it has the method": [[37, 56]]}}}, {"text": "Try DataOutputStream/DataInputStream or, for arrays, the ByteBuffer class", "label": {"api": {"DataOutputStream": [[4, 19]], "DataInputStream": [[21, 35]], "ByteBuffer": [[57, 66]]}}}, {"text": "Calculating the size of \"UTF-8\" is slightly more difficult (encode first, add 0x20 valued bytes at the end using ByteBuffer)", "label": {"api": {"ByteBuffer": [[113, 122]]}}}, {"text": "Another advice is if you want to get hold of your tasks as soon as they complete, you can implement Callable<T> instead of a Runnable that it's of a generic type and returns a value of type T", "label": {"api": {"Callable<T>": [[100, 110]]}}}, {"text": "Then you can wrap this Callable<T> into a FutureTask<V> and submit that to your ScheduledThreadPoolExecutor", "label": {"api": {"Callable<T>": [[23, 33]], "FutureTask<V>": [[42, 54]]}}}, {"text": "I believe it's a ObjectFactory", "label": {"api": {"ObjectFactory": [[17, 29]]}}}, {"text": "Such as StringBuffer or StringBuilder", "label": {"api": {"StringBuffer": [[8, 19]], "StringBuilder": [[24, 36]]}}}, {"text": "Convert your array to a List and than use the contains method", "label": {"api": {"contains": [[46, 53]]}}}, {"text": "The contains method returns", "label": {"api": {"contains": [[4, 11]]}}}, {"text": "true if the list contains the specified element", "label": {"api": {"contains": [[17, 24]]}}}, {"text": "Either through the Pattern class or the String's matches method", "label": {"api": {"Pattern": [[19, 25]], "matches method": [[49, 62]]}}}, {"text": "If you are using an external framework like Spring it becomes even easier, but if not, you just need to extend javax.servlet.http.HttpServlet, and then configure it in your web.xml", "label": {"api": {"javax.servlet.http.HttpServlet": [[111, 140]]}}}, {"text": "Perhaps not exactly equal but Java does have String.format which provides very similar functionality", "label": {"api": {"String.format": [[45, 57]]}}}, {"text": "the system class loader", "label": {"api": {"system class loader": [[4, 22]]}}}, {"text": "To do what you are required, you will need to initialize the string to the sentence you want to process, the, loop for the length of the string using the .charAt() method and see if the Character is a space", "label": {"api": {".charAt()": [[154, 162]]}}}, {"text": "To do this, you can use the Character.isWhiteSpace()", "label": {"api": {"Character.isWhiteSpace()": [[28, 51]]}}}, {"text": "If the character is not a space, you can append it to a StringBuilder", "label": {"api": {"StringBuilder": [[56, 68]]}}}, {"text": "URLEncoder.encode(String url, String encoding) should help you, no", "label": {"api": {"URLEncoder.encode(String url, String encoding)": [[0, 45]]}}}, {"text": "Starting from Java 7 you can use WatchService to track changes in file system", "label": {"api": {"WatchService": [[33, 44]]}}}, {"text": "Either make a Comparator that can compare your objects, or if they are all instances of the same class, you can make that class implement Comparable", "label": {"api": {"Comparator": [[14, 23]], "Comparable": [[138, 147]]}}}, {"text": "If you are using BufferedInputStream and BufferedOutputStream then it is hard to make it faster", "label": {"api": {"BufferedInputStream": [[17, 35]], "BufferedOutputStream": [[41, 60]]}}}, {"text": "BTW if you are processing the input as characters as opposed to bytes, you should use readers/writers with BufferedReader and BufferedWriter", "label": {"api": {"BufferedReader": [[107, 120]], "BufferedWriter": [[126, 139]]}}}, {"text": "There is a getTime() method (unsure why it's not called getDate)", "label": {"api": {"getTime()": [[11, 19]]}}}, {"text": "Line2D.ptSegDist(x1, y1, x2, y2, xP, yP) returns 0.0 if the point (xP, yP) is on the line segment from (x1, y1) to (x2, y2)", "label": {"api": {"Line2D.ptSegDist(x1, y1, x2, y2, xP, yP)": [[0, 39]]}}}, {"text": "ArrayList has the contains(Object o) method which \"returns true if the list contains the specified element\", likewise you can determine which method, add() or set() to use", "label": {"api": {"contains(Object o) method": [[18, 42]]}}}, {"text": "To fix my issue, I reused project.build.sourceEncoding in my Maven plugin (I had this problem in a custom plugin) to override file.encoding at runtime, and use this file.encoding to instantiate InputStreamReader and OutputStreamWriter with an explicit encoding as 2nd parameter", "label": {"api": {"InputStreamReader": [[194, 210]], "OutputStreamWriter": [[216, 233]]}}}, {"text": "You should consider using a List<E> implementation such as ArrayList..", "label": {"api": {"List<E>": [[28, 34]], "ArrayList": [[59, 67]]}}}, {"text": "If you want resizable array use ArrayList", "label": {"api": {"ArrayList": [[32, 40]]}}}, {"text": "You need to use SSLEngine and do the handshake manually using that state machine", "label": {"api": {"SSLEngine": [[16, 24]]}}}, {"text": "The article Non-blocking I/O with SSLEngine may be helpful", "label": {"api": {"SSLEngine": [[34, 42]]}}}, {"text": "There is no readObject method with input parameter", "label": {"api": {"There is no readObject method with input parameter": [[0, 49]]}}}, {"text": "Take a look at the charAt(int) method of the String class", "label": {"api": {"charAt(int)": [[19, 29]]}}}, {"text": "writeUTF() documentation says", "label": {"api": {"writeUTF() documentation": [[0, 23]]}}}, {"text": "You can encode the string as utf-8 yourself and then send the resulting byte array to the server using write()", "label": {"api": {"write()": [[103, 109]]}}}, {"text": "You will want to check out java.util.regex.Pattern", "label": {"api": {"java.util.regex.Pattern": [[27, 49]]}}}, {"text": "If you select that route then Java has a WatchService to handle it (complete with tutorial)", "label": {"api": {"WatchService": [[41, 52]]}}}, {"text": "Alternatively you can also use java's inbuilt URLConnection or HttpURLConnection class for these purposes", "label": {"api": {"URLConnection": [[46, 58], [67, 79]], "HttpURLConnection": [[63, 79]]}}}, {"text": "If you're on JSF 2.0, just use FacesContext#isValidationFailed() to check it", "label": {"api": {"FacesContext#isValidationFailed()": [[31, 63]]}}}, {"text": "You can do it \"the Java way\" with AtomicBoolean flag", "label": {"api": {"AtomicBoolean": [[34, 46]]}}}, {"text": "Seems to me you don't need reflection, but just need to call the JavaCompiler directly from your code", "label": {"api": {"JavaCompiler": [[65, 76]]}}}, {"text": "In JSF 2.x you could have used UIComponent#getCurrentComponent() for this", "label": {"api": {"UIComponent#getCurrentComponent()": [[31, 63]]}}}, {"text": "JDBC getColumnType returns java.sql.Types.DOUBLE for that column", "label": {"api": {"getColumnType": [[5, 17]]}}}]