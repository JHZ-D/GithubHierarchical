[{"text": "See an example of how to fix it using Arrays#asList inside a Static Initialization Blocks", "label": {"api": {"List": [[47, 50]], "Arrays#asList": [[38, 50]]}}}, {"text": "To achieve this, you can use Stream#skip in conjunction with Stream#limit", "label": {"api": {"Stream#skip": [[29, 39]], "Stream#limit": [[61, 72]]}}}, {"text": "In this example, Stream#skip skips the first element of the Stream and Stream#limit limits the remaining Stream to three elements", "label": {"api": {"Stream#skip": [[17, 27]], "Stream#limit": [[71, 82]]}}}, {"text": "Normally, you check for the user pressing Enter in a JTextField by adding an ActionListener, but JFormattedTextField has a better way, which monitors not only Enter but also loss of focus", "label": {"api": {"adding an ActionListener": [[67, 90]]}}}, {"text": "the documentation for JFormattedTextField’s value property states that it is a bound property, which means you can listen to changes in that property", "label": {"api": {"the documentation for JFormattedTextField’s value property": [[0, 57]], "listen to changes": [[115, 131]]}}}, {"text": "The javadoc of close() says", "label": {"api": {"The javadoc of close()": [[0, 21]]}}}, {"text": "You could call finish() to have the same effect but without closing the stream (and thus still close it in the finally block)", "label": {"api": {"finish()": [[15, 22]]}}}, {"text": "The bucket is determined by calling the key's hashCode() method, XORing it with the its high order 16 bits right-unsigned-shifted by 16 (see source), and then taking the modulus of the table size", "label": {"api": {"source": [[141, 146]]}}}, {"text": "First you can use Stream.map() and Stream.flatMap() to get a Stream containing a List of ThirdClass", "label": {"api": {"Stream.map()": [[18, 29]], "Stream.flatMap()": [[35, 50]]}}}, {"text": "To remove the items matching the condition you could use Collection.removeIf(), which removes all items from a collection matching the given condition", "label": {"api": {"Collection.removeIf()": [[57, 77]]}}}, {"text": "Beside that I would recommend using a Set<String> instead of a List<String> for your titles, because it has a time complexity of O(1) instead of O(n)", "label": {"api": {"Set<String>": [[38, 48]]}}}, {"text": "All you do is iterate over the nested lists and either the enhanced for loop or forEach is more straightforward", "label": {"api": {"forEach": [[80, 86]]}}}, {"text": "The improvements can come from using removeIf to modify the list and, possibly, from moving the rejection logic out of the loop", "label": {"api": {"removeIf": [[37, 44]]}}}, {"text": "The java.nio.file package is its replacement", "label": {"api": {"java.nio.file package": [[4, 24]]}}}, {"text": "Specifically, you want to use the Path and Files classes", "label": {"api": {"Path": [[34, 37]], "Files": [[43, 47]]}}}, {"text": "The (String a, String b) -> a.length() - b.length() is the Single-Abstract-Method shortcut for Comparator, and Comparator's compare method must satisfy compare(a, b) > 0 if and only if compare(b, a) < 0, otherwise it wouldn't define a proper comparison function", "label": {"api": {"Comparator": [[95, 104], [111, 120]]}}}, {"text": "If you wanted to \"sort-by\" length, you could use Comparator.comparing(String::length) (see here)", "label": {"api": {"Comparator": [[49, 58]]}}}, {"text": "Is there any value in using the javax.lang.model.element.Name class instead of immediately calling toString() on it", "label": {"api": {"javax.lang.model.element.Name class": [[32, 66]]}}}, {"text": "The HttpSessionAttributeListener interface is done for that", "label": {"api": {"HttpSessionAttributeListener": [[4, 31]]}}}, {"text": "Since the DateTimeFormatterBuilder behaves like a fluent interface, the easiest way is to append both of the patterns", "label": {"api": {"DateTimeFormatterBuilder": [[10, 33]]}}}, {"text": "You could use Integer.toBinaryString()", "label": {"api": {"Integer.toBinaryString()": [[14, 37]]}}}, {"text": "Why not just use LocalDate class for this", "label": {"api": {"LocalDate": [[17, 25]]}}}, {"text": "If you don't provide an executor to supplyAsync then it uses the fork-join common pool which does not need to be started or stopped", "label": {"api": {"fork-join common pool": [[65, 85]]}}}, {"text": "We've got this far so both partial and full are non-empty, let's utilize String's indexOf instance method", "label": {"api": {"String": [[73, 78]], "indexOf": [[82, 88]]}}}, {"text": "You can split the String into chars by toCharArray(), then you can shift them like this", "label": {"api": {"toCharArray()": [[39, 51]]}}}, {"text": "Another way that doesn't use toCharArray()", "label": {"api": {"toCharArray()": [[29, 41]]}}}, {"text": "Use a DefaultListModel (which is programmatically dynamic) for the JList", "label": {"api": {"DefaultListModel": [[6, 21]]}}}, {"text": "However, in Java, primitive data types and immutable classes like String are passed by value", "label": {"api": {"String": [[66, 71]]}}}, {"text": "Just take a look at the documentation for String you'll see a ton of method taking in a String and return a NEW String", "label": {"api": {"String": [[42, 47], [88, 93], [112, 117]]}}}, {"text": "You are getting an Optional<Integer> because that is the return type of reduce(...)", "label": {"api": {"reduce(...)": [[72, 82]], "Optional": [[19, 26]]}}}, {"text": "It returns an Optional because there is no reduced value from an empty list", "label": {"api": {"Optional": [[14, 21]]}}}, {"text": "Of course, in your case, an empty list cannot happen, because if numbers is empty, numbers.split(\" \") will return an array of one empty string, and Integer.parseInt(s) will throw NumberFormatException", "label": {"api": {"numbers.split(\" \")": [[83, 100]], "Integer.parseInt(s)": [[148, 166]]}}}, {"text": "Add a filter(...) to ignore that empty value", "label": {"api": {"filter(...)": [[6, 16]]}}}, {"text": "Now that you know the list isn't empty, you can simply unwrap the Optional by calling get()", "label": {"api": {"Optional": [[66, 73]], "get()": [[86, 90]]}}}, {"text": "Instead of calling reduce(...), you should use max(...) and min(...)", "label": {"api": {"reduce(...)": [[19, 29]], "max(...)": [[47, 54]], "min(...)": [[60, 67]]}}}, {"text": "NumberFormat's getCurrencyInstance method has a Locale parameter", "label": {"api": {"NumberFormat's getCurrencyInstance": [[0, 33]]}}}, {"text": "As \"idiomatic\" approach, you might want a FilterOutputStream", "label": {"api": {"FilterOutputStream": [[42, 59]]}}}, {"text": "If I understand your question correctly, FilterOutputStream is what you want to subclass", "label": {"api": {"FilterOutputStream": [[41, 58]]}}}, {"text": "DigestOutputStream extends FilterOutputStream and does something somewhat similar to what you want to do", "label": {"api": {"FilterOutputStream": [[27, 44]], "DigestOutputStream": [[0, 17]]}}}, {"text": "One solution that comes to mind is for the FilterOutputStream to pass the bytes to a PipedOutputStream, connected to a PipedInputStream which a different thread reads in order to create your sum", "label": {"api": {"FilterOutputStream": [[43, 60]], "PipedOutputStream": [[85, 101]]}}}, {"text": "If you want a synchronized list, use synchronizedList", "label": {"api": {"synchronizedList": [[37, 52]]}}}, {"text": "Or, if you want unsynchronized read access, at the cost of slower writes, use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[78, 97]]}}}, {"text": "ByteBuffer#getInt reads 4 bytes starting at the current position, however your wrapped ByteBuffer has a remaining size (limit - position) of 2, hence it throws a BufferUnderflowException", "label": {"api": {"ByteBuffer#getInt": [[0, 16]]}}}, {"text": "Instead, you should use ByteBuffer#getShort, which can be stored in an int", "label": {"api": {"ByteBuffer#getShort": [[24, 42]]}}}, {"text": "According to the documentation for ArrayDeque", "label": {"api": {"documentation for ArrayDeque": [[17, 44]]}}}, {"text": "If the deque is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will generally throw a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[164, 194]]}}}, {"text": "Instead of m.getReturnType(), use m.getGenericReturnType()", "label": {"api": {"m.getGenericReturnType()": [[34, 57]]}}}, {"text": "You then need to test if this is an instance of ParameterizedType", "label": {"api": {"ParameterizedType": [[48, 64]]}}}, {"text": "Implement your own ClassLoader subclass, and call defineClass(byte[] b, int off, int len)", "label": {"api": {"defineClass(byte[] b, int off, int len)": [[50, 88]]}}}, {"text": "Use SwingWorker to implement this behavior, it provides ability to execute the tasks in background (a separate thread) and also gives the ability to cancel the task", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "But since this is not using any of the CompletionStage methods, I'm pretty sure there is an even better way to do this job", "label": {"api": {"CompletionStage": [[39, 53]]}}}, {"text": "Use BigInteger, and its nextProbablePrime() method", "label": {"api": {"BigInteger": [[4, 13]], "nextProbablePrime()": [[24, 42]]}}}, {"text": "An alternative would be to use the BigInteger​(int bitLength, int certainty, Random rnd) constructor, but it will find numbers with exactly bitLength bits, which is inconvenient because it doesn't go below n ^ (bitLength - 1)", "label": {"api": {"BigInteger": [[35, 44]]}}}, {"text": "There's plenty of methods you can use from the String class, just read Oracle docs about the String class at https://docs.oracle.com/javase/9/docs/api/java/lang/String.html and maybe you'll find your happiness there", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/java/lang/String.html": [[109, 171]]}}}, {"text": "I'm using a java.util.Set interface with a java.util.HashSet implementation and storing it in a Map", "label": {"api": {"java.util.Set": [[12, 24]], "java.util.HashSet": [[43, 59]]}}}, {"text": "When adding the seemingly equal objects, Set.add returns true and two equal objects are stored in a HashSet", "label": {"api": {"Set.add": [[41, 47]]}}}, {"text": "I'm using Java 12 via IntelliJ IDEA 2018.3.6 and have checked my java.lang.Object.hashCode implementation for the class of the two objects I add to the Set, with both returning the same hash code", "label": {"api": {"java.lang.Object.hashCode": [[65, 89]]}}}, {"text": "I've also checked the java.lang.Objects.equals implementation and it returns true when the method is used to check their equality", "label": {"api": {"java.lang.Objects.equals": [[22, 45]]}}}, {"text": "You can use String.split to split the string", "label": {"api": {"String.split": [[12, 23]]}}}, {"text": "Then I guess you could cut out parts you don't want from each part using String.replace", "label": {"api": {"String.replace": [[73, 86]]}}}, {"text": "Reading up on the documentation of ThreadPoolExecutor, I'm confused what the difference is between the following to example usages", "label": {"api": {"ThreadPoolExecutor": [[35, 52]]}}}, {"text": "So what works is loading the file as a resource from the class path into a inputstream, and then feeding that input stream into ImageIO.read(java.io.InputStream)", "label": {"api": {"ImageIO.read(java.io.InputStream)": [[128, 160]]}}}, {"text": "You can just use NumberFormat class", "label": {"api": {"NumberFormat": [[17, 28]]}}}, {"text": "Alternatively you can use DecimalFormat if you want to be able to use a different format", "label": {"api": {"DecimalFormat": [[26, 38]]}}}, {"text": "You may wish to reuse the interfaces provided by Java or, if they're not sufficient, follow their naming convention in the java.util.function package", "label": {"api": {"java.util.function package": [[123, 148]]}}}, {"text": "You can take a look at https://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html#mappedBy() for more details", "label": {"api": {"https://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html#mappedBy()": [[23, 102]]}}}, {"text": "You can do it in Java 8+ with Functional Interfaces and Method References", "label": {"api": {"Functional Interfaces": [[30, 50]]}}}, {"text": "First, replace Long with AtomicLong", "label": {"api": {"AtomicLong": [[25, 34]]}}}, {"text": "Second, use computeIfAbsent", "label": {"api": {"computeIfAbsent": [[12, 26]]}}}, {"text": "That code generates extra garbage, which can be avoided by using AtomicLong", "label": {"api": {"AtomicLong": [[65, 74]]}}}, {"text": "You can just use Collection.removeIf() to remove all objects matching a given condition", "label": {"api": {"Collection.removeIf()": [[17, 37]]}}}, {"text": "With regard to the performance and massive amount of data, I recommend you to avoid any usage of java-stream (although it is quite quick itself) and the Map::merge method", "label": {"api": {"Map::merge": [[153, 162]]}}}, {"text": "Set prevents duplicate values", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "So what comes directly to mind is using Set ( which is a collection of non duplicated values)", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "I would strongly suggest you use the java.time.MonthDay class to store your dates", "label": {"api": {"java.time.MonthDay": [[37, 54]]}}}, {"text": "System.in returns the InputStream, and the read method of its is called", "label": {"api": {"read": [[43, 46]]}}}, {"text": "JavaDocs states read", "label": {"api": {"read": [[16, 19]]}}}, {"text": "How can I read input from the console using the Scanner class in Java", "label": {"api": {"read": [[10, 13]]}}}, {"text": "That's why you should use BigDecimal", "label": {"api": {"BigDecimal": [[26, 35]]}}}, {"text": "Then, to parse a String to BigDecimal, as suggested here, you should use setParseBigDecimal in DecimalFormat class, then parse will return a BigDecimal for you", "label": {"api": {"BigDecimal": [[27, 36], [81, 90], [141, 150]], "setParseBigDecimal": [[73, 90]], "parse": [[9, 13], [121, 125]]}}}, {"text": "How should you handle a FileSystemAlreadyExistsException when calling FileSystems.newFileSystem", "label": {"api": {"FileSystems.newFileSystem": [[70, 94]]}}}, {"text": "You can use Arrays.stream() and IntStream.min()", "label": {"api": {"Arrays.stream()": [[12, 26]], "IntStream.min()": [[32, 46]]}}}, {"text": "We can use Collectors#groupingBy and streams to sort each player into groups of scores", "label": {"api": {"Collectors#groupingBy": [[11, 31]]}}}, {"text": "Applets are no longer supported", "label": {"api": {"no longer supported": [[12, 30]]}}}, {"text": "Although the javadoc for SSLParameters.setServerNames doesn't say so, if the value set is an empty List (with no elements), then ClientHandshaker actually sends no SNI at all", "label": {"api": {"SSLParameters.setServerNames": [[25, 52]]}}}, {"text": "Let's say I've the following Java class called Memory with PropertyChangeSupport..", "label": {"api": {"PropertyChangeSupport": [[59, 79]]}}}, {"text": "You can use the Java 8 Year class and its Year.minusYears() method", "label": {"api": {"Year": [[23, 26], [42, 45], [52, 55]], "Year.minusYears()": [[42, 58]]}}}, {"text": "Use LocalDate class from Java 8", "label": {"api": {"LocalDate": [[4, 12]]}}}, {"text": "But you can just shorten this using Files.write()", "label": {"api": {"Files.write()": [[36, 48]]}}}, {"text": "You also can simplify your read method using Files.lines()", "label": {"api": {"Files.lines()": [[45, 57]]}}}, {"text": "use a Java 8+ Consumer", "label": {"api": {"Consumer": [[14, 21]]}}}, {"text": "The bootstrap method itself, hosted in the LambdaMetafactory class will generate a new class each time it is invoked", "label": {"api": {"LambdaMetafactory": [[43, 59]]}}}, {"text": "The LambdaMetafactory has an exhaustive documentation about its usage", "label": {"api": {"LambdaMetafactory": [[4, 20]]}}}, {"text": "I recommend changing your ScheduledExecutorService to a ScheduledThreadPoolExecutor, which will allow you to override its beforeExecute(Thread, Runnable) method; this method is invoked immediately before the task is run by the pool after it has already been assigned a thread that will execute the task", "label": {"api": {"ScheduledExecutorService": [[26, 49]], "ScheduledThreadPoolExecutor": [[56, 82]], "beforeExecute(Thread, Runnable)": [[122, 152]]}}}, {"text": "You can achieve this by using Collectors.collectingAndThen()", "label": {"api": {"Collectors.collectingAndThen()": [[30, 59]]}}}, {"text": "I suggest you rename @URL to @URLCollection to avoid conflict with the class java.net.URL", "label": {"api": {"java.net.URL": [[77, 88]]}}}, {"text": "Don't forget to the annotation @Constraint (look at its documentation to learn how to define the custom validation annotation properly)", "label": {"api": {"@Constraint": [[31, 41]]}}}, {"text": "Then continue with the implementation of ConstraintValidator", "label": {"api": {"ConstraintValidator": [[41, 59]]}}}, {"text": "* A @Constraint annotation that declares the constraint and its configurable properties", "label": {"api": {"@Constraint": [[4, 14]]}}}, {"text": "* An implementation of the javax.validation.ConstraintValidator interface that implements the constraint’s behavior", "label": {"api": {"ConstraintValidator": [[44, 62]]}}}, {"text": "The Class class already has a method to cast an object at runtime -- the cast method", "label": {"api": {"the cast method": [[69, 83]]}}}, {"text": "Use the terminal operation Stream::toArray which packs the sequence of items into an array", "label": {"api": {"Stream::toArray": [[27, 41]]}}}, {"text": "However, you have to define a provided generator IntFunction<A[]> to allocate the type of returned array", "label": {"api": {"IntFunction<A[]>": [[49, 64]]}}}, {"text": "If you do that, your problem becomes \"How do I sort a list of objects based on one of their fields?\" You can use the Comparator or Comparable interfaces to decide how you want to sort them", "label": {"api": {"Comparator": [[117, 126]], "Comparable": [[131, 140]]}}}, {"text": "Maybe some workaround is to use ManagedScheduledExecutorService", "label": {"api": {"ManagedScheduledExecutorService": [[32, 62]]}}}, {"text": "You can use Files.lines() to read all lines in the file and String.toCharArray() to get all the chars from each line", "label": {"api": {"Files.lines()": [[12, 24]], "String.toCharArray()": [[60, 79]]}}}, {"text": "You're calling Duration.getNano() on the Duration returned by elapsed(), which isn't what you want", "label": {"api": {"Duration.getNano()": [[15, 32]]}}}, {"text": "Duration.getNano() returns that nano offset, and should almost never be called unless you're also calling Duration.getSeconds()", "label": {"api": {"Duration.getNano()": [[0, 17]]}}}, {"text": "Once you have added all the data into list you can directly use list.sort() method by using Comparator but in your case you want to write selection sort that's why you have to write another method to do selection sort", "label": {"api": {"Comparator": [[92, 101]]}}}, {"text": "The hashCode value for String is specified in detail specifically so that any two strings with the same content will hash to the same value", "label": {"api": {"is specified in detail": [[30, 51]]}}}, {"text": "The most obvious example of an equivalent functional interface would be Consumer<T>", "label": {"api": {"Consumer<T>": [[72, 82]]}}}, {"text": "So in your code you set up a seed for your Random and you create new Random object every loop iteration so it just returns same number every time", "label": {"api": {"Random": [[43, 48], [69, 74]]}}}, {"text": "If you use seed the documentation of Random class says", "label": {"api": {"Random": [[37, 42]]}}}, {"text": "If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers", "label": {"api": {"Random": [[20, 25]]}}}, {"text": "In your case you can get rid of seed value from your constructor or move Random class object creation outside of the loop", "label": {"api": {"Random": [[73, 78]]}}}, {"text": "Here I moved creation of Random instance outside of the loop so only one object is created and I am not passing seed to the constructor", "label": {"api": {"Random": [[25, 30]]}}}, {"text": "I could pass the seed but in this case it is not needed as I don't need to create more instances of Random and I dont need them to generate same results", "label": {"api": {"Random": [[100, 105]]}}}, {"text": "In javax.sound.sampled terms, you are writing them to a SourceDataLine using its write(buf) method", "label": {"api": {"SourceDataLine": [[56, 69]], "write(buf)": [[81, 90]]}}}, {"text": "The preferred replacement for finalization is to use something like a WeakReference", "label": {"api": {"WeakReference": [[70, 82]]}}}, {"text": "This kind of reference processing can be inconvenient, so there is another mechanism called Cleaner that might be easier to use", "label": {"api": {"Cleaner": [[92, 98]]}}}, {"text": "The trick with reference or Cleaner processing is that you need to keep track of stuff that needs to be cleaned up without keeping a reference to the object it's associated with", "label": {"api": {"Cleaner": [[28, 34]]}}}, {"text": "Create a Cleaner instance that will be responsible for performing cleanup actions", "label": {"api": {"Cleaner": [[9, 15]]}}}, {"text": "When a DiskCacheItem is added to the DiskCache, create an instance of the state class, and register it with the Cleaner, associating it with a cleanup action", "label": {"api": {"Cleaner": [[112, 118]]}}}, {"text": "This returns an instance of Cleanable", "label": {"api": {"Cleanable": [[28, 36]]}}}, {"text": "If there is an explicit \"close\" or \"delete\" action on DiskCacheItem, have it call clean() on the associated Cleanable object", "label": {"api": {"Cleanable": [[108, 116]]}}}, {"text": "This will cause the Cleaner to invoke the cleanup action", "label": {"api": {"Cleaner": [[20, 26]]}}}, {"text": "After all this, what's the point of replacing finalization with the Cleaner/Cleanable mechanism", "label": {"api": {"Cleaner": [[68, 74]], "Cleanable": [[76, 84]]}}}, {"text": "First, you can explicitly clean up a Cleanable", "label": {"api": {"Cleanable": [[37, 45]]}}}, {"text": "With reference processing and Cleaner, there is no possibility of \"resurrecting\" an object", "label": {"api": {"Cleaner": [[30, 36]]}}}, {"text": "The problem is that a GZIPOutputStream isn't complete until the finish() method has been called", "label": {"api": {"GZIPOutputStream": [[22, 37]], "finish()": [[64, 71]]}}}, {"text": "And closing the GZIPOutputStream automatically closes the underlying stream(s) (i.e", "label": {"api": {"GZIPOutputStream": [[16, 31]]}}}, {"text": "You can use Map#merge e.g", "label": {"api": {"Map#merge": [[12, 20]]}}}, {"text": "You can just use Stream.concat() to concatenate the streams of the two maps", "label": {"api": {"Stream.concat()": [[17, 31]]}}}, {"text": "You can use map merge from Java 8", "label": {"api": {"map merge": [[12, 20]]}}}, {"text": "When it comes to making simple one-liners, the Stream API is your friend", "label": {"api": {"Stream API": [[47, 56]]}}}, {"text": "I would use the Stream#collect method and the Collectors#toMap methods", "label": {"api": {"Stream#collect": [[16, 29]], "Collectors#toMap": [[46, 61]]}}}, {"text": "perhaps use a ScheduledExecutorService to trigger the delayed tasks and perform the actions using NIO", "label": {"api": {"ScheduledExecutorService": [[14, 37]]}}}, {"text": "You first need to get a Validator object", "label": {"api": {"Validator": [[24, 32]]}}}, {"text": "you should be using a Map", "label": {"api": {"Map": [[22, 24]]}}}, {"text": "The method String::split uses Regex for the split", "label": {"api": {"String::split": [[11, 23]]}}}, {"text": "However, as general background, understand that there are actually three different ways that annotations can be handled, per the RetentionPolicy meta-annotation (and yes, I picked the 1.5 JavaDoc intentionally)", "label": {"api": {"RetentionPolicy": [[129, 143]]}}}, {"text": "Having the defined method with Comparator as one of the formal parameters means that you can pass a lambda expression in it of a functional interface corresponding to Comparator", "label": {"api": {"Comparator": [[31, 40], [167, 176]]}}}, {"text": "Don't forget to wrap the Comparator around the boxed types, since you cannot use the primitive ones", "label": {"api": {"Comparator": [[25, 34]]}}}, {"text": "The crucial is Comparator::compare which returns int and therefore behaves like a BiFunction<T, T, Integer>, shall be shortened as a lambda expression (or a method reference in some cases)", "label": {"api": {"Comparator": [[15, 24]], "Comparator::compare": [[15, 33]]}}}, {"text": "For integers or objects implementing Comparable the whole thing would be much easier", "label": {"api": {"Comparable": [[37, 46]]}}}, {"text": "You can use BigInteger to hold the number which is more than int max size as well as you can avoid NumberFormatException", "label": {"api": {"BigInteger": [[12, 21]]}}}, {"text": "You can just use Integer.compare() in your Comparator to achieve this", "label": {"api": {"Integer.compare()": [[17, 33]]}}}, {"text": "Or even shorter using Comparator.comparingInt()", "label": {"api": {"Comparator.comparingInt()": [[22, 46]]}}}, {"text": "Moreover, the method String.format(..) might be more interesting for you", "label": {"api": {"String.format(..)": [[21, 37]]}}}, {"text": "Based on readUTF from the docs, I don't see an elegant way to do it, maybe you could read until it hits EOFException like this", "label": {"api": {"readUTF": [[9, 15]]}}}, {"text": "I have found JSR-310 with ChronoUnit - that solves the problem, BUT it needs Java8", "label": {"api": {"ChronoUnit": [[26, 35]]}}}, {"text": "I noticed in the JShell API there is a method called drop(Snippet) which seems to remove the Snippet from the history, but it does not remove any effect the Snippet had on the state", "label": {"api": {"JShell API": [[17, 26]]}}}, {"text": "The documentation of AsynchronousSocketChannel.write() says", "label": {"api": {"AsynchronousSocketChannel.write()": [[21, 53]]}}}, {"text": "Use the class Scanner instead, which function int nextInt() does exactly what you need", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "Random.nextInt() can return any of the possible 232 integer numbers (from -2147483648 to 2147483647)", "label": {"api": {"Random.nextInt()": [[0, 15]]}}}, {"text": "See the documentation for Random.nextInt(int bound)", "label": {"api": {"Random.nextInt(int bound)": [[26, 50]]}}}, {"text": "The use of List.remove here is with respect to removing an element from the index and not the object and hence casting to (int)", "label": {"api": {"List.remove": [[11, 21]]}}}, {"text": "To prevent an int overflow I would recommend using Math.multiplyExact() for the multiplication", "label": {"api": {"Math.multiplyExact()": [[51, 70]]}}}, {"text": "Accordung to the docs for @Override, you can't", "label": {"api": {"the docs for @Override": [[13, 34]]}}}, {"text": "The retention policy is SOURCE, not RUNTIME, which means the annotation is not present at runtime", "label": {"api": {"retention policy": [[4, 19]], "SOURCE": [[24, 29]], "RUNTIME": [[36, 42]]}}}, {"text": "The problem is you use Stream::reduce for Mutable reduction, which has been Stream::collect specifically designed for", "label": {"api": {"Stream::reduce": [[23, 36]], "Mutable reduction": [[42, 58]], "Stream::collect": [[76, 90]]}}}, {"text": "Java 11 introduced a new standard HTTP client", "label": {"api": {"HTTP client": [[34, 44]]}}}, {"text": "A request is sent using HttpClient:send, which returns a HttpResponse", "label": {"api": {"HttpClient:send": [[24, 38]], "HttpResponse": [[57, 68]]}}}, {"text": "The HttpResponse::statusCode method can be used to find the HTTP status of the response", "label": {"api": {"HttpResponse": [[4, 15]], "HttpResponse::statusCode": [[4, 27]]}}}, {"text": "HttpClient::send also takes a BodyHandler which is used to handle the body of the response", "label": {"api": {"BodyHandler": [[30, 40]]}}}, {"text": "A useful family of BodyHandlers are those which wrap a Flow.Subscription, created with BodyHandlers::fromSubscriber and relatives", "label": {"api": {"BodyHandler": [[19, 29], [87, 97]], "Flow.Subscription": [[55, 71]], "BodyHandlers::fromSubscriber": [[87, 114]]}}}, {"text": "However, it seems that if you use one of these BodyHandlers, the flow is delivered on the thread which called HttpClient::send, and so for an infinite stream, that method never returns", "label": {"api": {"BodyHandler": [[47, 57]]}}}, {"text": "Since it never returns, you never get a HttpResponse with which you can determine the status", "label": {"api": {"HttpResponse": [[40, 51]]}}}, {"text": "Don't mistake the append-method of the BufferedWriter as appending content to the file", "label": {"api": {"append": [[18, 23], [57, 62]], "BufferedWriter": [[39, 52]]}}}, {"text": "It actually appends to the given writer", "label": {"api": {"append": [[12, 17]]}}}, {"text": "To actually append additional content to the file you need to specify that when opening the file writer", "label": {"api": {"append": [[12, 17]]}}}, {"text": "FileWriter has an additional constructor parameter allowing to specify that", "label": {"api": {"FileWriter": [[0, 9]]}}}, {"text": "You may even be interested in the Java Files API instead, so you can spare instantating your own BufferedWriter, etc.", "label": {"api": {"BufferedWriter": [[97, 110]], "Java Files API": [[34, 47]]}}}, {"text": "Yes, as Willem has mentioned pop removes top element from the stack and returns its value", "label": {"api": {"pop": [[29, 31]]}}}, {"text": "Instead, you should multiply a by 100.0 (note the .0, which makes it a double literal!) to use floating-point division, and then ceil the result, and truncate it to an int", "label": {"api": {"ceil": [[129, 132]]}}}, {"text": "I was watching a video on Java by Tim Buchalka and he said that Java LinkedList iterators don't point to the item in the list, but instead they point between the items in the list (as illustrated here https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html": [[201, 269]]}}}, {"text": "You can do that using request.getAttribute() & request.setAttribute() , for eg", "label": {"api": {"request.getAttribute()": [[22, 43]], "request.setAttribute()": [[47, 68]]}}}, {"text": "This is due to the ResolverStyle used by the formatter to parse the value", "label": {"api": {"ResolverStyle": [[19, 31]]}}}, {"text": "Java's ForkJoinPool.ManagedBlocker is part of a solution for a similar problem when working with parallel streams", "label": {"api": {"ForkJoinPool.ManagedBlocker": [[7, 33]]}}}, {"text": "You can solve this by implementing the java.lang.Thread.UncaughtExceptionHandler interface", "label": {"api": {"java.lang.Thread.UncaughtExceptionHandler": [[39, 79]]}}}, {"text": "While it will work without problems if we only want to re-throw subtypes of RuntimeException and Error, there is a little adaptation needed if we want to make it work  - you can find it explained in @JBC's question", "label": {"api": {"RuntimeException": [[76, 91]], "Error": [[97, 101]]}}}, {"text": "String.hashcode is specified to use a specific algorithm", "label": {"api": {"String.hashcode": [[0, 14]]}}}, {"text": "If you want to read more about AtomicInteger, see atomic", "label": {"api": {"atomic": [[50, 55]]}}}, {"text": "The easiest way to regularly execute code in that thread is by using the javax.swing.Timer class", "label": {"api": {"javax.swing.Timer": [[73, 89]]}}}, {"text": "Note that, similar to a Thread, a Timer needs to have its start() (or restart()) method called", "label": {"api": {"start()": [[58, 64], [72, 78]], "restart()": [[70, 78]]}}}, {"text": "You can also try to implements the Serializable hidden methods writeObject and readObject (see link) to customize the serialized form of your object", "label": {"api": {"Serializable": [[35, 46]]}}}, {"text": "The standard library Javadoc for Thread.yield() effectively says that yield() does not have to do anything at all", "label": {"api": {"Javadoc for Thread.yield()": [[21, 46]]}}}, {"text": "A getCause() should help here to access the inner exception", "label": {"api": {"getCause()": [[2, 11]]}}}, {"text": "This doesn't occur with FileNotFoundException, because no matter how specific the type parameter is, it won't be any more specific than IOException (the lower bound), so a FileNotFoundException, which is a subclass of IOException, is legal in all cases, so the compiler allows it", "label": {"api": {"FileNotFoundException": [[24, 44], [172, 192]]}}}, {"text": "In addition to wrapping the synchronous method call into a CompletableFuture as suggested by Matt there is CompletableFuture.thenCompose for composing the results of the two individual futures", "label": {"api": {"CompletableFuture.thenCompose": [[107, 135]]}}}, {"text": "If your keyset is static then you can simply use AtomicInteger values", "label": {"api": {"AtomicInteger": [[49, 61]]}}}, {"text": "You could use compareAndSet like this", "label": {"api": {"compareAndSet": [[14, 26]]}}}, {"text": "Alternatively, you can use a ConcurrentHashMap which does not lock the entire map", "label": {"api": {"ConcurrentHashMap": [[29, 45]]}}}, {"text": "For example, if your trigger code is relatively fast then you can simply use compute()", "label": {"api": {"compute()": [[77, 85]]}}}, {"text": "The Javadoc of CompleteableFuture.runAsync() says", "label": {"api": {"CompleteableFuture.runAsync()": [[15, 43]]}}}, {"text": "Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool.commonPool() after it runs the given action", "label": {"api": {"ForkJoinPool.commonPool()": [[90, 114]]}}}, {"text": "The Javadoc of ForkJoinPool.commonPool() says", "label": {"api": {"ForkJoinPool.commonPool()": [[15, 39]]}}}, {"text": "You could implement your own HandlerMethodArgumentResolver and bind the x parameter from HttpServletRequest object", "label": {"api": {"HttpServletRequest": [[89, 106]]}}}, {"text": "If it's a single endpoint that handles the strange parameter convention it would be more readable to just have HttpServletRequest as method parameter and do the work there before calling service", "label": {"api": {"HttpServletRequest": [[111, 128]]}}}, {"text": "JavaMail has MimeMultipart and MimeBodyPart classes for this", "label": {"api": {"MimeMultipart": [[13, 25]], "MimeBodyPart": [[31, 42]]}}}, {"text": "getMethod returns a java.lang.reflect.Method object", "label": {"api": {"java.lang.reflect.Method": [[20, 43]]}}}, {"text": "JsonObject implements java.util.Map, so you can simply call the keySet-Method on your JsonObject", "label": {"api": {"java.util.Map": [[22, 34]], "keySet-Method": [[64, 76]]}}}, {"text": "The issue with your code is that you need to ensure that you use Scanner's hasNextLine() method before calling the nextLine() method", "label": {"api": {"hasNextLine()": [[75, 87]]}}}, {"text": "Java provides java.awt.Desktop (API JDK 11), with which such interactions can be made", "label": {"api": {"API JDK 11": [[32, 41]]}}}, {"text": "Duration might help", "label": {"api": {"Duration": [[0, 7]]}}}, {"text": "According to the docs, Pattern.matches(regex,string) is equivalent to Pattern.compile(regex).matcher(string).matches(), which is equivalent to string.matches(regex)", "label": {"api": {"Pattern.matches(regex,string)": [[23, 51]]}}}, {"text": "Convert that java.time.Duration object to a javafx.util.Duration object", "label": {"api": {"java.time.Duration": [[13, 30]]}}}, {"text": "Where MoreObjects.firstNonNull and Collections.emptyList() are used", "label": {"api": {"Collections.emptyList()": [[35, 57]]}}}, {"text": "You can return a BiPredicate", "label": {"api": {"BiPredicate": [[17, 27]]}}}, {"text": "Since you want 2 operands, and a boolean result, you could simply use BiPredicate, but since you want the 2 operands to be of the same type, that would require you to repeat the type, so you could create a new functional interface, e.g", "label": {"api": {"BiPredicate": [[70, 80]]}}}, {"text": "But on the server side you can decode received string using URLDecoder class", "label": {"api": {"URLDecoder": [[60, 69]]}}}, {"text": "I want to create a java.util.stream.Stream that blocks on terminal actions and uses an arbitrary object for synchronization", "label": {"api": {"terminal actions": [[58, 73]]}}}, {"text": "(This is mentioned in the Javadoc for that method.) You're giving it an angle in degrees", "label": {"api": {"the Javadoc for that method": [[22, 48]]}}}, {"text": "You could use System.setOut() with a StringWriter", "label": {"api": {"System.setOut()": [[14, 28]], "StringWriter": [[37, 48]]}}}, {"text": "You can even write less code with Comparator.comparingInt", "label": {"api": {"Comparator.comparingInt": [[34, 56]]}}}, {"text": "Unlike compiler generated type casts, which can only work with types known at compile-time, this will perform a check against the Class object retrieved at runtime", "label": {"api": {"cast": [[31, 34]]}}}, {"text": "Since this is safe, it won’t generated an “Unchecked cast” warning", "label": {"api": {"cast": [[53, 56]]}}}, {"text": "Note the existence of a similar operation, cast for casting an instance of a Class", "label": {"api": {"cast": [[43, 46], [52, 55]]}}}, {"text": "Is there a proper approach to do this in java.util.LinkedList<Integer>", "label": {"api": {"java.util.LinkedList<Integer>": [[41, 69]]}}}, {"text": "You obtain it by using LinkedList#listIterator", "label": {"api": {"LinkedList#listIterator": [[23, 45]]}}}, {"text": "Use Stream.filter() to filter Records matching the criteria", "label": {"api": {"Stream.filter()": [[4, 18]]}}}, {"text": "Then collect filtered elements into a list (Stream.collect()), and create an instance of ClassB passing the list into the constructor", "label": {"api": {"Stream.collect()": [[44, 59]]}}}, {"text": "I'd recommend you have a look at the more robust ProcessBuilder API if you need to pass complex arguments like json", "label": {"api": {"ProcessBuilder API": [[49, 66]]}}}, {"text": "Class has no explicitly defined hashCode() method, so it's not defined to be stable", "label": {"api": {"Class": [[0, 4]]}}}, {"text": "That means that you can (and probably will) get different results for MyClass.class.hashCode() between different runs, even on the same JVM and definitely between different JVM implementations and/or versions", "label": {"api": {"Class": [[72, 76]]}}}, {"text": "Also, you may find the java.text.NumberFormat class useful for the Currency handling", "label": {"api": {"java.text.NumberFormat": [[23, 44]]}}}, {"text": "What is the most reliable pattern to follow when closing an OutputStream, ServerSocket, or other object that implements the AutoCloseable interface", "label": {"api": {"OutputStream": [[60, 71]], "ServerSocket": [[74, 85]], "AutoCloseable": [[124, 136]]}}}, {"text": "The correct way to use an AutoCloseable instance is with a try-with-resources block, so the resource is reliably closed even if an exception is thrown", "label": {"api": {"AutoCloseable": [[26, 38]], "closed": [[113, 118]]}}}, {"text": "try-with-resources is the recommended manner of properly closing all AutoCloseable resources", "label": {"api": {"AutoCloseable": [[69, 81]]}}}, {"text": "If none of your methods explicitly call close(), your code is guaranteed never to throw an exception (such as a \"Socket closed\" java.net.SocketException) because it attempts to use a resource that has been closed", "label": {"api": {"closed": [[120, 125], [206, 211]]}}}, {"text": "Doing this ensures that the resource is closed precisely once", "label": {"api": {"closed": [[40, 45]]}}}, {"text": "Beware that in general it is unsafe to close an AutoCloseable more than once", "label": {"api": {"AutoCloseable": [[48, 60]]}}}, {"text": "You can use Introspector", "label": {"api": {"Introspector": [[12, 23]]}}}, {"text": "As stated in the documentation of List.indexOf(Object), that method returns -1 if the List does not contain the object passed as an argument", "label": {"api": {"List.indexOf(Object)": [[34, 53]]}}}, {"text": "Now take a look at the return type of Stream.findFirst()—it returns Optional<T>", "label": {"api": {"Stream.findFirst()": [[38, 55]]}}}, {"text": "You could even use Optional.ifPresent(Consumer)", "label": {"api": {"Optional.ifPresent(Consumer)": [[19, 46]]}}}, {"text": "If the element not being present in the list is an error, you can instead use something like Optional.orElseThrow(Supplier) or Optional.orElseThrow() (Java 10+)", "label": {"api": {"Optional.orElseThrow(Supplier)": [[93, 122]], "Optional.orElseThrow()": [[127, 148]]}}}, {"text": "You could execute your task asynchronously as runnable in a threadpool using ExecutorService", "label": {"api": {"ExecutorService": [[77, 91]]}}}, {"text": "If you want to match one or more of those characters, you need to add a + quantifier at the end", "label": {"api": {"quantifier": [[74, 83]]}}}, {"text": "MemoryPoolMXBean.getCollectionUsage() returns memory usage after the most recent garbage collection", "label": {"api": {"MemoryPoolMXBean.getCollectionUsage()": [[0, 36]]}}}, {"text": "jcmd GC.heap_info gives the current heap usage (equivalent of MemoryPoolMXBean.getUsage()", "label": {"api": {"MemoryPoolMXBean.getUsage()": [[62, 88]]}}}, {"text": "Use a Map instead", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "\"It is never legal to start a thread more than once\"", "label": {"api": {"\"It is never legal to start a thread more than once\"": [[0, 51]]}}}, {"text": "As the javadoc of exec says, the preferred way to run commands is ProcessBuilder, so your code should be", "label": {"api": {"exec": [[18, 21]], "ProcessBuilder": [[66, 79]]}}}, {"text": "setJMSMessageId does nothing - from the javadocs", "label": {"api": {"the javadocs": [[36, 47]]}}}, {"text": "Here's how to get the actual file from your Logger, then you can use java.io.File.setLastModified()", "label": {"api": {"java.io.File.setLastModified()": [[69, 98]]}}}, {"text": "The certificate is compatible with CertificateFactory for \"X.509\"", "label": {"api": {"CertificateFactory": [[35, 52]]}}}, {"text": "The private key is compatible with KeyFactory with \"RSA\" as algorithm and PKCS8EncodedKeySpec", "label": {"api": {"KeyFactory": [[35, 44]], "PKCS8EncodedKeySpec": [[74, 92]]}}}, {"text": "I think you are looking for the compute method", "label": {"api": {"compute method": [[32, 45]]}}}, {"text": "ForkJoinPool was introduced in Java 7, so no JVM under 1.7 would ever be able to call it", "label": {"api": {"Java 7": [[31, 36]]}}}, {"text": "Second, I highly recommend to change the method name in class Point because there is a toString method already inherited from Object", "label": {"api": {"toString": [[87, 94]]}}}, {"text": "This may lead to confusions since the goal of the inherited method is not the same the one you created this toString method for", "label": {"api": {"toString": [[108, 115]]}}}, {"text": "Here, String.format(\"%s:%s:%s\", ...) is a nicer way to format the string with the three numbers, but you can just as well keep yours", "label": {"api": {"format the string": [[55, 71]]}}}, {"text": "Sure, ActiveMQ, like any other JMS provider has a blocking API (MessageConsumer.receive()) as well as a method to setup a MessageListener that is called automatically once a message arrives", "label": {"api": {"MessageConsumer.receive()": [[64, 88]], "MessageListener": [[122, 136]]}}}, {"text": "Sounds to me like you are looking for a java.util.concurrent.CountDownLatch", "label": {"api": {"java.util.concurrent.CountDownLatch": [[40, 74]]}}}, {"text": "Use getFileName to get the name of the file", "label": {"api": {"getFileName": [[4, 14]]}}}, {"text": "Date objects have a method getTime() which returns the number of milliseconds since 1 Jan, 1970 (see the docs)", "label": {"api": {"see the docs": [[97, 108]]}}}, {"text": "In this case, indexOf will return -1 for everything, meaning everything is equal to everything else", "label": {"api": {"indexOf will return -1": [[14, 35]]}}}, {"text": "And your application’s code would create a ModuleFinder that looks in the directory (or directories) where you expect those plugin modules to reside, then pass that ModuleFinder to a Configuration which can be used to create a ModuleLayer for the ServiceLoader", "label": {"api": {"ServiceLoader": [[247, 259]], "ModuleFinder": [[43, 54], [165, 176]], "Configuration": [[183, 195]], "ModuleLayer": [[227, 237]]}}}, {"text": "You might even want to watch the plugin directory for new or removed files", "label": {"api": {"watch": [[23, 27]]}}}, {"text": "The Image(String url) constructor requires a URL string, not a file name", "label": {"api": {"Image(String url)": [[4, 20]]}}}, {"text": "If it's for your app or for your application server, then you can use Runtime.getRuntime().freeMemory() to get the memory usage before and after the database/JDBC call", "label": {"api": {"Runtime.getRuntime().freeMemory()": [[70, 102]]}}}, {"text": "I would like to convert objects of type Foo to XML using XStream, however I need to do so with a custom converter as Foo contains a JavaFX property which cannot easily be serialized", "label": {"api": {"JavaFX property": [[132, 146]]}}}, {"text": "You can also use poll(timeout, timeunit) method for checking if the thread is stopped", "label": {"api": {"poll(timeout, timeunit)": [[17, 39]]}}}, {"text": "The method servis.listOnayStatus4Belge returns a Vector", "label": {"api": {"Vector": [[49, 54]]}}}, {"text": "A Vector implements the List interface but is not an ArrayList", "label": {"api": {"Vector": [[2, 7]]}}}, {"text": "You are copying a Vector and assigning it to cloneOnayStatu", "label": {"api": {"Vector": [[18, 23]]}}}, {"text": "The clone() method call will return another Vector but it's declared return type is Object", "label": {"api": {"Vector": [[44, 49]]}}}, {"text": "InputStream and OutputStream work in bytes", "label": {"api": {"InputStream": [[0, 10]], "OutputStream": [[16, 27]]}}}, {"text": "Reader and Writer work in characters", "label": {"api": {"Reader": [[0, 5]], "Writer": [[11, 16]]}}}, {"text": ":-) InputStream and Reader are both for reading information (a stream of bytes or a stream of characters, respectively), and OutputStream and Writer are both for writing information (a stream of bytes or a stream of characters, respectively)", "label": {"api": {"InputStream": [[4, 14]], "OutputStream": [[125, 136]], "Reader": [[20, 25]], "Writer": [[142, 147]]}}}, {"text": "InputStreamReader reads from an InputStream and converts bytes to characters using a CharSet (one provided explicitly or by name)", "label": {"api": {"InputStream": [[0, 10], [32, 42]], "Reader": [[11, 16]], "InputStreamReader": [[0, 16]]}}}, {"text": "OutputStreamWriter does the converse", "label": {"api": {"OutputStream": [[0, 11]], "Writer": [[12, 17]], "OutputStreamWriter": [[0, 17]]}}}, {"text": "Converts characters to bytes (again via a CharSet) and writes the bytes to an OutputStream", "label": {"api": {"OutputStream": [[78, 89]]}}}, {"text": "...but most Reader/Writer subclasses read from/write to sources/destinations that are already character-based, and so don't deal with bytes at all", "label": {"api": {"Reader": [[12, 17]], "Writer": [[19, 24]]}}}, {"text": "For instance, StringReader reads characters from a string", "label": {"api": {"Reader": [[20, 25]], "StringReader": [[14, 25]]}}}, {"text": "Since the source (the string) is already character-based, the Reader doesn't ever deal with bytes, just characters", "label": {"api": {"Reader": [[62, 67]]}}}, {"text": "Standard classes InputStreamReader and OutputStreamWriter act as adapters from the byte stream interfaces to the character stream interfaces, requiring only that a Charset (typically UTF-8) is specified", "label": {"api": {"InputStreamReader": [[17, 33]], "OutputStreamWriter": [[39, 56]]}}}, {"text": "You could combine dropWhile and takeWhile methods introduced in Java 9", "label": {"api": {"dropWhile": [[18, 26]], "takeWhile": [[32, 40]]}}}, {"text": "Store your resources in a single zip archive which is embedded in your jar, and extract it yourself with a ZipInputStream which wraps MyApplication.class.getResourceAsStream", "label": {"api": {"ZipInputStream": [[107, 120]]}}}, {"text": "To quote the documentaion, Map#put retruns \"the previous value associated with key, or null if there was no mapping for key\"", "label": {"api": {"the documentaion": [[9, 24]]}}}, {"text": "ActivityB.class simply refers to the ActivityB Class reference", "label": {"api": {"Class": [[47, 51]]}}}, {"text": "You can use a DateTimeFormatter to parse your time strings into LocalTimes, and then check if the current is between the start and end", "label": {"api": {"DateTimeFormatter": [[14, 30]], "LocalTime": [[64, 72]]}}}, {"text": "And specify the Locale for the human language to use in reading the name of month", "label": {"api": {"Locale": [[16, 21]]}}}, {"text": "From Oracle's docs, in particular, from this line", "label": {"api": {"Oracle's docs": [[5, 17]]}}}, {"text": "The official document of Reader shows that it has only one field locker inherited from its parent class Reader", "label": {"api": {"Reader": [[25, 30], [104, 109]]}}}, {"text": "But it is supposed to have another field of type Reader, according to its contructors", "label": {"api": {"Reader": [[49, 54]], "its contructors": [[70, 84]]}}}, {"text": "To transform an IntStream to a Stream<Integer> you need to call IntStream.boxed() on your stream", "label": {"api": {"IntStream.boxed()": [[64, 80]]}}}, {"text": "You can simply use Collectors.toMap() to achieve this", "label": {"api": {"Collectors.toMap()": [[19, 36]]}}}, {"text": "Singe you are talking about pseudofiles on /sys virtual filesystem, it's unlikely that the standard WatchService will work for them", "label": {"api": {"WatchService": [[100, 111]]}}}, {"text": "PriorityQueue in java gets the addAll method from the AbstractQueue", "label": {"api": {"PriorityQueue": [[0, 12]], "AbstractQueue": [[54, 66]]}}}, {"text": "YourTestClass.class.getResource(\"filename\") orYourTestClass.class.getResourceAsStream(\"filename\") is what you should use", "label": {"api": {"YourTestClass.class.getResource(\"filename\")": [[0, 42]], "YourTestClass.class.getResourceAsStream(\"filename\")": [[46, 96]]}}}, {"text": "I would suggest using a LinkedHashMap (which also supports the insertion order of the entries) instead of List<Pair<>>", "label": {"api": {"LinkedHashMap": [[24, 36]]}}}, {"text": "Beside that, if you also want to remove duplicates of B you can use a LinkedHashSet (which also keeps the order) for that", "label": {"api": {"LinkedHashSet": [[70, 82]]}}}, {"text": "To do this, I thought I had to change the initModality of that alert window (https://docs.oracle.com/javafx/2/api/javafx/stage/Stage.html see 'Modality')", "label": {"api": {"https://docs.oracle.com/javafx/2/api/javafx/stage/Stage.html": [[77, 136]]}}}, {"text": "JMS 1.1 does support durable subscriptions, you simply need to look at the API docs to find out how, here's one method that would create a durable Topic subscriber", "label": {"api": {"API docs": [[75, 82]], "method": [[112, 117]]}}}, {"text": "Ok, found the missing module, it was jdk.crypto.ec", "label": {"api": {"jdk.crypto.ec": [[37, 49]]}}}, {"text": "We have the DayOfWeek enum defining the days of the week in standard ISO 8601 order", "label": {"api": {"DayOfWeek": [[12, 20]]}}}, {"text": "I want a List of those objects in the order appropriate to a Locale", "label": {"api": {"List": [[9, 12]], "Locale": [[61, 66]]}}}, {"text": "Set up the List", "label": {"api": {"List": [[11, 14]]}}}, {"text": "You can use the plus method of DayOfWeek", "label": {"api": {"plus": [[16, 19]]}}}, {"text": "Increment numbers with IntStream and its range method (inclusive start, exclusive end)", "label": {"api": {"IntStream": [[23, 31]], "range": [[41, 45]]}}}, {"text": "I don’t know a way to do it in JavaFX, but you can use Java2D to do it", "label": {"api": {"Java2D": [[55, 60]]}}}, {"text": "So you are effectively calling base Object.toString implementation, which is useless", "label": {"api": {"Object.toString": [[36, 50]]}}}, {"text": "In particular, extend JViewport to draw a gradient in exactly the same manner you would with any other JComponent", "label": {"api": {"JViewport": [[22, 30]]}}}, {"text": "Then call setViewport() on your JScrollPane with an instance of your new class as the argument", "label": {"api": {"setViewport()": [[10, 22]]}}}, {"text": "You can use the String.split() method", "label": {"api": {"String.split()": [[16, 29]]}}}, {"text": "If you don't have length variable you can find it with a loop and use new String(char[], int, int) constructor", "label": {"api": {"new String(char[], int, int)": [[70, 97]]}}}, {"text": "Use the constructor that takes a collection", "label": {"api": {"the constructor that takes a collection": [[4, 42]]}}}, {"text": "and the API documentation on String.getBytes()", "label": {"api": {"String.getBytes()": [[29, 45]]}}}, {"text": "Here is the java version 8 javadoc for Stack class", "label": {"api": {"java version 8 javadoc for Stack class": [[12, 49]]}}}, {"text": "You have to use the Class.isInstance method", "label": {"api": {"Class.isInstance": [[20, 35]]}}}, {"text": "I do not suggest to do it manually, you could use a CountDownLatch with init value 1 provided in jdk", "label": {"api": {"CountDownLatch": [[52, 65]]}}}, {"text": "You can let the readers calls await, and let the writer calls countDown once data is prepared", "label": {"api": {"await": [[30, 34]], "countDown": [[62, 70]]}}}, {"text": "when looking at class DecimalFormatSymbols, method .getPercent() simply returns a % sign..", "label": {"api": {"DecimalFormatSymbols": [[22, 41]]}}}, {"text": "This will use the EntityManager.find which should take the mapping information into account and create the appropriate query", "label": {"api": {"EntityManager.find": [[18, 35]]}}}, {"text": "Asynchronous client using CompletableFuture in the back", "label": {"api": {"CompletableFuture": [[26, 42]]}}}, {"text": "The toString() result you are seeing is just Object's default toString implementation", "label": {"api": {"Object's default toString implementation": [[45, 84]]}}}, {"text": "The method .getCanonicalName() will return a fully qualified class name including the package prefix, but there are other methods available", "label": {"api": {".getCanonicalName()": [[11, 29]], "other methods available": [[116, 138]]}}}, {"text": "You can test an annotation is present on a Class object using the .getAnnotation(Class<A> annotationType) method of the Class, where A is a generic type parameter just as T usually is", "label": {"api": {".getAnnotation(Class<A> annotationType)": [[66, 104]]}}}, {"text": "You are trying to find instances of ApplicationConfiguration directly, on an array of type Map.Entry<K,V>[] produced by Map#entrySet() and a subsequent call to Set#toArray()", "label": {"api": {"Map#entrySet()": [[120, 133]], "Set#toArray()": [[160, 172]]}}}, {"text": "Although you could accomplish this with a loop and check every time it changes the type increase a counter, I would personally use a String#replaceAll with regex here", "label": {"api": {"String#replaceAll": [[133, 149]]}}}, {"text": "You can do this by defining columnDefinition for the column in your entity", "label": {"api": {"columnDefinition": [[28, 43]]}}}, {"text": "This also applies if you use AttributeConverters to map your MySQL enum to a Java enum", "label": {"api": {"AttributeConverters": [[29, 47]]}}}, {"text": "If you are in Java-EE environment the be TimerService would be a good idea.It can be implemented with TimerService.createSingleActionTimer()", "label": {"api": {"TimerService": [[41, 52], [102, 113]]}}}, {"text": "java.util.Timer is supported by Scala.js, and provides exactly the functionality you're describing", "label": {"api": {"java.util.Timer": [[0, 14]]}}}, {"text": "If that doesn't work for you, I recommend you taking a look at Java Properties class", "label": {"api": {"Java Properties class": [[63, 83]]}}}, {"text": "You can get a list of all available properties in the file by key or by (key,value)", "label": {"api": {"by key": [[59, 64]], "by (key,value)": [[69, 82]]}}}, {"text": "I, along with the Java language architects, agree with you that Stream#flatMap for a Stream<Optional<T>> isn't readable in Java 8, which is why they introduced Optional#stream in Java 9", "label": {"api": {"Optional#stream": [[160, 174]]}}}, {"text": "Using Java 11, you can utilize String#repeat for an efficient solution that uses a single for-loop", "label": {"api": {"String#repeat": [[31, 43]]}}}, {"text": "You can do this using Matcher", "label": {"api": {"Matcher": [[22, 28]]}}}, {"text": "Obviously improvements can be made such as storing the compiled Pattern somewhere sensible", "label": {"api": {"Pattern": [[64, 70]]}}}, {"text": "You can read about this in ExecutorService documentation", "label": {"api": {"ExecutorService": [[27, 41]]}}}, {"text": "For that purpose you have andThen", "label": {"api": {"andThen": [[26, 32]]}}}, {"text": "You can compose them with andThen as follows", "label": {"api": {"andThen": [[26, 32]]}}}, {"text": "According to the specification, getBytes() encodes the string using the platform's default charset, which is different from Java's internal encoding, UTF-16", "label": {"api": {"specification": [[17, 29]]}}}, {"text": "BTW, if you are using Java 1.8, you can use the new String.codePoints API, which returns a IntStream", "label": {"api": {"String.codePoints": [[52, 68]]}}}, {"text": "Optional#isEmpty() is a Java 11 method, which is a shortcut for Java 8's !Optional#isPresent()", "label": {"api": {"Optional#isEmpty()": [[0, 17]], "!Optional#isPresent()": [[73, 93]]}}}, {"text": "You can use Optional.filter() with Stream.anyMatch() and Optional.isPresent()", "label": {"api": {"Optional.filter()": [[12, 28]], "Stream.anyMatch()": [[35, 51]], "Optional.isPresent()": [[57, 76]]}}}, {"text": "As of Java 9, you can use CompletableFuture.orTimeout", "label": {"api": {"CompletableFuture.orTimeout": [[26, 52]]}}}, {"text": "The CharSequence interface gained a new static method in Java 11", "label": {"api": {"CharSequence": [[4, 15]]}}}, {"text": "the value 0 if the two CharSequence are equal; a negative integer if the first CharSequence is lexicographically less than the second; or a positive integer if the first CharSequence is lexicographically greater than the second", "label": {"api": {"CharSequence": [[23, 34], [79, 90], [170, 181]]}}}, {"text": "That sounds just like compareTo of Comparable", "label": {"api": {"compare": [[22, 28]], "compareTo": [[22, 30]], "Comparable": [[35, 44]]}}}, {"text": "Yet the Java team obviously chose to not make CharSequence extend Comparable", "label": {"api": {"CharSequence": [[46, 57]], "Comparable": [[66, 75]]}}}, {"text": "➥ What is it about CharSequence::compare that would not be an appropriate fit for Comparable::compareTo", "label": {"api": {"CharSequence": [[19, 30]], "compare": [[33, 39], [94, 100]], "compareTo": [[94, 102]], "Comparable": [[82, 91]]}}}, {"text": "Adding Comparable<CharSequence> wouldn't really work since String implements CharSequence and Comparable<String>", "label": {"api": {"String": [[59, 64], [105, 110]], "CharSequence": [[18, 29], [77, 88]], "Comparable<String>": [[94, 111]]}}}, {"text": "A method reference of the form CharSequence::compare would be suitable as a Comparator", "label": {"api": {"CharSequence": [[31, 42]], "CharSequence::compare": [[31, 51]], "Comparator": [[76, 85]]}}}, {"text": "An example of such a design decision can be found in class Queue, which works in two modes when e.g., trying to remove an element from an empty queue", "label": {"api": {"Queue": [[59, 63]]}}}, {"text": "To get the icon you use the getDesktopIcon() method on the JInternalFrame class", "label": {"api": {"getDesktopIcon()": [[28, 43]]}}}, {"text": "You can use EnumSet#allOf to get all the values in the enum, and remove the used ones from it", "label": {"api": {"EnumSet#allOf": [[12, 24]]}}}, {"text": "As Date class is deprecated and holds actual date and time, you could use LocalDateTime as your field in Order class", "label": {"api": {"LocalDate": [[74, 82]]}}}, {"text": "Then you could group your orders by LocalDate taken from LocalDateTime", "label": {"api": {"LocalDate": [[36, 44], [57, 65]]}}}, {"text": "LocalDate holds year, month and day without time", "label": {"api": {"LocalDate": [[0, 8]]}}}, {"text": "You should use DecimalFormat.parse() instead of DecimalFormat.format()", "label": {"api": {"DecimalFormat.parse()": [[15, 35]], "DecimalFormat.format()": [[48, 69]]}}}, {"text": "If it is possible, you can use BigDecimal.longValue() or BigDecimal.longValueExact() to convert the BigDecimals to long values to use them in your calculation", "label": {"api": {"BigDecimal.longValue()": [[31, 52]], "BigDecimal.longValueExact()": [[57, 83]]}}}, {"text": "Assuming that you want to create a LocalDate object from a String, such as \"01-JAN-19\", you'll have to use a DateTimeFormatterBuilder and invoke DateTimeFormatterBuilder#parseCaseInsensitive (because the month in your example is uppercase)", "label": {"api": {"DateTimeFormatterBuilder": [[109, 132], [145, 168]], "DateTimeFormatterBuilder#parseCaseInsensitive": [[145, 189]]}}}, {"text": "Since JDBC 4.2 get a LocalDate at once", "label": {"api": {"LocalDate": [[21, 29]]}}}, {"text": "Note the use of getObject rather than getString or getDate", "label": {"api": {"getObject": [[16, 24]]}}}, {"text": "Instead of converting ArrayList into array int[], use List.size() method in order to get number of elements in the list", "label": {"api": {"List.size()": [[54, 64]]}}}, {"text": "You can check for null values using wasNull() method of ResultSet.For example like below", "label": {"api": {"wasNull()": [[36, 44]]}}}, {"text": "getText is inherted from JTextComponent, and it never returns null", "label": {"api": {"getText": [[0, 6]]}}}, {"text": "If you want to check for an empty JTextField, use isEmpty (or, depending on your use case, isBlank)", "label": {"api": {"isEmpty": [[50, 56]], "isBlank": [[91, 97]]}}}, {"text": "Also, close your result set when finished using it", "label": {"api": {"close your result set": [[6, 26]]}}}, {"text": "Even better, use try-with-resources to automatically close your result set", "label": {"api": {"close your result set": [[53, 73]]}}}, {"text": "Convert the array to an List and use contains()", "label": {"api": {"contains()": [[37, 46]]}}}, {"text": "If you want to easily check for multiple keywords you can instead use Collections.disjoint()", "label": {"api": {"Collections.disjoint()": [[70, 91]]}}}, {"text": "You can use real ints, with IntStream", "label": {"api": {"IntStream": [[28, 36]]}}}, {"text": "IntStream.range(1, 6) would be equivalent, 6 being the exclusive upper bound", "label": {"api": {"IntStream": [[0, 8]]}}}, {"text": "You don't need to change it manually, you can use a PseudoClass", "label": {"api": {"PseudoClass": [[52, 62]]}}}, {"text": "It looks like CheckBoxTreeCell doesn't have a built-in \"checked\" pseudo-class, you can add a \"checked\" PseudoClass and apply it when the tree cell is checked", "label": {"api": {"PseudoClass": [[103, 113]]}}}, {"text": "You can use the Logger::getHandlers method to acquire all of the install handlers for the given logger", "label": {"api": {"Logger::getHandlers": [[16, 34]]}}}, {"text": "You can convert the input into shapes, and then use the Area#add method to compute the merged shape", "label": {"api": {"Area#add": [[56, 63]]}}}, {"text": "Use Map.getOrDefault(Object key, V defaultValue)", "label": {"api": {"Map.getOrDefault(Object key, V defaultValue)": [[4, 47]]}}}, {"text": "As an alternative to the for-loop you might try to resolve this issue using stream api", "label": {"api": {"stream api": [[76, 85]]}}}, {"text": "use Comparator to find sublist with minimum element among maximum elements", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "You can even make code shorter by using Comparator::comparing method", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "Throw an exception using the Optional::orElseThrow allows the method terminates the method and throws an Exception", "label": {"api": {"Optional::orElseThrow": [[29, 49]]}}}, {"text": "You can just use List.forEach()", "label": {"api": {"List.forEach()": [[17, 30]]}}}, {"text": "If you are just looking for a util method you can use Math.negateExact()", "label": {"api": {"Math.negateExact()": [[54, 71]]}}}, {"text": "Internally Math.negateExact() uses just -", "label": {"api": {"Math.negateExact()": [[11, 28]]}}}, {"text": "I recommend streaming the List and then using Stream#filter to filter through any elements that contain the letter 'C'", "label": {"api": {"Stream#filter": [[46, 58]]}}}, {"text": "If you want the hex number the default toString() method prints, call System.identityHashCode()", "label": {"api": {"System.identityHashCode()": [[70, 94]]}}}, {"text": "In case of Queue, you just extend a AbstractQueue class, overriding its offer method", "label": {"api": {"AbstractQueue": [[36, 48]]}}}, {"text": "Give the JTextArea an initial size by using the constructor that takes the number of rows and columns, e.g", "label": {"api": {"constructor": [[48, 58]]}}}, {"text": "You can use the DateFormat class to convert your String to a Date object", "label": {"api": {"DateFormat": [[16, 25]], "Date": [[16, 19], [61, 64]]}}}, {"text": "The easiest way to do addition or subtraction is using the Calendar class", "label": {"api": {"Calendar": [[59, 66]]}}}, {"text": "You can convert the Date object to a Calendar object and do the calculation", "label": {"api": {"Date": [[20, 23]], "Calendar": [[37, 44]]}}}, {"text": "Keep in mind the Calendar object won't keep the time information, but that doesn't seem to be an issue with your problem", "label": {"api": {"Calendar": [[17, 24]]}}}, {"text": "The simplest approach is to use ChronoUnit#between method", "label": {"api": {"ChronoUnit#between": [[32, 49]]}}}, {"text": "Also be aware that Swing is not safe for use by multiple threads", "label": {"api": {"Swing is not safe for use by multiple threads": [[19, 63]]}}}, {"text": "You should be using javax.swing.Timer instead of java.util.Timer, since it properly executes its tasks in the AWT event dispatch thread", "label": {"api": {"javax.swing.Timer": [[20, 36]]}}}, {"text": "Unfortunately, java-stream doesn't provide a straightforward way to change the Map values without violating the Side-effects principle", "label": {"api": {"Side-effects": [[112, 123]]}}}, {"text": "Side-effects in behavioral parameters to stream operations are, in general, discouraged, as they can often lead to unwitting violations of the statelessness requirement, as well as other thread-safety hazards", "label": {"api": {"Side-effects": [[0, 11]]}}}, {"text": "Note the usage of withZoneSameInstant here, e.g", "label": {"api": {"withZoneSameInstant": [[18, 36]]}}}, {"text": "In Java 8, you can use ZonedDateTime to convert LocalDateTime with respect to a specific ZoneId", "label": {"api": {"ZonedDateTime": [[23, 35]], "LocalDateTime": [[48, 60]], "ZoneId": [[89, 94]]}}}, {"text": "One way to make your changes to the Graphics temporary is by creating a new Graphics object, using Graphics.create, then apply your changes to that", "label": {"api": {"Graphics.create": [[99, 113]]}}}, {"text": "If you do this, you are responsible for deallocating the Graphics object by calling its dispose method", "label": {"api": {"dispose": [[88, 94]]}}}, {"text": "Streams are Java's parallel of LINQ", "label": {"api": {"Streams": [[0, 6]]}}}, {"text": "From the output it looks like flogger is using SimpleFormatter from JUL", "label": {"api": {"SimpleFormatter": [[47, 61]]}}}, {"text": "The formatter arguments are described in SimpleFormatter::format method", "label": {"api": {"SimpleFormatter": [[41, 55]], "SimpleFormatter::format": [[41, 63]]}}}, {"text": "The syntax of the date formatting is described in java.util.Formatter", "label": {"api": {"java.util.Formatter": [[50, 68]]}}}, {"text": "You could use java.util.Objects#equals(Object, Object) to clean up your code, and seemless handle null-safe equality checks", "label": {"api": {"java.util.Objects#equals(Object, Object)": [[14, 53]]}}}, {"text": "Use an absolute path or specify one of the FileHandler special components", "label": {"api": {"FileHandler special components": [[43, 72]]}}}, {"text": "You can use DecimalFormat to format your number", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "This uses DecimalFormatSymbols to add the + for the exponent if needed (value > 1 or value < -1)", "label": {"api": {"DecimalFormat": [[10, 22]]}}}, {"text": "If order doesn't matter, just use Set", "label": {"api": {"Set": [[34, 36]]}}}, {"text": "Set will filter out duplicate element automatically", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "You have some options such as ROUND_HALF_EVEN and you need to decide which rounding mode to use", "label": {"api": {"ROUND_HALF_EVEN": [[30, 44]]}}}, {"text": "You can use the java.swing.Timer, like this", "label": {"api": {"java.swing.Timer": [[16, 31]]}}}, {"text": "You can, however, access these entries through the URL returned by Class#getResource(String) or the InputStream returned by Class#getResourceAsStream(String)", "label": {"api": {"Class#getResource(String)": [[67, 91]], "Class#getResourceAsStream(String)": [[124, 156]], "URL": [[51, 53]]}}}, {"text": "Note the latter basically just finds the URL and, if it exists, calls URL#openStream()", "label": {"api": {"URL": [[41, 43], [70, 72]]}}}, {"text": "resources) with the URL is due to the JarURLConnection and related classes; I won't go into detail about how URLs are handled by Java as that's out of scope for this answer", "label": {"api": {"JarURLConnection": [[38, 53]], "URL": [[20, 22], [41, 43], [109, 111]]}}}, {"text": "Use Image#<init>(String) where the argument URL has no scheme", "label": {"api": {"URL": [[44, 46]]}}}, {"text": "In this case the class will treat the URL as a path relative to the root of the classpath and try to access the image accordingly", "label": {"api": {"URL": [[38, 40]]}}}, {"text": "Basically, the argument is the same argument you'd give to Class#getResource(String), except that the path must be absolute (i.e", "label": {"api": {"Class#getResource(String)": [[59, 83]]}}}, {"text": "All URLs supported by URL can be passed to the constructor", "label": {"api": {"URL": [[4, 6], [22, 24]]}}}, {"text": "If the passed string is not a valid URL, but a path instead, the Image is searched on the classpath in that case", "label": {"api": {"URL": [[36, 38]]}}}, {"text": "If you're using modules then resource encapsulation comes into play when using this option", "label": {"api": {"resource encapsulation": [[29, 50]]}}}, {"text": "Use the same constructor as used above but pass a valid URL (i.e", "label": {"api": {"URL": [[56, 58]]}}}, {"text": "When using a resource, you can simply convert the URL returned by Class#getResource(Sring) into a String using URL#toExternalForm()", "label": {"api": {"URL": [[50, 52], [111, 113]], "URL#toExternalForm()": [[111, 130]]}}}, {"text": "You can also use URL#toString() which returns the same value", "label": {"api": {"URL": [[17, 19]]}}}, {"text": "Here you can use Class#getResourceAsStream(String)", "label": {"api": {"Class#getResourceAsStream(String)": [[17, 49]]}}}, {"text": "However, when using resources in an application you should stick with Class#getResource(String) and related methods", "label": {"api": {"Class#getResource(String)": [[70, 94]]}}}, {"text": "Runnable is interface, you are creating an anonymous class which implements the Runnable interface", "label": {"api": {"Runnable": [[0, 7], [80, 87]]}}}, {"text": "Sorting and related events in a JTable are handled by a RowSorter", "label": {"api": {"RowSorter": [[56, 64]]}}}, {"text": "They can be set using JTable.setRowSorter", "label": {"api": {"RowSorter": [[32, 40]], "JTable.setRowSorter": [[22, 40]]}}}, {"text": "A RowSorter allows you to listen to sorting events, by subscribing a listener using RowSorter.addRowSorterListener", "label": {"api": {"RowSorter": [[2, 10], [84, 92], [97, 105]], "RowSorter.addRowSorterListener": [[84, 113]], "RowSorterListener": [[97, 113]]}}}, {"text": "This listener is of interface RowSorterListener, the listener method receives an instance of RowSorterEvent", "label": {"api": {"RowSorter": [[30, 38], [93, 101]], "RowSorterListener": [[30, 46]], "RowSorterEvent": [[93, 106]]}}}, {"text": "When the Type of this event is Sorted, this indicates that", "label": {"api": {"Type": [[9, 12]], "Sorted": [[31, 36]]}}}, {"text": "Use plusMonths to go into the next month, then use withDayOfMonth to set a random day between 1 and lengthOfMonth", "label": {"api": {"plusMonths": [[4, 13]], "withDayOfMonth": [[51, 64]], "lengthOfMonth": [[100, 112]]}}}, {"text": "I think you can use the Java 8 static comparing function that includes the key comparator to achieve this", "label": {"api": {"comparing function that includes the key comparator": [[38, 88]]}}}, {"text": "String has a handy case insensitive comparator that you can use in a few places as well", "label": {"api": {"case insensitive comparator": [[19, 45]]}}}, {"text": "The key method is Collectors.groupingBy with classifier describing the key and the downstream defining a value, which would be a sum of quantities, hence Collectors.summingInt (depends on the quantity type)", "label": {"api": {"Collectors.groupingBy": [[18, 38]], "Collectors.summingInt": [[154, 174]]}}}, {"text": "The desired structure is List<Order>, therefore you want to use the Collectors.collectingAndThen method with a Collector<T, A, R> downstream and Function<R, RR> finisher", "label": {"api": {"Collectors.collectingAndThen": [[68, 95]]}}}, {"text": "You can just use Stream.flatMap() twice", "label": {"api": {"Stream.flatMap()": [[17, 32]]}}}, {"text": "I think ReentrantReadWriteLock is just what I need", "label": {"api": {"ReentrantReadWriteLock": [[8, 29]]}}}, {"text": "Instead of a TableColumnModelListener, you can add a property listener to each individual TableColumn whose size interests you", "label": {"api": {"add a property listener": [[47, 69]]}}}, {"text": "You must iterate through all entries in the ZipFile, and check whether each one matches", "label": {"api": {"all entries": [[25, 35]]}}}, {"text": "If it’s the latter case, you can simplify the code using a Stream", "label": {"api": {"Stream": [[59, 64]]}}}, {"text": "I have a shared resource for which I would like to know how many other objects are still using this resource", "label": {"api": {"source": [[18, 23], [102, 107]]}}}, {"text": "Since ReferenceQueues do not keep track of the references registered for them (source, section \"Notification\"), my idea was to store the reference as field of the tracked object", "label": {"api": {"source": [[79, 84]]}}}, {"text": "In particular I am interested in the identity hash code of the caller object", "label": {"api": {"identity hash code": [[37, 54]]}}}, {"text": "As explained in ForkJoinTask.html#getSurplusQueuedTaskCount(), it’s a reasonable strategy to split work such that there are a few additional tasks per worker, to be potentially picked up by other threads, which may compensate unbalanced workloads, e.g", "label": {"api": {"ForkJoinTask.html#getSurplusQueuedTaskCount()": [[16, 60]]}}}, {"text": "Otherwise Files.list will do", "label": {"api": {"Files": [[10, 14]]}}}, {"text": "For this particular use case you probably want to use StringJoiner, unless your goal is to have a leading space in the result", "label": {"api": {"StringJoiner": [[54, 65]]}}}, {"text": "or use Collectors.joining()", "label": {"api": {"Collectors.joining()": [[7, 26]]}}}, {"text": "String does have a default constructor to create an empty string", "label": {"api": {"String does have a default constructor": [[0, 37]]}}}, {"text": "Array contains only static methods and shouldn't be instantiated for any reason", "label": {"api": {"Array contains only static methods": [[0, 33]]}}}, {"text": "This might be what you need using Optional", "label": {"api": {"Optional": [[34, 41]]}}}, {"text": "That's why I used this behavior with the Optional", "label": {"api": {"Optional": [[41, 48]]}}}, {"text": "document.getElementsByTagName(tagname) searches all the Elements contained in the document", "label": {"api": {"document.getElementsByTagName(tagname)": [[0, 37]]}}}, {"text": "element.getElementsByTagName(name) searches all descendant Elements, i.e", "label": {"api": {"element.getElementsByTagName(name)": [[0, 33]]}}}, {"text": "FileInputStream#read() reads a single byte of information from the underlying file", "label": {"api": {"FileInputStream#read()": [[0, 21]]}}}, {"text": "Since these files are text files (according to their extensions), you probably should be using a FileInputStream, but a FileReader, to properly handle characters, and not the bytes that make them up", "label": {"api": {"FileReader": [[120, 129]]}}}, {"text": "You try to add the items to (I guess) a common implementation ArrayList or List which is not thread safe and causes the ConcurrentModificationException which is thrown upon modifying (add/delete) a structure on which is not optimized to do so", "label": {"api": {"ConcurrentModificationException": [[120, 150]]}}}, {"text": "I recommend using the Collections.synchronizedList wrapper", "label": {"api": {"Collections.synchronizedList": [[22, 49]]}}}, {"text": "If you workload is computationally intensive (CPU bound) you might want to look into ForkJoinPool which implements worker stealing", "label": {"api": {"ForkJoinPool": [[85, 96]]}}}, {"text": "A ForkJoinPool differs from other kinds of ExecutorService mainly by virtue of employing work-stealing", "label": {"api": {"ForkJoinPool": [[2, 13]]}}}, {"text": "You should use a ConcurrentHashMap if your map can be accessed by multiple Threads", "label": {"api": {"ConcurrentHashMap": [[17, 33]]}}}, {"text": "Or you can use String::join method", "label": {"api": {"String::join": [[15, 26]]}}}, {"text": "As fabian said, I would throw the controller into Scene#userData", "label": {"api": {"Scene#userData": [[50, 63]]}}}, {"text": "As found in Javadoc newScheduledThreadPool(int) there always will be the specified amount of threads", "label": {"api": {"newScheduledThreadPool(int)": [[20, 46]]}}}, {"text": "While the JavaDocs for Executors.newFixedThreadPool explicitly mention this", "label": {"api": {"Executors.newFixedThreadPool": [[23, 50]]}}}, {"text": "there is no such strong guarantee about the Executors.newScheduledThreadPool", "label": {"api": {"Executors.newScheduledThreadPool": [[44, 75]]}}}, {"text": "The important part is that the class has to implement the interface Serializable", "label": {"api": {"Serializable": [[68, 79]]}}}, {"text": "If you don't want the list to contain Strings, that is also possible as long as the generic type (the type that replaces String) also implements Serializable (many classes like List, String, and many als do this)", "label": {"api": {"Serializable": [[145, 156]]}}}, {"text": "What these pairs buy us is that we can put them in a PriorityQueue", "label": {"api": {"PriorityQueue": [[53, 65]]}}}, {"text": "Create a Polygon and use the contains(int x, int y) inside a loop to figure out which pixels should be white and which should be black", "label": {"api": {"Polygon": [[9, 15]]}}}, {"text": "Create a BufferedImage, and use createGraphics() to draw the correct colors to the image", "label": {"api": {"BufferedImage": [[9, 21]]}}}, {"text": "Finally, check How to save a BufferedImage as a File for help with outputting the image file", "label": {"api": {"BufferedImage": [[29, 41]]}}}, {"text": "Also, because you're not using regex, you should use replace() rather than replaceAll(), ie", "label": {"api": {"replace()": [[53, 61]], "replaceAll()": [[75, 86]]}}}, {"text": "replace() still replaces all occurrences", "label": {"api": {"replace()": [[0, 8]]}}}, {"text": "Since Java 9 you can use IntStream.iterate() to achieve that", "label": {"api": {"IntStream.iterate()": [[25, 43]]}}}, {"text": "Consider using flatMap() which would produce empty stream for beginning of the pair and a single-entry stream for the end of the pair", "label": {"api": {"flatMap()": [[15, 23]]}}}, {"text": "In Java, Optional is used to save us from NullPointerException cases, by using it as", "label": {"api": {"Optional": [[9, 16]]}}}, {"text": "Oracle docs says the lock maps to native locking of underlying OS and hence visible to all programs", "label": {"api": {"Oracle docs": [[0, 10]]}}}, {"text": "Rather than scaling the Image yourself, let the Graphics do it, by calling the drawImage method which takes width and height arguments", "label": {"api": {"drawImage method which takes width and height arguments": [[79, 133]]}}}, {"text": "If you want to be certain that the equivalent of SCALE_SMOOTH is used to scale the image, set the appropriate RenderingHint", "label": {"api": {"set the appropriate RenderingHint": [[90, 122]]}}}, {"text": "The best solution is to call shutdown on your ExecutorService once you've submitted all your tasks to it", "label": {"api": {"shutdown": [[29, 36]]}}}, {"text": "Alternatively you could create an ExecutorService which uses daemon threads (see the Thread documentation), or a ThreadPoolExecutor with allowCoreThreadTimeout(true), or just call System.exit at the end of your main method", "label": {"api": {"Thread documentation": [[85, 104]], "allowCoreThreadTimeout(true)": [[137, 164]], "System.exit": [[180, 190]]}}}, {"text": "Or as mentioned by @CarlosHeuberger, try java.awt.Toolkit", "label": {"api": {"java.awt.Toolkit": [[41, 56]]}}}, {"text": "There is an overloaded version of indexOf() which takes an index to start the search at", "label": {"api": {"indexOf()": [[34, 42]]}}}, {"text": "According to the Javadoc for java.lang.Class", "label": {"api": {"Javadoc for java.lang.Class": [[17, 43]]}}}, {"text": "You may use the UUID", "label": {"api": {"UUID": [[16, 19]]}}}, {"text": "One attractive option is to use a constructor expression to create the DTO directly", "label": {"api": {"constructor expression to create the DTO directly": [[34, 82]]}}}, {"text": "Since you're using a new Thread to do this concatenation and I can't find any place where you interrupt the thread and you're invoking the Thread.yield()(Thread.yield) to inform the thread scheduler to seize the usage of the CPU for this particular thread and mark the thread is willing to be scheduled as soon as possible again, make pretty much clear this Thread object still lives and refers those String objects not making them garbage eligible", "label": {"api": {"Thread.yield": [[139, 150], [154, 165]]}}}, {"text": "You need to use Stream.flatMap() and create a new stream with the items for each row", "label": {"api": {"Stream.flatMap()": [[16, 31]]}}}, {"text": "ExecutorService#invokeAny looks like a good option", "label": {"api": {"ExecutorService#invokeAny": [[0, 24]]}}}, {"text": "You also may want to look into CompletionService", "label": {"api": {"CompletionService": [[31, 47]]}}}, {"text": "available() doesn't do what you may think it does and it is almost never useful in production code (and that's particularly true for ObjectInputStream)", "label": {"api": {"available()": [[0, 10]]}}}, {"text": "The reason you don't receive any data is in fact that in.available() always returns 0 as you already suspected", "label": {"api": {"available()": [[57, 67]]}}}, {"text": "Use setFixedLengthStreamingMode as per this answer on the duplicate question Denis Tulskiy linked to", "label": {"api": {"setFixedLengthStreamingMode": [[4, 30]]}}}, {"text": "In Netty every EventLoop extends ScheduledExecutorService which means you could schedule a task to run every 5 seconds like this", "label": {"api": {"ScheduledExecutorService": [[33, 56]]}}}, {"text": "You may want to look into String.join", "label": {"api": {"String.join": [[26, 36]]}}}, {"text": "Now I'm trying to implement signatures, using the SignedObject class", "label": {"api": {"SignedObject": [[50, 61]]}}}, {"text": "As a third parameter when creating a new SignedObject, I have to pass a signature algorithm", "label": {"api": {"SignedObject": [[41, 52]]}}}, {"text": "then on the incoming Socket object, you set a read timeout using Socket.setSoTimeout (link) to a reasonable timeout for your purposes", "label": {"api": {"Socket.setSoTimeout (link)": [[65, 90]]}}}, {"text": "Use the integer-based methods such as String::codePointAt and String::codePoints", "label": {"api": {"String::codePointAt": [[38, 56]]}}}, {"text": "From the looks of things, it seems as though it's supposed to be a Scanner instance", "label": {"api": {"Scanner": [[67, 73]]}}}, {"text": "You can find all the digit-letter boundaries and replace them with a space, using replaceAll with this regex", "label": {"api": {"replaceAll": [[82, 91]]}}}, {"text": "And this is possible because the parameter to the Stream.map(...) is", "label": {"api": {"Stream.map(...)": [[50, 64]]}}}, {"text": "Apart from Pattern.CASE_INSENSITIVE, how do I also chose Pattern.MULTILINE in the call to Pattern.compile()", "label": {"api": {"Pattern.compile()": [[90, 106]]}}}, {"text": "You should take a look at LinkedBlockingQueue class", "label": {"api": {"LinkedBlockingQueue class": [[26, 50]]}}}, {"text": "You can use a java.util.function.Consumer<T> object to change an object inside your container where you have all the type safety you get", "label": {"api": {"java.util.function.Consumer<T>": [[14, 43]]}}}, {"text": "You can use CountDownLatch instead of Executors", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "Or you can use CyclicBarrier", "label": {"api": {"CyclicBarrier": [[15, 27]]}}}, {"text": "Main difference is CyclicBarrier can be reset and use again", "label": {"api": {"CyclicBarrier": [[19, 31]]}}}, {"text": "CounDownLatch vs CyclicBarrier", "label": {"api": {"CyclicBarrier": [[17, 29]]}}}, {"text": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeSet.html there is this information", "label": {"api": {"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeSet.html": [[0, 82]]}}}, {"text": "Java's SimpleDateFormat allows you to specify a TimeZone to be used when parsing a String to a Date", "label": {"api": {"SimpleDateFormat": [[7, 22]], "TimeZone": [[48, 55]], "Date": [[13, 16], [95, 98]]}}}, {"text": "The documentation doesn't seem to really explain how the TimeZone is used, either", "label": {"api": {"TimeZone": [[57, 64]]}}}, {"text": "Note how for the first example, the Date changes - but for the second, it does not", "label": {"api": {"Date": [[36, 39]]}}}, {"text": "To get the absolute URLs you can use URI.resolve() with your base URL", "label": {"api": {"URI.resolve()": [[37, 49]]}}}, {"text": "One of possible solution is to match start of the line ^ (with MULTILINE flag (?m)) and then check if after it there is PERS or TASK PERS", "label": {"api": {"MULTILINE": [[63, 71]]}}}, {"text": "However, since the method, LdapTemplate::search returns a List<T>, then you can use a characteristics of any Collection<T> that is convertible to Stream<T> using a simple call of collection.stream() method", "label": {"api": {"collection.stream()": [[179, 197]]}}}, {"text": "6), you can do that with a SpringLayout, but SpringLayout is more complicated and usually isn’t worth the trouble", "label": {"api": {"SpringLayout": [[27, 38], [45, 56]]}}}, {"text": "The method CharSequence::chars returns the IntStream, which of course doesn't provide any method converting to int, such as mapToInt, but mapToObj instead", "label": {"api": {"CharSequence::chars": [[11, 29]], "IntStream": [[43, 51]]}}}, {"text": "Therefore the method IntStream::map(IntUnaryOperator mapper) which both takes returns int as well shall be used since IntUnaryOperator does the same like Function<Integer, Integer> or UnaryOperator<Integer>", "label": {"api": {"IntStream": [[21, 29]], "IntStream::map(IntUnaryOperator mapper)": [[21, 59]], "IntUnaryOperator": [[36, 51], [118, 133]]}}}, {"text": "However, regardless of what you try to achieve, your code is wrong by principle, the NO Stateless behaviors to be exact", "label": {"api": {"NO Stateless behaviors": [[85, 106]]}}}, {"text": "Java has support for java.lang.Process", "label": {"api": {"java.lang.Process": [[21, 37]]}}}, {"text": "This can be used with java.lang.ProcessBuilder or Runtime.exec", "label": {"api": {"java.lang.Process": [[22, 38]], "java.lang.ProcessBuilder": [[22, 45]], "Runtime.exec": [[50, 61]]}}}, {"text": "With object of java.lang.Process", "label": {"api": {"java.lang.Process": [[15, 31]]}}}, {"text": "If you add it, someone won't be able to add more methods without breaking your functional interface and will get a compile time error", "label": {"api": {"functional interface": [[79, 98]]}}}, {"text": "The annotated type satisfies the requirements of a functional interface", "label": {"api": {"functional interface": [[51, 70]]}}}, {"text": "From the docs of matches", "label": {"api": {"the docs of matches": [[5, 23]]}}}, {"text": "You can use Stream.map() to get only the names of your model", "label": {"api": {"Stream.map()": [[12, 23]]}}}, {"text": "Use Stream.filter() to get only the names matching your charAPresent() method", "label": {"api": {"Stream.filter()": [[4, 18]]}}}, {"text": "To log the entries before collecting you can use Stream.peek()", "label": {"api": {"Stream.peek()": [[49, 61]]}}}, {"text": "Instead, try using Paths.get", "label": {"api": {"Paths.get": [[19, 27]]}}}, {"text": "Parse it into an InetAddress, then check its bytes", "label": {"api": {"Parse it into an InetAddress": [[0, 27]], "its bytes": [[41, 49]]}}}, {"text": "But if you really wanted to use a straight collector, you could use the source code of Collections.joining and the Javadoc of StringJoiner as a guide to make a custom collector", "label": {"api": {"the Javadoc of StringJoiner": [[111, 137]]}}}, {"text": "First of all, there's no need to convert the arrays into Lists (since you don't need to use retainAll, which finds all the common elements of the 3 arrays, which is more than you need)", "label": {"api": {"List": [[57, 60]], "retainAll": [[92, 100]]}}}, {"text": "The sorting of the arrays (or Lists) seems necessary to ensure a worst case complexity of O(NlogN)", "label": {"api": {"List": [[30, 33]]}}}, {"text": "Your code should include a custom keystore file as an application resource, which you should pass to Keystore.load", "label": {"api": {"resource": [[66, 73]], "Keystore.load": [[101, 113]]}}}, {"text": "There is a version of toArray that accepts an array as an argument", "label": {"api": {"toArray": [[22, 28]]}}}, {"text": "You want Files.walk", "label": {"api": {"Files.walk": [[9, 18]]}}}, {"text": "Also take a look at java.util.EnumMap", "label": {"api": {"java.util.EnumMap": [[20, 36]]}}}, {"text": "the javadoc of forward", "label": {"api": {"forward": [[15, 21]]}}}, {"text": "forward should be called before the response has been committed to the client (before response body output has been flushed)", "label": {"api": {"forward": [[0, 6]]}}}, {"text": "Uncommitted output in the response buffer is automatically cleared before the forward", "label": {"api": {"forward": [[78, 84]]}}}, {"text": "The only direction i have at this point is getting the original request from the response but could not figure out how to do it as HttpServletResponse does not expose getRequest", "label": {"api": {"HttpServletResponse": [[131, 149]]}}}, {"text": "Should you use a ListArray or a ListLinked", "label": {"api": {"ListArray": [[17, 25]], "ListLinked": [[32, 41]]}}}, {"text": "What would a TokenizerString be", "label": {"api": {"TokenizerString": [[13, 27]]}}}, {"text": "Is a MapTree a tree or a map", "label": {"api": {"MapTree": [[5, 11]]}}}, {"text": "Is a TaskTimer a timer or a task", "label": {"api": {"TaskTimer": [[5, 13]]}}}, {"text": "Is a LoaderService a service", "label": {"api": {"LoaderService": [[5, 17]]}}}, {"text": "What about an ErrorConfigurationService", "label": {"api": {"ErrorConfigurationService": [[14, 38]]}}}, {"text": "You do this by specifying one or more element types as an argument to the @Target annotation - see the API docs of java.lang.annotation.ElementType", "label": {"api": {"java.lang.annotation.ElementType": [[115, 146]]}}}, {"text": "I don't know exactly where your confusion lies, but there exists a Thread constructor which takes a Runnable", "label": {"api": {"there exists": [[52, 63]]}}}, {"text": "That Thread constructor accepts anything that implements Runnable", "label": {"api": {"constructor": [[12, 22]]}}}, {"text": "Call onClose, and document that the returned stream must be closed by caller", "label": {"api": {"onClose": [[5, 11]]}}}, {"text": "Set.remove already returns true if the set contained the specified element", "label": {"api": {"Set.remove": [[0, 9]]}}}, {"text": "Alternatively you could use Stream.peek() for the remove, but be careful with other side effects (see the comments)", "label": {"api": {"Stream.peek()": [[28, 40]]}}}, {"text": "I would take advantage of retainAll", "label": {"api": {"retainAll": [[26, 34]]}}}, {"text": "The answer to that is explained in the proper ExecutorService documentation", "label": {"api": {"ExecutorService documentation": [[46, 74]]}}}, {"text": "Take a look at CountDownLatch", "label": {"api": {"CountDownLatch": [[15, 28]]}}}, {"text": "For a more modern (and compact) code style, you can leverage your predicate method isKey() in a stream operation and return an Optional instead of a possibly null key", "label": {"api": {"Optional": [[127, 134]]}}}, {"text": "With the TemporalAdjusters class you get the methods firstDayOfNextYear(), firstDayOfNextMonth()", "label": {"api": {"TemporalAdjusters": [[9, 25]]}}}, {"text": "Because ArrayIndexOutOfBoundsException extends from IndexOutOfBoundsException, which means the first one is more specific than the second one", "label": {"api": {"ArrayIndexOutOfBoundsException": [[8, 37]], "IndexOutOfBoundsException": [[13, 37], [52, 76]]}}}, {"text": "So if there is an ArrayIndexOutOfBoundsException it is matched to an IndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[18, 47]], "IndexOutOfBoundsException": [[23, 47], [69, 93]]}}}, {"text": "in other words, the catch for ArrayIndexOutOfBoundsException would be unreachable", "label": {"api": {"ArrayIndexOutOfBoundsException": [[30, 59]], "IndexOutOfBoundsException": [[35, 59]]}}}, {"text": "ChronoLocalDateTime.format includes this", "label": {"api": {"ChronoLocalDateTime.format": [[0, 25]]}}}, {"text": "The official javadocs say this about File#isFile()", "label": {"api": {"File#isFile()": [[37, 49]]}}}, {"text": "You can check if it is a directory with File#isDirectory(), then if it is, you can list its contents with File#listFiles()", "label": {"api": {"File#isDirectory()": [[40, 57]], "File#listFiles()": [[106, 121]]}}}, {"text": "The equals implementation of annotations should suffice to ensure the correct component is injected", "label": {"api": {"equals": [[4, 9]]}}}, {"text": "If I go ahead and use newOutputstream method of Files class, it may looks like the following", "label": {"api": {"method": [[38, 43]]}}}, {"text": "Use Collectors.groupingBy together with Collectors.summingInt as a downstream collector", "label": {"api": {"Collectors.groupingBy": [[4, 24]], "Collectors.summingInt": [[40, 60]]}}}, {"text": "For the second approach I would recommend using a Set<String> for a larger list of keys because it has a O(1) time complexity for .contains() because it does not contain any duplicates", "label": {"api": {"Set<String>": [[50, 60]]}}}, {"text": "Any methods not annotated with @Order will be assigned a default order value of Integer.MAX_VALUE which will effectively cause them to appear at the end of the sorted list", "label": {"api": {"Integer.MAX_VALUE": [[80, 96]]}}}, {"text": "For example, Integer.MAX_VALUE has the lowest priority", "label": {"api": {"Integer.MAX_VALUE": [[13, 29]]}}}, {"text": "The problem is that the -splash option takes a file name, but the SplashScreen-Image manifest attribute must refer to a jar entry", "label": {"api": {"the SplashScreen-Image manifest attribute must refer to a jar entry": [[62, 128]]}}}, {"text": "You can use Matche's replaceAll method to replace the matched string", "label": {"api": {"replaceAll": [[21, 30]]}}}, {"text": "You might also be able to use Files.copy(InputStream,Path,CopyOption...) (Java 7+)", "label": {"api": {"Files.copy(InputStream,Path,CopyOption...)": [[30, 71]]}}}, {"text": "If you prefer using NIO channels, you can open a FileChannel directly via FileChannel.open(Path,OpenOption...) rather than going through a FileOutputStream", "label": {"api": {"FileChannel.open(Path,OpenOption...)": [[74, 109]]}}}, {"text": "That's why it has method redirectOutput, for example", "label": {"api": {"redirectOutput": [[25, 38]]}}}, {"text": "No, this does not exist, and cannot exist without violating the contract of ByteBuffer's superclass Buffer", "label": {"api": {"Buffer": [[80, 85], [100, 105]]}}}, {"text": "Therefore, if you were to allow \"seamless dynamic growing\", ByteBuffer would no longer act as a Buffer", "label": {"api": {"Buffer": [[64, 69], [96, 101]]}}}, {"text": "After all, consumers of your HypotheticalGrowingByteBuffer might rely on Buffer's fixed capacity to cache a single call to capacity(), which otherwise would be defined not to change", "label": {"api": {"Buffer": [[52, 57], [73, 78]]}}}, {"text": "Another motivating factor behind making ByteBuffer an abstract class rather than an interface", "label": {"api": {"Buffer": [[44, 49]]}}}, {"text": "That said, Buffer defines a mutable concept of limit, where a large originally-allocated buffer might have its availability artificially constrained", "label": {"api": {"Buffer": [[11, 16]]}}}, {"text": "If the goal is simply to concatenate smaller fixed-size buffers where the overall total size is predictable, it may be worthwhile to generate them as pieces of a larger buffer using ByteBuffer.duplicate and setting the mark and limit to constrain the writable area", "label": {"api": {"Buffer": [[186, 191]], "ByteBuffer.duplicate": [[182, 201]]}}}, {"text": "If so, you’d create a Comparator to sort using the Comparator.comparing method", "label": {"api": {"Comparator.comparing": [[51, 70]]}}}, {"text": "You can also call Collection#sort() directly on the ArrayList", "label": {"api": {"Collection#sort()": [[18, 34]]}}}, {"text": "If you’re always (or usually) going to sort your Appointment objects by date, you might consider making Appointment implement Comparable so that you can call .sort() without passing a Comparator", "label": {"api": {"Comparable": [[126, 135]]}}}, {"text": "read() blocks indefinitely until the process terminates and I do not want to hardcode the length of the expected process output or similar hacks to circumvent this shortcoming", "label": {"api": {"read()": [[0, 5]]}}}, {"text": "Most of us are familiar with binarySearch", "label": {"api": {"binarySearch": [[29, 40]]}}}, {"text": "[After performing a binarySearch] Then you continue iterating linearly until you hit to the end of the equal range", "label": {"api": {"binarySearch": [[20, 31]]}}}, {"text": "I think use Java Attach API", "label": {"api": {"Java Attach API": [[12, 26]]}}}, {"text": "Java Attach API is procedure of loading a Java agent into an already running JVM", "label": {"api": {"Java Attach API": [[0, 14]]}}}, {"text": "you can understand the work of javaagents by reading the Java Instrument javadoc", "label": {"api": {"Java Instrument javadoc": [[57, 79]]}}}, {"text": "For maximum clarity I would suggest encapsulating the low-level predicate into a helper method, and using Stream.allMatch to do the check", "label": {"api": {"Stream.allMatch": [[106, 120]]}}}, {"text": "Comparator.comparingLong is what you need", "label": {"api": {"Comparator.comparingLong": [[0, 23]]}}}, {"text": "ThreadLocal is available from Java 1.2, although remove() method was introduced in 1.5", "label": {"api": {"remove()": [[49, 56]]}}}, {"text": "As per the ConcurrentTaskScheduler.schedule() method currently it does not support Instant Class so you have to try with Date or Trigger type only as second parameter to schedule method", "label": {"api": {"Instant Class": [[83, 95]]}}}, {"text": "get a SeekableChannel into your file, then call the position(long) method to get where you want to read from", "label": {"api": {"SeekableChannel": [[6, 20]], "position(long)": [[52, 65]]}}}, {"text": "The capacity with the default constructor is 10 simply because the docs say so", "label": {"api": {"the docs say so": [[63, 77]]}}}, {"text": "Note that you should almost always override paintComponent rather than paint", "label": {"api": {"paintComponent": [[44, 57]]}}}, {"text": "There is no SortedList in Java, but javafx.base contains a SortedList which wraps a supplied List and keeps is sorted based on a Comparator supplied at instantiation", "label": {"api": {"but javafx.base contains a SortedList": [[32, 68]]}}}, {"text": "The depth parameter is used in exactly the same way as maxDepth is in Files#walkFileTree", "label": {"api": {"Files#walkFileTree": [[70, 87]]}}}, {"text": "don't want to recursively traverse the file tree), then you can use Files#list(Path)", "label": {"api": {"Files#list(Path)": [[68, 83]]}}}, {"text": "I used a three-argument IntStream.iterate overload that is available starting from Java 9", "label": {"api": {"IntStream.iterate": [[24, 40]]}}}, {"text": "It also drops leading 0 values using the Java 9+ method dropWhile", "label": {"api": {"Java 9+ method dropWhile": [[41, 64]]}}}, {"text": "Probably, you should take a look at what substring method does", "label": {"api": {"method": [[51, 56]]}}}, {"text": "Link to the method signature", "label": {"api": {"Link": [[0, 3]], "method": [[12, 17]]}}}, {"text": "Either you can provide the second argument as n or just don't provide the second argument in which case the method will be called", "label": {"api": {"method": [[108, 113]]}}}, {"text": "For input validation, use Objects.requireNonNull instead", "label": {"api": {"Objects.requireNonNull": [[26, 47]]}}}, {"text": "Solve this by using an ObservableList (if you are implementing in Java10+ https://docs.oracle.com/javase/10/docs/api/javafx/collections/ObservableList.html) or by implementing such a List yourself (probably by extending an existing List type)", "label": {"api": {"https://docs.oracle.com/javase/10/docs/api/javafx/collections/ObservableList.html": [[74, 154]]}}}, {"text": "FYI Objects#equals() returns true if both parameters are null", "label": {"api": {"Objects#equals()": [[4, 19]]}}}, {"text": "But according to the official documentation", "label": {"api": {"official documentation": [[21, 42]]}}}, {"text": "I checked the OffsetDateTime.toString() docu, but not sure if that is really where I should be looking..", "label": {"api": {"docu": [[40, 43]]}}}, {"text": "Like the javadoc says about Queue interface", "label": {"api": {"javadoc says about Queue interface": [[9, 42]]}}}, {"text": "And from the LinkedList doc we know that the add method \"appends the specified element to the end of this list\", so calling add/offer will insert an element at the tail of the queue, while remove/poll will get an element from the head", "label": {"api": {"LinkedList doc": [[13, 26]]}}}, {"text": "Note that hashCode() may be the same for two objects that aren't equals(), but two equals() objects must never have a different hashCode()", "label": {"api": {"hashCode() may be the same for two objects that aren't equals(), but two equals() objects must never have a different hashCode()": [[10, 137]]}}}, {"text": "Java 8+ provides a compiler plugin api allowing you to hook into the compilation process at various stages (before/after parse/entry/analysis/code generation)", "label": {"api": {"compiler plugin api": [[19, 37]]}}}, {"text": "The javax.jms.TextMessage is just one of several types of javax.jms.Message implementations supported by JMS", "label": {"api": {"javax.jms.TextMessage": [[4, 24]], "javax.jms.Message": [[58, 74]]}}}, {"text": "I recommend you convert your MMS data into a byte array and send it using a javax.jms.BytesMessage", "label": {"api": {"javax.jms.BytesMessage": [[76, 97]]}}}, {"text": "But since your assignment says you should use one which uses the Comparable interface to compare the objects, you have to use the TreeSet class", "label": {"api": {"TreeSet": [[130, 136]]}}}, {"text": "Now you can create a TreeSet object and add objects to it", "label": {"api": {"TreeSet": [[21, 27]]}}}, {"text": "Even as we have three different Employee objects with different usernames the TreeSet consider them all equal because of the way the compareTo() method is implemented", "label": {"api": {"TreeSet": [[78, 84]]}}}, {"text": "I would rather use javafx.fxml.Initializable to avoid misspelling issue", "label": {"api": {"javafx.fxml.Initializable": [[19, 43]]}}}, {"text": "This is not the recommended approach", "label": {"api": {"This is not the recommended approach": [[0, 35]]}}}, {"text": "You can get the standard offset of a ZoneId by calling getRules() and then getStandardOffset()", "label": {"api": {"getStandardOffset()": [[75, 93]]}}}, {"text": "Calling ArrayList.clear() has no affect whatsoever on the objects it contains", "label": {"api": {"ArrayList.clear()": [[8, 24]]}}}, {"text": "You can either use appropriate locking whenever mutating the state of the ArrayList (synchronized or one of the Lock implementations), you can wrap your ArrayList using Collections.synchronizedList(), or you can switch to a threadsafe collection such as CopyOnWriteArrayList", "label": {"api": {"Lock": [[112, 115]], "Collections.synchronizedList()": [[169, 198]], "CopyOnWriteArrayList": [[254, 273]]}}}, {"text": "the best way is to use String.format like so", "label": {"api": {"String.format": [[23, 35]]}}}, {"text": "Consider instead using ThreadLocalRandom in multithreaded designs", "label": {"api": {"ThreadLocalRandom": [[23, 39]]}}}, {"text": "I would recommend to switch to ThreadLocalRandom instead", "label": {"api": {"ThreadLocalRandom": [[31, 47]]}}}, {"text": "The Array class is an internal Java class containing only public static methods, and its intended use is to not be be directly instantiated", "label": {"api": {"Array": [[4, 8]]}}}, {"text": "fails because testarray is of type Array[], not Array, and therefore does not have the static method get() available", "label": {"api": {"Array": [[35, 39], [48, 52]]}}}, {"text": "Hypothetically speaking, if you could call Array#get on an instance, it should work, but as mentioned above, Array cannot be instantiated", "label": {"api": {"Array": [[43, 47], [109, 113]]}}}, {"text": "A more typical way to use Array would be something like", "label": {"api": {"Array": [[26, 30]]}}}, {"text": "That is, create an array of the desired type, and then use Array#get to access whichever element you want", "label": {"api": {"Array": [[59, 63]]}}}, {"text": "Use the Blocking Queue", "label": {"api": {"Blocking Queue": [[8, 21]]}}}, {"text": "You're on the right track with a while loop, basically, you just need to use scanner.next() when the user enters something other than an integer", "label": {"api": {"scanner.next()": [[77, 90]]}}}, {"text": "I do not know your exact needs, but you could also do this using Class#getEnclosingMethod like that", "label": {"api": {"Class#getEnclosingMethod": [[65, 88]]}}}, {"text": "To add from QuaternionsRock's answer, since it's not tested, you can always use DateFormat", "label": {"api": {"DateFormat": [[80, 89]]}}}, {"text": "There does not need to be two a in the DateFormat string, contrary to what is posted in QuaternionsRock' link", "label": {"api": {"DateFormat": [[39, 48]]}}}, {"text": "I would go for the former (put) since you are not using the message or even trying to merge (I put emphasis on that because of Java 8 and merge method)", "label": {"api": {"merge": [[86, 90], [138, 142]]}}}, {"text": "Call shutdownOputput to match the code in the Go client", "label": {"api": {"shutdownOputput": [[5, 19]]}}}, {"text": "Considering that each of your 4 sections has a different service call, you may utilize ExecutorService#invokeAll to concurrently execute all service calls and then consolidating the result as per your need", "label": {"api": {"ExecutorService#invokeAll": [[87, 111]]}}}, {"text": "If you need to keep a specific order in your map, it is recommended to use a Map implementation like TreeMap", "label": {"api": {"TreeMap": [[101, 107]]}}}, {"text": "The value of maxRows is eventually being set on the created Statement through the corresponding setMaxRows method", "label": {"api": {"setMaxRows": [[96, 105]]}}}, {"text": "You can try to use Java StAX API for this propose", "label": {"api": {"Java StAX API": [[19, 31]]}}}, {"text": "For the toString() method, catching Exception is not necessarily a bad practice", "label": {"api": {"toString()": [[8, 17]]}}}, {"text": "The contract for toString() is", "label": {"api": {"toString()": [[17, 26]]}}}, {"text": "Catch the checked exceptions using their specific exception type, and integrate this fact in the toString() message, instead of propagating it", "label": {"api": {"toString()": [[97, 106]]}}}, {"text": "Of course in order to do that we need to create our own custom TableCellRenderer", "label": {"api": {"TableCellRenderer": [[63, 79]]}}}, {"text": "If this task is too simple to use a Task for then you could try a CompletableFuture, which may make it easier for you to invoke simple things asynchronously", "label": {"api": {"CompletableFuture": [[66, 82]]}}}, {"text": "Yes, you can use Java 8 Streams", "label": {"api": {"Java 8 Streams": [[17, 30]]}}}, {"text": "Collectors#partitionBy is your friend", "label": {"api": {"Collectors#partitionBy": [[0, 21]]}}}, {"text": "Try using the focusedProperty of the Window object (stage inherits this from Window)", "label": {"api": {"focusedProperty": [[14, 28]]}}}, {"text": "Here, specifically, you're calling println(Object)", "label": {"api": {"println(Object)": [[35, 49]]}}}, {"text": "You should also consider using a CountDownLatch instead of synchronizing on an object", "label": {"api": {"CountDownLatch": [[33, 46]]}}}, {"text": "Given JsonArray is a List (source) you can just try to swap the value with erer to be the new first element", "label": {"api": {"source": [[27, 32]]}}}, {"text": "You may want to invest in Math.abs(int)", "label": {"api": {"Math.abs(int)": [[26, 38]]}}}, {"text": "To read contents of the file, you can simply use the BufferedReader and then iterate over every line and print", "label": {"api": {"BufferedReader": [[53, 66]]}}}, {"text": "Date#getTime() returns the number of milliseconds since January 1, 1970, 00:00:00 GMT represented by this Date object", "label": {"api": {"Date#getTime()": [[0, 13]]}}}, {"text": "I believe BigDecimal is usually used in this case", "label": {"api": {"BigDecimal": [[10, 19]]}}}, {"text": "Here's a tutorial I found on using BigDecimal", "label": {"api": {"BigDecimal": [[35, 44]]}}}, {"text": "In Java instances of the Class class represent classes and interfaces in a running Java application", "label": {"api": {"Class": [[25, 29]]}}}, {"text": "You could use Class::isInstance method to determine if object is instance of given type and then apply processing based on this evaluation", "label": {"api": {"Class": [[14, 18]], "Class::isInstance": [[14, 30]]}}}, {"text": "Alternatively (and preferably, in my opinion), you can declare one or more static nested classes of Studenti that implements the Comparator<Studenti> interface", "label": {"api": {"Comparator<Studenti> interface": [[129, 158]]}}}, {"text": "Then to sort the array you can just call Arrays.sort() and pass an instance of the appropriate comparator class", "label": {"api": {"Arrays.sort()": [[41, 53]]}}}, {"text": "Use the split(String, int) version of split()", "label": {"api": {"split(String, int)": [[8, 25]]}}}, {"text": "You could use a ReentrantLock", "label": {"api": {"ReentrantLock": [[16, 28]]}}}, {"text": "The lock will only allow one thread at a time, and its tryLock() method will return immediately with true or false depending on whether the lock was acquired", "label": {"api": {"tryLock()": [[55, 63]]}}}, {"text": "Rather than using some kind of explicit lock, I would suggest you use a blocking queue", "label": {"api": {"blocking queue": [[72, 85]]}}}, {"text": "List.sort() has void as return value, because it sorts the list you are calling sort() on", "label": {"api": {"List.sort()": [[0, 10]]}}}, {"text": "You can use Random.nextInt() for that", "label": {"api": {"Random.nextInt()": [[12, 27]]}}}, {"text": "In Java String.equals() function takes only one parameter, you will need to amend your code like", "label": {"api": {"String.equals()": [[8, 22]]}}}, {"text": "See SimpleDateFormat class JavaDoc for above pattern explanation as well as for information on methods and fields", "label": {"api": {"SimpleDateFormat class JavaDoc": [[4, 33]]}}}, {"text": "In Java, Math.round rounds up/down to closest long value (in mathematics terms, closest whole number)", "label": {"api": {"Math.round": [[9, 18]]}}}, {"text": "Then you can use the methods of Pattern as needed", "label": {"api": {"Pattern": [[32, 38]]}}}, {"text": "And from there you can use the Matcher to do all your extraction of data, stepping through matches, replacements and so on..", "label": {"api": {"Matcher": [[31, 37]]}}}, {"text": "I have gone through with the source code of BigInteger", "label": {"api": {"BigInteger": [[44, 53]]}}}, {"text": "It is internally using the MillerRabin algorithm for the nextProbablePrime method", "label": {"api": {"nextProbablePrime": [[57, 73]]}}}, {"text": "For RSA private keys you should be using PKCS8EncodedKeySpec if your key is encoded in PKCS8 format", "label": {"api": {"PKCS8EncodedKeySpec": [[41, 59]]}}}, {"text": "If you don't care about the order oft the items use a HashSet, otherwise use a LinkedHashSet", "label": {"api": {"HashSet": [[54, 60], [85, 91]], "LinkedHashSet": [[79, 91]]}}}, {"text": "To read the lines you can alternatively use Files.lines()", "label": {"api": {"Files.lines()": [[44, 56]]}}}, {"text": "Without any code, it's going to be hard to make any concrete suggestions but why not just extend whatever class you're using as a writer and add a simple CountDownLatch to it (I'm assuming that reader and writer are running in two different threads) and call countDown() once writing is done", "label": {"api": {"CountDownLatch": [[154, 167]]}}}, {"text": "You are looking for Stream.mapToInt(), which creates an IntStream and IntStream.sum()", "label": {"api": {"Stream.mapToInt()": [[20, 36]], "IntStream": [[56, 64], [70, 78]], "IntStream.sum()": [[70, 84]]}}}, {"text": "You should add BigDecimals using BigDecimal.add() instead of converting them to double and back again to avoid rounding errors", "label": {"api": {"BigDecimal.add()": [[33, 48]]}}}, {"text": "To sum all prices you can use Stream.reduce()", "label": {"api": {"Stream.reduce()": [[30, 44]]}}}, {"text": "From the docs of Stream.reduce()", "label": {"api": {"Stream.reduce()": [[17, 31]]}}}, {"text": "When reading from an InputStream, the read method doesn't return a byte; it returns an int", "label": {"api": {"the read method": [[34, 48]]}}}, {"text": "In that case, you can simply map (\"translate\") each collection item", "label": {"api": {"map": [[29, 31]]}}}, {"text": "The thing is, split() receives as parameter a regular expression", "label": {"api": {"split()": [[14, 20]]}}}, {"text": "You can ensure that parent directories exist by using this method File#mkdirs()", "label": {"api": {"File#mkdirs()": [[66, 78]]}}}, {"text": "Then, computeIfAbsent allows to eliminate the conditional, as it will return an existing value or construct a new value, put and return it", "label": {"api": {"computeIfAbsent": [[6, 20]]}}}, {"text": "null is a special return value indicating that the list is empty", "label": {"api": {"special return value": [[10, 29]]}}}, {"text": "You need to specify that the date is UTC, by specifying a TimeZone using the getTimestamp(String columnLabel, Calendar cal) method", "label": {"api": {"getTimestamp(String columnLabel, Calendar cal)": [[77, 122]]}}}, {"text": "I have tried searching online through other sources and the official Oracle JavaFX 8 Javadocs to at least hint me on what permission I should grant in my policy to allow JavaFX windows to display always on top, however I am out of luck", "label": {"api": {"official Oracle JavaFX 8 Javadocs": [[60, 92]]}}}, {"text": "Pass in a ToIntFunction<T> as a parameter", "label": {"api": {"ToIntFunction<T>": [[10, 25]]}}}, {"text": "I'm trying to find out, what are the methods mark() and reset() of BufferedReader really useful for", "label": {"api": {"BufferedReader": [[67, 80]]}}}, {"text": "I believe there must be some reason why these methods are present in the BufferedReader and other Reader implementations supporting it but I'm unable to make an assumption why", "label": {"api": {"BufferedReader": [[73, 86]]}}}, {"text": "What are mark and reset in BufferedReader?) and couldn't find any explanation why to actually solve these kinds of problems using mark & reset", "label": {"api": {"BufferedReader": [[27, 40]]}}}, {"text": "At the same time I replaced that Base64 class with the standard java's Base64, that was intended to replace several Base64 implementations some ten years ago", "label": {"api": {"Base64": [[33, 38], [71, 76], [116, 121]]}}}, {"text": "Use the replaceAll() method of List, with a suitable UnaryOperator", "label": {"api": {"replaceAll()": [[8, 19]], "List": [[31, 34]], "UnaryOperator": [[53, 65]]}}}, {"text": "You can also use Long.compareUnsigned", "label": {"api": {"Long.compareUnsigned": [[17, 36]]}}}, {"text": "If you need fairness, where you want the longest-waiting thread to acquire the lock next, then you might try one of the explicit Locks from java.util.concurrent.locks, such as ReentrantLock, but read the fine print", "label": {"api": {"ReentrantLock": [[176, 188]]}}}, {"text": "Instead of next() use nextLine()", "label": {"api": {"next()": [[11, 16]], "nextLine()": [[22, 31]]}}}, {"text": "I have a Path object leading to a folder", "label": {"api": {"Path": [[9, 12]]}}}, {"text": "…or the recommended way using Path.of", "label": {"api": {"Path": [[30, 33]], "Path.of": [[30, 36]]}}}, {"text": "I want to create a file named \"whatever.text\" in that folder using Files.newBufferedWriter where I pass a Path object", "label": {"api": {"Path": [[106, 109]], "Files.newBufferedWriter": [[67, 89]]}}}, {"text": "How do I transform my pathToFolder to get a Path object pathToFile", "label": {"api": {"Path": [[44, 47]]}}}, {"text": "You are looking for Path.resolve()", "label": {"api": {"Path.resolve()": [[20, 33]]}}}, {"text": "You can used HttpSession.setAttribute & HttpSession.getAttribute for eg", "label": {"api": {"HttpSession.setAttribute": [[13, 36]], "HttpSession.getAttribute": [[40, 63]]}}}, {"text": "With the disclaimer that there are many different ways to persist data, here is a minimal example using Java Serialization to make the point more concrete", "label": {"api": {"Java Serialization": [[104, 121]]}}}, {"text": "Or when your code deals with times/dates, imagine a functionality that does something only at 29th February - you could wait for 4 years to test it, or instead provide a Clock object to your test that is set to particular date", "label": {"api": {"Clock": [[170, 174]]}}}, {"text": "The Clock class has static methods offering a variety of alternative clocks, to provide a fixed moment, a moment adjusted into the future or the past, or a clock with an altered cadence", "label": {"api": {"Clock": [[4, 8]], "fixed moment": [[90, 101]], "adjusted into the future or the past": [[113, 148]], "clock with an altered cadence": [[156, 184]]}}}, {"text": "There are no overrides of Arrays::sort that take an array of primitives and a lambda as a parameter", "label": {"api": {"Arrays::sort": [[26, 37]]}}}, {"text": "The Arrays class has a bunch of static hashCode(...) methods for arrays of all primitive types", "label": {"api": {"bunch": [[23, 27]]}}}, {"text": "You can query the index of the currently expanded pane using List#indexOf(Object)", "label": {"api": {"List#indexOf(Object)": [[61, 80]]}}}, {"text": "if you compile classes, you can't reuse the same class name over and over so your ClassLoader will eventually eat up all of your RAM before OOME", "label": {"api": {"ClassLoader": [[82, 92]]}}}, {"text": "If you're just looking for a way to add a more dynamic configuration to your program, I would strongly suggest you look at ScriptEngine, which supports ECMAScript (very close to JavaScript) out-of-the-box (if you use Oracle's HotSpot JVM at least)", "label": {"api": {"ScriptEngine": [[123, 134]]}}}, {"text": "It will save you the overhead of writing your own ClassLoader and compiling code", "label": {"api": {"ClassLoader": [[50, 60]]}}}, {"text": "That said, if you still want to continue in that direction, I'm just guessing here to give to a headstart, but you'll probably have to compile a file through a JavaCompiler object and inject the content of the compilation result into a ClassLoader", "label": {"api": {"JavaCompiler": [[160, 171]], "compilation result": [[210, 227]], "ClassLoader": [[236, 246]]}}}, {"text": "Apart from that being a complete try in the dark, you'll also have to define your own ClassLoader, as the defineClass() method is protected", "label": {"api": {"ClassLoader": [[86, 96]], "defineClass()": [[106, 118]]}}}, {"text": "Alternatively, you could also spawn a call to javac using Runtime.exec() and reading bytecode bytes directly from the generated .class, or even maybe generate it directly into the classpath", "label": {"api": {"Runtime.exec()": [[58, 71]]}}}, {"text": "How does it differ from java.awt.Robot", "label": {"api": {"java.awt.Robot": [[24, 37]]}}}, {"text": "The ArrayIndexOutOfBoundsException() is an Exception and what it basically means is that at some point you're trying to access a element of an array with an illegal index", "label": {"api": {"Exception": [[25, 33], [43, 51]]}}}, {"text": "Refer to the ArrayIndexOutOfBoundsException Documentation for more informations", "label": {"api": {"Exception": [[34, 42]], "ArrayIndexOutOfBoundsException Documentation": [[13, 56]]}}}, {"text": "Sounds like a job for a ThreadPoolExecutor, which will create and manage the thread pool for you and also handle passing jobs to do (records to validate and write to the DB) to threads", "label": {"api": {"ThreadPoolExecutor": [[24, 41]]}}}, {"text": "You'd create it with an appropriate BlockingQueue<Runnable> implementation (ArrayBlockingQueue<Runnable>, LinkedBlockingQueue<Runnable>, etc.) along with the thread pool characteristics you want (core size, max size, etc.), then give it Runnable tasks to do", "label": {"api": {"BlockingQueue<Runnable>": [[36, 58], [81, 103], [112, 134]], "ArrayBlockingQueue<Runnable>": [[76, 103]], "LinkedBlockingQueue<Runnable>": [[106, 134]], "Runnable": [[50, 57], [95, 102], [126, 133], [237, 244]]}}}, {"text": "You could use LinkedList or ArrayDeque which implement Deque interface and this interface has stack-like methods pop and push", "label": {"api": {"LinkedList": [[14, 23]], "ArrayDeque": [[28, 37]], "Deque": [[33, 37], [55, 59]]}}}, {"text": "Because LinkedList and ArrayDeque implement this interface, we can use them as if we were using a Stack", "label": {"api": {"LinkedList": [[8, 17]], "ArrayDeque": [[23, 32]], "Deque": [[28, 32]]}}}, {"text": "From the docs of Deque", "label": {"api": {"Deque": [[17, 21]]}}}, {"text": "Deques can also be used as LIFO (Last-In-First-Out) stacks", "label": {"api": {"Deque": [[0, 4]]}}}, {"text": "So as you can see implementations of Deque should be preferred over legacy Stack class", "label": {"api": {"Deque": [[37, 41]]}}}, {"text": "Even better would to be to use UUIDs, since they are more or less guaranteed to be unique", "label": {"api": {"UUIDs": [[31, 35]]}}}, {"text": "PauseTransition should work", "label": {"api": {"PauseTransition": [[0, 14]]}}}, {"text": "Now bind is a protected method, hence it is not allowed to do inputsAreFull.bind()", "label": {"api": {"bind": [[4, 7], [76, 79]]}}}, {"text": "But bind may be called in the anonymous initializer block { ..", "label": {"api": {"bind": [[4, 7]]}}}, {"text": "as the object is not fully initialized at that moment; the code actually being executed in the BooleanBinding constructor (compilier takes care of that), the method bind should not be overridable", "label": {"api": {"bind": [[165, 168]]}}}, {"text": "The items property of ComboBox is an ObservableList", "label": {"api": {"items": [[4, 8]]}}}, {"text": "Use class FXCollections to create an ObservableList and populate the list with the ResultSet data", "label": {"api": {"FXCollections": [[10, 22]], "ResultSet": [[83, 91]]}}}, {"text": "I was reading this question about the differences between Java's Arrays.sort and Arrays.parallelSort, which is a few years old by now", "label": {"api": {"Arrays.sort": [[65, 75]], "Arrays.parallelSort": [[81, 99]]}}}, {"text": "Hence I suggest that you read the file line by line and then split each line on the commas", "label": {"api": {"split": [[61, 65]]}}}, {"text": "The right approach is using the @PostConstruct annotation", "label": {"api": {"@PostConstruct": [[32, 45]]}}}, {"text": "I would like to change the color of a SeparatorMenuItem in my program", "label": {"api": {"SeparatorMenuItem": [[38, 54]]}}}, {"text": "I cannot find any information on it in the JavaFX CSS Reference Guide", "label": {"api": {"JavaFX CSS Reference Guide": [[43, 68]]}}}, {"text": "In Java, if you use the WatchService frameworks to watch the disk for changes, it locks the parents of watched directories, preventing deletion, renaming, etc", "label": {"api": {"WatchService": [[24, 35]]}}}, {"text": "Is it possible to either tell the WatchService to not lock, or is there an alternative API which watches the disk but does not lock any folders", "label": {"api": {"WatchService": [[34, 45]]}}}, {"text": "Once the JavaTimeModule is registered in your ObjectMapper, simply use OffsetDateTime instead of Date", "label": {"api": {"OffsetDateTime": [[71, 84]], "Date": [[77, 80], [97, 100]]}}}, {"text": "The method addAll() expects a list but split() returns an array", "label": {"api": {"addAll()": [[11, 18]], "split()": [[39, 45]]}}}, {"text": "You must use Arrays.asList() to convert the array to a list", "label": {"api": {"Arrays.asList()": [[13, 27]]}}}, {"text": "Java 7 introduced a Throwable (and also Exception and RuntimeException) constructor which allows disabling a writable stack trace and suppression", "label": {"api": {"disabling a writable stack trace and suppression": [[97, 144]]}}}, {"text": "parse the 2019-07-03 12:14:11 date string to a LocalDateTime object, then call toLocalDate() to get the date-only LocalDate value, which would then be the key in your map (Map<LocalDate, List<Integer>>)", "label": {"api": {"LocalDateTime": [[47, 59]], "toLocalDate()": [[79, 91]], "LocalDate": [[47, 55], [81, 89], [114, 122], [176, 184]]}}}, {"text": "If getInvoice_Date() returns a java.util.Date, then you can get the LocalDate value like this", "label": {"api": {"LocalDate": [[68, 76]]}}}, {"text": "You can shorten the code seen in Question by using putIfAbsent", "label": {"api": {"putIfAbsent": [[51, 61]]}}}, {"text": "But if you have only one application that uses this table - you can use local, application specific locks, for example you can create Read/Write java locks on @Service level", "label": {"api": {"Read/Write": [[134, 143]]}}}, {"text": "You can do it cleaner using streams, with Collectors.groupingBy() and Collectors.counting()", "label": {"api": {"Collectors.groupingBy()": [[42, 64]], "Collectors.counting()": [[70, 90]]}}}, {"text": "In Java, you can also stop a program execution by calling System.exit(ret)", "label": {"api": {"System.exit(ret)": [[58, 73]]}}}, {"text": "The utility methods in interface Comparator are very useful to help with these types of operations", "label": {"api": {"Comparator": [[33, 42]]}}}, {"text": "The intention of Stream#forEach is to pass the elements of the stream to a consumer that uses the elements in some way", "label": {"api": {"Stream#forEach": [[17, 30]]}}}, {"text": "Duration.parse() does offer this feature", "label": {"api": {"Duration.parse()": [[0, 15]]}}}, {"text": "If you need to deal with dates instead of time, you can use the equivalent parse method in Period class", "label": {"api": {"Period": [[91, 96]]}}}, {"text": "I went through the documentation of @Lock and LockModeType but I still can't figure out if it covers my case", "label": {"api": {"LockModeType": [[46, 57]]}}}, {"text": "Use a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[6, 22]]}}}, {"text": "From the Swing package documentation", "label": {"api": {"Swing package documentation": [[9, 35]]}}}, {"text": "You'd want to annotate the interface with @FunctionalInterface to document its purpose, and to ensure nobody accidentally adds another method", "label": {"api": {"@FunctionalInterface": [[42, 61]]}}}, {"text": "As mentioned in the comments by Andreas and Stephen C, use method add() of class java.util.ArrayList, e.g", "label": {"api": {"add()": [[66, 70]]}}}, {"text": "Please read the documentation of ArrayList's constructors", "label": {"api": {"the documentation of ArrayList's constructors": [[12, 56]]}}}, {"text": "The constructor that you're calling is the one that receives an integer as argument, which has its capacity defined according to the argument (i.e", "label": {"api": {"the one that receives an integer as argument": [[39, 82]]}}}, {"text": "It's important to differentiate between what calling Stream#mapToInt(ToIntFunction) does and what the ToIntFunction argument does", "label": {"api": {"Stream#mapToInt(ToIntFunction)": [[53, 82]], "ToIntFunction": [[69, 81], [102, 114]]}}}, {"text": "The ToIntFunction argument is how the stream is going to map each element to an int", "label": {"api": {"ToIntFunction": [[4, 16]]}}}, {"text": "Hence the method accepts a ToIntFunction argument that describes how to map the elements to an int on a case-by-case basis", "label": {"api": {"ToIntFunction": [[27, 39]]}}}, {"text": "In other words, you're creating a new ToIntFunction instance and passing it as an argument", "label": {"api": {"ToIntFunction": [[38, 50]]}}}, {"text": "Pattern.compile() is a static method", "label": {"api": {"Pattern.compile()": [[0, 16]]}}}, {"text": "For compareAndSet the documentation says", "label": {"api": {"says": [[36, 39]]}}}, {"text": "In your case the used executor is ForkJoinPool.commonPool() whose documentation says", "label": {"api": {"ForkJoinPool.commonPool()": [[34, 58]]}}}, {"text": "The documentation for File.listFiles() says", "label": {"api": {"File.listFiles()": [[22, 37]]}}}, {"text": "For your use case Files.walkFileTree appears to be well suited", "label": {"api": {"Files.walkFileTree": [[18, 35]]}}}, {"text": "You can use IntStream for this", "label": {"api": {"IntStream": [[12, 20]]}}}, {"text": "IntStream.distinct will skip all duplicate elements and toArray() will then collect the remaining elements in a new array", "label": {"api": {"IntStream": [[0, 8]]}}}, {"text": "Since Java 7 JComboBox is a generic type, which means that when declaring a variable of this type you are expected to perform a generic type invocation by supplying a type argument which represents \"the type of the elements of this combo box\" [from the API]", "label": {"api": {"[from the API]": [[243, 256]]}}}, {"text": "Alternatively, you can get rid of them using the @SuppressWarnings annotation", "label": {"api": {"@SuppressWarnings": [[49, 65]]}}}, {"text": "See also this post for more info on @SuppressWarnings", "label": {"api": {"@SuppressWarnings": [[36, 52]]}}}, {"text": "startsWith is method of String, you need to convert to String first", "label": {"api": {"startsWith": [[0, 9]]}}}, {"text": "And in this case you are weaving together multiple network connections, which previously would require individual threads to wait on, into a single conceptual object (Selector) which only requires a single thread to wait on", "label": {"api": {"Selector": [[167, 174]]}}}, {"text": "In your case you could weave together the entirety of your network connections into a single Selector and wait on that in a single thread", "label": {"api": {"Selector": [[93, 100]]}}}, {"text": "The docs for pollLast mention", "label": {"api": {"pollLast": [[13, 20]]}}}, {"text": "Do not use peek() for this, because it is not called with short-circuiting terminal operations (like findAny())", "label": {"api": {"peek()": [[11, 16]]}}}, {"text": "You could decide to have all the nulls at the beginning or the end of the list, and use Comparator.nullsFirst or Comparator.nullsLast respectively", "label": {"api": {"Comparator.nullsFirst": [[88, 108]], "Comparator.nullsLast": [[113, 132]]}}}, {"text": "Because that's how a HashMap works", "label": {"api": {"HashMap": [[21, 27]]}}}, {"text": "The HashMap only knows that, once the limit has been reached, the probablility of collisions becomes too high, and it must rehash to lower that probability and leave room for future entries", "label": {"api": {"HashMap": [[4, 10]]}}}, {"text": "If you are considering other methods too, from Java 8 you can do it by mixing streams and comparators", "label": {"api": {"streams": [[78, 84]], "comparators": [[90, 100]]}}}, {"text": "There are multiple ways to do this, but one of the easier ones is to use HashMap.merge() to handle both adding new mappings and updating existing ones, as appropriate", "label": {"api": {"HashMap.merge()": [[73, 87]]}}}, {"text": "Stream.flatMap() requires a Function which returns a Stream as parameter", "label": {"api": {"Stream.flatMap()": [[0, 15]]}}}, {"text": "Alternatively you can use Stream.map() and Stream.flatMap()", "label": {"api": {"Stream.flatMap()": [[43, 58]]}}}, {"text": "You can test if a Parameter is a varargs parameter via Parameter#isVarArgs()", "label": {"api": {"Parameter#isVarArgs()": [[55, 75]]}}}, {"text": "The Executable interface has a similar method, which both Constructor and Method implement", "label": {"api": {"Executable": [[4, 13]], "similar method": [[31, 44]]}}}, {"text": "One of its essential steps is the invocation of Shutdown hooks", "label": {"api": {"Shutdown hooks": [[48, 61]]}}}, {"text": "Shutdown hooks are regular Java threads", "label": {"api": {"Shutdown hooks": [[0, 13]]}}}, {"text": "The answer to your questions is hidden in the documentation of the notify() and notifyAll() methods", "label": {"api": {"notify()": [[67, 74]], "notifyAll()": [[80, 90]]}}}, {"text": "When we call the notify() method on the lock object, if you see the doc it says \"only single thread\" is woken up", "label": {"api": {"notify()": [[17, 24]]}}}, {"text": "If you see the documentation of \"notifyAll()\" it states \"Wakes up all threads that are waiting on this object's monitor", "label": {"api": {"notifyAll()": [[33, 43]]}}}, {"text": "The below is the result when we changed the call from notifyAll() to notify(), the first thread to do the wait is notified in this case", "label": {"api": {"notify()": [[69, 76]], "notifyAll()": [[54, 64]]}}}, {"text": "If I understand your question correctly you put the username in a ThreadLocal in one thread and then try to access it from another thread", "label": {"api": {"ThreadLocal": [[66, 76]]}}}, {"text": "It should be obvious from the documentation of ThreadLocal that this won't work", "label": {"api": {"ThreadLocal": [[47, 57]]}}}, {"text": "Alternatively you can put the value in the ThreadLocal at the beginning of whatever runs in a single Thread in your setup", "label": {"api": {"ThreadLocal": [[43, 53]]}}}, {"text": "In any case I would recommend using javax.swing.Timer, which schedules your tasks as action listeners to be executed on the Swing event dispatching thread", "label": {"api": {"javax.swing.Timer": [[36, 52]]}}}, {"text": "It is the first parameter of the static methods, as described in the documentation", "label": {"api": {"described in the documentation": [[52, 81]]}}}, {"text": "You can use Stream::flatMap method", "label": {"api": {"Stream::flatMap": [[12, 26]]}}}, {"text": "Best use Files", "label": {"api": {"Files": [[9, 13]]}}}, {"text": "Here I think AtomicBoolean might be nice for non-blocking usage", "label": {"api": {"AtomicBoolean": [[13, 25]]}}}, {"text": "Using a global CyclicBarrier - not the nicest API as it works with N predefined Runnables", "label": {"api": {"CyclicBarrier": [[15, 27]]}}}, {"text": "An alternative to already mentioned Stream::concat is the Stream::of", "label": {"api": {"Stream::concat": [[36, 49]], "Stream::of": [[58, 67]]}}}, {"text": "You could call the two-argument variant with limit = -1 to have all the trailing empty elements included in the result, or possibly with limit = 8 (or whatever your expected column count is) if that suits your case better", "label": {"api": {"two-argument variant": [[19, 38]]}}}, {"text": "You can get username by using request.getAttribute() & request.setAttribute()", "label": {"api": {"request.getAttribute()": [[30, 51]], "request.setAttribute()": [[55, 76]]}}}, {"text": "You can use invokeAll", "label": {"api": {"invokeAll": [[12, 20]]}}}, {"text": "To fix this you can use the Character.toString(char) method like this", "label": {"api": {"Character.toString(char) method": [[28, 58]]}}}, {"text": "String.charAt() returns a char (https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#charAt(int)) so you're dealing with a single character", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#charAt(int)": [[32, 106]]}}}, {"text": "Configure your JmsTemplate with a MarshallingMessageConverter that uses a Jaxb2Marshaller where you can set the marshaller property JAXB_ENCODING", "label": {"api": {"JAXB_ENCODING": [[132, 144]]}}}, {"text": "ButDateFormat/SimpleDateFormat is not thread-safe(refer the synchronization section)", "label": {"api": {"thread-safe": [[38, 48]]}}}, {"text": "It is recommend to use DateTimeFormatter instead", "label": {"api": {"DateTimeFormatter": [[23, 39]]}}}, {"text": "You can accomplish this with Files.list", "label": {"api": {"Files.list": [[29, 38]]}}}, {"text": "Use Java's BigDecimal class instead of implementing this yourself", "label": {"api": {"Java's BigDecimal": [[4, 20]]}}}, {"text": "There is no avalilable method in https://docs.oracle.com/javase/7/docs/api/java/util/Map.html to get Entity from map if there is any key or value available", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Map.html": [[33, 92]]}}}, {"text": "Use either CallableStatement.setBlob(int, InputStream) or  Blob.setBinaryStream(long)", "label": {"api": {"CallableStatement.setBlob(int, InputStream)": [[11, 53]], "Blob.setBinaryStream(long)": [[59, 84]]}}}, {"text": "The editor installs an AbstractFormatter which never allows below the minimum or above the maximum, so you never get a chance to react to those conditions", "label": {"api": {"AbstractFormatter": [[23, 39]]}}}, {"text": "Since it’s nearly impossible to intercept an existing AbstractFormatter’s behavior, I would just create the JSpinner with no minimum or maximum, and enforce those bounds manually in a ChangeListener", "label": {"api": {"AbstractFormatter": [[54, 70]]}}}, {"text": "Take a look at java https://docs.oracle.com/javase/10/docs/api/java/util/TreeSet.html, which should take care of the most of the work, but keep in mind that underlying structure is made out of objects that will be slower than arrays", "label": {"api": {"https://docs.oracle.com/javase/10/docs/api/java/util/TreeSet.html": [[20, 84]]}}}, {"text": "By the way, since java 8, class java.nio.file.Files contains method readAllLines", "label": {"api": {"readAllLines": [[68, 79]]}}}, {"text": "So if file \"TempFile.csv\" is not too big, readAllLines may be a simpler alternative to class Scanner", "label": {"api": {"readAllLines": [[42, 53]]}}}, {"text": "The problem with your code is that the Scanner class tokenizes the user input - so with scanner.next() you will only get the text to the first blank", "label": {"api": {"Scanner": [[39, 45]]}}}, {"text": "FileOutputStream has a constructor which allows you to specify it", "label": {"api": {"a constructor": [[21, 33]]}}}, {"text": "To reinterpret its signedness you then use Short.toUnsignedInt", "label": {"api": {"Short.toUnsignedInt": [[43, 61]]}}}, {"text": "For example, ArrayList (https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html) says \"Note that this implementation is not synchronized\" along with suggested workarounds", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[24, 89]]}}}, {"text": "The \\0 special character is part of a set of special characters used for octal values (link)", "label": {"api": {"link": [[87, 90]]}}}, {"text": "However, if your goal is to understand how ReentrantLocks work (or if your use case somehow fits better with ReentrantLocks than is clear from the example above), I would encourage you to read the Javadoc - https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html - it contains useful information about how to use them and how they behave", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html": [[207, 293]]}}}, {"text": "A solution could be to wait for the thread's execution before returning the list requisicoes (by calling the join method of the thread", "label": {"api": {"join method": [[109, 119]]}}}, {"text": "The Exception.getMessage() returns a String which doesn't have a length limit", "label": {"api": {"Exception.getMessage()": [[4, 25]]}}}, {"text": "You can just use the read method of ImageIO which takes a URL", "label": {"api": {"read method of ImageIO which takes a URL": [[21, 60]]}}}, {"text": "Javadoc for Thread (https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html) explains the two ways to create a new thread", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html": [[20, 82]]}}}, {"text": "Note that I have made uses of classes like AtomicBoolean to ensure the thread-safety of fields like playable and done so that changes by one thread are observable to other threads", "label": {"api": {"AtomicBoolean": [[43, 55]]}}}, {"text": "Java's Optional class was also used to set clip and stream to a safer value than null", "label": {"api": {"Optional": [[7, 14]]}}}, {"text": "This is a variation of the difference between Reduction and Mutable Reduction", "label": {"api": {"Reduction": [[46, 54], [68, 76]], "Mutable Reduction": [[60, 76]]}}}, {"text": "It comes naturally, that the groupingBy collector, which takes a second Collector as argument, is the right tool when we want to apply a Mutable Reduction to the groups", "label": {"api": {"Reduction": [[145, 153]], "Mutable Reduction": [[137, 153]]}}}, {"text": "Not that obviously, the toMap collector taking a merge function is the right tool when we want to perform a classical Reduction, as that merge function has the same shape and purpose as a Reduction function, even if it is not called as such", "label": {"api": {"Reduction": [[118, 126], [188, 196]]}}}, {"text": "In practice, we note that the collectors which perform a Reduction, return an Optional, which is usually not desired when being used with groupingBy, which is the reason why toMap works more smoothly in these cases", "label": {"api": {"Reduction": [[57, 65]]}}}, {"text": "From the Javadoc (https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html#flush--) for OutputStream (where FileOutputStream is an OutputStream), this is what it says for flush()", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html#flush--": [[18, 92]]}}}, {"text": "While other answers have correctly said that implementations such as ArrayList and LinkedList explicitly store the lists size as a field of the list, that doesn't actually answer your question, because List.of​(E..", "label": {"api": {"ArrayList": [[69, 77]], "LinkedList": [[83, 92]]}}}, {"text": "If you look at Javadoc for Number (https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html), you can see a list of methods that are available – none of them are \"round()\"", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html": [[35, 97]]}}}, {"text": "You can do that by synchronizing on the same object as per Mangat's answer or use ReadWriteLock from SDK", "label": {"api": {"ReadWriteLock": [[82, 94]]}}}, {"text": "I'm not sure to understand exactly what you want to do, but if you want a \"collection\" (such as an array) of object and you want to get the one you need by the object and not an index you should look to Set", "label": {"api": {"Set": [[203, 205]]}}}, {"text": "Duplicate the buffer to preserve the original's position, limit, and mark values", "label": {"api": {"Duplicate": [[0, 8]]}}}, {"text": "However java.util.Date class is deprecated and you should consider using LocalDate or LocalDateTime - both those classes are immutable", "label": {"api": {"LocalDate": [[73, 81], [86, 94]], "LocalDateTime": [[86, 98]]}}}, {"text": "Elements inherits from ArrayList, so you can access individual elements directly", "label": {"api": {"ArrayList": [[23, 31]]}}}, {"text": "Just remember the ScheduledFuture from your call to schedule", "label": {"api": {"ScheduledFuture": [[18, 32]]}}}, {"text": "If you then want to run it ahead of time, call future.cancel(), submit the Task again for immediate execution and then schedule it again", "label": {"api": {"future.cancel()": [[47, 61]]}}}, {"text": "Java's SSL engine requires client authentication only if you call SSLEngine.setNeedClientAuth()", "label": {"api": {"SSLEngine.setNeedClientAuth()": [[66, 94]]}}}, {"text": "This is from the javadoc of Error", "label": {"api": {"Error": [[28, 32]]}}}, {"text": "An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch", "label": {"api": {"Error": [[3, 7]]}}}, {"text": "You mentionned StackoverflowError, if you have this kind of error, there's probably a problem with your algorithm and your code should be optimized", "label": {"api": {"Error": [[28, 32]]}}}, {"text": "In both cases, you can use the Collectors#groupingBy method", "label": {"api": {"Collectors#groupingBy": [[31, 51]]}}}, {"text": "Also java provide this structure with MXBean", "label": {"api": {"MXBean": [[38, 43]]}}}, {"text": "You should use StringBuilder if you plan to concatenate in a loop", "label": {"api": {"StringBuilder": [[15, 27]]}}}, {"text": "Optional and more specifically  Optional.ofNullable() are not designed to catch any exception triggered in the expression execution passed to their factory methods", "label": {"api": {"Optional": [[0, 7], [32, 39]]}}}, {"text": "Optional was originally designed to convey/constraint that a method may return an thing or not (empty)", "label": {"api": {"Optional": [[0, 7]]}}}, {"text": "In some cases we could also rely on Optional to perform elegantly some null checks", "label": {"api": {"Optional": [[36, 43]]}}}, {"text": "List.toArray() does that", "label": {"api": {"List.toArray()": [[0, 13]]}}}, {"text": "from a source (the list) to the array but you have other ways to fill an array dynamically with some objects such as Arrays.fill(Object[] a, Object val)", "label": {"api": {"Arrays.fill(Object[] a, Object val)": [[117, 151]]}}}, {"text": "Every event in Java SE has a source, which is the object to which the listener was originally added", "label": {"api": {"source": [[29, 34]]}}}, {"text": "Since you know the type of your checkboxes, it is safe to cast the event source to the appropriate type", "label": {"api": {"source": [[73, 78]]}}}, {"text": "If you want to get more precise result, consider changing the type of averagespeed to float or double", "label": {"api": {"float": [[86, 90]], "double": [[95, 100]]}}}, {"text": "I found this Question leading to the requireEnd method of java.util.regex.Matcher, but this method only tells me if there is a character c so that p(A+c) is false assuming that p(A) is true", "label": {"api": {"requireEnd": [[37, 46]]}}}, {"text": "List<E> of(E e1, E e2,) require Java in version 9 or higher", "label": {"api": {"List<E> of(E e1, E e2,)": [[0, 22]]}}}, {"text": "Swing calls the toString() method of model objects in order to render them;  you can take advantage of that by overriding that method in your value class", "label": {"api": {"toString()": [[16, 25]]}}}, {"text": "Note the documentation of JComponent.sebBackground", "label": {"api": {"JComponent.sebBackground": [[26, 49]]}}}, {"text": "The reason is the fact that since java9 OpenJDK creators decided to make the newer version of the secureRandomSpi to reset the value of the remCount integer field each time SecureRandom.setSeed() is called, which the older version did not", "label": {"api": {"setSeed()": [[186, 194]]}}}, {"text": "Then you may call setSeed() and then install the saved value back to the remCount field", "label": {"api": {"setSeed()": [[18, 26]]}}}, {"text": "Once you read the Double values from the excel instead of displaying the values as 2.0, to print it as 2 you can use the DecimalFormat Class methods and you can use the following solution", "label": {"api": {"DecimalFormat": [[121, 133]]}}}, {"text": "You should use ProcessBuilder instead of Runtime.exec, e.g", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "The inheritIO() means that you don't need to process the commands output", "label": {"api": {"inheritIO()": [[4, 14]]}}}, {"text": "Java 9 introduced a new method failedFuture to meet this need", "label": {"api": {"failedFuture": [[31, 42]]}}}, {"text": "You should read the javadoc of ResourceBundle and the PropertyResourceBundle subclass to learn how this all works", "label": {"api": {"ResourceBundle": [[31, 44], [62, 75]], "PropertyResourceBundle": [[54, 75]]}}}, {"text": "You would use ByteArrayOutputStream if the scope was to write to memory", "label": {"api": {"ByteArrayOutputStream": [[14, 34]]}}}, {"text": "In your case, you could write your data to https://docs.oracle.com/javase/8/docs/api/index.html?java/util/zip/ZipOutputStream.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/index.html?java/util/zip/ZipOutputStream.html": [[43, 129]]}}}, {"text": "And then use the String instances split method", "label": {"api": {"String instances split method": [[17, 45]]}}}, {"text": "You can use return v1 and other strings separately using map function and then collect it by using Collectors.toMap function", "label": {"api": {"Collectors.toMap": [[99, 114]]}}}, {"text": "Note that Collectors.toMap function takes two FunctionalInterface Functions each for a key and a value", "label": {"api": {"Collectors.toMap": [[10, 25]], "FunctionalInterface": [[46, 64]], "Functions": [[66, 74]]}}}, {"text": "I am using vsilaev/task-concurrent to work with future object much like CompletableFuture in the Java API", "label": {"api": {"CompletableFuture": [[72, 88]]}}}, {"text": "The documentation mentioning this is actually in the DateTimeFormatterBuilder API rather than DateTimeFormatter's", "label": {"api": {"DateTimeFormatterBuilder": [[53, 76]]}}}, {"text": "It uses ForkJoinPool by default which is also intended for CPU-bound operations and uses only as many threads as many CPU cores you have in your machine", "label": {"api": {"ForkJoinPool": [[8, 19]]}}}, {"text": "Make a data structure using LinkedHashMap and override removeEldestEntry i.e", "label": {"api": {"LinkedHashMap": [[28, 40]], "removeEldestEntry": [[55, 71]]}}}, {"text": "The paintComponent method actually comes from abstract class JComponent which is extend by the JPanel class which in turn is what you are extending", "label": {"api": {"paintComponent method": [[4, 24]], "abstract class JComponent": [[46, 70]], "JPanel class": [[95, 106]]}}}, {"text": "The Javadoc for the instrument package gives you an overview on how to do so", "label": {"api": {"Javadoc for the instrument package": [[4, 37]]}}}, {"text": "Here's another way to do it – construct a Set and store just the 10-digit prefix", "label": {"api": {"Set": [[42, 44]]}}}, {"text": "Use String.split(\", \") which should give you a String array with 3 strings", "label": {"api": {"String.split(\", \")": [[4, 21]]}}}, {"text": "you can use Arrays.asList() on this to get an ArrayList from this", "label": {"api": {"Arrays.asList()": [[12, 26]]}}}, {"text": "You can call Pattern.compile", "label": {"api": {"Pattern.compile": [[13, 27]]}}}, {"text": "With Java 9, you can use the three-argument Stream#iterate with the condition that you already have in your for-loop", "label": {"api": {"Stream#iterate": [[44, 57]]}}}, {"text": "Secondly do not use SimpleDateFormat it is long outdated, use DateTimeFormatter and LocalDatefrom java 1.8 instead", "label": {"api": {"DateTimeFormatter": [[62, 78]], "LocalDate": [[84, 92]]}}}, {"text": "instead of using an array you can use an ArrayList and make you code much simpler", "label": {"api": {"ArrayList": [[41, 49]]}}}, {"text": "The new java time classes are a huge improvement", "label": {"api": {"java time classes": [[8, 24]]}}}, {"text": "You can not override Object.notify() which is final", "label": {"api": {"Object.notify()": [[21, 35]]}}}, {"text": "Notice that it extends ObjectOptimisticLockingFailureException and takes javax.persistence.OptimisticLockException and it invokes super contructor with message taken from OptimisticLockException", "label": {"api": {"javax.persistence.OptimisticLockException": [[73, 113]]}}}, {"text": "For suggesting a size when the combo will only be populated later, give the combo the longest string expected and call setPrototypeDisplayValue(E), then set an empty model after the GUI is packed", "label": {"api": {"setPrototypeDisplayValue(E)": [[119, 145]]}}}, {"text": "Create a PriorityQueue holding Lines where the Comparator compares two instances of Line and returns that the shortest line is least (see the interface for Comparator for what you have to implement there)", "label": {"api": {"PriorityQueue": [[9, 21]], "Comparator": [[47, 56], [156, 165]]}}}, {"text": "All you need to do is create the right Comparator for running it (described above) and another one for sorting on the original line number, and you're done", "label": {"api": {"Comparator": [[39, 48]]}}}, {"text": "Instead of using a LocalDate, use YearMonth", "label": {"api": {"YearMonth": [[34, 42]]}}}, {"text": "Cassandra Time type, as explained here, stores the value up to the nanoseconds, while java.sql.time stores the value up to the milliseconds", "label": {"api": {"up to the milliseconds": [[117, 138]]}}}, {"text": "The Phaser is able to do this because it internally calls ForkJoinPool.managedBlock(ManagedBlocker) when blocking a thread", "label": {"api": {"ForkJoinPool.managedBlock(ManagedBlocker)": [[58, 98]]}}}, {"text": "Few minutes later, when transaction b tries to flush, it fails with ConstraintViolationException caused by having duplicate keys in the common table", "label": {"api": {"ConstraintViolationException": [[68, 95]]}}}, {"text": "In Java 7 there is no PriorityQueue constructor that takes only Comparator as an argument", "label": {"api": {"constructor": [[36, 46]]}}}, {"text": "Take a look Java 7 Priority queue docs", "label": {"api": {"Java 7 Priority queue docs": [[12, 37]]}}}, {"text": "However in Java 8+ there is such constructor for this class", "label": {"api": {"constructor": [[33, 43]]}}}, {"text": "Your best choice would be to use constructor that takes initial capacity and a Comparator", "label": {"api": {"constructor": [[33, 43]]}}}, {"text": "If the last integer value represents a year, why not use java.time.Year directly", "label": {"api": {"java.time.Year": [[57, 70]]}}}, {"text": "And then you could sort this list using List::sort method and passing a comparator", "label": {"api": {"List::sort": [[40, 49]]}}}, {"text": "You should use IsoFields.QUARTER_YEARS which is of type TemporalUnit", "label": {"api": {"IsoFields.QUARTER_YEARS": [[15, 37]]}}}, {"text": "Comparator::comparing is a generic method that takes a function that is used to extract the value to be compared", "label": {"api": {"Comparator::comparing": [[0, 20]]}}}, {"text": "Looking further let's look at Comparator::comparing(Function) method implementation", "label": {"api": {"Comparator::comparing": [[30, 50]]}}}, {"text": "But seriously look into class Future", "label": {"api": {"Future": [[30, 35]]}}}, {"text": "Read about it in the API (provided link) and may be search for usage examples, usually in conjunction with ExecutorService", "label": {"api": {"ExecutorService": [[107, 121]]}}}, {"text": "ThreadPoolTaskExecutor is a class from Spring Framework", "label": {"api": {"Executor": [[14, 21]]}}}, {"text": "On the other hand Executors::newFixedThreadPool creates a standard ThreadPoolExecutor thread pool that comes from standard Java and is available since Java 5", "label": {"api": {"ThreadPoolExecutor": [[67, 84]], "Executor": [[18, 25], [77, 84]]}}}, {"text": "From docs of ThreadPoolTaskExecutor", "label": {"api": {"Executor": [[27, 34]]}}}, {"text": "JavaBean that allows for configuring a ThreadPoolExecutor in bean style (through its \"corePoolSize\", \"maxPoolSize\", \"keepAliveSeconds\", \"queueCapacity\" properties) and exposing it as a Spring TaskExecutor", "label": {"api": {"ThreadPoolExecutor": [[39, 56]], "Executor": [[49, 56], [196, 203]]}}}, {"text": "This class implements Spring's TaskExecutor interface as well as the Executor interface, with the former being the primary interface, the other just serving as secondary convenience", "label": {"api": {"Executor": [[35, 42], [69, 76]]}}}, {"text": "For this reason, the exception handling follows the TaskExecutor contract rather than the Executor contract, in particular regarding the TaskRejectedException", "label": {"api": {"Executor": [[56, 63], [90, 97]]}}}, {"text": "Notice that ThreadPoolTaskExecutor implements many Spring interfaces like  Aware, BeanNameAware, DisposableBean, InitializingBean which makes it easier to work with such pool as a Spring bean", "label": {"api": {"Executor": [[26, 33]]}}}, {"text": "One way to do that is to combine the getBytes() method with this constructor", "label": {"api": {"getBytes()": [[37, 46]], "this constructor": [[60, 75]]}}}, {"text": "so new String(string.getBytes(), a, b) works with the same logic as string.substring(a, b), but per-byte instead of per-character", "label": {"api": {"getBytes()": [[21, 30]]}}}, {"text": "Instead use String.codePoints() method", "label": {"api": {"String.codePoints()": [[12, 30]]}}}, {"text": "You can use getFontMetrics and getFont on the JFormattedTextField of the DefaultEditor of the JSpinner", "label": {"api": {"getFontMetrics": [[12, 25]], "getFont": [[12, 18], [31, 37]]}}}, {"text": "this makes no guarantees of the iterator ordering; however, LinkedHashSet, a subclass of HashSet does guarantee iterator ordering", "label": {"api": {"this makes no guarantees of the iterator ordering": [[0, 48]], "LinkedHashSet": [[60, 72]]}}}, {"text": "The guarantee of LinkedHashSet is consistent with the guarantee of HashSet, because a specific ordering is one of the possible orderings that could be observed with \"no guaranteed ordering\" (after all, you have to return the elements in some order)", "label": {"api": {"LinkedHashSet": [[17, 29]]}}}, {"text": "From the Javadoc", "label": {"api": {"From the Javadoc": [[0, 15]]}}}, {"text": "java.util.Queue<E> does not support this", "label": {"api": {"java.util.Queue<E>": [[0, 17]]}}}, {"text": "Per the parseInt() docs", "label": {"api": {"parseInt() docs": [[8, 22]]}}}, {"text": "With release of Java-11, Why do we have orElseThrow with optionalLong / OptionalDouble and other Optional Types when we can directly check if a number is not null or not equals to a specific number", "label": {"api": {"orElseThrow": [[40, 50]]}}}, {"text": "May be not able to visualize the real use of optionalTypes and orElseThrow", "label": {"api": {"orElseThrow": [[63, 73]]}}}, {"text": "Javadoc for orElseThrow", "label": {"api": {"orElseThrow": [[12, 22]]}}}, {"text": "I'm using SimpleDateFormat to parse dates in my application and for some reason I get completely unexpected results for some formats", "label": {"api": {"SimpleDateFormat": [[10, 25]]}}}, {"text": "Rounded corners are actually a boolean argument when instantiating a border, as can be seen here with BorderFactory", "label": {"api": {"here with BorderFactory": [[92, 114]]}}}, {"text": "the method thenAccept(Consumer) of the class CompletableFuture", "label": {"api": {"thenAccept(Consumer)": [[11, 30]]}}}, {"text": "So when we compare 404 to 908 we check whether 404 % 10 > 908 % 10 or 4 > 8", "label": {"api": {"compare": [[11, 17]]}}}, {"text": "You should also check out the documentation for compare", "label": {"api": {"compare": [[48, 54]]}}}, {"text": "Per the documentation, read() uses -1 as a special value to indicate EOF", "label": {"api": {"Per the documentation": [[0, 20]]}}}, {"text": "As stated in the documentation of the base method, InputStream.read()", "label": {"api": {"InputStream.read()": [[51, 68]]}}}, {"text": "Take a look at Graphics2D#drawImage(Image, AffineTransform, ImageObserver)", "label": {"api": {"Graphics2D#drawImage(Image, AffineTransform, ImageObserver)": [[15, 73]]}}}, {"text": "Luckily, there is a very convenient method called Pattern.quote that does this for you automatically", "label": {"api": {"Pattern.quote": [[50, 62]]}}}, {"text": "You could come up with a sample class implementing Callable interface", "label": {"api": {"Callable": [[51, 58]]}}}, {"text": "When you need to send your application to the background and do something else while it is there - call it with the ExecutorService", "label": {"api": {"ExecutorService": [[116, 130]]}}}, {"text": "One way to enable Loggers to write to a standard output stream is to create your own StreamHandler and configure your Logger to send input to the handler instead", "label": {"api": {"StreamHandler": [[85, 97]]}}}, {"text": "You may also have to disable parent handlers to avoid duplicate output", "label": {"api": {"disable parent handlers": [[21, 43]]}}}, {"text": "Call processBuilder21.redirectErrorStream(true) to merged the commands error output into the standard output", "label": {"api": {"processBuilder21.redirectErrorStream(true)": [[5, 46]]}}}, {"text": "Of course, since you're just printing the output, you might as well just let the system do it for you, by calling inheritIO()", "label": {"api": {"inheritIO()": [[114, 124]]}}}, {"text": "If this is a command line program, then you can use a Scanner to read input from the user", "label": {"api": {"Scanner": [[54, 60]]}}}, {"text": "See Scanner for more information", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "Use IntStream::collect with a StringBuilder", "label": {"api": {"IntStream::collect": [[4, 21]], "StringBuilder": [[30, 42]], "String": [[30, 35]]}}}, {"text": "If you prefer the more general CharSequence interface over concrete String, simply drop the toString() at the end", "label": {"api": {"CharSequence": [[31, 42]], "String": [[68, 73], [94, 99]]}}}, {"text": "The returned StringBuilder is a CharSequence", "label": {"api": {"StringBuilder": [[13, 25]], "CharSequence": [[32, 43]], "String": [[13, 18]]}}}, {"text": "So your question is answered by the javadoc of EnumMap", "label": {"api": {"javadoc of EnumMap": [[36, 53]]}}}, {"text": "The JAVA interface Map knows nothing about order", "label": {"api": {"knows nothing about order": [[23, 47]]}}}, {"text": "If you are reading from a text file, why not use Java 7 Files.readAllLines", "label": {"api": {"Java 7 Files.readAllLines": [[49, 73]]}}}, {"text": "The method getLevel() gives you the (linear) gain of the DataLine, which is used for playback, not some property of the audio file", "label": {"api": {"getLevel()": [[11, 20]]}}}, {"text": "If you need to check a condition on all elements and choose only some of them, you should use Stream.filter instead", "label": {"api": {"Stream.filter": [[94, 106]]}}}, {"text": "The Javadoc for ReadWriteLock explicitly says", "label": {"api": {"Javadoc for ReadWriteLock": [[4, 28]]}}}, {"text": "The problem is that the Character.toUpperCase() won't overwrite the character in the string", "label": {"api": {"Character.toUpperCase()": [[24, 46]]}}}, {"text": "Specifically, Date was replaced by java.time.Instant", "label": {"api": {"java.time.Instant": [[35, 51]]}}}, {"text": "If not, use OffsetDateTime", "label": {"api": {"OffsetDateTime": [[12, 25]]}}}, {"text": "Because you're indexing two Lists with a for-loop, you can replace it with an IntStream and reduce it with IntStream#anyMatch", "label": {"api": {"IntStream": [[78, 86], [107, 115]], "IntStream#anyMatch": [[107, 124]]}}}, {"text": "The proper way in Java is to use codePointCount", "label": {"api": {"codePointCount": [[33, 46]]}}}, {"text": "The thing is that Executors.newSingleThreadScheduledExecutor() creates a pool which has it's own threads internally", "label": {"api": {"Thread": [[37, 42]]}}}, {"text": "When you look at ScheduledExecutorService::scheduleAtFixedRate it takes Runnable as first argument", "label": {"api": {"ScheduledExecutorService::scheduleAtFixedRate": [[17, 61]], "Runnable": [[72, 79]]}}}, {"text": "And this Runnable will be run by some thread from the pool", "label": {"api": {"Runnable": [[9, 16]]}}}, {"text": "Notice that Thread implements Runnable and you pass a Thread instance to scheduleAtFixedRate method so this thread's run method will be invoked by some other thread but the thread that you passed wil not be started", "label": {"api": {"Runnable": [[30, 37]], "Thread": [[12, 17], [54, 59]]}}}, {"text": "Generally to avoid any misconceptions you should pass simple Runnable here which will represent work that needs to be done", "label": {"api": {"Runnable": [[61, 68]]}}}, {"text": "If you want to change names of threads from this pool you would have to provide custom ThreadFactory which will be used by the pool to create new threads", "label": {"api": {"Thread": [[87, 92]], "ThreadFactory": [[87, 99]]}}}, {"text": "For Java versions < 8 we could simply create new class implementing ThreadFactory interface", "label": {"api": {"Thread": [[68, 73]], "ThreadFactory": [[68, 80]]}}}, {"text": "CompletableFuture.allOf(...) returns a  CompletableFuture<Void>", "label": {"api": {"CompletableFuture.allOf(...)": [[0, 27]]}}}, {"text": "You could use Stream::generate and Queue::poll method to get create a Stream with elements from PriorityQueue  with keeping their order", "label": {"api": {"Stream::generate": [[14, 29]], "Queue::poll": [[35, 45]]}}}, {"text": "However this might be dangerous because Stream::generate will be invoking poll constantly so it is potentially an inifinite Stream", "label": {"api": {"Stream::generate": [[40, 55]]}}}, {"text": "In Java 9 you could use Stream::takeWhile with predicate that rejects nulls", "label": {"api": {"Stream::takeWhile": [[24, 40]]}}}, {"text": "As Queue::poll will return null when queue is empty - the resulting Stream will contain elements from the queue in their order (this is alternative to using limit as described in the first solution)", "label": {"api": {"Queue::poll": [[3, 13]]}}}, {"text": "And in your case you could even use Map.merge() that allows in addition to merge the actual value for an already existing  mapping for a key", "label": {"api": {"Map.merge()": [[36, 46]]}}}, {"text": "Implement a FileVisitor which inserts files into a blocking queue", "label": {"api": {"FileVisitor": [[12, 22]]}}}, {"text": "Use walkFileTree() with that file visitor", "label": {"api": {"walkFileTree()": [[4, 17]]}}}, {"text": "Use that queue to build a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[26, 43]]}}}, {"text": "The built-in java.util.Arrays class provides a binarySearch method to do that for you", "label": {"api": {"a binarySearch method": [[45, 65]]}}}, {"text": "InputStream is an abstract class (perhaps should have been an interface)", "label": {"api": {"InputStream": [[0, 10]]}}}, {"text": "You can use anything that subclasses InputStream or that can produce an InputStream, for example StringBufferInputStream which will stream a StringBuffer", "label": {"api": {"InputStream": [[37, 47], [72, 82], [109, 119]], "StringBufferInputStream": [[97, 119]]}}}, {"text": "I created a Comparator for a specific class", "label": {"api": {"Comparator": [[12, 21]]}}}, {"text": "In my case, I need to know if there are pairs of objects that are \"equal\" in the sense of the Comparator", "label": {"api": {"Comparator": [[94, 103]]}}}, {"text": "The Comparator counts the number of null values in fields", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "The documentation of Collectors.toList() says that there are no guarantees on the type returned", "label": {"api": {"Collectors.toList()": [[21, 39]]}}}, {"text": "Try to find the Window in which the button is, SwingUtilities::windowForComponent may help, or if you want the focused window, combine KeyboardFocusManager::getCurrentKeyboardFocusManager, KeyboardFocusManager::getFocusOwner and SwingUtilities::windowForComponent", "label": {"api": {"SwingUtilities::windowForComponent": [[47, 80], [229, 262]], "KeyboardFocusManager::getCurrentKeyboardFocusManager": [[135, 186]], "KeyboardFocusManager::getFocusOwner": [[189, 223]]}}}, {"text": "You are perhaps looking for something like a CompletionService", "label": {"api": {"CompletionService": [[45, 61]]}}}, {"text": "If such method exists, the FXMLLoader will execute it on initialization of the controller", "label": {"api": {"FXMLLoader": [[27, 36]]}}}, {"text": "See also the Controllers section in Introduction to FXML guide", "label": {"api": {"Controllers": [[13, 23]], "Introduction to FXML": [[36, 55]]}}}, {"text": "If you set a value using ServletRequest.setAttribute(), you have to retrieve it using ServletRequest.getAttribute()", "label": {"api": {"ServletRequest.setAttribute()": [[25, 53]], "ServletRequest.getAttribute()": [[86, 114]]}}}, {"text": "...implies that there was a RuntimeException which should never be thrown and as per the documentation such exception is thrown due to an INTERNAL ERROR of BCEL's class file verifier JustIce", "label": {"api": {"RuntimeException": [[28, 43]]}}}, {"text": "https://docs.oracle.com/javaee/7/api/javax/persistence/UniqueConstraint.html and trying to name the constraint like so", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/persistence/UniqueConstraint.html": [[0, 75]]}}}, {"text": "A neat thing about Maps is that the key set and value collection are both backed by the Map itself", "label": {"api": {"key set": [[36, 42]], "value collection": [[48, 63]]}}}, {"text": "What this means is that removing a key from the key set effectively removes it from the Map it belongs to", "label": {"api": {"key set": [[48, 54]]}}}, {"text": "Therefore, you can use retainAll on the key set", "label": {"api": {"key set": [[40, 46]], "retainAll": [[23, 31]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/index.html?javax/swing/SwingWorker.html This will allow you to have more control over async tasks in swing", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/index.html?javax/swing/SwingWorker.html": [[0, 80]]}}}]