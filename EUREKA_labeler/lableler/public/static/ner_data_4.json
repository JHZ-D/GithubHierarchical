[{"text": "You could also use fireTableRowsUpdated(int,int) and specify the entire range of rows that have been updated in one call, but generally it's better to stick to the conservative side to minimize unnecessary redraws", "label": {"api": {"fireTableRowsUpdated(int,int)": [[19, 47]]}}}, {"text": "You can call Collections.sort(listOfHorses) before the for loop on listOfHorses, and do the same with listOfCows", "label": {"api": {"Collections.sort(listOfHorses)": [[13, 42]]}}}, {"text": "The easiest option is probably to use SwingUtilities.invokeAndWait() from your thread, with a Runnable that calls render()", "label": {"api": {"SwingUtilities.invokeAndWait()": [[38, 67]]}}}, {"text": "Note that all of this information is readily available in the Timestamp documentation", "label": {"api": {"Timestamp documentation": [[62, 84]]}}}, {"text": "A BufferedWriter buffers output until you flush the stream you write to so you need to flush the stream by either closing the file or using save.flush()", "label": {"api": {"BufferedWriter": [[2, 15]]}}}, {"text": "Or use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[7, 24]]}}}, {"text": "And remember to import java.util.ArrayList", "label": {"api": {"import java.util.ArrayList": [[16, 41]]}}}, {"text": "You also need to compile the files first with the JavaCompiler class", "label": {"api": {"JavaCompiler": [[50, 61]]}}}, {"text": "However I would strongly recommend that you use a ScheudledExecutorService as below", "label": {"api": {"ScheudledExecutorService": [[50, 73]]}}}, {"text": "Or you can use List.contains(), in this case you have to add your names inside List instead of regular array", "label": {"api": {"List.contains()": [[15, 29]]}}}, {"text": "As a third option, if you put make your names array sorted (either by hand or by calling Arrays.sort) you could use Arrays.binarySearch to try to find the name entered by the user", "label": {"api": {"Arrays.binarySearch": [[116, 134]]}}}, {"text": "You can use the matches() method with the right regex", "label": {"api": {"matches()": [[16, 24]]}}}, {"text": "According to this page of the Java SE 8 API docs, Optional<T> is a value based class", "label": {"api": {"this page of the Java SE 8 API docs": [[13, 47]]}}}, {"text": "According to this page of the API docs, value-based classes have to be immutable", "label": {"api": {"this page of the API docs": [[13, 37]]}}}, {"text": "In some cases, the evaluation might go out of order, when UNORDERED chararacteristic is set for a collector", "label": {"api": {"UNORDERED": [[58, 66]]}}}, {"text": "You can write a simple async-sync adaptor using FutureTask's get() method with timeout", "label": {"api": {"FutureTask": [[48, 57]], "get() method with timeout": [[61, 85]]}}}, {"text": "The java.ext.dirs setting automatically adds all jar-files found in the specified directory to the main classloader, which is why the ServiceLoader can find and load TestIface.class (from the Apidocs", "label": {"api": {"Apidocs": [[192, 198]]}}}, {"text": "This leaves you the option to use the URLClassLoader to load additional jars and then call ServiceLoader.load(class from another jar)", "label": {"api": {"URLClassLoader": [[38, 51]]}}}, {"text": "I've used Collections.max(Collection<T>) on a List<Float> before, but I don't know how to get the maximum from a custom object like my Emp class", "label": {"api": {"Collections.max(Collection<T>)": [[10, 39]]}}}, {"text": "Assuming I'm correctly interpreting your question, the answer is to use the other max() method, Collections.max(Collection<T>, Comparator<T>)", "label": {"api": {"Collections.max(Collection<T>, Comparator<T>)": [[96, 140]], "Comparator": [[127, 136]]}}}, {"text": "This method takes a Comparator in addition to the collection you want to search, so that you can provide an explicit ordering for your Emp objects", "label": {"api": {"Comparator": [[20, 29]]}}}, {"text": "I'm using KeyListeners in my code (game or otherwise) as the way for my on-screen objects to react to user key input", "label": {"api": {"KeyListener": [[10, 20]]}}}, {"text": "You need to use intern() method of the String class to get desired result, here is a working example of your TestThread", "label": {"api": {"intern()": [[16, 23]]}}}, {"text": "Use a StringBuilder", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "You could use a Collector", "label": {"api": {"Collector": [[16, 24]]}}}, {"text": "You could also use AtomicReference<T> to ensure reliable concurrent access to an object without locking", "label": {"api": {"AtomicReference<T>": [[19, 36]]}}}, {"text": "If you have a look at http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html, you will know that the compareTo() method is what you need", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html": [[22, 87]]}}}, {"text": "You can use Integer.toOctalString(int) method to get octal representation of a number, if you meant that", "label": {"api": {"Integer.toOctalString(int)": [[12, 37]]}}}, {"text": "If you use a DefaultTableModel as your TableModel, you can use the addRow or setValueAt methods to add a row and change a row value", "label": {"api": {"DefaultTableModel": [[13, 29]]}}}, {"text": "If you are asking for a way to do what your code does (check if a string is substring of another string), you can use String#contains", "label": {"api": {"String#contains": [[118, 132]]}}}, {"text": "You can also use String#indexOf", "label": {"api": {"String#indexOf": [[17, 30]]}}}, {"text": "Make sure you have overridden hashCode and equals correctly in your Param class and use containsAll", "label": {"api": {"containsAll": [[88, 98]]}}}, {"text": "My suggestion would therefore be to use an AtomicReference", "label": {"api": {"AtomicReference": [[43, 57]]}}}, {"text": "Your ref would be an AtomicReference<List<OrderMain>> shared between the producer and consumer", "label": {"api": {"AtomicReference": [[21, 35]]}}}, {"text": "Use System.out.print for each column and print a \\n at the end of each row, something like", "label": {"api": {"System.out.print": [[4, 19]]}}}, {"text": "Another option, if your application has to poll keyboard state all over its execution, is to mark your Timer as daemon so it wonÂ´t prevent the application to finish", "label": {"api": {"daemon": [[112, 117]]}}}, {"text": "To search your data with strength array sorted in ascended order use binarySearch", "label": {"api": {"sort": [[40, 43]], "binarySearch": [[69, 80]]}}}, {"text": "Note, you could implement \"binding\" of strength/names data and their sorting much cleaner and more effectively in at least two different ways", "label": {"api": {"sort": [[69, 72]]}}}, {"text": "use Map to store your bindings assuming your strength keys are unique, and then sorting by keys", "label": {"api": {"sort": [[80, 83]]}}}, {"text": "Use helper POJO class MyData holding both strength and name, as in Hannes's answer and sort array of MyData objects supplying custom Comparator, then do binarySearch with same comparator to find index according to your requirements", "label": {"api": {"sort": [[87, 90]], "binarySearch": [[153, 164]]}}}, {"text": "As far as testing for upper and lower case of characters, take a look at the Character class in the javadocs", "label": {"api": {"Character": [[77, 85]]}}}, {"text": "Alternatively, instead of dealing with converting floats, consider the java.util.Random class", "label": {"api": {"java.util.Random": [[71, 86]]}}}, {"text": "You may want to take a look at the Java SDK documentation for Random", "label": {"api": {"Java SDK documentation for Random": [[35, 67]]}}}, {"text": "The Java encryption classes happily accommodate you by supplying encryption methods on ByteBuffer - update and doFinal specifically", "label": {"api": {"update": [[100, 105]], "doFinal": [[111, 117]]}}}, {"text": "If you are simply trying to use split to get the formula parameter, you could use the Pattern and Matcher classes instead, like so", "label": {"api": {"Pattern": [[86, 92]], "Matcher": [[98, 104]]}}}, {"text": "Javadoc of Collector shows how to collect elements of a stream into a new List", "label": {"api": {"Javadoc of Collector": [[0, 19]]}}}, {"text": "Try using http://docs.oracle.com/javase/7/docs/api/ instead of http://docs.oracle.com/javase/7/docs/api", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/": [[10, 50]], "http://docs.oracle.com/javase/7/docs/api": [[10, 49], [63, 102]]}}}, {"text": "You can use the java Executors, included in version 7", "label": {"api": {"Executors, included in version 7": [[21, 52]]}}}, {"text": "Also JFrame has getFocusOwner() method", "label": {"api": {"getFocusOwner()": [[16, 30]]}}}, {"text": "Of course it is better to use replaceAll if you want to change all elements of a list but using streams enables you to also apply filters or to parallel easily", "label": {"api": {"replaceAll": [[30, 39]]}}}, {"text": "replaceAll also modifies the list and throws an exception when the list is unmodifiable, whereas collectcreates a new list", "label": {"api": {"replaceAll": [[0, 9]]}}}, {"text": "is running in Java 1.6 on the system (outside the IDE) it would not have access to Nimbus (scroll to the bottom for the @since element)", "label": {"api": {"Nimbus": [[83, 88]]}}}, {"text": "Nimbus only became available in 1.7", "label": {"api": {"Nimbus": [[0, 5]]}}}, {"text": "I want to show JavaFX content (a JFXPanel) within the area of a JApplet within a browser window", "label": {"api": {"JFXPanel": [[33, 40]]}}}, {"text": "That is exactly what this answer explains how to do (at least the packaging portion), the JFXPanel javadoc describes the rest", "label": {"api": {"JFXPanel": [[90, 97]]}}}, {"text": "The documentation for wait covers this", "label": {"api": {"documentation for wait covers this": [[4, 37]]}}}, {"text": "Check out the FileChannel#tryLock(...) function", "label": {"api": {"FileChannel#tryLock(...)": [[14, 37]]}}}, {"text": "You can use the String method Split to make an array from each String element", "label": {"api": {"Split": [[30, 34]]}}}, {"text": "The key aspect is to use a single AtomicLong as the singleton", "label": {"api": {"AtomicLong": [[34, 43]]}}}, {"text": "Collections.sort is stable", "label": {"api": {"stable": [[20, 25]]}}}, {"text": "the algorithm used by sort does not have to be a mergesort, but it does have to be stable", "label": {"api": {"stable": [[83, 88]]}}}, {"text": "If you want to compare Strings by length, then use <= operator on String#length instead", "label": {"api": {"String#length": [[66, 78]]}}}, {"text": "Have a look at the Comparable interface that String implements", "label": {"api": {"Comparable": [[19, 28]]}}}, {"text": "A good class to start with is java.util.ArrayList", "label": {"api": {"java.util.ArrayList": [[30, 48]]}}}, {"text": "You can use Class.asSubclass()", "label": {"api": {"Class.asSubclass()": [[12, 29]]}}}, {"text": "Basically, your comparison needs to obey the documented rules", "label": {"api": {"documented rules": [[45, 60]]}}}, {"text": "As far as searching for previously guessed letters, you may be better served by the Set, which is a Collection of unique elements", "label": {"api": {"Set": [[84, 86]]}}}, {"text": "You could use a Set of Characters, i.e", "label": {"api": {"Set": [[16, 18]], "Characters": [[23, 32]]}}}, {"text": "Actually, you can get some extra mileage out of the add method by taking advantage of the fact that it returns true if the element was not already in the set", "label": {"api": {"add": [[52, 54]]}}}, {"text": "First of all FileInputStream does not have a constructor with parameters file and character set (JavaDoc JDK)", "label": {"api": {"JavaDoc JDK": [[97, 107]]}}}, {"text": "The missing javax.servlet.AsyncListener class is part of Servlet Spec 3.0, which makes sense because Jetty 9.0.x follows that spec", "label": {"api": {"Servlet Spec 3.0": [[57, 72]]}}}, {"text": "As suggested by others, consider using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[39, 52]]}}}, {"text": "Then you can use ProcessBuilder to call the script and get the output", "label": {"api": {"ProcessBuilder": [[17, 30]]}}}, {"text": "The Object.hashCode() javadoc tells you everything you need to know to answer your question", "label": {"api": {"Object.hashCode() javadoc": [[4, 28]]}}}, {"text": "However, for individuals who do not have access to JUnit, it appears as though  System.setIn() will get the job done just as well", "label": {"api": {"System.setIn": [[80, 91]]}}}, {"text": "You can simply give your handler method a parameter of type HttpServletRequest and Spring will provide it for you", "label": {"api": {"HttpServletRequest": [[60, 77]]}}}, {"text": "HttpServletRequest provides a number of methods to retrieve HTTP headers", "label": {"api": {"HttpServletRequest": [[0, 17]], "methods": [[40, 46]]}}}, {"text": "The easiest way to do this is using InternetAddress from JavaMail", "label": {"api": {"InternetAddress": [[36, 50]]}}}, {"text": "Just do new InternetAddress(email).validate() and it will throw an AddressException if it's invalid", "label": {"api": {"InternetAddress": [[12, 26]]}}}, {"text": "The JavaDoc for the LambdaMetaFactory of Java 1.8 specifies that lambda capture \"may involve allocation of a new function object, or may return an existing function object\", but it doesn't specify when and under what circumstances it might choose one way or the other", "label": {"api": {"JavaDoc for the LambdaMetaFactory of Java 1.8": [[4, 48]]}}}, {"text": "You can use Integer.parseInt for this", "label": {"api": {"Integer.parseInt": [[12, 27]]}}}, {"text": "Having said that all, I would say, since you are playing with Java 8, use Optional along with streams here", "label": {"api": {"Optional": [[74, 81]]}}}, {"text": "This code uses the default encoding to turn the returned bytes into chars", "label": {"api": {"default encoding": [[19, 34]]}}}, {"text": "On Windows, the default encoding will likely be a legacy encoding - an \"ANSI\" code page", "label": {"api": {"default encoding": [[16, 31]]}}}, {"text": "You will need to figure out the encoding of the data and provide it explicitly in the String(byte[],Charset) constructor or switch to a documented API - e.g", "label": {"api": {"provide it explicitly": [[57, 77]]}}}, {"text": "But I guess, after clicking the submit button, the login form is submitted to a Java servlet that doesn't implement doGet() or service() methods", "label": {"api": {"Java servlet": [[80, 91]]}}}, {"text": "Callable is not a method", "label": {"api": {"Callable": [[0, 7]]}}}, {"text": "The easiest way is to use Integer.toHexString(int)", "label": {"api": {"Integer.toHexString(int)": [[26, 49]]}}}, {"text": "Use the IdentityHashMap class", "label": {"api": {"IdentityHashMap": [[8, 22]]}}}, {"text": "Note that this class intentionally violates the API contract of java.util.Map which requires that key equality is based on equals(Object)", "label": {"api": {"java.util.Map": [[64, 76]]}}}, {"text": "Use String.valueOf on each element of your array and store it to another String array like this", "label": {"api": {"String.valueOf": [[4, 17]]}}}, {"text": "Do not use a Timer", "label": {"api": {"Timer": [[13, 17]]}}}, {"text": "You can use StreamTokenizer for this in a pinch", "label": {"api": {"StreamTokenizer": [[12, 26]]}}}, {"text": "If you want to pull numbers out separately, then the default StreamTokenizer configuration is fine, although it uses double and provides no int numeric tokens", "label": {"api": {"StreamTokenizer": [[61, 75]]}}}, {"text": "You should take a look at the documentation for Random", "label": {"api": {"Random": [[48, 53]]}}}, {"text": "To execute some arbitrary code based on a timer, use the ServletTimer class which can be created from the TimerService", "label": {"api": {"TimerService": [[106, 117]]}}}, {"text": "When you want to set a timer, obtain a reference to the TimerService", "label": {"api": {"TimerService": [[56, 67]]}}}, {"text": "Use the TimerService to create a ServletTimer with the required timeout period", "label": {"api": {"TimerService": [[8, 19]]}}}, {"text": "As discussed in this link, declare the class to be a listener in the SIP deployment descriptor", "label": {"api": {"this link": [[16, 24]]}}}, {"text": "A RandomAccessFile might help to do this manually, or there may be some libraries that give you an array interface and takes care of the file I/O behind the scenes", "label": {"api": {"RandomAccessFile": [[2, 17]]}}}, {"text": "File#lastAccessTime is probably what you are looking for", "label": {"api": {"File#lastAccessTime": [[0, 18]]}}}, {"text": "One option is to use mutable value like AtomicInteger", "label": {"api": {"AtomicInteger": [[40, 52]]}}}, {"text": "You can use AtomicInteger which has increment and decrement functions", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "You should use the setNull method", "label": {"api": {"setNull method": [[19, 32]]}}}, {"text": "You're looking for the toPattern() method", "label": {"api": {"toPattern() method": [[23, 40]]}}}, {"text": "Use a BufferedReader on top of FileReader instead", "label": {"api": {"BufferedReader": [[6, 19]], "FileReader": [[31, 40]]}}}, {"text": "Take a look to JOptionPane", "label": {"api": {"JOptionPane": [[15, 25]]}}}, {"text": "Also, for reading files from shares, you could use an URI", "label": {"api": {"URI": [[54, 56]]}}}, {"text": "Since the member System.out is of class PrintStream you could do", "label": {"api": {"System.out": [[17, 26]], "PrintStream": [[40, 50]]}}}, {"text": "It is better to use the waitForChange method instead of polling the card terminals", "label": {"api": {"waitForChange": [[24, 36]]}}}, {"text": "Try creating your socket with parameter-less constructor and use connect() method with port and timeout parameter", "label": {"api": {"connect()": [[65, 73]]}}}, {"text": "You can use List.containsAll with JUnit's assertTrue to check that the first list contains every element from the second one, and vice versa", "label": {"api": {"List.containsAll": [[12, 27]]}}}, {"text": "According to javadoc of getResource method", "label": {"api": {"javadoc of getResource method": [[13, 41]]}}}, {"text": "Alternately, those META-INF files are really part of the ServiceLoader mechanism, so maybe you would be better off using that class", "label": {"api": {"ServiceLoader": [[57, 69]]}}}, {"text": "Just use JarFile to examine the jar and extract the information you desire", "label": {"api": {"JarFile": [[9, 15]]}}}, {"text": "Swing Timer API states that a timer will repeat the notification to its listeners by default", "label": {"api": {"Swing Timer API": [[0, 14]]}}}, {"text": "See isRepeats() javadoc", "label": {"api": {"isRepeats()": [[4, 14]]}}}, {"text": "As far as I can see in SourceDataLine interface API it extends from Line interface which allows you add LineListeners to listen LineEvents", "label": {"api": {"SourceDataLine": [[23, 36]], "Line": [[33, 36], [68, 71], [104, 107], [128, 131]], "LineListener": [[104, 115]], "LineEvent": [[128, 136]]}}}, {"text": "You can use the javax.tools to compile the code and then load it into your JVM", "label": {"api": {"javax.tools": [[16, 26]]}}}, {"text": "Oracle has a write-up as does IBM", "label": {"api": {"write-up": [[13, 20]]}}}, {"text": "With each HttpServletRequest comes an array of Cookie objects; You can access them using request.getCookies()", "label": {"api": {"HttpServletRequest": [[10, 27]], "Cookie": [[47, 52], [100, 105]], "request.getCookies()": [[89, 108]]}}}, {"text": "By iterating over this array, you can find the cookie you've previously filled based on its name, and then read its value", "label": {"api": {"name": [[92, 95]], "value": [[116, 120]]}}}, {"text": "Setting a cookie is done by adding it to the response using response.addCookie(...)", "label": {"api": {"Cookie": [[72, 77]], "response.addCookie(...)": [[60, 82]]}}}, {"text": "you can do this by RandomAccessFile class but because fields sizes is not fixed it is will be hard and complex", "label": {"api": {"RandomAccessFile": [[19, 34]]}}}, {"text": "You can use a LinkedList for this", "label": {"api": {"LinkedList": [[14, 23]]}}}, {"text": "With a LinkedList, you can use its iterator to loop through it, and use that same iterator to remove the object from the LinkedList", "label": {"api": {"LinkedList": [[7, 16], [121, 130]]}}}, {"text": "Java's LinkedHashSet doesn't work because it doesn't allow descending traversal", "label": {"api": {"Java's LinkedHashSet": [[0, 19]]}}}, {"text": "How about using a LinkedHashSet and whenever you detect that the item is in there you remove it and reinsert it", "label": {"api": {"LinkedHashSet": [[18, 30]]}}}, {"text": "You can iterate over the LinkedHashSet by creating a LinkedList over the LinkedHashSet and reversing over it in any way you like, e.g", "label": {"api": {"LinkedHashSet": [[25, 37], [73, 85]]}}}, {"text": "The easiest method of accomplishing this is to call Collections.shuffle(List, Random) on your ArrayList after you have inserted all of the elements", "label": {"api": {"Collections.shuffle(List, Random)": [[52, 84]]}}}, {"text": "If you really want to do this as you insert the items instead, you can use add(int, E) to specify the position at which you need to insert the item", "label": {"api": {"add(int, E)": [[75, 85]]}}}, {"text": "The parseDouble method is in the Double class", "label": {"api": {"parseDouble method is in the Double class": [[4, 44]]}}}, {"text": "You could use the subList method", "label": {"api": {"subList": [[18, 24]]}}}, {"text": "http://docs.oracle.com/javaee/7/api/javax/ws/rs/core/GenericEntity.html for my JSONP responses", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/ws/rs/core/GenericEntity.html": [[0, 70]]}}}, {"text": "You can use TrayIcon to create a tray icon", "label": {"api": {"TrayIcon": [[12, 19]]}}}, {"text": "To add pop up, you can use the method setPopupMenu(PopupMenu popup) function", "label": {"api": {"setPopupMenu(PopupMenu popup)": [[38, 66]]}}}, {"text": "Take a look at DateFormat and particularly SimpleDateFormat", "label": {"api": {"DateFormat": [[15, 24], [49, 58]], "SimpleDateFormat": [[43, 58]]}}}, {"text": "Your example would be coded like this, using SimpleDateFormat", "label": {"api": {"DateFormat": [[51, 60]], "SimpleDateFormat": [[45, 60]]}}}, {"text": "If you aren't trying to make your own, try using a Set", "label": {"api": {"Set": [[51, 53]]}}}, {"text": "Actually DocFlavor.STRING is a nested class", "label": {"api": {"DocFlavor.STRING": [[9, 24]]}}}, {"text": "PrintService is an interface and cannot be instantiated", "label": {"api": {"PrintService": [[0, 11]]}}}, {"text": "I have looked at the java api for the StrictMath class (http://docs.oracle.com/javase/7/docs/api/java/lang/StrictMath.html) and it mentions something called fdlimb", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/StrictMath.html": [[56, 121]]}}}, {"text": "The JDK is not obligated to compute sine and cosine on its own, only to provide you with an interface to some implementation via Math", "label": {"api": {"Math": [[129, 132]]}}}, {"text": "I believe HotSpot has the ability to spot Math.cos(), etc", "label": {"api": {"Math": [[42, 45]]}}}, {"text": "From the documentation for Math", "label": {"api": {"Math": [[27, 30]]}}}, {"text": "By default many of the Math methods simply call the equivalent method in StrictMath for their implementation", "label": {"api": {"Math": [[23, 26], [79, 82]], "StrictMath": [[73, 82]]}}}, {"text": "Code generators are encouraged to use platform-specific native libraries or microprocessor instructions, where available, to provide higher-performance implementations of Math methods", "label": {"api": {"Math": [[171, 174]]}}}, {"text": "Such higher-performance implementations still must conform to the specification for Math", "label": {"api": {"Math": [[84, 87]]}}}, {"text": "The documentation for StrictMath actually mentions fdlibm (it places the constraint on StrictMath that all functions must produce the same results that fdlibm produces)", "label": {"api": {"Math": [[28, 31], [93, 96]], "StrictMath": [[22, 31], [87, 96]]}}}, {"text": "These algorithms are available from the well-known network library netlib as the package \"Freely Distributable Math Library,\" fdlibm", "label": {"api": {"Math": [[111, 114]]}}}, {"text": "Note, however, that Math is not required to defer to StrictMath", "label": {"api": {"Math": [[20, 23], [59, 62]], "StrictMath": [[53, 62]]}}}, {"text": "Use StrictMath explicitly in your code if you want to guarantee consistent results across all platforms", "label": {"api": {"Math": [[10, 13]], "StrictMath": [[4, 13]]}}}, {"text": "HotSpot) are not given the freedom to optimize StrictMath calls to hardware calls unless the hardware would produce exactly the same results as fdlibm", "label": {"api": {"Math": [[53, 56]], "StrictMath": [[47, 56]]}}}, {"text": "The easiest option is to probably have the FileWriter open the file in append mode", "label": {"api": {"open the file in append mode": [[54, 81]]}}}, {"text": "You can try this, using Stream", "label": {"api": {"Stream": [[24, 29]]}}}, {"text": "The DecimalFormat class is the correct place to look", "label": {"api": {"DecimalFormat class": [[4, 22]]}}}, {"text": "Take a look at the Runtime class", "label": {"api": {"Runtime": [[19, 25]]}}}, {"text": "In particular, look at Runtime.exec()", "label": {"api": {"Runtime": [[23, 29]]}}}, {"text": "Read java.util.Formatter javadoc for more formatting options", "label": {"api": {"java.util.Formatter": [[5, 23]]}}}, {"text": "Have a look at the string docs", "label": {"api": {"the string docs": [[15, 29]]}}}, {"text": "Maybe you can do that using Files.readAttributes()", "label": {"api": {"Files.readAttributes()": [[28, 49]]}}}, {"text": "If symlink1 is a Path to your first symlink and symlink2 a Path to your second symlink, and realFile a Path to your real file, then you can retrieve FileTime objects of the last access time for both symlinks and last modification time of the file using", "label": {"api": {"FileTime": [[149, 156]]}}}, {"text": "Since FileTime is Comparable to itself, you may spot which symlink is modified but this is NOT a guarantee", "label": {"api": {"FileTime": [[6, 13]]}}}, {"text": "You can access the properties via the ResourceBundle API", "label": {"api": {"ResourceBundle API": [[38, 55]]}}}, {"text": "You have it well explained in the Comparator.compare docs", "label": {"api": {"Comparator.compare": [[34, 51]]}}}, {"text": "Following @Eelco's comment (and for completeness), the conversion to a map is better down with Collectors.toMap like this", "label": {"api": {"Collectors.toMap": [[95, 110]]}}}, {"text": "The properly implemented Object.equals is symmetric, meaning that there should be no difference between anObject.equals(element) and element.equals(anObject)", "label": {"api": {"Object.equals": [[25, 37], [106, 118]]}}}, {"text": "I am not sure that library creators tried to prevent programmers from implementing broken equals() by choosing that specific anObject.equals(element) expression, but even if it was element.equals(anObject) it would still be bad practice to provide deliberately incorrect equals() implementation just for the sake of simplifying the combobox selection", "label": {"api": {"Object.equals": [[127, 139]]}}}, {"text": "String.split() could be used to separate the line into two tokens instead of explicitly coding the separation", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "A Properties style file could be used to store the abbreviation-to-term map instead of a comma separated file", "label": {"api": {"Properties": [[2, 11]]}}}, {"text": "The Properties class provides a mechanism for loading the file and methods for searching the map", "label": {"api": {"Properties": [[4, 13]]}}}, {"text": "You need to pass Class<T> clazz as argument to your method, then use it to check if the element can be assignable to that class by using Class#isInstance", "label": {"api": {"Class#isInstance": [[137, 152]]}}}, {"text": "Your best solution is to use an AtomicInteger, they were basically designed for exactly this use case", "label": {"api": {"AtomicInteger": [[32, 44]]}}}, {"text": "If this is more of a theoretical \"could this be done question\", I think something like the following would be safe (but still not perform as well as an AtomicInteger)", "label": {"api": {"AtomicInteger": [[152, 164]]}}}, {"text": "Java offers several Queue implementations that are thread-safe, notably ConcurrentLinkedQueue and LinkedBlockingQueue", "label": {"api": {"Queue": [[20, 24], [88, 92], [112, 116]], "ConcurrentLinkedQueue": [[72, 92]], "LinkedBlockingQueue": [[98, 116]]}}}, {"text": "The handleEvent() component method is marked as deprecated and replaced with processEvent()", "label": {"api": {"handleEvent()": [[4, 16]], "processEvent()": [[77, 90]]}}}, {"text": "handleEvent() was having a return value to indicate whether the event was processed or not, while processEvent() has no such return value", "label": {"api": {"handleEvent()": [[0, 12]], "processEvent()": [[98, 111]]}}}, {"text": "So how does processEvent() signal that it was unable to process the event", "label": {"api": {"processEvent()": [[12, 25]]}}}, {"text": "You may use threads using ExecutorService", "label": {"api": {"ExecutorService": [[26, 40]]}}}, {"text": "In any case, the result computed by the Area should be in line with the definition of \"insideness\" in the Shape class", "label": {"api": {"definition of \"insideness\" in the Shape class": [[72, 116]]}}}, {"text": "From the Java docs (http://docs.oracle.com/javase/7/docs/api)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api": [[20, 59]]}}}, {"text": "See Class.getDeclaredField() and Field.get()", "label": {"api": {"Class.getDeclaredField()": [[4, 27]], "Field.get()": [[33, 43]]}}}, {"text": "The number of threads passed into newFixedThreadPool is at most how many threads could be running executing your tasks", "label": {"api": {"The number of threads passed into newFixedThreadPool is at most how many threads could be running executing your tasks": [[0, 117]]}}}, {"text": "Sounds like a use case for a Map which you can use the ID as the key and a value (or potentially an array of values, if multiple values can have the same id) as the value", "label": {"api": {"Map": [[29, 31]]}}}, {"text": "The problem with using a List like this is if I have two ids 1 and 3000 then there are 2998 indices that are wasted, which is not exactly ideal", "label": {"api": {"List": [[25, 28]]}}}, {"text": "In the case of equals(), you'd start with", "label": {"api": {"equals()": [[15, 22]]}}}, {"text": "If you look at the documentation for Object.equals(), you can see that it actually returns a boolean, not a Boolean", "label": {"api": {"Object.equals()": [[37, 51]]}}}, {"text": "Your Pizza will have to implement, e.g., Comparable<Pizza> and then override int compareTo(Pizza); the implementation should behave as defined in the documentation for Comparable.compareTo(), and the exact logic you use for determining the result depends on the requirements given in your problem description", "label": {"api": {"Comparable<Pizza>": [[41, 57]], "Comparable.compareTo()": [[168, 189]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/awt/EventQueue.html for details", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/EventQueue.html": [[4, 68]]}}}, {"text": "My suggestion you experiment with ExecutorService, and implement Runnable and send in Runnables for it to run", "label": {"api": {"ExecutorService": [[34, 48]], "Runnable": [[65, 72], [86, 93]]}}}, {"text": "It will automatically assign the new Runnables you send in to a Thread when it becomes available", "label": {"api": {"Runnable": [[37, 44]]}}}, {"text": "You can start an ExecutorService with a fixed number of threads simply by calling Executors.newFixedThreadPool(int numThreads)", "label": {"api": {"ExecutorService": [[17, 31]]}}}, {"text": "Then just call submit(Runnable runnableWithYourProcessing)", "label": {"api": {"Runnable": [[22, 29]]}}}, {"text": "You can use ImageIO.read(File) to read in an image from a file (you can adjust the position and size of the image inside the paintComponent method)", "label": {"api": {"ImageIO.read(File)": [[12, 29]]}}}, {"text": "You may want to also see Graphics.drawImage`", "label": {"api": {"Graphics.drawImage`": [[25, 43]]}}}, {"text": "Knowing that each part is an exact length--and if it happens to be less, it's padded by spaces--this is a perfect situation for using String.substring(i,i) and String.trim()", "label": {"api": {"String.substring(i,i)": [[134, 154]], "String.trim()": [[160, 172]]}}}, {"text": "Also see the Javadoc for Scanner", "label": {"api": {"Javadoc for Scanner": [[13, 31]]}}}, {"text": "Consider using XPath for this", "label": {"api": {"XPath": [[15, 19]]}}}, {"text": "Use Pattern.compile(s) to obtain a Pattern out of a String s", "label": {"api": {"Pattern": [[4, 10], [35, 41]]}}}, {"text": "Use p.matcher(s) to obtain a Matcher out of a Pattern p on a String s", "label": {"api": {"Pattern": [[46, 52]], "Matcher": [[29, 35]]}}}, {"text": "Then you can use the Matcher", "label": {"api": {"Matcher": [[21, 27]]}}}, {"text": "Note that ideally you should store Patterns as keys in your Map; creating the same set of patterns each time is a waste", "label": {"api": {"Pattern": [[35, 41]]}}}, {"text": "See the API docs for ImageIO.getImageWritersByFormatName(String) for more information", "label": {"api": {"ImageIO.getImageWritersByFormatName(String)": [[21, 63]]}}}, {"text": "Then use writer.canWriteSequence() to tell if your writer instance supports writing sequences", "label": {"api": {"writer.canWriteSequence()": [[9, 33]]}}}, {"text": "Next, use writer.prepareWriteSequence(...) to prepare your image sequence", "label": {"api": {"writer.prepareWriteSequence(...)": [[10, 41]]}}}, {"text": "For each image (page) you want to append, use  writer.writeToSequence(new IIOImage(..., bufferedImage, null), ...) in a for loop", "label": {"api": {"writer.writeToSequence(new IIOImage(..., bufferedImage, null), ...)": [[47, 113]]}}}, {"text": "Then finally, outside the for loop use writer.endWriteSequence() to end the image sequence", "label": {"api": {"writer.endWriteSequence()": [[39, 63]]}}}, {"text": "The important changes are removing the writer.setOutput(ios) from the loop (you should only set it once), and moving writer.endWriteSequence() oustide the loop", "label": {"api": {"writer.endWriteSequence()": [[117, 141]]}}}, {"text": "you just can use the java function replaceAll, or replaceFirst, if you want to that just for the first occurrence", "label": {"api": {"replaceAll": [[35, 44]], "replaceFirst": [[50, 61]]}}}, {"text": "With Java 7 and up, a one liner using Files", "label": {"api": {"Files": [[38, 42]]}}}, {"text": "Can't you use the code that is present in Arrays.hashCode already", "label": {"api": {"Arrays.hashCode": [[42, 56]]}}}, {"text": "Then I convert this javax.Message into a String with (String) getContent()", "label": {"api": {"javax.Message": [[20, 32]]}}}, {"text": "The ClassLoader#loadClass(String) method throws the declared exception ClassNotFoundException", "label": {"api": {"ClassLoader#loadClass(String)": [[4, 32]]}}}, {"text": "It looks like you have to use method prepareCall with additional parameters and, possible, additional parameters are required for method execute", "label": {"api": {"prepareCall": [[37, 47]], "execute": [[137, 143]]}}}, {"text": "Some references JPA Tutorial ;JPQL", "label": {"api": {"JPQL": [[30, 33]]}}}, {"text": "Yes, Runnable or Callable (if you need to return a result) are perfectly fine to use", "label": {"api": {"Runnable": [[5, 12]], "Callable": [[17, 24]]}}}, {"text": "As per the Java CallableStatement API, you should use this syntax", "label": {"api": {"Java CallableStatement API": [[11, 36]]}}}, {"text": "It can be done in O(n) time (average case) and space by creating a HashMap<Integer,A> where the key is the ID, and the value is the A object", "label": {"api": {"HashMap<Integer,A>": [[67, 84]]}}}, {"text": "The method that cannot be invoked multiple times is start()(according to Thread)", "label": {"api": {"Thread": [[73, 78]]}}}, {"text": "You should use a Task for your off JavaFX thread logic, then, rather than using runLater, you could bind the spinner visible property to the task running property", "label": {"api": {"Task": [[17, 20]]}}}, {"text": "Does using Collection.contains() help at all", "label": {"api": {"Collection.contains()": [[11, 31]]}}}, {"text": "The mod method returns another BigInteger, and a BigInteger is a Number, so you can just call intValue() to get an int that can be the switch argument", "label": {"api": {"intValue()": [[94, 103]]}}}, {"text": "You're looking for BigInteger's negate() method", "label": {"api": {"BigInteger's negate() method": [[19, 46]]}}}, {"text": "Use the Arrays.sort() that takes a Comparator, then, depending on the selection, create a Comparator<Event> that compares two Events based on the selected sort key, e.g.", "label": {"api": {"Arrays.sort()": [[8, 20]]}}}, {"text": "ImageIO.read() will return null for formats it doesn't support", "label": {"api": {"ImageIO.read()": [[0, 13]]}}}, {"text": "You can query the formats you have installed support for, using ImageIO.getReaderFormatNames()", "label": {"api": {"ImageIO.getReaderFormatNames()": [[64, 93]]}}}, {"text": "If you're looking for absolute precision, look into BigDecimal", "label": {"api": {"BigDecimal": [[52, 61]]}}}, {"text": "IMO, creating a new List<T> will be better then removing from the existing List<T>, if you can specify enough initial capacity (see - public ArrayList(int initialCapacity), the constructor that lets you specify the capacity of the ArrayList at the time of it's construction)", "label": {"api": {"public ArrayList(int initialCapacity)": [[134, 170]]}}}, {"text": "You're not assigning a value to statement in that method, and you're using the overload of executeUpdate from Statement..", "label": {"api": {"overload of executeUpdate from Statement": [[79, 118]]}}}, {"text": "I suspect you actually want to assign the statement using Connection.prepareStatement", "label": {"api": {"Connection.prepareStatement": [[58, 84]]}}}, {"text": "The returned value is actually number of pixels, even if Java API doesn't precise it", "label": {"api": {"Java API": [[57, 64]]}}}, {"text": "See also the documentation for StackOverflowError, which states", "label": {"api": {"StackOverflowError": [[31, 48]]}}}, {"text": "clone() is protected which means it is only accessible from a subclass or that very same package", "label": {"api": {"clone()": [[0, 6]]}}}, {"text": "When you change the parameter to HashMap<K, V> for example you can call it because HashMap overrides the clone() method with a public modifier", "label": {"api": {"clone()": [[105, 111]]}}}, {"text": "HashMap defines its own clone() method", "label": {"api": {"clone()": [[24, 30]]}}}, {"text": "Byte also has a .parseByte() method taking a radix as an argument", "label": {"api": {".parseByte() method taking a radix": [[16, 49]]}}}, {"text": "Use getDeclaredMethods which returns all methods, including the ones that aren't public", "label": {"api": {"getDeclaredMethods": [[4, 21]]}}}, {"text": "This is a pretty large class and calling getDeclaredMethods on it will create a pretty large amount of objects", "label": {"api": {"getDeclaredMethods": [[41, 58]]}}}, {"text": "Finally, remember that Thread.sleep is itself subject to precision problems", "label": {"api": {"Thread.sleep": [[23, 34]]}}}, {"text": "and then use next() which returns the next complete token, since hasNext() returns a boolean representinf if the scanner has another token in its input", "label": {"api": {"next()": [[13, 18]], "hasNext()": [[65, 73]]}}}, {"text": "You can use the setReadOnly() method of File", "label": {"api": {"setReadOnly()": [[16, 28]]}}}, {"text": "The method File#listFiles() yields null if the file object (f) does not denote a directory (or if an I/O-error occurs)", "label": {"api": {"File#listFiles()": [[11, 26]]}}}, {"text": "You may be able to determine the actual implemented type via getGenericInterfaces et", "label": {"api": {"getGenericInterfaces": [[61, 80]]}}}, {"text": "Why not simply use DoubleStream#summaryStatistics or apply a similar pattern", "label": {"api": {"DoubleStream#summaryStatistics": [[19, 48]]}}}, {"text": "Use the next() method to read a String", "label": {"api": {"next()": [[8, 13]]}}}, {"text": "Now from ArrayList doc I get the idea of updating a list element using its index by set operation", "label": {"api": {"ArrayList doc": [[9, 21]]}}}, {"text": "Use a DoubleBuffer, it is much easier to do what you want to achieve", "label": {"api": {"DoubleBuffer": [[6, 17]]}}}, {"text": "To create a new DoubleBuffer which is..", "label": {"api": {"DoubleBuffer": [[16, 27]]}}}, {"text": "Also note that a DoubleBuffer, like any XBuffer, allows you to set endianness", "label": {"api": {"DoubleBuffer": [[17, 28]]}}}, {"text": "+ ..., you can use a StringBuilder (see Javadoc for java.lang.StringBuilder) to assemble it across several statements", "label": {"api": {"see Javadoc for java.lang.StringBuilder": [[36, 74]]}}}, {"text": "As per http://docs.oracle.com/javase/7/docs/api/javax/sound/midi/MidiSystem.html#getSequence%28java.io.File%29, MidiSystem.getSequence(File) throws InvalidMidiDataException and IOException", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/sound/midi/MidiSystem.html#getSequence%28java.io.File%29": [[7, 109]]}}}, {"text": "Same amount of code, except no need converting to list, using EnumSet.of()", "label": {"api": {"EnumSet.of()": [[62, 73]]}}}, {"text": "Read more about Java Regex Pattern", "label": {"api": {"Java Regex Pattern": [[16, 33]]}}}, {"text": "Server-side, you can use http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getParameter(java.lang.String) to get the query string parameters and process them", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getParameter(java.lang.String)": [[25, 124]]}}}, {"text": "you can loop through elements of the ArrayList and use String#split(delimiter) to separate   the string based in the delimiter", "label": {"api": {"String#split(delimiter)": [[55, 77]]}}}, {"text": "You can use NumberFormat by setting the locale to Indian setting", "label": {"api": {"NumberFormat": [[12, 23]]}}}, {"text": "If you're using Java 8, you might check out the new java.time package, which provides a new and hopefully better API for dates and times; Oracle tutorial here", "label": {"api": {"java.time package": [[52, 68]]}}}, {"text": "Last, to remove the first comma, use Sting#substring or (better solution), when you print for the first time, simply don't print the comma and add it only in the iterations", "label": {"api": {"Sting#substring": [[37, 51]]}}}, {"text": "If you need to be able to store null in b, one possibility would be to change its type to Integer", "label": {"api": {"Integer": [[90, 96]]}}}, {"text": "This will match on anything containing a line separator, and since hitting return/enter will produce that, it will match the entire line you enter, even if it's a blank line", "label": {"api": {"containing a line separator": [[28, 54]]}}}, {"text": "You can use a static ThreadLocal in some class and set its value to whatever diff is", "label": {"api": {"ThreadLocal": [[21, 31]]}}}, {"text": "You can then access that ThreadLocal anywhere else", "label": {"api": {"ThreadLocal": [[25, 35]]}}}, {"text": "You can access your file as a resource using the ServletContext.getResourceAsStream(), the file can be located anywhere in your web application", "label": {"api": {"ServletContext.getResourceAsStream()": [[49, 84]]}}}, {"text": "What happens is that the method replaceAll() uses a regex (regular expression) to determine what to replace", "label": {"api": {"replaceAll()": [[32, 43]]}}}, {"text": "You may want to use the method replace() that uses strings literally to replace", "label": {"api": {"replace()": [[31, 39]]}}}, {"text": "The method of transferring these packets would be through a java.lang.Process, which I have set up already", "label": {"api": {"java.lang.Process": [[60, 76]]}}}, {"text": "By using the interface, the method which call the constructor of your class will be able to use ArrayList or LinkedList (or an other one)", "label": {"api": {"an other one": [[124, 135]]}}}, {"text": "You could do a variant of the above, but with a larger type (this is how, e.g., InputStream.read() indicates EOF), so that the \"magic\" value can't be in the valid range", "label": {"api": {"InputStream.read()": [[80, 97]]}}}, {"text": "You can use Integer.toUnsignedString to get the results you're expecting", "label": {"api": {"Integer.toUnsignedString": [[12, 35]]}}}, {"text": "Actually I don't think you want to pass a class of type Class as argument", "label": {"api": {"Class": [[56, 60]]}}}, {"text": "The actual cause of the problem is the usage of InputStream.available() to get the size of the data", "label": {"api": {"InputStream.available()": [[48, 70]]}}}, {"text": "A BreakIterator can be used to determine sentence boundaries", "label": {"api": {"BreakIterator": [[2, 14]]}}}, {"text": "StringBuilder.append() returns a StringBuilder (this), so you can chain append() commands", "label": {"api": {"StringBuilder.append()": [[0, 21]]}}}, {"text": "Of course you can catch all WebApplicationException in a single catch clause, as all exceptions extend it (e.g check BadRequestException)", "label": {"api": {"WebApplicationException": [[28, 50]]}}}, {"text": "NodeList is designed to store an ordered collection of Nodes", "label": {"api": {"NodeList": [[0, 7]], "Nodes": [[55, 59]]}}}, {"text": "By calling getTextContent you get the text content of this node and its descendants", "label": {"api": {"getTextContent": [[11, 24]]}}}, {"text": "The problem is that you have re-defined the Comparable<T> interface that Java has already defined", "label": {"api": {"Comparable<T>": [[44, 56]]}}}, {"text": "The Collections.sort method knows about java.lang.Comparable<T>, but it has no idea about your Chapter10.Comparable<T>", "label": {"api": {"Comparable<T>": [[50, 62], [105, 117]]}}}, {"text": "When you want to schedule something to happen at regular intervals, you can use a java.util.Timer with one or more java.util.TimerTasks", "label": {"api": {"java.util.Timer": [[82, 96], [115, 129]], "java.util.TimerTask": [[115, 133]]}}}, {"text": "Don't be concerned about performance of List.toArray(), its complexity is linear as it will resort to a single loop internally", "label": {"api": {"List.toArray()": [[40, 53]]}}}, {"text": "As it is implemented with Arrays.copyOf, which eventually comes to System.arraycopy, that is implemented in native code it could be potentially even faster than a java-level loop", "label": {"api": {"Arrays.copyOf": [[26, 38]], "System.arraycopy": [[67, 82]]}}}, {"text": "The method print in the class java.awt.Desktop", "label": {"api": {"print": [[11, 15]], "java.awt.Desktop": [[30, 45]]}}}, {"text": "Prints a file with the native desktop printing facility, using the associated application's print command", "label": {"api": {"print": [[38, 42], [92, 96]]}}}, {"text": "You can use the String#toUpperCase() method", "label": {"api": {"String#toUpperCase()": [[16, 35]]}}}, {"text": "Reading through the documentation for java.nio.CharBuffer, I don't see any explicit semantics given as to how trailing partial multibyte characters are handled", "label": {"api": {"java.nio.CharBuffer": [[38, 56]]}}}, {"text": "Given a series of ByteBuffers, what's the best way to get (complete) characters out of them, understanding that a character may span the gap between two sequencial ByteBuffers", "label": {"api": {"ByteBuffer": [[18, 27], [164, 173]]}}}, {"text": "If you are able to use Java 8 you can use the new Date and Time API", "label": {"api": {"Date and Time API": [[50, 66]]}}}, {"text": "Specifically, you will find the new Month enum useful", "label": {"api": {"Month": [[36, 40]]}}}, {"text": "You can use ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[12, 38]]}}}, {"text": "I do advice you read up on String class but if you do not and simply copy my answer, then no one will cry for you because you fail the class by not putting effort into homework", "label": {"api": {"String class": [[27, 38]]}}}, {"text": "The best option would be to change HashMap for ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[47, 63]]}}}, {"text": "The problem is Iterator<Product> iterator field", "label": {"api": {"Iterator": [[15, 22]]}}}, {"text": "Iterator doesn't implement Serializable", "label": {"api": {"Iterator": [[0, 7]]}}}, {"text": "Look into the ProcessBuilder class, and it's associated classes like Process, and Runtime", "label": {"api": {"ProcessBuilder": [[14, 27]]}}}, {"text": "The close of the interface AutoCloseable should only be called once", "label": {"api": {"AutoCloseable": [[27, 39]]}}}, {"text": "See the documentation of AutoCloseable for more information", "label": {"api": {"AutoCloseable": [[25, 37]]}}}, {"text": "If you happen to know the index ahead of time (i.e., you statically initialize the list of options instead of dynamically generating the list), you could also just refer to .getSelectedIndex() to retrieve the index as follows", "label": {"api": {".getSelectedIndex()": [[173, 191]]}}}, {"text": "Because invokeAll() is a Generic Method, you may need to use special syntax to indicate what they type of T is", "label": {"api": {"invokeAll()": [[8, 18]]}}}, {"text": "BufferedImage is a subclass of Image", "label": {"api": {"BufferedImage": [[0, 12]], "Image": [[8, 12], [31, 35]]}}}, {"text": "You could also use an ActionListener on a button to either control the Timer or on a button to move the object manually once per click", "label": {"api": {"ActionListener": [[22, 35]]}}}, {"text": "If you're working with the single thread model, you can use a ThreadLocal", "label": {"api": {"ThreadLocal": [[62, 72]]}}}, {"text": "Either use a class with a public static final ThreadLocal field or make a singleton bean with an instance field", "label": {"api": {"ThreadLocal": [[46, 56]]}}}, {"text": "What you put in the ThreadLocal is entirely up to you", "label": {"api": {"ThreadLocal": [[20, 30]]}}}, {"text": "The current thread is looked up using Thread.currentThread() inside the method Thread.interrupted()", "label": {"api": {"Thread.currentThread()": [[38, 59]]}}}, {"text": "Thread.currentThread() returns a reference to the calling thread", "label": {"api": {"Thread.currentThread()": [[0, 21]]}}}, {"text": "Calling ArrayList#add returns a boolean which is not the desired value for your Map, thus getting the compiler error", "label": {"api": {"ArrayList#add": [[8, 20]]}}}, {"text": "Don't use regex for this task, use String#split (that takes a regex)", "label": {"api": {"String#split": [[35, 46]]}}}, {"text": "This is exposed to you through the SwingUtilities.invokeLater(Runnable runnable) class", "label": {"api": {"SwingUtilities.invokeLater(Runnable runnable)": [[35, 79]]}}}, {"text": "I want to convert java.time.LocalDate into java.util.Date type", "label": {"api": {"java.time.LocalDate": [[18, 36]], "java.util.Date": [[43, 56]], "java.time": [[18, 26]]}}}, {"text": "Or is there any date chooser that supports java.time dates", "label": {"api": {"java.time": [[43, 51]]}}}, {"text": "You should use 'java.text.NumberFormat'", "label": {"api": {"'java.text.NumberFormat'": [[15, 38]]}}}, {"text": "I would like to understand the purpose of the proxy argument of the invoke method of java.lang.reflect.InvocationHandler", "label": {"api": {"invoke": [[68, 73]]}}}, {"text": "You can use a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[14, 34]]}}}, {"text": "After having written to it/flushed it/closed it (although those two last operations are essentially a no-op, that's no reason for ditching sane practices), you can obtain the underlying byte array using this class's .toByteArray()", "label": {"api": {".toByteArray()": [[216, 229]]}}}, {"text": "Instead, you could pack those files into a ZIP file (using a ZipOutputStream), and return that as your response", "label": {"api": {"ZipOutputStream": [[61, 75]]}}}, {"text": "A BoxLayout might be what you're after", "label": {"api": {"BoxLayout": [[2, 10]]}}}, {"text": "If you really need to store your properties in WEB-INF, you can try to resolve the file system path where it is deployed to using ServletContext.getRealPath()", "label": {"api": {"ServletContext.getRealPath()": [[130, 157]]}}}, {"text": "Once you do that, you can also make use of ResourceBundle to read the properties", "label": {"api": {"ResourceBundle": [[43, 56]]}}}, {"text": "An example using Java 1.7's Files class", "label": {"api": {"Files": [[28, 32]]}}}, {"text": "The second problem is that you try to read bytes from a Reader", "label": {"api": {"Reader": [[56, 61]]}}}, {"text": "And as you construct one with new InputStreamReader(InputStream), it uses the default platform character set", "label": {"api": {"Reader": [[45, 50]], "InputStream": [[34, 44], [52, 62]]}}}, {"text": "drop the use of a BufferedReader and read the bytes directly from an InputStream, or if the data is actually character data, then make sure you 1) use char and char[] and 2) specify the expected encoding when constructing the Reader", "label": {"api": {"Reader": [[26, 31], [226, 231]], "InputStream": [[69, 79]]}}}, {"text": "You don't really need the characters to be sorted, so you can use a Set (e.g", "label": {"api": {"Set": [[68, 70]]}}}, {"text": "a TreeSet) for them instead of an ArrayList", "label": {"api": {"Set": [[6, 8]], "TreeSet": [[2, 8]]}}}, {"text": "I suspect you just want Class.getClasses()", "label": {"api": {"Class.getClasses()": [[24, 41]]}}}, {"text": "So call MyClass.class.getClasses(), and then filter out non-interfaces using Class.isInterface", "label": {"api": {"Class.isInterface": [[77, 93]]}}}, {"text": "This is quite similar approach to Overriding Object's equals method for new types", "label": {"api": {"equals": [[54, 59]]}}}, {"text": "You can take advantage of @PostConstruct annotation", "label": {"api": {"@PostConstruct": [[26, 39]]}}}, {"text": "To use @PostConstruct, take into account", "label": {"api": {"@PostConstruct": [[7, 20]]}}}, {"text": "There must be only one method decorated by @PostConstruct", "label": {"api": {"@PostConstruct": [[43, 56]]}}}, {"text": "the javadoc of the method", "label": {"api": {"javadoc of the method": [[4, 24]]}}}, {"text": "If you can change your template string, then you could use String.format(...) and reduce it to one function call", "label": {"api": {"String.format(...)": [[59, 76]]}}}, {"text": "As you see SQLException  extends exception", "label": {"api": {"SQLException": [[11, 22]]}}}, {"text": "But when you are catching SQLException then you catch only that(which is good because that is what you are seeking)", "label": {"api": {"SQLException": [[26, 37]]}}}, {"text": "Catching Exception is dangerous because it also catches all RuntimeExceptions (therefore unchecked exceptions), and that include niceties such as NullPointerException etc which are clear programmer errors", "label": {"api": {"RuntimeException": [[60, 75]]}}}, {"text": "For instance, SQLException has a .getErrorCode() method which Exception does not have", "label": {"api": {".getErrorCode() method": [[33, 54]]}}}, {"text": "So we need SerialExecutor described in api/java/util/concurrent/Executor, which accepts Runnables and executes them serially, but on another executor", "label": {"api": {"api/java/util/concurrent/Executor": [[39, 71]]}}}, {"text": "You're looking for matches(), which will accept a regular expression", "label": {"api": {"matches()": [[19, 27]]}}}, {"text": "From the Stream javadoc", "label": {"api": {"Stream javadoc": [[9, 22]]}}}, {"text": "Note that the indexOf() method will return -1 when the specified object is not contained within the list", "label": {"api": {"indexOf()": [[14, 22]]}}}, {"text": "Another possibility is that you need to override equals() (and as a consequence, also hashCode()) so that your indexOf() lookup succeeds", "label": {"api": {"indexOf()": [[111, 119]]}}}, {"text": "u may try StringBuilder", "label": {"api": {"StringBuilder": [[10, 22]]}}}, {"text": "If you don't want to have duplicates, construct a new Set, then convert it back to List", "label": {"api": {"Set": [[54, 56]], "List": [[83, 86]]}}}, {"text": "Java binarySearch method is documented as \"If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found\"", "label": {"api": {"documented": [[28, 37]]}}}, {"text": "The C++ std::map is an ordered data-structure usually implemented as a tree", "label": {"api": {"std::map": [[8, 15]]}}}, {"text": "A fairer comparison would be between java.util.HashMap and std::unordered_map or java.util.TreeMap and std::map", "label": {"api": {"std::map": [[103, 110]], "java.util.HashMap": [[37, 53]], "java.util.TreeMap": [[81, 97]]}}}, {"text": "I'm implementing a Java key store  and one of the methods I could override is KeyStoreSpi.engineStore(KeyStore.LoadStoreParameter param), which is supposed to store the key store based on the supplied parameters", "label": {"api": {"KeyStoreSpi.engineStore(KeyStore.LoadStoreParameter param)": [[78, 135]]}}}, {"text": "The LoadStoreParameter argument is a loose wrapper around ProtectionParameter, which seems to only provide access to password information", "label": {"api": {"ProtectionParameter": [[58, 76]]}}}, {"text": "If you can reduce your problem to comparing a pairs of strings, the java.text.Collator (SE 7 JavaDoc, Android JavaDoc) provides a base for comparing two strings using different \"strength\" modes", "label": {"api": {"SE 7 JavaDoc": [[88, 99]]}}}, {"text": "Either, as you suggest, use BufferedImage.getType() (you can find what the int return values mean, in the API doc)", "label": {"api": {"API doc": [[106, 112]]}}}, {"text": "The above code will throw an ArithmeticException which extends from RuntimeException thereby reducing your work of throwing a RuntimeException explicitly", "label": {"api": {"ArithmeticException": [[29, 47]]}}}, {"text": "You don't have to explicitly throw that exception, java.lang.ArithmeticException will be thrown if the divisor is zero", "label": {"api": {"java.lang.ArithmeticException": [[51, 79]]}}}, {"text": "It creates a new Random when you call shuffle method (if there is no previous Random assigned to static r)", "label": {"api": {"Random": [[17, 22], [78, 83]]}}}, {"text": "You could pack your tasks into it and run them all as threads using a ThreadPoolExecutor (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html": [[90, 174]]}}}, {"text": "To retrieve the result of each call, you then have to use the Future object that each of the submits gave you, using get()", "label": {"api": {"Future": [[62, 67]]}}}, {"text": "Just use the object itself", "label": {"api": {"object itself": [[13, 25]]}}}, {"text": "Which will remove everything from the list btw, so you could just do clear()", "label": {"api": {"clear()": [[69, 75]]}}}, {"text": "Per the API documentation, it is optional to throw a ClassCastException, which List won't throw", "label": {"api": {"API documentation": [[8, 24]]}}}, {"text": "I was wondering if there is an elegant way to do this using the javax.validation annotations, i.e", "label": {"api": {"javax.validation": [[64, 79]]}}}, {"text": "You can create your own Dialog by using a JPasswordField, which hides characters by default", "label": {"api": {"JPasswordField": [[42, 55]]}}}, {"text": "Use setEchoChar() to change the character displayed to the user while typing", "label": {"api": {"setEchoChar()": [[4, 16]]}}}, {"text": "If you really want to know the file type, you have to read it directly from the file with MidiSystem.getMidiFileFormat", "label": {"api": {"MidiSystem.getMidiFileFormat": [[90, 117]]}}}, {"text": "The \"ulp\" (unit in last place) of a float that big is 8.0, but the \"ulp\" for  a double that big is still reasonably small", "label": {"api": {"\"ulp\" (unit in last place) of a float": [[4, 40]], "\"ulp\" for  a double": [[67, 85]]}}}, {"text": "Yes, use Stream#findFirst() method", "label": {"api": {"Stream#findFirst()": [[9, 26]]}}}, {"text": "You can find information in the Thread javadoc", "label": {"api": {"Thread javadoc": [[32, 45]]}}}, {"text": "To do this, you need to change the action of closing the frame to JFrame.DO_NOTHING_ON_CLOSE and add a WindowListener (I use a WindowAdapter since it makes things easier) that programatically closes the current frame and opens a new one (I just followed the recommendation in this answer for closing the window)", "label": {"api": {"JFrame.DO_NOTHING_ON_CLOSE": [[66, 91]], "WindowListener": [[103, 116]], "WindowAdapter": [[127, 139]]}}}, {"text": "From the List#remove documentation", "label": {"api": {"List#remove documentation": [[9, 33]]}}}, {"text": "An easy option is java.util.Properties, which not only supports loading configuration data from key=value and XML files, but also directly supports the hierarchical defaults you describe", "label": {"api": {"java.util.Properties": [[18, 37]]}}}, {"text": "Note also that, if you want your new string interned into the string pool, you can use the intern() method", "label": {"api": {"intern() method": [[91, 105]]}}}, {"text": "You can't call put and pass the HashMap into the method at the same time, because the put method doesn't return the HashMap", "label": {"api": {"the put method": [[82, 95]]}}}, {"text": "Whereas The Object(in the API reference documentation) class sits at the top of the class hierarchy tree in the Java development environment", "label": {"api": {"in the API reference documentation": [[19, 52]]}}}, {"text": "From the Javadoc for VerifyError", "label": {"api": {"VerifyError": [[21, 31]]}}}, {"text": "You should either read the entire line (including the newline, perhaps using a Scanner) and then process the first character of the line or simply add a test to skip newlines in your loop logic", "label": {"api": {"Scanner": [[79, 85]]}}}, {"text": "You should be using Character.toUpperCase() and Character.toLowerCase() instead", "label": {"api": {"Character.toUpperCase()": [[20, 42]], "Character.toLowerCase()": [[48, 70]]}}}, {"text": "In your case, your substring starts with a white space, so to fix it you would need to use the .trim() method to remove any leading/trailing white spaces like so", "label": {"api": {".trim()": [[95, 101]]}}}, {"text": "Have a look at this Stack Overflow answer; long story short, using scheduleAtFixedRate will queue up the tasks you have scheduled and fire them relative to the system time that the task was first queued; if anything should delay these tasks from firing, they will play 'catch up' and fire as fast as they can", "label": {"api": {"scheduleAtFixedRate": [[67, 85]]}}}, {"text": "You're looking for a BufferedInputStream", "label": {"api": {"BufferedInputStream": [[21, 39]]}}}, {"text": "Wrap this around a BufferedInputStream and write it to a file or a ByteArrayOutputStream", "label": {"api": {"BufferedInputStream": [[19, 37]]}}}, {"text": "You can use StringBuilder", "label": {"api": {"StringBuilder": [[12, 24]]}}}, {"text": "This internally uses System.arraycopy() method", "label": {"api": {"System.arraycopy()": [[21, 38]]}}}, {"text": "However, you probably want to use RSAPublicKey.getModulus() to obtain public key modulus and plug it directly to PHP Crypt_RSA Object", "label": {"api": {"RSAPublicKey.getModulus()": [[34, 58]]}}}, {"text": "You can use GarbageCollectorMXBean to get the count of garbage collections", "label": {"api": {"GarbageCollectorMXBean": [[12, 33]]}}}, {"text": "If you have an offset, there is a dedicated method on LocalDateTime for this task", "label": {"api": {"dedicated method": [[34, 49]]}}}, {"text": "You can try converting the string to lowercase first String#toLowerCase()", "label": {"api": {"String#toLowerCase()": [[53, 72]]}}}, {"text": "The documentation for JEditorPane.setPage(String) tells us", "label": {"api": {"documentation for JEditorPane.setPage(String)": [[4, 48]]}}}, {"text": "I was reading the javadoc for InetSocketAddress at http://docs.oracle.com/javase/8/docs/api/ and was wondering what the following phrase means", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/": [[51, 91]]}}}, {"text": "The run() method as defined in the Runnable interface does not list any exceptions in any throws clause, so it can only throw RuntimeExceptions", "label": {"api": {"run() method as defined in the Runnable interface": [[4, 52]]}}}, {"text": "From Java API Random I can see constructor Random(long seed) creates a new random number generator using a single long seed", "label": {"api": {"Random": [[14, 19], [43, 48]]}}}, {"text": "You may want to try Runtime.exec(String[] cmdarray)  or java.lang.ProcessBuilder instead to specify each parameter individually", "label": {"api": {"Runtime.exec(String[] cmdarray) ": [[20, 51]], "java.lang.ProcessBuilder": [[56, 79]]}}}, {"text": "RoundingMode.DOWN always rounds toward zero, so that should be what you're looking for", "label": {"api": {"RoundingMode.DOWN": [[0, 16]]}}}, {"text": "You can use the UNICODE_CHARACTER_CLASS flag to make \\p{Punct} match all Unicode punctuation", "label": {"api": {"UNICODE_CHARACTER_CLASS": [[16, 38]]}}}, {"text": "This is possible if you write a multithreading application or use a Selector", "label": {"api": {"Selector": [[68, 75]]}}}, {"text": "You would use setFileSelectionMode()", "label": {"api": {"setFileSelectionMode()": [[14, 35]]}}}, {"text": "Try to use anyMatch of Lambda Expression", "label": {"api": {"anyMatch": [[11, 18]]}}}, {"text": "Don't neglect using Stream#map() which allows to flatten the data structure before applying the Predicate", "label": {"api": {"Stream#map()": [[20, 31]]}}}, {"text": "Use String class split method to split the string using the desired pattern", "label": {"api": {"String": [[4, 9]], "split": [[17, 21], [33, 37]]}}}, {"text": "Try to use URL.openConnection(proxy) instead", "label": {"api": {"URL.openConnection(proxy)": [[11, 35]]}}}, {"text": "However, String is not a supported argument", "label": {"api": {"not a supported argument": [[19, 42]]}}}, {"text": "The implementation expects a Node", "label": {"api": {"Node": [[29, 32]]}}}, {"text": "Provide an InputSource", "label": {"api": {"InputSource": [[11, 21]]}}}, {"text": "Depending on how Defaultconstant works, you can either save the data when it doesn't change anymore or you can use a ServletContextListener to notify the class when the app server is shut down", "label": {"api": {"ServletContextListener": [[117, 138]]}}}, {"text": "I suggest you try a HashSet or TreeSet instead", "label": {"api": {"HashSet": [[20, 26]], "TreeSet": [[31, 37]]}}}, {"text": "If you're familiar with big-O notation (if not, I suggest you read this post), LinkedList.contains is O(n), HashSet.contains is expected O(1) and TreeSet.contains is O(log n)", "label": {"api": {"HashSet": [[108, 114]], "TreeSet": [[146, 152]]}}}, {"text": "If you need more control over the decimal places and rounding, you'll have to use BigDecimal", "label": {"api": {"BigDecimal": [[82, 91]]}}}, {"text": "Have a look at the java docs for String class and find a method for replacing / with /\\n in the string", "label": {"api": {"java docs for String class": [[19, 44]]}}}, {"text": "DefaultTreeModel supports adding any number of children to a node, listening on a node, and looking up nodes by path", "label": {"api": {"DefaultTreeModel": [[0, 15]]}}}, {"text": "The Oracle documentation for Group says", "label": {"api": {"Oracle documentation for Group": [[4, 33]]}}}, {"text": "But there are a number of hints you can take from Arrays.binarySearch to help design your program", "label": {"api": {"Arrays.binarySearch": [[50, 68]]}}}, {"text": "If you were to pattern your method signature off that used by the Arrays.binarySearch method, the task becomes much easier", "label": {"api": {"Arrays.binarySearch": [[66, 84]]}}}, {"text": "I would also change the argument order to match Arrays.binarySearch, and even call it binarySearch", "label": {"api": {"Arrays.binarySearch": [[48, 66]]}}}, {"text": "To pass data from GUI to client thread, use LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[44, 62]]}}}, {"text": "To send the response to the GUI, use SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[37, 62]]}}}, {"text": "This also breaks the contract for equals", "label": {"api": {"equals": [[34, 39]]}}}, {"text": "for any non-null reference value x, x.equals(x) should return true", "label": {"api": {"equals": [[38, 43]]}}}, {"text": "What you want to do is get the filename of the File with getName(), then you need to strip off the extension", "label": {"api": {"getName()": [[57, 65]]}}}, {"text": "You have complete control over the rounding, so use that judiciously", "label": {"api": {"You have complete control over the rounding": [[0, 42]]}}}, {"text": "You could look into an external library like Joda Time  (and use their DateTimeFormatter and Period class) or try using Java's SimpleDateFormat to read and parse your input log file dates", "label": {"api": {"SimpleDateFormat": [[127, 142]]}}}, {"text": "The following is somewhat psuedo-code but the lines that matters most to you the SimpleDateFormat and parse should work for your case", "label": {"api": {"SimpleDateFormat": [[81, 96]]}}}, {"text": "You can access the HttpSession and store the username like this", "label": {"api": {"HttpSession": [[19, 29]]}}}, {"text": "If you are using a newer JDK there are also static methods such as Double.compare", "label": {"api": {"Double.compare": [[67, 80]]}}}, {"text": "use Random#nextInt(int n) instead to guarantee that you're in the bounds of your array, and that you'll always be getting back an int", "label": {"api": {"Random#nextInt(int n)": [[4, 24]]}}}, {"text": "According to the MemoryConfiguration javadoc (Which is one of the parent classes for the YamlConfiguration you're using), getStringList() returns a List<String>, however I'm willing to bet it actually returns an ArrayList<String>, and calling ArrayList#add() will return a boolean indicating whether the item was successfully added to the list", "label": {"api": {"ArrayList#add()": [[243, 257]]}}}, {"text": "Not sue if I totally understand your question, but you can find all the predefined classes in Java under the Java Class Library", "label": {"api": {"Java Class Library": [[109, 126]]}}}, {"text": "Java Class Library", "label": {"api": {"Java Class Library": [[0, 17]]}}}, {"text": "That said, I highly suggest you use a built-in collection, like ArrayList, to handle automatically resizing arrays", "label": {"api": {"ArrayList": [[64, 72]]}}}, {"text": "They are much easier to use, and their performance is also better (increasing the array size by one means you have to resize every time an item is added, in comparison to ArrayList's implementation, which doubles the size every time it fills up)", "label": {"api": {"ArrayList": [[171, 179]]}}}, {"text": "Try with Collections.shuffle() if there is no harm to shuffle the items in original list", "label": {"api": {"Collections.shuffle()": [[9, 29]]}}}, {"text": "String#split  using the regex and don't add the first and last element in the array to the arraylist", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "In addition to the accepted answer, you must also have consistency in the compareTo and equals methods in order to correctly implement the Comparable interface", "label": {"api": {"Comparable": [[139, 148]]}}}, {"text": "Use a DecimalFormat object (see the documentation at http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html": [[53, 121]]}}}, {"text": "I don't know what are you trying to accomplish but you are not adding the components correctly", "label": {"api": {"add": [[63, 65]]}}}, {"text": "This is incorrect, the add method has two arguments, like this", "label": {"api": {"add": [[23, 25]]}}}, {"text": "container.add(component, constraints); your error is not specifying the constraints", "label": {"api": {"add": [[10, 12]]}}}, {"text": "The constraints contains all the details to know where in the panel you want to add that component", "label": {"api": {"add": [[80, 82]]}}}, {"text": "The call container.add(component) exists because sometimes the LayoutManager does not need extra information (like the BoxLayout), in the other cases it just uses the \"default\" constraints for the LayoutManager in use, which may not be what you need", "label": {"api": {"add": [[19, 21]]}}}, {"text": "Is correct, but what it actually does is calling game.janela.add(game, defaultConstraints); where defaultConstraints is the default constraints value for the LayoutManager of the JFrame janela", "label": {"api": {"add": [[61, 63]]}}}, {"text": "Most calls to add must have two parameters", "label": {"api": {"add": [[14, 16]]}}}, {"text": "Converts your arrays into set to remove possible duplicated elements ans then containsAll() returns true if setB contains all of the elements of setA", "label": {"api": {"containsAll()": [[78, 90]]}}}, {"text": "Consider using java.util.ArrayList instead", "label": {"api": {"java.util.ArrayList": [[15, 33]]}}}, {"text": "The fastest might be to convert your Integers into a byte[] and then using ByteBuffer.wrap(...) if you need the answer as a ByteBuffer", "label": {"api": {"ByteBuffer.wrap(...)": [[75, 94]]}}}, {"text": "This class, as well as the class Field, class Class, are all part of reflection API", "label": {"api": {"Field": [[33, 37]], "Class": [[46, 50]]}}}, {"text": "Take a look at http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html, you can write Java programs that can compile Java code", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html": [[15, 84]]}}}, {"text": "You can go with appropriate java collection - in your case LinkedHashSet should do the job", "label": {"api": {"LinkedHashSet": [[59, 71]]}}}, {"text": "If my assumption is correct then you should implement this kind of functionality using a Queue rather than List (for example a BlockingQueue)", "label": {"api": {"BlockingQueue": [[127, 139]]}}}, {"text": "Don't override fireTableRowsDeleted() or related methods in AbstractTableModel", "label": {"api": {"AbstractTableModel": [[60, 77]]}}}, {"text": "Use DefaultTableModel as a guide; a related example is examined here", "label": {"api": {"DefaultTableModel": [[4, 20]]}}}, {"text": "Take a look at http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html, it is Java Compiler's API", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html": [[15, 84]]}}}, {"text": "If you want the printout to include a leading zero, I recommend using String#format()", "label": {"api": {"String#format()": [[70, 84]]}}}, {"text": "To get a value of a private field you should set it as accessible by using setAccessible", "label": {"api": {"setAccessible": [[75, 87]]}}}, {"text": "getDeclaredFields will allow you to see names of private fields, not the value", "label": {"api": {"getDeclaredFields": [[0, 16]]}}}, {"text": "If you amend your method B so that you don't read the file line-by-line into the StringBuilder but use Files.readAllBytes to get the entire file as a String then split you will probably find performance more or less identical", "label": {"api": {"Files.readAllBytes": [[103, 120]]}}}, {"text": "System.out.println(number) will go through Double.toString() which is a fairly complex method (as seen in its documentation) an will not always behave as you'd expect", "label": {"api": {"Double.toString()": [[43, 59]]}}}, {"text": "You could also use a List to avoid iterating two times through your file and use readAllLines (if you're using Java 7)", "label": {"api": {"readAllLines": [[81, 92]]}}}, {"text": "This is just a static sorting method in class Collections that you are looking at", "label": {"api": {"sorting method": [[22, 35]]}}}, {"text": "According to http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html, one can't call destroy; one's computations have to check for interrupts", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html": [[13, 74]]}}}, {"text": "You could use String.trim to remove leading and trailing whitespace", "label": {"api": {"String.trim": [[14, 24]]}}}, {"text": "If you want the stream to forget about what it has already sent, then you need to call the reset() method", "label": {"api": {"reset()": [[91, 97]]}}}, {"text": "If you want to compare the String value, you should use equals()", "label": {"api": {"equals()": [[56, 63]]}}}, {"text": "See the CallableStatement apidoc", "label": {"api": {"CallableStatement": [[8, 24]]}}}, {"text": "#accept() blocks till a connection is made", "label": {"api": {"#accept()": [[0, 8]]}}}, {"text": "A solution to run the code asynchronously, is in ExecutorService", "label": {"api": {"ExecutorService": [[49, 63]]}}}, {"text": "You could also call getChannel and use it with a Selector to keep things non blocking", "label": {"api": {"getChannel": [[20, 29]], "Selector": [[49, 56]]}}}, {"text": "If you need to calculate factorials of such large numbers, use BigInteger class instead", "label": {"api": {"BigInteger": [[63, 72]]}}}, {"text": "Then inject the nested controllers into MainController as described in the Nested Controllers section of the Introduction to FXML", "label": {"api": {"Nested Controllers": [[75, 92]]}}}, {"text": "List#sort(Comparator) was added in Java 8", "label": {"api": {"List#sort(Comparator)": [[0, 20]]}}}, {"text": "The easiest way to print any array to any depth is to use Arrays.deepToString()", "label": {"api": {"Arrays.deepToString()": [[58, 78]]}}}, {"text": "Use a LinkedHashSet, so that order is preserved in the same order that you added it", "label": {"api": {"LinkedHashSet": [[6, 18]]}}}, {"text": "The built-in ExecutorService lets you launch background threads in a much cleaner way", "label": {"api": {"ExecutorService": [[13, 27]]}}}, {"text": "You can't do sorting with a Hashtable, I would suggest using TreeMap instead", "label": {"api": {"TreeMap": [[61, 67]]}}}, {"text": "The schedule(...) method should return a Future object", "label": {"api": {"Future": [[41, 46]]}}}, {"text": "The Future API has a cancel(...) method", "label": {"api": {"Future": [[4, 9]]}}}, {"text": "save the Future object somewhere and then call cancel on it after 5 seconds", "label": {"api": {"Future": [[9, 14]]}}}, {"text": "I looked at KeyCodeCombination, however this appears to be for use in cases when a key has a modifier key from a specified list (ALT_DOWN, SHIFT_DOWN, etc)", "label": {"api": {"KeyCodeCombination": [[12, 29]]}}}, {"text": "InputStreams provide raw bytes while Readers provide chars", "label": {"api": {"InputStream": [[0, 10]], "Reader": [[37, 42]]}}}, {"text": "You can wrap an InputStream with an InputStreamReader that interpretes the bytes as unicode characters according to the encoding you define", "label": {"api": {"InputStream": [[16, 26], [36, 46]], "Reader": [[47, 52]], "InputStreamReader": [[36, 52]]}}}, {"text": "You can use Scanner#hasNextInt() method to check that", "label": {"api": {"Scanner#hasNextInt()": [[12, 31]]}}}, {"text": "It is better to use Thread Pool Manager (Executor Service - Link)", "label": {"api": {"Link": [[60, 63]]}}}, {"text": "Maybe dig deeper in http://docs.oracle.com/javase/6/docs/api/java/lang/ProcessBuilder.html and the python docs, as I remember, when I did this from PHP, I ran into some problems with the python code itself", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/ProcessBuilder.html": [[20, 89]]}}}, {"text": "There is of course a generic version of binarySearch1", "label": {"api": {"generic version": [[21, 35]]}}}, {"text": "If you look at the documentation for InputStream, you'll notice it will not promise you that toString will present you the contents of the stream", "label": {"api": {"InputStream": [[37, 47]]}}}, {"text": "To get the String out of the InputStream, I'd recommend IOUtils.toString from apache commons-io", "label": {"api": {"InputStream": [[29, 39]]}}}, {"text": "String.format() uses half up as a rounding method, so you can use it as a first step to get your output to eight characters", "label": {"api": {"String.format()": [[0, 14]]}}}, {"text": "By default String.format() uses a precision of 6 for BigDecimal", "label": {"api": {"String.format()": [[11, 25]]}}}, {"text": "To align them, just use the String.format() again", "label": {"api": {"String.format()": [[28, 42]]}}}, {"text": "bestTime) from the getter (ie getBestTime), assuming the class complies with the camel case convention, I would simply substring(3) and decapitalize the result, using either Introspector.decapitalize (available in the JDK) or StringUtils.uncapitalize (Apache Commons)", "label": {"api": {"Introspector.decapitalize": [[174, 198]]}}}, {"text": "You can try using BigInteger#intValue()", "label": {"api": {"BigInteger#intValue()": [[18, 38]]}}}, {"text": "The reason this works is from the Group javadoc", "label": {"api": {"Group javadoc": [[34, 46]]}}}, {"text": "If you want additional fixed space between VBox items, you can use vbox.setSpacing as suggested in Rohan's answer", "label": {"api": {"vbox.setSpacing": [[67, 81]]}}}, {"text": "Sounds like you want the JToolTip class", "label": {"api": {"JToolTip": [[25, 32]]}}}, {"text": "File.delete() will return true only if it deletes the file", "label": {"api": {"File.delete()": [[0, 12]]}}}, {"text": "Ensure File.exists() returns true prior to invoking File.delete()", "label": {"api": {"File.delete()": [[52, 64]], "File.exists()": [[7, 19]]}}}, {"text": "Also see Files.deleteIfExists() which may provide more information, via an IOException, in the event of a failed deletion attempt", "label": {"api": {"Files.deleteIfExists()": [[9, 30]]}}}, {"text": "From the PreparedStatement docs", "label": {"api": {"PreparedStatement docs": [[9, 30]]}}}, {"text": "I found this in the API documentation for the add(Component comp) method in java.awt.Containter (emphasis mine)", "label": {"api": {"add(Component comp)": [[46, 64]]}}}, {"text": "Check out the java documentation for more information", "label": {"api": {"the java documentation": [[10, 31]]}}}, {"text": "If I use one thread to repeatedly call the Tyrus implementation of RemoteEndpoint.Async.sendText(String), will my messages always go away on the wire orderly as I, the client, sent them", "label": {"api": {"RemoteEndpoint.Async.sendText(String)": [[67, 103]]}}}, {"text": "You can save a reference to each of your Labels, or perhaps use container.getComponents(), but I am unsure if that method has any guarantee on the order of the components in the array", "label": {"api": {"perhaps use container.getComponents()": [[52, 88]]}}}, {"text": "ReentrantReadWriteLock doesn't have a Lock method", "label": {"api": {"ReentrantReadWriteLock": [[0, 21]], "Lock": [[18, 21], [38, 41]]}}}, {"text": "It has public ReentrantReadWriteLock.ReadLock readLock() and public ReentrantReadWriteLock.WriteLock writeLock()", "label": {"api": {"ReentrantReadWriteLock": [[14, 35], [68, 89]], "public ReentrantReadWriteLock.ReadLock readLock()": [[7, 55]], "public ReentrantReadWriteLock.WriteLock writeLock()": [[61, 111]], "Lock": [[32, 35], [41, 44], [50, 53], [86, 89], [96, 99], [106, 109]]}}}, {"text": "Those both implement the Lock interface and have lock(), lockInterruptibly(), unlock(), and trylock() methods", "label": {"api": {"Lock": [[25, 28]]}}}, {"text": "The WriteLock has a few extra methods since write locks are generally exclusive", "label": {"api": {"Lock": [[9, 12]]}}}, {"text": "It is also possible to programmatically ask every object of type TemporalAccessor for its specific set of supported fields", "label": {"api": {"programmatically ask": [[23, 42]]}}}, {"text": "The right class for me was ZonedDateTime which includes both Time and Time Zone", "label": {"api": {"ZonedDateTime": [[27, 39]]}}}, {"text": "You should key into the more general idea of a Map", "label": {"api": {"Map": [[47, 49]]}}}, {"text": "In this case, a Map<char, int>", "label": {"api": {"Map": [[16, 18]]}}}, {"text": "Note that Java Collections allow all sorts of fun sorting options; by the value of the key, by the frequency (or value of the value in the Map's key->value pair), or any arbitrary setup you can imagine", "label": {"api": {"Map": [[139, 141]]}}}, {"text": "You need to use a SecretKeyFactory not a KeyGenerator", "label": {"api": {"SecretKeyFactory": [[18, 33]]}}}, {"text": "Thus, we can see that another way of speeding up the code is to compile our regex first, then use the Pattern#split to split", "label": {"api": {"Pattern#split": [[102, 114]]}}}, {"text": "You could have a Map", "label": {"api": {"Map": [[17, 19]]}}}, {"text": "You seem to have a few issues in your code, there is a handy method in Arrays.toString() and then something like this ..", "label": {"api": {"Arrays.toString()": [[71, 87]]}}}, {"text": "Basically I fear you might be facing an issue with oldUser.equals(e) for every e contained in the list which is called in the contains method of ArrayList", "label": {"api": {"which is called in the contains method of ArrayList": [[103, 153]]}}}, {"text": "Check the documentation on how to specify the path - public URL getResource(String name)", "label": {"api": {"public URL getResource(String name)": [[53, 87]]}}}, {"text": "Well, have a look on timer class", "label": {"api": {"timer": [[21, 25]]}}}, {"text": "I have learned that, in Java, TreeMap<K,V> is a SortedMap that sorts according to its keys or by using a Comparator<", "label": {"api": {"TreeMap<K,V>": [[30, 41]]}}}, {"text": "Are there some other SortedMap like TreeMap<K,V> but can sort using a Comparator<", "label": {"api": {"TreeMap<K,V>": [[36, 47]]}}}, {"text": "A Set cannot contain duplicates, but a List can", "label": {"api": {"A Set cannot contain duplicates": [[0, 30]]}}}, {"text": "Use Queue<E>#peek () to retrieve an object without removing it", "label": {"api": {"Queue<E>#peek ()": [[4, 19]]}}}, {"text": "Seeing your response to my comment, I think that in your case, you should use the PriorityQueue because it does what you need without needing you to reinvent the wheel, which is usually not recommended", "label": {"api": {"PriorityQueue": [[82, 94]]}}}, {"text": "You can make your custom class implement the Comparabale interface and have your sorting logic there", "label": {"api": {"Comparabale": [[45, 55]]}}}, {"text": "This is suggested in the API documentation for the method", "label": {"api": {"API documentation for the method": [[25, 56]]}}}, {"text": "You can use the java.net.URI-class to extract the hostname from the string", "label": {"api": {"java.net.URI": [[16, 27]]}}}, {"text": "To connect to a remote machine you need that machines IP address or hostname, then you can use InetAddress.getByName(String)", "label": {"api": {"InetAddress.getByName(String)": [[95, 123]]}}}, {"text": "Have a look at the Java Timer class, this will help you do a timed loop more elegantly", "label": {"api": {"Timer": [[24, 28]]}}}, {"text": "hasNextLine() only checks, but doesn't consume the line", "label": {"api": {"doesn't consume the line": [[31, 54]]}}}, {"text": "You need to call nextLine() inside the loop", "label": {"api": {"nextLine()": [[17, 26]]}}}, {"text": "You have specific classes for big numbers in Java, for example BigInteger", "label": {"api": {"BigInteger": [[63, 72]]}}}, {"text": "String#split split and get the first index in the ouput array", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "You should be using replace(CharSequence target, CharSequence replacement), not replaceAll(String regex, String replacement) as you are not using a Regex but a simple pair of Strings", "label": {"api": {"replace(CharSequence target, CharSequence replacement)": [[20, 73]], "replaceAll(String regex, String replacement)": [[80, 123]]}}}, {"text": "Use Map.get() and Map.put() methods", "label": {"api": {"Map.get()": [[4, 12]], "Map.put()": [[18, 26]]}}}, {"text": "You would need to identify the class you want to read the comments from and then use Element.getDocComment", "label": {"api": {"Element.getDocComment": [[85, 105]]}}}, {"text": "Instead, you can change your code to adapt this array and convert it into a list using Arrays#asList", "label": {"api": {"Arrays#asList": [[87, 99]]}}}, {"text": "You can then pass this into Hashtable#get(Object)", "label": {"api": {"Hashtable#get(Object)": [[28, 48]]}}}, {"text": "Take a look at the JavaDocs for the Formatter", "label": {"api": {"Formatter": [[36, 44]]}}}, {"text": "From the ButtonGroup documentation", "label": {"api": {"ButtonGroup documentation": [[9, 33]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html to \"grow\" Strings", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html": [[0, 68]]}}}, {"text": "See URL.toURI() for more information", "label": {"api": {"URL.toURI()": [[4, 14]]}}}, {"text": "2) You can manage highlight ability with help of ListCellRenderer", "label": {"api": {"ListCellRenderer": [[49, 64]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html for more info", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/ConcurrentModificationException.html": [[4, 90]]}}}, {"text": "Integer.parseInt(String) will do this for you", "label": {"api": {"Integer.parseInt(String)": [[0, 23]]}}}, {"text": "Why does the Object class in Java contain protected methods, such as clone() and finalize(), if all classes you use or write inherit the instance methods of Object", "label": {"api": {"Object class": [[13, 24]], "clone()": [[69, 75]], "finalize()": [[81, 90]]}}}, {"text": "I was wondering if there is a library or something to play a sound on a given sample rate (20â20,000 Hz)", "label": {"api": {"something": [[41, 49]]}}}, {"text": "Actually, I found something but I'm not understanding how I can make it work", "label": {"api": {"something": [[18, 26]]}}}, {"text": "I'm writing my own web crawler in Java, and I'm using URI#resolve to resolve URLs that appear on every HTML page that my crawler encounters", "label": {"api": {"URI#resolve": [[54, 64]]}}}, {"text": "URI constructor Javadoc states that (from http://docs.oracle.com/javase/7/docs/api/java/net/URI.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/net/URI.html": [[42, 99]]}}}, {"text": "I just noticed you added the baseURL with new URL(\"HTTP\", \"cs.uwec.edu/~stevende/cs145testpages/\", theHREF) this is wrong, you need to use new URL(\"http\", \"cs.uwec.edu\", 80, \"/~stevende/cs145testpages/#\"+theHREF)", "label": {"api": {"new URL(\"http\", \"cs.uwec.edu\", 80, \"/~stevende/cs145testpages/#\"+theHREF)": [[139, 211]]}}}, {"text": "You can also use the single argument constructor new URL(\"http://cs.uwec.edu//~stevende/cs145testpages/\")", "label": {"api": {"new URL(\"http://cs.uwec.edu//~stevende/cs145testpages/\")": [[49, 104]]}}}, {"text": "You can do input.next(pattern) to get the next input which matches a certain pattern", "label": {"api": {"input.next(pattern)": [[11, 29]]}}}, {"text": "or Create a custom EL function which delegates to Math#abs(int)", "label": {"api": {"Math#abs(int)": [[50, 62]]}}}, {"text": "In class StringBuffer exists method setCharAt", "label": {"api": {"setCharAt": [[36, 44]]}}}, {"text": "When letter is guessed you will update guess with setCharAt", "label": {"api": {"setCharAt": [[50, 58]]}}}, {"text": "If you want to call the method multiple times and append to the same file instead of overwriting an existing file, an alternative is to use a FileWriter instead with true as a second argument to its constructor so it will append to an existing file", "label": {"api": {"FileWriter": [[142, 151]]}}}, {"text": "LinkedList should be fastest for this case", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "When you get to the end of your input data, you should call engine.closeInbound(), which will verify with the SSLEngine that the remote peer has closed cleanly from the SSL/TLS perspective, and then the application should still try to shutdown cleanly by using the procedure above", "label": {"api": {"closeInbound()": [[67, 80]]}}}, {"text": "Basically, if the link is severed, engine.closeInbound() should be called", "label": {"api": {"closeInbound()": [[42, 55]]}}}, {"text": "However, the documentation of this closeInbound() method indicates that it will throw an exception if it is called before receiving the proper closing message from peer", "label": {"api": {"closeInbound()": [[35, 48]]}}}, {"text": "I made the test, made a simple shutdown procedure where is socketChannel.read() returns -1, I call engine.closeInbound() and I indeed get the following exception", "label": {"api": {"closeInbound()": [[106, 119]]}}}, {"text": "If you're using Java SE 7 or greater, you could use Files.copy", "label": {"api": {"Files.copy": [[52, 61]]}}}, {"text": "I think flatMap() is what you're looking for", "label": {"api": {"flatMap()": [[8, 16]]}}}, {"text": "Entering, exiting, and throwing are logged at level FINER", "label": {"api": {"exiting": [[10, 16]], "throwing": [[23, 30]]}}}, {"text": "As far as style goes, you should try creating a static final for class name because you'll use it as the name of the logger and reference it for entering, exiting, throwing, and log precise tracing", "label": {"api": {"name of the logger": [[105, 122]], "entering": [[145, 152]], "exiting": [[155, 161]], "throwing": [[164, 171]], "log precise": [[178, 188]]}}}, {"text": "You always want to use a class literal to fetch the name (as above) because getClass().getName() can return a subclass name which can falsify your tracing", "label": {"api": {"getClass().getName()": [[76, 95]]}}}, {"text": "For method names don't include () in the name, just use the entering/exiting method that matches the number of arguments", "label": {"api": {"entering": [[60, 67]], "exiting": [[69, 75]]}}}, {"text": "In Java EE (JTA), this is done by calling UserTransaction#setRollbackOnly()", "label": {"api": {"UserTransaction#setRollbackOnly()": [[42, 74]]}}}, {"text": "Try with ArrayList.trimToSize() that says", "label": {"api": {"ArrayList.trimToSize()": [[9, 30]]}}}, {"text": "Look at ArrayList.ensureCapacity() that says", "label": {"api": {"ArrayList.ensureCapacity()": [[8, 33]]}}}, {"text": "Directly answering the question, using volatile or AtomicLong will make actual read/write atomic", "label": {"api": {"AtomicLong": [[51, 60]]}}}, {"text": "You would use lastIndexOf to get the position, and substring to effectively remove the user name", "label": {"api": {"lastIndexOf": [[14, 24]], "substring": [[51, 59]]}}}, {"text": "In your case, a TreeSet would be a good choice", "label": {"api": {"TreeSet": [[16, 22]]}}}, {"text": "If you want to sort the entries by surname only in this usage (and not generally), you can pass a customer Comparator to the constructor", "label": {"api": {"constructor": [[125, 135]]}}}, {"text": "You could use String#contains instead", "label": {"api": {"String#contains": [[14, 28]]}}}, {"text": "What you could do is rely on Duration or Period, depending on long the durations can be in your use cases", "label": {"api": {"Duration": [[29, 36]], "Period": [[41, 46]]}}}, {"text": "You could use a Map<String, Supplier<A>>", "label": {"api": {"Supplier": [[28, 35]]}}}, {"text": "This uses a standard Java 8 Supplier interface, with a Java 8 lambda syntax, but you could of course define your own Supplier interface, and create instances using anonymous inner classes", "label": {"api": {"Supplier": [[28, 35], [117, 124]]}}}, {"text": "Please have a look at StringReader#read()", "label": {"api": {"StringReader#read()": [[22, 40]]}}}, {"text": "Look at the source code of StringReader#read() method", "label": {"api": {"StringReader#read()": [[27, 45]]}}}, {"text": "See the docs, JLabel#getName()", "label": {"api": {"JLabel#getName()": [[14, 29]]}}}, {"text": "In Java, you cannot simply return the name of the variable (without using reflection), you should set it before, you can use JLabel#setName to do that", "label": {"api": {"JLabel#setName": [[125, 138]]}}}, {"text": "You can use the Scanner class' nextLine() method to read the text line by line", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "a space ' ' or any other, and use this in the String class' split() method", "label": {"api": {"String": [[46, 51]]}}}, {"text": "Regarding to the fact of Set in java that it can't contain a duplicate value, then your set values will be 6023 and 0230 only", "label": {"api": {"Set": [[25, 27]]}}}, {"text": "there is a filter method which basically is what you are looking for, I think", "label": {"api": {"filter": [[11, 16]]}}}, {"text": "You can do this by applying the Java copyOf method on the result of SHA-256", "label": {"api": {"copyOf": [[37, 42]]}}}, {"text": "The KeyListener interface has three methods to be implemented", "label": {"api": {"KeyListener": [[4, 14]]}}}, {"text": "I don't like links generally, but here is a small tutorial on KeyListeners", "label": {"api": {"KeyListener": [[62, 72]]}}}, {"text": "And here is an example to add a KeyListener to a JTextField", "label": {"api": {"KeyListener": [[32, 42]]}}}, {"text": "You might want to use StringTokenizer to parse your string with '-'", "label": {"api": {"StringTokenizer": [[22, 36]]}}}, {"text": "You might want to use ExecutorService to run multiple threads within a single object", "label": {"api": {"ExecutorService": [[22, 36]]}}}, {"text": "While closing a Connection will close all Statements associated with it, there's an upper limit in most databases on how many Statements you can have open concurrently for any one Connection", "label": {"api": {"closing a Connection will close all Statements associated with it": [[6, 70]]}}}, {"text": "If you close Statements, they also close their ResultSets, so you don't have to close both", "label": {"api": {"they also close their ResultSets": [[25, 56]]}}}, {"text": "Your HashSet comes out in unsorted order because each entry is hashed to be placed in a bucket", "label": {"api": {"HashSet": [[5, 11]]}}}, {"text": "For a SortedSet (which HashSet is not), you could use TreeSet", "label": {"api": {"HashSet": [[23, 29]], "SortedSet": [[6, 14]], "TreeSet": [[54, 60]]}}}, {"text": "You can use rangeClosed if you want to include n in the resulting array", "label": {"api": {"rangeClosed": [[12, 22]]}}}, {"text": "If you want to specify a step, you could iterate and then limit the stream to take the first n elements you want", "label": {"api": {"iterate": [[41, 47]], "limit": [[58, 62]]}}}, {"text": "This means that you need to use a source such as SecureRandom to generate your primes", "label": {"api": {"SecureRandom": [[49, 60]]}}}, {"text": "If you are using the BigInteger(int bitLength, int certainty, Random rnd) constructor, you can pass in your SecureRandom as it subclasses Random", "label": {"api": {"SecureRandom": [[108, 119]]}}}, {"text": "You could use the JColorChooser", "label": {"api": {"JColorChooser": [[18, 30]]}}}, {"text": "You should use Java's Comparable interface (http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html": [[44, 109]]}}}, {"text": "What is the difference between limit and capacity in Java's java.nio.ByteBuffer", "label": {"api": {"java.nio.ByteBuffer": [[60, 78]]}}}, {"text": "When a bad argument is passed into your method the convention is to throw an IllegalArgumentException (which is a RuntimeException) - see API for details - which you can also extend to your liking", "label": {"api": {"API": [[138, 140]]}}}, {"text": "As per Nizil's comment and this page, you can use the reverse(List<?> list) function from the Collections class in Java", "label": {"api": {"this page": [[27, 35]]}}}, {"text": "The name of the key can be specified with @JsonRootName if you are using Jackson-Annotations or @XmlRootElement if you are using JAXB-Annotations", "label": {"api": {"@XmlRootElement": [[96, 110]]}}}, {"text": "It is, unsurprisingly, called LinkedList", "label": {"api": {"LinkedList": [[30, 39]]}}}, {"text": "It has methods such as add(int index, E element), as well as an add(E e) to add to the end", "label": {"api": {"add(int index, E element)": [[23, 47]], "add(E e)": [[64, 71]]}}}, {"text": "You can use Class.asSubclass()", "label": {"api": {"Class.asSubclass()": [[12, 29]]}}}, {"text": "You can use a regular expression to do so, in which case the Pattern class is what you need", "label": {"api": {"Pattern": [[61, 67]]}}}, {"text": "Use PreparedStatement to avoid problems with erroneous input", "label": {"api": {"PreparedStatement": [[4, 20]]}}}, {"text": "I believe the actual type of myMap is WeakReference", "label": {"api": {"WeakReference": [[38, 50]]}}}, {"text": "And get method is invoked on a WeakReference instance returning a Map", "label": {"api": {"WeakReference": [[31, 43]]}}}, {"text": "A TreeView would seem to fit this nicely, or a TreeTableView if your Items have multiple columns (multiple, additional to the repeat frequency) and you are using Java 8", "label": {"api": {"TreeView": [[2, 9]], "TreeTableView": [[47, 59]]}}}, {"text": "If this is indeed what you need then use a ListIterator for adding while iterating through the list", "label": {"api": {"add": [[60, 62]]}}}, {"text": "You can read more about the add method of ListIterator", "label": {"api": {"add": [[28, 30]]}}}, {"text": "One edge case that requires a private method to be final is when the SafeVarargs annotation is used", "label": {"api": {"SafeVarargs": [[69, 79]]}}}, {"text": "Calling fireTableDateChanged() is excesive and unnecessary at this point since you seem to add a single row to your table", "label": {"api": {"fireTableDateChanged()": [[8, 29]]}}}, {"text": "The correct implementation should call fireTableRowsInserted(int firstRow, int lastRow) as follows", "label": {"api": {"fireTableRowsInserted(int firstRow, int lastRow)": [[39, 86]]}}}, {"text": "For further information, try to read Map Javadoc and List Javadoc", "label": {"api": {"Map Javadoc": [[37, 47]], "List Javadoc": [[53, 64]]}}}, {"text": "To remove it from the bodies List, call the remove method on bodies, passing body as an argument", "label": {"api": {"remove method": [[44, 56]]}}}, {"text": "You can use the split method, like this", "label": {"api": {"split": [[16, 20]]}}}, {"text": "The parameter passed to the split method is a regular expression, and returns an array of Strings which every division", "label": {"api": {"split": [[28, 32]]}}}, {"text": "Looking at your actionPerformed method, we can see you isn't calling the run method in a separate Thread", "label": {"api": {"Thread": [[98, 103]]}}}, {"text": "You need create a Thread object and call start method", "label": {"api": {"Thread": [[18, 23]]}}}, {"text": "Arrays.equals() compares array lengths and each element", "label": {"api": {"Arrays.equals()": [[0, 14]]}}}, {"text": "Use SimpleDateFormat to format the Date to a String", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "In example if you want \"precise\" timing, you can instead use a ScheduledExecutorService, which uses the OS scheduling service to offer a precision of at least milliseconds, and often even nanoseconds", "label": {"api": {"ScheduledExecutorService": [[63, 86]]}}}, {"text": "You can create an ArrayList from the array via Arrays.asList", "label": {"api": {"Arrays.asList": [[47, 59]]}}}, {"text": "If you don't need it to specifically be an ArrayList, and can use any type of List, you can use the result of Arrays.asList directly (which will be a fixed-size list)", "label": {"api": {"Arrays.asList": [[110, 122]]}}}, {"text": "The JavaDocs for Object.getClass() specify", "label": {"api": {"JavaDocs for Object.getClass()": [[4, 33]]}}}, {"text": "The Scanner was scanning the file path (as a String), not the file", "label": {"api": {"was scanning the file path": [[12, 37]]}}}, {"text": "Note also that Arrays.binarySearch requires your input array to be pre-sorted in ascending order to work correctly", "label": {"api": {"Arrays.binarySearch": [[15, 33]]}}}, {"text": "One way to do this is to use scan.nextLine() to read the entire line; this essentially uses the \"newline\" to indicate the end of the sentence", "label": {"api": {"scan.nextLine()": [[29, 43]]}}}, {"text": "You could also use a second Scanner to read the words from the sentence string, if you'd like to stay away from the regular expressions of String.split(), e.g.", "label": {"api": {"String.split()": [[139, 152]], "regular expressions": [[116, 134]]}}}, {"text": "sentenceScan.hasNext() returns true if it can get another word from the sentence, and false if it can not (i.e", "label": {"api": {"sentenceScan.hasNext()": [[0, 21]]}}}, {"text": "sentenceScan.next() will read the next word from the sentence string and return it", "label": {"api": {"sentenceScan.next()": [[0, 18]]}}}, {"text": "vec.add(...) of course appends whatever to the end of the Vector", "label": {"api": {"vec.add(...)": [[0, 11]]}}}, {"text": "For more info have a look at NumberFormat#getNumberInstance(Locale)", "label": {"api": {"NumberFormat#getNumberInstance(Locale)": [[29, 66]]}}}, {"text": "Scanner.nextLine returns the line excluding any newline characters", "label": {"api": {"Scanner.nextLine": [[0, 15]]}}}, {"text": "If you need speed, also make sure to look into direct NIO ByteBuffers", "label": {"api": {"direct NIO ByteBuffers": [[47, 68]]}}}, {"text": "Use a LinkedHashMap if you want to preserve insertion order instead", "label": {"api": {"LinkedHashMap": [[6, 18]]}}}, {"text": "Info on Random.nextInt() can be found here", "label": {"api": {"found here": [[32, 41]]}}}, {"text": "If you want to remove elements from a List while visiting its elements I suggest to used the following pattern", "label": {"api": {"List": [[38, 41]]}}}, {"text": "Try KeyAgreement and algorithm \"DiffieHellman\"", "label": {"api": {"KeyAgreement": [[4, 15]]}}}, {"text": "Take a look at ExecutorService", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "You may consider using InputVerifier", "label": {"api": {"InputVerifier": [[23, 35]]}}}, {"text": "Secondly, you should return appropriate types (and you're doing a distinct query) so we should return a Set - I picked a sorted set, but that's not in anyway mandatory", "label": {"api": {"Set": [[104, 106]]}}}, {"text": "It's a good idea to close resources in the block that opens them, and thusly I only close the PreparedStatement and ResultSet objects", "label": {"api": {"Set": [[122, 124]], "PreparedStatement": [[94, 110]], "ResultSet": [[116, 124]]}}}, {"text": "Have a look at BigInteger", "label": {"api": {"BigInteger": [[15, 24]]}}}, {"text": "If there's a change, use a JOptionPane to ask the user what to do", "label": {"api": {"JOptionPane": [[27, 37]]}}}, {"text": "ConcurrentLinkedQueue provides all necessary guarantees", "label": {"api": {"ConcurrentLinkedQueue": [[0, 20]]}}}, {"text": "As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentLinkedQueue happen-before actions subsequent to the access or removal of that element from the ConcurrentLinkedQueue in another thread", "label": {"api": {"ConcurrentLinkedQueue": [[92, 112], [197, 217]]}}}, {"text": "The way to go is to ditch your approach and make your student class implement the Comparable interface", "label": {"api": {"Comparable": [[82, 91]]}}}, {"text": "public class student implements Comparable<student>", "label": {"api": {"Comparable": [[32, 41]]}}}, {"text": "As a fix, you should look into the Java BigDecimal type since it has arbitrary precision", "label": {"api": {"Java BigDecimal": [[35, 49]]}}}, {"text": "forEach() doesn't guarantee to process elements in specific order", "label": {"api": {"forEach()": [[0, 8]]}}}, {"text": "If you want to print the content of an array, you can use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[58, 74]], "Arrays.toString": [[58, 72]]}}}, {"text": "An alternative is to create a wrapper class that wraps your boolean array and you can use the methods Arrays.equals, Arrays.toString and Arrays.hashcode to implement properly the equals, toString and hashCode methods", "label": {"api": {"Arrays.equals": [[102, 114]], "Arrays.toString": [[117, 131]], "Arrays.hashcode": [[137, 151]]}}}, {"text": "When you do new ArrayList(root.key()) you are constructing a list with a certain capacity, not constructing a list that already has that int in it as an element", "label": {"api": {"constructing a list with a certain capacity": [[46, 88]]}}}, {"text": "Throw the new ArithmeticException as is", "label": {"api": {"ArithmeticException": [[14, 32]]}}}, {"text": "Note that ArithmeticException extends from RuntimeException, so your method doesn't need to declare it", "label": {"api": {"ArithmeticException": [[10, 28]], "RuntimeException": [[43, 58]]}}}, {"text": "Convert the value of txt_vouchno_p.getText() into an int using Integer#parseInt and pass it to your PreparedStatement accordingly", "label": {"api": {"Integer#parseInt": [[63, 78]]}}}, {"text": "A BigInteger can store an arbitrarily large number (usually the memory available sets the limit)", "label": {"api": {"BigInteger": [[2, 11]]}}}, {"text": "Java BigInteger or BigDecimal can be used for large numbers", "label": {"api": {"BigInteger": [[5, 14]], "BigDecimal": [[19, 28]]}}}, {"text": "When sorting or creating sorted collections, you can always specify your own instance of the object's Comparator", "label": {"api": {"Comparator": [[102, 111]]}}}, {"text": "I have now implemented a wrapper-class that makes all operations with my older SQLite-class using an ExecutorService, inspired from Thread Executor Example and got the correct usage from Java Doc ExecutorService", "label": {"api": {"Java Doc ExecutorService": [[187, 210]]}}}, {"text": "This is documented in the Javadoc for Thread#join", "label": {"api": {"Thread#join": [[38, 48]]}}}, {"text": "For example, it doesn't make sense to compare Colors, so this class doesn't implement the Comparable interface", "label": {"api": {"Colors": [[46, 51]]}}}, {"text": "You can use System.currentTimeMillis to get the current time in milliseconds", "label": {"api": {"System.currentTimeMillis": [[12, 35]]}}}, {"text": "Try appending HttpServletRequest#getContextPath for your internal URLs", "label": {"api": {"HttpServletRequest#getContextPath": [[14, 46]]}}}, {"text": "You could use a java.util.Set to hold your words", "label": {"api": {"java.util.Set": [[16, 28]]}}}, {"text": "You can create a custom Comparator<String>, and use it in Arrays#sort", "label": {"api": {"Arrays#sort": [[58, 68]]}}}, {"text": "Consider using java.lang.Math.atan2(double y, double x) to get a vertical angle when there is a zero change in the x value", "label": {"api": {"java.lang.Math.atan2(double y, double x)": [[15, 54]]}}}, {"text": "I have been able to generate private and public keys with the tutorial at http://docs.oracle.com/javase/tutorial/security/apisign/index.html but have not been able to do anything with them", "label": {"api": {"http://docs.oracle.com/javase/tutorial/security/apisign/index.html": [[74, 139]]}}}, {"text": "See SwingUtilities.invokeAndWait(Runnable) which", "label": {"api": {"SwingUtilities.invokeAndWait(Runnable)": [[4, 41]]}}}, {"text": "If you want a \"flexible\" size array, where you can add elements easily, use an ArrayList instead", "label": {"api": {"ArrayList": [[79, 87]]}}}, {"text": "If you look at the docs of the Request#getParameterMap(), it returns a Map of the type Map<String, String[]>", "label": {"api": {"Request#getParameterMap()": [[31, 55]]}}}, {"text": "Ofcourse, you can avoid all this and directly get the parameters from the request objects using the Request#getParameter() method", "label": {"api": {"Request#getParameter()": [[100, 121]]}}}, {"text": "Call Future.cancel(true) in the case of a timeout exception", "label": {"api": {"Future.cancel(true)": [[5, 23]]}}}, {"text": "This should result in an InterruptedIOException being thrown in your callable by conn.getResponseCode()", "label": {"api": {"InterruptedIOException": [[25, 46]]}}}, {"text": "You should use Collections", "label": {"api": {"Collections": [[15, 25]]}}}, {"text": "For more details on the user of the String format specifiers (i.e., the %6d and %6s above), please look at the Formatter API", "label": {"api": {"Formatter API": [[111, 123]]}}}, {"text": "You don't even need volatile here, because BlockingQueues already provide necessary memory visibility guarantees", "label": {"api": {"BlockingQueues": [[43, 56]]}}}, {"text": "Also it looks like you can use CyclicBarrier instead of your solution with queues, it's especially designed for similar scenarios", "label": {"api": {"CyclicBarrier": [[31, 43]]}}}, {"text": "I had a look at LSOuput as a replacement but I'm not really sure how to go about it", "label": {"api": {"LSOuput": [[16, 22]]}}}, {"text": "Arrays#asList doesn't return an ArrayList<T>, it returns a List<T>", "label": {"api": {"Arrays#asList": [[0, 12]], "List<T>": [[37, 43], [59, 65]]}}}, {"text": "You don't know anything about the implementation of the List, just that it adheres to the List contract, with the documented limitations (the List is fixed-size, so presumably doesn't implement the optional operations like List#add that would change its size)", "label": {"api": {"List#add": [[223, 230]]}}}, {"text": "You should use BigDecimal instead of float", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "If the BigDecimal.toString doesn't format the result the way you want, use DecimalFormat to perform the formatting instead", "label": {"api": {"BigDecimal": [[7, 16]], "DecimalFormat": [[75, 87]]}}}, {"text": "You can create warnings, notes, errors and other diagnostic messages like this using an annotation processor", "label": {"api": {"annotation processor": [[88, 107]]}}}, {"text": "Messages are created using the Messager class", "label": {"api": {"Messager": [[31, 38]]}}}, {"text": "I know that Eclipse and NetBeans do support messages generated by annotation processors, but there are probably other modern IDE that do so as well", "label": {"api": {"annotation processor": [[66, 85]]}}}, {"text": "The getMessage() and getLength() methods come from http://docs.oracle.com/javase/7/docs/api/javax/sound/midi/MidiMessage.html, I still haven't figured out what a FastShortMessage is, but it might just be leftover legacy code or something", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/sound/midi/MidiMessage.html": [[51, 124]]}}}, {"text": "Does anyone know how to add a tooltip to a column header in a TableView", "label": {"api": {"TableView": [[62, 70]]}}}, {"text": "Behind the scenes, a TransferHandler manages the adding and removing of strings", "label": {"api": {"TransferHandler": [[21, 35]]}}}, {"text": "Next, your server will need to listen for incoming connections by using SocketServer.accept()", "label": {"api": {"SocketServer.accept()": [[72, 92]]}}}, {"text": "An example of this is the Arrays class, which has lots of static methods for operating on arrays", "label": {"api": {"Arrays": [[26, 31]]}}}, {"text": "Try redirecting the error stream on the process by using a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[59, 72]]}}}, {"text": "If you wanted to pass the elements from al to alal, use ArrayList#addAll method", "label": {"api": {"ArrayList#addAll": [[56, 71]]}}}, {"text": "You can replace the format string according to your needs by looking at the SimpleDateFormat API", "label": {"api": {"SimpleDateFormat API": [[76, 95]]}}}, {"text": "You can replace the format string according to your needs by looking at the MaskFormatter API", "label": {"api": {"MaskFormatter API": [[76, 92]]}}}, {"text": "Your initial approach failed because PrintWriter wraps the given ByteArrayOutputStream with a BufferedWriter which has an internal character buffer of 8192 characters, and you never flush() the buffer before getting the bytes from the ByteArrayOutputStream", "label": {"api": {"PrintWriter": [[37, 47]], "BufferedWriter": [[94, 107]]}}}, {"text": "A fix would be to perform a flush() call before toByteArray() in your MyPrintWriter", "label": {"api": {"PrintWriter": [[72, 82]]}}}, {"text": "This also totally explains why it works when you write to getOutputStream(), this step namely doesn't use the PrintWriter and nothing gets buffered in some internal buffer", "label": {"api": {"PrintWriter": [[110, 120]]}}}, {"text": "It isn't respecting the response character encoding during construction of PrintWriter (you should actually wrap the ByteArrayOutputStream in an OutputStreamWriter instead which can take a character encoding) and relying on the platform default, in other words, any written Unicode characters may end up in Mojibake this way and thus this approach isn't ready for World Domination", "label": {"api": {"PrintWriter": [[75, 85]], "response character encoding": [[24, 50]], "OutputStreamWriter": [[145, 162]]}}}, {"text": "Also, this approach makes it possible to call both getWriter() and getOutputStream() on the same response, while that's considered an illegal state (precisely to avoid this kind of buffering and encoding trouble)", "label": {"api": {"considered an illegal state": [[120, 146]]}}}, {"text": "It is rather returning a number or string(may be, you need check your file for that) which is not matching with the pattern followed by your Scanner", "label": {"api": {"which is not matching with the pattern followed by your Scanner": [[85, 147]]}}}, {"text": "I think the best example is java.lang.Math, they are all static methods, and returns the expected values to you no matter what you called before", "label": {"api": {"java.lang.Math": [[28, 41]]}}}, {"text": "Look at String.split and you will find your answer after a bit of pondering it", "label": {"api": {"String.split": [[8, 19]]}}}, {"text": "Note that the new Java 8 time API defines such a Clock class, specifically for that purpose", "label": {"api": {"Clock class": [[49, 59]]}}}, {"text": "To find the intersection of two sets you can use the function retainAll", "label": {"api": {"retainAll": [[62, 70]]}}}, {"text": "However, Java, actually, has a EnumMap (it does implement regular Map interface) which is designed especially for use with enum type keys, and, as said in the documentation, it is likely to be faster than using HashMap", "label": {"api": {"EnumMap": [[31, 37]]}}}, {"text": "Probably TreeMap will help you", "label": {"api": {"TreeMap": [[9, 15]]}}}, {"text": "Now every implementation of SortedMap will do what you need", "label": {"api": {"SortedMap": [[28, 36]]}}}, {"text": "When iteration over the keys (which are profiles), you get them in the order as provided by your Comparator", "label": {"api": {"Comparator": [[97, 106]]}}}, {"text": "If you look for a solution how to parse the whole given string in one and only one step then Java 8 offers this option (the pattern symbol V is not supported in SimpleDateFormat)", "label": {"api": {"Java 8": [[93, 98]]}}}, {"text": "Every object inherits default implementations of hashCode() and equals() from java.lang.Object", "label": {"api": {"hashCode()": [[49, 58]], "equals()": [[64, 71]]}}}, {"text": "The implementations of those two functions in Object are obviously very basic but ensure the contract of hashCode() and equals() is fulfilled, specifically the a.equals(b) ==> a.hashCode() == b.hashCode() statement", "label": {"api": {"hashCode()": [[105, 114], [178, 187], [194, 203]], "equals()": [[120, 127]]}}}, {"text": "It's not a good way but still you can try it using ActionEvent#paramString() if it suits you", "label": {"api": {"ActionEvent#paramString()": [[51, 75]]}}}, {"text": "If you refer to the most commonly used one (MemoryStore), it uses SelectableConcurrentHashMap which is a somewhat customized version of ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[76, 92], [136, 152]]}}}, {"text": "If you don't want this behavior, you can mark to fetch the User in lazy way using FetchType.LAZY", "label": {"api": {"FetchType.LAZY": [[82, 95]]}}}, {"text": "Also, use AtomicInteger for Global.messageCount, calling AtomicInteger.getAndIncrement() to increment the counter", "label": {"api": {"AtomicInteger": [[10, 22], [57, 69]]}}}, {"text": "First, it's probably better to use the newer ProcessBuilder class as opposed to Runtime exec", "label": {"api": {"ProcessBuilder": [[45, 58]]}}}, {"text": "The purpose of BufferedWriter is to hold those characters in a buffer in memory until such time as you flush the buffer", "label": {"api": {"BufferedWriter": [[15, 28]]}}}, {"text": "John's solution seems faster but, if this is critical section of your program, you might want to also test the following (using just ConcurrentMap's atomic methods)", "label": {"api": {"ConcurrentMap's atomic methods": [[133, 162]]}}}, {"text": "Consider using a CountDownLatch to start the two threads at the same time", "label": {"api": {"CountDownLatch": [[17, 30]]}}}, {"text": "You could go and extend java.lang.Exception 4 times for each case", "label": {"api": {"java.lang.Exception": [[24, 42]]}}}, {"text": "Sounds like a good candidate for a Hashtable or Hashmap, where K would be your RepID, and V would be your ArrayList of type Person", "label": {"api": {"Hashtable": [[35, 43]], "Hashmap": [[48, 54]]}}}, {"text": "In Android, method getDeclaredMethod on class Class is said to be available starting on API Level 9 (reference)", "label": {"api": {"reference": [[101, 109]]}}}, {"text": "It has been available since JDK 1.1 (reference)", "label": {"api": {"reference": [[37, 45]]}}}, {"text": "The alternative (which is /much/ simpler) is to simply set your \"core\" size to the max number you wish to allow and allow core threads to time out", "label": {"api": {"allow core threads to time out": [[116, 145]]}}}, {"text": "According to DecimalFormat JavaDoc", "label": {"api": {"DecimalFormat JavaDoc": [[13, 33]]}}}, {"text": "You've got a variable of type Object, and you're calling Arrays.asList", "label": {"api": {"Arrays.asList": [[57, 69]]}}}, {"text": "You can remove any character/string from a string by using the Replace function", "label": {"api": {"Replace function": [[63, 78]]}}}, {"text": "What you want to achieve can be done using Arrays.copyOf", "label": {"api": {"Arrays.copyOf": [[43, 55]]}}}, {"text": "Although it is not explicitly specified for setTimestamp(int parameterIndex, Timestamp x) drivers have to follow the rules established by the setTimestamp(int parameterIndex, Timestamp x, Calendar cal) javadoc", "label": {"api": {"setTimestamp(int parameterIndex, Timestamp x, Calendar cal) javadoc": [[142, 208]]}}}, {"text": "You could also use a StringBuilder with its insert method", "label": {"api": {"insert": [[44, 49]]}}}, {"text": "Have a look at Collection.toArray", "label": {"api": {"Collection.toArray": [[15, 32]]}}}, {"text": "Instead of calling the empty constructor use JTextArea(int, int) to set the row and column size like this", "label": {"api": {"JTextArea(int, int)": [[45, 63]]}}}, {"text": "You have to implement a TableCellRenderer", "label": {"api": {"TableCellRenderer": [[24, 40]]}}}, {"text": "Seems like a TilePane is a better fit for this use case than a GridPane", "label": {"api": {"TilePane": [[13, 20]]}}}, {"text": "I would suggest using a ReentrantReadWriteLock to synchronize access", "label": {"api": {"ReentrantReadWriteLock": [[24, 45]]}}}, {"text": "Have a look at regular expressions", "label": {"api": {"regular expressions": [[15, 33]]}}}, {"text": "JMXConnectorServer has a method getConnectionIds() that I could use for that, but I already got stuck with the following question", "label": {"api": {"getConnectionIds()": [[32, 49]]}}}, {"text": "Why don't you use Stack that has a ensureCapacity() method", "label": {"api": {"Stack": [[18, 22]], "ensureCapacity()": [[35, 50]]}}}, {"text": "If you're using Java 7, you could use the Files.write method", "label": {"api": {"Files.write": [[42, 52]]}}}, {"text": "Files.lines(Path) expects a Path argument and returns a Stream<String>", "label": {"api": {"Files.lines(Path)": [[0, 16]]}}}, {"text": "Stream#forEach(Consumer) expects a Consumer argument", "label": {"api": {"Stream#forEach(Consumer)": [[0, 23]], "Consumer": [[15, 22], [35, 42]]}}}, {"text": "So invoke the method, passing it a Consumer", "label": {"api": {"Consumer": [[35, 42]]}}}, {"text": "This is Java 8, so you can use lambda expressions or method references to provide a Consumer argument", "label": {"api": {"Consumer": [[84, 91]]}}}, {"text": "There's a class called Preferences which stores this kind of information in an OS-dependent way", "label": {"api": {"Preferences": [[23, 33]]}}}, {"text": "The class Integer has many bit functions like Integer.highestOneBit", "label": {"api": {"Integer.highestOneBit": [[46, 66]]}}}, {"text": "Overload your method for the various primitive types like Arrays.toString(..) does", "label": {"api": {"Arrays.toString(..)": [[58, 76]]}}}, {"text": "Java provide methods to get a resource as a InputStream, but nothing that can easily get the File for a resource, although it is possible to get the URL for a given resource", "label": {"api": {"InputStream": [[44, 54]], "get the URL": [[141, 151]]}}}, {"text": "Have a look at java.util.Formatter", "label": {"api": {"java.util.Formatter": [[15, 33]]}}}, {"text": "The other answer's suggestion using of using StringBuilder was a good one", "label": {"api": {"StringBuilder": [[45, 57]]}}}, {"text": "Take a look at NumberFormat for formatting the number", "label": {"api": {"NumberFormat": [[15, 26]]}}}, {"text": "The docs say you need to provide the Qualified Name Representation of the element", "label": {"api": {"Qualified Name Representation": [[37, 65]]}}}, {"text": "Instead of using a no-op Transformer to serialize your DOM tree you could try using the DOM-native \"load and save\" mechanism, which should preserve the CDATASection nodes from the DOM tree and write them as CDATA sections in the resulting XML", "label": {"api": {"\"load and save\" mechanism": [[99, 123]]}}}, {"text": "A PathMatcher seems to be a purely functional interface", "label": {"api": {"PathMatcher": [[2, 12]]}}}, {"text": "The PathMatcher accepts a Path and returns boolean, I can't think of a reason why this processing would need any state that would make it unsafe", "label": {"api": {"PathMatcher": [[4, 14]]}}}, {"text": "The only state it might need would be a fixed(!) pattern, like when created with FileSystem.getPathMatcher(java.lang.String))", "label": {"api": {"PathMatcher": [[95, 105]], "FileSystem.getPathMatcher(java.lang.String)": [[81, 123]]}}}, {"text": "You use Class.getModifiers(), ideally using the Modifier class to interpret the return value in a readable way", "label": {"api": {"Class.getModifiers()": [[8, 27]], "Modifier": [[17, 24], [48, 55]]}}}, {"text": "Use a stack to store parenthesis and iterate through the string...a stack is lifo, so should make getting the closing parenthesis easy", "label": {"api": {"stack": [[6, 10], [68, 72]]}}}, {"text": "It gets the Metadata from the the returned Resultset to determine the number of columns the result set contains and does a simple iteration", "label": {"api": {"Metadata": [[12, 19]]}}}, {"text": "With the volatile it is guaranteed that (my interpretation of happens-before) a thread accessing the variable later (according to wall clock time) will see the changed value", "label": {"api": {"happens-before": [[62, 75]]}}}, {"text": "Alternatively you can create the PrintWriter with the autoFlush parameter, e.g.", "label": {"api": {"PrintWriter with the autoFlush parameter": [[33, 72]]}}}, {"text": "Java have Iterator interface that can walk through an Collection, so if your 'o' Object is an array, cast it into 'array' ArrayList and iterate on it", "label": {"api": {"Iterator": [[10, 17]]}}}, {"text": "This code takes advantage of the other overload of toArray, which accepts a typed array as an argument", "label": {"api": {"overload of toArray": [[39, 57]]}}}, {"text": "Is it safe for a task (a Runnable) being run by an Executor to submit (execute()) a task", "label": {"api": {"Executor": [[51, 58]], "execute()": [[71, 79]]}}}, {"text": "Any changes to the Observable's state can be propagated via a parameter in the notification mechanism; this is why Java's Observable has an extra parameter in it's notifyObservers(Object) method", "label": {"api": {"notifyObservers(Object)": [[164, 186]]}}}, {"text": "If the \"external object\" can be represented as an interface, another approach would be to create and use a proxy class", "label": {"api": {"proxy class": [[107, 117]]}}}, {"text": "You should make Player non-static in your class, or at the very least use a thread-local storage for it", "label": {"api": {"thread-local storage for it": [[76, 102]]}}}, {"text": "This could be done using standard input/output of the file watching process or using a Socket/ServerSocket or some other mechanism", "label": {"api": {"input": [[34, 38]], "output": [[40, 45]], "Socket": [[87, 92], [100, 105]], "ServerSocket": [[94, 105]]}}}, {"text": "According to the javadoc for Scanner, nextLine() throws this exception when there is no more input", "label": {"api": {"the javadoc for Scanner": [[13, 35]]}}}, {"text": "Use hasNextLine to make sure there's another line before using nextLine", "label": {"api": {"hasNextLine": [[4, 14]]}}}, {"text": "You need to use ZipOutputStream instead of FileOutputStream", "label": {"api": {"ZipOutputStream": [[16, 30]]}}}, {"text": "The javax.lang.model package (and subpackages) are designed for dealing with source code (the primary use case being annotation processors)", "label": {"api": {"javax.lang.model": [[4, 19]], "annotation processors": [[117, 137]]}}}, {"text": ".class files) for the Elements you're dealing with, so invoking Class.forName() is likely to fail", "label": {"api": {"Element": [[22, 28]]}}}, {"text": "It's likely that the DeclaredType returned by annotationMirror.getAnnotationType() provides access to the information you're after in a more reliable way than Annotation would", "label": {"api": {"DeclaredType": [[21, 32]], "Annotation": [[66, 75], [159, 168]]}}}, {"text": "It sounds like what you are looking for is a List, which is a data structure which is dynamically sized (it grows and shrinks as you add and remove elements)", "label": {"api": {"List": [[45, 48]]}}}, {"text": "When you iterate over a List you will only see the elements it currently holds, as opposed to an array, where you will need to traverse its length and check each entry to see if there is a value there or not", "label": {"api": {"List": [[24, 27]]}}}, {"text": "If you're married to using arrays for your calculation, you can still easily convert them to Lists for the purpose of display", "label": {"api": {"List": [[93, 96]]}}}, {"text": "I would make Rectangle objects and then use the Rectangle.intersects and Rectangle.contains methods to determine if they intersect or if one contains the other", "label": {"api": {"Rectangle objects": [[13, 29]]}}}, {"text": "Use String.format to format your output to 3 decimal places", "label": {"api": {"String.format": [[4, 16]]}}}, {"text": "According to the API, getSchema() returns the current schema name or null if there is none", "label": {"api": {"API": [[17, 19]]}}}, {"text": "I have tried using AccessController#doPrivileged, but that didn't help", "label": {"api": {"AccessController#doPrivileged": [[19, 47]]}}}, {"text": "do not confuse ArrayList#size(), current number of elements in the collection, with ArrayList#capacity, current maximum size of the collection (which cannot be accessed)", "label": {"api": {"ArrayList#size()": [[15, 30]]}}}, {"text": "You could use a java.util.LinkedHashMap<K, V>", "label": {"api": {"java.util.LinkedHashMap<K, V>": [[16, 44]]}}}, {"text": "Call its .restart() method to .", "label": {"api": {"restart()": [[10, 18]]}}}, {"text": "Please have a look atJTable#getValueAt() and JTable#getRowCount()", "label": {"api": {"JTable#getValueAt()": [[21, 39]], "JTable#getRowCount()": [[45, 64]]}}}, {"text": "You can add an image to a JLabel", "label": {"api": {"JLabel": [[26, 31]]}}}, {"text": "This Icon could be something like an ImageIcon, which has a constructor that takes a filename to display", "label": {"api": {"ImageIcon": [[37, 45]], "constructor that takes a filename to display": [[60, 103]]}}}, {"text": "If someone tries to add to a queue whose capacity is zero, or in fact any time someone tries to add an element which would exceed the capacity of the queue, you should throw an IllegalStateException", "label": {"api": {"IllegalStateException": [[177, 197]]}}}, {"text": "Personally I would recommend taking a look at AbstractQueue and its subclasses in the API docs for a good example of how to handle the various error other conditions as well", "label": {"api": {"the API docs": [[82, 93]]}}}, {"text": "A JTextField can be set uneditable using setEditable(false)", "label": {"api": {"setEditable(false)": [[41, 58]]}}}, {"text": "You could also use JLabels", "label": {"api": {"JLabels": [[19, 25]]}}}, {"text": "For maximal performance in parallel operations use findAny() which is similar to findFirst()", "label": {"api": {"findAny": [[51, 57]]}}}, {"text": "This is possible for Iterable.forEach() (but not reliably with Stream.forEach())", "label": {"api": {"Iterable.forEach()": [[21, 38]]}}}, {"text": "According to the documentation for Iterable.forEach()", "label": {"api": {"Iterable.forEach()": [[35, 52]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/security/Signature.html for details", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/security/Signature.html": [[4, 72]]}}}, {"text": "I have some trouble understanding what the javadoc for this method means to say here", "label": {"api": {"javadoc for this method": [[43, 65]]}}}, {"text": "Try DefaultTableCellRenderer.getTableCellRendererComponent() to customize the look and feel of cell item", "label": {"api": {"DefaultTableCellRenderer.getTableCellRendererComponent()": [[4, 59]]}}}, {"text": "Look at the JavaDoc what Color.getColor() says", "label": {"api": {"Color.getColor()": [[25, 40]]}}}, {"text": "What you're missing is that EntityManager.find() returns the entity identified by the given ID (primary key)", "label": {"api": {"EntityManager.find()": [[28, 47]]}}}, {"text": "The documentation for the Pattern class provides a great cheat-sheet of the pattern elements", "label": {"api": {"documentation for the Pattern class": [[4, 38]]}}}, {"text": "For buffering a String, use a StringBuilder", "label": {"api": {"StringBuilder": [[30, 42]]}}}, {"text": "There exists also a StringBuffer class, the difference is that the latter one (StringBuffer) is synchonized while StringBuilder is not", "label": {"api": {"StringBuilder": [[114, 126]]}}}, {"text": "But in case of multi-threading, I recommend you to use a StringBuilder and to synchronize it (read this article from @PeterLawrey)", "label": {"api": {"StringBuilder": [[57, 69]]}}}, {"text": "I assumed the delete(int start, int end) should suit that purpose", "label": {"api": {"delete(int start, int end)": [[14, 39]]}}}, {"text": "Use a Map<String, Double> where the key is the concatenation of the names in alphabetic order, separated by a special character (i.e", "label": {"api": {"Map<String, Double>": [[6, 24]]}}}, {"text": "Instead use the second version and supply the constant value from StandardCharsets (specifically, StandardCharsets.UTF_8, in this case)", "label": {"api": {"StandardCharsets": [[66, 81], [98, 113]]}}}, {"text": "You can set multiline delimeter", "label": {"api": {"delimeter": [[22, 30]]}}}, {"text": "Use Signature class instead of combination Cipher and MessageDigest", "label": {"api": {"Signature": [[4, 12]], "Cipher": [[43, 48]], "MessageDigest": [[54, 66]]}}}, {"text": "Also you want to use Arrays.equals(byte[], byte[]) instead of equality operator, as the latter just ensures that array object is the same, while the former compares actual content of the arrays", "label": {"api": {"Arrays.equals(byte[], byte[])": [[21, 49]]}}}, {"text": "I would create a FileInputStream and pass it to copy()", "label": {"api": {"FileInputStream": [[17, 31]]}}}, {"text": "Well, I could create CountingFileInputStream which extends FileInputStream", "label": {"api": {"FileInputStream": [[29, 43], [59, 73]]}}}, {"text": "The CountingFileInputStream is-a FileInputStream", "label": {"api": {"FileInputStream": [[12, 26], [33, 47]]}}}, {"text": "So in short, in terms of the is-a relationship, CountingInputStream is-an InputStream (which is usually all we care about) but it is-not-a FileInputStream, which allows it to wrap any InputStream, like a LimitInputStream which is decorating a DeflaterInputStream which is decorating a BufferedInputStream which is decorating a FileInputStream", "label": {"api": {"DeflaterInputStream": [[243, 261]], "BufferedInputStream": [[285, 303]], "FileInputStream": [[139, 153], [327, 341]]}}}, {"text": "String#substring() is meant to throw an IndexOutOfBoundsException if the first parameter is greater than the second parameter", "label": {"api": {"String#substring()": [[0, 17]]}}}, {"text": "just use constructor of Number class", "label": {"api": {"Number": [[24, 29]]}}}, {"text": "You might want to take a look at the StringBuffer and the StringBuilder classes (http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html": [[81, 148]]}}}, {"text": "The String javadoc should help you find how to look for characters in a string, and how to extract substrings", "label": {"api": {"String javadoc": [[4, 17]]}}}, {"text": "Or use the isAssignableFrom method on Class to test with the Class rather than an instance", "label": {"api": {"isAssignableFrom": [[11, 26]]}}}, {"text": "You could use Java's built-in ProcessBuilder to do this", "label": {"api": {"ProcessBuilder": [[30, 43]]}}}, {"text": "You could annotate your servlet with @MultipartConfig, then you can use HttpServletRequest#getParts() to get the individual parts", "label": {"api": {"@MultipartConfig": [[37, 52]], "HttpServletRequest#getParts()": [[72, 100]]}}}, {"text": "You could use a for loop and call toArray() for each inner list", "label": {"api": {"toArray()": [[34, 42]]}}}, {"text": "With a comparator you can simply use Collections.sort to sort the list", "label": {"api": {"Collections.sort": [[37, 52]]}}}, {"text": "It's not very efficient to sort a linked list, so if you don't use Collections.sort, which uses an intermediate array to sort, I'd suggest that you change your datastructure to e.g", "label": {"api": {"Collections.sort": [[67, 82]]}}}, {"text": "If you are using Java 8, there's also a specialized TextFlow container available", "label": {"api": {"TextFlow": [[52, 59]]}}}, {"text": "Using the @Convert annotation", "label": {"api": {"@Convert": [[10, 17]]}}}, {"text": "Pay attention for TimeUnit class, very useful for tasks with delay", "label": {"api": {"TimeUnit": [[18, 25]]}}}, {"text": "Use a Timeline to update the imageProperty of an ImageView", "label": {"api": {"Timeline": [[6, 13]], "ImageView": [[49, 57]]}}}, {"text": "You could use an implementation of an ExecutorService in combination with a Future object (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html": [[91, 163]]}}}, {"text": "Or you could just use an ArrayList which has no defined size (you can .add elements to it and so you don't need to know the size beforehand to populate it)", "label": {"api": {"ArrayList": [[25, 33]]}}}, {"text": "And then just convert the ArrayList to a regular array afterword if you wanted to", "label": {"api": {"ArrayList": [[26, 34]]}}}, {"text": "The readInput() method uses a Console to read the high and low values into a class Pair that holds the user input", "label": {"api": {"Console": [[30, 36]]}}}, {"text": "In fact I'm searching the setVisibleRowCount() method of JList in the ListView component", "label": {"api": {"setVisibleRowCount()": [[26, 45]]}}}, {"text": "I wanted to set the amount of visible rows (exactly 3) in my ListView", "label": {"api": {"ListView": [[61, 68]]}}}, {"text": "In my case, a TextField gave a perfect result", "label": {"api": {"TextField": [[14, 22]]}}}, {"text": "I can image though that the ideal would be to tie the preferred height (or with) to the height (or width) of a ListCell which is the thing that the list view actually contain", "label": {"api": {"ListCell": [[111, 118]]}}}, {"text": "Note that I had to use Platform.runLater(Runnable) because during the controller's initialization, the nodes doesn't have a height", "label": {"api": {"Platform.runLater(Runnable)": [[23, 49]]}}}, {"text": "You should use remainder() method", "label": {"api": {"remainder()": [[15, 25]]}}}, {"text": "According to Java's Class KeyStore, there is a KeyStore.TrustedCertificateEntry type", "label": {"api": {"Class KeyStore": [[20, 33]]}}}, {"text": "Next check the documentation for the Scanner class", "label": {"api": {"check the documentation for the Scanner class": [[5, 49]]}}}, {"text": "Just split once using the alternate version of split()", "label": {"api": {"split()": [[47, 53]]}}}, {"text": "3) Moreover, \"Servlet.init()\" is also used by web container to inject \"ServletContext\" object where you can't use constructor for that purpose", "label": {"api": {"is also used by web container to inject \"ServletContext\" object": [[30, 92]]}}}, {"text": "Instead, I am going to say to take a look at the StringBuilder API", "label": {"api": {"StringBuilder API": [[49, 65]]}}}, {"text": "You can set uncaught exception handler for main thread and every other you create using Thread.setUncaughtExceptionHandler() method and do all the required logging there", "label": {"api": {"Thread.setUncaughtExceptionHandler()": [[88, 123]]}}}, {"text": "Look at java.lang.reflect.Array, it has all the methods needed to access the length and the individual elements of an array", "label": {"api": {"java.lang.reflect.Array": [[8, 30]]}}}, {"text": "To access arrays reflectively use java.lang.reflect.Array", "label": {"api": {"java.lang.reflect.Array": [[34, 56]]}}}, {"text": "you have to close the ExecutorService afterwards using shutdownNow() or  shutdown()", "label": {"api": {"ExecutorService": [[22, 36]]}}}, {"text": "contains(Object o) is internally based on equals between objects of your list and your input, as stated by the doc", "label": {"api": {"as stated by the doc": [[94, 113]]}}}, {"text": "I think the value classpath:data/exampleMessage.xml is not an InputStream but an InputStreamSource which is not an InputStream as of the Spring Documentation", "label": {"api": {"InputStream": [[62, 72], [81, 91], [115, 125]]}}}, {"text": "The JavaDoc of SimpleDateFormat does contain such a list", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "Implementing a TableCellRenderer is the way to go", "label": {"api": {"TableCellRenderer": [[15, 31]]}}}, {"text": "getTableCellRendererComponent can return any Swing component", "label": {"api": {"TableCellRenderer": [[3, 19]]}}}, {"text": "Relevant javadoc for QName, spec constraints stating name is an anyURI, and localpart is an NCName", "label": {"api": {"Relevant javadoc for QName": [[0, 25]]}}}, {"text": "It is the responsibility of the Student class to provide a proper equals() method which is consistent with the hashCode() contract", "label": {"api": {"equals()": [[66, 73]], "hashCode()": [[111, 120]]}}}, {"text": "If two objects are equal according to the equals(Object) method, then calling the hashCode() method on each of the two objects must produce the same integer result", "label": {"api": {"hashCode()": [[82, 91]]}}}, {"text": "You have not overwritten the underlying Object.Hashcode, you would need something like this, your ide can generate hashcode and equals for you", "label": {"api": {"Object.Hashcode": [[40, 54]]}}}, {"text": "The steps outlined in this question use DocumentBuilder.parse(String); this tries to parse the entire file at once", "label": {"api": {"DocumentBuilder.parse(String)": [[40, 68]]}}}, {"text": "The JSpinner JavaDoc describes why this happens and how to solve it", "label": {"api": {"JSpinner JavaDoc": [[4, 19]]}}}, {"text": "To access files inside a JAR, you need to use the Class.getResource or Class.getResourceAsStream methods as they aren't visible to normal file operations", "label": {"api": {"Class.getResource": [[50, 66], [71, 87]], "Class.getResourceAsStream": [[71, 95]]}}}, {"text": "From the j.u.l.FileHandler documentation", "label": {"api": {"j.u.l.FileHandler": [[9, 25]]}}}, {"text": "Files.move() will work provided that the file system is able to \"move\" the file", "label": {"api": {"Files.move()": [[0, 11]]}}}, {"text": "Java has this built in, using native OS operation, in File.renameTo(File dest)", "label": {"api": {"File.renameTo(File dest)": [[54, 77]]}}}, {"text": "Java has the BigDecimal type for this purpose", "label": {"api": {"BigDecimal": [[13, 22]]}}}, {"text": "Instead reinventing the wheel or marking the methods to throw UnsupportedOperationException, extend from a class that already implements all the methods, like HashMap or LinkedHashMap, or a class that implements Map but doesn't implement it at all, like AbstractMap, and left empty the other methods", "label": {"api": {"AbstractMap": [[254, 264]]}}}, {"text": "You could consider to extend the punctuation to \\p{Punct}, see javadoc for Pattern", "label": {"api": {"Pattern": [[75, 81]]}}}, {"text": "What I'm looking for - just to be clear - is not CAS operations, but an implementation of, say, the synchronized keyword, or ReentrantLock that works like a Semaphore BUT with actual synchronization semantics that doesn't block threads to perform a certain action like invocations getters and setters", "label": {"api": {"ReentrantLock": [[125, 137]], "Semaphore": [[157, 165]]}}}, {"text": "But you could use tryLock to determine if you can acquire a Lock and perform a synchronized action or, if you cannot acquire the Lock, perform a non-synchronized action", "label": {"api": {"tryLock": [[18, 24]]}}}, {"text": "The best approach is to usePreparedStatement, because it makes code more readable, easier to understand, it provides compile time check of paramaters and it provides protection for SQL injections", "label": {"api": {"PreparedStatement": [[27, 43]]}}}, {"text": "I would suggest using the Executors framework", "label": {"api": {"Executors": [[26, 34]]}}}, {"text": "The Java API specification itself is an example of HTML documentation generated through javadoc", "label": {"api": {"The Java API specification itself": [[0, 32]]}}}, {"text": "I believe the Interface org.w3c.dom.NodeList is missing a stream() function to make use of the benefits of Java 8's Stream API", "label": {"api": {"org.w3c.dom.NodeList": [[24, 43]]}}}, {"text": "Use the promptText property (see ref)", "label": {"api": {"ref": [[33, 35]]}}}, {"text": "The usual way to do this is to override toString in your classes", "label": {"api": {"toString": [[40, 47]]}}}, {"text": "You could use the Number type as your array type", "label": {"api": {"Number": [[18, 23]]}}}, {"text": "It is extended by both Integer and Double", "label": {"api": {"Integer": [[23, 29]], "Double": [[35, 40]]}}}, {"text": "Make it accept a Number[][]", "label": {"api": {"Number[][]": [[17, 26]]}}}, {"text": "Also, you could wrap your current List using Collections#unmodifiableList to avoid elements removal (that is a wrapper class like mentioned above except that implements List) but note that you cannot add elements either", "label": {"api": {"Collections#unmodifiableList": [[45, 72]]}}}, {"text": "Use the XMLDecoder", "label": {"api": {"XMLDecoder": [[8, 17]]}}}, {"text": "Check ResultSet#getInt(int columnIndex)", "label": {"api": {"ResultSet#getInt(int columnIndex)": [[6, 38]]}}}, {"text": "Apart from this, it would be better if you use a PreparedStatement to execute your queries, it has many advantages over plain Statement as explained here", "label": {"api": {"PreparedStatement": [[49, 65]]}}}, {"text": "Difference between Statement and PreparedStatement", "label": {"api": {"PreparedStatement": [[33, 49]]}}}, {"text": "There are some changes in Java 8 that might have introduced a bug", "label": {"api": {"changes": [[15, 21]]}}}, {"text": "java.awt.geom.Point2D.Double does not implement java.awt.Shape, so you can't use it as an argument to Graphics2D.draw", "label": {"api": {"java.awt.geom.Point2D.Double": [[0, 27]], "java.awt.Shape": [[48, 61]]}}}, {"text": "The simplest method would probably be to use Rectangle2D.Double like so", "label": {"api": {"Rectangle2D.Double": [[45, 62]]}}}, {"text": "Sounds like a job for UUID.randomUUID()", "label": {"api": {"UUID.randomUUID()": [[22, 38]]}}}, {"text": "I suggest you add a clone to your Customer class by implementing Cloneable", "label": {"api": {"Cloneable": [[65, 73]]}}}, {"text": "However, BigInteger does implement Comparable<BigInteger>, so call compareTo instead", "label": {"api": {"compareTo": [[67, 75]]}}}, {"text": "For equality, use left.compareTo(right) == 0", "label": {"api": {"compareTo": [[23, 31]]}}}, {"text": "For less than, use left.compareTo(right) < 0", "label": {"api": {"compareTo": [[24, 32]]}}}, {"text": "For greater than, use left.compareTo(right) > 0", "label": {"api": {"compareTo": [[27, 35]]}}}, {"text": "By looking at the DecimalFormat docs, I can say, that", "label": {"api": {"DecimalFormat": [[18, 30]]}}}, {"text": "You can use System.arraycopy()", "label": {"api": {"System.arraycopy": [[12, 27]]}}}, {"text": "Use Arrays.copyOf(double, int)", "label": {"api": {"Arrays.copyOf(double, int)": [[4, 29]]}}}, {"text": "That's exactly what it's made for, with methods like take", "label": {"api": {"take": [[53, 56]]}}}, {"text": "If you are interesting in how this is implemented, you can take a look at the source for these classes, for example LinkedBlockingQueue#take", "label": {"api": {"take": [[59, 62], [136, 139]]}}}, {"text": "As you can see, they maintain a couple of Conditions to signal if the queue is empty or not", "label": {"api": {"Conditions": [[42, 51]]}}}, {"text": "More about Thread.yield", "label": {"api": {"Thread.yield": [[11, 22]]}}}, {"text": "Also consider sleeping for some small amount of time, say 50ms", "label": {"api": {"sleeping": [[14, 21]]}}}, {"text": "To validate a String, you can simply use Double.parseDouble or Integer.parseInt", "label": {"api": {"Double.parseDouble": [[41, 58]], "Integer.parseInt": [[63, 78]]}}}, {"text": "This is the default way to store some settings in Java, using Properties", "label": {"api": {"Properties": [[62, 71]]}}}, {"text": "The javadoc for URL's .toURI() method mentions that it can throw a URISyntaxException if", "label": {"api": {"URL's .toURI() method": [[16, 36]], "URISyntaxException": [[67, 84]]}}}, {"text": "The interface defines exactly how equals and hashCode should work", "label": {"api": {"interface defines exactly": [[4, 28]]}}}, {"text": "Instead of using replaceAll, you could use replaceFirst to replace just the first occurrence of that section title", "label": {"api": {"replaceFirst": [[43, 54]]}}}, {"text": "If so, you could use the Double#parseDouble function", "label": {"api": {"Double#parseDouble": [[25, 42]]}}}, {"text": "I think this is the relevant part of the Javadoc that describes the behavior you're looking at (from the static String toString(float) method)", "label": {"api": {"static String toString(float)": [[105, 133]]}}}, {"text": "If you have a look at the java.sql.Connection interface and search for the \"Since:\" markers you will see that additional methods were added to it in Java 6, and more in Java7", "label": {"api": {"java.sql.Connection": [[26, 44]]}}}, {"text": "The nature of DBCP means that it will be providing it's own implementation of java.sql.Connection (amongst others I expect), and it needs to implement the new interfaces for the newer Java versions", "label": {"api": {"java.sql.Connection": [[78, 96]]}}}, {"text": "Have each Runnable or Thread that implements your routing thread expose (say) a java.util.concurrent.TransferQueue<YourTableType> and deliver your tables to it", "label": {"api": {"java.util.concurrent.TransferQueue<YourTableType>": [[80, 128]], "java.util.concurrent": [[80, 99]]}}}, {"text": "The java.util.concurrent package is extremely well documented, so it's worth having a good look around in it", "label": {"api": {"java.util.concurrent": [[4, 23]]}}}, {"text": "You are using clearRect which is effectively deleting that portion of the panel, and replaces it with the background color", "label": {"api": {"clearRect": [[14, 22]]}}}, {"text": "Use the corresponding drawRect-method instead, which will employ the foreground color which you are correctly setting via setColor", "label": {"api": {"drawRect": [[22, 29]], "setColor": [[122, 129]]}}}, {"text": "The usual approach would be to write a Comparator so that sort works as you intend it", "label": {"api": {"Comparator": [[39, 48]], "sort": [[58, 61]]}}}, {"text": "Since you don't say how the other keys should be sorted, the only thing I can say about this comparator is that it should consider the key that has no parent as the lowest one", "label": {"api": {"sort": [[49, 52]]}}}, {"text": "java.awt.MouseInfo should help you get what you want", "label": {"api": {"java.awt.MouseInfo": [[0, 17]]}}}, {"text": "However I don't think that in your case that you need to use replaceAll, as you may use replace(), which will yield cleaner code replace(\"],[\", \"] [\")", "label": {"api": {"replace()": [[88, 96]]}}}, {"text": "If what you want is simply to delete the matching items, then you can use java.util.Iterator (see http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html) to iterate over the collection, and invoke the Iterator's remove() method on each matching object as you encounter it", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html": [[98, 161]]}}}, {"text": "Class.getResourceAsStream() returns null when there is no resource with the specified name", "label": {"api": {"Class.getResourceAsStream()": [[0, 26]]}}}, {"text": "KeyStore.load() resets the key store to the empty state when passed a null input stream", "label": {"api": {"KeyStore.load()": [[0, 14]]}}}, {"text": "add a guarding condition that checks that getResourceAsStream() returned non-null value before passing it value into KeyStore.load()", "label": {"api": {"KeyStore.load()": [[117, 131]]}}}, {"text": ".length() is a method for the class String (look here)", "label": {"api": {"look here": [[44, 52]]}}}, {"text": "Integer.decode should do the trick", "label": {"api": {"Integer.decode": [[0, 13]]}}}, {"text": "The %n prints a platform-dependent newline character (\\r, \\r\\n, \\n), but there is no such a thing as a platform-dependent \"space\", so you just use a \" \" in your format string", "label": {"api": {"prints a platform-dependent newline character": [[7, 51]]}}}, {"text": "Make sure you are using a DefaultListModel", "label": {"api": {"DefaultListModel": [[26, 41]]}}}, {"text": "Sounds like a ConcurrentLinkedQueue is what you are looking for", "label": {"api": {"ConcurrentLinkedQueue": [[14, 34]]}}}, {"text": "Java 8 officially introduce java.io.UncheckedIOException to JDK class libraries for lambda with Stream API, because lambda expressions can't declare its throws-clause and lambda body can't throw checked exception such as IOException", "label": {"api": {"java.io.UncheckedIOException": [[28, 55]]}}}, {"text": "If the byte array actually contains some format of raw pixel data, you will need to load it into a BufferedImage directly (such as via setRGB) and encode that as a JPEG", "label": {"api": {"setRGB": [[135, 140]]}}}, {"text": "Use a StringBuilder to construct your string", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "Take advantage of Java 7's Objects class for your hashCode() and equals() methods", "label": {"api": {"Objects": [[27, 33]]}}}, {"text": "The following method declaration would throw the NoRouteToHostException exception", "label": {"api": {"NoRouteToHostException": [[49, 70]]}}}, {"text": "Will catch the NoRouteToHostException; as NoRouteToHostException extends IOException", "label": {"api": {"NoRouteToHostException": [[15, 36], [42, 63]]}}}, {"text": "String.join was only introduced in Java 8 (JDK 1.8)", "label": {"api": {"String.join": [[0, 10]]}}}, {"text": "EditorKit is the abstract parent of DefaultEditorKit and StyledEditorKit, both of which export useful Action classes that operate on the Document model common to text components", "label": {"api": {"EditorKit": [[0, 8], [43, 51], [63, 71]]}}}, {"text": "You can create a instance of FXMLLoader and use a non-static load method (load(java.io.InputStream inputStream) or load())", "label": {"api": {"FXMLLoader": [[29, 38]], "load(java.io.InputStream inputStream)": [[74, 110]], "load()": [[115, 120]]}}}, {"text": "Afterwards you can get the controller using the getController() method", "label": {"api": {"getController()": [[48, 62]]}}}, {"text": "The reference Optional has a map method which you could use do something similar to what you want, but it appears to be absent from the primitive optionals", "label": {"api": {"Optional": [[14, 21]], "map": [[29, 31]]}}}, {"text": "I believe your only recourse currently is to use OptionalDouble::isPresent or OptionalDouble::ifPresent", "label": {"api": {"Optional": [[49, 56], [78, 85]]}}}, {"text": "Or you could define your own helper add methods or define your own OptionalDouble class to include those methods", "label": {"api": {"Optional": [[67, 74]]}}}, {"text": "String's substring(startIndex, endIndex) methods actually takes a string from a start index (inclusive) to the end index (exclusive) of the string array (A string is a CharSequence which is a \"string array\")", "label": {"api": {"substring(startIndex, endIndex)": [[9, 39]]}}}, {"text": "A substring(startIndex) takes a string starting from index to the end of the string", "label": {"api": {"substring(startIndex)": [[2, 22]]}}}, {"text": "The replaceAll(String regularExpression, String replacement) method will replace a string based on the matched regular expression criteria", "label": {"api": {"replaceAll(String regularExpression, String replacement)": [[4, 59]]}}}, {"text": "EDIT - The exception was caused by a leftover SwingNode from some earlier experiment on the same Pane as the ComboBox", "label": {"api": {"SwingNode": [[46, 54]]}}}, {"text": "Deleting the SwingNode made the exception vanish", "label": {"api": {"SwingNode": [[13, 21]]}}}, {"text": "If your input is coming up as a String just parse it using Integer.parseInt", "label": {"api": {"Integer.parseInt": [[59, 74]]}}}, {"text": "I would use a linked list", "label": {"api": {"linked list": [[14, 24]]}}}, {"text": "If you are using Java 11 or above, you can use the String class isBlank() method", "label": {"api": {"String class isBlank()": [[51, 72]]}}}, {"text": "All Number classes have a String constructor, so you can safely use reflection to invoke that constructor", "label": {"api": {"Number": [[4, 9]]}}}, {"text": "Also JDK 1.5 or above should be present and visible instead of default JDK 1.4 which doesn't understand String.replace method with string params", "label": {"api": {"String.replace": [[104, 117]]}}}, {"text": "Use Pattern.quote(String) method", "label": {"api": {"Pattern.quote(String)": [[4, 24]]}}}, {"text": "However, you could extract the file(s) into temp file(s) on start and then use that", "label": {"api": {"temp file(s)": [[44, 55]]}}}, {"text": "The method you are looking for is ServletContext#getInitParameterNames()", "label": {"api": {"ServletContext#getInitParameterNames()": [[34, 71]]}}}, {"text": "JList component has setListData(Object[] ListData) method for set data of your jlist", "label": {"api": {"JList": [[0, 4]], "setListData(Object[] ListData)": [[20, 49]]}}}, {"text": "You could use object serialization with ObjectOutputStream and a Shutdown Hook", "label": {"api": {"ObjectOutputStream": [[40, 57]]}}}, {"text": "What is the difference between ClassNotFoundException and ClassDefNotFoundException I know that both are subclass of Exception", "label": {"api": {"ClassNotFoundException": [[31, 52]]}}}, {"text": "Got some explanation for ClassNotFoundException from this question", "label": {"api": {"ClassNotFoundException": [[25, 46]]}}}, {"text": "What is the difference between NoClassDefFoundError and ClassNotFoundException", "label": {"api": {"ClassNotFoundException": [[56, 77]]}}}, {"text": "Exception handling in java is meant to process the risky behaviour in your program but Errors stand for serious matters and should not be catched", "label": {"api": {"Error": [[87, 91]]}}}, {"text": "Generally speaking, it is non advised to catch Errors but only Exceptions (checked or unchecked)", "label": {"api": {"Error": [[47, 51]]}}}, {"text": "Here is lines from the JAVA API for Error", "label": {"api": {"Error": [[36, 40]]}}}, {"text": "An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch", "label": {"api": {"Error": [[3, 7]]}}}, {"text": "The ThreadDeath error, though a \"normal\" condition, is also a subclass of Error because most applications should not try to catch it", "label": {"api": {"Error": [[74, 78]]}}}, {"text": "A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur", "label": {"api": {"Error": [[75, 79]]}}}, {"text": "That is, Error and its subclasses are regarded as unchecked exceptions for the purposes of compile-time checking of exceptions", "label": {"api": {"Error": [[9, 13]]}}}, {"text": "You can do it using Calendar", "label": {"api": {"Calendar": [[20, 27]]}}}, {"text": "Look at the method Timer#schedule(TimerTask task,long delay,long period) that you have used of  Timer class", "label": {"api": {"Timer#schedule(TimerTask task,long delay,long period)": [[19, 71]]}}}, {"text": "In case you're not doing this for homework/exercise/specific sort algorithm purpose, use Arrays#sort(int[]) or Arrays#sort(Object[] array) instead", "label": {"api": {"Arrays#sort(int[])": [[89, 106]], "Arrays#sort(Object[] array)": [[111, 137]]}}}, {"text": "Heck, that's the scenario that PropertyResourceBundle is made for", "label": {"api": {"PropertyResourceBundle": [[31, 52]]}}}, {"text": "Have a look at the API for java.util.regex to see the other methods which Pattern and Matcher provide", "label": {"api": {"the API for java.util.regex": [[15, 41]]}}}, {"text": "I know I could use getAnnotations and search in the resulting array for an element whose class name is equal to the name of SomeAnnotation", "label": {"api": {"getAnnotations": [[19, 32]]}}}, {"text": "Honestly, though, I would say that the use of doubleToLongBits is a bug here, since if you care about exact equality you should be using Double.doubleToRawLongBits() (which does not perform any translations on the double data at all) instead", "label": {"api": {"Double.doubleToRawLongBits()": [[137, 164]]}}}, {"text": "Eclipse uses Double.doubleToLongBits because that's what Double.equals does", "label": {"api": {"Double.doubleToLongBits": [[13, 35]], "Double.equals": [[57, 69]]}}}, {"text": "For this purpose, two double values are considered to be the same if and only if the method doubleToLongBits(double) returns the identical long value when applied to each", "label": {"api": {"doubleToLongBits(double)": [[92, 115]]}}}, {"text": "the JLS specifies a few differences between Double.equals and ==", "label": {"api": {"Double.equals": [[44, 56]]}}}, {"text": "The handler code runs in different context than where you register the handler (addEventHandler()), so the value of i does not have the same meaning", "label": {"api": {"addEventHandler()": [[80, 96]]}}}, {"text": "To use a parable, by calling the addEventHandler() you tell the ImageView this", "label": {"api": {"addEventHandler()": [[33, 49]]}}}, {"text": "I think you're looking for System.arraycopy, which you can use to copy the contents of one array into another", "label": {"api": {"System.arraycopy": [[27, 42]]}}}, {"text": "For firing events programmatically, look at AbstractButton.doClick() if you are outside the button, or preferably AbstractButton.fireActionPerformed() in a subclass", "label": {"api": {"AbstractButton.doClick()": [[44, 67]]}}}, {"text": "For the particular example of NavigableSet.descendingIterator(), I think the simplest way is to use NavigableSet.descendingSet() instead", "label": {"api": {"NavigableSet.descendingSet()": [[100, 127]]}}}, {"text": "In short, you have to create a Spliterator from the Iterator first using one of the static methods in Spliterators", "label": {"api": {"Spliterator": [[31, 41], [102, 112]], "Spliterators": [[102, 113]]}}}, {"text": "Then you can create a Stream using the static methods in StreamSupport", "label": {"api": {"StreamSupport": [[57, 69]]}}}, {"text": "I don't have that much experience with creating Spliterators and Streams by hand yet, so I can't really comment on what the characteristics should be or what effect they will have", "label": {"api": {"Spliterator": [[48, 58]], "Spliterators": [[48, 59]]}}}, {"text": "There is also a method in Spliterators for creating a Spliterator with an initial size estimate - I suppose in this particular example you could use set.size(), but if you want to handle arbitrary Iterators I guess this won't be the case", "label": {"api": {"Spliterator": [[26, 36], [54, 64]], "Spliterators": [[26, 37]]}}}, {"text": "The argument you pass in is a Consumer which is the same thing you pass to Stream::forEach", "label": {"api": {"Consumer": [[30, 37]], "Stream::forEach": [[75, 89]]}}}, {"text": "Here are the docs for that method", "label": {"api": {"Here are the docs": [[0, 16]]}}}, {"text": "You can go take a look at the ResultSetMetaData API for all the other things you can do with it", "label": {"api": {"the ResultSetMetaData API": [[26, 50]]}}}, {"text": "Using Random.nextInt(n) you can generate a random index between 0 (inclusive) and the length of your array (exclusive)", "label": {"api": {"Random.nextInt(n)": [[6, 22]]}}}, {"text": "Look here Component#show()", "label": {"api": {"Component#show()": [[10, 25]]}}}, {"text": "2) If you want to block current thread until the child thread finishes then instead of calling cancel you can use get http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get() or even get with timeout", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get()": [[118, 196]]}}}, {"text": "If there is only 1 number in each line of the file, then you can read it line by line and convert each line to an Integer using Integer.parseInt", "label": {"api": {"Integer.parseInt": [[128, 143]]}}}, {"text": "(http://docs.oracle.com/javase/7/docs/api/javax/swing/DefaultListModel.html) class to manipulate JList", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/DefaultListModel.html": [[1, 74]]}}}, {"text": "Call JList#setListData() again after clearing the list", "label": {"api": {"JList#setListData()": [[5, 23]]}}}, {"text": "If you must get the GridBagConstraints for an individual component in the GridBagLayout-using container, per the GridBagLayout API you could use the GridBagLayout method, public GridBagConstraints getConstraints(Component comp)", "label": {"api": {"GridBagLayout API": [[113, 129]]}}}, {"text": "The java.sql.Timestamp object returned, when treated like a java.util.Date, has integer seconds", "label": {"api": {"java.sql.Timestamp": [[4, 21]]}}}, {"text": "I suppose you could have an ArrayList and just add IDs from it and always take the lowest one available", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "However, from the description of your problem, it sounds like JSplitPane will serve you better for this", "label": {"api": {"JSplitPane": [[62, 71]]}}}, {"text": "The TableRowSorter class provides the setComparator(int column, Comparator<?> comparator) method", "label": {"api": {"TableRowSorter": [[4, 17]]}}}, {"text": "You can make getAll() returning an unmodifiable list", "label": {"api": {"unmodifiable list": [[35, 51]]}}}, {"text": "I have not used SwingWorker in Java yet", "label": {"api": {"SwingWorker": [[16, 26]]}}}, {"text": "While doing some coding on threads I came across this reference from JavaDoc for SwingWorker as a solution for threadsafety when working with swing objects", "label": {"api": {"SwingWorker": [[81, 91]], "reference from JavaDoc for SwingWorker as a solution for threadsafety when working with swing objects": [[54, 154]]}}}, {"text": "I want to know if SwingWorker can be a substitute for threads in all aspect in Java, like how BackgroundWorker is used in C#", "label": {"api": {"SwingWorker": [[18, 28]]}}}]