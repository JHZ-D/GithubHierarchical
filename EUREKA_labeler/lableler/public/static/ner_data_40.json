[{"text": "Stream has a function called anyMatch that can clean up your filter a bit", "label": {"api": {"anyMatch": [[29, 36]]}}}, {"text": "This can also be done with Map.computeIfAbsent() if the above is too wordy for your tastes", "label": {"api": {"Map.computeIfAbsent()": [[27, 47]]}}}, {"text": "Map::compute is probably what you're looking for", "label": {"api": {"Map::compute": [[0, 11]]}}}, {"text": "You can use Map#merge like this", "label": {"api": {"Map#merge": [[12, 20]]}}}, {"text": "But when looking at the TemporalAmount interface", "label": {"api": {"TemporalAmount": [[24, 37]]}}}, {"text": "it seems that instances of TemporalAmount aren't \"signed\"", "label": {"api": {"TemporalAmount": [[27, 40]]}}}, {"text": "simply by looking at concrete implementations of that interface, namely Duration", "label": {"api": {"Duration": [[72, 79]]}}}, {"text": "That class actually offers negated() to well, negate a Duration instance", "label": {"api": {"Duration": [[55, 62]], "negated()": [[27, 35]]}}}, {"text": "Therefore the above implementation already works, when passing a negative Duration", "label": {"api": {"Duration": [[74, 81]]}}}, {"text": "ArrayList inherits sort from List", "label": {"api": {"sort": [[19, 22]]}}}, {"text": "It expects a Comparator that can compare list entries via its compare method", "label": {"api": {"compare": [[33, 39], [62, 68]]}}}, {"text": "The JavaDoc for compare says", "label": {"api": {"compare": [[16, 22]]}}}, {"text": "sort calls the comparator's compare repeatedly with pairs of values, and uses those return values to sort the list", "label": {"api": {"sort": [[0, 3], [101, 104]], "compare": [[28, 34]]}}}, {"text": "A good example can be found in JMS Connection#setExceptionListener(), (ref.link), which offers notification hook in the ExceptionListener", "label": {"api": {"link": [[75, 78]]}}}, {"text": "The closest example I've found so far is described in this PostgreSQL documentation (ref.link), which uses asynchronous thread(s) to test/poll JDBC connection", "label": {"api": {"link": [[89, 92]]}}}, {"text": "The regular way to define a custom ordering in Java is via a Comparator instance", "label": {"api": {"Comparator": [[61, 70]]}}}, {"text": "This object can be plugged into the sorting routines of eg Arrays or Collections", "label": {"api": {"Arrays": [[59, 64]], "Collections": [[69, 79]]}}}, {"text": "I would just convert the OffsetDateTime to an Instant and then use toEpochMilli", "label": {"api": {"toEpochMilli": [[67, 78]]}}}, {"text": "You should use java.time types instead of Date and Calendar, which are considered legacy types since Java 8", "label": {"api": {"java.time": [[15, 23]], "Date": [[42, 45]], "Calendar": [[51, 58]]}}}, {"text": "The only change I would make to your second solution is to replace the boolean[] with a BitSet, which is similar to a boolean[] but more space-efficient as it uses just one bit per element", "label": {"api": {"BitSet": [[88, 93]]}}}, {"text": "For example, using ListIterator", "label": {"api": {"ListIterator": [[19, 30]]}}}, {"text": "Secondly, you can change the TableModel of the second JTable, by using setModel() method passing a DefaultTableModel", "label": {"api": {"DefaultTableModel": [[99, 115]]}}}, {"text": "The exception is thrown in DefaultHttpClient class in a method named channelRead0", "label": {"api": {"HttpClient": [[34, 43]]}}}, {"text": "If you don't like it, you can always use good old built-in HttpURLConnection, a new HttpClient from Java 9 or something 3rd party like OkHttp", "label": {"api": {"HttpURLConnection": [[59, 75]], "HttpClient": [[84, 93]]}}}, {"text": "The read() method has returned a Java char value, which is an unsigned 2-byte binary number (0-65535)", "label": {"api": {"read()": [[4, 9]]}}}, {"text": "I think the issue is that the underlying javax.servlet.http.Cookie does not support the SameSite attribute, let alone the new None value", "label": {"api": {"javax.servlet.http.Cookie": [[41, 65]]}}}, {"text": "Instead you can set this directly as a header, assuming your response is an instance of javax.servlet.http.HttpServletResponse", "label": {"api": {"javax.servlet.http.HttpServletResponse": [[88, 125]]}}}, {"text": "When trying to inject a class which is in the java.lang namespace via java.lang.instrument.Instrumentation#appendToBootstrapClassLoaderSearch  on a OpenJDK 11, nothing happens and no error is thrown", "label": {"api": {"java.lang.instrument.Instrumentation#appendToBootstrapClassLoaderSearch ": [[70, 141]]}}}, {"text": "Since you're referring to a IntBuffer, then", "label": {"api": {"IntBuffer": [[28, 36]]}}}, {"text": "The javadoc of get() says", "label": {"api": {"get()": [[15, 19]]}}}, {"text": "If the if statement is true, then rewind() is called, and javadoc says", "label": {"api": {"rewind()": [[34, 41]]}}}, {"text": "You can use a loop, or a Java utility class Arrays.copyOf or System.arraycopy", "label": {"api": {"Arrays.copyOf": [[44, 56]], "System.arraycopy": [[61, 76]]}}}, {"text": "java.nio.file.Paths was introduced in Java 7", "label": {"api": {"java.nio.file.Paths": [[0, 18]]}}}, {"text": "Use String.split with a limit", "label": {"api": {"String.split with a limit": [[4, 28]]}}}, {"text": "The Class class itself provides the a method called getInterfaces() which according to the JavaDoc", "label": {"api": {"getInterfaces()": [[52, 66]]}}}, {"text": "the javadoc of interrupt()", "label": {"api": {"interrupt()": [[15, 25]]}}}, {"text": "and sleep(long millis)", "label": {"api": {"sleep(long millis)": [[4, 21]]}}}, {"text": "Added prefix My to avoid confusion with built-in class named Class", "label": {"api": {"Class": [[61, 65]]}}}, {"text": "Otherwise, take a look at Map.merge() or the corresponding Collectors.toMap() overload", "label": {"api": {"Map.merge()": [[26, 36]], "Collectors.toMap()": [[59, 76]]}}}, {"text": "You will probably be much better off initializing an InputMismatchException with a message, and using its getMessage method to extract the relevant information in the catch statement", "label": {"api": {"with a message": [[76, 89]], "getMessage": [[106, 115]]}}}, {"text": "The easiest way would be to stream the List and use Collectors#groupingBy and Collectors#mapping", "label": {"api": {"Collectors#groupingBy": [[52, 72]], "Collectors#mapping": [[78, 95]]}}}, {"text": "It happens because you initialize an instance level variable as an instance of the class where it is defined itself which results in the endless recursion and the JVM throws the StackOverflowError", "label": {"api": {"StackOverflowError": [[178, 195]]}}}, {"text": "am not sure if it fits the bill, java.net.InetAddress uses dns resolution (domain to ip translation) cache", "label": {"api": {"java.net.InetAddress": [[33, 52]]}}}, {"text": "The tf you see referenced above is just a variable I use to refer to the CellDataFeatures object in Java which we can use to get a reference to that row's data model object (using the getValue() method)", "label": {"api": {"CellDataFeatures": [[73, 88]]}}}, {"text": "However, you can obtain a localized DateTimeFormatter pattern, and strip the year from that", "label": {"api": {"DateTimeFormatter": [[36, 52]]}}}, {"text": "From List docs", "label": {"api": {"List": [[5, 8]]}}}, {"text": "java.net.http first appeared in Java 11 and you are trying to compile your code for Java 8 (sourceCompatibility = 1.8)", "label": {"api": {"appeared in Java 11": [[20, 38]]}}}, {"text": "According to the documentation ReentrantLock.getOwner() is protected", "label": {"api": {"According to the documentation": [[0, 29]]}}}, {"text": "In this case the size of the list is exceeded so IndexOutOfBoundsException is thrown", "label": {"api": {"IndexOutOfBoundsException": [[49, 73]]}}}, {"text": "You may build such pattern using DateTimeFormatterBuilder", "label": {"api": {"DateTimeFormatterBuilder": [[33, 56]]}}}, {"text": "to then use System.arraycopy to copy all bytes from b to that new array, at the position you want them to show up", "label": {"api": {"System.arraycopy": [[12, 27]]}}}, {"text": "Set the positive prefix and negative prefix of the DecimalFormat", "label": {"api": {"DecimalFormat": [[51, 63]]}}}, {"text": "You can do this in your format string for DecimalFormat", "label": {"api": {"DecimalFormat": [[42, 54]]}}}, {"text": "Have you tried using ImageIcon.getIconHeight and ImageIcon.getIconWidth", "label": {"api": {"getIconHeight": [[31, 43]], "getIconWidth": [[59, 70]]}}}, {"text": "Additionally, if you have a fixed-size view, you might consider using ImageIcon.getImage followed by Image.getScaledInstance", "label": {"api": {"getImage": [[80, 87]], "getScaledInstance": [[107, 123]]}}}, {"text": "Since you already have an ImageIcon instance, you can simply use its getIconHeight() and getIconWidth() methods to get these values", "label": {"api": {"ImageIcon": [[26, 34]], "getIconHeight()": [[69, 83]], "getIconWidth()": [[89, 102]]}}}, {"text": "I would use CharSequence::codePoints to get an IntStream of the code points and map them to strings, and then collect them, concatenating to a single string", "label": {"api": {"CharSequence::codePoints": [[12, 35]]}}}, {"text": "Assuming you have Java 8 or later, use the Base64 class to decode into a byte[]", "label": {"api": {"Base64": [[43, 48]]}}}, {"text": "You can use anyMatch on the inner stream", "label": {"api": {"anyMatch": [[12, 19]]}}}, {"text": "Thus it can't be mapped to ArrayList<BaseContact>", "label": {"api": {"ArrayList<BaseContact>": [[27, 48]]}}}, {"text": "You may want to trim the word in the first place, so you no longer have spaces before the first character and after the last one, and then you could start splitting", "label": {"api": {"trim": [[16, 19]]}}}, {"text": "Because it is java.lang.String", "label": {"api": {"java.lang.String": [[14, 29]]}}}, {"text": "There is no String in java.util", "label": {"api": {"java.util": [[22, 30]]}}}, {"text": "For an immutable vector class, however, you need to clone the vector", "label": {"api": {"clone": [[52, 56]]}}}, {"text": "You invoked startCustomThread method twice so you have started 2 Threads", "label": {"api": {"Thread": [[23, 28], [65, 70]]}}}, {"text": "From Thread docs", "label": {"api": {"Thread": [[5, 10]]}}}, {"text": "According to the web, the value of KeyEvent.VK_DOWN matches the Win32 definition (40)", "label": {"api": {"KeyEvent.VK_DOWN": [[35, 50]]}}}, {"text": "In the code you linked to from your question, your LinkedList class is not generic", "label": {"api": {"class": [[62, 66]]}}}, {"text": "However, since your LinkedList class contains only Nodes, you should rather just make your Node class generic", "label": {"api": {"class": [[31, 35], [96, 100]]}}}, {"text": "By the way, I suggest renaming your LinkedList class since there is already such a class in the standard java library of classes", "label": {"api": {"class": [[47, 51], [83, 87], [121, 125]]}}}, {"text": "You won't need to sort after doing this, because IntStream.rangeClosed promises that all the elements from the IntStream will be provided in sorted order", "label": {"api": {"IntStream.rangeClosed": [[49, 69]]}}}, {"text": "Instead, use SwingUtilities.invokeLater, like so", "label": {"api": {"SwingUtilities.invokeLater": [[13, 38]]}}}, {"text": "Using File#listFiles can give you a list of files (in form of an array) in a directory", "label": {"api": {"File#listFiles": [[6, 19]]}}}, {"text": "You can wrap it in a Number class", "label": {"api": {"Number": [[21, 26]]}}}, {"text": "The javadoc of Instrumentation.redefineClasses does not tell whether it support concurrency or not", "label": {"api": {"Instrumentation.redefineClasses": [[15, 45]]}}}, {"text": "Since the NullPointerException is wrapped in an InvocationTargetException, the actual source has to lie somewhere in the constructor that is called, according to Oracle Docs", "label": {"api": {"Oracle Docs": [[162, 172]]}}}, {"text": "Thread B could try to acquire the lock by Lock.tryLock", "label": {"api": {"Lock.tryLock": [[42, 53]]}}}, {"text": "Looking at the API docs for BytesMessage might reveal a possible way to do that", "label": {"api": {"BytesMessage": [[28, 39]]}}}, {"text": "That method has nothing to do with the Process;  it is the inherited Object.wait method, which is used for cooperation between multiple threads", "label": {"api": {"Object.wait": [[69, 79]]}}}, {"text": "It still works, since the Collection returned by values is backed by the map", "label": {"api": {"backed by the map": [[59, 75]]}}}, {"text": "Simply use Stream::noneMatch for your nested Stream", "label": {"api": {"Stream::noneMatch": [[11, 27]]}}}, {"text": "You can iterate through this since it represents a set", "label": {"api": {"set": [[51, 53]]}}}, {"text": "The set is iterable", "label": {"api": {"set": [[4, 6]], "iterable": [[11, 18]]}}}, {"text": "For Java, this probably means \"Can you open the channel with an AudioFormat that includes 4 channels\"", "label": {"api": {"AudioFormat": [[64, 74]]}}}, {"text": "file string, and a Set<String> of discarded user IDs and then use removeAll function to remove all discarded users", "label": {"api": {"removeAll": [[66, 74]]}}}, {"text": "For the TimeZone API - https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String), where can I find the list of IDs which can be used as parameter here", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String)": [[23, 117]]}}}, {"text": "On the other hand, if you don't have a sorted list, just use Collection.removeAll, which has a time complexity of O(M*N) in this case", "label": {"api": {"Collection.removeAll": [[61, 80]]}}}, {"text": "You can find an AbstractCollection.removeAll implementation here", "label": {"api": {"Collection.removeAll": [[24, 43]]}}}, {"text": "If I were you, I'd just use Stream#of for all Map#values, and then call Stream#flatMap and Stream#collect to transform it to a List", "label": {"api": {"Stream#of": [[28, 36]], "Map#values": [[46, 55]], "Stream#flatMap": [[72, 85]], "Stream#collect": [[91, 104]], "List": [[127, 130]]}}}, {"text": "Consider using a Set (for example HashSet) instead of List for picks as HashSet::contains is O(1)", "label": {"api": {"Set": [[17, 19], [38, 40], [76, 78]], "HashSet": [[34, 40], [72, 78]]}}}, {"text": "I use HttpServletRequest class in Java that has getCookies()", "label": {"api": {"HttpServletRequest": [[6, 23]], "getCookies()": [[48, 59]]}}}, {"text": "Is there a built in method to convert the output of getCookies() to string", "label": {"api": {"getCookies()": [[52, 63]]}}}, {"text": "You can combine multiple Comparator<T>s into a single Comparator<T> (with more complicated logic) using Comparator.thenComparing (and its primitive counterparts) to achieve what you want", "label": {"api": {"Comparator.thenComparing": [[104, 127]]}}}, {"text": "Oh, no, there is a handy IntSummaryStatistics#getAverage", "label": {"api": {"IntSummaryStatistics#getAverage": [[25, 55]]}}}, {"text": "An easier API without this limitation is offered by channel.getIterableHistory().takeAsync(amount) which returns a CompletableFuture and can be combined with thenAccept", "label": {"api": {"thenAccept": [[158, 167]]}}}, {"text": "Shut down the executor, then await for its termination, then finally close the logger", "label": {"api": {"Shut down the executor": [[0, 21]], "await for its termination": [[29, 53]]}}}, {"text": "You can set this with setRequestMethod", "label": {"api": {"setRequestMethod": [[22, 37]]}}}, {"text": "You can set them with setRequestProperty", "label": {"api": {"setRequestProperty": [[22, 39]]}}}, {"text": "This is done by setting the Content-Type header using the setRequestProperty method, just like the other headers", "label": {"api": {"setRequestProperty": [[58, 75]]}}}, {"text": "The URLEncoder class exists for this purpose", "label": {"api": {"URLEncoder class": [[4, 19]]}}}, {"text": "Note that if it is possible for different threads to modify the individual LockerControl instances, look into concurrency and/or Atomic Integer, Atomic Boolean classes", "label": {"api": {"Atomic Integer": [[129, 142]], "Atomic Boolean": [[145, 158]]}}}, {"text": "You can use ClassLoader.getResources() to find all resources of a given name, when they exist in multiple jar files", "label": {"api": {"ClassLoader.getResources()": [[12, 37]]}}}, {"text": "This is even promoted way to do it described in OpenJDK 13 docs)", "label": {"api": {"OpenJDK 13 docs": [[48, 62]]}}}, {"text": "I refer to ObjectStreamConstants.STREAM_MAGIC in the interface ObjectStreamConstants, which is defined in the JDK source like so", "label": {"api": {"ObjectStreamConstants.STREAM_MAGIC": [[11, 44]], "ObjectStreamConstants": [[11, 31], [63, 83]]}}}, {"text": "My best guess at the error, is that the jar file contains a ServiceLoader file in the META-INF/services/ folder, which lists the 2 classes in the error message", "label": {"api": {"ServiceLoader": [[60, 72]]}}}, {"text": "I'm looking for a class implementing HttpHandler and providing a WebSocket implementation", "label": {"api": {"HttpHandler": [[37, 47]]}}}, {"text": "Split your String by space, create a LinkedHashSet out of it - this will remove duplicates and preserve element order (since Set does not allow duplicate values and it uses Object::equals and Object::hashCode methods for it", "label": {"api": {"LinkedHashSet": [[37, 49]], "Set": [[47, 49], [125, 127]], "Object::equals": [[173, 186]], "Object::hashCode": [[192, 207]]}}}, {"text": "LinkedHashSet also preserves element adding order)", "label": {"api": {"LinkedHashSet": [[0, 12]], "Set": [[10, 12]]}}}, {"text": "You can use AtomicInteger as Integer wrapper", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "You can use an IntStream to solve this", "label": {"api": {"IntStream": [[15, 23]]}}}, {"text": "You create an IntStream from 0 to list.size() - 1 (IntStream.range() excludes the last value from the stream) and map each index to the value in your list", "label": {"api": {"IntStream": [[14, 22], [51, 59]], "IntStream.range()": [[51, 67]]}}}, {"text": "Use a NavigableMap interface (implemented by TreeMap, a red-black tree)", "label": {"api": {"NavigableMap": [[6, 17]], "TreeMap": [[45, 51]]}}}, {"text": "The methods of NavigableMap, like subMap(), are designed to work this way, and it's a good practice when you are working with intervals of any quantity, as it's easy to define a sequence of intervals without overlap or gaps", "label": {"api": {"NavigableMap": [[15, 26]], "subMap()": [[34, 41]]}}}, {"text": "Read the documentation of Platform.exit()", "label": {"api": {"Platform.exit()": [[26, 40]]}}}, {"text": "I am trying to import the Java Instrumentation library (java.lang.instrument) https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/Instrumentation.html in my Android Studio project but it is complaining that it isn't able to find it", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/Instrumentation.html": [[78, 160]]}}}, {"text": "Then it's just a question of calling Stream.anyMatch with that predicate", "label": {"api": {"Stream.anyMatch": [[37, 51]]}}}, {"text": "removeEldestEntry is called after put or putAll (source), when you put something for the first time the value of size() in removeEldestEntry is 1, which is larger than size which is 0", "label": {"api": {"source": [[49, 54]]}}}, {"text": "Better work with the frame content pane", "label": {"api": {"frame content pane": [[21, 38]]}}}, {"text": "In addition to the doFinal-call an update-call is performed in the encryptWithGCM-method", "label": {"api": {"doFinal": [[19, 25]], "update": [[35, 40]]}}}, {"text": "The update-call must either be removed or the result must be concatenated with the result of the doFinal-call (resulting in a double plaintext when decrypted)", "label": {"api": {"doFinal": [[97, 103]], "update": [[4, 9]]}}}, {"text": "In the doFinal-call of the decryptWithGCM-method encryptedText.getBytes() is used", "label": {"api": {"doFinal": [[7, 13]]}}}, {"text": "For details, see this Javadoc for details on that constructor", "label": {"api": {"this Javadoc": [[17, 28]]}}}, {"text": "Your current object is an instance of the Runnable interface (you should be able to check that by checking out the code where the class starts)", "label": {"api": {"Runnable interface": [[42, 59]]}}}, {"text": "That's because the code inside orElse() will be always evaluated", "label": {"api": {"orElse()": [[31, 38]]}}}, {"text": "In other words it will be executed even if you specify a non-empty Optional, so that's why the Exception will be thrown", "label": {"api": {"Optional": [[67, 74]]}}}, {"text": "If you check the orElse() section of Java Optional – orElse() vs orElseGet() article, you can see that in their example, where it says", "label": {"api": {"orElse()": [[17, 24], [53, 60]], "Optional": [[42, 49]]}}}, {"text": "We can easily infer that the parameter of orElse() is evaluated even when having a non-empty Optional", "label": {"api": {"orElse()": [[42, 49]], "Optional": [[93, 100]]}}}, {"text": "For example it offers a method destroy()", "label": {"api": {"destroy()": [[31, 39]]}}}, {"text": "You can use the ScriptEngine API to evaluate JS scripts", "label": {"api": {"ScriptEngine": [[16, 27]]}}}, {"text": "Source from the docs that explains ChronoUnit.DAYS is an estimation", "label": {"api": {"Source": [[0, 5]]}}}, {"text": "In addition to the other answers, you would likely be better off using an ArrayList if you're planning on adding integers to it dynamically", "label": {"api": {"ArrayList": [[74, 82]]}}}, {"text": "You can use one of the existing implementations like AbstractMap.SimpleEntry", "label": {"api": {"AbstractMap.SimpleEntry": [[53, 75]]}}}, {"text": "Specifically, java.util.Date is replaced by java.time.Instant", "label": {"api": {"java.time.Instant": [[44, 60]]}}}, {"text": "I'd say that the idiomatic approach for that case would be to throw an IllegalArgumentException, which is a built-in runtime exception", "label": {"api": {"IllegalArgumentException": [[71, 94]]}}}, {"text": "You can use eiter a TreeMap, which is sorted by natural ordering of its keys, or by a predefined comparator or a LinkedHashMap, which is sorted by insertion order", "label": {"api": {"TreeMap": [[20, 26]], "LinkedHashMap": [[113, 125]]}}}, {"text": "Using a TreeMap you need to change your code just a little bit to get correct result", "label": {"api": {"TreeMap": [[8, 14]]}}}, {"text": "Use the getValue() method of JFormattedTextField", "label": {"api": {"getValue()": [[8, 17]]}}}, {"text": "If you are assuming the image is grayscale, it’s probably easier to call getRGB and divide one of its components", "label": {"api": {"getRGB": [[73, 78]]}}}, {"text": "The API documentation of StandardOpenOption.CREATE_NEW says", "label": {"api": {"API documentation": [[4, 20]]}}}, {"text": "If you want to query the database using whereLessThanOrEqualTo() you can simply pass as the second argument a Date object", "label": {"api": {"Date": [[110, 113]]}}}, {"text": "From the java/lang/InterruptedException documentation its not clear to me if by standards it should be another thread that should interrupt or if its okay for a thread to throw this exception for itself", "label": {"api": {"java/lang/InterruptedException": [[9, 38]]}}}, {"text": "The Javadoc for InterruptedException states", "label": {"api": {"Javadoc for InterruptedException": [[4, 35]]}}}, {"text": "Being interrupted is a result of Thread.interrupt() being called on your running thread, which is not what's happening in the code you posted", "label": {"api": {"Thread.interrupt()": [[33, 50]]}}}, {"text": "Java has an attribute within their StringBuffer class called setLength that allows one to set a fixed length to a variable", "label": {"api": {"StringBuffer class called setLength": [[35, 69]]}}}, {"text": "Instead of java.lang.ProcessImpl use the abstract class (\"interface\") java.lang.Process", "label": {"api": {"java.lang.Process": [[11, 27], [70, 86]]}}}, {"text": "This is also documented", "label": {"api": {"documented": [[13, 22]]}}}, {"text": "String#trim method also removes \\t", "label": {"api": {"String#trim": [[0, 10]]}}}, {"text": "If performance matters for you or if you have a very large list I would recommend using a StringBuilder and Java Streams to collect all numbers", "label": {"api": {"StringBuilder": [[90, 102]]}}}, {"text": "To get the final result we can use StringBuilder.substring() to cut off the first white space", "label": {"api": {"StringBuilder": [[35, 47]], "StringBuilder.substring()": [[35, 59]]}}}, {"text": "To improve the performance on large lists you can also use List.parallelStream() or Stream.parallel() to create a parallel stream", "label": {"api": {"List.parallelStream()": [[59, 79]], "Stream.parallel()": [[84, 100]]}}}, {"text": "Just a guess, but a MessageProducer extends AutoClosable, suggesting it to be closed after it is no longer of use", "label": {"api": {"MessageProducer": [[20, 34]]}}}, {"text": "Since you've got a Map<String, String>, Map#getOrDefault could be an option", "label": {"api": {"Map#getOrDefault": [[40, 55]]}}}, {"text": "If I understand correctly, a simple call to ifPresent should work", "label": {"api": {"ifPresent": [[44, 52]]}}}, {"text": "It doesn't matter what you do with the optional (whether you cast it or not), because ifPresent accepts a \"function\" as its parameter", "label": {"api": {"ifPresent": [[86, 94]]}}}, {"text": "StringBuffer extends Object class directly and it does not override hashCode from Object class", "label": {"api": {"StringBuffer": [[0, 11]], "Object": [[21, 26], [82, 87]]}}}, {"text": "So the implementation of StringBuffer::hashCode is the same as for Object::hashCode", "label": {"api": {"StringBuffer": [[25, 36]], "Object": [[67, 72]], "Object::hashCode": [[67, 82]]}}}, {"text": "But just going deeper into data-structures in Java, I have found out that the LinkedList implementation has a getLast() method that is not implemented (I suppose for some reason) in the ArrayList implementation", "label": {"api": {"getLast()": [[110, 118]]}}}, {"text": "If you need to do something with every value in the ConcurrentHashMap, you have many choices", "label": {"api": {"ConcurrentHashMap": [[52, 68]]}}}, {"text": "Collections.unmodifiableMap returns a Map<K,V> so you would have to use it like this", "label": {"api": {"Collections.unmodifiableMap": [[0, 26]], "Map<K,V>": [[38, 45]]}}}, {"text": "because Collections.unmodifiableMap returns instance of private static UnmodifiableMap so you will get a ClassCastException", "label": {"api": {"Collections.unmodifiableMap": [[8, 34]]}}}, {"text": "And then use the object returned from Collections.unmodifiableMap as Map", "label": {"api": {"Collections.unmodifiableMap": [[38, 64]]}}}, {"text": "The easiest way to do this would be to extend AbstractMap, and delegate to an actual LinkedHashMap", "label": {"api": {"AbstractMap": [[46, 56]]}}}, {"text": "When you use a ExecutorService you need to call the ExecutorService.shutdown() after all tasks are submitted, then you need to wait for the pool to shut down by calling ExecutorService.awaitTermination() and supply the time to wait as parameters", "label": {"api": {"awaitTermination()": [[185, 202]]}}}, {"text": "In the finally section call shutdown() to initiate a orderly shut down of the threads in the pool and as the shutdown call is not blocking the awaitTermination() has to be called for the calling thread to wait for the shut down process to finish", "label": {"api": {"awaitTermination()": [[143, 160]]}}}, {"text": "For the desktop, the way to go is to generate the data, acquire a SourceDataLine, open and start the line and then write your data to it", "label": {"api": {"SourceDataLine": [[66, 79]]}}}, {"text": "It's important that the line is suitable for the AudioFormat you have chosen to generate", "label": {"api": {"AudioFormat": [[49, 59]]}}}, {"text": "The strings your code is producing are the string versions of the ArrayList<Character>, because you're using its toString", "label": {"api": {"toString": [[113, 120]]}}}, {"text": "Or use a StringBuilder instead of the ArrayList<Character>, or..", "label": {"api": {"StringBuilder": [[9, 21]]}}}, {"text": "Use Map::computeIfPresent instead", "label": {"api": {"Map::computeIfPresent": [[4, 24]]}}}, {"text": "It can be substituted by single usage of Map::merge", "label": {"api": {"Map::merge": [[41, 50]]}}}, {"text": "Is there a way to obtain the file attributes (specifically, the file key) of an already-open file channel", "label": {"api": {"file attributes": [[29, 43]], "file key": [[64, 71]]}}}, {"text": "If I know a path of the file, I can call Files.readAttributes(…), but this still has a race condition on systems where open files can be deleted or renamed", "label": {"api": {"Files.readAttributes(…)": [[41, 63]]}}}, {"text": "You can tell from the method documentation", "label": {"api": {"method documentation": [[22, 41]]}}}, {"text": "You can use MessageFormat like so", "label": {"api": {"MessageFormat": [[12, 24]]}}}, {"text": "There is no standard to represent NaN and INFINITY in neither the Graphql and also in JSON", "label": {"api": {"NaN": [[34, 36]], "INFINITY": [[42, 49]]}}}, {"text": "After that you can submit a specific task to a ExecutorService that handels the execution of the \"input reading\" seperately from the main Thread", "label": {"api": {"ExecutorService": [[47, 61]]}}}, {"text": "You will get a Future on which you can define a timeout", "label": {"api": {"Future": [[15, 20]]}}}, {"text": "Instead use PreparedStatement to avoid SQL njection attacks", "label": {"api": {"PreparedStatement": [[12, 28]]}}}, {"text": "Is there a place in the JDBC API to interrogate a JDBC driver as to the version of JDBC it supports", "label": {"api": {"JDBC API": [[24, 31]]}}}, {"text": "I found Driver::jdbcCompliant, but that is simply boolean, with no indication of with which version the driver is compliant", "label": {"api": {"Driver::jdbcCompliant": [[8, 28]]}}}, {"text": "I found Driver::getMajorVersion & getMinorVersion", "label": {"api": {"Driver::getMajorVersion": [[8, 30]]}}}, {"text": "If you want to avoid boxing values to Integer and you want to get primitive integer directly use IntStream::concat and and IntStream::of", "label": {"api": {"IntStream::concat": [[97, 113]], "IntStream::of": [[123, 135]]}}}, {"text": "Have a look in the documentation of FXMLLoader", "label": {"api": {"FXMLLoader": [[36, 45]]}}}, {"text": "You can load a FXML-File using the load(InputStream) Method", "label": {"api": {"load(InputStream) Method": [[35, 58]]}}}, {"text": "Both noneMatch and anyMatch are short-circuiting stream operations", "label": {"api": {"noneMatch": [[5, 13]], "anyMatch": [[19, 26]]}}}, {"text": "The only difference is that noneMatch will return false on a match and anyMatch will return true", "label": {"api": {"noneMatch": [[28, 36]], "anyMatch": [[71, 78]]}}}, {"text": "Your negating the result from anyMatch makes the two expressions logically equivalent", "label": {"api": {"anyMatch": [[30, 37]]}}}, {"text": "NumberFormat.format() (see this) returns a String, not an int/long/double/or similar", "label": {"api": {"see this": [[23, 30]]}}}, {"text": "Arrays.hashCode(double[]) is specified to return the equivalent value of a List containing Double values representing the same numeric value", "label": {"api": {"Arrays.hashCode(double[])": [[0, 24]]}}}, {"text": "List.hashCode in turn is specified with a fairly simple algorithm", "label": {"api": {"List.hashCode": [[0, 12]]}}}, {"text": "You can use Streams", "label": {"api": {"Stream": [[12, 17]]}}}, {"text": "This will result in the List", "label": {"api": {"List": [[24, 27]]}}}, {"text": "You can take an input Set having the keys to query for and use stream operations Stream#filter and Stream#map to filter and map the results and finally collect the values into a list", "label": {"api": {"Set": [[22, 24]], "Stream#filter": [[81, 93]], "Stream#map": [[99, 108]]}}}, {"text": "As another example, take Java's OutputStream", "label": {"api": {"OutputStream": [[32, 43]]}}}, {"text": "In your program you can write to an OutputStream that the caller passes in", "label": {"api": {"OutputStream": [[36, 47]]}}}, {"text": "send it over the network or save it to a file or pipe it into another program", "label": {"api": {"file": [[41, 44]], "pipe": [[49, 52]]}}}, {"text": "Zip it or encrypt it before doing so", "label": {"api": {"Zip": [[0, 2]], "encrypt": [[10, 16]]}}}, {"text": "The caller can do that by passing you a different OutputStream, and your code does not need to change to handle network I/O, compression, or encryption", "label": {"api": {"OutputStream": [[50, 61]], "encrypt": [[141, 147]]}}}, {"text": "Tests can pass a ByteArrayOutputStream to capture your program's output", "label": {"api": {"OutputStream": [[26, 37]], "ByteArrayOutputStream": [[17, 37]]}}}, {"text": "However, you could try to use https://docs.oracle.com/javase/8/docs/api/java/lang/management/ThreadMXBean.html to find the CPU usage of all threads and filter those out that are not interesting to you (maybe by package name)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/lang/management/ThreadMXBean.html": [[30, 109]]}}}, {"text": "Why does computeIfAbsent work", "label": {"api": {"computeIfAbsent": [[9, 23]]}}}, {"text": "When you call computeIfAbsent, you pass the following parameters", "label": {"api": {"computeIfAbsent": [[14, 28]]}}}, {"text": "You create a new ArrayList and immediately call add", "label": {"api": {"add": [[48, 50]]}}}, {"text": "If you are interested in creating a new list of elements on the spot, you can use Arrays.asList", "label": {"api": {"Arrays.asList": [[82, 94]]}}}, {"text": "Note that this creates a fixed sized ArrayList (you can't add elements to this list)", "label": {"api": {"add": [[58, 60]]}}}, {"text": "You can add a blocking method call or use a CountDownLatch to wait for the cache to be populated", "label": {"api": {"CountDownLatch": [[44, 57]]}}}, {"text": "Alternatively, if you're asynchronously populating the cache, you can use a CountDownLatch", "label": {"api": {"CountDownLatch": [[76, 89]]}}}, {"text": "The only guarantee given in the Javadoc for System.nanoTime() is that the resolution of the clock is at least as good as System.currentTimeMillis() - so if you are writing cross-platform code, there is clearly no expectation that the results of nanoTime are unique, as you can call nanoTime() many times per millisecond", "label": {"api": {"the Javadoc for System.nanoTime()": [[28, 60]]}}}, {"text": "I recommend always passing the optional ZoneId (or ZoneOffset) to the various date-time methods", "label": {"api": {"ZoneId": [[40, 45]], "ZoneOffset": [[51, 60]]}}}, {"text": "Define a functional interface", "label": {"api": {"a functional interface": [[7, 28]]}}}, {"text": "If you reduced the number of parameters to 2, we could go with BiFunction", "label": {"api": {"BiFunction": [[63, 72]], "Function": [[65, 72]]}}}, {"text": "If there were one parameter, Function would come in handy", "label": {"api": {"Function": [[29, 36]]}}}, {"text": "A possible solution is to use Stream to convert your String in a Set of char, then if the size of the set is the same as the length of your string, it is unique", "label": {"api": {"Stream": [[30, 35]], "String": [[53, 58]], "Set": [[65, 67]]}}}, {"text": "Class Date has methods compareTo(), after() and before() that allow you to compare 2 Dates", "label": {"api": {"compareTo()": [[23, 33]], "after()": [[36, 42]], "before()": [[48, 55]]}}}, {"text": "Also Date has method getTime() that returns you the number of milliseconds since January 1, 1970, 00:00:00 GMT represented by this date", "label": {"api": {"getTime()": [[21, 29]]}}}, {"text": "But again, The best option is to switch to java.time package and classes Instant and ZonedDateTime (and others) have methods compareTo(), isAfter() and isBefore()", "label": {"api": {"compareTo()": [[125, 135]], "Instant": [[73, 79]], "ZonedDateTime": [[85, 97]]}}}, {"text": "If you don't pass anything in for this parameter, it defaults to \" \\t\\n\\r\\f\", which is basically just whitespace", "label": {"api": {"defaults to": [[53, 63]]}}}, {"text": "The only method that allows me to get the details of the return type is ExecutableElement.getReturnType()", "label": {"api": {"ExecutableElement.getReturnType()": [[72, 104]]}}}, {"text": "It gives me back a TypeMirror", "label": {"api": {"TypeMirror": [[19, 28]]}}}, {"text": "I could not find anything that allows me to check if TypeMirror returned is a subtype of Collection", "label": {"api": {"TypeMirror": [[53, 62]], "Collection": [[89, 98]]}}}, {"text": "I am trying to generate the source code to call one of the methods in Collection", "label": {"api": {"Collection": [[70, 79]]}}}, {"text": "You can use the Math.pow() method to get the square of a value", "label": {"api": {"Math.pow()": [[16, 25]]}}}, {"text": "Check Math.pow() for more details", "label": {"api": {"Math.pow()": [[6, 15]]}}}, {"text": "Javadoc for ConcurrentLinkedQueue explicitly states that the complexity of the size() method is O(n)", "label": {"api": {"Javadoc for ConcurrentLinkedQueue": [[0, 32]]}}}, {"text": "From Object::wait docs", "label": {"api": {"Object::wait": [[5, 16]]}}}, {"text": "It might not be documented as thread-safe and it's not specified that it should be thread-safe, but any sane implementation is thread-safe", "label": {"api": {"it's not specified that it should be thread-safe": [[46, 93]]}}}, {"text": "Open your file as a RandomAccessFile", "label": {"api": {"RandomAccessFile": [[20, 35]]}}}, {"text": "I would suggest you use Timeline instead of Thread", "label": {"api": {"Timeline": [[24, 31]], "Thread": [[44, 49]]}}}, {"text": "It can be done using a Thread, but Timeline is designed for cases like this", "label": {"api": {"Timeline": [[35, 42]], "Thread": [[23, 28]]}}}, {"text": "Alternatively, if you want to use Files.probeContentType(…) but do not want to rely upon the provided default implementation, you can create your own FileTypeDetector", "label": {"api": {"Files.probeContentType(…)": [[34, 58]], "FileTypeDetector": [[150, 165]]}}}, {"text": "You will also need to create a file that ServiceLoader can find because that is how it discovers implementations of FileTypeDetector", "label": {"api": {"FileTypeDetector": [[116, 131]], "ServiceLoader": [[41, 53]]}}}, {"text": "You can make use of String's indexOf() to find the index of \"TERM\" and substring() to extract the String containing the integer value", "label": {"api": {"String's indexOf()": [[20, 37]], "substring()": [[71, 81]]}}}, {"text": "For the AutoClosable implementation running Reference#reachabilityFence​ from the close method after the handler is unregister would be a sane decision", "label": {"api": {"Reference#reachabilityFence": [[44, 70]]}}}, {"text": "As an alternative you could simply use String::split method and then make a Stream out of returned array", "label": {"api": {"String::split": [[39, 51]]}}}, {"text": "According to your scenario you can use collections like  class like ArrayList where dynamically you can insert or remove elements", "label": {"api": {"ArrayList": [[68, 76]]}}}, {"text": "Every element of the ArrayList represents one of your rows (initially empty) where you can add or remove your elements", "label": {"api": {"ArrayList": [[21, 29]]}}}, {"text": "It is possible using Java Stream and Stream::flatMap", "label": {"api": {"Stream::flatMap": [[37, 51]]}}}, {"text": "To begin with, this code is bad, since priorityQueue.remove(v) requires O(n) time, which defeats the whole purpose of using PriorityQueue https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html", "label": {"api": {"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html": [[138, 226]]}}}, {"text": "Because Sedan is package-private, you need to call myConstructor.setAccessible​(true)", "label": {"api": {"myConstructor.setAccessible​(true)": [[51, 84]]}}}, {"text": "If you want to keep the array that you created using new char[10]; you will have to use System.arraycopy() for example", "label": {"api": {"System.arraycopy()": [[88, 105]]}}}, {"text": "Judging from what you've shown, Stream#anyMatch might a good candidate", "label": {"api": {"Stream#anyMatch": [[32, 46]]}}}, {"text": "If you're running in a semi-standard JAX-RS environment you can trigger this internally with a ContainerResponseFilter", "label": {"api": {"ContainerResponseFilter": [[95, 117]]}}}, {"text": "But you also have the option of using the index-based version of getXyz", "label": {"api": {"index-based version of getXyz": [[42, 70]]}}}, {"text": "ProcessBuilder#directory(File) sets the working directory for the process", "label": {"api": {"ProcessBuilder#directory(File)": [[0, 29]]}}}, {"text": "Since this code calls t1.wait without holding the lock on t1 object - the IllegalMonitorStateException will be thrown - as is documented in Object::wait(time) method", "label": {"api": {"Object::wait(time)": [[140, 157]]}}}, {"text": "You could use OffsetDateTime for mapping  both firstDate and secondDate properties", "label": {"api": {"OffsetDateTime": [[14, 27]]}}}, {"text": "The deserialization will fail when the input doesn't match the DateTimeFormatter.ISO_OFFSET_DATE_TIME pattern", "label": {"api": {"DateTimeFormatter.ISO_OFFSET_DATE_TIME": [[63, 100]]}}}, {"text": "The value of System.in, which is an instance of InputStream, is the \"standard input\"", "label": {"api": {"System.in": [[13, 21]]}}}, {"text": "When you use new Scanner(System.in) you are using the Scanner#<init>(InputStream) constructor, whose documentation says", "label": {"api": {"System.in": [[25, 33]], "Scanner#<init>(InputStream)": [[54, 80]]}}}, {"text": "As you can see, passing System.in simply configures the Scanner to read from the standard input", "label": {"api": {"System.in": [[24, 32]]}}}, {"text": "As you can see, we just pass a Supplier to retrieveValue and call it in a try-catch block where we catch the possible NullPointerException and return an Optional.empty() in that case", "label": {"api": {"Supplier": [[31, 38]]}}}, {"text": "The correct way to implement a plugin architecture is with the ServiceLoader class", "label": {"api": {"ServiceLoader": [[63, 75]]}}}, {"text": "However, you can use java.util.concurrent.TimeUnit api to easily convert from nanoseconds to milliseconds", "label": {"api": {"java.util.concurrent.TimeUnit": [[21, 49]]}}}, {"text": "Build a string using StringBuilder and trim() it when done", "label": {"api": {"StringBuilder": [[21, 33]], "trim()": [[39, 44]]}}}, {"text": "Build a string using Java 8's StringJoiner", "label": {"api": {"StringJoiner": [[30, 41]]}}}, {"text": "exec splits into tokens based on whitespace", "label": {"api": {"splits into tokens based on whitespace": [[5, 42]]}}}, {"text": "Javadoc on Executors.newSingleThreadExecutor", "label": {"api": {"Executors.newSingleThreadExecutor": [[11, 43]]}}}, {"text": "By exposing a Principal instance (such as an instance of GenericPrincipal from Apache Tomcat) in your web API, you may ended up leaking some sensitive details you don't intent to", "label": {"api": {"Principal": [[14, 22], [64, 72]]}}}, {"text": "If you create an instance of GenericPrincipal and then attempt to serialize it to JSON using ObjectMapper directly, you'll see it won't succeed", "label": {"api": {"Principal": [[36, 44]]}}}, {"text": "If you check the GenericPrincipal source code, you'll see a userPrincipal field", "label": {"api": {"Principal": [[24, 32], [64, 72]]}}}, {"text": "This can also be inferred from the Servlet documentation", "label": {"api": {"Servlet documentation": [[35, 55]]}}}, {"text": "You need to call this PriorityQueue constructor, supplying your own Comparator", "label": {"api": {"this PriorityQueue constructor": [[17, 46]]}}}, {"text": "I think you're looking for NumberFormat", "label": {"api": {"NumberFormat": [[27, 38]]}}}, {"text": "Either use an array and set the 0th index or if you need to go ahead with a List for some reason, then consider using List.set instead, as stated in the comments above", "label": {"api": {"List.set": [[118, 125]]}}}, {"text": "You should call ListIterator::next in your loop", "label": {"api": {"ListIterator::next": [[16, 33]]}}}, {"text": "From ListIterator::next docs", "label": {"api": {"ListIterator::next": [[5, 22]]}}}, {"text": "Also, im using a BlockingLinkedQueue, maybe you should use a PriorityQueue, it will automatically order your items in the Queue", "label": {"api": {"PriorityQueue": [[61, 73]]}}}, {"text": "There are lots of useful methods in the Comparator interface to help you compare things", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "You only need to create a Comparator", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "Further, CompletableFuture marks its completion tasks with AsynchronousCompletionTask to help monitoring and debugging and its useful to follow the convention", "label": {"api": {"AsynchronousCompletionTask": [[59, 84]]}}}, {"text": "In Java you use a ServerSocket for TCP sockets", "label": {"api": {"ServerSocket": [[18, 29]]}}}, {"text": "You cannot use a ServerSocket for the WebSocket protocol, at least not so straight forward as you might think", "label": {"api": {"ServerSocket": [[17, 28]]}}}, {"text": "In the Java world you can use web servers like Tomcat or Jetty which provide WebSocket implementations and a high level Java API", "label": {"api": {"high level Java API": [[109, 127]]}}}, {"text": "decimal parts is controlled by the Locale in use", "label": {"api": {"Locale": [[35, 40]]}}}, {"text": "An example is Locale.US", "label": {"api": {"Locale": [[14, 19]]}}}, {"text": "You simply need to use thenCombine()", "label": {"api": {"thenCombine()": [[23, 35]]}}}, {"text": "Consider the documentation of TransferHandler.exportDone", "label": {"api": {"documentation of TransferHandler.exportDone": [[13, 55]]}}}, {"text": "If you're okay with ISO 4217 Currency Codes, java has a Currency class (https://docs.oracle.com/javase/7/docs/api/java/util/Currency.html) where you can get all currency codes as a set", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Currency.html": [[72, 136]]}}}, {"text": "The Object.wait() function keeps waiting, even though the other thread already called Object.notifyAll()", "label": {"api": {"notifyAll()": [[93, 103]], "wait": [[11, 14], [33, 36]]}}}, {"text": "Javadoc of notifyAll() says", "label": {"api": {"notifyAll()": [[11, 21]]}}}, {"text": "Wakes up all threads that are waiting on this object's monitor", "label": {"api": {"wait": [[30, 33]]}}}, {"text": "A thread waits on an object's monitor by calling one of the wait methods", "label": {"api": {"wait": [[9, 12], [60, 63]]}}}, {"text": "Only threads current waiting are woken up", "label": {"api": {"wait": [[21, 24]]}}}, {"text": "No flag is set or anything, so threads that start waiting after the call to notifyAll will not see the call, and will have to wait until the next call to notifyAll", "label": {"api": {"wait": [[50, 53], [126, 129]]}}}, {"text": "Use BigDecimal instead", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "As it states in the documentation", "label": {"api": {"in the documentation": [[13, 32]]}}}, {"text": "I suggest using String.format(format, ...args) to do the heavy lifting unless explicitly disallowed", "label": {"api": {"String.format(format, ...args)": [[16, 45]]}}}, {"text": "If you need arguments or a return value, you can use a different functional interface", "label": {"api": {"functional interface": [[65, 84]]}}}, {"text": "That said, this approach can be simplified by using a Map to count the number of times each word appears", "label": {"api": {"Map": [[54, 56]]}}}, {"text": "The Java class Double contains a static method that will do what you're looking for", "label": {"api": {"Double": [[15, 20]]}}}, {"text": "The exception doesn't occur if an (additional) init is executed immediately before the doPhase", "label": {"api": {"init": [[47, 50]], "doPhase": [[87, 93]]}}}, {"text": "However, this init-call shouldn't be necessary, since after the doPhase-call generateSecret is executed, which should reset the KeyAgreement-instance to the state after the init-call, at least according to the generateSecret-documentation", "label": {"api": {"init": [[14, 17], [173, 176]], "doPhase": [[64, 70]], "generateSecret": [[77, 90], [210, 223]]}}}, {"text": "This method resets this KeyAgreement object to the state that it was in after the most recent call to one of the init methods..", "label": {"api": {"init": [[113, 116]]}}}, {"text": "repeated doPhase-calls are possible (without additional init-calls)", "label": {"api": {"init": [[56, 59]], "doPhase": [[9, 15]]}}}, {"text": "The second parameter (lastPhase) in doPhase should be set to true, otherwise an IllegalStateException (Only two party agreement supported, lastPhase must be true) is generated (at least for ECDH)", "label": {"api": {"doPhase": [[36, 42]], "lastPhase": [[22, 30], [139, 147]]}}}, {"text": "KeyAgreement#generateSecret is not reset for ECDH based algorithmm", "label": {"api": {"generateSecret": [[13, 26]]}}}, {"text": "You can use AtomicLong#incrementAndGet as a counter", "label": {"api": {"AtomicLong#incrementAndGet": [[12, 37]]}}}, {"text": "Take a look at java.util.Objects", "label": {"api": {"java.util.Objects": [[15, 31]]}}}, {"text": "Be careful not to use String methods that work on regexs, especially since the name of the methods aren't very informative (replace replaces all occurences of a fixed string, replaceAll replaces all occurences that match a regex pattern)", "label": {"api": {"replace": [[124, 130], [132, 138], [175, 181], [186, 192]], "replaceAll": [[175, 184]]}}}, {"text": "InetAddress.getByAddress(...) throws a UnknownHostException  which is a checked exception because it is a subclass of Exception", "label": {"api": {"UnknownHostException": [[39, 58]], "Exception": [[50, 58], [118, 126]]}}}, {"text": "As the behaviour you've mentioned above is compliant with the JavaDoc documentation of ExecutorService, no subclass (at least the ones coming with the Java Standard Edition) will behave differently", "label": {"api": {"JavaDoc documentation of ExecutorService": [[62, 101]]}}}, {"text": "I think you can solve the problem with CompletableFuture", "label": {"api": {"CompletableFuture": [[39, 55]]}}}, {"text": "The main idea here is to use CompletableFuture.anyOf and apply it to CompletableFuture of your useful task and CopmpletableFuture of timeout task", "label": {"api": {"CompletableFuture": [[29, 45], [69, 85]]}}}, {"text": "Timeout is achieved by using ScheduledExecutorService and CompletableFuture.completeExceptionally", "label": {"api": {"CompletableFuture": [[58, 74]]}}}, {"text": "You could use BigDecimal", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "All of them are in the Files class", "label": {"api": {"Files": [[23, 27]]}}}, {"text": "If you browse the \"Developer’s Guide for Java Clients\" linked from the Open MQ 4.5 Documentation page and inspect chapter 2 titled \"Using the Java API\" you'll see this in the \"Obtaining a Connection Factory\" section", "label": {"api": {"\"Using the Java API\"": [[131, 150]]}}}, {"text": "Further down in the document you'll find an example of how to look up a connection factory object in the JNDI object store", "label": {"api": {"an example of how to look up a connection factory object in the JNDI object store": [[41, 121]]}}}, {"text": "To generate text in other formats, see the DateTimeFormatter class", "label": {"api": {"DateTimeFormatter": [[43, 59]]}}}, {"text": "However, you can eliminate that error, and the possibility of most other errors, by using Files.copy instead of writing your own save code", "label": {"api": {"Files.copy": [[90, 99]]}}}, {"text": "EntityManager#remove takes an entity instance as parameter", "label": {"api": {"EntityManager#remove": [[0, 19]]}}}, {"text": "Use the Objects.toString method, which takes a ‘use if first argument is null’ argument", "label": {"api": {"Objects.toString": [[8, 23]]}}}, {"text": "if you're on JDK9+ I'd suggest looking into Objects.requireNonNullElse i.e.", "label": {"api": {"Objects.requireNonNullElse": [[44, 69]]}}}, {"text": "So the Pattern class for a full description of the syntax", "label": {"api": {"Pattern class": [[7, 19]]}}}, {"text": "Looking at Math class, the ulp method", "label": {"api": {"ulp method": [[27, 36]]}}}, {"text": "You're forgetting the call to Matcher.find", "label": {"api": {"Matcher.find": [[30, 41]]}}}, {"text": "Oracle's Java Docs have a very helpful definition of SimpleFileVisitor on https://docs.oracle.com/javase/7/docs/api/java/nio/file/SimpleFileVisitor.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/nio/file/SimpleFileVisitor.html": [[74, 151]]}}}, {"text": "A FileVisitor is an object whose callback methods are invoked as a method such as Files.walkFileTree traverses an entire hierarchy of files under a common root directory", "label": {"api": {"FileVisitor": [[2, 12]], "Files.walkFileTree": [[82, 99]]}}}, {"text": "As each file or directory in the tree is encountered, we say it is “visited.”  At that point, the FileVisitor argument that was passed to the walk method has one or more of its methods invoked, depending on the nature of each file", "label": {"api": {"FileVisitor": [[98, 108]]}}}, {"text": "The documentation of SimpleFileVisitor does in fact distinguish it from the FileVisitor interface", "label": {"api": {"FileVisitor": [[27, 37], [76, 86]], "documentation of SimpleFileVisitor": [[4, 37]]}}}, {"text": "A SimpleFileVisitor implements each method of FileVisitor", "label": {"api": {"FileVisitor": [[8, 18], [46, 56]]}}}, {"text": "The “simple” part means that a SimpleFileVisitor has no functionality of its own", "label": {"api": {"FileVisitor": [[37, 47]]}}}, {"text": "Instead of hand-crafted polling with an infinite loop and manual 2 minute sleep, look into scheduling, for example with Quartz or at least a ScheduledExecutorService, here's a Tomcat based example", "label": {"api": {"ScheduledExecutorService": [[141, 164]]}}}, {"text": "As each line seems to consist of comma separated values, you can just use split to get the individual values as array", "label": {"api": {"split": [[74, 78]]}}}, {"text": "Using streams (or alternatively a for-each loop) you can clean those values, e.g", "label": {"api": {"streams": [[6, 12]]}}}, {"text": "using strip to remove whitespaces and replaceAll to remove the brackets", "label": {"api": {"strip": [[6, 10]]}}}, {"text": "For converting the array back into a line, you could use join", "label": {"api": {"join": [[57, 60]]}}}, {"text": "You can collect the lines using a String or better a StringBuilder", "label": {"api": {"StringBuilder": [[53, 65]]}}}, {"text": "If you don't want the content on disk, you could alternatively implement your own in-memory URLStreamHandler, and specify it when creating the URL using the URL(String protocol, String host, int port, String file, URLStreamHandler handler) constructor", "label": {"api": {"URLStreamHandler": [[92, 107], [214, 229]], "URL(String protocol, String host, int port, String file, URLStreamHandler handler)": [[157, 238]]}}}, {"text": "The parameters are self-explanatory (see javadoc iterate) however", "label": {"api": {"iterate": [[49, 55]]}}}, {"text": "You can use AtomicInteger class", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "Further, according to System.nanoTime() documentation and Kevin Bourrillion's answer to another question I concluded that JMH, by default, measures time according to some arbitrary, but fixed, source (just like System.nanoTime())", "label": {"api": {"System.nanoTime() documentation": [[22, 52]]}}}, {"text": "String::copyValueOf internally returns new String", "label": {"api": {"String::copyValueOf": [[0, 18]]}}}, {"text": "The HttpRequest, HttpResponse, and HttpClient classes are from the java.net.http package", "label": {"api": {"java.net.http": [[67, 79]]}}}, {"text": "In my DTO I have some fields having Timestamp as a data type", "label": {"api": {"Time": [[36, 39]], "Timestamp": [[36, 44]]}}}, {"text": "Since Java 8, Date and their friends such as Time, Timestamp, Calendar and SimpleDateFormat are legacy classes", "label": {"api": {"Date": [[14, 17], [81, 84]], "Time": [[45, 48], [51, 54]], "Timestamp": [[51, 59]], "Calendar": [[62, 69]], "SimpleDateFormat": [[75, 90]]}}}, {"text": "In your situation, you could either use Instant or OffsetDateTime", "label": {"api": {"Date": [[57, 60]], "Time": [[61, 64]], "Instant": [[40, 46]], "OffsetDateTime": [[51, 64]]}}}, {"text": "id brings a backport of Java 8 date and time classes to Java 6 and 7, so you can use Instant or OffsetDateTime", "label": {"api": {"Date": [[102, 105]], "Time": [[106, 109]], "Instant": [[85, 91]], "OffsetDateTime": [[96, 109]]}}}, {"text": "You are using a wrong formatter pattern, you should use ISO date-time formatter", "label": {"api": {"ISO date-time formatter": [[56, 78]]}}}, {"text": "It always returns true", "label": {"api": {"always": [[3, 8]]}}}, {"text": "Using DateTimeFormatterBuilder to produce a DateTimeFormatter as suggested by vmrvictor", "label": {"api": {"DateTimeFormatterBuilder": [[6, 29]], "DateTimeFormatter": [[6, 22], [44, 60]]}}}, {"text": "The returned LocalDateTime object can be formatted at will, but I assumed that 2019-01-01 00:00:00 in the question indicates an object, compared to \"2019\" that represents a string", "label": {"api": {"LocalDateTime": [[13, 25]]}}}, {"text": "If you look at the documentation of replace(), it mentions", "label": {"api": {"documentation of replace()": [[19, 44]]}}}, {"text": "I believe what you are looking for is LinkedHashMap", "label": {"api": {"LinkedHashMap": [[38, 50]]}}}, {"text": "All heavy tasks in Swing should be executed by SwingWorkers", "label": {"api": {"SwingWorkers": [[47, 58]]}}}, {"text": "Integers are object types so for comparing them you should use Integer::equals", "label": {"api": {"Integer::equals": [[63, 77]]}}}, {"text": "You can use printf in Java", "label": {"api": {"printf": [[12, 17]]}}}, {"text": "It does the String.format() internally, so you can write pretty much in the same way as Python (or any language with printf-like functionality)", "label": {"api": {"printf": [[117, 122]]}}}, {"text": "System.out is a static field / global object / singleton", "label": {"api": {"System.out": [[0, 9]]}}}, {"text": "But you can call non-static methods even from static methods as long as you have an instance to call them on (such as System.out here)", "label": {"api": {"System.out": [[118, 127]]}}}, {"text": "That is not needed here (unless you want to do System.out.println(this) -- that would not work from inside a static method)", "label": {"api": {"System.out": [[47, 56]]}}}, {"text": "None of this is \"special\" about System.out or requires internal JVM magic", "label": {"api": {"System.out": [[32, 41]]}}}, {"text": "The built-in Objects.equals() method does exactly this", "label": {"api": {"Objects.equals()": [[13, 28]]}}}, {"text": "Not knowing the exception, one thing that is wrong, is that you're not calling the close() method on the NamingEnumeration, so you're leaking resources", "label": {"api": {"close()": [[83, 89]]}}}, {"text": "Javadoc of Inflater.needsInput()", "label": {"api": {"Javadoc of Inflater.needsInput()": [[0, 31]]}}}, {"text": "Then when I want to check what type of map is returned by the factory method, I found the following note", "label": {"api": {"note": [[100, 103]]}}}, {"text": "You could pass a Consumer that accepts a list of strings and calls the builder methods, e.g.", "label": {"api": {"Consumer": [[17, 24]]}}}, {"text": "You have to make sure that ArrayOutOfBoundException is not thrown by not mixing rows and columns indices", "label": {"api": {"ArrayOutOfBoundException": [[27, 50]]}}}, {"text": "The given stream is guaranteed to support the mark feature and the detector is expected to mark the stream before reading any bytes from it, and to reset the stream before returning", "label": {"api": {"mark feature": [[46, 57]], "mark": [[46, 49], [91, 94]], "reset": [[148, 152]]}}}, {"text": "Javadoc of TikaInputStream says", "label": {"api": {"InputStream": [[15, 25]]}}}, {"text": "The created TikaInputStream instance keeps track of the original resource used to create it, while behaving otherwise just like a normal, buffered InputStream", "label": {"api": {"InputStream": [[16, 26], [147, 157]]}}}, {"text": "A TikaInputStream instance is also guaranteed to support the mark(int) feature", "label": {"api": {"mark": [[61, 64]], "InputStream": [[6, 16]]}}}, {"text": "Which means you should use TikaInputStream to read the content, and try-with-resources to close it", "label": {"api": {"InputStream": [[31, 41]]}}}, {"text": "You can use the add method of JsonObjectBuilder", "label": {"api": {"add method of JsonObjectBuilder": [[16, 46]]}}}, {"text": "In this specific case I think the isDefault() method should return true", "label": {"api": {"isDefault()": [[34, 44]]}}}, {"text": "From the JToolBar documentation", "label": {"api": {"JToolBar documentation": [[9, 30]]}}}, {"text": "Using IntStream::range should work (for your special step of 20)", "label": {"api": {"IntStream::range": [[6, 21]]}}}, {"text": "The same could be achieved with IntStream::iterate (available since JDK9) which takes seed, IntPredicate and IntUnaryOperator", "label": {"api": {"IntStream::iterate": [[32, 49]]}}}, {"text": "From the Javadoc for TreeMap", "label": {"api": {"Javadoc for TreeMap": [[9, 27]]}}}, {"text": "Converting bytes to a String decodes the bytes, which means some values may be altered or lost", "label": {"api": {"decodes": [[29, 35]]}}}, {"text": "Your data appears to consist entirely of short values, so, assuming the C client is built to regard short as a 16-bit value, and assuming the C compiler didn’t pad your struct members in order to word-align them, you can convert your bytes to a sequence of shorts using ByteBuffer and ShortBuffer", "label": {"api": {"ByteBuffer": [[270, 279]], "ShortBuffer": [[285, 295]]}}}, {"text": "To print them, retrieve them as an array and use Arrays.toString", "label": {"api": {"Arrays.toString": [[49, 63]]}}}, {"text": "Note that if you're not using Java 11+ you can replace the use List#of with Arrays#asList(T...)", "label": {"api": {"List#of": [[63, 69]], "Arrays#asList(T...)": [[76, 94]]}}}, {"text": "If you are using Java 11+ then consider using the result of List#of directly, rather than copying the result into a modifiable ArrayList (assuming you don't plan on modifying the list)", "label": {"api": {"List#of": [[60, 66]]}}}, {"text": "You may also want to consider using the java.time.DayOfWeek enum instead of a String to represent each day of the week", "label": {"api": {"java.time.DayOfWeek": [[40, 58]]}}}, {"text": "As per Javadoc", "label": {"api": {"per Javadoc": [[3, 13]]}}}, {"text": "Use Number in your calculatory code for int/double/BigDecimal (all are Number) and such", "label": {"api": {"Number": [[4, 9], [71, 76]]}}}, {"text": "To compile and cache your fixed code use newTemplates to create a Templates object, https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newTemplates-javax.xml.transform.Source-, then for each execution in a multi-threaded environment use newTransformer on the Templates object to create a new Transformer", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newTemplates-javax.xml.transform.Source-": [[84, 209]]}}}, {"text": "Since java 8 exist Stream.flatMap, which is well suited for such situations", "label": {"api": {"Stream.flatMap": [[19, 32]]}}}, {"text": "This sets up a cache which wraps any value it stores in a SoftReference", "label": {"api": {"SoftReference": [[58, 70]]}}}, {"text": "A far easier way to go about it would be to replace() all instances of the substring with an empty string, and check whether the resulting string is empty or not", "label": {"api": {"replace()": [[44, 52]]}}}, {"text": "Alternatively, use a regular expression to check whether the string matches() a multiple of the substring", "label": {"api": {"matches()": [[68, 76]]}}}, {"text": "Think about List.indexOf", "label": {"api": {"List.indexOf": [[12, 23]]}}}, {"text": "You may want to define your triangle as a Polygon , and use fillPolygon(Polygon) e.g", "label": {"api": {"fillPolygon(Polygon)": [[60, 79]]}}}, {"text": "The API documentation for Thread.join says", "label": {"api": {"API documentation for Thread.join": [[4, 36]]}}}, {"text": "We are building an application using the new (well comparatively) Java HttpClient that was added in Java 11", "label": {"api": {"HttpClient": [[71, 80]]}}}, {"text": "Would java RandomAccessFile class methods help", "label": {"api": {"RandomAccessFile": [[11, 26]]}}}, {"text": "There's nothing in the java.util.function package which applies to this", "label": {"api": {"java.util.function": [[23, 40]]}}}, {"text": "then you could use BiFunction but there is no \"TriFunction\"", "label": {"api": {"BiFunction": [[19, 28]]}}}, {"text": "inheritIO() will cause all of the child process’s output to appear in the output of the Java program which calls it, eliminating the need to consume the process’s InputStream and ErrorStream yourself", "label": {"api": {"inheritIO()": [[0, 10]]}}}, {"text": "allOf returns a new CompletableFuture that is completed when all of the given CompletableFutures complete", "label": {"api": {"allOf": [[0, 4]]}}}, {"text": "There is no single Java SE method for it, but with Character.digit it’s fairly straightforward", "label": {"api": {"Character.digit": [[51, 65]]}}}, {"text": "You could use collectingAndThen", "label": {"api": {"collectingAndThen": [[14, 30]]}}}, {"text": "From the Javadoc of Socket.getInputStream()", "label": {"api": {"Javadoc of Socket.getInputStream()": [[9, 42]]}}}, {"text": "If you need the method to take or return data, you could use an existing Functional Interface that matches what you need, or you could write your own", "label": {"api": {"existing Functional Interface": [[64, 92]]}}}, {"text": "what about rounding that double?", "label": {"api": {"rounding": [[11, 18]]}}}, {"text": "From the Hashtable Javadoc", "label": {"api": {"the Hashtable Javadoc": [[5, 25]]}}}, {"text": "setExecutable, setReadable, setReadOnly, setWritable are replaced by the Files method setAttribute(Path, String, Object, LinkOption...)", "label": {"api": {"setAttribute(Path, String, Object, LinkOption...)": [[86, 134]]}}}, {"text": "See AclFileAttributeView for more details", "label": {"api": {"AclFileAttributeView": [[4, 23]]}}}, {"text": "Instead, you can use Optional for control flow", "label": {"api": {"Optional": [[21, 28]]}}}, {"text": "This sort of thing is what JPA Attribute Converters are designed to help achieve", "label": {"api": {"JPA Attribute Converters": [[27, 50]]}}}, {"text": "As you can see here https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html Thread.currentThread() returns a reference to the currently executing thread", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html": [[20, 82]]}}}, {"text": "Thread.currentThread() returns the currently running thread", "label": {"api": {"Thread.currentThread()": [[0, 21]]}}}, {"text": "In any case, when the terminate() method is called directly on some thread, Thread.currentThread() will return that thread", "label": {"api": {"Thread.currentThread()": [[76, 97]]}}}, {"text": "The thread.interrupt() method doesn't necessarily cause an InterruptedException to be thrown", "label": {"api": {"thread.interrupt()": [[4, 21]]}}}, {"text": "And then in Bar, instead of calling f.terminate(), call fthread.interrupt()", "label": {"api": {"thread.interrupt()": [[57, 74]]}}}, {"text": "You could use readAllBytes() and create a String using the default charset", "label": {"api": {"readAllBytes()": [[14, 27]]}}}, {"text": "You might want to look into a SortedMap instead", "label": {"api": {"SortedMap": [[30, 38]]}}}, {"text": "You may also refer to the official Formatter documentation", "label": {"api": {"Formatter documentation": [[35, 57]]}}}, {"text": "If you call setSoTimeout on your instance of ServerSocket, you will be able to set a timeout for your socket", "label": {"api": {"setSoTimeout": [[12, 23]]}}}, {"text": "Then, when you block during calls to accept, your ServerSocket will keep track of the timeout", "label": {"api": {"accept": [[37, 42]]}}}, {"text": "As you can see in the documentation, accept throws a SocketTimeoutException if a timeout has been defined and the wait time has exceeded the timeout", "label": {"api": {"accept": [[37, 42]]}}}, {"text": "Consider using Optional<> instead of null to represent something that can legitimately not be present", "label": {"api": {"Optional<>": [[15, 24]]}}}, {"text": "Optional<> has a handful of methods (map, ifPresent, orElse, and orElseGet) to take different actions depending on whether it has a value", "label": {"api": {"Optional<>": [[0, 9]]}}}, {"text": "But I think what you'll find is that if you start this way, the Optional<> paradigm will naturally spread over time and improve the code quality of your project as a whole", "label": {"api": {"Optional<>": [[64, 73]]}}}, {"text": "Instead, maybe consider using a Timer to fire a second event that corresponds to the drawing of the second card, as in the example below", "label": {"api": {"Timer": [[32, 36]]}}}, {"text": "I know I can parse a double from a String using Double.parseDouble(String s)", "label": {"api": {"Double.parseDouble(String s)": [[48, 75]]}}}, {"text": "I know I can also parse that same string into a BigDecimal using new BigDecimal(String s), and then ask the BigDecimal for a double using BigDecimal.doubleValue()", "label": {"api": {"new BigDecimal(String s)": [[65, 88]], "BigDecimal.doubleValue()": [[138, 161]]}}}, {"text": "The BigDecimal(String) constructor Javadocs states", "label": {"api": {"BigDecimal(String) constructor Javadocs": [[4, 42]]}}}, {"text": "However, the Double.parseDouble(String) method states", "label": {"api": {"Double.parseDouble(String) method": [[13, 45]]}}}, {"text": "Probably, as workaround you can use longs method introduced in Java 8", "label": {"api": {"longs": [[36, 40]]}}}, {"text": "I will show you a modern and true Java approach employed in Stream API and implemented in the [Int/Long/Double]SummaryStatistics classes", "label": {"api": {"[Int/Long/Double]SummaryStatistics": [[94, 127]]}}}, {"text": "For Jax-RS you can use ExceptionMapper to catch the exceptions", "label": {"api": {"ExceptionMapper": [[23, 37]]}}}, {"text": "The LinkedHashMap class works really well for your particular problem", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "You may iterate the character array from your input string, and then add the characters, along with their counts, as keys, into the LinkedHashMap", "label": {"api": {"LinkedHashMap": [[132, 144]]}}}, {"text": "Since LinkedHashMap preserves insertion order, to get the output you want you need only iterate the map and print out all keys whose counts are greater than one", "label": {"api": {"LinkedHashMap": [[6, 18]]}}}, {"text": "Everything works fine until calling the reflection for Modifier.isFinal(), which reports incorrectly that a non-final class is actually final", "label": {"api": {"Modifier.isFinal()": [[55, 72]]}}}, {"text": "From the URLClassLoader documentation", "label": {"api": {"URLClassLoader documentation": [[9, 36]]}}}, {"text": "You can use Arrays::stream to convert String array to Stream of Strings and then use Stream::flatMap and collect to Set using Collectors.toSet", "label": {"api": {"Collectors.toSet": [[126, 141]]}}}, {"text": "I can't reproduce this issue myself, however I know that DecimalFormat is not thread-safe and I probably made a mistake somewhere", "label": {"api": {"DecimalFormat is not thread-safe": [[57, 88]]}}}, {"text": "ForkJoinPool.invoke() is not a static method, but you are using as it was", "label": {"api": {"ForkJoinPool.invoke()": [[0, 20]]}}}, {"text": "The Certificate::verify serves this purpose", "label": {"api": {"Certificate::verify": [[4, 22]]}}}, {"text": "Also you can have a look at X509Certificate::verify(PublicKey, Provider) which takes PublicKey and Provider implementation", "label": {"api": {"Certificate::verify": [[32, 50]], "X509Certificate::verify(PublicKey, Provider)": [[28, 71]]}}}, {"text": "You need to combine your predicates using and", "label": {"api": {"and": [[42, 44]]}}}, {"text": "Returns a composed predicate that represents a short-circuiting logical AND of this predicate and another", "label": {"api": {"and": [[94, 96]]}}}, {"text": "You must use Predicate::and to combine the Predicates", "label": {"api": {"Predicate::and": [[13, 26]]}}}, {"text": "You can use the Class.asSubclass() method to change your Class<?> object returned by Class.forName(...) to something you can work with", "label": {"api": {"Class.asSubclass()": [[16, 33]]}}}, {"text": "In combination with the getConstructor() method (the singular one, the one without the s) you can create a Constructor object with a desired type you want", "label": {"api": {"getConstructor()": [[24, 39]]}}}, {"text": "You have to rewrite your code that you use getConstructor() instead of getConstructors() (you are using only one anyway) because this method is returning a Constructor<", "label": {"api": {"getConstructor()": [[43, 58]]}}}, {"text": "Use a BufferedReader, place a mark(...), read the first line", "label": {"api": {"BufferedReader": [[6, 19]], "mark(...)": [[30, 38]], "line": [[56, 59]]}}}, {"text": "If that line contains a \\t tab character, then your file is tab-separated, otherwise assume that it is comma-separated", "label": {"api": {"line": [[8, 11]]}}}, {"text": "One way to achieve this is by using Collectors.groupingBy", "label": {"api": {"Collectors.groupingBy": [[36, 56]]}}}, {"text": "There is one method that lets you set a TrustManagerFactory", "label": {"api": {"method": [[13, 18]]}}}, {"text": "Although I extend the  class, the method that returns the TrustManagers is final", "label": {"api": {"method": [[34, 39]]}}}, {"text": "However, looking at Javadoc for LinkedList, there is no way to change where the last element points", "label": {"api": {"Javadoc for LinkedList": [[20, 41]]}}}, {"text": "Note that if there was a way, you could create a synchronized view of that data structure by call Collections.synchronizedList() like this", "label": {"api": {"Collections.synchronizedList()": [[98, 127]]}}}, {"text": "Then use Collections.synchronizedList() to create a thread-safe view of it", "label": {"api": {"Collections.synchronizedList()": [[9, 38]]}}}, {"text": "Note that Javadoc for Collections.synchronizedList() says", "label": {"api": {"Collections.synchronizedList()": [[22, 51]]}}}, {"text": "The reason you are seeing everything on a single line is because you're calling print() instead of println()", "label": {"api": {"print()": [[80, 86]], "println()": [[99, 107]]}}}, {"text": "You could print two lines by making two separate calls to println(), like this", "label": {"api": {"println()": [[58, 66]]}}}, {"text": "the javadoc of File.listFiles() says", "label": {"api": {"File.listFiles()": [[15, 30]]}}}, {"text": "In general though the whole approach seems to be wrong - why do you want to draw text manually instead of using an available component like javax.swing.JLabel", "label": {"api": {"javax.swing.JLabel": [[140, 157]]}}}, {"text": "If ArrayList.removeRange() meets what you're trying to do, you can work around the protected limitation by creating a new ArrayList that contains the first and last sublists, excluding the range in the middle", "label": {"api": {"ArrayList.removeRange()": [[3, 25]]}}}, {"text": "You can use Stream and filter to concisely filter items from a list", "label": {"api": {"Stream": [[12, 17]], "filter": [[23, 28], [43, 48]]}}}, {"text": "However, since Arrays.asList() supports varargs, I might have called it with two (or more) different int arrays and would have seen no warning at all (for example", "label": {"api": {"Arrays.asList()": [[15, 29]]}}}, {"text": "Arrays.asList() converts an array to a List of objects, which works as expected when converting Integer[] to List<Integer>", "label": {"api": {"Arrays.asList()": [[0, 14]]}}}, {"text": "\"An object is a class instance or an array\" – clearly though, in the case of Arrays.asList(), there's a subtlety about whether it's an array of objects or an array of primitives", "label": {"api": {"Arrays.asList()": [[77, 91]]}}}, {"text": "Why does the Javadoc for Arrays.asList() make no mention of this behavior with primitive arrays", "label": {"api": {"Arrays.asList()": [[25, 39]]}}}, {"text": "You can use the Pattern.quote() method to escape characters that have a special meaning in regular expressions", "label": {"api": {"Pattern.quote()": [[16, 30]]}}}, {"text": "See Optional documentation", "label": {"api": {"Optional documentation": [[4, 25]]}}}, {"text": "URLConnection has getOutputStream()", "label": {"api": {"URLConnection": [[0, 12]], "getOutputStream()": [[18, 34]]}}}, {"text": "Please read the documentation for fillRect(), and note that the coordinates are treated differently from drawRect()", "label": {"api": {"fillRect()": [[34, 43]]}}}, {"text": "fillRect() fills in a rectangle that's 1 pixels wider and taller than drawRect()", "label": {"api": {"fillRect()": [[0, 9]]}}}, {"text": "the parse method does exactly what you are trying to do and LocalDate replace java.util.Date and is immutable", "label": {"api": {"parse": [[4, 8]]}}}, {"text": "I would personally not use a String to store Date, and I would not use java.util.Date and SimpleDateFormat to parse Date now that we have LocalDate and LocalDate.parse doing the exact thing you are trying to do", "label": {"api": {"parse": [[110, 114], [162, 166]], "LocalDate.parse": [[152, 166]]}}}, {"text": "Read Stream.collect(Supplier supplier, BiConsumer, BiConsumer combiner) for more info", "label": {"api": {"Stream.collect(Supplier supplier, BiConsumer, BiConsumer combiner)": [[5, 70]]}}}, {"text": "And if you don't like the way its rendered, you can always add your own ListCellRenderer", "label": {"api": {"ListCellRenderer": [[72, 87]]}}}, {"text": "pow's parameter is an int", "label": {"api": {"pow": [[0, 2]]}}}, {"text": "BigInteger.pow() only exists for int parameters, so you can't take the power bigger than Integer.MAX_VALUE at once", "label": {"api": {"BigInteger.pow()": [[0, 15]]}}}, {"text": "Note that the \"power with modulus\" operation which is often used in cryptography is implemented using BigInteger.modPow() which does take BigInteger arguments and can therefore handle effectively arbitrarily large values", "label": {"api": {"BigInteger.modPow()": [[102, 120]]}}}, {"text": "From the documentation of Condition", "label": {"api": {"Condition": [[26, 34]]}}}, {"text": "Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations", "label": {"api": {"Condition": [[0, 8]]}}}, {"text": "Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods", "label": {"api": {"Condition": [[72, 80]]}}}, {"text": "Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to \"wait\") until notified by another thread that some state condition may now be true", "label": {"api": {"Condition": [[0, 8]]}}}, {"text": "A Condition instance is intrinsically bound to a lock", "label": {"api": {"Condition": [[2, 10]]}}}, {"text": "To obtain a Condition instance for a particular Lock instance use its newCondition() method", "label": {"api": {"Condition": [[12, 20], [73, 81]]}}}, {"text": "As explained, a Condition instance must be associated with a Lock instance1", "label": {"api": {"Condition": [[16, 24]]}}}, {"text": "Having Lock function as a factory for creating instances of Condition makes perfect sense with that in mind as it implies the relationship between the two", "label": {"api": {"Condition": [[60, 68]]}}}, {"text": "Another way this relationship could have been enforced is to give Condition a constructor which accepts a Lock instance, but since Condition is also an interface it cannot declare constructors", "label": {"api": {"Condition": [[66, 74], [131, 139]]}}}, {"text": "If it's not already clear, the ReentrantLock class is an implementation of the Lock interface and the ConditionObject class is an implementation of the Condition interface", "label": {"api": {"Condition": [[102, 110], [152, 160]]}}}, {"text": "The other problem with attempting to use ConditionObject directly is that it's an inner class (i.e", "label": {"api": {"Condition": [[41, 49]]}}}, {"text": "In other words, you have no way to call the constructor of ConditionObject which means the only way to create an instance is via newCondition()", "label": {"api": {"Condition": [[59, 67], [132, 140]]}}}, {"text": "To recap, there's at least three reasons why a factory method is used to create Condition objects", "label": {"api": {"Condition": [[80, 88]]}}}, {"text": "It makes the relationship between Lock and Condition clear", "label": {"api": {"Condition": [[43, 51]]}}}, {"text": "With both Lock and Condition being interfaces, you need a way to associate a Condition with a Lock without knowing about the implementations", "label": {"api": {"Condition": [[19, 27], [77, 85]]}}}, {"text": "Due to ConditionObject being an inner class it cannot be instantiated directly—at least, not by code which doesn't have access to an instance of the enclosing class", "label": {"api": {"Condition": [[7, 15]]}}}, {"text": "The methods of Condition only make sense in the context of owning a Lock", "label": {"api": {"Condition": [[15, 23]]}}}, {"text": "wait/notify), a thread must own the associated Lock before it can legally invoke the methods of the Condition (i.e", "label": {"api": {"Condition": [[100, 108]]}}}, {"text": "There's also AbstractQueuedLongSynchronizer which declares its own ConditionObject inner class", "label": {"api": {"Condition": [[67, 75]]}}}, {"text": "There is a simple way to copy all bytes from an input stream to a file - Files.copy(in, path)", "label": {"api": {"Files.copy(in, path)": [[73, 92]]}}}, {"text": "Consider using the built in conversion method for binary strings", "label": {"api": {"the built in conversion method": [[15, 44]]}}}, {"text": "To represent that range, we can use IntStream#rangeClosed", "label": {"api": {"IntStream#rangeClosed": [[36, 56]]}}}, {"text": "From this answer, we can utilize BigInteger to left-pad the binary String (generated by Integer#toBinaryString) with 0s if its length is less than 8 (denoting that the value is positive)", "label": {"api": {"BigInteger": [[33, 42]], "Integer#toBinaryString": [[88, 109]]}}}, {"text": "Otherwise, the value represents a negative number, and its respective binary string will have a length greater than 8, which must be truncated to 8 characters using String#substring", "label": {"api": {"String#substring": [[165, 180]]}}}, {"text": "Finally, the Stream<String> can be collected to a String[] using Stream#toArray", "label": {"api": {"Stream#toArray": [[65, 78]]}}}, {"text": "Alternatively you can use the split()-Method and split by spaces", "label": {"api": {"split()": [[30, 36]]}}}, {"text": "You can use reflection", "label": {"api": {"reflection": [[12, 21]]}}}, {"text": "Take a look at ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[15, 41]]}}}, {"text": "It looks like scan is an instance of java.util.Scanner", "label": {"api": {"java.util.Scanner": [[37, 53]]}}}, {"text": "For details for how the input is read, look at the documentation for Scannner#nextDouble()", "label": {"api": {"the documentation for Scannner#nextDouble()": [[47, 89]]}}}, {"text": "Calling start() on a Thread doesn't necessarily result in the thread running immediately after", "label": {"api": {"start()": [[8, 14]]}}}, {"text": "It is possible for other things to happen in between your calling start() and the first line of your thread's run() method actually being run", "label": {"api": {"start()": [[66, 72]]}}}, {"text": "I can put this method in an abstract class, and then the actual implementations of the list (array, linked, something else) only have to provide a way to iterate", "label": {"api": {"an abstract class": [[25, 41]]}}}, {"text": "My question is can, ResultSetMetaData.getColumnLabel(int) return null", "label": {"api": {"ResultSetMetaData.getColumnLabel(int)": [[20, 56]]}}}, {"text": "Note that for this specific case, simply adding volatile to value would have the same effect, but for more complex access patterns synchronized (or it's equivalence in newer APIs Lock) is necessary", "label": {"api": {"Lock": [[179, 182]]}}}, {"text": "Optional::orElseThrow takes a Supplier and this Supplier is used to get an instance of Exception which will be thrown if Optional has null value underneath", "label": {"api": {"Optional::orElseThrow": [[0, 20]], "Supplier": [[30, 37], [48, 55]]}}}, {"text": "See the implementation for Optional::orElseThrow", "label": {"api": {"Optional::orElseThrow": [[27, 47]]}}}, {"text": "it simply checks if value is there and if not - it gets the Execption instance from Supplier and throws it", "label": {"api": {"Supplier": [[84, 91]]}}}, {"text": "is conformant to Supplier expected by Optional::orElseThrow method - Supplier<", "label": {"api": {"Optional::orElseThrow": [[38, 58]], "Supplier": [[17, 24], [69, 76]]}}}, {"text": "extends X> exceptionSupplier where X extends Throwable", "label": {"api": {"Supplier": [[20, 27]]}}}, {"text": "The documentation of Files#copy(Path,Path,CopyOption...) says", "label": {"api": {"Files#copy(Path,Path,CopyOption...)": [[21, 55]]}}}, {"text": "May be interesting to note that Files#copy(Path,Path,CopyOption...) does something very similar to the second example, but only if the source and target have the different FileSystemProvider instances", "label": {"api": {"Files#copy(Path,Path,CopyOption...)": [[32, 66]]}}}, {"text": "You can use charAt() function to get values sequentially for all characters in the string", "label": {"api": {"charAt() function": [[12, 28]]}}}, {"text": "This is clearly stated in the docs", "label": {"api": {"in the docs": [[23, 33]]}}}, {"text": "If the mapped keys may have duplicates, use toMap(Function, Function, BinaryOperator) instead", "label": {"api": {"toMap(Function, Function, BinaryOperator": [[44, 83]]}}}, {"text": "If you look at the docs for Container, you will see that it has a remove() method", "label": {"api": {"Container": [[28, 36]]}}}, {"text": "Since JPanel extends Container, it also has this method", "label": {"api": {"Container": [[21, 29]], "JPanel": [[6, 11]]}}}, {"text": "Class Scanner has a constructor that takes a Path", "label": {"api": {"Path": [[45, 48]]}}}, {"text": "But Path is an interface, so you need to use class Paths to create an appropriate Path", "label": {"api": {"Path": [[4, 7], [51, 54], [82, 85]], "Paths": [[51, 55]]}}}, {"text": "Furthermore I will store all the Worker objects I create in a collection, a List to be precise", "label": {"api": {"List": [[76, 79]]}}}, {"text": "You should look at reset method in ObjectOutputStream", "label": {"api": {"reset": [[19, 23]]}}}, {"text": "The state is reset to be the same as a new ObjectOutputStream", "label": {"api": {"reset": [[13, 17]]}}}, {"text": "The current point in the stream is marked as reset so the corresponding ObjectInputStream will be reset at the same point", "label": {"api": {"reset": [[45, 49], [98, 102]]}}}, {"text": "You should call reset before writing the same object again", "label": {"api": {"reset": [[16, 20]]}}}, {"text": "You can also use writeUnshared method", "label": {"api": {"writeUnshared": [[17, 29]]}}}, {"text": "If you decide to use writeUnshared, you should look into readUnshared method from ObjectInputStream", "label": {"api": {"writeUnshared": [[21, 33]], "readUnshared": [[57, 68]]}}}, {"text": "Use a StringWriter to keep everything as text", "label": {"api": {"StringWriter": [[6, 17]]}}}, {"text": "Using Collectors.groupingBy, you can generate a Map from your Key to a List of Values, provided you can compute the Key from the Value", "label": {"api": {"Collectors.groupingBy": [[6, 26]], "groupingBy": [[17, 26]]}}}, {"text": "Alternatively, you can use Collectors.toMap, provided you can compute both the Key and the Value from an upstream element", "label": {"api": {"Collectors.toMap": [[27, 42]], "toMap": [[38, 42]]}}}, {"text": "You probably want the version of toMap with a merge function, because that will allow you to handle multiple keys with the same value (by putting them in a list together)", "label": {"api": {"toMap": [[33, 37]]}}}, {"text": "If you want ordering, there are overloads for toMap and groupingBy that allow you to provide a mapFactory (Supplier<Map>) , such as TreeMap::new", "label": {"api": {"toMap": [[46, 50]], "groupingBy": [[56, 65]]}}}, {"text": "To invert a map, so that its distinct values become keys, and its keys are added to a collection under the corresponding value, use groupingBy() on the map entries", "label": {"api": {"groupingBy()": [[132, 143]]}}}, {"text": "Calling print will output the exact String that you provide to it, whereas calling println will output the String you provide to it, followed by a new line (the line separator for your system)", "label": {"api": {"line separator": [[161, 174]]}}}, {"text": "I'm using the Java 11+ feature String.repeat to massively simplify the operation of repeating a String here", "label": {"api": {"String.repeat": [[31, 43]]}}}, {"text": "Dialogs can accept an object as their 2nd parameter which in this case you could pass a custom panel with your inputs", "label": {"api": {"Dialogs": [[0, 6]]}}}, {"text": "Let's say this data is a single int, then the enumerated types could look like this (using IntSupplier)", "label": {"api": {"IntSupplier": [[91, 101]]}}}, {"text": "You need Optional#ifPresent", "label": {"api": {"Optional#ifPresent": [[9, 26]]}}}, {"text": "Starting from Java 8 you can use Long.toUnsignedString(values)", "label": {"api": {"Long.toUnsignedString(values)": [[33, 61]]}}}, {"text": "The javax.ws.rs.core.MultivaluedMap interface defined in Java EE API is an example that achieves what you want to do", "label": {"api": {"javax.ws.rs.core.MultivaluedMap": [[4, 34]]}}}, {"text": "Otherwise, an exception java.lang.IllegalMonitorStateException will be thrown", "label": {"api": {"java.lang.IllegalMonitorStateException": [[24, 61]]}}}, {"text": "From the documentation for Scanner.close()", "label": {"api": {"the documentation for Scanner.close()": [[5, 41]]}}}, {"text": "if its underlying readable also implements the Closeable interface then the readable's close method will be invoked", "label": {"api": {"Closeable": [[47, 55]]}}}, {"text": "Calendar.DAY_OF_WEEK is a constant 7 so it's working correctly, just not how you expected", "label": {"api": {"Calendar.DAY_OF_WEEK": [[0, 19]]}}}, {"text": "But calendar.get(Calendar.DAY_OF_WEEK) will give you the value you seek", "label": {"api": {"Calendar.DAY_OF_WEEK": [[17, 36]], "calendar.get(Calendar.DAY_OF_WEEK)": [[4, 37]]}}}, {"text": "You can check the documentation on docs.oracle", "label": {"api": {"docs.oracle": [[35, 45]]}}}, {"text": "Using single thread executor service, I would try something like this", "label": {"api": {"single thread executor service": [[6, 35]]}}}, {"text": "The forEach method that you are calling is not the Stream::forEach method, but the Map::forEach method, as you are calling it on the return value of collect(...), which is a Map", "label": {"api": {"Map::forEach": [[83, 94]]}}}, {"text": "A feature of the Map::forEach method is that it takes a BiConsumer, instead of a Consumer", "label": {"api": {"Map::forEach": [[17, 28]]}}}, {"text": "In that case, you should use flatMap", "label": {"api": {"flatMap": [[29, 35]]}}}, {"text": "N calls to flatMap is required for a map nested N levels deep", "label": {"api": {"flatMap": [[11, 17]]}}}, {"text": "To render the numbers in your output using Western Arabic Numerals you just need to explicitly set the Locale appropriately within your application", "label": {"api": {"Locale": [[103, 108]]}}}, {"text": "See the Javadocs for Locale and NumberFormat for more details", "label": {"api": {"Locale": [[21, 26]], "NumberFormat": [[32, 43]]}}}, {"text": "Instead, they use a special type called BigDecimal", "label": {"api": {"BigDecimal": [[40, 49]]}}}, {"text": "If, however, a value of -934 is valid, and -966 is not, just eliminate the sign by calling Math.abs()", "label": {"api": {"Math.abs()": [[91, 100]]}}}, {"text": "The main thing is using ExceptionInInitializerError which is built for this kind of static context initializations", "label": {"api": {"ExceptionInInitializerError": [[24, 50]]}}}, {"text": "Just try using Scanner and System.out.println instead", "label": {"api": {"Scanner": [[15, 21]]}}}, {"text": "In case you need to generate whole url in another place try using URLEncoder (but you should also disable URL encoding in RestAssured to prevent double encoding)", "label": {"api": {"URLEncoder": [[66, 75]]}}}, {"text": "This will query the system UTC clock to obtain the current instant", "label": {"api": {"system UTC clock": [[20, 35]]}}}, {"text": "Simply use Collectors::groupingBy and pass method reference to MyDto::getName method which will be used as the key for your map", "label": {"api": {"Collectors::groupingBy": [[11, 32]]}}}, {"text": "You can solve your problem using Stream API by adding the following method to OrderItem", "label": {"api": {"Stream API": [[33, 42]]}}}, {"text": "You need to add a filter to your stream (before the map operation)", "label": {"api": {"filter": [[18, 23]]}}}, {"text": "I haven't found where this is formally stated, but can point to the Javadoc for java.lang.reflect.Method which has no methods exposing anything about local variables", "label": {"api": {"java.lang.reflect.Method": [[80, 103]]}}}, {"text": "Looking at the rest of the the reflection package, there's nothing else would that would be a better fit than Method", "label": {"api": {"the reflection package": [[27, 48]]}}}, {"text": "I've tried to append the username and password using the BindingProvider with no success", "label": {"api": {"BindingProvider": [[57, 71]]}}}, {"text": "You could use reduce to do this", "label": {"api": {"reduce": [[14, 19]]}}}, {"text": "My primary stream has some operations that are needed to be done on Stream.onClose()", "label": {"api": {"Stream.onClose()": [[68, 83]]}}}, {"text": "In my custom logic, I use Iterator from Stream.iterator() for stream processing", "label": {"api": {"Stream.iterator()": [[40, 56]]}}}, {"text": "But, when I used Stream.flatMap() for constructing a lazy stream, onClose function gets called when I start iterating, which in-turn creates problems for me", "label": {"api": {"Stream.flatMap()": [[17, 32]]}}}, {"text": "For processor component, it requires a java instance of class implementing the java interface Processor when route is being created", "label": {"api": {"java interface Processor": [[79, 102]]}}}, {"text": "Create a Predicate which tests an object and returns a boolean value", "label": {"api": {"Predicate": [[9, 17]]}}}, {"text": "Here's the documentation of List#add(int,E)", "label": {"api": {"List#add(int,E)": [[28, 42]]}}}, {"text": "This would be equivalent to calling List#add(E) every iteration", "label": {"api": {"List#add(E)": [[36, 46]]}}}, {"text": "Looking at the Javadoc for Scanner", "label": {"api": {"Javadoc for Scanner": [[15, 33]]}}}, {"text": "Use the filter method, passing in a DoublePredicate that uses Double.isNaN to filter them out", "label": {"api": {"filter method": [[8, 20]], "Double.isNaN": [[62, 73]]}}}, {"text": "You seem to be looking for List#replaceAll such as", "label": {"api": {"List#replaceAll": [[27, 41]]}}}, {"text": "This is what the Collections.emptyList() method does", "label": {"api": {"Collections.emptyList()": [[17, 39]]}}}, {"text": "yes, setting a socket timeout through socket.setSoTimeout(timeout) will be enough to trigger a SocketTimeoutException (a subclass of IOException) if the handshake process doesn't complete after \"some time\" (but not necessarily the specified timeout1)", "label": {"api": {"socket.setSoTimeout(timeout)": [[38, 65]]}}}, {"text": "the handshake protocol performed by startHandshake() involves several reads/writes from the socket Input/OutputStream, which will trigger the timeout itself", "label": {"api": {"startHandshake()": [[36, 51]]}}}, {"text": "Also, note that you don't need to call startHandshake() yourself", "label": {"api": {"startHandshake()": [[39, 54]]}}}, {"text": "The timeout specified by setSoTimeout(timeout) is for a single read()", "label": {"api": {"read()": [[63, 68]]}}}, {"text": "So the handshake process can timeout (in the worst case) after the number of read() it performs, times the timeout value you specified", "label": {"api": {"read()": [[77, 82]]}}}, {"text": "Use Class.getResourceAsStream or ClassLoader.getResourceAsStream", "label": {"api": {"Class.getResourceAsStream": [[4, 28]], "ClassLoader.getResourceAsStream": [[33, 63]]}}}, {"text": "The javadoc of SimpleDateFormat will tell you what combination of letters you need to use", "label": {"api": {"javadoc of SimpleDateFormat": [[4, 30]]}}}, {"text": "For #1, I'd use Collectors.groupingBy along with Collectors.counting", "label": {"api": {"Collectors.groupingBy": [[16, 36]], "Collectors.counting": [[49, 67]]}}}, {"text": "Instead, I'd use the Map.computeIfAbsent operation (introduced in Java 8)", "label": {"api": {"Map.computeIfAbsent": [[21, 39]]}}}, {"text": "For #3, I'd again use Collectors.groupingBy along with Collectors.counting, but I'd use a composite key to group by", "label": {"api": {"Collectors.groupingBy": [[22, 42]], "Collectors.counting": [[55, 73]]}}}, {"text": "As it says in the documentation of getSuperclass()", "label": {"api": {"in the documentation of getSuperclass()": [[11, 49]]}}}, {"text": "That method getSuperClass says", "label": {"api": {"getSuperClass": [[12, 24]]}}}, {"text": "To gather information about implemented (or extended) interfaces, use getInterfaces", "label": {"api": {"getInterfaces": [[70, 82]]}}}, {"text": "The equivalent class for that in Java is LocalDate", "label": {"api": {"LocalDate": [[41, 49]]}}}, {"text": "LocalDate is an immutable date-time object that represents a date, often viewed as year-month-day", "label": {"api": {"LocalDate": [[0, 8]]}}}, {"text": "For example, the value \"2nd October 2007\" can be stored in a LocalDate", "label": {"api": {"LocalDate": [[61, 69]]}}}, {"text": "In Java, it can be represented with Instant or OffsetDateTime", "label": {"api": {"Instant": [[36, 42]], "OffsetDateTime": [[47, 60]]}}}, {"text": "From the Javadoc of Map.put", "label": {"api": {"Javadoc of Map.put": [[9, 26]]}}}, {"text": "For example, in the Java Stream class, any time a method returns a Stream, this is happening", "label": {"api": {"Stream": [[25, 30], [67, 72]]}}}, {"text": "This is because Stream implements BaseStream", "label": {"api": {"Stream": [[16, 21], [38, 43]], "BaseStream": [[34, 43]]}}}, {"text": "From the documentation of that method", "label": {"api": {"the documentation of that method": [[5, 36]]}}}, {"text": "Use ZonedDateTime.parse to parse the time you are receiving", "label": {"api": {"ZonedDateTime.parse": [[4, 22]]}}}, {"text": "The second parameter for method printf is an array of Object", "label": {"api": {"printf": [[32, 37]]}}}, {"text": "Hence the message that there is no printf method that takes two parameters where the first is a String and the second is an int", "label": {"api": {"printf": [[35, 40]]}}}, {"text": "Create an Integer from the value returned by message.get_counter() and use that as the second argument when you call method printf, i.e", "label": {"api": {"printf": [[124, 129]]}}}, {"text": "Alternatively, you could use method println instead of printf, as in..", "label": {"api": {"printf": [[55, 60]]}}}, {"text": "Because Arrays#asList returns the fixed-size List backed by the array", "label": {"api": {"Arrays#asList": [[8, 20]]}}}, {"text": "Here is the doc of Arrays#asList", "label": {"api": {"Arrays#asList": [[19, 31]]}}}, {"text": "First, consult the documentation of ProgressMonitorInputStream", "label": {"api": {"the documentation of ProgressMonitorInputStream": [[15, 61]], "ProgressMonitor": [[36, 50]]}}}, {"text": "The ProgressMonitor’s maximum should be the size of the download, which you can obtain from the getContentLength() method of URLConnection", "label": {"api": {"ProgressMonitor": [[4, 18]], "getContentLength()": [[96, 113]]}}}, {"text": "You can use Files.copy for that", "label": {"api": {"Files.copy": [[12, 21]]}}}, {"text": "You need to use another variant of Collectors.toMap such that you pass the merge function and supplier to collect as a TreeMap there", "label": {"api": {"Collectors.toMap": [[35, 50]]}}}, {"text": "An alternate way could be determining all the possible headers before completing the build chain for the HttpRequest and using them with HttpRequest.Builder#headers as", "label": {"api": {"HttpRequest.Builder#headers": [[137, 163]]}}}, {"text": "You can do it yourself using AWT/Swing (for example, Canvas) or exploit third-party library (like JFreeChart)", "label": {"api": {"Canvas": [[53, 58]]}}}, {"text": "Then create File object for each directory name and use File#exists() api to check and create new file if not exists", "label": {"api": {"File#exists()": [[56, 68]]}}}, {"text": "It seems you're looking for Files.html#createDirectories, for example", "label": {"api": {"Files.html#createDirectories": [[28, 55]]}}}, {"text": "For the fixed-delay execution of some code you want to use a timer object, in this case javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[88, 104]]}}}, {"text": "What you need to do is call flatMap on the stream returned by data.stream(), with the function argument being List::stream (or Collection::stream)", "label": {"api": {"flatMap": [[28, 34]]}}}, {"text": "I think the correct data structure would be a Map", "label": {"api": {"Map": [[46, 48]]}}}, {"text": "The Map key would be Integer (since the key cannot be a primitive, so it cannot be int) which would be the index of the letter, and the value would be a List of the words that have the relevant letter at that index", "label": {"api": {"Map": [[4, 6]], "List": [[153, 156]]}}}, {"text": "But of course there is Collections.sort which is able sorting a given List using given Comparator", "label": {"api": {"Collections.sort": [[23, 38]]}}}, {"text": "You can use a StringBuilder", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "Yes, you can allocate a StringBuilder with enough room for the whole result, and then use its append to append the pieces, converting to string when you're done with toString", "label": {"api": {"StringBuilder": [[24, 36]]}}}, {"text": "Be sure you don't put any user-derived information in the SQL via StringBuilder or other string-combining methods", "label": {"api": {"StringBuilder": [[66, 78]]}}}, {"text": "Use computeIfAbsent to return the existing instance if the key already exists or create a new one if it doesn't", "label": {"api": {"computeIfAbsent": [[4, 18]]}}}, {"text": "A ConcurrentMap ensures thread safety", "label": {"api": {"ConcurrentMap": [[2, 14]]}}}, {"text": "If you insist of using JTextField, I suggest you to take the DocumentFilter approach, mostly described in this question", "label": {"api": {"DocumentFilter": [[61, 74]]}}}, {"text": "Why don't you use the built-in Integer#parseInt(s, radix) method", "label": {"api": {"Integer#parseInt(s, radix)": [[31, 56]]}}}, {"text": "You can use the JSONObject class to do the operations you need", "label": {"api": {"JSONObject class": [[16, 31]]}}}, {"text": "You can initialize a new ObservableSet object and addAll your list, which takes any kind of collection", "label": {"api": {"addAll": [[50, 55]]}}}, {"text": "From StackWalker docs", "label": {"api": {"StackWalker": [[5, 15]]}}}, {"text": "If you want have access to each stack element of you exception's stack trace - use Throwable::getStackTrace which returns array of StackTraceElement", "label": {"api": {"Throwable::getStackTrace": [[83, 106]]}}}, {"text": "If you want only to print it Throwable::printStackTrace should be enough", "label": {"api": {"Throwable::printStackTrace": [[29, 54]]}}}, {"text": "The approach that you show (using Class.cast) does work, but has the overhead of handling an exception", "label": {"api": {"Class.cast": [[34, 43]]}}}, {"text": "A clearer and more concise way of doing this is using the Class.isInstance method", "label": {"api": {"Class.isInstance": [[58, 73]]}}}, {"text": "I assume that your professor wants you to change counter to an AtomicInteger", "label": {"api": {"AtomicInteger": [[63, 75]]}}}, {"text": "First you want to import AtomicInteger as well as change the declaration of counter and the constructor to reflect that", "label": {"api": {"AtomicInteger": [[25, 37]]}}}, {"text": "Also, you want to change the increaseVehicleCount and decreaseVehicleCount methods in order to use AtomicInteger instead of int", "label": {"api": {"AtomicInteger": [[99, 111]]}}}, {"text": "incrementAndGet as well as decrementAndGet do just as they say", "label": {"api": {"incrementAndGet": [[0, 14]], "decrementAndGet": [[27, 41]]}}}, {"text": "I am trying to implement a SdkAsyncHttpClient that uses Java 11's java.net.http.HttpClient (specifically sendAsync)", "label": {"api": {"java.net.http.HttpClient": [[66, 89]]}}}, {"text": "You can use DoubleSummaryStatistics for both the max and min of your value attribute", "label": {"api": {"DoubleSummaryStatistics": [[12, 34]]}}}, {"text": "Since Java 8, you should avoid using Date", "label": {"api": {"Date": [[37, 40]]}}}, {"text": "According to your question, a suitable replacement for Date would be LocalDate, which is expected to be in the format yyyy-MM-dd", "label": {"api": {"Date": [[55, 58], [74, 77]], "LocalDate": [[69, 77]]}}}, {"text": "And also I would discourage to use Pair class form JavaFX for this purpose and use AbstractMap.SimpleEntry for example", "label": {"api": {"AbstractMap.SimpleEntry": [[83, 105]]}}}, {"text": "Here's the java doc to back this up (https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_EVEN)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html#HALF_EVEN": [[37, 115]]}}}, {"text": "It also seems like this should be possible, seeing as spring-websocket uses the Java WebSocket API under the hood, and they allow MessageHandlers to handle InputStreams (see https://docs.oracle.com/javaee/7/api/javax/websocket/MessageHandler.Whole.html)", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/websocket/MessageHandler.Whole.html": [[174, 251]]}}}, {"text": "Integer class does implement Comparable", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "You want a Map", "label": {"api": {"Map": [[11, 13]]}}}, {"text": "A common (probably the most common) implementation of Map is HashMap", "label": {"api": {"Map": [[54, 56], [65, 67]], "HashMap": [[61, 67]]}}}, {"text": "Map<Boolean, BufferedImage>> is a little hard to follow", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "If you look up the Javadoc for DecimalFormat, you'll see that it extends NumberFormat", "label": {"api": {"Javadoc for DecimalFormat": [[19, 43]]}}}, {"text": "You could also call NumberFormat.getNumberInstance() and store the result using one of the interfaces that NumberFormat implements (you can see those in the Javadoc)", "label": {"api": {"in the Javadoc": [[150, 163]]}}}, {"text": "new FileOutputStream(filepath + fileName) will only throw FileNotFoundException if the specified path is a directory or if a security manager prevents you from writing to that path, as specified in the documentation", "label": {"api": {"as specified in the documentation": [[182, 214]]}}}, {"text": "Just use regex and String#toLowerCase", "label": {"api": {"String#toLowerCase": [[19, 36]]}}}, {"text": "Pay attention to default close operation you apply to your top-level JFrame or JDialog", "label": {"api": {"default close operation": [[17, 39]]}}}, {"text": "It's unclear where you have imported @CreateTimestamp and @UpdateTimestamp from", "label": {"api": {"Timestamp": [[44, 52], [65, 73]]}}}, {"text": "However, as you seem to be using Spring, you could use @CreatedDate and @LastModifiedDate from Spring Data", "label": {"api": {"Date": [[63, 66], [85, 88]]}}}, {"text": "Apart from it, since Java 8, with the introduction of the new Date and Time API, you should avoid using Date and related classes such as Timestamp", "label": {"api": {"Date": [[62, 65], [104, 107]], "Timestamp": [[137, 145]]}}}, {"text": "A suitable replacement for Timestamp, in your situation, would be Instant or OffsetDateTime", "label": {"api": {"Date": [[83, 86]], "Timestamp": [[27, 35]], "Instant": [[66, 72]], "OffsetDateTime": [[77, 90]]}}}, {"text": "You may want to check CountDownLatch for this purpose", "label": {"api": {"CountDownLatch": [[22, 35]]}}}, {"text": "This uses Map.computeIfAbsent to group regions of ReleaseTime objects by start and end dates", "label": {"api": {"Map.computeIfAbsent": [[10, 28]]}}}, {"text": "getTitle() method will give a window title String", "label": {"api": {"getTitle()": [[0, 9]]}}}, {"text": "I'm using introspection through getDeclaredFields() which means I can't assume a specific type for the field, so I can't use an annotation like", "label": {"api": {"getDeclaredFields()": [[32, 50]]}}}, {"text": "Then instead of having a difficult to debug test failure, you will get an AssertionError or AssumptionViolatedException or TestAbortedException that more clearly points towards the cause of the problem", "label": {"api": {"AssertionError": [[74, 87]]}}}, {"text": "A ConcurrentLinkedQueue will do a similar same job without locking, there you'd want to sleep, bot only when no item is available, rather than after every item", "label": {"api": {"ConcurrentLinkedQueue": [[2, 22]]}}}, {"text": "After you have sorted your arrays values1 and values2 you can use the equals function of Arrays (like you already did)", "label": {"api": {"Arrays": [[89, 94]]}}}, {"text": "Or should I adapt all the code to use Java 11 java.net.http", "label": {"api": {"Java 11 java.net.http": [[38, 58]]}}}, {"text": "I would go with java.time.LocalDate and java.time.Period class", "label": {"api": {"java.time.LocalDate": [[16, 34]], "java.time.Period": [[40, 55]]}}}, {"text": "But as you can see in the java.util.function package, which contains interfaces for various number of type parameters, Java does not support this yet and there are no plans to do so", "label": {"api": {"java.util.function": [[26, 43]]}}}, {"text": "Remove all use of p.getInputStream(), and replace it with a call to inheritIO()", "label": {"api": {"inheritIO()": [[68, 78]]}}}, {"text": "inheritIO() will cause both the standard output and the standard error of the child process to appear in the Java process's own standard output and standard error", "label": {"api": {"inheritIO()": [[0, 10]]}}}, {"text": "The copy constructor you are using is described in the API as", "label": {"api": {"the API": [[51, 57]]}}}, {"text": "One option would be to use a ExecutorService provided by the JDK, which can execute Runnable and Callable tasks", "label": {"api": {"ExecutorService": [[29, 43]]}}}, {"text": "You will need to create a class that implements Runnable, which will execute your Python script, and after receiving a new document, you need to create a new instance of this class and pass it to the ExecutorService", "label": {"api": {"ExecutorService": [[200, 214]]}}}, {"text": "Then we create main method that creates ExecutorService with a fixed number of parallel threads in the amount of 5 and pass 10 instances of ScriptRunner to it with interruptions of 1 second", "label": {"api": {"ExecutorService": [[40, 54]]}}}, {"text": "I see Thread() takes both Runnable and String for single argument constructors", "label": {"api": {"Thread()": [[6, 13]]}}}, {"text": "The List interface supports the contains() method", "label": {"api": {"contains()": [[32, 41]]}}}, {"text": "For a cert in a file (or anything that can be accessed as a Stream) in either PEM or DER format (although the javadoc isn't clear on that) all you need is CertificateFactory", "label": {"api": {"CertificateFactory": [[155, 172]]}}}, {"text": "Although JCA APIs like this one are defined to allow a lot of extension,  reading an X.509 cert will actually give you not just Certificate but subclass X509Certificate from which .getNotAfter() gives the expiration date-time directly", "label": {"api": {"X509Certificate": [[153, 167]]}}}, {"text": "If you use at least Java 9, you can apply takeWhile(Objects::nonNull) on your stream", "label": {"api": {"takeWhile(Objects::nonNull)": [[42, 68]]}}}, {"text": "If we assume the first approach, you can use the getRGB method of BufferedImage to retrieve the values", "label": {"api": {"getRGB method of BufferedImage": [[49, 78]]}}}, {"text": "You can use setRGB to convert the bytes back to an image", "label": {"api": {"setRGB": [[12, 17]]}}}, {"text": "The implementation is a ThreadPoolExecutor which lets threads exit when they are unused (look for \"Keep-alive times\" in its docs)", "label": {"api": {"its docs": [[120, 127]]}}}, {"text": "As documented, the BigDecimal(double) is unpredictable", "label": {"api": {"BigDecimal(double)": [[19, 36]]}}}, {"text": "This is generally the preferred way to convert a float or double into a BigDecimal, as it doesn't suffer from the unpredictability of the BigDecimal(double) constructor", "label": {"api": {"BigDecimal(double)": [[138, 155]]}}}, {"text": "Also note, in the below code, that method getValue() in class CellDataFeatures returns a Part object", "label": {"api": {"getValue()": [[42, 51]]}}}, {"text": "The javadoc of reduce says", "label": {"api": {"reduce": [[15, 20]]}}}, {"text": "Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value", "label": {"api": {"reduce": [[145, 150]]}}}, {"text": "If you want to see which tools are included you can check out this link https://docs.oracle.com/javase/7/docs/api/", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/": [[72, 113]]}}}, {"text": "I need to track a few formats (DateTimeFormatter objects) for repeated use in my app", "label": {"api": {"DateTimeFormatter": [[31, 47]]}}}, {"text": "The return value of subSequence() is a CharSequence which is not a String", "label": {"api": {"subSequence()": [[20, 32]], "CharSequence": [[39, 50]]}}}, {"text": "Since you are starting from an array of characters – char [] – you could use Arrays.copyOfRange() to create a new array of some smaller subset of charArray, like this", "label": {"api": {"Arrays.copyOfRange()": [[77, 96]]}}}, {"text": "They implementation is going to throw UnsupportedOperationException and nothing else", "label": {"api": {"UnsupportedOperationException": [[38, 66]]}}}, {"text": "But for a simple flag, the easiest approach is probably a Semaphore", "label": {"api": {"Semaphore": [[58, 66]]}}}, {"text": "But Semaphore does require you to plan your logic correctly, otherwise you could end up in a deadlock", "label": {"api": {"Semaphore": [[4, 12]]}}}, {"text": "The above code could be better implemented with for example Exchanger", "label": {"api": {"Exchanger": [[60, 68]]}}}, {"text": "You can use ExecutorService.submit(Callable task) and then call Future.get(long timeout, TimeUnit unit) on the result", "label": {"api": {"ExecutorService.submit(Callable task)": [[12, 48]], "Future.get(long timeout, TimeUnit unit)": [[64, 102]]}}}, {"text": "Java 8's CompletableFuture.allOf(CompletableFuture<?>...cfs) will return a CompletableFuture that is completed when all the given futures complete, or throws a CompletionException if one of the futures completes with an exception", "label": {"api": {"CompletableFuture.allOf(CompletableFuture<?>...cfs)": [[9, 59]]}}}, {"text": "you could try to use Base64.Decoder#wrap", "label": {"api": {"Base64.Decoder#wrap": [[21, 39]]}}}, {"text": "For that reason, you should use LocalDate in conjunction with LocalDate#atTime (to get a LocalDateTime object) and LocalDateTime#atZone (with ZoneOffset.UTC to get a ZonedDateTime)", "label": {"api": {"LocalDate": [[32, 40], [62, 70], [89, 97], [115, 123]], "LocalDate#atTime": [[62, 77]], "LocalDateTime#atZone": [[115, 134]]}}}, {"text": "See the Javadoc for String", "label": {"api": {"the Javadoc for String": [[4, 25]]}}}, {"text": "I want the contents of a plain text file on the web browser’s machine to load into memory as a String or CharSequence on the server machine", "label": {"api": {"String": [[95, 100]], "CharSequence": [[105, 116]]}}}, {"text": "We use an InputStream to manage the flow of arriving octets", "label": {"api": {"InputStream": [[10, 20]]}}}, {"text": "Our InputStream reads each octet as an int with a value in the range from 0-255 inclusive", "label": {"api": {"InputStream": [[4, 14]]}}}, {"text": "We use try-with-resources syntax to automatically close the InputStream that loads bytes from the client to the server", "label": {"api": {"InputStream": [[60, 70]], "automatically close": [[36, 54]]}}}, {"text": "We collect the arriving octets in a ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[36, 56]]}}}, {"text": "That library has a convenience method for taking an InputStream and producing a String", "label": {"api": {"InputStream": [[52, 62]]}}}, {"text": "However, you can abstract out this locking into the data structure itself by using a concurrent version", "label": {"api": {"concurrent": [[85, 94]]}}}, {"text": "As pointed out in the comments, take a look at Collectors.joining", "label": {"api": {"Collectors.joining": [[47, 64]]}}}, {"text": "The compareTo() method needs to return a -1, 0 1", "label": {"api": {"The compareTo() method needs to return a -1, 0 1": [[0, 47]]}}}, {"text": "If your requirement is to enable concurrent access to the collection, then you should explore java concurrency APIs and especially ConcurrentHashMap or ConcurrentSkipListMap for your case", "label": {"api": {"ConcurrentHashMap": [[131, 147]], "ConcurrentSkipListMap": [[152, 172]]}}}, {"text": "You can use AtomicIntegerArray instead, although if you explain your root problem, there may be a more suitable class to use", "label": {"api": {"AtomicIntegerArray": [[12, 29]]}}}, {"text": "By loading a DLL using Java's System#loadLibrary, I only get a long negative exit code such as -1073741515 instead of a Windows error message stating which DLL is missing", "label": {"api": {"System#loadLibrary": [[30, 47]]}}}, {"text": "If you don't care about losing precision in some cases, you could define the type of the parameters to be Number and then call doubleValue and/ or longValue before doing the addition", "label": {"api": {"Number": [[106, 111]]}}}, {"text": "Since foods is an ArrayList you can just use the add(int, E) method to add an element at the beginning, like this", "label": {"api": {"add(int, E)": [[49, 59]]}}}, {"text": "If you have such large numbers you can't use ints and longs, you will have to use BigInteger which already defines an isProbablePrime method for you", "label": {"api": {"BigInteger": [[82, 91]]}}}, {"text": "However you could have control over task completion by using ExecutorsCompletionService for your parallel processing", "label": {"api": {"ExecutorsCompletionService": [[61, 86]]}}}, {"text": "You could use a simple forEach with List#replaceAll to update your existing collection such as", "label": {"api": {"List#replaceAll": [[36, 50]]}}}, {"text": "To sort a Map by key, use a TreeMap", "label": {"api": {"Map": [[10, 12], [32, 34]], "TreeMap": [[28, 34]]}}}, {"text": "The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used", "label": {"api": {"Comparator": [[73, 82]], "constructor": [[134, 144]]}}}, {"text": "Since XMLGregorianCalendar doesn't implement Comparable, i.e", "label": {"api": {"XMLGregorianCalendar": [[6, 25]], "Comparable": [[45, 54]]}}}, {"text": "doesn't have a natural ordering, you have to specify a Comparator in the constructor", "label": {"api": {"Comparator": [[55, 64]], "constructor": [[73, 83]]}}}, {"text": "That is because they are defined as final in the Enum class, which implicitly is the base class of all enum types", "label": {"api": {"Enum": [[49, 52]]}}}, {"text": "Since Stack#push method returns an Integer here", "label": {"api": {"Stack#push": [[6, 15]]}}}, {"text": "The documentation of Statement.executeBatch() is not clear on this, but I assume that calling it will empty the Statement object's current list of SQL commands in the same way as clearBatch() does", "label": {"api": {"Statement.executeBatch()": [[21, 44]], "clearBatch()": [[179, 190]]}}}, {"text": "I'm also assuming the same is true for PreparedStatement", "label": {"api": {"PreparedStatement": [[39, 55]]}}}, {"text": "I suppose it is possible to continue using the Statement after calling Statement.executeBatch(), i.e", "label": {"api": {"Statement.executeBatch()": [[71, 94]]}}}, {"text": "Unfortunately, file1() closes the PrintWriter, so when file2() runs, all the pw.println(...) calls fails silently", "label": {"api": {"PrintWriter": [[34, 44]]}}}, {"text": "See javadoc of PrintWriter", "label": {"api": {"PrintWriter": [[15, 25]]}}}, {"text": "The client may inquire as to whether any errors have occurred by invoking checkError()", "label": {"api": {"checkError()": [[74, 85]]}}}, {"text": "If, for some reason, you still want to do this in parallel, then you can use Arrays#parallelSetAll", "label": {"api": {"Arrays#parallelSetAll": [[77, 97]]}}}, {"text": "You can use CopyOnWriteArrayLists, but they are very expensive to write, you can also create a Syncronized Collection, which are not so expensive to write, and you can also work with Queues, it will depend on what you want to achieve", "label": {"api": {"CopyOnWriteArrayLists": [[12, 32]], "Syncronized Collection": [[95, 116]]}}}, {"text": "I think you could use ConcurrentHashMap::computeIfPresent in this case assuming that the same List instances are not put for the same keys", "label": {"api": {"ConcurrentHashMap::computeIfPresent": [[22, 56]]}}}, {"text": "Because ScheduledExecutorService#scheduleAtFixedRate is called, and as the documentation says (bolded is mine)", "label": {"api": {"ScheduledExecutorService#scheduleAtFixedRate": [[8, 51]]}}}, {"text": "Therefore, I guess you can use java.util.Arrays (since Java 8)", "label": {"api": {"Java 8": [[55, 60]]}}}, {"text": "You'd probably be better off using StreamTokenizer, with quoteChar('\"')", "label": {"api": {"StreamTokenizer": [[35, 49]]}}}, {"text": "Java's String and StringBuilder are limited to a length of Integer.MAX_VALUE", "label": {"api": {"StringBuilder": [[18, 30]]}}}, {"text": "What I can do at most is replace a method in an existing module, or introduce a new class that replaces String and StringBuilder in that method", "label": {"api": {"StringBuilder": [[115, 127]]}}}, {"text": "As a temporary workaround, to prevent the OutOfMemory exception thrown when the StringBuilder length exceeds Integer.MAX_VALUE, I implemented the follow safeAppend()", "label": {"api": {"StringBuilder": [[80, 92]]}}}, {"text": "What is a recommended approach to implementing a String and StringBuilder that are NOT limited by an int max size", "label": {"api": {"StringBuilder": [[60, 72]]}}}, {"text": "Also, a single LimitlessString class that can be appended efficiently like StringBuilder is also adequate", "label": {"api": {"StringBuilder": [[75, 87]]}}}, {"text": "Use JTextPane instead", "label": {"api": {"JTextPane": [[4, 12]]}}}, {"text": "As for your font and color menu actions, use the JTextPane’s getStyledDocument() method", "label": {"api": {"JTextPane": [[49, 57]], "getStyledDocument()": [[61, 79]]}}}, {"text": "Among them is SimpleAttributeSet, which is sufficient for your needs", "label": {"api": {"SimpleAttributeSet": [[14, 31]]}}}, {"text": "Rather than setting its attributes directly, use the methods of StyleConstants", "label": {"api": {"StyleConstants": [[64, 77]]}}}, {"text": "Printing is as simple as calling the inherited print() method", "label": {"api": {"print()": [[47, 53]]}}}, {"text": "You can convert a MouseEvent’s coordinates so they’re relative to another component, like a JFrame, using SwingUtilities.convertMouseEvent", "label": {"api": {"SwingUtilities.convertMouseEvent": [[106, 137]]}}}, {"text": "If you know something is an array, but may be a primitive array (like int[]), use the java.lang.reflect.Array class to access it", "label": {"api": {"java.lang.reflect.Array": [[86, 108]]}}}, {"text": "You can't concisely get an Object[] from your Object, but you can trivially turn it into a List<Object>, by implementing AbstractList", "label": {"api": {"AbstractList": [[121, 132]]}}}, {"text": "It's a lambda expression for the Comparable interface", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "The flag is just the value the compareTo method normally returns", "label": {"api": {"compareTo": [[31, 39]]}}}, {"text": "To convert a char to a String, use the method Character.toString(char)", "label": {"api": {"Character.toString(char)": [[46, 69]]}}}, {"text": "When you do odtSummer.toLocalDateTime(), you're discarding the fact that the input date/time is UTC, so you've lost the information right there", "label": {"api": {"toLocalDateTime()": [[22, 38]]}}}, {"text": "Instead, convert the OffsetDateTime to a ZonedDateTime the desired time zone, by calling atZoneSameInstant(zoneId)", "label": {"api": {"atZoneSameInstant(zoneId)": [[89, 113]]}}}, {"text": "Then get the LocalDateTime from that, by calling toLocalDateTime()", "label": {"api": {"toLocalDateTime()": [[49, 65]]}}}, {"text": "Use ZoneId.systemDefault() to get default time zone, not TimeZone.getDefault().toZoneId()", "label": {"api": {"ZoneId.systemDefault()": [[4, 25]]}}}, {"text": "The documentation for MulticastSocket doesn't say it's threadsafe, so you can't assume it's threadsafe", "label": {"api": {"documentation for MulticastSocket": [[4, 36]]}}}, {"text": "There is no need to call Files.walk on the matched source files", "label": {"api": {"Files.walk": [[25, 34]]}}}, {"text": "Additionally instead of calling File.listFiles() recursively you can use Files.walk or even better Files.find", "label": {"api": {"Files.walk": [[73, 82]], "Files.find": [[99, 108]]}}}, {"text": "The default model for JTextField is PlainDocument, however JTextField code actually refers to the Document interface which PlainDocument implements", "label": {"api": {"PlainDocument": [[36, 48], [123, 135]]}}}, {"text": "Apart from DocumentFilter or JFormattedTextField (or even InputVerifier), you can add an ActionListener to JTextField which will execute when you hit Enter in the JTextField", "label": {"api": {"DocumentFilter": [[11, 24]], "JFormattedTextField": [[29, 47]], "InputVerifier": [[58, 70]], "add": [[82, 84]]}}}, {"text": "And clone will throw a CloneNotSupportedException if called on a object that hasn't overriden it", "label": {"api": {"if called on a object that hasn't overriden it": [[50, 95]]}}}, {"text": "Here's the description of the default behavior of clone() when the class implements Cloneable but does not override clone()", "label": {"api": {"default behavior of clone()": [[30, 56]]}}}, {"text": "Use Character.compare(character, t.character)", "label": {"api": {"Character.compare(character, t.character)": [[4, 44]]}}}, {"text": "You can use BufferedReader", "label": {"api": {"BufferedReader": [[12, 25]]}}}, {"text": "Just as you use getDeclaredMethod() to invoke (private) method m1(), you can call method getDeclaredConstructor() to get a reference to the private constructor", "label": {"api": {"getDeclaredConstructor()": [[89, 112]]}}}, {"text": "To ensure a correct ordering; the compareTo method needs to satisfy the contract specified by the Comparable interface", "label": {"api": {"contract": [[72, 79]]}}}, {"text": "Unfortunately, there is no way to extend Person; overriding compareTo in Employee to compare the salary while preserving the contract", "label": {"api": {"contract": [[125, 132]]}}}, {"text": "Take a look at Lock and Condition if you want to implement thread-safe queue-like structures", "label": {"api": {"Lock": [[15, 18]], "Condition": [[24, 32]]}}}, {"text": "The third point is, that instead of using an empty while construct, you should use Thread.onSpinWait", "label": {"api": {"Thread.onSpinWait": [[83, 99]]}}}, {"text": "A LinkedHashMap can be iterated over in the same order you inserted the entries in", "label": {"api": {"LinkedHashMap": [[2, 14]]}}}, {"text": "You could use CompleteableFuture to divide up each non-CPU-bound step", "label": {"api": {"CompleteableFuture": [[14, 31]]}}}, {"text": "The Scanner.nextInt method does not read the newline character when you press the \"Enter\" key, hence Scanner.nextLine returns right after reading that newline", "label": {"api": {"Scanner.nextInt": [[4, 18]]}}}, {"text": "To solve it, you can call Scanner.nextLine after each Scanner.nextInt to consume the pending newline", "label": {"api": {"Scanner.nextInt": [[54, 68]]}}}, {"text": "You could read the file line wise using a BufferedReader", "label": {"api": {"BufferedReader": [[42, 55]]}}}, {"text": "If I have a java.awt.Image object in hand, how can I get a byte array of the image data", "label": {"api": {"java.awt.Image": [[12, 25]]}}}, {"text": "If I had the subclass BufferedImage I could do this", "label": {"api": {"BufferedImage": [[22, 34]]}}}, {"text": "…where ImageIO.write takes an RenderedImage — an interface implemented by BufferedImage but not implemented by its superclass java.awt.Image", "label": {"api": {"java.awt.Image": [[126, 139]], "BufferedImage": [[74, 86]], "ImageIO.write": [[7, 19]], "RenderedImage": [[30, 42]]}}}, {"text": "Unfortunately, I do not have a BufferedImage or RenderedImage", "label": {"api": {"BufferedImage": [[31, 43]], "RenderedImage": [[48, 60]]}}}, {"text": "After having called getScaledInstance on my original BufferedImage object to get a reduced thumbnail image, I have only a java.awt.Image object in hand", "label": {"api": {"java.awt.Image": [[122, 135]], "BufferedImage": [[53, 65]], "getScaledInstance": [[20, 36]]}}}, {"text": "I am trying to get a byte array of the data in that java.awt.Image object", "label": {"api": {"java.awt.Image": [[52, 65]]}}}, {"text": "Java methods start with lower case valueOf", "label": {"api": {"valueOf": [[35, 41]]}}}, {"text": "The LocalDate class does exactly what you want", "label": {"api": {"LocalDate": [[4, 12]]}}}, {"text": "The current date can be obtained by LocalDate.now()", "label": {"api": {"LocalDate": [[36, 44]]}}}, {"text": "Looking at the implementation of the clear operation of ArrayDeque (which basically is just a circular array queue), you can see that it uses an O(n) approach through the following two operations", "label": {"api": {"ArrayDeque": [[56, 65]]}}}, {"text": "If you read the javadoc of StoredProcedureQuery, you will find", "label": {"api": {"StoredProcedureQuery": [[27, 46]]}}}, {"text": "j8+ java.util.Base64 provides the newer base64 variants (i.e", "label": {"api": {"java.util.Base64": [[4, 19]]}}}, {"text": "You need to use requestFocusInWindow() after you click on any operator (+,-,*,/,etc)", "label": {"api": {"requestFocusInWindow()": [[16, 37]]}}}, {"text": "PublicKey and PrivateKey are interfaces, as you can see from the linked documentation", "label": {"api": {"PublicKey": [[0, 8]], "PrivateKey": [[14, 23]]}}}, {"text": "The object is being created by KeyPairGenerator", "label": {"api": {"KeyPairGenerator": [[31, 46]]}}}, {"text": "The objects in the keypair will be instances of classes that implement the PublicKey and PrivateKey interfaces", "label": {"api": {"PublicKey": [[75, 83]], "PrivateKey": [[89, 98]]}}}, {"text": "Code in the KeyPairGenerator implementation being used will create objects in a similar way, ones that are instances of classes implementing PublicKey and PrivateKey", "label": {"api": {"PublicKey": [[141, 149]], "PrivateKey": [[155, 164]], "KeyPairGenerator": [[12, 27]]}}}, {"text": "You can use Stream API and Arrays#equals to write elegant 1 line checkIdentical", "label": {"api": {"Stream API": [[12, 21]], "Arrays#equals": [[27, 39]]}}}, {"text": "Your methodRef2 should be of type Supplier", "label": {"api": {"Supplier": [[34, 41]]}}}, {"text": "and methodRef4 should be of type Runnable", "label": {"api": {"Runnable": [[33, 40]]}}}, {"text": "You could use a Context object containing a ThreadLocal, with static access methods, that stores this kind of information", "label": {"api": {"ThreadLocal": [[44, 54]]}}}, {"text": "Clean the ThreadLocal after every Request was processed", "label": {"api": {"ThreadLocal": [[10, 20]]}}}, {"text": "One can use existing utility functions, Arrays.binarySearch, and System.arraycopy", "label": {"api": {"Arrays.binarySearch": [[40, 58]]}}}, {"text": "One option is an annotation processor", "label": {"api": {"annotation processor": [[17, 36]]}}}, {"text": "Note, however, that the annotation processor API does allow one to use the class of the annotation (e.g", "label": {"api": {"annotation processor": [[24, 43]]}}}, {"text": "You would then need to tell javac to use the annotation processor", "label": {"api": {"annotation processor": [[45, 64]]}}}, {"text": "Note you may not be able to enforce the use of your annotation processor", "label": {"api": {"annotation processor": [[52, 71]]}}}, {"text": "As far as I can tell, Paths.get and Path.of seem to do exactly the same thing, turning one or more strings into a Path object; the documentation https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html#get-java.lang.String-java.lang.String...- and https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Path.html#of(java.lang.String,java.lang.String...) use the same wording", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html#get-java.lang.String-java.lang.String...-": [[145, 252]], "https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Path.html#of(java.lang.String,java.lang.String...)": [[258, 382]]}}}, {"text": "java.util.Collections is a library class containing utility methods for dealing with Collection types", "label": {"api": {"java.util.Collections": [[0, 20]], "Collection": [[10, 19], [85, 94]]}}}, {"text": "Your first link shows an implementation of the binary search algorithm from scratch, while your second link shows how to use the utility method Collections.binarySearch, which saves writing your own implementation", "label": {"api": {"Collection": [[144, 153]]}}}, {"text": "For example, a variation of binary search can be used to find the first occurrence of the target number, or the smallest number greater than or equal to the target, but the Collections.binarySearch method cannot do either of these things, so you could have to write an implementation yourself", "label": {"api": {"Collection": [[173, 182]]}}}, {"text": "For guaranteed behavior, there needs to be synchronization, through volatile or AtomicBoolean for example", "label": {"api": {"AtomicBoolean": [[80, 92]]}}}, {"text": "You need to use PagedResultsControl", "label": {"api": {"PagedResultsControl": [[16, 34]]}}}, {"text": "You will have to change the declaration of context so it's an LdapContext, and you can pass the PagedResultsControl in the constructor of InitialLdapContext", "label": {"api": {"PagedResultsControl": [[96, 114]]}}}, {"text": "The producer is submitting tasks to an ExecutorCompletionService that does some fast processing and add the result to its internal completionQueue, an unbounded BlockingQueue", "label": {"api": {"ExecutorCompletionService": [[39, 63]], "BlockingQueue": [[161, 173]]}}}, {"text": "The interesting fact is that ExecutorCompletionService is using add method to output results in the queue and add doesn't block", "label": {"api": {"ExecutorCompletionService": [[29, 53]]}}}, {"text": "What if I have a slow consumer and I want the ExecutorCompletionService to block to avoid memory overflow", "label": {"api": {"ExecutorCompletionService": [[46, 70]]}}}, {"text": "Here is the relevant code in the ExecutorCompletionService class, with javadoc stating that the completionQueue should be treated as unbounded", "label": {"api": {"ExecutorCompletionService": [[33, 57]]}}}, {"text": "As a side note, there is a way to throttle the input into the ExecutorCompletionService if the task processing is slow", "label": {"api": {"ExecutorCompletionService": [[62, 86]]}}}, {"text": "What you could do is get the editor component of your cell(s) and if it's a subclass of JTextComponent, call JTextComponent.setCaretColor", "label": {"api": {"JTextComponent.setCaretColor": [[109, 136]]}}}, {"text": "As per Object.hashCode() javadoc", "label": {"api": {"Object.hashCode() javadoc": [[7, 31]]}}}, {"text": "If you can use CompletableFuture instead of plain Future you can use CompletableFuture.anyOf() method", "label": {"api": {"CompletableFuture": [[15, 31], [69, 85]]}}}, {"text": "Returns a new CompletableFuture that is completed when any of the given CompletableFutures complete, with the same result", "label": {"api": {"CompletableFuture": [[14, 30], [72, 88]]}}}, {"text": "I dont have experience with the Graphics class, but seems like fillOval() only draws circles, it does not apply for logarithmic functions", "label": {"api": {"fillOval()": [[63, 72]]}}}, {"text": "You can use the repeat method, so the code is less verbose, also enclosing the generation in a method you can make it dynamic bu setting two arguments", "label": {"api": {"repeat": [[16, 21]]}}}, {"text": "Another approach is to use @PostConstruct like below", "label": {"api": {"@PostConstruct": [[27, 40]]}}}, {"text": "You can use the static Map#entry method to create a single, unmodifiable instance of Map.Entry", "label": {"api": {"Map#entry": [[23, 31]]}}}, {"text": "You can't use ResultSet.equals for this, because that is not what the Object.equals contract is for", "label": {"api": {"Object.equals": [[70, 82]]}}}, {"text": "To represent larger numbers than this, you will need to use a different datatype, such as BigInteger, which allows arbitrarily large numbers", "label": {"api": {"BigInteger": [[90, 99]]}}}, {"text": "The constructor new BigInteger(String val) will parse a string as a BigInteger", "label": {"api": {"BigInteger": [[20, 29], [68, 77]]}}}, {"text": "To solve this problem you will need to use a datatype which can represent larger integers, such as long (up to about 19 digits) or BigInteger (arbitrarily large)", "label": {"api": {"BigInteger": [[131, 140]]}}}, {"text": "Use FileSystems to access, write and replace the contents of the jar file", "label": {"api": {"FileSystems": [[4, 14]]}}}, {"text": "From Thread:::isAlive docs", "label": {"api": {"Thread:::isAlive": [[5, 20]]}}}, {"text": "From the docs of Thread::start", "label": {"api": {"Thread::start": [[17, 29]]}}}, {"text": "Instead, for any kind of animation or long-heavy task (consider Thread.sleep as one), Swing Timers and Swing Workers should be used", "label": {"api": {"Swing Workers": [[103, 115]]}}}, {"text": "The problem is that the Scanner class by default uses space as a delimiter (from the class' Javadoc)", "label": {"api": {"from the class' Javadoc": [[76, 98]]}}}, {"text": "Instead, it receives an abstraction of the compiler’s model of the source code, see the java.compiler module for details", "label": {"api": {"the java.compiler module": [[84, 107]]}}}, {"text": "You call pack on the JFrame, which sizes components to their preferred sizes", "label": {"api": {"pack": [[9, 12]]}}}, {"text": "You want to use java.util.Arrays.equals(A, ex.getA())", "label": {"api": {"java.util.Arrays.equals(A, ex.getA())": [[16, 52]]}}}, {"text": "The Collectors.groupingBy stream Collector can help you here", "label": {"api": {"Collectors.groupingBy": [[4, 24]]}}}, {"text": "MultipleSelectionModel (link) extends SelectionModel (link), in which the selectedItemProperty() method is implemented", "label": {"api": {"link": [[24, 27], [54, 57]]}}}, {"text": "selectedItemProperty() returns a ReadOnlyObjectProperty (link) instance, which extends ObservableValue (link), from which the addListener() method is coming", "label": {"api": {"link": [[57, 60], [104, 107]]}}}, {"text": "Each call forwards the iterator to the next element", "label": {"api": {"forwards the iterator to the next element": [[10, 50]]}}}, {"text": "Originally I hoped that the TimestampResponseGenerator would automatically include the public certificate in the response if the request had setCertReq(true), but now my understanding is that I have to manually add them in the TimestampTokenGenerator using addCertificates(Store certStore)", "label": {"api": {"certStore": [[279, 287]]}}}, {"text": "However, I can only seem to get the certificate into a standard Java certStore, not a BouncyCastle Store, and I can't find a way to convert or create the Store object from scratch", "label": {"api": {"certStore": [[69, 77]]}}}, {"text": "This is explained in the ArrayList javadoc, you are modifying the list with remove() and set() while using an Iterator", "label": {"api": {"ArrayList": [[25, 33]]}}}, {"text": "By using LocalDateTime#of(LocalDate,LocalTime) you can create a LocalDateTime from a LocalDate and a LocalTime", "label": {"api": {"LocalDateTime#of(LocalDate,LocalTime)": [[9, 45]]}}}, {"text": "I'm working with Joda-Time's Duration", "label": {"api": {"Duration": [[29, 36]]}}}, {"text": "Is there an easy way to achieve the same functionality on the Java 8+ java.time Duration", "label": {"api": {"java.time": [[70, 78]], "Duration": [[80, 87]]}}}, {"text": "I'm assuming based on the code and comments that Duration::toMinutes will not necessarily return the desired value", "label": {"api": {"Duration": [[49, 56]], "Duration::toMinutes": [[49, 67]]}}}, {"text": "Do any of the same principles apply to handling ClosedChannelException from NIO calls, which can be a ClosedByInterruptException", "label": {"api": {"ClosedChannelException": [[48, 69]], "ClosedByInterruptException": [[102, 127]]}}}, {"text": "Here's what the documentation of ClosedByInterruptException says (emphasis mine)", "label": {"api": {"ClosedByInterruptException": [[33, 58]]}}}, {"text": "Also, the ClosedByInterruptException class and its superclass, AsynchronousCloseException, are associated with channels which implement InterruptibleChannel", "label": {"api": {"ClosedByInterruptException": [[10, 35]], "InterruptibleChannel": [[136, 155]]}}}, {"text": "This will cause the channel to be closed, the blocked thread to receive a ClosedByInterruptException, and the blocked thread's interrupt status to be set", "label": {"api": {"ClosedByInterruptException": [[74, 99]]}}}, {"text": "If a thread's interrupt status is already set and it invokes a blocking I/O operation upon a channel then the channel will be closed and the thread will immediately receive a ClosedByInterruptException; its interrupt status will remain set", "label": {"api": {"ClosedByInterruptException": [[175, 200]]}}}, {"text": "In other words, you do not need to call Thread.currentThread().interrupt() after catching a ClosedByInterruptException because the channel will have already set, or simply maintained, the interrupt status of the thread", "label": {"api": {"ClosedByInterruptException": [[92, 117]]}}}, {"text": "Integer objects are immutable so you don't need to deep copy them", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "ArrayList vs LinkedList, we can simply use the ArrayList(Collection) constructor to copy the inner lists", "label": {"api": {"ArrayList": [[0, 8], [47, 55]], "LinkedList": [[13, 22]], "ArrayList(Collection)": [[47, 67]]}}}, {"text": "A ValueRetriever can mean anything and we already have a DoubleSupplier", "label": {"api": {"DoubleSupplier": [[57, 70]]}}}, {"text": "In Java we have the constant Double.NaN, which according to the documentation is the same as Double.longBitsToDouble(0x7ff8000000000000L)", "label": {"api": {"Double.NaN": [[29, 38]], "Double.longBitsToDouble": [[93, 115]]}}}, {"text": "Your C++ conversion seems faulty, and also according to the docs of Double.longBitsToDouble there can be differences in the bit patterns returned, even if it's IEEE 754 compliant", "label": {"api": {"Double.longBitsToDouble": [[68, 90]]}}}, {"text": "It's part of the JavaFX Button definition", "label": {"api": {"part of the JavaFX Button definition": [[5, 40]]}}}, {"text": "ChronoUnits have a between method which returns the number of complete units between a start and end date/time", "label": {"api": {"a between method": [[17, 32]]}}}, {"text": "As suggested in the comments, Arrays.copyOfRange is a better alternative to the above because it takes care of out-of-bound index and negative ranges", "label": {"api": {"Arrays.copyOfRange": [[30, 47]]}}}, {"text": "First, you have the Comparable interface which roughly looks like", "label": {"api": {"Comparable": [[20, 29]]}}}, {"text": "As you can see, the type parameter of Comparable is used as the parameter of the compareTo method", "label": {"api": {"Comparable": [[38, 47]]}}}, {"text": "Typically, the type argument for T is the same class which is implementing the Comparable interface", "label": {"api": {"Comparable": [[79, 88]]}}}, {"text": "Used U as the type variable instead of T to show it is separate from the T used in the Comparable interface", "label": {"api": {"Comparable": [[87, 96]]}}}, {"text": "The type variable U is upper-bounded by Comparable<U>", "label": {"api": {"Comparable": [[40, 49]]}}}, {"text": "subtype of) Comparable<U>", "label": {"api": {"Comparable": [[12, 21]]}}}, {"text": "For instance, if we use Name as the type argument it will work because Name is assignable to Comparable<Name>", "label": {"api": {"Comparable": [[93, 102]]}}}, {"text": "The reason for specifying the upper-bound as Comparable<U> is that the method needs to call compareTo in order to function properly", "label": {"api": {"Comparable": [[45, 54]]}}}, {"text": "The difference being the use of Comparable<", "label": {"api": {"Comparable": [[32, 41]]}}}, {"text": "super U> as the upper-bound instead of Comparable<U>", "label": {"api": {"Comparable": [[39, 48]]}}}, {"text": "Explanation of generic <T extends Comparable<", "label": {"api": {"Comparable": [[34, 43]]}}}, {"text": "If you're using Java 9+ then CompletableFuture#delayedExecutor(long,TimeUnit) may fit your needs", "label": {"api": {"CompletableFuture#delayedExecutor(long,TimeUnit)": [[29, 76]]}}}, {"text": "There's also an overload where you can specify the Executor to use in place of the \"default executor\"", "label": {"api": {"an overload": [[13, 23]]}}}, {"text": "You can use Collection.sort(list) to sort your ArrayList but AnimSprite must implement the Comparable Interface to let the sort method to know how to compare two AnimSprite objects", "label": {"api": {"Collection.sort(list)": [[12, 32]], "Comparable": [[91, 100]]}}}, {"text": "From the documentation for this PriorityQueue constructor", "label": {"api": {"the documentation for this PriorityQueue constructor": [[5, 56]]}}}, {"text": "Looking at its documentation", "label": {"api": {"its documentation": [[11, 27]]}}}, {"text": "Am I misunderstanding the purpose of createStoredProcedureQuery", "label": {"api": {"createStoredProcedureQuery": [[37, 62]]}}}, {"text": "When executing this procedure without providing any result classes to createStoredProcedureQuery I get two lists both with Bean1 objects", "label": {"api": {"createStoredProcedureQuery": [[70, 95]]}}}, {"text": "You should use Optional.map() method", "label": {"api": {"Optional.map()": [[15, 28]]}}}, {"text": "You can use a HashSet to store the names of teams in such a manner that the check if a new name was already used happens very efficiently", "label": {"api": {"HashSet": [[14, 20]]}}}, {"text": "The great advantage of this approach is that the check if a name is already in a HashSet takes a constant time (O(1))", "label": {"api": {"HashSet": [[81, 87]]}}}, {"text": "To use getMethod, you must provide not just the name of the method you want to get, but also its argument types as Class<?> objects", "label": {"api": {"getMethod": [[7, 15]]}}}, {"text": "The String.length method takes no arguments, so no Class<?> arguments are needed in getMethod", "label": {"api": {"getMethod": [[84, 92]]}}}, {"text": "On the other hand, the List.get method takes an int argument, so we need to pass int.class as an argument to getMethod", "label": {"api": {"getMethod": [[109, 117]]}}}, {"text": "Hence, getMethod needs to  be called with two Object.class arguments", "label": {"api": {"getMethod": [[7, 15]]}}}, {"text": "And if you check the docs of PriorityQueue::iterator it returns iterator that returns elements in no particular order", "label": {"api": {"PriorityQueue::iterator": [[29, 51]]}}}, {"text": "You can call CompletableFuture::join to wait for it to finish and it will block the main Thread until it finishes", "label": {"api": {"CompletableFuture::join": [[13, 35]]}}}, {"text": "You are looking for filter", "label": {"api": {"filter": [[20, 25]]}}}, {"text": "see for example Collections.unmodifiableList", "label": {"api": {"Collections.unmodifiableList": [[16, 43]]}}}, {"text": "In the code below, accessing Random from multiple threads leads to both asserts failing", "label": {"api": {"Random": [[29, 34]]}}}, {"text": "Random is not thread safe so this was to be expected", "label": {"api": {"Random": [[0, 5]]}}}, {"text": "Utilizing SplittableRandom, I expected to get unique and consistent results (both asserts), doesn't work", "label": {"api": {"Random": [[20, 25]], "SplittableRandom": [[10, 25]]}}}, {"text": "Utilizing ThreadLocalRandom has no seed and so cannot provide consistent results", "label": {"api": {"Random": [[21, 26]], "ThreadLocalRandom": [[10, 26]]}}}, {"text": "This is the SplittableRandom code, expected it to be threadsafe - didn't work", "label": {"api": {"Random": [[22, 27]], "SplittableRandom": [[12, 27]]}}}, {"text": "You need to write your own Spliterator, something like this", "label": {"api": {"Spliterator": [[27, 37]]}}}, {"text": "Use String in @RequestBody, and use URLDecoder to decode in UTF-8", "label": {"api": {"URLDecoder": [[36, 45]]}}}, {"text": "Like this - URLDecoder.decode(value, StandardCharsets.UTF_8.toString())", "label": {"api": {"URLDecoder": [[12, 21]]}}}, {"text": "It´s a good practice to use the method invokeLater from SwingUtilities class", "label": {"api": {"SwingUtilities": [[56, 69]]}}}, {"text": "SwingUtilities.invokeLater takes a Runnable and invokes it in the UI thread later", "label": {"api": {"SwingUtilities": [[0, 13]]}}}, {"text": "In JDK 8 you have the Duration class where you can perform conversions between units of time", "label": {"api": {"Duration": [[22, 29]]}}}, {"text": "For instance, Java has a built-in HttpServer class", "label": {"api": {"HttpServer": [[34, 43]]}}}, {"text": "Put a wait condition before your print to synchronize your code, using ExecutorService.awaitTermination before printing out the resulting SortedMap", "label": {"api": {"ExecutorService.awaitTermination": [[71, 102]]}}}, {"text": "The javadocs are published (https://docs.oracle.com/en/java/javase/13/docs/api/jdk.httpserver/com/sun/net/httpserver/package-summary.html) and there are no visible caveats in the package summary to say that these APIs are intended for internal use only", "label": {"api": {"https://docs.oracle.com/en/java/javase/13/docs/api/jdk.httpserver/com/sun/net/httpserver/package-summary.html": [[28, 136]]}}}, {"text": "As the Overview page says", "label": {"api": {"Overview": [[7, 14]]}}}, {"text": "You could do that using System.nanoTime(), but there are some complications -- check out the note on the JavaDoc for more", "label": {"api": {"check out the note on the JavaDoc for more": [[79, 120]]}}}, {"text": "The Duration class has several useful methods you can use to interpret the result", "label": {"api": {"several useful methods": [[23, 44]]}}}, {"text": "I would use a OneToMany annotation implementation instead", "label": {"api": {"OneToMany": [[14, 22]]}}}, {"text": "As per JTable.doLayout() javadoc", "label": {"api": {"JTable.doLayout()": [[7, 23]]}}}, {"text": "You can see this behavior by setting the column manually with JTableHeader.setResizingColumn() with following code, it will auto-resize the last column", "label": {"api": {"JTableHeader.setResizingColumn()": [[62, 93]]}}}, {"text": "A clue that it's a bug is revealed in the setResizingColumn javadoc", "label": {"api": {"setResizingColumn javadoc": [[42, 66]]}}}, {"text": "You are reimplementing a java.util.concurrent.ArrayBlockingQueue with your Buffer", "label": {"api": {"java.util.concurrent.ArrayBlockingQueue": [[25, 63]]}}}, {"text": "The above indicates you're using java.time.Duration when you need to be using javafx.util.Duration", "label": {"api": {"java.time.Duration": [[33, 50]]}}}, {"text": "You definitely want to use Random.nextInt() to get a uniform distribution of your int", "label": {"api": {"Random.nextInt()": [[27, 42]]}}}, {"text": "There is Arrays.equals, and also Streams, which are designed for similar use cases as LINQ", "label": {"api": {"Arrays.equals": [[9, 21]], "Stream": [[33, 38]]}}}, {"text": "In this case, the Stream.anyMatch method is very similar to Any in LINQ", "label": {"api": {"Stream": [[18, 23]], "Stream.anyMatch": [[18, 32]]}}}, {"text": "Only if you know for sure that your program will never be used outside your own time zone, is it safe to use LocalDateTime", "label": {"api": {"LocalDateTime": [[109, 121]]}}}, {"text": "I receommend you use ZonedDateTime just in case", "label": {"api": {"ZonedDateTime": [[21, 33]]}}}, {"text": "In any case, using that LocalDateTime, the code for your logic as I have understood it is", "label": {"api": {"LocalDateTime": [[24, 36]]}}}, {"text": "The javadoc of sorted(Comparator) says", "label": {"api": {"sorted(Comparator)": [[15, 32]]}}}, {"text": "To delete the first 100 elements of a List, whether ArrayList, LinkedList, or any other kind of mutable list", "label": {"api": {"List": [[38, 41], [57, 60], [69, 72]], "ArrayList": [[52, 60]], "LinkedList": [[63, 72]]}}}, {"text": "This is documented in the javadoc of subList()", "label": {"api": {"List": [[40, 43]], "subList()": [[37, 45]]}}}, {"text": "Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list", "label": {"api": {"List": [[83, 86]]}}}, {"text": "See the Javadoc for the interface javax.mail.Part, which is implemented by class javax.mail.Message, for more information on setContent() and setText()", "label": {"api": {"the Javadoc for the interface javax.mail.Part": [[4, 48]]}}}, {"text": "There is a better solution - declare myarray as AtomicIntegerArray myarray;", "label": {"api": {"AtomicIntegerArray": [[48, 65]]}}}, {"text": "Updates to AtomicIntegerArray are always correctly synchronized; other threads are guaranteed to see them immediately and in the right order", "label": {"api": {"AtomicIntegerArray": [[11, 28]]}}}, {"text": "Using a stream would be an easy way to deal with this", "label": {"api": {"stream": [[8, 13]]}}}, {"text": "When passing a single arg to  ImageIcon that arg is both the filename and description", "label": {"api": {"ImageIcon": [[30, 38]]}}}, {"text": "See the documentation of paintIcon()", "label": {"api": {"documentation of paintIcon()": [[8, 35]]}}}, {"text": "Fill a DefaultListModel with the strings that match the search criteria", "label": {"api": {"DefaultListModel": [[7, 22]]}}}, {"text": "Create a new JList with the model of the previous step", "label": {"api": {"JList": [[13, 17]]}}}, {"text": "Pop a JOptionPane with the list of the previous step as its message", "label": {"api": {"JOptionPane": [[6, 16]]}}}, {"text": "Please check https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html for more information", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[13, 76]]}}}, {"text": "Fortunately, you can provide your own support, by specifying a PersistenceDelegate for each non-Java-bean class you plan to serialize", "label": {"api": {"specifying a PersistenceDelegate": [[50, 81]]}}}, {"text": "And two solutions using Stream API", "label": {"api": {"Stream API": [[24, 33]]}}}, {"text": "And since arrays don't override the hashCode() method from the Object class you will get the result from the Object.hashCode() method", "label": {"api": {"Object.hashCode()": [[109, 125]]}}}, {"text": "To fix this problem you use the Arrays.deepHashCode() method", "label": {"api": {"Arrays.deepHashCode()": [[32, 52]]}}}, {"text": "For System.exit() calls you can define and set your own SecurityManager", "label": {"api": {"SecurityManager": [[56, 70]]}}}, {"text": "The drawback of this solution is that you have to make sure that your application always runs with SecurityManager enabled", "label": {"api": {"SecurityManager": [[99, 113]]}}}, {"text": "A LinkedList is not synchornized, as highlighted in the documentation", "label": {"api": {"as highlighted in the documentation": [[34, 68]]}}}, {"text": "But that's not a perfect solution, see the API docs", "label": {"api": {"the API docs": [[39, 50]]}}}, {"text": "The answer to this comes straight from the documentation for the method", "label": {"api": {"the documentation for the method": [[39, 70]]}}}, {"text": "To have a text field accept a numeric entry, you should use a JFormattedTextField", "label": {"api": {"JFormattedTextField": [[62, 80]]}}}, {"text": "To make it check both a localized number format (one that uses commas) and also the java.lang syntax (like 1e5), you can create a NumberFormatter which does both", "label": {"api": {"NumberFormatter": [[130, 144]]}}}, {"text": "Let JFormattedTextField do the work of verifying the input", "label": {"api": {"JFormattedTextField": [[4, 22]]}}}, {"text": "It's documented in Map", "label": {"api": {"Map": [[19, 21]]}}}, {"text": "The mutable value problem affects other map/set implementations too (for example TreeMap/TreeSet)", "label": {"api": {"Map": [[85, 87]], "Set": [[93, 95]]}}}, {"text": "According to docs, you can use \"method\" to specify other kind of methods like PATCH, OPTIONS, TRACE, etc", "label": {"api": {"method": [[32, 37], [65, 70]]}}}, {"text": "Simple solution would be to use ClassLoader to obtain InputStream, and use InputStream to load the font", "label": {"api": {"ClassLoader": [[32, 42]]}}}, {"text": "As the specification says", "label": {"api": {"the specification": [[3, 19]]}}}, {"text": "See DateTimeFormatter Javadoc for more information", "label": {"api": {"DateTimeFormatter Javadoc": [[4, 28]]}}}, {"text": "Streams are basically sequence of elements supporting sequential and parallel aggregate operations", "label": {"api": {"sequence of elements supporting sequential and parallel aggregate operations": [[22, 97]]}}}, {"text": "In a now deleted comment I said to look into Optional#map(Function) but I now realize you should actually be using Optional#flatMap(Function), assuming the logging statements are not too important", "label": {"api": {"Optional#map(Function)": [[45, 66]], "Optional#flatMap(Function)": [[115, 140]], "map(Function)": [[54, 66]]}}}, {"text": "This method is similar to map(Function), but the mapping function is one whose result is already an Optional, and if invoked, flatMap does not wrap it within an additional Optional", "label": {"api": {"map(Function)": [[26, 38]]}}}, {"text": "You can use SimpleDateFormat with the following pattern", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "SimpleDateFormat may throw ParseException where argument is invalid", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "See section Manifest Attributes in Instrumentation's documentation for more details", "label": {"api": {"section Manifest Attributes in Instrumentation's documentation": [[4, 65]]}}}, {"text": "Use the groupingBy overload which takes a Supplier<M> mapFactory, to get a map with an ordering guarantee, e.g", "label": {"api": {"groupingBy overload": [[8, 26]]}}}, {"text": "The javadoc for groupingBy() says", "label": {"api": {"groupingBy()": [[16, 27]]}}}, {"text": "Look into ScheduledExecutorService.scheduleAtFixedRate", "label": {"api": {"ScheduledExecutorService.scheduleAtFixedRate": [[10, 53]]}}}, {"text": "To get the oldest element from the ArrayList you can use Java streams (stream(), filter(...), min(...), etc)", "label": {"api": {"streams": [[62, 68]]}}}, {"text": "Instead of using reflection, treat each constructor as a function", "label": {"api": {"function": [[57, 64]]}}}, {"text": "Specifically, a function which takes a sequence of PathElements as input, and produces a new instance of a particular class as output", "label": {"api": {"function": [[16, 23]]}}}, {"text": "The range returned by a ChronoField defers to IsoChronology.range, which says", "label": {"api": {"defers to IsoChronology.range": [[36, 64]], "says": [[73, 76]]}}}, {"text": "The actual maximum value is defined by Instant.MAX", "label": {"api": {"Instant.MAX": [[39, 49]]}}}, {"text": "In your case, if you don't care about the precision of your values past the thousandths position, you can use DecimalFormat", "label": {"api": {"DecimalFormat": [[110, 122]]}}}, {"text": "This value doesn't impact the close operation, but instead determines the timeout value that is supplied to the Connection.isValid(timeout) operation, which is used to check the validity of the connection", "label": {"api": {"Connection.isValid(timeout)": [[112, 138]]}}}, {"text": "Issue was in Windows the the newline consists of CR (carriage return) + LF (line feed) characters, so we must use the System.lineSeoeartor() or \\r\\n", "label": {"api": {"System.lineSeoeartor()": [[118, 139]]}}}, {"text": "And there is also the method JFileChoose#setApproveButtonText, but I do not think this covers your needs", "label": {"api": {"JFileChoose#setApproveButtonText": [[29, 60]]}}}, {"text": "Don't use Thread with execute, use Runnable", "label": {"api": {"execute": [[22, 28]]}}}, {"text": "Just one or two, created and started by the ExecutorService in response to the fact you've called execute two or more times and the limit set when creating the service was two threads", "label": {"api": {"execute": [[98, 104]]}}}, {"text": "The work being scheduled by those execute calls is just a single method call (though we have no idea how long that method takes to run)", "label": {"api": {"execute": [[34, 40]]}}}, {"text": "I tend to doubt it (I think the first thread will still be allocated to the first execute call when your second one is made), but my confidence level on that is no more than 60%", "label": {"api": {"execute": [[82, 88]]}}}, {"text": "No, java.lang.Float.compare( double, double ) does not return 0 (equal) for values within a hidden epsilon value of each other", "label": {"api": {"java.lang.Float.compare( double, double )": [[4, 44]]}}}, {"text": "You need to apply Math.abs function to keep the difference always positive", "label": {"api": {"Math.abs": [[18, 25]]}}}, {"text": "You can use merge method", "label": {"api": {"merge": [[12, 16]]}}}, {"text": "There is no field for INDIA in Locale and therefore, you need to create a custom Locale for INDIA", "label": {"api": {"Locale": [[31, 36], [81, 86]]}}}, {"text": "So I suggest to use SerialExecutor instead, which is described in the documentation to the  java.util.concurrent.Executor", "label": {"api": {"java.util.concurrent.Executor": [[92, 120]]}}}, {"text": "You can use the RandomAccessFile to jump to a location where you want to read the next data", "label": {"api": {"RandomAccessFile": [[16, 31]]}}}, {"text": "Use the seek() method to go backwards from a given position", "label": {"api": {"seek()": [[8, 13]]}}}, {"text": "See the FileWriter api", "label": {"api": {"FileWriter api": [[8, 21]]}}}, {"text": "From the RandomAccessFile docs", "label": {"api": {"RandomAccessFile docs": [[9, 29]]}}}, {"text": "If your data source can be easily split multiple times (which, I think, is equivalent to being able to provide the required windows efficiently and concurrently), you can do this with Streams", "label": {"api": {"split": [[34, 38]]}}}, {"text": "Console.readPassword() will turn it off until you hit Enter", "label": {"api": {"Console.readPassword()": [[0, 21]]}}}, {"text": "If you want to initialize a type which doesn't provide a no-arg constructor and therefore requires the constructor's caller to provide an argument, you can use the java.lang.reflect.Constructor-API", "label": {"api": {"java.lang.reflect.Constructor-API": [[164, 196]]}}}, {"text": "You can use PreparedStatement to achieve this, see below example", "label": {"api": {"PreparedStatement": [[12, 28]]}}}, {"text": "Can you try ByteBuffer class", "label": {"api": {"ByteBuffer": [[12, 21]]}}}, {"text": "You can use Collections.shuffle to \"randomize\" an array", "label": {"api": {"Collections.shuffle": [[12, 30]]}}}, {"text": "I tend to use Arrays.deepToString for such cases", "label": {"api": {"Arrays.deepToString": [[14, 32]]}}}, {"text": "The size of a Queue in java is limited by the max integer value", "label": {"api": {"Queue": [[14, 18]]}}}, {"text": "Are there a more bigdata-friendly Queues or similar data structures", "label": {"api": {"Queue": [[34, 38]]}}}, {"text": "You will just need to use String .replaceAll() method", "label": {"api": {"String .replaceAll() method": [[26, 52]]}}}, {"text": "No method of Comparator interface does support null values, so be sure to check https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html": [[80, 146]]}}}, {"text": "You can use Stream::allMatch which performs exactly what you wish to accomplish", "label": {"api": {"Stream::allMatch": [[12, 27]]}}}, {"text": "You should look into the replaceAll() method, for which you can use a regex expression to match all non alphanumeric", "label": {"api": {"replaceAll()": [[25, 36]]}}}, {"text": "I believe what you're looking for is AsynchronousFileChannel", "label": {"api": {"AsynchronousFileChannel": [[37, 59]]}}}, {"text": "I have a function that takes in a java.net.http.HttpRequest, logs it, sends it via a java.net.http.HttpClient, logs the response and returns the java.net.http.HttpResponse", "label": {"api": {"java.net.http.HttpRequest": [[34, 58]]}}}, {"text": "An easier way to do this would be to use the Java String startsWith API", "label": {"api": {"Java String startsWith API": [[45, 70]]}}}, {"text": "You can't use streams to remove elements from a list, but you can use lambda expression by calling removeIf()", "label": {"api": {"removeIf()": [[99, 108]]}}}, {"text": "I'm looking to generate prime numbers using BigInteger#nextProbablePrime", "label": {"api": {"BigInteger#nextProbablePrime": [[44, 71]]}}}, {"text": "Is it safe to assume that every value that this method returns (between BigInteger.TWO and BigInteger.valueOf(Long.MAX_VALUE)) is prime", "label": {"api": {"BigInteger.TWO": [[72, 85]], "BigInteger.valueOf(Long.MAX_VALUE)": [[91, 124]]}}}, {"text": "Consider ExecutorService.submit() methods, and the Future.get() method", "label": {"api": {"Future.get()": [[51, 62]]}}}, {"text": "But Future.get() wraps whatever exception was thrown in a single, well-defined, and declared ExecutableException", "label": {"api": {"Future.get()": [[4, 15]]}}}, {"text": "You can solve this in a single pass (O(n)) using a HashSet, which has O(1) put and lookup time", "label": {"api": {"HashSet": [[51, 57]]}}}, {"text": "Create a comparator chain using thenComparing", "label": {"api": {"thenComparing": [[32, 44]]}}}, {"text": "Java includes since 1.4 a package named javax.crypto, which allows you to encrypt and decrypt data using a Cipher", "label": {"api": {"javax.crypto": [[40, 51]]}}}]