[{"text": "Java has a equivalent type (I asume all higher languages do), but I have no data on it's workings", "label": {"api": {"Java has a equivalent type": [[0, 25]]}}}, {"text": "You can fine tune it by using an implementation of the ExecutorService", "label": {"api": {"implementation": [[33, 46]], "ExecutorService": [[55, 69]]}}}, {"text": "That's one of the reasons why Java 7 added addSuppressed to throwable which can basically attach an arbitrary amount of exceptions to a single other one (the other primary motivation was try-with-resources which needed a way to handle exceptions in the finally block without silently dropping them)", "label": {"api": {"addSuppressed": [[43, 55]]}}}, {"text": "So basically when you have 1 exception that causes your process to fail, you add that one as the cause of your higher-level exception, and if you have any more, then you add those to the original one using addSuppressed", "label": {"api": {"addSuppressed": [[206, 218]]}}}, {"text": "I'm not sure I'd do it (though given the JavaDoc I couldn't tell you why I hesitate), but there is the list of suppressed exceptions on Throwable, which you can add to via addSuppressed", "label": {"api": {"addSuppressed": [[172, 184]]}}}, {"text": "Look up JTable.convertRowIndexToView, JTable.convertRowIndexToModel, JTable.convertColumnIndexToView and JTable.convertColumnIndexToModel", "label": {"api": {"JTable.convertRowIndexToView": [[8, 35]], "JTable.convertRowIndexToModel": [[38, 66]], "JTable.convertColumnIndexToView": [[69, 99]], "JTable.convertColumnIndexToModel": [[105, 136]]}}}, {"text": "getMethod gets a method by its name, e.g", "label": {"api": {"getMethod": [[0, 8]]}}}, {"text": "You would need two uses of getMethod here, one to get the getObjOne method and another to get the getStrAttribOne method", "label": {"api": {"getMethod": [[27, 35]]}}}, {"text": "You can have a list of Function objects instead of strings, and then call their apply method", "label": {"api": {"Function": [[23, 30]], "apply": [[80, 84]]}}}, {"text": "If that is correct, check PreparedStatement Interface to see how can you use executeUpdate(String sql, int autoGeneratedKeys) in this context", "label": {"api": {"PreparedStatement Interface": [[26, 52]]}}}, {"text": "A Stream<Byte> is about as good as a ByteStream of primitives would be, since Byte#valueOf returns cached instances of the boxed values (and the compiler handles boxing and unboxing for you)", "label": {"api": {"Byte#valueOf": [[78, 89]]}}}, {"text": "The underlying Formatter says that \"the value will be rounded using the round half up algorithm\" and it apparently does not offer direct options to prevent that", "label": {"api": {"Formatter": [[15, 23]]}}}, {"text": "Use a stream to map an array of enum values to a list of strings", "label": {"api": {"stream": [[6, 11]], "map": [[16, 18]]}}}, {"text": "There are much better things like the interfaces Runnable and Callable", "label": {"api": {"Runnable": [[49, 56]], "Callable": [[62, 69]]}}}, {"text": "The lock has the Type ReentrantLock and is passed to the constructor of Fun, so every Thread has the same lock instance", "label": {"api": {"ReentrantLock": [[22, 34]]}}}, {"text": "There is no 'value' of an ObjectReference", "label": {"api": {"ObjectReference": [[26, 40]]}}}, {"text": "It is itself an instance of Value", "label": {"api": {"Value": [[28, 32]]}}}, {"text": "What you probably want is to get a string representation of an object referenced by this ObjectReference", "label": {"api": {"ObjectReference": [[89, 103]]}}}, {"text": "Call ObjectReference.invokeMethod passing a Method for toString()", "label": {"api": {"ObjectReference": [[5, 19]], "ObjectReference.invokeMethod": [[5, 32]]}}}, {"text": "As a result, you'll get a StringReference instance, on which you then call value() to obtain the desired string representation", "label": {"api": {"value()": [[75, 81]]}}}, {"text": "The description of the field is", "label": {"api": {"description of the field is": [[4, 30]]}}}, {"text": "Another solution if you are using Java-8 by using removeIf and regex [A-Z]+ like so", "label": {"api": {"removeIf": [[50, 57]]}}}, {"text": "You can parse timestamps with the DateTimeFormatter class", "label": {"api": {"DateTimeFormatter class": [[34, 56]]}}}, {"text": "One of the options would be to use the OffsetDateTime class for representing the time including the offset", "label": {"api": {"OffsetDateTime class": [[39, 58]]}}}, {"text": "Optionally, the LocalDateTime class can be used for representing the timestamp after parsing", "label": {"api": {"LocalDateTime class": [[16, 34]]}}}, {"text": "Java's Stream operations are well suited for this kind of problem", "label": {"api": {"Stream": [[7, 12]]}}}, {"text": "In particular, method groupingBy does exactly what you need", "label": {"api": {"groupingBy": [[22, 31]]}}}, {"text": "This is easy to do using the StringBuilder class, which can be used like this", "label": {"api": {"StringBuilder": [[29, 41]]}}}, {"text": "Since the same delimiter is used each time another option is to use java.util.StringJoiner", "label": {"api": {"java.util.StringJoiner": [[68, 89]]}}}, {"text": "For non academic purposes or in cases when efficiency is a priority the java.lang.StringBuilder object should be used", "label": {"api": {"java.lang.StringBuilder": [[72, 94]]}}}, {"text": "Just checking the JavaDocs of AtomicInteger will show you methods like AtomicInteger.getAndAdd that you can use for this", "label": {"api": {"AtomicInteger.getAndAdd": [[71, 93]]}}}, {"text": "In your case, I would consider using an ArrayList", "label": {"api": {"ArrayList": [[40, 48]]}}}, {"text": "An ArrayList is an object that is similar to an array but which you can add values to at any point", "label": {"api": {"ArrayList": [[3, 11]]}}}, {"text": "With an array, once you set the values, you can't change them, but with an ArrayList, you can keep adding values at any time", "label": {"api": {"ArrayList": [[75, 83]]}}}, {"text": "First at the very top of your program, you need to import the ArrayList class from the java.util library", "label": {"api": {"ArrayList": [[62, 70]]}}}, {"text": "ArrayList initializes a new ArrayList of type int", "label": {"api": {"ArrayList": [[0, 8], [28, 36]]}}}, {"text": "evens.add() adds a value to the ArrayList", "label": {"api": {"ArrayList": [[32, 40]]}}}, {"text": "Notice at the end we have to return evens.toArray(), which converts the ArrayList back to a normal array of type int, because sum() is expecting an array of type int, and not an ArrayList", "label": {"api": {"ArrayList": [[72, 80], [178, 186]]}}}, {"text": "If you just want to terminate a java program, there's an exit() method, both in class Runtime and class System", "label": {"api": {"Runtime": [[86, 92]], "System": [[104, 109]]}}}, {"text": "If you want numbers between 0.85 and 1, inclusive, use SplittableRandom and its nextDouble(double origin, double bound) method, or use ThreadLocalRandom and its nextDouble(double origin, double bound) method", "label": {"api": {"SplittableRandom": [[55, 70]], "nextDouble(double origin, double bound)": [[80, 118], [161, 199]], "ThreadLocalRandom": [[135, 151]]}}}, {"text": "Since the upper bound is exclusive in those methods, you need to bump up the double value by the smallest amount possible, which you can do by calling Math.nextUp(double d)", "label": {"api": {"Math.nextUp(double d)": [[151, 171]]}}}, {"text": "You don't synchronized on a ReentrantLock instance (you synchronize on any object you want) – or, if you want to go the lock route, you can call the lock lock method on your lock object, using a try/finally guard to always ensure you call unlock later (and don't use synchronized at all)", "label": {"api": {"lock": [[120, 123], [149, 152], [154, 157], [174, 177], [241, 244]]}}}, {"text": "The key issue is to remove all references to a lock object (thus ensuring it can be garbage collected), but not until you are certain there are zero active threads locking on it", "label": {"api": {"lock": [[47, 50], [164, 167]]}}}, {"text": "Once you return an instance of a Lock object, it's 'out of your hands' and it is not possible to track if the caller is ever going to call lock on it", "label": {"api": {"lock": [[139, 142]]}}}, {"text": "Instead, call lock as part of the job; the getLock method should actually do the locking as part of the operation", "label": {"api": {"lock": [[14, 17], [81, 84]]}}}, {"text": "So, whilst you might have millions of keys, the number of 'locked' keys is MUCH smaller", "label": {"api": {"lock": [[59, 62]]}}}, {"text": "You could make a ConcurrentHashMap which maps your string keys to lock objects", "label": {"api": {"lock": [[66, 69]], "ConcurrentHashMap": [[17, 33]]}}}, {"text": "To acquire a lock", "label": {"api": {"lock": [[13, 16]]}}}, {"text": "Create a new lock object (literally", "label": {"api": {"lock": [[13, 16]]}}}, {"text": "Once you're done, acquire the sync lock on your object, send a notification, release, and remove", "label": {"api": {"lock": [[35, 38]]}}}, {"text": "To wait until the lock is available, first acquire a lock on the locker object, THEN check if the concurrentMap still contains it", "label": {"api": {"lock": [[18, 21], [53, 56], [65, 68]]}}}, {"text": "Instead of this setup where you pass the operation to execute along with the lock key, you could have tandem 'lock' and 'unlock' methods but now you run the risk of writing code that forgets to call unlock", "label": {"api": {"lock": [[77, 80], [110, 113], [123, 126], [201, 204]]}}}, {"text": "You want to use BiFunction instead", "label": {"api": {"BiFunction": [[16, 25]]}}}, {"text": "Or you could create your own separate comparator and use that in Collections.sort", "label": {"api": {"use that in Collections.sort": [[53, 80]]}}}, {"text": "You're getting that error because you're calling the read() method from a JButton, but buttons don't read files -- all they do is throw events when they're clicked so that you can run other code in response", "label": {"api": {"read()": [[53, 58]]}}}, {"text": "What you should be doing is calling read() on br, which is your BufferedReader", "label": {"api": {"read()": [[36, 41]]}}}, {"text": "I'm not sure why you're trying to pass an instance of the BufferedReader to itself, but those aren't the parameters that read() takes", "label": {"api": {"read()": [[121, 126]]}}}, {"text": "Typically, you'd use the readLine() method, which, as its name suggests, reads an entire line of text, allowing you to handle a file line by line without having to tell your code how many bytes of data to process on each read", "label": {"api": {"readLine()": [[25, 34]]}}}, {"text": "Method 3 - using a List", "label": {"api": {"List": [[19, 22]]}}}, {"text": "Method 4 - using a Set", "label": {"api": {"Set": [[19, 21]]}}}, {"text": "This works because HashSet#add() will NOT add duplicates, and returns false if requested", "label": {"api": {"Set": [[23, 25]], "HashSet#add()": [[19, 31]]}}}, {"text": "Method 5 - using Streams", "label": {"api": {"Streams": [[17, 23]]}}}, {"text": "If you just need the index of an element in the list, use List#indexOf()", "label": {"api": {"List#indexOf()": [[58, 71]]}}}, {"text": "Pass the comparator as an additional argument", "label": {"api": {"as an additional argument": [[20, 44]]}}}, {"text": "You can use DecimalFormat with # symbol", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "You can use the good old read method like this", "label": {"api": {"read": [[25, 28]]}}}, {"text": "The read method in input streams is a blocking call (like explained in the api)", "label": {"api": {"in the api": [[68, 77]]}}}, {"text": "A solution would be to execute your code in another thread so the main thread doesn't get blocked", "label": {"api": {"thread": [[52, 57], [71, 76]]}}}, {"text": "After receiving the data in the thread you can inform the gui or any other class that there is a new move (or any other data) available", "label": {"api": {"thread": [[32, 37]]}}}, {"text": "If you're using ExecutorCompletionService, create a new instance wrapping your ExecutorService, submit two tasks, and call take()", "label": {"api": {"ExecutorCompletionService": [[16, 40]]}}}, {"text": "No additional cleanup is required for the ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[42, 66]]}}}, {"text": "To clear the selection of a ComboBox, you need to access the SelectionModel", "label": {"api": {"SelectionModel": [[61, 74]]}}}, {"text": "In the SelectionModel you'll find a method clearSelection() which can be used in the action handler for button", "label": {"api": {"SelectionModel": [[7, 20]]}}}, {"text": "Do note that you should create a single instance of ExecutorService for your tasks and use submit() to enqueu tasks", "label": {"api": {"submit()": [[91, 98]]}}}, {"text": "You can terminating by calling shutdownNow() but your tasks will get interrupted", "label": {"api": {"shutdownNow()": [[31, 43]]}}}, {"text": "In that case you can for instance simply encode an integer to 4 bytes using ByteBuffer#putInt(int) or by using DataOutputStream#writeInt(int)", "label": {"api": {"ByteBuffer#putInt(int)": [[76, 97]], "DataOutputStream#writeInt(int)": [[111, 140]]}}}, {"text": "I suggest you look at the All Known Implementing Classes list of java.util.Collections interface", "label": {"api": {"java.util.Collections": [[65, 85]]}}}, {"text": "You can combine the Map with an AtomicLong", "label": {"api": {"AtomicLong": [[32, 41]]}}}, {"text": "the Map for getting an AtomicLong per mapKey, and then compareAndSet on the AtomicLong for the atomicity you need", "label": {"api": {"AtomicLong": [[23, 32], [76, 85]]}}}, {"text": "If someone else got in before you (and specifically, between the idForKey.get() and the compareAndSet), then you'll still generate newId, but you won't use update the AtomicLong, and you'll get to the // do something else block", "label": {"api": {"AtomicLong": [[167, 176]]}}}, {"text": "Use the printf method, or String.format", "label": {"api": {"printf": [[8, 13]], "String.format": [[26, 38]]}}}, {"text": "You're using the showOpenDialog which, as the name suggests, shows a \"Open File\" dialog to select a file to open", "label": {"api": {"showOpenDialog": [[17, 30]]}}}, {"text": "If you want to allow the user to select a new file, you probably want the showSaveDialog which shows a \"Save File\" dialog and (should) allow a new file to be created", "label": {"api": {"showSaveDialog": [[74, 87]]}}}, {"text": "As of writing, I haven't found a way of doing this with jOOQ, but the following code snippet  demonstrates how to get column names for a particular table in a particular schema using java.sql.DatabaseMetaData", "label": {"api": {"java.sql.DatabaseMetaData": [[183, 207]]}}}, {"text": "Reader.read reads a single character", "label": {"api": {"Reader.read": [[0, 10]]}}}, {"text": "You can use the Consumer interface here", "label": {"api": {"Consumer": [[16, 23]]}}}, {"text": "when your methods throw checked exceptions, you can do two use your own Consumer/Function interface see here for details", "label": {"api": {"Consumer": [[72, 79]]}}}, {"text": "You may try using a thread pool executor to send many connections in parallel", "label": {"api": {"thread pool executor": [[20, 39]]}}}, {"text": "One way to work around it is to use a Scanner", "label": {"api": {"Scanner": [[38, 44]]}}}, {"text": "From the HashSet documentation", "label": {"api": {"HashSet documentation": [[9, 29]]}}}, {"text": "Using the FileChannel and FileLock classes from the java.nio package could possibly assist you here", "label": {"api": {"FileChannel": [[10, 20]], "FileLock": [[26, 33]]}}}, {"text": "A String represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the Character class for more information)", "label": {"api": {"Unicode Character Representations": [[136, 168]]}}}, {"text": "The CharsetDecoder class should be used when more control over the decoding process is required", "label": {"api": {"CharsetDecoder": [[4, 17]]}}}, {"text": "Assuming the dataset is small enough, is there a way to write the content directly into a String, a Stream or any kind of OutputStream", "label": {"api": {"String": [[90, 95]], "Stream": [[100, 105], [128, 133]], "OutputStream": [[122, 133]]}}}, {"text": "From what I read, the object passed to execute function should be a Runnable with a run() method (see execute documentation)", "label": {"api": {"see execute documentation": [[98, 122]]}}}, {"text": "In the java code of the invoked method, I first call method totalMemory() and write the result to a log file", "label": {"api": {"totalMemory()": [[60, 72]]}}}, {"text": "Usually method totalMemory() returns a value of around 66 million, i.e", "label": {"api": {"totalMemory()": [[15, 27]]}}}, {"text": "When totalMemory() is only 2 MB, my java method throws OutOfMemoryError (java heap space) because there isn't enough memory to allocate the object that my java method needs to do", "label": {"api": {"totalMemory()": [[5, 17]], "OutOfMemoryError": [[55, 70]]}}}, {"text": "After the OutOfMemoryError, for a subsequent call to my JNI function, totalMemory() will again return a value of 64 MB", "label": {"api": {"totalMemory()": [[70, 82]], "OutOfMemoryError": [[10, 25]]}}}, {"text": "From the Javadoc of wait() (emphasis added)", "label": {"api": {"Javadoc of wait()": [[9, 25]]}}}, {"text": "So if you're inserting elements into your list search their respective position and use List.add(index,element)Oracle Doc to add it at said position", "label": {"api": {"Oracle Doc": [[111, 120]]}}}, {"text": "To change a value at a specific index in a Vector you have to use set()", "label": {"api": {"set()": [[66, 70]]}}}, {"text": "Use CyclicBarrier instead, which supports reset", "label": {"api": {"CyclicBarrier": [[4, 16]], "reset": [[42, 46]]}}}, {"text": "From reading the docs, all it does with the numTypeValueExact variants is to check for existence of a fraction part or if the value is too big for the numeric type and throw exceptions", "label": {"api": {"reading": [[5, 11]], "the": [[13, 15], [40, 42], [122, 124], [147, 149]]}}}, {"text": "As for floatValue() and doubleValue(), a similar overflow check is being done, but instead of throwing an exception, instead it returns Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY for doubles and Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY for floats", "label": {"api": {"floatValue()": [[7, 18]], "doubleValue()": [[24, 36]]}}}, {"text": "Therefore the most reasonable (and simplest) implementation of the exact methods for float and double, should simply check if the conversion returns POSITIVE_INFINITY or NEGATIVE_INFINITY", "label": {"api": {"the": [[10, 12], [63, 65], [126, 128]]}}}, {"text": "Furthermore, remember that BigDecimal was designed to handle the lack of precision that comes from using float or double for large irrationals, therefore as @JB Nizet commented, another check you can add to the above would be to convert the double or float back to BigDecimal to see if you still get the same value", "label": {"api": {"the": [[3, 5], [61, 63], [144, 146], [181, 183], [207, 209], [237, 239], [300, 302]]}}}, {"text": "This should prove the conversion was correct", "label": {"api": {"the": [[18, 20]]}}}, {"text": "The use of compareTo instead of equals above is intentional so as to not become too strict with the checks", "label": {"api": {"the": [[96, 98]], "compareTo": [[11, 19]], "equals": [[32, 37]]}}}, {"text": "equals will only evaluate to true when the two BigDecimal objects have the same value and scale (size of the fraction part of the decimal), whereas compareTo will overlook this difference when it does not matter", "label": {"api": {"the": [[39, 41], [71, 73], [105, 107], [126, 128]], "compareTo": [[148, 156]], "equals": [[0, 5]]}}}, {"text": "Have you considered using the Scanner class", "label": {"api": {"Scanner": [[30, 36]]}}}, {"text": "When a message goes out to System.err such as", "label": {"api": {"System.err": [[27, 36]]}}}, {"text": "On the console displayed within IntelliJ I see message appear that I sent to System.out", "label": {"api": {"System.out": [[77, 86]]}}}, {"text": "But message sent to System.err fail to appear on that same console", "label": {"api": {"System.err": [[20, 29]]}}}, {"text": "You can try to use AtomicInteger wrapper for such cases", "label": {"api": {"AtomicInteger": [[19, 31]]}}}, {"text": "connectTimeout ends in timeout argument of Socket.connect of both control and data connection", "label": {"api": {"Socket.connect": [[43, 56]]}}}, {"text": "defaultTimeout ends in Socket.setSoTimeout of the control connection", "label": {"api": {"Socket.setSoTimeout": [[23, 41]]}}}, {"text": "dataTimeout ends in Socket.setSoTimeout of the data connection", "label": {"api": {"Socket.setSoTimeout": [[20, 38]]}}}, {"text": "See for example the documentation on Thread.stop", "label": {"api": {"the documentation on Thread.stop": [[16, 47]]}}}, {"text": "boolean add(E e) or boolean contains(Object o)", "label": {"api": {"add": [[8, 10]], "contains": [[28, 35]]}}}, {"text": "It can efficiently find duplicate addition", "label": {"api": {"add": [[34, 36]]}}}, {"text": "If we only catch Exceptions, an IOError would crash our code and prevent us from using the strength of a Try chain", "label": {"api": {"IOError": [[32, 38]]}}}, {"text": "When catching Throwable, this IOError will be caught, and we will be able to execute the onFailure method", "label": {"api": {"IOError": [[30, 36]]}}}, {"text": "According to javaFX-8 documentation, SelectionModel.java does not expose any focus() method", "label": {"api": {"javaFX-8 documentation": [[13, 34]]}}}, {"text": "Obtain a constructor with getConstructor(), and invoke it with the necessary arguments", "label": {"api": {"getConstructor(),": [[26, 42]], "invoke it": [[48, 56]]}}}, {"text": "The closest you can get to perform automated parameter processing, is to declare the methods in an interface and generate a proxy", "label": {"api": {"proxy": [[124, 128]]}}}, {"text": "Assuming you are using java.awt.Rectangle, this is the approach I would go for", "label": {"api": {"java.awt.Rectangle": [[23, 40]]}}}, {"text": "Use Dynamic Attach API", "label": {"api": {"Dynamic Attach API": [[4, 21]]}}}, {"text": "Note that you can improve the code by using AccessibleObject.setAccessible, to set the accessibility status of all objects at once, to avoid repeated potentially expensive security checks", "label": {"api": {"AccessibleObject.setAccessible": [[44, 73]]}}}, {"text": "Also, the use of NIO is strongly recommended here, as it allows to make a diagnosis when the creation of the directories failed, rather than returning an unhelpful boolean value", "label": {"api": {"NIO": [[17, 19]]}}}, {"text": "Take a look at Optional, it provides an object that can be either absent (very roughly equivalent to null) or present (and have an actual value)", "label": {"api": {"Optional": [[15, 22]]}}}, {"text": "First, do not perform the processing in main() since you will not be able to invoke the non-static method getClass() which is needed to get runtime details about your application", "label": {"api": {"getClass()": [[106, 115]]}}}, {"text": "The javadoc for Comparable explains how this works pretty well but this is an example", "label": {"api": {"javadoc for Comparable": [[4, 25]]}}}, {"text": "I am using the AWT library class Robot to simulate interactions with a graphical user interface", "label": {"api": {"Robot": [[33, 37]]}}}, {"text": "I want to create a method for writing complete Strings (instead of a character simulating a key press) using the Robot class,  those strings should also support including the \"_\" character", "label": {"api": {"Robot": [[113, 117]]}}}, {"text": "And I used the constructor of BigInteger that takes signum and raw bytes", "label": {"api": {"BigInteger": [[30, 39]]}}}, {"text": "You want to look at SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[20, 35]]}}}, {"text": "Instantiate yourself a SimpleDateFormat with the desired output format e.g", "label": {"api": {"SimpleDateFormat": [[23, 38]]}}}, {"text": "new SimpleDateFormat(\"dd/MM/yyyy\") and then simply use the format(java.util.Date) method to convert your date objects to strings in your desired format", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Why not use ArrayList.removeAll(Collection c)", "label": {"api": {"ArrayList.removeAll": [[12, 30]], "Collection": [[32, 41]]}}}, {"text": "This way, you can create a Collection, such as an ArrayList, iterate through the original list, add all rotten items to your new collection, then call removeAll on the original ArrayList after iterating through the entire list", "label": {"api": {"Collection": [[27, 36]]}}}, {"text": "You can call that method through Reflection API", "label": {"api": {"Reflection API": [[33, 46]]}}}, {"text": "You can use the Pattern class as per below", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "Second, The datatype should be Integer", "label": {"api": {"Integer": [[31, 37]]}}}, {"text": "Now, to elaborate, The method toString() is defined in Java Object class, and any class that you define by default extends it", "label": {"api": {"toString()": [[30, 39]], "Object": [[60, 65]]}}}, {"text": "The datatype you used - \"int\" is a primitive data type (taken directly from C - simple but not object oriented approach) which does not extend Java Object class", "label": {"api": {"Object": [[148, 153]]}}}, {"text": "Thus, you cannot use toString() method with any instance of a primitive datatype", "label": {"api": {"toString()": [[21, 30]]}}}, {"text": "Whereas \"Integer\" datatype is a class defined in Java API, it extends Object class and has toString() method defined in it", "label": {"api": {"toString()": [[91, 100]], "Object": [[70, 75]], "Integer": [[9, 15]]}}}, {"text": "Thus, you can use toString() method with any instance of this class", "label": {"api": {"toString()": [[18, 27]]}}}, {"text": "Note that, int or Integer can easily be converted to string without calling toString() method, as Java kind of automatically does that for you when you concatenate it with a String - something like this", "label": {"api": {"toString()": [[76, 85]], "Integer": [[18, 24]]}}}, {"text": "Method.invoke returns an Object and the Object  class does not have a clear() method, so you need to cast the returned object into a List", "label": {"api": {"Method.invoke": [[0, 12]]}}}, {"text": "Use the Java 8+ Time API class LocalTime", "label": {"api": {"LocalTime": [[31, 39]]}}}, {"text": "The Java API documentation on String.split() is a good place to start", "label": {"api": {"String.split()": [[30, 43]]}}}, {"text": "For elapsed time, or age, use Period class", "label": {"api": {"Period": [[30, 35]]}}}, {"text": "You can use the Files.readAttributes() method to get meta information about a file and then use BasicFileAttributes.fileKey() to get a key which identifiers the file on the disk", "label": {"api": {"Files.readAttributes()": [[16, 37]], "BasicFileAttributes.fileKey()": [[96, 124]]}}}, {"text": "If you want to synchronize processing between threads, you can use wait()/notify(), but if you're not sure about the order in which those \"processings\" will take place, I suggest you use a Semaphore instead", "label": {"api": {"wait()": [[67, 72]], "notify()": [[74, 81]], "Semaphore": [[189, 197]]}}}, {"text": "And on the other hand, you're returning (but not in all cases) from the function (lambda) passed to Optional.ifPresent(), although the lambda is supposed to be a Consumer, and thus shouldn't return anything", "label": {"api": {"Optional.ifPresent()": [[100, 119]], "Consumer": [[162, 169]]}}}, {"text": "If you need to guarantee the order of elements in a data structure, you don't use Vector -- it's not 1999 anymore", "label": {"api": {"Vector": [[82, 87]]}}}, {"text": "Look at the documentation for Vector", "label": {"api": {"Vector": [[30, 35]]}}}, {"text": "Change your data structure to an ArrayList, which guarantees order", "label": {"api": {"ArrayList": [[33, 41]]}}}, {"text": "ArrayLists are also more performant in a single threaded application like yours, because unlike Vector, an ArrayList skips the overhead associated with being synchronized", "label": {"api": {"Vector": [[96, 101]], "ArrayList": [[0, 8], [107, 115]]}}}, {"text": "Using the index of the ArrayList elements may also simplify the way you construct your switch statement", "label": {"api": {"ArrayList": [[23, 31]]}}}, {"text": "https://docs.oracle.com/javaee/7/api/javax/ws/rs/NotFoundException.html#NotFoundException-java.lang.String- , when you pass the error message to a NotFoundException, surely the Throwable.getMessage() enrich that message with the class name", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/ws/rs/NotFoundException.html#NotFoundException-java.lang.String-": [[0, 106]]}}}, {"text": "Piped streams are intended to be used by two different threads", "label": {"api": {"are intended to be used by two different threads": [[14, 61]]}}}, {"text": "The way you're trying to use PipedOutputStream is provided in a much simpler manner, which doesn't require threads, by the class ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[129, 149]]}}}, {"text": "Check https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#indexOf(int) for more details", "label": {"api": {"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#indexOf(int)": [[6, 100]]}}}, {"text": "I think Java's AtomicStampedReference can solve this problem", "label": {"api": {"AtomicStampedReference": [[15, 36]]}}}, {"text": "If you do have the leading 0x, then you need Long.decode", "label": {"api": {"Long.decode": [[45, 55]]}}}, {"text": "While working with legacy code not yet updated for the modern java.time classes, I need to convert a ZonedDateTime to XMLGregorianCalendar", "label": {"api": {"ZonedDateTime": [[101, 113]], "XMLGregorianCalendar": [[118, 137]], "GregorianCalendar": [[121, 137]]}}}, {"text": "So I thought I'd go by way of GregorianCalendar, calling GregorianCalendar.from( ZonedDateTime )", "label": {"api": {"ZonedDateTime": [[81, 93]], "GregorianCalendar": [[30, 46], [57, 73]], "GregorianCalendar.from( ZonedDateTime )": [[57, 95]]}}}, {"text": "I see methods for going from XMLGregorianCalendar to GregorianCalendar", "label": {"api": {"XMLGregorianCalendar": [[29, 48]], "GregorianCalendar": [[32, 48], [53, 69]]}}}, {"text": "➥ I need the opposite, going from GregorianCalendar to XMLGregorianCalendar", "label": {"api": {"XMLGregorianCalendar": [[55, 74]], "GregorianCalendar": [[34, 50], [58, 74]]}}}, {"text": "If you want to filter the list for just ones with a certain condition, the most common way to do that these days is with the Stream::filter method", "label": {"api": {"Stream::filter": [[125, 138]]}}}, {"text": "If you just want a one-line text component, you should use a JTextField", "label": {"api": {"JTextField": [[61, 70]]}}}, {"text": "If you insist on using a JTextArea, set its preferred column count, and place it in a JScrollPane", "label": {"api": {"set its preferred column count": [[36, 65]]}}}, {"text": "When you do not know name of a key in JSON Object you can iterate over all elements using elements which returns Iterator<JsonNode>", "label": {"api": {"Iterator<JsonNode>": [[113, 130]]}}}, {"text": "Implement a custom sort (Comparator) and use on the list of file names collection (Collections.sort) and handle the sorting appropriately, ie, treat the end digits as number", "label": {"api": {"Comparator": [[25, 34]], "Collections.sort": [[83, 98]]}}}, {"text": "I have come up against this problem many times before and solved it using Spring's DelegatingDataSource which allows you to define multiple DataSource objects and delegate to the correct target data source needed by means of some type of lookup key", "label": {"api": {"DataSource": [[93, 102], [140, 149]]}}}, {"text": "A sub-class of this which may be a good choice for the code you've displayed in your post may be TransactionAwareDataSourceProxy which is, as the first sentence of the JavaDoc description states", "label": {"api": {"DataSource": [[113, 122]]}}}, {"text": "Proxy for a target JDBC DataSource, adding awareness of Spring-managed transactions", "label": {"api": {"DataSource": [[24, 33]]}}}, {"text": "Similar to a transactional JNDI DataSource as provided by a Java EE server", "label": {"api": {"DataSource": [[32, 41]]}}}, {"text": "I generally always use the same target data source in any given thread, so I tend to tuck my lookup key into a ThreadLocal object and have the proxy datasource read this to find the actual target data source whenever a call to DataSource#getConnection is made", "label": {"api": {"DataSource": [[227, 236]], "ThreadLocal": [[111, 121]], "DataSource#getConnection": [[227, 250]]}}}, {"text": "If you create such a delegating (proxy) data source, your EntityManagerFactory can use this as its underlying JDBC data source and delegate to the correct target data source as needed at any given time", "label": {"api": {"EntityManagerFactory": [[58, 77]]}}}, {"text": "Here is the proxy DataSource class that delegates to an actual target JDBC DataSource", "label": {"api": {"DataSource": [[18, 27], [75, 84]]}}}, {"text": "It does not extend Spring's DelegatingDataSource as mentioned above, but it's doing the exact same thing", "label": {"api": {"DataSource": [[38, 47]]}}}, {"text": "In case you're not familiar with OSGI declarative services and their annotations (I imagine most people aren't), @Component(property = {\"osgi.jndi.service.name=jdbc/customation\"} is what puts the DataSource into the JNDI registry such that it may be located by the persistence unit descriptor (persistence.xml) shown a bit further below", "label": {"api": {"DataSource": [[196, 205]]}}}, {"text": "Here is the class that holds the lookup key in a ThreadLocal", "label": {"api": {"ThreadLocal": [[49, 59]]}}}, {"text": "We're using java.util.logging as a logger", "label": {"api": {"java.util.logging": [[12, 28]]}}}, {"text": "java.util.logging has overloads that take Supplier<String> but not in combination with a format string", "label": {"api": {"java.util.logging": [[0, 16]]}}}, {"text": "You would need a Map to do that", "label": {"api": {"Map": [[17, 19]]}}}, {"text": "Please note here that we are using an HashMap but there is many type of Map you can use", "label": {"api": {"Map": [[42, 44], [72, 74]]}}}, {"text": "HashMap is simply the more common one", "label": {"api": {"Map": [[4, 6]]}}}, {"text": "If you have a currency value, you should use a currency format to read it", "label": {"api": {"currency format": [[47, 61]]}}}, {"text": "As pointed by @Ravi in his answer you can make use of PropertyChangeListener instead", "label": {"api": {"PropertyChangeListener": [[54, 75]]}}}, {"text": "Instead, you can do your check with the Class#isInstance method of your Class object", "label": {"api": {"Class#isInstance": [[40, 55]]}}}, {"text": "If you are looking to validate the input of the user as he/she type, you might wanna have a look at javax.swing.text.DocumentFilter", "label": {"api": {"javax.swing.text.DocumentFilter": [[100, 130]]}}}, {"text": "AudioInputStream extends InputStream", "label": {"api": {"AudioInputStream extends InputStream": [[0, 35]]}}}, {"text": "In theory, reading the audio as stream of bytes until EOF (-1) and writing those bytes into the output stream of the HTTP (servlet) response  will transfer the audio to the browser; most likely a specific \"content-type\" header will have to be set first on the response to denote the type of audio/audio format and perhaps some additional audio characteristics from AudioFormat", "label": {"api": {"reading": [[11, 17]], "AudioFormat": [[365, 375]]}}}, {"text": "You need to use ofNullable if you are not sure whether the value you want to wrap as Optional is null or not", "label": {"api": {"ofNullable": [[16, 25]]}}}, {"text": "This is however not something that can be achieved with a SortedMap", "label": {"api": {"SortedMap": [[58, 66]]}}}, {"text": "If you just want to store them sorted in a Map, without requiring the Map to still be sorted when you would add new values, you could store all entries in a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[157, 169]]}}}, {"text": "This won't give you a SortedMap though, but the Map will be sorted", "label": {"api": {"SortedMap": [[22, 30]]}}}, {"text": "You can use String.lines introduced since Java-11 as", "label": {"api": {"String.lines": [[12, 23]]}}}, {"text": "After some search, I realized that ThreadMXBean.getThreadAllocatedBytes(long id) can be used to achieve this", "label": {"api": {"ThreadMXBean.getThreadAllocatedBytes(long id)": [[35, 79]]}}}, {"text": "As the Javadoc of ThreadMXBean.getThreadAllocatedBytes(long id) indicates, it returns the total amount of memory allocated in heap memory", "label": {"api": {"ThreadMXBean.getThreadAllocatedBytes(long id)": [[18, 62]]}}}, {"text": "This may also work for you by matching \\p{So} (Other Symbol)", "label": {"api": {"\\p{So} (Other Symbol)": [[39, 59]]}}}, {"text": "I'd recommend using a DateFormat object, taking advantage of the parse(String) and format(Date) methods", "label": {"api": {"DateFormat": [[22, 31]], "parse(String)": [[65, 77]], "format(Date)": [[83, 94]]}}}, {"text": "The javadoc of compare(T o1, T o2) says", "label": {"api": {"compare(T o1, T o2)": [[15, 33]]}}}, {"text": "According to this Oracle blog, a method which overrides another but declares a covariant return type is implemented using bridge methods", "label": {"api": {"bridge": [[122, 127]]}}}, {"text": "As you can see, the second method, the one which returns javax.lang.model.element.Name, is both synthetic and a bridge", "label": {"api": {"synthetic": [[96, 104]], "bridge": [[112, 117]]}}}, {"text": "I searched the LinkedList API But I didn't quite get how to implement the Iterator properly", "label": {"api": {"LinkedList API": [[15, 28]]}}}, {"text": "If you want to work atomically with 2 resources in a transaction then you need to acquire javax.transaction.xa.XAResource implementations from each resource manager (i.e", "label": {"api": {"javax.transaction.xa.XAResource": [[90, 120]]}}}, {"text": "To get an XAResource from JMS take a look at javax.jms.XAConnectionFactory", "label": {"api": {"javax.jms.XAConnectionFactory": [[45, 73]], "javax.jms.XAConnection": [[45, 66]]}}}, {"text": "You can use createXAConnection() to get an instance of javax.jms.XAConnection and then use createXASession() to get an javax.jms.XASession and then finally use getXAResource()", "label": {"api": {"javax.jms.XAConnection": [[55, 76]], "javax.jms.XASession": [[119, 137]]}}}, {"text": "To get an XAResource from JDBC take a look at javax.sql.XADataSource", "label": {"api": {"javax.sql.XADataSource": [[46, 67]]}}}, {"text": "You can use getXAConnection() to get an instance of javax.sql.XAConnection and then use getXAResource()", "label": {"api": {"javax.sql.XAConnection": [[52, 73]]}}}, {"text": "Then you can call getTransaction() on the transaction manager and use the returned javax.transaction.Transaction to invoke enlistResource() with your XAResources", "label": {"api": {"getTransaction()": [[18, 33]], "javax.transaction.Transaction": [[83, 111]], "enlistResource()": [[123, 138]]}}}, {"text": "You have to set lenient to false on SimpleDateFormat object", "label": {"api": {"SimpleDateFormat": [[36, 51]]}}}, {"text": "Let's look at what intern actually does (emphasis mine)", "label": {"api": {"intern": [[19, 24]]}}}, {"text": "When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned", "label": {"api": {"intern": [[9, 14]]}}}, {"text": "Note that the reason why str2 == str1 is not because intern somehow changes which object str2 refers to", "label": {"api": {"intern": [[53, 58]]}}}, {"text": "Now you call s4.intern(), which does nothing to s4, and returns the object that is in the string pool", "label": {"api": {"intern": [[16, 21]]}}}, {"text": "This is why s4 != s5, and s4.intern() == s5", "label": {"api": {"intern": [[29, 34]]}}}, {"text": "The reason for s2.intern() != s2 is much simpler - s2 refers to a different object than \"cc\" in the string pool", "label": {"api": {"intern": [[18, 23]]}}}, {"text": "s2.intern() is supposed to return the object in the string pool, so of course it is not the same object", "label": {"api": {"intern": [[3, 8]]}}}, {"text": "The contains method on a string tests whether the target is contained as a substring; if ABAC is contained as a substring then so is ABA, since ABA is a substring of ABAC and hence it is also a substring of any string which ABAC is a substring of", "label": {"api": {"contains": [[4, 11]]}}}, {"text": "Therefore, it is not logically possible for the String.contains method to return true for ABAC and false for ABA", "label": {"api": {"contains": [[55, 62]]}}}, {"text": "You want to test if the target is one of the elements of a collection of strings, so you should use contains on a collection of strings, not on a string", "label": {"api": {"contains": [[100, 107]]}}}, {"text": "The best choice is a HashSet, since this performs membership tests in O(1) time on average", "label": {"api": {"HashSet": [[21, 27]]}}}, {"text": "As @Ashutosh KS has already mentioned, String.contains is not really what you are looking for in this case", "label": {"api": {"String": [[39, 44]]}}}, {"text": "The Java String class contains a few methods that you can use to compare the content of two strings, of which you can choose accordingly to match your exact use case", "label": {"api": {"String": [[9, 14]]}}}, {"text": "contentEquals(CharSequence cs) and contentEquals(StringBuffer sb) both check if the passed string representation's content matches the current one", "label": {"api": {"String": [[49, 54]]}}}, {"text": "equalsIgnoreCase(String anotherString), as the name implies, will do a check while ignoring the string case", "label": {"api": {"String": [[17, 22], [31, 36]]}}}, {"text": "This is an interface defined in the Java standard library, which declares a method named compareTo which returns an int, so therefore your lambda returns an int", "label": {"api": {"compareTo": [[89, 97]]}}}, {"text": "I'm trying to test my code which uses the new Java 11 java.net.http.HttpClient", "label": {"api": {"java.net.http.HttpClient": [[54, 77]]}}}, {"text": "And in my test I mock the HttpClient and so get the java.net.http.HttpRequest", "label": {"api": {"java.net.http.HttpRequest": [[52, 76]]}}}, {"text": "Instead of reading the whole result as a single string you might want to consider reading it line by line using a scanner", "label": {"api": {"scanner": [[114, 120]]}}}, {"text": "The above uses this constructor of TextFormatter which accepts a UnaryOperator", "label": {"api": {"UnaryOperator": [[65, 77]]}}}, {"text": "The filter itself is an UnaryOperator that accepts TextFormatter.Change object", "label": {"api": {"UnaryOperator": [[24, 36]]}}}, {"text": "I'm looking for an operator like peek() of Java Streams or tap() in RxJS", "label": {"api": {"peek()": [[33, 38]]}}}, {"text": "I have integrated a JFileChooser into a JavaFX application using a SwingNode", "label": {"api": {"SwingNode": [[67, 75]]}}}, {"text": "The Javadocs for Stack state", "label": {"api": {"Javadocs for Stack": [[4, 21]]}}}, {"text": "You should have a look at java.nio because it is a more modern way to perform operations on the file system", "label": {"api": {"java.nio": [[26, 33]]}}}, {"text": "The following example renames the given file (as java.nio.Path) or throws an Exception (e.g", "label": {"api": {"java.nio": [[49, 56]]}}}, {"text": "Instead, use a pattern that matches the actual polynomial term, and use a Matcher, specifically its find and group methods, to extract each matched term", "label": {"api": {"find": [[100, 103]], "group": [[109, 113]]}}}, {"text": "You are calling this method from the main thread, but you will receive an IllegalStateException as noted in the API documentation (https://docs.oracle.com/javase/8/javafx/api/javafx/stage/Stage.html) if the Stage object is instantiated in any other thread besides the JavaFX Application thread", "label": {"api": {"https://docs.oracle.com/javase/8/javafx/api/javafx/stage/Stage.html": [[131, 197]]}}}, {"text": "You need to externally synchronize structural modifications, as stated in the Javadoc", "label": {"api": {"in the Javadoc": [[71, 84]]}}}, {"text": "You've identified correctly that you need java.util.Base64", "label": {"api": {"java.util.Base64": [[42, 57]]}}}, {"text": "The problem is that you are using java.sql.Time.valueOf(String) and depend on LocalTime.toString() format which may not print seconds because", "label": {"api": {"LocalTime.toString()": [[78, 97]]}}}, {"text": "You should use Time.valueOf(LocalTime)", "label": {"api": {"Time.valueOf(LocalTime)": [[15, 37]]}}}, {"text": "Is there a simpler approach by which I can convert Pair to 2 dimensional array", "label": {"api": {"Pair": [[51, 54]]}}}, {"text": "Also by default CompletableFuture uses the ForkJoinPool, so you need to also pass your custom executor", "label": {"api": {"pass your custom executor": [[77, 101]]}}}, {"text": "You can pass a custom Executor which names the threads it creates", "label": {"api": {"pass a custom Executor": [[8, 29]]}}}, {"text": "No, CompletableFuture is bundled in the JDK itself and does not have any dependency on any external jar", "label": {"api": {"CompletableFuture": [[4, 20]]}}}, {"text": "I am trying to understand the javax.persistence annotations @OneToOne, @ManyToOne and @ManyToMany", "label": {"api": {"@OneToOne": [[60, 68]], "@ManyToOne": [[71, 80]], "@ManyToMany": [[86, 96]]}}}, {"text": "This is achieved by using the field declarations in the Character.UnicodeBlock class", "label": {"api": {"Character.UnicodeBlock": [[56, 77]]}}}, {"text": "As the Files class makes all effort superfluous, use that", "label": {"api": {"Files": [[7, 11]]}}}, {"text": "Read an integer from the scanner instead (see Scanner#nextInt)", "label": {"api": {"Scanner#nextInt": [[46, 60]]}}}, {"text": "To make such an operation atomic, you can use AtomicReference", "label": {"api": {"AtomicReference": [[46, 60]]}}}, {"text": "If you want to keep track of each Beverage the user clicks use an ArrayList (allows duplicates) which seems convenient in this case", "label": {"api": {"ArrayList": [[66, 74]]}}}, {"text": "Use an ActionListener to the button of each Beverage, which will do the summary and then show to the user any message you want (for example the summary of the prices)", "label": {"api": {"ActionListener": [[7, 20]]}}}, {"text": "Use a static method of JOptionPane, such as the showMessageDialog ones, which will pop a new dialog displaying a simple message (such as the total cost of Beverage instances the user has selected)", "label": {"api": {"JOptionPane": [[23, 33]]}}}, {"text": "\"TEST1\" and \"TEST2\"), or alter one of the nested maps stored under \"TEST\", or introduce an altogether different data structure (such as a java.util.Set)", "label": {"api": {"java.util.Set": [[138, 150]]}}}, {"text": "With a ListMultimap you can call asMap() to get a view as a java.util.Map, then do normal map things", "label": {"api": {"java.util.Map": [[60, 72]]}}}, {"text": "I can't speak to whether there are any real exceptions that could occur within the try – something like OutOfMemoryError might occur, but wouldn't be caught with catch (Exception e) – but I believe this is just due to the compiler being extra careful (perhaps unnecessarily so)", "label": {"api": {"OutOfMemoryError": [[104, 119]]}}}, {"text": "You could consider using Futures (https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html)", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html": [[34, 107]]}}}, {"text": "CompletableFuture.runAsync documentation states", "label": {"api": {"CompletableFuture.runAsync": [[0, 25]]}}}, {"text": "Returns a new CompletableFuture that is asynchronously completed by a task running in the ForkJoinPool.commonPool() after it runs the given action", "label": {"api": {"ForkJoinPool.commonPool()": [[90, 114]]}}}, {"text": "However, as far as I can tell, runAsync only submits a task to ForkJoinPool.commonPool() when ForkJoinPool.getCommonPoolParallelism() > 1", "label": {"api": {"ForkJoinPool.commonPool()": [[63, 87]]}}}, {"text": "From the documentation of the getSubimage method", "label": {"api": {"documentation of the getSubimage method": [[9, 47]]}}}, {"text": "The documentation for nextLong() says only", "label": {"api": {"nextLong()": [[22, 31]]}}}, {"text": "Using Java11's HttpClient it could look like follows", "label": {"api": {"HttpClient": [[15, 24]]}}}, {"text": "You should use RFC_1123_DATE_TIME formatter", "label": {"api": {"RFC_1123_DATE_TIME": [[15, 32]]}}}, {"text": "I have already looked at X509Certificate::getBasicConstraints() method which returns an int", "label": {"api": {"X509Certificate::getBasicConstraints()": [[25, 62]]}}}, {"text": "Use FileWriter(File file, boolean append) to open the log file in append mode", "label": {"api": {"FileWriter(File file, boolean append)": [[4, 40]]}}}, {"text": "You can restrict input solely to numerals by using JFormattedTextField in lieu of a normal JTextField", "label": {"api": {"JFormattedTextField": [[51, 69]]}}}, {"text": "I also tried with ExecutorService but it is roughly the same, I can't instantiate my consecutive task and find some way to the second one to retrieve a value from the first one without separating each task in a method", "label": {"api": {"ExecutorService": [[18, 32]]}}}, {"text": "I also checked regexes in Java, but did not find anything about a Vowel class for example", "label": {"api": {"regexes in Java": [[15, 29]]}}}, {"text": "However, when I check using the Field.isSynthetic method, it actually returns false", "label": {"api": {"Field.isSynthetic": [[32, 48]]}}}, {"text": "Am I misinterpreting the JVMS, am I misinterpreting the Field.isSynthetic method documentation, are the spec and the docs using the word \"synthetic\" to mean different things, or is this a bug", "label": {"api": {"Field.isSynthetic": [[56, 72]]}}}, {"text": "A solution to this is to use a CipherOutputStream", "label": {"api": {"CipherOutputStream": [[31, 48]]}}}, {"text": "Because ThreadLocalRandom#ints returns an infinite IntStream, you'll need to use IntStream#filter and IntStream#findFirst to short-circuit it", "label": {"api": {"ThreadLocalRandom#ints": [[8, 29]], "IntStream": [[51, 59], [81, 89], [102, 110]], "IntStream#filter": [[81, 96]], "IntStream#findFirst": [[102, 120]]}}}, {"text": "The copyOfRange call is erroneous; note that the second argument is exclusive rather than inclusive", "label": {"api": {"copyOfRange": [[4, 14]]}}}, {"text": "So when calling copyOfRange(a, b, c) for example, the array a is copied from index b to c - 1, not c", "label": {"api": {"copyOfRange": [[16, 26]]}}}, {"text": "You should create your own custom Collector for this", "label": {"api": {"Collector": [[34, 42]]}}}, {"text": "I also recommend you look into both EnumSet and EnumMap as they may provide additional alternatives", "label": {"api": {"EnumSet": [[36, 42]], "EnumMap": [[48, 54]]}}}, {"text": "Stream.sorted(Comparator) makes a stable sort if the stream is ordered", "label": {"api": {"Stream.sorted(Comparator)": [[0, 24]]}}}, {"text": "Add pn2 to another JPanel and then set that panel to the JFrame using setContentPane", "label": {"api": {"setContentPane": [[70, 83]]}}}, {"text": "This is not how PreparedStatement should be used", "label": {"api": {"PreparedStatement": [[16, 32]]}}}, {"text": "I also recommend to use PreparedStatement::executeUpdate", "label": {"api": {"PreparedStatement": [[24, 40]], "PreparedStatement::executeUpdate": [[24, 55]]}}}, {"text": "Executes the SQL statement in this PreparedStatement object, which must be an SQL Data Manipulation Language (DML) statement, such as INSERT, UPDATE or DELETE; or an SQL statement that returns nothing, such as a DDL statement", "label": {"api": {"PreparedStatement": [[35, 51]]}}}, {"text": "Using Stream::anyMatch twice assures there is the condition you have raised met", "label": {"api": {"Stream::anyMatch": [[6, 21]]}}}, {"text": "If you want to return that item, use a different approach using Stream::filter which is not a terminal operation like the operation above and allows the Stream to continue", "label": {"api": {"Stream::filter": [[64, 77]]}}}, {"text": "Stream::findAny retruns an Optional of the qualifed instance", "label": {"api": {"Stream::findAny": [[0, 14]]}}}, {"text": "You can use the java.lang.Integer.numberOfTrailingZeros to get it", "label": {"api": {"java.lang.Integer.numberOfTrailingZeros": [[16, 54]]}}}, {"text": "The FileVisitOption.FOLLOW_LINKS is for symbolic directory links only", "label": {"api": {"File": [[4, 7]]}}}, {"text": "See File and Files documentation", "label": {"api": {"File": [[4, 7], [13, 16]], "Files": [[13, 17]]}}}, {"text": "I noticed that IOdiInterfaceFinder is marked as deprecated, so it might not play well with Oracle 12c", "label": {"api": {"marked as deprecated": [[38, 57]]}}}, {"text": "That's the constructor that scans the string itself", "label": {"api": {"the constructor": [[7, 21]]}}}, {"text": "Writing to a file with a Formatter the way you do works because the Formatter constructor that takes a String assumes that the string is a file name", "label": {"api": {"Formatter": [[25, 33], [68, 76]]}}}, {"text": "The documentation of add() state that an IllegalStateException is thrown if the queue is full", "label": {"api": {"add()": [[21, 25]]}}}, {"text": "If you want to forcefully halt the JVM, you can call Runtime#halt", "label": {"api": {"Runtime#halt": [[53, 64]]}}}, {"text": "Here's an approach using a parallel IntStream", "label": {"api": {"IntStream": [[36, 44]]}}}, {"text": "You have to escape the parenthesis because replaceAll use regex, and parenthesis is a reserved characters in regex to define groups", "label": {"api": {"replaceAll": [[43, 52]], "replace": [[43, 49]]}}}, {"text": "or in your case, you just need use replace", "label": {"api": {"replace": [[35, 41]]}}}, {"text": "use LocalDate instead", "label": {"api": {"LocalDate": [[4, 12]]}}}, {"text": "You can just use either java 8 LocalDate or Date API", "label": {"api": {"LocalDate": [[31, 39]], "Date": [[36, 39], [44, 47]]}}}, {"text": "LocalDate is thread safe and immutable, most recommended way of handling date use cases", "label": {"api": {"LocalDate": [[0, 8]], "Date": [[5, 8]]}}}, {"text": "If you insist on creating your own Date class you can just easily do the following", "label": {"api": {"Date": [[35, 38]]}}}, {"text": "Using the Date class", "label": {"api": {"Date": [[10, 13]]}}}, {"text": "If you want all of the charset encoding to be handled inside this method, return a Reader, the analogue of InputStream that represents a stream of chars", "label": {"api": {"Reader": [[83, 88]]}}}, {"text": "For example, you could return an InputStreamReader, e.g", "label": {"api": {"Reader": [[44, 49]]}}}, {"text": "new InputStreamReader(zipIn, charset)", "label": {"api": {"Reader": [[15, 20]]}}}, {"text": "You need to use an @SqlResultSetMapping", "label": {"api": {"@SqlResultSetMapping": [[19, 38]]}}}, {"text": "Use the URI class to extract the path (the part between the host and the ?, if any), then look for the last occurrence of ==", "label": {"api": {"URI class": [[8, 16]]}}}, {"text": "This feels like it has something to do with the IP_MULTICAT_LOOP socket option which is surprisingly enabled by default in Java Multicast Sockets", "label": {"api": {"enabled by default in Java Multicast Sockets": [[101, 144]]}}}, {"text": "From the documentation for Java's Matcher#matches() method", "label": {"api": {"Matcher#matches()": [[34, 50]]}}}, {"text": "This is the very same code rewritten in Java-8 compliant Optional", "label": {"api": {"Optional": [[57, 64]]}}}, {"text": "The logged statement dbUser.get().getStatus() might throw NoSuchElementException", "label": {"api": {"NoSuchElementException": [[58, 79]]}}}, {"text": "The statement id -> id.indexOf(\"1\") >= 0 means that the \"1\" is contained in the given string at any position, therefore the following expression using String::contains would me more suitable", "label": {"api": {"String::contains": [[151, 166]]}}}, {"text": "On the other hand, I feel you might want to count these ids having \"1\" at the first position, therefore String::startsWith is better", "label": {"api": {"String::startsWith": [[104, 121]]}}}, {"text": "Just one last tip, if you ever need dynamic arrays in Java, check out ArrayList", "label": {"api": {"ArrayList": [[70, 78]]}}}, {"text": "(Y/N)\" with next() but didn't handle the newline following the \"Y\"", "label": {"api": {"next()": [[12, 17]]}}}, {"text": "I will try to complete Answer by Basil Bourque by covering a time zoned date using the ZonedDateTime class", "label": {"api": {"ZonedDateTime": [[87, 99]]}}}, {"text": "If you need it, instead of using intrinsic locking with a simple Object, you can use a Lock implementation to get more capabilities, like interruptibility or time-outs on lock acquisition", "label": {"api": {"Lock implementation": [[87, 105]]}}}, {"text": "But in this case, an AtomicInteger (or AtomicLong) looks like a good fit", "label": {"api": {"AtomicInteger": [[21, 33]]}}}, {"text": "See this documentation page", "label": {"api": {"this documentation page": [[4, 26]]}}}, {"text": "The easy way is to use the BigInteger class and its methods exclusively during your learning exercises", "label": {"api": {"BigInteger": [[27, 36]]}}}, {"text": "In particular, you want to be using BigInteger.modPow for all modular exponentiations", "label": {"api": {"BigInteger": [[36, 45]], "BigInteger.modPow": [[36, 52]]}}}, {"text": "Here's what the documentation of File#getName() says", "label": {"api": {"File#getName()": [[33, 46]]}}}, {"text": "You could do this via File#getPath() but it'd probably be easier to just use the FileReader#<init>(File) constructor and pass the File object directly", "label": {"api": {"File#getPath()": [[22, 35]], "FileReader#<init>(File)": [[81, 103]], "Path": [[30, 33]]}}}, {"text": "You can use the NIO.2 API to open a BufferedReader by converting the File to a Path via File#toPath() and then using Files#newBufferedReader(Path)", "label": {"api": {"Path": [[79, 82], [95, 98], [141, 144]], "File#toPath()": [[88, 100]], "Files#newBufferedReader(Path)": [[117, 145]]}}}, {"text": "Also see some of the other available API, such as Files#lines(Path) (don't forget to close the Stream when done with it)", "label": {"api": {"Path": [[62, 65]], "Files#lines(Path)": [[50, 66]]}}}, {"text": "In JDBC, you use the factory class DriverManager and call e.g", "label": {"api": {"DriverManager": [[35, 47]], "Driver": [[35, 40]]}}}, {"text": "getConnection​(String url, String user, String password)", "label": {"api": {"getConnection​(String url, String user, String password)": [[0, 55]]}}}, {"text": "The factory class will do the ServiceLoader logic to find the implementation of the Driver interface, which is basically a Factory interface", "label": {"api": {"Driver": [[84, 89]]}}}, {"text": "It will then invoke the connect​(String url, Properties info) method to create the actual Connection object", "label": {"api": {"connect​(String url, Properties info)": [[24, 60]]}}}, {"text": "For a thread-safe solution, you'll need to protect the addition, e.g., by using an AtomicInteger", "label": {"api": {"AtomicInteger": [[83, 95]]}}}, {"text": "You need to call s.intern() to ensure you get a String that has both same value and memory address from String Pool", "label": {"api": {"s.intern()": [[17, 26]]}}}, {"text": "After using the recommendation of @JBNizet, i have used the BorderLayout https://docs.oracle.com/javase/8/docs/api/java/awt/BorderLayout.html to fit according to my specifications", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/awt/BorderLayout.html": [[73, 140]]}}}, {"text": "Use a HashMap", "label": {"api": {"HashMap": [[6, 12]]}}}, {"text": "The correct way to execute something in a particular directory is not by trying to send a cd command, but by specifying the directory in the ProcessBuilder itself", "label": {"api": {"specifying the directory in the ProcessBuilder itself": [[109, 161]]}}}, {"text": "From document SimpleDateTimePattern, yy should be the same with YY", "label": {"api": {"SimpleDateTimePattern": [[14, 34]]}}}, {"text": "You can use subList method", "label": {"api": {"subList": [[12, 18]]}}}, {"text": "To make it in one shot you have to use computeIfAbsent", "label": {"api": {"computeIfAbsent": [[39, 53]]}}}, {"text": "the javadoc of getOrDefault()", "label": {"api": {"getOrDefault()": [[15, 28]]}}}, {"text": "However, the correct way to do this is to use computeIfAbsent(), for 2 reasons", "label": {"api": {"computeIfAbsent()": [[46, 62]]}}}, {"text": "How about using Instrumentation.getAllLoadedClasses", "label": {"api": {"Instrumentation.getAllLoadedClasses": [[16, 50]]}}}, {"text": "Provides extra functionality for classes in java.lang", "label": {"api": {"java.lang": [[44, 52]]}}}, {"text": "Lang provides a host of helper utilities for the java.lang API, notably String manipulation methods, basic numerical methods, object reflection, concurrency, creation and serialization and System properties", "label": {"api": {"java.lang": [[49, 57]]}}}, {"text": "\"Lang\" refers to the core java package java.lang", "label": {"api": {"java.lang": [[39, 47]]}}}, {"text": "For reference, the javadoc of package java.lang says", "label": {"api": {"java.lang": [[38, 46]]}}}, {"text": "The normal way to do that is a queue", "label": {"api": {"queue": [[31, 35]]}}}, {"text": "Create a queue and make references to it available to both threads", "label": {"api": {"queue": [[9, 13]]}}}, {"text": "The main thread should add() an element to the queue (e.g", "label": {"api": {"queue": [[47, 51]]}}}, {"text": "The other thread should poll() the queue and use this information to update its internal state", "label": {"api": {"queue": [[35, 39]]}}}, {"text": "From Java-8 onwards use #Stream API, I have implemented the code below", "label": {"api": {"#Stream API": [[24, 34]]}}}, {"text": "Try using this constructor, that takes the class name of the factory", "label": {"api": {"this constructor": [[10, 25]]}}}, {"text": "You can use IntSummaryStatistics, with all its functionality Average, Sum, Max, .", "label": {"api": {"IntSummaryStatistics": [[12, 31]]}}}, {"text": "You can use DateTimeFormatter with withLocale", "label": {"api": {"DateTimeFormatter": [[12, 28]], "withLocale": [[35, 44]]}}}, {"text": "Using both Java 8 and Java 11, consider the following TreeSet with a String::compareToIgnoreCase comparator", "label": {"api": {"TreeSet": [[54, 60]], "String::compareToIgnoreCase": [[69, 95]]}}}, {"text": "When I try to remove the exact elements present in the TreeSet, it works", "label": {"api": {"TreeSet": [[55, 61]]}}}, {"text": "However, if I try to remove instead more than is present in the TreeSet, the call doesn't remove anything at all (this is not a subsequent call but called instead of the snippet above)", "label": {"api": {"TreeSet": [[64, 70]]}}}, {"text": "String::compareToIgnoreCase is a valid comparator", "label": {"api": {"String::compareToIgnoreCase": [[0, 26]]}}}, {"text": "Here's the javadoc of removeAll()", "label": {"api": {"removeAll()": [[22, 32]]}}}, {"text": "Any difference between java.util.Collections.synchronizedList() and Apache commons-collections' ListUtils.synchronizedList()", "label": {"api": {"java.util.Collections.synchronizedList()": [[23, 62]]}}}, {"text": "For Java's LinkedList, it will require multiple traversals to do multiple indexing operations", "label": {"api": {"Java's LinkedList": [[4, 20]]}}}, {"text": "You'd probably want to maintain an iterator from a call to listIterator to iterate if you need a bunch of \"near\" indexing operations", "label": {"api": {"iterator": [[35, 42]], "listIterator": [[59, 70]]}}}, {"text": "Or just use an ArrayList instead of a linked list", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "You can read more about this class at https://docs.oracle.com/javase/7/docs/api/java/io/FileWriter.html", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/FileWriter.html": [[38, 102]]}}}, {"text": "You can see the ulp limits for each calculation (method) in the docs for the Math class", "label": {"api": {"docs for the Math class": [[64, 86]]}}}, {"text": "You can read the documentation of System.out.println()", "label": {"api": {"System.out": [[34, 43]]}}}, {"text": "System.out is a PrintStream", "label": {"api": {"System.out": [[0, 9]]}}}, {"text": "PrintStream::println(Object) calls PrintStream::print(Object), which calls String.valueOf(Object), which returns the string \"null\" if the reference is null; otherwise returns obj.toString()", "label": {"api": {"PrintStream::println(Object)": [[0, 27]], "PrintStream::print(Object)": [[35, 60]], "String.valueOf(Object)": [[75, 96]]}}}, {"text": "Using StAX you first get a reader from XMLInputFactory", "label": {"api": {"XMLInputFactory": [[39, 53]]}}}, {"text": "If you have found the wanted StartElement - userCompany in your case - then you can get the value of the attribute named \"LITERAL\" from it", "label": {"api": {"StartElement": [[29, 40]]}}}, {"text": "You have to use arrayListObject.set(index, object)", "label": {"api": {"arrayListObject.set(index, object)": [[16, 49]]}}}, {"text": "The version elements are used by instances of the Runtime.Version class", "label": {"api": {"Runtime.Version": [[50, 64]]}}}, {"text": "You can obtain an instance for the currently running JVM using the Runtime.version() method", "label": {"api": {"Runtime.version()": [[67, 83]]}}}, {"text": "You will need to invoke Platform.runLater() to popup your window in the FX thread", "label": {"api": {"Platform.runLater()": [[24, 42]]}}}, {"text": "And you will have to wrap your function as a Runnable() in turn", "label": {"api": {"Runnable()": [[45, 54]]}}}, {"text": "You cannot use a method reference in the constructor of BigDecimal because it accepts neither interface matching the m -> m.getAmount() lambda expression (which is a Function<MoneyAmount, String>) nor any functional interface (see the constructors)", "label": {"api": {"BigDecimal": [[56, 65]], "Function<MoneyAmount, String>": [[166, 194]]}}}, {"text": "Also, note that Collectors::groupingBy returns a Map, therefore the return type has to correspond with the grouping strategy", "label": {"api": {"Collectors::groupingBy": [[16, 37]]}}}, {"text": "The downstream collector Collectors::reducing causes the List<BigDecimal> is reduced to BigDecimal using a mapper and an operator", "label": {"api": {"BigDecimal": [[62, 71], [88, 97]], "Collectors::reducing": [[25, 44]]}}}, {"text": "In case the amount is not BigDecimal but String which shall be used as the way to construct the BigDecimal, then change the downstream line with method reference MoneyAmount to", "label": {"api": {"BigDecimal": [[26, 35], [96, 105]]}}}, {"text": "Use ConcurrentSkipListSet instead of HashSet", "label": {"api": {"ConcurrentSkipListSet": [[4, 24]]}}}, {"text": "It can be instantiated by using ConcurrentHashMap.newKeySet() method", "label": {"api": {"ConcurrentHashMap.newKeySet()": [[32, 60]]}}}, {"text": "This Set is faster then ConcurrentSkipListSet and is not ordered", "label": {"api": {"ConcurrentSkipListSet": [[24, 44]]}}}, {"text": "Try converting the Date object to an Instant", "label": {"api": {"Instant": [[37, 43]]}}}, {"text": "Here's an example showing your input string first converted to a Date, and then converting that to an Instant", "label": {"api": {"Instant": [[102, 108]]}}}, {"text": "The exception is raised if the charsetName parameter of String.getBytes(String) or String(byte[], String) is invalid", "label": {"api": {"String.getBytes(String)": [[56, 78]], "String(byte[], String)": [[83, 104]]}}}, {"text": "In order to extract a part of an array, you could use Arrays.copyOfRange(), like this", "label": {"api": {"Arrays.copyOfRange()": [[54, 73]]}}}, {"text": "As you can see in here https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#substring(int,%20int) beginIndex always has to be lower than the endIndex", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#substring(int,%20int)": [[23, 107]]}}}, {"text": "In the third version the call to super(id); within CustomException's constructor would result in a compilation error since such a constructor does not exist within Exception", "label": {"api": {"Exception": [[57, 65], [164, 172]]}}}, {"text": "That's what Function is for", "label": {"api": {"Function": [[12, 19]]}}}, {"text": "Or, since the return type and the argument type are the same in your case, UnaryOperator", "label": {"api": {"UnaryOperator": [[75, 87]]}}}, {"text": "hm is a Path, thus list(hm) returns a Stream<Path>", "label": {"api": {"Path": [[8, 11], [45, 48]], "list(hm)": [[19, 26]]}}}, {"text": "There is no method compareToIgnoreCases(...) in class Path", "label": {"api": {"Path": [[54, 57]]}}}, {"text": "If one wants to use compareToIgnoreCase from String, one needs to transform the Path to String first, e.g", "label": {"api": {"Path": [[80, 83]], "compareToIgnoreCase from String": [[20, 50]]}}}, {"text": "The empty space between the components is probably caused by the Insets", "label": {"api": {"Insets": [[65, 70]]}}}, {"text": "An Insets object is a representation of the borders of a container", "label": {"api": {"Insets": [[3, 8]]}}}, {"text": "If you change all entries in the Insets to 0 the empty space should be gone", "label": {"api": {"Insets": [[33, 38]]}}}, {"text": "You can use the indexOf(char) method in the String class to check whether the character was in the word", "label": {"api": {"indexOf(char)": [[16, 28]]}}}, {"text": "You might be running into an issue because you're calling close() right after out.println() such that the close happens prior to I/O finishing", "label": {"api": {"close()": [[58, 64]]}}}, {"text": "You could try wrapping close() in a try-catch to see if any exceptions are thrown, like this", "label": {"api": {"close()": [[23, 29]]}}}, {"text": "According to the @Target documentation", "label": {"api": {"@Target documentation": [[17, 37]]}}}, {"text": "You can use the Stream.iterate() method to provide a custom seed object, which will be used in your iterations", "label": {"api": {"Stream.iterate()": [[16, 31]]}}}, {"text": "Based on this question I'm guessing its done using ServiceLoader but it's not clear to me exactly how to do this", "label": {"api": {"ServiceLoader": [[51, 63]]}}}, {"text": "If you want to test if a preference exists at all, you can use something like nodeExists()", "label": {"api": {"nodeExists()": [[78, 89]]}}}, {"text": "A Swing based Timer is recommended for updating GUI components - because the calls to the components are automatically on the Event Dispatch Thread (the correct thread for updating Swing or AWT based components)", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "The Swing Timer though, has a tendency to 'drift' off time", "label": {"api": {"Timer": [[10, 14]]}}}, {"text": "When using a Swing Timer to update a display which must be accurate (e.g", "label": {"api": {"Timer": [[19, 23]]}}}, {"text": "I'm assuming this is specifically an ExecutorService", "label": {"api": {"ExecutorService": [[37, 51]]}}}, {"text": "Actions in a thread prior to the submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the result is retrieved via Future.get()", "label": {"api": {"ExecutorService": [[81, 95]]}}}, {"text": "Here's an example using your code, with just two extra lines needed, to disable escaping, and then enable escaping, by calling the Document method createProcessingInstruction()", "label": {"api": {"calling the Document method createProcessingInstruction()": [[119, 175]]}}}, {"text": "The key is each Company, the value of the map is the sum of prices of all its products within purchases - this assures Collectors::groupingBy(Function, Collector)", "label": {"api": {"Collectors::groupingBy(Function, Collector)": [[119, 161]]}}}, {"text": "The downstream collector Collectors::summingDouble(ToDoubleFunction) is responsible for summing all the prices", "label": {"api": {"Collectors::summingDouble(ToDoubleFunction)": [[25, 67]]}}}, {"text": "My attempt using Stream::collect(Supplier, BiConsumer, BiConsumer) is a bit very clumsy and contains mutable operations such as Map::put and Map::remove which I would like to avoid", "label": {"api": {"Stream::collect(Supplier, BiConsumer, BiConsumer)": [[17, 65]]}}}, {"text": "Is there a solution using an appropriate combination of Collectors within one Stream::collect call (e.g", "label": {"api": {"Collectors": [[56, 65]]}}}, {"text": "This uses Map.merge with your reducing bi-function and uses LinkedHashMap to preserve original entries order", "label": {"api": {"Map.merge": [[10, 18]]}}}, {"text": "PriorityQueue's toString() method, inherited from AbstractCollection, uses the iterator() method; according to the Javadoc", "label": {"api": {"toString() method": [[16, 32]], "according to the Javadoc": [[98, 121]]}}}, {"text": "From Javadoc for PriorityQueue", "label": {"api": {"Javadoc for PriorityQueue": [[5, 29]]}}}, {"text": "If you need ordered traversal, consider using Arrays.sort(pq.toArray())", "label": {"api": {"toArray()": [[61, 69]]}}}, {"text": "Note that toArray() also returns elements in no particular order", "label": {"api": {"toArray()": [[10, 18]]}}}, {"text": "Another option to use huge pages for direct ByteBuffers is to create a file on a hugetlbfs filesystem and then map it in Java as a MappedByteBuffer", "label": {"api": {"MappedByteBuffer": [[131, 146]]}}}, {"text": "Object[] arrays and Vector exist in Java since the beginning with Java version 1.0", "label": {"api": {"Vector": [[20, 25]]}}}, {"text": "As value is in milliseconds, the 5000 is not the one because it's just 5 seconds - any small network hiccup and your connection will get axed", "label": {"api": {"milliseconds": [[15, 26]]}}}, {"text": "For data transfer timeout (which definitely should be set higher) you need to use setReadTimeout()", "label": {"api": {"setReadTimeout()": [[82, 97]]}}}, {"text": "These various features are described in the Pattern documentation", "label": {"api": {"Pattern documentation": [[44, 64]]}}}, {"text": "I suggest using BigInteger", "label": {"api": {"BigInteger": [[16, 25]]}}}, {"text": "The other route is using Long to parse the value", "label": {"api": {"Long": [[25, 28]]}}}, {"text": "From the API", "label": {"api": {"From the API": [[0, 11]]}}}, {"text": "You can use the generated Stream using IntStream and process the numbers in the same way", "label": {"api": {"IntStream": [[39, 47]]}}}, {"text": "Note that Math::pow returns Double therefore the pipeline results in DoubleStream", "label": {"api": {"Math::pow": [[10, 18]], "DoubleStream": [[69, 80]]}}}, {"text": "If you're always reading from the same file you can use Files.readAllLines(path, charset) to read the files contents and use it", "label": {"api": {"Files.readAllLines(path, charset)": [[56, 88]]}}}, {"text": "java time API", "label": {"api": {"java time API": [[0, 12]]}}}, {"text": "The Files.isExecutable Java method tests whether a path (file or directory) is executable", "label": {"api": {"Files.isExecutable": [[4, 21]]}}}, {"text": "For converting your result to a String I would recommend using the null-friendly Objects.toString(Object, String) as such", "label": {"api": {"Objects.toString(Object, String)": [[81, 112]]}}}, {"text": "Please check https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html for further details", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html": [[13, 76]]}}}, {"text": "If your Dog instances are in a List your best bet for sorting is using Java's Comparator class with List#sort", "label": {"api": {"List": [[31, 34], [100, 103]], "Comparator": [[78, 87]], "List#sort": [[100, 108]]}}}, {"text": "You can use the default methods of Comparator to create a comparator on multiple criteria", "label": {"api": {"Comparator": [[35, 44]]}}}, {"text": "Instead of Base64, you can use Base64InputStream which provides Base64 encoding and decoding in a streaming fashion (unlimited size)", "label": {"api": {"Base64": [[11, 16], [31, 36], [64, 69]]}}}, {"text": "You use Duration.ONE, which is", "label": {"api": {"Duration.ONE": [[8, 19]]}}}, {"text": "List.of(elements..) is a Java 9 construct for initializing a list, use something else if you aren't using Java 9+", "label": {"api": {"List.of(elements..)": [[0, 18]]}}}, {"text": "Integer is immutable", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "The javadoc of writeTo(OutputStream out) does not say anything about closing the OutputStream, which means it doesn't, so the last of the data is still sitting buffered in the un-closed, un-flushed FileOutputStream", "label": {"api": {"writeTo(OutputStream out)": [[15, 39]]}}}, {"text": "Also, a ByteArrayOutputStream does not need to be closed or flushed", "label": {"api": {"ByteArrayOutputStream": [[8, 28]]}}}, {"text": "As the javadoc of close() says it", "label": {"api": {"close()": [[18, 24]]}}}, {"text": "Closing a ByteArrayOutputStream has no effect", "label": {"api": {"ByteArrayOutputStream": [[10, 30]]}}}, {"text": "You will however need to call finish() on an ZipOutputStream to complete the content", "label": {"api": {"finish()": [[30, 37]], "ZipOutputStream": [[45, 59]]}}}, {"text": "If you look official document of the {string}.isEmpty()then you find just looks length of the string and tells wether it has value or not", "label": {"api": {"official document": [[12, 28]]}}}, {"text": "Use URL fields", "label": {"api": {"URL": [[4, 6]]}}}, {"text": "Better use Stream::anyMatch as a return value of the Predicate within the filter method", "label": {"api": {"Stream::anyMatch": [[11, 26]]}}}, {"text": "Because you trying to ignore the line-breaks and define ; as your custom line terminator, it is best to use String#split(String)", "label": {"api": {"String#split(String)": [[108, 127]]}}}, {"text": "An ExecutorService can be shut down, which will cause it to reject new tasks so the above created ScheduledExecutorService would become useless", "label": {"api": {"An ExecutorService can be shut down, which will cause it to reject new tasks": [[0, 75]], "ScheduledExecutorService": [[98, 121]]}}}, {"text": "When Javadoc files are generated, that \"link\" directive will evaluate to HTML that points to the toString() method on the \"Integer\" .html page (specifically this", "label": {"api": {"String": [[99, 104]]}}}, {"text": "https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#toString--), so you can go right there", "label": {"api": {"go right there": [[89, 102]], "String": [[67, 72]]}}}, {"text": "Here's another example with just \".\" characters (no \"#\"), from String which has a link ({@link java.text.Collator}) which generates a URL (https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/Collator.html) that goes to the top of the page for java.text.Collator", "label": {"api": {"String": [[63, 68]], "the top of the page for java.text.Collator": [[238, 279]]}}}, {"text": "It takes OutputStream as a parameter and blindly writes the downloaded data to it", "label": {"api": {"OutputStream": [[9, 20]]}}}, {"text": "It is up to the OutputStream, what it does with the data", "label": {"api": {"OutputStream": [[16, 27]]}}}, {"text": "If you use FileOutputStream, it will overwrite the existing file immediately – even before you actually call FTPClient.retrieveFile", "label": {"api": {"OutputStream": [[15, 26]], "FileOutputStream": [[11, 26]]}}}, {"text": "means \"any character\", because replaceAll uses regular expressions", "label": {"api": {"regular expressions": [[47, 65]]}}}, {"text": "Try using FadeTransition", "label": {"api": {"FadeTransition": [[10, 23]]}}}, {"text": "Java is smart enough to be able to treat a function myButtonActionListener with the appropriate declaration, as if you implemented an anonymous class that implements the required interface ActionListener", "label": {"api": {"ActionListener": [[60, 73], [189, 202]]}}}, {"text": "That's the only reason myButtonActionListener can be used as you described, because ActionListener only requires you to implement one function and nothing else", "label": {"api": {"ActionListener": [[31, 44], [84, 97]]}}}, {"text": "However, KeyListener requires three (!) functions to be implemented", "label": {"api": {"KeyListener": [[9, 19]]}}}, {"text": "Java has no way to understand which of these three functions you are trying to \"implement\", because their declaration is the same and even if it did, then you still didn't implement the other two which is illegal by design, because you cant tell if the function using your KeyListener uses them", "label": {"api": {"KeyListener": [[273, 283]]}}}, {"text": "the javadoc for that method", "label": {"api": {"method": [[21, 26]]}}}, {"text": "As you use List#get(int index) to get a value of element with index i", "label": {"api": {"List#get(int index)": [[11, 29]]}}}, {"text": "You have to use a setter method, which is List#set(int index, E element), to assign the value to element with index i", "label": {"api": {"List#set(int index, E element)": [[42, 71]]}}}, {"text": "You can use replaceAll to transform elements in a list", "label": {"api": {"replaceAll": [[12, 21]]}}}, {"text": "Or if you don't want to change the original list, you can use map, to create a new list with elements transformed", "label": {"api": {"map": [[62, 64]]}}}, {"text": "This assumes Java 9 or above (for Map.entry) and the following static imports", "label": {"api": {"Map.entry": [[34, 42]]}}}, {"text": "As I have suggested in my comment, I would add an AtomicInteger to count the number of constructor calls", "label": {"api": {"AtomicInteger": [[50, 62]]}}}, {"text": "The reason for using an AtomicInteger is thread-safety", "label": {"api": {"AtomicInteger": [[24, 36]]}}}, {"text": "One involves overriding finalize() (which is deprecated in Java 13)", "label": {"api": {"finalize()": [[24, 33]]}}}, {"text": "The other uses a List of PhantomReferences to track reachable instances", "label": {"api": {"PhantomReferences": [[25, 41]]}}}, {"text": "You can use AtomicInteger, which is used in applications such as atomically incremented counters", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "The Number type has the longValue() method, so you can safely cast to Number and compare the result of calling that method", "label": {"api": {"longValue()": [[24, 34]]}}}, {"text": "Assuming that the lists have the same size and the elements are in the right order you could use an IntStream to solve your problem", "label": {"api": {"IntStream": [[100, 108]]}}}, {"text": "For Labeled there is the -fx-text-overrun style attribute - the values clip or ellipsis would be fine for me, but this is not available for Text-Flows", "label": {"api": {"-fx-text-overrun": [[25, 40]]}}}, {"text": "Best fits for your application would be either the BoxLayout or the FlowLayout", "label": {"api": {"BoxLayout": [[51, 59]], "FlowLayout": [[68, 77]]}}}, {"text": "You should always use the \"getContentPane()\" method on Frames and apply layouting and adding components to the \"ContentPane\"", "label": {"api": {"getContentPane()": [[27, 42]]}}}, {"text": "According to the corresponding section of the corresponding Java tutorials, you can override stopCellEditing of DefaultCellEditor to return false if the editor should not lose focus or true otherwise", "label": {"api": {"stopCellEditing": [[93, 107]], "DefaultCellEditor": [[112, 128]]}}}, {"text": "In the following example code I'm using a JTextField, which lets the users type whatever they want and then checks the user's input in stopCellEditing to be non-empty (as defined by my static checkValid method, but you can obviously alter it according to your needs)", "label": {"api": {"stopCellEditing": [[135, 149]]}}}, {"text": "An alternative solution could be to add an InputVerifier in the JTextField of the editor, but this would be a bit more tricky as I tested it, so I would rather not post it here in favor of the better above solution (and also suggested by the Java tutorial)", "label": {"api": {"InputVerifier": [[43, 55]]}}}, {"text": "Apache poi uses AttributedString and TextLayout to get the bounds out of a text in a special font", "label": {"api": {"AttributedString": [[16, 31]], "TextLayout": [[37, 46]]}}}, {"text": "Then get the width of that string in that font using java.awt.font.TextLayout", "label": {"api": {"TextLayout": [[67, 76]]}}}, {"text": "thenCombine can be used to express dependencies between CompletionStages allowing you to perform a task after both have completed", "label": {"api": {"thenCombine": [[0, 10]]}}}, {"text": "You can then preform the subsequent actions with thenApply", "label": {"api": {"thenApply": [[49, 57]]}}}, {"text": "The output \"pool size = 5, active threads = 4\" shows approximate number of active threads", "label": {"api": {"active threads": [[27, 40], [75, 88]]}}}, {"text": "It's not obvious from the documentation because they don't link it prominently (but subtly), but setOutputProperty refers to OutputKeys, and those values can be used for the property names (and contain information about what they do, like control the indentation of the output)", "label": {"api": {"OutputKeys": [[125, 134]]}}}, {"text": "Use getErrorStream() and getOutputStream() methods of Process to capture the output from the process somewhat like described here", "label": {"api": {"getErrorStream()": [[4, 19]]}}}, {"text": "The cleanest and most concise way of doing this would be to use the Java8 Stream API and the methods from the Array utility class", "label": {"api": {"Stream API": [[74, 83]], "Array": [[110, 114]]}}}, {"text": "The static method Array.getLength takes a reference of type Object", "label": {"api": {"Array": [[18, 22]], "Array.getLength": [[18, 32]], "Array.get": [[18, 26]]}}}, {"text": "Tne static method Array.get works accordingly to give access to individual array elements", "label": {"api": {"Array": [[18, 22]], "Array.get": [[18, 26]]}}}, {"text": "In addition to the concurrency tutorial recommended in the comments, the Javadoc for ReentrantLock has great info that's worth reading", "label": {"api": {"Javadoc for ReentrantLock": [[73, 97]]}}}, {"text": "Your example uses isLocked(), which Javadoc says you shouldn't do", "label": {"api": {"isLocked()": [[18, 27]]}}}, {"text": "A solution with streams", "label": {"api": {"streams": [[16, 22]]}}}, {"text": "Using isInstance() is the \"dynamic equivalent of the Java language instanceof operator\"", "label": {"api": {"isInstance()": [[6, 17]]}}}, {"text": "Comparing the output of getClass() will match exact classes only", "label": {"api": {"getClass()": [[24, 33]]}}}, {"text": "Using isAssignableFrom() will check if the class is \"the same as, or is a superclass or superinterface of, the class or interface represented by the specified Class parameter\"", "label": {"api": {"isAssignableFrom()": [[6, 23]]}}}, {"text": "Alternatively to @BeppeC's answer, if you can't easily determine the type of the object that you're injecting at runtime, and assuming that you don't have duplicate property names, I would use Class's getMethods() method and Method's getName() method", "label": {"api": {"Class's getMethods()": [[193, 212]], "Method's getName()": [[225, 242]]}}}, {"text": "If I understand your problem, you can use that (java.util.Objects is here since JDK7)", "label": {"api": {"java.util.Objects": [[48, 64]]}}}, {"text": "Create a Path2D", "label": {"api": {"Path2D": [[9, 14]]}}}, {"text": "Or use drawPolyline(int[] xPoints, int[] yPoints, int nPoints)", "label": {"api": {"drawPolyline(int[] xPoints, int[] yPoints, int nPoints)": [[7, 61]]}}}, {"text": "Or use drawPolygon(int[] xPoints, int[] yPoints, int nPoints) where you don't have to repeat the first point at the end", "label": {"api": {"drawPolygon(int[] xPoints, int[] yPoints, int nPoints)": [[7, 60]], "Polygon": [[11, 17]]}}}, {"text": "Or create a Polygon and use it, again without repeating the first point", "label": {"api": {"Polygon": [[12, 18]]}}}, {"text": "If you take a look at the source code of the Retrofit library, in particular the create() method of Retrofit.java class, you can see that they're using Java's Dynamic Proxy approach to create classes at runtime", "label": {"api": {"Java's Dynamic Proxy": [[152, 171]]}}}, {"text": "You need to create a modal JDialog then", "label": {"api": {"JDialog": [[27, 33]]}}}, {"text": "Dont use a JFrame as the child, use a JDialog", "label": {"api": {"JDialog": [[38, 44]]}}}, {"text": "Have a look at the constuctors of JDialog and pass as an owner the frame, and then set modal to true or the ModalityType to APPLICATION_MODAL for example", "label": {"api": {"JDialog": [[34, 40]], "ModalityType": [[108, 119]], "APPLICATION_MODAL": [[124, 140]]}}}, {"text": "You may want to use StringBuilder, where you can append any type of primitives", "label": {"api": {"StringBuilder": [[20, 32]]}}}, {"text": "The documentation of Supplier::get is not explicit on the possibility or not for it to return null", "label": {"api": {"Supplier::get": [[21, 33]]}}}, {"text": "The recommended way to return nothing, as of Java 8, is to return an Optional", "label": {"api": {"Optional": [[69, 76]]}}}, {"text": "Guide To Java 8 Optional", "label": {"api": {"Optional": [[16, 23]]}}}, {"text": "It is however too easy for the caller to forget to do that, which is why use of Optional is preferred", "label": {"api": {"Optional": [[80, 87]]}}}, {"text": "The capital Y represents Week based year as per official documentation of DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[74, 90]]}}}, {"text": "According to the docs of DateTimeFormatter, Y is the week-based year", "label": {"api": {"the docs of DateTimeFormatter": [[13, 41]]}}}, {"text": "Later, the java.net.URI class was added, which does all of the proper checks", "label": {"api": {"java.net.URI": [[11, 22]]}}}, {"text": "And a valid URI can be converted to a URL with the toURL() method", "label": {"api": {"toURL()": [[51, 57]]}}}, {"text": "The getNumOfMoves provides a hint that your Pokemon class should store more than one move, a common way to do this is with arrays or lists", "label": {"api": {"lists": [[133, 137]]}}}, {"text": "There still is ManagedExecutorService in JEE7 which can be used for this purpose", "label": {"api": {"ManagedExecutorService": [[15, 36]]}}}, {"text": "Use a CopyOnWriteArrayList instead", "label": {"api": {"CopyOnWriteArrayList": [[6, 25]]}}}, {"text": "There are various options (including using reflection) but in the simple case where the fields are all of the same type (here, String), my suggestion would be to store the values of interest in an EnumMap instead", "label": {"api": {"EnumMap": [[197, 203]]}}}, {"text": "You might try using a CompletableFuture", "label": {"api": {"CompletableFuture": [[22, 38]]}}}, {"text": "The LogManager documentation suggests .handlers is invalid because it is missing the logger specifier", "label": {"api": {"LogManager": [[4, 13]]}}}, {"text": "One solution is to use a Stream with Collectors#joining", "label": {"api": {"Stream": [[25, 30]], "Collectors#joining": [[37, 54]]}}}, {"text": "You are looking for a dropWhile operation, but an in-built implementation of that would require Java-9 and above", "label": {"api": {"dropWhile": [[22, 30]]}}}, {"text": "What you need is a custom TableCell that renders the byte array into an ImageView", "label": {"api": {"Image": [[72, 76]]}}}, {"text": "Then reference it inside your Controller and add a CellFactory to it", "label": {"api": {"CellFactory": [[51, 61]]}}}, {"text": "The CellFactory creates a table cell for each of your Avatar items, and the updateItem() method of that cell converts the bytes to an Image which in turn is rendered into an ImageView (if the cell is not empty)", "label": {"api": {"CellFactory": [[4, 14]], "Image": [[134, 138], [174, 178]]}}}, {"text": "Here's a way to convert an array of bytes to a JavaFX Image", "label": {"api": {"Image": [[54, 58]]}}}, {"text": "I would avoid calling thegetImageFromBytes() method from inside the updateItem(), especially for a TableView with lots of records", "label": {"api": {"Image": [[28, 32]]}}}, {"text": "Changed the updateItem() method to not create a new ImageView each time it is called", "label": {"api": {"Image": [[52, 56]]}}}, {"text": "If you want to kill the subprocess, use either destroy() or destroyForcibly()", "label": {"api": {"destroy()": [[47, 55]], "destroyForcibly()": [[60, 76]]}}}, {"text": "There are, however, custom types, such as AtomicInteger that can do the job", "label": {"api": {"AtomicInteger": [[42, 54]]}}}, {"text": "That's nice to have, and java intentionally does not allow you to break this without explicit consent (which takes the form of having the param be of type AtomicInteger instead)", "label": {"api": {"AtomicInteger": [[155, 167]]}}}, {"text": "You probably want java.net.URI", "label": {"api": {"java.net.URI": [[18, 29]]}}}, {"text": "According to https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/Color.html#getRed(), getRed(), getBlue() and getGreen() return int", "label": {"api": {"https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/Color.html#getRed()": [[13, 104]]}}}, {"text": "Welcome to SO, You can use contains method for check if your string has specific text", "label": {"api": {"contains method": [[27, 41]]}}}, {"text": "You can drop a range of elements from a ArrayList using subList", "label": {"api": {"subList": [[56, 62]]}}}, {"text": "The problem with subList is that it creates sublist keeping the original one in memory", "label": {"api": {"List": [[20, 23]]}}}, {"text": "However, ArrayList or other extension of AbstractList has removeRange(int fromIndex, int toIndex) which removes elements of current list, so doesn't require additional memory", "label": {"api": {"AbstractList": [[41, 52]], "List": [[14, 17], [49, 52]]}}}, {"text": "For the other List implementations there is similar remove(int index) which you can use multiple times for the same purpose", "label": {"api": {"List": [[14, 17]]}}}, {"text": "Call the newSchema method that takes a URL as argument", "label": {"api": {"the newSchema method that takes a URL as argument": [[5, 53]]}}}, {"text": "method.getGenericReturnType() returns java.lang.reflect.Type and as you can see in javadocs it have a list of known subtypes", "label": {"api": {"java.lang.reflect.Type": [[38, 59]]}}}, {"text": "Do not pass around the string SATURDAY, pass around the DayOfWeek.SATURDAY object", "label": {"api": {"DayOfWeek": [[56, 64]]}}}, {"text": "If you insist on using strings against my advice, you can get the name of the DayOfWeek enum object as text by calling toString", "label": {"api": {"DayOfWeek": [[78, 86]]}}}, {"text": "Going the other direction, calling DayOfWeek.valueOf", "label": {"api": {"DayOfWeek": [[35, 43]]}}}, {"text": "However, since your format happens to match the ISO-8601 format, which is the natural format of an Instant, just use the Instant.parse() method, without any need for a formatter", "label": {"api": {"Instant.parse()": [[121, 135]]}}}, {"text": "1) Using Arrays.copyOfRange() method", "label": {"api": {"Arrays.copyOfRange()": [[9, 28]]}}}, {"text": "You can use Arrays.stream as follows", "label": {"api": {"Arrays.stream": [[12, 24]]}}}, {"text": "For example, both the ArrayList and LinkedList classes have a get(int) method", "label": {"api": {"get(int)": [[62, 69]]}}}, {"text": "For example, Arrays.asList returns a java.util.Arrays$ArrayList object which is not an instance of java.util.ArrayList", "label": {"api": {"Arrays.asList": [[13, 25]]}}}, {"text": "how the standard library's binarySearch method ensures it takes a sequence which supports random access in O(1) time", "label": {"api": {"binarySearch": [[27, 38]]}}}, {"text": "A class is loaded through a ClassLoader", "label": {"api": {"ClassLoader": [[28, 38]]}}}, {"text": "Most classes are loaded and constructed through the ClassLoader.getSystemClassLoader(), the JVM takes care of constructing the class", "label": {"api": {"ClassLoader": [[52, 62], [73, 83]], "ClassLoader.getSystemClassLoader()": [[52, 85]]}}}, {"text": "The simplest way is to use a method reference to BigInteger::add", "label": {"api": {"BigInteger::add": [[49, 63]]}}}, {"text": "You can use the Comparator.thenComparing method", "label": {"api": {"Comparator.thenComparing": [[16, 39]]}}}, {"text": "The Comparator.comparing method also simplifies this so you don't have to write your own classes implementing Comparator", "label": {"api": {"Comparator.comparing": [[4, 23]]}}}, {"text": "the comparingDouble method instead of comparing", "label": {"api": {"comparingDouble": [[4, 18]]}}}, {"text": "There are also comparingInt and comparingLong", "label": {"api": {"comparingInt": [[15, 26]], "comparingLong": [[32, 44]]}}}, {"text": "Because the string you've given isn't an object, but an array", "label": {"api": {"array": [[56, 60]]}}}, {"text": "As you are executing a select statement, instead of using Statement.execute(..), you should use Statement.executeQuery(..) and iterate over its result set", "label": {"api": {"Statement.execute(..)": [[58, 78]], "Statement.executeQuery(..)": [[96, 121]]}}}, {"text": "See ScheduledExecutorService#schelude for details", "label": {"api": {"ScheduledExecutorService#schelude": [[4, 36]]}}}, {"text": "You should trim the strings first, after that filter by isEmpty and collect", "label": {"api": {"trim": [[11, 14]], "isEmpty": [[56, 62]]}}}, {"text": "However, you can use addAll() with your current usage", "label": {"api": {"addAll()": [[21, 28]]}}}, {"text": "MimetypesFileTypeMap has 5 different ways of identifying a file and I was hoping that the third method (looking in META-INF/mime.types) would work as i edited it so the .h extension is now text/x-h instead of text/h-c but it seems to be defaulting to an earlier comparison that I cant figure out how to bypass", "label": {"api": {"MimetypesFileTypeMap": [[0, 19]]}}}, {"text": "executeUpdate() is documented as", "label": {"api": {"documented": [[19, 28]]}}}, {"text": "If you take a look at the Java-Doc for SimpleDateFormat.parse(), you can see that the TimeZone might be overwritten", "label": {"api": {"the Java-Doc for SimpleDateFormat.parse()": [[22, 62]]}}}, {"text": "You need WeekFields, which has an of method that takes a Locale", "label": {"api": {"WeekFields": [[9, 18]]}}}, {"text": "Use this modified Node class", "label": {"api": {"Node": [[18, 21]]}}}, {"text": "You may consider renaming your class Node as it clashes with Node", "label": {"api": {"Node": [[37, 40], [61, 64]]}}}, {"text": "If you can use Java 8 or higher, then it's recommended to use java.time for operations with dates and times", "label": {"api": {"java.time": [[62, 70]]}}}, {"text": "Should be easy to use for file output, which should be done with java.nio nowadays", "label": {"api": {"java.nio": [[65, 72]]}}}, {"text": "To complete my two previous points and to solve partially yours, you can take a look at List in java", "label": {"api": {"List": [[88, 91]]}}}, {"text": "For performance reasons, it \"obtains an array containing all elements in this list, sorts the array, [and writes back to the list]\"", "label": {"api": {"\"obtains an array containing all elements in this list, sorts the array, [and writes back to the list]\"": [[28, 130]]}}}, {"text": "You can search for an element with a particular ID using the conveniently named getElementById method", "label": {"api": {"getElementById": [[80, 93]]}}}, {"text": "If the element does not have an id attribute, you will have to rely on the document’s structure and use XPath to find the HTML element of interest", "label": {"api": {"XPath": [[104, 108]]}}}, {"text": "A tutorial on the use of XPath would make this answer too large, but you can learn about it yourself by reading the specification", "label": {"api": {"XPath": [[25, 29]]}}}, {"text": "If it’s just text, you can use the element’s getTextContent() method", "label": {"api": {"getTextContent()": [[45, 60]]}}}, {"text": "The matching you describe would not be symmetric and transitive as required by the documentation (https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object))", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)": [[98, 185]]}}}, {"text": "Stream inherits an iterator() method to produce an Iterator", "label": {"api": {"Stream": [[0, 5]], "iterator()": [[19, 28]], "Iterator": [[51, 58]]}}}, {"text": "But I need an Iterable rather than an Iterator", "label": {"api": {"Iterator": [[38, 45]], "Iterable": [[14, 21]]}}}, {"text": "…I need to pass those parts of string as an Iterable to a specific library", "label": {"api": {"Iterable": [[44, 51]]}}}, {"text": "Calling input.lines() yields a Stream", "label": {"api": {"Stream": [[31, 36]]}}}, {"text": "So I would be set if I could make that Stream into a Iterable of its elements", "label": {"api": {"Stream": [[39, 44]], "Iterable": [[53, 60]]}}}, {"text": "You can wrap the int inside of a mutable class wrapper, such as Java's AtomicInteger or Apache's MutableInt, and pass around an instance of that class, eg", "label": {"api": {"AtomicInteger": [[71, 83]]}}}, {"text": "I use Map::getOrDefault to either replace the value or keep it as is if no mapping is found", "label": {"api": {"Map::getOrDefault": [[6, 22]]}}}, {"text": "using ProcessBuilder) with the credentials of the other user", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "The lambda expression is nothing else than the implementation of an anonymous class with one method (this secures @FunctionalInterface annotation)", "label": {"api": {"@FunctionalInterface": [[114, 133]]}}}, {"text": "Java already has Collection that doesn't allow duplicate elements - it's called Set", "label": {"api": {"Set": [[80, 82]]}}}, {"text": "Build a compound Comparator incrementally using thenComparing(Comparator)", "label": {"api": {"Comparator": [[17, 26], [62, 71]], "thenComparing(Comparator)": [[48, 72]]}}}, {"text": "Though I would actually turn it around a bit, and let the method just build the Comparator, leaving the caller to use it", "label": {"api": {"Comparator": [[80, 89]]}}}, {"text": "The Stream is ordered", "label": {"api": {"ordered": [[14, 20]]}}}, {"text": "A stream sourced by a List is ordered, even with parallel enabled", "label": {"api": {"ordered": [[30, 36]]}}}, {"text": "The accumulator passed to reduce() is associative", "label": {"api": {"associative": [[38, 48]]}}}, {"text": "Consumer::andThen is associative", "label": {"api": {"associative": [[21, 31]]}}}, {"text": "So although the compound consumer is built like [[A, B], [C, D]] instead of the left-associative [[[A, B], C], D], the 4 consumers are executed in order, all because Consumer::andThen is associative", "label": {"api": {"associative": [[85, 95], [187, 197]]}}}, {"text": "You're looking for java.lang.Class", "label": {"api": {"java.lang.Class": [[19, 33]]}}}, {"text": "That Date constructor is deprecated, like all Date constructors other than the one that takes a milliseconds argument", "label": {"api": {"is deprecated": [[22, 34]]}}}, {"text": "The class which is designed to represent a time difference is java.time.Duration", "label": {"api": {"java.time.Duration": [[62, 79]]}}}, {"text": "The simplest time value is probably Instant, so you will want a private field of type Instant in the class which creates the Timer and adds a listener to the button, to keep track of when the button was pressed", "label": {"api": {"Instant": [[36, 42], [86, 92]]}}}, {"text": "Finally, your Timer can calculate the Duration using Duration.between", "label": {"api": {"Duration.between": [[53, 68]]}}}, {"text": "As per the documentation on Oracle's website", "label": {"api": {"the documentation on Oracle's website": [[7, 43]]}}}, {"text": "Sounds like java.util.concurrent.LongAdder might be what you're looking for", "label": {"api": {"java.util.concurrent.LongAdder": [[12, 41]]}}}, {"text": "That being said, there is a simpler way to generate a stream of random numbers using Random#ints(long,int,int), which", "label": {"api": {"Random#ints(long,int,int)": [[85, 109]]}}}, {"text": "Base64url encoding is possible in Java with on-board means [9]", "label": {"api": {"[9]": [[59, 61]]}}}, {"text": "While I'm at it, you may be interested in the library method Arrays.binarySearch, which does what you want faster and without the inconvenience of bugs", "label": {"api": {"Arrays.binarySearch": [[61, 79]]}}}, {"text": "For example you may use the darker() versions of those colors", "label": {"api": {"darker()": [[28, 35]]}}}, {"text": "The Cloneable-interface is generally regarded as broken (and won't be fixed)", "label": {"api": {"Cloneable-interface": [[4, 22]], "Cloneable": [[4, 12]]}}}, {"text": "At the core, the argument revolves around the fact that clone() is a method defined on Object, instead of being a method of the interface Cloneable", "label": {"api": {"clone() is a method defined on Object": [[56, 92]], "Cloneable": [[138, 146]]}}}, {"text": "Here is the Original documentation for it", "label": {"api": {"Here is the Original documentation for it": [[0, 40]]}}}, {"text": "I guess you should use a different data structure, like a BitSet which will avoid working with bitwise operators directly", "label": {"api": {"BitSet": [[58, 63]]}}}, {"text": "The static factory valueOf(int) is generally a better choice, as it is likely to yield significantly better space and time performance", "label": {"api": {"valueOf(int)": [[19, 30]]}}}, {"text": "The Integer class has a static method toString(int) for this purpose", "label": {"api": {"toString(int)": [[38, 50]]}}}, {"text": "For more detailed information on how strings are compared, you can read the String.compareTo JavaDoc", "label": {"api": {"the String.compareTo JavaDoc": [[72, 99]]}}}, {"text": "Use a LinkedList rather than an ArrayList when doing multiple deletions", "label": {"api": {"LinkedList": [[6, 15]]}}}, {"text": "In addition to Sumit Singh's answer, you can also implement the Comparable interface on your Enemy or Piece classes, and use the Collections.sort(...) method to sort your collection", "label": {"api": {"Comparable": [[64, 73]]}}}, {"text": "Consider using ExecutorService::invokeAll which will return a list of Futures", "label": {"api": {"ExecutorService::invokeAll": [[15, 40]]}}}, {"text": "I'm fairly sure the getText method never returns null", "label": {"api": {"getText method": [[20, 33]]}}}, {"text": "If you want to check for an empty field, check .length() == 0 or .isEmpty", "label": {"api": {".isEmpty": [[65, 72]]}}}, {"text": "You might consider .trim() first", "label": {"api": {".trim()": [[19, 25]]}}}, {"text": "You can do that by configuring DecimalFormatSymbols", "label": {"api": {"DecimalFormatSymbols": [[31, 50]]}}}, {"text": "There is a method available on a JCA X509Certificate to return the bits of the keyUsage extension, called simply getKeyUsage()", "label": {"api": {"X509Certificate": [[37, 51]], "getKeyUsage()": [[113, 125]]}}}, {"text": "I show both methods because the Bouncycastle libraries offer much more complete support for examining an X509Certificate, so it's useful to have an example illustrating something easy in case you want to do something more difficult", "label": {"api": {"X509Certificate": [[105, 119]]}}}, {"text": "In your servlet you can use session to set your value in array so, that value will be save until you remove it from the session.Your code will somewhat look like below", "label": {"api": {"session": [[28, 34], [120, 126]]}}}, {"text": "Another thing that does not make sense is calling notify on a lock that you already own", "label": {"api": {"notify": [[50, 55]]}}}, {"text": "And you have the one using Stream, which is also O(n²)", "label": {"api": {"Stream": [[27, 32]]}}}, {"text": "The difference in the second version is that you may eventually parallelize the Stream, using parallelStream()", "label": {"api": {"Stream": [[80, 85], [102, 107]], "parallelStream()": [[94, 109]]}}}, {"text": "In the following statement, toString() method of Car is called", "label": {"api": {"toString()": [[28, 37]]}}}, {"text": "In the following statement, toString() method of Class is called", "label": {"api": {"toString()": [[28, 37]]}}}, {"text": "Since you haven't overridden the toString() method of Car, the toString() method of Object is getting called giving you output like Car@xxx", "label": {"api": {"toString()": [[33, 42], [63, 72]]}}}, {"text": "Will point you to take a look at the Thread State Class", "label": {"api": {"Thread State Class": [[37, 54]]}}}, {"text": "To parse date in a given format you can use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[44, 59]]}}}, {"text": "You can use a Calendar instance to get the last day of the month", "label": {"api": {"Calendar": [[14, 21]]}}}, {"text": "I've read DecimalFormat documentation and the corresponding Java Tutorial, but cannot find anything about specifying optional currency symbols, so that's why I think you have to work with a custom Pattern like the preceding sample codes in this answer and I'm also posting those links here, in case someone else finds the solution within them", "label": {"api": {"DecimalFormat documentation": [[10, 36]]}}}, {"text": "I have a javax.xml.datatype.Duration that contains a fraction of millisecond, e.g", "label": {"api": {"javax.xml.datatype.Duration": [[9, 35]]}}}, {"text": "The Duration API was slightly surprising to me here because you have to get the seconds part of the duration with Duration.getField(Field)", "label": {"api": {"Duration.getField(Field)": [[114, 137]]}}}, {"text": "You can parse the duration to java.time.Duration", "label": {"api": {"java.time.Duration": [[30, 47]]}}}, {"text": "Then call toNanos() method", "label": {"api": {"toNanos()": [[10, 18]]}}}, {"text": "Using hasNextInt will return true/false which appears to be what you want, but it also importantly \"does not advance past any input.\" So if you enter \"s\", hasNextInt() will return false, the \"s\" input will remain unconsumed, and each time through the loop it will again call hasNextInt() (which will again return false), etc", "label": {"api": {"hasNextInt": [[6, 15], [155, 164], [275, 284]]}}}, {"text": "Another way to make this work would be to continue using hasNextInt(), but then also", "label": {"api": {"hasNextInt": [[57, 66]]}}}, {"text": "You need to use the place it's actually defined in, javax.swing.WindowConstants", "label": {"api": {"javax.swing.WindowConstants": [[52, 78]]}}}, {"text": "You can take advantage of this by looking up “LATIN LETTER SMALL CAPITAL c” using the method Character.codePointOf(String)", "label": {"api": {"Character.codePointOf(String)": [[93, 121]]}}}, {"text": "The JTable.getModel() method returns TableModel, an interface (https://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableModel.html) that guarantees that whatever object is returned will implement all the methods in the interface", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableModel.html": [[63, 137]]}}}, {"text": "You can do chaining with Optional", "label": {"api": {"Optional": [[25, 32]]}}}, {"text": "this is split with limit parameter (the second one) and as documenation says", "label": {"api": {"documenation": [[59, 70]]}}}, {"text": "Java 9 introduced a new logger, namely java.lang.System.Logger but we always had java.util.logging.Logger", "label": {"api": {"java.lang.System.Logger": [[39, 61]], "java.util.logging.Logger": [[81, 104]]}}}, {"text": "Or, You could simply use Java's Arrays class to print the contents of the array like so", "label": {"api": {"Arrays": [[32, 37]]}}}, {"text": "For more details you can check Spliterator documentation", "label": {"api": {"Spliterator documentation": [[31, 55]]}}}, {"text": "There is a package java.beans in the official API", "label": {"api": {"package java.beans": [[11, 28]]}}}, {"text": "A starting point for tool trying to analyze a bean class is the Introspector class having the getBeanInfo method, whose class doc states", "label": {"api": {"Introspector class": [[64, 81]]}}}, {"text": "Compare with the PropertyDescriptor class of the package, which provides the meta information of a property, along with getReadMethod() and getWriteMethod() returning instances of the Reflection Method class", "label": {"api": {"PropertyDescriptor class": [[17, 40]]}}}, {"text": "You should use instead more robust solution which is a ScheduledExecutorService and its schedule method", "label": {"api": {"ScheduledExecutorService": [[55, 78]]}}}, {"text": "As documented by StreamSource, that class is in the java.xml module", "label": {"api": {"StreamSource": [[17, 28]], "java.xml": [[52, 59]]}}}, {"text": "Which means to use StreamSource in your module you need the following module-info", "label": {"api": {"StreamSource": [[19, 30]]}}}, {"text": "\"Standard API\" calls are those defined by the JDBC API, basically all the types defined in the java.sql package", "label": {"api": {"java.sql": [[95, 102]]}}}, {"text": "With that said, you can make use of Supplier<T> and make a utility method to call the method", "label": {"api": {"Supplier<T>": [[36, 46]]}}}, {"text": "You could use containsAll method to find a person who's hobbies contain all searchHobby", "label": {"api": {"containsAll": [[14, 24]]}}}, {"text": "Or if you need to find persons where at least one person's hobby is in searchHobbies then you could use removeAll", "label": {"api": {"removeAll": [[104, 112]]}}}, {"text": "anyMatch will return true if some hobby matches", "label": {"api": {"anyMatch": [[0, 7]]}}}, {"text": "It uses hasNextDouble() and, depending on the result, either proceeds to capture the double (by calling nextDouble()), or prints a message (along with consuming and ignoring whatever non-double token is present by calling next())", "label": {"api": {"hasNextDouble()": [[8, 22]], "nextDouble()": [[104, 115]], "next()": [[222, 227]]}}}, {"text": "A simple approach would be to use an ExecutorService - based on your description, you want to use one thread per processor", "label": {"api": {"an ExecutorService": [[34, 51]]}}}, {"text": "A [Google] search for the terms java checkSystemClipboardAccess removed provided a link to Oracle's javadoc for class SecurityManager (JDK 10), and the documentation for method checkSystemClipboardAccess() contains the following", "label": {"api": {"checkSystemClipboardAccess()": [[177, 204]]}}}, {"text": "This seems in direct violation of the JavaDoc", "label": {"api": {"This seems in direct violation of the JavaDoc": [[0, 44]]}}}, {"text": "I'm just using Objects.hash in the recommended, IDE auto-generated manner..", "label": {"api": {"Objects.hash in the recommended, IDE auto-generated manner": [[15, 72]]}}}, {"text": "Instead, you can use Arrays#hashCode to get value's hash code", "label": {"api": {"Arrays#hashCode": [[21, 35]]}}}, {"text": "According to official documentation", "label": {"api": {"official documentation": [[13, 34]]}}}, {"text": "From the Javadoc of HashMap", "label": {"api": {"Javadoc of HashMap": [[9, 26]]}}}, {"text": "A ReentrantLock can be used to grant access to the longest waiting thread if this matters for your program", "label": {"api": {"ReentrantLock": [[2, 14]]}}}, {"text": "Is there a website like https://docs.oracle.com/javase/8/docs/api/java/util/List.html to see the documentation of a class or its (available) methods for AdopOpenJDK", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/List.html": [[24, 84]]}}}, {"text": "There are no public constructor taking as much as parameter as the one you are trying to invoke", "label": {"api": {"no public constructor": [[10, 30]]}}}, {"text": "as document Integer.parseInt(String str) says", "label": {"api": {"Integer.parseInt(String str)": [[12, 39]]}}}, {"text": "To use ByteBuffer you can use FileBuffer.read", "label": {"api": {"FileBuffer.read": [[30, 44]]}}}, {"text": "Then you need to flip the buffer before writing the read data", "label": {"api": {"flip": [[17, 20]]}}}, {"text": "Finally, after writing you need to clear the buffer's position (and limit, but that only changes on the last read) to prepare the buffer for the next read operation", "label": {"api": {"clear": [[35, 39]]}}}, {"text": "So the order is commonly read, flip, write, clear for instances of Buffer", "label": {"api": {"flip": [[31, 34]], "clear": [[44, 48]]}}}, {"text": "You can use static methods from Executors  class, for example Executors.callable", "label": {"api": {"Executors": [[32, 40], [62, 70]]}}}, {"text": "Now use String.join()", "label": {"api": {"String.join()": [[8, 20]]}}}, {"text": "According to doc on Java 8 TreeMap's subMap, we can get a sub map out of the give map", "label": {"api": {"doc on Java 8 TreeMap's subMap": [[13, 42]]}}}, {"text": "I share the Instant documentation", "label": {"api": {"Instant documentation": [[12, 32]]}}}, {"text": "Thanks to @XtremeBaumer for pointing out the Void.TYPE attribute that is available in Java and Kotlin, and both of them refer to the void class", "label": {"api": {"Void.TYPE": [[45, 53]]}}}, {"text": "Set SimpleDateFormat.setLenient(false) to disable lenient parsing and supply a non-existing date e.g", "label": {"api": {"SimpleDateFormat.setLenient(false)": [[4, 37]]}}}, {"text": "It seems that Float.parseFloat() does not support Eastern-Arabic numbers", "label": {"api": {"Float.parseFloat()": [[14, 31]]}}}, {"text": "Alternatively, you can use NumberFormat class", "label": {"api": {"NumberFormat": [[27, 38]]}}}, {"text": "I don’t think you can do this with only a pattern, but you can create a DateTimeFormatterBuilder and call its parseDefaulting method", "label": {"api": {"parseDefaulting": [[110, 124]]}}}, {"text": "You can use Collectors.toMap for this purpose", "label": {"api": {"Collectors.toMap": [[12, 27]]}}}, {"text": "(where identity() is also statically imported)", "label": {"api": {"identity()": [[7, 16]]}}}, {"text": "Given your question, you may also be interested in Map.computeIfAbsent, which allows you to do the initialization lazily", "label": {"api": {"Map.computeIfAbsent": [[51, 69]]}}}, {"text": "If you are allowed to use ListIterator interface, then its remove() method can [safely] be used", "label": {"api": {"ListIterator": [[26, 37]]}}}, {"text": "Note that method remove() in interface ListIterator is defined as an optional operation which means that calling the remove() method may result in a java.lang.UnsupportedOperationException being thrown", "label": {"api": {"ListIterator": [[39, 50]]}}}, {"text": "You can write your own ClassLoader implementation and apply your logic in loadClass() or other available method", "label": {"api": {"ClassLoader": [[23, 33]], "loadClass()": [[74, 84]]}}}, {"text": "ClassLoader is the usual source of ClassNotFoundException in the application", "label": {"api": {"ClassLoader": [[0, 10]]}}}, {"text": "OSGI) they will still invoke your ClassLoader", "label": {"api": {"ClassLoader": [[34, 44]]}}}, {"text": "Instead of writing your own comparator logic, it is usually simpler to use one of the helper methods such as Comparator.comparing", "label": {"api": {"Comparator.comparing": [[109, 128]]}}}, {"text": "The non-null elements will remain in their original order, because Collections.sort is stable", "label": {"api": {"Collections.sort": [[67, 82]]}}}, {"text": "For this specific case as @Zabuza notes, the helper method Comparator.nullsLast does exactly the right thing; the argument is null because there is no \"fallback\" comparator we want to use for non-null elements", "label": {"api": {"Comparator.nullsLast": [[59, 78]]}}}, {"text": "You can find the expiry dates of SSL certificates (X509Certificate) that were sent to the peer during handshaking this way", "label": {"api": {"X509Certificate": [[51, 65]]}}}, {"text": "To do this properly, use SwingUtilities#invokeLater(Runnable), which will not wait for the work to complete, or SwingUtilities#invokeAndWait(Runnable), which will", "label": {"api": {"SwingUtilities#invokeLater(Runnable)": [[25, 60]], "SwingUtilities#invokeAndWait(Runnable)": [[112, 149]]}}}, {"text": "You can use the comparing method to compare by urgency or date, and you can use thenComparing to chain them together", "label": {"api": {"comparing": [[16, 24]], "thenComparing": [[80, 92]]}}}, {"text": "The reversed method allows you to compare the urgencies so that true occurs before false", "label": {"api": {"reversed": [[4, 11]]}}}, {"text": "You can then create a priority queue which uses this comparator by calling the appropriate PriorityQueue constructor", "label": {"api": {"constructor": [[105, 115]]}}}, {"text": "The java.util.zip API", "label": {"api": {"java.util.zip": [[4, 16]]}}}, {"text": "To read the contents of an entry, see ZipFile#getInputStream(ZipEntry)", "label": {"api": {"ZipFile#getInputStream(ZipEntry)": [[38, 69]]}}}, {"text": "The ZIP FileSystemProvider API", "label": {"api": {"ZIP FileSystemProvider": [[4, 25]]}}}, {"text": "To read the contents of an entry, use one of the many methods provided by the java.nio.file.Files class", "label": {"api": {"java.nio.file.Files": [[78, 96]]}}}, {"text": "The Path#of(String,String...) method was added in Java 11 and the FileSystems#newFileSystem(Path) method was added in Java 13", "label": {"api": {"Path#of(String,String...)": [[4, 28]], "FileSystems#newFileSystem(Path)": [[66, 96]]}}}, {"text": "That out of the way, it seems CryptoCipher lacks a method called Cipher#getOutputSize", "label": {"api": {"Cipher#getOutputSize": [[65, 84]]}}}, {"text": "The default level for the ConsoleHandler is INFO", "label": {"api": {"INFO": [[44, 47]]}}}, {"text": "You could use the getOrDefault method to get a default value for any value that isn't between a and f", "label": {"api": {"getOrDefault": [[18, 29]]}}}, {"text": "There is a Java 8 feature to handle such cases", "label": {"api": {"feature": [[18, 24]]}}}, {"text": "You could sort them using built in sort of Arrays in Java with a simple comparator like", "label": {"api": {"Arrays": [[43, 48]]}}}, {"text": "Arrays.sort() uses a version of quick sort and hence should be more efficient than selection or bubble sort", "label": {"api": {"Arrays": [[0, 5]]}}}, {"text": "From what information was provided, I would use a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[50, 67]]}}}, {"text": "Constructing such an Executor with a limited amount of threads is quite simle thanks to Executors::newFixedSizeThreadPool", "label": {"api": {"Executors::newFixedSizeThreadPool": [[88, 120]]}}}, {"text": "Looking at the ExecutorService-interface, method <T> Future<T> submit​(Callable<T> task) might be fitting", "label": {"api": {"ExecutorService-interface": [[15, 39]], "<T> Future<T> submit​(Callable<T> task)": [[49, 87]], "Callable<T>": [[71, 81]], "Future<T>": [[53, 61]]}}}, {"text": "what is currently a Runnable in the given implementation) must be converted to a Callable<T>, where T should be substituted with the return-type", "label": {"api": {"Callable<T>": [[81, 91]]}}}, {"text": "The Future<T> returned should then be collected into a list and waited upon on", "label": {"api": {"Future<T>": [[4, 12]]}}}, {"text": "I use a program that returns data whose timestamp is in Java date objects", "label": {"api": {"Java date objects": [[56, 72]]}}}, {"text": "I have been trying to use Java time serial", "label": {"api": {"Java time serial": [[26, 41]]}}}, {"text": "However, starting with Java time serial, which is time since 1970/1/1 GMT in miliseconds, the same line doesn't work", "label": {"api": {"Java time serial": [[23, 38]]}}}, {"text": "If using date serial is the way to make the above conversion work, how do you incorporate time zone in Matlab from a Java time serial", "label": {"api": {"Java time serial": [[117, 132]]}}}, {"text": "The getTime method of java.util.Date returns the milliseconds in GMT, but the datenum constructor takes milliseconds in local time", "label": {"api": {"returns the milliseconds in GMT": [[37, 67]]}}}, {"text": "I also recommend you go through documentation on Scanner", "label": {"api": {"documentation on Scanner": [[32, 55]]}}}, {"text": "A JavaFX DatePicker returns its value as a java.time.LocalDate", "label": {"api": {"java.time.LocalDate": [[43, 61]]}}}, {"text": "Then you feed it into java.sql.Date#valueOf(LocalDate), whose documentation indicates that a certain kind of conversion will occur", "label": {"api": {"java.sql.Date#valueOf(LocalDate)": [[22, 53]]}}}, {"text": "The class that may help you out here is java.time.ZonedDateTime", "label": {"api": {"java.time.ZonedDateTime": [[40, 62]]}}}, {"text": "There is a groupingBy method which takes a second Collector for customizing the values of the groups, by collecting all of the grouped values seen", "label": {"api": {"groupingBy method which takes a second Collector": [[11, 58]]}}}, {"text": "We can use that to get our averages, using an averaging collector", "label": {"api": {"averaging collector": [[46, 64]]}}}, {"text": "What you can do, however, is to push all the strings you want to print onto a stack, and then print them as you pop them", "label": {"api": {"stack": [[78, 82]]}}}, {"text": "This works because a stack is a Last In First Out data structure", "label": {"api": {"stack": [[21, 25]]}}}, {"text": "Strictly, the answer to your question \"How can I override System.out.println()?\" is that you can replace System.out with an alternative PrintStream using System.setOut", "label": {"api": {"System.setOut": [[154, 166]]}}}, {"text": "It has a constructor that takes a boolean argument, you should pass true to it in order to have your file being appended not overwritten", "label": {"api": {"takes": [[26, 30]]}}}, {"text": ".orElseThrow() accepts a Supplier<Exception>, which should return, rather than throw, an exception", "label": {"api": {".orElseThrow()": [[0, 13]]}}}, {"text": "A common cause for blocking when working with processes is that the process is blocked on output, either to stdout or (the more likely to be overlooked) stderr", "label": {"api": {"output": [[90, 95]]}}}, {"text": "In this context, setting up tests on a CI server, you might try setting the output and error output to INHERIT", "label": {"api": {"output": [[76, 81], [93, 98]], "error": [[87, 91]]}}}, {"text": "Note that this means that you won't be able to read the sub-process output or error stream in your Java code", "label": {"api": {"output": [[68, 73]], "error": [[78, 82]]}}}, {"text": "Instead, that output will be redirected to the output of the Java process, and I expect your CI server will log it as part of the build", "label": {"api": {"output": [[14, 19], [47, 52]]}}}, {"text": "See the String documentation", "label": {"api": {"String documentation": [[8, 27]]}}}, {"text": "As documented the method Scanner.nextLine returns a String, you can transform it to a character array using String.tocharArray and after iterate over it like below", "label": {"api": {"nextLine": [[33, 40]], "tocharArray": [[115, 125]]}}}, {"text": "If you are using Java 9 or newer, use Set.of()", "label": {"api": {"Set.of()": [[38, 45]]}}}, {"text": "In that case you use the ObjectOutputStream methods to serialize the properties, check them in https://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html for example", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html": [[95, 167]]}}}, {"text": "The problem with this approach is that the key you have, a LinekdList<Integer> is not Comparable", "label": {"api": {"Comparable": [[86, 95]]}}}, {"text": "You can overcome this by providing a custom Comparator", "label": {"api": {"Comparator": [[44, 53]]}}}, {"text": "You can use java.time.Year", "label": {"api": {"java.time.Year": [[12, 25]]}}}, {"text": "The javax.swing.text.Utilities class can get the data you want", "label": {"api": {"javax.swing.text.Utilities": [[4, 29]]}}}, {"text": "ZoneRules has this very convenient method called getTransition that takes a LocalDateTime and gives you a ZoneOffsetTransition, which represents a gap/overlap transition, or null if that date time doesn't have a transition", "label": {"api": {"getTransition": [[49, 61]]}}}, {"text": "You can use java.text.Normalizer as described in the Normalizing Text tutorial", "label": {"api": {"java.text.Normalizer": [[12, 31]], "Normalizing Text tutorial": [[53, 77]]}}}, {"text": "java.util.Set and java.util.HashSet", "label": {"api": {"java.util.Set": [[0, 12]], "java.util.HashSet": [[18, 34]]}}}, {"text": "String has lastIndexOf to find the last index of a delimiter (like space), and it looks like you're not trying to find a \"word\" but \"the substring after the last space\" (which are not the same thing in many, many languages), so given that, just use", "label": {"api": {"lastIndexOf": [[11, 21]]}}}, {"text": "Something like this should be equivalent, using Stream.reduce", "label": {"api": {"Stream.reduce": [[48, 60]]}}}, {"text": "The Optional.get method throws NoSuchElementException if there are no events with data; your original code's namesToProcess.get(0) will throw IndexOutOfBoundsException in that case", "label": {"api": {"Optional.get": [[4, 15]]}}}, {"text": "You can also check the Class.newInstance()-Javadoc which states that too", "label": {"api": {"Class.newInstance()-Javadoc": [[23, 49]]}}}, {"text": "As shown in this SwingWorker example, you can access the serial port in your implementation of doInBackground() without fear of blocking the UI thread", "label": {"api": {"SwingWorker": [[17, 27]]}}}, {"text": "You likely want to look into the ProcessBuilder class", "label": {"api": {"the ProcessBuilder class": [[29, 52]]}}}, {"text": "In that case you can use CompletableFuture::exceptionally to collect the exceptions", "label": {"api": {"CompletableFuture::exceptionally": [[25, 56]]}}}, {"text": "As Kevin pointed out in his comment below, a pre-Java 11 solution would be to replace the call to String#repeat", "label": {"api": {"String#repeat": [[98, 110]]}}}, {"text": "You are using poll() which by contract mutate the queue", "label": {"api": {"poll()": [[14, 19]]}}}, {"text": "You can use Optional::stream and Stream::findFirst to convert between the two as required.(java 9 https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#stream--)", "label": {"api": {"https://docs.oracle.com/javase/9/docs/api/java/util/Optional.html#stream--": [[98, 171]]}}}, {"text": "In J2EE you can create a JsonArray or a JsonStructure (https://docs.oracle.com/javaee/7/api/javax/json/JsonArray.html)..", "label": {"api": {"https://docs.oracle.com/javaee/7/api/javax/json/JsonArray.html": [[55, 116]]}}}, {"text": "runAsync takes Runnable as input parameter and returns CompletableFuture<Void>, which means it does not return any result", "label": {"api": {"runAsync": [[0, 7]]}}}, {"text": "But suppyAsync takes Supplier as argument and returns the CompletableFuture<U> with result value, which means it does not take any input parameters but it returns result as output", "label": {"api": {"suppyAsync": [[4, 13]]}}}, {"text": "So if you want the result to be returned, then choose supplyAsync or if you just want to run an async action, then choose runAsync", "label": {"api": {"runAsync": [[122, 129]]}}}, {"text": "If you read the documentation, the javadoc of Timestamp.valueOf​(LocalDateTime dateTime) says", "label": {"api": {"Timestamp.valueOf​(LocalDateTime dateTime)": [[46, 87]]}}}, {"text": "Since you just want to replace occurrences an exact substring, it is simpler to use the replace method which does not take a regex", "label": {"api": {"replace": [[23, 29], [88, 94]]}}}, {"text": "Don't be fooled by the name replace vs", "label": {"api": {"replace": [[28, 34]]}}}, {"text": "replaceAll; both methods replace all occurrences, the difference is really that replaceAll takes a regex but replace just takes an exact substring", "label": {"api": {"replace": [[0, 6], [25, 31], [80, 86], [109, 115]]}}}, {"text": "Based on the (very brief) documents, checkAccess() seems like a good idea, but also seems quite different than .suspend(), which certainly seems very bad based on the docs", "label": {"api": {"the (very brief) documents": [[9, 34]]}}}, {"text": "You can switch to the new Date & Time classes introduced in Java 8 including its parser/formatter", "label": {"api": {"parser/formatter": [[81, 96]]}}}, {"text": "Use the return value of add to see if the id was already in the Set", "label": {"api": {"the return value": [[4, 19]]}}}, {"text": "Add all list elements to a Set to remove any duplicate values", "label": {"api": {"Set": [[27, 29]]}}}, {"text": "From the Java API", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "As stated in the javadoc of IntStream.of, that method returns a sequential stream", "label": {"api": {"IntStream.of": [[28, 39]]}}}, {"text": "Study the documentation on BufferedInputStream and Scanner", "label": {"api": {"BufferedInputStream": [[27, 45]], "Scanner": [[51, 57]]}}}, {"text": "What you're looking for is to turn folder_name_01-18-2020-19_00_00_PM_EST into 20201801190000 which is easy to do with a regular expression", "label": {"api": {"regular expression": [[121, 138]]}}}, {"text": "To avoid mistakes like this, always include the @Override annotation on overridden methods", "label": {"api": {"@Override annotation": [[48, 67]]}}}, {"text": "Since you are already on Java-13, I would suggest refraining from using an additional library to represent a tuple and make use ofMap.entry(introduced in Java-9) with the syntactic sugar of local variable type var inferred", "label": {"api": {"Map.entry": [[130, 138]]}}}, {"text": "LocalDate can then give you a LocalDateTime at any time in that day, but (for example) you can get the start of day from it", "label": {"api": {"the start of day": [[99, 114]]}}}, {"text": "LocalDateTime has a toInstant method to give you an Instant", "label": {"api": {"toInstant": [[20, 28]]}}}, {"text": "Instant has a toEpochMilli method to get your long", "label": {"api": {"toEpochMilli": [[14, 25]]}}}, {"text": "You can still monitor any IOExceptions thrown by the underlying IO component via Scanner#ioException()", "label": {"api": {"Scanner#ioException()": [[81, 101]]}}}, {"text": "On my system, for instance, MAX_RADIX is 36 (I suspect this is common), which means the \"digits\" in the number are 0-9 and a-z", "label": {"api": {"MAX_RADIX": [[28, 36]]}}}, {"text": "If there is some discrepancies, one must define SqlResultSetMapping and refer to it from resultsetMappings", "label": {"api": {"SqlResultSetMapping": [[48, 66]], "resultsetMappings": [[89, 105]]}}}, {"text": "That class is Runtime.Version", "label": {"api": {"Runtime.Version": [[14, 28]]}}}, {"text": "So you can sort your strings by comparing their respective Runtime.Version equivalents, then converting the sorted objects back to strings", "label": {"api": {"Runtime.Version": [[59, 73]]}}}, {"text": "With ZonedDateTime you get the earlier one", "label": {"api": {"ZonedDateTime": [[5, 17]]}}}, {"text": "We can find its constructor Proxy(Proxy.Type type, SocketAddress sa) shown in this page", "label": {"api": {"page": [[83, 86]]}}}, {"text": "getResultList() expects results to be returned from the query", "label": {"api": {"getResultList()": [[0, 14]]}}}, {"text": "In Java 9+, you can stream the matches from a regex", "label": {"api": {"stream the matches from a regex": [[20, 50]]}}}, {"text": "You could return Optional<Track> to signify that a track with given id might not exist", "label": {"api": {"Optional<Track>": [[17, 31]]}}}, {"text": "In the most cases you will get InterruptedIOException, which will break the loop", "label": {"api": {"InterruptedIOException": [[31, 52]]}}}, {"text": "For example, InflaterInputStream.available() will always return 1 if EOF isn't reached", "label": {"api": {"InflaterInputStream.available()": [[13, 43]]}}}, {"text": "The most efficient way will be to use SortedMap as you won't need to find the smallest available key", "label": {"api": {"SortedMap": [[38, 46]]}}}, {"text": "You can use SortedMap::firstKey to get the smallest key", "label": {"api": {"SortedMap": [[12, 20]], "SortedMap::firstKey": [[12, 30]]}}}, {"text": "You can however do it in O(N) using LinkedList.add(index, Collection) method by using 0 index", "label": {"api": {"LinkedList.add(index, Collection)": [[36, 68]]}}}, {"text": "See for example LocalTime with its method plusMinutes", "label": {"api": {"LocalTime": [[16, 24]], "plusMinutes": [[42, 52]]}}}, {"text": "For example, it provides the DoubleUnaryOperator class", "label": {"api": {"DoubleUnaryOperator": [[29, 47]]}}}, {"text": "Accepting an instance of this as your method argument and using the applyAsDouble() method will do (effectively) what you want", "label": {"api": {"applyAsDouble()": [[68, 82]]}}}, {"text": "Javadoc of exec(String[] cmdarray) says", "label": {"api": {"exec(String[] cmdarray)": [[11, 33]]}}}, {"text": "Regarding the specification in https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#hashCode() says that the hashCode is calculated from the string content but the example seems to shows that is not true for the first string", "label": {"api": {"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#hashCode()": [[31, 123]]}}}, {"text": "I'm not familiar with the getRepositoryFor method, but Optional is a standard Java class intruduced in Java SE 8", "label": {"api": {"Optional": [[55, 62]]}}}, {"text": "You can check if the value is present and get the actual value from the Optional if it is present", "label": {"api": {"Optional": [[72, 79]]}}}, {"text": "Here is a sample using orElseThrow, but there are also other variants", "label": {"api": {"orElseThrow": [[23, 33]]}}}, {"text": "The Stack API documentation recommends using Deque instead", "label": {"api": {"Deque": [[45, 49]]}}}, {"text": "A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class", "label": {"api": {"Deque": [[79, 83]]}}}, {"text": "I have a collection of Java Date objects, loaded from an old database which did not store timezone info", "label": {"api": {"Date": [[28, 31]]}}}, {"text": "(I did not find any code examples which use Date as their starting point)", "label": {"api": {"Date": [[44, 47]]}}}, {"text": "You can use the toMap() collector with a stream", "label": {"api": {"toMap()": [[16, 22]]}}}, {"text": "For classes Stepparam and Jobparam you can create a base class and extends it, but it seems me that a Map<String, String> jobparam and a Map<String, String> step could be more appropriate of List<Jobparam> jobparam and List<Step> step, so you should not have to define the classes Stepparam and Jobparam", "label": {"api": {"Map": [[102, 104], [137, 139]]}}}, {"text": "You can check map documentation at Map", "label": {"api": {"Map": [[35, 37]]}}}, {"text": "To calculate distance between your point and another one you can use the java standard method Math.hypot like below", "label": {"api": {"Math.hypot": [[94, 103]]}}}, {"text": "You can use the overloaded groupingBy() that takes a supplier", "label": {"api": {"groupingBy()": [[27, 38]]}}}, {"text": "This may be to clearly state the intent that the reduction should not be cumulative (see Reduction operations), and must be an operation not a function (too general)", "label": {"api": {"Reduction operations": [[89, 108]]}}}, {"text": "My Question is if/how I can pass an OutputStream to a Response-Object in Jax-rs", "label": {"api": {"OutputStream": [[36, 47]]}}}, {"text": "The api is accessed using web browser and there is some service in the backend that emits an OutputStream", "label": {"api": {"OutputStream": [[93, 104]]}}}, {"text": "The result of this OutputStream is offered as a file download", "label": {"api": {"OutputStream": [[19, 30]]}}}, {"text": "To transport the data from the OutputStream to the Browser I am storing the output of the OutputStream in the filesystem and then I am using a ResponsBuilder and a StreamingOutput to get the data to the browser/user", "label": {"api": {"OutputStream": [[31, 42], [90, 101]], "StreamingOutput": [[164, 178]]}}}, {"text": "A Clock is meant for providing access to the current instant, date and time using a time-zone", "label": {"api": {"Clock": [[2, 6]]}}}, {"text": "As your class needs to obtain the current instant, so it should receive an instance of the Clock in the constructor", "label": {"api": {"Clock": [[91, 95]]}}}, {"text": "Then, in your test, you can use a fixed() clock, which will always return the same instant", "label": {"api": {"fixed()": [[34, 40]]}}}, {"text": "In a Spring Boot application, you could expose a Clock as a @Bean", "label": {"api": {"Clock": [[49, 53]]}}}, {"text": "Assuming you mean \"lambda expressions\" when you say \"Java 8 style\", you can do it using Optional", "label": {"api": {"Optional": [[88, 95]]}}}, {"text": "ScheduledExecutorService is available as part of Java language", "label": {"api": {"ScheduledExecutorService": [[0, 23]]}}}, {"text": "If you want to make a separate wrapper over ExecutorService that would provide ScheduledExecutorService functionality you will have to write it yourself, but that would be a waste of time", "label": {"api": {"ScheduledExecutorService": [[79, 102]]}}}, {"text": "What you need to do is to have your central ExecutorService instance to be an instance of ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[90, 113]]}}}, {"text": "Note that ScheduledExecutorService extends ExecutorService and thus could be used as ExecutorService or ScheduledExecutorService as needed", "label": {"api": {"ScheduledExecutorService": [[10, 33], [104, 127]]}}}, {"text": "A solution using Java's Stream API which creates an array of Point2D objects - since it appears, from the code in your question, that's what you want to do", "label": {"api": {"Stream API": [[24, 33]]}}}, {"text": "And there is File.move() method which you can check oracle document too", "label": {"api": {"oracle document": [[52, 66]]}}}, {"text": "The following document from the Oracle document might be useful https://docs.oracle.com/javase/8/docs/api/java/util/Random.html to know more about the package", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Random.html": [[64, 126]]}}}, {"text": "If the string op isn't in the map, it will throw a NullPointerException; if you like, you can use getOrDefault to handle that case", "label": {"api": {"getOrDefault": [[98, 109]]}}}, {"text": "A ByteBuffer has a position indicating where the next byte should be read from", "label": {"api": {"position": [[19, 26]]}}}, {"text": "Your respWithPut method needs to call respBuf.flip() to make sure the buffer’s position is pointing to the data you just put in it", "label": {"api": {"position": [[79, 86]], "respBuf.flip()": [[38, 51]]}}}, {"text": "After calling ByteBuffer.flip, the limit will be the old position, and the new position will be zero, making any existing data ready for reading", "label": {"api": {"position": [[57, 64], [79, 86]]}}}, {"text": "You may want to consider using Card as the model item combined with a memory-constrained cache of Image objects (see WeakReference / SoftReference, though you could also look for a third-party caching library)", "label": {"api": {"WeakReference": [[117, 129]], "SoftReference": [[133, 145]]}}}, {"text": "I would rather use the type MonthDay which is the \"date-without-year\" and which is also comparable and offers methods like isAfter() or isBefore()", "label": {"api": {"MonthDay": [[28, 35]]}}}, {"text": "Furthermore, a MonthDay can be extended to a LocalDate using the method atYear(int)", "label": {"api": {"MonthDay": [[15, 22]]}}}, {"text": "Before JDK 9, the type com.sun.management.OperatingSystemMXBean was an undocumented extension of java.lang.management.OperatingSystemMXBean", "label": {"api": {"OperatingSystemMXBean": [[42, 62], [118, 138]]}}}, {"text": "Being part of a documented module also implies that when you are willing to accept a permanent dependency to the module, you can use the extended OperatingSystemMXBean directly", "label": {"api": {"OperatingSystemMXBean": [[146, 166]]}}}, {"text": "You can use Integer.toString(int i, int radix) with radix Character.MAX_RADIX (36)", "label": {"api": {"Integer.toString(int i, int radix)": [[12, 45]], "Character.MAX_RADIX (36)": [[58, 81]]}}}, {"text": "toUnsignedInt has been introduced in Java SE 8", "label": {"api": {"toUnsignedInt": [[0, 12]]}}}, {"text": "If you go to the same documentation, you will find", "label": {"api": {"the same documentation": [[13, 34]]}}}, {"text": "When you call ImageIO.write(img, \"jpg\", outstream);, the method will invoke ImageIO.createImageOutputStream(outstream) and pass the result to the ImageWriter", "label": {"api": {"ImageIO.write(img, \"jpg\", outstream);": [[14, 50]], "ImageIO.createImageOutputStream(outstream)": [[76, 117]]}}}, {"text": "When you call setOutput directly, you must do that yourself", "label": {"api": {"setOutput": [[14, 22]]}}}, {"text": "String.format takes as the second argument varargs, so you could just rewrite your code like this", "label": {"api": {"String.format": [[0, 12]]}}}, {"text": "A Supplier is an object that has a get-method to request the object that it supplies (a list in your case)", "label": {"api": {"Supplier": [[2, 9]], "get": [[35, 37]]}}}, {"text": "To execute the methods later (and in another thread) you need the Supplier (so the other thread can call the get-method and execute the code)", "label": {"api": {"Supplier": [[66, 73]], "get": [[109, 111]]}}}, {"text": "create a new Supplier object which calls the method processdatacsv from it's method get", "label": {"api": {"Supplier": [[13, 20]], "get": [[84, 86]]}}}, {"text": "The reason Java does this is because you (usually) do not want your code to depend on a specific implementation of a list, but rather the contract of a list instead", "label": {"api": {"contract of a list": [[138, 155]]}}}, {"text": "Both Character and String classes offer the method codePointAt to examine a character and return an int representing the code point assigned in Unicode", "label": {"api": {"Character": [[5, 13]], "String": [[19, 24]], "codePointAt": [[51, 61]]}}}, {"text": "➥ Given an int, how to get an object of Character, String, or some implementation of CharSequence that I can then join to other text", "label": {"api": {"Character": [[40, 48]], "String": [[51, 56]], "CharSequence": [[85, 96]]}}}, {"text": "If you already using java.util.Scanner, you can use nextDouble() or nextBigDecimal() (which is better if your program is going to deal with money  values like in your case)", "label": {"api": {"java.util.Scanner": [[21, 37]]}}}, {"text": "If you are not using Java version >= 9, please use Arrays.asList instead of List.of", "label": {"api": {"Arrays.asList": [[51, 63]], "List.of": [[76, 82]]}}}, {"text": "The .forEach(SomeInterfaceToBeRenamed::sendNotification); line compiles because you are passing the method reference to forEach(), and it in turn invokes each sendNotification() method", "label": {"api": {"forEach()": [[120, 128]]}}}, {"text": "For what I can see the get(key) method can return a null value if the requested field it is not present in the SolrInputDocument instance", "label": {"api": {"can return a null value": [[39, 61]]}}}, {"text": "You can't modify the entry, as another thread is iterating over it; which throws the ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[85, 115]]}}}, {"text": "Java Beans, with ConstructorProperties would have been my choice, might be interesting to see some ideas", "label": {"api": {"ConstructorProperties": [[17, 37]]}}}, {"text": "Easier it is to use Files", "label": {"api": {"Files": [[20, 24]]}}}, {"text": "Perhaps the best way to handle this would be to use Integer#parseInt(), which takes a string input and either returns an integer result or throws an exception if the input cannot be coerced to an integer", "label": {"api": {"Integer#parseInt()": [[52, 69]]}}}, {"text": "Java has EnumMap - special Map implementation designed for the case when keys are of enum type (Please, see class declaration EnumMap<K extends Enum<K>,V>)", "label": {"api": {"EnumMap": [[9, 15], [126, 132]]}}}, {"text": "However, according to the floor() documentation", "label": {"api": {"floor()": [[26, 32]]}}}, {"text": "binarySearch only works on a sorted array", "label": {"api": {"binarySearch": [[0, 11]]}}}, {"text": "By calling CompletableFuture.runAsync(...) the tasks are submitted to the common ForkJoinPool", "label": {"api": {"CompletableFuture.runAsync(...)": [[11, 41]], "common ForkJoinPool": [[74, 92]]}}}, {"text": "In fact, without further configuration, the Exception will be silently ignored (to catch Exceptions, an explicit UncaughtExceptionHandler can be set when constructing a ForkJoinPool)", "label": {"api": {"explicit UncaughtExceptionHandler can be set when constructing a ForkJoinPool": [[104, 180]]}}}, {"text": "One can also figure out if a ComletableFuture has completed with an Exception by calling isDone() (to know if the task has been executed) and isCompletedExceptionally() (to know whether the task has completed with an Exception)", "label": {"api": {"isDone()": [[89, 96]], "isCompletedExceptionally()": [[142, 167]]}}}, {"text": "The Exception itself can be obtained by calling get(), but one should beware that the Exception is thrown, not returned when calling get()", "label": {"api": {"get()": [[48, 52], [133, 137]]}}}, {"text": "However, the \"first\" element is an arbitrary thing for a HashSet, since they are unordered, or as the javadoc says it", "label": {"api": {"HashSet": [[57, 63]]}}}, {"text": "Instead of HashSet, you could use a LinkedHashSet, which keeps insertion order, or a TreeSet, with is sorted, so in both cases \"first\" is well-defined", "label": {"api": {"HashSet": [[11, 17], [42, 48]], "LinkedHashSet": [[36, 48]], "TreeSet": [[85, 91]]}}}, {"text": "This is described in the javax.swing.text.html.ObjectView documentation", "label": {"api": {"javax.swing.text.html.ObjectView": [[25, 56]]}}}, {"text": "When instantiating PBEKeySpec, the number of bits to be generated must be specified in the 4th parameter", "label": {"api": {"PBEKeySpec": [[19, 28]]}}}, {"text": "The IV must be passed in the 3rd parameter of the Cipher#init-call using an IvParameterSpec instance", "label": {"api": {"Cipher#init": [[50, 60]], "IvParameterSpec": [[76, 90]]}}}, {"text": "LinkedHashMap is precisely what you're looking for", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "An example may be LocalDate::plusDays", "label": {"api": {"LocalDate::plusDays": [[18, 36]]}}}, {"text": "What's causing the error is that the number you are trying to parse, 10104102103, is bigger than the maximum possible value for an int, 2147483647", "label": {"api": {"maximum possible value for an int": [[101, 133]]}}}, {"text": "You can use Year with Year::isBefore from java-time api like so", "label": {"api": {"Year": [[12, 15], [22, 25]], "Year::isBefore": [[22, 35]]}}}, {"text": "Most Java devs would be tempted to answer SimpleDateFormat but it's not thread safe", "label": {"api": {"SimpleDateFormat": [[42, 57]]}}}, {"text": "A better approach than indexOf would be to use Java XPath implementation for navigating XML", "label": {"api": {"Java XPath implementation": [[47, 71]]}}}, {"text": "See the Java XPath implementation, and the XPath Specification", "label": {"api": {"Java XPath implementation": [[8, 32]]}}}, {"text": "There is a method summaryStatistics on IntStream so you can get the average of an array directly (as well as the sum, min, max, etc.)", "label": {"api": {"summaryStatistics": [[18, 34]]}}}, {"text": "One of the possible solutions for this task will be using Pattern class", "label": {"api": {"Pattern class": [[58, 70]]}}}, {"text": "You made an instance, type of a Function functional interface, which has a method Function.apply()", "label": {"api": {"Function": [[32, 39], [82, 89]], "Function.apply()": [[82, 97]]}}}, {"text": "To fully understand this I recommend reading the documentation of CompletionStage", "label": {"api": {"CompletionStage": [[66, 80]]}}}, {"text": "Used CompletableFuture#runAsync(Runnable) to create a \"primordial\" stage", "label": {"api": {"CompletableFuture#runAsync(Runnable)": [[5, 40]]}}}, {"text": "Learn to work with the code documentation Java API", "label": {"api": {"Java API": [[42, 49]]}}}, {"text": "It is possible because StringBuffer does implement the Comparable interface", "label": {"api": {"does": [[36, 39]]}}}, {"text": "A better solution would be a LinkedList (https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html) where entries are ordered by the sequence you add them (It may be easier, I do not know your application)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html": [[41, 107]]}}}, {"text": "You'd want to use flatMap", "label": {"api": {"flatMap": [[18, 24]]}}}, {"text": "Here's one way you can easily do it using LocalDateTime", "label": {"api": {"LocalDateTime": [[42, 54]]}}}, {"text": "Since you already have a timestamp, assuming it's in the form of a String you can convert it to a LocalDateTime like so", "label": {"api": {"LocalDateTime": [[98, 110]]}}}, {"text": "Changed LocalTime to LocalDateTime to fix rollover issues with previous solution", "label": {"api": {"LocalDateTime": [[21, 33]]}}}, {"text": "CompletableFuture on the other hand would provide you non-blocking mechanism", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "The DataInputStream methods readInt and readDouble do not take any arguments", "label": {"api": {"readInt": [[28, 34]], "readDouble": [[40, 49]]}}}, {"text": "Similarly, you should not provide an integer value when you want to read an integer value;  the whole point of calling readInt is that you don’t have an integer value and you want the DataInputStream to provide you with one", "label": {"api": {"readInt": [[119, 125]]}}}, {"text": "readInt and readDouble are declared to take zero arguments, so you must pass zero arguments", "label": {"api": {"readInt": [[0, 6]], "readDouble": [[12, 21]]}}}, {"text": "In that case, you can use the containsAll method to check for the classes of item required for the win condition", "label": {"api": {"containsAll": [[30, 40]]}}}, {"text": "Java 9 added flatMapping collector, which is perfect for this", "label": {"api": {"flatMapping": [[13, 23]]}}}, {"text": "You can also use Map#computeIfAbsent to make the second loop more compact", "label": {"api": {"Map#computeIfAbsent": [[17, 35]]}}}, {"text": "You cannot use String::contains in this case since this method works with a certain character sequence and your use-case is too specific", "label": {"api": {"String::contains": [[15, 30]]}}}, {"text": "However, you can use the advantage of List::contains which might be more useful as long as the String is be understood as a List<Character> using java-stream", "label": {"api": {"List::contains": [[38, 51]]}}}, {"text": "When you submit to an ExecutorService, it returns a Future", "label": {"api": {"submit": [[9, 14]], "ExecutorService": [[22, 36]], "Future": [[52, 57]]}}}, {"text": "This has a cancel method on it", "label": {"api": {"cancel": [[11, 16]]}}}, {"text": "So just call cancel on the appropriate Future", "label": {"api": {"Future": [[39, 44]], "cancel": [[13, 18]]}}}, {"text": "Instead of Files.readAllBytes(Paths.get(inputFile)), you should use Files.lines(Paths.get(inputFile)), and process the lines as they are streamed", "label": {"api": {"Files.readAllBytes(Paths.get(inputFile))": [[11, 50]], "Files.lines(Paths.get(inputFile))": [[68, 100]]}}}, {"text": "If you need blocks of text, instead of lines of text, you should use a BufferedReader, e.g", "label": {"api": {"BufferedReader": [[71, 84]]}}}, {"text": "using Files.newBufferedReader(Paths.get(inputFile)), like this", "label": {"api": {"BufferedReader": [[15, 28]], "Files.newBufferedReader(Paths.get(inputFile))": [[6, 50]]}}}, {"text": "If your client is written in Java, you can use URLEncoder", "label": {"api": {"URLEncoder": [[47, 56]]}}}, {"text": "Paraphrased from the documentation of getResource", "label": {"api": {"the documentation of getResource": [[17, 48]]}}}, {"text": "Here is the documentation on Vector.add() and Stream.reduce() if you want to investigate a little bit more", "label": {"api": {"Vector.add()": [[29, 40]], "Stream.reduce()": [[46, 60]]}}}, {"text": "As there is HttpSessionListener in Spring MVC for session creation and destroy event, is there anything similar in Spring Webflux", "label": {"api": {"HttpSessionListener": [[12, 30]]}}}, {"text": "You can use groupingBy collector", "label": {"api": {"groupingBy": [[12, 21]]}}}, {"text": "To find all indexes, look for a first occurrence of the letter, then if you find one (indexOf returns a positive value), keep looking from that last position using the indexOf(int ch, int fromIndex) method until you have found them all (indexOf returns -1)", "label": {"api": {"indexOf(int ch, int fromIndex)": [[168, 197]]}}}, {"text": "Another way is to use Stream.generate(), like so", "label": {"api": {"Stream.generate()": [[22, 38]]}}}, {"text": "The interface for AttributeConverter is as follows", "label": {"api": {"AttributeConverter": [[18, 35]]}}}, {"text": "However, the CompletableFuture.runAsync() and Executors.newSingleThreadExecutor() calls use different threads, specially using different daemon flags (see What is a daemon thread in Java?)", "label": {"api": {"daemon": [[137, 142], [165, 170]]}}}, {"text": "When you place a System.out.println(Thread.currentThread().isDaemon()); inside your doRead() method you will see that CompletableFuture.runAsync uses a daemon thread (so it doesn't block the JVM from terminating) where Executors.newSingleThreadExecutor() does not (and keeps the JVM alive)", "label": {"api": {"daemon": [[152, 157]]}}}, {"text": "I had never seen that before, but the javadoc mentions it's a \"modified\" UTF-8 encoding", "label": {"api": {"\"modified\" UTF-8 encoding": [[62, 86]]}}}, {"text": "Parse as a OffsetDateTime object", "label": {"api": {"OffsetDateTime": [[11, 24]]}}}, {"text": "Adjust the offset to UTC, producing a second OffsetDateTime object", "label": {"api": {"OffsetDateTime": [[45, 58]]}}}, {"text": "Change code to use setTimestamp(...), using Timestamp.valueOf(LocalDateTime dateTime)", "label": {"api": {"setTimestamp(...)": [[19, 35]], "Timestamp.valueOf(LocalDateTime dateTime)": [[44, 84]]}}}, {"text": "You can create a copy of your array in the beginning of your program using Arrays.copyOf, and then compare this old copy to your modified array (note the below solution will only work in this case, because your array is of primitive values)", "label": {"api": {"Arrays.copyOf": [[75, 87]]}}}, {"text": "You can create a copy of your original array with the method Arrays.copyOf and then pass the copy to your method generateWorstCase that will modify it", "label": {"api": {"Arrays.copyOf": [[61, 73]]}}}, {"text": "You can however use the Math#acos method to identify a possible input", "label": {"api": {"Math#acos": [[24, 32]]}}}, {"text": "There is a ConcurrentHashMap class which implements ConcurrentMap which can be used for thread-safe Map handling", "label": {"api": {"ConcurrentHashMap": [[11, 27]], "ConcurrentMap": [[52, 64]]}}}, {"text": "It looks like there's a withInputStream method and you can always create an InputStream from a byte array via ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[110, 129]]}}}, {"text": "You might want to have a look at the documentation of LineBorder", "label": {"api": {"documentation of LineBorder": [[37, 63]]}}}, {"text": "For caches where you want to manually remove entries when the memory is low, you can use SoftReferences", "label": {"api": {"SoftReference": [[89, 101]]}}}, {"text": "Since I assume that you don't have control of the code of the \"Snort\" application, I don't think that NIO FileLocks will help you", "label": {"api": {"FileLock": [[106, 113]]}}}, {"text": "First, create a Blocking Queue", "label": {"api": {"Blocking Queue": [[16, 29]]}}}, {"text": "When you reach the limit use ByteArrayOutputStream.toByteArray() and reset with ByteArrayOutputStream.reset()", "label": {"api": {"ByteArrayOutputStream.toByteArray()": [[29, 63]], "ByteArrayOutputStream.reset()": [[80, 108]]}}}, {"text": "My advice would be to use RandomAccessFile and save the data you get to a file", "label": {"api": {"RandomAccessFile": [[26, 41]]}}}, {"text": "Via RandomAccessFile you can operate on data files larger than 2GiB", "label": {"api": {"RandomAccessFile": [[4, 19]]}}}, {"text": "If you only want to set the default timezone for joda time, use DateTimeZone.setDefault", "label": {"api": {"TimeZone.setDefault": [[68, 86]]}}}, {"text": "If you want to change the timezone that the whole jvm uses use TimeZone.setDefault method", "label": {"api": {"TimeZone.setDefault": [[63, 81]]}}}, {"text": "If you are connecting to a web address you would probably want to create a URL then call openConnection to get a URLConnection", "label": {"api": {"URL": [[75, 77], [113, 115]], "URLConnection": [[113, 125]]}}}, {"text": "Now with your URLConnection you can do", "label": {"api": {"URL": [[14, 16]], "URLConnection": [[14, 26]]}}}, {"text": "If your worker thread waits on the blocking queue by calling take() it should not consume CPU resources", "label": {"api": {"take()": [[61, 66]]}}}, {"text": "Quoting a section of the relevant javadoc(emphasis mine)", "label": {"api": {"relevant javadoc": [[25, 40]]}}}, {"text": "What you want to use is File.createTempFile() and call deleteOnExit() on the resulting file", "label": {"api": {"File.createTempFile()": [[24, 44]]}}}, {"text": "I setup COMET functionality in my web-app (with the help of such Servlet 3.0 features as AsyncContext and startAsync) to allow for things such as real-time notifications", "label": {"api": {"AsyncContext": [[89, 100]], "startAsync": [[106, 115]]}}}, {"text": "You can use the Charset and CharsetEncoder APIs directly, in particular calling encode(CharBuffer, ByteBuffer, boolean)", "label": {"api": {"encode(CharBuffer, ByteBuffer, boolean)": [[80, 118]]}}}, {"text": "Once you have content of your element, pass it to MimeUtility.decode() and write stream to file", "label": {"api": {"MimeUtility.decode()": [[50, 69]]}}}, {"text": "Look at SimpleDateFormat if you want to use java.util.Date/Calendar, or DateTimeFormat and DateTimeFormatter in Joda Time (which is a much nicer date/time API)", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "It seems to be working fine for input upto 10^3, at 10^4 it simply hangs and at 10^5 and above I get OutOfMemoryError", "label": {"api": {"OutOfMemoryError": [[101, 116]]}}}, {"text": "This is normally the role of the EntityManager.getReference() method", "label": {"api": {"EntityManager.getReference()": [[33, 60]]}}}, {"text": "See Java Boolean.valueOf() and Boolean.booleanValue() docs", "label": {"api": {"Boolean.valueOf()": [[9, 25]], "Boolean.booleanValue()": [[31, 52]]}}}, {"text": "See documentation on OutputStream.flush", "label": {"api": {"OutputStream.flush": [[21, 38]]}}}, {"text": "Calling close also calls flush (that's why close can throw an IOException", "label": {"api": {"close": [[8, 12], [43, 47]]}}}, {"text": "For more information, see the buffered streams tutorial and the documentation of the java.io.PrintStream class", "label": {"api": {"java.io.PrintStream class": [[85, 109]]}}}, {"text": "Runtime.addShutdownHook() is what you're looking for", "label": {"api": {"Runtime.addShutdownHook()": [[0, 24]]}}}, {"text": "This can be a DefaultListModel", "label": {"api": {"DefaultListModel": [[14, 29]]}}}, {"text": "methods in DefaultListModel", "label": {"api": {"DefaultListModel": [[11, 26]]}}}, {"text": "Check out List and ArrayList in the Java documentation", "label": {"api": {"List": [[10, 13], [24, 27]], "ArrayList": [[19, 27]]}}}, {"text": "According to javax.annotation.Generated javadoc, its retention is Source, so the annotation won't be compiled to your classes (and result classes with and without this annotation are the same)", "label": {"api": {"javax.annotation.Generated": [[13, 38]]}}}, {"text": "Because you want to affect only certain cells based on location rather than type, override prepareRenderer() and return a component having a red Border for the desired cells", "label": {"api": {"prepareRenderer()": [[91, 107]]}}}, {"text": "It's available by UIComponent#getStateHelper()", "label": {"api": {"StateHelper": [[33, 43]], "UIComponent#getStateHelper()": [[18, 45]]}}}, {"text": "Unrelated to the concrete problem, you can for more simplicity also just extend UINamingContainer instead of implementing NamingContainer", "label": {"api": {"UINamingContainer": [[80, 96]]}}}, {"text": "This way you can omit the overridden getFamily() method as it's already implemented rightly by UINamingContainer", "label": {"api": {"UINamingContainer": [[95, 111]]}}}, {"text": "Look up System.arraycopy() to copy arrays", "label": {"api": {"System.arraycopy()": [[8, 25]]}}}, {"text": "However you should look into running the code with a SecurityManager", "label": {"api": {"SecurityManager": [[53, 67]]}}}, {"text": "If you want to perform a time expensive task, take a look at a SwingWorker (SwingWorker tutorial)", "label": {"api": {"SwingWorker": [[63, 73], [76, 86]]}}}, {"text": "Instead of printing it try using a StringBuilder and returning it's string representation", "label": {"api": {"StringBuilder": [[35, 47]]}}}, {"text": "How about replacing those arrays with an EnumMap<Resource, Double>", "label": {"api": {"EnumMap": [[41, 47]]}}}, {"text": "The EnumMap class is optimised for use with enum keys, such that it does end up using an array keyed on the enums' ordinal (integer) value behind the scenes", "label": {"api": {"EnumMap": [[4, 10]]}}}, {"text": "Just use Calendar.add method to \"add\" -1 to the year and wrap it in your own utility method", "label": {"api": {"Calendar.add": [[9, 20]]}}}, {"text": "You need to create a Scanner and just return a[scanner.nextInt()]; [where scanner is the initialized Scanner]", "label": {"api": {"Scanner": [[21, 27], [101, 107]]}}}, {"text": "Quoted from the API documentation", "label": {"api": {"API documentation": [[16, 32]]}}}, {"text": "See the String#matches(java.lang.String) method", "label": {"api": {"String#matches(java.lang.String)": [[8, 39]]}}}, {"text": "Use Random Access File that is available..", "label": {"api": {"Random Access File": [[4, 21]]}}}, {"text": "It seems like there would be such a thing that uses ResultSetMetaData to create ColumnDescription objects and then iterate populates rows", "label": {"api": {"ResultSetMetaData": [[52, 68]]}}}, {"text": "Since both ResultSetMetaData and DataTable have so many special properties, wanted to double check here before starting down the garden path of writing a custom method", "label": {"api": {"ResultSetMetaData": [[11, 27]]}}}, {"text": "If you want to delay your processing code for a fixed length of time, then sleep() is a good thing (however, the Timer class is a nice way to implement periodic behaviour)", "label": {"api": {"Timer": [[113, 117]]}}}, {"text": "You could use CharSequence.subSequence(int, int) and String.replaceAll(String, String) as follows", "label": {"api": {"CharSequence.subSequence(int, int)": [[14, 47]], "String.replaceAll(String, String)": [[53, 85]]}}}, {"text": "Using the Image.getScaledInstance method will not guarantee that the aspect ratio of the original image will be maintained for the resized image, and furthermore, it is in general very slow", "label": {"api": {"Image.getScaledInstance": [[10, 32]]}}}, {"text": "Thumbnailator uses a technique to progressively resize the image which can be several times faster than Image.getScaledInstance while achieving an image quality which generally is comparable", "label": {"api": {"Image.getScaledInstance": [[104, 126]]}}}, {"text": "I guess the closest you can come is making some class that implements CharSequence", "label": {"api": {"CharSequence": [[70, 81]]}}}, {"text": "Most JDK string manipulation methods accept a CharSequence", "label": {"api": {"CharSequence": [[46, 57]]}}}, {"text": "StringBuilder for example", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "You almost certainly want to be using Math.atan2(y, x), which is much smarter about pointing in the right direction, as opposed to Math.atan, which has to assume that you're in one of the first two quadrants", "label": {"api": {"Math.atan2(y, x)": [[38, 53]]}}}, {"text": "It is necessary to call container's validate method after adding/removing components", "label": {"api": {"validate": [[36, 43]]}}}, {"text": "Use a ProgressMonitorInputStream instead", "label": {"api": {"ProgressMonitorInputStream": [[6, 31]]}}}, {"text": "LinePanel shows one approach, but it can be adapted to any Shape", "label": {"api": {"Shape": [[59, 63]]}}}, {"text": "For many lines, your program might maintain a List<Shape>", "label": {"api": {"Shape": [[51, 55]]}}}, {"text": "If you look at the Javadocs for MouseEvent you'll see that it has a number of methods you can use to get information from the event", "label": {"api": {"Javadocs for MouseEvent": [[19, 41]]}}}, {"text": "Use ProcessBuilder to construct the Process", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "It involves creating a new Process object using ProcessBuilder.start() or Runtime.exec()", "label": {"api": {"Process": [[27, 33], [48, 54]], "ProcessBuilder.start()": [[48, 69]], "Runtime.exec()": [[74, 87]]}}}, {"text": "The HashMap (java.util.HashMap<K,V>) uses it for example", "label": {"api": {"HashMap": [[4, 10], [23, 29]]}}}, {"text": "A good example of K and V is a HashMap", "label": {"api": {"HashMap": [[31, 37]]}}}, {"text": "There's a method to get file names directly, but they won't have your trailing /, and you have to be able to filter by file name", "label": {"api": {"method to get file names directly": [[10, 42]]}}}, {"text": "ThreadMXBean might be a good place to start if you can add your code to do it", "label": {"api": {"ThreadMXBean": [[0, 11]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executors.html and docs.oracle.com/javase/6/docs/api/java/util/concurrent/CountDownLatch.html for more information", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executors.html": [[4, 79]]}}}, {"text": "Use a Collator", "label": {"api": {"Collator": [[6, 13]]}}}, {"text": "This is a type of Comparator that performs locale-sensitive String comparison", "label": {"api": {"Comparator": [[18, 27]]}}}, {"text": "Take a look at the example based on Norwegian in the JavaDoc for the RuleBasedCollator class", "label": {"api": {"JavaDoc for the RuleBasedCollator class": [[53, 91]]}}}, {"text": "Take a look at SimpleDateFormat#parse()", "label": {"api": {"SimpleDateFormat#parse()": [[15, 38]]}}}, {"text": "You can use BufferedReader.readLine() to get the first line", "label": {"api": {"BufferedReader.readLine()": [[12, 36]]}}}, {"text": "It will get you a List<String> which you can handle like any list, including getting a specific line", "label": {"api": {"List<String>": [[18, 29]]}}}, {"text": "Note that it has more overhead because it reads the entire file, and populates a List<String> with its lines", "label": {"api": {"List<String>": [[81, 92]]}}}, {"text": "Did you take a look at the BigDecimal class?", "label": {"api": {"BigDecimal": [[27, 36]]}}}, {"text": "Use BigDecimal for anything decimal related in Java", "label": {"api": {"BigDecimal": [[4, 13]]}}}]