[{"text": "Go through StringBuffer", "label": {"api": {"StringBuffer": [[11, 22]]}}}, {"text": "There is a replace method in String class that can do it", "label": {"api": {"replace": [[11, 17]]}}}, {"text": "If you are using a JTextField, you could register a document listener on it", "label": {"api": {"document listener": [[52, 68]]}}}, {"text": "This won't work as the URI constructor of the File class that you are using only works with file URIs as documented in the JDK", "label": {"api": {"JDK": [[123, 125]]}}}, {"text": "If you're using for example JPA, you could use the @PreUpdate annotation for this", "label": {"api": {"@PreUpdate": [[51, 60]]}}}, {"text": "Maybe some JVM implementations are basically returning Enum.ordinal() (which would make great hashCode as well) - but it wouldn't effectively change anything", "label": {"api": {"Enum.ordinal()": [[55, 68]]}}}, {"text": "The only required contract is described in the JavaDocs of Object.hashCode() - and it is the implementation in Object that is used in enum", "label": {"api": {"Object.hashCode()": [[59, 75]]}}}, {"text": "You have to synchronize access to bullets list or use thread-safe collection like CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[82, 101]]}}}, {"text": "You can generate an array of random numbers, and then sort it using Array sort", "label": {"api": {"Array sort": [[68, 77]]}}}, {"text": "To copy an array, you can use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[30, 47]]}}}, {"text": "The Arrays utility class also has some useful methods for copying arrays", "label": {"api": {"Arrays": [[4, 9]]}}}, {"text": "If you want to use an existing class - maybe IllegalArgumentException might fit, though not perfectly", "label": {"api": {"IllegalArgumentException": [[45, 68]]}}}, {"text": "I've narrowed the issue down to the behavior of the java.net.URL class and how the library uses it to look up resources", "label": {"api": {"java.net.URL": [[52, 63]]}}}, {"text": "I'm curious, why does java.net.URL behave like this", "label": {"api": {"java.net.URL": [[22, 33]]}}}, {"text": "If the loop is doing the same thing with different data values, I would prefer PreparedStatement for speed", "label": {"api": {"PreparedStatement": [[79, 95]]}}}, {"text": "The docs for ServletResponse.setContentType(..) clearly state that calling this method has no effect if called after getWriter() method is called", "label": {"api": {"ServletResponse.setContentType(..)": [[13, 46]]}}}, {"text": "To format the string, use String.format", "label": {"api": {"String.format": [[26, 38]]}}}, {"text": "To get the number back from string, use Integer.parseInt", "label": {"api": {"Integer.parseInt": [[40, 55]]}}}, {"text": "There's been lots of debate about the usefulness of checked exceptions, and over time I've come to agree with the people who say that they're just not worth the effort, and if there are cases where there are a lot of annoying pointless checked exceptions being declared, I will wrap them and rethrow an appropriate runtime Exception (say hello to my lil friend!)", "label": {"api": {"lil friend": [[350, 359]]}}}, {"text": "From the Java Documentation on Comparable", "label": {"api": {"Comparable": [[31, 40]]}}}, {"text": "In other words, a class that implements Comparable is capable of comparing itself to other objects of the same kind", "label": {"api": {"Comparable": [[40, 49]]}}}, {"text": "From the Java documentation on Comparator", "label": {"api": {"Comparator": [[31, 40]]}}}, {"text": "Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow precise control over the sort order", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "Comparators can also be used to control the order of certain data structures (such as sorted sets or sorted maps), or to provide an ordering for collections of objects that don't have a natural ordering", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "A class that implements Comparator is capable of comparing other objects with each other", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "Use quote(), it seems you've already figured out the ignore case, but you should use (?i), not (i?)", "label": {"api": {"quote()": [[4, 10]]}}}, {"text": "You have to use ByteBuffer.allocateDirect if you want to be able to use JNI's GetDirectBufferAddress", "label": {"api": {"ByteBuffer.allocateDirect": [[16, 40]]}}}, {"text": "Use ByteBuffer.order(ByteOrder.nativeOrder()) to adjust the ByteBuffer instance's endianness to match the current platform", "label": {"api": {"ByteBuffer.order(ByteOrder.nativeOrder())": [[4, 44]]}}}, {"text": "After the ByteBuffer's endianness is properly configured, use ByteBuffer.asIntBuffer() to get a view of it as a java.nio.IntBuffer and fill it with your data", "label": {"api": {"ByteBuffer.asIntBuffer()": [[62, 85]]}}}, {"text": "If you really need to load the resources from an Excel document at runtime, you could create your own ResourceBundle class that delegates to Apache POI or another library capable of reading Excel files, but that seems like it might be a lot of work", "label": {"api": {"ResourceBundle": [[102, 115]]}}}, {"text": "Process.destroy() might help", "label": {"api": {"Process.destroy()": [[0, 16]]}}}, {"text": "I want to be notified when a SocketChannel has its close method called", "label": {"api": {"SocketChannel": [[29, 41]], "close": [[51, 55]]}}}, {"text": "My first thought was to create a wrapper which notifies a listener when the implCloseSelectableChannel method is called (since the close method itself is declared final in AbstractInterruptibleChannel)", "label": {"api": {"close": [[131, 135]]}}}, {"text": "Now I can't override the register method to delegate to the wrapped SocketChannel because it's declared final in AbstractSelectableChannel and I can't implement SelChImpl because it has default visibility in the sun.nio.ch package", "label": {"api": {"SocketChannel": [[68, 80]]}}}, {"text": "Is there an easier way to be notified when a SocketChannel has been closed or do I need to rethink my program design", "label": {"api": {"SocketChannel": [[45, 57]], "close": [[68, 72]]}}}, {"text": "Use the constructor with two arguments, where the second is the delimiters", "label": {"api": {"constructor with two arguments": [[8, 37]]}}}, {"text": "Yes, you can use the newInstance() method on Class to construct one", "label": {"api": {"newInstance()": [[21, 33]]}}}, {"text": "The AbstractTableModel API will show you more about these methods as will the JTable tutorial", "label": {"api": {"AbstractTableModel API": [[4, 25]]}}}, {"text": "I thought that the vAlign uses the java.awt.Component contants for BOTTOM_ALIGNMENT, CENTER_ALIGNMENT AND TOP_ALIGNMENT which hold 1.0f, 0.5f, and 0.0f respectively, and so a value of 2.0 may not make much sense", "label": {"api": {"java.awt.Component contants": [[35, 61]]}}}, {"text": "java.util.ArrayList#clone creates a shallow copy of the list", "label": {"api": {"java.util.ArrayList#clone": [[0, 24]]}}}, {"text": "From the Java Documentation on Socket, see info on \"close\"-method", "label": {"api": {"Socket": [[31, 36]]}}}, {"text": "Could be done with a Map", "label": {"api": {"Map": [[21, 23]]}}}, {"text": "You can see meaning of special characters in Pattern class, for example", "label": {"api": {"Pattern": [[45, 51]]}}}, {"text": "List returned from Arrays.asList has fixed size", "label": {"api": {"Arrays.asList": [[19, 31]]}}}, {"text": "Instead, add both lists to new ArrayList", "label": {"api": {"ArrayList": [[31, 39]]}}}, {"text": "Another solution would be to use Arrays.deepEquals", "label": {"api": {"Arrays.deepEquals": [[33, 49]]}}}, {"text": "You can create a class CombinationsGetter that implements Iterable<Pair>, and implement its Iterator<Pair>", "label": {"api": {"Iterable<Pair>": [[58, 71]], "Iterator<Pair>": [[92, 105]]}}}, {"text": "Later - you can use ArrayList.addAll() to convert those different lists into one", "label": {"api": {"ArrayList.addAll()": [[20, 37]]}}}, {"text": "though complexity is stiil O(n^2), it is likely to be much faster - since the creation of pairs is done in parallel, and ArrayList.addAll() is implemented much more effieciently then the trivial insert one by one elements", "label": {"api": {"ArrayList.addAll()": [[121, 138]]}}}, {"text": "The problem is, when I use javax.imageio.ImageIO.read method, the image it strangely imports is to a BufferedImage rotated to left and becomes 960*720", "label": {"api": {"javax.imageio.ImageIO.read": [[27, 52]]}}}, {"text": "It what you want is to copy the contents of a Map to another Map, use the putAll method", "label": {"api": {"putAll": [[74, 79]]}}}, {"text": "Store all your records in a List<TrainData>, sort the list using Collections.sort(), then iterate through the list and write each record to the file", "label": {"api": {"Collections.sort()": [[65, 82]]}}}, {"text": "You need to use the content type's character set as specified by the response headers", "label": {"api": {"content type's": [[20, 33]]}}}, {"text": "You can use the String#Split method to convert your actual String to an array of Strings with all the values", "label": {"api": {"String#Split": [[16, 27]]}}}, {"text": "Character is a standard class in the java.lang package, which is auto-imported in every class", "label": {"api": {"Character": [[0, 8]]}}}, {"text": "Rather than using an AccessControlContext directly, you should use AccessController.checkPermission, which will check the active security context for you", "label": {"api": {"AccessController.checkPermission": [[67, 98]]}}}, {"text": "To control what permissions are granted a class, use ClassLoader.defineClass, and pass a ProtectionDomain containing a PermissionCollection with the appropriate set of permissions", "label": {"api": {"ClassLoader.defineClass": [[53, 75]], "ProtectionDomain": [[89, 104]], "PermissionCollection": [[119, 138]]}}}, {"text": "You could trim() the string before you parse it", "label": {"api": {"trim()": [[10, 15]]}}}, {"text": "Logging frameworks like Java's built in Logging API allow you to configure what severity of messages to produce when the program is run", "label": {"api": {"Logging API": [[40, 50]]}}}, {"text": "For an example, have a look at the List.sublist(int fromIndex, int toIndex) and List.listIterator(int index) methods", "label": {"api": {"List.sublist(int fromIndex, int toIndex)": [[35, 74]], "List.listIterator(int index)": [[80, 107]]}}}, {"text": "As a bonus trick, if the iteration operations are expensive or slow, such as those required to access a database, you might see a throughput improvement if you separate them out to a separate thread that will use the iterator to fill in a BlockingQueue", "label": {"api": {"BlockingQueue": [[239, 251]]}}}, {"text": "In Java I would use BigInteger", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "Have a look at Collection.toArray(T[]) - it follows the same principle", "label": {"api": {"Collection.toArray(T[])": [[15, 37]]}}}, {"text": "The method setEnabledAt() works with the example here", "label": {"api": {"setEnabledAt()": [[11, 24]]}}}, {"text": "some table being fixed, you can wrap it with constraint Box.createRigidArea(new Dimension(100, 100))", "label": {"api": {"Box.createRigidArea(new Dimension(100, 100))": [[56, 99]]}}}, {"text": "In example, look at java.awt.Rectangle or at java.awt.Point classes", "label": {"api": {"java.awt.Rectangle": [[20, 37]], "java.awt.Point": [[45, 58]]}}}, {"text": "A straightforward solution would be splitting the input string at the whitespaces, then reversing the result array with eg", "label": {"api": {"splitting": [[36, 44]]}}}, {"text": "Collections.reverse()  or Commons ArrayUtils.reverse(), then joining them back together", "label": {"api": {"Collections.reverse()": [[0, 20]]}}}, {"text": "What you can do however is to force a repaint by calling the repaint() method and then paint the new image in the paint method", "label": {"api": {"repaint()": [[61, 69]]}}}, {"text": "There is no compareTo() method in Object", "label": {"api": {"Object": [[34, 39]]}}}, {"text": "I guess you're looking for String.compareTo()", "label": {"api": {"String.compareTo()": [[27, 44]]}}}, {"text": "Thus anytime you use a direct arithmetic operation (such as +), the compiler will unbox Long into long by invoking Long.longValue()", "label": {"api": {"Long.longValue()": [[115, 130]]}}}, {"text": "The API makes no mention of synchronization, so this seems possible, or is interleaved output prevented by buffering and/or the VM memory model, etc.", "label": {"api": {"API": [[4, 6]]}}}, {"text": "Since the API documentation makes no mention of thread safety on the System.out object nor does the PrintStream#println(String) method you cannot assume that it is thread-safe", "label": {"api": {"System.out object": [[69, 85]], "PrintStream#println(String) method": [[100, 133]]}}}, {"text": "You use it to create a new Thread encapsulating your Runnable and then start it", "label": {"api": {"Thread": [[27, 32]], "Runnable": [[53, 60]]}}}, {"text": "After the variable threadReceive goes out of scope, the Thread is still left running in the background, it won't be affected by it", "label": {"api": {"Thread": [[56, 61]]}}}, {"text": "Assigning a new Thread to the variable has no effect on the Thread the variable referenced earlier", "label": {"api": {"Thread": [[16, 21], [60, 65]]}}}, {"text": "This situation probably calls for a JFormattedTextField", "label": {"api": {"JFormattedTextField": [[36, 54]]}}}, {"text": "I think that what you describe fits the Properties class", "label": {"api": {"Properties": [[40, 49]]}}}, {"text": "Rather than do this yourself, wouldn't it be easier to use String.replaceFirst() or String.replaceAll() to do the replacement", "label": {"api": {"String.replaceFirst()": [[59, 79]], "String.replaceAll()": [[84, 102]]}}}, {"text": "I'm not familiar with Eclipse, but most text fields will probably implement an abstract class like JTextComponent which has handy methods to getText() and setText()", "label": {"api": {"JTextComponent": [[99, 112]], "getText()": [[141, 149]], "setText()": [[155, 163]]}}}, {"text": "create a List with all the required values in, randomly shuffle the List and then populate your array from that, mapping the entries in the List to the rows and columns on your array", "label": {"api": {"randomly shuffle": [[47, 62]]}}}, {"text": "JEditorPane may be the closest thing to what you are looking for", "label": {"api": {"JEditorPane": [[0, 10]]}}}, {"text": "Usually a JTable is used to render database data in a table format, you can see how here", "label": {"api": {"JTable": [[10, 15]]}}}, {"text": "They are similar, but from a design perspective, the Properties class is considered to be one of the \"mistakes\" of java, because it is a Hashtable (rather than using a Hashtable)", "label": {"api": {"Properties": [[53, 62]], "Hashtable": [[137, 145], [168, 176]]}}}, {"text": "Tend to avoid using Properties unless you have to", "label": {"api": {"Properties": [[20, 29]]}}}, {"text": "Have a look at the Class documentation using this you can do", "label": {"api": {"Class documentation": [[19, 37]]}}}, {"text": "ObjectOutputStream is used to serialize objects", "label": {"api": {"ObjectOutputStream": [[0, 17]]}}}, {"text": "If you want to store just the raw data use DataOutputStream instead", "label": {"api": {"DataOutputStream": [[43, 58]]}}}, {"text": "To achieve a filtered directory listing, you can try using the list() method on the File object for the Save folder, passing a custom java.io.FilenameFilter implementation, so it will scan the whole content of the target folder, and returning only the names of the files that match your constraint", "label": {"api": {"java.io.FilenameFilter": [[134, 155]]}}}, {"text": "I think you're looking for java.lang.System#setOut(PrintStream stream) method", "label": {"api": {"java.lang.System#setOut(PrintStream stream)": [[27, 69]]}}}, {"text": "getResource searches via the classloader, so typically and simplified in the classpath", "label": {"api": {"searches via the classloader": [[12, 39]]}}}, {"text": "You can try to escape the spaces Documents\\\\ and\\\\ Settings or you use the exec method that does this for you", "label": {"api": {"exec method": [[75, 85]]}}}, {"text": "Better use ProcessBuilder for starting processes", "label": {"api": {"ProcessBuilder": [[11, 24]]}}}, {"text": "They can be java.util.Properties", "label": {"api": {"java.util.Properties": [[12, 31]]}}}, {"text": "Take a look at the java class Scanner", "label": {"api": {"Scanner": [[30, 36]]}}}, {"text": "I appreciate that you're doing this because you want to use relative references, but perhaps you ought to abstract this out from the filesystem itself and use Classloader.findResource() (or probably getResourceAsStream())", "label": {"api": {"Classloader.findResource()": [[159, 184]]}}}, {"text": "Use java Timers", "label": {"api": {"Timers": [[9, 14]]}}}, {"text": "In Java 9+ you can use Immutable Set Static Factory Methods", "label": {"api": {"Immutable Set Static Factory Methods": [[23, 58]]}}}, {"text": "I'd like to use the Java class HttpURLConnection to connect to a particular device on a (local network)", "label": {"api": {"HttpURLConnection": [[31, 47]]}}}, {"text": "Using HttpURLConnection is convenient because it relieves me of having to parse the server response etc and get straight at the data I need instead of doing something like this", "label": {"api": {"HttpURLConnection": [[6, 22]]}}}, {"text": "Am I correct in my understanding of how HttpURLConnection works i.e", "label": {"api": {"HttpURLConnection": [[40, 56]]}}}, {"text": "With plain Java you will only be able to bind a Socket to a selected NetworkInterface", "label": {"api": {"Socket": [[48, 53]], "NetworkInterface": [[69, 84]]}}}, {"text": "Take a look at the Calendar api", "label": {"api": {"Calendar": [[19, 26]]}}}, {"text": "To maintain a reliable count, you'll have to implement your own ListModel or override the mutators in DefaultListModel", "label": {"api": {"DefaultListModel": [[102, 117]]}}}, {"text": "setMaximumSize() in your component objects", "label": {"api": {"setMaximumSize()": [[0, 15]]}}}, {"text": "You can Map each numeric value to a letter", "label": {"api": {"Map": [[8, 10]]}}}, {"text": "Then you pull from the Map for each number found in the input string", "label": {"api": {"Map": [[23, 25]]}}}, {"text": "You can use addRequestProperty() to set a cookie on a URLConnection object, e.g", "label": {"api": {"addRequestProperty()": [[12, 31]], "URLConnection": [[54, 66]]}}}, {"text": "If the cookie isn't known beforehand, but is set by a reply to a previous HTTP request, then one can use getHeaderFields() etc on the URLConnection instance representing the previous HTTP exchange to retrieve the cookie", "label": {"api": {"URLConnection": [[134, 146]], "getHeaderFields()": [[105, 121]]}}}, {"text": "From java.util.MapJavaDoc (implemented by HashMap)", "label": {"api": {"java.util.MapJavaDoc": [[5, 24]]}}}, {"text": "Since Java 8 it's better to use java.time.LocalDate rather than java.util.Calendar", "label": {"api": {"java.time.LocalDate": [[32, 50]], "java.util.Calendar": [[64, 81]]}}}, {"text": "With Java 8 and later, you can convert the Date object to a LocalDate object and then easily get the year, month and day", "label": {"api": {"Date": [[43, 46], [65, 68]], "LocalDate": [[60, 68]]}}}, {"text": "You can use SimpleDateFormat.parse with the appropriate format string", "label": {"api": {"SimpleDateFormat.parse": [[12, 33]]}}}, {"text": "What you really want is a CardLayout , Have a look at this", "label": {"api": {"CardLayout": [[26, 35]]}}}, {"text": "How to Use CardLayout", "label": {"api": {"CardLayout": [[11, 20]]}}}, {"text": "If you have, I'll need to dig deeper into the modified UTF-8 format used by Java's binary data streams", "label": {"api": {"modified UTF-8 format": [[46, 66]]}}}, {"text": "If you're using Java6 the File class will do", "label": {"api": {"File": [[26, 29]]}}}, {"text": "Becaue \"a scanning operation may block waiting for input,\" I suspect you're blocking the event dispatch thread", "label": {"api": {"scanning operation": [[10, 27]]}}}, {"text": "Check out the KeyStore class", "label": {"api": {"KeyStore": [[14, 21]]}}}, {"text": "In this case, the obvious solution, java.util.prefs.Preferences, is probably the correct one", "label": {"api": {"java.util.prefs.Preferences": [[36, 62]]}}}, {"text": "You may use Map interface to implement it", "label": {"api": {"Map interface": [[12, 24]]}}}, {"text": "You can use the setFocusTraversalPolicy in your container", "label": {"api": {"setFocusTraversalPolicy": [[16, 38]], "FocusTraversalPolicy": [[19, 38]]}}}, {"text": "FocusTraversalPolicy class is abstract and you need implement few methods which will return the container's component focus order", "label": {"api": {"FocusTraversalPolicy": [[0, 19]]}}}, {"text": "Arrays.sort() only works for arrays; the equivalent function for lists is Collections.sort()", "label": {"api": {"Arrays.sort()": [[0, 12]], "Collections.sort()": [[74, 91]]}}}, {"text": "I can't say I fully understand the logic behind your code, but you might also want to take a look at Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[101, 121]]}}}, {"text": "In your case, I suggest you to use a TreeSet, it provides you a sorted collection (it sort itself after every add or remove", "label": {"api": {"TreeSet": [[37, 43]]}}}, {"text": "So, i suggest using AttributedString with main font attribute on whole string", "label": {"api": {"AttributedString": [[20, 35]]}}}, {"text": "The best option would probably to marshal to a TransformerHandler which does the xsl transformation and builds a dom tree", "label": {"api": {"TransformerHandler": [[47, 64]]}}}, {"text": "You can use setScale() e.g", "label": {"api": {"setScale()": [[12, 21]]}}}, {"text": "You can implement your own Iterator to do this", "label": {"api": {"Iterator": [[27, 34]]}}}, {"text": "Simply by implementing the Iterator however will not let you use it directly in a for loop", "label": {"api": {"Iterator": [[27, 34]]}}}, {"text": "This still uses nested loops, but uses a ListIterator instead", "label": {"api": {"ListIterator": [[41, 52]]}}}, {"text": "A ListIterator can be obtained through the listIterator(idx) method of the List interface", "label": {"api": {"ListIterator": [[2, 13]], "listIterator(idx) method": [[43, 66]]}}}, {"text": "Is there a reason you're not simply calling Window.setIconImages() on startup, and loading some images, possibly stored right within the JAR", "label": {"api": {"Window.setIconImages()": [[44, 65]]}}}, {"text": "— this means you know the full length of data %filekey% [3:%piece3% 5:%piece5% 7:%piece7% 8:%piece8% 9:%piece9%], so you can just use java.io.InputStream.read(byte[]) or .read(byte[], int, int) to read the exact number of bytes you need", "label": {"api": {"java.io.InputStream.read(byte[])": [[134, 165]], ".read(byte[], int, int)": [[170, 192]]}}}, {"text": "You can create any exception you like by extending the Exception class, like a NoNameProvidedException for example", "label": {"api": {"Exception": [[55, 63], [93, 101]]}}}, {"text": "This violates the following requirement", "label": {"api": {"requirement": [[28, 38]]}}}, {"text": "The above requirement implies that compare(x,x) must return zero", "label": {"api": {"requirement": [[10, 20]]}}}, {"text": "I would recommend reading the contract and making sure your implementation fulfils it", "label": {"api": {"contract": [[30, 37]]}}}, {"text": "The easiest way to compare your double values correctly is to call Double.compare", "label": {"api": {"Double.compare": [[67, 80]]}}}, {"text": "getClickCount()) of the MouseEvent", "label": {"api": {"getClickCount()": [[0, 14]]}}}, {"text": "Once your menu routine is done, call the repaint function on the appropriate component", "label": {"api": {"repaint": [[41, 47]]}}}, {"text": "You should wait for the threads to finish by calling join on each of them", "label": {"api": {"join": [[53, 56]]}}}, {"text": "A better approach is to use a PrintWriter to wrap your OutputStream and use println() instead because it handles this automatically", "label": {"api": {"PrintWriter": [[30, 40]]}}}, {"text": "Try Long.parseLong(String) or new BigInteger(String) for really big integers", "label": {"api": {"Long.parseLong(String)": [[4, 25]], "new BigInteger(String)": [[30, 51]]}}}, {"text": "There's another type called a Long which can store numbers up to 2^63 - 1", "label": {"api": {"Long": [[30, 33]]}}}, {"text": "Try parsing the string using java.text.NumberFormat into a long", "label": {"api": {"java.text.NumberFormat": [[29, 50]]}}}, {"text": "I think the problem here is with the characters in your input string, not in the CharsetDecoder provided by your JRE", "label": {"api": {"CharsetDecoder": [[81, 94]]}}}, {"text": "In particular, it doesn't distinguish between checked and unchecked exceptions and errors", "label": {"api": {"checked": [[46, 52], [60, 66]], "unchecked": [[58, 66]], "errors": [[83, 88]]}}}, {"text": "In other words, since the exception caught may be really anything including violated assertions, programming errors, thread interruptions, missing classes, I/O errors, OOM conditions and even library and VM bugs, the program state is practically unpredictable beyond the exception handler", "label": {"api": {"errors": [[109, 114], [160, 165]]}}}, {"text": "Even in these situations one should carefully consider whether errors, e.g", "label": {"api": {"errors": [[63, 68]]}}}, {"text": "VirtualMachineError should really be caught", "label": {"api": {"VirtualMachineError": [[0, 18]]}}}, {"text": "From looking at the Oracle/Sun JDK's 1.6.0_23 implementation of Scanner, the Scanner(File) constructor invokes a FileInputStream, which is meant for raw binary data", "label": {"api": {"Scanner(File)": [[77, 89]], "FileInputStream": [[113, 127]], "meant for raw binary data": [[139, 163]], "InputStream": [[117, 127]]}}}, {"text": "This points to a difference in buffering and parsing technique used when invoking one constructor or another, which will directly impact your code on the call to hasNextLine()", "label": {"api": {"hasNextLine()": [[162, 174]]}}}, {"text": "Scanner(InputStream) uses an InputStreamReader while Scanner(File) uses an InputStream passed to a ByteChannel (and probably reads the whole file in one jump, thus advancing the cursor, in your case)", "label": {"api": {"Scanner(File)": [[53, 65]], "Scanner(InputStream)": [[0, 19]], "InputStreamReader": [[29, 45]], "InputStream": [[8, 18], [29, 39], [75, 85]], "ByteChannel": [[99, 109]]}}}, {"text": "I think what you want to use is a CountDownLatch as this was built specifically for just this type of situation", "label": {"api": {"CountDownLatch": [[34, 47]]}}}, {"text": "To check if a value was actually 0 or null in the database, use ResultSet.wasNull", "label": {"api": {"ResultSet.wasNull": [[64, 80]]}}}, {"text": "If you don't want to implement your own thread.kill() mechanism from the scratch, you can use existing API, Manage your thread creation within a ThreadPoolExecutor, and use Future.cancel() to kill the running thread", "label": {"api": {"ThreadPoolExecutor": [[145, 162]], "Future.cancel()": [[173, 187]]}}}, {"text": "You could also have a look at the Locks", "label": {"api": {"Locks": [[34, 38]]}}}, {"text": "Otherwise you can throw a RuntimeException", "label": {"api": {"RuntimeException": [[26, 41]]}}}, {"text": "it's a RuntimeException afterall)", "label": {"api": {"RuntimeException": [[7, 22]]}}}, {"text": "See the JavaDoc for AtomicBoolean to grok what is going on there (assuming it is available in Android's Java)", "label": {"api": {"JavaDoc for AtomicBoolean": [[8, 32]]}}}, {"text": "The main difference is , StringBuffer is thread safe (all of its methods are synchronized),but StringBuilder is not", "label": {"api": {"StringBuffer": [[25, 36]], "StringBuilder": [[95, 107]]}}}, {"text": "But StringBuilder is faster than the StringBuffer.Use StringBuilder if you don't need thread-safety", "label": {"api": {"StringBuffer": [[37, 48]], "StringBuilder": [[4, 16], [54, 66]]}}}, {"text": "In this case you should be using f.dispose() instead", "label": {"api": {"f.dispose()": [[33, 43]]}}}, {"text": "System.exit stops the whole jvm", "label": {"api": {"System.exit": [[0, 10]]}}}, {"text": "Note that you can use setDefaultCloseOperation on the frame so that you close it using the window managers hooks (eg Alt-F4 etc)", "label": {"api": {"setDefaultCloseOperation": [[22, 45]]}}}, {"text": "java.util.Arrays#asList is what you are looking for", "label": {"api": {"java.util.Arrays#asList": [[0, 22]]}}}, {"text": "you can set object to ServletContext", "label": {"api": {"ServletContext": [[22, 35]]}}}, {"text": "I am trying to implement unit testing in a web application and certain parts of it use ThreadLocal", "label": {"api": {"ThreadLocal": [[87, 97]]}}}, {"text": "I need to be able to assign different values to my ThreadLocal variable", "label": {"api": {"ThreadLocal": [[51, 61]]}}}, {"text": "I recommend you use Futures and execute them using a ThreadPoolExecutor", "label": {"api": {"Futures": [[20, 26]], "ThreadPoolExecutor": [[53, 70]]}}}, {"text": "have you looked at Arrays.equals()", "label": {"api": {"Arrays.equals()": [[19, 33]]}}}, {"text": "For comparing the contents, use Arrays.equals()", "label": {"api": {"Arrays.equals()": [[32, 46]]}}}, {"text": "At the very least, use an object monitor or a lock to wait for that value to be set, rather than polling", "label": {"api": {"lock": [[46, 49]]}}}, {"text": "Even better, use a message bus to register handlers and process events as they come - you can easily construct a multithreaded message bus using any BlockingQueue implementation to pass message objects", "label": {"api": {"lock": [[150, 153]], "BlockingQueue": [[149, 161]]}}}, {"text": "If you are using an implementation of InputStream, you can check the result of InputStream#markSupported() that tell you whether or not you can use the method mark() / reset()", "label": {"api": {"InputStream": [[38, 48], [79, 89]], "InputStream#markSupported()": [[79, 105]], "mark()": [[159, 164]], "reset()": [[168, 174]]}}}, {"text": "If you can mark the stream when you read, then call reset() to go back to begin", "label": {"api": {"reset()": [[52, 58]]}}}, {"text": "Another solution would be to convert InputStream to byte array, then iterate over the array as many time as you need", "label": {"api": {"InputStream": [[37, 47]]}}}, {"text": "You can find several solutions in this post Convert InputStream to byte array in Java using 3rd party libs or not", "label": {"api": {"InputStream": [[52, 62]]}}}, {"text": "Using ImageIO#read(java.net.URL) also allows you to use cache", "label": {"api": {"ImageIO#read(java.net.URL)": [[6, 31]]}}}, {"text": "Use Java2D ColorConvertOp.filter(..) to convert colors of BufferedImage with specified ColorSpace", "label": {"api": {"ColorConvertOp.filter(..)": [[11, 35]], "ColorSpace": [[87, 96]]}}}, {"text": "Java image I/O uses the Service Provider Interface to support new image formats1", "label": {"api": {"Service Provider Interface": [[24, 49]]}}}, {"text": "Further I recommend to use File#createTempFile() instead to create temp files", "label": {"api": {"File#createTempFile()": [[27, 47]]}}}, {"text": "If you trust the website that produces the application, and are fetching it over a secure channel (encrypted to prevent MITM and tampering), then you can fetch the libraries, dump them to the local file system, verify any signatures or checksums, then call Runtime.loadLibrary or System.loadLibrary to load the native libraries before causing the class to initialize", "label": {"api": {"Runtime.loadLibrary or System.loadLibrary": [[257, 297]]}}}, {"text": "Using String.format is a little cleaner than concatenating several strings, in my opinion", "label": {"api": {"String.format": [[6, 18]]}}}, {"text": "I suggest you use a RandomAccessFile", "label": {"api": {"RandomAccessFile": [[20, 35]]}}}, {"text": "You can use TreeSet as a data-structure for storing the players and just call the treeSetObject.pollLast() method twice, which will give you the top 2 players", "label": {"api": {"TreeSet": [[12, 18]]}}}, {"text": "Open the file in Java with a reader which takes in an encoding", "label": {"api": {"reader": [[29, 34]]}}}, {"text": "Of course, if the URL doesn't have a filename then you'll get the hostname instead", "label": {"api": {"URL": [[18, 20]]}}}, {"text": "You're probably best off parsing a URL, extracting the file part of it, and removing the path and extension", "label": {"api": {"URL": [[35, 37]]}}}, {"text": "Within a servlet container, you should use ServletContext.getResource() and  ServletContext.getResourceAsStream() instead of Class.getResource() and Class.getResourceAsStream() respectively", "label": {"api": {"Class.getResource()": [[125, 143]], "Class.getResourceAsStream()": [[149, 175]]}}}, {"text": "Buffer.clear resets the position, yes, and then you can use getPosition() > 0 to check if anything has been added to the buffer afterwards, no...", "label": {"api": {"Buffer.clear": [[0, 11]]}}}, {"text": "You use an Executor, the implementation of which handles a pool of threads, decides how many, and so forth", "label": {"api": {"Executor": [[11, 18]]}}}, {"text": "Take a look at the Java Executor API", "label": {"api": {"Executor": [[24, 31]]}}}, {"text": "The Executor API allows you to create various types of thread pool for executing Runnable tasks, so you can reuse threads, flexibly manage the number that are created, and avoid the overhead of thread-per-runnable", "label": {"api": {"Executor": [[4, 11]]}}}, {"text": "From the java.lang.Thread documentation", "label": {"api": {"java.lang.Thread documentation": [[9, 38]]}}}, {"text": "Please refer to the JavaDoc's on Class for proper use of the forName method", "label": {"api": {"JavaDoc's on Class": [[20, 37]]}}}, {"text": "From the Scanner JavaDocs", "label": {"api": {"the Scanner JavaDocs": [[5, 24]]}}}, {"text": "Use a different delimiter, or use Scanner#nextLine() instead of Scanner#next()", "label": {"api": {"Scanner#nextLine()": [[34, 51]], "Scanner#next()": [[64, 77]]}}}, {"text": "There are many ways to read a file, but as you want to keep the count of characters to get 500 of them, you could use the read() method of the Reader object that will read character by character", "label": {"api": {"Reader": [[143, 148]]}}}, {"text": "The Reader object needs to be initialized with an object that extends Reader, like an InputStreamReader (this one take an implementation of an InputStream as parameter, a FileInputStream when working with a file as input)", "label": {"api": {"Reader": [[4, 9], [70, 75], [97, 102]]}}}, {"text": "In particular check out RescaleOp", "label": {"api": {"RescaleOp": [[24, 32]]}}}, {"text": "System.currentTimeMillis() is epoch in millisecond", "label": {"api": {"System.currentTimeMillis()": [[0, 25]]}}}, {"text": "For parsing the date from a string, I recommend using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[54, 69]], "Date": [[60, 63]]}}}, {"text": "That way you will obtain a Date object", "label": {"api": {"Date": [[27, 30]]}}}, {"text": "Use the Date object to create a GregorianCalendar", "label": {"api": {"Date": [[8, 11]], "GregorianCalendar": [[32, 48]]}}}, {"text": "Then, you can use GregorianCalendar's add method to increase it one day at a time until you reach your end date", "label": {"api": {"GregorianCalendar": [[18, 34]]}}}, {"text": "If you want multliple writes to the same file, use FileLocks", "label": {"api": {"FileLocks": [[51, 59]]}}}, {"text": "However i can't find anything about thread safety on the related java doc and thus the API does not make any such gurantees, as such implementations could vary", "label": {"api": {"on the related java doc": [[50, 72]]}}}, {"text": "'horizontally in multiple columns' can be done using a list and setLayoutOrientation(int)", "label": {"api": {"setLayoutOrientation(int)": [[64, 88]]}}}, {"text": "I think, you can also get it using JMX using ThreadMXBean management interface", "label": {"api": {"ThreadMXBean": [[45, 56]]}}}, {"text": "Use javax.swing.text.Utilities getRowStart/getRowEnd, passing the offsets", "label": {"api": {"javax.swing.text.Utilities": [[4, 29]]}}}, {"text": "See Charset to have a bit more informations about how to use it", "label": {"api": {"Charset": [[4, 10]]}}}, {"text": "In your case, you could for example use a CyclicBarrier, which will handle the synchronization details for you", "label": {"api": {"CyclicBarrier": [[42, 54]]}}}, {"text": "Unfortunately, the time zone formats available to SimpleDateFormat are not ISO8601 compliant", "label": {"api": {"SimpleDateFormat": [[50, 65]]}}}, {"text": "SimpleDateFormat understands time zone strings like \"GMT+01:00\" or \"+0100\", the latter according to RFC822", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Therefore using SimpleDateFormat does not seem as an option in your case (since you use UTC−05:00 as timezone)", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "Instead of SimpleDateFormat you need to use JodaTime for that type of date format", "label": {"api": {"SimpleDateFormat": [[11, 26]]}}}, {"text": "If you want to do it in Java, Use SimpleDateFormat like this", "label": {"api": {"SimpleDateFormat": [[34, 49]]}}}, {"text": "Yes, quoting the JavaDoc of List.subList(int, int)", "label": {"api": {"List.subList(int, int)": [[28, 49]]}}}, {"text": "If you want to stay with pure Java code, you can look for Calendar class to do your operations with dates", "label": {"api": {"Calendar": [[58, 65]]}}}, {"text": "You can also use ImageIO instead of Toolkit as far as I know", "label": {"api": {"ImageIO": [[17, 23]]}}}, {"text": "Simply inject HttpServletResponse and send the data directly", "label": {"api": {"HttpServletResponse": [[14, 32]]}}}, {"text": "You could easily call the chmod command from your Java application to add that missing x bit", "label": {"api": {"call": [[17, 20]]}}}, {"text": "Or you could do it straight from Java", "label": {"api": {"straight from Java": [[19, 36]]}}}, {"text": "You might consider using an AtomicInteger instead", "label": {"api": {"AtomicInteger": [[28, 40]]}}}, {"text": "SwingWorker is the most reliable approach with which to periodically publish the BufferedImage; there's an example here using Double", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "You might want to also have a look at the Matcher and Pattern classes", "label": {"api": {"Matcher": [[42, 48]], "Pattern": [[54, 60]]}}}, {"text": "In such case, you can write HttpServlet and in its service(HttpServletRequest req, HttpServletResponse resp) method rewrite request parameters and perform request to the destination service (using HttpClient for example)", "label": {"api": {"HttpServlet": [[28, 38], [59, 69], [83, 93]]}}}, {"text": "You have to call the cast method on the Class object", "label": {"api": {"cast method": [[21, 31]], "Class": [[40, 44]]}}}, {"text": "Take a look at java.lang.Runtime, in particular the various exec() methods", "label": {"api": {"java.lang.Runtime": [[15, 31]]}}}, {"text": "Use an Iterator", "label": {"api": {"Iterator": [[7, 14]]}}}, {"text": "If your list supports Iterator.remove you can use it instead", "label": {"api": {"Iterator": [[22, 29]], "Iterator.remove": [[22, 36]]}}}, {"text": "You might want to hava a look on the Matcher and Pattern classes as well", "label": {"api": {"Matcher": [[37, 43]], "Pattern": [[49, 55]]}}}, {"text": "You can also control file type assocations in the program using the IntegrationService (I've had no time to experiment with the service, so there is no demo", "label": {"api": {"IntegrationService": [[68, 85]]}}}, {"text": "The JSpinner.DateEditor component uses the same formatting as the SimpleDateFormat", "label": {"api": {"JSpinner.DateEditor": [[4, 22]], "SimpleDateFormat": [[66, 81]]}}}, {"text": "Have a look at the SimpleDateFormat formats", "label": {"api": {"SimpleDateFormat": [[19, 34]]}}}, {"text": "One possibility is to use Map<Integer,Integer> for the counts", "label": {"api": {"Map<Integer,Integer>": [[26, 45]]}}}, {"text": "You can solve it like this by using the Random class", "label": {"api": {"Random class": [[40, 51]]}}}, {"text": "Use JFrame.setDefaultCloseOperation to set a different value", "label": {"api": {"JFrame.setDefaultCloseOperation": [[4, 34]]}}}, {"text": "I would use a combination of ConcurrentHashMap and AtomicInteger http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html": [[65, 151]]}}}, {"text": "AFAIR java.util.concurrent.Future.get() will throw ExecutionException if provided callable threw exception in the past (the exception is stored in the Future)", "label": {"api": {"java.util.concurrent.Future.get()": [[6, 38]], "ExecutionException": [[51, 68]]}}}, {"text": "You could use a PhaseListener instead and hook on PhaseId.INVOKE_APPLICATION", "label": {"api": {"PhaseListener": [[16, 28]], "PhaseId.INVOKE_APPLICATION": [[50, 75]]}}}, {"text": "You can't do that using the Option Dialog from JOptionPane, but you still can create your own dialog window by extending JDialog, and this way you will be able to use the layout you want for your components", "label": {"api": {"JDialog": [[121, 127]]}}}, {"text": "Hashtable was the original implementation of a map in Java 1", "label": {"api": {"Hashtable": [[0, 8]]}}}, {"text": "It's been overtaken by the Map<K,V> implementations defined in the Java Collections Framework", "label": {"api": {"Map<K,V>": [[27, 34]]}}}, {"text": "Sure, Hashtable has been retrofitted to implement Map but that's not terribly useful", "label": {"api": {"Hashtable": [[6, 14]]}}}, {"text": "ConcurrentHashMap is a better choice in that situation", "label": {"api": {"ConcurrentHashMap": [[0, 16]], "HashMap": [[10, 16]]}}}, {"text": "If you are running on a single thread then the un-synchronized HashMap is a better choice", "label": {"api": {"HashMap": [[63, 69]]}}}, {"text": "If you are dealing with any class not visible from system class loader you'll run into JDK-6448699 LogManager does not load log handler correctly and JDK-6878454 LogManager class loading inconsistent with Java EE best practices", "label": {"api": {"system class loader": [[51, 69]]}}}, {"text": "You have to create your own URLStreamHandler so that you can set URLConnection parameters like connection timeout and read timeout", "label": {"api": {"URLStreamHandler": [[28, 43]], "URLConnection": [[65, 77]]}}}, {"text": "2) For less code, use the methods of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[37, 52]]}}}, {"text": "Second, override prepareEditor(), as shown in this example, and set the background color of the editor component to match", "label": {"api": {"prepareEditor()": [[17, 31]]}}}, {"text": "Maybe a HashSet<E>", "label": {"api": {"HashSet<E>": [[8, 17]], "Set<E>": [[12, 17]]}}}, {"text": "Or indeed, anything that implements Set<E>, although they don't all have O(1) expected lookup", "label": {"api": {"Set<E>": [[36, 41]]}}}, {"text": "You can do your own implementation (a lightweight one) of the Queue interface to manage the relevant (non-null) items", "label": {"api": {"Queue": [[62, 66]]}}}, {"text": "If you'd like to avoid blocking have a look at java.nio and channels (SocketChannel in particular)", "label": {"api": {"java.nio": [[47, 54]], "channels": [[60, 67]], "SocketChannel": [[70, 82]]}}}, {"text": "You could fix your regex by changing [^,]+ to [^,]*, but I'm inclined to agree with the spirit of Kisaro's comment above; I think you'd be better off using Pattern.split", "label": {"api": {"Pattern.split": [[156, 168]]}}}, {"text": "Add a fat EmptyBorder to the component", "label": {"api": {"EmptyBorder": [[10, 20]]}}}, {"text": "You could use LinkedBlockingQueues poll(long timeout, TimeUnit unit) -method in the consumer, and if it returns null (the timout elapsed), check the boolean flag", "label": {"api": {"LinkedBlockingQueues": [[14, 33]]}}}, {"text": "The key to the answer lies in the contract to Throwable.getStackTrace()", "label": {"api": {"Throwable.getStackTrace()": [[46, 70]]}}}, {"text": "Also access to this queue must be synchronized, consider ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[57, 74]]}}}, {"text": "In plain servlets you can use ServletContextListener by starting a thread in contextInitialized() and interrupting it in contextDestroyed", "label": {"api": {"ServletContextListener": [[30, 51]]}}}, {"text": "TimerService or @Schedule", "label": {"api": {"Timer": [[0, 4]]}}}, {"text": "Finally there is a Timer class in standard Java", "label": {"api": {"Timer": [[19, 23]]}}}, {"text": "The key thing to notice here is the distinct() operation", "label": {"api": {"distinct()": [[36, 45]]}}}, {"text": "You do need to close the input Stream, because the stream returned by the method you mention is actually FileInputStream or some other subclass of InputStream that holds a handle for a file", "label": {"api": {"FileInputStream": [[105, 119]]}}}, {"text": "Well you have to parse it, but that's easy enough to do with SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[61, 76]]}}}, {"text": "You can certainly implement the Shape interface yourself, but there's no need when you can use an  existing subclass, such as Ellipse2D", "label": {"api": {"Shape": [[32, 36]], "Ellipse2D": [[126, 134]]}}}, {"text": "There's an example here that shows how to center an arbitrary glyph in an Ellipse2D.Double", "label": {"api": {"Ellipse2D": [[74, 82]]}}}, {"text": "Have a look at the Java API of ParameterizedType", "label": {"api": {"ParameterizedType": [[31, 47]]}}}, {"text": "In general if you want incremented unique IDs in a Java application, AtomicIntegers work well", "label": {"api": {"AtomicInteger": [[69, 81]]}}}, {"text": "Use component.getMouseListeners() to check for your component Listeners and debug the code that handles its events", "label": {"api": {"component.getMouseListeners()": [[4, 32]]}}}, {"text": "You can use the form of String#split(regex,limit) which takes a limit", "label": {"api": {"String#split(regex,limit) which takes a limit": [[24, 68]]}}}, {"text": "You could also use a Scanner", "label": {"api": {"Scanner": [[21, 27]]}}}, {"text": "The Java Properties class is a serializable Map with a simple, human-editor-friendly format (see the Java Tutorial", "label": {"api": {"Properties class": [[9, 24]]}}}, {"text": "If all you need to save to file are key-value I would consider using Properties for this", "label": {"api": {"Properties": [[69, 78]]}}}, {"text": "You can convert from Properties to Map like this", "label": {"api": {"Properties": [[21, 30]]}}}, {"text": "As an alternative, try using a buffered reader or scanner to read in your data", "label": {"api": {"buffered reader": [[31, 45]]}}}, {"text": "TreeMap is a Map (implemented via a tree), not a tree (implemented via a Map or otherwise)", "label": {"api": {"TreeMap": [[0, 6]], "Map": [[4, 6], [13, 15], [73, 75]]}}}, {"text": "The parameterless forName explicitly loads the class it's being called with, and that's when static initializers are called (more or less)", "label": {"api": {"parameterless forName explicitly loads the class it's being called with": [[4, 74]]}}}, {"text": "You could try calling the variant that takes boolean initialize", "label": {"api": {"variant that takes boolean initialize": [[26, 62]]}}}, {"text": "It might be easier to use the Collections.sort(), this standard Java method will sort your Collection for you", "label": {"api": {"Collections.sort()": [[30, 47]]}}}, {"text": "String#split(String) takes a regular expression", "label": {"api": {"String#split(String)": [[0, 19]]}}}, {"text": "This is because String.split() needs a valid regular expression; text()= is not a valid regular expression, while = is a valid regular expression", "label": {"api": {"String.split()": [[16, 29]]}}}, {"text": "The Java String.split(String) method accepts a Java regular expression as the first (and only) parameter", "label": {"api": {"Java regular expression": [[47, 69]]}}}, {"text": "A LinkedHashMap will keep the data in the same order as it has been inserted", "label": {"api": {"LinkedHashMap": [[2, 14]]}}}, {"text": "The LinkedHashMap maintains insertion order", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "See the constructor FlowLayout(int align)", "label": {"api": {"FlowLayout(int align)": [[20, 40]]}}}, {"text": "If you see the API documentation of setChunkedStreamingMode, it has been mentioned there that not all servers support this mode", "label": {"api": {"setChunkedStreamingMode": [[36, 58]]}}}, {"text": "Java Strings already have one hash function built in that you can use - String.hashCode() with returns a 32-bit integer hash", "label": {"api": {"String.hashCode()": [[72, 88]]}}}, {"text": "If not, you'll probably want to roll your own, in which case I'd recommend using String.getChars() to access the raw char data, then use this to calculate multiple hashcodes", "label": {"api": {"String.getChars()": [[81, 97]]}}}, {"text": "The chief difference between those two is that in the first case, the string is implicitly interned; in the second case, it is not", "label": {"api": {"interned": [[91, 98]]}}}, {"text": "It sounds to me like a NavigableMap such as TreeMap is exactly what you're looking for", "label": {"api": {"NavigableMap": [[23, 34]]}}}, {"text": "To add more user-control to the process, look to the IntegrationService that was introduced in 1.6.0_18 (I don't have a demo", "label": {"api": {"IntegrationService": [[53, 70]]}}}, {"text": "you can use JToggleButton and put them in a ButtonGroup so that you can treat them as a group and set the color to the activated one", "label": {"api": {"JToggleButton": [[12, 24]], "ButtonGroup": [[44, 54]]}}}, {"text": "DefaultMutableTreeNode has depthFirstEnumeration() and breadthFirstEnumeration()", "label": {"api": {"depthFirstEnumeration()": [[27, 49]], "breadthFirstEnumeration()": [[55, 79]]}}}, {"text": "You can create a new String from chunks of the old one (using the substring() method) and stick your new character in the middle, or you can create a StringBuilder, which can be modified, then regenerate a String from that", "label": {"api": {"StringBuilder": [[150, 162]]}}}, {"text": "Can't you just use charAt to get the character and indexOf to check for whether or not the character is special", "label": {"api": {"charAt": [[19, 24]], "indexOf": [[51, 57]]}}}, {"text": "This sets a new value at index col of the array at index row in the nameOfArray ArrayList", "label": {"api": {"ArrayList": [[80, 88]]}}}, {"text": "Use FileChannels or RandomAccessFile insteead", "label": {"api": {"FileChannels": [[4, 15]]}}}, {"text": "Have you considered using a Map", "label": {"api": {"Map": [[28, 30]]}}}, {"text": "Calling getDocument on the jTextPane returns an HTMLDocument", "label": {"api": {"HTMLDocument": [[48, 59]]}}}, {"text": "Use StringBuilder instead, use the insert() methods", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "A value of -1 here implies that linger is disabled", "label": {"api": {"linger is disabled": [[32, 49]]}}}, {"text": "Have a look at Canvas and Graphics (Tutorial)", "label": {"api": {"Canvas": [[15, 20]], "Graphics": [[26, 33]]}}}, {"text": "You need to add the Canvas to a JContainer for example JPanel", "label": {"api": {"Canvas": [[20, 25]]}}}, {"text": "Have a look at the java.util.Timer class, this is exactly what you need", "label": {"api": {"java.util.Timer": [[19, 33]]}}}, {"text": "The closest you have is network mac address", "label": {"api": {"network mac address": [[24, 42]]}}}, {"text": "Can't you just get all the variables and filter them by type using Field.getType()", "label": {"api": {"Field.getType()": [[67, 81]]}}}, {"text": "You could use String.format instead", "label": {"api": {"String.format": [[14, 26]]}}}, {"text": "I'm trying to write my own implementation of ListSelectionModel and currently I'm stuck while trying to implement insertIndexInterval", "label": {"api": {"ListSelectionModel": [[45, 62]]}}}, {"text": "I don't understand the result of this method in Sun's/Oracle's DefautListSelectionModel implementation", "label": {"api": {"ListSelectionModel": [[69, 86]]}}}, {"text": "Consider using ArrayList instead", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "Use ArrayList instead", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "Use ArrayList for a dynamic size", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "DataOutputStream does not implement any caching (which is good", "label": {"api": {"DataOutputStream": [[0, 15]]}}}, {"text": "Even the simplest methods like writeInt() can result in four separate disk writes", "label": {"api": {"writeInt()": [[31, 40]]}}}, {"text": "As far as I can see only write(byte[], int, int) and writeUTF(String) are writing data in one byte[] chunk", "label": {"api": {"write(byte[], int, int)": [[25, 47]], "writeUTF(String)": [[53, 68]]}}}, {"text": "The injector, after creating the instance, can use the Reflection API to look at the fields of the Class and inspect their annotations with Field.getDeclaredAnnotations()", "label": {"api": {"Field.getDeclaredAnnotations()": [[140, 169]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "As you can see in the Oracle Documentation for java.awt.Point, x and y are stored as int", "label": {"api": {"java.awt.Point": [[47, 60]]}}}, {"text": "It would be better to use java.io.File and the appropriate methods on those classes for walking and manipulating the file system", "label": {"api": {"java.io.File": [[26, 37]]}}}, {"text": "extends Object>, which means it can contain any object inherits from Object class (i.e", "label": {"api": {"Object": [[8, 13], [69, 74]]}}}, {"text": "Socket.bind or the Socket constructor which accepts a local port", "label": {"api": {"Socket.bind": [[0, 10]], "the Socket constructor which accepts a local port": [[15, 63]]}}}, {"text": "But if tasklist works for you, you can use ProcessBuilder in order to run the windows command taskkill", "label": {"api": {"ProcessBuilder": [[43, 56]]}}}, {"text": "Call taskkill like this with a ProcessBuilder instance cmd /c taskkill /pid %pid% (replace %pid% with the actual pid)", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "(There can be at most one such mapping.)\" (reference)", "label": {"api": {"reference": [[43, 51]]}}}, {"text": "You want some variant of ClassLoader.getResource(), though whether you access via the classloader or the class depends on how you want to package things", "label": {"api": {"ClassLoader.getResource()": [[25, 49]]}}}, {"text": "You can overload the toString() method on the Job class to return the string describing a Job", "label": {"api": {"toString()": [[21, 30]]}}}, {"text": "You can use Double.parseDouble(String) to convert the contents of your strings into double-precision floating-point numbers", "label": {"api": {"Double.parseDouble(String)": [[12, 37]]}}}, {"text": "It's Collections.sort() with an s", "label": {"api": {"Collections.sort()": [[5, 22]]}}}, {"text": "If you're using Swing, then you should be able to use Line2D.ptSegDist(Point2D) or its various overloads to do all the math for you", "label": {"api": {"Line2D.ptSegDist(Point2D)": [[54, 78]]}}}, {"text": "If it's for real code, use a higher level mechanism in java.util.concurrent", "label": {"api": {"java.util.concurrent": [[55, 74]]}}}, {"text": "The standard way in Java 8 is Integer.toUnsignedLong(someInt), which is equivalent to @Mysticial's answer", "label": {"api": {"Integer.toUnsignedLong(someInt)": [[30, 60]]}}}, {"text": "Try using a combination of Random#nextBytes(byte[]) and new BigInteger(byte[])", "label": {"api": {"Random#nextBytes(byte[])": [[27, 50]], "new BigInteger(byte[])": [[56, 77]]}}}, {"text": "I believe in Java SE you can only refer to drives on Windows by using the File.listRoots() method, which will just return a list like {\"C:\\\", \"D:\\\", \"E:\\\"}, and of course, the USB drive could be mounted on (essentially) any drive letter", "label": {"api": {"File.listRoots() method": [[74, 96]]}}}, {"text": "Java 8 added Base64 methods, so Apache Commons is no longer needed to encode large files", "label": {"api": {"Base64": [[13, 18]]}}}, {"text": "You're looking for any class that implements the Queue interface, excluding PriorityQueue and PriorityBlockingQueue, which do not use a FIFO algorithm", "label": {"api": {"Queue interface": [[49, 63]]}}}, {"text": "Probably a LinkedList using add (adds one to the end) and removeFirst (removes one from the front and returns it) is the easiest one to use", "label": {"api": {"LinkedList": [[11, 20]]}}}, {"text": "For example, here's a program that uses a LinkedList to queue and retrieve the digits of PI", "label": {"api": {"LinkedList": [[42, 51]]}}}, {"text": "Alternatively, if you know you only want to treat it as a queue (without the extra features of a linked list), you can just use the Queue interface itself", "label": {"api": {"Queue interface": [[132, 146]]}}}, {"text": "This has the advantage of allowing you to replace the underlying concrete class with any class that provides the Queue interface, without having to change the code too much", "label": {"api": {"Queue interface": [[113, 127]]}}}, {"text": "The basic changes are to change the type of fifo to a Queue and to use remove() instead of removeFirst(), the latter being unavailable for the Queue interface", "label": {"api": {"Queue interface": [[143, 157]]}}}, {"text": "Queues are First In First Out structures", "label": {"api": {"Queue": [[0, 4]]}}}, {"text": "You request is pretty vague, but I am guessing that you need only the basic functionality which usually comes out with Queue structures", "label": {"api": {"Queue": [[119, 123]]}}}, {"text": "Or the Byte constructor", "label": {"api": {"Byte constructor": [[7, 22]]}}}, {"text": "BTW your code also uses Files introduced in Java 7", "label": {"api": {"Files": [[24, 28]]}}}, {"text": "Have you tried with an AtomicInteger", "label": {"api": {"AtomicInteger": [[23, 35]]}}}, {"text": "You, as being the server, can also determine the mime type based on the file extension by ExternalContext#getMimeType(), or when you're still on the ancient JSF 1.x, by ServletContext#getMimeType()", "label": {"api": {"ExternalContext#getMimeType()": [[90, 118]], "ServletContext#getMimeType()": [[169, 196]]}}}, {"text": "I would advise you to use the Matcher.find method", "label": {"api": {"Matcher.find": [[30, 41]]}}}, {"text": "Also note that Pattern.matches(regex, input) boils down to", "label": {"api": {"Pattern.matches(regex, input)": [[15, 43]]}}}, {"text": "Which calls Matcher.matches", "label": {"api": {"Matcher.matches": [[12, 26]]}}}, {"text": "For this particular case I would not use regexp but rather use String's startsWith(String prefix, int toffset) instead", "label": {"api": {"startsWith(String prefix, int toffset)": [[72, 109]]}}}, {"text": "You could use Swing Worker or ExecutorService to implement this but for such a simple task you might be better off just starting a thread with a callback", "label": {"api": {"Swing Worker": [[14, 25]], "ExecutorService": [[30, 44]]}}}, {"text": "StringBuilder is a good utility for that", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "Reading the docs for invokeAll", "label": {"api": {"invokeAll": [[21, 29]]}}}, {"text": "I would create a work queue for each of your target databases using some BlockingQueue such as a LinkedBlockingQueue", "label": {"api": {"BlockingQueue": [[73, 85], [103, 115]], "LinkedBlockingQueue": [[97, 115]]}}}, {"text": "TimeUnit.SECONDS.sleep(x) will call Thread.sleep", "label": {"api": {"TimeUnit.SECONDS.sleep(x)": [[0, 24]], "Thread.sleep": [[36, 47]], "TimeUnit": [[0, 7]]}}}, {"text": "The only difference is readability and using TimeUnit is probably easier to understand for non obvious durations (for example", "label": {"api": {"TimeUnit": [[45, 52]]}}}, {"text": "For reference, see below the code of sleep() in TimeUnit", "label": {"api": {"TimeUnit": [[48, 55]]}}}, {"text": "I prefer the latter because it is more descriptive and allows to choose time unit (see TimeUnit)", "label": {"api": {"TimeUnit": [[87, 94]]}}}, {"text": "You can use the appropriate read() method from the input stream, for example FileInputStream supports a read(byte[]) to read a chunk of bytes", "label": {"api": {"FileInputStream": [[77, 91]]}}}, {"text": "Then you can implement Collections.sort to sort your list", "label": {"api": {"Collections.sort": [[23, 38]]}}}, {"text": "Now, during the reading just put all those records into SortedSet implementation, for example", "label": {"api": {"SortedSet": [[56, 64]]}}}, {"text": "You can also store records into an array or List and sort them using Arrays or Collections class", "label": {"api": {"Arrays": [[69, 74]], "Collections": [[79, 89]]}}}, {"text": "HashMap is an implementation of Map", "label": {"api": {"Map": [[4, 6], [32, 34]]}}}, {"text": "Map is just an interface for any type of map", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "Use a TableRowSorter - which is", "label": {"api": {"TableRowSorter": [[6, 19]]}}}, {"text": "Also, I strongly advise you to change the code to use PreparedStatement with bound arguments (represented by ?)", "label": {"api": {"PreparedStatement": [[54, 70]]}}}, {"text": "Read your regex manuals for more details there", "label": {"api": {"regex manuals": [[10, 22]]}}}, {"text": "You can have have the parent JFrame implement WindowListener and register it with the child JFrame", "label": {"api": {"WindowListener": [[46, 59]]}}}, {"text": "You could create a BlockingQueue<Runnable> with a fixed capacity and have each of your worker threads dequeue a Runnable and run it", "label": {"api": {"BlockingQueue<Runnable>": [[19, 41]]}}}, {"text": "Looks like you can use setInstanceFollowRedirects() to alter the default behaviour defined in setFollowRedirects() on a per connection basis", "label": {"api": {"setInstanceFollowRedirects()": [[23, 50]], "setFollowRedirects()": [[94, 113]]}}}, {"text": "Once setFollowRedirects() is called, all connections created afterwards will use this value as default", "label": {"api": {"setFollowRedirects()": [[5, 24]]}}}, {"text": "This interface is new with Java 7", "label": {"api": {"new with Java 7": [[18, 32]]}}}, {"text": "The class extends from AbstractTableModel, which means you can set it as the your JTable's data source", "label": {"api": {"which means you can set it": [[43, 68]]}}}, {"text": "See String.intern for details", "label": {"api": {"String.intern": [[4, 16]]}}}, {"text": "The API, as always, provides more information", "label": {"api": {"The API": [[0, 6]]}}}, {"text": "Try myJList.clearSelection(); It clears the selection(s) on your JList object", "label": {"api": {"myJList.clearSelection();": [[4, 28]]}}}, {"text": "One of the idea to have a filter, and in it have a condition based on ServletRequest#getServerName() and dispatch the request to appropriate servlet, will do", "label": {"api": {"filter": [[26, 31]], "ServletRequest#getServerName()": [[70, 99]]}}}, {"text": "It turns out the service implementation mypackage.MyServiceImpl was missing the javax.jws.WebService annotation", "label": {"api": {"javax.jws.WebService": [[80, 99]]}}}, {"text": "I guess that you're looking for TreeMap", "label": {"api": {"TreeMap": [[32, 38]]}}}, {"text": "Use Set, not List", "label": {"api": {"Set": [[4, 6]], "List": [[13, 16]]}}}, {"text": "If that does not work, check out the API of HTTPServletRequest to see if there is another way to get your data", "label": {"api": {"the API": [[33, 39]]}}}, {"text": "Use the indexOf method of ArrayList", "label": {"api": {"indexOf": [[8, 14]]}}}, {"text": "You can use an InputVerifier, take a look at the following code", "label": {"api": {"InputVerifier": [[15, 27]]}}}, {"text": "You could use String.format()", "label": {"api": {"String.format()": [[14, 28]]}}}, {"text": "You can easily make a GUI like that in the screenshot designing it with WindowBuilder and using GroupLayout as layout manager for example, otherwise you can use Netbeans", "label": {"api": {"GroupLayout": [[96, 106]]}}}, {"text": "Your CDStore could implement the interface ListModel", "label": {"api": {"ListModel": [[43, 51]]}}}, {"text": "Here is example implementation of CDStore implements ListModel", "label": {"api": {"ListModel": [[53, 61]]}}}, {"text": "you are basically recreating the work of a CompletionService (implementation is ExecutorCompletionService), i would recommend using that instead", "label": {"api": {"CompletionService": [[43, 59], [88, 104]], "ExecutorCompletionService": [[80, 104]]}}}, {"text": "Use a byte[] or a ByteBuffer if you need simplified byte-level manipulation", "label": {"api": {"ByteBuffer": [[18, 27]]}}}, {"text": "You may have a look on Apache Commons FileUpload and setBlob() of PreparedStratement", "label": {"api": {"setBlob()": [[53, 61]]}}}, {"text": "What you are looking for is probably a Map, not List", "label": {"api": {"Map": [[39, 41]]}}}, {"text": "Why Dictionary and not Map", "label": {"api": {"Map": [[23, 25]]}}}, {"text": "For security, consider JPasswordField, illustrated here", "label": {"api": {"JPasswordField": [[23, 36]]}}}, {"text": "This would allow use of a DocumentFilter, discussed here", "label": {"api": {"DocumentFilter": [[26, 39]]}}}, {"text": "Even for the more general case, I'd use a DocumentFilter, as shown below", "label": {"api": {"DocumentFilter": [[42, 55]]}}}, {"text": "What you want to do is skip the content you don't want by way of the ByteBuffer.position(int) method - there is no magic in the ByteBuffer impl, it is a backing data store (either a byte[] or direct memory reference to OS) and a series of int pointers that refer to conceptual positions in the buffer (start, end, limit, etc.) -- you just want to make sure you \"skip\" the bytes you don't want, which can be done by moving the position beyond it so the next operation to write out the entire buffer will start from position and go to limit", "label": {"api": {"ByteBuffer.position(int)": [[69, 92]]}}}, {"text": "For example, a date could be mapped to month-level aggregation with the Formatter pattern \"%1$04tY-%1$02tm\" (i.e., YYYY-MM)", "label": {"api": {"Formatter pattern": [[72, 88]]}}}, {"text": "Will two java.security.SecureRandom instances which are seeded with the same value initially give the same sequence of random numbers", "label": {"api": {"java.security.SecureRandom": [[9, 34]]}}}, {"text": "From the API docs", "label": {"api": {"the API docs": [[5, 16]]}}}, {"text": "Collections.nCopies(int n, T o) returns a List<T> containing n copies of the given object o", "label": {"api": {"Collections.nCopies(int n, T o)": [[0, 30]]}}}, {"text": "In this case, you have overridden the Thread.run() method", "label": {"api": {"Thread.run()": [[38, 49]]}}}, {"text": "I would use a BlockingQueue", "label": {"api": {"BlockingQueue": [[14, 26]]}}}, {"text": "You could try the RescaleOp that handles alpha, illustrated here, and use the same lightLevel for all color components", "label": {"api": {"RescaleOp": [[18, 26]]}}}, {"text": "Set the Graphics objects clip", "label": {"api": {"clip": [[25, 28]]}}}, {"text": "Rather use the executors from the java.util.concurrent package", "label": {"api": {"the java.util.concurrent package": [[30, 61]]}}}, {"text": "In cases where you need to update the GUI from another class, you need to use SwingUtilities.invokeLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[78, 105]]}}}, {"text": "System.getenv() reads environment variables, such as PATH", "label": {"api": {"System.getenv": [[0, 12]]}}}, {"text": "You can use System.getProperty() to read the system property value from within your code", "label": {"api": {"System.getProperty()": [[12, 31]]}}}, {"text": "Instead of implementing ActionListener, implement Action by extending AbstractAction, which will make it easier to manage the accelerator key", "label": {"api": {"Action": [[24, 29], [50, 55], [78, 83]]}}}, {"text": "Thread#setUncaughtExceptionHandler to specify some code that is run when an exception is thrown (outside of normal program flow), or", "label": {"api": {"Thread#setUncaughtExceptionHandler": [[0, 33]]}}}, {"text": "ExecutorService#invokeAll to run all of your blocks, and inspect the returned list for Future#get()'s throwing of ExecutionException", "label": {"api": {"ExecutorService#invokeAll": [[0, 24]], "Future#get()": [[87, 98]]}}}, {"text": "Another option is CompletionService, but this is slightly harder to use for such a simple case", "label": {"api": {"CompletionService": [[18, 34]]}}}, {"text": "Instead, you're dealing with the higher level of abstraction of ExecutorServices", "label": {"api": {"ExecutorService": [[64, 78]]}}}, {"text": "Can you use Integer.toString()", "label": {"api": {"Integer.toString()": [[12, 29]]}}}, {"text": "Java 7's Files.copy method helps you copy a file from one location to another", "label": {"api": {"Files.copy": [[9, 18]]}}}, {"text": "If you want to use multiple JFrames you could use the method setEnabled() when you open the other JFrame", "label": {"api": {"setEnabled()": [[61, 72]]}}}, {"text": "Otherwise you should go with JDialog and its method setModal()", "label": {"api": {"setModal()": [[52, 61]]}}}, {"text": "It has an HTML-style layout language called FXML", "label": {"api": {"FXML": [[44, 47]]}}}, {"text": "In the javadocs for the available() method, it says", "label": {"api": {"available()": [[24, 34]]}}}, {"text": "Using a fixed sized buffer should solve your problem instead of InputStream.available() which could return 0", "label": {"api": {"available()": [[76, 86]]}}}, {"text": "I think you should use the Calendar class and get an instance of the Calendar and then set the time", "label": {"api": {"Calendar": [[27, 34], [69, 76]]}}}, {"text": "Once that is done, you create a date object from the Calendar and parse it to your needs", "label": {"api": {"Calendar": [[53, 60]]}}}, {"text": "If this is the problem you can fix it by wrapping your List using Collections.synchronizedList()", "label": {"api": {"Collections.synchronizedList()": [[66, 95]]}}}, {"text": "To do that at run-time in a JWS app., look to the IntegrationService introduced in 1.6.0_18+", "label": {"api": {"IntegrationService": [[50, 67]]}}}, {"text": "Capital D is day in year", "label": {"api": {"day in year": [[13, 23]]}}}, {"text": "The only way in to \"kill\" a Thread in Java is the deprecated stop() method", "label": {"api": {"stop()": [[61, 66]]}}}, {"text": "use ProcessBuilder and Process.destroy()", "label": {"api": {"ProcessBuilder": [[4, 17]], "Process.destroy()": [[23, 39]]}}}, {"text": "In an event driven environment a Datagram Socket will incur lower network overhead but will not give you the reliability", "label": {"api": {"Datagram Socket": [[33, 47]]}}}, {"text": "probablePrime has been in Java since version 1.4", "label": {"api": {"probablePrime": [[0, 12]]}}}, {"text": "In addition, there is no mention of this system property in the documentation where javax.rmi.ssl.client.enabledCipherSuites is documented", "label": {"api": {"in the documentation": [[57, 76]]}}}, {"text": "Java API on Class", "label": {"api": {"Java API on Class": [[0, 16]]}}}, {"text": "In Java 7, there is the java.nio.file.Files.probeContentType() method", "label": {"api": {"java.nio.file.Files.probeContentType()": [[24, 61]]}}}, {"text": "You might want to have a look at Process class and Runtime.exec() method ( and it's variations ) for starting a sub-process (gedit in your case) and working with it while executing your Java program", "label": {"api": {"Process": [[33, 39]], "Runtime.exec()": [[51, 64]]}}}, {"text": "See the ProcessBuilder constructor JavaDoc for more details and examples", "label": {"api": {"ProcessBuilder constructor JavaDoc": [[8, 41]]}}}, {"text": "The String.hashCode() method is based only on the content of the string, not the object identity", "label": {"api": {"String.hashCode()": [[4, 20]]}}}, {"text": "With an IdentityHashMap you would get different results for map.get(\"a\") and map.get(new String(\"a\")), but that class is clearly documented as violating the general contract of maps", "label": {"api": {"IdentityHashMap": [[8, 22]]}}}, {"text": "Prefer PrintWriter, which will wrap an arbitrary Writer", "label": {"api": {"PrintWriter": [[7, 17]]}}}, {"text": "(String objects are immutable)", "label": {"api": {"objects": [[8, 14]]}}}, {"text": "String.split() should suffice", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "But I think that Scanner is the best fit for your problem", "label": {"api": {"Scanner": [[17, 23]]}}}, {"text": "I recommend using the same sort of logic as is used by java.util.List.hashCode(), which is a straightforward and effective way to assemble the hash-codes of component objects in a specific order; basically you would write something like", "label": {"api": {"java.util.List.hashCode()": [[55, 79]]}}}, {"text": "I think the problem with Collections.shuffle() is that is uses default Random instance which is a thread-safe singleton", "label": {"api": {"Collections.shuffle()": [[25, 45]], "Random": [[71, 76]], "shuffle()": [[37, 45]]}}}, {"text": "You say that your program is multi-threaded, so I can imagine synchronization in Random being a bottle-neck", "label": {"api": {"Random": [[81, 86]]}}}, {"text": "If you are happily running on Java 7, simply use ThreadLocalRandom", "label": {"api": {"Random": [[60, 65]], "ThreadLocalRandom": [[49, 65]]}}}, {"text": "Look carefully, there is a version of shuffle() taking Random instance explicitly", "label": {"api": {"Random": [[55, 60]], "shuffle()": [[38, 46]]}}}, {"text": "where threadLocalRandom is created only once", "label": {"api": {"Random": [[17, 22]]}}}, {"text": "On Java 6 you can simply create a single instance of Random once per thread", "label": {"api": {"Random": [[53, 58]]}}}, {"text": "Note that you shouldn't create a new instance of Random per run, unless you can provide random seed every time", "label": {"api": {"Random": [[49, 54]]}}}, {"text": "If you want anything more complicated, you can always iterate yourself, performing any comparisons you want, and then use List.remove(int) to remove by index", "label": {"api": {"List.remove(int)": [[122, 137]]}}}, {"text": "If timestamp is an invalid date, the parse method throws a ParseException, so it's not that", "label": {"api": {"parse method": [[37, 48]], "ParseException": [[59, 72]]}}}, {"text": "If timestamp is null, parse() throws a NullPointerException", "label": {"api": {"NullPointerException": [[39, 58]]}}}, {"text": "As the search may take some time to complete, consider using SwingWorker, illustrated here", "label": {"api": {"SwingWorker": [[61, 71]]}}}, {"text": "In essence, there is a Field.getGenericType() method introduced in (surprise) 1.5 that always returns reliable generic type of a field", "label": {"api": {"Field.getGenericType()": [[23, 44]]}}}, {"text": "The double -> long conversion is done via public static doubleToLongBits()", "label": {"api": {"public static doubleToLongBits()": [[42, 73]]}}}, {"text": "Use replace as suggested", "label": {"api": {"replace": [[4, 10]]}}}, {"text": "If you want to allocate elements in array dynamically, may be you should consider ArrayList", "label": {"api": {"ArrayList": [[82, 90]]}}}, {"text": "A SwingWorker uses an ExecutorService internally, but the worker \"is only designed to be executed once.\" I don't see why you're wrapping the worker in a Runnable that's scheduled at a fixed rate", "label": {"api": {"SwingWorker": [[2, 12]], "ExecutorService": [[22, 36]]}}}, {"text": "For line numbers, SwingWorker<Boolean, Integer> may be appropriate", "label": {"api": {"SwingWorker": [[18, 28]]}}}, {"text": "The trigger can be a java.util.Timer, a javax.swing.Timer or even the ScheduledExecutorService you originally proposed", "label": {"api": {"ExecutorService": [[79, 93]]}}}, {"text": "The first entry in an ArrayList<Integer> is accessible as an Integer via get(0)", "label": {"api": {"get(0)": [[73, 78]]}}}, {"text": "Then, to get an int from the Integer, you use intValue (although as you're using Java5 or later, you don't need to; the compiler will automatically unbox it for you)", "label": {"api": {"intValue": [[46, 53]]}}}, {"text": "The method javax.xml.bind.DatatypeConverter.printHexBinary(), part of the Java Architecture for XML Binding (JAXB), was a convenient way to convert a byte[] to a hex string", "label": {"api": {"javax.xml.bind.DatatypeConverter.printHexBinary()": [[11, 59]], "DatatypeConverter": [[26, 42]]}}}, {"text": "The DatatypeConverter class also included many other useful data-manipulation methods", "label": {"api": {"DatatypeConverter": [[4, 20]]}}}, {"text": "Now, javax.xml.bind doesn't exist, and if you want to use JAXB, which contains DatatypeConverter, you'll need to install the JAXB API and JAXB Runtime from Maven", "label": {"api": {"DatatypeConverter": [[79, 95]]}}}, {"text": "You can use Runtime's maxMemory() method to get how much heap is allocated to the process", "label": {"api": {"maxMemory()": [[22, 32]]}}}, {"text": "Scanner class has also hasNextBigDecimal() method, so you would like to do", "label": {"api": {"hasNextBigDecimal()": [[23, 41]]}}}, {"text": "This uses System.getenv() to get a map of all environment variables", "label": {"api": {"System.getenv()": [[10, 24]]}}}, {"text": "Consider using BigDecimal if exactness is required", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "Use NumberFormat class instead of Float.parseFloat", "label": {"api": {"NumberFormat": [[4, 15]]}}}, {"text": "Since Java 1.3+, use the Clip class of the Java Sound API", "label": {"api": {"Clip": [[25, 28]]}}}, {"text": "It is similar to the applet based AudioClip class, but better", "label": {"api": {"Clip": [[39, 42]]}}}, {"text": "You're looking for the Object.getClass() method", "label": {"api": {"Object.getClass()": [[23, 39]]}}}, {"text": "To read the file, you can use a Scanner", "label": {"api": {"Scanner": [[32, 38]]}}}, {"text": "If you have spaces in your Strings, you should use commas and tell the Scanner to use ,s as a delimiter", "label": {"api": {"Scanner": [[71, 77]]}}}, {"text": "You can't just stop any thread*", "label": {"api": {"can": [[4, 6]]}}}, {"text": "You can try interrupting it", "label": {"api": {"interrupting": [[12, 23]], "can": [[4, 6]]}}}, {"text": "If it performs CPU intensive operations, the thread must periodically check isInterrupted() flag and terminate if it happens to be set", "label": {"api": {"isInterrupted()": [[76, 90]]}}}, {"text": "If it waits on I/O or sleeps, chances are it will just work - see InterruptedException", "label": {"api": {"InterruptedException": [[66, 85]]}}}, {"text": "Well, technically you can, but this method is deprecated for a reason", "label": {"api": {"can": [[22, 24]]}}}, {"text": "It may be worthwhile to wrap your HashMap with Collections#synchronizedMap", "label": {"api": {"Collections#synchronizedMap": [[47, 73]]}}}, {"text": "Implementations of map such as HashMap, TreeMap, etc are not atomic nor thread safe when it comes to updates, but you may achieve atomic update operations when you're using a ConcurrentHashMap since Java 1.8", "label": {"api": {"ConcurrentHashMap": [[175, 191]]}}}, {"text": "if you have two sequences of boolean values, no equal size, and only need a portion of it (left to right), I'd suggest using a BitSet", "label": {"api": {"BitSet": [[127, 132]]}}}, {"text": "Also refer to the ArrayList JavaDoc", "label": {"api": {"ArrayList JavaDoc": [[18, 34]]}}}, {"text": "This might not be as visual as you like, but the hierarchy can be seen in the official Java docs", "label": {"api": {"the official Java docs": [[74, 95]]}}}, {"text": "As per your example, here's what it shows for Exception", "label": {"api": {"Exception": [[46, 54]]}}}, {"text": "Atoms are similar to Java's atomic data types (like AtomicReference), but are actually somewhat more powerful since an atom allows you to use an arbitrary function to update the atom", "label": {"api": {"AtomicReference": [[52, 66]]}}}, {"text": "To do that at run-time in a JWS app., look to the IntegrationService introduced in 1.6.0_18+", "label": {"api": {"IntegrationService": [[50, 67]]}}}, {"text": "Use Class and Method to iterate over the methods", "label": {"api": {"Class": [[4, 8]], "Method": [[14, 19]]}}}, {"text": "Use the getAnnotation method to determine if a method has the annotation", "label": {"api": {"getAnnotation": [[8, 20]]}}}, {"text": "Look at the javadocs for java.util.concurrent.RecursiveAction which shows an example of partitioning an array to sort it", "label": {"api": {"java.util.concurrent.RecursiveAction": [[25, 60]]}}}, {"text": "You can use javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[12, 28]]}}}, {"text": "I think JProgressBar  is what you need!.", "label": {"api": {"JProgressBar": [[8, 19]]}}}, {"text": "You can use the contains method", "label": {"api": {"contains": [[16, 23]]}}}, {"text": "You can use mkdirs", "label": {"api": {"mkdirs": [[12, 17]]}}}, {"text": "HashMap is unordered, and Collections.sort() works only on Lists", "label": {"api": {"Collections.sort()": [[26, 43]]}}}, {"text": "You might want to use a TreeMap instead of a HashMap here, but it is sorted according to keys [and not values!] [I am not sure I understand, but if you are trying to sort according to the key, you can just make your class implement Comparable or implement your own Comparator, and TreeMap will probably best fit here]", "label": {"api": {"TreeMap": [[24, 30], [281, 287]], "Comparable": [[232, 241]], "Comparator": [[265, 274]]}}}, {"text": "An alternative is using LinkedHashMap [and have to do some more work]", "label": {"api": {"LinkedHashMap": [[24, 36]]}}}, {"text": "LinkedHashMap maintain elements at the order you inserted them, so you will have to maintain it by yourself", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "If you do not have a way to find out which item is the last one, then you could use an IdentityHashMap to map each previousItem value to the Item object that uses it", "label": {"api": {"IdentityHashMap": [[87, 101]]}}}, {"text": "Place two charts in a StackPane", "label": {"api": {"StackPane": [[22, 30]]}}}, {"text": "Use css lookups on the top chart to translate (using translate-x and translate-y) it's axes and labels so that they can be read independently of the bottom chart", "label": {"api": {"css lookups": [[4, 14]]}}}, {"text": "The plug-in's own SplashScreen is pure AWT", "label": {"api": {"SplashScreen": [[18, 29]]}}}, {"text": "use of SplashScreen & the EDT", "label": {"api": {"SplashScreen": [[7, 18]]}}}, {"text": "With the standard libraries, you can use SimpleDateFormat for that", "label": {"api": {"SimpleDateFormat": [[41, 56]]}}}, {"text": "There are other higher-level frameworks available that give you more control on how things are run such as Executors, which can for example be used to schedule events", "label": {"api": {"schedule events": [[151, 165]]}}}, {"text": "I suspect you will want to create a Raster with a BandedSampleModel, and then blit the contents of the other two images into its DataBuffer", "label": {"api": {"Raster": [[36, 41]], "BandedSampleModel": [[50, 66]], "DataBuffer": [[129, 138]]}}}, {"text": "Although it looks like you should be able to create a two-bank DataBuffer which uses the arrays of the source images' (one-banked) DataBuffers as banks, which would avoid copying", "label": {"api": {"DataBuffer": [[63, 72], [131, 140]]}}}, {"text": "Once you have a two-band image, simply apply a BandCombineOp which sums the bands", "label": {"api": {"BandCombineOp": [[47, 59]]}}}, {"text": "RandomAccessFile exposes a function", "label": {"api": {"RandomAccessFile": [[0, 15]]}}}, {"text": "You should be able to use Arrays.copyOfRange(...) to do this", "label": {"api": {"Arrays.copyOfRange(...)": [[26, 48]]}}}, {"text": "The method GraphicsConfiguration.createCompatibleImage could create such images", "label": {"api": {"GraphicsConfiguration.createCompatibleImage": [[11, 53]]}}}, {"text": "If you want to make sure that a particular thread has terminated, then Thread.isAlive() will check, and Thread.join() will wait until it happens", "label": {"api": {"Thread.isAlive()": [[71, 86]], "Thread.join()": [[104, 116]]}}}, {"text": "If you look up in the javadoc for the Thread class you will see many methods that might help you check what you want, for example", "label": {"api": {"Thread class": [[38, 49]]}}}, {"text": "This feels like it ought to exist, and indeed it does - java.io.StringReader", "label": {"api": {"java.io.StringReader": [[56, 75]]}}}, {"text": "First, you should use a PreparedStatement to insert values in your query", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "If you use PreparedStatement, you will be avoid the errors that you are seeing now", "label": {"api": {"PreparedStatement": [[11, 27]]}}}, {"text": "Your code using PreparedStatement would something like this", "label": {"api": {"PreparedStatement": [[16, 32]]}}}, {"text": "You can load it by the Properties API", "label": {"api": {"the Properties API": [[19, 36]]}}}, {"text": "Depends on exactly what values you want to add from your HashMap", "label": {"api": {"HashMap": [[57, 63]]}}}, {"text": "The example below gets the entries from the map, using entrySet() method in HashMap", "label": {"api": {"HashMap": [[76, 82]], "entrySet()": [[55, 64]]}}}, {"text": "If you just want to gather keys or values, use the keySet() or values() respectively, with the correct types", "label": {"api": {"keySet()": [[51, 58]], "values()": [[63, 70]]}}}, {"text": "Use the TimeUnit class, as shown here in combination with the javax.swing.Timer class set to execute at 1 second intervals", "label": {"api": {"TimeUnit": [[8, 15]], "javax.swing.Timer": [[62, 78]]}}}, {"text": "I think the easiest way to do this is with a Scanner", "label": {"api": {"Scanner": [[45, 51]]}}}, {"text": "I would recommend the concurrency trail of the Java tutorials for a broad overview, but in your specific case the synchronization mechanisms to get you started will probably be Thread.join and the synchronized keyword (one specific use of this keyword is described in the Java tutorials)", "label": {"api": {"Thread.join": [[177, 187]]}}}, {"text": "You can do this with the setClip() method in Graphics", "label": {"api": {"Graphics": [[45, 52]]}}}, {"text": "As I said, it needs more work, meaning the QuadCurve2D object might need to be defined differently, but you can check the doc for that", "label": {"api": {"check the doc": [[112, 124]]}}}, {"text": "To convert the String to a date you can use the SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[48, 63]]}}}, {"text": "KeyEvent has a constant value named VK_PASTE which can be used inside of KeyListener#keyPressed(KeyEvent e)", "label": {"api": {"KeyEvent": [[0, 7], [96, 103]], "VK_PASTE": [[36, 43]], "KeyListener#keyPressed(KeyEvent e)": [[73, 106]]}}}, {"text": "You could also consider using the PreparedStatement class in preference to Statement as that handles the parameter types reducing such issues", "label": {"api": {"PreparedStatement": [[34, 50]], "Statement": [[42, 50], [75, 83]]}}}, {"text": "You can look here for a PreparedStatement example", "label": {"api": {"PreparedStatement": [[24, 40]], "Statement": [[32, 40]]}}}, {"text": "It is possible to place the same bean instance into more than one scope programmatically using the FacesContext", "label": {"api": {"FacesContext": [[99, 110]]}}}, {"text": "Anyway, it's absolutely possible to sort your list using Collections.sort", "label": {"api": {"Collections.sort": [[57, 72]]}}}, {"text": "Since you're not really using any regex so instead of replaceAll you should be using String#replace method like this", "label": {"api": {"String#replace": [[85, 98]]}}}, {"text": "You should look into using the ProcessBuilder class instead of Runtime.exec()", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "Use Arrays.copyOf(...) to set length of the input buffer for encoding", "label": {"api": {"Arrays.copyOf(...)": [[4, 21]]}}}, {"text": "If you want to add elements to the head of a data structure then use a LinkedBlockingDeque instead", "label": {"api": {"LinkedBlockingDeque": [[71, 89]]}}}, {"text": "Not sure if I understood your question correctly, but LinkedBlockingDeque provides both FIFO and LIFO operations (similar to a Stack)", "label": {"api": {"LinkedBlockingDeque": [[54, 72]]}}}, {"text": "Once you have the byte array, a String can be created from this byte array", "label": {"api": {"String can be created": [[32, 52]]}}}, {"text": "Usually the easiest would be to use ExecutorService, submit your job to it and hold on on returned Future object which you could use to get result later or to cancel job execution", "label": {"api": {"ExecutorService": [[36, 50]], "Future": [[99, 104]]}}}, {"text": "You also could shutdown ExecutorService without waiting for job(s) to complete if you wish to do so", "label": {"api": {"ExecutorService": [[24, 38]]}}}, {"text": "} block you can use the Thread.interrupt() method (http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Thread.html#interrupt())", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Thread.html#interrupt()": [[51, 128]]}}}, {"text": "I'm investigating an interesting performance issue, where there are no calls to java.sql.Clob.free() on a frequently used resource", "label": {"api": {"java.sql.Clob.free()": [[80, 99]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/javax/xml/xpath/XPathConstants.html#NODESET) like this", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/xml/xpath/XPathConstants.html#NODESET": [[0, 83]]}}}, {"text": "I've been running tesseract-ocr in a Java application using ProcessBuilder, and, in some files, I got a error with the code 2", "label": {"api": {"ProcessBuilder": [[60, 73]]}}}, {"text": "I found SchemaFactory and Schema, but no way to get any information about the schema, just how to use it for validation", "label": {"api": {"SchemaFactory": [[8, 20]], "Schema": [[8, 13], [26, 31]]}}}, {"text": "When you create a javax.servlet.http.Cookie in Java, use the setSecure() method", "label": {"api": {"setSecure": [[61, 69]]}}}, {"text": "See the documentation for java.lang.Comparable", "label": {"api": {"the documentation for java.lang.Comparable": [[4, 45]]}}}, {"text": "You might examine the frame's getInsets()", "label": {"api": {"getInsets()": [[30, 40]]}}}, {"text": "For example in the JDK there is java.util.Map and java.util.Map.Entry", "label": {"api": {"java.util.Map": [[32, 44], [50, 62]], "java.util.Map.Entry": [[50, 68]]}}}, {"text": "java.util.Map.Entry is declared as a public static interface and doing it this way clearly signposts its relationship to Map", "label": {"api": {"java.util.Map": [[0, 12]], "java.util.Map.Entry": [[0, 18]]}}}, {"text": "It could have been defined as java.util.MapEntry but doing it as a static nested interface makes it clear that it has a strong relationship to Map", "label": {"api": {"java.util.Map": [[30, 42]]}}}, {"text": "If the rotated object is one that implements the Shape interface, it may have a useful implementation of the contains() method", "label": {"api": {"Shape": [[49, 53]]}}}, {"text": "If you want to print the content of the array, you should use Arrays.deepToString(cardInDeck) instead of Arrays.toString(cardInDeck)", "label": {"api": {"Arrays.deepToString(cardInDeck)": [[62, 92]]}}}, {"text": "If the array contains other arrays as elements, they are converted to strings by the Object.toString() method inherited from Object, which describes their identities rather than their contents", "label": {"api": {"Object": [[85, 90], [125, 130]]}}}, {"text": "Because it's the default version from Object, what you'll get is..", "label": {"api": {"Object": [[38, 43]]}}}, {"text": "The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object", "label": {"api": {"Object": [[30, 35]]}}}, {"text": "As suggested in another answer, Arrays.deepToString should be what you're after", "label": {"api": {"Arrays.deepToString": [[32, 50]]}}}, {"text": "See, for example, SwingWorker, which is a utility class designed to help do this kind of worker thread offloading correctly in a Swing GUI", "label": {"api": {"SwingWorker": [[18, 28]]}}}, {"text": "If you need to support Java 5, you can find earlier versions of SwingWorker for download", "label": {"api": {"SwingWorker": [[64, 74]]}}}, {"text": "You can use UIData#getRowIndex() for this", "label": {"api": {"UIData#getRowIndex()": [[12, 31]]}}}, {"text": "Returning a copy instead of original could help, as could using a collection which allows modification while iterating, like CopyOnWriteArrayList (but do note the additional cost of modifications, it may be a showstopper in some cases)", "label": {"api": {"CopyOnWriteArrayList": [[125, 144]]}}}, {"text": "Once you have the correct format, you could use JodaTime", "label": {"api": {"format": [[26, 31]]}}}, {"text": "I initially answered it using the serverSocket.setSoTimeout(millis) and handling the SocketTimeoutException", "label": {"api": {"setSoTimeout(millis)": [[47, 66]]}}}, {"text": "From the accept() javadocs", "label": {"api": {"accept() javadocs": [[9, 25]]}}}, {"text": "You can use setSoTimeout(millis) for that", "label": {"api": {"setSoTimeout(millis)": [[12, 31]]}}}, {"text": "The trick appears to be the use of @XmlJavaTypeAdapter on the target interfaces as described here", "label": {"api": {"@XmlJavaTypeAdapter": [[35, 53]]}}}, {"text": "stop.getName() is  returning null ,that is why you are getting NPE", "label": {"api": {"NPE": [[63, 65]]}}}, {"text": "There's also the Console class, but that doesn't actually buy you very much as far as I can see..", "label": {"api": {"Console": [[17, 23]]}}}, {"text": "Nothing too surprising -- it's just like Java's Proxy class but allows me to proxy actual classes instead of interfaces (see dexmaker's ProxyBuilder)", "label": {"api": {"Proxy": [[48, 52], [136, 140]]}}}, {"text": "You can look at the Java API entry on Class for more information", "label": {"api": {"Java API entry on Class": [[20, 42]]}}}, {"text": "The standard input is System.in and I seem to recall there being some methods on that to read lines etc, perhaps you can check the Java API for that", "label": {"api": {"Java API": [[131, 138]]}}}, {"text": "As per the javaDoc sleep method throws InterruptedException so you will ideally need to either surround it with a try/catch block", "label": {"api": {"sleep": [[19, 23]], "InterruptedException": [[39, 58]]}}}, {"text": "It depends on what you mean by equivalent, but you can use a Collator to see which characters would be sorted together", "label": {"api": {"Collator": [[61, 68]]}}}, {"text": "Casting this to a RuleBasedCollator allows you to do", "label": {"api": {"Collator": [[27, 34]], "RuleBasedCollator": [[18, 34]]}}}, {"text": "There is a big difference - matches checks the match of a String to a regular expression pattern, not the same string", "label": {"api": {"matches": [[28, 34]]}}}, {"text": "However, when you are trying to do something that does not fit the mold of one of those types, it is best to create your own dialog by making a sub-class of JDialog", "label": {"api": {"JDialog": [[157, 163]]}}}, {"text": "Except, instead of extending JFrame, you should extend JDialog", "label": {"api": {"JDialog": [[55, 61]]}}}, {"text": "Sleep() causes the currently executing thread to sleep (temporarily cease execution)", "label": {"api": {"Sleep()": [[0, 6]]}}}, {"text": "Yield() causes the currently executing thread object to temporarily pause and allow other threads to execute", "label": {"api": {"Yield()": [[0, 6]]}}}, {"text": "If system can't find this environment value, it will return null (reference), and thus, the toLowerCase invocation on a null reference will throw a NullPointerException", "label": {"api": {"reference": [[66, 74], [125, 133]]}}}, {"text": "See MouseEvent for the meaning of all the parameters - the underscores are things you have to fill and the two is the number of clicks", "label": {"api": {"MouseEvent": [[4, 13]]}}}, {"text": "I think what you actually want is a ColorSpace object, you can get to this using the BufferedImage and ColorModel APIs", "label": {"api": {"ColorSpace": [[36, 45]], "BufferedImage": [[85, 97]], "ColorModel": [[103, 112]]}}}, {"text": "Check out the JButton JavaDoc, it has links to dealing with Actions and specifically button Actions supported", "label": {"api": {"JButton JavaDoc": [[14, 28]]}}}, {"text": "the BitSet class", "label": {"api": {"BitSet": [[4, 9]]}}}, {"text": "In general, a good thing to bear in mind is the hashCode-equals contract documented in the java.lang.Object.hashCode java doc", "label": {"api": {"java.lang.Object.hashCode": [[91, 115]]}}}, {"text": "I was wondering whether is ByteArrayInputStream class from java.io package good to be used", "label": {"api": {"ByteArrayInputStream": [[27, 46]]}}}, {"text": "The function does the same as the one in ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[41, 60]]}}}, {"text": "I was curious if ByteArrayInputStream class would be used, does it increase the amount of bytes placed into the java's memory", "label": {"api": {"ByteArrayInputStream": [[17, 36]]}}}, {"text": "Use a HashSet, check if the provided answer is inside it by adding the element with add, and checking if the result is true or false", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "Use Object.wait instead and make sure you synchronize on the object containing the boolean", "label": {"api": {"Object.wait": [[4, 14]]}}}, {"text": "Use a LinkedHashMap instead of a regular HashMap", "label": {"api": {"LinkedHashMap": [[6, 18]]}}}, {"text": "In regards to the order of items removed, consider the Java API for pop()", "label": {"api": {"pop()": [[68, 72]]}}}, {"text": "You may want to look into another method, like removeLast()", "label": {"api": {"removeLast()": [[47, 58]]}}}, {"text": "The function's in the Math library and is called abs() (short for \"absolute value\")", "label": {"api": {"in the Math library": [[15, 33]]}}}, {"text": "I believe you are looking for Math.abs()", "label": {"api": {"Math.abs()": [[30, 39]]}}}, {"text": "Take a look at the class notes for the Scanner API, in particular the paragraph on using delimiters other than whitespace", "label": {"api": {"Scanner API": [[39, 49]]}}}, {"text": "and question/exclamation mark, you will have to define a Pattern and then apply it to your Scanner using useDelimiter (doc)", "label": {"api": {"Pattern": [[57, 63]]}}}, {"text": "Consider using a data structure that guarantees sorted insertion, like a TreeSet", "label": {"api": {"TreeSet": [[73, 79]]}}}, {"text": "Call getChildNodes() on the RootTagElement node", "label": {"api": {"getChildNodes()": [[5, 19]]}}}, {"text": "You might try getRootPane().setDefaultButton() on the frame", "label": {"api": {"getRootPane().setDefaultButton()": [[14, 45]]}}}, {"text": "replaceAll() could be a good option here, as per the Java API", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "The problem most people have with replaceAll() is that the first parameter is not a literal String, it is regex that gets interpreted and used as a pattern to be matched against", "label": {"api": {"replaceAll()": [[34, 45]]}}}, {"text": "This is just a quick example, but using replace() and replaceAll() effectively does what you want", "label": {"api": {"replaceAll()": [[54, 65]]}}}, {"text": "EntityManager.persist() is used to create a new entity bean", "label": {"api": {"EntityManager.persist": [[0, 20]]}}}, {"text": "You use EntityManager.merge() to update an entity bean that already exists", "label": {"api": {"EntityManager.merge": [[8, 26]]}}}, {"text": "Calling EntityManager.merge() updates the database to reflect changes made to a detached entity bean", "label": {"api": {"EntityManager.merge": [[8, 26]]}}}, {"text": "I assumed that you were using the DOM parser built in to java", "label": {"api": {"DOM parser": [[34, 43]]}}}, {"text": "Because you want to highlight every cell in the same row as a qualifying Expiry, you should override prepareRenderer(), as shown in this example and discussed in this Q&A", "label": {"api": {"prepareRenderer()": [[101, 117]]}}}, {"text": "Apache commons-logging, log4j or SLF4J) and a simple one is even in the core API of Java, see the API documentation of the java.util.logging package", "label": {"api": {"API documentation of the java.util.logging package": [[98, 147]]}}}, {"text": "It doesn't matter how many times and in how many classes a string literal is used, they will all be String.intern() so they will all be the same object", "label": {"api": {"String.intern()": [[100, 114]]}}}, {"text": "Assuming that aFile.txt is in the root of your application, you should be able to open the stream using the servlet context", "label": {"api": {"using the servlet context": [[98, 122]]}}}, {"text": "NoClassDefFoundError is not an Exception, it derives from Error", "label": {"api": {"NoClassDefFoundError": [[0, 19]]}}}, {"text": "Your problem seems to be that you aren't using the special synchronized version of the put method putIfAbsent()", "label": {"api": {"putIfAbsent()": [[98, 110]]}}}, {"text": "It'd be better to use the URI class, and its methods like getHost() and getPath(), rather than a regular expression", "label": {"api": {"URI": [[26, 28]]}}}, {"text": "The rules for constructing URIs are more complex than you probably realize, and your regex is likely to have lots of corner cases that won't be handled correctly", "label": {"api": {"URI": [[27, 29]]}}}, {"text": "Please used weak references (weak reference map) for caching", "label": {"api": {"weak reference map": [[29, 46]]}}}, {"text": "If you're content with having the lifespan of the registry be the same as the lifespan of the server process, the LocateRegistry class has createRegistry(...) methods which allow you to build an in-process registry easily", "label": {"api": {"LocateRegistry": [[114, 127]]}}}, {"text": "All the rmiregistry program does is put a tiny little wrapper around a call to LocateRegistry.createRegistry(1099);", "label": {"api": {"LocateRegistry": [[79, 92]]}}}, {"text": "IllegalStateException means the state of a component or configuration is incorrect", "label": {"api": {"IllegalStateException": [[0, 20]]}}}, {"text": "You could schedule this using the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[34, 57]]}}}, {"text": "One solution would be to parse the file line by line using the BufferedReader and FileReader classes", "label": {"api": {"BufferedReader": [[63, 76]], "FileReader": [[82, 91]]}}}, {"text": "It should be fine for Queue, assuming you mean java.util.Queue", "label": {"api": {"java.util.Queue": [[47, 61]]}}}, {"text": "As defined, read will return the number of bytes read, or -1 if the end of file is reached", "label": {"api": {"defined": [[3, 9]]}}}, {"text": "However, if you want something that grows/shrinks dynamically, then you probably want to create a List instead", "label": {"api": {"List": [[98, 101]]}}}, {"text": "You need to override getPreferredSize(...) method as you are doing it with paintComponent(...) method, let it be something like", "label": {"api": {"getPreferredSize(...)": [[21, 41]]}}}, {"text": "It also uses File.list which is a source of order non-determinism", "label": {"api": {"File.list": [[13, 21]]}}}, {"text": "Can you avoid using multiple Buttons, and just add a MouseListener on a custom-drawn panel", "label": {"api": {"MouseListener": [[53, 65]]}}}, {"text": "For more information on BigDecimal, check the API", "label": {"api": {"check the API": [[36, 48]]}}}, {"text": "If you use the version of getConstructor that takes arguments you can specify the constructor you want by its argument types", "label": {"api": {"the version of getConstructor that takes arguments": [[11, 60]]}}}, {"text": "Arrays.fill lets you avoid the loop", "label": {"api": {"Arrays.fill": [[0, 10]]}}}, {"text": "Collections.nCopies is your friend if you need a list instead of an array", "label": {"api": {"Collections.nCopies": [[0, 18]]}}}, {"text": "You can parse the structure of the underlying Document to get to the actual elements", "label": {"api": {"Document": [[46, 53]]}}}, {"text": "Each Element has a set of attributes you can access with getAttributes()", "label": {"api": {"Element": [[5, 11]], "getAttributes()": [[57, 71]]}}}, {"text": "Take a look at styledDocumentToAttributedString() method here", "label": {"api": {"Document": [[21, 28]]}}}, {"text": "Do TreeMap and TreeSet keep track of how many items they contain, or do they have to count them every time you call size()", "label": {"api": {"TreeMap": [[3, 9]], "TreeSet": [[15, 21]]}}}, {"text": "Instead of passing the script as an executable to ProcessBuilder, pass in the path to bash binary and pass your script as argument", "label": {"api": {"ProcessBuilder": [[50, 63]]}}}, {"text": "This is from the JDK 7 JavaDoc for HashSet", "label": {"api": {"HashSet": [[35, 41]]}}}, {"text": "Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the \"capacity\" of the backing HashMap instance (the number of buckets)", "label": {"api": {"HashSet": [[69, 75]]}}}, {"text": "I looked at the JDK 7 implementation of HashSet and LinkedHashSet", "label": {"api": {"HashSet": [[40, 46], [58, 64]]}}}, {"text": "You can use Collections.shuffle together with queue remove and lazy question generation, working example", "label": {"api": {"Collections.shuffle": [[12, 30]]}}}, {"text": "When opening the popup, you have to store your context value (1 or 2) in HttpSession with setAttribute method", "label": {"api": {"HttpSession": [[73, 83]]}}}, {"text": "When the back button is pressed, the servlet gets the page to refresh from that context attribute with HttpSession.getAttribute(\"popupContext\") for instance", "label": {"api": {"HttpSession": [[103, 113]]}}}, {"text": "I recommend you to remove this attribute from HttpSession (removeAttribute) when refreshing to avoid troubles later", "label": {"api": {"HttpSession": [[46, 56]]}}}, {"text": "If each page is generated thanks to a specific path, you can get it from HttpServletRequest.getQueryString() and use it as context", "label": {"api": {"HttpServletRequest.getQueryString()": [[73, 107]]}}}, {"text": "You could use a semaphore", "label": {"api": {"semaphore": [[16, 24]]}}}, {"text": "Seems like you had added the wrong Listener, what you should be adding is addWindowFocusListener(...), see this small sample program, is this what you want to happen", "label": {"api": {"addWindowFocusListener(...)": [[74, 100]]}}}, {"text": "You can create an RMI Registry in your server process using LocateRegistry.createRegistry()", "label": {"api": {"LocateRegistry.createRegistry()": [[60, 90]]}}}, {"text": "see the docs", "label": {"api": {"see the docs": [[0, 11]]}}}, {"text": "The Javadoc for Math explains why you get -Infinity as a result", "label": {"api": {"Javadoc for Math": [[4, 19]]}}}, {"text": "Therefore, using DateFormatSymbols directly is not necessary the best idea, as it may lead to Internationalization defects", "label": {"api": {"DateFormatSymbols": [[17, 33]]}}}, {"text": "If you want to use some Locale-dependent classes anyway, you need to create HttpSession and store Locale object to it", "label": {"api": {"HttpSession": [[76, 86]]}}}, {"text": "There are no rules, apart from the equivalence definition of the Java API", "label": {"api": {"equivalence definition": [[35, 56]]}}}, {"text": "Both Set and List interfaces extend the Collection interface, which itself extends the Iterable interface", "label": {"api": {"Set": [[5, 7]], "List": [[13, 16]], "Collection": [[40, 49]], "Iterable": [[87, 94]]}}}, {"text": "There's no way to 'clean up' that socket since it's already gone, but you can allow reuse of the same network address using SO_REUSEADDR on the original app's socket", "label": {"api": {"SO_REUSEADDR": [[124, 135]]}}}, {"text": "ZipEntry.getName() contains entry path (although it's not documented) so you can detect the ones that you need by using something like String.startsWith(\"your/path\")", "label": {"api": {"ZipEntry.getName()": [[0, 17]], "String.startsWith(\"your/path\")": [[135, 164]]}}}, {"text": "I noticed that JFrame has a frameInit() method", "label": {"api": {"frameInit()": [[28, 38]]}}}, {"text": "You could also you an executorService like ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[43, 60]]}}}, {"text": "The most commonly used API for server socket construction binds to all address by default", "label": {"api": {"The most commonly used API for server socket construction": [[0, 56]]}}}, {"text": "However, there is another that can bind to a specific address", "label": {"api": {"there is another": [[9, 24]]}}}, {"text": "I am not familiar with VFS, but you can wrap an OutputStream with a PrintWriter, and use it to append text", "label": {"api": {"PrintWriter": [[68, 78]]}}}, {"text": "Note that PrintWriter uses the default character encoding", "label": {"api": {"PrintWriter": [[10, 20]]}}}, {"text": "If I understand your question correctly, you should just use ProcessBuilder", "label": {"api": {"ProcessBuilder": [[61, 74]]}}}, {"text": "I would switch to using DatagramChannel, making the socket non-blocking, and use NIO receive to do the reads", "label": {"api": {"DatagramChannel": [[24, 38]]}}}, {"text": "(2) Keep in mind String.split may throw a PatternSyntaxException if the regex is invalid at runtime", "label": {"api": {"String.split": [[17, 28]]}}}, {"text": "it could be that simple invoke the app using something like ProcessBuilder", "label": {"api": {"ProcessBuilder": [[60, 73]]}}}, {"text": "You should extend HTMLEditorKit.ParserCallback with some class (I'll call it Parser), then override the methods you care about", "label": {"api": {"HTMLEditorKit.ParserCallback": [[18, 45]]}}}, {"text": "Have a look at how to configure the Java logging, and the documentation on how to specify formatting for SimpleFormatter", "label": {"api": {"how to specify formatting": [[75, 99]]}}}, {"text": "Take a look at the Java ThreadPoolExecutor  This should help with what you are trying to do", "label": {"api": {"ThreadPoolExecutor": [[24, 41]]}}}, {"text": "Use the tryAcquire() method, and be sure to put a corresponding release in a finally block, like this", "label": {"api": {"tryAcquire()": [[8, 19]]}}}, {"text": "Use the Calendar class", "label": {"api": {"Calendar": [[8, 15]]}}}, {"text": "You're supposed to build an appropriate Calendar -- which you can use by itself in many cases -- and just call getDate() on it if you really need a Date object", "label": {"api": {"Calendar": [[40, 47]]}}}, {"text": "Since Java 8 you can use the Calendar.Builder class", "label": {"api": {"Calendar.Builder": [[29, 44]]}}}, {"text": "I'd just do it as follows, using the Character.toUpperCase function on the first character of the string", "label": {"api": {"Character.toUpperCase": [[37, 57]]}}}, {"text": "To answer my own question, I found an example of a PausableThreadPoolExecutor in the javadocs of ThreadPoolExecutor itself", "label": {"api": {"itself": [[116, 121]]}}}, {"text": "You can use PreparedStatement.setBlob (or potentially PreparedStatement.setBinaryStream; I'll readily admit I'm not confident in the differences) to upload the data", "label": {"api": {"PreparedStatement.setBlob": [[12, 36]]}}}, {"text": "Trying using a FileWriter instead", "label": {"api": {"FileWriter": [[15, 24]]}}}, {"text": "Check out RandomAccessFile.skipBytes skipping until offset, that class might help you", "label": {"api": {"RandomAccessFile.skipBytes": [[10, 35]]}}}, {"text": "A NavigableMap is a Map", "label": {"api": {"Map": [[11, 13], [20, 22]]}}}, {"text": "you can use a CountDownLatch to syncronize thread execution", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "As stand in the doc, a CountDownLatch allows one or more threads to wait until a set of operations being performed in other threads completes", "label": {"api": {"CountDownLatch": [[23, 36]]}}}, {"text": "As suggested in this example and the SwingWorker API, either process() or done() should meet that obligation", "label": {"api": {"SwingWorker": [[37, 47]]}}}, {"text": "If you really want to have a void method, or a method in which the given parameters are modified by the method to return the results, you can use the Holder pattern", "label": {"api": {"Holder": [[150, 155]]}}}, {"text": "MD5, SHA-1, SHA-256 can be obtained using MessageDigest", "label": {"api": {"MessageDigest": [[42, 54]]}}}, {"text": "The LineNumberReader only keeps track of the number of lines read, it does not give random access to lines in the stream", "label": {"api": {"LineNumberReader": [[4, 19]]}}}, {"text": "You can achieve this by using SwingUtilities.invokeLater in your PongBall thread to include all the code which updates the GUI", "label": {"api": {"SwingUtilities.invokeLater": [[30, 55]]}}}, {"text": "If all you really want is a sorted list, use one of the SortedSet implementations", "label": {"api": {"SortedSet": [[56, 64]]}}}, {"text": "You can use the Formatter class, or with String.format()", "label": {"api": {"Formatter": [[16, 24]], "String.format()": [[41, 55]]}}}, {"text": "There is no sane way to test equality of Iterators", "label": {"api": {"Iterators": [[41, 49]]}}}, {"text": "If going insane in this is an option, you may want to delve into the implementation of the specific iterator type you are testing, and use reflection to access private stuff and compare that (I'm sure, with enough analysis of source code, that you would find what needs to hold for two ListIterators to be equal, for example)", "label": {"api": {"Iterators": [[290, 298]]}}}, {"text": "Call an API method that does some work at an unknown point in the future; the method call returns a Future that wraps the actual work", "label": {"api": {"Future": [[100, 105]]}}}, {"text": "The calling code (your code) that wants the result, can keep doing work until Future.isDone() returns true to indicate the work was completed OR the calling code can just block until the operation is done by calling", "label": {"api": {"Future": [[78, 83]], "Future.isDone()": [[78, 92]]}}}, {"text": "Future.get() -- this method returns the result of the work, in this case, a BufferedImage that represents the scaled result", "label": {"api": {"Future": [[0, 5]], "Future.get()": [[0, 11]]}}}, {"text": "If you had a significant amount of other work you could do while waiting for the image to be scaled, you can simply loop on result.isDone() and keep working until the scaling operation is done; but if you only have a discrete/specific amount of work to do, no need to loop on isDone, just do the work then call Future.get() to get the result (or block until it is ready)", "label": {"api": {"Future": [[311, 316]], "Future.get()": [[311, 322]]}}}, {"text": "When using the String(byte[]) constructor the actual length of the string is dependent on the contents of the array", "label": {"api": {"String(byte[])": [[15, 28]]}}}, {"text": "The constructor that gets two arguments is this", "label": {"api": {"constructor that gets two arguments": [[4, 38]]}}}, {"text": "The Rectangle constructor that you're using takes a width and a height", "label": {"api": {"Rectangle": [[4, 12]]}}}, {"text": "You might want to take a look at a BitSet The one used in Lucene is even faster as the standard Java implementation since it neglects some standard boundary checks", "label": {"api": {"BitSet": [[35, 40]]}}}, {"text": "I would suggest to have a look at MessageDigest", "label": {"api": {"MessageDigest": [[34, 46]]}}}, {"text": "I know it is homework so you might not be allowed to - but if you can use a HashSet<Character> - it will probably simplify life for you", "label": {"api": {"HashSet<Character>": [[76, 93]]}}}, {"text": "The methods should be setInt and getInt", "label": {"api": {"setInt": [[22, 27]], "getInt": [[33, 38]]}}}, {"text": "The methods are setInt and getInt", "label": {"api": {"setInt": [[16, 21]], "getInt": [[27, 32]]}}}, {"text": "For example, a button's delegate typically derives from javax.swing.plaf.ButtonUI", "label": {"api": {"javax.swing.plaf.ButtonUI": [[56, 80]]}}}, {"text": "The delete(r) method seems apropos, although you may also want to look at the inherited Set operations, too", "label": {"api": {"Set": [[88, 90]]}}}, {"text": "The javadoc for ArrayList in JDK 6 shows iterator() as something inherited from AbstractList", "label": {"api": {"javadoc for ArrayList in JDK 6": [[4, 33]]}}}, {"text": "You could also use nanoTime if you need it", "label": {"api": {"nanoTime": [[19, 26]]}}}, {"text": "As mentioned in the errata, setUseParentHandlers specifies whether to send data recursively up the logging tree", "label": {"api": {"setUseParentHandlers": [[28, 47]]}}}, {"text": "The documentation for Comparator has this cautionary note", "label": {"api": {"Comparator": [[22, 31]]}}}, {"text": "There is a special character / deliminter in Scanner to read 'all'", "label": {"api": {"Scanner": [[45, 51]]}}}, {"text": "Java has a pluggable classloader system, and thus the only way to know what will happen is to look at the documentation of the ClassLoader class, probably in particular the ClassLoader#findClass method, which doesn't define a behavior for this, and to look at the relevant sections of the JLS and JVM specs, neither of which seem to specify a constraint on class loaders in this regard", "label": {"api": {"ClassLoader class": [[127, 143]], "ClassLoader#findClass method": [[173, 200]]}}}, {"text": "You can just invalidate the session by calling HttpSession.invalidate() which will clear all the attributes as well as destroy the session itself", "label": {"api": {"HttpSession.invalidate()": [[47, 70]]}}}, {"text": "You just need to call session.invalidate() and servlet framework will take care of the rest", "label": {"api": {"session.invalidate()": [[22, 41]]}}}, {"text": "If you migrate to Java 8 you can use Optional and Lambdas", "label": {"api": {"Optional": [[37, 44]]}}}, {"text": "First, you need to rewrite your classes to return Optional of each type", "label": {"api": {"Optional": [[50, 57]]}}}, {"text": "Consider Using Java SE 8's Optional", "label": {"api": {"Optional": [[27, 34]]}}}, {"text": "I recommend you to use XPath with javax.xml.xpath package", "label": {"api": {"javax.xml.xpath": [[34, 48]]}}}, {"text": "String.split cuts the string at each match of the pattern", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "What you could do to limit an ArrayList would be to override the ensureCapacity(int minCapacity) method like in the following sample", "label": {"api": {"ensureCapacity(int minCapacity)": [[65, 95]]}}}, {"text": "You should override toString() in InformationType", "label": {"api": {"toString()": [[20, 29]]}}}, {"text": "Have a look at the API for JFrame for a list of methods, but what you probably want is call this.dispose();", "label": {"api": {"API": [[19, 21]]}}}, {"text": "Or use the hasNextInt method to prevent the exception from being thrown in the first place", "label": {"api": {"hasNextInt": [[11, 20]]}}}, {"text": "Assuming that you are using a ResultSet, this is straight from the JavaDocs", "label": {"api": {"ResultSet": [[30, 38]]}}}, {"text": "The next method moves the cursor to the next row, and because it returns false when there are no more rows in the ResultSet object, it can be used in a while loop to iterate through the result set", "label": {"api": {"ResultSet": [[114, 122]]}}}, {"text": "I would suggest using a Queue for your decks, as you need to put (offer) cards on one side of the deck (the bottom) and retrieve (poll) cards from the top (as far as I understand from the Wikipedia entry about this game)", "label": {"api": {"Queue": [[24, 28]]}}}, {"text": "A LinkedList is a good implementation of a Queue", "label": {"api": {"Queue": [[43, 47]]}}}, {"text": "They actually do both implement Appendable", "label": {"api": {"Appendable": [[32, 41]]}}}, {"text": "For example, CopyOnWriteArrayList in an array-based thread-safe list (it makes a new list for every write), while LinkedList is a non-thread-safe linked list", "label": {"api": {"CopyOnWriteArrayList": [[13, 32]], "LinkedList": [[114, 123]]}}}, {"text": "Just use String.getBytes(), or the overloaded version which allows you to specify the encoding", "label": {"api": {"String.getBytes()": [[9, 25]]}}}, {"text": "Is it possible to create a static member in a class that would react (if its wait method is called), correctly for threads which do not share the same instance of the class (would they be able to notify each other with notifyAll using the static member field)", "label": {"api": {"wait": [[77, 80]], "notifyAll": [[219, 227]]}}}, {"text": "While this example uses the built-in Java wait and notifyAll methods, you're far better off using the java.util.concurrent package rather than rolling your own multithreading solutions", "label": {"api": {"java.util.concurrent": [[102, 121]]}}}, {"text": "You would be much better off serialising your date using Date.getTime() which gives the number of milliseconds since the epoch (January 1, 1970, 00:00:00 GMT)", "label": {"api": {"Date.getTime()": [[57, 70]]}}}, {"text": "You can re-create the date by calling the Date(long date) constructor", "label": {"api": {"Date(long date)": [[42, 56]]}}}, {"text": "In this case, I would suggest you to use a LinkedHashMap, where you can use a Identifier as a key to uniquely identify a Method's object", "label": {"api": {"LinkedHashMap": [[43, 55]]}}}, {"text": "The closest match for your need is probably the DateFormat.getInstance() which gives you the default date format for the default locale on your system", "label": {"api": {"DateFormat.getInstance()": [[48, 71]]}}}, {"text": "Another way of doing the given task would be using java.nio.ByteBuffer classes", "label": {"api": {"java.nio.ByteBuffer": [[51, 69]]}}}, {"text": "@StanislavL has the right idea to use the contains() method of a class that implements Shape, but @Catalina observes that it's always false for Line2D", "label": {"api": {"Shape": [[87, 91]], "Line2D": [[144, 149]]}}}, {"text": "Instead, render the endpoints using a Shape with a non-empty boundary", "label": {"api": {"Shape": [[38, 42]]}}}, {"text": "The javadoc for Dictionary has your answer", "label": {"api": {"Dictionary": [[16, 25]]}}}, {"text": "The Dictionary class is the abstract parent of any class, such as Hashtable, which maps keys to values", "label": {"api": {"Dictionary": [[4, 13]]}}}, {"text": "You don't work directly with Dictionary, since it is an abstract class", "label": {"api": {"Dictionary": [[29, 38]]}}}, {"text": "New implementations should implement the Map interface, rather than extending this class", "label": {"api": {"Map": [[41, 43]]}}}, {"text": "But you shouldn't use either because they have been superceded by the Map interface and the implementing classes, of which HashMap is the most popular", "label": {"api": {"HashMap": [[123, 129]]}}}, {"text": "Tomcat's builtin Apache EL parser will indeed do that for all classes extending Number", "label": {"api": {"Number": [[80, 85]]}}}, {"text": "This can probably be achieved by adding the buttons to a single row GridLayout", "label": {"api": {"GridLayout": [[68, 77]]}}}, {"text": "java.net.URLEncoder does this", "label": {"api": {"java.net.URLEncoder": [[0, 18]]}}}, {"text": "The correct way to do it is to supply you own implementation of ListCellRenderer (doc here)", "label": {"api": {"(doc here": [[81, 89]]}}}, {"text": "See the Java documentation of Component.setIgnoreRepaint(boolean)", "label": {"api": {"Component.setIgnoreRepaint(boolean)": [[30, 64]]}}}, {"text": "Now that we're at it, I'd rather recommend you use JButton instead", "label": {"api": {"JButton": [[51, 57]]}}}, {"text": "What you are looking for is probably StringBuilder", "label": {"api": {"StringBuilder": [[37, 49]]}}}, {"text": "You can build it from string, change it as long as you need and then generate an immutable String as a result via toSting()", "label": {"api": {"toSting()": [[114, 122]]}}}, {"text": "This is one of the reasons why InputStream is not simply throwing EOFException when it reaches end of file", "label": {"api": {"EOFException": [[66, 77]]}}}, {"text": "You're using isDirectory() and isFile() on a file object that doesn't exist", "label": {"api": {"isDirectory()": [[13, 25]], "isFile()": [[31, 38]]}}}, {"text": "I'm guessing your model is HTMLDocument, which isn't really line oriented", "label": {"api": {"HTMLDocument": [[27, 38]]}}}, {"text": "To help avoid ArrayIndexOutOfBoundsExceptions, use the concise for-each syntax as much as possible on arrays and Iterable objects", "label": {"api": {"Iterable": [[113, 120]]}}}, {"text": "If you are using Java 7 you could use Files.readAllBytes", "label": {"api": {"Files.readAllBytes": [[38, 55]]}}}, {"text": "ComboBoxModel became generic in Java 7", "label": {"api": {"ComboBoxModel": [[0, 12]]}}}, {"text": "Use a SwingWorker to shutdown the thread pool and call awaitTermination()", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "This will prevent the UI from blocking and call done() from the Event Dispatch Thread on your SwingWorker implementation which you can use to trigger the whatever UI changes you need", "label": {"api": {"SwingWorker": [[94, 104]]}}}, {"text": "Using the getMenuShortcutKeyMask() method works with NimbusLookAndFeel to enable the ⌘ key, as shown in this example", "label": {"api": {"getMenuShortcutKeyMask()": [[10, 33]]}}}, {"text": "A great deal of the functionality of StreamTokenizer has been replaced by the Scanner class, I believe it's worth looking before proceeding", "label": {"api": {"Scanner": [[78, 84]]}}}, {"text": "You do so by using String.substring()", "label": {"api": {"String.substring()": [[19, 36]]}}}, {"text": "You might prefer to use different version of divide", "label": {"api": {"divide": [[45, 50]]}}}, {"text": "Whereas, with your version the final scale depends on the scale of the dividend and divisor", "label": {"api": {"divide": [[71, 76]]}}}, {"text": "ArrayList internals uses simple arrays to store its elements, if the number of elements exceeds the capacity of the underlying array, a resize effort is need", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "So, in the case you know how many items will your List contain, you can inform ArrayList to use an array of the needed size so the resize logic won't be needed or executed", "label": {"api": {"ArrayList": [[79, 87]]}}}, {"text": "The Desktop class has a method that allows you to open a file in a text editor", "label": {"api": {"Desktop": [[4, 10]]}}}, {"text": "Probably the best way would be to use the Java Regex APIs", "label": {"api": {"Java Regex": [[42, 51]]}}}, {"text": "The construct I have in mind is a Future", "label": {"api": {"Future": [[34, 39]]}}}, {"text": "for JavaCompiler suggests to me that adding them to the iterable collection of compilationUnits provided to getTask(..) should achieve the desired result", "label": {"api": {"JavaCompiler": [[4, 15]], "getTask(..)": [[108, 118]]}}}, {"text": "FacesContext.responseComplete() does not send any response to the client", "label": {"api": {"FacesContext.responseComplete()": [[0, 30]]}}}, {"text": "You'll need to create your own X509KeyManager to load the key/cert from the keystore more dynamically and make your application use an SSLContext initialised with it", "label": {"api": {"X509KeyManager": [[31, 44]]}}}, {"text": "If you are trying to create your own zip file, which you are sending in the response of your WS, and the client is expecting a zip file, then you want to look at java.util.zip", "label": {"api": {"java.util.zip": [[162, 174]]}}}, {"text": "I would look at GZipOutputStream", "label": {"api": {"GZipOutputStream": [[16, 31]]}}}, {"text": "I cannot find any official documentation saying that it is safe to call Component.repaint from another thread than the Event Dispatch Thread, the EDT", "label": {"api": {"Component.repaint": [[72, 88]]}}}, {"text": "The release method (confusingly named imo) can be used to increment permits since, from the docs", "label": {"api": {"release": [[4, 10]]}}}, {"text": "An ArrayList is a general-purpose a data structure", "label": {"api": {"ArrayList": [[3, 11]]}}}, {"text": "Put two grids into one panel with a new GridLayout(1,2) (then add that panel to whatever you are now adding the one grid)", "label": {"api": {"new GridLayout(1,2)": [[36, 54]]}}}, {"text": "No one mentioned Stream so far, so here it is", "label": {"api": {"Stream": [[17, 22]]}}}, {"text": "This follows the pattern of String's format method", "label": {"api": {"format": [[37, 42]]}}}, {"text": "The clearest way is to just call the Remove method of the list without any loops and pass in your object the parameter", "label": {"api": {"Remove": [[37, 42]]}}}, {"text": "— then you can use the JDK's System.identityHashCode(Object) utility method", "label": {"api": {"the JDK's System.identityHashCode(Object) utility method": [[19, 74]]}}}, {"text": "Why isn't the Contained an @Embeddable", "label": {"api": {"@Embeddable": [[27, 37]]}}}, {"text": "Seems like this would be easier to do using either byte[] (byte arrays) or BitSets", "label": {"api": {"BitSet": [[75, 80]]}}}, {"text": "You might be able to use ByteBuffer as described e.g", "label": {"api": {"ByteBuffer": [[25, 34]]}}}, {"text": "The constructor you're using for FileWriter takes two arguments", "label": {"api": {"The constructor you're using for FileWriter takes two arguments": [[0, 62]]}}}, {"text": "See the JavaDocs for more info", "label": {"api": {"the JavaDocs": [[4, 15]]}}}, {"text": "As you said, documentation says that URL.getContent() is a shortcut for openConnection().getContent() so we need to look at the documentation for URLConnection.getContent()", "label": {"api": {"the documentation for URLConnection.getContent()": [[124, 171]]}}}, {"text": "This type determines the ContentHandler that will be used", "label": {"api": {"ContentHandler": [[25, 38]]}}}, {"text": "So a ContentHandler converts data based on its  MIME type to the appropriate class of Java Object", "label": {"api": {"ContentHandler": [[5, 18]]}}}, {"text": "So you can say String foo = (String) url.getContent(); if you know your ContentHandler will return a String", "label": {"api": {"ContentHandler": [[72, 85]]}}}, {"text": "You could create your own ContentHandler that does return a String but it will probably be easier just to read the Stream as you suggest", "label": {"api": {"ContentHandler": [[26, 39]]}}}, {"text": "You need to use a PreparedStatement to make it work", "label": {"api": {"PreparedStatement": [[18, 34]]}}}, {"text": "Whilst I like the String.format option, I think breaking it up looks uglier", "label": {"api": {"String.format": [[18, 30]]}}}, {"text": "FontShower is an applet that displays a list of available fonts, including the installed logical fonts, and a selection of available glyphs, sizes and colors", "label": {"api": {"logical": [[89, 95]]}}}, {"text": "Also consider nextGaussian() for simulated latency, as illustrated here", "label": {"api": {"nextGaussian()": [[14, 27]]}}}, {"text": "It would be much wise, that instead of using Canvas, if you override the paintComponent(...) method of a JComponent and paint on it, instead of overriding paint(...) method", "label": {"api": {"paintComponent(...)": [[73, 91]]}}}, {"text": "just simply need to addHierarchyBoundsListener(...), to your MyDraw object, i.e", "label": {"api": {"addHierarchyBoundsListener(...)": [[20, 50]]}}}, {"text": "You can add your numbers to a Set", "label": {"api": {"Set": [[30, 32]]}}}, {"text": "Here's the relevant documentation from the standard library", "label": {"api": {"relevant documentation": [[11, 32]]}}}, {"text": "When looking at web applications, some synchronization on \"JVM global\" scope is maybe becoming a performance bottleneck and synchronization only within the scope of the user's HttpSession would make more sense", "label": {"api": {"HttpSession": [[176, 186]]}}}, {"text": "You can take a look at Phaser", "label": {"api": {"Phaser": [[23, 28]]}}}, {"text": "The precise definition is documented in the Java Doc for ensureCapacity", "label": {"api": {"the Java Doc for ensureCapacity": [[40, 70]]}}}, {"text": "If this is the case, you could simply instantiate a java.util.JarFile from the known jar file path and use getEntries()", "label": {"api": {"getEntries()": [[107, 118]]}}}, {"text": "The correct way to do this in Java is to use the BreakIterator to detect \"Words\" and process them according to your logic", "label": {"api": {"BreakIterator": [[49, 61]]}}}, {"text": "It would be a good idea to read the javadoc for OptionalDataException", "label": {"api": {"OptionalDataException": [[48, 68]]}}}, {"text": "But, is there an official (or common) file extension or suffix for deflated files", "label": {"api": {"deflated": [[67, 74]]}}}, {"text": "Have you tried using the java.nio.file.Files#isWritable method", "label": {"api": {"java.nio.file.Files#isWritable": [[25, 54]]}}}, {"text": "I checked the SimpleDateFormat and there is a placeholder for the timezone, however its a different format", "label": {"api": {"SimpleDateFormat": [[14, 29]]}}}, {"text": "You could use the elementAt method, documented here, to get the value you wanted", "label": {"api": {"documented here": [[36, 50]]}}}, {"text": "See ArrayList and Collection", "label": {"api": {"ArrayList": [[4, 12]], "Collection": [[18, 27]]}}}, {"text": "You can use JOptionPane's setLocation(...) method", "label": {"api": {"JOptionPane's setLocation(...)": [[12, 41]]}}}, {"text": "OR Instead of using JOptionPane you can extends a JDialog, and then specify it's location on the screen", "label": {"api": {"JDialog": [[50, 56]]}}}, {"text": "A JOptionPane can be easily turned into a JDialog (check out the JOptionPane API and it will show you how with example)", "label": {"api": {"JOptionPane API": [[65, 79]]}}}, {"text": "Because the syntax for that parameter to split is a regular expression, where in the '|' has a special meaning of OR, and a '\\|' means a literal '|' so the string \"\\\\|\" means the regular expression '\\|' which means match exactly the character '|'", "label": {"api": {"split": [[41, 45]]}}}, {"text": "Have a look at the API doc of ArrayList.add(int index, E element)", "label": {"api": {"ArrayList.add(int index, E element)": [[30, 64]]}}}, {"text": "If you want to swap between panels in the frame, then you probably want a JCardLayout", "label": {"api": {"JCardLayout": [[74, 84]]}}}, {"text": "You would set the layout manager to JCardLayout of the frame, and then add the two panels to the frame", "label": {"api": {"JCardLayout": [[36, 46]]}}}, {"text": "I believe I've used the URL class to achieve this in the past", "label": {"api": {"URL": [[24, 26]]}}}, {"text": "You can use its openStream() method to get an InputStream you can read", "label": {"api": {"openStream()": [[16, 27]]}}}, {"text": "In Java, the usual way you'd do that would be with null and the Integer, Long, etc", "label": {"api": {"Integer": [[64, 70]], "Long": [[73, 76]]}}}, {"text": "If you have a C# background, Integer in Java (with autoboxing) is kind of like int", "label": {"api": {"Integer": [[29, 35]]}}}, {"text": "For instance, List#indexOf has this signature", "label": {"api": {"List#indexOf": [[14, 25]]}}}, {"text": "You asked more than two years ago, but two months ago, Java SE 8 has introduced java.util.Optional<T>", "label": {"api": {"java.util.Optional<T>": [[80, 100]]}}}, {"text": "Use Java Instrumentation APIs", "label": {"api": {"Java Instrumentation APIs": [[4, 28]]}}}, {"text": "The Atomic* classes offer a lock-free atomic conditional update operation, compareAndSet - you should use that one for thread safety", "label": {"api": {"The Atomic* classes": [[0, 18]]}}}, {"text": "You can set them using JScrolPane(Component,int,int) constructor, or by calling setVerticalScrollBarPolicy() and setHorizontalScrollBarPolicy()", "label": {"api": {"JScrolPane(Component,int,int)": [[23, 51]]}}}, {"text": "http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestURL() and from there parse out the parameters", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRequestURL": [[0, 91]]}}}, {"text": "An OutOfMemoryError is thrown by the VM when it runs out of memory for allocating new objects", "label": {"api": {"OutOfMemoryError": [[3, 18]]}}}, {"text": "You can use SimpleDateFormat to parse a String in the given pattern to a java.util.Date object", "label": {"api": {"SimpleDateFormat": [[12, 27]], "String": [[40, 45]], "java.util.Date": [[73, 86]]}}}, {"text": "Once having the java.util.Date object, you can store it in a TIME column by converting it to java.sql.Time and using PreparedStatement#setTime()", "label": {"api": {"java.util.Date": [[16, 29]], "java.sql.Time": [[93, 105]], "PreparedStatement#setTime()": [[117, 143]]}}}, {"text": "You can use Short.parseShort(str, 16) to parse HEX", "label": {"api": {"Short.parseShort(str, 16)": [[12, 36]]}}}, {"text": "I think using java.util.concurrent.ConcurrentSkipListMap and java.util.concurrent.ConcurrentSkipListSet could help you resolve the concurrency concerns", "label": {"api": {"java.util.concurrent.ConcurrentSkipListMap": [[14, 55]], "java.util.concurrent.ConcurrentSkipListSet": [[61, 102]]}}}, {"text": "Use LinkedHashMap if you need such guarantee", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "Use ByteBuffer.wrap to get a buffer that wraps your byte[] and then useByteBuffer.asLongBuffer() to get a view that allows you to extract and manipulate longs as suggested by @NiklasB", "label": {"api": {"ByteBuffer.wrap": [[4, 18]], "ByteBuffer.asLongBuffer()": [[71, 95]]}}}, {"text": "Sounds like you need a MouseMotionListener", "label": {"api": {"MouseMotionListener": [[23, 41]]}}}, {"text": "The MouseEvent contains the current mouse position", "label": {"api": {"MouseEvent": [[4, 13]]}}}, {"text": "Per stax specification, the getElementText() returns the text data and places the current event as the END_ELEMENT", "label": {"api": {"stax specification": [[4, 21]]}}}, {"text": "Also I recommend you looking at Service Loader, which is a really cool tool to dynamically load services from the classpath", "label": {"api": {"Service Loader": [[32, 45]]}}}, {"text": "For creating instance of the class you can follow answer from @Peter and for holding the reference to the that object I suggest EnumMap", "label": {"api": {"EnumMap": [[128, 134]]}}}, {"text": "Use the URI class", "label": {"api": {"URI class": [[8, 16]]}}}, {"text": "Instead of Base64, you could just use URLEncoder and URLDecoder, which has nothing to do with MongoDB but converts Strings into a valid URL-Strings", "label": {"api": {"URLEncoder": [[38, 47]], "URLDecoder": [[53, 62]]}}}, {"text": "But if still want to do a click, each button has a doClick method which does the same thing as if the user had pressed and released the button (quote from the javadoc)", "label": {"api": {"doClick": [[51, 57]]}}}, {"text": "The Java 1.4 doc for javax.xml.parsers.DocumentBuilderFactory states in no uncertain terms", "label": {"api": {"Java 1.4 doc": [[4, 15]]}}}, {"text": "The Java 5 and Java 6 docs, however, say nothing of the kind", "label": {"api": {"Java 5": [[4, 9]], "Java 6": [[15, 20]]}}}, {"text": "According to the documentation of the singleton DocumentBuilderFactory the newInstance method is not sychronized and then, the DocumentBuilderFactory is still not a thread safe in Java 8..", "label": {"api": {"DocumentBuilderFactory": [[48, 69], [127, 148]]}}}, {"text": "Neither in Java 11", "label": {"api": {"Java 11": [[11, 17]]}}}, {"text": "You can use generics to achieve this, Java's enums all extend implicitly java.lang.Enum", "label": {"api": {"java.lang.Enum": [[73, 86]]}}}, {"text": "Maybe all you really need is an ExecutorService that you can submit your runnables and callables to", "label": {"api": {"ExecutorService": [[32, 46]]}}}, {"text": "Being new, you might also want to take a look at Callable", "label": {"api": {"Callable": [[49, 56]]}}}, {"text": "It's almost like a thread, except a Callable returns a value", "label": {"api": {"Callable": [[36, 43]]}}}, {"text": "When you submit a callable, you get back a Future object, which is like a promise to get the value from the callable", "label": {"api": {"Future": [[43, 48]]}}}, {"text": "You can make use of the Matcher class", "label": {"api": {"Matcher": [[24, 30]]}}}, {"text": "It may very well be a custom border, implemented entirely from scratch or a CompoundBorder which is a combination of several standard borders", "label": {"api": {"CompoundBorder": [[76, 89]]}}}, {"text": "ZipFile already decompresses an entry's data, there is no need to use a ZipInputStream as well", "label": {"api": {"ZipFile": [[0, 6]]}}}, {"text": "If they're expensive, consider creating one-per-thread with ThreadLocal", "label": {"api": {"ThreadLocal": [[60, 70]]}}}, {"text": "Subclass or create an anonymous version of DefaultTableModel and override the isCellEditable method", "label": {"api": {"isCellEditable": [[78, 91]]}}}, {"text": "If you're going to be calling interrupt() on threads doing I/O you should look at using classes that implement the InterruptableChannel interface", "label": {"api": {"the InterruptableChannel interface": [[111, 144]]}}}, {"text": "Looking here, a lot of things can go wrong when interrupting a thread", "label": {"api": {"Looking here": [[0, 11]]}}}, {"text": "Or you can view a complete list in the KeyEvent field summary", "label": {"api": {"KeyEvent field summary": [[39, 60]]}}}, {"text": "setModel and getModel are defined in AbstractButton", "label": {"api": {"setModel": [[0, 7]], "getModel": [[13, 20]]}}}, {"text": "If you need to iterate through a list, removing items from the list as you go, try using an Iterator and a while loop", "label": {"api": {"Iterator": [[92, 99]]}}}, {"text": "The Iterator interface defines a remove() method that deletes the last item retrieved with next() from the Collection being iterated over", "label": {"api": {"Iterator": [[4, 11]]}}}, {"text": "So I looked at JavaCompiler, and there's an example used to collect diagnostics", "label": {"api": {"JavaCompiler": [[15, 26]]}}}, {"text": "This is all fine and dandy, except that the Diagnostic objects I get back are not very helpful in determining exactly what compile error occurred during compilation", "label": {"api": {"Diagnostic": [[44, 53]]}}}, {"text": "As for implementing containsTypes(), simply iterate over each element and call getClass() on it, adding the result to a Set<Class<", "label": {"api": {"getClass()": [[79, 88]]}}}, {"text": "Using subList() may be convenient", "label": {"api": {"subList()": [[6, 14]]}}}, {"text": "One way could be to implement your own MBeanServerForwarder and do the logging there", "label": {"api": {"MBeanServerForwarder": [[39, 58]]}}}, {"text": "In Swing I would try SwingUtilities.invokeLater(Runnable)", "label": {"api": {"SwingUtilities": [[21, 34]]}}}, {"text": "Have a look at HttpServletRequest's getRequestURI() and getRequestURL() methods", "label": {"api": {"getRequestURI()": [[36, 50]], "getRequestURL()": [[56, 70]]}}}, {"text": "If you need to remove context and servlet mappings, look at getContextPath() and getServletPath()", "label": {"api": {"getContextPath()": [[60, 75]], "getServletPath()": [[81, 96]]}}}, {"text": "When you start a subprocess with Java you get back a Process object corresponding to the running process", "label": {"api": {"start a subprocess with Java": [[9, 36]], "a Process object": [[51, 66]]}}}, {"text": "You can use destroy() method on the Process object to kill the running command", "label": {"api": {"destroy() method on the Process object": [[12, 49]]}}}, {"text": "You can add values to a ResultSet using insertRow() but this will also add the data to the underlying database", "label": {"api": {"using insertRow()": [[34, 50]]}}}, {"text": "You could just use java.math.BigInteger instead", "label": {"api": {"java.math.BigInteger": [[19, 38]]}}}, {"text": "Consider using the java.math.BigInteger class", "label": {"api": {"java.math.BigInteger": [[19, 38]]}}}, {"text": "You can concatenate all the lines together to create a String then convert it to a byte array using String#getBytes and pass it into ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[133, 152]]}}}, {"text": "Alternatively, depending on what you're trying to do, a StringReader might be better", "label": {"api": {"StringReader": [[56, 67]]}}}, {"text": "You could, however, implement your own InputStream that read from a List of Strings", "label": {"api": {"InputStream": [[39, 49]]}}}, {"text": "This basically an adapter for ByteArrayInputStream", "label": {"api": {"InputStream": [[39, 49]]}}}, {"text": "You could use ProcessBuilder and redirect ( redirectErrorStream(true) ) the stderr to stdout then you only have to read the output of one stream", "label": {"api": {"ProcessBuilder": [[14, 27]]}}}, {"text": "If you want it to disapear, use frame.dispose()", "label": {"api": {"frame.dispose()": [[32, 46]]}}}, {"text": "the former is just a character sequence, while the later is a regular expression", "label": {"api": {"regular expression": [[62, 79]]}}}, {"text": "I would read the docs on the Pattern class if I were you", "label": {"api": {"Pattern": [[29, 35]]}}}, {"text": "You could improve the performance if the above code by using a StringBuilder to build the destination String so you only need to do the copy once", "label": {"api": {"using a StringBuilder": [[55, 75]]}}}, {"text": "If you really are dealing with a long binary number you should consider using a BitSet", "label": {"api": {"using a BitSet": [[72, 85]]}}}, {"text": "Remember to call setAccessible(true) on the Method in order to avoid an IllegalAccessException", "label": {"api": {"setAccessible(true)": [[17, 35]]}}}, {"text": "The Statement#execute method returns a boolean", "label": {"api": {"Statement#execute": [[4, 20]]}}}, {"text": "You are looking for the Statement#executeQuery method, which returns a ResultSet", "label": {"api": {"Statement#execute": [[24, 40]], "Statement#executeQuery": [[24, 45]]}}}, {"text": "Its quite easy to do using java ExecutorService", "label": {"api": {"ExecutorService": [[32, 46]]}}}, {"text": "The AbstractTableModel contains three methods that need to be overwritten", "label": {"api": {"AbstractTableModel": [[4, 21]]}}}, {"text": "Look at the Javadoc for AbstractTableModel to get an overview of other methods that can be overwritten", "label": {"api": {"AbstractTableModel": [[24, 41]]}}}, {"text": "Doing this for the mouse is simple, since using the PointerInfo class in a manner described in this related question gives you the screen coordinates for the current mouse location and the click information if desired", "label": {"api": {"PointerInfo": [[52, 62]]}}}, {"text": "I am trying to generate a key and it is important that each time the class is run, the key be exactly the same", "label": {"api": {"generate a key": [[15, 28]]}}}, {"text": "Java ships with several different algorithms, which can be used by a KeyFactory to produce keys", "label": {"api": {"KeyFactory": [[69, 78]]}}}, {"text": "You are looking for String.indexOf", "label": {"api": {"String.indexOf": [[20, 33]]}}}, {"text": "Just use the BigInteger.isProbablePrime() library function built into Java..", "label": {"api": {"BigInteger.isProbablePrime()": [[13, 40]]}}}, {"text": "Using Java, Zoom uses createScreenCapture() to render an enlarged 16 x 16 pixel BufferedImage taken as the mouse is dragged across the screen", "label": {"api": {"createScreenCapture()": [[22, 42]]}}}, {"text": "Once you have the BufferedImage, you can periodically recapture the screen at the same point and use the getRGB() method to compare", "label": {"api": {"getRGB()": [[105, 112]]}}}, {"text": "You can use the Random class", "label": {"api": {"Random": [[16, 21]]}}}, {"text": "But looking at the API docs for Thread http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html there is no method to return the Runnable", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html": [[39, 100]]}}}, {"text": "Check out this sample and the Executors API (specifically the fixedThreadPool)", "label": {"api": {"Executors API": [[30, 42]]}}}, {"text": "The accept method blocks until a connection is made", "label": {"api": {"accept": [[4, 9]]}}}, {"text": "So, you are sitting blocked one one .accept(), even though the other server may have activity", "label": {"api": {"accept": [[37, 42]]}}}, {"text": "Use replace() to replace a literal string with another", "label": {"api": {"replace()": [[4, 12]]}}}, {"text": "Note that replace() still replaces all occurrences, as does replaceAll() - the difference is that replaceAll() uses regex to search", "label": {"api": {"replace()": [[10, 18]], "replaceAll()": [[60, 71], [98, 109]]}}}, {"text": "You might want to have a look the documentation for Random.nextInt(int n), which discusses the algorithm used, and adapt it to work with longs", "label": {"api": {"documentation for Random.nextInt(int n)": [[34, 72]]}}}, {"text": "the documentation for TargetDataLine.read says", "label": {"api": {"TargetDataLine.read": [[22, 40]]}}}, {"text": "So, maybe you can try to gain access to the TargetDataLine(s) being used (maybe using Mixer.getTargetLines) and try to act on them too (stopping, flushing etc)", "label": {"api": {"Mixer.getTargetLines": [[86, 105]]}}}, {"text": "If you know the length of your input (or an upper bound to it) you can read the whole thing to a character array, using read(char[],int,int), then use that to build a String", "label": {"api": {"read(char[],int,int)": [[120, 139]]}}}, {"text": "The value of this constant is actually \"Name\" so you could use that as well, but as you see it's easy to get it wrong", "label": {"api": {"value of this constant": [[4, 25]]}}}, {"text": "I think you'd be best off using String.replace rather than String.replaceAll so you don't have to deal with escaping regex patterns..", "label": {"api": {"String.replace": [[32, 45], [59, 72]]}}}, {"text": "Yes, this one, for example", "label": {"api": {"this one": [[5, 12]]}}}, {"text": "Try using Console instead", "label": {"api": {"Console": [[10, 16]]}}}, {"text": "I think that a Regular Expression using the Pattern class is your best bet if you are simply trying to match HELLO (case-insensitive), any string, Name (taken from a list)", "label": {"api": {"Pattern": [[44, 50]]}}}, {"text": "Here you need to use String.compareTo instead, like this", "label": {"api": {"String.compareTo": [[21, 36]]}}}, {"text": "String implements Comparator, which allows you to compare the value of two objects (the form for the interface is actually Comparator<E>, so you're using Comparator<String>)", "label": {"api": {"Comparator": [[18, 27], [123, 132], [154, 163]]}}}, {"text": "The manual does not answer this question", "label": {"api": {"does not answer this question": [[11, 39]]}}}, {"text": "Java has a convenient BitSet class which can store a virtually unlimited number of bits", "label": {"api": {"BitSet": [[22, 27]]}}}, {"text": "If the number of bits is limited to 32, using BitSet is going to be wasteful", "label": {"api": {"BitSet": [[46, 51]]}}}, {"text": "Reader and its subclasses are based around char and char[], only convenience methods use String", "label": {"api": {"Reader": [[0, 5]]}}}, {"text": "As of Java SE 8, new methods in the Integer class allow you to fully use the int data type to perform unsigned arithmetic", "label": {"api": {"Integer": [[36, 42]]}}}, {"text": "Use the Integer class to use int data type as an unsigned integer", "label": {"api": {"Integer": [[8, 14]]}}}, {"text": "Static methods like compareUnsigned, divideUnsigned etc have been added to the Integer class to support the arithmetic operations for unsigned integers", "label": {"api": {"Integer": [[79, 85]], "compareUnsigned": [[20, 34]], "divideUnsigned": [[37, 50]]}}}, {"text": "Note that int variables are still signed when declared but unsigned arithmetic is now possible by using those methods in the Integer class", "label": {"api": {"Integer": [[125, 131]]}}}, {"text": "Use a JList", "label": {"api": {"JList": [[6, 10]]}}}, {"text": "Look into the dragging behavior for the reordering ability", "label": {"api": {"dragging behavior": [[14, 30]]}}}, {"text": "In Java 8 and later, we can use the java.time classes including LocalDate and TemporalAdjusters, and the DayOfWeek enum", "label": {"api": {"java.time": [[36, 44]], "LocalDate": [[64, 72]], "TemporalAdjusters": [[78, 94]], "DayOfWeek": [[105, 113]]}}}, {"text": "The java-doc of the String(byte[])-Constructor says", "label": {"api": {"String(byte[])-Constructor": [[20, 45]]}}}, {"text": "will raise an ArrayStoreException at run-time, because foo refers to an array instance that knows it's a String[] (even though it's referred to via the variable foo, which has compile-time type Object[])", "label": {"api": {"ArrayStoreException": [[14, 32]]}}}, {"text": "According to the docs for File.createTempFile(), if the prefix (first argument) contains fewer than three characters, an IllegalArgumentException will be thrown", "label": {"api": {"the docs for File.createTempFile()": [[13, 46]]}}}, {"text": "currentTimeMillis doesn't return timezone-dependent timestamps", "label": {"api": {"currentTimeMillis": [[0, 16]]}}}, {"text": "To display the \"correct\" time, you can use a SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[45, 60]]}}}, {"text": "If I understand you correctly, you could implement your own RepaintManager", "label": {"api": {"RepaintManager": [[60, 73]]}}}, {"text": "The List returned by Arrays#asList has a fixed size", "label": {"api": {"Arrays#asList": [[21, 33]]}}}, {"text": "By default, calling createStament() in a connection results in every ResultSet having type 'TYPE_FORWARD_ONLY' - This results in the exception you see using first()", "label": {"api": {"createStament()": [[20, 34]], "first()": [[157, 163]]}}}, {"text": "Instead, use another versions of createStatement, like this one", "label": {"api": {"this one": [[55, 62]]}}}, {"text": "You can remove an item from a Collection - including a Set - whilst iterating over it as long as you iterate over it using an Iterator and call Itertator.remove() to do the remove", "label": {"api": {"Itertator.remove()": [[144, 161]]}}}, {"text": "The only one I can remember off the top of my head is javax.security.auth.callback", "label": {"api": {"javax.security.auth.callback": [[54, 81]]}}}, {"text": "Have a look at ArrayList and LinkedList and chose which is better for you", "label": {"api": {"ArrayList": [[15, 23]], "LinkedList": [[29, 38]]}}}, {"text": "For example, if you use to use an ArrayList for both, your c'tor should be something like", "label": {"api": {"ArrayList": [[34, 42]]}}}, {"text": "It is better to use JDialog than JFrame when you want modal", "label": {"api": {"JDialog": [[20, 26]]}}}, {"text": "Since making it unmodifiable prevents pushing and popping, how about just using Collections.unmodifiableCollection() which returns an unmodifiable Collection and works well with a Stack as input", "label": {"api": {"Collections.unmodifiableCollection()": [[80, 115]]}}}, {"text": "How about creating a queue for them so it is just in process communication", "label": {"api": {"queue": [[21, 25]]}}}, {"text": "You can use a ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[14, 35]]}}}, {"text": "heres a tutorial on how to use threads", "label": {"api": {"heres": [[0, 4]]}}}, {"text": "You could represent your method with a Runnable, for example", "label": {"api": {"Runnable": [[39, 46]]}}}, {"text": "Or if you need to represent a method with a return type, look at Callable - or even better, Guava's Function", "label": {"api": {"Callable": [[65, 72]]}}}, {"text": "You can try TexturePaint", "label": {"api": {"TexturePaint": [[12, 23]]}}}, {"text": "You can find a more complete example of TexturePaint in this sample chapter from Java 2D Graphics book", "label": {"api": {"TexturePaint": [[40, 51]]}}}, {"text": "If you want to change the specific location's string, then you would want to use String.replaceAll() and capture the results in your ArrayList", "label": {"api": {"String.replaceAll()": [[81, 99]]}}}, {"text": "You need to call fireContentsChanged() on the ListModel", "label": {"api": {"fireContentsChanged()": [[17, 37]]}}}, {"text": "Instead of setModel(), update your existing model using one of the DefaultListModel methods such as setElementAt(), which will fireContentsChanged() for you", "label": {"api": {"setElementAt()": [[100, 113]]}}}, {"text": "A solution to this problem would be (as you already mentioned) moving your for loop to another thread and call doClick using SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[125, 150]]}}}, {"text": "Call it from a SwingWorker", "label": {"api": {"SwingWorker": [[15, 25]]}}}, {"text": "Try to use setSoTimeout to put a timeout on your read(), then you just need to catch the SocketTimeoutException if the timer has expired", "label": {"api": {"setSoTimeout": [[11, 22]]}}}, {"text": "You can also have a glance at the new package nio.2 in Java 7, with tutorial here", "label": {"api": {"new package nio.2": [[34, 50]]}}}, {"text": "Of course it exists a true implementation of this AtomicInteger and it's part of the package java.util.concurrent.atomic, it provides some simple basic routines for lock-free concurrent programming", "label": {"api": {"java.util.concurrent.atomic": [[93, 119]]}}}, {"text": "An example for this would be the IdentityHashMap", "label": {"api": {"IdentityHashMap": [[33, 47]]}}}, {"text": "generate random number through Random", "label": {"api": {"Random": [[31, 36]]}}}, {"text": "You use Math.cos, Math.sin like this", "label": {"api": {"Math.cos": [[8, 15]], "Math.sin": [[18, 25]]}}}, {"text": "Note that Math.cos and Math.sin assumes the argument is given in radians", "label": {"api": {"Math.cos": [[10, 17]], "Math.sin": [[23, 30]]}}}, {"text": "If you have the angle in degrees, you would use Math.cos(Math.toRadians(angle)) for instance", "label": {"api": {"Math.cos": [[48, 55]], "Math.toRadians(angle)": [[57, 77]]}}}, {"text": "You can use String.replaceAll(regex, replacement) with the regex [^A-Za-z]+ like this", "label": {"api": {"String.replaceAll(regex, replacement)": [[12, 48]]}}}, {"text": "The API for ServerSocket explains how this works (the constructor and bind() functions for instance)", "label": {"api": {"API": [[4, 6]]}}}, {"text": "If the database driver you are using supports it, you can use DatabaseMetaData#getTables to get the list of tables for a schema", "label": {"api": {"DatabaseMetaData#getTables": [[62, 87]]}}}, {"text": "You can get access to DatabaseMetaData from Connection#getMetaData", "label": {"api": {"Connection#getMetaData": [[44, 65]]}}}, {"text": "I am thinking along the lines of ZipFile.getInputStream()", "label": {"api": {"ZipFile.getInputStream()": [[33, 56]], "ZipFile": [[33, 39]]}}}, {"text": "Unfortunately, ZipFile doesn't work for this use case since its constructors require a standalone ZIP file", "label": {"api": {"ZipFile": [[15, 21]]}}}, {"text": "Try Point2D.Double instead", "label": {"api": {"Point2D.Double": [[4, 17]]}}}, {"text": "But the Point2D.Double class has a constructor that accepts doubles, which probably is what you want", "label": {"api": {"Point2D.Double": [[8, 21]]}}}, {"text": "There is a note at the end of the atomics package summary that states", "label": {"api": {"atomics package summary": [[34, 56]]}}}, {"text": "Simply copy it to somewhere in your build path and use Class.getResourceAsStream or ClassLoader.getResourceAsStream", "label": {"api": {"Class.getResourceAsStream": [[55, 79]], "ClassLoader.getResourceAsStream": [[84, 114]]}}}, {"text": "Locale#toString() returns what you want", "label": {"api": {"Locale#toString()": [[0, 16]]}}}, {"text": "A simple approach to address this is to require to enter secure token while original HttpSession in your web application is still active", "label": {"api": {"HttpSession": [[85, 95]]}}}, {"text": "However you can implement HttpSessionListener and store/restore your attributes when session is created and destroyed", "label": {"api": {"HttpSessionListener": [[26, 44]]}}}, {"text": "The new ISO8601 time zone pattern is covered by the X pattern specifier which is introduced in Java 7", "label": {"api": {"Java 7": [[95, 100]]}}}, {"text": "If you're still on Java 6 or older, then yes it may make difference", "label": {"api": {"Java 6": [[19, 24]]}}}, {"text": "To make the actual request programmatically check out the HttpURLConnection class", "label": {"api": {"HttpURLConnection": [[58, 74]]}}}, {"text": "For more information about Pattern and regexes in Java, see the documentation for the Pattern class", "label": {"api": {"the documentation for the Pattern class": [[60, 98]]}}}, {"text": "IndexColorModel is a good place to start in AWT", "label": {"api": {"IndexColorModel": [[0, 14]]}}}, {"text": "I suspect you could use System.setOut(PrintStream) to delegate to a PrintStream that doesn't do anything, but that probably won't eliminate all of your overhead -- I suspect, for example, that the formatting of the error messages will still cost you", "label": {"api": {"System.setOut(PrintStream)": [[24, 49]]}}}, {"text": "...or you could just normalize to lower case or upper case before switching", "label": {"api": {"lower case": [[34, 43]], "upper case": [[48, 57]]}}}, {"text": "If you are using the newer version of Java (jdk 6), then look in to Future", "label": {"api": {"Future": [[68, 73]]}}}, {"text": "You can use 'events' to achieve the same", "label": {"api": {"'events'": [[12, 19]]}}}, {"text": "You can use Toolkit.createImage(byte[]) to create a java.awt.Image from JPEG data", "label": {"api": {"Toolkit.createImage(byte[])": [[12, 38]]}}}, {"text": "Or, if you need a BufferedImage, you can wrap the byte array in a ByteArrayInputStream and use ImageIO.read(InputStream) to read it", "label": {"api": {"ImageIO.read(InputStream)": [[95, 119]]}}}, {"text": "Using plain Oracle JAXB I only see the possibility to implement that using an javax.xml.bind.Unmarshaller.Listener", "label": {"api": {"javax.xml.bind.Unmarshaller.Listener": [[78, 113]]}}}, {"text": "Class.forName(\"ClassName\") will solve your purpose", "label": {"api": {"Class.forName(\"ClassName\")": [[0, 25]]}}}, {"text": "Math.round returns a long...", "label": {"api": {"Math.round": [[0, 9]]}}}, {"text": "Yes, because ZipEntry.getSize() can return -1", "label": {"api": {"ZipEntry.getSize()": [[13, 30]]}}}, {"text": "I can see that you're trying to output in Moscow time as well, but Russia/Moscow is not a valid timezone, and the getTimeZone call \"helpfully\" silently defaults to returning GMT", "label": {"api": {"silently defaults to returning GMT": [[143, 176]]}}}, {"text": "The easiest way to make a ThreadPool is to use one created by the Executors class", "label": {"api": {"Executors": [[66, 74]]}}}, {"text": "javax.xml.validation.Validator has a method to validate and augment xml against a schema", "label": {"api": {"method": [[37, 42]]}}}, {"text": "According to javadocs for hashmap", "label": {"api": {"javadocs for hashmap": [[13, 32]]}}}, {"text": "File.isFile will tell you that a file exists and is not a directory", "label": {"api": {"File.isFile": [[0, 10]]}}}]