[{"text": "You could use java.net.InetAddress#getLocalHost for this", "label": {"api": {"java.net.InetAddress#getLocalHost": [[14, 46]]}}}, {"text": "Does the HttpServletRequest#getContextPath() helps you further", "label": {"api": {"HttpServletRequest#getContextPath()": [[9, 43]]}}}, {"text": "In your case, dealing with BufferedImage is a problem as it contains only visual raster image data", "label": {"api": {"BufferedImage": [[27, 39]]}}}, {"text": "When a BufferedImage is created from JPG data, all of the Exif/IPTC/Jfif/etc metadata is stripped off", "label": {"api": {"BufferedImage": [[7, 19]]}}}, {"text": "Theres the ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[11, 30]]}}}, {"text": "How about ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[10, 29]]}}}, {"text": "ByteArrayInputStream extends InputStream", "label": {"api": {"ByteArrayInputStream": [[0, 19]]}}}, {"text": "Some more details are necessary for a proper answer but you can start with the DocumentBuilder like this", "label": {"api": {"DocumentBuilder": [[79, 93]]}}}, {"text": "An InvocationTargetException is thrown when the invoked method (testMethod in your case) throws an exception", "label": {"api": {"InvocationTargetException": [[3, 27]]}}}, {"text": "InvocationTargetException is a checked exception that wraps an exception thrown by an invoked method or constructor", "label": {"api": {"InvocationTargetException": [[0, 24]]}}}, {"text": "This NullPointerException propagates up until it reaches the reflective call, at which point the it is wrapped in an InvocationTargetException", "label": {"api": {"InvocationTargetException": [[117, 141]]}}}, {"text": "Specifically, you'll need to create an Instrumentation agent, and call java.lang.instrument.Instrumentation.getAllLoadedClasses()", "label": {"api": {"java.lang.instrument.Instrumentation.getAllLoadedClasses()": [[71, 128]]}}}, {"text": "The package documentation for java.lang.instrument has lots of details on how to create and instantiate an agent", "label": {"api": {"documentation for java.lang.instrument": [[12, 49]]}}}, {"text": "Use the java.lang.Math class, and specifically for absolute value and square root:, the abs() and sqrt() methods", "label": {"api": {"java.lang.Math": [[8, 21]], "abs()": [[88, 92]], "sqrt()": [[98, 103]]}}}, {"text": "Try using Math.abs", "label": {"api": {"Math.abs": [[10, 17]]}}}, {"text": "You can use the UUID class", "label": {"api": {"UUID": [[16, 19]]}}}, {"text": "The default content viewer (HTML renderer) in JavaHelp is HTMLEditorKit", "label": {"api": {"HTMLEditorKit": [[58, 70]]}}}, {"text": "Maybe Swing's TreeModel and its implementation - DefaultTreeModel", "label": {"api": {"TreeModel": [[14, 22], [56, 64]], "DefaultTreeModel": [[49, 64]]}}}, {"text": "I wish to make some sort of an Iterable class that uses opendir()/closedir() like functions to lazily load file names as required", "label": {"api": {"Iterable": [[31, 38]]}}}, {"text": "Java 7 NIO.2 supports file iteration via java.nio.file.DirectoryStream", "label": {"api": {"java.nio.file.DirectoryStream": [[41, 69]]}}}, {"text": "It is an Iterable class", "label": {"api": {"Iterable": [[9, 16]]}}}, {"text": "From the Javadoc for Thread.sleep (called by TimeUnit.sleep)", "label": {"api": {"Thread.sleep": [[21, 32]]}}}, {"text": "Since you specified that you want unique items in a sorted manner, in Java the best tool for this is the TreeSet (although any SortedSet implementation will do)", "label": {"api": {"TreeSet": [[105, 111]]}}}, {"text": "Normally, the TreeSet class stores items in ascending order, but luckily we can change that with a custom Comparator object as an argument", "label": {"api": {"TreeSet": [[14, 20]]}}}, {"text": "Now pass an object of that class into your TreeSet<String> object, and you should be set", "label": {"api": {"TreeSet": [[43, 49]]}}}, {"text": "Because to make the iteration atomic and thread safe, you need to use the same lock as the synchronizedList, which happens to be the list itself", "label": {"api": {"the list itself": [[129, 143]]}}}, {"text": "Look at the Reflection API, in package java.lang.reflect and the Class class", "label": {"api": {"Reflection API": [[12, 25]], "Class": [[65, 69]]}}}, {"text": "You could use Class#isAssignableFrom", "label": {"api": {"Class#isAssignableFrom": [[14, 35]]}}}, {"text": "use File.seperator for  seperator for any operating system", "label": {"api": {"File.seperator": [[4, 17]]}}}, {"text": "If so, there are several more efficient options, the most simple being having a BlockingQueue where the sender class adds its commands and the receiver takes them", "label": {"api": {"BlockingQueue": [[80, 92]], "adds": [[117, 120]], "takes": [[152, 156]]}}}, {"text": "A simple and fast way to get an array of pixels into an image is using BufferedImage", "label": {"api": {"BufferedImage": [[71, 83]]}}}, {"text": "You can sort the list using Collections.sort method instead of all the conversions", "label": {"api": {"Collections.sort": [[28, 43]]}}}, {"text": "From the manual", "label": {"api": {"manual": [[9, 14]]}}}, {"text": "Java provides the BlockingQueue interface for this purpose", "label": {"api": {"BlockingQueue": [[18, 30]]}}}, {"text": "Form the String into a File reference, convert that to an URL then call setPage(URL)", "label": {"api": {"setPage(URL)": [[72, 83]]}}}, {"text": "The closest thing to a \"good termination\" signal I can think of is not an exception, but a call to System.exit(int) with 0 as argument, to indicate to the operating system that the program ended successfully", "label": {"api": {"System.exit(int)": [[99, 114]]}}}, {"text": "Maybe you mean an InterrupedException", "label": {"api": {"InterrupedException": [[18, 36]]}}}, {"text": "To be truly platform independent, you'd need to combine this with some platform detection to decide whether to append \"bin/java\" or \"bin\\java.exe\", but it should be reasonably straightforward to do using some of the other system properties", "label": {"api": {"system properties": [[222, 238]]}}}, {"text": "Have a look at http://docs.oracle.com/javase/1.4.2/docs/api/org/w3c/dom/package-summary.html", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/org/w3c/dom/package-summary.html": [[15, 91]]}}}, {"text": "If you are not after a templating engine you could build the DOM in code maybe using javax.swing.text.Document and javax.swing.text.html.HTMLEditorKit but I would recomemend against it", "label": {"api": {"javax.swing.text.Document": [[85, 109]], "javax.swing.text.html.HTMLEditorKit": [[115, 149]]}}}, {"text": "Have a look at using a Transformer to output the XML", "label": {"api": {"Transformer": [[23, 33]]}}}, {"text": "See CardLayout, as shown here", "label": {"api": {"CardLayout": [[4, 13]]}}}, {"text": "You might want to use BigDecimal to get exactly a decimal number [but you will again encounter rounding errors when you try to get 1/3]", "label": {"api": {"BigDecimal": [[22, 31]]}}}, {"text": "Providers are global", "label": {"api": {"Providers": [[0, 8]]}}}, {"text": "See addChangeListener(ChangeListener), as well as How to Use Sliders & How to Write a Change Listener", "label": {"api": {"addChangeListener(ChangeListener)": [[4, 36]]}}}, {"text": "Perhaps you should use Java's split method on a string", "label": {"api": {"split": [[30, 34]]}}}, {"text": "If you are required to use scanner, you might want to start off something like", "label": {"api": {"scanner": [[27, 33]]}}}, {"text": "Inside this loop, you will possibly need to use one of the next methods in Java's scanner api to work with each token as string", "label": {"api": {"scanner": [[82, 88]]}}}, {"text": "In any case, its well worth working this out on your own and exploring the scanner api", "label": {"api": {"scanner": [[75, 81]]}}}, {"text": "Using Option 1 you can use FutureTask.cancel() with mayInterruptIfRunning parameter set to true to cancel your tasks", "label": {"api": {"FutureTask.cancel()": [[27, 45]]}}}, {"text": "The ScheduledExecutorService.scheduleAtFixedRate() creates a ScheduledFuture, which still can be canceled trough the FutureTask api", "label": {"api": {"ScheduledExecutorService.scheduleAtFixedRate()": [[4, 49]], "ScheduledFuture": [[61, 75]]}}}, {"text": "Now look at the docs for the deprecated Date constructor", "label": {"api": {"deprecated Date constructor": [[29, 55]]}}}, {"text": "I think thats what a shutdown hook is for", "label": {"api": {"shutdown hook": [[21, 33]]}}}, {"text": "Take a look at LinkedHashMap with an overridden removeEldestEntry -- if it returns size() > MAXSIZE, you'll have what you want", "label": {"api": {"LinkedHashMap": [[15, 27]]}}}, {"text": "One of LinkedHashMap's constructors also has a boolean that says whether the \"oldest\" entry means the one that was added longest ago, or the one that was accessed longest ago", "label": {"api": {"LinkedHashMap": [[7, 19]]}}}, {"text": "You want a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[11, 23]]}}}, {"text": "I would use the Java 5 Executors instead of rolling your own", "label": {"api": {"Executors": [[23, 31]]}}}, {"text": "Just return the result of ResultSet#next(), assuming that there's an UNIQUE constraint on the username", "label": {"api": {"ResultSet#next()": [[26, 41]]}}}, {"text": "Your node class will need to implement Cloneable and override the clone() method", "label": {"api": {"Cloneable": [[39, 47]], "clone()": [[66, 72]]}}}, {"text": "From the Javadoc for Object.clone()", "label": {"api": {"clone()": [[28, 34]]}}}, {"text": "You should use a ConcurrentSkipListMap", "label": {"api": {"ConcurrentSkipListMap": [[17, 37]]}}}, {"text": "One option would be to create your own ELResolver", "label": {"api": {"ELResolver": [[39, 48]]}}}, {"text": "You can probably extend ScopedAttributeELResolver and override getValue", "label": {"api": {"ELResolver": [[39, 48]], "ScopedAttributeELResolver": [[24, 48]], "getValue": [[63, 70]]}}}, {"text": "In order to register the resolver, create a ServletContextListener and do something like the following in contextInitialized", "label": {"api": {"ServletContextListener": [[44, 65]], "contextInitialized": [[106, 123]]}}}, {"text": "About JComponent.setEnabled(boolean) it sayes", "label": {"api": {"JComponent.setEnabled(boolean)": [[6, 35]]}}}, {"text": "See Desktop.browse(URI) which", "label": {"api": {"Desktop.browse(URI)": [[4, 22]]}}}, {"text": "Yes, List.subList returns a view, as documented", "label": {"api": {"List.subList": [[5, 16]]}}}, {"text": "If are ok with using JRockit JVM, you can make use of the APIs below, which will give you callback methods when a class is loaded and class is unloaded", "label": {"api": {"JVM": [[29, 31]]}}}, {"text": "Have a look at JVM class from which we are supposed to use the getClassLibrary() method", "label": {"api": {"JVM": [[15, 17]]}}}, {"text": "The API for flushBuffer() is very precise", "label": {"api": {"flushBuffer()": [[12, 24]]}}}, {"text": "Use Arrays.deepToString() instead", "label": {"api": {"Arrays.deepToString()": [[4, 24]]}}}, {"text": "For the latter, in Java 6, the Math.nextUp method is what you are looking for", "label": {"api": {"Math.nextUp": [[31, 41]]}}}, {"text": "For decrement by one ULP, the Math.nextAfter method is useful", "label": {"api": {"Math.nextAfter": [[30, 43]]}}}, {"text": "Because RunnableScheduledFuture requires a parameterized type", "label": {"api": {"RunnableScheduledFuture": [[8, 30]]}}}, {"text": "The method Date.getDay() gives the day of the week (0 = Sunday, ..., 6 = Saturday)", "label": {"api": {"Date.getDay()": [[11, 23]]}}}, {"text": "Change it to Date.getDate() and you will get 30 as the result", "label": {"api": {"Date.getDate()": [[13, 26]]}}}, {"text": "You have to get the components from the panel mainPanel12 and iterate over the collection", "label": {"api": {"get the components": [[12, 29]]}}}, {"text": "You could put the numbers from 0 to n-1 into an ArrayList, then call Collections.shuffle() on that list, and then fetch the numbers from the list one by one", "label": {"api": {"Collections.shuffle()": [[69, 89]]}}}, {"text": "If you wish, you could encapsulate this into an Iterable", "label": {"api": {"Iterable": [[48, 55]]}}}, {"text": "System.out.println(d) will go through Double.toString which is a fairly complex method (as seen in its documentation) an will not always behave as you'd expect", "label": {"api": {"Double.toString": [[38, 52]]}}}, {"text": "As can be seen, the literal is sometimes far from the value it actually represents, which means that Double.toString prints something that may look surprising", "label": {"api": {"Double.toString": [[101, 115]]}}}, {"text": "Make sure you are using isPopupTrigger() the way they show in the section Bringing Up a Popup Menu", "label": {"api": {"isPopupTrigger()": [[24, 39]]}}}, {"text": "it should probably fall back to TrustManagerFactory.getDefaultAlgorithm() when nothing is set (that's the point of this method)", "label": {"api": {"TrustManagerFactory.getDefaultAlgorithm()": [[32, 72]]}}}, {"text": "It gives you an instance of Manifest, providing several convenience methods to access the attributes", "label": {"api": {"Manifest": [[28, 35]]}}}, {"text": "You can achieve the same behaviour using the new ProcessBuilder class, setting up the redirection using ProcessBuilder.Redirect.INHERIT", "label": {"api": {"ProcessBuilder": [[49, 62], [104, 117]]}}}, {"text": "It looks like you will have to use reflection to retrieve the static member (called a Field in the Java reflection APIs) named in the \"class\" attribute", "label": {"api": {"Field in the Java reflection APIs": [[86, 118]]}}}, {"text": "If you want to order elements by some comparison on the keys, then use a TreeMap with some Comparator on the keys, or just use their default Comparable ordering", "label": {"api": {"TreeMap": [[73, 79]], "Comparator": [[91, 100]], "Comparable": [[141, 150]]}}}, {"text": "It clearly doesn't do everything you want, but you may find the ThreadMXBean available in java.lang.management useful", "label": {"api": {"ThreadMXBean": [[64, 75]]}}}, {"text": "You can see the idiom of passing Class<T> as a constructor parameter in types like EnumMap", "label": {"api": {"EnumMap": [[83, 89]]}}}, {"text": "To multiply a BigDecimal by a power of 10 it's probably clearer to the reader (and more efficient, too) to use movePointLeft and movePointRight", "label": {"api": {"movePointLeft": [[111, 123]], "movePointRight": [[129, 142]]}}}, {"text": "Instead of tempValue.multiply(ten.pow(exponent)) you would use tempValue.movePointRight(exponent)", "label": {"api": {"movePointRight": [[73, 86]]}}}, {"text": "There are several types of Kerberos principals", "label": {"api": {"several types": [[10, 22]]}}}, {"text": "Try flushing the output stream after each print call", "label": {"api": {"flushing": [[4, 11]]}}}, {"text": "I'm getting a com.sun.jdi.InvocationException when I return an empty List<String> from one method and set that empty List in another POJO", "label": {"api": {"com.sun.jdi.InvocationException": [[14, 44]]}}}, {"text": "There's no stack trace and the JavaDocs don't even list a com.sun.jdi.InvocationException", "label": {"api": {"com.sun.jdi.InvocationException": [[58, 88]]}}}, {"text": "A doubly linked list with head and tail pointers would be better, but you should just use a Queue instead", "label": {"api": {"Queue": [[92, 96]]}}}, {"text": "You could use a LinkedBlockingQueue or an ArrayBlockingQueue which can be bounded (fixed size)", "label": {"api": {"LinkedBlockingQueue": [[16, 34]], "ArrayBlockingQueue": [[42, 59]]}}}, {"text": "The setBackground() API mentions that \"It is up to the look and feel to honor this property, some may choose to ignore it.\" Set the graphics context's color explicitly in paintComponent() and invoke fillRect()", "label": {"api": {"setBackground()": [[4, 18]]}}}, {"text": "Instead of attempting to implement Cloneable, which is considered broken, I would recommend you look at using copy constructors", "label": {"api": {"Cloneable": [[35, 43]]}}}, {"text": "For further reading, this article touches on both the issues of Cloneable and the limitations of copy constructors", "label": {"api": {"Cloneable": [[64, 72]]}}}, {"text": "Simply call setKeepAliveTime to set how long to wait, and set allowCoreThreadTimeOut to ensure that all threads (including the core threads) can be terminated", "label": {"api": {"setKeepAliveTime": [[12, 27]], "allowCoreThreadTimeOut": [[62, 83]]}}}, {"text": "The method for converting a string to a long is Long.parseLong", "label": {"api": {"Long.parseLong": [[48, 61]]}}}, {"text": "Use parseLong(), e.g.", "label": {"api": {"parseLong()": [[4, 14]]}}}, {"text": "Until now, I just built a String using StringBuilder, because in this application only select, update, insert and delete are used", "label": {"api": {"StringBuilder": [[39, 51]]}}}, {"text": "I would recommend looking at the Executors framework first, and then look into the CompletionService", "label": {"api": {"Executors": [[33, 41]], "CompletionService": [[83, 99]]}}}, {"text": "You simply need to use the displayMessage(...) method of the TrayIcon class", "label": {"api": {"displayMessage(...)": [[27, 45]], "TrayIcon": [[61, 68]]}}}, {"text": "The system properties should give you the information you need", "label": {"api": {"system properties": [[4, 20]]}}}, {"text": "To test signing/verifying I changed Oracle's tutorial on digital signatures to operate with PKCS11 tokens", "label": {"api": {"Oracle's tutorial": [[36, 52]]}}}, {"text": "For that, I used the same files that are used by the website itself to switch locales - in my case applicationResources.properties accesible perfectly by Properties - you can load the right file based on the URL at the start of the test and you're basically done", "label": {"api": {"Properties": [[154, 163]]}}}, {"text": "The best way to solve this issue is to use Thread.setDefaultUncaughtExceptionHandler()", "label": {"api": {"Thread.setDefaultUncaughtExceptionHandler()": [[43, 85]]}}}, {"text": "A priority queue should be the data structure you need in this case", "label": {"api": {"priority queue": [[2, 15]]}}}, {"text": "The easiest way here is to implement Comparable in this class and return someting like Float.compare(this.price, other.price)", "label": {"api": {"Comparable": [[37, 46]]}}}, {"text": "You may however set bthread polling on some shared stateful synchronization object (a CountDownLatch or a Semaphore for instance, look into the java.util.concurrent package), so that you alter the status of the object to set bthread waiting", "label": {"api": {"CountDownLatch": [[86, 99]], "Semaphore": [[106, 114]], "java.util.concurrent": [[144, 163]]}}}, {"text": "I have not found the source code of the default SSLSocketFactory and probably the keep-alive mechanism is implemented there", "label": {"api": {"default SSLSocketFactory": [[40, 63]]}}}, {"text": "However, you can guarantee the order of a LinkedHashSet so you can just use that", "label": {"api": {"LinkedHashSet": [[42, 54]]}}}, {"text": "Another option could be to use Futures if your animations are inside runnables or callables", "label": {"api": {"Futures": [[31, 37]]}}}, {"text": "Assuming this is a web application, you can implement and register a ServletContextListener", "label": {"api": {"ServletContextListener": [[69, 90]]}}}, {"text": "Attach a MouseListener to the panel", "label": {"api": {"MouseListener": [[9, 21]]}}}, {"text": "You want to look at Process Builder", "label": {"api": {"Process Builder": [[20, 34]]}}}, {"text": "You could synchronize it (and all other aspects to the variable) - but it would be better to use AtomicInteger which is designed for exactly this sort of thing", "label": {"api": {"AtomicInteger": [[97, 109]]}}}, {"text": "Consider using the SwingWorker class in order to ensure that it is not accessed outside of the Event Dispatch Thread", "label": {"api": {"SwingWorker class": [[19, 35]]}}}, {"text": "Runtime's exec(String) method just splits the string on whitespace; it doesn't understand any sort of quoting", "label": {"api": {"Runtime's exec(String) method": [[0, 28]]}}}, {"text": "Instead, you can use its exec(String[]) method, which takes an array, so doesn't have to apply any splitting logic", "label": {"api": {"exec(String[]) method": [[25, 45]]}}}, {"text": "Basically it override default console using System.setErr() and System.setOut()", "label": {"api": {"System.setErr()": [[44, 58]], "System.setOut()": [[64, 78]]}}}, {"text": "Run your data acquisition loop on another thread, such as SwingWorker", "label": {"api": {"SwingWorker": [[58, 68]]}}}, {"text": "The implementation of Math.pow (and most other methods in the Math class) is based on the   network library netlib as the package \"Freely Distributable Math Library\" (see StrictMath javadoc)", "label": {"api": {"StrictMath javadoc": [[171, 188]]}}}, {"text": "I'm using BigInteger's nextProbablePrime in a homework assignment to calculate the next prime number I can use to resize a hash table that uses quadratic probing", "label": {"api": {"nextProbablePrime": [[23, 39]]}}}, {"text": "I'm wondering if there is any relationship between the size of the value that I pass to nextProbablePrime and the likelihood that it will correctly return a prime number", "label": {"api": {"nextProbablePrime": [[88, 104]]}}}, {"text": "In other words, is there a number below which nextProbablePrime is guaranteed to be accurate", "label": {"api": {"nextProbablePrime": [[46, 62]]}}}, {"text": "From this version of the API, the Item constructor requires a String parameter, which you are not providing", "label": {"api": {"this version": [[5, 16]]}}}, {"text": "If you have control over the source, then you could use annotation processing", "label": {"api": {"process": [[67, 73]]}}}, {"text": "Create an annotation processor that will create a class - MapClass with a static member Map<String,Foo>", "label": {"api": {"process": [[21, 27]]}}}, {"text": "Every time the annotation processor encounters the @Name annotation, it adds that to the source code of MapClass", "label": {"api": {"process": [[26, 32]]}}}, {"text": "When it finishes processing the annotations, it will have the same effect as if you hard coded the map", "label": {"api": {"process": [[17, 23]]}}}, {"text": "Annotation processing happens during compile time", "label": {"api": {"process": [[11, 17]]}}}, {"text": "To create an annotation processor, extend AbstractProcessor", "label": {"api": {"AbstractProcessor": [[42, 58]], "process": [[24, 30]]}}}, {"text": "You will want to annotate your class with a @ SupportedAnnotationTypes ( \"Name\" ) annotation (make sure name is the fully qualified name of your annotation", "label": {"api": {"@ SupportedAnnotationTypes ( \"Name\" )": [[44, 80]]}}}, {"text": "Override the process method", "label": {"api": {"process": [[13, 19]]}}}, {"text": "process has two parameters", "label": {"api": {"process": [[0, 6]]}}}, {"text": "annotations is just the set of annotations that this particular processor supports - in your case it should be (Name)", "label": {"api": {"process": [[64, 70]]}}}, {"text": "Use roundEnv to getElementsAnnotatedWith", "label": {"api": {"getElementsAnnotatedWith": [[16, 39]]}}}, {"text": "AbstractProcessor has another utility member - processingEnv", "label": {"api": {"AbstractProcessor": [[0, 16]], "process": [[47, 53]], "processingEnv": [[47, 59]]}}}, {"text": "Use its getFiler method to createSourceFile", "label": {"api": {"getFiler": [[8, 15]], "createSourceFile": [[27, 42]]}}}, {"text": "You must compile your processor separately and before the other classes", "label": {"api": {"process": [[22, 28]]}}}, {"text": "After the processor is compiled and you are compiling the other classes you must tell the compiler about your processor", "label": {"api": {"process": [[10, 16], [110, 116]]}}}, {"text": "If you are using the command line you would add -processorpath /path/to/processor/class[es] and -processor qualified.name.of.processor", "label": {"api": {"process": [[49, 55], [72, 78], [97, 103], [125, 131]]}}}, {"text": "So for example, if you accidentally add a @Name annotation to a Bar element, then you can have the processor throw a compile time error (if you wish the processor can ignore it)", "label": {"api": {"process": [[99, 105], [153, 159]]}}}, {"text": "You are calling toString() on a byte[] which is just calling Object.toString()", "label": {"api": {"Object.toString()": [[61, 77]]}}}, {"text": "If you are not keen on adding an external dependency and just want to implement this for yourself then you just have to decode a String representation for each byte value in your byte array, such as by Arrays.toString()", "label": {"api": {"Arrays.toString()": [[202, 218]]}}}, {"text": "If you want to have a set of unique objects, use Set instead of List", "label": {"api": {"Set": [[49, 51]]}}}, {"text": "Set a timeout to wait a reasonable amount of time before deciding the server has sent all its packets", "label": {"api": {"Set a timeout": [[0, 12]]}}}, {"text": "I think the List it returns is already an ArrayList, but you can use the constructor ArrayList(Collection) to make sure you get one", "label": {"api": {"ArrayList(Collection)": [[85, 105]]}}}, {"text": "To get the image size, see getWidth()/getHeight()", "label": {"api": {"getWidth()": [[27, 36]], "getHeight()": [[38, 48]]}}}, {"text": "Also it's not generally a good idea to read the file 1 character at a time - you should try and use a char [] as a buffer and use the read(char[] cbuf, int off, int len) method, or for simplicity, use a BufferedReader", "label": {"api": {"BufferedReader": [[203, 216]]}}}, {"text": "I guess your teacher might be talking about TreeSet which is based on a form of self-balancing binary tree", "label": {"api": {"TreeSet": [[44, 50]]}}}, {"text": "The constructor expects a Comparator which can compare the instances that the tree will store", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "The code above declares an anonymous class which implements the Comparator interface", "label": {"api": {"Comparator": [[64, 73]]}}}, {"text": "In java you usually throw an IllegalArgumentException if one of the arguments were wrong which is a common thing to do really as a guard statement", "label": {"api": {"IllegalArgumentException": [[29, 52]]}}}, {"text": "You could store all paths as URIs", "label": {"api": {"URIs": [[29, 32]]}}}, {"text": "(Judging from your title, it is of type Thread.) Or, it isThread.sleep that you're looking for", "label": {"api": {"Thread.sleep": [[58, 69]]}}}, {"text": "It's some code, but the principle is easy, the component does a RequestDispatcher#include() with a custom HttpServletResponseWrapper which captures the written output and then writes it to the body of the JSF component", "label": {"api": {"RequestDispatcher#include()": [[64, 90]], "HttpServletResponseWrapper": [[106, 131]]}}}, {"text": "Checking the AudioFormat reference is also a good start for getting the idea", "label": {"api": {"AudioFormat": [[13, 23]]}}}, {"text": "Try changing local variables in your getAudioFormat() method to this", "label": {"api": {"AudioFormat": [[40, 50]]}}}, {"text": "Format Strings interpret every % as a placeholder, with literal % being escaped as %%, so it should be as simple as this", "label": {"api": {"Format Strings": [[0, 13]]}}}, {"text": "The TableModel method getValueAt() is called by the table renderer each time it wants to get the value of the cell so that it can render it", "label": {"api": {"getValueAt()": [[22, 33]]}}}, {"text": "In other words, you don't want to be mutating the state of your table model as a result of calling the getValueAt() method", "label": {"api": {"getValueAt()": [[103, 114]]}}}, {"text": "It would be easiest if your getValueAt() method use the row as the index into your array", "label": {"api": {"getValueAt()": [[28, 39]]}}}, {"text": "This simplifies your getValueAt() method", "label": {"api": {"getValueAt()": [[21, 32]]}}}, {"text": "If you only want doSomething to execute every second, you could move the task to its own Runnable and schedule it with a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[121, 144]]}}}, {"text": "Take Font for instance", "label": {"api": {"Font": [[5, 8]]}}}, {"text": "It has a constructor that takes the name of the Font you want, its size and its style (new Font(String, int, int))", "label": {"api": {"Font": [[48, 51], [91, 94]]}}}, {"text": "If Font had used an enum for all of its different styles (PLAIN, BOLD, ITALIC, BOLD_ITALIC), its constructor would look like Font(String, Style, int), preventing any confusion", "label": {"api": {"Font": [[3, 6], [125, 128]]}}}, {"text": "Unfortunately, enums weren't around when the Font class was created, and since Java has to maintain reverse compatibility, we will always be plagued by this ambiguity", "label": {"api": {"Font": [[45, 48]]}}}, {"text": "An example of the latter is java.nio.file's OpenOption and StandardOpenOption", "label": {"api": {"OpenOption": [[44, 53], [67, 76]], "StandardOpenOption": [[59, 76]]}}}, {"text": "if a developer wanted to create his own non-standard OpenOption, he could", "label": {"api": {"OpenOption": [[53, 62]]}}}, {"text": "Using an enum however gives you useful methods (Enum javadoc) that you would otherwise have to implement yourself, such as Enum.valueOf", "label": {"api": {"Enum javadoc": [[48, 59]]}}}, {"text": "If not directly helpful, I believe you can take advantage of ReentrantLock to test if concurrent control over NNTP can resolve the issue", "label": {"api": {"ReentrantLock": [[61, 73]]}}}, {"text": "The javadoc for Math.atan(double) is pretty clear that the returning value can range from -pi/2 to pi/2", "label": {"api": {"Math.atan(double)": [[16, 32]]}}}, {"text": "Call your function from a FutureTask and use the get(long, TimeUnit) method", "label": {"api": {"FutureTask": [[26, 35]]}}}, {"text": "Read the whole file into a big string and then split it on the new line token ('\\n')", "label": {"api": {"split": [[47, 51]]}}}, {"text": "ArrayList is more preferable to your second one", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "Better try this other method", "label": {"api": {"method": [[22, 27]]}}}, {"text": "The method you're invoking returns an Object[], not a String[] and the cast you're trying to perform is invalid", "label": {"api": {"method": [[4, 9]]}}}, {"text": "Get the default navigation handler via Application.getNavigationHandler", "label": {"api": {"Application.getNavigationHandler": [[39, 70]]}}}, {"text": "Wrap it in a reflection proxy and set the proxy as new default navigation handler via Application.setNavigationHandler", "label": {"api": {"reflection proxy": [[13, 28]], "Application.setNavigationHandler": [[86, 117]]}}}, {"text": "A concrete example in the Java class library is ConcurrentSkipListSet (although it may not be directly usable for you here)", "label": {"api": {"ConcurrentSkipListSet": [[48, 68]]}}}, {"text": "readLine() returns null when it reaches the end of the stream, so you need to compare to null, not \"null\"", "label": {"api": {"readLine() returns null": [[0, 22]]}}}, {"text": "The standard protocol is to implement the equals() method", "label": {"api": {"equals()": [[42, 49]]}}}, {"text": "Note that once you've done this, you also need to implement the hashCode() method", "label": {"api": {"hashCode()": [[64, 73]]}}}, {"text": "So you need to use Iterator.remove() to avoid this exception", "label": {"api": {"Iterator.remove()": [[19, 35]]}}}, {"text": "Using a PreparedStatement might give you slightly better performances but nothing of the magnitude described here", "label": {"api": {"PreparedStatement": [[8, 24]]}}}, {"text": "Here, the interface in question is ActionListener", "label": {"api": {"ActionListener": [[35, 48]]}}}, {"text": "It contains a single method, actionPerformed(ActionEvent)", "label": {"api": {"actionPerformed(ActionEvent)": [[29, 56]]}}}, {"text": "You could implement a FilenameFilter to use on File.listFiles", "label": {"api": {"File.listFiles": [[47, 60]]}}}, {"text": "You have to pass a Path instance to Files.newOutputStream()", "label": {"api": {"Path": [[19, 22]], "Files.newOutputStream()": [[36, 58]]}}}, {"text": "You can obtain such an instance using one of the methods in Paths", "label": {"api": {"Path": [[60, 63]], "Paths": [[60, 64]]}}}, {"text": "Likewise, it appears that you meant to initialize startingPath something like this (using a string)", "label": {"api": {"Path": [[58, 61]]}}}, {"text": "but you need to use Paths to convert a String into a Path", "label": {"api": {"Path": [[20, 23], [53, 56]], "Paths": [[20, 24]]}}}, {"text": "See http://docs.oracle.com/javase/1.4.2/docs/api/javax/swing/table/AbstractTableModel.html#fireTableChanged(javax.swing.event.TableModelEvent) for an example", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/javax/swing/table/AbstractTableModel.html#fireTableChanged(javax.swing.event.TableModelEvent": [[4, 140]]}}}, {"text": "Recognizing shapes is not a trivial exercise, but Java2D easily accommodates rotating defined instances of classes implementing the Shape interface in two dimensions", "label": {"api": {"Shape": [[132, 136]]}}}, {"text": "But you probably want to use Random.nextGaussian()", "label": {"api": {"Random.nextGaussian()": [[29, 49]]}}}, {"text": "The mappedBy attribute of the @OneToMany annotation refers to the property name of the association on the owners side", "label": {"api": {"mappedBy": [[4, 11]]}}}, {"text": "Also, if you need to deal with a large chunk of data (perhaps more than just the two counters you mention) on a per-bit level, you might consider taking a look at BitSet", "label": {"api": {"BitSet": [[163, 168]]}}}, {"text": "If you need to notify another thread that all the workers have gone home, you can use a CountDownLatch to do so", "label": {"api": {"CountDownLatch": [[88, 101]]}}}, {"text": "You might want to use UnsupportedOperationException and detect calls to-yet-to-be-implemented methods when running your tests", "label": {"api": {"UnsupportedOperationException": [[22, 50]]}}}, {"text": "Or, since you are starting with a String, you could use String#substring to create a substring of 1 char", "label": {"api": {"String#substring": [[56, 71]]}}}, {"text": "Look at this link", "label": {"api": {"this link": [[8, 16]]}}}, {"text": "See also Pattern.quote()", "label": {"api": {"Pattern.quote()": [[9, 23]]}}}, {"text": "From the Socket Javadoc", "label": {"api": {"the Socket Javadoc": [[5, 22]]}}}, {"text": "Based on reference documentation, CompletionService acts upon a consumer/producer approach and takes advantage of an internal Executor", "label": {"api": {"reference documentation": [[9, 31]]}}}, {"text": "For that, I suggest that you use BigDecimal instead", "label": {"api": {"BigDecimal": [[33, 42]]}}}, {"text": "It has a method divide that takes another BigDecimal and a MathContext", "label": {"api": {"BigDecimal": [[42, 51]], "MathContext": [[59, 69]]}}}, {"text": "In the MathContext, you can specify the rounding mode as ceiling or floor (among others)", "label": {"api": {"MathContext": [[7, 17]]}}}, {"text": "If all you need is rounding toward zero, you can also use BigDecimal.divideToIntegralValue", "label": {"api": {"BigDecimal": [[58, 67]]}}}, {"text": "You can do that using Arrays#copyOf method to create and copy it in a simple way", "label": {"api": {"Arrays#copyOf": [[22, 34]]}}}, {"text": "BufferedWriter wrapped around a File Writer", "label": {"api": {"BufferedWriter": [[0, 13]], "File Writer": [[32, 42]]}}}, {"text": "try using replaceAll method from java.lang.String", "label": {"api": {"replaceAll": [[10, 19]]}}}, {"text": "If you read on http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/String.html#replace%28char,%20char%29 you will see that it takes two char objects as an argument", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/String.html#replace%28char,%20char%29": [[15, 106]]}}}, {"text": "Use a Matcher to find and replace the as", "label": {"api": {"Matcher": [[6, 12]]}}}, {"text": "If you want to manipulate Swing components from another thread, there are several ways you can do it, including SwingUtilities.invokeLater(), SwingUtilities.invokeAndWait(), and SwingWorker (these don't actually manipulate the components from another thread - they just make it easy to coordinate with the EDT)", "label": {"api": {"SwingUtilities.invokeLater()": [[112, 139]], "SwingUtilities.invokeAndWait()": [[142, 171]], "SwingWorker": [[178, 188]]}}}, {"text": "SwingUtilities.invokeLater() and invokeAndWait() allow you to pass a Runnable to them, and have the Event Dispatch Thread run them for you", "label": {"api": {"SwingUtilities.invokeLater()": [[0, 27]]}}}, {"text": "The SwingWorker allows you to create a task and divide it into two portions", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "It has all you need to learn about using SwingUtilities and SwingWorker", "label": {"api": {"SwingWorker": [[60, 70]]}}}, {"text": "You need to adopt the node by the new document, calling Document.adoptNode()", "label": {"api": {"Document.adoptNode()": [[56, 75]]}}}, {"text": "unimplemented) methods specified by the TableModel interface in AbstractTableModel", "label": {"api": {"AbstractTableModel": [[64, 81]]}}}, {"text": "You do not check the result of File#renameTo()", "label": {"api": {"File#renameTo()": [[31, 45]]}}}, {"text": "You can use System.setOut (and setErr) to set the default standard output/error to your own PrintStreams", "label": {"api": {"System.setOut": [[12, 24]]}}}, {"text": "For signing you will need a PrivateKey entry", "label": {"api": {"PrivateKey": [[28, 37]]}}}, {"text": "If you examine the Keystore entry type you should be able to tell which is which", "label": {"api": {"Keystore": [[19, 26]]}}}, {"text": "If you can only compare the certificates you will need to look at the X509 cert usage and see if that helps", "label": {"api": {"X509 cert usage": [[70, 84]]}}}, {"text": "You just need your object to implement the Comparable interface and code your logic in the compareTo method", "label": {"api": {"interface": [[54, 62]]}}}, {"text": "From Statement javadoc", "label": {"api": {"Statement javadoc": [[5, 21]]}}}, {"text": "You're calling getApplicationId() on a Class instance, but it does not have that method at all", "label": {"api": {"Class": [[39, 43]]}}}, {"text": "I ended up implementing my own XmlAdapter that adapts my LargeObject to special LazyLargeObjectLoader", "label": {"api": {"XmlAdapter": [[31, 40]]}}}, {"text": "You can override Container#getInsets, although you should be using Swing components", "label": {"api": {"Container#getInsets": [[17, 35]]}}}, {"text": "To adapt the code to monitor the initialization progress of your application, rather than tying the ProgressBar to a WebEngine's loadWorker.workDone property, create a JavaFX Task which performs expensive initialization work, and monitor the progress of the Task via the Task's progressProperty and messageProperty", "label": {"api": {"Task": [[175, 178], [258, 261], [271, 274]], "progressProperty": [[278, 293]], "messageProperty": [[299, 313]]}}}, {"text": "Here is a link to a splash based sample based upon the Task approach outlined in the prior paragraph", "label": {"api": {"Task": [[55, 58]]}}}, {"text": "For a WebStart or browser embedded JavaFX application, use a preloader as suggested by assylias", "label": {"api": {"preloader": [[61, 69]]}}}, {"text": "Create a new JLabel from your ImageIcon and add that to your JPanel", "label": {"api": {"JLabel": [[13, 18]]}}}, {"text": "The Object class has a getClass() method which returns the name of the class of which the given Object is an instance", "label": {"api": {"getClass()": [[23, 32]]}}}, {"text": "And then calling the functions using a ByteArrayInputStream with the contents of barr", "label": {"api": {"ByteArrayInputStream": [[39, 58]]}}}, {"text": "Have you checked out Priority Queue", "label": {"api": {"Priority Queue": [[21, 34]]}}}, {"text": "Like all other InputStreams, AudioInputStream can only be read once (unless it can be .reset())", "label": {"api": {".reset()": [[86, 93]]}}}, {"text": "You could try calling .reset() on the AudioInputStream before attemping to play the sound again, but AudioInputStream may not support .reset()", "label": {"api": {".reset()": [[22, 29], [134, 141]]}}}, {"text": "Also see markSupported()", "label": {"api": {"markSupported()": [[9, 23]]}}}, {"text": "If .reset() doesn't work, consider constructing a new AudioInputStream every time you need to start playing", "label": {"api": {".reset()": [[3, 10]]}}}, {"text": "This example utilizes AudioInputStream.reset()", "label": {"api": {".reset()": [[38, 45]]}}}, {"text": "In fact, AudioInputStream does supports reset() if and only if its underlying InputStream supports .reset()", "label": {"api": {".reset()": [[99, 106]]}}}, {"text": "Because ByteArrayInputStream supports reset, these cached AudioInputStreams also support .reset(), which allows them to be reused", "label": {"api": {".reset()": [[89, 96]]}}}, {"text": "When you construct your FileWriter or FileOutputStream there's a constructor argument which allows you to put it in append mode", "label": {"api": {"FileWriter": [[24, 33]], "FileOutputStream": [[38, 53]]}}}, {"text": "The stream keeps track of objects references that it has serialised previously (unless you call reset()), and instead of writing the object out in full, it will write a handle that points back to where the real object was written", "label": {"api": {"reset()": [[96, 102]]}}}, {"text": "Use a JLabel with an ImageIcon to paint your image for you", "label": {"api": {"JLabel": [[6, 11]], "ImageIcon": [[21, 29]]}}}, {"text": "If you look at the Node interface documentation, you'll notice a method called getOwnerDocument()", "label": {"api": {"Node interface documentation": [[19, 46]]}}}, {"text": "According to BufferedWriter API the write method takes an int that is supposed to be character", "label": {"api": {"BufferedWriter API": [[13, 30]]}}}, {"text": "I want to convert a String to an array of objects of Character class but I am unable to perform the conversion", "label": {"api": {"Character": [[53, 61]]}}}, {"text": "I know that I can convert a String to an array of primitive datatype type \"char\" with the toCharArray() method but it doesn't help in converting a String to an array of objects of Character type", "label": {"api": {"Character": [[180, 188]]}}}, {"text": "java.util.BitSet is designed for that if the length is not fixed", "label": {"api": {"java.util.BitSet": [[0, 15]]}}}, {"text": "GraphicsEnvironment class should be of help here", "label": {"api": {"GraphicsEnvironment": [[0, 18]]}}}, {"text": "Thread.sleep()) in your code, using variable delays to change the load", "label": {"api": {"Thread.sleep()": [[0, 13]]}}}, {"text": "Use simple JTextField and set a DocumentFilter filter on it", "label": {"api": {"JTextField": [[11, 20]]}}}, {"text": "using standard java DOM tools, you would provide a NamespaceContext to the XPath instance", "label": {"api": {"NamespaceContext": [[51, 66]]}}}, {"text": "The easiest, but certainly not the most efficient is to create an instance of a TreeMap with provided Comparator for your type, putAll() elements from your map to the map you just created and remove k-elements with help of keySet()", "label": {"api": {"TreeMap": [[80, 86]], "Comparator": [[102, 111]], "keySet()": [[223, 230]]}}}, {"text": "In the end a TreeMap will not contain k-smallest elements", "label": {"api": {"TreeMap": [[13, 19]]}}}, {"text": "During runtime using reflection you can check if your class is a ParameterizedType has a parameter that is actually a class and if it has an empty constructor", "label": {"api": {"ParameterizedType": [[65, 81]]}}}, {"text": "You can achieve by simply adding a call to ExecutorService#awaitTermination after the call to ExecutorService#shutdown", "label": {"api": {"ExecutorService#awaitTermination": [[43, 74]]}}}, {"text": "The typical way to do this is to write a generic sorting algorithm on any type that accepts a Comparator, and then to write different Comparators to sort by different fields", "label": {"api": {"Comparator": [[94, 103], [134, 143]]}}}, {"text": "You could either use a long which has a bound of 9223372036854775807 or a BigInteger", "label": {"api": {"BigInteger": [[74, 83]]}}}, {"text": "BufferedReader.readLine()(link) expects it", "label": {"api": {"(link)": [[25, 30]]}}}, {"text": "Copy array portions with System.arraycopy() instead of iterating over its elements", "label": {"api": {"System.arraycopy()": [[25, 42]]}}}, {"text": "You are trying to treat list as an array, but the only way to access elements of the is through calling get() method", "label": {"api": {"get()": [[104, 108]]}}}, {"text": "The constructors for Locale are", "label": {"api": {"Locale": [[21, 26]]}}}, {"text": "Locale(String language)Construct a locale from a language code", "label": {"api": {"Locale": [[0, 5]], "Locale(String language)": [[0, 22]]}}}, {"text": "Locale(String language, String country)Construct a locale from language, country", "label": {"api": {"Locale": [[0, 5]], "Locale(String language, String country)": [[0, 38]]}}}, {"text": "Locale(String language, String country, String variant)Construct a locale from language, country, variant", "label": {"api": {"Locale": [[0, 5]], "Locale(String language, String country, String variant)": [[0, 54]]}}}, {"text": "You want new Locale(\"es\", \"ES\"); to get the Locale that goes with es_ES", "label": {"api": {"Locale": [[13, 18], [44, 49]]}}}, {"text": "However, it would be better to use Locale.forLanguageTag(\"es-ES\"), using the well-formed IETF BCP 47 language tag es-ES (with - instead of _), since that method can return a cached Locale, instead of always creating a new one", "label": {"api": {"Locale": [[35, 40], [181, 186]], "Locale.forLanguageTag(\"es-ES\")": [[35, 64]]}}}, {"text": "The String class provides the following format method, http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html": [[55, 120]]}}}, {"text": "It might be better to store valueClass as Class<T> and use Class#cast to cast for you, then you won't have any ugly @SuppressWarnings hanging over your method", "label": {"api": {"Class#cast": [[59, 68]]}}}, {"text": "But with String if you need for some strange reason using == operator you need to be sure to compare the results of .intern method", "label": {"api": {".intern method": [[116, 129]]}}}, {"text": "The JTree responds to the TreeSelectionListener rather than the MouseListener", "label": {"api": {"TreeSelectionListener": [[26, 46]]}}}, {"text": "Previously, I recommended using an EnumMap for this case, but Adrian's answer makes much more sense", "label": {"api": {"EnumMap": [[35, 41]]}}}, {"text": "Don't need any third party APIs, just use DateFormat to parse/format Dates by providing date format pattern", "label": {"api": {"DateFormat": [[42, 51]]}}}, {"text": "I would use LastIndexOf(\".\") to get the index of that last '.', and then use substring() to cut out the part that you want", "label": {"api": {"LastIndexOf(\".\")": [[12, 27]], "substring()": [[77, 87]]}}}, {"text": "You can create a Filter that opens a database transaction before handling the request and commits it afterwards", "label": {"api": {"Filter": [[17, 22]]}}}, {"text": "First, do not open a connection on each request, but rather reuse a connection from the connection pool (possibly DataSource), and put in a shared space - in your case the easiest would be to leverage static ThreadLocal field", "label": {"api": {"DataSource": [[114, 123]], "ThreadLocal": [[208, 218]]}}}, {"text": "There is no need for using DataOutputStream", "label": {"api": {"DataOutputStream": [[27, 42]]}}}, {"text": "If the method java.io.File.exists() returns false, and the file C:\\pagefile.sys exists in your file system, you specified the incorrect file path then", "label": {"api": {"java.io.File.exists()": [[14, 34]]}}}, {"text": "If you are following the Publish/Subscribe pattern then you need a message queue of some sort", "label": {"api": {"queue": [[75, 79]]}}}, {"text": "The Producer puts messages on the queue and Consumer reads messages of the queue", "label": {"api": {"queue": [[34, 38], [75, 79]]}}}, {"text": "The point of messaging is that your producers/consumers don't have to reference each other directly but only communicate via a queue", "label": {"api": {"queue": [[127, 131]]}}}, {"text": "You can use the method instersects in class Area", "label": {"api": {"instersects": [[23, 33]]}}}, {"text": "However, when opening the popup menu programmatically via show(Component invoker, int x, int y), the focus is getting taken from the JTextField", "label": {"api": {"show(Component invoker, int x, int y)": [[58, 94]]}}}, {"text": "It allows iteration over arrays and Iterables", "label": {"api": {"Iterable": [[36, 43]]}}}, {"text": "This can be done (as in I have done it) using a custom DocumentFilter", "label": {"api": {"DocumentFilter": [[55, 68]]}}}, {"text": "Looks like a good fit for BoxLayout", "label": {"api": {"BoxLayout": [[26, 34]]}}}, {"text": "it should be possible to interrupt it before it's completed) you need to either use other interruptable action (Thread.sleep, InputStream.read, read for more info) or manually check thread interruption status in your cycle condition using Thread.isInterrupted", "label": {"api": {"read for more info": [[144, 161]]}}}, {"text": "From the BigDecimal#divide(BigDecimal) documentation", "label": {"api": {"BigDecimal#divide(BigDecimal) documentation": [[9, 51]]}}}, {"text": "In your specific case \"2/3\" has a non-terminating decimal expansion (0.6666...) so you'll have to use a form of divide() which takes a scale and/or RoundingMode to resolve the infinite representation", "label": {"api": {"RoundingMode": [[148, 159]]}}}, {"text": "The class java.awt.Robot can be used to generate mouse and keyboard events", "label": {"api": {"java.awt.Robot": [[10, 23]]}}}, {"text": "As I found on this post the EntityManager have a method called refresh that will update your object after you persist him", "label": {"api": {"refresh": [[63, 69]]}}}, {"text": "I haven't tested this, so I'm not sure where exactly to put the refresh method call, there, after the commit, after the flush, etc", "label": {"api": {"refresh": [[64, 70]]}}}, {"text": "Then, create an SSLEngine using SSLContext.createSSLEngine()", "label": {"api": {"SSLContext.createSSLEngine()": [[32, 59]]}}}, {"text": "On this SSLEngine, you should be able to enable the cipher suites you want", "label": {"api": {"enable the cipher suites you want": [[41, 73]]}}}, {"text": "According to the Java Language Specification, Section 5.1.8, the unboxing of a Boolean is done by calling booleanValue() on the Boolean reference", "label": {"api": {"booleanValue()": [[106, 119]]}}}, {"text": "The accept method only accepts new connections", "label": {"api": {"accept": [[4, 9], [23, 28]]}}}, {"text": "Since you only have two clients attempting to connect to your server, it will hang indefinitely on your third invocation of accept", "label": {"api": {"accept": [[124, 129]]}}}, {"text": "you should use vector.get(0) to retrieve your object", "label": {"api": {"vector.get(0)": [[15, 27]]}}}, {"text": "That's why the String class has the matches method", "label": {"api": {"matches": [[36, 42]]}}}, {"text": "That StringUtils class probably predates Java 1.4 when the matches method was added", "label": {"api": {"matches": [[59, 65]]}}}, {"text": "Use the split() method in the String class, like this", "label": {"api": {"split()": [[8, 14]]}}}, {"text": "What you could do, and I don't recommend this, is use WeakReferences in your Lists", "label": {"api": {"WeakReference": [[54, 66]]}}}, {"text": "Normally, these are used for lists and arrays, such as ArrayList or HashMap", "label": {"api": {"ArrayList": [[55, 63]], "HashMap": [[68, 74]]}}}, {"text": "Scanner does this with the useDelimiter() method", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "I would try bd.remainder(BigDecimal.ONE)", "label": {"api": {"remainder": [[15, 23]], "ONE": [[36, 38]]}}}, {"text": "Uses the remainder method and the ONE constant", "label": {"api": {"remainder": [[9, 17]], "ONE": [[34, 36]]}}}, {"text": "You don't really explain what you want to do, but between the listFiles() and exists() methods of the java.io.File class, you should be able to get it done", "label": {"api": {"java.io.File": [[102, 113]]}}}, {"text": "Or even the compiler API provided by modern Java implementations", "label": {"api": {"compiler API": [[12, 23]]}}}, {"text": "I think the Observer pattern might work well for you", "label": {"api": {"Observer": [[12, 19]]}}}, {"text": "In Java, this is implemented via Observer and Observable", "label": {"api": {"Observer": [[33, 40]], "Observable": [[46, 55]]}}}, {"text": "You should be using ExternalContext#redirect() to perform a redirect in a JSF-safe way", "label": {"api": {"ExternalContext#redirect()": [[20, 45]]}}}, {"text": "I came across Phaser, but this solution is for java 7 which I unfortunately cannot use", "label": {"api": {"Phaser": [[14, 19]]}}}, {"text": "You have to split on word boundaries, and that exists in the javadoc of Pattern, see \"Boundary matchers.\" In fact as this is homework, read the documentation; there are nice jewels of expressive power", "label": {"api": {"Pattern": [[72, 78]]}}}, {"text": "Take a look at the GridLayout you can find examples on how to use it here", "label": {"api": {"GridLayout": [[19, 28]]}}}, {"text": "You can just use String.split", "label": {"api": {"String.split": [[17, 28]]}}}, {"text": "Use the method split() instead, like this", "label": {"api": {"split()": [[15, 21]]}}}, {"text": "Have you taken a look at the static method Float.parseFloat()", "label": {"api": {"Float.parseFloat()": [[43, 60]]}}}, {"text": "You can always use masking to achieve the same effect and there is the BitSet class, which lets you do all kinds of bit manipulation", "label": {"api": {"BitSet": [[71, 76]]}}}, {"text": "It's available in Java as Math.asin()", "label": {"api": {"Math.asin()": [[26, 36]]}}}, {"text": "Please read the Math.asin() javadoc to be aware of what is returned by the function", "label": {"api": {"Math.asin()": [[16, 26]]}}}, {"text": "You can use a Set and store the values already printed", "label": {"api": {"Set": [[14, 16]]}}}, {"text": "Sounds like a job for one of the implementations of java.util.NavigableMap", "label": {"api": {"java.util.NavigableMap": [[52, 73]]}}}, {"text": "It is useful to get familiar with HTTP first, then with URLConnection and Apache HttpClient", "label": {"api": {"URLConnection": [[56, 68]]}}}, {"text": "The window includes the border around the edge of the contentPane, which is why you're getting 3, 25 instead of 0,0", "label": {"api": {"contentPane": [[54, 64]]}}}, {"text": "You can either add your MouseListener to the contentPane directly, or use the frame's Insets to account for the border", "label": {"api": {"contentPane": [[45, 55]], "Insets": [[86, 91]]}}}, {"text": "Then you can find the correct constructor and create your new instance", "label": {"api": {"find the correct constructor": [[13, 40]], "new instance": [[58, 69]]}}}, {"text": "I highly recommend listening to the advice given by @Jeffrey, but if you do proceed with this design, then perhaps implementing the ContainerListener interface may prove useful", "label": {"api": {"ContainerListener": [[132, 148]]}}}, {"text": "As you mentioned in your question, you should use BigInteger", "label": {"api": {"BigInteger": [[50, 59]]}}}, {"text": "I hope it's alright to answer my own question - but I ended up learning about the java.nio package", "label": {"api": {"java.nio": [[82, 89]]}}}, {"text": "Why don't you use InetAddres.getByName on the domain part", "label": {"api": {"InetAddres.getByName": [[18, 37]]}}}, {"text": "But JTable with accepts data as Object[][], but will give Object[]", "label": {"api": {"JTable": [[4, 9]]}}}, {"text": "(Well, that's what it did when I last looked at the source; the docs don't actually say it has to use that.) if you know the seed that new Random() used", "label": {"api": {"don't actually say": [[69, 86]]}}}, {"text": "Note that if you're relying on the numbers being unpredictable for security, you should be using java.secure.SecureRandom rather than java.util.Random", "label": {"api": {"java.secure.SecureRandom": [[97, 120]]}}}, {"text": "Also, check out the Javadocs for regexes", "label": {"api": {"Javadocs for regexes": [[20, 39]]}}}, {"text": "Read them into a HashSet instead", "label": {"api": {"HashSet": [[17, 23]]}}}, {"text": "The dialog is still re-usable as per the Window API (since JDialog inherits this method from Window)", "label": {"api": {"Window API": [[41, 50]]}}}, {"text": "The easiest to use is Scanner", "label": {"api": {"Scanner": [[22, 28]]}}}, {"text": "A JFileChooser is a JComponent, so you can just add it to a JPanel with BorderLayout and it will fill the whole panel", "label": {"api": {"JFileChooser": [[2, 13]], "JComponent": [[20, 29]], "add": [[48, 50]], "JPanel": [[60, 65]], "BorderLayout": [[72, 83]]}}}, {"text": "Either use Window#dispose or Window#setVisible(false)", "label": {"api": {"Window#dispose": [[11, 24]], "Window#setVisible(false)": [[29, 52]]}}}, {"text": "If there are more e-mails, you will miss some, if there are less - you will have some nulls left [which the Set will collapse into a single null]", "label": {"api": {"Set": [[108, 110]]}}}, {"text": "Try using an ArrayList instead of an array, or using a Set from the first place.", "label": {"api": {"ArrayList": [[13, 21]], "Set": [[55, 57]]}}}, {"text": "As a side note, what you really need is a Set", "label": {"api": {"Set": [[42, 44]]}}}, {"text": "This is a collection which is guaranteed to have no duplicates and allows you to answer the question \"do I contain this value?\" in an efficient manner using the method Set.contains( Object )", "label": {"api": {"Set": [[168, 170]]}}}, {"text": "So I would create a TreeSet or HashSet and put every number the user types into it", "label": {"api": {"Set": [[24, 26], [35, 37]]}}}, {"text": "Yes a simpler way would be use to use Java's serialization framework to do all that for you by simply having your object implement Serializable", "label": {"api": {"Serializable": [[131, 142]]}}}, {"text": "You would wrap your sockets outputstream with an ObjectOutputStream and simply tell it to write your object", "label": {"api": {"ObjectOutputStream": [[49, 66]]}}}, {"text": "Use scanner.next() to return the next token instead of scanner.nextLine(), which returns the next full line (and your input only has one)", "label": {"api": {"scanner.next()": [[4, 17]], "scanner.nextLine()": [[55, 72]]}}}, {"text": "How about creating a ThreadPoolExecutor backed by a BlockingQueue using ThreadPoolExecutor.CallerRunsPolicy", "label": {"api": {"ThreadPoolExecutor": [[21, 38], [72, 89]], "ThreadPoolExecutor.CallerRunsPolicy": [[72, 106]]}}}, {"text": "There are more details on the constructor options for ThreadPoolExecutor on its Javadoc page", "label": {"api": {"ThreadPoolExecutor": [[54, 71]]}}}, {"text": "contains() method of String class does not take regular expression as a parameter, it takes normal text", "label": {"api": {"contains()": [[0, 9]], "String": [[21, 26]]}}}, {"text": "You should either use StringBuffer with its convenient append method, or build an array of N characters, and use the corresponding constructor of the String", "label": {"api": {"StringBuffer": [[22, 33]]}}}, {"text": "You need to take a look at three methods setSelectionStart(...), setSelectionEnd(...) and replaceSelection(...)", "label": {"api": {"setSelectionStart(...)": [[41, 62]], "setSelectionEnd(...)": [[65, 84]], "replaceSelection(...)": [[90, 110]]}}}, {"text": "You can use java.util.Timer to schedule the time when your program needs to stop", "label": {"api": {"java.util.Timer": [[12, 26]]}}}, {"text": "I've overriden the equals method of the Node class, but seems like the containskey method checks the hashcodes, however as far as i understood it only has to check the equals method link to java reference", "label": {"api": {"link to java reference": [[182, 203]]}}}, {"text": "Refer to http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object": [[9, 94]]}}}, {"text": "Extend JPanel instead of Panel, and override paintComponent method, ie", "label": {"api": {"JPanel": [[7, 12]], "paintComponent": [[45, 58]]}}}, {"text": "Perhaps Graphics#clearRect is what you're looking for", "label": {"api": {"Graphics#clearRect": [[8, 25]]}}}, {"text": "The DecimalFormat class can format this for you", "label": {"api": {"DecimalFormat": [[4, 16]]}}}, {"text": "You can use the Scanner class to read the values", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "You will have to do a bit more work to ensure that + is not part of your conversion to Integer (check the Integer wrapper class), as Scanner won't accept + as a unary operator (it works fine with negative)", "label": {"api": {"Scanner": [[133, 139]], "Integer": [[87, 93], [106, 112]]}}}, {"text": "Also, you might want to check out JTextArea#append", "label": {"api": {"JTextArea#append": [[34, 49]]}}}, {"text": "You're probably interested in a FileChannel", "label": {"api": {"FileChannel": [[32, 42]]}}}, {"text": "Channels were designed to perform bulk IO operations to and from Buffers", "label": {"api": {"Buffer": [[65, 70]]}}}, {"text": "Use a WeakReference to wrap the objects before putting them in the list", "label": {"api": {"WeakReference": [[6, 18]]}}}, {"text": "I suppose you could keep a list of WeakReferences", "label": {"api": {"WeakReference": [[35, 47]]}}}, {"text": "But if you want to save a file and give the oportunity to create a folder to save it, then you can use the JFileChooser and call it in save mode", "label": {"api": {"save mode": [[135, 143]]}}}, {"text": "This doesn't work because you can't assume the result of getGenericReturnType will always be a ParameterizedType", "label": {"api": {"Type": [[73, 76], [108, 111]]}}}, {"text": "Note that getGenericReturnType may return more possible subinterfaces of Type which you will need to account for somehow, either by handling them also or throwing a runtime exception", "label": {"api": {"Type": [[26, 29], [73, 76]]}}}, {"text": "If listeners are attached, an easy way to determine the source is to call ActionEvent.getSource()", "label": {"api": {"ActionEvent.getSource()": [[74, 96]]}}}, {"text": "Use the @Override annotation, which will help highlight the error", "label": {"api": {"@Override": [[8, 16]]}}}, {"text": "Given a List<Integer>, add() each song index score times, Collections.shuffle() the list, and play in order", "label": {"api": {"Collections.shuffle()": [[58, 78]]}}}, {"text": "What about parser, have you tried out http://docs.oracle.com/javase/6/docs/api/javax/sound/midi/package-summary.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/sound/midi/package-summary.html": [[38, 115]]}}}, {"text": "The type of built-in boolean is represented by Boolean.TYPE", "label": {"api": {"Boolean.TYPE": [[47, 58]]}}}, {"text": "you can simply check the type in question for equality to Boolean.TYPE to see if the type of a parameter is built-in boolean", "label": {"api": {"Boolean.TYPE": [[58, 69]]}}}, {"text": "You could whitelist characters in a String.matches() call", "label": {"api": {"String.matches()": [[36, 51]]}}}, {"text": "Assuming that the array is already sorted, you could use the Arrays.binarySearch mechanism to perform a binary search on your array", "label": {"api": {"Arrays.binarySearch": [[61, 79]]}}}, {"text": "As an alternative to getLocationOnScreen(), you may be able to use getXOnScreen() and getYOnScreen() from a MouseEvent", "label": {"api": {"getLocationOnScreen()": [[21, 41]], "getXOnScreen()": [[67, 80]], "getYOnScreen()": [[86, 99]]}}}, {"text": "Even if you need to have the same Entity carried across requests, its pretty simple with refresh() and merge()", "label": {"api": {"refresh()": [[89, 97]], "merge()": [[103, 109]]}}}, {"text": "You need to get the edited text from the combobox editor via combo.getEditor().getItem()", "label": {"api": {"combo.getEditor().getItem()": [[61, 87]]}}}, {"text": "The obvious choice would be to use an implementation of the Set interface", "label": {"api": {"Set": [[60, 62]]}}}, {"text": "This exposes a convenient contains method, which you can use to test if a specific title exists", "label": {"api": {"contains": [[26, 33]]}}}, {"text": "You could also use an implementation of a Map, like HashMap to associate a String with an object", "label": {"api": {"HashMap": [[52, 58]]}}}, {"text": "The advantage of using a Set or a Map, is that searching for a specific key is very effective", "label": {"api": {"Set": [[25, 27]]}}}, {"text": "You can't have duplicate items in a Set", "label": {"api": {"Set": [[36, 38]]}}}, {"text": "If you insist on doing such tasks with regular expressions you might like to know that back references are represented as \\n in java instead of $n", "label": {"api": {"back references": [[87, 101]]}}}, {"text": "In Java 8 and later, the java.time package has support for parsing and manipulating date/times to nanosecond precision", "label": {"api": {"java.time": [[25, 33]]}}}, {"text": "Maybe the hitEnd of Matcher might be useful in this case", "label": {"api": {"hitEnd": [[10, 15]]}}}, {"text": "You could try to match each chunk, and if there is no match but hitEnd returns true you would have to append the next chunk and try again", "label": {"api": {"hitEnd": [[64, 69]]}}}, {"text": "While composing this answer, I recalled a venerable HTMLDocumentEditor by Charles Bell that illustrates the typical usage of the subclasses found in javax.swing.text.TextAction", "label": {"api": {"javax.swing.text.TextAction": [[149, 175]]}}}, {"text": "This related example showing actions found in StyledEditorKit follows the same approach", "label": {"api": {"StyledEditorKit": [[46, 60]]}}}, {"text": "You should not use equals to compare an Item with a string, as this would violate the equals contract", "label": {"api": {"contract": [[93, 100]]}}}, {"text": "If the JScrollPane is decorating a text component, it will automatically scroll to the bottom, but after it loads calling setCaretPosition(0) on your text component will cause it to scroll to the top", "label": {"api": {"setCaretPosition(0)": [[122, 140]]}}}, {"text": "Java already comes with SSL Sockets", "label": {"api": {"SSL Sockets": [[24, 34]]}}}, {"text": "You can implement your own SecurityManager", "label": {"api": {"SecurityManager": [[27, 41]]}}}, {"text": "Have you tried the Arrays.fill function", "label": {"api": {"Arrays.fill function": [[19, 38]]}}}, {"text": "I personally prefer the Strings.format(), simple easy to read one-line string formatter", "label": {"api": {"string formatter": [[71, 86]]}}}, {"text": "Since the argument to split() is a regular expression, you can look for one or more spaces (\" +\") instead of just one space (\" \")", "label": {"api": {"split()": [[22, 28]], "regular expression": [[35, 52]]}}}, {"text": "Since split() uses regular expressions, you can do something like s.split(\"\\\\s+\") to set the split delimiter to be any number of whitespace characters", "label": {"api": {"regular expressions": [[19, 37]]}}}, {"text": "This behavior corresponds to the documented way the valueOf method is supposed to work", "label": {"api": {"documented": [[33, 42]]}}}, {"text": "Use a Comparator and Arrays#sort", "label": {"api": {"Comparator": [[6, 15]], "Arrays#sort": [[21, 31]]}}}, {"text": "Check out FilenameFilter and File.list(FilenameFilter) or (preferably) File.listFiles(FilenameFilter)", "label": {"api": {"FilenameFilter": [[10, 23], [39, 52], [86, 99]], "File.list(FilenameFilter)": [[29, 53]]}}}, {"text": "Your reader method could be simplified by using String.matches(...) or String.regionMatches(...)", "label": {"api": {"String.matches(...)": [[48, 66]]}}}, {"text": "Both of these methods (and similar ones) are regular expression comparisons--take a look at the Pattern class, in particular", "label": {"api": {"Pattern": [[96, 102]]}}}, {"text": "Since you're repeating the same comparisons a lot, you may want to create one or more Patterns to reuse over and over, but that's just a performance optimization", "label": {"api": {"Pattern": [[86, 92]]}}}, {"text": "This is efficient since you don't have to perform many file I/O operations, and it will work because String.indexOf(String) to find strings with newline characters in them", "label": {"api": {"String.indexOf(String)": [[101, 122]]}}}, {"text": "The method Graphics2D.rotate applies transform to all subsequent rendering operations", "label": {"api": {"Graphics2D.rotate": [[11, 27]]}}}, {"text": "You can preserve a copy of transform (with getTransform()) before applying rotation, and then restore the original", "label": {"api": {"getTransform()": [[43, 56]]}}}, {"text": "Since this is a common operation, Java already provides you with a functional interface called Consumer that acts as a way to take an object of a certain type as input and do some action on it (two words so far that you already mentioned in the question", "label": {"api": {"Consumer": [[95, 102]]}}}, {"text": "Since a Consumer is a functional interface, i.e", "label": {"api": {"Consumer": [[8, 15]]}}}, {"text": "This object provides the method getRemoteAddr()", "label": {"api": {"getRemoteAddr()": [[32, 46]]}}}, {"text": "For this use case, it seems like ZipFile might be more appropriate, since that can give you the zip file's TOC", "label": {"api": {"ZipFile": [[33, 39]]}}}, {"text": "You need to get Cipher object", "label": {"api": {"Cipher": [[16, 21]]}}}, {"text": "Once you have Cipher object in decrypt mode, you can feed it with encrypted data using update methods, and it will return you plain-text data", "label": {"api": {"Cipher": [[14, 19]], "update": [[87, 92]]}}}, {"text": "When you are done, you must call one of doFinal methods to get final block", "label": {"api": {"doFinal": [[40, 46]]}}}, {"text": "Alternatively, you can create CipherInputStream  using your Cipher object, and original input stream that supplies encrypted data", "label": {"api": {"Cipher": [[30, 35], [60, 65]], "CipherInputStream": [[30, 46]]}}}, {"text": "You read data from CipherInputStream, which in turn reads data from original input stream, decrypts it, and returns you the plain-text data", "label": {"api": {"Cipher": [[19, 24]], "CipherInputStream": [[19, 35]]}}}, {"text": "For encrypting, you need to pass Cipher.ENCRYPT_MODE into Cipher.init method, and use CipherOutputStream instead", "label": {"api": {"Cipher": [[33, 38], [58, 63], [86, 91]]}}}, {"text": "You will need to install Bouncycastle extension for that and then just use Cipher.getInstance(\"Rijndael/CBC/PKCS7PADDING\");", "label": {"api": {"Cipher": [[75, 80]]}}}, {"text": "I want the thread to be interruptible even when blocking on I/O, so it seems InterruptibleChannel is a good solution", "label": {"api": {"InterruptibleChannel": [[77, 96]]}}}, {"text": "You should be using getLevel", "label": {"api": {"getLevel": [[20, 27]]}}}, {"text": "getLevel returns the number of levels above this node -- the distance from the root to this node", "label": {"api": {"getLevel": [[0, 7]]}}}, {"text": "If you have a TreeSelectionListener which handles the TreeSelectionEvent, you can use the TreeSelectionEvent#getPaths method to retrieve the selected TreePaths", "label": {"api": {"TreeSelectionEvent#getPaths": [[90, 116]]}}}, {"text": "The TreePath#getPathCount method returns the depth of the selected path", "label": {"api": {"TreePath#getPathCount": [[4, 24]]}}}, {"text": "You can also ask it directly to the JTree (although you will need the listener to be informed when the selection changes) by using the JTree#getSelectionPaths method", "label": {"api": {"JTree#getSelectionPaths": [[135, 157]]}}}, {"text": "That can be done using the Dataline.stop() method", "label": {"api": {"Dataline.stop()": [[27, 41]]}}}, {"text": "You should take a look at the join() method in the Thread class", "label": {"api": {"join() method in the Thread class": [[30, 62]]}}}, {"text": "I think using a http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/CountDownLatch.html is actually preferable over Thread.join() as it should scale better", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/CountDownLatch.html": [[16, 100]]}}}, {"text": "You can use setRejectedExectutionHandler to test if tasks are being rejected", "label": {"api": {"setRejectedExectutionHandler": [[12, 39]]}}}, {"text": "Refer to the Inet4Address javadoc for a description of what an IP address string can look like", "label": {"api": {"Inet4Address javadoc": [[13, 32]]}}}, {"text": "The method String.compareTo performs a lexicographical comparison which your original code is negating", "label": {"api": {"String.compareTo": [[11, 26]]}}}, {"text": "For example, from HashMap", "label": {"api": {"HashMap": [[18, 24]]}}}, {"text": "If your question is \"how do I print the content of an array\", you can use the Arrays.deepToString() method", "label": {"api": {"Arrays.deepToString() method": [[78, 105]]}}}, {"text": "Call validate() on the parent container, as shown in the Nested Layout Example", "label": {"api": {"validate()": [[5, 14]]}}}, {"text": "Note that calling pack() might cause the size of the GUI to change, whereas calling validate() won't", "label": {"api": {"validate()": [[84, 93]]}}}, {"text": "If you need to get the GUI to resize - call pack(), else call validate()", "label": {"api": {"validate()": [[62, 71]]}}}, {"text": "Setting an opaque component (for instance JTable) as a view for the scroll pane will give strange visual bugs, for instance moving the fixed blue box when scrolling", "label": {"api": {"JTable": [[42, 47]]}}}, {"text": "Adding an EmptyBorder to components or containers", "label": {"api": {"EmptyBorder": [[10, 20]]}}}, {"text": "Such a situation can be solved using Queues", "label": {"api": {"Queue": [[37, 41]]}}}, {"text": "The simplest solution would be to have an unbounded blocking queue (a LinkedTransferQueue is tailored for such a case) and a limited size pool of worker threads", "label": {"api": {"Queue": [[84, 88]], "LinkedTransferQueue": [[70, 88]]}}}, {"text": "You would add()/offer() the log entry from the listener's thread and take() for processing with worker threads", "label": {"api": {"add()": [[10, 14]], "offer()": [[16, 22]], "take()": [[69, 74]]}}}, {"text": "take() will block a thread if no log entries are available for processing", "label": {"api": {"take()": [[0, 5]]}}}, {"text": "A LinkedTransferQueue is designed for concurrent usage, no external synchronization is necessary", "label": {"api": {"Queue": [[16, 20]], "LinkedTransferQueue": [[2, 20]]}}}, {"text": "According to SAX parser specification, you may be getting multiple callbacks for characters, representing chunks of the same character block", "label": {"api": {"SAX parser specification": [[13, 36]]}}}, {"text": "openStream() is shorthand for openConnection().getInputStream(), where openConnection() returns URLConnection", "label": {"api": {"openStream()": [[0, 11]]}}}, {"text": "Maybe you can do your check based on the HttpServletRequest.getRequestURI() and the filename extension in this value", "label": {"api": {"HttpServletRequest.getRequestURI()": [[41, 74]]}}}, {"text": "I'm trying to use the JSlider setValue(int) to automatically move the position of the knob to the closest tick when a user finishes dragging it", "label": {"api": {"JSlider": [[22, 28]], "setValue(int)": [[30, 42]]}}}, {"text": "If you do not plan to replace the .jasper file after it was created then you could use the resources and getResourcesAsStream", "label": {"api": {"getResourcesAsStream": [[105, 124]]}}}, {"text": "Unless you are using some native allocation or using IntBuffer created as a view of a byte buffer will be direct if, and only if, the byte buffer itself is direct", "label": {"api": {"IntBuffer": [[53, 61]], "byte buffer": [[86, 96], [134, 144]]}}}, {"text": "Use System.nanoTime() instead", "label": {"api": {"System.nanoTime()": [[4, 20]]}}}, {"text": "If you read in the image as a BufferedImage, you can use the getType() method", "label": {"api": {"getType()": [[61, 69]]}}}, {"text": "Or just a plain AWT Window", "label": {"api": {"AWT Window": [[16, 25]]}}}, {"text": "If you don't care about the algorithm, use Collections.reverse()", "label": {"api": {"Collections.reverse()": [[43, 63]]}}}, {"text": "For more information read the DatatypeConverter class reference from Javadocs", "label": {"api": {"DatatypeConverter class reference": [[30, 62]]}}}, {"text": "A workaround could be to use a Map<String,Object>, and hold the properites there", "label": {"api": {"Map<String,Object>": [[31, 48]]}}}, {"text": "You can create a new ThreadGroup for the client code", "label": {"api": {"ThreadGroup": [[21, 31]]}}}, {"text": "Have a look at DecimalFormat", "label": {"api": {"DecimalFormat": [[15, 27]]}}}, {"text": "does not need to be trusted to invoke the programmatic updates part of the JNLP API", "label": {"api": {"JNLP API": [[75, 82]]}}}, {"text": "According to How to disable http caching in applet and URLConnection JavaDoc caching will be enabled when requesting a resource programatically", "label": {"api": {"URLConnection JavaDoc": [[55, 75]]}}}, {"text": "Java Util Properties is a great tool for configuration", "label": {"api": {"Properties": [[10, 19]]}}}, {"text": "You can have the file embed in the jar, if you want to, and load it using getResourceAsStream() method", "label": {"api": {"getResourceAsStream()": [[74, 94]]}}}, {"text": "If you want to get the timezone of the client on the server-side, you'll have to parse the timezone field out of the serialized date (you could split on spaces, keep the last part –the timezone part– and pass it to java.util.TimeZone.getTimeZone() prefixed with GMT)", "label": {"api": {"java.util.TimeZone.getTimeZone()": [[215, 246]]}}}, {"text": "AFAIK, there is no way to subclass TooltipManager and make it be used as the default", "label": {"api": {"TooltipManager": [[35, 48]]}}}, {"text": "I can not test this because I don't have a second display available but maybe you can try GraphicsDevice#getDefaultConfiguration()#getBounds()", "label": {"api": {"GraphicsDevice#getDefaultConfiguration()#getBounds()": [[90, 141]]}}}, {"text": "You should take a look at the API documentation of the Scanner class", "label": {"api": {"API documentation of the Scanner class": [[30, 67]]}}}, {"text": "For example, its javadoc says", "label": {"api": {"its javadoc": [[13, 23]]}}}, {"text": "You can use a ThreadPoolExecutor with a SynchronousQueue", "label": {"api": {"ThreadPoolExecutor": [[14, 31]], "SynchronousQueue": [[40, 55]]}}}, {"text": "This is described in the docs for ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[34, 51]]}}}, {"text": "Thread#join, although I prefer to use the classes found within the java.util.concurrent package", "label": {"api": {"Thread#join": [[0, 10]], "java.util.concurrent": [[67, 86]]}}}, {"text": "To give the appropriate behaviour to your MyTreeCellRenderer, you will have to extend DefaultTreecellRenderer and override the getTreeCellRendererComponent method", "label": {"api": {"DefaultTreecellRenderer": [[86, 108]], "getTreeCellRendererComponent": [[127, 154]]}}}, {"text": "I tried floatingToolFrame.setFocusableWindowState(false), which according to the doc is \"the standard mechanism for an application to identify to the AWT a Window which will be used as a floating palette or toolbar\", but the behavior remains the same", "label": {"api": {"the doc": [[77, 83]]}}}, {"text": "You're looking for Math.random", "label": {"api": {"Math.random": [[19, 29]]}}}, {"text": "Consider instead using ThreadLocalRandom in multithreaded designs", "label": {"api": {"ThreadLocalRandom": [[23, 39]]}}}, {"text": "or use ThreadLocalRandom if you're going to be using this from many threads", "label": {"api": {"ThreadLocalRandom": [[7, 23]]}}}, {"text": "It's still not going to be as random as SecureRandom of course", "label": {"api": {"SecureRandom": [[40, 51]]}}}, {"text": "Use SwingWorker, which allows you to update your TableModel as you examine your result set", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "Trim() Returns a copy of the string, with leading and trailing whitespace omitted", "label": {"api": {"Trim()": [[0, 5]]}}}, {"text": "ArrayIndexOutOfBoundsException is a subclass of Exception and should be caught there", "label": {"api": {"ArrayIndexOutOfBoundsException": [[0, 29]]}}}, {"text": "Pretty concise solution with plain Java 8 using java.util.stream", "label": {"api": {"java.util.stream": [[48, 63]]}}}, {"text": "Note there is a difference between Iterable and Iterator", "label": {"api": {"Iterable": [[35, 42]], "Iterator": [[48, 55]]}}}, {"text": "If you have an Iterable, then with Java 8 you can use this solution", "label": {"api": {"Iterable": [[15, 22]]}}}, {"text": "The simplest way is to use ProcessBuilder.redirectErrorStream() when you create your process", "label": {"api": {"ProcessBuilder.redirectErrorStream()": [[27, 62]]}}}, {"text": "You can use java nio's WatchService to get asynchronous notifications if a file/directory has changed", "label": {"api": {"java nio's WatchService": [[12, 34]]}}}, {"text": "To get it to run Java, you'd need to create a ScriptEngine implementation which could take the source, run it through the compiler API ( http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html ), and execute it", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/tools/JavaCompiler.html": [[137, 206]]}}}, {"text": "From the docs for java.math.BigInteger(byte[])", "label": {"api": {"java.math.BigInteger(byte[])": [[18, 45]]}}}, {"text": "perhaps by using the constructor that takes a String parameter", "label": {"api": {"constructor that takes a String parameter": [[21, 61]]}}}, {"text": "You are using conn.setChunkedStreamingMode(100) that will effectively enable the chunked transfer encoding in chunks of 100 bytes when the content-lenght is unknown in advance", "label": {"api": {"conn.setChunkedStreamingMode(100)": [[14, 46]]}}}, {"text": "Use conn.setFixedLengthStreamingMode(int len) if you know in advance the length of the content you are going to send in the body of the request", "label": {"api": {"conn.setFixedLengthStreamingMode(int len)": [[4, 44]]}}}, {"text": "To make a JPanel appear rounded, you need to make your own class that extends JPanel, override paintComponent and draw the panel as an ellipse Javadoc here This will create a customized object which is an JPanel", "label": {"api": {"Javadoc here": [[143, 154]]}}}, {"text": "Especially BorderFactory.createEmptyBorder(int top, int left, int bottom, int right) might be helpfull", "label": {"api": {"BorderFactory.createEmptyBorder(int top, int left, int bottom, int right)": [[11, 83]]}}}, {"text": "When we look at the spec for a BitSet, we can see that it is composed of boolean values", "label": {"api": {"BitSet": [[31, 36]]}}}, {"text": "By the reference above, this seems to suggest that the \"size\" of a BitSet is undefined - it's composed of boolean values, after all", "label": {"api": {"BitSet": [[67, 72]]}}}, {"text": "So my question is, why not implement a BitSet using another datatype that is precisely defined", "label": {"api": {"BitSet": [[39, 44]]}}}, {"text": "If we have a system that absolutely cannot exceed a certain memory capacity, it seems useful to have a BitSet implementation that is precise in terms of size", "label": {"api": {"BitSet": [[103, 108]]}}}, {"text": "See BufferedImage.html#getSubimage(x,y,,w,h) for the sub-image", "label": {"api": {"BufferedImage.html#getSubimage(x,y,,w,h)": [[4, 43]]}}}, {"text": "To gain a BufferedImage, use ImageIO.read(File/InputStream/URL)", "label": {"api": {"ImageIO.read(File/InputStream/URL)": [[29, 62]]}}}, {"text": "Use a JList", "label": {"api": {"JList": [[6, 10]]}}}, {"text": "The Drag'n'Drop package is where to look for the functionality to re-order the list", "label": {"api": {"Drag'n'Drop": [[4, 14]]}}}, {"text": "As stated in the api", "label": {"api": {"api": [[17, 19]]}}}, {"text": "Note that the use of @Override here is just good practice, but unrelated to the question", "label": {"api": {"@Override": [[21, 29]]}}}, {"text": "You can create a Document from your String using a method like that", "label": {"api": {"Document": [[17, 24]]}}}, {"text": "Then you can use that Document and get the data you need to populate your JTable", "label": {"api": {"Document": [[22, 29]]}}}, {"text": "To learn what row was selected, add a ListSelectionListener, as shown in How to Use Tables in the example SimpleTableSelectionDemo", "label": {"api": {"ListSelectionListener": [[38, 58]]}}}, {"text": "In the Java 7 API, the network properties the article mentions are no longer listed", "label": {"api": {"Java 7 API": [[7, 16]]}}}, {"text": "LinkedTransferQueue is a blocking, unbounded queue that doesn't enforce strict FIFO ordering", "label": {"api": {"LinkedTransferQueue": [[0, 18]]}}}, {"text": "You can use LinkedBlockingQueue with the non-blocking methods offer (or add) and poll to access it", "label": {"api": {"LinkedBlockingQueue": [[12, 30]]}}}, {"text": "Pay attention that accept() is not thread safe, so the call is wrapped within synchronized", "label": {"api": {"accept()": [[19, 26]]}}}, {"text": "This example shows that editable file names is a feature of the FileChooserUI implementation", "label": {"api": {"FileChooserUI": [[64, 76]]}}}, {"text": "For example, com.apple.laf.AquaFileChooserUI does not have this capability", "label": {"api": {"FileChooserUI": [[31, 43]]}}}, {"text": "AppClay's answer is absolutely correct, but if you are interested in \"tidying it up\", create a helper that implements Comparator", "label": {"api": {"Comparator": [[118, 127]]}}}, {"text": "Not only does this make the code easier to read and test, it's now trivial to swap out different Comparator implementations as needed", "label": {"api": {"Comparator": [[97, 106]]}}}, {"text": "The collections API doesn't allow that", "label": {"api": {"doesn't allow that": [[20, 37]]}}}, {"text": "The reason mainFrame.repaint() forces the map to refresh is because repaint() calls repaint(0, 0, 0, width, height), which marks the entire mainFrame's area to be marked as \"dirty\" for the RepaintManager", "label": {"api": {"repaint(0, 0, 0, width, height)": [[84, 114]], "RepaintManager": [[189, 202]]}}}, {"text": "So, in onTick(), when mainFrame.paintAll() is being called, my guess is that the mapPanel's area has not been marked dirty, so the RepaintManager skips it, to save processing time", "label": {"api": {"RepaintManager": [[131, 144]]}}}, {"text": "Create and initialize ExecutorService then onClick you can create any instance of your own class that implements Runnable interface", "label": {"api": {"ExecutorService": [[22, 36]]}}}, {"text": "Point of it is to avoid create too many threads, by specifying number (size) of the pool (ExecutorService", "label": {"api": {"ExecutorService": [[90, 104]]}}}, {"text": "You would have to call intern() on it first", "label": {"api": {"intern()": [[23, 30]]}}}, {"text": "From the String Javadoc", "label": {"api": {"String Javadoc": [[9, 22]]}}}, {"text": "Create a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[9, 22]], "Process": [[9, 15]]}}}, {"text": "Call for the Process", "label": {"api": {"Process": [[13, 19]]}}}, {"text": "BTW - When (not if) you run into problems using a Process, see When Runtime.exec() won't & implement all the suggestions", "label": {"api": {"Process": [[50, 56]]}}}, {"text": "I suggest using ProcessBuilder instead of Runtime", "label": {"api": {"ProcessBuilder": [[16, 29]]}}}, {"text": "To add a limit to your JTextComponent, simply write the following line of code", "label": {"api": {"JTextComponent": [[23, 36]]}}}, {"text": "If you're building a desktop application and these are basically user preferences, you should look into the Preferences API", "label": {"api": {"Preferences API": [[108, 122]]}}}, {"text": "Perhaps the high-scores would be better stored using the Preferences API", "label": {"api": {"Preferences": [[57, 67]]}}}, {"text": "Perhaps the StringTokenizer class is a better fit for your need", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "You should use listFiles which returns File[] instead of list which returns String[]", "label": {"api": {"listFiles": [[15, 23]]}}}, {"text": "As creme de la creme with regard to performance, you could use NIO Channels and a directly allocated ByteBuffer", "label": {"api": {"Channels": [[67, 74]], "ByteBuffer": [[101, 110]]}}}, {"text": "DateFormat already allows you to do this - just use DateTimeFormat.getDateTimeInstance(dateStyle, timeStyle, locale) or something similar, depending on your needs", "label": {"api": {"DateTimeFormat.getDateTimeInstance(dateStyle, timeStyle, locale)": [[52, 115]]}}}, {"text": "You can use the JPA Criteria API to accomplish this", "label": {"api": {"JPA Criteria API": [[16, 31]]}}}, {"text": "Assuming TypedQuery, you would use setFirstResult and setLastResult to limit the records returned from the database", "label": {"api": {"TypedQuery": [[9, 18]]}}}, {"text": "You might want to use a Scanner and specifically Scanner.nextInt() and Scanner.hasNextInt() for this", "label": {"api": {"Scanner": [[24, 30], [49, 55], [71, 77]], "Scanner.nextInt()": [[49, 65]], "Scanner.hasNextInt()": [[71, 90]]}}}, {"text": "See this tutorial on measuring text, which is heavily focused on FontMetrics", "label": {"api": {"FontMetrics": [[65, 75]]}}}, {"text": "The more advanced measurements (to get the bounding box of a particular string), then TextLayout is your friend, as explained here", "label": {"api": {"TextLayout": [[86, 95]]}}}, {"text": "In addition to that tutorial on TextLayout, the javadoc contains examples of its use", "label": {"api": {"TextLayout": [[32, 41]]}}}, {"text": "If you are using Point3D to represent your points then you have a distance method you can use to calculate the distance", "label": {"api": {"Point3D": [[17, 23]]}}}, {"text": "Also, the AtomicInteger class works just fine on multicore architectures", "label": {"api": {"AtomicInteger": [[10, 22]]}}}, {"text": "You might want to use Scanner.nextLine() to read an entire line", "label": {"api": {"Scanner.nextLine()": [[22, 39]]}}}, {"text": "Your custom input component must surely already extend UIInput, otherwise you've many other (future) problems and/or you'll waste time in writing repeated code", "label": {"api": {"UIInput": [[55, 61]]}}}, {"text": "If your custom input component extends UIInput, then you can just add the Validator by the inherited UIInput#addValidator() method in for example the component's constructor", "label": {"api": {"UIInput": [[39, 45], [101, 107]], "UIInput#addValidator()": [[101, 122]]}}}, {"text": "The already-implemented UIInput#validate() method will do all the conversion, validation and message handling automagically", "label": {"api": {"UIInput": [[24, 30]], "UIInput#validate()": [[24, 41]]}}}, {"text": "Set the white image as the icon and the yellow image as the roll-over icon", "label": {"api": {"roll-over icon": [[60, 73]]}}}, {"text": "Similar API design choice can be observed with Future.get() - in case of exception thrown from asynchronous job ExecutionException is thrown wrapping the actual exception", "label": {"api": {"Future.get()": [[47, 58]], "ExecutionException": [[112, 129]]}}}, {"text": "Create a URL object and then use the methods provided to grab whatever you need", "label": {"api": {"URL": [[9, 11]]}}}, {"text": "The signature is", "label": {"api": {"signature": [[4, 12]]}}}, {"text": "How about using ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[16, 36]]}}}, {"text": "A ConcurrentLinkedQueue is an appropriate choice when many threads will share access to a common collection", "label": {"api": {"ConcurrentLinkedQueue": [[2, 22]]}}}, {"text": "Once you have read the image to a byte array, you might be able to use the BufferedImage class to make it usable for Java", "label": {"api": {"the BufferedImage class": [[71, 93]]}}}, {"text": "A GZIPOutputStream can accept an OutputStream, so 'yes'", "label": {"api": {"GZIPOutputStream": [[2, 17]]}}}, {"text": "checkout ConcurrentHashMap.putIfAbsent() which will provide all you need for storing and retrieving synchronously", "label": {"api": {"ConcurrentHashMap.putIfAbsent()": [[9, 39]]}}}, {"text": "You'll find plenty of examples with custom format in SimpleDateFormat, a simple example with built-in format", "label": {"api": {"SimpleDateFormat": [[53, 68]]}}}, {"text": "Have you considered the ForkJoinPool", "label": {"api": {"ForkJoinPool": [[24, 35]]}}}, {"text": "The call yaml.dump() does not create a file, rather returns a string (which you can then put into a file)", "label": {"api": {"put into a file": [[89, 103]]}}}, {"text": "List is just an interface, you should use a concrete implementation when creating an instance, such as ArrayList for example", "label": {"api": {"List": [[0, 3], [108, 111]], "ArrayList": [[103, 111]]}}}, {"text": "One example is given by one of our trainers when he was explaining difference between CountDownLatch and CyclicBarrier", "label": {"api": {"CountDownLatch": [[86, 99]], "CyclicBarrier": [[105, 117]]}}}, {"text": "You can use Runtime.exec() for executing external commands of the operating system", "label": {"api": {"Runtime.exec()": [[12, 25]]}}}, {"text": "If that's too simplistic for your needs, take a look at ProcessBuilder", "label": {"api": {"ProcessBuilder": [[56, 69]]}}}, {"text": "The new ProcessBuilder class provides a more convenient way to invoke subprocesses than does Runtime.exec", "label": {"api": {"ProcessBuilder": [[8, 21]]}}}, {"text": "In particular, ProcessBuilder makes it easy to start a subprocess with a modified process environment (that is, one based on the parent's process environment, but with a few changes)", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "The doc on renameTo and delete give some limited insight", "label": {"api": {"renameTo and delete": [[11, 29]]}}}, {"text": "One option is to use javax.swing.Box, which uses a BoxLayout and provides convenient methods such as", "label": {"api": {"javax.swing.Box": [[21, 35]]}}}, {"text": "See javax.swing.Box for the API", "label": {"api": {"javax.swing.Box": [[4, 18]]}}}, {"text": "I'd suggest a either GroupLayout or a Nested Layout for this layout", "label": {"api": {"GroupLayout": [[21, 31]]}}}, {"text": "You can set the value for the key Action.NAME to null or an empty String", "label": {"api": {"Action.NAME": [[34, 44]]}}}, {"text": "The methods include the usual sin, cos, tan methods required to calculate the height of the pixel needed for the top vertex", "label": {"api": {"methods": [[4, 10], [44, 50]]}}}, {"text": "But beware, those methods take angles in radians, so it will be necessary to convert them from degrees to radians when using them", "label": {"api": {"methods": [[18, 24]]}}}, {"text": "Math.PI will be helpful for that", "label": {"api": {"Math.PI": [[0, 6]]}}}, {"text": "Specifically, look at the methods Class and Method provide in the Java API", "label": {"api": {"Class": [[34, 38]], "Method": [[44, 49]]}}}, {"text": "A ByteBuffer can be configured to decode multi-byte values as either big or little endian using the order() method", "label": {"api": {"ByteBuffer": [[2, 11]], "order()": [[100, 106]]}}}, {"text": "In your TreeSelectionListener, use an instance of SwingWorker to update your JTable's TableModel in the background", "label": {"api": {"SwingWorker": [[50, 60]]}}}, {"text": "But as Mark Byers mentions the Integer class is immutable and you could use MutableInt from Apache Commons library", "label": {"api": {"Integer": [[31, 37]]}}}, {"text": "In your case you want to change a Vector object..", "label": {"api": {"Vector": [[34, 39]]}}}, {"text": "Take a look at ServiceLoader", "label": {"api": {"ServiceLoader": [[15, 27]]}}}, {"text": "canRead, canWrite, etc", "label": {"api": {"canRead": [[0, 6]]}}}, {"text": "Both new GregorianCalendar() and Calendar.getInstance() will correctly give a calendar initialized at the current date and time", "label": {"api": {"Calendar": [[18, 25], [33, 40]]}}}, {"text": "MONTH and YEAR are constants within the Calendar class", "label": {"api": {"Calendar": [[40, 47]]}}}, {"text": "It's an unfortunate part of the design of the Calendar class that to access the values of different fields, you need to call get with a field number, specified as one of those constants, as shown in other answers", "label": {"api": {"Calendar": [[46, 53]]}}}, {"text": "If your IDE allows it (as Eclipse does), make expressions such as c.YEAR give a compile-time error - you'll end up with much clearer code if you always use Calendar.YEAR", "label": {"api": {"Calendar": [[156, 163]]}}}, {"text": "You can call String.intern() to acquire the shared string object in the string pool", "label": {"api": {"String.intern()": [[13, 27]]}}}, {"text": "I think you want to look into the RandomAccessFile", "label": {"api": {"RandomAccessFile": [[34, 49]]}}}, {"text": "To guarantee the write is on disk, you need to use force()", "label": {"api": {"force()": [[51, 57]]}}}, {"text": "You can set the default close operation for your internal frames and then when you are closing the view call doDefaultCloseAction which fires an Event", "label": {"api": {"doDefaultCloseAction": [[109, 128]]}}}, {"text": "You can use a List  [specifically an ArrayList] to hold the elements, and use Collections.sort() to sort it when you are done populating it", "label": {"api": {"List": [[14, 17], [42, 45]], "ArrayList": [[37, 45]], "Collections.sort()": [[78, 95]]}}}, {"text": "Sometimes a PriorityQueue is also a good option - if what you actually need is to maintain the smallest/biggest element in the collection", "label": {"api": {"PriorityQueue": [[12, 24]]}}}, {"text": "You can filter your input to ignore any non-alphabetic characters before counting them (or filter your map similarly before printing the result)", "label": {"api": {"filter your input": [[8, 24]]}}}, {"text": "Alternatively, you can use Character.isLetter(char c) method to determine whether a character is really a letter", "label": {"api": {"Character.isLetter(char c)": [[27, 52]]}}}, {"text": "Instead of implementing your own, how about using java.util.concurrent.Semaphore which is build into the Java Standard Library", "label": {"api": {"java.util.concurrent.Semaphore": [[50, 79]]}}}, {"text": "Irrespectively, you should to invoke a SwingWorker or such to create a thread to do the processing that takes a long time, then use the EDT to display the result", "label": {"api": {"SwingWorker": [[39, 49]]}}}, {"text": "Import java.util.ArrayList, and use the ArrayList data structure instead of a normal array", "label": {"api": {"ArrayList": [[17, 25], [40, 48]]}}}, {"text": "To sort a Map by its values, you could grab its entrySet and sort that with a custom Comparator", "label": {"api": {"entrySet": [[48, 55]], "Comparator": [[85, 94]]}}}, {"text": "You should also take a look at PreparedStatement as that's a much better solution", "label": {"api": {"PreparedStatement": [[31, 47]]}}}, {"text": "I stumbled upon InheritableThreadLocal, which I think could work for my code", "label": {"api": {"InheritableThreadLocal": [[16, 37]]}}}, {"text": "You should use the ResponseBuilder instead", "label": {"api": {"ResponseBuilder": [[19, 33]]}}}, {"text": "You are calling the read() method on FileInputStream", "label": {"api": {"read()": [[20, 25]]}}}, {"text": "Alternatively, you could read a chunk of the file into a buffer and iterate over the buffer using read(byte[],int,int)", "label": {"api": {"read(byte[],int,int)": [[98, 117]]}}}, {"text": "You can use setRolloverIcon", "label": {"api": {"setRolloverIcon": [[12, 26]]}}}, {"text": "You could use a ScheduledExecutorService, which is part of the standard JDK since 1.5", "label": {"api": {"ScheduledExecutorService, which is part of the standard JDK since 1.5": [[16, 84]]}}}, {"text": "The java.nio.channels.FileLock can help you match all three points (including the abnormal termination case)", "label": {"api": {"java.nio.channels.FileLock": [[4, 29]]}}}, {"text": "You should rather use a SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "See DateFormat class here for more info", "label": {"api": {"DateFormat class here": [[4, 24]]}}}, {"text": "There are many such interfaces, such as org.w3c.dom.Node", "label": {"api": {"org.w3c.dom.Node": [[40, 55]]}}}, {"text": "A good example is Collections.shuffle(List) - I can provide that any list implementation, and it will only use the methods declared in the interface", "label": {"api": {"Collections.shuffle(List)": [[18, 42]]}}}, {"text": "Check out InputStream's methods which read bytes into an array or SocketChannel from nio which uses ByteBuffers", "label": {"api": {"InputStream's methods which read bytes into an array": [[10, 61]]}}}, {"text": "Not sure if I quite get your question, but if I do, have you tried the Calendar object", "label": {"api": {"Calendar": [[71, 78]]}}}, {"text": "To print arrays in a user-friendly manner, you need to loop over the array items or you can use the Arrays.deepToString method", "label": {"api": {"Arrays.deepToString method": [[100, 125]]}}}, {"text": "You problem is that the newInstance method is diamond function (i.e", "label": {"api": {"method": [[36, 41]]}}}, {"text": "Taking a look at the JavaDoc for the writeObject() method", "label": {"api": {"writeObject()": [[37, 49]]}}}, {"text": "You could use a blocking queue and in your third wing, you try to poll from the queue and it will block until some element gets added", "label": {"api": {"blocking queue": [[16, 29]]}}}, {"text": "In your particular example, all submitted values are as a string array available by HttpServletRequest#getParameterValues(), in the exact same order as the inputs appear in the HTML markup", "label": {"api": {"HttpServletRequest#getParameterValues()": [[84, 122]]}}}, {"text": "The JDK7 SwingWorker javadoc hints that the designers did not intend for users to directly interact with or alter the background threads", "label": {"api": {"SwingWorker javadoc": [[9, 27]]}}}, {"text": "Have a look at using SwingUtilities.invokeLater(Runnable) to perform the tasks where the Swing components are updated", "label": {"api": {"SwingUtilities.invokeLater(Runnable)": [[21, 56]]}}}, {"text": "Other than that, here's the quick win you're looking for - switch from Stack to Deque, namely ArrayDeque", "label": {"api": {"Deque": [[80, 84], [99, 103]], "ArrayDeque": [[94, 103]]}}}, {"text": "(Streaming is sort of the opposite of random access.) Have a look at RandomAccessFile instead", "label": {"api": {"RandomAccessFile": [[69, 84]]}}}, {"text": "You need to specify the radix", "label": {"api": {"specify the radix": [[12, 28]]}}}, {"text": "You need the Map#values() method which returns a Collection", "label": {"api": {"Map#values()": [[13, 24]]}}}, {"text": "You need to override Object#toString() in your Administrator class", "label": {"api": {"Object#toString()": [[21, 37]]}}}, {"text": "You need the Pattern.DOTALL switch, and a match for whitespace (\"\\\\s+\"), rather than a literal space", "label": {"api": {"Pattern.DOTALL": [[13, 26]]}}}, {"text": "Also note that despite its name, the Pattern.MULTILINE switch won't help you here", "label": {"api": {"Pattern.MULTILINE": [[37, 53]]}}}, {"text": "See the javadoc for public String substring(int beginIndex, int endIndex)", "label": {"api": {"javadoc for public String substring(int beginIndex, int endIndex)": [[8, 72]]}}}, {"text": "You can simulate key presses quite easily using the Robot class, it has methods to press and release keys", "label": {"api": {"press and release keys": [[83, 104]]}}}, {"text": "Alternatively, if you can use DOM level 3, you can use the Node.getTextContent() method instead which does what you want", "label": {"api": {"Node.getTextContent()": [[59, 79]]}}}, {"text": "The Random class has a nextInt(int n) method, and the List interface has a size() method", "label": {"api": {"nextInt(int n)": [[23, 36]]}}}, {"text": "If you need to access this information at runtime, you can use the JMX management beans, specifically  RuntimeMXBean.getInputArguments", "label": {"api": {"RuntimeMXBean.getInputArguments": [[103, 133]]}}}, {"text": "the current heap memory", "label": {"api": {"current heap memory": [[4, 22]]}}}, {"text": "That being said, for basic tasks, you should use a ScheduledExecutorService like this", "label": {"api": {"ScheduledExecutorService": [[51, 74]]}}}, {"text": "You can use a SynchronousQueue in your ThreadPoolExector which is a queue which holds no objects", "label": {"api": {"SynchronousQueue": [[14, 29]]}}}, {"text": "If it cannot be queued but I would suggest using the RejectedExecutionHandler to run the task in the current thread", "label": {"api": {"RejectedExecutionHandler": [[53, 76]]}}}, {"text": "If you want to take it one step further, you could consider using ThreadPoolExecutor to handle your Threading strategy", "label": {"api": {"ThreadPoolExecutor": [[66, 83]]}}}, {"text": "Accessing the file system should work fine however, if you truly want to comply with the spec you could bundle the file inside the EJB jar and access it from the classpath using Class.getResourceAsStream", "label": {"api": {"Class.getResourceAsStream": [[178, 202]]}}}, {"text": "Java uses explicit exception handling - except of RuntimeExceptions, every exception thrown [by the method itself, or a method it invokes declares it throws it]- must be handle or declared in the method signature", "label": {"api": {"RuntimeException": [[50, 65]]}}}, {"text": "You need to look into the POSIX character classes to catch those", "label": {"api": {"POSIX character classes": [[26, 48]]}}}, {"text": "that has a GUI can be launched using Java Web Start & use the PersistenceService", "label": {"api": {"PersistenceService": [[62, 79]]}}}, {"text": "An implementation of ImageIO supports a minimum of JPEG, PNG, BMP, WBMP and GIF", "label": {"api": {"supports a minimum of JPEG, PNG, BMP, WBMP and GIF": [[29, 78]]}}}, {"text": "The rules for converting from the method names to property names are specified in 'Introspector.decpitalize` which is part of the java bean standard", "label": {"api": {"'Introspector.decpitalize`": [[82, 107]]}}}, {"text": "Change each string to a charArray", "label": {"api": {"charArray": [[24, 32]]}}}, {"text": "Looking at the Runtime.java and ProcessBuilder.java sources, Runtime.exec(String) splits the string out using a StringTokenizer, which uses default delimiters of \" \\t\\n\\r\\f\"", "label": {"api": {"StringTokenizer": [[112, 126]]}}}, {"text": "Contrary to what you might guess, Arrays.asList() does not return an ArrayList", "label": {"api": {"Arrays.asList()": [[34, 48]], "ArrayList": [[69, 77]], "List": [[43, 46], [74, 77]]}}}, {"text": "In other words, the List returned by Arrays.asList() should be considered a Collection-like view of the array rather than a new list backed by an array", "label": {"api": {"Arrays.asList()": [[37, 51]], "List": [[20, 23], [46, 49]]}}}, {"text": "Which will use an ArrayList, which is a proper full implementation of List", "label": {"api": {"ArrayList": [[18, 26]], "List": [[23, 26], [70, 73]]}}}, {"text": "Incidentally, you might take a look at this blog post that delves a little more into the actual implementation of the class returned by Arrays.asList()", "label": {"api": {"Arrays.asList()": [[136, 150]], "List": [[145, 148]]}}}, {"text": "It's also worth noting that throwing an UnsupportedOperationException is documented behavior for List.add()", "label": {"api": {"List": [[97, 100]], "documented behavior for List.add()": [[73, 106]]}}}, {"text": "This may seem to violate the expected nature of an interface, but the Java List class actually offers a number of methods (add(), addAll(), remove(), clear(), etc., basically, the methods intended to change the underlying stored list) that implementations can optionally not implement by simply throwing an UnsupportedOperationException", "label": {"api": {"List": [[75, 78]]}}}, {"text": "The main practical difference was simply that Scanner wasn't introduced until 1.5, and thus before that you had no choice but to to wrap System.in round various readers and then parse the output yourself to retrieve what you wanted", "label": {"api": {"Scanner": [[46, 52]]}}}, {"text": "Scanner manages a lot of this now for you, so unless you have a compelling reason to use BufferedReader and parse / process things entirely by yourself, I'd generally default to using Scanner - if nothing else because it makes the code clearer", "label": {"api": {"Scanner": [[0, 6], [184, 190]]}}}, {"text": "You could implement a custom servlet filter that would replace request, response and session objects with your own wrappers", "label": {"api": {"servlet filter": [[29, 42]]}}}, {"text": "Since it needs to be serializable and send it across a network connection a CachedRowSet seems to be a good option for you to try", "label": {"api": {"CachedRowSet": [[76, 87]]}}}, {"text": "JSF uses by default the one as obtained from ServletRequest#getCharacterEncoding()", "label": {"api": {"ServletRequest#getCharacterEncoding()": [[45, 81]]}}}, {"text": "This is normally overrideable by some custom filter which calls request.setCharacterEncoding()", "label": {"api": {"request.setCharacterEncoding()": [[64, 93]]}}}, {"text": "Given the incorrect charset, this can only mean that your web application is somewhere calling request.setCharacterEncoding() with \"UTF8\" instead of \"UTF-8\"", "label": {"api": {"request.setCharacterEncoding()": [[95, 124]]}}}, {"text": "Timer mentioned in Ozzy's answer should not be used any more as it has been improved in Java 1.5 by ScheduledThreadPoolExecutor, as explained in Timer's javadoc", "label": {"api": {"Timer's javadoc": [[145, 159]]}}}, {"text": "From the documentation for SecondaryLoop, it is not clear when you should use this new feature instead of a SwingWorker, a few examples of interesting cases would be useful", "label": {"api": {"SecondaryLoop": [[27, 39]], "SwingWorker": [[108, 118]]}}}, {"text": "DocumentFilter is a good solution for your case", "label": {"api": {"DocumentFilter": [[0, 13]]}}}, {"text": "Providing custom DocumentFilter should easily accommodate the requirement to strip off the unwanted characters upon copy/pase as you have specified in one of the comments", "label": {"api": {"DocumentFilter": [[17, 30]]}}}, {"text": "Also consider InputVerifier, discussed in How to Use the Focus Subsystem", "label": {"api": {"InputVerifier": [[14, 26]]}}}, {"text": "You can attach an object to the current request with setAttribute", "label": {"api": {"setAttribute": [[53, 64]]}}}, {"text": "Just set the necessary data in the request scope and use RequestDispatcher#forward() to forward the control to the desired JSP which in turn can generate the appropriate HTML based on the results", "label": {"api": {"RequestDispatcher#forward()": [[57, 83]]}}}, {"text": "If you want to get specific line from the file, and you already have access to the offset of the line you want to read, you can use RandomAccessFile", "label": {"api": {"RandomAccessFile": [[132, 147]]}}}, {"text": "However, if you want to read a specific line but have no information where that line could be in the input file, you will need to read each line (eg., using a BufferedReader) to find the one you need", "label": {"api": {"BufferedReader": [[159, 172]]}}}, {"text": "If so, you should be able to wrap your IOException in a RuntimeException and throw that instead", "label": {"api": {"RuntimeException": [[56, 71]]}}}, {"text": "Since Java 7 we have OpenOption", "label": {"api": {"OpenOption": [[21, 30]]}}}, {"text": "Of particular interest is StandardOpenOptions.CREATE_NEW", "label": {"api": {"OpenOption": [[34, 43]], "StandardOpenOptions.CREATE_NEW": [[26, 55]]}}}, {"text": "See methods like File.listFiles(FilenameFilter)", "label": {"api": {"File.listFiles(FilenameFilter)": [[17, 46]]}}}, {"text": "In Java, just use replaceAll(String pattern,String replacement) method on a string, like below", "label": {"api": {"replaceAll(String pattern,String replacement)": [[18, 62]]}}}, {"text": "file.length() returns the length of the file in bytes, as described in the Java 7 Documentation", "label": {"api": {"Java 7 Documentation": [[75, 94]]}}}, {"text": "It looks like you could draw an Arc2D to get the effect you want", "label": {"api": {"Arc2D": [[32, 36]]}}}, {"text": "Once this is done, you have the objects in your standalone application through which using object.getClass().getAnnotations(), you can then inject the listeners or custom behavior you need to add to the objects holding the custom annotations", "label": {"api": {"object.getClass().getAnnotations()": [[91, 124]]}}}, {"text": "The format is described in the java.util.Properties documentation", "label": {"api": {"java.util.Properties documentation": [[31, 64]]}}}, {"text": "You call Thread.interrupt(), and then react to the interrupted status or InterruptedException within the thread that's being interrupted", "label": {"api": {"Thread.interrupt()": [[9, 26]]}}}, {"text": "Along that line, you might find WeakReferences helpful", "label": {"api": {"WeakReference": [[32, 44]]}}}, {"text": "Keep the acceptable values in a HashSet and check if your string exists using the contains method", "label": {"api": {"contains": [[82, 89]]}}}, {"text": "The List interface already has this solved", "label": {"api": {"List": [[4, 7]]}}}, {"text": "More can be found in the documentation about List", "label": {"api": {"List": [[45, 48]]}}}, {"text": "This works in Java 1.6, for more information, look at the File class documentation", "label": {"api": {"File class documentation": [[58, 81]]}}}, {"text": "Se also the API description", "label": {"api": {"API description": [[12, 26]]}}}, {"text": "Put the numbers into a Set", "label": {"api": {"Set": [[23, 25]]}}}, {"text": "Then retrieve numbers from the Set", "label": {"api": {"Set": [[31, 33]]}}}, {"text": "You could use a TreeSet (which automatically sorts all entries added from least to greatest) to store the deleted id's (myTreeSet.add(old_id))", "label": {"api": {"TreeSet": [[16, 22], [122, 128]]}}}, {"text": "That way, when you go to create a new instance, you would check to see if there are any entries in the TreeSet first", "label": {"api": {"TreeSet": [[103, 109]]}}}, {"text": "To grab the lowest value, you would use myTreeSet.first() (which should be an O(1) operation)", "label": {"api": {"TreeSet": [[42, 48]]}}}, {"text": "If the TreeSet is empty, which means all known id's are currently in use, then you would go ahead and use the next available id as normal", "label": {"api": {"TreeSet": [[7, 13]]}}}, {"text": "How about a TreeSet to store the used IDs", "label": {"api": {"TreeSet": [[12, 18]]}}}, {"text": "You could then use higher(0) to find the lowest free ID", "label": {"api": {"higher(0)": [[19, 27]]}}}, {"text": "To learn more about this including sample code, please have a look at the CardLayout Tutorial, and the API", "label": {"api": {"API": [[103, 105]]}}}, {"text": "Create a Thread, and override runnable", "label": {"api": {"Thread": [[9, 14]]}}}, {"text": "When you invoke start() on the thread, each thread will be invoked parallel of each other", "label": {"api": {"start()": [[16, 22]]}}}, {"text": "You could use a ConcurrentSkipListMap which can provide forward and reverse iterators over the keys", "label": {"api": {"ConcurrentSkipListMap": [[16, 36]]}}}, {"text": "Or you can always keep a simple HashMap or whatever to maintain parallel item associations, and then construct a SortedMap (Treemap or ConcurrentSkipListMap) as needed by providing an appropriate Comparator", "label": {"api": {"ConcurrentSkipListMap": [[135, 155]]}}}, {"text": "A LinkedList can be used as a Queue - but you need to use it right", "label": {"api": {"LinkedList": [[2, 11]]}}}, {"text": "Remember, if you use push instead of add ( which you will very likely do intuitively ), this will add element at the front of the list, making it behave like a stack", "label": {"api": {"push": [[21, 24]], "add": [[37, 39], [98, 100]]}}}, {"text": "So this is a Queue only if used in conjunction with add", "label": {"api": {"add": [[52, 54]]}}}, {"text": "I know that the javadoc of setForeground() is clear about the fact that the L&F might ignore the call, so I'm looking for a workaround", "label": {"api": {"javadoc of setForeground()": [[16, 41]]}}}, {"text": "If you use the Scanner class, it would make your life so much easier", "label": {"api": {"Scanner": [[15, 21]]}}}, {"text": "Use java.lang.Class.getFields(), iterate through the array, get each value (using Field.get(null)), check if it's already in a Set, and store it in the Set if it's not there already", "label": {"api": {"java.lang.Class.getFields()": [[4, 30]], "Field.get(null)": [[82, 96]]}}}, {"text": "resource bundles are cached, you can call clearCache, unfortunately not per bundle but per class loader", "label": {"api": {"resource bundles": [[0, 15]]}}}, {"text": "You may want to use NetworkInterface class", "label": {"api": {"NetworkInterface": [[20, 35]]}}}, {"text": "In particular, use static getNetworkInterfaces method to enumerate all available network interfaces", "label": {"api": {"NetworkInterface": [[29, 44]], "getNetworkInterfaces": [[26, 45]]}}}, {"text": "See HTMLEditorKit for details", "label": {"api": {"HTMLEditorKit": [[4, 16]]}}}, {"text": "Replace the call to base64Encode(...) with new String(...) and base64Decode(s) with s.getBytes() in order to get the original XORed String", "label": {"api": {"getBytes()": [[86, 95]], "new String(...)": [[43, 57]]}}}, {"text": "Even after that change, it is possible that getBytes() returns a byte array longer that the string length, depending on the platform default charset", "label": {"api": {"getBytes()": [[44, 53]]}}}, {"text": "Similarly, new String(...) might fail to produce the expected characters, because the given bytes are not valid for the platform default encoding", "label": {"api": {"new String(...)": [[11, 25]]}}}, {"text": "For the contents use one of the Arrays.toString() methods", "label": {"api": {"Arrays.toString() methods": [[32, 56]]}}}, {"text": "You could put your config in a final AtomicReference", "label": {"api": {"AtomicReference": [[37, 51]]}}}, {"text": "If it's not important for all your config to change at the same time, you could skip the ServerConf class and use AtomicInteger for the port setting, and AtomicReference<File> for the root", "label": {"api": {"AtomicReference": [[154, 168]], "AtomicInteger": [[114, 126]]}}}, {"text": "The most correct way to convert a single digit character to an int is Character.digit(char ch, int radix), which can handle values in bases besides 10", "label": {"api": {"Character.digit(char ch, int radix)": [[70, 104]]}}}, {"text": "Also, consider returning a copy as an ImmutableList or at least as an unmodifiable list", "label": {"api": {"unmodifiable list": [[70, 86]]}}}, {"text": "and the IndexOutOfBounds exception is caused because you are trying to retrieve an item from a position where there is nothing", "label": {"api": {"IndexOutOfBounds": [[8, 23]]}}}, {"text": "Oh, Scanners can scan Strings as well", "label": {"api": {"Scanners can scan Strings": [[4, 28]]}}}, {"text": "It is not exactly the same thing, but why not split the string on spaces, which are the word boundaries", "label": {"api": {"split": [[46, 50]]}}}, {"text": "By default, javax.swing.Timer will coalesce events; you may be seeing this effect", "label": {"api": {"javax.swing.Timer": [[12, 28]]}}}, {"text": "Then fireTableDataChanged() (or another approptiate fire* method) will notify your table about changes", "label": {"api": {"fireTableDataChanged()": [[5, 26]]}}}, {"text": "You have to use Arrays.binarySearch method (array has to be sorted)", "label": {"api": {"Arrays.binarySearch": [[16, 34]]}}}, {"text": "Initially I used a HashMap in order to hash each password I had generated so far and use as a check each time I created a new one before returning", "label": {"api": {"HashMap": [[19, 25]]}}}, {"text": "However, Java HashMap objects are limited in size and eventually the Map would become too saturated to maintain acceptable retrieval time", "label": {"api": {"HashMap": [[14, 20]]}}}, {"text": "I may decide to just use the dumb generator method to fill up a BlockingQueue and just multithread it to death..", "label": {"api": {"BlockingQueue": [[64, 76]]}}}, {"text": "You could put both chars in lower case and then compare them", "label": {"api": {"put both chars in lower case": [[10, 37]]}}}, {"text": "The Character class of Java API has various functions you can use", "label": {"api": {"Character": [[4, 12]]}}}, {"text": "I think about to use the Service guava interface as a SwingWorker, because in a SwingWorker I always need a start and end state", "label": {"api": {"SwingWorker": [[54, 64], [80, 90]]}}}, {"text": "Literals get interned automatically; strings created via new String(\"literal here\") are not", "label": {"api": {"interned": [[13, 20]]}}}, {"text": "System.load can be used to load any shared library, so you might try loading the debug library in a static block using System.load (before you load your JNI lib)", "label": {"api": {"System.load": [[0, 10], [119, 129]]}}}, {"text": "Or try System.loadLibary(\"debug\") before your JNI lib", "label": {"api": {"System.load": [[7, 17]]}}}, {"text": "The idea is similar to java standard SortedSet, which extends a Set - we wouldn't want to regard Set as SortedSets and give a variable of this type a value of HashSet, instead we use a sub-interface, SortedSet for this purpose", "label": {"api": {"SortedSet": [[37, 45], [104, 112], [200, 208]], "Set": [[43, 45], [64, 66], [97, 99], [110, 112], [163, 165], [206, 208]]}}}, {"text": "Parse your date to an actual Date Object and then pass it to a Calendar Instance (through setTime(Date date))", "label": {"api": {"Calendar": [[63, 70]], "setTime(Date date)": [[90, 107]]}}}, {"text": "You can then use the DAY_OF_WEEK to get a number representing the days of the week", "label": {"api": {"DAY_OF_WEEK": [[21, 31]]}}}, {"text": "Use the SimpleDateFormat to parse the String then you have a Date object an can get the day of the week", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "You'd be far better off using a MulticastSocket", "label": {"api": {"MulticastSocket": [[32, 46]]}}}, {"text": "With JMS these messages would be sent to a single queue, with a MulticastSocket you send a DatagramPacket to a group", "label": {"api": {"MulticastSocket": [[64, 78]], "DatagramPacket": [[91, 104]]}}}, {"text": "The read-method consumes a character, check if readLine returns null instead", "label": {"api": {"read-method": [[4, 14]], "readLine": [[47, 54]]}}}, {"text": "Create a File object with that path and then use getPath method from File Class", "label": {"api": {"File Class": [[69, 78]]}}}, {"text": "Consider SortedMap for this task", "label": {"api": {"SortedMap": [[9, 17]]}}}, {"text": "The server uses DataInputStream.readInt() to read the data length before reading the data", "label": {"api": {"DataInputStream.readInt()": [[16, 40]]}}}, {"text": "If you want to continue using the Preferences API, but write to a file, you will need a new PreferencesFactory, as detailed in this SO post", "label": {"api": {"PreferencesFactory": [[92, 109]]}}}, {"text": "Thus you get an ArrayIndexOutOfBoundException", "label": {"api": {"ArrayIndexOutOfBoundException": [[16, 44]]}}}, {"text": "If you are looking for a dynamic array (array which its size is modifiable) - you will probably want to use an ArrayList<String> instead of a String[]", "label": {"api": {"ArrayList<String>": [[111, 127]]}}}, {"text": "Try looking at FocusListener and WindowFocusListener to implement the listeners for either the Swing components themselves or the JFrame", "label": {"api": {"FocusListener": [[15, 27], [39, 51]], "WindowFocusListener": [[33, 51]]}}}, {"text": "It uses the constructor File(String,String) first, and then it uses File(File,String)", "label": {"api": {"File(String,String)": [[24, 42]], "File(File,String)": [[68, 84]]}}}, {"text": "It depends on the way you want to sort your Strings, but the method compareTo of String would help you achieve that kind of sorting", "label": {"api": {"String": [[44, 49], [81, 86]]}}}, {"text": "Why not use the built in Java compiler API", "label": {"api": {"Java compiler API": [[25, 41]]}}}, {"text": "Attach a listener to your Stage's iconified property", "label": {"api": {"iconified property": [[34, 51]]}}}, {"text": "If you want to parse a String, Use Byte#decode", "label": {"api": {"Byte#decode": [[35, 45]]}}}, {"text": "Create a new list using subList() to get a view into the first, then use clear() on the subList", "label": {"api": {"subList()": [[24, 32]], "clear()": [[73, 79]]}}}, {"text": "You could use the sublist method to split this list into two (making two calls to sublist)", "label": {"api": {"sublist": [[18, 24], [82, 88]]}}}, {"text": "Disable the ImageIO cache through the ImageIO.setUseCache() method", "label": {"api": {"ImageIO.setUseCache()": [[38, 58]]}}}, {"text": "As a subclass of ThreadPoolExecutor, you don't have to re-implement everything which ThreadPoolExecutor does for you just to get the waitUntilFinished() functionality that you're after", "label": {"api": {"ThreadPoolExecutor": [[17, 34], [85, 102]]}}}, {"text": "This implementation works by taking advantage of the beforeExecute() and afterExecute() methods which ThreadPoolExecutor exposes to keep our own count of active tasks", "label": {"api": {"ThreadPoolExecutor": [[102, 119]]}}}, {"text": "I don't use getActiveCount() because, according to the JavaDoc, it doesn't guarantee an exact answer (although perhaps in the case of ThreadPoolExecutor it does provide an exact answer, I'd need to research further to be sure)", "label": {"api": {"ThreadPoolExecutor": [[134, 151]]}}}, {"text": "In order to do that, you can use the Java Compiler API", "label": {"api": {"Java Compiler API": [[37, 53]]}}}, {"text": "Proxying an interface is relatively straightforward since an interface is simply a list of methods which need to be implemented, facilitating the interception of method invocations", "label": {"api": {"Proxy": [[0, 4]]}}}, {"text": "The Proxy class in Java is a class that implements a list of interfaces which are specified at runtime", "label": {"api": {"Proxy": [[4, 8]]}}}, {"text": "A proxy then has an InvocationHandler associated with it, which delegates method calls made on the proxy to the object being proxied", "label": {"api": {"InvocationHandler": [[20, 36]]}}}, {"text": "The InvocationHandler has but a single method which needs to be implemented", "label": {"api": {"InvocationHandler": [[4, 20]]}}}, {"text": "Proxying a class dynamically, as opposed to an interface, is not quite as simple", "label": {"api": {"Proxy": [[0, 4]]}}}, {"text": "While Java's Proxy is merely a runtime implementation of an interface or set of interfaces, objects do not have to implement an interface", "label": {"api": {"Proxy": [[13, 17]]}}}, {"text": "class files), meaning it can extend classes at runtime in a way that Java's Proxy can implement an interface at runtime", "label": {"api": {"Proxy": [[76, 80]]}}}, {"text": "The above InvocationHandler would be passed to a proxy so that methods invoked on the proxy would be handled by the InvocationHandler", "label": {"api": {"InvocationHandler": [[10, 26], [116, 132]]}}}, {"text": "You can set setAutoCommit to false, execute two separate statements and then commit the transaction manually", "label": {"api": {"setAutoCommit": [[12, 24]]}}}, {"text": "If you want to store the HashMap between application usages, you can store it to disk, just make sure that the elements making up the HashMap implement the Serializable interface", "label": {"api": {"Serializable": [[156, 167]]}}}, {"text": "You can access the annotations at run time using reflection - getAnnotations", "label": {"api": {"getAnnotations": [[62, 75]]}}}, {"text": "Did you specify that your annotation is available at runtime using the RetentionPolicy", "label": {"api": {"RetentionPolicy": [[71, 85]]}}}, {"text": "It seems that date.SetYear is deprecated", "label": {"api": {"deprecated": [[30, 39]]}}}, {"text": "You can add file attributes in Java 7 through the java.nio.file.Files class", "label": {"api": {"Java 7": [[31, 36]], "java.nio.file.Files": [[50, 68]]}}}, {"text": "So it would be possible to mark whether a file contains X using the Files.setAttribute() method", "label": {"api": {"Files.setAttribute()": [[68, 87]]}}}, {"text": "And then check whether the file does contain X using the Files.getAttribute( ) method", "label": {"api": {"Files.getAttribute( )": [[57, 77]]}}}, {"text": "You can call requestDispatcher.include(request, response) method", "label": {"api": {"requestDispatcher.include(request, response)": [[13, 56]]}}}, {"text": "The Rhino engine doesn't appear to have any mechanism for doing this (bad Rhino!) and it's hard to tell whether it creates threads internally, so the only solution you've got is to create a ThreadGroup, load and execute the Rhino engine and its script from inside a thread in that group, and when you want to kill it off, use ThreadGroup.stop()", "label": {"api": {"ThreadGroup": [[190, 200], [326, 336]], "ThreadGroup.stop()": [[326, 343]]}}}, {"text": "It would be cool to use a ForkJoinPool for this, as that's better suited for recursive type task breakdown", "label": {"api": {"ForkJoinPool": [[26, 37]]}}}, {"text": "See this method in the JDK docs", "label": {"api": {"this method": [[4, 14]]}}}, {"text": "Use the ExecutorService it has a methode invokeAll()", "label": {"api": {"ExecutorService": [[8, 22]], "invokeAll()": [[41, 51]]}}}, {"text": "One of the example classes that can solve your problem is ReentrantLock", "label": {"api": {"ReentrantLock": [[58, 70]]}}}, {"text": "One way to do this is to append() a series of suitable Printable instances to a java.awt.print.Book, as shown here", "label": {"api": {"java.awt.print.Book": [[80, 98]]}}}, {"text": "JTable has a getPrintable() method that should simplify things; here's an outline and simple title Printable", "label": {"api": {"getPrintable()": [[13, 26]]}}}, {"text": "If you want to access a list of things (in your case Buttons), you should use a List or an Array", "label": {"api": {"List": [[80, 83]]}}}, {"text": "Here is an example using an ArrayList of Buttons", "label": {"api": {"List": [[33, 36]]}}}, {"text": "You can use a RandomAccessFile", "label": {"api": {"RandomAccessFile": [[14, 29]]}}}, {"text": "Also, in some situations, a FileChannel may work better", "label": {"api": {"FileChannel": [[28, 38]]}}}, {"text": "you can get a FileChannel from the RandomAccessFile object using getChannel", "label": {"api": {"FileChannel": [[14, 24]]}}}, {"text": "You can add a random algorithm using SecureRandom", "label": {"api": {"SecureRandom": [[37, 48]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/io/DataInput.html#readUTF() for details", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/DataInput.html#readUTF": [[4, 74]]}}}, {"text": "Use URLEncoder to encode the value as application/x-www-form-urlencoded", "label": {"api": {"URLEncoder": [[4, 13]]}}}, {"text": "Why not use a BlockingQueue - this does exactly what you want", "label": {"api": {"BlockingQueue": [[14, 26]]}}}, {"text": "The BlockingQueue interface has a take() method for this purpose", "label": {"api": {"BlockingQueue": [[4, 16]], "take()": [[34, 39]]}}}, {"text": "You use List#get(int index) to get an object with the index index in the list", "label": {"api": {"List#get(int index)": [[8, 26]]}}}, {"text": "You must implement the method readResolve, mentioned at Serializable Javadoc, in your myfirstpath.UserState class", "label": {"api": {"Serializable Javadoc": [[56, 75]]}}}, {"text": "See the Java Reference for details", "label": {"api": {"Java Reference": [[8, 21]]}}}, {"text": "Parse the string to an int, and check that the value is in range", "label": {"api": {"Parse the string to an int": [[0, 25]]}}}, {"text": "I would tend to use a JList with a disabled JButton Start Race below it, for this", "label": {"api": {"JList": [[22, 26]]}}}, {"text": "Put the images into the list and add a list selection listener to detect selections", "label": {"api": {"list selection listener": [[39, 61]]}}}, {"text": "When the selection changes, check the list for the selected values array (1.6) or selected values list (1.7+) and count the entries", "label": {"api": {"selected values array (1.6)": [[51, 77]], "selected values list (1.7+)": [[82, 108]]}}}, {"text": "That is the class you will need", "label": {"api": {"class": [[12, 16]]}}}, {"text": "The Java data structure that's best suited for this task is a Deque, I'd say", "label": {"api": {"Deque": [[62, 66]]}}}, {"text": "Implement different Comparators for the columns you want to sort on", "label": {"api": {"Comparators": [[20, 30]]}}}, {"text": "use a CountDownLatch", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "In Java File represents a path name to a file or a directory, not a writable file stream", "label": {"api": {"File": [[8, 11]]}}}, {"text": "If you need to create a file, call createNewFile on the File object", "label": {"api": {"File": [[44, 47], [56, 59]]}}}, {"text": "Take a look at the method javadocs", "label": {"api": {"the method javadocs": [[15, 33]]}}}, {"text": "You can do this by using the invokeLater method from the SwingUtilities class", "label": {"api": {"invokeLater": [[29, 39]], "SwingUtilities": [[57, 70]]}}}, {"text": "Thread.interrupt will only cause the target thread to stop if it is in very specific states", "label": {"api": {"Thread.interrupt": [[0, 15]]}}}, {"text": "My preferred way of making a temporary implementation, either in a TDD environment or when your IDE generates a class from an interface, is to throw an exception such as the UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[174, 202]]}}}, {"text": "You should use setFetchSize(int rows) on your Statement with a reasonable number of rows (100 maybe)", "label": {"api": {"setFetchSize(int rows)": [[15, 36]]}}}, {"text": "You need to add a XmlSeeAlso annotation to the User class with the attributes Admin and all the other concrete classes that subclass the User class", "label": {"api": {"XmlSeeAlso": [[18, 27]]}}}, {"text": "Alternatively, consider using a Timer or ScheduledExecutorService", "label": {"api": {"Timer": [[32, 36]], "ScheduledExecutorService": [[41, 64]]}}}, {"text": "You can use ReplaceAll(String regex, String replacement) to remove the brackets and then use Split() function to split the string into an ArrayList using \", \" as your delimiter", "label": {"api": {"ReplaceAll(String regex, String replacement)": [[12, 55]], "Split()": [[93, 99]]}}}, {"text": "If you need to calculate the hash of a string, simply use the hashCode() method of the String class", "label": {"api": {"hashCode()": [[62, 71]]}}}, {"text": "As an example, in OpenJDK's implementation of the String class the hashCode() method caches the value in the hash attribute and only needs to be computed once", "label": {"api": {"hashCode()": [[67, 76]]}}}, {"text": "all hashes returned by the hashCode() method in Java are of type int, and ints in Java are represented using 32-bits", "label": {"api": {"hashCode()": [[27, 36]]}}}, {"text": "This is a misunderstanding of what getRealPath does", "label": {"api": {"getRealPath": [[35, 45]]}}}, {"text": "What you can do is add the contentPane from the JFrame to your JPanel", "label": {"api": {"contentPane": [[27, 37]]}}}, {"text": "Try looking into the PreparedStatement class to create you're statements", "label": {"api": {"PreparedStatement": [[21, 37]]}}}, {"text": "You can reduce verbosity using the reflection API to create a utility method", "label": {"api": {"reflection": [[35, 44]]}}}, {"text": "You can clear it", "label": {"api": {"clear": [[8, 12]]}}}, {"text": "You might find an array or collection of BitSets helpful", "label": {"api": {"BitSet": [[41, 46]]}}}, {"text": "In any event, if you just want to check if the integers in the tickets match -- if they have exactly the same values in exactly the same order -- the simplest solution is just to use Arrays.equals(int[], int[])", "label": {"api": {"Arrays.equals(int[], int[])": [[183, 209]]}}}, {"text": "How should I use UniCastRemoteObject", "label": {"api": {"UniCastRemoteObject": [[17, 35]]}}}, {"text": "AsyncContext.html#start is probably the closest you can get", "label": {"api": {"AsyncContext.html#start": [[0, 22]]}}}, {"text": "You should store them as Integers using the Integer.valueOf(String s, int radix) method", "label": {"api": {"Integer.valueOf(String s, int radix)": [[44, 79]]}}}, {"text": "As noted in the JScrollPane API, unless you change the policy, \"both horizontal and vertical scrollbars appear whenever the component's contents are larger than the view.\" Once pack() has sized the Window \"to fit the preferred size and layouts of its subcomponents,\" any subsequent changes are seen by the scroll pane when the container is validated and repainted", "label": {"api": {"JScrollPane": [[16, 26]]}}}, {"text": "You can use String.lastIndexOf to find the last occurance of \"/sdcard\" and then read the rest using usual substring from index+offset ..", "label": {"api": {"String.lastIndexOf": [[12, 29]]}}}, {"text": "To be able to write (serialise) your objects to streams, your class should implement  Serializable interface", "label": {"api": {"Serializable": [[86, 97]]}}}, {"text": "In most cases you don't need to do anything except for adding the \"implements Serializable\" clause in your class definition", "label": {"api": {"Serializable": [[78, 89]]}}}, {"text": "For an even more simplified approach, have a loop at the various implementation of BlockingQueue, which provides the above features out of the box", "label": {"api": {"BlockingQueue": [[83, 95]]}}}, {"text": "In practice I would probably use an AtomicInteger instead, which is basically a wrapper around an int to allow for atomic queries and updates, just like the DonutShop class above", "label": {"api": {"AtomicInteger": [[36, 48]]}}}, {"text": "Toolkit provides a method accepting a URL as well, see java.awt.Toolkit#getImage()", "label": {"api": {"java.awt.Toolkit#getImage()": [[55, 81]]}}}, {"text": "All it means is that Restaurant.Time doesn't override the toString() method, so the default implementation provided by Object is used", "label": {"api": {"toString()": [[58, 67]]}}}, {"text": "If you want the output to look differently, you'll need to override Restaurant.Time.toString()", "label": {"api": {"toString()": [[84, 93]]}}}, {"text": "Have you tried to read the documentation for java.io.File", "label": {"api": {"java.io.File": [[45, 56]]}}}, {"text": "I believe the Java Set (see documentation) is pretty much a direct parallel to the C++ STL versions", "label": {"api": {"see documentation": [[24, 40]]}}}, {"text": "Swing is the way to go, as it is the newer version that fixed AWT's weaknesses; and there are many great tutorials, such as here", "label": {"api": {"Swing": [[0, 4]]}}}, {"text": "See here also - Oracle Swing tutorial", "label": {"api": {"Swing": [[23, 27]]}}}, {"text": "If BufferedReader is there because of readLine method you can replace it by InputStreamReader and use a method like", "label": {"api": {"BufferedReader": [[3, 16]]}}}, {"text": "If PrintWriter is there because of print methods you can replace it by PrintStream", "label": {"api": {"PrintWriter": [[3, 13]]}}}, {"text": "This method was introduced in Servlet 3.0", "label": {"api": {"introduced": [[16, 25]]}}}, {"text": "You're looking for intValue, not Integer.valueOf (though it's easy to see how you could get them confused!)", "label": {"api": {"intValue": [[19, 26]]}}}, {"text": "intValue returns the primitive int contained by an Integer instance", "label": {"api": {"intValue": [[0, 7]]}}}, {"text": "See Java API docs..", "label": {"api": {"Java API docs": [[4, 16]]}}}, {"text": "Assuming that you have already loaded the file as an array of these objects in loadedNames than you can search them using the String#indexOf(String) method as such", "label": {"api": {"String#indexOf(String) method": [[126, 154]]}}}, {"text": "String.hashCode() uses an efficient, high-quality hashing algorithm, so it's the best choice", "label": {"api": {"String.hashCode()": [[0, 16]]}}}, {"text": "At some interval, perhaps each time through your loop, you should call OutputStream.flush()", "label": {"api": {"OutputStream.flush()": [[71, 90]]}}}, {"text": "See Desktop.open(File) for details", "label": {"api": {"Desktop.open(File)": [[4, 21]]}}}, {"text": "Take a look at the Comparator class and the Collections.sort(List<T>, Comparator<", "label": {"api": {"Comparator": [[19, 28], [70, 79]]}}}, {"text": "For sorting strings, use compareTo method in your if condition", "label": {"api": {"compareTo": [[25, 33]]}}}, {"text": "You could create a date from a string using DateFormat.parse() and then convert it to a timestamp using Date.getTime()", "label": {"api": {"DateFormat.parse()": [[44, 61]], "Date.getTime()": [[104, 117]]}}}, {"text": "The Java String class has an endsWith method you could be using", "label": {"api": {"endsWith": [[29, 36]]}}}, {"text": "Create original_value using the String(byte[] bytes, String charsetName) constructor", "label": {"api": {"String(byte[] bytes, String charsetName)": [[32, 71]]}}}, {"text": "You have to use the put(key, value) method of your map", "label": {"api": {"put(key, value)": [[20, 34]]}}}, {"text": "Use Process.getOutputStream() and write() to it", "label": {"api": {"Process.getOutputStream()": [[4, 28]]}}}, {"text": "If you need more range, you'll have to resort to something like a bignum library, such as BigDecimal", "label": {"api": {"BigDecimal": [[90, 99]]}}}, {"text": "BigDecimal is better for your requirement", "label": {"api": {"BigDecimal": [[0, 9]]}}}, {"text": "I think the ExecutorService itself will be able to perform your requirements", "label": {"api": {"ExecutorService": [[12, 26]]}}}, {"text": "Use a JTree instead", "label": {"api": {"JTree": [[6, 10]]}}}, {"text": "I think the single JTree as well as a single JList with a custom renderer both have the same shortcoming", "label": {"api": {"JTree": [[19, 23]]}}}, {"text": "You will need to use DateFormat#format(Date) in order to get a String in a given format, or you'll get whatever the system/implementation default is", "label": {"api": {"DateFormat#format(Date)": [[21, 43]]}}}, {"text": "Use a ThreadLocal<DateFormat>", "label": {"api": {"ThreadLocal<DateFormat>": [[6, 28]]}}}, {"text": "To improve this, use one of the EntityManager query creation methods which returns a TypedQuery<T>", "label": {"api": {"EntityManager query creation methods": [[32, 67]]}}}, {"text": "To read from the certain byte - SeekableByteChannel", "label": {"api": {"SeekableByteChannel": [[32, 50]]}}}, {"text": "ArrayList#remove returns the removed element, if any, so you could also just do return getBoxes().remove(index)", "label": {"api": {"ArrayList#remove": [[0, 15]]}}}, {"text": "You might find it easier to use ByteBuffer, which is probably the nicest way in Java to organize byte-by-byte output", "label": {"api": {"ByteBuffer": [[32, 41]]}}}, {"text": "ByteBuffer doesn't directly care about alignment, though, and I don't know how C++ is aligning its output -- but in a pinch, you can just advance it manually", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "Collections.sort and implement comparable on pojo or pass in a comparator to the sort method", "label": {"api": {"Collections.sort": [[0, 15]], "comparable": [[31, 40]], "comparator": [[63, 72]]}}}, {"text": "As an alternative to all this, you could use a SortedSet<Email> with the appropriate comparator", "label": {"api": {"SortedSet<Email>": [[47, 62]]}}}, {"text": "Have a look at TreeSet and how it deals with comparators and natural ordering", "label": {"api": {"TreeSet": [[15, 21]]}}}, {"text": "VK_BACK_QUOTE is the code you want", "label": {"api": {"VK_BACK_QUOTE": [[0, 12]]}}}, {"text": "I tried to use the Java ServiceLoader to find all classes that implement a specific interface like so", "label": {"api": {"ServiceLoader": [[24, 36]]}}}, {"text": "Unfortunately, when I run Eclipse in debug mode the ServiceLoader doesn't find any classes", "label": {"api": {"ServiceLoader": [[52, 64]]}}}, {"text": "You should use isAssignableFrom() or isInstance()", "label": {"api": {"isAssignableFrom()": [[15, 32]], "isInstance()": [[37, 48]]}}}, {"text": "No, you need to use Class.isInstance(Object)", "label": {"api": {"Class.isInstance(Object)": [[20, 43]]}}}, {"text": "Since this is CMT specific, you should look at the SessionSynchronization interface, and it's afterCompletion() method", "label": {"api": {"SessionSynchronization": [[51, 72]], "afterCompletion()": [[94, 110]]}}}, {"text": "Everyone else is right, you can just set your String to the empty string at the start, but if you are building a string from a lot of data, might want to use a StringBuilder object, which is designed for string building", "label": {"api": {"StringBuilder": [[160, 172]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html for more details", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html": [[4, 79]]}}}, {"text": "Use SimpleDateFormat class from standard JavaSDK", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "You can simply use Integer.toBinaryString(int)", "label": {"api": {"Integer.toBinaryString(int)": [[19, 45]]}}}, {"text": "You're using matches() which tries to match the whole of the input; you want find which will just try to find a match for the regex somewhere in the input", "label": {"api": {"matches()": [[13, 21]], "find": [[77, 80], [105, 108]]}}}, {"text": "But JavaFX's Image class offers no such methods, and creating a BufferedImage just to convert it to a JavaFX Image (by using Image.impl_fromPlatformImage()) is highly costly", "label": {"api": {"Image": [[13, 17], [72, 76], [109, 113], [125, 129], [148, 152]]}}}, {"text": "How does one create a JavaFX Image, that can be set to an ImageView, based on a rgb int[]", "label": {"api": {"Image": [[29, 33], [58, 62]]}}}, {"text": "If I where you I would use something such as an ArrayList to store data, especially students", "label": {"api": {"ArrayList": [[48, 56]]}}}, {"text": "With regards to persisting your data, you should take a look at the ObjectOutputStream to store your objects and to the ObjectInputStream to load them back into your application", "label": {"api": {"ObjectOutputStream": [[68, 85]], "ObjectInputStream": [[120, 136]]}}}, {"text": "Regardless, to answer your question you would want to use ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[58, 78]]}}}, {"text": "Yes, you can \"forward\" internally via getRequestDispatcher(path).forward(..)", "label": {"api": {"getRequestDispatcher(path).forward(..)": [[38, 75]]}}}, {"text": "How about calling modPow", "label": {"api": {"modPow": [[18, 23]]}}}, {"text": "The 'console' could be implemented using a JTextPane", "label": {"api": {"JTextPane": [[43, 51]]}}}, {"text": "Whenever the window has focus, you can write any keypress to the text pane and parse, execute whenever 'Enter' is pressed (use a KeyListener and implement keyTyped)", "label": {"api": {"KeyListener": [[129, 139]]}}}, {"text": "See the getter/ setter for Thread name at this link", "label": {"api": {"this link": [[42, 50]]}}}, {"text": "A .ser extension probably just means it is a Java serialized object", "label": {"api": {"Java serialized object": [[45, 66]]}}}, {"text": "The X509Certificate class does in fact implement Serializable", "label": {"api": {"X509Certificate": [[4, 18]]}}}, {"text": "My guess is that you just need to serialize your X509Certificate instance", "label": {"api": {"X509Certificate": [[49, 63]]}}}, {"text": "Use Boolean.valueOf(String string) to archieve your goal", "label": {"api": {"Boolean.valueOf(String string)": [[4, 33]]}}}, {"text": "You are better off using the JavaCompiler API, rather than attemtping to call javac directly which is in tools.jar The API will add this for you if you use it", "label": {"api": {"JavaCompiler API": [[29, 44]]}}}, {"text": "Had you tried adding setWheelScrollingEnabled(true/false), on your JScrollPane", "label": {"api": {"setWheelScrollingEnabled(true/false)": [[21, 56]]}}}, {"text": "Try using a BufferedReader and InputStreamReader to read the line first", "label": {"api": {"BufferedReader": [[12, 25]], "InputStreamReader": [[31, 47]]}}}, {"text": "You'll notice in the Java API it returns null sometimes or -1 where an Int is expected", "label": {"api": {"returns null sometimes": [[33, 54]], "or -1 where an Int is expected": [[56, 85]]}}}, {"text": "Reading the exception and the JavaDoc for sun.security.rsa.RSAPadding  and javax.crypto.BadPaddingException, it looks like your Java code expects PKCS#1 v1.5 padding, but your C code is not using this same padding", "label": {"api": {"javax.crypto.BadPaddingException": [[75, 106]]}}}, {"text": "In general those methods are called lifecycle callback methods", "label": {"api": {"lifecycle callback methods": [[36, 61]]}}}, {"text": "Or depending about details, @PreRemove can be more useful", "label": {"api": {"@PreRemove": [[28, 37]]}}}, {"text": "Use getInputStream() to access returned process's stdout", "label": {"api": {"getInputStream()": [[4, 19]]}}}, {"text": "You can also use facilities provided by ProcessBuilder.Redirect", "label": {"api": {"ProcessBuilder.Redirect": [[40, 62]]}}}, {"text": "You need to use Process.getInputStream to obtain the output from the sub-process being created", "label": {"api": {"Process.getInputStream": [[16, 37]]}}}, {"text": "The JDK provides an SSL socket  implementation that seems an appropriate place to start", "label": {"api": {"provides an SSL socket": [[8, 29]]}}}, {"text": "What you could do is just put your component in a JScrollPane and set the horizontal and vertical scroll bar policies to [VERTICAL|HORIZONTAL]_SCROLLBAR_AS_NEEDED", "label": {"api": {"horizontal": [[74, 83]], "vertical": [[89, 96]]}}}, {"text": "A ThreadLocal seems to fit your use perfectly", "label": {"api": {"ThreadLocal": [[2, 12]]}}}, {"text": "A ThreadLocal object can provide a way to store a variable per thread", "label": {"api": {"ThreadLocal": [[2, 12]]}}}, {"text": "See the split method on the String class", "label": {"api": {"the split method": [[4, 19]]}}}, {"text": "The applet tag is not supported by HTMLEditorKit", "label": {"api": {"HTMLEditorKit": [[35, 47]]}}}, {"text": "The second could also gain a bit of elegance by writing a FilterReader that skips the first line", "label": {"api": {"FilterReader": [[58, 69]]}}}, {"text": "Default charset of Java is not UTF-16, its locale dependent", "label": {"api": {"dependent": [[50, 58]]}}}, {"text": "If you want to change Charset in Java then you will have to do it before JVM startup, or else value of defaultCharset which is locale dependent will be used", "label": {"api": {"dependent": [[134, 142]]}}}, {"text": "Try reading each two characters, parsing them as a base 16 integer with Integer.parseInt(String,int), adding them to a byte array, and constructing a String from the result", "label": {"api": {"Integer.parseInt(String,int)": [[72, 99]], "String from the result": [[150, 171]]}}}, {"text": "As the MessagesBean seems to comply the javabeans specification, you can just use java.beans.Introspector for this", "label": {"api": {"java.beans.Introspector": [[82, 104]]}}}, {"text": "So to actually load your dicom image, you'll either have to write/find an image spi (see the javadoc for ImageIO.scanForPlugins for more info), or use another api, like the one provided by pixelmed", "label": {"api": {"ImageIO.scanForPlugins": [[105, 126]]}}}, {"text": "You can use System.arraycopy method", "label": {"api": {"System.arraycopy": [[12, 27]]}}}, {"text": "When using EJB 3.1 you can pass around contextual information in the EJBContext using its context data", "label": {"api": {"EJBContext": [[69, 78]], "context data": [[90, 101]]}}}, {"text": "In EJB there is a different approach call TransactionSyncrhonizationRegistry", "label": {"api": {"TransactionSyncrhonizationRegistry": [[42, 75]]}}}, {"text": "You will find your self restricted doing so had this been from Concurrency package like CopyOnWriteArrayList and you were using methods like addIfAbsent which is not defined in List interface", "label": {"api": {"CopyOnWriteArrayList": [[88, 107]], "addIfAbsent": [[141, 151]]}}}, {"text": "If you are looking for some ordered collection, look at SortedSet", "label": {"api": {"SortedSet": [[56, 64]]}}}, {"text": "I'm trying to build URI's using the JDK java.net.URI", "label": {"api": {"java.net.URI": [[40, 51]]}}}, {"text": "Why #resolve() \"eats\" the last path", "label": {"api": {"#resolve()": [[4, 13]]}}}, {"text": "You can add the buffer size on BufferedReader constructor, so you can use the previous File object to ascertain the file lenght and create the buffer size accordingly", "label": {"api": {"constructor": [[46, 56]], "lenght": [[121, 126]]}}}, {"text": "The ResultSetMetaData contains the column names", "label": {"api": {"ResultSetMetaData": [[4, 20]]}}}, {"text": "This can be done by using local variables or java.lang.ThreadLocal", "label": {"api": {"java.lang.ThreadLocal": [[45, 65]]}}}, {"text": "java.util.concurrent.locks.ReentrantLock has the same functionality as the lock you access when using synchronized blocks and methods, and it is even more powerful", "label": {"api": {"java.util.concurrent.locks.ReentrantLock": [[0, 39]]}}}, {"text": "It is called JSpinner, the Swing tutorial has an overview for all standard components", "label": {"api": {"JSpinner": [[13, 20]]}}}, {"text": "Just use a ArrayList<Integer>", "label": {"api": {"ArrayList<Integer>": [[11, 28]]}}}, {"text": "As this reeks of database, but you require a more direct approach, use a memory mapped file of java.nio", "label": {"api": {"memory mapped": [[73, 85]]}}}, {"text": "Try using DecimalFormat and set the RoundingMode to match what you need", "label": {"api": {"DecimalFormat": [[10, 22]], "RoundingMode": [[36, 47]]}}}, {"text": "If you consult the official documentation for the class System (http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/System.html) it will tell you that this method runs the garbage collection", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/System.html": [[64, 129]]}}}, {"text": "You should either use a splitting API which doesn't use regular expressions, or use Pattern.quote first", "label": {"api": {"Pattern.quote": [[84, 96]]}}}, {"text": "You're better off going with something like BufferedReader with a FileReader for large files", "label": {"api": {"BufferedReader": [[44, 57]], "FileReader": [[66, 75]]}}}, {"text": "You'll have either implement that interface yourself or use Proxy to create an instance of said interface that will delegate all calls to provided InvocationHandler", "label": {"api": {"Proxy": [[60, 64]], "InvocationHandler": [[147, 163]]}}}, {"text": "Have a look at the documentation for InputStreamReader and specify the right encoding when reading your file", "label": {"api": {"InputStreamReader": [[37, 53]]}}}, {"text": "CachedRowSet is a standard Java interface", "label": {"api": {"CachedRowSet": [[0, 11]]}}}, {"text": "If you already have a ResultSet, then you can fill a CachedRowSet from it using the populate method", "label": {"api": {"CachedRowSet": [[53, 64]], "populate": [[84, 91]]}}}, {"text": "If you are forward-thinking enough to be using Java 7, then you can obtain a CachedRowSet instance in a portable way, using a RowSetFactory, which has a createCachedRowSet method", "label": {"api": {"CachedRowSet": [[77, 88], [159, 170]], "RowSetFactory": [[126, 138]], "createCachedRowSet": [[153, 170]]}}}, {"text": "You can get a RowSetFactory from a RowSetProvider (of course!)", "label": {"api": {"RowSetFactory": [[14, 26]], "RowSetProvider": [[35, 48]]}}}, {"text": "Usually the solution is to move the work in another Thread, using for example a SwingWorker", "label": {"api": {"SwingWorker": [[80, 90]]}}}, {"text": "If you want the redirect triggered from within the applet I would try with the showDocument()", "label": {"api": {"showDocument()": [[79, 92]]}}}, {"text": "You could convert all Numbers to a single type (double is least-lossy)", "label": {"api": {"convert all Numbers to a single type": [[10, 45]]}}}, {"text": "You can read images directly from byte streams with the ImageIO class", "label": {"api": {"ImageIO": [[56, 62]]}}}, {"text": "Vector offers a subList method, which you can use as follows", "label": {"api": {"subList": [[16, 22]]}}}, {"text": "I'd give java.awt.Robot a try", "label": {"api": {"Robot": [[18, 22]]}}}, {"text": "You need to investigate SwingWorker, and SwingUtilities.invokeLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[41, 68]]}}}, {"text": "If you were to use java, you can write your own Comparator and pass on the ArrayList and the comparator to the Collections.sort() method", "label": {"api": {"Comparator": [[48, 57]], "Collections.sort() method": [[111, 135]]}}}, {"text": "Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow precise control over the sort order", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "Comparators can also be used to control the order of certain data structures (such as sorted sets or sorted maps), or to provide an ordering for collections of objects that don't have a natural ordering", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "I'm using java.util.concurrent.ExecutorService with fixed thread pool to execute list of tasks", "label": {"api": {"java.util.concurrent.ExecutorService": [[10, 45]], "fixed thread pool": [[52, 68]]}}}, {"text": "It can be found in java.util namespace as PriorityQueue", "label": {"api": {"PriorityQueue": [[42, 54]]}}}, {"text": "Seems like the SQLDriver you used, did not implement the getArray(int) method, and hence is throwing this exception", "label": {"api": {"getArray(int)": [[57, 69]]}}}, {"text": "Have the java class return a java.util.Map", "label": {"api": {"java.util.Map": [[29, 41]]}}}, {"text": "Use the ProcessBuilder API to start the child process, it lets you set environment variables", "label": {"api": {"ProcessBuilder": [[8, 21]]}}}, {"text": "Assuming the code compiles, the problem is that you're comparing strings with ==; you should use equals (or sometimes you want equalsIgnoreCase)", "label": {"api": {"equals": [[97, 102], [127, 132]], "equalsIgnoreCase": [[127, 142]]}}}, {"text": "If you have the Thread object you can try to set a UncaughtExceptionHandler", "label": {"api": {"UncaughtExceptionHandler": [[51, 74]]}}}, {"text": "Take a look at Thread.setUncaughtExceptionHandler(...)", "label": {"api": {"UncaughtExceptionHandler": [[25, 48]], "Thread.setUncaughtExceptionHandler(...)": [[15, 53]]}}}, {"text": "Another option is to use the same strategy as the UnmodifiableList", "label": {"api": {"UnmodifiableList": [[50, 65]]}}}, {"text": "If you are using JDK 1.7 you can use the java.nio.file.Files class which offers several copy methods to copy a file to a given destiny", "label": {"api": {"java.nio.file.Files": [[41, 59]]}}}, {"text": "Use DateEditor.getModel() to get the SpinnerDateModel which provides setStart,setEnd and setCalendarField", "label": {"api": {"SpinnerDateModel": [[37, 52]]}}}, {"text": "ArrayList.get will return the element at an index (Java ArrayList API) Collections.swap swaps the elements at an index (Java Collections API)", "label": {"api": {"Java ArrayList API": [[51, 68]], "Java Collections API": [[120, 139]]}}}, {"text": "Did you mean the deprecated setStatus method instead", "label": {"api": {"setStatus": [[28, 36]]}}}, {"text": "Or perhaps sendError", "label": {"api": {"sendError": [[11, 19]]}}}, {"text": "Any reason not to just use setStatus(500)", "label": {"api": {"setStatus": [[27, 35]]}}}, {"text": "You should use the one that's built-in", "label": {"api": {"one that's built-in": [[19, 37]]}}}, {"text": "You can replace the code at the end that copies it to an array with a call to the toArray() method", "label": {"api": {"toArray() method": [[82, 97]]}}}, {"text": "Before you display your JDialog, you should probably pack it", "label": {"api": {"pack": [[53, 56]]}}}, {"text": "Also, if you did not supply an owner for the JDialog when you created it, you should use setLocationRelativeTo(owner) to make it pop up in the center of the owner", "label": {"api": {"setLocationRelativeTo(owner)": [[89, 116]]}}}, {"text": "Are you familiar with clone", "label": {"api": {"clone": [[22, 26]]}}}, {"text": "Be careful that it won't do a clone of each field's object, but they will point to the same reference", "label": {"api": {"clone": [[30, 34]]}}}, {"text": "Close your FileReader objects before moving on to the next one", "label": {"api": {"FileReader": [[11, 20]]}}}, {"text": "FileReader is an InputStreamReader, which needs to call close() in order to free up resources", "label": {"api": {"FileReader": [[0, 9]]}}}, {"text": "Use the listFiles(FileFilter) method so Java can filter out non-text files for you", "label": {"api": {"listFiles(FileFilter)": [[8, 28]]}}}, {"text": "From the ConcurrentModificationException's javadoc", "label": {"api": {"ConcurrentModificationException": [[9, 39]]}}}, {"text": "As the subList method returns a view of the list, the returned list from this method is backed by your stringVector, so non-structural changes in the returned list are reflected in stringVector and vice-versa", "label": {"api": {"subList": [[7, 13]]}}}, {"text": "Use the getHeader(String Name) method of the javax.servlet.http.HttpServletRequest object to retrieve the value of Remote_Addr variable", "label": {"api": {"getHeader(String Name)": [[8, 29]], "javax.servlet.http.HttpServletRequest": [[45, 81]]}}}, {"text": "You can also use ThreadLocal object , in case you use the channels", "label": {"api": {"ThreadLocal": [[17, 27]]}}}, {"text": "You should use a javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[17, 33]]}}}, {"text": "As suggested by @eugener, classes that implement the Shape interface have a contains() method that is useful for this", "label": {"api": {"Shape": [[53, 57]]}}}, {"text": "You can use/extend DefaultComboBoxModel - a default model used by a JComboBox", "label": {"api": {"DefaultComboBoxModel": [[19, 38]]}}}, {"text": "First you need to create an instance of Random somewhere sensible in your program - for example when your program starts", "label": {"api": {"Random": [[40, 45]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html  Use the remove and add methods", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html": [[0, 65]]}}}, {"text": "As Chin Boon pointed out, you should use Integer.parseInt(String)", "label": {"api": {"Integer.parseInt(String)": [[41, 64]]}}}, {"text": "This is also explicitly mentioned in javadoc of DriverManager", "label": {"api": {"javadoc of DriverManager": [[37, 60]]}}}, {"text": "Be aware that the replace() method does not modify the String in-place (as is the case with all methods in the String class, because it's immutable), instead it returns a new String with the modifications - and you need to save the returned string somewhere", "label": {"api": {"replace()": [[18, 26]]}}}, {"text": "Also, the above version of replace() doesn't receive a regular expression as an argument, just the string to be replaced and its replacement", "label": {"api": {"replace()": [[27, 35]]}}}, {"text": "You can pass a Rectangle to the repaint() method, which tells Swing 'only this part of my component needs to be repainted'", "label": {"api": {"pass a Rectangle to the repaint() method": [[8, 47]]}}}, {"text": "In the paint method, you can get hold of this rectangle using the getClipBounds() method of the Graphics class and use it to determine which cell or cells to repaint", "label": {"api": {"the getClipBounds() method of the Graphics class": [[62, 109]]}}}, {"text": "You will add WindowListener to your frame", "label": {"api": {"WindowListener": [[13, 26]]}}}, {"text": "WindowListener has a windowClosing callback function which will be invoked when your frame is being closed", "label": {"api": {"WindowListener": [[0, 13]], "windowClosing": [[21, 33]]}}}, {"text": "When you need all the distinct values, you just use Map.keySet()", "label": {"api": {"Map.keySet": [[52, 61]]}}}, {"text": "The function takes one argument, and you're supplying three", "label": {"api": {"takes one argument": [[13, 30]]}}}, {"text": "The better solution is to use ReentrantReadWriteLock because it allows concurrent access to readers as well", "label": {"api": {"ReentrantReadWriteLock": [[30, 51]]}}}, {"text": "If you really need this to happen, you should use a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[52, 64]]}}}, {"text": "At the channelConnected event, grab the client from the ChannelHandlerContext and store it somewhere (a concurrent collection would be nice, like ConcurrentHashMap)", "label": {"api": {"ConcurrentHashMap": [[146, 162]]}}}, {"text": "This is stated in the ReadableByteChannel interface docs", "label": {"api": {"ReadableByteChannel": [[22, 40]]}}}, {"text": "You need to clear() the buffer after processing its content before passing it back to read", "label": {"api": {"clear()": [[12, 18]]}}}, {"text": "Get the table model of the table, cast it to DefaultTableModel, and use one of its addRow() methods", "label": {"api": {"DefaultTableModel": [[45, 61]]}}}, {"text": "You can use String.split()  to split each string on the newline characters and store the pieces in an array", "label": {"api": {"String.split()": [[12, 25]]}}}, {"text": "And, it is always useful to research the Internet before asking on StackOverflow, for example, you could read this tutorial about formatting numbers (and JavaDoc of Formatter class)", "label": {"api": {"Formatter": [[165, 173]]}}}, {"text": "I wonder what is a formal connection if any between Enumeration interface in Java and an Enum construct", "label": {"api": {"Enumeration interface": [[52, 72]]}}}]