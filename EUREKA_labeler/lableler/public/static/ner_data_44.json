[{"text": "Enumeration is a largely-outdated interface superceded by Iterator", "label": {"api": {"Enumeration": [[0, 10]], "Iterator": [[58, 65]]}}}, {"text": "In that case, it would be best to put in the java.io.tmpdir, as a temporary file, with a request to delete on exit", "label": {"api": {"temporary file": [[66, 79]], "delete on exit": [[100, 113]]}}}, {"text": "Cal repaint from a Swing Timer", "label": {"api": {"Timer": [[25, 29]]}}}, {"text": "In continuation to a question posted by me, I'm trying to use ThreadPoolExecutor in my codebase", "label": {"api": {"ThreadPoolExecutor": [[62, 79]]}}}, {"text": "This is possible using the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[27, 46]]}}}, {"text": "These collections, such as ConcurrentHashMap, enable much better throughput when scaling", "label": {"api": {"ConcurrentHashMap": [[27, 43]]}}}, {"text": "I am not saying that it is perfect, but I can get the job done using the Thread class", "label": {"api": {"Thread": [[73, 78]]}}}, {"text": "In Java I have a method called startThreads and in that method I created the threads and then started them", "label": {"api": {"Thread": [[36, 41]]}}}, {"text": "Try your hands on this code, and ask any questions that may arise, do painting inside the paintComponent(...) method of the JPanel", "label": {"api": {"paintComponent(...)": [[90, 108]]}}}, {"text": "Instead of providing size everytime for the said JComponent you can simply override getPreferredSize(), of the said component", "label": {"api": {"getPreferredSize()": [[84, 101]]}}}, {"text": "In order to call your paintComponent(...) you can simply write repaint() instead of explicitly making a call to paintComponent(...) from within your program, Swing will do that automatically", "label": {"api": {"paintComponent(...)": [[22, 40], [112, 130]]}}}, {"text": "Starting a new thread without specifying a thread group will add it to the default group", "label": {"api": {"add it to the default group": [[61, 87]]}}}, {"text": "Moreover, this class should be cloneable, then you must make this class implements the Cloneable interface", "label": {"api": {"Cloneable": [[87, 95]], "clone": [[31, 35]]}}}, {"text": "to this end, you have to declare that the Gene class implements the Cloneable interface (simply writing implements Cloneable in the class definition) and you must implement the clone method in this class (in this method you must make a deep copy of object fields and return the cloned object, see the code below for detail)", "label": {"api": {"Cloneable": [[68, 76], [115, 123]], "clone": [[177, 181], [278, 282]]}}}, {"text": "Note that to copy the array I used the method copyOf of Arrays class (please read here for more details about array copying)", "label": {"api": {"copyOf": [[46, 51]]}}}, {"text": "I would use a GridBagLayout", "label": {"api": {"GridBagLayout": [[14, 26]]}}}, {"text": "To make a Java Date out of it, use the Date(long) constructor, which expects milliseconds since The Epoch (so you multiply by 1,000)", "label": {"api": {"Date(long)": [[39, 48]]}}}, {"text": "If you're getting the value as a String, you'll need to parseLong it first, e.g.", "label": {"api": {"parseLong": [[56, 64]]}}}, {"text": "You should use executeUpdate for updates", "label": {"api": {"executeUpdate": [[15, 27]]}}}, {"text": "Also, use prepared statements, they are good, really", "label": {"api": {"prepared statements": [[10, 28]]}}}, {"text": "Your code basically matches the SwingUtilies.getAncestorOfClass() method", "label": {"api": {"SwingUtilies.getAncestorOfClass()": [[32, 64]]}}}, {"text": "Take a look at the Javadoc for Serializable for details (see the description of readObject())", "label": {"api": {"Javadoc for Serializable": [[19, 42]]}}}, {"text": "That's because you have to beware of MissingResourceException that will be thrown if there is no bundle for base name you are looking for", "label": {"api": {"MissingResourceException": [[37, 60]]}}}, {"text": "In Java Servlet world that means calling ServletRequest's getLocale() or getLocales() method and assign to variable in HttpSession object, which is accessible from JSP page", "label": {"api": {"getLocale()": [[58, 68]], "getLocales()": [[73, 84]], "HttpSession": [[119, 129]]}}}, {"text": "If you wonder how to access HttpSession on the servlet side, there is a getSession() method", "label": {"api": {"HttpSession": [[28, 38]], "getSession()": [[72, 83]]}}}, {"text": "If you're using Java 7, you can use the new WatchService (FileSystem.newWatchService()) to detect changes to the filesystem", "label": {"api": {"WatchService": [[44, 55], [72, 83]], "FileSystem.newWatchService()": [[58, 85]]}}}, {"text": "Press Enter at the beginning of a line, returns a String \"\" to the method Scanner.nextLine()", "label": {"api": {"Scanner.nextLine()": [[74, 91]]}}}, {"text": "setScale() rounds the number to zero decimal places, and despite its name, does not mutate the value of d", "label": {"api": {"setScale()": [[0, 9]]}}}, {"text": "I'm developing a JMS provider to spec, and it requires that certain objects implement Referenceable", "label": {"api": {"Referenceable": [[86, 98]]}}}, {"text": "I've implemented getReference() on my JMS ConnectionFactory, and I've created an object factory to convert the References to objects", "label": {"api": {"object factory": [[81, 94]]}}}, {"text": "The objects are identical and neither getReference nor my object factory gets called", "label": {"api": {"object factory": [[58, 71]]}}}, {"text": "I'm using the Java Referenceable Objects and References tutorials for defining how they should be implemented", "label": {"api": {"Referenceable": [[19, 31]]}}}, {"text": "I'm not sure this is relevant, but here is the object factory, and here is the Referenceable.getReference() implementation that I'm trying to test", "label": {"api": {"Referenceable": [[79, 91]], "object factory": [[47, 60]]}}}, {"text": "By the way, have you thought of using a linked list or a built-in queue implementation (Queue<E>) instead of an array", "label": {"api": {"Queue<E>": [[88, 95]]}}}, {"text": "I think you are looking for DataInputStream", "label": {"api": {"DataInputStream": [[28, 42]]}}}, {"text": "You could use the get() method instead of execute() - it will block until the SwingWorker finishes its job", "label": {"api": {"get() method": [[18, 29]]}}}, {"text": "Memory Consistency Properties summarizes the JLS", "label": {"api": {"Memory Consistency Properties": [[0, 28]]}}}, {"text": "I've never tried it, but you might look to the DownloadService method summary for methods starting with 'remove'", "label": {"api": {"DownloadService method summary": [[47, 76]]}}}, {"text": "From the ObjectInputStream documentation", "label": {"api": {"ObjectInputStream documentation": [[9, 39]]}}}, {"text": "For the most part, this works fine -- java.bean.Introspector doesn't return non-public methods in its default BeanInfo implementation", "label": {"api": {"java.bean.Introspector": [[38, 59]], "BeanInfo": [[110, 117]]}}}, {"text": "I'm looking through the documentation for java.lang.Class, and I don't see an obvious way to determine a class's permissions that doesn't involve a try/catch block for java.lang.SecurityException..", "label": {"api": {"java.lang.Class": [[42, 56]], "java.lang.SecurityException": [[168, 194]]}}}, {"text": "You can use ProcessBuilder, which wraps the Process class to start a process from your Java application, and grab its IO streams using Process#getInputStream and Process#getOutputStream", "label": {"api": {"ProcessBuilder": [[12, 25]], "Process class": [[44, 56]], "Process#getInputStream": [[135, 156]], "Process#getOutputStream": [[162, 184]]}}}, {"text": "EventQueue.invokeLater() will run that Runnable on the GUI thread (dispatch thread)", "label": {"api": {"EventQueue.invokeLater()": [[0, 23]]}}}, {"text": "The SwingWorker class is nominally a simpler way to do this, but in all honesty, beginners always find creating their own thread to be easier", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "You can, however, use a JTextPane which allows for attributes to be applied to text", "label": {"api": {"JTextPane": [[24, 32]]}}}, {"text": "Also, another alternative to Hashtable is a Collections.synchronziedMap", "label": {"api": {"Collections.synchronziedMap": [[44, 70]]}}}, {"text": "There are a number of existing interfaces that use HashTable", "label": {"api": {"use HashTable": [[47, 59]]}}}, {"text": "The model itself will notify the table in response to addRow()", "label": {"api": {"addRow()": [[54, 61]]}}}, {"text": "Another possibility is to open the file with a Scanner and use its findWithinHorizon() method", "label": {"api": {"findWithinHorizon()": [[67, 85]]}}}, {"text": "Java's Future interface is designed for results that may only arrive later, and the FutureTask class implements this interface", "label": {"api": {"Future": [[7, 12], [84, 89]], "FutureTask": [[84, 93]]}}}, {"text": "Have the first thread obtain access to the Future and get the second thread to run the FutureTask, and all of this stuff gets handled for you", "label": {"api": {"Future": [[43, 48], [87, 92]], "FutureTask": [[87, 96]]}}}, {"text": "The API doc for Condition has a code example that shows using multiple conditions for a bounded buffer, it says", "label": {"api": {"API doc for Condition": [[4, 24]]}}}, {"text": "You need to call process.destroy in order to kill a subprocess", "label": {"api": {"process.destroy": [[17, 31]]}}}, {"text": "The out in jsp is a JspWriter object which is created by Jsp automatically, it is used to write something to webpage while System.out.print() is used to output/write something to the console", "label": {"api": {"JspWriter": [[20, 28]]}}}, {"text": "I couldn't find anything in the API documentation either", "label": {"api": {"API documentation": [[32, 48]]}}}, {"text": "Reading the javadoc of DirectoryStream, you will see that", "label": {"api": {"the javadoc of DirectoryStream": [[8, 37]]}}}, {"text": "In the Java world, you'd use the Executors.newFixedThreadPool factory method, and submit each job as a Callable", "label": {"api": {"Executors.newFixedThreadPool": [[33, 60]], "Callable": [[103, 110]]}}}, {"text": "To let Collections.sort(list) works, you have to implement an interface call Comparaple", "label": {"api": {"Comparaple": [[77, 86]]}}}, {"text": "Now, once you have the union - all is left is to create a histogram (in how many lists each term appear, can be implemented as HashMap<Term,Integer>) - and print the keys of these histogram in descending value order", "label": {"api": {"HashMap<Term,Integer>": [[127, 147]]}}}, {"text": "Basically as described by the snippet in the first answer, but instead of the BufferedInputStream use AudioSystem.getAudioInputStream(File) to get the InputStream", "label": {"api": {"AudioSystem.getAudioInputStream(File)": [[102, 138]]}}}, {"text": "Put the tokens into an ArrayList and offer the user a JList instead", "label": {"api": {"JList": [[54, 58]]}}}, {"text": "Note that if you don't want the complete stack trace, the Exception method getStackTrace() gives you an array of StackTraceElements", "label": {"api": {"getStackTrace()": [[75, 89]], "StackTraceElements": [[113, 130]]}}}, {"text": "You could use a priority queue for representing object priorities, and define an appropriate Comparator for your class that takes into account the rules described", "label": {"api": {"priority queue": [[16, 29]]}}}, {"text": "I think you should be able to have the functionality you want by defining an AbstractDocument.Content implementation which takes care of the memory management (e.g", "label": {"api": {"AbstractDocument.Content": [[77, 100]]}}}, {"text": "The DefaultStyledDocument takes an AbstractDocument.Content in its constructor, and the JTextPane takes a StyledDocument, so if you define that implementation you should be able to plug it in", "label": {"api": {"AbstractDocument.Content": [[35, 58]], "DefaultStyledDocument": [[4, 24]]}}}, {"text": "Alternatively use a Timer if you want something to execute at a fixed interval", "label": {"api": {"Timer": [[20, 24]]}}}, {"text": "I'd suggest to use BreakIterator", "label": {"api": {"BreakIterator": [[19, 31]]}}}, {"text": "Depending on your application needs, maybe appropriate to use getMethods()", "label": {"api": {"getMethods()": [[62, 73]]}}}, {"text": "Use a JButton with an ActionListener", "label": {"api": {"JButton": [[6, 12]]}}}, {"text": "This example shows some tricks to dealing with images in JToggleButton that also apply to JButton - removing the borders around the image", "label": {"api": {"JButton": [[90, 96]]}}}, {"text": "The short answer is yes, you can declare an array like String[][] playerCoords, However I would suggest looking at the Map interface, as it may be more descriptive of what you want to do", "label": {"api": {"Map": [[119, 121]]}}}, {"text": "You can use String#replaceAll that has support for regex like this", "label": {"api": {"String#replaceAll": [[12, 28]]}}}, {"text": "You may use the class DecimalFormat to do this", "label": {"api": {"DecimalFormat": [[22, 34]]}}}, {"text": "FYI System.out.format() is a convenience facade for System.out.println(String.format()), so if you need the String in your code (and don't want to output it) use", "label": {"api": {"System.out.format()": [[4, 22]]}}}, {"text": "The Java API for File indicates there is a setLastModified(long time) function that you can call to set the last modified date", "label": {"api": {"Java API for File": [[4, 20]]}}}, {"text": "This sounds like the perfect job for a JDialog", "label": {"api": {"JDialog": [[39, 45]]}}}, {"text": "Better use the ProcessBuilder class; in particular, its start() method will return a Process object with methods for accessing the stdin and stdout streams, which can be redirected wherever you need them", "label": {"api": {"ProcessBuilder": [[15, 28]], "Process": [[15, 21], [85, 91]]}}}, {"text": "But since you are manipulating Strings it will be much better to use StringBuilder instead of String", "label": {"api": {"StringBuilder": [[69, 81]]}}}, {"text": "However StringBuilder is mutable and has various overloaded append methods to support your operation", "label": {"api": {"StringBuilder": [[8, 20]]}}}, {"text": "Using StringBuilder your code will become like this", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "Java's ArrayBlockingQueue does the job quite nicely", "label": {"api": {"ArrayBlockingQueue": [[7, 24]]}}}, {"text": "Doing the producing and consuming in concurrent threads is best achieved using Java's Executors framework", "label": {"api": {"Executors": [[86, 94]]}}}, {"text": "You could use the drawImage method", "label": {"api": {"drawImage": [[18, 26]]}}}, {"text": "If you are specifically talking about regular expressions, as implied by ‘matching words’, then the method you want is Pattern.quote", "label": {"api": {"Pattern.quote": [[119, 131]]}}}, {"text": "Use a Map (which you'll have to populate) that maps from String to whatever type your ObjectType.TYPE_x values are", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "What you are looking for is the Collator API", "label": {"api": {"Collator": [[32, 39]]}}}, {"text": "I used the HierarchyBoundsListener to detect changes in the JScrollPane's size", "label": {"api": {"HierarchyBoundsListener": [[11, 33]]}}}, {"text": "Use Files.walkFileTree in Java 7, which is faster than listFiles because it uses streaming", "label": {"api": {"Files.walkFileTree": [[4, 21]]}}}, {"text": "You could use a private final EnumMap associated to your enum, fill it with new Object()s, make sure you don't modify the map, and use the object associated with the category as a lock for that category", "label": {"api": {"EnumMap": [[30, 36]]}}}, {"text": "The JEditorPane can show (simple) HTML", "label": {"api": {"JEditorPane": [[4, 14]]}}}, {"text": "See this JEditorPane tutorial for more details", "label": {"api": {"JEditorPane": [[9, 19]]}}}, {"text": "Why don't you just try CipherInputStream and CipherOutputStream", "label": {"api": {"CipherInputStream": [[23, 39]], "CipherOutputStream": [[45, 62]]}}}, {"text": "Use a JToggleButton as shown in Swing JToolbarButton pressing", "label": {"api": {"JToggleButton": [[6, 18]]}}}, {"text": "mm stands for \"minutes\"", "label": {"api": {"stands for \"minutes\"": [[3, 22]]}}}, {"text": "Just create a PriorityBlockingQueue with your own Comparator that takes creation time into account (see http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/PriorityBlockingQueue.html#PriorityBlockingQueue(int, java.util.Comparator) )", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/PriorityBlockingQueue.html#PriorityBlockingQueue(int, java.util.Comparator)": [[104, 240]]}}}, {"text": "Only those exceptions that are subclasses of RuntimeException are considered unchecked", "label": {"api": {"RuntimeException": [[45, 60]]}}}, {"text": "You could have used IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[20, 43]]}}}, {"text": "You could use the SwingUtilities.getAncestorOfClass method", "label": {"api": {"SwingUtilities.getAncestorOfClass": [[18, 50]]}}}, {"text": "In that case you could create a SequenceInputStream wrapping several ByteArrayInputStreams", "label": {"api": {"SequenceInputStream": [[32, 50]]}}}, {"text": "You would be best served with BigInteger", "label": {"api": {"BigInteger": [[30, 39]]}}}, {"text": "use JTextArea#read(Reader in, Object desc) throws IOException, this method accepting line separator e.i", "label": {"api": {"JTextArea#read(Reader in, Object desc) throws IOException": [[4, 60]]}}}, {"text": "Yes, you should use .properties files and access them using ResourceBundle", "label": {"api": {"ResourceBundle": [[60, 73]]}}}, {"text": "See the ResourceBundle   class", "label": {"api": {"ResourceBundle": [[8, 21]]}}}, {"text": "The ResourceBundle will look first for classes and if not found, it will look for properties files", "label": {"api": {"ResourceBundle": [[4, 17]]}}}, {"text": "We don't have to specify file names, the ResourceBundle will construct the file name using the same mechanism used for classes", "label": {"api": {"ResourceBundle": [[41, 54]]}}}, {"text": "The ResourceBundle try to load the properties file from the current class-path", "label": {"api": {"ResourceBundle": [[4, 17]]}}}, {"text": "You could  run it through a SimpleDateFormatter", "label": {"api": {"SimpleDateFormatter": [[28, 46]]}}}, {"text": "You can use fireContentsChanged method or fireIntervalAdded one", "label": {"api": {"fireContentsChanged": [[12, 30]]}}}, {"text": "From the InetAddress#getHostName() javadocs, that method will perform a reverse hostname lookup", "label": {"api": {"InetAddress#getHostName() javadocs": [[9, 42]]}}}, {"text": "Build a RSAPublicKeySpec, pass it to KeyFactory.generatePublic, then pass the result as the second argument to cipher.init", "label": {"api": {"RSAPublicKeySpec": [[8, 23]], "KeyFactory.generatePublic": [[37, 61]]}}}, {"text": "You can explicitly exit the VM using System.exit(status)", "label": {"api": {"System.exit(status)": [[37, 55]]}}}, {"text": "Change N to 2, and change GridLayout(0, 1) to GridLayout(1, 0); now you have a row panel that adds across", "label": {"api": {"GridLayout": [[26, 35], [46, 55]]}}}, {"text": "Add ten of these to a JPanel with GridLayout(0, 1)", "label": {"api": {"GridLayout": [[34, 43]]}}}, {"text": "Check out the GridLayout API for the details", "label": {"api": {"GridLayout": [[14, 23]]}}}, {"text": "Arrays#copyOfRange does the trick", "label": {"api": {"Arrays#copyOfRange": [[0, 17]]}}}, {"text": "Taking a look at the API reveals that Double.parseDouble throws a NullPointerException if the argument is null", "label": {"api": {"API": [[21, 23]]}}}, {"text": "A KeyEvent inherits the method getModifiers() from InputEvent", "label": {"api": {"getModifiers()": [[31, 44]]}}}, {"text": "You can use the Integer.parseInt() method", "label": {"api": {"Integer.parseInt()": [[16, 33]]}}}, {"text": "You can use CertificateFactory.generateCertificate(InputStream inStream) to generate a Certificate", "label": {"api": {"CertificateFactory.generateCertificate(InputStream inStream)": [[12, 71]]}}}, {"text": "You can of course give Jetty your own SSLContext with your own X509KeyManager to choose the alias", "label": {"api": {"X509KeyManager": [[63, 76]]}}}, {"text": "Map is for Key:Value pair kind of data.for instance if you want to map student roll numbers to their names", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "List is for simple ordered collection of elements which allow duplicates", "label": {"api": {"List": [[0, 3]]}}}, {"text": "Check this list documentation .You can access elements by their integer index (position in the list), and search for elements in the list", "label": {"api": {"list documentation": [[11, 28]]}}}, {"text": "Check this map documentation", "label": {"api": {"map documentation": [[11, 27]]}}}, {"text": "You're looking for MappedSuperClass, which allows the subclasses to inherit the annotations from the superclass without needing a discriminator", "label": {"api": {"MappedSuperClass": [[19, 34]]}}}, {"text": "Make sure that your list elements implement the Serializable interface and then you can use the ObjectOutputStream to write objects to file and the ObjectInputStream to read them back in", "label": {"api": {"Serializable": [[48, 59]], "ObjectOutputStream": [[96, 113]], "ObjectInputStream": [[148, 164]]}}}, {"text": "The advantage of using XStream instead of object streams is that using XML will provide you with something which is human readable, it can be processed by other platforms and also does not require you to implement the Serializable interface, which uses the serialVersionUID to store the items to a file", "label": {"api": {"Serializable": [[218, 229]]}}}, {"text": "Use this method of Collections class to copy all elements of ArrayList to another ArrayList", "label": {"api": {"method": [[9, 14]]}}}, {"text": "Once that you will have done that, you should be able to call the method by converting the list to an array using toArray method", "label": {"api": {"toArray": [[114, 120]]}}}, {"text": "The file is thus not searched in the file system, but in the classpath, following the rules detailed in ClassLoader.getResource()", "label": {"api": {"ClassLoader.getResource()": [[104, 128]]}}}, {"text": "What you want to do could be done by using an undecorated JDesktopPane and maximize it over the dimensions of the screen", "label": {"api": {"JDesktopPane": [[58, 69]]}}}, {"text": "Then proceed with using a JInternalFrame to have a JFrame like window inside that JDesktopPane", "label": {"api": {"JDesktopPane": [[82, 93]], "JInternalFrame": [[26, 39]]}}}, {"text": "From the javadoc of TreeSet", "label": {"api": {"TreeSet": [[20, 26]]}}}, {"text": "From the javadoc of HashSet", "label": {"api": {"HashSet": [[20, 26]]}}}, {"text": "HashSet is quicker by a factor of 50", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "Multiply, use Math#floor and divide before providing the number to the DecimalFormat", "label": {"api": {"Math#floor": [[14, 23]]}}}, {"text": "A (more expensive, but also more logical) alternative is to use a BigDecimal", "label": {"api": {"BigDecimal": [[66, 75]]}}}, {"text": "Once you do this, you should also override hashCode()", "label": {"api": {"hashCode()": [[43, 52]]}}}, {"text": "You would be better off using LinkedHashSet instead (or, if the ordering of elements is not important, any Set)", "label": {"api": {"LinkedHashSet": [[30, 42]]}}}, {"text": "Element.getAttributes() will give a list of all attributes in that Element", "label": {"api": {"Element.getAttributes()": [[0, 22]]}}}, {"text": "If you know beforehand the name of the attribute and just want to get its value, use Element.getAttribute(String) instead", "label": {"api": {"Element.getAttribute(String)": [[85, 112]]}}}, {"text": "If you need to get the child elements, use Element.getChildNodes()", "label": {"api": {"Element.getChildNodes()": [[43, 65]]}}}, {"text": "To get the text inside an Element, or more specifically a Node, use getNodeValue()", "label": {"api": {"getNodeValue()": [[68, 81]]}}}, {"text": "You can't do the second, because even if you use the remove() method on Iterator, you'll get an Exception thrown", "label": {"api": {"Iterator": [[72, 79]], "you'll get an Exception thrown": [[82, 111]]}}}, {"text": "On some Collection implementations, the Iterator remove() is supported, on other it isn't", "label": {"api": {"Iterator": [[40, 47]]}}}, {"text": "You can read more in the docs for Iterator", "label": {"api": {"Iterator": [[34, 41]]}}}, {"text": "To compare the input with KeyEvent.xxx values, you need to use the getKeyCode method, which returns an int when you capture keyPressed or keyReleased events - you can then compare the value with a KeyEvent.xxx", "label": {"api": {"the getKeyCode method": [[63, 83]]}}}, {"text": "I didn't see any method in the Java FX 2 JavaDocs for WebView  that does what I want", "label": {"api": {"Java FX 2 JavaDocs for WebView ": [[31, 61]]}}}, {"text": "You need a custom ELResolver for this", "label": {"api": {"ELResolver": [[18, 27]]}}}, {"text": "Extending BeanELResolver and overriding getType(), getValue() and setValue() wherein you grab the concrete ValueHolder implementation should do it", "label": {"api": {"ELResolver": [[14, 23]], "BeanELResolver": [[10, 23]]}}}, {"text": "You can register the custom EL resolver on application's startup by Application#addELResolver()", "label": {"api": {"ELResolver": [[83, 92]]}}}, {"text": "The @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER) line says that it will cascade ALL updates", "label": {"api": {"CascadeType": [[23, 33]]}}}, {"text": "Look into CascadeType", "label": {"api": {"CascadeType": [[10, 20]]}}}, {"text": "I use the DecimalFormat class to format numbers to strings, and vice-versa", "label": {"api": {"DecimalFormat": [[10, 22]]}}}, {"text": "Is there a way to tell DecimalFormat not to use any decimal separator", "label": {"api": {"DecimalFormat": [[23, 35]]}}}, {"text": "Or the DecimalFormat class is not as flexible", "label": {"api": {"DecimalFormat": [[7, 19]]}}}, {"text": "Perhaps the BigDecimal class is something for you", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "Ideally, you move your \"work\" outside the EDT with a SwingWorker, and meanwhile the progressbar get updated through property change listeners in the EDT", "label": {"api": {"SwingWorker": [[53, 63]]}}}, {"text": "getLocationOnScreen exists in Java SE 6, but not Java SE 5 (notice the anchor goes nowhere)", "label": {"api": {"Java SE 6": [[30, 38]], "Java SE 5": [[49, 57]]}}}, {"text": "The String.replace() method is a good place to start", "label": {"api": {"String.replace()": [[4, 19]]}}}, {"text": "From the Set interface documentation", "label": {"api": {"Set interface documentation": [[9, 35]]}}}, {"text": "Also, be aware of this note from the documentation of Set", "label": {"api": {"note": [[23, 26]]}}}, {"text": "Use the URLEncoder class to perform the encoding", "label": {"api": {"URLEncoder class": [[8, 23]]}}}, {"text": "Continue with DateFormat#format(Date)", "label": {"api": {"DateFormat#format(Date)": [[14, 36]]}}}, {"text": "It's probably easiest to use a Scanner", "label": {"api": {"Scanner": [[31, 37]]}}}, {"text": "This method uses the HttpURLConnection class to make the request, and it has the setConnectTimeout method which you can use to timeout the request, but the facebook implementation does not let you pass a parameter for it, maybe since this method is new from java version 1.5 and they wanted the SDK to work for lower versions", "label": {"api": {"HttpURLConnection": [[21, 37]], "setConnectTimeout": [[81, 97]]}}}, {"text": "This can then be handled using the MessageFormat type", "label": {"api": {"MessageFormat": [[35, 47]]}}}, {"text": "Have you read the documentation on setCharacterAttributes", "label": {"api": {"setCharacterAttributes": [[35, 56]]}}}, {"text": "Write a small Java program which calls font.canDisplay(int codePoint) where codePoint must be the characters you want", "label": {"api": {"font.canDisplay(int codePoint)": [[39, 68]]}}}, {"text": "File.createNewFile() is required to be called", "label": {"api": {"File.createNewFile()": [[0, 19]]}}}, {"text": "Additionally, you can use endsWith instead of the regular expression", "label": {"api": {"endsWith": [[26, 33]]}}}, {"text": "FileNotFoundException is a checked exception", "label": {"api": {"FileNotFoundException": [[0, 20]]}}}, {"text": "I was looking at the source code of the sort() method of the java.util.ArrayList on grepcode", "label": {"api": {"java.util.ArrayList": [[61, 79]]}}}, {"text": "The way to see if equals and hashCode are overridden is to take a look at the API", "label": {"api": {"API": [[78, 80]]}}}, {"text": "In fact, AWTKeyStroke#hashCode states", "label": {"api": {"AWTKeyStroke#hashCode": [[9, 29]]}}}, {"text": "Good examples of such stateless, globally available methods are the methods from the java.lang.Math class", "label": {"api": {"java.lang.Math": [[85, 98]]}}}, {"text": "It is typical to implement shared functionality independent of the class instance in a static utility class, the same way that Java implements functionality common to all collections in the java.utils.Collections", "label": {"api": {"java.utils.Collections": [[190, 211]]}}}, {"text": "You could roll your own CountDownLatch out using a ReentrantLock that allows access to its protected getWaitingThreads method", "label": {"api": {"getWaitingThreads": [[101, 117]]}}}, {"text": "You want to use a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[18, 30]]}}}, {"text": "Instead of having your Test2 class contain a JPanel, you should have it subclass JPanel", "label": {"api": {"JPanel": [[45, 50], [81, 86]]}}}, {"text": "JPanel is a subclass of Component, so any method that takes a Component as an argument can also take a JPanel as an argument", "label": {"api": {"JPanel": [[0, 5], [103, 108]]}}}, {"text": "After trying a number of fruitless efforts, it looks like setting a page to zero margin and then calling PrinterJob.validatePage() seems to be the only way I can get a valid minimum-margin PageFormat", "label": {"api": {"PrinterJob.validatePage()": [[105, 129]]}}}, {"text": "Use the Collections sort() or Arrays sort() method which takes a Comparator and use a custom comparator which only inspects the first integer in the pair", "label": {"api": {"Collections sort()": [[8, 25]], "Arrays sort()": [[30, 42]], "Comparator": [[65, 74]]}}}, {"text": "There's a HttpServletResponse#addCookie()", "label": {"api": {"HttpServletResponse#addCookie()": [[10, 40]]}}}, {"text": "Add a MouseMotionListener to the game area and watch for mouseMoved(MouseEvent)", "label": {"api": {"MouseMotionListener": [[6, 24]], "mouseMoved(MouseEvent)": [[57, 78]]}}}, {"text": "I would recommend using AtomicLong or AtomicInteger instead of just having a primitive variable, as that way you get simple thread-safety", "label": {"api": {"AtomicLong": [[24, 33]], "AtomicInteger": [[38, 50]]}}}, {"text": "\"SwingWorker is only designed to be executed once.\" Instead control the worker's execution and life-cycle as shown in this example", "label": {"api": {"SwingWorker": [[1, 11]]}}}, {"text": "You can retrieve all of the Map's keys using the method keySet()", "label": {"api": {"keySet()": [[56, 63]]}}}, {"text": "As Torious suggested you probably want to use a VolatileImage if you are working in Java2D to get the benefits of hardware acceleration", "label": {"api": {"VolatileImage": [[48, 60]]}}}, {"text": "Use the get() method on your Calendar object, and use Calendar static constants for the needed field (hour, minute, etc...)", "label": {"api": {"get()": [[8, 12]]}}}, {"text": "You need to add an ActionListener to the checkbox", "label": {"api": {"add": [[12, 14]], "ActionListener": [[19, 32]]}}}, {"text": "You might be interested in using a WindowListener", "label": {"api": {"WindowListener": [[35, 48]]}}}, {"text": "The WindowListener tutorial", "label": {"api": {"WindowListener": [[4, 17]]}}}, {"text": "However, if you're looking for a place to do some cleanup and graceful shutdown stuff, then you probably want a shutdown hook instead", "label": {"api": {"shutdown hook": [[112, 124]]}}}, {"text": "I'm using a ScheduledThreadPoolExecutor and I suspect that there are at times too many outstanding requests for the number of threads available (yes...I probably need to tune the number of threads)", "label": {"api": {"ScheduledThreadPoolExecutor": [[12, 38]]}}}, {"text": "Seems that I would need to have a hook into when the ScheduledThreadPoolExecutor adds the task to its internal queue (ScheduledThreadPoolExecutor.super.queue.add(task)) but looking at the JDK's API and code there doesn't seem to be an easy way", "label": {"api": {"ScheduledThreadPoolExecutor": [[53, 79], [118, 144]]}}}, {"text": "If you call any of these methods on the EDT while Robot.isAutoWaitForIdle is true, an exception will be thrown", "label": {"api": {"Robot.isAutoWaitForIdle": [[50, 72]]}}}, {"text": "Here is a part from PriorityQueue Javadoc", "label": {"api": {"PriorityQueue Javadoc": [[20, 40]]}}}, {"text": "If you want a behavior like Queue<String> aQueue = new LinkedList<String>(); then your LinkedList must extend/implement the Queue class/interface", "label": {"api": {"Queue": [[28, 32], [43, 47], [124, 128]], "LinkedList": [[55, 64], [87, 96]]}}}, {"text": "Also, as the Java documentation states, Queue is an interface and LinkedList implements it", "label": {"api": {"Queue": [[40, 44]], "LinkedList": [[66, 75]]}}}, {"text": "If you want to implement a Queue using your LinkedList, you should see the code sample posted by @Tudor", "label": {"api": {"Queue": [[27, 31]], "LinkedList": [[44, 53]]}}}, {"text": "A CompletionService might be a possibility here", "label": {"api": {"CompletionService": [[2, 18]]}}}, {"text": "I think you are looking for JComponent#getVisibleRect()", "label": {"api": {"JComponent#getVisibleRect()": [[28, 54]]}}}, {"text": "Use a BufferedInputStream", "label": {"api": {"BufferedInputStream": [[6, 24]]}}}, {"text": "Lastly, you could use the ObjectOutputStream to write the data and the ObjectInputStream to re-read it back", "label": {"api": {"ObjectOutputStream": [[26, 43]], "ObjectInputStream": [[71, 87]]}}}, {"text": "Also, your classes will need to implement the Serializable interface", "label": {"api": {"Serializable": [[46, 57]]}}}, {"text": "It returns the same what Object.getClass() does for a given instance, but you can use it when you know statically what class you want (i.e", "label": {"api": {"Object.getClass()": [[25, 41]]}}}, {"text": "ArrayList should do what you need", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "To convert it to a Java Date instantiate a new Date Object (see Java doc) and invoke setTime() on that", "label": {"api": {"(see Java doc)": [[59, 72]]}}}, {"text": "In the handleMessage(...) method, you count the incoming messages and, as the Javadoc for the Handler interface indicates, return false if the overload limit is reached", "label": {"api": {"Javadoc for the Handler interface": [[78, 110]]}}}, {"text": "The client SSL certificate chain is available in a request attribute javax.servlet.request.X509Certificate", "label": {"api": {"javax.servlet.request.X509Certificate": [[69, 105]]}}}, {"text": "Use BigDecimal instead", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "I suggest you to use the recommended ProcessBuilder instead of Process", "label": {"api": {"ProcessBuilder": [[37, 50]]}}}, {"text": "You would better use a NavigableMap implementation, such as TreeMap, for this job, with the keys being the first elements in your rows and the values a List containing the rest of the numbers in each row, e.g", "label": {"api": {"NavigableMap": [[23, 34]], "TreeMap": [[60, 66]], "List": [[152, 155]]}}}, {"text": "You can use substring()", "label": {"api": {"substring()": [[12, 22]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/String.html before posting this kind of questions", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[0, 61]]}}}, {"text": "@Generated is used by meta-programs such as Auto/Value which generate source code so you don't have to manually write it", "label": {"api": {"@Generated": [[0, 9]]}}}, {"text": "If you're writing a .java file by hand (which is normally what one does), don't use @Generated", "label": {"api": {"@Generated": [[84, 93]]}}}, {"text": "Or as pointed out by @Guillaume use Dekstop.mail() (or the overloaded variant) specifically for the email client", "label": {"api": {"Dekstop.mail()": [[36, 49]]}}}, {"text": "My first guess was that you should look at javax.servlet.ServletContextListener but I'm not sure if that will help you since Spring is usually initialized in exactly such a listener", "label": {"api": {"javax.servlet.ServletContextListener": [[43, 78]]}}}, {"text": "Since it seems that your output is a properties file, you should use Properties.store() to generate the output file", "label": {"api": {"Properties.store()": [[69, 86]]}}}, {"text": "You can use the CropImageFilter to get your image", "label": {"api": {"CropImageFilter": [[16, 30]]}}}, {"text": "Reading the Java documentation for the ADT List it says", "label": {"api": {"Java documentation for the ADT List": [[12, 46]]}}}, {"text": "You need to setup a HttpSessionListener for your application", "label": {"api": {"HttpSessionListener": [[20, 38]]}}}, {"text": "ArrayBlockingQueue) to publish these \"files to process\"", "label": {"api": {"ArrayBlockingQueue": [[0, 17]]}}}, {"text": "See the documentation for setReadTimeout", "label": {"api": {"setReadTimeout": [[26, 39]]}}}, {"text": "If you want to print it out in a hex representation, use Integer.toHexString()", "label": {"api": {"Integer.toHexString()": [[57, 77]]}}}, {"text": "The VerifyError is evident that the class Class expects to find some native method that doesn't exist in the JRE getDeclaredConstructors0(Native Method)", "label": {"api": {"VerifyError": [[4, 14]]}}}, {"text": "You can call getState and check against Controller.Started", "label": {"api": {"getState": [[13, 20]], "Controller.Started": [[40, 57]]}}}, {"text": "Your item class will need to implement Cloneable and override the clone() method", "label": {"api": {"Cloneable": [[39, 47]], "clone()": [[66, 72]]}}}, {"text": "From the Javadoc for Object.clone()", "label": {"api": {"clone()": [[28, 34]]}}}, {"text": "Look for Preferences.systemNodeForPackage() and Preferences.userNodeForPackage() in the documentation", "label": {"api": {"Preferences.systemNodeForPackage()": [[9, 42]], "Preferences.userNodeForPackage()": [[48, 79]]}}}, {"text": "To sort the array you can use the sort method of the Arrays class", "label": {"api": {"sort method": [[34, 44]]}}}, {"text": "To run the D class, you should be at the package 'root', and supply the Fully Qualified Class Name", "label": {"api": {"Fully Qualified Class Name": [[72, 97]]}}}, {"text": "First, create a date and time pattern string as specified in the SimpleDateFormat javadocs and then call parse to convert the string to a Date object", "label": {"api": {"SimpleDateFormat": [[65, 80]], "parse": [[105, 109]]}}}, {"text": "Obviously, you need to check that the objects in your list are Cloneable otherwise they won't be copied correctly", "label": {"api": {"Cloneable": [[63, 71]]}}}, {"text": "The default implementation doesn't have such a method", "label": {"api": {"default implementation": [[4, 25]]}}}, {"text": "Margin have some problem with Border, to work around the problem you can try using a CompoundBorder setting an EmptyBorder as inner border and the desired border (lineBorder in your case) as outer border", "label": {"api": {"CompoundBorder": [[85, 98]]}}}, {"text": "You can use the TreeMap object where the Fruit name is the key and value is the number of times it has been seen", "label": {"api": {"TreeMap": [[16, 22]]}}}, {"text": "You iterate through the array fruit by fruit, using say a foreach loop and update that fruit's value in the TreeMap", "label": {"api": {"TreeMap": [[108, 114]]}}}, {"text": "Since we've used a TreeMap the keys will be in sorted order", "label": {"api": {"TreeMap": [[19, 25]]}}}, {"text": "The StringTokenizer has a constructor that takes another argument", "label": {"api": {"constructor": [[26, 36]]}}}, {"text": "Alternatively you could use the JarURLConnection if you know the exact jar in which your file resides", "label": {"api": {"JarURLConnection": [[32, 47]]}}}, {"text": "Arrays don't override the default toString() method", "label": {"api": {"toString()": [[34, 43]]}}}, {"text": "In order to print a representation of their contents, you can use Arrays.toString(int[])", "label": {"api": {"Arrays.toString(int[])": [[66, 87]]}}}, {"text": "Take a peek at the BlockingQueue", "label": {"api": {"BlockingQueue": [[19, 31]]}}}, {"text": "Semaphore looks like it might be closer to what you're looking for, actually -- it lets you wait until one or more \"permits\" is available", "label": {"api": {"Semaphore": [[0, 8]]}}}, {"text": "I think a closer match to what you want is a Phaser", "label": {"api": {"Phaser": [[45, 50]]}}}, {"text": "The NavigableSet and NavigableMap classes offer methods to do just that", "label": {"api": {"NavigableSet": [[4, 15]], "NavigableMap": [[21, 32]]}}}, {"text": "NavigableSet already offer methods like headSet and tailSet to get all elements before or after a other given element", "label": {"api": {"NavigableSet": [[0, 11]]}}}, {"text": "Likewise NavigableMap offer similar methods like headMap and tailMap to do exactly the same kind of slicing", "label": {"api": {"NavigableMap": [[9, 20]]}}}, {"text": "A TreeModel can only have one root node, but you can use JTree.setRootVisible() to hide the root node when displaying the tree", "label": {"api": {"JTree.setRootVisible()": [[57, 78]]}}}, {"text": "The Connection class implements the AutoClosable interface, which defines \"a resource that must be closed when it is no longer needed\"", "label": {"api": {"Connection": [[4, 13]], "AutoClosable": [[36, 47]]}}}, {"text": "On the other hand, the Connection.close() method is documented as \"releasing the Connection object's database and JDBC resources immediately instead of waiting for them to be automatically released\"", "label": {"api": {"Connection": [[23, 32], [81, 90]]}}}, {"text": "Try using the setPreferredSize() method on the button, although the layout manager has the final word on what size is used in the end", "label": {"api": {"setPreferredSize()": [[14, 31]]}}}, {"text": "Indeed ,  you should map this field but make it as read-only by setting its @Column.insertable() and @Column.updatable() to false", "label": {"api": {"@Column.insertable()": [[76, 95]], "@Column.updatable()": [[101, 119]]}}}, {"text": "You can use String.charAt(int) to get a character from any point in the string", "label": {"api": {"String.charAt(int)": [[12, 29]]}}}, {"text": "If you want to check for the existance of your entry, you can use a Set (a useful concrete implementation is HashSet", "label": {"api": {"Set": [[68, 70], [113, 115]], "HashSet": [[109, 115]]}}}, {"text": "If you do, make sure you implement equals() and hashCode() (here's an article explaining good practice)", "label": {"api": {"equals()": [[35, 42]], "hashCode()": [[48, 57]]}}}, {"text": "Arrays.asList() is a useful way of creating a list in-line in the code", "label": {"api": {"Arrays.asList()": [[0, 14]]}}}, {"text": "A more general list is an ArrayList", "label": {"api": {"ArrayList": [[26, 34]]}}}, {"text": "You can execute any shell command using Runtime.exec", "label": {"api": {"Runtime.exec": [[40, 51]]}}}, {"text": "Look at Class.getMethod and related methods, along with Method itself, for more details", "label": {"api": {"Class.getMethod": [[8, 22]], "Method": [[17, 22], [56, 61]]}}}, {"text": "You may want getDeclaredMethod instead, and you may need to make it accessible", "label": {"api": {"Method": [[24, 29]]}}}, {"text": "Btw, have you considered using a BitSet", "label": {"api": {"BitSet": [[33, 38]]}}}, {"text": "Depending on the amount of data you plan to send, you may need to call flush() to ensure that the data is sent without requiring the internal buffer to be full", "label": {"api": {"flush()": [[71, 77]]}}}, {"text": "Use the String.split() method with the , separator to get the list of pairs", "label": {"api": {"String.split()": [[8, 21]]}}}, {"text": "sleep() is a static method and causes the current thread to sleep for the specified amount of time", "label": {"api": {"sleep()": [[0, 6]]}}}, {"text": "According to the GSS-API/Kerberos v5 Authentication guide you must authenticate to Kerberos before making your call to the JNDI context", "label": {"api": {"GSS-API/Kerberos v5 Authentication": [[17, 50]]}}}, {"text": "One thing you could do is have the scheduled job push results into a BlockingQueue", "label": {"api": {"BlockingQueue": [[69, 81]]}}}, {"text": "IMO your best bet is to use the Executor framework", "label": {"api": {"Executor": [[32, 39]]}}}, {"text": "If you look at the documentation for matches(), uou will notice that it is trying to match the entire string", "label": {"api": {"matches()": [[37, 45]]}}}, {"text": "Why not use JTextArea's built in write function", "label": {"api": {"write": [[33, 37]]}}}, {"text": "You can do this by embedding a JVM within your application and writing a little bit of (untested) JNI to get and call a method on the JavaCompiler", "label": {"api": {"JavaCompiler": [[134, 145]]}}}, {"text": "The compiler was looked up from ToolProvider", "label": {"api": {"ToolProvider": [[32, 43]]}}}, {"text": "You can use the getSelectedIndex() method on the combobox to see if there is a selection", "label": {"api": {"getSelectedIndex()": [[16, 33]]}}}, {"text": "Use a PriorityQueue and assign different priorities to your tasks, which could change dynamically over time, for instance with Aging", "label": {"api": {"PriorityQueue": [[6, 18]]}}}, {"text": "And last but not least, as was already pointed out in the comments you could try both ConcurrentLinkDeque and let some fetch the front objects and some the rear objects", "label": {"api": {"ConcurrentLinkDeque": [[86, 104]]}}}, {"text": "Would PropertyChangeSupport suffice", "label": {"api": {"PropertyChangeSupport": [[6, 26]]}}}, {"text": "Hmm, well the API says yes it can send Objects", "label": {"api": {"API": [[14, 16]]}}}, {"text": "Perhaps you could use a BitSet", "label": {"api": {"BitSet": [[24, 29]]}}}, {"text": "You could drain the queue by calling drainTo(collection), then invoke processing yourself on all items (possibly via Futures etc), then your final processing", "label": {"api": {"drainTo(collection)": [[37, 55]]}}}, {"text": "isSelected() is the method you looking for, I guess", "label": {"api": {"isSelected()": [[0, 11]]}}}, {"text": "The TimeZone class has a method called useDaylightTime(), which 'queries if this timezone uses daylight savings time'", "label": {"api": {"TimeZone": [[4, 11]], "useDaylightTime()": [[39, 55]]}}}, {"text": "Java has a static function called Collections.sort(List, Comparator) which sorts a (generified) List of objects given a custom Comparator which, given two objects of the same type, determines which one is ordered before the other", "label": {"api": {"Collections.sort(List, Comparator)": [[34, 67]], "Comparator": [[57, 66], [127, 136]]}}}, {"text": "Your task is to write a function which creates a Comparator which orders the objects based on its arguments and the user specified sort order", "label": {"api": {"Comparator": [[49, 58]]}}}, {"text": "Try using WritableRaster", "label": {"api": {"WritableRaster": [[10, 23]]}}}, {"text": "As you cannot just add more charachters to a regular String in Java", "label": {"api": {"String": [[53, 58]]}}}, {"text": "You should use the StringBuffer to do this", "label": {"api": {"String": [[19, 24]], "StringBuffer": [[19, 30]]}}}, {"text": "You can loop through the String with a for loop and then so something after every 100th character", "label": {"api": {"String": [[25, 30]]}}}, {"text": "I need to measure the width of an AttributedString in pixels", "label": {"api": {"AttributedString": [[34, 49]]}}}, {"text": "In Java SE, I'd get an AttributedCharacterIterator from my AttributedString and pass it to FontMetrics#getStringBounds, but in J2ME PBP, FontMetrics doesn't have a getStringBounds method, or any other method that accepts a CharacterIterator", "label": {"api": {"AttributedString": [[59, 74]], "AttributedCharacterIterator": [[23, 49]], "FontMetrics": [[91, 101], [137, 147]]}}}, {"text": "I have tried to implement it in EventQueue, but it did not work", "label": {"api": {"EventQueue": [[32, 41]]}}}, {"text": "This is done by using the config option described in the top level class documentation of the LogManger", "label": {"api": {"LogManger": [[94, 102]]}}}, {"text": "Using the identifier, and your repository, or an EntityManager persistence context (both injected to the class by Spring), you get the object from your repository", "label": {"api": {"EntityManager": [[49, 61]]}}}, {"text": "Using your object's setters, update the object from the repository with the fields of the other object, and then validate it using your Validator also injected to this class by Spring", "label": {"api": {"Validator": [[136, 144]]}}}, {"text": "If you want to sleep, Thread.sleep has 2 methods, one of which accepts nanoseconds", "label": {"api": {"one of which accepts nanoseconds": [[50, 81]]}}}, {"text": "If you want to schedule a task, you can use a ScheduledExecutorService which schedule methods can use nanoseconds too", "label": {"api": {"ScheduledExecutorService": [[46, 69]]}}}, {"text": "The java.util.concurrent package uses TimeUnit for timing", "label": {"api": {"TimeUnit": [[38, 45]]}}}, {"text": "TimeUnit has a NANOSECONDS field", "label": {"api": {"TimeUnit": [[0, 7]]}}}, {"text": "Because you use the DecimalFormat with the standard pattern", "label": {"api": {"DecimalFormat": [[20, 32]]}}}, {"text": "Or you use NumberFormat.getCurrencyInstance()", "label": {"api": {"NumberFormat.getCurrencyInstance()": [[11, 44]]}}}, {"text": "The most \"natural\" way to save a SecretKey into a file in Java is to use a KeyStore", "label": {"api": {"a KeyStore": [[73, 82]]}}}, {"text": "The example in the documentation shows how to save a private key and a secret key", "label": {"api": {"example in the documentation": [[4, 31]]}}}, {"text": "If you look closer to the close() method of AutoCloseable", "label": {"api": {"close() method of AutoCloseable": [[26, 56]]}}}, {"text": "Or even Closeable close() method", "label": {"api": {"Closeable close() method": [[8, 31]]}}}, {"text": "Whereas the close() method of XMLStreamReader says", "label": {"api": {"close() method of XMLStreamReader": [[12, 44]], "Reader": [[39, 44]]}}}, {"text": "Frees any resources associated with this Reader", "label": {"api": {"Reader": [[41, 46]]}}}, {"text": "Indeed the input source is managed by the Reader which implement the Closeable interface", "label": {"api": {"Reader": [[42, 47]]}}}, {"text": "You can just call getTime() to get milliseconds since the Unix epoch", "label": {"api": {"getTime()": [[18, 26]]}}}, {"text": "So you should usually be using getTime() in conjunction with getNanos()", "label": {"api": {"getTime()": [[31, 39]]}}}, {"text": "I would advise that you look into String.split(String regex), which will allow you to split your symbols and your numerals", "label": {"api": {"String.split(String regex)": [[34, 59]]}}}, {"text": "String.split(Sting regex) would be a great place to start", "label": {"api": {"String.split(Sting regex)": [[0, 24]]}}}, {"text": "You can use the String.split() method to do this", "label": {"api": {"String.split()": [[16, 29]]}}}, {"text": "You can also use a StringTokenizer to do this, but that seems to be discouraged", "label": {"api": {"StringTokenizer": [[19, 33]]}}}, {"text": "Use String#equals(), not ==, to compare strings", "label": {"api": {"String#equals()": [[4, 18]]}}}, {"text": "You must use an Integer instead", "label": {"api": {"Integer": [[16, 22]]}}}, {"text": "unless you're doing this as an academic exercise, you can/should just use a List<T> instead of your custom-implemented class", "label": {"api": {"List<T>": [[76, 82]]}}}, {"text": "I think you are looking for BigDecimal, which lets you control the granularity, as you want, for example with its round() method", "label": {"api": {"BigDecimal": [[28, 37]], "round()": [[114, 120]]}}}, {"text": "retainAll does remove items from the list it is invoked on", "label": {"api": {"retainAll": [[0, 8]]}}}, {"text": "If you can get any kind of output of what your program prints during runtime, you can put into your application some debug code where you use File.listFiles() to crawl the machine's directory trees", "label": {"api": {"File.listFiles()": [[142, 157]]}}}, {"text": "What you need to use for exact percision is the BigDecimal object", "label": {"api": {"BigDecimal": [[48, 57]]}}}, {"text": "You could try a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[16, 39]]}}}, {"text": "If the purpose of the dragging is to change the order in a slideshow or similar, look to a JList", "label": {"api": {"JList": [[91, 95]]}}}, {"text": "See setDragEnabled(true) & How to Use Lists for more details", "label": {"api": {"setDragEnabled(true)": [[4, 23]]}}}, {"text": "JList uses a JLabel as the rendering component by default", "label": {"api": {"JList": [[0, 4]]}}}, {"text": "Note that \"Extended modifiers represent the state of all modal keys, such as ALT, CTRL, META, and the mouse buttons just after the event occurred,\" so the presence of extModifiers on some events does not seem inconsistent", "label": {"api": {"Extended modifiers": [[11, 28]]}}}, {"text": "I don't see anything indicating that MOUSE_MOVED events include any modifiers at all", "label": {"api": {"MOUSE_MOVED": [[37, 47]]}}}, {"text": "You can differentiate between the key press and release by passing the correct KeyStroke object into the bound component's InputMap using the KeyStroke.getKeyStroke(int keyCode, int modifiers, boolean onKeyRelease) method found here", "label": {"api": {"InputMap": [[123, 130]]}}}, {"text": "Here's the Scanner documentation", "label": {"api": {"Scanner documentation": [[11, 31]]}}}, {"text": "Similar to Uluk's second suggestion, unless you want to build a pure JavaFX version yourself, I'd suggest wrapping something like Google Calendar in a WebView and programming it via a Java/JavaScript bridge", "label": {"api": {"WebView": [[151, 157]]}}}, {"text": "To change the foreground color use \"-fx-text-fill", "label": {"api": {"-fx-text-fill": [[36, 48]]}}}, {"text": "Indeed, this is the way the default exception API handles the error messages and causes, passing them as constructor parameters (see Exception constructors API Doc) to be handled later", "label": {"api": {"Exception": [[133, 141]]}}}, {"text": "You register a ServletContextListener which programmatically registers Servlet instances with the addServlet(String, Servlet) method of ServletContext just before the app starts", "label": {"api": {"ServletContextListener": [[15, 36]], "addServlet(String, Servlet)": [[98, 124]]}}}, {"text": "You should go via the File api", "label": {"api": {"File": [[22, 25]]}}}, {"text": "Quoted from the File.getName() documentation", "label": {"api": {"File": [[16, 19]], "File.getName()": [[16, 29]]}}}, {"text": "If that does'nt help you may catch user in/output and pipe to the Process", "label": {"api": {"Process": [[66, 72]]}}}, {"text": "If you use JMS API, check the JMSXDeliveryCount property by calling msessage.getIntProperty(\"JMSXDeliveryCount\") before you start processing the message", "label": {"api": {"msessage.getIntProperty(\"JMSXDeliveryCount\")": [[68, 111]]}}}, {"text": "If you want to have variable size \"arrays\", use ArrayList", "label": {"api": {"ArrayList": [[48, 56]]}}}, {"text": "Although JavaDoc is a bit harsh on name() method, I would actually advice using it in case given enum has toString() overriden", "label": {"api": {"JavaDoc is a bit harsh on name()": [[9, 40]]}}}, {"text": "I haven't benchmarked this, but how about using BigDecimal", "label": {"api": {"BigDecimal": [[48, 57]]}}}, {"text": "Java 1.4 introduced getCause() method on Throwable class which is a parent for all Exception classes", "label": {"api": {"getCause()": [[20, 29]]}}}, {"text": "You can get the name of a host (but not the domain name) by using getCanonicalHostName()  on InetAddress - that should work", "label": {"api": {"InetAddress": [[93, 103]]}}}, {"text": "Have a look at java.net.InetAddress", "label": {"api": {"java.net.InetAddress": [[15, 34]]}}}, {"text": "ImageIO.read(URL)), loaded asynchronously (e.g", "label": {"api": {"ImageIO.read(URL)": [[0, 16]]}}}, {"text": "Toolkit.createImage(URL)) or generated in memory", "label": {"api": {"Toolkit.createImage(URL)": [[0, 23]]}}}, {"text": "Instead you want to assign the result of the getFollowersIDs() call to a separate local array and afterwards use arraycopy to copy the 5000 current followers into the much larger array of all followers", "label": {"api": {"arraycopy": [[113, 121]]}}}, {"text": "if(line.matches(\"Answer \\\\d[\\\\:\\\\.]\")), and if you are not yet used to it, see the Pattern Docs, as String.matches() is something you will probably use a lot when processing text", "label": {"api": {"Pattern Docs": [[83, 94]]}}}, {"text": "Try to change to ProcessBuilder", "label": {"api": {"ProcessBuilder": [[17, 30]]}}}, {"text": "String.valueOf will return a string representation of primitive data types", "label": {"api": {"String.valueOf": [[0, 13]]}}}, {"text": "I believe that you want to extend javax.swing.SwingWorker", "label": {"api": {"javax.swing.SwingWorker": [[34, 56]]}}}, {"text": "The non-ui start-up functionality would run in doInBackground and the done method would be called when it finishes to update the ui", "label": {"api": {"doInBackground": [[47, 60]], "done": [[70, 73]]}}}, {"text": "There is another way using Java 8 Stream API", "label": {"api": {"Java 8 Stream API": [[27, 43]]}}}, {"text": "You should implement your concurrent class by extending the java.util.concurrent.Executor interface built into JavaSE, and then using the Spring IoC container, you can inject in an implementation class of WorkManagerTaskExecutor when running under Websphere", "label": {"api": {"java.util.concurrent.Executor": [[60, 88]]}}}, {"text": "If you are using Java 7, you can use the @SafeVarargs annotation on the factory method to suppress the warning for every invocation of newInstance", "label": {"api": {"@SafeVarargs": [[41, 52]]}}}, {"text": "Call listIterator() on your list to create one, then see relevant methods on ListIterator", "label": {"api": {"listIterator()": [[5, 18]]}}}, {"text": "You might be able to use the java.util.StringTokenizer but in many cases this is not flexible enough", "label": {"api": {"java.util.StringTokenizer": [[29, 53]]}}}, {"text": "You want to use the Scanner class of Java to consume that huge file word by word", "label": {"api": {"Scanner": [[20, 26]]}}}, {"text": "Check out the getDateInstance(int, Locale) method", "label": {"api": {"getDateInstance(int, Locale)": [[14, 41]]}}}, {"text": "Have you tried ReentrantReadWriteLock.getReadLockCount()", "label": {"api": {"ReentrantReadWriteLock.getReadLockCount()": [[15, 55]]}}}, {"text": "The default toString on Object returns what you're seeing, which is not an address, but rather the name of the class, a @, and the hex version of the object's hash code", "label": {"api": {"hex version of the object's hash code": [[131, 167]]}}}, {"text": "You're looking for the method ServletContext.getResourceAsStream(), which loads a resource from a path starting at the webapp's root folder", "label": {"api": {"ServletContext.getResourceAsStream()": [[30, 65]]}}}, {"text": "Use split(), for all practical purposes StringTokenizer is deprecated (it's still there only for backwards compatibility)", "label": {"api": {"split()": [[4, 10]]}}}, {"text": "You want to use split", "label": {"api": {"split": [[16, 20]]}}}, {"text": "You can use getStackTrace to get an array of StackTraceElement instances, and filter that based on your package and/or class names (using getClassName for each element, which gives you the fully-qualified class name for that stack trace frame)", "label": {"api": {"getStackTrace": [[12, 24]], "StackTraceElement": [[45, 61]], "getClassName": [[138, 149]]}}}, {"text": "The easiest way (though not most efficient) will probably be to populate a list with all elements, use Collections.shuffle(), and select the first 10% elements", "label": {"api": {"Collections.shuffle()": [[103, 123]]}}}, {"text": "I would use java.awt.Color for this", "label": {"api": {"java.awt.Color": [[12, 25]]}}}, {"text": "In this case, the repaint() method will indirectly call paintComponent(), meanwhile, the Timer will set off a call to actionPerformed", "label": {"api": {"actionPerformed": [[118, 132]]}}}, {"text": "To move the cursor back to the center of the screen you can try using the java.awt.Robot class", "label": {"api": {"java.awt.Robot": [[74, 87]]}}}, {"text": "First, the \"year\" argument is supposed to be \"the year minus 1900\"", "label": {"api": {"the year minus 1900": [[46, 64]]}}}, {"text": "Second, January is month 0, not month 1", "label": {"api": {"January is month 0, not month 1": [[8, 38]]}}}, {"text": "If you call repaint() within your paint() method, it will keep calling paint() over and over again", "label": {"api": {"repaint()": [[12, 20]]}}}, {"text": "Double.MIN_VALUE doesn't mean what you think it means", "label": {"api": {"Double.MIN_VALUE": [[0, 15]]}}}, {"text": "'AbstractTableModel.fireTableDataChanged()' is used to indicate to the model (and the JTable UI which is notified by the model) that all possible data in the table may have changed and needs to be checked", "label": {"api": {"AbstractTableModel": [[1, 18]]}}}, {"text": "If you know which rows have been added, just use the 'AbstractTableModel.fireTableRowsInserted(int firstRow, int lastRow)' method instead", "label": {"api": {"AbstractTableModel": [[54, 71]]}}}, {"text": "Take a look at all the fire* methods in AbstractTableModel", "label": {"api": {"AbstractTableModel": [[40, 57]]}}}, {"text": "executeUpdate returns an int", "label": {"api": {"executeUpdate returns an int": [[0, 27]]}}}, {"text": "Sounds like a job for java.util.Scanner", "label": {"api": {"java.util.Scanner": [[22, 38]]}}}, {"text": "If an unsupported operation is invoked, a collection throws an UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[63, 91]]}}}, {"text": "Every time you call Iterator.next(), it advances the iterator to the next element in the iteration", "label": {"api": {"Iterator.next()": [[20, 34]]}}}, {"text": "You can only make a suggestion API", "label": {"api": {"API": [[31, 33]]}}}, {"text": "For cross-platform convenience, use getMenuShortcutKeyMask()", "label": {"api": {"getMenuShortcutKeyMask()": [[36, 59]]}}}, {"text": "Apart from that, there is an AutoCloseable interface and a feature called try-with-resources in Java 7, which may simplify your case (i.e", "label": {"api": {"AutoCloseable": [[29, 41]]}}}, {"text": "I just shortened http://www.youtube.com URL to http://bit.ly/9b2Y3D", "label": {"api": {"URL": [[40, 42]]}}}, {"text": "You see, the shortened URL returns 302 as opposed to 200 OK", "label": {"api": {"URL": [[23, 25]]}}}, {"text": "Then look at URL class,e specially how it implements equals()", "label": {"api": {"URL": [[13, 15]], "equals()": [[53, 60]]}}}, {"text": "Can you return a List, Set, or Map", "label": {"api": {"List": [[17, 20]], "Set": [[23, 25]], "Map": [[31, 33]]}}}, {"text": "Once you have that you can call setIconImages(List) instead of setIconImage() to define the icons that the operating system can use", "label": {"api": {"setIconImages(List)": [[32, 50]]}}}, {"text": "To convert a string of bits into a long, you can use Long.parseLong", "label": {"api": {"Long.parseLong": [[53, 66]]}}}, {"text": "To drop off all but the top two bits, you can use Long.bitCount to count the bits, then shift off the remaining bits", "label": {"api": {"Long.bitCount": [[50, 62]]}}}, {"text": "Since the question you're asking has to do with going from longs to the bits of the longs, you should use the Long.toBinaryString method for this", "label": {"api": {"Long.toBinaryString": [[110, 128]]}}}, {"text": "For example, you could try and see what Double.parseDouble(String s) returns for you", "label": {"api": {"Double.parseDouble(String s)": [[40, 67]]}}}, {"text": "If you don't mind the (extremely) minor performance hit--which is probably no worse than doing a regex match--use Integer.parseInt() or Double.parseDouble()", "label": {"api": {"Integer.parseInt()": [[114, 131]], "Double.parseDouble()": [[136, 155]]}}}, {"text": "If you need to handle longer strings of numbers, both BigInteger and BigDecimal sport constructors that accept Strings", "label": {"api": {"BigInteger": [[54, 63]], "BigDecimal": [[69, 78]]}}}, {"text": "Any of these will throw a NumberFormatException if you try to pass it a non-number (integral or decimal, based on the one you choose, of course)", "label": {"api": {"NumberFormatException": [[26, 46]]}}}, {"text": "Alternately, depending on your requirements, just iterate the characters in the String and check Character.isDigit() and/or Character.isLetter()", "label": {"api": {"Character.isDigit()": [[97, 115]], "Character.isLetter()": [[124, 143]]}}}, {"text": "Consider moving your socket in a SwingWorker which returns progressively the values of your Socker to the GUI", "label": {"api": {"SwingWorker": [[33, 43]]}}}, {"text": "The name of the input field is available by Part#getName()", "label": {"api": {"Part#getName()": [[44, 57]]}}}, {"text": "The content of the uploaded file is available by Part#getInputStream()", "label": {"api": {"Part#getInputStream()": [[49, 69]]}}}, {"text": "Yes, it's contains", "label": {"api": {"contains": [[10, 17]]}}}, {"text": "Yes contains method in LinkedList API will return true if it contains the search element", "label": {"api": {"contains": [[4, 11], [61, 68]]}}}, {"text": "For a fancier search you should use a Map instead of a list or any other collection, but that's an entirely different data structure", "label": {"api": {"Map": [[38, 40]]}}}, {"text": "contains(Object) is indeed what you're looking for", "label": {"api": {"contains(Object)": [[0, 15]]}}}, {"text": "You could also use Collections.binarysearch(List, T) if the list is sorted in ascending order", "label": {"api": {"Collections.binarysearch(List, T)": [[19, 51]]}}}, {"text": "Since it seems you want to know where the item is placed in the list so you can access the actual instance found, you want to use indexOf to find it and get to return the found instance", "label": {"api": {"indexOf": [[130, 136]], "get": [[153, 155]]}}}, {"text": "You can use a Default Uncaught Exception Handler to catch any unhanded exceptions", "label": {"api": {"Default Uncaught Exception Handler": [[14, 47]]}}}, {"text": "I don't have much experience with them, but I think you could be able to do that by wrapping your arrays (and sub-arrays) into IntBuffer instances", "label": {"api": {"IntBuffer": [[127, 135]]}}}, {"text": "I would recommend you to use the Executors framework and call Future.get(long, TimeUnit)", "label": {"api": {"Future.get(long, TimeUnit)": [[62, 87]]}}}, {"text": "You can use the java class TimerTask for repeated execution of a method", "label": {"api": {"TimerTask": [[27, 35]], "Timer": [[27, 31]]}}}, {"text": "Timer, which uses TimerTask to schedule tasks", "label": {"api": {"TimerTask": [[18, 26]], "Timer": [[0, 4], [18, 22]]}}}, {"text": "This is also a use-case for the Executors framework, specifically scheduleAtFixedRate", "label": {"api": {"scheduleAtFixedRate": [[66, 84]]}}}, {"text": "Or, if you want something simpler, use the Timer API", "label": {"api": {"Timer": [[43, 47]]}}}, {"text": "You can construct a Timer with a boolean argument meaning \"use daemon thread\"", "label": {"api": {"Timer": [[20, 24]]}}}, {"text": "You could take a look at the DecimalFormat Class and format your result as how you wish", "label": {"api": {"DecimalFormat": [[29, 41]]}}}, {"text": "The closest what CDI offers is the @ConversationScoped", "label": {"api": {"@ConversationScoped": [[35, 53]]}}}, {"text": "Use its .getMetaData() method", "label": {"api": {".getMetaData() method": [[8, 28]]}}}, {"text": "You could map it with an ElementCollection so JPA would know how to handle it", "label": {"api": {"ElementCollection": [[25, 41]]}}}, {"text": "It doesn't provide a 64 bit hash, but given the title of the question it's probably worth mentioning that since Java 1.7 there is java.util.Objects#hash(Object...)", "label": {"api": {"java.util.Objects#hash(Object...)": [[130, 162]]}}}, {"text": "Use Character.toLowerCase() followed by String.valueOf()", "label": {"api": {"Character.toLowerCase()": [[4, 26]], "String.valueOf()": [[40, 55]]}}}, {"text": "In Java 7 you can use NIO util class Files as follows", "label": {"api": {"Files": [[37, 41]]}}}, {"text": "NavigableMap allows you to get a sub-map back, but it requires that you specify a 'from key' and a 'to key', so you can't do it purely on index", "label": {"api": {"NavigableMap": [[0, 11]]}}}, {"text": "Perhaps not the safest way, but you might consider using the Window#getWindows method", "label": {"api": {"Window#getWindows": [[61, 77]]}}}, {"text": "You can use the alternate method signature for File.listFiles(FilenameFilter filter) to simplify your code", "label": {"api": {"File.listFiles(FilenameFilter filter)": [[47, 83]]}}}, {"text": "Try the Executor Service", "label": {"api": {"Executor": [[8, 15]]}}}, {"text": "JAXB is very good if your XML directly maps to the objects you want to create", "label": {"api": {"JAXB": [[0, 3]]}}}, {"text": "JDOM is useful if you want to navigate you XML in complex ways, eg, if you implement something like XPath; but for simple parsing its overkill", "label": {"api": {"JDOM": [[0, 3]]}}}, {"text": "SAX was the lightest and most efficient parser before StAX was around", "label": {"api": {"SAX": [[0, 2]]}}}, {"text": "I know, how to convert a Timestamp to a long, with the getTime() method", "label": {"api": {"getTime()": [[55, 63]]}}}, {"text": "As it's in the webcontent folder already, just get it by ServletContext#getResourceAsStream() instead", "label": {"api": {"ServletContext#getResourceAsStream()": [[57, 92]]}}}, {"text": "Note that the getServletContext() is inherited from the GenericServlet class which the HttpServlet extends from, so you don't need to provide the method yourself", "label": {"api": {"getServletContext()": [[14, 32]]}}}, {"text": "I think you're looking for the Robot class", "label": {"api": {"Robot": [[31, 35]]}}}, {"text": "See Robot.mousePress(int) for activating the button", "label": {"api": {"Robot.mousePress(int)": [[4, 24]]}}}, {"text": "If you look at ReferenceQueue you will see that it explicitly supports threading inside the platform, because it states that the remove() method will block until a new entry is available", "label": {"api": {"ReferenceQueue": [[15, 28]]}}}, {"text": "The synchronized you see in WeakHashMap is about ensuring that multiple threads accessing a ReferenceQueue are properly synchronized", "label": {"api": {"ReferenceQueue": [[92, 105]]}}}, {"text": "To answer your question, I think external synchronization of the ReferenceQueue is not required if you ensure it is only accessed by a single thread", "label": {"api": {"ReferenceQueue": [[65, 78]]}}}, {"text": "I would not use (and can't think of a good reason) to use a single ReferenceQueue as a consumer from multiple threads", "label": {"api": {"ReferenceQueue": [[67, 80]]}}}, {"text": "The InputStream returned by getSystemResourceAsStream is not an AudioInputStream, so casting it will never work", "label": {"api": {"AudioInputStream": [[64, 79]]}}}, {"text": "Just create a new AudioInputStream instead", "label": {"api": {"AudioInputStream": [[18, 33]]}}}, {"text": "See also AudioSystem.getAudioInputStream(InputStream) but this is 'more dangerous'", "label": {"api": {"AudioSystem.getAudioInputStream(InputStream)": [[9, 52]]}}}, {"text": "Another solution would be to switch to using the ConcurrentSkipListMap which was added in Java 6", "label": {"api": {"ConcurrentSkipListMap": [[49, 69]]}}}, {"text": "using java.io.File or maybe JDK7's new File I/O mechanism", "label": {"api": {"java.io.File": [[6, 17]]}}}, {"text": "This blog post found the field in Toolkit that controls it, named awtAppClassName", "label": {"api": {"Toolkit": [[34, 40]]}}}, {"text": "Use Desktop#browse() wherein you just specify the URI of that file (exactly the one as you would enter in the address bar of a normal webbrowser)", "label": {"api": {"Desktop#browse()": [[4, 19]]}}}, {"text": "You can explicitly call URLConnection.connect() or get any information about the HTTP response such as HttpURLConnection.getResponseCode etc to trigger HTTP request", "label": {"api": {"URLConnection.connect()": [[24, 46]], "HttpURLConnection.getResponseCode": [[103, 135]]}}}, {"text": "You could use a List to do what you want", "label": {"api": {"List": [[16, 19]]}}}, {"text": "Another way will be to use System.arraycopy", "label": {"api": {"System.arraycopy": [[27, 42]]}}}, {"text": "You should use a KeyListener to capture keyboard events", "label": {"api": {"KeyListener": [[17, 27]]}}}, {"text": "Perhaps you need a NavigableMap, like a TreeMap", "label": {"api": {"NavigableMap": [[19, 30]]}}}, {"text": "LinkedHashMap is also a good choice", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "Your connector probably doesn't support TYPE_FORWARD_ONLY you can check it using DatabaseMetaData#supportsResultSetType(int)", "label": {"api": {"DatabaseMetaData#supportsResultSetType(int)": [[81, 123]]}}}, {"text": "There is also a methodisAfterLast which you can check after a call to next", "label": {"api": {"isAfterLast": [[22, 32]]}}}, {"text": "Look into double buffering and BufferStrategy", "label": {"api": {"BufferStrategy": [[31, 44]]}}}, {"text": "Once upon a time you'd do it yourself by painting to an offscreen image then drawing the offscreen image to your applet in a single go - but these days you can use BufferStrategy", "label": {"api": {"BufferStrategy": [[164, 177]]}}}, {"text": "BufferStrategy javadoc shows you how to use the new way", "label": {"api": {"BufferStrategy": [[0, 13]]}}}, {"text": "What you have to do is, first create a class implementing ServletContextListener", "label": {"api": {"ServletContextListener": [[58, 79]]}}}, {"text": "See the javadoc of ListChangeListener.Change for a simple canonical example", "label": {"api": {"javadoc of ListChangeListener.Change": [[8, 43]]}}}, {"text": "This means that you can specify that the type parameter must be a Number", "label": {"api": {"Number": [[66, 71]]}}}, {"text": "You can then use the methods in the Number class (intValue(), doubleValue(), etc.) to turn it into a primitive, and do arithmetic on that", "label": {"api": {"Number": [[36, 41]]}}}, {"text": "Assuming that each connected client opens a session, I think I would use an HttpSessionListener for that purpose", "label": {"api": {"HttpSessionListener": [[76, 94]]}}}, {"text": "However, you could probably improve this by explicitly destroying the session (session.invalidate()) when a user leaves your application (using addWindowClosingHandler)", "label": {"api": {"invalidate()": [[87, 98]]}}}, {"text": "HashMap.values() returns a Collection", "label": {"api": {"HashMap.values()": [[0, 15]]}}}, {"text": "You should have a look at RoundingMode, especially HALF_UP", "label": {"api": {"RoundingMode": [[26, 37]]}}}, {"text": "You should use the string constructor to avoid rounding errors due to the use of doubles", "label": {"api": {"string constructor": [[19, 36]]}}}, {"text": "Javadoc extract for the constructor using doubles - emphasis mine", "label": {"api": {"constructor using doubles": [[24, 48]]}}}, {"text": "The ServletContext in turn is available in the session listener by HttpSession#getServletContext()", "label": {"api": {"HttpSession#getServletContext()": [[67, 97]]}}}, {"text": "The easier way to do this may be to request that users of your application set their default browser to IE, and then call the JavaFX hostservices.showDocument(uri) api to launch an IE page which embeds the OCX components you need", "label": {"api": {"hostservices.showDocument(uri)": [[133, 162]]}}}, {"text": "Java docs on BigDecimal", "label": {"api": {"Java docs on BigDecimal": [[0, 22]]}}}, {"text": "\"Pre-coded\", or pre-written Java classes, are pretty much the same concept as the Java API - someone has written the code for you, was kind enough to document how you can use the code, and you may create instances (as necessary) through the prescribed way", "label": {"api": {"Java API": [[82, 89]]}}}, {"text": "simply call getClass()", "label": {"api": {"getClass()": [[12, 21]]}}}, {"text": "You can easily find out whether the method is called on an X or Y, using getClass()", "label": {"api": {"getClass()": [[73, 82]]}}}, {"text": "The SSLEngine will only resume sessions if you create it with SSLContext.createEngine(host, port)", "label": {"api": {"SSLContext.createEngine(host, port)": [[62, 96]]}}}, {"text": "Both are just as easy as one another, the only difference is you call ResultSet.next()", "label": {"api": {"ResultSet.next()": [[70, 85]]}}}, {"text": "Combine with an Optional for optional values instead of null", "label": {"api": {"Optional": [[16, 23]]}}}, {"text": "Using Java 8 or above you can use an Optional and Java Streams", "label": {"api": {"Optional": [[37, 44]]}}}, {"text": "So you can simply use the JdbcTemplate.queryForList() method, create a Stream and use Stream.findFirst() which will return the first value of the Stream or an empty Optional", "label": {"api": {"Optional": [[165, 172]], "Stream.findFirst()": [[86, 103]]}}}, {"text": "You can do this by specifying a port number of zero when creating the InetSocketAddress", "label": {"api": {"specifying a port number of zero when creating the InetSocketAddress": [[19, 86]]}}}, {"text": "You can then find the actual port in useby querying the server for its port after creating it, and use that in tests", "label": {"api": {"querying the server for its port": [[43, 74]]}}}, {"text": "Change the global server socket factory to a custom factory which returns the same server socket every time", "label": {"api": {"Change the global server socket factory": [[0, 38]]}}}, {"text": "As seen in the documentation for com.sun.net.httpserver", "label": {"api": {"documentation for com.sun.net.httpserver": [[15, 54]]}}}, {"text": "Alternatively, you could look at an ArrayList, which will automatically grow in size if needed", "label": {"api": {"ArrayList": [[36, 44]]}}}, {"text": "And in your case, the size of array is not determined, ArrayList is better", "label": {"api": {"ArrayList": [[55, 63]]}}}, {"text": "Consider using the PreparedStatement setObject() method instead of setString()", "label": {"api": {"setObject()": [[37, 47]]}}}, {"text": "The PreparedStatement setObject() will attempt to convert any of the java.lang types for you if the type is unknown at compile time", "label": {"api": {"setObject()": [[22, 32]], "type": [[79, 82], [100, 103]]}}}, {"text": "Note that setNull() can accept a type as the 2nd parameter if it is known", "label": {"api": {"setNull()": [[10, 18]], "type": [[33, 36]]}}}, {"text": "You're using an ObjectOutputStream, which does Java object serialisation", "label": {"api": {"ObjectOutputStream": [[16, 33]]}}}, {"text": "Since you're only sending a String, you don't need to use an ObjectOutputStream - just use the OutputStream returned from the socket", "label": {"api": {"ObjectOutputStream": [[61, 78]]}}}, {"text": "For simple List implementations (simple value list storage), you can use the ArrayList class", "label": {"api": {"ArrayList": [[77, 85]]}}}, {"text": "For Map (key-value storage), use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[33, 45]]}}}, {"text": "String is final and therefore cannot be extended", "label": {"api": {"String is final": [[0, 14]]}}}, {"text": "You can use System.getProperty(String key); method with \"java.version\" as key", "label": {"api": {"System.getProperty(String key);": [[12, 42]]}}}, {"text": "As other answer point out, I would recommend you look into PreparedStatement to avoid possible SQL Injection and PreparedStatement will help you escape special character as well, for example ' char in which to avoid SQL syntax error", "label": {"api": {"PreparedStatement": [[59, 75], [113, 129]]}}}, {"text": "Read its API doc, and the tutorial about concurrency in Swing", "label": {"api": {"its API doc": [[5, 15]]}}}, {"text": "Use one of the ResultSet.getTimestamp() methods, and you'll have a java.sql.Timestamp object directly, which extends java.util.Date", "label": {"api": {"ResultSet.getTimestamp()": [[15, 38]], "java.sql.Timestamp": [[67, 84]]}}}, {"text": "The bundled class java.util.UUID can generate either a version 3 or version 4 UUID", "label": {"api": {"java.util.UUID": [[18, 31]]}}}, {"text": "Then I would create a ScheduledExecutorService, and submit the \"vanilla\" runnable to the executor - this way it's the job of the executor to run the task periodically", "label": {"api": {"ScheduledExecutorService": [[22, 45]]}}}, {"text": "As a \"simple\" solution, you could wrap your DataInputStream with a PushbackInputStream", "label": {"api": {"PushbackInputStream": [[67, 85]]}}}, {"text": "Use the Arrays class - specifically this Arrays.sort() method", "label": {"api": {"Arrays.sort()": [[41, 53]]}}}, {"text": "The operations you do in your jComboBox1ActionPerformed should actually be performed in setValueAt()", "label": {"api": {"setValueAt()": [[88, 99]]}}}, {"text": "Maybe, extending AbstractTableModel would be a better fit than the DefaultTableModel, but again, can't be sure without the complete code", "label": {"api": {"AbstractTableModel": [[17, 34]]}}}, {"text": "Try to set some property of the file to indicate that its processed", "label": {"api": {"set some property of the file": [[7, 35]]}}}, {"text": "You should use a Calendar instead", "label": {"api": {"Calendar": [[17, 24]]}}}, {"text": "Grab all the infos on the File chooser API here", "label": {"api": {"the File chooser API here": [[22, 46]]}}}, {"text": "This is a huge topic in any programming language, but here is a simple example of one of the many ways it could be done in Java, using a Swing Worker", "label": {"api": {"Swing Worker": [[137, 148]]}}}, {"text": "Use servletRequest.getInputStream() to get hold of binary data", "label": {"api": {"servletRequest.getInputStream()": [[4, 34]]}}}, {"text": "Create a DefaultListModel object and add the files to this, then have the JList use this model", "label": {"api": {"DefaultListModel": [[9, 24]]}}}, {"text": "So, since you employ reflection, you can use getConstructor(java.lang.Class...) (sorry, cannot paste a link to the method JavaDoc) to see if the ctor is there, and if it is, call it with specific arguments", "label": {"api": {"getConstructor(java.lang.Class...)": [[45, 78]]}}}, {"text": "This is mentioned in javadoc of DateFormat#parse()", "label": {"api": {"DateFormat#parse()": [[32, 49]]}}}, {"text": "Clients may insist on strict adherence to the format by calling setLenient(false)", "label": {"api": {"setLenient(false)": [[64, 80]]}}}, {"text": "This parsing operation uses the calendar to produce a Date", "label": {"api": {"calendar": [[32, 39]]}}}, {"text": "As a result, the calendar's date-time fields and the TimeZone value may have been overwritten, depending on subclass implementations", "label": {"api": {"calendar": [[17, 24]]}}}, {"text": "Any TimeZone value that has previously been set by a call to setTimeZone may need to be restored for further operations", "label": {"api": {"setTimeZone": [[61, 71]]}}}, {"text": "You need to use Arrays.toString(array) to print an array (you can't rely on array.toString() - it isn't useful)", "label": {"api": {"Arrays.toString(array)": [[16, 37]]}}}, {"text": "In Java 8, you can just use Integer.toUnsignedString(int i)", "label": {"api": {"Integer.toUnsignedString(int i)": [[28, 58]]}}}, {"text": "You might also find the JAI API Library useful too", "label": {"api": {"JAI API Library": [[24, 38]]}}}, {"text": "Java does as well", "label": {"api": {"well": [[13, 16]]}}}, {"text": "Read more in RowSorter spec", "label": {"api": {"RowSorter": [[13, 21]]}}}, {"text": "One option might be playing with Thread.setUncaughtExceptionHandler()", "label": {"api": {"Thread.setUncaughtExceptionHandler()": [[33, 68]]}}}, {"text": "Seems like futzing to me, but if by 'status bar' you mean the little bar at the bottom of older browsers, try using Applet.showStatus(\"\") at the end of init() or start()", "label": {"api": {"Applet.showStatus(\"\")": [[116, 136]]}}}, {"text": "If so, then SIZE operator is there for this kind of purpose", "label": {"api": {"SIZE": [[12, 15]]}}}, {"text": "If you use ThreadPoolExecutor, and you use submit() method, it will give you a Future back", "label": {"api": {"submit()": [[43, 50]]}}}, {"text": "You can call cancel() on the returned Future to stop your Runnable task", "label": {"api": {"cancel()": [[13, 20]]}}}, {"text": "Use SimpleDateFormat to do it", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Basically the .split() method will split the string according to (in this case) delimiter you are passing and will return an array of strings", "label": {"api": {".split()": [[14, 21]]}}}, {"text": "However, you seem to be after a List of Strings rather than an array, so the array must be turned into a list by using the Arrays.asList() utility", "label": {"api": {"Arrays.asList()": [[123, 137]]}}}, {"text": "DecimalFormat's format method is the equivalent in java to toFixed in javascript", "label": {"api": {"DecimalFormat": [[0, 12]], "format": [[16, 21]]}}}, {"text": "You're missing the FileOutputStream constructor which allows to append to the file", "label": {"api": {"FileOutputStream constructor": [[19, 46]]}}}, {"text": "Have you tried jtable.setRowSelectionInterval(..)", "label": {"api": {"setRowSelectionInterval": [[22, 44]]}}}, {"text": "also try jtable.addRowSelectionInterval(..)", "label": {"api": {"addRowSelectionInterval": [[16, 38]]}}}, {"text": "You need to flush the stream", "label": {"api": {"flush the stream": [[12, 27]]}}}, {"text": "or if you are really done writing to the file you need to close the writer", "label": {"api": {"close the writer": [[58, 73]]}}}, {"text": "You can use the Scanner", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "The result of User.class.toString() is", "label": {"api": {"toString()": [[25, 34]]}}}, {"text": "You need to use getName()", "label": {"api": {"getName()": [[16, 24]]}}}, {"text": "You have to specify on your class that it implements Cloneable interface and you have to override clone method inside that class", "label": {"api": {"Cloneable": [[53, 61]]}}}, {"text": "The DatabaseMetadata.getColumns(...) method returns a ResultSet that describes the columns of a table", "label": {"api": {"DatabaseMetadata.getColumns(...)": [[4, 35]]}}}, {"text": "You can also use DatabaseMetaData to get the information you want", "label": {"api": {"DatabaseMetaData": [[17, 32]]}}}, {"text": "Check the java.sql.Types section at Constant Field Values for the SQL data type values", "label": {"api": {"Constant Field Values": [[36, 56]]}}}, {"text": "The Math.ulp(double) method might be useful for this, it returns something like the possible floating point precision for the given value", "label": {"api": {"Math.ulp(double)": [[4, 19]]}}}, {"text": "Use nextAfter(double start, double direction)", "label": {"api": {"nextAfter(double start, double direction)": [[4, 44]]}}}, {"text": "Look into PreparedStatement instead of concatenating your query via Strings", "label": {"api": {"PreparedStatement": [[10, 26]]}}}, {"text": "Take a look at the File Class and it's getPath(), getAbsolutePath(), and getParent() methods that could be of use to you", "label": {"api": {"File Class": [[19, 28]]}}}, {"text": "I would prefer to read the file using an InputStreamReader", "label": {"api": {"InputStreamReader": [[41, 57]]}}}, {"text": "It's still the java.lang.Object's wait you're calling, so only the current thread will wait (assuming you're holding the objects monitor, otherwise an IllegalMonitorStateException will be thrown)", "label": {"api": {"wait": [[34, 37], [87, 90]]}}}, {"text": "Java has the Formatter class that supports creating strings with width definitions for specific fields, much like sprintf() in C", "label": {"api": {"Formatter": [[13, 21]]}}}, {"text": "String.format() also uses a Formatter object internally", "label": {"api": {"Formatter": [[28, 36]], "String.format()": [[0, 14]]}}}, {"text": "That said, Formatter is not all that fast", "label": {"api": {"Formatter": [[11, 19]]}}}, {"text": "Just create a new class extending JComponent or Component and override paint(Graphics) method", "label": {"api": {"Graphics": [[77, 84]]}}}, {"text": "And in the paint method just use a for loop to draw the grid using Graphics methods drawLine, fillRect etc", "label": {"api": {"Graphics": [[67, 74]]}}}, {"text": "If not all BasicObjects implement CodeObject, then you can use an instanceof / Class.isInstance() check in your method (see http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Class.html)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Class.html": [[124, 188]]}}}, {"text": "Double.byteValue() might help you", "label": {"api": {"Double.byteValue()": [[0, 17]]}}}, {"text": "There is also a 32-bit equivalent Float.byteValue()", "label": {"api": {"Float.byteValue()": [[34, 50]]}}}, {"text": "Use a SimpleDateFormat for that purpose", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "You are looking for a JFormattedTextField", "label": {"api": {"JFormattedTextField": [[22, 40]]}}}, {"text": "String equality must be tested using String.equals(), not ==", "label": {"api": {"String.equals()": [[37, 51]]}}}, {"text": "I suggest using Double.parseDouble()", "label": {"api": {"Double.parseDouble()": [[16, 35]]}}}, {"text": "You'll want to look at the comparable interface and the comparator interface", "label": {"api": {"comparable interface": [[27, 46]], "comparator interface": [[56, 75]]}}}, {"text": "The current JRE supports the types returned by AudioSystem.getAudioFileTypes(), but I would stick with one of those two", "label": {"api": {"AudioSystem.getAudioFileTypes()": [[47, 77]]}}}, {"text": "The Clip class provides easy methods to load and play sound bytes", "label": {"api": {"Clip": [[4, 7]]}}}, {"text": "Later port number is concatenated before returning from the InetSocketAddress's toString() to the returned value (from the toString() of InetAddress), hence the final result is hostname / literal IP address:port number", "label": {"api": {"InetSocketAddress's toString()": [[60, 89]]}}}, {"text": "For more information see the JavaDocs for InetSocketAddress's toString()", "label": {"api": {"InetSocketAddress's toString()": [[42, 71]]}}}, {"text": "Basically, you have your objects implament java.io.Serializable and then you can give them to an ObjectOutputStream and say out.writeObject(yourObject)", "label": {"api": {"ObjectOutputStream": [[97, 114]]}}}, {"text": "To write a String to a file, you usually should use a BufferedWriter", "label": {"api": {"BufferedWriter": [[54, 67]]}}}, {"text": "If you are satisfied with how is your application is laid out, you should take a look at the ImageIO to see how you can load JPG images on the fly and add them to your JPanels", "label": {"api": {"ImageIO": [[93, 99]]}}}, {"text": "Usually one would use the JLabel(Icon image) constructor to add images to JPanels but there are other methods", "label": {"api": {"JLabel(Icon image)": [[26, 43]]}}}, {"text": "You should use CallableStatement and define input/output params", "label": {"api": {"CallableStatement": [[15, 31]]}}}, {"text": "Take a look at the KeyEvent constants", "label": {"api": {"KeyEvent constants": [[19, 36]]}}}, {"text": "There is a VK_EURO_SIGN, not sure about the others", "label": {"api": {"VK_EURO_SIGN": [[11, 22]]}}}, {"text": "The EntityManagerFactory has a getMetamodel() method, which returns its MetaModel", "label": {"api": {"getMetamodel()": [[31, 44]]}}}, {"text": "One such collection is CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[23, 42]]}}}, {"text": "Do not simply replace every ArrayList with a CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[45, 64]]}}}, {"text": "AType) doesn't contain the XmlRootElement-annotation, then the returned root element gets wrapped in a JAXBElement and you have to use its getValue()-method to get the root element", "label": {"api": {"XmlRootElement": [[27, 40]], "getValue()": [[139, 148]]}}}, {"text": "AFAIK, XJC will only generate the XmlRootElement-annotation if the type of the root element is an anonymous type", "label": {"api": {"XmlRootElement": [[34, 47]]}}}, {"text": "When you want to control how a number is formatted, look at NumberFormat and particularly the concrete DecimalFormat subclass", "label": {"api": {"NumberFormat": [[60, 71]], "DecimalFormat": [[103, 115]]}}}, {"text": "You can create a DecimalFormat either from a pattern, or just set the various aspects of it directly", "label": {"api": {"DecimalFormat": [[17, 29]]}}}, {"text": "Take a look at this trail, and SimpleFileVisitor", "label": {"api": {"SimpleFileVisitor": [[31, 47]]}}}, {"text": "You can use a ListCellRenderer for that purpose", "label": {"api": {"ListCellRenderer": [[14, 29]]}}}, {"text": "The default CellRenderer is the DefaultListCellRenderer which is basically an extension of a JLabel and with all the proper look & feel settings already set", "label": {"api": {"ListCellRenderer": [[39, 54]], "DefaultListCellRenderer": [[32, 54]]}}}, {"text": "So you could extend DefaultListCellRenderer and set the array-text on the returned value", "label": {"api": {"ListCellRenderer": [[27, 42]], "DefaultListCellRenderer": [[20, 42]]}}}, {"text": "Build a JTree with your data", "label": {"api": {"JTree": [[8, 12]]}}}, {"text": "I was reading BigDecimal Class but I was not able to find any information how BigDecimal class stores values in computer memory", "label": {"api": {"BigDecimal Class": [[14, 29]]}}}, {"text": "lastIndexOf(int ch) will start from the end and search backwards, returning the absolute index of the last occurrence", "label": {"api": {"lastIndexOf(int ch)": [[0, 18]]}}}, {"text": "You can also use lastIndexOf(int ch, int fromIndex)if you want to search backwards from a particular index", "label": {"api": {"lastIndexOf(int ch, int fromIndex)": [[17, 50]]}}}, {"text": "Is @ElementCollection what you're looking for", "label": {"api": {"@ElementCollection": [[3, 20]]}}}, {"text": "Or do you just need to define a @OneToMany relationship", "label": {"api": {"@OneToMany": [[32, 41]]}}}, {"text": "If you are looking for something in EntityManager which will save or update a collection, the answer is no", "label": {"api": {"EntityManager": [[36, 48]]}}}, {"text": "If you use EntityManager.merge() API it will update if record is existing or else will insert a new record", "label": {"api": {"EntityManager": [[11, 23]], "EntityManager.merge()": [[11, 31]]}}}, {"text": "You can use a LinkedHashMap to keep order of insertion instead since basic maps do not guarantee the order of keys", "label": {"api": {"LinkedHashMap": [[14, 26]]}}}, {"text": "You should use either a TreeMap or a LinkedHashMap instead of a HashMap depending on if you want elements sorted by their natural order or insertion order respectively", "label": {"api": {"TreeMap": [[24, 30]], "LinkedHashMap": [[37, 49]]}}}, {"text": "A TreeMap will sort keys based on their natural order which means the keys must implement Comparable or you have to provide your own comparator in order to determine the ordering", "label": {"api": {"TreeMap": [[2, 8]]}}}, {"text": "A LinkedHashMap will keep the keys ordered based on when they are inserted", "label": {"api": {"LinkedHashMap": [[2, 14]]}}}, {"text": "You're probably want to going to use the expand lookup in the official bit.ly API, or the getHeaderField method of URLConnection to grab the Location header", "label": {"api": {"getHeaderField": [[90, 103]]}}}, {"text": "Take a look at JDialog http://docs.oracle.com/javase/6/docs/api/javax/swing/JDialog.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/swing/JDialog.html": [[23, 87]]}}}, {"text": "You can get the file InputStream via BlobKey(String blobKey) as constructor parameter to BlobstoreInputStream(BlobKey blobKey)", "label": {"api": {"InputStream": [[21, 31], [98, 108]]}}}, {"text": "In case of the Proxy Design Pattern, What is the difference between JDK's Dynamic Proxy and third party dynamic code generation API s such as CGLib", "label": {"api": {"JDK's Dynamic Proxy": [[68, 86]]}}}, {"text": "Take a look at Class.getConstructor and Constructor", "label": {"api": {"Class.getConstructor": [[15, 34]], "Constructor": [[24, 34], [40, 50]]}}}, {"text": "To understand the SimpleDateFormat read the Oracle documentation", "label": {"api": {"Oracle documentation": [[44, 63]]}}}, {"text": "Yes, you can do it by passing a custom FileView to the setFileView() method", "label": {"api": {"setFileView()": [[55, 67]]}}}, {"text": "Instead why not use a Scanner object", "label": {"api": {"Scanner": [[22, 28]]}}}, {"text": "For more on this, please check out the Scanner Tutorial", "label": {"api": {"Scanner": [[39, 45]]}}}, {"text": "You can format it differently if you like using DecimalFormat for instance", "label": {"api": {"DecimalFormat": [[48, 60]]}}}, {"text": "Use Collections.emptyList() for an empty, type-safe, and immutable list", "label": {"api": {"Collections.emptyList()": [[4, 26]]}}}, {"text": "Then you can use String(byte[] bytes, Charset charset) to test it with multiple encodings, most likely to least likely", "label": {"api": {"String(byte[] bytes, Charset charset)": [[17, 53]]}}}, {"text": "If you can't use Java 7, then look at RandomAccessFile which also has seek functionality and has existed since Java 1.0", "label": {"api": {"RandomAccessFile": [[38, 53]]}}}, {"text": "Also take a look at  JFileChooser if you are allowed to use Swing components", "label": {"api": {"JFileChooser": [[21, 32]]}}}, {"text": "To learn the particulars of the Java \"dialect\" of regular expressions, follow the documentation of the Pattern class", "label": {"api": {"the documentation of the Pattern class": [[78, 115]]}}}, {"text": "You can use String.split() to convert the string into an array, with one word in each element", "label": {"api": {"String.split()": [[12, 25]]}}}, {"text": "The Console class, as used by System.console() seems targeted to interactive character-based I/O, as provided by an actual console such as a cmd.exe window in Windows or a terminal in Unix-like systems", "label": {"api": {"Console": [[4, 10]], "System.console()": [[30, 45]]}}}, {"text": "On the other hand, Scanner works with any input stream, including files and the standard input", "label": {"api": {"Scanner": [[19, 25]]}}}, {"text": "It is more flexible, but it does not provide some console-specific functionality that Console does, such as the ability to read text - usually passwords - without echoing it back to the console", "label": {"api": {"Console": [[86, 92]]}}}, {"text": "Have a look at List.containsAll()", "label": {"api": {"List.containsAll()": [[15, 32]]}}}, {"text": "See How to Use Swing Timers and the Swing Timer API docs", "label": {"api": {"Timer": [[21, 25], [42, 46]]}}}, {"text": "String is not iteratable, try String#GetBytes()", "label": {"api": {"String#GetBytes()": [[30, 46]]}}}, {"text": "You should the reluctant version of this quantifier +?; your pattern then becomes", "label": {"api": {"reluctant version": [[15, 31]]}}}, {"text": "String.intern() is documented like this", "label": {"api": {"String.intern()": [[0, 14]]}}}, {"text": "You'd want to use toArray(T[])", "label": {"api": {"toArray(T[])": [[18, 29]]}}}, {"text": "Probably the easiest way would be to use JComponent.getFontMetrics(Font)", "label": {"api": {"JComponent.getFontMetrics(Font)": [[41, 71]]}}}, {"text": "For example PrePersist and PreUpdate", "label": {"api": {"PrePersist": [[12, 21]], "PreUpdate": [[27, 35]]}}}, {"text": "You can also use Collections.unmodifiableList", "label": {"api": {"Collections.unmodifiableList": [[17, 44]]}}}, {"text": "You should probably be using a TreeSet", "label": {"api": {"TreeSet": [[31, 37]]}}}, {"text": "As for telling the client how many bytes to expect, you can find the size of a file without reading it into memory using File.length", "label": {"api": {"File.length": [[121, 131]]}}}, {"text": "For more information on regular expressions, see the Javadocs on Regex Pattern", "label": {"api": {"Javadocs on Regex Pattern": [[53, 77]]}}}, {"text": "So far, the solution I found was to poll FileSystem#getFileStores for changes", "label": {"api": {"FileSystem#getFileStores": [[41, 64]]}}}, {"text": "FileStore#type and FileStore#name both seem highly unreliable as their return value is implementation specific, but they appear to be the only methods that might return any relevant information that might help find the directory for the FileStore", "label": {"api": {"FileStore#type": [[0, 13]], "FileStore#name": [[19, 32]]}}}, {"text": "As it turns out, FileStore#type returns the format of the drive and FileStore#name returns the location of the device file for the drive", "label": {"api": {"FileStore#type": [[17, 30]], "FileStore#name": [[68, 81]]}}}, {"text": "Try to pass the type reference", "label": {"api": {"type": [[16, 19]]}}}, {"text": "I'd create a ScheduledExecutorService (e.g", "label": {"api": {"ScheduledExecutorService": [[13, 36]]}}}, {"text": "via Executors.newScheduledThreadPool) allowing you to schedule repeated pings", "label": {"api": {"Executors.newScheduledThreadPool": [[4, 35]]}}}, {"text": "That method clearly doesn't exist, even with the generic type erasure", "label": {"api": {"clearly doesn't exist": [[12, 32]]}}}, {"text": "You tried to cast a TextView object to subclass of TextView, but the object is not an instance of the subclass type (see example)", "label": {"api": {"see example": [[117, 127]]}}}, {"text": "So the Linked one is intended to used as an HashMap via standard methods of the HashMap and the only method added is removeEldestEntry(), useful if you want to deal with the \"list\" part of the data structure", "label": {"api": {"removeEldestEntry()": [[117, 135]]}}}, {"text": "You can use DecimalFormat to do your desired task", "label": {"api": {"DecimalFormat ": [[12, 25]]}}}, {"text": "Put the images into a JPanel and this JPanel into a JScrollPane without scroll bars at all", "label": {"api": {"JScrollPane": [[52, 62]]}}}, {"text": "I break down a design into one of these two scenarios, or I use something from the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[83, 102]]}}}, {"text": "Now, I am not sure what kind of Currency class are using, but if it is the one from the standard JDK, then it has a getCurrencyCode() method that returns a string (or you can use the countryCode you're passing into get() invocation)", "label": {"api": {"from the standard JDK": [[79, 99]]}}}, {"text": "You should check out the BigDecimal class, which provides functionality like ROUND_HALF_DOWN, etc, for precision", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "You can use Runtime.exec(java.lang.String, java.lang.String[], java.io.File) where you can set the working directory", "label": {"api": {"Runtime.exec(java.lang.String, java.lang.String[], java.io.File)": [[12, 75]]}}}, {"text": "Or else you can use ProcessBuilder as follows", "label": {"api": {"ProcessBuilder": [[20, 33]]}}}, {"text": "assuming that behaves as documented", "label": {"api": {"as documented": [[22, 34]]}}}, {"text": "The JDK 6 docs only indicate that - is handled", "label": {"api": {"JDK 6": [[4, 8]]}}}, {"text": "Locale.setDefault() sets the default locale for the whole JVM, which is fine for a client application", "label": {"api": {"Locale.setDefault()": [[0, 18]]}}}, {"text": "You are looking for JDialog and not a new frame", "label": {"api": {"JDialog": [[20, 26]]}}}, {"text": "Make sure to pass the correct Dialog owner to the constructor of JDialog", "label": {"api": {"JDialog": [[65, 71]]}}}, {"text": "I'm using the Java DOM library to parse XML Elements and I'm running into trouble", "label": {"api": {"DOM library": [[19, 29]], "Elements": [[44, 51]]}}}, {"text": "Now, whenever I call notificationElement.getElementsByTagName(\"file\"); it gives me all the <file> elements, including those under the <group> element", "label": {"api": {"Elements": [[44, 51]]}}}, {"text": "Use HttpServletRequest#getParameter() to collect request parameters", "label": {"api": {"HttpServletRequest#getParameter()": [[4, 36]]}}}, {"text": "Use SimpleDateFormat#parse() to convert it to java.util.Date using a specific pattern, depending on how the enduser was asked to enter the date", "label": {"api": {"SimpleDateFormat#parse()": [[4, 27]], "java.util.Date": [[46, 59]]}}}, {"text": "You need to convert it to java.sql.Date, so that you can use PreparedStatement#setDate() to set it on the SQL query", "label": {"api": {"java.sql.Date": [[26, 38]], "PreparedStatement#setDate()": [[61, 87]]}}}, {"text": "If Java 7 is an option, look into the walkFileTree() method", "label": {"api": {"walkFileTree() method": [[38, 58]]}}}, {"text": "The server and client are probably running in different locales, check Locale.getDefault() to see the difference", "label": {"api": {"Locale.getDefault()": [[71, 89]]}}}, {"text": "I believe you're looking for System.mapLibraryName, which is the method typically used by ClassLoader.findLibrary implementations", "label": {"api": {"System.mapLibraryName": [[29, 49]], "ClassLoader.findLibrary": [[90, 112]]}}}, {"text": "A better way to do this is to use a HashSet instead of a list which should make every membership test take the same amount of time regardless of how many things you have put in it", "label": {"api": {"HashSet": [[36, 42]]}}}, {"text": "If you are going to want every number (or even a non-trivial portion of them), it is going to be a great deal faster to just put every number from 1 to 1000 into a list and then shuffle them using Collections.shuffle", "label": {"api": {"Collections.shuffle": [[197, 215]]}}}, {"text": "Class#getDeclaredFields makes no guarantee about the ordering of the fields returned", "label": {"api": {"Class#getDeclaredFields": [[0, 22]]}}}, {"text": "Thread.sleep waits a specified amount of time  while Object.wait waits for a notify event (which may take arbitrary amount of time to happen)", "label": {"api": {"Thread.sleep": [[0, 11]], "Object.wait": [[53, 63]]}}}, {"text": "Also, Object.wait requires that the current thread is holding the monitor associated with the object", "label": {"api": {"Object.wait": [[6, 16]]}}}, {"text": "Easiest is to extend the existing BeanELResolver", "label": {"api": {"BeanELResolver": [[34, 47]]}}}, {"text": "It correctly acquires the component-tree lock and performs component validation in order to ensure that nothing can go wrong", "label": {"api": {"component-tree lock": [[26, 44]], "validation": [[69, 78]]}}}, {"text": "In my opinion, the most natural way to model this kind of problem is with Future<V>", "label": {"api": {"Future<V>": [[74, 82]]}}}, {"text": "Then you can either model subsequent steps as things like Future<ResponseB> step2(Future<ResponseA>), or use ListenableFuture<V> from Guava", "label": {"api": {"Future<V>": [[119, 127]]}}}, {"text": "If used in this way, Future<V> behaves like a monad (in fact, I think it may qualify as one, although I'm not sure off the top of my head), and so the whole process feels a bit like IO in Haskell as performed via the IO monad", "label": {"api": {"Future<V>": [[21, 29]]}}}, {"text": "When you close() or flush() a stream, the data is written to the file (or whatever other storage mechanism you are using)", "label": {"api": {"close()": [[9, 15]], "flush()": [[20, 26]]}}}, {"text": "You can use g.clearRect(x, y, width, height), and provide the said coordinates, where you want the painting to be cleared from", "label": {"api": {"g.clearRect(x, y, width, height)": [[12, 43]]}}}, {"text": "I think you are trying to retrieve the Canonical Name of the Charset which can be obtained through the name() method of the class Charset", "label": {"api": {"name()": [[103, 108]]}}}, {"text": "I am not sure what exactly you mean by \"reading the output from the console\" but you can intercept calls to System.out by using http://docs.oracle.com/javase/6/docs/api/java/lang/System.html#setOut%28java.io.PrintStream%29", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/System.html#setOut%28java.io.PrintStream%29": [[128, 221]]}}}, {"text": "XPathFilterParameterSpec does have another constructor that allows to specify a mapping of namespace prefixes, you could try the following expression", "label": {"api": {"XPathFilterParameterSpec": [[0, 23]]}}}, {"text": "I am using Java 7 and AsynchronousSocketChannel", "label": {"api": {"AsynchronousSocketChannel": [[22, 46]]}}}, {"text": "I'm trying to generate a zip file with java.util.zip API and I haven't found any way to set permissions of a ZipEntry", "label": {"api": {"ZipEntry": [[109, 116]]}}}, {"text": "AFAIK, you can't do that using ZipEntry apis", "label": {"api": {"ZipEntry": [[31, 38]]}}}, {"text": "Though you use the File apis setWritable(), setReadable() and setExecutable() etc", "label": {"api": {"File": [[19, 22]]}}}, {"text": "By the way, brackets indicate an \"array\" not an \"ArrayList\"", "label": {"api": {"ArrayList": [[49, 57]]}}}, {"text": "An ArrayList is a Java Collection class", "label": {"api": {"ArrayList": [[3, 11]]}}}, {"text": "The combobox javadoc at http://docs.oracle.com/javafx/2/api/index.html does not say much about key value pair", "label": {"api": {"http://docs.oracle.com/javafx/2/api/index.html": [[24, 69]]}}}, {"text": "There is another solution, implementing a StringConverter", "label": {"api": {"StringConverter": [[42, 56]]}}}, {"text": "Your problem is that the out variable in a JSP is a JspWriter, which is a character stream and so your binary files get altered", "label": {"api": {"JspWriter": [[52, 60]]}}}, {"text": "You can use java.util.zip's GZIPInputStream to read the gzip file sequentially", "label": {"api": {"GZIPInputStream": [[28, 42]]}}}, {"text": "Then you can implement your own buffering and extract lines, or use BufferedReader with the readLine method", "label": {"api": {"BufferedReader": [[68, 81]]}}}, {"text": "You should be using the matchers built in Matcher.appendReplacement and Matcher.appendTail methods like this", "label": {"api": {"Matcher.appendReplacement": [[42, 66]], "Matcher.appendTail": [[72, 89]]}}}, {"text": "You can of course also use ThreadLocal variables, which on the whole are incredibly useful but probably not in this scenario", "label": {"api": {"ThreadLocal": [[27, 37]]}}}, {"text": "Well, I can't say I have a lot of experience with MP in Java so I won't try to speak to common usage, but after reading the Runnable and Thread docs, it sounds like Runnable is intended to be exactly what the name implies", "label": {"api": {"Runnable": [[124, 131], [165, 172]], "Thread": [[137, 142]]}}}, {"text": "Specifically, the docs mention using Runnable in cases where you do not wish to implement Thread, but desire a similar concept", "label": {"api": {"Runnable": [[37, 44]], "Thread": [[90, 95]]}}}, {"text": "I actually think that makes Runnable ideal for classes which encapsulate parallel or concurrent algorithms", "label": {"api": {"Runnable": [[28, 35]]}}}, {"text": "Certainly, there is nothing to imply that you should not or can not specifically design Runnable for concurrency", "label": {"api": {"Runnable": [[88, 95]]}}}, {"text": "I should clarify, I mentioned encapsulating parallel or concurrent algorithms within a Runnable, but I meant to convey that it might also make sense to encapsulate a task within the Runnable, and then let the caller determine whether to allocate parallel resources to that task by invoking it in concurrent threads, for instance", "label": {"api": {"Runnable": [[87, 94], [182, 189]]}}}, {"text": "My point is just that, as the docs imply, if you can imagine an object being run (in any context) then Runnable may be a good bet", "label": {"api": {"Runnable": [[103, 110]]}}}, {"text": "Here is a custom extension of the BasicTableUI", "label": {"api": {"BasicTableUI": [[34, 45]]}}}, {"text": "In java I can transfer objects between server and client by using Object Output Stream and Object Input Stream", "label": {"api": {"Object Output Stream": [[66, 85]], "Object Input Stream": [[91, 109]]}}}, {"text": "Um, Integer.toString(int, base) and Integer.parseInt(String, base)...", "label": {"api": {"Integer.toString(int, base)": [[4, 30]], "Integer.parseInt(String, base)": [[36, 65]]}}}, {"text": "CopyOnWriteArrayList.iterator() doesn't support remove()", "label": {"api": {"doesn't support remove()": [[32, 55]]}}}, {"text": "You should probably use a Collections.synchronizedList(ArrayList) (properly locked during iteration as specified in the Javadoc)", "label": {"api": {"Collections.synchronizedList(ArrayList)": [[26, 64]]}}}, {"text": "What you are calling is Delayed with a Fixed-Delay Repeat Execution and what you want is a Single Delay Non Repeat execution", "label": {"api": {"Delayed with a Fixed-Delay Repeat Execution": [[24, 66]], "Single Delay Non Repeat execution": [[91, 123]]}}}, {"text": "You need to write a ListModel of your own, where you store List<File> internally and return fileName from getElementAt(int index) method", "label": {"api": {"ListModel": [[20, 28]]}}}, {"text": "To start with, Java 8 introduced the sort() metod on the List interface", "label": {"api": {"sort()": [[37, 42]]}}}, {"text": "Here, I used the pre-defined naturalOrder() comparator, which in turn relies on Comparable, but a custom comparator can also be used", "label": {"api": {"Comparable": [[80, 89]]}}}, {"text": "For an example of where passing a map is appropriate, look at the DriverManager.getConnection method", "label": {"api": {"DriverManager.getConnection": [[66, 92]]}}}, {"text": "this method needs to pass parameters to constructors of driver-specific implementations of the Connection being created, so it wraps a map into Properties, and lets the user pass it through to the driver-specific connection", "label": {"api": {"Properties": [[144, 153]]}}}, {"text": "If you have a problem with, say FacesContext class, you get an error like this", "label": {"api": {"FacesContext class": [[32, 49]]}}}, {"text": "LinkedHashMap is precisely what you're looking for", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "HashMap is unordered per the second line of the documentation", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "Perhaps you can do as aix suggests and use a LinkedHashMap, or another ordered collection", "label": {"api": {"HashMap": [[51, 57]]}}}, {"text": "One convenient way to bind Enter to an Action, irrespective of focus, is via the root pane's setDefaultButton() method", "label": {"api": {"setDefaultButton()": [[93, 110]]}}}, {"text": "At the same time in your main application you can listen to other TCP ports via a ServerSocket", "label": {"api": {"ServerSocket": [[82, 93]]}}}, {"text": "Although there is more than one way to achieve these layouts, I would guess that you are looking at GridBagLayout, the most flexible but also the hardest of them all to get right", "label": {"api": {"GridBagLayout": [[100, 112]]}}}, {"text": "submit returns a Future on which the submitting thread can call get to block until the task completes", "label": {"api": {"Future": [[17, 22]], "get": [[64, 66]]}}}, {"text": "In particular, java.lang.Error is not a subclass of Exception, but is a subclass of Throwable", "label": {"api": {"java.lang.Error": [[15, 29]]}}}, {"text": "You could try java.lang.Runtime.addShutdownHook(), and have the hook iterate over all threads and dump their stack traces with Thread.getAllStackTraces()", "label": {"api": {"java.lang.Runtime.addShutdownHook()": [[14, 48]], "Thread.getAllStackTraces()": [[127, 152]]}}}, {"text": "Another way of doing it would be to install a SecurityManager which doesn't enforce any security, but which dumps the list of threads whenever SecurityManager.checkExit() is invoked, since both halt() and exit() call that security manager method", "label": {"api": {"SecurityManager": [[46, 60], [143, 157]]}}}, {"text": "You cannot extend Scanner since it's final", "label": {"api": {"Scanner": [[18, 24]]}}}, {"text": "You can use the JavaCompiler", "label": {"api": {"JavaCompiler": [[16, 27]]}}}, {"text": "AsyncContext was introduced in Servlet 3.0, it doesn't exist in 2.5", "label": {"api": {"AsyncContext": [[0, 11]]}}}, {"text": "The GZipStream classes (GZipOutputStream and GZipInputStream) should take care of the compression part", "label": {"api": {"GZipInputStream": [[45, 59]]}}}, {"text": "Yes, using the XMLReader and XMLFilter APIs", "label": {"api": {"XMLReader": [[15, 23]], "XMLFilter": [[29, 37]]}}}, {"text": "Just remember that the method clone()  is marked as protected in the Object class, and you need to make it visible in your own classes", "label": {"api": {"clone() ": [[30, 37]]}}}, {"text": "Using a LinkedHashMap might be of use, since it guarantees that insertion order is preserved at iteration time, although accessing an element by index will still need some extra processing, something like this", "label": {"api": {"LinkedHashMap": [[8, 20]]}}}, {"text": "You can try LinkedHashSet, I think", "label": {"api": {"LinkedHashSet": [[12, 24]]}}}, {"text": "You can use Authenticator for that purpose", "label": {"api": {"Authenticator": [[12, 24]]}}}, {"text": "if everything fails, you can try blindly pressing Enter after clicking the download, Robot helps with this", "label": {"api": {"Robot": [[85, 89]]}}}, {"text": "Because the contract of Reader says it should", "label": {"api": {"Reader": [[24, 29]]}}}, {"text": "Rather than re-invent the wheel, just use a CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[44, 63]]}}}, {"text": "You can achieve this by implementing a custom ActionListener which is been registered as a global <action-listener> in the faces-config.xml", "label": {"api": {"ActionListener": [[46, 59]]}}}, {"text": "To achieve this, you can use an ActionListener which basically does the following", "label": {"api": {"ActionListener": [[32, 45]]}}}, {"text": "This has been reported as JSF issue 1060 and a complete and reuseable solution has been implemented in the OmniFaces library as ResetInputAjaxActionListener (source code here and showcase demo here)", "label": {"api": {"ActionListener": [[142, 155]]}}}, {"text": "Unless you're stuck on an ancient JVM, java.lang.ProcessBuilder makes it much easier to specify a process, set up its environment, spawn it, and handle its file descriptors", "label": {"api": {"java.lang.ProcessBuilder": [[39, 62]]}}}, {"text": "See regex for more information", "label": {"api": {"regex": [[4, 8]]}}}, {"text": "Use Comparator object to define comparison logic", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "I have to look up which one, possibly an AncestorListener...", "label": {"api": {"AncestorListener": [[41, 56]]}}}, {"text": "edit, yes I think that's right, try using an AncestorListener", "label": {"api": {"AncestorListener": [[45, 60]]}}}, {"text": "A fairly simple way is to use a resource file, through the ResourceBundle class", "label": {"api": {"ResourceBundle": [[59, 72]]}}}, {"text": "You can change the century it uses to interpret 2 digit data entry with the set2DigitYearStart() method", "label": {"api": {"set2DigitYearStart()": [[76, 95]]}}}, {"text": "I'm a little confused with the ScheduledExecutorService, because shutdownNow() does not interrupt the Threads, neither does ScheduledFuture.cancel(true) (at least for me it doesn't), so I can't interrupt ServerSocket.accept()", "label": {"api": {"ScheduledExecutorService": [[31, 54]], "ScheduledFuture.cancel(true)": [[124, 151]]}}}, {"text": "I know, in my example there is no need for the ScheduledExecutorService, but in my real application there is", "label": {"api": {"ScheduledExecutorService": [[47, 70]]}}}, {"text": "Process.waitFor is a blocking call", "label": {"api": {"Process.waitFor": [[0, 14]]}}}, {"text": "Before you do myProcess.waitFor, you need to have created threads to handle program i/o", "label": {"api": {"Process.waitFor": [[16, 30]]}}}, {"text": "In javadoc for BigDecimal, it says BigDecimal is represented as (unscaledValue × 10-scale), where unscaledValue is an arbitatrily long integer and scale is a 32-bit integer", "label": {"api": {"javadoc for BigDecimal": [[3, 24]]}}}, {"text": "See ProcessBuilder documentation", "label": {"api": {"ProcessBuilder documentation": [[4, 31]]}}}, {"text": "If you have a simple text as the one you showed above (words separated by blank spaces) you can always think of StringTokenizer", "label": {"api": {"StringTokenizer": [[112, 126]]}}}, {"text": "I learned about Serialization from this website", "label": {"api": {"Serialization": [[16, 28]]}}}, {"text": "Java 8 introduced a new method replaceAll() for just such a purpose, making the code required even simpler", "label": {"api": {"replaceAll()": [[31, 42]]}}}, {"text": "http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html, specifically the contains area", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/String.html": [[0, 65]]}}}, {"text": "You will need to use mkdirs() if the parent folder (some in your example) doesn't already exist", "label": {"api": {"mkdirs()": [[21, 28]]}}}, {"text": "Consider using SwingWorker", "label": {"api": {"SwingWorker": [[15, 25]]}}}, {"text": "Also, SwingWorker has bound progress property", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "You can use setProgress() to update it", "label": {"api": {"setProgress()": [[12, 24]]}}}, {"text": "The article demonstrates collaboration of SwingWorker with a progress bar", "label": {"api": {"SwingWorker": [[42, 52]]}}}, {"text": "Use the cause parameter for Exceptions (see here)", "label": {"api": {"see here": [[40, 47]]}}}, {"text": "The query timeout should be set with Statement.setQueryTimeout() and then queries will be cancelled properly", "label": {"api": {"Statement.setQueryTimeout()": [[37, 63]]}}}, {"text": "Class.getResourceAsStream() resolves relative paths as relative to the class object that you call it on", "label": {"api": {"Class.getResourceAsStream()": [[0, 26]]}}}, {"text": "java Runtime can help you", "label": {"api": {"Runtime": [[5, 11]]}}}, {"text": "The special method putIfAbsent(K, V)) will either put your value object in, or if another thread got before you, then it will ignore your value object", "label": {"api": {"putIfAbsent(K, V))": [[19, 36]]}}}, {"text": "Either way, after the call to putIfAbsent(K, V)), get(key) is guaranteed to be consistent between threads and therefore the above code is threadsafe", "label": {"api": {"putIfAbsent(K, V))": [[30, 47]]}}}, {"text": "If the enter key is pressed in a JTextField while that JTextField has ActionListeners, an ActionEvent is fired", "label": {"api": {"JTextField": [[33, 42], [55, 64]]}}}, {"text": "You can use JSeparator for lines", "label": {"api": {"JSeparator": [[12, 21]]}}}, {"text": "Exploring JavaFX 2 - Accessing application parameters, in which the author recommends that you \"let Application.getParameters() to act a transporter and ask Apache Commons CLI to take the main work\" by which he means just get the raw parameter data rather than the parsed parameters", "label": {"api": {"Application.getParameters()": [[100, 126]]}}}, {"text": "You might want to consider using a LinkedList", "label": {"api": {"LinkedList": [[35, 44]]}}}, {"text": "There are so many overloaded methods of the PrintStream System.out", "label": {"api": {"PrintStream": [[44, 54]]}}}, {"text": "Look at the API for PrintStream (System.out is a PrintStream)", "label": {"api": {"PrintStream": [[20, 30], [49, 59]]}}}, {"text": "If you want to create a String from an integer literal, you can either put quotes around it  (String s = \"123\";) or use Integer.toString (String s = Integer.toString(123);) or String.valueOf (String s = String.valueOf(123);)", "label": {"api": {"Integer.toString": [[120, 135], [149, 164]], "String.valueOf": [[176, 189], [203, 216]]}}}, {"text": "I recommend reading up on the List & ArrayList documentation for a good implementation", "label": {"api": {"List & ArrayList": [[30, 45]]}}}, {"text": "What is the recommended way to handle an UnsupportedEncodingException  when calling String.getBytes(\"UTF-8\") inside a library method", "label": {"api": {"UnsupportedEncodingException ": [[41, 69]]}}}, {"text": "Since Java 1.7, we have StandardCharsets", "label": {"api": {"StandardCharsets": [[24, 39]]}}}, {"text": "I am trying to read an XML document and output it into a new XML document using the W3C DOM API in Java", "label": {"api": {"W3C DOM API in Java": [[84, 102]]}}}, {"text": "For instance, Tomcat is written in Java, but there is also SUN's httpserver package", "label": {"api": {"httpserver package": [[65, 82]]}}}, {"text": "You can use InputVerifier, discussed here", "label": {"api": {"InputVerifier": [[12, 24]]}}}, {"text": "What confuses me even more is that the Iterator class has only three methods", "label": {"api": {"three": [[63, 67]]}}}, {"text": "But as I said, Iterator class has only three methods", "label": {"api": {"three": [[39, 43]]}}}, {"text": "For other ideas, see the ListIterator interface", "label": {"api": {"ListIterator": [[25, 36]]}}}, {"text": "All standard containers that I know of will throw ConcurrentModificationException when you try to do this", "label": {"api": {"ConcurrentModificationException": [[50, 80]]}}}, {"text": "Add listener to image and then you can open a JOptionPane or JDialog on click of Image", "label": {"api": {"JOptionPane": [[46, 56]], "JDialog": [[61, 67]]}}}, {"text": "If the title is a user preference, the you can add it to your Preferences dialog", "label": {"api": {"Preferences": [[62, 72]]}}}, {"text": "The authors of setBorder() \"recommend that you put the component in a JPanel and set the border on the JPanel.\" You could add a MouseAdapter to that JPanel and have the chosen handler bring up the Preferences dialog, as @Catalina Island suggests", "label": {"api": {"setBorder()": [[15, 25]]}}}, {"text": "You can use a Scanner and its nextInt() method", "label": {"api": {"Scanner": [[14, 20]], "nextInt()": [[30, 38]]}}}, {"text": "Scanner also has nextLong() for larger integers, if needed", "label": {"api": {"Scanner": [[0, 6]], "nextLong()": [[17, 26]]}}}, {"text": "LinkedHashSet is what you need", "label": {"api": {"LinkedHashSet": [[0, 12]]}}}, {"text": "The Set interface does not provide any ordering guarantees", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "Its sub-interface SortedSet represents a set that is sorted according to some criterion", "label": {"api": {"Set": [[24, 26]], "SortedSet": [[18, 26]]}}}, {"text": "In Java 6, there are two standard containers that implement SortedSet", "label": {"api": {"Set": [[66, 68]], "SortedSet": [[60, 68]]}}}, {"text": "They are TreeSet and ConcurrentSkipListSet", "label": {"api": {"Set": [[13, 15], [39, 41]], "TreeSet": [[9, 15]], "ConcurrentSkipListSet": [[21, 41]]}}}, {"text": "In addition to the SortedSet interface, there is also the LinkedHashSet class", "label": {"api": {"Set": [[25, 27], [68, 70]], "SortedSet": [[19, 27]], "LinkedHashSet": [[58, 70]]}}}, {"text": "The SortedSet does however", "label": {"api": {"SortedSet": [[4, 12]]}}}, {"text": "execute is a method of SwingWorker", "label": {"api": {"execute": [[0, 6]]}}}, {"text": "What you're seeing there is an anonymous class being instantiated and having its execute method called immediately", "label": {"api": {"execute": [[81, 87]]}}}, {"text": "I have to admit I'm a bit surprised that code compiles, though, because it seems to be assigning the result of execute to the worker variable, and the documentation tells us that execute is a void function", "label": {"api": {"execute": [[111, 117], [179, 185]]}}}, {"text": "Then we call execute and assign the result to worker (which is the bit that, it seems to me, shouldn't compile)", "label": {"api": {"execute": [[13, 19]]}}}, {"text": "Noticing the java tag, isn't it feasible to call DAY_OF_MONTH to get the \"day\" part instead of regexing or splitting it out", "label": {"api": {"DAY_OF_MONTH": [[49, 60]]}}}, {"text": "The new implementation of ConcurrentHashMap.size() in JDK 8 uses a cool algorithm they kind of copy pasted from LongAdder", "label": {"api": {"ConcurrentHashMap.size()": [[26, 49]], "LongAdder": [[112, 120]]}}}, {"text": "In effect, the complexity of ConcurrentHashMap.size() is almost constant (\"O(1)\" in nerd language) and the real time cost as compared with HashMap.size() is negligible", "label": {"api": {"ConcurrentHashMap.size()": [[29, 52]]}}}, {"text": "If you look at the Javadocs, you'll see that getPrincipals() is now defined to take a Class<T extends Principal> -- i.e., a Class object representing a subclass of Principal", "label": {"api": {"the Javadocs,": [[15, 27]]}}}, {"text": "Note that the item's equals method must be consistent with yourComarator as per the TreeSet documentation for this to work", "label": {"api": {"the TreeSet documentation": [[80, 104]]}}}, {"text": "DataOutputStream.writeByte() will write the int as a 1-byte value", "label": {"api": {"DataOutputStream.writeByte()": [[0, 27]]}}}, {"text": "Does AtomicInteger provide any kind of fairness guarantee", "label": {"api": {"AtomicInteger": [[5, 17]]}}}, {"text": "In Java this problem is often addressed with WeakReference<T> objects", "label": {"api": {"WeakReference<T>": [[45, 60]]}}}, {"text": "Here's the link for further knowledge", "label": {"api": {"link": [[11, 14]]}}}, {"text": "Have you considered using Thread.getID()", "label": {"api": {"Thread.getID()": [[26, 39]]}}}, {"text": "For better performance you can also use java.nio", "label": {"api": {"java.nio": [[40, 47]]}}}, {"text": "You are not supposed interact with Swing (=call setLocation()) from a separate thread, see http://docs.oracle.com/javase/1.4.2/docs/api/javax/swing/SwingUtilities.html#invokeLater(java.lang.Runnable)", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/javax/swing/SwingUtilities.html#invokeLater(java.lang.Runnable)": [[91, 198]]}}}, {"text": "Take a look at ProcessBuilder class, here's an example that could fit your situation", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "Use the java.util.Arrays.toString(int[]) method instead to visually see the contents of an array", "label": {"api": {"java.util.Arrays.toString(int[])": [[8, 39]]}}}, {"text": "To compare arrays, use Arrays.equals(int[], int[])", "label": {"api": {"Arrays.equals(int[], int[])": [[23, 49]]}}}, {"text": "Alternatively, you can view the information in the arrays in a better format with Arrays.toString(int[])", "label": {"api": {"Arrays.toString(int[])": [[82, 103]]}}}, {"text": "Refer to the Serializable java doc for info on these methods", "label": {"api": {"Serializable java doc": [[13, 33]]}}}, {"text": "PreparedStatement.executeQuery() does not take any argument, however since the interface inherits Statement.executeQuery(String sql) you are calling that instead", "label": {"api": {"PreparedStatement.executeQuery()": [[0, 31]], "Statement.executeQuery(String sql)": [[98, 131]]}}}, {"text": "Why do you need to use SchedulerThreadPoolExecutor", "label": {"api": {"SchedulerThreadPoolExecutor": [[23, 49]], "ThreadPoolExecutor": [[32, 49]]}}}, {"text": "Unless you intend to use its timer-like capabilities, which would probably conflict with your task period requirement anyway, a simple ThreadPoolExecutor should be enough", "label": {"api": {"ThreadPoolExecutor": [[135, 152]]}}}, {"text": "Have you considered restructuring your code to use invokeAll()", "label": {"api": {"invokeAll()": [[51, 61]]}}}, {"text": "You could use a simple array, any collection from the core java.util API would also do the job (like lists or sets, it's a bit more convenient than using arrays), but probably what you are after is EnumSet", "label": {"api": {"java.util": [[59, 67]], "EnumSet": [[198, 204]]}}}, {"text": "You might be interested in BeanInfo, a class that may accompany a bean class, without that the bean class need to be altered", "label": {"api": {"BeanInfo": [[27, 34]]}}}, {"text": "That's because you're breaking symmetry as specified in the contract of equals()", "label": {"api": {"specified in the contract": [[43, 67]]}}}, {"text": "So basically it is the String's equals() method which is called here, not your one which is returning false of course", "label": {"api": {"String's equals()": [[23, 39]]}}}, {"text": "A naive approach would be to call System.setOut() with a suitably wrapped response output stream", "label": {"api": {"System.setOut()": [[34, 48]]}}}, {"text": "If your pkgmain() spawns additional threads then this approach might not work (though you could try using InheritableThreadLocal in this case)", "label": {"api": {"InheritableThreadLocal": [[106, 127]]}}}, {"text": "It's not the only directional character, looking at the Character documentation Java seems to define them", "label": {"api": {"Character documentation": [[56, 78]]}}}, {"text": "All objects that support clone are supposed to also implement Cloneable", "label": {"api": {"Cloneable": [[62, 70]]}}}, {"text": "If you're not sure where a file is going to be created, you can see its full path with File.getAbsolutePath() or File.getCanonicalPath()", "label": {"api": {"File.getAbsolutePath()": [[87, 108]], "File.getCanonicalPath()": [[113, 135]]}}}, {"text": "Another approach which works better if you have multiple threads which are to wait for each other is to use a CyclicBarrier or a CountDownLatch", "label": {"api": {"CyclicBarrier": [[110, 122]], "CountDownLatch": [[129, 142]]}}}, {"text": "With the code snippet provided this is what I understand, To append text in the text area use append", "label": {"api": {"append": [[61, 66], [94, 99]]}}}, {"text": "If you need to go even further, BigInteger (or strings) may be the answer", "label": {"api": {"BigInteger": [[32, 41]]}}}, {"text": "That being said, Class.isAssignableFrom() is another way to check inheritance hierarchies that can only fail at runtime", "label": {"api": {"Class.isAssignableFrom()": [[17, 40]]}}}, {"text": "The JMF Player implements Clock which in turn provides methods like", "label": {"api": {"Player": [[8, 13]], "Clock": [[26, 30]]}}}, {"text": "Use equals() on String (see the exact definition here), == compares by reference (i.e., the two reference you have are pointing to exactly the same object in memory), not by value (you may have multiple string instances in the memory having the same content)", "label": {"api": {"the exact definition here": [[28, 52]]}}}, {"text": "Get the instance's class with Object.getClass(), then use Class.getMethod(String, Class...) and catch a NoSuchMethodException if the class doesn't have that method", "label": {"api": {"Class.getMethod(String, Class...)": [[58, 90]]}}}, {"text": "You can also use SimpleDateFormat to format your time", "label": {"api": {"SimpleDateFormat": [[17, 32]]}}}, {"text": "You can index into a string using charAt", "label": {"api": {"charAt": [[34, 39]]}}}, {"text": "As shown in this example, your use of the worker's setProgress() in your second  example is correct", "label": {"api": {"setProgress()": [[51, 63]]}}}, {"text": "The cleanest way to do something like this is probably to use the utility method Arrays.copyOfRange", "label": {"api": {"Arrays.copyOfRange": [[81, 98]]}}}, {"text": "You can use Hashmap, if you can create combined key based on records key/int pair and value as object then you can store it in HashMap and delete values from hashMap in constant time operation", "label": {"api": {"Hashmap": [[12, 18]]}}}, {"text": "Where response is of ServletResponse type (or HttpServletResponse inheriting from it)", "label": {"api": {"ServletResponse": [[21, 35], [50, 64]], "HttpServletResponse": [[46, 64]]}}}, {"text": "If you are trying to call this from a different class, you must either pass the whole ServletResponse or PrinterWriter returned from getWriter() and use it as you out variable", "label": {"api": {"ServletResponse": [[86, 100]]}}}, {"text": "Java implementations available", "label": {"api": {"Java implementations available": [[0, 29]]}}}, {"text": "yourTextField.getText() returns a String you can use as you would any other String, store it in an array, teach it to sing, fly and enjoy life", "label": {"api": {"getText()": [[14, 22]]}}}, {"text": "The right way is to avoid this method, and use the standard Arrays.binarySearch() method, which has the enormous advantage of being documented, and the other enormous advantage of returning a result rather than printing it on System.out (which makes it useless)", "label": {"api": {"Arrays.binarySearch()": [[60, 80]]}}}, {"text": "Integer.parseInt doesn't use casting but rather a simple algorithm to interpret the digits in the string as a number", "label": {"api": {"Integer.parseInt": [[0, 15]]}}}, {"text": "Here is an (unoptimized) adapter factory that uses the Proxy type", "label": {"api": {"Proxy": [[55, 59]]}}}, {"text": "Before you get on to compile an XPath expression, you should register a NamespaceContext on your XPath instance", "label": {"api": {"NamespaceContext": [[72, 87]]}}}, {"text": "You do it using   XPath#setNamespaceContext(NamespaceContex nsContext)", "label": {"api": {"NamespaceContext": [[27, 42]], "XPath#setNamespaceContext(NamespaceContex nsContext)": [[18, 69]]}}}, {"text": "Please read using NamespaceContext chapter over at xml.apache.org", "label": {"api": {"NamespaceContext": [[18, 33]]}}}, {"text": "In order to use instances of a class as keys in a HashMap you need to override its hashCode and equals methods", "label": {"api": {"HashMap": [[50, 56]], "hashCode": [[83, 90]], "equals": [[96, 101]]}}}, {"text": "Notice that you're not parameterizing the Map with a class as a key, but with instances of the class Foo", "label": {"api": {"Map": [[42, 44]]}}}, {"text": "Then you need to make sure that Foo overrides both equals() and hashCode() for everything to work fine", "label": {"api": {"equals()": [[51, 58]], "hashCode()": [[64, 73]]}}}, {"text": "It is ill-advised to use mutable objects in Set (or as keys in Map)", "label": {"api": {"Set": [[44, 46]]}}}, {"text": "As the Javadoc for Set says", "label": {"api": {"Set": [[19, 21]]}}}, {"text": "So your example is directly on-point, and puts your Set in the \"behavior...not specified\" area", "label": {"api": {"Set": [[52, 54]]}}}, {"text": "If you put the url of the site into a HashSet you will get the same behaviour as your arraylist solution but it will be a constant time lookup instead of variable on the length of your list", "label": {"api": {"HashSet": [[38, 44]]}}}, {"text": "Keep the list in memory and use an appropriate data structure - a HashSet would do a good job", "label": {"api": {"HashSet": [[66, 72]]}}}, {"text": "Instead, you have to call the appropriate methods of the BigInteger class (equals() and multipy())", "label": {"api": {"equals()": [[75, 82]], "multipy()": [[88, 96]]}}}, {"text": "Also note that there exist BigInteger.ZERO and BigInteger.ONE", "label": {"api": {"BigInteger.ZERO": [[27, 41]], "BigInteger.ONE": [[47, 60]]}}}, {"text": "You can use getModel method to get ListModel", "label": {"api": {"getModel": [[12, 19]], "ListModel": [[35, 43]]}}}, {"text": "To walk the file tree, FileVisitor interface can be used", "label": {"api": {"FileVisitor": [[23, 33]]}}}, {"text": "In Java 8 via the streams API", "label": {"api": {"streams API": [[18, 28]]}}}, {"text": "The #walk is lazy, so any short-circuiting terminal operation will optimize the IO required", "label": {"api": {"short-circuiting terminal operation": [[26, 60]]}}}, {"text": "There is a constructor that takes a char[] and a range, if that is what you are looking for", "label": {"api": {"a constructor": [[9, 21]]}}}, {"text": "This information is available by HttpServletRequest and inherently thus also ExternalContext", "label": {"api": {"HttpServletRequest": [[33, 50]], "ExternalContext": [[77, 91]]}}}, {"text": "Note that the HttpServletRequest is available as #{request} in EL", "label": {"api": {"HttpServletRequest": [[14, 31]]}}}, {"text": "Have a look at ScheduledExecutorService which will allow you to execute your time-dependent tasks", "label": {"api": {"ScheduledExecutorService": [[15, 38]]}}}, {"text": "Maybe you can check other pacakges in java.security, like AccessController", "label": {"api": {"AccessController": [[58, 73]]}}}, {"text": "In order to convert numbers with decimal points, you can use the class Double and its methods, toHexString and doubleToLongBits", "label": {"api": {"Double": [[71, 76]]}}}, {"text": "How can I set the format for a Date in a text field with Spring MVC", "label": {"api": {"Date": [[31, 34]]}}}, {"text": "You can use toArray(T[])", "label": {"api": {"toArray(T[])": [[12, 23]]}}}, {"text": "Additionally, if you need to localize your output date, SimpleDateFormat's constructor supports custom locale", "label": {"api": {"SimpleDateFormat's constructor": [[56, 85]]}}}, {"text": "If you wanted 2.97, you should have used BigDecimal", "label": {"api": {"BigDecimal": [[41, 50]]}}}, {"text": "You might use GroupLayout1 or a nested layout2 for the bottom panels", "label": {"api": {"GroupLayout": [[14, 24]]}}}, {"text": "See How to Use GroupLayout for details", "label": {"api": {"GroupLayout": [[15, 25]]}}}, {"text": "After some research I discovered I could use doInBackground() under SwingWorker for any methods with labor-intesive work and use done() for GUI drawing", "label": {"api": {"SwingWorker": [[68, 78]]}}}, {"text": "Also I believe I can use SwingUtilities.invokeLater for every GUI drawing that happens to be in the doInBackground() function", "label": {"api": {"SwingUtilities.invokeLater": [[25, 50]]}}}, {"text": "Is there a way I can use a single SwingWorker and send any long-running methods to the doInBackground() function", "label": {"api": {"SwingWorker": [[34, 44]]}}}, {"text": "Using the invokeLater function multiple times for every misplaced GUI code where a SwingWorker would be used is not a problem as it is not that frequent", "label": {"api": {"SwingWorker": [[83, 93]]}}}, {"text": "Use SimpleDateFormat with the following pattern", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Use SimpleDateFormat and implementations to get a date displayable in a format you want", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Look over java.util.prefs", "label": {"api": {"java.util.prefs": [[10, 24]]}}}, {"text": "You can use a List such as ArrayList or any of the other Collection classes", "label": {"api": {"List": [[14, 17], [32, 35]], "ArrayList": [[27, 35]], "Collection": [[57, 66]]}}}, {"text": "Iterate over Matcher.start(groupNum)", "label": {"api": {"Matcher.start(groupNum)": [[13, 35]]}}}, {"text": "The code you've posted, as well as my Java 7 code could all be collapsed into simply catch (Exception e), because Exception is a superclass of both ApplicationException and IllegalStateException", "label": {"api": {"Exception": [[92, 100], [114, 122], [159, 167], [185, 193]], "ApplicationException": [[148, 167]], "IllegalStateException": [[173, 193]]}}}, {"text": "Read up on DecimalFormat, which can be used to format currency amounts", "label": {"api": {"DecimalFormat": [[11, 23]]}}}, {"text": "Currently I am thinking of replacing the list by using List.subList() but I'm not sure if that has equal performance", "label": {"api": {"List.subList()": [[55, 68]]}}}, {"text": "Indeed, the Javadoc for subList specifically recommends this idiom", "label": {"api": {"Javadoc for subList": [[12, 30]]}}}, {"text": "I would recommend to make your class an implementor of java.io.Closeable", "label": {"api": {"java.io.Closeable": [[55, 71]]}}}, {"text": "You have to deal with ByteArrayOutputStream and not with the String it self", "label": {"api": {"ByteArrayOutputStream": [[22, 42]]}}}, {"text": "The most acceptable way is to use a ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[36, 62]]}}}, {"text": "The JDK 1.7 Documentation in the Iterable interface lists everything within the JDK API that implements iterable, but nothing precludes a third-party library from implementing Iterable as well in any class", "label": {"api": {"Iterable": [[33, 40], [176, 183]]}}}, {"text": "You should use a PreparedStatement and pass the date field ad Date ..", "label": {"api": {"PreparedStatement": [[17, 33]], "Date": [[62, 65]]}}}, {"text": "First up, you have to use PreparedStatement", "label": {"api": {"PreparedStatement": [[26, 42]]}}}, {"text": "One solution is to rely on the fact that a Set contains no duplicate elements, so in your loop you could do something like this", "label": {"api": {"Set": [[43, 45]]}}}, {"text": "To rectify the problem, use one of the AccessController.doPrivileged(..) overloaded methods", "label": {"api": {"AccessController.doPrivileged(..)": [[39, 71]]}}}, {"text": "This can be done by using this specific FileWriter constructor which takes an additional boolean as a second parameter", "label": {"api": {"this specific FileWriter constructor": [[26, 61]]}}}, {"text": "For the docs, read http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html": [[19, 81]]}}}, {"text": "The problem I see is that the Iterator interface is so limited, that it either requires one to reconstruct the Iterable into a usable data structure, or forces the users to perform multiple traversals of the Iterable, increase execution time", "label": {"api": {"interface": [[39, 47]]}}}, {"text": "Sounds like a good job for an ExecutorService", "label": {"api": {"ExecutorService": [[30, 44]]}}}, {"text": "ExecutorService is basically a wrapper around a queue and a set of threads that are waiting on that queue (10 in example above)", "label": {"api": {"ExecutorService": [[0, 14]]}}}, {"text": "Objects.requireNonNull and Validate.notNull)", "label": {"api": {"Objects.requireNonNull": [[0, 21]]}}}, {"text": "The problem you are having is that you are using the BufferedWriter.write(int) method", "label": {"api": {"BufferedWriter.write(int)": [[53, 77]]}}}, {"text": "From Writer's javadoc", "label": {"api": {"Writer's": [[5, 12]]}}}, {"text": "I suggest to use PrintStream or PrintWriter instead", "label": {"api": {"PrintStream": [[17, 27]], "PrintWriter": [[32, 42]]}}}, {"text": "Any Enum is an object that extends java.lang.Enum and as such you get back a reference", "label": {"api": {"Enum": [[4, 7], [45, 48]]}}}, {"text": "The method setPreferredScrollableViewportSize(), mentioned here, may be useful in this context", "label": {"api": {"setPreferredScrollableViewportSize()": [[11, 46]]}}}, {"text": "Calling ObjectOutputStream.reset between the calls to writeObject will clear the cache and give you the behavior you originally expected", "label": {"api": {"ObjectOutputStream.reset": [[8, 31]]}}}, {"text": "Perhaps Thread.sleep would work better", "label": {"api": {"Thread.sleep": [[8, 19]]}}}, {"text": "You cannot assign null to variables of primitive data types, such as int and double, but you can use it with their boxed counterparts -- Integer, Double, et cetera", "label": {"api": {"Integer": [[137, 143]], "Double": [[146, 151]]}}}, {"text": "Where the String part type will be provided with HttpServletRequest.getParameter() method", "label": {"api": {"HttpServletRequest.getParameter()": [[49, 81]]}}}, {"text": "And the File type parts can be retrieved using HttpServletRequest.getPart() method", "label": {"api": {"HttpServletRequest.getPart()": [[47, 74]]}}}, {"text": "Since Java 8 BufferedReader has new method lines() which returns a stream of lines, which you can easily consume", "label": {"api": {"lines()": [[43, 49]]}}}, {"text": "Use String.replace(CharSequence, CharSequence) instead, it repleaces all occurrences", "label": {"api": {"String.replace(CharSequence, CharSequence)": [[4, 45]]}}}, {"text": "Note that String.replaceAll method takes a regular expression and in this case you don't need it.", "label": {"api": {"String.replaceAll": [[10, 26]]}}}, {"text": "If you want the day in the month on two characters, as indicated in the javadoc of SimpleDateFormat, you must use \"dd\" for the pattern", "label": {"api": {"javadoc of SimpleDateFormat": [[72, 98]]}}}, {"text": "The details can be found in the Formatter javadoc", "label": {"api": {"Formatter": [[32, 40]]}}}, {"text": "I think that the answer is in javadoc of GraphicsDevice.setDisplayMode(...)", "label": {"api": {"GraphicsDevice.setDisplayMode(...)": [[41, 74]]}}}, {"text": "Generally, if you want to create temporary data files, I would suggest using File.createTempFile(..) to create them, they will automatically be placed in the standard temporary folder", "label": {"api": {"File.createTempFile(..)": [[77, 99]]}}}, {"text": "Try wrapping it with a BufferedReader and using readLine()", "label": {"api": {"BufferedReader": [[23, 36]]}}}, {"text": "BufferedReader will read a few kb at a time, which is much more efficient", "label": {"api": {"BufferedReader": [[0, 13]]}}}, {"text": "Consider using PreparedStatement", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "If you use PreparedStatement it will escape parameters in a correct way", "label": {"api": {"PreparedStatement": [[11, 27]]}}}, {"text": "You need to set the default close operation on the JFrame as such", "label": {"api": {"default close operation": [[20, 42]]}}}, {"text": "Streams work at the byte level, they can read (InputStream) and write (OutputStream) bytes or list of bytes to a stream", "label": {"api": {"InputStream": [[47, 57]], "OutputStream": [[71, 82]]}}}, {"text": "Reader/Writers add the concept of character on top of a stream", "label": {"api": {"Reader": [[0, 5]], "Writer": [[7, 12]]}}}, {"text": "The characters read (Reader) or written (Writer) are automatically converted to bytes by the encoding and sent to the stream", "label": {"api": {"Reader": [[21, 26]], "Writer": [[41, 46]]}}}, {"text": "One of the constructors of ArrayList takes a collection as an argument and fills the list with the items contained in that collection", "label": {"api": {"One of the constructors of ArrayList": [[0, 35]]}}}, {"text": "Depending on the type of your data, you could use BigInteger or BigDecimal", "label": {"api": {"BigInteger": [[50, 59]], "BigDecimal": [[64, 73]]}}}, {"text": "Of course, a JTextArea having methods like setLineWrap(true) & setWrapStyleWord(true) also handles line wrap automatically", "label": {"api": {"setLineWrap(true)": [[43, 59]], "setWrapStyleWord(true)": [[63, 84]]}}}, {"text": "The getResourcesAsStream() expects a name which is NOT a filename cause it's a resource name", "label": {"api": {"getResourcesAsStream()": [[4, 25]]}}}, {"text": "Use a HashSet<Long> - it will take nanoseconds (literally) for contains() to return", "label": {"api": {"HashSet<Long>": [[6, 18]]}}}, {"text": "Collections.sort() and the Comparator interface are precisely the right tool for this job", "label": {"api": {"Collections.sort()": [[0, 17]], "Comparator": [[27, 36]]}}}, {"text": "The class Console has a method readPassword() that might solve your problem", "label": {"api": {"Console": [[10, 16]]}}}, {"text": "You could also compress the data before sending it to save bandwidth (and time), take a look at ZipOutputStream and ZipInputStream", "label": {"api": {"ZipOutputStream": [[96, 110]], "ZipInputStream": [[116, 129]]}}}, {"text": "Combined with java.util.Date", "label": {"api": {"with java.util.Date": [[9, 27]]}}}, {"text": "If you want to receive mouseMoved and mouseDragged events, you need to also register your listener as a MouseMotionListener", "label": {"api": {"MouseMotionListener": [[104, 122]]}}}, {"text": "ReplaceAll take a regex as first parameter so you match ALL characters with", "label": {"api": {"ReplaceAll": [[0, 9]]}}}, {"text": "You are looking for screen.setSelected(true); (I just tried it on your code and it works now)", "label": {"api": {"screen.setSelected(true);": [[20, 44]]}}}, {"text": "If you look at the javadocs for java.util.HashSet.add(), you'll see that the comparison to determine if an object is already there uses .equals()", "label": {"api": {"java.util.HashSet.add()": [[32, 54]]}}}, {"text": "You can use a synchronized map", "label": {"api": {"synchronized map": [[14, 29]]}}}, {"text": "DecimalFormat comes with currency support", "label": {"api": {"DecimalFormat": [[0, 12]]}}}, {"text": "This also comes with full locale support by optionally passing in a Locale", "label": {"api": {"Locale": [[68, 73]]}}}, {"text": "In case it is not for practice, you might look at Collections sort method for sorting the ArrayList", "label": {"api": {"Collections sort": [[50, 65]]}}}, {"text": "You can use a simple SoftReference HashMap based cache", "label": {"api": {"SoftReference": [[21, 33]]}}}, {"text": "Here is the complete implementation example SoftReference Cache In addition you can clear the complete Map periodically to bring in fresh data", "label": {"api": {"SoftReference": [[44, 56]]}}}, {"text": "In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's)", "label": {"api": {"java.lang.String": [[3, 18]]}}}, {"text": "Use File.createNewFile() in a while loop", "label": {"api": {"File.createNewFile()": [[4, 23]]}}}, {"text": "Checking the existence of the file with File.exists() in a loop does not give you such guarantee", "label": {"api": {"File.exists()": [[40, 52]]}}}, {"text": "The most easy way to this is just to write a class that overrides  java.util.AbstractList<E> http://docs.oracle.com/javase/6/docs/api/java/util/AbstractList.html and selects an element from your 3-element list", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/AbstractList.html": [[93, 160]]}}}, {"text": "This in turn requires that all session attributes implement Serializable so that the server could use ObjectOutputStream to convert Java objects to bytes which can then be saved on disk or transferred over network and ObjectInputStream to convert those bytes back to Java objects", "label": {"api": {"Serializable": [[60, 71]], "ObjectOutputStream": [[102, 119]], "ObjectInputStream": [[218, 234]]}}}, {"text": "If an object which is stored in the HTTP session does not implement Serializable, then you will get a NotSerializableException with the full qualified class name in the message", "label": {"api": {"Serializable": [[68, 79], [105, 116]]}}}, {"text": "You should then fix the class to implement Serializable", "label": {"api": {"Serializable": [[43, 54]]}}}, {"text": "Request and application scoped beans doesn't need to implement Serializable", "label": {"api": {"Serializable": [[63, 74]]}}}, {"text": "Note that all of the bean properties should also be Serializable", "label": {"api": {"Serializable": [[52, 63]]}}}, {"text": "But you will get a clear enough NotSerializableException whenever one is encountered", "label": {"api": {"Serializable": [[35, 46]]}}}, {"text": "Reading the API documentation is what you need to do", "label": {"api": {"API documentation": [[12, 28]]}}}, {"text": "You're constructing the JInternalFrame that \"Creates a non-resizable, non-closable, non-maximizable, non-iconifiable JInternalFrame with the specified title.\" You want the one like this", "label": {"api": {"JInternalFrame": [[24, 37], [117, 130]]}}}, {"text": "You can use Scanner.useDelimiter to set your own delimiter", "label": {"api": {"Scanner.useDelimiter": [[12, 31]]}}}, {"text": "Instead, use KeyGenerator", "label": {"api": {"KeyGenerator": [[13, 24]]}}}, {"text": "Use URLEncoder to encode the url in app1", "label": {"api": {"URLEncoder": [[4, 13]]}}}, {"text": "Use URLDecoder to decode the url in app2", "label": {"api": {"URLDecoder": [[4, 13]]}}}, {"text": "You can safely use much higher limit (underneath it is a simple ConcurrentHashMap) although it is hard to justify such a choice", "label": {"api": {"ConcurrentHashMap": [[64, 80]]}}}, {"text": "Try using Properties if you need a key-value map", "label": {"api": {"Properties": [[10, 19]]}}}, {"text": "You can order the rows of your TableModel independent of RowSorter using Collections.sort() and a custom Comparator, such as the one shown here, that can accept a parameter specifying the sort direction", "label": {"api": {"Collections.sort()": [[73, 90]]}}}, {"text": "You can use the MessageFormat class, which replaces dynamic placeholders in a string with the desired values", "label": {"api": {"MessageFormat": [[16, 28]]}}}, {"text": "You can simply get the pattern from your Properties object, then apply the MessageFormat translation", "label": {"api": {"MessageFormat": [[75, 87]]}}}, {"text": "The File class also offers handy constructors like new File(parent,child) that will insert the correct separator", "label": {"api": {"new File(parent,child)": [[51, 72]]}}}, {"text": "In the case of Java, you'd need to either write some JNI (C code), use JNA (Java only), or parse the output of Runtime.exec() (call various system/shell commands) to access the system APIs related to managing and/or monitoring processes", "label": {"api": {"Runtime.exec()": [[111, 124]]}}}, {"text": "There are several ways to achieve the functional requirement anyway, one of them is to just evaluate #{eachRow} programmatically by Application#evaluateExpressionGet() in the value change listener method", "label": {"api": {"Application#evaluateExpressionGet()": [[132, 166]]}}}, {"text": "These options specify the buffer sizes on the Channel's underlying Java Socket instances", "label": {"api": {"Socket": [[72, 77]]}}}, {"text": "Reading the TextMessage Javadoc, I'd go for that", "label": {"api": {"TextMessage": [[12, 22]]}}}, {"text": "But that shouldn't be a motivation for abusing a different message type that was not primarily intended for text transfer, such as BytesMessage", "label": {"api": {"BytesMessage": [[131, 142]]}}}, {"text": "Even with BytesMessage, you can get the encoding wrong", "label": {"api": {"BytesMessage": [[10, 21]]}}}, {"text": "See docs for details", "label": {"api": {"See docs for details": [[0, 19]]}}}, {"text": "Also note, that JXLayer made it into Java 7, and is available as javax.swing.JLayer", "label": {"api": {"javax.swing.JLayer": [[65, 82]]}}}, {"text": "Read about SwingWorker and learn to write multithreaded code for Swing", "label": {"api": {"SwingWorker": [[11, 21]]}}}, {"text": "The Javadoc for LocaleServiceProvider should get you started", "label": {"api": {"LocaleServiceProvider": [[16, 36]]}}}, {"text": "If all you want to do is sort an array of ints into a specific order and your professor doesn't mind you using a utility class then Go Here", "label": {"api": {"Go Here": [[132, 138]]}}}, {"text": "However, if you are required to write the sorting algorithm yourself then Go Here there are explanations and examples", "label": {"api": {"Go Here": [[74, 80]]}}}, {"text": "Blending in java is done via a Composite", "label": {"api": {"Composite": [[31, 39]]}}}, {"text": "I just noticed that the Enum#toString javadoc states (emphasis mine)", "label": {"api": {"Enum#toString javadoc": [[24, 44]]}}}, {"text": "By default, toString() and name() return the same thing, so even once toString has been overriden, one can still access the name of the enum through the name() method", "label": {"api": {"name()": [[27, 32], [153, 158]]}}}, {"text": "For reference, name()'s javadoc (emphasis as in the original)", "label": {"api": {"name()": [[15, 20]]}}}, {"text": "The fact that the compiler warns you about not declaring serialVersionUID is handled by a different mechanism at the compiler level (and therefore, out of the reach of the programmer); it's more of a coding convention enforced by the serialization API than a consequence of implementing the Serializable interface", "label": {"api": {"Serializable": [[291, 302]]}}}, {"text": "In fact, here you can examine the source code of Serializable and as you can see, there's nothing special about it for forcing a compiler warning", "label": {"api": {"Serializable": [[49, 60]]}}}, {"text": "I am calling java.lang.Runtime.exec(...) but this seems to accept the command lines as an array and I want to use a single string", "label": {"api": {"java.lang.Runtime.exec(...)": [[13, 39]]}}}, {"text": "What you need is a CountDownLatch", "label": {"api": {"CountDownLatch": [[19, 32]]}}}, {"text": "As an alternative, depending on your scenario, you might also be able to use a BlockingQueue to implement the Producer-Consumer pattern", "label": {"api": {"BlockingQueue": [[79, 91]]}}}, {"text": "Package java.util.concurrent.locks would be a good start", "label": {"api": {"Package": [[0, 6]]}}}, {"text": "Integer.parseInt throws NumberFormatException which is unchecked", "label": {"api": {"Integer.parseInt": [[0, 15]]}}}, {"text": "getLines() method, is that not working for you", "label": {"api": {"getLines() method": [[0, 16]]}}}, {"text": "Desktop.open(File) Launches the associated application to open the file", "label": {"api": {"Desktop.open(File)": [[0, 17]]}}}, {"text": "Desktop.edit(File) Launches the associated editor application and opens a file for editing", "label": {"api": {"Desktop.edit(File)": [[0, 17]]}}}, {"text": "Desktop.print(File) Prints a file with the native desktop printing facility, using the associated application's print command", "label": {"api": {"Desktop.print(File)": [[0, 18]]}}}, {"text": "You want something that implements the SortedMap interface -- instead of HashMap, use TreeMap", "label": {"api": {"SortedMap": [[39, 47]]}}}, {"text": "You can create a class that has the character and the frequency as data member, and make the class implements Comparable interface", "label": {"api": {"Comparable": [[110, 119]]}}}, {"text": "Insert all objects into a class that implements List interface (e.g", "label": {"api": {"List": [[48, 51]]}}}, {"text": "Then call Collections.sort(List<T> list) on the List", "label": {"api": {"List": [[27, 30], [48, 51]], "Collections.sort(List<T> list)": [[10, 39]]}}}, {"text": "Insert all objects into TreeSet", "label": {"api": {"TreeSet": [[24, 30]]}}}, {"text": "You can insert the existing object into a List, implement a class that extends on Comparator interface, and sort the List with Collections.sort(List<T> list, Comparator<", "label": {"api": {"List": [[42, 45], [117, 120], [144, 147]], "Comparator": [[82, 91], [158, 167]]}}}, {"text": "the next() method keeps moving the cursor forward one row at a time", "label": {"api": {"method": [[11, 16]]}}}, {"text": "I am wondering why the default size of a PriorityQueue in Java is 11", "label": {"api": {"PriorityQueue in Java": [[41, 61]]}}}, {"text": "In the paintComponent(Graphics g) or paint method you can do with Graphics2D.scale", "label": {"api": {"Graphics2D.scale": [[66, 81]]}}}, {"text": "Not directly, but you can use the varStatus to put an instance of LoopTagStatus in the scope of <c:forEach>", "label": {"api": {"LoopTagStatus": [[66, 78]]}}}, {"text": "It offers several getters to figure among others the loop index and whether it's the first or the last iteration of the loop", "label": {"api": {"index": [[58, 62]], "first": [[85, 89]], "last": [[98, 101]]}}}, {"text": "I'm only unsure how your <c:if> makes sense, but I think that you actually have two lists of the same size with comment names and comment rates and that you need to show only the rate at the same index as the comment", "label": {"api": {"index": [[196, 200]]}}}, {"text": "You can better get the rate by index directly", "label": {"api": {"index": [[31, 35]]}}}, {"text": "Reading more closely, the symbol [Ljava.lang.String;@1c23f1bb is an artifact of the toString() method as applied to a String []", "label": {"api": {"toString()": [[84, 93]]}}}, {"text": "BoxLayout implements LayoutManager2.invalidateLayout() where it does reset its cached details", "label": {"api": {"LayoutManager2.invalidateLayout()": [[21, 53]]}}}, {"text": "For example, GroupLayout and OverlayLayout also require container argument in their constructors", "label": {"api": {"GroupLayout": [[13, 23]], "OverlayLayout": [[29, 41]]}}}, {"text": "You could use Arrays.copyOfRange", "label": {"api": {"Arrays.copyOfRange": [[14, 31]]}}}, {"text": "Note there that we called on Thread#interrupted(), which has the side effect of clearing the thread's interruption status if it had been set", "label": {"api": {"Thread#interrupted()": [[29, 48]]}}}, {"text": "You're saying, \"This may take a while to complete, but it will take no longer than you're willing to wait.\" You're saying, \"I'll run until you tell me not to.\" That's different from, say, java.io.InputStream#read(), which threatens to block until one of three conditions occur, none of which is the caller's thread being interrupted", "label": {"api": {"java.io.InputStream#read()": [[188, 213]]}}}, {"text": "I suggest that you study the topic of a thread's interruption status, and get comfortable with the methods Thread#isInterrupted(), Thread#interrupted(), and Thread#interrupt()", "label": {"api": {"Thread#isInterrupted()": [[107, 128]], "Thread#interrupted()": [[131, 150]], "Thread#interrupt()": [[157, 174]]}}}]