[{"text": "Once you understand those, and see that an InterruptedException being in flight is an alternate representation of Thread#isInterrupted() having returned true, or a courteous translation of Thread#interrupted() having returned true, this should all start making more sense", "label": {"api": {"Thread#isInterrupted()": [[114, 135]], "Thread#interrupted()": [[189, 208]]}}}, {"text": "Blob has a getBinaryStream() which returns a stream of bytes containing the data stored in the blob", "label": {"api": {"getBinaryStream()": [[11, 27]]}}}, {"text": "ImageIcon, which implements Icon, has a constructor which takes a byte array as argument", "label": {"api": {"constructor": [[40, 50]]}}}, {"text": "JLabel has a setIcon(Icon) method", "label": {"api": {"setIcon(Icon)": [[13, 25]]}}}, {"text": "Assuming that lock is a ReentrantLock, then it makes no real difference, since lock() does not throw any checked exceptions", "label": {"api": {"ReentrantLock": [[24, 36]], "lock()": [[79, 84]]}}}, {"text": "The Java documentation, however, leaves lock() outside the try block in the ReentrantLock example", "label": {"api": {"ReentrantLock": [[76, 88]], "lock()": [[40, 45]]}}}, {"text": "The reason for this is that an unchecked exception in lock() should not lead to unlock() incorrectly being called", "label": {"api": {"lock()": [[54, 59], [82, 87]]}}}, {"text": "Whether correctness is a concern in the presence of an unchecked exception in lock() of all things, that is another discussion altogether", "label": {"api": {"lock()": [[78, 83]]}}}, {"text": "Instead use .createNativeQuery() method of the entity manager, to create complex and mixed  queries", "label": {"api": {".createNativeQuery()": [[12, 31]]}}}, {"text": "This is suitable for a CountDownLatch", "label": {"api": {"CountDownLatch": [[23, 36]]}}}, {"text": "See Color.decode(String) instead", "label": {"api": {"Color.decode(String)": [[4, 23]]}}}, {"text": "See the documentation for SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[26, 41]]}}}, {"text": "Take a look at ExecutorService.shutdownNow", "label": {"api": {"ExecutorService.shutdownNow": [[15, 41]]}}}, {"text": "In which case see InetAddress.isReachable()", "label": {"api": {"InetAddress.isReachable()": [[18, 42]]}}}, {"text": "Yes, you should throw a RuntimeException to indicate an \"exceptional\" situation that should not have occurred", "label": {"api": {"RuntimeException": [[24, 39]]}}}, {"text": "IllegalStateException probably fits the bill", "label": {"api": {"IllegalStateException": [[0, 20]]}}}, {"text": "A simpler (and better) way would be to use a java Hashtable (key", "label": {"api": {"Hashtable": [[50, 58]]}}}, {"text": "There's some sample code which shows how to use the Hashtable in the linked documentation", "label": {"api": {"Hashtable": [[52, 60]]}}}, {"text": "The d_pword field should be a JPasswordField", "label": {"api": {"JPasswordField": [[30, 43]]}}}, {"text": "Using JFrame.EXIT_ON_CLOSE actually terminates the JVM (System.exit)", "label": {"api": {"System.exit": [[56, 66]]}}}, {"text": "Take a look at the PreparedStatement javadoc and support every setSomething datatype there", "label": {"api": {"PreparedStatement": [[19, 35]]}}}, {"text": "To write out strings, take a look at the PrintStream class", "label": {"api": {"PrintStream": [[41, 51]]}}}, {"text": "Also, you can wrap an OutputStream using one of the PrintStream constructors", "label": {"api": {"PrintStream": [[52, 62]], "one of the PrintStream constructors": [[41, 75]]}}}, {"text": "note that you can also use the PrintWriter class in the same manner as PrintStream above; which is typically better because you can specify the encoding to use, avoiding any platform dependencies", "label": {"api": {"PrintStream": [[71, 81]], "PrintWriter": [[31, 41]]}}}, {"text": "According to documentation (http://docs.oracle.com/javase/7/docs/api/java/awt/Font.html), AWT components can only use logical fonts", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/Font.html": [[28, 86]]}}}, {"text": "As the java.sql.Date javadoc says", "label": {"api": {"java.sql.Date javadoc": [[7, 27]]}}}, {"text": "That's not very hard to implement using two Thread objects and an ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[66, 83]]}}}, {"text": "This constructor creates a random BigInteger of the specified length", "label": {"api": {"constructor": [[5, 15]]}}}, {"text": "String.replaceAll ends up using (or being equivalent to using) Matcher.replaceAll, which includes this in the documentation", "label": {"api": {"Matcher.replaceAll": [[63, 80]]}}}, {"text": "You can also use quoteReplacement() method, in case you really need a regex", "label": {"api": {"quoteReplacement()": [[17, 34]]}}}, {"text": "I am looking for working examples of Oracle's Java Compiler API usage", "label": {"api": {"Oracle's Java Compiler API": [[37, 62]]}}}, {"text": "The simplest way to do this is to create a Color object and use the getRed, getGreen and getBlue (aswell as getAlpha) methods to get the components", "label": {"api": {"Color": [[43, 47]], "getRed": [[68, 73]], "getGreen": [[76, 83]], "getBlue": [[89, 95]], "getAlpha": [[108, 115]]}}}, {"text": "Use this constructor for InputStreamReader instead", "label": {"api": {"constructor": [[9, 19]]}}}, {"text": "And also use this constructor for OutputStreamWriter", "label": {"api": {"constructor": [[18, 28]]}}}, {"text": "To manipulate shapes in Java like you're describing, you want to use the Area class, which has these operations", "label": {"api": {"Area": [[73, 76]]}}}, {"text": "Just convert a Shape to an Area with new Area(Shape)", "label": {"api": {"Area": [[27, 30], [41, 44]]}}}, {"text": "You can use ScheduledThreadPoolExecutor.schedule", "label": {"api": {"ScheduledThreadPoolExecutor.schedule": [[12, 47]]}}}, {"text": "executeBatch is a \"super\" method from the PreparedStatement's parent Statement which returns an int[] which indicates the success/failure of the executed queries and executeQuery returns a ResultSet", "label": {"api": {"executeBatch": [[0, 11]], "executeQuery": [[166, 177]]}}}, {"text": "An executeQuery(HelperQuery helperQuery) method which will return the associated ResultSet and will only get the first QueryParameters from the HelperQuery (for convenience) and another method which the developer can specify which QueryParameter set to use (either have them specify a number of the QueryParameter list or just pass in the QueryParameters explicitly (I recommend the second of the two))", "label": {"api": {"executeQuery": [[3, 14]]}}}, {"text": "An executeBatch(HelperQuery helperQuery method which will return the int[] and the developer can handle that as they wish", "label": {"api": {"executeBatch": [[3, 14]]}}}, {"text": "You can use temporary files for this, as this requires input/output file, or you can create custom implementation of JavaFileObject that reads source from string", "label": {"api": {"JavaFileObject": [[117, 130]]}}}, {"text": "You can use getData and setData to speed up access to the pixels vs", "label": {"api": {"getData": [[12, 18]], "setData": [[24, 30]]}}}, {"text": "The ${cookie} points to a Map<String, Cookie> with the cookie name as map key and the Cookie object as map value", "label": {"api": {"Map<String, Cookie>": [[26, 44]], "Cookie": [[38, 43], [86, 91]]}}}, {"text": "Every iteration over a Map in <c:forEach> gives you a Map.Entry back which in turn has getKey() and getValue() methods", "label": {"api": {"Map.Entry": [[54, 62]], "getKey()": [[87, 94]], "getValue()": [[100, 109]]}}}, {"text": "Your confusion is that the Cookie object has in turn also a getValue() method", "label": {"api": {"Cookie": [[27, 32]], "getValue()": [[60, 69]]}}}, {"text": "It's a Map<String, Cookie> because it allows you easy direct access to cookie value when you already know the name beforehand", "label": {"api": {"Map<String, Cookie>": [[7, 25]], "Cookie": [[19, 24]]}}}, {"text": "The first line of the javadoc says it all", "label": {"api": {"The first line of the javadoc says it all": [[0, 40]]}}}, {"text": "For the part of testing that the method exits, you could use the Future interface that provides a timeout for getting the results", "label": {"api": {"Future": [[65, 70]]}}}, {"text": "Use DocumentBuilder.setErrorHandler to set an implementation of ErrorHandler", "label": {"api": {"DocumentBuilder.setErrorHandler": [[4, 34]]}}}, {"text": "In case you want to keep limited amount of data (circular log), and able to reserve fixed amount of persistent memory for it, then most effective solution is memory-mapped buffers", "label": {"api": {"memory-mapped buffers": [[158, 178]]}}}, {"text": "You can inspect the stacktrace (using Throwable#getStackTrace()) and see if it contains the allowed method on specified position", "label": {"api": {"Throwable#getStackTrace()": [[38, 62]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html should hep you out", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html": [[0, 62]]}}}, {"text": "I'm not sure, but with Files class you can read and write attributes in files", "label": {"api": {"Files": [[23, 27]]}}}, {"text": "Your innermost loop could be removed by using Arrays.equals()", "label": {"api": {"Arrays.equals()": [[46, 60]]}}}, {"text": "From JPanel (Java 2 Platform SE v1.4.2), it says", "label": {"api": {"JPanel (Java 2 Platform SE v1.4.2)": [[5, 38]]}}}, {"text": "Please see XMLEncoder", "label": {"api": {"XMLEncoder": [[11, 20]]}}}, {"text": "What you are doing is probably using StringBuilder#append(double) which in the end calls Double#toString()", "label": {"api": {"StringBuilder#append(double)": [[37, 64]], "Double#toString()": [[89, 105]]}}}, {"text": "Alternatively, if you want to have control over your code, use NumberFormat or it's subclasses", "label": {"api": {"NumberFormat": [[63, 74]]}}}, {"text": "java strings are always utf-16 internally (javadoc link), but you can use -Dfile.encoding=UTF-8 to facilitate reading files with a default charset", "label": {"api": {"javadoc link": [[43, 54]]}}}, {"text": "java.nio.charset.Charset.defaultCharset() Will get you the JVM's default charset", "label": {"api": {"java.nio.charset.Charset.defaultCharset()": [[0, 40]]}}}, {"text": "Take a look at the Hashtable.values() documentation", "label": {"api": {"the Hashtable.values() documentation": [[15, 50]]}}}, {"text": "An alternative to using split could be to use a Delimiter with the Scanner and use hasNext() and next() instead of hasNextLine() and nextLine()", "label": {"api": {"Delimiter": [[48, 56]]}}}, {"text": "If you're using this in Swing then you should use SwingWorker (part of Java)", "label": {"api": {"SwingWorker": [[50, 60]]}}}, {"text": "If you're not using Swing then standard java comes with Executors class", "label": {"api": {"Executors": [[56, 64]]}}}, {"text": "You can create a single thread ExecutorService and submit your Runnable to it", "label": {"api": {"ExecutorService": [[31, 45]]}}}, {"text": "You can do it programmatically using the logout()-Method of HttpServletRequest", "label": {"api": {"logout()": [[41, 48]], "HttpServletRequest": [[60, 77]]}}}, {"text": "So if you want to store configuration/properties, you could create your own class for that or use one of the existing ones (for instance Properties)", "label": {"api": {"Properties": [[137, 146]]}}}, {"text": "(?( is not a valid syntax", "label": {"api": {"valid syntax": [[13, 24]]}}}, {"text": "You may try using method substring and indexOf from String object", "label": {"api": {"String": [[52, 57]]}}}, {"text": "I would recommend replacing your use of Runtime.getRuntime().exec(...) with a ProcessBuilder, using something like the following", "label": {"api": {"ProcessBuilder": [[78, 91]]}}}, {"text": "Explicitely set the preferred size of your labels using JLabel#setPreferredSize(Dimension)", "label": {"api": {"JLabel#setPreferredSize(Dimension)": [[56, 89]]}}}, {"text": "You can use replaceFirst(String regex, String replacement) method of String", "label": {"api": {"replaceFirst(String regex, String replacement)": [[12, 57]]}}}, {"text": "You can iterate through the file using MappedByteBuffer.getInt(int) and compare it to Message.FLAG", "label": {"api": {"MappedByteBuffer.getInt(int)": [[39, 66]]}}}, {"text": "Find more in the SimpleDateFormat documentation", "label": {"api": {"the SimpleDateFormat documentation": [[13, 46]]}}}, {"text": "Just use SimpleDateFormat to convert String to Date", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "Whenever you need to present the Date object to humans, just use another SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[73, 88]]}}}, {"text": "For advance control on window closing events, you have to use WindowListener", "label": {"api": {"WindowListener": [[62, 75]]}}}, {"text": "If you want to validate input to a JTextField rather use InputVerifier", "label": {"api": {"InputVerifier": [[57, 69]]}}}, {"text": "The javadoc contains some examples of how to use it, have a look", "label": {"api": {"some examples of how to use it": [[21, 50]]}}}, {"text": "You can use the Calendar class, in the following way", "label": {"api": {"Calendar": [[16, 23]]}}}, {"text": "For inserting several chars in an array at once, consider using a StringBuilder instead", "label": {"api": {"StringBuilder": [[66, 78]]}}}, {"text": "use StrigBuilder object to manipulate strings, it has an insert() method that enables you to do just what you were asking", "label": {"api": {"StrigBuilder": [[4, 15]]}}}, {"text": "I'd suggest using StringTokenizer instead of String.split()", "label": {"api": {"StringTokenizer": [[18, 32]]}}}, {"text": "If you want to get DOM elements, use the NODE or NODESET (NodeList) options", "label": {"api": {"NODE": [[41, 44], [49, 52]], "NODESET": [[49, 55]]}}}, {"text": "If you're able to find the new path of your leaf you can create a TreePath", "label": {"api": {"TreePath": [[66, 73]]}}}, {"text": "Have a look at this link to know more about it", "label": {"api": {"link": [[20, 23]]}}}, {"text": "For more details on it please refer this link", "label": {"api": {"link": [[41, 44]]}}}, {"text": "There is a static Arrays.toString helper method for every different primitive java type; the one for int[] says this", "label": {"api": {"int[] says this": [[101, 115]]}}}, {"text": "You can use java.util.Arrays", "label": {"api": {"java.util.Arrays": [[12, 27]]}}}, {"text": "Concerning the IllegalArgumentException use SwingUtilities.invokeAndWait in launchFileChooser instead of SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[105, 130]]}}}, {"text": "Better yet, if you're sure launchFileChooser will always occur on the event dispatch thread, there's no need to call either SwingUtilities.invokeAndWait or SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[156, 181]]}}}, {"text": "More precisely, calling split(String) is the same as calling split(String, int) with the second parameter set to 0", "label": {"api": {"split(String)": [[24, 36]], "split(String, int)": [[61, 78]]}}}, {"text": "The only thing I'm aware that can be done is to add a WindowListener to the JFrame and handle closing events in that listener", "label": {"api": {"WindowListener": [[54, 67]]}}}, {"text": "The trick lies in the PLAF and setDefaultLookAndFeelDecorated(true) (Specifying Window Decorations)", "label": {"api": {"setDefaultLookAndFeelDecorated(true)": [[31, 66]]}}}, {"text": "You should be able to grab it from the HTTP request parameter values map by ExternalContext#getRequestParameterValuesMap() in JSF as follows", "label": {"api": {"ExternalContext#getRequestParameterValuesMap()": [[76, 121]]}}}, {"text": "Use the ZipEntry#getSize() method", "label": {"api": {"ZipEntry#getSize()": [[8, 25]]}}}, {"text": "You need to also override Object.hashcode()", "label": {"api": {"Object.hashcode()": [[26, 42]]}}}, {"text": "Please read the Concurrency in Swing tutorial to see why this matters, and how to solve this issue with a SwingWorker object", "label": {"api": {"SwingWorker": [[106, 116]]}}}, {"text": "to add the Component, use the method JScrollPane.html#setViewportView(java.awt.Component) (if you don't want to use the JScrollPane constructor that take a parameter)", "label": {"api": {"JScrollPane.html#setViewportView(java.awt.Component)": [[37, 88]]}}}, {"text": "Additionally, you may want to consider using a StringBuilder for String accumulation, as they are lighter-weight", "label": {"api": {"StringBuilder": [[47, 59]]}}}, {"text": "You have just reinvented the ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[29, 46]]}}}, {"text": "Since you are using java 7, it would be tempting to use the new fork join API, but I am pretty sure that in your case the ThreadPoolExecutor is what you need", "label": {"api": {"ThreadPoolExecutor": [[122, 139]]}}}, {"text": "ArrayList::add returns true in this scenario; that is, it doesn't return the new ArrayList", "label": {"api": {"ArrayList::add returns true in this scenario": [[0, 43]]}}}, {"text": "In your case i think you can use ExecutorService and create jobs in Callable objects that will help you to get the status of your running job it the form of Future objects", "label": {"api": {"Callable": [[68, 75]], "Future objects": [[157, 170]]}}}, {"text": "Use BigDecimal that is available in Java", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "The java.util.regex package was added to Java SE 1.4", "label": {"api": {"java.util.regex": [[4, 18]]}}}, {"text": "You can use ExecutorService or Java Threads to do this job", "label": {"api": {"ExecutorService": [[12, 26]]}}}, {"text": "Bytes have the longValue() method as well", "label": {"api": {"longValue()": [[15, 25]]}}}, {"text": "You can use Runtime.addShutdownHook to register one", "label": {"api": {"Runtime.addShutdownHook": [[12, 34]]}}}, {"text": "I assume you are executing this program using one of the Runtime.exec() methods in Java code to create a Process", "label": {"api": {"Runtime": [[57, 63]], "Process": [[105, 111]]}}}, {"text": "Note that some of those methods allows you to pass environment variables to the process you are creating, for example exec(String[] cmd, String[] envp)", "label": {"api": {"exec(String[] cmd, String[] envp)": [[118, 150]]}}}, {"text": "Alternatively, the Map returned by ProcessBuilder.environment() can be manipulated for the same effect", "label": {"api": {"Process": [[35, 41]], "ProcessBuilder.environment()": [[35, 62]]}}}, {"text": "Use JarFile.entries to get an enumeration of all of the entries in your Jar file", "label": {"api": {"JarFile.entries": [[4, 18]]}}}, {"text": "How to execute a bunch of threaded objects on a ThreadPoolExecutor and wait for them all to finish before moving on", "label": {"api": {"ThreadPoolExecutor": [[48, 65]]}}}, {"text": "I'm new to ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[11, 28]]}}}, {"text": "When you re-execute the statement, the previous result set is closed", "label": {"api": {"the previous result set is closed": [[35, 67]]}}}, {"text": "This is also told in API", "label": {"api": {"API": [[21, 23]]}}}, {"text": "getJavaFileObjectsFromStrings from StandardJavaFileManager takes an Iterable<String>", "label": {"api": {"getJavaFileObjectsFromStrings": [[0, 28]]}}}, {"text": "extends JavaFileObject>, which in turn is passed to the getTask method of any class that implements the JavaCompiler interface", "label": {"api": {"getTask method": [[56, 69]]}}}, {"text": "the Arrays.asList(fileToCompile) call creates an array of strings with exactly one string in it; even without documentation, it should be easy to deduce getJavaFileObjectsFromStrings takes an array of strings corresponding to filenames", "label": {"api": {"getJavaFileObjectsFromStrings": [[153, 181]]}}}, {"text": "The default Java Float.toString(float) method prints a floating point number with \"only as many ..", "label": {"api": {"Java Float.toString(float)": [[12, 37]]}}}, {"text": "Consequently, replaceAll() returns the altered String; it doesn't change the String on which it was called", "label": {"api": {"replaceAll()": [[14, 25]]}}}, {"text": "It even says so in the documentation for this method", "label": {"api": {"in the documentation for this method": [[16, 51]]}}}, {"text": "Take a look at SwingUtilities.isEventDispatchThread", "label": {"api": {"SwingUtilities.isEventDispatchThread": [[15, 50]]}}}, {"text": "you didn't fully read and understand the documentation of ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[58, 75]]}}}, {"text": "It's better to add the writing flag to SelectionKey.interestOps when you're ready to write something to the channel, and remove the flag when you're done", "label": {"api": {"SelectionKey.interestOps": [[39, 62]]}}}, {"text": "If you're using Java 7, you can use Files.copy to do this for you", "label": {"api": {"Files.copy": [[36, 45]]}}}, {"text": "In your case, use @PostConstruct, documentation here", "label": {"api": {"documentation here": [[34, 51]]}}}, {"text": "If you want to limit the number of messages, then ArrayBlockingQueue with its capacity constructor allows you to do this", "label": {"api": {"ArrayBlockingQueue": [[50, 67]]}}}, {"text": "You can achieve it by making an HttpURLConnection and appending username and password with the URL", "label": {"api": {"HttpURLConnection": [[32, 48]]}}}, {"text": "You can use Java Reflection and StackTraceElement", "label": {"api": {"StackTraceElement": [[32, 48]]}}}, {"text": "You should use batching when you insert a huge amount of data and commit every let's say 500 entries", "label": {"api": {"batching": [[15, 22]]}}}, {"text": "Take a look at JSplitPane and the corresponding Java Tutorial", "label": {"api": {"JSplitPane": [[15, 24]]}}}, {"text": "You can use Java Reflection and StackTraceElement", "label": {"api": {"StackTraceElement": [[32, 48]]}}}, {"text": "Let Categoria implement Comparable", "label": {"api": {"Comparable": [[24, 33]]}}}, {"text": "Why not use the newLine() method provided by the BufferedWriter class", "label": {"api": {"newLine()": [[16, 24]]}}}, {"text": "Also, take a look to KeyStore class", "label": {"api": {"KeyStore": [[21, 28]]}}}, {"text": "You can use the various implementations of java.util.Map (see http://docs.oracle.com/javase/7/docs/api/java/util/Map.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Map.html": [[62, 120]]}}}, {"text": "A more direct approach using only JRE available class File", "label": {"api": {"File": [[54, 57]]}}}, {"text": "pInValues is a java.util.List", "label": {"api": {"java.util.List": [[15, 28]]}}}, {"text": "Following JTextArea JAVAdoc i tried to create a JTextArea of a long string and wanted to have my lines wrap automatically", "label": {"api": {"JTextArea JAVAdoc": [[10, 26]]}}}, {"text": "Use compareTo(BigDecimal.ZERO) instead of equals()", "label": {"api": {"compareTo(BigDecimal.ZERO)": [[4, 29]], "equals()": [[42, 49]], "BigDecimal": [[14, 23]], "BigDecimal.ZERO": [[14, 28]]}}}, {"text": "Comparing with the BigDecimal constant BigDecimal.ZERO avoids having to construct a new BigDecimal(0) every execution", "label": {"api": {"BigDecimal": [[19, 28], [39, 48], [88, 97]], "BigDecimal.ZERO": [[39, 53]]}}}, {"text": "FYI, BigDecimal also has constants BigDecimal.ONE and BigDecimal.TEN for your convenience", "label": {"api": {"BigDecimal": [[5, 14], [35, 44], [54, 63]], "BigDecimal.ONE": [[35, 48]], "BigDecimal.TEN": [[54, 67]]}}}, {"text": "The reason you can't use BigDecimal#equals() is that it takes scale into consideration", "label": {"api": {"equals()": [[36, 43]], "BigDecimal": [[25, 34]], "BigDecimal#equals()": [[25, 43]]}}}, {"text": "However, BigDecimal.compareTo() doesn't consider scale when comparing", "label": {"api": {"BigDecimal": [[9, 18]], "BigDecimal.compareTo()": [[9, 30]]}}}, {"text": "There is a static constant that represents 0", "label": {"api": {"represents 0": [[32, 43]]}}}, {"text": "Alternatively, I think it is worth mentioning that the behavior of equals and compareTo methods in the class BigDecimal are not consistent with each other", "label": {"api": {"are not consistent with each other": [[120, 153]]}}}, {"text": "Alternatively, signum() can be used", "label": {"api": {"signum()": [[15, 22]]}}}, {"text": "This is explained in the documentation for String", "label": {"api": {"documentation for String": [[25, 48]]}}}, {"text": "Add a MediaPrintableArea", "label": {"api": {"MediaPrintableArea": [[6, 23]]}}}, {"text": "Then you use nextLine() which Advances this scanner past the current line and returns the input that was skipped.", "label": {"api": {"Advances this scanner past the current line and returns the input that was skipped.": [[30, 112]]}}}, {"text": "Some background on Error", "label": {"api": {"Error": [[19, 23]]}}}, {"text": "As for it working inside of a try...catch statement, the reason is that this is a property of the Throwable class", "label": {"api": {"Throwable": [[98, 106]]}}}, {"text": "By default, closing a JFrame will simply hide it (see the documentation for setDefaultCloseOperation())", "label": {"api": {"the documentation for setDefaultCloseOperation()": [[54, 101]]}}}, {"text": "If above is true, then you can use CachedRowSet", "label": {"api": {"CachedRowSet": [[35, 46]]}}}, {"text": "You can try Thread.sleep() method", "label": {"api": {"Thread.sleep()": [[12, 25]]}}}, {"text": "To achieve your goal you have multiple options but most of them refer to Format and Formatter, but i just suggest to look in this answer", "label": {"api": {"Formatter": [[84, 92]]}}}, {"text": "Configure the ListCellRenderer to handle that", "label": {"api": {"ListCellRenderer": [[14, 29]]}}}, {"text": "You may use the String.split() method", "label": {"api": {"String.split()": [[16, 29]]}}}, {"text": "After that, use Double.parseDouble() method to parse the string value to a double", "label": {"api": {"Double.parseDouble()": [[16, 35]]}}}, {"text": "You could use the contains(Rectancle r) method twice", "label": {"api": {"contains(Rectancle r)": [[18, 38]]}}}, {"text": "If you have to care about the Z-order of several components, then JLayeredPane is your best alternative", "label": {"api": {"JLayeredPane": [[66, 77]]}}}, {"text": "But as locking has a cost, you may also encapsulate your variable in AtomicLong", "label": {"api": {"AtomicLong": [[69, 78]]}}}, {"text": "The FlowLayout class (along with a few other layout classes) allows you to set the horizontal and vertical gaps in its constructor, like so", "label": {"api": {"in its constructor": [[112, 129]]}}}, {"text": "When you wrote the nonce, you were calling StringBuffer.append(Object) which ends up calling byte[].toString()", "label": {"api": {"StringBuffer.append(Object)": [[43, 69]]}}}, {"text": "For instance, imagine you would like to catch the StringIndexOutOfBoundsException thrown by the String.charAt(index) method but your code could also throw a NullPointerException, here's how you could go to catch the exceptions", "label": {"api": {"StringIndexOutOfBoundsException": [[50, 80]], "String.charAt(index)": [[96, 115]], "NullPointerException": [[157, 176]]}}}, {"text": "So, with this order, I am making sure the exceptions are caught correctly and they are not tripping over one another, if it's a NullPointerException it enters the first catch, if a StringIndexOutOfBoundsException it enters the second and finally if it is something else that is a RuntimeException (or inherits from it, like a IllegalArgumentException) it enters the third catch", "label": {"api": {"StringIndexOutOfBoundsException": [[181, 211]], "NullPointerException": [[128, 147]]}}}, {"text": "In your paint method, make sure to call super.paint(g) since it is a method inherited from Container, a superclass of JApplet", "label": {"api": {"paint": [[8, 12], [46, 50]], "Container": [[91, 99]]}}}, {"text": "Check out the Map documentation as well", "label": {"api": {"Map documentation": [[14, 30]]}}}, {"text": "Use the Desktop#browse(URI) method", "label": {"api": {"Desktop#browse(URI)": [[8, 26]]}}}, {"text": "You can use @XmlTransient on the field", "label": {"api": {"@XmlTransient": [[12, 24]]}}}, {"text": "One easy structure to use to communicate between threads is the BlockingQueue", "label": {"api": {"BlockingQueue": [[64, 76]]}}}, {"text": "I often find if you use a BlockingQueue it will focus you on making the threads work together correctly", "label": {"api": {"BlockingQueue": [[26, 38]]}}}, {"text": "Note that when using your invocation of Runtime.exec, the working directory of the command being executed will be the current working directory of the java process", "label": {"api": {"Runtime.exec": [[40, 51]]}}}, {"text": "If you need to set a specific working directory for the sub-process, you'll need to use another version of Runtime.exec", "label": {"api": {"Runtime.exec": [[107, 118]]}}}, {"text": "Check @MappedSuperclass annotation", "label": {"api": {"@MappedSuperclass": [[6, 22]]}}}, {"text": "These methods allow you to fetch results of all tasks, that were submitted to an executor service", "label": {"api": {"These": [[0, 4]]}}}, {"text": "To set the displayed component of a JScrollPane, use JScrollPane#setViewportView(Component) rather than add(Component)", "label": {"api": {"JScrollPane#setViewportView(Component)": [[53, 90]]}}}, {"text": "The point is that FileWriter contains more than one write method", "label": {"api": {"FileWriter": [[18, 27]]}}}, {"text": "There is write(int) and write(String)", "label": {"api": {"write(int)": [[9, 18]], "write(String)": [[24, 36]]}}}, {"text": "LinkedHashMap maintains insertion-order", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "Beyond that there are various SortedMap implementations such as TreeMap", "label": {"api": {"SortedMap": [[30, 38]], "TreeMap": [[64, 70]]}}}, {"text": "To make changes visible, you will need to call the event dispatcher thread again by using the SwingUtilities.invokeLater() method", "label": {"api": {"SwingUtilities.invokeLater()": [[94, 121]]}}}, {"text": "You should take an image of the JFrame by painting the component to an image, and then send the image to a printer using the java.awt.print API", "label": {"api": {"java.awt.print": [[125, 138]]}}}, {"text": "I highly recommend to not do manual escaping of special characters, but instead to use Pattern.quote(...) for the escaping", "label": {"api": {"Pattern.quote(...)": [[87, 104]]}}}, {"text": "If you want to do more complex number formating, have a look at DecimaFormat", "label": {"api": {"DecimaFormat": [[64, 75]]}}}, {"text": "getDeclaredField gives you fields in the exact class referred by your Class object, as stated in the docs", "label": {"api": {"as stated in the docs": [[84, 104]]}}}, {"text": "You probably want to use getField instead", "label": {"api": {"getField": [[25, 32]]}}}, {"text": "A Java LinkedList is not only a List, btw, it also implements the Queue and Deque interfaces", "label": {"api": {"Queue": [[66, 70]], "Deque": [[76, 80]]}}}, {"text": "Your resultset probably didn't have any record, which is the reason why next() closed it", "label": {"api": {"next()": [[72, 77]]}}}, {"text": "next() returns a boolean, check it", "label": {"api": {"next()": [[0, 5]]}}}, {"text": "Refer this page", "label": {"api": {"page": [[11, 14]]}}}, {"text": "I would recommend you take a look at the BigDecimal Class", "label": {"api": {"BigDecimal": [[41, 50]]}}}, {"text": "If you're dealing with financial calculations, you might prefer BigDecimal to float or double", "label": {"api": {"BigDecimal": [[64, 73]]}}}, {"text": "ListIterator is a subclass which extends Iterator", "label": {"api": {"ListIterator": [[0, 11]], "Iterator": [[4, 11], [41, 48]]}}}, {"text": "A ListIterator allows traversal in both directions, rather than just checking if there are more elements (hasNext()), and getting the next one (next())", "label": {"api": {"ListIterator": [[2, 13]], "Iterator": [[6, 13]]}}}, {"text": "ListIterator also allows the addition (add(E e)) of entries, and the setting of entries (set(E e)) to the underlying list (Unlike Iterator, which just allows removing)", "label": {"api": {"ListIterator": [[0, 11]], "Iterator": [[4, 11], [130, 137]]}}}, {"text": "A ListIterator has no current element; its cursor position always lies between the element that would be returned by a call to previous() and the element that would be returned by a call to next()", "label": {"api": {"ListIterator": [[2, 13]]}}}, {"text": "ListIterator is just an extension of plain Iterator, allowing you to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list", "label": {"api": {"ListIterator": [[0, 11]], "Iterator": [[4, 11], [43, 50]]}}}, {"text": "If you want to know in real time the directory, you can access the class ServletContext methods", "label": {"api": {"ServletContext": [[73, 86]]}}}, {"text": "You can add a JTextArea to the JFileChooser by using the setAccessory() method", "label": {"api": {"setAccessory()": [[57, 70]]}}}, {"text": "Have a look at the API for the BigDecimal class", "label": {"api": {"API for the BigDecimal class": [[19, 46]]}}}, {"text": "You will find methods with names like add(BigDecimal), one for each elementary operator", "label": {"api": {"add(BigDecimal)": [[38, 52]]}}}, {"text": "You can check if a perticular permission is granted to you applet or not by using SecurityManager", "label": {"api": {"SecurityManager": [[82, 96]]}}}, {"text": "I have traced the issue down to ElementType", "label": {"api": {"ElementType": [[32, 42]]}}}, {"text": "supposed I could supplant ElementType with my own class and master the rippling changes, could I annotate any statement", "label": {"api": {"ElementType": [[26, 36]]}}}, {"text": "After Andrew Thompson described in his comment, that 3 different UI libraries are not the best choice, i started to try the AWT Choice class", "label": {"api": {"Choice": [[128, 133]]}}}, {"text": "When you receive new data, you could create an immutable object and  post it to the consumer thread (via a thread safe queue like a BlockingQueue) instead of having a shared variable", "label": {"api": {"BlockingQueue": [[132, 144]]}}}, {"text": "Better use the split() method found in the String class, like this", "label": {"api": {"split()": [[15, 21]]}}}, {"text": "For all practical purposes, StringTokenizer is deprecated and you should stop using it", "label": {"api": {"StringTokenizer": [[28, 42]]}}}, {"text": "StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "If you don't intend your delimiter to represent a regular expression, use the Pattern.quote() method to escape any special characters it contains", "label": {"api": {"Pattern.quote()": [[78, 92]]}}}, {"text": "You could use the Java reflection API and call getModifiers() to check and see if the class is final", "label": {"api": {"getModifiers()": [[47, 60]]}}}, {"text": "See the documentation for java.util.Random", "label": {"api": {"java.util.Random": [[26, 41]]}}}, {"text": "As you can see from the Constructor summary of http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/String.html you can initialize a String from bytes directly", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/String.html": [[47, 112]]}}}, {"text": "Why not iterate over the Map.Entry objects", "label": {"api": {"Map.Entry": [[25, 33]]}}}, {"text": "Initially, I had a single session shared across all threads, but I noticed that this was not supported", "label": {"api": {"not supported": [[89, 101]]}}}, {"text": "You could use HttpURLConnection.getHeaderField(String name) to get the Content-Disposition header, which is normally used to set the file name", "label": {"api": {"HttpURLConnection.getHeaderField(String name)": [[14, 58]]}}}, {"text": "EntityManager.persist() always tries to create a new managed object", "label": {"api": {"EntityManager.persist()": [[0, 22]]}}}, {"text": "The query string is URL-encoded by ExternalContext#encodeRedirectURL() which uses the response character encoding as obtained by ExternalContext#getResponseCharacterEncoding()", "label": {"api": {"ExternalContext#encodeRedirectURL()": [[35, 69]], "ExternalContext#getResponseCharacterEncoding()": [[129, 174]]}}}, {"text": "Try to run your \"work\" with SwingWorker", "label": {"api": {"SwingWorker": [[28, 38]]}}}, {"text": "According to the Javadoc getNodeValue() return null if it's call on some kind of Nodes (see the table at the start of the previous link)", "label": {"api": {"getNodeValue()": [[25, 38]]}}}, {"text": "You should probably use getTextContent() instead", "label": {"api": {"getTextContent()": [[24, 39]]}}}, {"text": "StringTokenizer is much faster for simple parsing like this (I did some benchmarking with a while back and you get huge speedups)", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "Or the BigInteger class will get you an arbitrary sized integer", "label": {"api": {"BigInteger": [[7, 16]]}}}, {"text": "Check out copyOfRange; and example", "label": {"api": {"copyOfRange": [[10, 20]]}}}, {"text": "If you are using Java 1.6 or greater, you can use Arrays.copyOfRange to copy a portion of the array", "label": {"api": {"Arrays.copyOfRange": [[50, 67]]}}}, {"text": "See javadoc for System", "label": {"api": {"javadoc for System": [[4, 21]]}}}, {"text": "One thing that could possibly help is to use an AtomicLong but that doesnt solve the issues with rolling back transactions", "label": {"api": {"AtomicLong": [[48, 57]]}}}, {"text": "If you know that these bytes are UTF-8 encoded, use BytesMessage.readUTF() convenience method", "label": {"api": {"BytesMessage.readUTF()": [[52, 73]]}}}, {"text": "UTF-16, use String(byte[], java.lang.String) constructor", "label": {"api": {"String(byte[], java.lang.String)": [[12, 43]]}}}, {"text": "Finally, consider using TextMessage to avoid the whole hustle", "label": {"api": {"TextMessage": [[24, 34]]}}}, {"text": "The BytesMessage specification has a method readUTF() that might be helpful", "label": {"api": {"BytesMessage specification": [[4, 29]]}}}, {"text": "You could use Collections.checkedList() - but why would you want to not use generics", "label": {"api": {"Collections.checkedList()": [[14, 38]]}}}, {"text": "This is not clearly documented in the Javadocs of the iterator method (be it in the Collection or Iterable interfaces) but all Java collections always return a new iterator under iterator() calls", "label": {"api": {"iterator": [[54, 61], [164, 171], [179, 186]], "Collection": [[84, 93]], "Iterable": [[98, 105]]}}}, {"text": "So, you should reuse the iterator you create instead of re-creating iterators on every loop run", "label": {"api": {"iterator": [[25, 32], [68, 75]]}}}, {"text": "As an example, there is the iterator() implementation at AbstractList", "label": {"api": {"iterator": [[28, 35]]}}}, {"text": "Take a look at CheckboxMenuItem if you're using AWT or JCheckBoxMenuItem if you're using Swing", "label": {"api": {"CheckboxMenuItem": [[15, 30]], "JCheckBoxMenuItem": [[55, 71]]}}}, {"text": "Directories you have to create by using the mkdir method", "label": {"api": {"mkdir": [[44, 48]]}}}, {"text": "See the com.sun.security.auth.login.ConfigFile for details on the load order", "label": {"api": {"com.sun.security.auth.login.ConfigFile": [[8, 45]]}}}, {"text": "You can use String.substring() to inspect the characters after HerpDerp", "label": {"api": {"String.substring()": [[12, 29]]}}}, {"text": "Here's the page with the String functions", "label": {"api": {"page with the String functions": [[11, 40]]}}}, {"text": "Here's the documentation for the FileReader class, which will also be helpful here", "label": {"api": {"documentation for the FileReader class": [[11, 48]]}}}, {"text": "Try using ArrayList instead of Vector, like so", "label": {"api": {"ArrayList": [[10, 18]]}}}, {"text": "You may be looking for the setTitleAt() method", "label": {"api": {"setTitleAt()": [[27, 38]]}}}, {"text": "Use HashMap.toString() (docs here)", "label": {"api": {"docs here": [[24, 32]]}}}, {"text": "The Java List#toArray explains it", "label": {"api": {"List#toArray": [[9, 20]]}}}, {"text": "This pitfall is documented in the Javadoc for the doubleToRawLongBits method", "label": {"api": {"doubleToRawLongBits method": [[50, 75]]}}}, {"text": "because the getText() method returns a String", "label": {"api": {"returns a String": [[29, 44]]}}}, {"text": "See http://docs.oracle.com/cd/E24290_01/coh.371/e22837/api_transactionslocks.htm#BEIIEEBB and http://docs.oracle.com/cd/E24290_01/coh.371/e22837/appendix_operational.htm#BAGJBCEF for more details", "label": {"api": {"http://docs.oracle.com/cd/E24290_01/coh.371/e22837/api_transactionslocks.htm#BEIIEEBB": [[4, 88]]}}}, {"text": "You can use a Scanner to read the string one integer at a time", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "In words of Joshua Bloch (explaining the default implementation of hashCode() method in String class , that is", "label": {"api": {"method": [[78, 83]]}}}, {"text": "You can use String#replaceAll", "label": {"api": {"String#replaceAll": [[12, 28]]}}}, {"text": "You need to use the allocateDirect(int) method from the ByteBuffer class", "label": {"api": {"allocateDirect(int)": [[20, 38]]}}}, {"text": "To avoid having to deal with such subtleties yourself, my advice would be to stick to Math.abs()", "label": {"api": {"Math.abs()": [[86, 95]]}}}, {"text": "From the Java documentations, the reason why Comparator has it's own equals() method", "label": {"api": {"documentations": [[14, 27]]}}}, {"text": "Check http://docs.oracle.com/javase/6/docs/api/java/util/Map.html if you are unfamiliar with Maps", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Map.html": [[6, 64]]}}}, {"text": "Did you check ResultSet's next method", "label": {"api": {"ResultSet's next method": [[14, 36]]}}}, {"text": "When you do myList.toString(); you actually call the AbstractCollection.toString() method, which in turn calls the toString() method of each of the objects in the List", "label": {"api": {"AbstractCollection.toString()": [[53, 81]]}}}, {"text": "This is because the AbstractCollection.toString() method uses these special characters when building your temp String", "label": {"api": {"AbstractCollection.toString()": [[20, 48]]}}}, {"text": "For regular expressions in Java, see http://docs.oracle.com/javase/6/docs/api/java/util/regex/package-summary.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/regex/package-summary.html": [[37, 113]]}}}, {"text": "Please do try to provide one Empty Border to your JPanel to which you are adding JScrollPane, or you can add one EmptyBorder to your JTextArea", "label": {"api": {"Empty Border": [[29, 40]]}}}, {"text": "Class.getMethods() or Class.getDeclaredMethods()", "label": {"api": {"Class.getMethods()": [[0, 17]], "Class.getDeclaredMethods()": [[22, 47]]}}}, {"text": "In order to handle HTML content you should use JavaMailSender which offers you possibility to send MimeMessage", "label": {"api": {"MimeMessage": [[99, 109]]}}}, {"text": "If you are using MimeMessageHelper, don't forget to set the HTML flag to true when calling #setText method", "label": {"api": {"MimeMessage": [[17, 27]]}}}, {"text": "One uses the interface for the variable's type", "label": {"api": {"interface": [[13, 21]]}}}, {"text": "The other uses concrete class type", "label": {"api": {"concrete class": [[15, 28]]}}}, {"text": "In general, it's better to use an interface type for variable types, because they are more portable and produce less tightly coupling", "label": {"api": {"interface": [[34, 42]]}}}, {"text": "You need to use BigDecimal for better precision", "label": {"api": {"BigDecimal": [[16, 25]]}}}, {"text": "I'd try using BigDecimal for arbitrary precision", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "JTabbedPane is backed by a SingleSelectionModel", "label": {"api": {"JTabbedPane": [[0, 10]], "SingleSelectionModel": [[27, 46]]}}}, {"text": "If you extend DefaultSingleSelectionModel, you can override the setSelectedIndex method and implement your logic", "label": {"api": {"SingleSelectionModel": [[21, 40]], "DefaultSingleSelectionModel": [[14, 40]]}}}, {"text": "The docs for AtomicLongArray say", "label": {"api": {"AtomicLongArray": [[13, 27]]}}}, {"text": "Thread has exposed a getId method for some time", "label": {"api": {"getId": [[21, 25]]}}}, {"text": "The new java.time.Duration class in Java 8 let's you parse durations out of the box", "label": {"api": {"java.time.Duration": [[8, 25]]}}}, {"text": "There is an overloaded Arrays.binarySearch() that does exactly this", "label": {"api": {"Arrays.binarySearch()": [[23, 43]]}}}, {"text": "Consequently you need to pass two parameters, in addition to the method name, to Class#getDeclaredMethod()", "label": {"api": {"Class#getDeclaredMethod()": [[81, 105]], "Class": [[81, 85]]}}}, {"text": "The two additional parameters need to be instances of Class, which an Object[] is obviously not", "label": {"api": {"Class": [[54, 58]]}}}, {"text": "Specifically, those Class instances need to be the same as the types of the parameters that doIt accepts", "label": {"api": {"Class": [[20, 24]]}}}, {"text": "You must close the entry using ZipOutputStream#closeEntry() prior to closing the output stream, or the entry is never confirmed to have been written entirely", "label": {"api": {"ZipOutputStream#closeEntry()": [[31, 58]]}}}, {"text": "You can save a file, with user interaction, from an unsigned WebStart application using javax.jnlp.FileSaveService", "label": {"api": {"javax.jnlp.FileSaveService": [[88, 113]]}}}, {"text": "Use ObjectInputStream and ObjectOutputStream, something like", "label": {"api": {"ObjectInputStream": [[4, 20]], "ObjectOutputStream": [[26, 43]]}}}, {"text": "Sort them like this if they're Comparable, or like this using a custom Comparator", "label": {"api": {"Comparable": [[31, 40]], "Comparator": [[71, 80]]}}}, {"text": "Use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "In your JButton's actionPerformed, you can call JLabel.setIcon(Icon) to set a background image", "label": {"api": {"JLabel.setIcon(Icon)": [[48, 67]]}}}, {"text": "You may create a custom exception (say FooException) extending Exception annotated with JAX-WS @WebFault", "label": {"api": {"@WebFault": [[95, 103]]}}}, {"text": "An elegant way to wait for threads to finish their work is to use a high-level synchronization  aid, like CountDownLatch", "label": {"api": {"CountDownLatch": [[106, 119]]}}}, {"text": "On your Sender and Receiver classes, you create and maintain the CountDownLatch", "label": {"api": {"CountDownLatch": [[65, 78]]}}}, {"text": "If you really want to skip bytes, you can use DataInputStream.skipBytes(int n) method", "label": {"api": {"DataInputStream.skipBytes(int n)": [[46, 77]]}}}, {"text": "There is a BitSet implementation in the standard Java SE API, you should try using that one", "label": {"api": {"BitSet": [[11, 16]]}}}, {"text": "Use the BigInteger constructor that takes a string and a base as arguments", "label": {"api": {"BigInteger": [[8, 17]]}}}, {"text": "Initialize a BitSet from the byte array representation of the BigInteger by calling BigInteger.toByteArray() with BitSet.valueOf()", "label": {"api": {"BigInteger": [[62, 71], [84, 93]], "BigInteger.toByteArray()": [[84, 107]], "BitSet.valueOf()": [[114, 129]]}}}, {"text": "BitSet.valueOf() is new in Java 7 so won't work in earlier Java versions", "label": {"api": {"BitSet.valueOf()": [[0, 15]]}}}, {"text": "If you don't like initializing BigInteger with strings and your binary numbers fit into 64-bits, you could also use Java 7's binary literals and initialize the BigInteger using BigInteger.valueOf(long) method instead", "label": {"api": {"BigInteger": [[31, 40], [160, 169], [177, 186]], "BigInteger.valueOf(long)": [[177, 200]]}}}, {"text": "If, however, you insist on doing this in your own code, you might want to have a look at the LinkedHashMap class", "label": {"api": {"LinkedHashMap": [[93, 105]]}}}, {"text": "On the other hand, if you only need to access events based on their insertion order, then you cannot do much better than ArrayList, since it supports indexed access to its contents with a constant complexity", "label": {"api": {"ArrayList": [[121, 129]]}}}, {"text": "If you just need to process them in a queue or stack, Java has several implementations of the Deque interface that might interest you", "label": {"api": {"Deque": [[94, 98]]}}}, {"text": "Lastly, if you want to insert your keys randomly and have the underlying structure sort them itself, you might find the TreeMap class useful", "label": {"api": {"TreeMap": [[120, 126]]}}}, {"text": "As per Statement.close method JavaDoc", "label": {"api": {"Statement.close method JavaDoc": [[7, 36]]}}}, {"text": "See also the official documentation", "label": {"api": {"the official documentation": [[9, 34]]}}}, {"text": "The end of the range is exclusive in Random, so you have to use", "label": {"api": {"Random": [[37, 42]]}}}, {"text": "You are correct, JavaFX (as of 2.1) does not support serialization of components using the Java Serializable interface - so you cannot use that mechanism", "label": {"api": {"Serializable": [[96, 107]]}}}, {"text": "JavaFX can deserialize from an FXML document using the FXMLLoader.load() method", "label": {"api": {"FXMLLoader.load()": [[55, 71]]}}}, {"text": "You can use appropriate JPQL with TypedQuery", "label": {"api": {"TypedQuery": [[34, 43]]}}}, {"text": "You best chance is to use FileLock but it's plateform-dependant, read the documentation, it's written that the results are \"advisory\", so be carefull", "label": {"api": {"FileLock": [[26, 33]]}}}, {"text": "you can also take a look at the ReentrantReadWriteLock class", "label": {"api": {"ReentrantReadWriteLock class": [[32, 59]]}}}, {"text": "I have not tried this, but looking at the documentation the FileSystem#newWatchService might be what you need", "label": {"api": {"FileSystem#newWatchService": [[60, 85]]}}}, {"text": "It uses the DeflaterInputStream provided by the JRE for compression, prepends the gzip header and appends the gzip trailer (aka footer)", "label": {"api": {"DeflaterInputStream": [[12, 30]]}}}, {"text": "PipedOutputStream lets you write to a GZIPOutputStream and expose that data through an InputStream", "label": {"api": {"PipedOutputStream": [[0, 16]]}}}, {"text": "I think in Swing the most common approach is to use PropertyChangeListeners", "label": {"api": {"PropertyChangeListeners": [[52, 74]]}}}, {"text": "Documentation from the Map API", "label": {"api": {"Map API": [[23, 29]]}}}, {"text": "It's true the LinkedHashMap API is not explicit about this but you could just try it out and observe your output", "label": {"api": {"Map API": [[24, 30]], "LinkedHashMap API": [[14, 30]]}}}, {"text": "A better way to create the imageBytes might be a ByteBuffer; it allows you to simply put each byte sequentially without calculating the index", "label": {"api": {"ByteBuffer": [[49, 58]]}}}, {"text": "In addition, it can be used directly with MessageDigest", "label": {"api": {"MessageDigest": [[42, 54]]}}}, {"text": "If you don't close the stream, it will be closed by GC (http://docs.oracle.com/javase/7/docs/api/java/io/FileInputStream.html#close%28%29) but it's not clear at all, when GC will hit that object", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/FileInputStream.html#close%28%29": [[56, 136]]}}}, {"text": "Component has an add method that takes two params - the object to be added and the index for it to be inserted at", "label": {"api": {"add": [[17, 19], [69, 71]]}}}, {"text": "The jsr-303 Validator does have a method right on it to validate just one property", "label": {"api": {"Validator": [[12, 20]]}}}, {"text": "For reading resources, construct a new URLClassLoader with the URLs of the JARs you want to load from", "label": {"api": {"URLClassLoader": [[39, 52]]}}}, {"text": "For creating JAR files, you can use the JarOutputStream class", "label": {"api": {"JarOutputStream": [[40, 54]]}}}, {"text": "Then use a Set instead of List", "label": {"api": {"Set": [[11, 13]]}}}, {"text": "Comparable is explained in http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html and requires a compareTo(T o)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html": [[27, 92]]}}}, {"text": "This is for the String overload of Collator.compare (as the linked example compares Strings), but the general version of the method behaves the same way", "label": {"api": {"the general version of the method": [[98, 130]]}}}, {"text": "You can get a MethodHandle to anything you can get a Method for using MethodHandles.Lookup.unreflect()", "label": {"api": {"MethodHandle": [[14, 25], [70, 81]], "Method": [[14, 19], [53, 58], [70, 75]], "MethodHandles.Lookup.unreflect()": [[70, 101]]}}}, {"text": "All methods (keySet, values, entrySet) return a collection", "label": {"api": {"keySet": [[13, 18]], "values": [[21, 26]], "entrySet": [[29, 36]]}}}, {"text": "Since Java 8 i often use Streams with lambda expressions", "label": {"api": {"Streams": [[25, 31]]}}}, {"text": "List, along with Collection.sort() would fit your needs", "label": {"api": {"List": [[0, 3]]}}}, {"text": "An alternative is to bind the dropdown to an UIInput in the current view scope and evaluate the selected value by its UIInput#getValue() instead", "label": {"api": {"UIInput": [[45, 51], [118, 124]], "UIInput#getValue()": [[118, 135]]}}}, {"text": "I have little idea what Jsoup is, but I suggest you read up on HttpURLConnection.getErrorStream()", "label": {"api": {"HttpURLConnection.getErrorStream()": [[63, 96]]}}}, {"text": "See the Serializable javadoc for more info", "label": {"api": {"Serializable javadoc": [[8, 27]]}}}, {"text": "When constructing the JScrollBar, you can set the size of the viewable area in the constructor using the extent parameter", "label": {"api": {"constructor": [[83, 93]]}}}, {"text": "Use FontMetrics class", "label": {"api": {"FontMetrics": [[4, 14]]}}}, {"text": "Try the Polygon class or Area class", "label": {"api": {"Polygon class": [[8, 20]], "Area class": [[25, 34]]}}}, {"text": "And do similar things for all methods in the Shape interface", "label": {"api": {"Shape": [[45, 49]]}}}, {"text": "It's been interpreted as a Number by MessageFormat and hence being formatted with a thousands separator which can be a comma or a dot, depending on the current locale", "label": {"api": {"Number": [[27, 32]], "MessageFormat": [[37, 49]]}}}, {"text": "You can prevent it being interpreted as a Number by adding a zero width space", "label": {"api": {"Number": [[42, 47]]}}}, {"text": "Since <fmt:message /> uses Java's built-in MessageFormat class under the hood, we can just insert a formatting pattern in the ResourceBundle's message string itself", "label": {"api": {"MessageFormat": [[43, 55]]}}}, {"text": "The # here can in fact be any format string as documented in the DecimalFormat class", "label": {"api": {"DecimalFormat": [[65, 77]]}}}, {"text": "In this case, any SimpleDateFormat format string can be used instead of yyyy", "label": {"api": {"SimpleDateFormat": [[18, 33]]}}}, {"text": "Use File class, and its methods list() or listFiles()", "label": {"api": {"File": [[4, 7], [46, 49]], "list()": [[32, 37]], "listFiles()": [[42, 52]]}}}, {"text": "Also you can use the same methods with a FilenameFilter, which are list(FilenameFilter filter) or listFiles(FilenameFilter filter)", "label": {"api": {"File": [[41, 44], [72, 75], [102, 105], [108, 111]], "FilenameFilter": [[41, 54], [72, 85], [108, 121]], "list(FilenameFilter filter)": [[67, 93]], "listFiles(FilenameFilter filter)": [[98, 129]]}}}, {"text": "Java provides dynamically sized array with its ArrayList class", "label": {"api": {"ArrayList": [[47, 55]]}}}, {"text": "In your menu item's Action, you can use setSelectedIndex() on your JTabbedPane to select the pane holding an existing calculator instance", "label": {"api": {"setSelectedIndex()": [[40, 57]]}}}, {"text": "You can use setComponentAt() to replace the content of any tab with an instance of your calculator", "label": {"api": {"setComponentAt()": [[12, 27]]}}}, {"text": "I'm not sure if it will help, but when I had to do this assignment in School I found that looking through the API and trying to use it very helpful", "label": {"api": {"API": [[110, 112]]}}}, {"text": "Whenver you need textual formatting always use PrintWriter", "label": {"api": {"PrintWriter": [[47, 57]]}}}, {"text": "The right way of doing is to wrap the writer inside a PrintWriter and use println() method, like", "label": {"api": {"PrintWriter": [[54, 64]]}}}, {"text": "Inherit your handler from DefaultHandlder, and override characters to concatenate string parts coming from the parser (you can use StringBuilder for that)", "label": {"api": {"DefaultHandlder": [[26, 40]], "characters": [[56, 65]], "StringBuilder": [[131, 143]]}}}, {"text": "The ColorQuantizerDescriptor shows the choice of quantization processes you can apply", "label": {"api": {"ColorQuantizerDescriptor": [[4, 27]]}}}, {"text": "But let me guess, as something is telling me that when you are calling the ListSelectionListener you are not using getIsValueAdjusting() of the ListSelectionEvent, right", "label": {"api": {"getIsValueAdjusting()": [[115, 135]]}}}, {"text": "How about BitSet.size()?....", "label": {"api": {"BitSet.size()": [[10, 22]]}}}, {"text": "There is no general solution for Collection subclasses in general - most iterators will become invalid if the collection is modified, unless the modification happens through the iterator itself via Iterator.remove()", "label": {"api": {"Iterator.remove()": [[198, 214]], "remove": [[207, 212]]}}}, {"text": "There is a potential solution when it comes to List implementations", "label": {"api": {"List": [[47, 50]]}}}, {"text": "the List interface has index-based add/get/set/remove operations", "label": {"api": {"List": [[4, 7]], "add": [[35, 37]], "get": [[39, 41]], "set": [[43, 45]], "remove": [[47, 52]]}}}, {"text": "If concurrency is the case, then I would recommend using CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[57, 76]]}}}, {"text": "You can use List", "label": {"api": {"List": [[12, 15]]}}}, {"text": "The URL can be formed relative to the code base (the location of the Jars/classes) or document base (the location of the HTML)", "label": {"api": {"code base": [[38, 46]], "document base": [[86, 98]]}}}, {"text": "Refer to the example in this website", "label": {"api": {"website": [[29, 35]]}}}, {"text": "Refer to this website", "label": {"api": {"website": [[14, 20]]}}}, {"text": "Also, the Thread class has a non-arg constructor", "label": {"api": {"Thread": [[10, 15]], "non-arg constructor": [[29, 47]]}}}, {"text": "And, to access a List, you need to use ints.get(index)", "label": {"api": {"List": [[17, 20]]}}}, {"text": "A Map is a much better choice", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "Java's BigDecimal http://docs.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html class has all the functions you may need for this purpose", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/math/BigDecimal.html": [[18, 87]]}}}, {"text": "Verify that you invoke setVisible() after adding components and calling pack(), as discussed in this related example", "label": {"api": {"pack()": [[72, 77]]}}}, {"text": "You may have noticed that calling setVisible(true) also works; this is because it calls validate() internally", "label": {"api": {"it calls validate() internally": [[79, 108]]}}}, {"text": "Side note, you can probably skip the valid variable and use variable =sc.nextInt();, compare with @Austin's answer", "label": {"api": {"sc.nextInt()": [[70, 81]]}}}, {"text": "To read in the certificates from a p7b file you can use the CertificateFactory class", "label": {"api": {"CertificateFactory": [[60, 77]]}}}, {"text": "Ask each Shape with shape.contains(point)", "label": {"api": {"shape.contains(point)": [[20, 40]]}}}, {"text": "You just need to implement a comparator, which can then be used with Collections.sort()", "label": {"api": {"Collections.sort()": [[69, 86]]}}}, {"text": "The Writer, which is the superclass of PrintWriter explicitly mentions in its constructor documentation that all critical sections synchronize either on the Writer instance itself, or on an explicitly specified object", "label": {"api": {"Writer": [[4, 9], [44, 49], [157, 162]], "PrintWriter": [[39, 49]]}}}, {"text": "Therefore Writer is explicitly thread-safe..", "label": {"api": {"Writer": [[10, 15]]}}}, {"text": "Unfortunately, the PrintWriter subclass documentation makes no such promises explicitly", "label": {"api": {"Writer": [[24, 29]], "PrintWriter": [[19, 29]]}}}, {"text": "It inherits the Writer lock object, but there is no way to know whether any additional or overridden methods are still thread-safe", "label": {"api": {"Writer": [[16, 21]]}}}, {"text": "On the other hand, as far as I can tell the Sun/OpenJDK PrintWriter implementation contains synchronized blocks in pretty much every method", "label": {"api": {"Writer": [[61, 66]], "PrintWriter": [[56, 66]]}}}, {"text": "I'd rather play it safe and assume that PrintWriter is not thread-safe, than rely on undocumented behavior and regret this in the long run..", "label": {"api": {"Writer": [[45, 50]], "PrintWriter": [[40, 50]]}}}, {"text": "Try looking at the BigDecimal Class", "label": {"api": {"BigDecimal": [[19, 28]]}}}, {"text": "You can make use of DecimalFormat to give you the style you wish", "label": {"api": {"DecimalFormat": [[20, 32]]}}}, {"text": "I think you are in need to learn of Session and Session Handling in java web applications", "label": {"api": {"Session": [[36, 42], [48, 54]]}}}, {"text": "Another solution is to use an InputVerifier on a simple JTextField", "label": {"api": {"InputVerifier": [[30, 42]]}}}, {"text": "ObjectInputStream.readObject returns an Object", "label": {"api": {"ObjectInputStream.readObject": [[0, 27]]}}}, {"text": "BufferedReader#readLine returns null if the end of the stream has been reached", "label": {"api": {"BufferedReader#readLine": [[0, 22]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/net/Socket.html#Socket(java.net.InetAddress,%20int) <- it depends on the constructor you use", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/net/Socket.html#Socket(java.net.InetAddress,%20int)": [[0, 96]]}}}, {"text": "Collections.shuffle() puts the elements in a random order", "label": {"api": {"Collections.shuffle()": [[0, 20]]}}}, {"text": "The best you could do is use the copyOfRange method although that makes a deep copy", "label": {"api": {"copyOfRange": [[33, 43]]}}}, {"text": "The only way I've found to reliably use my own stream handler is to pass it into the URL constructor", "label": {"api": {"URL constructor": [[85, 99]]}}}, {"text": "Try using KeyEvent#getKeyChar()", "label": {"api": {"KeyEvent#getKeyChar()": [[10, 30]]}}}, {"text": "Use the directory() method of ProcessBuilder so that the external process is run in the correct place so that the jar can be found", "label": {"api": {"directory()": [[8, 18]]}}}, {"text": "Convert your data to a SortedMap, specifically a TreeMap instance", "label": {"api": {"TreeMap": [[49, 55]]}}}, {"text": "Use Date class that is available", "label": {"api": {"Date": [[4, 7]]}}}, {"text": "Since Java 8 there is a whole set of Function-like interfaces in the java.util.function package", "label": {"api": {"the java.util.function package": [[65, 94]], "Function": [[37, 44]]}}}, {"text": "The one you're asking for specifically is simply Function", "label": {"api": {"Function": [[49, 56]]}}}, {"text": "For example Guava has the Function<F,T> interface with the method T apply(F input)", "label": {"api": {"Function": [[26, 33]]}}}, {"text": "One of them is the SwingWorker", "label": {"api": {"SwingWorker": [[19, 29]]}}}, {"text": "Java does have a String.format method", "label": {"api": {"String.format": [[17, 29]]}}}, {"text": "Then use replace all for converting back", "label": {"api": {"replace all": [[9, 19]]}}}, {"text": "A first idea would be to use a Comparator", "label": {"api": {"Comparator": [[31, 40]]}}}, {"text": "Matcher has two methods that come in handy for this kind of situation, appendReplacement() and appendTail()", "label": {"api": {"Matcher": [[0, 6]], "appendReplacement()": [[71, 89]]}}}, {"text": "If the filename of the file changes at point //A, you're going to get a FileNotFoundException according to the FileReader documentation", "label": {"api": {"FileReader documentation": [[111, 134]]}}}, {"text": "I could not find any method in the Java SE 6 API to do that", "label": {"api": {"Java SE 6 API": [[35, 47]]}}}, {"text": "a copy-paste from the Container#add method)", "label": {"api": {"Container#add": [[22, 34]]}}}, {"text": "Most likely you are getting back a PropertyResourceBundle, which internally uses a HashMap for storage", "label": {"api": {"PropertyResourceBundle": [[35, 56]], "HashMap": [[83, 89]]}}}, {"text": "HashMaps are not ordered", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "For an easy way to create these, look into File.mkdirs()", "label": {"api": {"File.mkdirs()": [[43, 55]]}}}, {"text": "After you have used addAll to combine your lists, you can use Collections.sort(List, Comparator) to sort your ArrayList", "label": {"api": {"Collections.sort(List, Comparator)": [[62, 95]]}}}, {"text": "In your Comparator's compare function, you will compare the two objects using the values you wish to sort by (you mentioned serial id?)", "label": {"api": {"compare": [[21, 27], [48, 54]]}}}, {"text": "InputStream.read() typically doesn't read the entire stream for you, only some part of it", "label": {"api": {"InputStream.read()": [[0, 17]]}}}, {"text": "Note that InputStream.read() returns the number of bytes actually read, which you'll need to check", "label": {"api": {"InputStream.read()": [[10, 27]]}}}, {"text": "According to http://docs.oracle.com/javase/1.4.2/docs/api/java/io/StringReader.html#read%28%29 StringReader.Read() returns -1 if the end of the stream has been reached", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/io/StringReader.html#read%28%29": [[13, 93]]}}}, {"text": "The metadata for the exception is stored in StackTraceElement class, which you can get from your exception by calling getStackTrace()", "label": {"api": {"StackTraceElement": [[44, 60]], "getStackTrace()": [[118, 132]]}}}, {"text": "I'm guessing that because Calendar.add does not return anything, so the code you are showing can not be compiled at all", "label": {"api": {"Calendar.add": [[26, 37]]}}}, {"text": "You need to use BigDecimal", "label": {"api": {"BigDecimal": [[16, 25]]}}}, {"text": "Take a look at DefaultTableModel", "label": {"api": {"DefaultTableModel": [[15, 31]]}}}, {"text": "You could try loading the uploaded file into a KeyStore", "label": {"api": {"KeyStore": [[47, 54]]}}}, {"text": "You should use LinkedHashMap or TreeMap if you want to iterate on insertion order or on natural order, respectively", "label": {"api": {"LinkedHashMap": [[15, 27]], "TreeMap": [[32, 38]]}}}, {"text": "You should use the StringBuilder instead of concatenating strings", "label": {"api": {"StringBuilder": [[19, 31]]}}}, {"text": "There is an special java.lang.reflect.Array Class", "label": {"api": {"java.lang.reflect.Array": [[20, 42]]}}}, {"text": "To bind objects programmatically in the local one, you can use javax.naming.Context.bind(String, Object) as usual", "label": {"api": {"javax.naming.Context.bind(String, Object)": [[63, 103]]}}}, {"text": "You need to set the very same cookie with a null value and a max age of 0 (and the same path, if you have set a custom one) back on the response by HttpServletResponse#addCookie()", "label": {"api": {"HttpServletResponse#addCookie()": [[148, 178]]}}}, {"text": "One dirty way to do it is to run your application with administrative privileges and invoke a command utility such as Handle using a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[133, 146]]}}}, {"text": "Use the String(byteArray, charset) constructor", "label": {"api": {"String(byteArray, charset)": [[8, 33]]}}}, {"text": "Do the job in a method which is annotated with @PreDestroy", "label": {"api": {"@PreDestroy": [[47, 57]]}}}, {"text": "What you're looking for is SessionSynchronization", "label": {"api": {"SessionSynchronization": [[27, 48]]}}}, {"text": "You should find the encoding and use this encoding to read the File using InputStreamReader", "label": {"api": {"InputStreamReader": [[74, 90]]}}}, {"text": "The built in java.util.Properties#load(...) supports neither #includes nor variable substitution", "label": {"api": {"java.util.Properties#load(...)": [[13, 42]]}}}, {"text": "Calling File.delete() permanently removes the file, without going into the recycling bin or anything similar", "label": {"api": {"delete": [[13, 18]]}}}, {"text": "Because String is a class rest are just primitive data types and the naming conventions specify that the class names have to be in PascalCase", "label": {"api": {"String": [[8, 13]]}}}, {"text": "Have you tried using the Statement.setMaxRows method", "label": {"api": {"Statement.setMaxRows method": [[25, 51]]}}}, {"text": "The LinkedHashMap type is like a combination of a HashMap and a Queue - it stores key/value pairs, but also remembers the order in which they were inserted", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "There is no explicit poll() function, but if you get an iterator over the LinkedHashMap you will visit the elements in the order in which they were added", "label": {"api": {"LinkedHashMap": [[74, 86]]}}}, {"text": "The DefaultTreeCellRenderer simply calls toString(), via convertValueToText(), which accesses the user object of DefaultMutableTreeNode", "label": {"api": {"convertValueToText()": [[57, 76]]}}}, {"text": "In my Java app, I'm looking for a streaming version of URLEncoder.encode(String s, String enc)", "label": {"api": {"URLEncoder.encode(String s, String enc)": [[55, 93]]}}}, {"text": "Use Math.round() to perform rounding, instead of casting to int", "label": {"api": {"Math.round()": [[4, 15]]}}}, {"text": "See InputSteram.read(byte[]) for reading bytes at a time", "label": {"api": {"InputSteram.read(byte[])": [[4, 27]]}}}, {"text": "To get the package, use Class#getPackage()", "label": {"api": {"Class#getPackage()": [[24, 41]]}}}, {"text": "Then, Package#getName() can be called to get the package as the String you see in your code's package declaration", "label": {"api": {"Package#getName()": [[6, 22]]}}}, {"text": "Looks like you want Class.isInstance(Object o)", "label": {"api": {"Class.isInstance(Object o)": [[20, 45]]}}}, {"text": "If you intend to pass a copy of your Array and work with it, first create a copy using System.arraycopy() method, and then pass the copy of the Array", "label": {"api": {"System.arraycopy()": [[87, 104]]}}}, {"text": "From the JavaDoc of XMLAdapter#unmarshal(ValueType)", "label": {"api": {"XMLAdapter#unmarshal(ValueType)": [[20, 50]]}}}, {"text": "The caller is responsible for reporting the error to the user through ValidationEventHandler", "label": {"api": {"ValidationEventHandler": [[70, 91]]}}}, {"text": "So, yes - the exception is eaten and then reported using ValidationEventHandler, not thrown to the top of your stack", "label": {"api": {"ValidationEventHandler": [[57, 78]]}}}, {"text": "Check if you are already using any (custom, perhaps) ValidationEventHandler that groups your exceptions, or use DefaultValidationEventHandler, like this", "label": {"api": {"ValidationEventHandler": [[53, 74], [119, 140]], "DefaultValidationEventHandler": [[112, 140]]}}}, {"text": "See the documentation for Java's LineNumberReader class", "label": {"api": {"Java's LineNumberReader class": [[26, 54]]}}}, {"text": "Basically, your best option seems to be using CharsetDecoder directly", "label": {"api": {"CharsetDecoder": [[46, 59]]}}}, {"text": "The OpenJDK 7 and Java 7 SE from Oracle also implements Elliptic Curve cryptography, earlier editions only contained a comprehensive API for Elliptic Curve cryptography, but you required a JCE provider (like Bouncy Castle) to provide the actual implementation", "label": {"api": {"a comprehensive API for Elliptic Curve cryptography": [[117, 167]]}}}, {"text": "After this, you can use the TransformerFactory to get a Transformer object, and to use its transform method", "label": {"api": {"TransformerFactory": [[28, 45]]}}}, {"text": "You should transform from a DOMSource to a StreamResult object which can be created based on FileOutputStream", "label": {"api": {"DOMSource": [[28, 36]], "StreamResult": [[43, 54]]}}}, {"text": "You can create another caching Proxy around your web service client proxy object, and provide it with an InvocationHandler, that caches the result of method invocations", "label": {"api": {"Proxy": [[31, 35]], "InvocationHandler": [[105, 121]]}}}, {"text": "There is no empty constructor for class GroupLayout", "label": {"api": {"class GroupLayout": [[34, 50]]}}}, {"text": "Use SimpleDateFormat ( http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html ) class to parse original string, snd after it format it using new format with SimpleDateFormat class", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html": [[23, 94]]}}}, {"text": "First you need to have a Date object from String for this you can use SimpleDateFormat, Here is an Answer related to this step", "label": {"api": {"Date": [[25, 28], [76, 79]], "SimpleDateFormat": [[70, 85]]}}}, {"text": "Secondly, you have to get back this Date in respective text format, for this again use SimpleDateFormat as", "label": {"api": {"Date": [[36, 39], [93, 96]], "SimpleDateFormat": [[87, 102]]}}}, {"text": "Deserialize it to POJOs(with Gson or Jackson), and write a Comparator for that POJOs", "label": {"api": {"Comparator": [[59, 68]]}}}, {"text": "You could created a new Map instance and then call putAll(Map), passing in the original Map", "label": {"api": {"putAll(Map)": [[51, 61]]}}}, {"text": "I've found javax.swing.Box the most useful, and simplest, class for laying out windows, and I'd recommend it to you", "label": {"api": {"javax.swing.Box": [[11, 25]]}}}, {"text": "javax.swing.Box is not the solution to all the world's problems, but it should get you started", "label": {"api": {"javax.swing.Box": [[0, 14]]}}}, {"text": "Have you looked at the ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[23, 49]]}}}, {"text": "A simple usage would be to create a Callable for each of your sensors, and configure the thread pool to contain as many threads as you have sensors", "label": {"api": {"Callable": [[36, 43]]}}}, {"text": "Then submit each Callable, specifying an appropriate schedule", "label": {"api": {"Callable": [[17, 24]]}}}, {"text": "To get the best possible performances, you need to use a ZipFile in order to access directly to an entry thanks to the method getEntry(name) whatever the size of your archive", "label": {"api": {"ZipFile": [[57, 63]], "getEntry(name)": [[126, 139]]}}}, {"text": "Use the String.replaceAll() method with the right regex", "label": {"api": {"String.replaceAll()": [[8, 26]]}}}, {"text": "You're looking for an AtomicReferenceArray", "label": {"api": {"AtomicReferenceArray": [[22, 41]]}}}, {"text": "Notice that JFrame extends from java.awt.Frame which means that although JFrame may be rendered mostly by Java, it is backed by a heavy-weight native OS window", "label": {"api": {"JFrame": [[12, 17], [73, 78]], "java.awt.Frame": [[32, 45]]}}}, {"text": "Since yours appears to be small-scale, you should be fine, however, BigDecimal is much easier to use for purposes like these", "label": {"api": {"BigDecimal": [[68, 77]]}}}, {"text": "How to use BigDecimal", "label": {"api": {"BigDecimal": [[11, 20]]}}}, {"text": "The API docs say that this exception means that \"the specified GraphicsConfiguration does not support 3D rendering\"", "label": {"api": {"API docs": [[4, 11]]}}}, {"text": "I am implementing a MVC and i want to have a JToolTip on a JLabel in my view", "label": {"api": {"JToolTip": [[45, 52]]}}}, {"text": "I read the Javadoc for JToolTip and TollTipManager", "label": {"api": {"JToolTip": [[23, 30]], "TollTipManager": [[36, 49]]}}}, {"text": "JToolTip haven't setter for ToolTipManager and in the doc they said", "label": {"api": {"JToolTip": [[0, 7]]}}}, {"text": "To use it, you need to call a static sharedInstance method that returns the instance of this class", "label": {"api": {"sharedInstance": [[37, 50]]}}}, {"text": "ToolTipManager manages all tooltips - it is a global configuration class, changes made to the sharedInstance will be applied to every tooltip in your application", "label": {"api": {"sharedInstance": [[94, 107]]}}}, {"text": "JMF provides a class MediaPlayer which can be used as a full-featured player", "label": {"api": {"MediaPlayer": [[21, 31]]}}}, {"text": "Can someone tell me how to use MediaPlayer class to play audio file", "label": {"api": {"MediaPlayer": [[31, 41]]}}}, {"text": "The API you are using is using loadLibrary(String)", "label": {"api": {"loadLibrary(String)": [[31, 49]]}}}, {"text": "It seems you cannot successfully pre-empt (cause it to succeed) this by invoking the more explicit load(String) first", "label": {"api": {"load(String)": [[99, 110]]}}}, {"text": "For searching capabilities, have a look at Scanner", "label": {"api": {"Scanner": [[43, 49]]}}}, {"text": "As for seek and seekorigin, take a look at RandomAccessFile to see if it does what you want", "label": {"api": {"RandomAccessFile": [[43, 58]]}}}, {"text": "Then, I implemented the DynamicMBean interface in such a way that it parsed out the annotations on the class in question and then registers them with the PlatformMBeanServer", "label": {"api": {"DynamicMBean interface": [[24, 45]], "DynamicMBean": [[24, 35]]}}}, {"text": "Then, when my application starts up, I register an instance of this class using my implementation of DynamicMBean and parse out the annotations", "label": {"api": {"DynamicMBean": [[101, 112]]}}}, {"text": "If your iterator iterates over a List or Queue instance, then there are fewer restrictions", "label": {"api": {"List": [[33, 36]], "Queue": [[41, 45]]}}}, {"text": "As long as you do not change the structure of the list, you can do whatever you wish with the object returned by Iterator.next()", "label": {"api": {"Iterator.next()": [[113, 127]]}}}, {"text": "On the other hand, the only list structure modification that is allowed without invalidating the Iterator object, is to remove the current element using Iterator.remove(), which, incidentally, is an optional operation", "label": {"api": {"Iterator.remove()": [[153, 169]]}}}, {"text": "If you try to modify the list directly then the iterator will be invalidated and you will get a ConcurrentModificationException the next time you try to use it", "label": {"api": {"ConcurrentModificationException": [[96, 126]]}}}, {"text": "Additionally, if you are iterating over a Set, you are generally far more constrained", "label": {"api": {"Set": [[42, 44]]}}}, {"text": "depending on the details of the actual Set implemenation, you are not generally able to modify arbitrary fields in your objects", "label": {"api": {"Set": [[39, 41]]}}}, {"text": "For example, the value returned by hashCode() should not change once an object has been inserted in a HashSet..", "label": {"api": {"Set": [[106, 108]]}}}, {"text": "If you are not going to use Iterator.remove(), just use a for-each loop instead of the explicity iterator and be done with it", "label": {"api": {"Iterator.remove()": [[28, 44]]}}}, {"text": "You could always use the Java Preferences API which will store info per-user and you don't have to worry about the implementation", "label": {"api": {"Java Preferences API": [[25, 44]]}}}, {"text": "If the intention is to let the user enter a password however, I suggest you use Console.readPassword", "label": {"api": {"Console.readPassword": [[80, 99]]}}}, {"text": "Look at java.util.Timer", "label": {"api": {"java.util.Timer": [[8, 22]]}}}, {"text": "Maybe try explicitly setting the systemId of the source of the base files and make them have different directories", "label": {"api": {"setting the systemId": [[21, 40]]}}}, {"text": "This SSLContext will be initialised with TrustManager that dictate how trust should be established", "label": {"api": {"TrustManager": [[41, 52]]}}}, {"text": "You can also create an X509TrustManager based on a custom keystore programmatically (as described in this answer) and use it in a specific SSLContext that doesn't affect the default one", "label": {"api": {"TrustManager": [[27, 38]]}}}, {"text": "If you want to handle state changes, you should register a ChangeListener", "label": {"api": {"ChangeListener": [[59, 72]]}}}, {"text": "To mimic LIKE you are going to have to loop through all your objects and then on the field(s) you are about, you'll have to use something like String.match to see if the field(s) match the filtering criteria", "label": {"api": {"String.match": [[143, 154]]}}}, {"text": "You can use the addAll method, but bear in mind that'll not duplicate the HashMaps and much less the Objects within", "label": {"api": {"addAll": [[16, 21]]}}}, {"text": "Use the Calendar class", "label": {"api": {"Calendar": [[8, 15]]}}}, {"text": "If you already have a Date object, you can still use Calendar", "label": {"api": {"Calendar": [[53, 60]]}}}, {"text": "You'll need to .flush() your ObjectOutputStream otherwise the BufferedOutputStream won't send its output to the socket", "label": {"api": {".flush()": [[15, 22]]}}}, {"text": "Use setValue, ie", "label": {"api": {"setValue": [[4, 11]]}}}, {"text": "Also consider the AlphaComposite modes available to the graphics context, discussed here", "label": {"api": {"AlphaComposite": [[18, 31]]}}}, {"text": "You can use WindowStateListener", "label": {"api": {"WindowStateListener": [[12, 30]]}}}, {"text": "LinkedList seems to a way to go, LinkedList is a doubly linked list, which is good for a Queue data structure (FIFO)", "label": {"api": {"LinkedList": [[0, 9], [33, 42]]}}}, {"text": "Check out the Deque interface, which provides for insertions/removals at both ends", "label": {"api": {"Deque": [[14, 18]]}}}, {"text": "LinkedList implements that interface (as mentioned above), but for your use, an ArrayDeque may be better -- you won't incur the cost of constant object allocations for each node", "label": {"api": {"Deque": [[85, 89]]}}}, {"text": "the beauty of writing against the Deque interface, rather than any specific implementation of it, is that you can very easily switch implementations to test which one performs best", "label": {"api": {"Deque": [[34, 38]]}}}, {"text": "Each of the method calls is returning a new String representing the change, with the current String staying the same", "label": {"api": {"method calls": [[12, 23]]}}}, {"text": "Because the each method is returning a String you can chain your method calls together", "label": {"api": {"method calls": [[65, 76]]}}}, {"text": "You can also use Arrays.setAll for this", "label": {"api": {"Arrays.setAll": [[17, 29]]}}}, {"text": "java.util.concurrent.ConcurrentLinkedQueue.)  After polling both queues with no results, wait() on a monitor", "label": {"api": {"java.util.concurrent.ConcurrentLinkedQueue": [[0, 41]]}}}, {"text": "Read the hex as an integer and use intBitsToFloat", "label": {"api": {"intBitsToFloat": [[35, 48]]}}}, {"text": "You could also look for a HashSet or a TreeSet, they could be suitable to your solution", "label": {"api": {"HashSet": [[26, 32]], "TreeSet": [[39, 45]]}}}, {"text": "A good example of where this matters in practice is the ConcurrentSkipListSet implementation in the JDK, which states", "label": {"api": {"ConcurrentSkipListSet implementation": [[56, 91]]}}}, {"text": "You can communicate between threads easily if you use a ConcurrentLinkedQueue as the \"messenger\"", "label": {"api": {"ConcurrentLinkedQueue": [[56, 76]]}}}, {"text": "CopyOnWriteArraySet or Collections.newSetFromMap(ConcurrentHashMap), but it's hard to say given what I know about your problem", "label": {"api": {"CopyOnWriteArraySet": [[0, 18]], "ConcurrentHashMap": [[49, 65]]}}}, {"text": "Or when you're already on Java EE 6 /Servlet 3.0 and are thus likely using @WebFilter on the class", "label": {"api": {"@WebFilter": [[75, 84]]}}}, {"text": "Take a look at BlockingQueue and its implementations", "label": {"api": {"BlockingQueue": [[15, 27]]}}}, {"text": "createBufferStrategy() throws the exception because the Canvas is not displayable until added to the Frame, which relies on the features of the heavyweight peer component provided by the host platform", "label": {"api": {"createBufferStrategy()": [[0, 21]]}}}, {"text": "If so, you could use a java.util.BitSet", "label": {"api": {"java.util.BitSet": [[23, 38]]}}}, {"text": "You can use Line2D.Double", "label": {"api": {"Line2D.Double": [[12, 24]]}}}, {"text": "Use Graphics2D.draw() to draw it", "label": {"api": {"Graphics2D.draw()": [[4, 20]]}}}, {"text": "You can use a combination of BoxLayout and size/alignment hints to achieve this", "label": {"api": {"BoxLayout": [[29, 37]]}}}, {"text": "For the slight gradient (squints), paint the BG using a GradientPaint", "label": {"api": {"GradientPaint": [[56, 68]]}}}, {"text": "In the Java API, this is provided by the ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[41, 62]]}}}, {"text": "Look at the TreeNode API and you'll find the getParent() that will get your node's parent node", "label": {"api": {"TreeNode API": [[12, 23]]}}}, {"text": "Check the TreeModel API for more on this", "label": {"api": {"TreeModel API": [[10, 22]]}}}, {"text": "But I suggest you look at the java database tutorial http://docs.oracle.com/javase/tutorial/jdbc/index.html and the java.util.Date api doc http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Date.html for more info", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/sql/Date.html": [[139, 201]]}}}, {"text": "Best way is to use a SwingWorker class", "label": {"api": {"SwingWorker class": [[21, 37]]}}}, {"text": "For example, notice that in the Map interface there is the Map.Entry inner interface", "label": {"api": {"Map": [[32, 34], [59, 61]], "Map.Entry": [[59, 67]]}}}, {"text": "Here we see not only what you can expect of a Map but a good deal of detail about some of the things you can expect from a Map such as their Entries", "label": {"api": {"Map": [[46, 48], [123, 125]]}}}, {"text": "regarding to you sample directly after the pack command", "label": {"api": {"pack": [[43, 46]]}}}, {"text": "the pack() command possibly rearranges your frame", "label": {"api": {"pack": [[4, 7]]}}}, {"text": "I guess you want something like java.net.URL", "label": {"api": {"java.net.URL": [[32, 43]]}}}, {"text": "I recently found out about the WeakHashMap data structure in Java", "label": {"api": {"WeakHashMap": [[31, 41]]}}}, {"text": "Java has a system of references where the language can tell your code whether or not some object is still in use", "label": {"api": {"references": [[21, 30]]}}}, {"text": "You can use references to detect when some object has been specifically identified as no longer in use or usable, and can then take action accordingly", "label": {"api": {"references": [[12, 21]]}}}, {"text": "This tutorial covers references in some depth, in case you're curious how to use them", "label": {"api": {"references": [[21, 30]]}}}, {"text": "Internally, WeakHashMap likely uses these references to automatically detect when a given key cannot be used any more", "label": {"api": {"references": [[42, 51]]}}}, {"text": "No, ConcurrentModificationException \"does not always indicate that an object has been concurrently modified by a different thread.\" The exception is thrown if the \"list has been structurally modified\" outside of the iterator, on a best-effort basis", "label": {"api": {"ConcurrentModificationException": [[4, 34]], "structurally modified": [[178, 198]]}}}, {"text": "You can use getHeaderNames()", "label": {"api": {"getHeaderNames()": [[12, 27]]}}}, {"text": "Then you can access a value using getProperty(String key) like", "label": {"api": {"getProperty(String key)": [[34, 56]]}}}, {"text": "For precision use BigDecimal", "label": {"api": {"BigDecimal": [[18, 27]]}}}, {"text": "I am trying to create an object of Console class, but could not succeed", "label": {"api": {"Console": [[35, 41]]}}}, {"text": "I am getting this error \"The constructor Console() is not visible\"", "label": {"api": {"Console": [[41, 47]]}}}, {"text": "Instead, use the System.console() method", "label": {"api": {"System.console()": [[17, 32]]}}}, {"text": "you should use System.console() to get hold of the one instance of Console", "label": {"api": {"System.console()": [[15, 30]]}}}, {"text": "For convenience, DefaultCellEditor offers a constructor especially for this", "label": {"api": {"DefaultCellEditor": [[17, 33]]}}}, {"text": "Figure using DefaultTableCellRenderer and DefaultCellEditor, Windows (see comments)", "label": {"api": {"DefaultCellEditor": [[42, 58]]}}}, {"text": "You could also borrow a page from the Java DataInputStream.readUnsignedShort() implementation", "label": {"api": {"DataInputStream": [[43, 57]], "readUnsignedShort": [[59, 75]]}}}, {"text": "See XmlAttribute javadoc for instance", "label": {"api": {"XmlAttribute": [[4, 15]]}}}, {"text": "See File.createTempFile() and File.deleteOnExit()", "label": {"api": {"File.createTempFile()": [[4, 24]], "File.deleteOnExit()": [[30, 48]]}}}, {"text": "You could then could make use of executeUpdate(String sql, int autoGeneratedKeys)", "label": {"api": {"executeUpdate(String sql, int autoGeneratedKeys)": [[33, 80]]}}}, {"text": "Short of supplying your own delegate, you can use setPreferredScrollableViewportSize() to make the height of enclosing Container an intergral multiple of the rowHeight, as shown below and in this example", "label": {"api": {"setPreferredScrollableViewportSize()": [[50, 85]]}}}, {"text": "Attribute columnDefinition in Column annotation is there for such a needs", "label": {"api": {"columnDefinition": [[10, 25]]}}}, {"text": "The FORWARD dispatcher is only triggered when RequestDispatcher#forward() is been invoked somewhere in the webapp's code", "label": {"api": {"RequestDispatcher#forward()": [[46, 72]]}}}, {"text": "It just invokes ViewHandler#createView() and sets it as current view by FacesContext#setViewRoot()", "label": {"api": {"ViewHandler#createView()": [[16, 39]], "FacesContext#setViewRoot()": [[72, 97]]}}}, {"text": "If you really insist in invoking the FORWARD dispatcher using JSF, you can always use ExternalContext#dispatch() method, but this is not the recommended way", "label": {"api": {"ExternalContext#dispatch()": [[86, 111]]}}}, {"text": "Doesn't it help you - Collections.synchronizedList class", "label": {"api": {"Collections.synchronizedList": [[22, 49]]}}}, {"text": "In addition to Uluk's solutions (which are great), you could also look at the SequentialTransition class for handling assistance in performing transitions in sequence", "label": {"api": {"SequentialTransition": [[78, 97]]}}}, {"text": "Note that if you want to take an action after the SequentialTransition has completed, you will still want to add an onFinished handler to the SequentialTransition to take action at that time", "label": {"api": {"SequentialTransition": [[50, 69], [142, 161]]}}}, {"text": "According to the javadoc for the remove method the remaining entries will shift back so there are no gaps", "label": {"api": {"javadoc for the remove method": [[17, 45]]}}}, {"text": "You need to set the working directory of the launched process using ProcessBuilder.directory(File)", "label": {"api": {"ProcessBuilder.directory(File)": [[68, 97]]}}}, {"text": "Take a look at Integer.bitCount(int i)", "label": {"api": {"Integer.bitCount(int i)": [[15, 37]]}}}, {"text": "The Java term would be ThreadPoolExecutor, and it can't be that hard to write a simple one yourself", "label": {"api": {"ThreadPoolExecutor": [[23, 40]]}}}, {"text": "The reason you're getting org.sqlite.RS@24c672 when printing your result set is because that class has not overridden the default implementation of toString() in the base object class", "label": {"api": {"toString()": [[148, 157]]}}}, {"text": "You could use the string constructor of BigDecimal (docu)", "label": {"api": {"docu": [[52, 55]]}}}, {"text": "According to the docu that string is interpreted as the URI to your file", "label": {"api": {"docu": [[17, 20]]}}}, {"text": "If you want to parse your String directly, you have to transform it to an InputStream in the first place for usage with the parse(InputSource is, DefaultHandler dh) method (docu)", "label": {"api": {"docu": [[173, 176]]}}}, {"text": "With the Scanner#useDelimiter method you can specify what delimiter to use when reading from a File or InputStream or whatever", "label": {"api": {"Scanner#useDelimiter": [[9, 28]]}}}, {"text": "You always access the same instance of ThreadLocal for a specific problem but this instance returns a different value for each thread calling the get method", "label": {"api": {"get": [[146, 148]]}}}, {"text": "Because the thread-specific values are not stored in the ThreadLocal object, but the current Thread's ThreadLocalMap", "label": {"api": {"current Thread": [[85, 98]]}}}, {"text": "The getResourcePaths method of ServletContext can be used to retrieve all members of a \"directory\", and then getResource or getResourceAsStream to retrieve the contents of a file in the directory", "label": {"api": {"getResourcePaths": [[4, 19]], "getResource": [[4, 14], [109, 119], [124, 134]], "getResourceAsStream": [[124, 142]]}}}, {"text": "Image is an abstract superclass of all classes that represent graphical images", "label": {"api": {"Image": [[0, 4]]}}}, {"text": "ImageIcon is an implementation of Icon interface that uses Image as its source", "label": {"api": {"Image": [[0, 4], [59, 63]], "ImageIcon": [[0, 8]]}}}, {"text": "Think of an Image as something that could be rendered and an ImageIcon as something that will be rendered as an Icon when its paintIcon() method is called", "label": {"api": {"Image": [[12, 16], [61, 65]], "ImageIcon": [[61, 69]]}}}, {"text": "Image and ImageIcon", "label": {"api": {"Image": [[0, 4], [10, 14]], "ImageIcon": [[10, 18]]}}}, {"text": "You can check if an user is logged in by checking if HttpServletRequest#getRemoteUser() (the user name) or #getUserPrincipal() (the associated Princpal object) does not return null", "label": {"api": {"HttpServletRequest#getRemoteUser()": [[53, 86]], "#getUserPrincipal()": [[107, 125]]}}}, {"text": "The #isUserInRole() only checks if the logged-in user has some specific role and this is usually only useful to restrict some pages or page sections for specific roles", "label": {"api": {"#isUserInRole()": [[4, 18]]}}}, {"text": "Use Arrays.toString(array) to obtain something more human-readable", "label": {"api": {"Arrays.toString(array)": [[4, 25]]}}}, {"text": "If you are working on a list you could use ListIterator which provides both add and remove operations", "label": {"api": {"ListIterator": [[43, 54]]}}}, {"text": "If you're generating your WSDL from your web service class, you may add WebParam annotations to the parameters of your methods to enforce naming in the WSDL", "label": {"api": {"WebParam": [[72, 79]]}}}, {"text": "In the Java/Swing API's ButtonModel interface, what's the difference between the Rollover and Armed properties", "label": {"api": {"ButtonModel": [[24, 34]]}}}, {"text": "Is there any situation where a ButtonModel would be armed but not rolled over, or vice-versa", "label": {"api": {"ButtonModel": [[31, 41]]}}}, {"text": "If you want a value that can only be acceded by a single thread, and that exists idependly for each thread, then take a look to ThreadLocal", "label": {"api": {"ThreadLocal": [[128, 138]]}}}, {"text": "You can explicitly tell JAVA that the corresponding table doesn't contain such a field by using the @Transient annotation", "label": {"api": {"@Transient": [[100, 109]]}}}, {"text": "That looks like IllegalStateException to me", "label": {"api": {"IllegalStateException": [[16, 36]]}}}, {"text": "in which case an unchecked exception is appropriate, and IllegalStateException describes the general nature of the problem quite clearly", "label": {"api": {"IllegalStateException": [[57, 77]]}}}, {"text": "Remember that in Java you don't need to implement it, you can use the standard PriorityQueue class or PriorityBlockingQueue if you need that it works in a multithread program", "label": {"api": {"PriorityQueue": [[79, 91]], "PriorityBlockingQueue": [[102, 122]]}}}, {"text": "Yes, you can run a Webservice simply off the JDK using the @WebService annotation", "label": {"api": {"@WebService": [[59, 69]]}}}, {"text": "Put the file in the /assets folder of your project, then you can get an InputStream by opening it throught the AssetManager", "label": {"api": {"InputStream": [[72, 82]]}}}, {"text": "You can then read lines from the file and add them to a StringBuilder by using a Reader", "label": {"api": {"StringBuilder": [[56, 68]], "Reader": [[81, 86]]}}}, {"text": "If you use a bounded-size structure like an ArrayBlockingQueue, and you call the put method on a queue that's full, then the calling thread will block until there is space in the queue", "label": {"api": {"ArrayBlockingQueue": [[44, 61]], "put": [[81, 83]], "Queue": [[57, 61]]}}}, {"text": "If you use any kind of queue and you call take when it's empty, the calling thread will block until there's something in the queue", "label": {"api": {"take": [[42, 45]]}}}, {"text": "To avoid put blocking, you could use an unbounded structure like a LinkedBlockingQueue", "label": {"api": {"put": [[9, 11]], "LinkedBlockingQueue": [[67, 85]], "Queue": [[81, 85]]}}}, {"text": "To avoid blocking on removal, use a non-blocking operation - remove throws an exception if the queue is empty, and poll returns null", "label": {"api": {"remove": [[61, 66]], "poll": [[115, 118]]}}}, {"text": "Having said that, there are implementations of the Queue interface that are not in java.util.concurrent", "label": {"api": {"Queue": [[51, 55]]}}}, {"text": "ArrayDeque would probably be a good choice", "label": {"api": {"ArrayDeque": [[0, 9]]}}}, {"text": "The array argument version of exec is for executing a single command, where you have split the arguments yourself, not for executing multiple commands", "label": {"api": {"array argument version": [[4, 25]]}}}, {"text": "The documentation for SimpleDateFormat doesn't seem to do days of the week as single letters", "label": {"api": {"documentation for SimpleDateFormat": [[4, 37]]}}}, {"text": "The month on the Calendar API starts in 0", "label": {"api": {"month": [[4, 8]]}}}, {"text": "From Calendar's javadoc", "label": {"api": {"Calendar's javadoc": [[5, 22]]}}}, {"text": "Because it's the documented behavior of compareTo() (emphasis added)", "label": {"api": {"documented behavior of compareTo()": [[17, 50]]}}}, {"text": "If you are wondering, Arrays.copyOf calls System.arraycopy", "label": {"api": {"Arrays.copyOf": [[22, 34]], "System.arraycopy": [[42, 57]]}}}, {"text": "If you want to drag'n'drop something in, you'll have to use Robot or any other tool (there might be a library for this)", "label": {"api": {"Robot": [[60, 64]]}}}, {"text": "Single entity can refreshed from database via refresh method", "label": {"api": {"refresh": [[18, 24], [46, 52]]}}}, {"text": "Since IOException is a checked exception, that method needs to be declared as throwing IOException if you want it to propagate", "label": {"api": {"IOException": [[6, 16], [87, 97]]}}}, {"text": "If you need to use it as namespace aware, just implement your own NameSpaceContext, should look like this", "label": {"api": {"NameSpaceContext": [[66, 81]]}}}, {"text": "I also recommend reading the beginnings of java.util.map and java.util.HashMap", "label": {"api": {"java.util.map": [[43, 55]], "java.util.HashMap": [[61, 77]]}}}, {"text": "You should use the two string constructor of InternetAddress to pass in both the e-mail address and the person's name", "label": {"api": {"two string constructor of InternetAddress": [[19, 59]]}}}, {"text": "a) to keep their ordering and store those in a HashSet to ensure uniqueness and constant time performance on contains(Object o) to determine if it's already present", "label": {"api": {"HashSet": [[47, 53]], "contains(Object o)": [[109, 126]]}}}, {"text": "You need to use the VBox.setVgrow(editor, Priority.ALWAYS) method to get the HTMLEditor to take up any extra space in the VBox", "label": {"api": {"VBox.setVgrow(editor, Priority.ALWAYS)": [[20, 57]]}}}, {"text": "You need to do this because the BorderPane documentation states", "label": {"api": {"BorderPane documentation": [[32, 55]]}}}, {"text": "If they're in separate threads, one of the BlockingQueue implementations should do the trick", "label": {"api": {"BlockingQueue": [[43, 55]]}}}, {"text": "The answer is to use a JFormattedTextField and a MaskFormatter", "label": {"api": {"JFormattedTextField": [[23, 41]], "MaskFormatter": [[49, 61]]}}}, {"text": "The Java compiler will require that you catch or throw a ParseException when creating your MaskFormatter, and so be sure to do this", "label": {"api": {"MaskFormatter": [[91, 103]]}}}, {"text": "To force data to be written to disk before the call to a write returns, you must use a FileChannel and call force", "label": {"api": {"force": [[3, 7], [108, 112]]}}}, {"text": "I have some code that makes heavy use of a thread pool, which I use by creating Collection<Callable<T>> tasks, and calling ExecutorService.invokeAll(tasks)", "label": {"api": {"ExecutorService.invokeAll(tasks)": [[123, 154]]}}}, {"text": "The implementation of invokeAll() that I'm using calls ThreadPoolExecutor.execute(), whose implementation appears to always run the task in the thread pool (never in the calling thread)", "label": {"api": {"ThreadPoolExecutor.execute()": [[55, 82]]}}}, {"text": "This will fail, however, because the string representation is longer than 16 bytes", "label": {"api": {"string representation": [[37, 57]]}}}, {"text": "Use FutureTask http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/FutureTask.html#get%28%29", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/FutureTask.html#get%28%29": [[15, 101]]}}}, {"text": "Use String.replaceAll instead", "label": {"api": {"String.replaceAll": [[4, 20]]}}}, {"text": "Normal Java iterators just iterate over every element of the collection", "label": {"api": {"Normal Java iterators": [[0, 20]]}}}, {"text": "One way would be to use a ThreadLocal and put the instance of HttpServletRequest inside it in the beginning of request processing (a servlet Filter perhaps)", "label": {"api": {"ThreadLocal": [[26, 36]], "servlet Filter": [[133, 146]]}}}, {"text": "The alternative is to use the ProcessBuilder class, which has a somewhat cleaner interface, but your main problem is probably related to how the OS processes command lines, and there isn't much Java can do to help you with that", "label": {"api": {"ProcessBuilder": [[30, 43]]}}}, {"text": "Perhaps a preferable solution (however) would be to write your app in Java itself, and you can then make use of the Java compiler API directly within your app", "label": {"api": {"Java compiler API": [[116, 132]]}}}, {"text": "Use the FileUtils#readFileToByteArray(File) from Apache Commons IO, and then create the ByteArrayInputStream using the ByteArrayInputStream(byte[]) constructor", "label": {"api": {"ByteArrayInputStream(byte[])": [[119, 146]]}}}, {"text": "See http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/String.html#replaceAll(java.lang.String, java.lang", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/String.html#replaceAll(java.lang.String": [[4, 97]]}}}, {"text": "java.util.concurrent.CopyOnWriteArrayList will behave like this, except that no Java collection has \"resetting\" of iterators -- but getting a new iterator instead of resetting has the effect you request here", "label": {"api": {"java.util.concurrent.CopyOnWriteArrayList": [[0, 40]]}}}, {"text": "You can use the reluctant qualifiers such as *", "label": {"api": {"reluctant qualifiers": [[16, 35]]}}}, {"text": "Because of typo you do not actually override toString method", "label": {"api": {"toString": [[45, 52]]}}}, {"text": "That's the reason of unexpected output directly from Object.toString", "label": {"api": {"toString": [[60, 67]]}}}, {"text": "If you look here (http://docs.oracle.com/javase/1.5.0/docs/api/java/security/cert/package-tree.html) for the documentation for the java.security.cert.* package, you should find the type of objects you are instantiating", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/security/cert/package-tree.html": [[18, 98]]}}}, {"text": "In case you are dealing with an RSA based public key the PublicKey object you receive is a RSAPublicKey instance", "label": {"api": {"RSAPublicKey": [[91, 102]]}}}, {"text": "Therefore you can cast it to RSAPublicKey and then use it's methods getPublicExponent() and getModulus()", "label": {"api": {"RSAPublicKey": [[29, 40]]}}}, {"text": "For more information, see the Java documentation on String.charAt", "label": {"api": {"Java documentation on String.charAt": [[30, 64]]}}}, {"text": "If you want more information on the Character class and the toString method, I pulled my info from the documentation on Character.toString", "label": {"api": {"the documentation on Character.toString": [[99, 137]]}}}, {"text": "You could use the String.charAt(int index) method result as the parameter for String.valueOf(char c)", "label": {"api": {"String.charAt(int index)": [[18, 41]], "String.valueOf(char c)": [[78, 99]]}}}, {"text": "However, you can set them on a child process from a calling Java program, for example via the ProcessBuilder", "label": {"api": {"ProcessBuilder": [[94, 107]]}}}, {"text": "There's a working example here that uses StyledEditorKit.FontSizeAction and related classes in StyledEditorKit", "label": {"api": {"StyledEditorKit": [[41, 55], [95, 109]]}}}, {"text": "If you can extract an interface from GeneratedObject, then it would be possible to do this using a dynamic proxy", "label": {"api": {"dynamic proxy": [[99, 111]]}}}, {"text": "Since java 8 this has become very easy using CompletableFuture", "label": {"api": {"CompletableFuture": [[45, 61]]}}}, {"text": "A JMSException is the base type (derived from Exception) that the Java Message Service (JMS) Package API throws when it needs to communicate a exception to the consumer of the JMS Package", "label": {"api": {"JMSException": [[2, 13]]}}}, {"text": "There is good sample of how to use the JMS API and how to catch JMSExceptions here - the salient bits are", "label": {"api": {"JMSException": [[64, 75]]}}}, {"text": "You can use ReentrantLock to achieve this", "label": {"api": {"ReentrantLock": [[12, 24]]}}}, {"text": "There is a pattern attribute you need to set on @DataField and specify the Date pattern you use according to DateFormat", "label": {"api": {"DateFormat": [[109, 118]]}}}, {"text": "The entity objects are fetched from DB in one transaction (see TransactionAttributeType.REQUIRED) and stored in the DTO object", "label": {"api": {"TransactionAttributeType.REQUIRED": [[63, 95]]}}}, {"text": "You can use SimpleDateFormatter as this sample", "label": {"api": {"SimpleDateFormatter": [[12, 30]]}}}, {"text": "Also, just a recommendation, when working with consoles and system paths, you should ideally use File.seperator", "label": {"api": {"File.seperator": [[97, 110]]}}}, {"text": "You can either use Arrays.asList()", "label": {"api": {"Arrays.asList()": [[19, 33]]}}}, {"text": "or Collections.singletonList() if you have only one value (faster and more compact)", "label": {"api": {"Collections.singletonList()": [[3, 29]]}}}, {"text": "First take a look at all the date formats provided by java Date Formats", "label": {"api": {"Date Formats": [[59, 70]]}}}, {"text": "For all the keywords, use Pattern.quote() to make sure they are recognized as literal string", "label": {"api": {"Pattern.quote()": [[26, 40]]}}}, {"text": "You can also just ignore the Pattern.quote() step, if you are sure that the keywords do not contain regex", "label": {"api": {"Pattern.quote()": [[29, 43]]}}}, {"text": "Additionally if your custom types don't have a hashCode() implementation, then that value is entirely useless for comparing the content of the object, because it will be the identityHashCode()", "label": {"api": {"identityHashCode()": [[174, 191]]}}}, {"text": "See the documentation of Pattern", "label": {"api": {"Pattern": [[25, 31]]}}}, {"text": "See the reference (section \"Classes for Unicode scripts, blocks, categories and binary properties\")", "label": {"api": {"the reference": [[4, 16]]}}}, {"text": "After you create the Process object, you can call getOutputStream() in order to get hold of a stream that sends its contents to the process' standard input", "label": {"api": {"getOutputStream()": [[50, 66]]}}}, {"text": "in particular, its handling of NaNs", "label": {"api": {"its handling of NaNs": [[15, 34]]}}}, {"text": "In all probability SwingWorker is the right tool for your task", "label": {"api": {"SwingWorker": [[19, 29]]}}}, {"text": "How to convert a policy configuration text file in to a Policy object, to be used in the method call Policy.setPolicy() (API)", "label": {"api": {"API": [[121, 123]]}}}, {"text": "Get the output stream and the error stream from the process to see what happens", "label": {"api": {"process": [[52, 58]]}}}, {"text": "Use Process.getOutputStream() to access that stream or, with Java 1.7, employ a ProcessBuilder where you can use redirectOutput like this", "label": {"api": {"Process.getOutputStream()": [[4, 28]], "redirectOutput": [[113, 126]]}}}, {"text": "You should be using OutputStreamWriter to write characters in a specified character encoding to the file", "label": {"api": {"OutputStreamWriter": [[20, 37]]}}}, {"text": "Simply use an EmptyBorder.Have a look at this example, as to what you can do as an alternative", "label": {"api": {"EmptyBorder": [[14, 24]]}}}, {"text": "You could use java.util.Scanner (introduced in Java 5)", "label": {"api": {"java.util.Scanner": [[14, 30]]}}}, {"text": "If your inverted index is of type NavigableMap, with the value type being a collection of integers, then you can use the NavigableMap#lastEntry() method to find the pairing of the greatest integral key and its corresponding value", "label": {"api": {"NavigableMap#lastEntry()": [[121, 144]]}}}, {"text": "Alternately, if you merely had a SortedMap in hand, you could still use its SortedMap#lastKey() method to find the key in question", "label": {"api": {"SortedMap#lastKey()": [[76, 94]]}}}, {"text": "This means that Enum is an object (you can verify this by looking at the JavaDocs for Enum aswell)", "label": {"api": {"Enum": [[16, 19], [86, 89]]}}}, {"text": "Hence, if you simply tell MyType to contain Object(MyType<Object>), it will accept Object and Enum as you originally posted", "label": {"api": {"Enum": [[94, 97]]}}}, {"text": "If you map an ENUM column to a Java Enumeration, you should probably map a SET column to a Java EnumSet", "label": {"api": {"EnumSet": [[96, 102]]}}}, {"text": "There is at least one question on SF about mapping EnumSet, but the solution there appears to be a separate table, not the mysql SET type", "label": {"api": {"EnumSet": [[51, 57]]}}}, {"text": "If your project allows using LGPL-licensed source code, you might use the implementation of EnumType as a template for your own EnumSetType", "label": {"api": {"EnumSet": [[128, 134]]}}}, {"text": "Once you have your own UserType for EnumSet, you could annotate the corresponding fields with that @Type", "label": {"api": {"EnumSet": [[36, 42]]}}}, {"text": "There might be even ways to register the type somewhere, to automatically map all EnumSet instances using that type, but I know too little about this whole hibernation stuff to decide whether this is desirable or even possible", "label": {"api": {"EnumSet": [[82, 88]]}}}, {"text": "I haven't even figured out yet how the @Enumerated annotation maps to the EnumType implementation", "label": {"api": {"@Enumerated": [[39, 49]]}}}, {"text": "With the right keywords (UserType EnumSet split), one can find some implementations on the web", "label": {"api": {"EnumSet": [[34, 40]]}}}, {"text": "You could add your Runnables to an ExecutorService and call shutdown / awaitTermination which will return once all tasks have completed", "label": {"api": {"ExecutorService": [[35, 49]], "shutdown": [[60, 67]], "awaitTermination": [[71, 86]]}}}, {"text": "setIconImage does not set the jar icon", "label": {"api": {"setIconImage": [[0, 11]]}}}, {"text": "This will treat the pattern1 and pattern2 as literal text, and the text in between the patterns is captured in the first capturing group", "label": {"api": {"capturing group": [[121, 135]]}}}, {"text": "You can remove Pattern.quote() if you want to use regex, but I don't guarantee anything if you do that", "label": {"api": {"Pattern.quote()": [[15, 29]]}}}, {"text": "If you want Unicode-aware case-insensitive matching, then add (?iu) at the beginning of regexString, or supply Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE flag to Pattern.compile method", "label": {"api": {"Pattern.compile": [[167, 181]]}}}, {"text": "\"(?s)(.*?)\", or supply Pattern.DOTALL flag to Pattern.compile method", "label": {"api": {"Pattern.compile": [[46, 60]], "Pattern.DOTALL": [[23, 36]]}}}, {"text": "Then compile the regex, obtain a Matcher object, iterate through the matches and save them into a List (or any Collection, it's up to you)", "label": {"api": {"Matcher": [[33, 39]]}}}, {"text": "Similarly, yours might extend SwingWorker<DataSource, Void> to fetch a DataSource", "label": {"api": {"DataSource": [[42, 51], [71, 80]]}}}, {"text": "Instead of robot.keyPress and robot.keyRelease every single key you can use Toolkit to copy the String to the clipboard and then paste it", "label": {"api": {"Toolkit": [[76, 82]]}}}, {"text": "You never used the setOpaque(), method to set it's value as being OPAQUE", "label": {"api": {"setOpaque()": [[19, 29]]}}}, {"text": "In any way, you can create <f:param> programmatically by just creating an instance of UIParameter and adding it as a child of the link component", "label": {"api": {"UIParameter": [[86, 96]]}}}, {"text": "Use LineBorder with rounded corners or a variant of the TextBubbleBorder", "label": {"api": {"LineBorder": [[4, 13]]}}}, {"text": "Repeated use of the String.replaceFirst() method would help you here", "label": {"api": {"String.replaceFirst()": [[20, 40]]}}}, {"text": "Or given that you're parsing/outputting times, it may also be worth looking at SimpleDateFormat and its ability to parse/output date/time combinations", "label": {"api": {"SimpleDateFormat": [[79, 94]]}}}, {"text": "According to http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ClassFormatError.html \"Thrown when the Java Virtual Machine attempts to read a class file and determines that the file is malformed or otherwise cannot be interpreted as a class file\"", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ClassFormatError.html": [[13, 88]]}}}, {"text": "You will see this in a debugger, but getCause takes care of not returning the recursive reference", "label": {"api": {"getCause": [[37, 44]]}}}, {"text": "In the ActionListener of the JMenuItem, you can call JTabbedPane#setSelectedIndex", "label": {"api": {"JTabbedPane#setSelectedIndex": [[53, 80]]}}}, {"text": "File.isFile won't work when loading resource from JAR)", "label": {"api": {"File.isFile": [[0, 10]]}}}, {"text": "You can obtain the other servlet context by ServletContext#getContext() and then use its request dispatcher as available by ServletContext#getRequestDispatcher()", "label": {"api": {"ServletContext#getContext()": [[44, 70]], "ServletContext#getRequestDispatcher()": [[124, 160]]}}}, {"text": "Then, you need to obtain a RequestDispatcher from it on the path of the desired resource and invoke the forward() on it hereby passing the current HTTP servlet request and response", "label": {"api": {"forward()": [[104, 112]]}}}, {"text": "RowFilter has a static method called notFilter(), which takes a RowFilter as an argument and returns a new RowFilter that has the opposite effect", "label": {"api": {"RowFilter": [[0, 8], [64, 72], [107, 115]], "notFilter()": [[37, 47]]}}}, {"text": "You could take your regexFilter and pass it to RowFilter.notFilter()", "label": {"api": {"RowFilter": [[47, 55]], "notFilter()": [[57, 67]]}}}, {"text": "There's a working example here that sets color using StyledEditorKit.ForegroundAction", "label": {"api": {"StyledEditorKit": [[53, 67]]}}}, {"text": "It also illustrates related classes in StyledEditorKit", "label": {"api": {"StyledEditorKit": [[39, 53]]}}}, {"text": "Since Java 7 you can use the static method java.util.Objects.equals(Object, Object) to perform equals checks on two objects without caring about them being null", "label": {"api": {"java.util.Objects.equals(Object, Object)": [[43, 82]], "equals": [[61, 66], [95, 100]]}}}, {"text": "Otherwise it will return the result of calling equals on the first object with the second as argument", "label": {"api": {"equals": [[47, 52]]}}}, {"text": "Use Java's File.separator to help you", "label": {"api": {"File.separator": [[11, 24]]}}}, {"text": "In Java 7 URLClassLoader has a #close() method that fixes this", "label": {"api": {"URLClassLoader": [[10, 23]]}}}, {"text": "The result of hitting enter will be a line separator, whose characters are treated as delimiters (by default, see Character.isWhitespace()) and are skipped", "label": {"api": {"Character.isWhitespace()": [[114, 137]]}}}, {"text": "Yes, you can use the Short.parseShort(String) and Byte.parseByte(String) wrapper methods to parse smaller integer values", "label": {"api": {"Short.parseShort(String)": [[21, 44]], "Byte.parseByte(String)": [[50, 71]]}}}, {"text": "Take a loop at the Collections.sort method for more information", "label": {"api": {"Collections.sort": [[19, 34]]}}}, {"text": "Take a look into the SortedSet hierarchy of the Java library", "label": {"api": {"SortedSet": [[21, 29]]}}}, {"text": "Each sortable collection can be parameterized with the logic used to compare items (Comparator)", "label": {"api": {"Comparator": [[84, 93]]}}}, {"text": "See the difference between ArrayList.remove(int index) and ArrayList.remove(Object o)", "label": {"api": {"ArrayList.remove(int index)": [[27, 53]], "ArrayList.remove(Object o)": [[59, 84]]}}}, {"text": "You might want to take a look at BigInteger", "label": {"api": {"BigInteger": [[33, 42]]}}}, {"text": "I've had success building games that update the graphics using a Timer", "label": {"api": {"Timer": [[65, 69]]}}}, {"text": "JavaDoc of File", "label": {"api": {"JavaDoc of File": [[0, 14]]}}}, {"text": "If not, read the java reference on String.format format strings", "label": {"api": {"String.format format strings": [[35, 62]]}}}, {"text": "In my code, I am using several file reading using RandomAccessFile", "label": {"api": {"RandomAccessFile": [[50, 65]]}}}, {"text": "I am also using JAVA's in built HashMap", "label": {"api": {"HashMap": [[32, 38]]}}}, {"text": "Have look at Java Timer", "label": {"api": {"Java Timer": [[13, 22]]}}}, {"text": "Annotations certainly support this requirement in form of @MappedSuperclass annotation", "label": {"api": {"@MappedSuperclass annotation": [[58, 85]]}}}, {"text": "Try using Thread.sleep()", "label": {"api": {"Thread.sleep()": [[10, 23]]}}}, {"text": "Thread.sleep(1000) is what you need", "label": {"api": {"Thread.sleep(1000)": [[0, 17]]}}}, {"text": "Use a single shot Swing based Timer to flip the color and call repaint()", "label": {"api": {"Timer": [[30, 34]]}}}, {"text": "See Using Timers in Swing Applications for details", "label": {"api": {"Timer": [[10, 14]]}}}, {"text": "Notice that a Date object will always contain year, month, day, hours, minutes, seconds, milliseconds, etc., and by calling new Date() you obtain a date object with the current time", "label": {"api": {"Date": [[14, 17], [128, 131]]}}}, {"text": "If you only need some fields of a date (say, year, month and day) you need to format the date using a formatter, for instance SimpleDateFormat", "label": {"api": {"Date": [[132, 135]], "SimpleDateFormat": [[126, 141]]}}}, {"text": "The Java standard class MessageFormat is relatively close to what you want, but it doesn't handle arbitrary placeholder names", "label": {"api": {"MessageFormat": [[24, 36]]}}}, {"text": "Assuming you're talking about java.io.OutputStreamWriter, yes, you should close it, in a finally block, when you don't want to write anything more", "label": {"api": {"java.io.OutputStreamWriter": [[30, 55]]}}}, {"text": "If you are willing to switch to BigDecimal, there is a #stripTrailingZeroes() method that accomplishes this", "label": {"api": {"#stripTrailingZeroes()": [[55, 76]]}}}, {"text": "Create another class which holds those 4 fields as properties and implement/autogenerate equals() and hashCode() according the contract (important", "label": {"api": {"according the contract": [[113, 134]]}}}, {"text": "Try String format function, format arguments provide many options to customize the printing", "label": {"api": {"format arguments": [[28, 43]]}}}, {"text": "A BoxLayout might be what you are after for this use-case", "label": {"api": {"BoxLayout": [[2, 10]]}}}, {"text": "I am extremely confused as to how a JButton works", "label": {"api": {"JButton": [[36, 42]]}}}, {"text": "I have read over the oracle documents of the JButton, but I have failed to see how a JButton can have an actionlistener added to it", "label": {"api": {"JButton": [[45, 51], [85, 91]]}}}, {"text": "Can anyone explain how a JButton can have an actionListener added to it like the .addActionListener(...) syntax", "label": {"api": {"JButton": [[25, 31]]}}}, {"text": "My reason for wanting to know how to do this is to create my own \"JButton\" per say which can have an actionListener added to it and it will fire events when needed", "label": {"api": {"JButton": [[66, 72]]}}}, {"text": "ZipFile uses ZipInputStreams underneath the hood", "label": {"api": {"ZipFile": [[0, 6]], "ZipInputStreams": [[13, 27]]}}}, {"text": "Use the loadClass()method of java.net.URLClassLoader", "label": {"api": {"java.net.URLClassLoader": [[29, 51]]}}}, {"text": "i like to use CountDownLatch where you can initialize your latch in one thread and count down it in once it is about to complete the task ., On other thread call await() which will be blocked until previous thread doesn't call countDown()", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "The Area class supports addition of closed polygons", "label": {"api": {"Area": [[4, 7]]}}}, {"text": "Starting from Java 7 you can use java.nio.file.Files.exists", "label": {"api": {"java.nio.file.Files.exists": [[33, 58]]}}}, {"text": "Check the javadocs of the methods you're using - the Scanner(File) constructor lets you know that", "label": {"api": {"Scanner(File)": [[53, 65]]}}}, {"text": "Instead, you can call the Scanner(File, String) constructor to explicitly specify the file encoding", "label": {"api": {"Scanner(File, String)": [[26, 46]]}}}, {"text": "Every exception from Throwable upwards has a getCause() method", "label": {"api": {"getCause()": [[45, 54]]}}}, {"text": "The documentation for ArrayList has a discussion of the performance of the performance of these operations", "label": {"api": {"ArrayList": [[22, 30]]}}}, {"text": "What you could do, additionally, in order to ensure that will be handled just for reading operations is to give back an Collections.unmodifiableMap(Map)", "label": {"api": {"Collections.unmodifiableMap(Map)": [[120, 151]]}}}, {"text": "Better copy the original map using the constructor that receives another map as a parameter", "label": {"api": {"constructor": [[39, 49]]}}}, {"text": "Use something like this, which would return a Point object", "label": {"api": {"Point": [[46, 50]]}}}, {"text": "You may want to consider CountdownLatch in the main thread that starts all other threads", "label": {"api": {"CountdownLatch": [[25, 38]]}}}, {"text": "I saw that there is an Keystore API in Java", "label": {"api": {"Keystore API": [[23, 34]]}}}, {"text": "Any implementer of the List<E> interface would be more appropriate than an array; you can then add elements on the fly", "label": {"api": {"List<E>": [[23, 29]]}}}, {"text": "Absent more details, you can try setting the default caret to NEVER_UPDATE, available since Java 5", "label": {"api": {"NEVER_UPDATE": [[62, 73]]}}}, {"text": "This is done through Stage.requestFocus()", "label": {"api": {"Stage.requestFocus()": [[21, 40]]}}}, {"text": "The format code Z is for timezone offset, like -0800, while the format code z is for the written format, such as PST or CST, according to what's described at SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[158, 173]]}}}, {"text": "I've extended JToolTip and overrided the paint() method to draw my own tooltip, but i can't manage to remove the background around the tooltip", "label": {"api": {"JToolTip": [[14, 21]]}}}, {"text": "Then submit them to an ExecutorService, which provides all sorts of cool options for how many threads it is running (and an nice central location to change this in the future should your needs change), tie-ins to a CompletionService, etc..", "label": {"api": {"ExecutorService": [[23, 37]]}}}, {"text": "If you want to create a transparent button you need only to setContentAreaFilled(false), do not call setOpaque, see the javadoc (Just note that the last line in the javadoc suggests that varies by Look and Feel,.)", "label": {"api": {"setContentAreaFilled(false)": [[60, 86]]}}}, {"text": "The Correct Way is to use a Map from characters to counts", "label": {"api": {"Map": [[28, 30]]}}}, {"text": "You could use Instrumentation to do this", "label": {"api": {"Instrumentation": [[14, 28]]}}}, {"text": "You're calling getNodeValue on your result, and as this docs show (see the table) it is null for a node of type Element", "label": {"api": {"this docs": [[51, 59]]}}}, {"text": "And if you want to extract the text from your element, directly, you could use getTextContent instead of getNodeValue", "label": {"api": {"getTextContent": [[79, 92]]}}}, {"text": "Also note that according to its documentation, preparedStatement can't ever return null", "label": {"api": {"its documentation": [[28, 44]]}}}, {"text": "Map it using an Integer or Long, the usual @Column annotation, and a @GeneratedValue annotation with a @SequenceGenerator", "label": {"api": {"@GeneratedValue": [[69, 83]], "@SequenceGenerator": [[103, 120]]}}}, {"text": "Access to entities is via the EntityManager which you obtain from an EntityMangerFactory or, more commonly, by injecting it using @PersistenceContext", "label": {"api": {"EntityManager": [[30, 42]], "EntityMangerFactory": [[69, 87]], "@PersistenceContext": [[130, 148]]}}}, {"text": "An atomic reference is used to keep track of the latest event", "label": {"api": {"atomic reference": [[3, 18]]}}}, {"text": "A custom task is submitted to the queue for potentially processing an event, only the task that gets to read the latest event actually goes ahead and does useful work before clearing out the atomic reference to null", "label": {"api": {"atomic reference": [[191, 206]]}}}, {"text": "You can simply use the equals() implementation of ArrayList super class", "label": {"api": {"equals() implementation": [[23, 45]]}}}, {"text": "You can generate a stack trace and use the informations in the StackTraceElements", "label": {"api": {"StackTraceElements": [[63, 80]]}}}, {"text": "You can use for it contains() method of String or you can use Regex", "label": {"api": {"String": [[40, 45]]}}}, {"text": "Then look for a function that does the trick, such as, in this case, indexOf", "label": {"api": {"indexOf": [[69, 75]]}}}, {"text": "I followed the guidelines of Andrew Thomson and I created a custom SecurityManager", "label": {"api": {"SecurityManager": [[67, 81]]}}}, {"text": "To use my ugly SecurityManager I added these lines at the beginning of Java Applet start() method", "label": {"api": {"SecurityManager": [[15, 29]]}}}, {"text": "Check out the Executor frameworks for more info", "label": {"api": {"Executor": [[14, 21]]}}}, {"text": "Use JTextArea instead", "label": {"api": {"JTextArea": [[4, 12]]}}}, {"text": "You can use java.text.Normalizer, as follows", "label": {"api": {"java.text.Normalizer": [[12, 31]]}}}, {"text": "Use the setTime method to set the date of your calendar", "label": {"api": {"setTime": [[8, 14]]}}}, {"text": "Assuming that the timetable is a boolean[][], then you can use LoopTagStatus#getIndex() from varStatus to get the iteration index which you can use as the index of the 2D array", "label": {"api": {"LoopTagStatus#getIndex()": [[63, 86]]}}}, {"text": "characters() is allowed to be called multiple time for the same element (see documentation)", "label": {"api": {"see documentation": [[73, 89]]}}}, {"text": "If you need even larger values, java.math.BigInteger can store arbitrary-precision integers; the only limit is your computer's memory", "label": {"api": {"java.math.BigInteger": [[32, 51]]}}}, {"text": "It might be best to access the table as a memory-mapped buffer", "label": {"api": {"memory-mapped": [[42, 54]]}}}, {"text": "I see that your current implementation already does use memory-mapped access for reading and writing, but it still loads things into the java heap in between", "label": {"api": {"memory-mapped": [[56, 68]]}}}, {"text": "I guess others will have implemented stuff like this, but if you prefer your own hash map implementation, you might prefer to write your own memory-mapped B+ trees as well", "label": {"api": {"memory-mapped": [[141, 153]]}}}, {"text": "The getDateTimeInstance method is overloaded to offer an alternative method that receives the locale that you want to use as parameter", "label": {"api": {"alternative method": [[57, 74]]}}}, {"text": "System.getenv lets you get an environmental variable", "label": {"api": {"System.getenv": [[0, 12]]}}}, {"text": "There is another version which returns a Map of environmental variables", "label": {"api": {"another version": [[9, 23]]}}}, {"text": "Check out CompletionService, especially ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[40, 64]]}}}, {"text": "In this case I would prefer to use CountDownLatch, where i'll initialize my lathch with count 1 as soon i subscribe for publisher i will call await() on latch and when i get the callback i'll countdown the latch", "label": {"api": {"CountDownLatch": [[35, 48]]}}}, {"text": "You might want to take a look at java.sql.DatabaseMetaData.getTables", "label": {"api": {"java.sql.DatabaseMetaData.getTables": [[33, 67]]}}}, {"text": "You didn't call useDelimiter so the next() methods must load the whole file into a string if it hasn't a white space (the default delimiter)", "label": {"api": {"useDelimiter": [[16, 27]]}}}, {"text": "If you really want to avoid ThreadLocal, you could inverse the pattern and store a weak reference of the owner thread with every event in your (unique) queue", "label": {"api": {"weak reference": [[83, 96]], "queue": [[152, 156]]}}}, {"text": "But I'm a little unsure as I never saw the need for such a queue of events executed at \"end of thread execution\"", "label": {"api": {"queue": [[59, 63]]}}}, {"text": "If that is an issue, use BigDecimal", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "See DecimalFormat class", "label": {"api": {"DecimalFormat": [[4, 16]]}}}, {"text": "ByteBuffers have a capacity, position and a limit", "label": {"api": {"capacity, position and a limit": [[19, 48]]}}}, {"text": "Can you just feed IP to InetAddress and call getCanonnicalHostName()", "label": {"api": {"InetAddress": [[24, 34]], "getCanonnicalHostName()": [[45, 67]]}}}, {"text": "Examples maybe found in the API and here", "label": {"api": {"API": [[28, 30]]}}}, {"text": "As per javax.sql.Statement.close() method's JavaDoc", "label": {"api": {"javax.sql.Statement.close()": [[7, 33]]}}}, {"text": "Use SwingUtilities.invokeLater instead", "label": {"api": {"SwingUtilities.invokeLater": [[4, 29]]}}}, {"text": "Furthermore invoke static methods like Thread#sleep on classes e.g", "label": {"api": {"Thread#sleep": [[39, 50]]}}}, {"text": "I've built a custom TreeModel for my Java application and, as part of that, have set up my model to fire TreeModelListener events", "label": {"api": {"TreeModelListener": [[105, 121]]}}}, {"text": "In order to get the correct border shape you need to override the AbstractBorder.paintBorder(...) method", "label": {"api": {"AbstractBorder.paintBorder(...)": [[66, 96]]}}}, {"text": "However, if you want to use a more complex bevel border that uses 4 different colours, you will need to look at the source code of javax.swing.border.BevelBorder", "label": {"api": {"javax.swing.border.BevelBorder": [[131, 160]]}}}, {"text": "use The Scanner class for reading the input from file", "label": {"api": {"Scanner": [[8, 14]]}}}, {"text": "You should use PreparedStatement in fill the query parameters", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "Taken from The Java 5.0 Charset documentation", "label": {"api": {"The Java 5.0 Charset documentation": [[11, 44]]}}}, {"text": "with higher permission levels, so it would make more sense to install/remove the shortcuts and menu items using the IntegrationService - which allows an app", "label": {"api": {"IntegrationService": [[116, 133]]}}}, {"text": "All streams (InputStream, OutputStream) should be closed with their close() method to make sure that the data has been written out and no open handlers has left over", "label": {"api": {"InputStream": [[13, 23]], "OutputStream": [[26, 37]], "close()": [[68, 74]]}}}, {"text": "and the compiler tells me that r.read() might throw an IOException", "label": {"api": {"r.read()": [[31, 38]]}}}, {"text": "A FileNotFoundException is a subclass of IOException, you can check the \"known subclasses\" list for others", "label": {"api": {"\"known subclasses\" list": [[72, 94]]}}}, {"text": "Can any one say what the exact difference between CharSequence and String is, other than the fact that String implements CharSequence and that String is a sequence of character", "label": {"api": {"String": [[67, 72], [103, 108], [143, 148]], "CharSequence": [[50, 61], [121, 132]]}}}, {"text": "From the Java API of CharSequence", "label": {"api": {"CharSequence": [[21, 32]]}}}, {"text": "A CharSequence is a readable sequence of characters", "label": {"api": {"CharSequence": [[2, 13]]}}}, {"text": "This interface is then used by String, CharBuffer and StringBuffer to keep consistency for all method names", "label": {"api": {"String": [[31, 36], [54, 59]], "CharBuffer": [[39, 48]], "StringBuffer": [[54, 65]]}}}, {"text": "See the API documentation of SimpleDateFormat to understand the exact syntax of the format string", "label": {"api": {"API documentation of SimpleDateFormat": [[8, 44]]}}}, {"text": "According to the javadoc of the close method", "label": {"api": {"javadoc of the close method": [[17, 43]]}}}, {"text": "If you just need to run 3 tasks in parallel and wait for them to complete, ExecutorService.invokeAll seems like the simplest solution", "label": {"api": {"ExecutorService.invokeAll": [[75, 99]]}}}, {"text": "use a java.util.Map implementation (HashMap)", "label": {"api": {"java.util.Map": [[6, 18]]}}}, {"text": "Regarding caching, the javadoc of InetAddress says that", "label": {"api": {"InetAddress": [[34, 44]]}}}, {"text": "You can call System.gc(); which might lead the garbage collector to cleanup", "label": {"api": {"System.gc();": [[13, 24]]}}}, {"text": "You could use Array.newInstance, but", "label": {"api": {"Array.newInstance": [[14, 30]]}}}, {"text": "The current implementation uses DataInputStream, but as you can see in the documentation the readLine() method is deprecated because of an issue related to converting bytes to characters", "label": {"api": {"DataInputStream": [[32, 46]]}}}, {"text": "The \"official\" alternative is to use readLine from  BufferedReader, but we can't do a complete swap-out with DataInputStream since BufferedReader can't really handle the binary encoded primitives", "label": {"api": {"DataInputStream": [[109, 123]], "BufferedReader": [[52, 65], [131, 144]]}}}, {"text": "The problem with \"mixing\" these two classes is that when the BufferedReader buffers off the stream, it advances the stream marker", "label": {"api": {"BufferedReader": [[61, 74]]}}}, {"text": "This means that subsequent calls to methods like readDouble() from DataInputStream will fail with IOExceptions or EOFExceptions since the real location of the stream marker isn't where it \"should\" be in the context of the application logic", "label": {"api": {"DataInputStream": [[67, 81]]}}}, {"text": "I have a strange problem using an UUID field in a class", "label": {"api": {"UUID": [[34, 37]]}}}, {"text": "I'm supposing Neodatis does not store variant field, since it is marked as transient, but the strange thing is that the field is only setted by variant() function, which lazily calculate it based only on values from leastSigBits and mostSigBits fields", "label": {"api": {"variant()": [[144, 152]]}}}, {"text": "Both instance resolve to the same String value, so I could skip the problem by storing a string representation of the UUID, but I would prefer to understand what's going wrong", "label": {"api": {"UUID": [[118, 121]]}}}, {"text": "Your producer can have a one or more PipedOuputStream in which it throws whatever it reads from the file", "label": {"api": {"PipedOuputStream": [[37, 52]]}}}, {"text": "At the other side of the pipes, you have different consumer threads reading on a corresponding PipedInputstream (which is an InputStream that you can share with your libraries)", "label": {"api": {"PipedInputstream": [[95, 110]]}}}, {"text": "If your Java program is a desktop application, the browse() method of java.awt.Desktop accepts a URI that may be obtained form a URL", "label": {"api": {"browse()": [[51, 58]], "java.awt.Desktop": [[70, 85]]}}}, {"text": "One approach is to leverage the value property in JFormattedTextField, as shown  in this example and outlined here", "label": {"api": {"JFormattedTextField": [[50, 68]]}}}, {"text": "You require to depend on both PreparedStatement and any of String methods replace(...) and replaceFirst(...) to achieve your requirement", "label": {"api": {"PreparedStatement": [[30, 46]], "replace(...)": [[74, 85]], "replaceFirst(...)": [[91, 107]]}}}, {"text": "See the SimpleDateFormat documentation for more information", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "you could use java ProcessBuilder the get the input and output stream of the ssh process, detect that the remote host is asking for credentials and let your application ask the user for them", "label": {"api": {"java ProcessBuilder": [[14, 32]]}}}, {"text": "See more information on Thread interruption here", "label": {"api": {"Thread interruption here": [[24, 47]]}}}, {"text": "You need to parse it to a Date using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[37, 52]]}}}, {"text": "I don't see it mentioned with the other standard properties as documented with System.getProperties", "label": {"api": {"standard properties as documented with System.getProperties": [[40, 98]]}}}, {"text": "When i try to clone a generic Object i get compile time error", "label": {"api": {"Object": [[30, 35]]}}}, {"text": "Every class extends Object class and clone method is protected in Object class", "label": {"api": {"Object": [[20, 25], [66, 71]]}}}, {"text": "protected methods can be accessed in same package as well as by subclasses and all classes are child of java.lang.Object", "label": {"api": {"Object": [[114, 119]]}}}, {"text": "If you have your private key as an RSAPrivateCrtKey object, you can get the public exponent as well as modulous", "label": {"api": {"RSAPrivateCrtKey": [[35, 50]]}}}, {"text": "The JOptionPane.showConfirmDialog is blocking", "label": {"api": {"JOptionPane.showConfirmDialog": [[4, 32]]}}}, {"text": "Per the java.util.Map javadoc", "label": {"api": {"java.util.Map javadoc": [[8, 28]]}}}, {"text": "The SimpleDateFormat API should help out a lot here", "label": {"api": {"SimpleDateFormat API": [[4, 23]]}}}, {"text": "According to the JDBC Specification and the Statement.close() API doc it should be sufficient", "label": {"api": {"Statement.close() API doc": [[44, 68]]}}}, {"text": "Collections.synchronizedMap and ConcurrentHashMap", "label": {"api": {"Collections.synchronizedMap": [[0, 26]], "ConcurrentHashMap": [[32, 48]]}}}, {"text": "The RandomAccess interface is used for this purpose", "label": {"api": {"RandomAccess": [[4, 15]]}}}, {"text": "Check out the available() - but please do not call it in a loop exhausting CPU", "label": {"api": {"available()": [[14, 24]]}}}, {"text": "You can bridge from Streams to Readers using an InputStreamReader", "label": {"api": {"InputStreamReader": [[48, 64]]}}}, {"text": "setRolloverIcon() and setPressedIcon() will do the magic", "label": {"api": {"setRolloverIcon()": [[0, 16]], "setPressedIcon()": [[22, 37]]}}}, {"text": "You can use ByteBuffer to do what you want", "label": {"api": {"ByteBuffer": [[12, 21]]}}}, {"text": "Have a look at java.util.Calendar", "label": {"api": {"java.util.Calendar": [[15, 32]]}}}, {"text": "This is by default inner join, as told also in API", "label": {"api": {"API": [[47, 49]], "join": [[25, 28]]}}}, {"text": "If you need something similar to original JPQL query, that can be done with fetch", "label": {"api": {"fetch": [[76, 80]]}}}, {"text": "If you want to use left (outer) join instead, that can be done with join method that takes JoinType as argument", "label": {"api": {"join": [[32, 35], [68, 71]], "JoinType": [[91, 98]]}}}, {"text": "When distinct results are needed, then CriteriaQuery.distinct is useful", "label": {"api": {"CriteriaQuery.distinct": [[39, 60]]}}}, {"text": "As found in the docs", "label": {"api": {"in the docs": [[9, 19]]}}}, {"text": "Use System.exec() to fork a javac process to compile the downloaded Java file for you (or use a JavaCompiler implementation to do the same)", "label": {"api": {"JavaCompiler": [[96, 107]]}}}, {"text": "This will implicitly extend the special Enum class, as well as allow enum-specific syntax within the class body", "label": {"api": {"Enum": [[40, 43]]}}}, {"text": "Use a GridBagLayout with the default constraints", "label": {"api": {"GridBagLayout": [[6, 18]]}}}, {"text": "What I would like to do is run a TimerTask at set intervals, let's say two days and 23 hours, which would force a DAO method to draw all the product data from the web services", "label": {"api": {"TimerTask": [[33, 41]]}}}, {"text": "This dependency is for JPA 1", "label": {"api": {"JPA 1": [[23, 27]]}}}, {"text": "As you see UniqueConstraint in JPA 1 does not have name attribute, but in JPA 2 it is there", "label": {"api": {"JPA 1": [[31, 35]], "JPA 2": [[74, 78]]}}}, {"text": "You do refer to \"hibernate-jpa-2.0-api-1.0.0.jar\", which is  JPA 2.0 API provided by Hibernate", "label": {"api": {"JPA 2": [[61, 65]]}}}, {"text": "Additionally you should remove dependency to JPA 1 API", "label": {"api": {"JPA 1": [[45, 49]]}}}, {"text": "As mentioned by Peter Lawrey, CopyOnWriteArrayList can make your life easier and can provide better performance in a highly concurrent environment", "label": {"api": {"CopyOnWriteArrayList": [[30, 49]]}}}, {"text": "You may also be interested in the doFinal method which works on byteBuffers", "label": {"api": {"doFinal": [[34, 40]]}}}, {"text": "Using a java.util.Timer class you can create a timer and schedule it to run at specific time", "label": {"api": {"java.util.Timer": [[8, 22]]}}}, {"text": "You can use a ScheduledExecutorService, which is \"a more versatile replacement for the Timer/TimerTask combination\" (according to Timer's javadoc)", "label": {"api": {"ScheduledExecutorService": [[14, 37]], "Timer's javadoc": [[130, 144]]}}}, {"text": "If you are talking about SE then the Timer class might be what you are looking for http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Timer.html, available since Java 5", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Timer.html": [[83, 147]]}}}, {"text": "IT will also help to look at a executor service", "label": {"api": {"executor service": [[31, 46]]}}}, {"text": "You might also want to take a look at some of the concurrent collections", "label": {"api": {"some of the concurrent collections": [[38, 71]]}}}, {"text": "Have a look at the  JavaDoc API..", "label": {"api": {" JavaDoc API": [[19, 30]]}}}, {"text": "In cause of ExecutionException instance, I suppose", "label": {"api": {"ExecutionException": [[12, 29]]}}}, {"text": "Try setting the nowrap parameter in the Inflater class", "label": {"api": {"nowrap parameter": [[16, 31]]}}}, {"text": "Fortunately however the Inflater class provides the nowrap parameter to the constructor (would be set to true), which allows Inflater to decode raw deflate data without the zlib wrapper", "label": {"api": {"nowrap parameter": [[52, 67]]}}}, {"text": "Use JInternalFrame.setMaximum(true) after you create your frame", "label": {"api": {"JInternalFrame.setMaximum(true)": [[4, 34]]}}}, {"text": "As you can see here (setDefaultCloseOperation doc) you can use DISPOSE_ON_CLOSE if you want to trigger a window listener (for example to close a database connection)", "label": {"api": {"setDefaultCloseOperation doc": [[21, 48]]}}}, {"text": "More details in the JavaDoc for DateTimeFormatter and LocalDateTime", "label": {"api": {"DateTimeFormatter": [[32, 48]], "LocalDateTime": [[54, 66]]}}}, {"text": "You can predict the number of bytes needed to encode an int with a utility method on Integer", "label": {"api": {"a utility method": [[65, 80]]}}}, {"text": "insertRow() calls into Vector.insertElementAt() which throws ArrayIndexOutOfBoundsException if index is out of range", "label": {"api": {"Vector.insertElementAt()": [[23, 46]]}}}, {"text": "From the Javadoc for PrintWriter", "label": {"api": {"Javadoc for PrintWriter": [[9, 31]]}}}, {"text": "For example, PrintWriter(OutputStream)", "label": {"api": {"PrintWriter(OutputStream)": [[13, 37]]}}}, {"text": "You can use DefaultTableModel or your own implementation of TableModel", "label": {"api": {"DefaultTableModel": [[12, 28]]}}}, {"text": "Extension of AbstractTableModel usually is a most common approach if DefaultTableModel does not satisfy your needs", "label": {"api": {"DefaultTableModel": [[69, 85]]}}}, {"text": "SwingWorker can be used for such purpose", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "Get data from database in SwingWorker.doInBackground()", "label": {"api": {"SwingWorker": [[26, 36]]}}}, {"text": "Then, either build or update your model in SwingWorker.done()", "label": {"api": {"SwingWorker": [[43, 53]]}}}, {"text": "For instance you can use SwingWorker's publish()/process() tandem to process data in chunks", "label": {"api": {"SwingWorker": [[25, 35]]}}}, {"text": "You may choose to incorporate database access logic into your model or create commands that extend SwingWorker", "label": {"api": {"SwingWorker": [[99, 109]]}}}, {"text": "You can maintain ordering either use ExecurorService  and make pool of one thread then in a loop pass one by one thread to pool and execute it", "label": {"api": {"ExecurorService": [[37, 51]]}}}, {"text": "don't create 100000 Threads, but use an ExecutorService (eg use one of the ready to use from Executors)", "label": {"api": {"Executors": [[93, 101]]}}}, {"text": "You're using Matcher.group() which is documented as", "label": {"api": {"Matcher.group()": [[13, 27]]}}}, {"text": "You could do it using WindowListener", "label": {"api": {"WindowListener": [[22, 35]]}}}, {"text": "In the following sample WindowAdapter implements WindowListener and I just override the public void windowClosed(final WindowEvent e) method, opening the second window", "label": {"api": {"WindowListener": [[49, 62]], "WindowAdapter": [[24, 36]]}}}, {"text": "Java 8 streams provide some of this functionality in a reasonably fluent syntax", "label": {"api": {"Java 8 streams": [[0, 13]]}}}, {"text": "If you can use Java 7 I recommend Phaser", "label": {"api": {"Phaser": [[34, 39]]}}}, {"text": "Create a HashSet a use contains method", "label": {"api": {"HashSet": [[9, 15]]}}}, {"text": "String or ArrayList will have O(n) complexity where as HashSet will be O(1) complexity", "label": {"api": {"HashSet": [[55, 61]]}}}, {"text": "If you only care about containment, you should use a Set<String> of some kind (e.g", "label": {"api": {"Set<String>": [[53, 63]]}}}, {"text": "HashSet<String> or LinkedHashSet<String>, which will both give O(1) complexity unless you have a significant number of hash collisions) but for goodness' sake don't use a concatenated string", "label": {"api": {"Set<String>": [[4, 14], [29, 39]], "HashSet<String>": [[0, 14], [25, 39]], "LinkedHashSet<String>": [[19, 39]]}}}, {"text": "address using URLConnection", "label": {"api": {"URLConnection": [[14, 26]]}}}, {"text": "In order to use Timestamp, you could use it like this", "label": {"api": {"Timestamp": [[16, 24]]}}}, {"text": "Basically System.currentTimeMillis() returns the number of milliseconds since January 1, 1970, 00:00:00 GMT until current time", "label": {"api": {"System.currentTimeMillis()": [[10, 35]]}}}, {"text": "Note that this makes FileReader class completely useless if you want your code to be portable", "label": {"api": {"FileReader": [[21, 30]]}}}, {"text": "This answer is only applies if you are able to use an undecorated Stage for your application", "label": {"api": {"undecorated Stage": [[54, 70]]}}}, {"text": "Modify this class to add a setOnMouseReleased handler and implement your webView size modifications in there", "label": {"api": {"setOnMouseReleased": [[27, 44]]}}}, {"text": "So far, I've tried java.awt.Toolkit.sync(), but it didn't seem to help", "label": {"api": {"java.awt.Toolkit.sync()": [[19, 41]]}}}, {"text": "Once you manage to fix your code, consider using StringBuilder instead of concatenating to String", "label": {"api": {"StringBuilder": [[49, 61]]}}}, {"text": "And once you manage to use StringBuilder, you'll discover handy reverse() method", "label": {"api": {"StringBuilder": [[27, 39]], "reverse()": [[64, 72]]}}}, {"text": "You can also use Files#delete(Path path) (jdk7) to have more details about the issue", "label": {"api": {"Files#delete(Path path)": [[17, 39]]}}}, {"text": "You could use the ScheduledExecuterService as follows", "label": {"api": {"ScheduledExecuterService": [[18, 41]]}}}, {"text": "I guess you're looking for ArrayList", "label": {"api": {"ArrayList": [[27, 35]]}}}, {"text": "ArrayList#get(int index), with an iterator (ArrayList#iterator()) or with a foreach loop", "label": {"api": {"ArrayList": [[0, 8], [44, 52]], "ArrayList#get(int index)": [[0, 23]], "ArrayList#iterator()": [[44, 63]]}}}, {"text": "In Java 8 you can use computeIfAbsent from Map, like this", "label": {"api": {"computeIfAbsent": [[22, 36]]}}}, {"text": "This will work as long as you do not \"structurally modify\" the list or any of these sub-lists", "label": {"api": {"\"structurally modify\"": [[37, 57]]}}}, {"text": "Check the docs on ObjectOutpuStream and ObjectInputStream", "label": {"api": {"ObjectOutpuStream": [[18, 34]], "ObjectInputStream": [[40, 56]]}}}, {"text": "or read them using ObjectInputStream", "label": {"api": {"ObjectInputStream": [[19, 35]]}}}, {"text": "This uses a blocking queue, which is a much better concurrency mechanism than a check-sleep loop", "label": {"api": {"blocking queue": [[12, 25]]}}}, {"text": "I know there is this Node class, but I don't import it so I can't see why that would form a problem", "label": {"api": {"Node class": [[21, 30]]}}}, {"text": "PrinterJob.printDialog() should do the trick", "label": {"api": {"PrinterJob.printDialog()": [[0, 23]]}}}, {"text": "The Printable returned by the getPrintable() method of JTextComponent \"formats the document content appropriately for the page size.\" If this is insufficient, please edit your question to include an sscce that exhibits the problem you're having", "label": {"api": {"getPrintable()": [[30, 43]]}}}, {"text": "See getImage in the Java docs", "label": {"api": {"getImage": [[4, 11]]}}}, {"text": "Take a look at java.util.Formatter", "label": {"api": {"java.util.Formatter": [[15, 33]]}}}, {"text": "You can use System.out's printf method instead of println, and use formatting options to right-adjust the values that you print", "label": {"api": {"printf": [[25, 30]]}}}, {"text": "You use the same approach, just passing the converted array to the constructor of a Set implementation", "label": {"api": {"Set": [[84, 86]]}}}, {"text": "It could be applied to your list with Collections.sort(list, comparator)", "label": {"api": {"Collections.sort(list, comparator)": [[38, 71]]}}}, {"text": "If you are only intersted in the maximum, as your headline indicates, there is also Collections.max which is applied in the identical way", "label": {"api": {"Collections.max": [[84, 98]]}}}, {"text": "Your paintComponent(...) method needs to call the super's method on the first line", "label": {"api": {"paintComponent(...)": [[5, 23]]}}}, {"text": "If you want to draw a string on the component's surface, override paintComponent() and use the provided Graphics object", "label": {"api": {"paintComponent()": [[66, 81]]}}}, {"text": "Otherwise, if the intent is to simply notify user about the error, you could use JOptionPane", "label": {"api": {"JOptionPane": [[81, 91]]}}}, {"text": "The slightly-harder-but-definitely-better way is to extend an unmodifiable AbstractCollection (or AbstractList) and the associated iterator (that will iterate on the two List iterators as needed)", "label": {"api": {"unmodifiable AbstractCollection (or AbstractList)": [[62, 110]]}}}, {"text": "Note from the PriorityQueue API", "label": {"api": {"PriorityQueue API": [[14, 30]]}}}, {"text": "To control the sizing the view inside a JViewport, let it implement the Scrollable interface", "label": {"api": {"Scrollable": [[72, 81]]}}}, {"text": "I find java's BigInteger to be the best among them all for bit manipulation", "label": {"api": {"BigInteger": [[14, 23]]}}}, {"text": "Have a look at the documentation", "label": {"api": {"Have a look at the documentation": [[0, 31]]}}}, {"text": "In the Java SE 6 JavaDoc for Matcher, one finds the option of reusing the same Matcher object, via the reset(CharSequence) method, which, as the source code shows, is a bit less expensive than creating a new Matcher every time, i.e., unlike above, one could do", "label": {"api": {"Java SE 6 JavaDoc for Matcher": [[7, 35]]}}}, {"text": "You could parse the HTML to an XML infoset (There are several HTML parsers available, including TagSoup), transform using XSLT, and serialize back to HTML using the HTML output mode of XSLT", "label": {"api": {"transform using XSLT": [[106, 125]], "serialize": [[132, 140]]}}}, {"text": "java.util.Scanner was introduced in version 1.5 (\"Java 5\"), I'm not familiar with Rational Software Architect, but probably you need to set your project to use the correct Java-version (1.5 or newer)", "label": {"api": {"java.util.Scanner": [[0, 16]]}}}, {"text": "You could use String#lastIndexOf, starting from the penultimate character to find the first \"", "label": {"api": {"String#lastIndexOf": [[14, 31]]}}}, {"text": "Why not use String.split(regex, limit) and specify the number of commas you need to split on", "label": {"api": {"String.split(regex, limit)": [[12, 37]]}}}, {"text": "If you accept that, then all you need is a URLDecoder call that will replace %.", "label": {"api": {"URLDecoder": [[43, 52]]}}}, {"text": "We know that we can override the System classloader with", "label": {"api": {"classloader": [[40, 50]]}}}, {"text": "How do we get the class file of this \"meta\" classloader", "label": {"api": {"classloader": [[44, 54]]}}}, {"text": "From the Javadoc for ClassLoader.getSystemClassLoader", "label": {"api": {"ClassLoader.getSystemClassLoader": [[21, 52]]}}}, {"text": "Perhaps you're looking for the EventListenerList class", "label": {"api": {"EventListenerList": [[31, 47]]}}}, {"text": "You can use java.util.concurrent.ConcurrentHashMap for Thread safe hash map", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[12, 49]]}}}, {"text": "Take a look at EventListenerList", "label": {"api": {"EventListenerList": [[15, 31]], "EventListener": [[15, 27]]}}}, {"text": "It holds a list of anything implementing EventListener", "label": {"api": {"EventListener": [[41, 53]]}}}, {"text": "Provided you are using Java 6, you can have a look at ConcurrentSkipListSet and ConcurrentSkipListMap", "label": {"api": {"ConcurrentSkipListSet": [[54, 74]], "ConcurrentSkipListMap": [[80, 100]]}}}, {"text": "The closest you can get with standard Java foundation classes is a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[67, 79]]}}}, {"text": "Either based on the LinkedHashSet, or using your own set implementation", "label": {"api": {"LinkedHashSet": [[20, 32]]}}}, {"text": "Because String and StringBuilder (or StringBuffer) are designed for different purposes, I can understand the reasons for half of the difference (such as String does not have append and delete)", "label": {"api": {"String": [[8, 13], [19, 24], [37, 42], [153, 158]], "StringBuilder": [[19, 31]], "StringBuffer": [[37, 48]]}}}, {"text": "String has both getBytes and getChars but StringBuilder has only getChars", "label": {"api": {"String": [[0, 5], [42, 47]], "StringBuilder": [[42, 54]]}}}, {"text": "String and StringBuilder have replace of different functionality respectively", "label": {"api": {"String": [[0, 5], [11, 16]], "StringBuilder": [[11, 23]]}}}, {"text": "String has toLowerCase and toUpperCase, whereas StringBuilder does not", "label": {"api": {"String": [[0, 5], [48, 53]], "StringBuilder": [[48, 60]]}}}, {"text": "String has trim, whereas StringBuilder does not", "label": {"api": {"String": [[0, 5], [25, 30]], "StringBuilder": [[25, 37]]}}}, {"text": "The real magic is done in the custom AdjustmentListener, where we go and increase the current \"scroll-position\" by one single block per time", "label": {"api": {"AdjustmentListener": [[37, 54]]}}}, {"text": "As @kleopatra mentioned in the comments, you can also use a MouseWheelListener to only redefine the behavior of the mouse-wheel", "label": {"api": {"MouseWheelListener": [[60, 77]]}}}, {"text": "Per the documentation, php gzdeflate() generates raw deflate data (RFC 1951), but Java's Inflater class is expecting zlib (RFC 1950) data, which is raw deflate data wrapped in zlib header and trailer", "label": {"api": {"Inflater class": [[89, 102]]}}}, {"text": "Unless you specify nowrap as true to the Inflater constructor", "label": {"api": {"nowrap as true": [[19, 32]]}}}, {"text": "If I understood correctly your need, you could take a look at the ConcurrentMap and of course ConcurrentHashMap  which I believe was introduced with Java 5.0 and supports a level of concurrency", "label": {"api": {"ConcurrentMap": [[66, 78]], "ConcurrentHashMap": [[94, 110]]}}}, {"text": "Then, execute all your Workers using an ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[40, 64]]}}}, {"text": "You could just use the type T directly for a simple getter and Class.cast -method for other types", "label": {"api": {"Class.cast": [[63, 72]]}}}, {"text": "To create a long from a double, use Double.longValue()", "label": {"api": {"Double.longValue()": [[36, 53]]}}}, {"text": "To create a float from a double, use Double.floatValue()", "label": {"api": {"Double.floatValue()": [[37, 55]]}}}, {"text": "I am using the default java.util.Logging API to print information to my log", "label": {"api": {"API": [[41, 43]]}}}, {"text": "The handler can be any of the subclasses defined from Handler", "label": {"api": {"Handler": [[54, 60]]}}}, {"text": "If you use FileHandler, you should read the Java API for FileHandler", "label": {"api": {"Handler": [[15, 21], [61, 67]], "FileHandler": [[11, 21], [57, 67]]}}}, {"text": "run() can't throw a checked exception because it is not declared to do so", "label": {"api": {"run()": [[0, 4]]}}}, {"text": "So, implementations of Runnable can't simply add throws clauses to their implementations of run()", "label": {"api": {"run()": [[92, 96]]}}}, {"text": "If you look at the Runnable Interface you find that void     run() method is not declared as throwing any checked exception and your Thread class implements Runnable Interface", "label": {"api": {"Runnable Interface": [[19, 36], [157, 174]]}}}, {"text": "This relies on the fact that if a no-argument constructor is invoked with newInstance, any checked exception it throws escapes upward", "label": {"api": {"newInstance": [[74, 84]]}}}, {"text": "UncaughtExceptionHandler came in Java 5.0 to handle uncaught exceptions thrown by a Thread", "label": {"api": {"UncaughtExceptionHandler": [[0, 23]]}}}, {"text": "The Executor Framework saves the returned value or thrown exception( wrapper in ExecutionException) as the states of some Object shared across threads(like Outer class instance) and purveys those to the invoker(who is running in some other thread) of Future.get()", "label": {"api": {"get": [[258, 260]]}}}, {"text": "As mentioned in the API Documentation", "label": {"api": {"API Documentation": [[20, 36]]}}}, {"text": "In ThreadFactory.newThread(Runnable) there is no generic type, nor is Runnable or Thread a generic interface/class", "label": {"api": {"ThreadFactory.newThread(Runnable)": [[3, 35]]}}}, {"text": "Maybe you are getting confused with Callable", "label": {"api": {"Callable": [[36, 43]]}}}, {"text": "FileWriter writes to a file using the default encoding (from operating system on your machine)", "label": {"api": {"FileWriter": [[0, 9]]}}}, {"text": "This is anyway doable with isNotMember", "label": {"api": {"isNotMember": [[27, 37]]}}}, {"text": "In servlet you have access to HttpServletRequest which provides you with a getSession() method", "label": {"api": {"HttpServletRequest": [[30, 47]], "getSession()": [[75, 86]]}}}, {"text": "I recommend using ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[18, 44]]}}}, {"text": "One thing might come in handy PropertyResourceBundle have two constructors that will let you load whatever properties file you want, namely", "label": {"api": {"PropertyResourceBundle": [[30, 51]]}}}, {"text": "PropertyResourceBundle(InputStream stream) and PropertyResourceBundle(Reader reader)", "label": {"api": {"PropertyResourceBundle": [[0, 21], [47, 68]], "PropertyResourceBundle(InputStream stream)": [[0, 41]], "PropertyResourceBundle(Reader reader)": [[47, 83]]}}}, {"text": "I believe you may want to use the LocalDateTime class introduced in Java 8 with the new time API", "label": {"api": {"LocalDateTime": [[34, 46]]}}}, {"text": "java.crypto.SealedObject is what you are looking for", "label": {"api": {"java.crypto.SealedObject": [[0, 23]]}}}, {"text": "I recommend you look into ByteBuffer", "label": {"api": {"ByteBuffer": [[26, 35]]}}}, {"text": "The replace method just replaces one substring with another", "label": {"api": {"replace": [[4, 10], [24, 30]]}}}, {"text": "Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence", "label": {"api": {"replace": [[107, 113]]}}}, {"text": "The replacement proceeds from the beginning of the string to the end, for example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in \"ba\" rather than \"ab\"", "label": {"api": {"replace": [[4, 10]]}}}, {"text": "If you want to keep the trailing blank strings, you can use the 2 argument split method with a negative limit", "label": {"api": {"2 argument split method": [[64, 86]]}}}, {"text": "If the actionPane is taken from a small set of Panels that are pretty much predefined, with relatively minor live updates and changes, a good option is to use a CardLayout, and switch between the predefined actionPanes as needed", "label": {"api": {"CardLayout": [[161, 170]]}}}, {"text": "There's an overloaded Long.parseLong that accepts a second parameter, specifying the radix", "label": {"api": {"Long.parseLong": [[22, 35]]}}}, {"text": "As an alternative, you could iterate over the characters in the string and call Character.digit(c,16) on them (if any of them return -1 it's not a valid hexadecimal digit)", "label": {"api": {"Character.digit(c,16)": [[80, 100]]}}}, {"text": "Read UIManager and How to Set the Look and Feel for more information", "label": {"api": {"UIManager": [[5, 13]]}}}, {"text": "Create a new char[] copying only the elements you want to keep; for this you could use System.arraycopy() or even simplerArrays.copyOfRange()", "label": {"api": {"System.arraycopy()": [[87, 104]], "Arrays.copyOfRange()": [[121, 140]]}}}, {"text": "To get it to operate for left clicks only have a look at the ButtonMasks on MouseEvent (BUTTON1) being for left mouse clicks", "label": {"api": {"MouseEvent": [[76, 85]]}}}, {"text": "or you can use an Iterator to remove your objects", "label": {"api": {"Iterator": [[18, 25]]}}}, {"text": "The ThreadPoolExecutor transforms the Runnable you submit into a RunnableFuture using the newTaskFor() method, and adds this RunnableFuture to the queue", "label": {"api": {"newTaskFor()": [[90, 101]]}}}, {"text": "So if you want to use a PriorityQueue, you should override the newTaskFor() method to make sure the RunnableFuture instances it creates are comparable", "label": {"api": {"newTaskFor()": [[63, 74]]}}}, {"text": "A couple of general points, why do you do voodoo with the File constructor, where there is a perfectly usable constructor where you can define the name of the File you want to create and give a parent File", "label": {"api": {"perfectly usable constructor": [[93, 120]]}}}, {"text": "You can get the name of the field with the getPropertyPath() method from the ConstraintViolation class", "label": {"api": {"ConstraintViolation class": [[77, 101]]}}}, {"text": "You could use Blob.setBinaryStream to obtain a stream for writing the data to the db", "label": {"api": {"Blob.setBinaryStream": [[14, 33]]}}}]