[{"text": "But available() keeps returning 0, although there is readable data in the stream", "label": {"api": {"available()": [[4, 14]]}}}, {"text": "After a little search; I found that available() is not reliable when using with sockets, and that I should be reading first few bytes from stream to actually see if data is available to parse", "label": {"api": {"available()": [[36, 46]]}}}, {"text": "But in my case; I have to pass the DataInputStream reference I get from the socket to some other class that I cannot change", "label": {"api": {"DataInputStream": [[35, 49]]}}}, {"text": "Is it possible to read a few bytes from DataInputStream without corrupting it, or any other suggestions", "label": {"api": {"DataInputStream": [[40, 54]]}}}, {"text": "Putting a PushbackInputStream in between allows you to read some bytes without corrupting the data", "label": {"api": {"PushbackInputStream": [[10, 28]]}}}, {"text": "Put a ByteArrayOutputStream where you have the File and you should be good", "label": {"api": {"ByteArrayOutputStream": [[6, 26]]}}}, {"text": "You can call waitFor() on Process", "label": {"api": {"waitFor()": [[13, 21]]}}}, {"text": "Process#waitFor() is what you're looking for", "label": {"api": {"Process#waitFor()": [[0, 16]]}}}, {"text": "Why not use String#replace method instead of replaceAll", "label": {"api": {"String#replace": [[12, 25]]}}}, {"text": "According to XMLSignatureFactory.newSignatureMethod() you can probably register ecdsa-ripemd160 using something like this", "label": {"api": {"XMLSignatureFactory.newSignatureMethod()": [[13, 52]]}}}, {"text": "You will have to roll your own MyECDSARipemd160Provider() class to implement the SignatureMethodParameterSpec and it will need to identify your algorithm", "label": {"api": {"SignatureMethodParameterSpec": [[81, 108]]}}}, {"text": "I would assume the getAlgorithm() call to this class should return \"RIPEMD160WITHECDSA\"", "label": {"api": {"getAlgorithm()": [[19, 32]]}}}, {"text": "If MyClass is an interface look at java.lang.reflect.Proxy and java.lang.reflect.InvocationHandler", "label": {"api": {"java.lang.reflect.Proxy": [[35, 57]], "java.lang.reflect.InvocationHandler": [[63, 97]]}}}, {"text": "You might take a closer look at  the CertificateFactory", "label": {"api": {"CertificateFactory": [[37, 54]]}}}, {"text": "You can accept a normal socket connection and upgrade it to SSL/TLS at a later stage, using SSLSocketFactory.createSocket(Socket s, String host, int port, boolean autoClose) (and SSLSocket.setUseClientMode(false) on the server side)", "label": {"api": {"SSLSocketFactory.createSocket(Socket s, String host, int port, boolean autoClose)": [[92, 172]]}}}, {"text": "Thread.interrupt() is not throwing it, neither any of your methods", "label": {"api": {"Thread.interrupt()": [[0, 17]]}}}, {"text": "You must check that flag explicitly using Thread.isInterrupted()", "label": {"api": {"Thread.isInterrupted()": [[42, 63]]}}}, {"text": "It would probably make sense to implement Comparable", "label": {"api": {"Comparable": [[42, 51]]}}}, {"text": "Sort all of the lists using Collections.sort(List)", "label": {"api": {"Collections.sort(List)": [[28, 49]]}}}, {"text": "You will want to use getSystemResourceAsStream() to read the contents from files in a jar", "label": {"api": {"getSystemResourceAsStream()": [[21, 47]]}}}, {"text": "I think what you really want is an ArrayList or Vector", "label": {"api": {"ArrayList": [[35, 43]], "Vector": [[48, 53]]}}}, {"text": "For any object that you implement in your own classes, you can always override the default hashCode() method", "label": {"api": {"hashCode()": [[91, 100]]}}}, {"text": "Note, you should always obey the contract between hashCode() and equals() as mentioned in the hashCode() javadoc", "label": {"api": {"hashCode()": [[50, 59], [94, 103]]}}}, {"text": "String.split without the limit argument drops all trailing empty Strings from the result array", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "From String.split(String, int)", "label": {"api": {"String.split": [[5, 16]], "String.split(String, int)": [[5, 29]]}}}, {"text": "Calling String.split(String) is equivalent to calling the 2-argument split with a limit of 0", "label": {"api": {"String.split": [[8, 19]]}}}, {"text": "You can pass a limit to the split method so that the trailing empty strings are retained", "label": {"api": {"split": [[28, 32]]}}}, {"text": "Then I googled a bit for further information and found this link to another stackoverflow post, which looked so interesting (I had never heard of the ThreadPoolExecutor class)", "label": {"api": {"the ThreadPoolExecutor class": [[146, 173]]}}}, {"text": "Calling receive waits until a new datagram is delivered", "label": {"api": {"receive": [[8, 14]]}}}, {"text": "This method blocks until a datagram is received", "label": {"api": {"receive": [[39, 45]]}}}, {"text": "If you have many clients or if processing the packet isn't completely trivial, you should start a new thread for processing each one, so that the main thread that receives the datagrams doesn't get blocked", "label": {"api": {"receive": [[163, 169]]}}}, {"text": "It looks like your aList, presumably a JList, is dropping the tab character during rendering", "label": {"api": {"JList": [[39, 43]]}}}, {"text": "A bit verbose, but it's the standard way of parsing and formatting dates in Java", "label": {"api": {"standard": [[28, 35]]}}}, {"text": "If you'd rather not use the Apache Commons library you might be able to get by using Java's URLEncoder", "label": {"api": {"URLEncoder": [[92, 101]]}}}, {"text": "You can use a JWindow to get a barebones window", "label": {"api": {"JWindow": [[14, 20]]}}}, {"text": "Using the File Separator will give you the platform independent character and you wont have to escape it", "label": {"api": {"File Separator": [[10, 23]]}}}, {"text": "Your call to pause() is blocking the event dispatch thread", "label": {"api": {"event dispatch thread": [[37, 57]]}}}, {"text": "I believe what you are looking for is LinkedHashMap", "label": {"api": {"LinkedHashMap": [[38, 50]]}}}, {"text": "I imagine background Timers' I've seen a lot 5 to 10 years ago or some newer, like ScheduledThreadPoolExecutor", "label": {"api": {"Timer": [[21, 25]], "ScheduledThreadPoolExecutor": [[83, 109]]}}}, {"text": "You would need to keep track of Futures and cancel them or use some BlockingQueue", "label": {"api": {"BlockingQueue": [[68, 80]]}}}, {"text": "With this approach you'll start clutter your business entities with quite complex technical stuff even if you will use some patterns to simplify (encapsulate) complexity your 'state machine' start to spread between multiple components, it will be even worse if you'll use 'layered style' because you will start to produce data structures for the state stuff, like Map<Callee, BlockingQueue<Caller>>", "label": {"api": {"BlockingQueue": [[376, 388]]}}}, {"text": "This takes advantage of the fact that ArrayList has a constructor which takes Collection<", "label": {"api": {"constructor": [[54, 64]]}}}, {"text": "For the case of missing colon it is actually an IllegalArgumentException thrown by AbstractQueryImpl class", "label": {"api": {"IllegalArgumentException": [[48, 71]]}}}, {"text": "The data resides in the TableModel; to obtain this, you call getModel()", "label": {"api": {"getModel()": [[61, 70]]}}}, {"text": "Then you use getValueAt(int,int) to get the value of a specific cell", "label": {"api": {"getValueAt(int,int)": [[13, 31]]}}}, {"text": "Exactly as the error message tells you, there is no MimeMessage constructor that takes an HttpSession", "label": {"api": {"there is no MimeMessage constructor that takes an HttpSession": [[40, 100]], "HttpSession": [[90, 100]]}}}, {"text": "There is a constructor which takes a javax.mail.Session, which appears to be the one you're trying to use, but an HttpSession is not a javax.mail.Session", "label": {"api": {"javax.mail.Session": [[37, 54], [135, 152]], "HttpSession": [[114, 124]]}}}, {"text": "There are a bunch of nested schemas, my code has an org.w3c.dom.ls.LsResourceResolver to figure out what schema to use, implementing this method", "label": {"api": {"org.w3c.dom.ls.LsResourceResolver": [[52, 84]]}}}, {"text": "Collection.contains(object) uses object.equals(anotherObject) to check if collection contains certain object", "label": {"api": {"Collection.contains(object)": [[0, 26]]}}}, {"text": "You can load the profiles from the LangDetect jar using JarUrlConnection  and JarEntry", "label": {"api": {"JarUrlConnection": [[56, 71]], "JarEntry": [[78, 85]]}}}, {"text": "It's present as a request attribute with the name as specified by the RequestDispatcher.ERROR_EXCEPTION constant", "label": {"api": {"RequestDispatcher.ERROR_EXCEPTION": [[70, 102]]}}}, {"text": "Java7 provides a new language construct that makes it easier to close objects that implement the AutoClosable interface", "label": {"api": {"AutoClosable": [[97, 108]]}}}, {"text": "XML could be the way to go, but the usual approach to internationalise your Java applications is using ResourceBundles", "label": {"api": {"ResourceBundles": [[103, 117]]}}}, {"text": "As for string pooling, that is achieved by the compiler for string literals and at runtime by calling String.intern", "label": {"api": {"String.intern": [[102, 114]]}}}, {"text": "Java regular expressions support the supplementary range using surrogate pairs", "label": {"api": {"surrogate pairs": [[63, 77]]}}}, {"text": "First of all, the unicode block concerned is specified in java (strictly following the standard) as Character.UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS", "label": {"api": {"Character.UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS": [[100, 159]]}}}, {"text": "If we look at the Java String API we see that you're using substring() to get a particular character..", "label": {"api": {"look at the Java String API": [[6, 32]]}}}, {"text": "A Map is really what you want, because it's O(1) access time, reducing your function to O(n), where n is the length of your phrase", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "Don't run client => server calls on the JavaFX application thread, instead run them in their own thread via a Task or Service", "label": {"api": {"Task": [[110, 113]], "Service": [[118, 124]]}}}, {"text": "If you want to iterator over the elements, just use a Set.iterator()", "label": {"api": {"Set.iterator()": [[54, 67]]}}}, {"text": "I would choose BigInteger for this..", "label": {"api": {"BigInteger": [[15, 24]]}}}, {"text": "In any case, simply calling Thread.yield() after releasing the lock should be sufficient to allow the other threads a chance to acquire the lock before the original thread grabs it again", "label": {"api": {"Thread.yield()": [[28, 41]]}}}, {"text": "You can set that flag inside the windowClosed method of a WindowListener", "label": {"api": {"WindowListener": [[58, 71]]}}}, {"text": "This WindowListener you will then add it to your second window", "label": {"api": {"WindowListener": [[5, 18]]}}}, {"text": "You can see if a Window is opened by calling Window#isShowing", "label": {"api": {"Window#isShowing": [[45, 60]]}}}, {"text": "To match any series of two or more words starting with a capital letter, then you'll need to use a Matcher", "label": {"api": {"Matcher": [[99, 105]]}}}, {"text": "Also your longer code might actually be faster (signum() operaton on floating-point numbers), not to mention more readable", "label": {"api": {"signum()": [[48, 55]]}}}, {"text": "To ensure that two actions are free of a data race, you must establish a happens-before relationship between the two actions using any of the five conditions specified in §17.4.5 and recapitulated in Memory Consistency Properties", "label": {"api": {"Memory Consistency Properties": [[200, 228]]}}}, {"text": "As your iterator will be walking through Map.Entry objects, extract them out as those types first", "label": {"api": {"Map.Entry": [[41, 49]]}}}, {"text": "You can use BufferedReader for this purpose to read from system input", "label": {"api": {"BufferedReader": [[12, 25]]}}}, {"text": "Just use a HashMap", "label": {"api": {"HashMap": [[11, 17]]}}}, {"text": "You can use a LinkedHashMap instead, which will preserve the insertion order", "label": {"api": {"LinkedHashMap": [[14, 26]]}}}, {"text": "* There are tricks, such as using PhantomReference, which do let you monitor the status of garbage collection, however these will put more burden on the GC and thus aren't a good idea - or necessary - in general", "label": {"api": {"PhantomReference": [[34, 49]]}}}, {"text": "What's wrong with new ImageIcon(Image)", "label": {"api": {"new ImageIcon(Image)": [[18, 37]]}}}, {"text": "The KeyEvent comes with the component originating the KeyEvent \"attached,\" which can be accessed using its getComponent method", "label": {"api": {"getComponent method": [[107, 125]]}}}, {"text": "You're looking for Container.setFocusTraversalKeys", "label": {"api": {"Container.setFocusTraversalKeys": [[19, 49]]}}}, {"text": "See ScriptEngine as an example", "label": {"api": {"ScriptEngine": [[4, 15]]}}}, {"text": "Here is a demo of the JavaScript ScriptEngine in an applet", "label": {"api": {"ScriptEngine": [[33, 44]]}}}, {"text": "The reader might note that ScriptEngine is an interface, suggesting an answer of 'implement your own script engine, based on the rules required'", "label": {"api": {"ScriptEngine": [[27, 38]]}}}, {"text": "You can supply your own BasicRadioButtonUI, but the effort is not trivial", "label": {"api": {"BasicRadioButtonUI": [[24, 41]]}}}, {"text": "When I play the audio using MediaPlayer object and display the text from the text file", "label": {"api": {"MediaPlayer": [[28, 38]]}}}, {"text": "JDK 7 added a new transparency slider to the JColorChooser", "label": {"api": {"JColorChooser": [[45, 57]]}}}, {"text": "The other answers here show how to remove the transparency sliders from an instance of JColorChooser, but the main way to use JColorChooser is the static showDialog method, in which case you don't get access to an instance", "label": {"api": {"showDialog": [[154, 163]]}}}, {"text": "Therefore I present two methods, one which hides the controls from an instance of JColorChooser, and a drop-in replacement method for showDialog that has showTransparencyControls as a extra parameter", "label": {"api": {"showDialog": [[134, 143]]}}}, {"text": "With Java 9 you can use IntStream.iterate() with hasNext condition", "label": {"api": {"IntStream.iterate()": [[24, 42]]}}}, {"text": "You can use an ArrayList for this purpose", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "I think the distinction you're getting at is synchronized versus using the java.util.concurrent.Lock API", "label": {"api": {"java.util.concurrent.Lock": [[75, 99]], "Lock": [[96, 99]]}}}, {"text": "Most of what you get is added flexibility (from the Lock docs)", "label": {"api": {"Lock": [[52, 55]]}}}, {"text": "Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order", "label": {"api": {"Lock": [[23, 26]]}}}, {"text": "There are also two method calls which give you more ways to acquire a lock with the Lock API", "label": {"api": {"Lock": [[84, 87]]}}}, {"text": "You can tell the system to try to run pending finalizers immediately by calling the method System.runFinalization after a garbage collection", "label": {"api": {"System.runFinalization": [[91, 112]]}}}, {"text": "With JSPContext pushBody() and popBody() you can get some control over the order of output", "label": {"api": {"JSPContext": [[5, 14]]}}}, {"text": "Also, I've seen conflicting info about whether Joda Time is part of the standard API", "label": {"api": {"standard API": [[72, 83]]}}}, {"text": "No, it isn't part of the standard API", "label": {"api": {"standard API": [[25, 36]]}}}, {"text": "Try using String.split(\" \"), to split around the spaces", "label": {"api": {"String.split(\" \")": [[10, 26]]}}}, {"text": "Looping over the resulting array, including a parseInt for the number, you'll be able to match the rules that you've described", "label": {"api": {"parseInt": [[46, 53]]}}}, {"text": "the result of String.split() is an array, and [1] is taking the second element from that result", "label": {"api": {"String.split()": [[14, 27]]}}}, {"text": "You need a DocumentBuilder and to call parse() on it using an InputSource configured with the string of XML via a StringReader", "label": {"api": {"DocumentBuilder": [[11, 25]], "InputSource": [[62, 72]], "StringReader": [[114, 125]]}}}, {"text": "For instance GZipOutputStream to send data and GZipInputStream to receive sent data block", "label": {"api": {"GZipOutputStream": [[13, 28]], "GZipInputStream": [[47, 61]]}}}, {"text": "You should use a StringBuilder", "label": {"api": {"StringBuilder": [[17, 29]]}}}, {"text": "Create a Map<String,Integer> (let it be map) which will be used as a histogram", "label": {"api": {"Map<String,Integer>": [[9, 27]]}}}, {"text": "Use a URLClassLoader to do that for you", "label": {"api": {"URLClassLoader": [[6, 19]]}}}, {"text": "In Java, Iterator is an interface itself", "label": {"api": {"Iterator": [[9, 16]]}}}, {"text": "The method proposed in the tutorial linked above uses the WatchService API", "label": {"api": {"WatchService API": [[58, 73]]}}}, {"text": "If you want the set to maintain the insertion order, you can use a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[67, 79]]}}}, {"text": "Alternatively, if you want your set to be ordered, you can use a TreeSet", "label": {"api": {"TreeSet": [[65, 71]]}}}, {"text": "From the javadoc of String(String original)", "label": {"api": {"String(String original)": [[20, 42]]}}}, {"text": "Consequently, since you are creating a second instance == correctly returns false (and equals(Object anObject) will return true)", "label": {"api": {"equals(Object anObject)": [[87, 109]]}}}, {"text": "More than often it's just the same as Charset#defaultCharset()", "label": {"api": {"Charset#defaultCharset()": [[38, 61]]}}}, {"text": "The javadoc for this loadLibrary (http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#loadLibrary(java.lang.String) ) states that \"If this method is called more than once with the same library name, the second and subsequent calls are ignored.\", so it seems you can't load the same library more than once", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#loadLibrary(java.lang.String)": [[34, 125]]}}}, {"text": "There is the java.util.List and java.awt.List", "label": {"api": {"java.util.List": [[13, 26]], "java.awt.List": [[32, 44]]}}}, {"text": "I see you are importing java.awt.*, so Java thinks you want the java.awt.List, but you want the java.util.List version to make it compile", "label": {"api": {"java.util.List": [[96, 109]], "java.awt.List": [[64, 76]]}}}, {"text": "I just gave your FileFilter a quick look.Note that you can use a FileNameExtensionFilter instead of implementing your own", "label": {"api": {"FileNameExtensionFilter": [[65, 87]]}}}, {"text": "LinkedList does implement Queue", "label": {"api": {"LinkedList does implement Queue": [[0, 30]]}}}, {"text": "ArcTest shows how to use an XYShapeAnnotation that can be any Shape at all", "label": {"api": {"Shape": [[30, 34], [62, 66]]}}}, {"text": "With ss, use String#indexOf to get the next position of the dash (or w/e char you need)", "label": {"api": {"String#indexOf": [[13, 26]]}}}, {"text": "You can use String#charAt method for this purpose", "label": {"api": {"String#charAt": [[12, 24]]}}}, {"text": "Super simple using String.split", "label": {"api": {"String.split": [[19, 30]]}}}, {"text": "To counter against rounding errors, score here could be represented using a BigDecimal", "label": {"api": {"BigDecimal": [[76, 85]]}}}, {"text": "The class java.awt.AlphaComposite implements the same rules", "label": {"api": {"java.awt.AlphaComposite": [[10, 32]]}}}, {"text": "Either compile your Pattern with the Pattern.DOTALL option, or add the equivalent flag expression (?s) to your regex, so that", "label": {"api": {"Pattern.DOTALL": [[37, 50]]}}}, {"text": "It has been moved to ViewDeclarationLanguage#buildView() as this step is decoupled from the view technology used (Facelets, JSP, JavaVDL, whatever)", "label": {"api": {"ViewDeclarationLanguage#buildView()": [[21, 55]]}}}, {"text": "It's by the way simpler to extend ViewHandlerWrapper instead", "label": {"api": {"ViewHandlerWrapper": [[34, 51]]}}}, {"text": "I studied java.util.regex api doc, however I was unable to find a way to put together  negation of regular expression \"\\d{8}\"", "label": {"api": {"api doc": [[26, 32]]}}}, {"text": "Have a look at ArrayBlockingQueue for instance, and read up on the Consumer-Producer pattern", "label": {"api": {"ArrayBlockingQueue": [[15, 32]]}}}, {"text": "In Java you can use String.replaceFirst()", "label": {"api": {"String.replaceFirst()": [[20, 40]]}}}, {"text": "If you want to modify a string directly you will need to use a mutable string type like StringBuilder", "label": {"api": {"String": [[88, 93]]}}}, {"text": "There are many methods in the String API docs that will help you get a modified version of your string, including s.replace(), s.replaceAll(),s.replaceFirst(), ..", "label": {"api": {"String": [[30, 35]]}}}, {"text": "If you really want to treat the string as an array as in your initial example, you could use String.getChars to get an array of characters, manipulate that, and then use the String constructor String(char[]) to convert back to a String object", "label": {"api": {"String": [[93, 98], [174, 179], [193, 198], [229, 234]]}}}, {"text": "Instead of rewriting the insert statement using PostgreSQL-proprietary syntax, you could use JDBC 4 SQLXML", "label": {"api": {"JDBC 4 SQLXML": [[93, 105]]}}}, {"text": "Use BlockingQueue and a Producer-Consumer pattern", "label": {"api": {"BlockingQueue": [[4, 16]]}}}, {"text": "one way to do it would be to create a new instance of HashMap ubermap, iterate over the ArrayList<HashMap> and call putAll() method of ubermap, one map at a time", "label": {"api": {"putAll()": [[116, 123]]}}}, {"text": "Take a look at the table in SimpleDateFormat docs", "label": {"api": {"SimpleDateFormat docs": [[28, 48]]}}}, {"text": "This involves using the ClassLoader.getResources method to find all classes and subpackages in a given package", "label": {"api": {"ClassLoader.getResources": [[24, 47]]}}}, {"text": "Indeed use a StringBuilder", "label": {"api": {"StringBuilder": [[13, 25]]}}}, {"text": "super T>>, and change String[] to T[], which is how Collections.sort() work", "label": {"api": {"Collections.sort()": [[52, 69]]}}}, {"text": "PrintWriters buffer to memory before flushing to disk so you're not taking a performance hit by waiting for the write to disk to complete", "label": {"api": {"PrintWriters": [[0, 11]]}}}, {"text": "But, I suggest using StringBuilder where String copying happens in a loop", "label": {"api": {"StringBuilder": [[21, 33]]}}}, {"text": "To this end I recommend you look at ExecutorService", "label": {"api": {"ExecutorService": [[36, 50]]}}}, {"text": "It's been said that you can an instance of com.sun.net.httpserver.HttpServer to customize the HTTP behavior of the endpoint", "label": {"api": {"com.sun.net.httpserver.HttpServer": [[43, 75]]}}}, {"text": "There's an HttpsServer subclass that can be used to provide SSL, for example", "label": {"api": {"HttpsServer": [[11, 21]]}}}, {"text": "Use HttpServer.create(new InetSocketAddress(listenPortNumber), waitQueueDepth) to create a server instance", "label": {"api": {"HttpServer.create(new InetSocketAddress(listenPortNumber), waitQueueDepth)": [[4, 77]]}}}, {"text": "Use server.createContext(\"/path\") to create a context that will host the endpoint", "label": {"api": {"server.createContext(\"/path\")": [[4, 32]]}}}, {"text": "Call endpoint.publish(context) to associate the endpoint with the HttpServer (or HttpsServer) instance", "label": {"api": {"HttpsServer": [[81, 91]]}}}, {"text": "Of course, as others have suggested, using InetAddress might be more appropriate than doing things yourself..", "label": {"api": {"InetAddress": [[43, 53]]}}}, {"text": "Foreach is applicable for only java.lang.Iterable types", "label": {"api": {"java.lang.Iterable": [[31, 48]]}}}, {"text": "If your intention is to iterate characters in the string, then replace that \"s\" with \"s.toCharArray()\" which returns you an array that is java.lang.Iterable", "label": {"api": {"java.lang.Iterable": [[138, 155]]}}}, {"text": "The locales returned by getAvailableLocales() are not very important as you can create new ones the way you did", "label": {"api": {"Locale": [[36, 41]]}}}, {"text": "new Locale( \"gd\", \"GB\")", "label": {"api": {"Locale": [[4, 9]]}}}, {"text": "As stated in the Locale java docs the locale main purpose is to identify resources", "label": {"api": {"Locale": [[17, 22]]}}}, {"text": "The strings identifying the Locale are not even validated upon creation", "label": {"api": {"Locale": [[28, 33]]}}}, {"text": "Just use the ExternalContext#redirect() method directly", "label": {"api": {"ExternalContext#redirect()": [[13, 38]]}}}, {"text": "I'm looking to export the Java SE 7 Documentation from HTML into parse-able XML", "label": {"api": {"Java SE 7 Documentation": [[26, 48]]}}}, {"text": "I would suggest to use Observer pattern where the first servlet would be an observer of the object that implements Observable", "label": {"api": {"observer": [[76, 83]], "Observable": [[115, 124]]}}}, {"text": "When something happens, the second servlet would update the observable, and calls the setChanged() method which in turn would notify the observers (your first servlet in this case)", "label": {"api": {"observer": [[137, 144]]}}}, {"text": "Your array is storing Integer, which is a java Object, to test for equality of Java Object you need to call Object.equals method instead of ==", "label": {"api": {"Object.equals": [[108, 120]]}}}, {"text": "You should use ints (rather then Integers) or change the condition to use the equals() method", "label": {"api": {"equals()": [[78, 85]]}}}, {"text": "I have constructed a Path2D that represents an unclosed shape consisting of straight lines", "label": {"api": {"Path2D": [[21, 26]]}}}, {"text": "Using the contains method does not work because the algorithm treats the unclosed shape as implicitly closed (i.e", "label": {"api": {"contains": [[10, 17]]}}}, {"text": "There are only a few legal choices for alignments, so you should really use something like a JComboBox instead", "label": {"api": {"JComboBox": [[93, 101]]}}}, {"text": "You could store  custom objects in the JComboBox so that they display the named constant but also store the integer constant", "label": {"api": {"JComboBox": [[39, 47]]}}}, {"text": "Note that JComboBox changed between Java 6 and 7", "label": {"api": {"JComboBox": [[10, 18]]}}}, {"text": "In the Java 7 libraries JComboBox is generic, which makes it easier to store custom objects like this inside and retrieve their values later", "label": {"api": {"JComboBox": [[24, 32]]}}}, {"text": "You can simply use the Calendar class and iterate from one date to the other one by adding a month at each iteration using myCalendar.add(Calendar.MONTH, 1);", "label": {"api": {"the Calendar class": [[19, 36]]}}}, {"text": "You can't pass a String[] to executeQuery, it expects a single String as an argument", "label": {"api": {"executeQuery": [[29, 40]]}}}, {"text": "BigInteger would be the best fit, because a long has only 64-bit precision, whereas Oracle's number(38) datatype has 126-bit precision, and your field has no decimal part", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "I wrote a ResourceBundle.Control which takes a Charset as its argument, you might be interested in it if you want to load UTF-8 encoded resources files", "label": {"api": {"ResourceBundle.Control": [[10, 31]], "Charset": [[47, 53]]}}}, {"text": "If the browser can't handle the URI, browse launches \"the application registered for handling URIs of the specified type is invoked\"", "label": {"api": {"browse": [[7, 12], [37, 42]]}}}, {"text": "Check your favourite browser exists (Chrome, Fx, O, IE, etc) or get it by some other method, and then execute a custom command", "label": {"api": {"browse": [[21, 26]]}}}, {"text": "The JavaFX replacement for the awt Desktop.browse method would be HostServices.showDocument", "label": {"api": {"HostServices.showDocument": [[66, 90]]}}}, {"text": "Another alternative is to load the XML and perform the XSL transform in Java, then display the resulting document in a JavaFX WebView using webview.getEngine.loadContent(contentString, contentType) or just display the resultant document in a Label or custom JavaFX control", "label": {"api": {"webview.getEngine.loadContent(contentString, contentType)": [[140, 196]]}}}, {"text": "%> you're basically declaring an instance variable, so it get initialized during instantiation, however ServletContext is only available by getServletContext() after the init(ServletConfig) has been called", "label": {"api": {"init(ServletConfig)": [[170, 188]]}}}, {"text": "In case it is a file you want to open, you can use Desktop#open which will open the File with the default application", "label": {"api": {"Desktop#open": [[51, 62]]}}}, {"text": "Of course it will be better to test before if the directory exists and is writable", "label": {"api": {"is writable": [[71, 81]]}}}, {"text": "Without having it tested, the IDN class might be of help", "label": {"api": {"IDN": [[30, 32]]}}}, {"text": "ExternalContext.getSession(boolean) will invoke HttpServletRequest.getSession(boolean)", "label": {"api": {"ExternalContext.getSession(boolean)": [[0, 34]], "HttpServletRequest.getSession(boolean)": [[48, 85]]}}}, {"text": "This instance has a method getEncoded() that has the following description", "label": {"api": {"getEncoded()": [[27, 38]]}}}, {"text": "The best way to deal with this is to set Pattern.MULTILINE", "label": {"api": {"Pattern.MULTILINE": [[41, 57]]}}}, {"text": "They are mostly interchangeable, but keep in mind TreeSet is also a SortedSet and thus its elements must implement Comparable", "label": {"api": {"SortedSet": [[68, 76]]}}}, {"text": "Use toArray(T[]) as", "label": {"api": {"toArray(T[])": [[4, 15]]}}}, {"text": "Relative paths (when using java.io.File), are relative to the working directory", "label": {"api": {"java.io.File": [[27, 38]]}}}, {"text": "Check the syntax for Formatter especially the Numeric sub-title", "label": {"api": {"syntax for Formatter": [[10, 29]]}}}, {"text": "For regular expression, look toward this link", "label": {"api": {"this link": [[36, 44]]}}}, {"text": "The docs say that keySet() (for a Collections.synchronizedMap) \"Needn't be in synchronized block\"", "label": {"api": {"docs say": [[4, 11]]}}}, {"text": "Instead, you should consider switching to using a ConcurrentHashMap which does all of the right things there", "label": {"api": {"ConcurrentHashMap": [[50, 66]]}}}, {"text": "Iterating over a collection view in CHM (like keySet()) gives useful concurrent behavior (\"weakly consistent\" iterators)", "label": {"api": {"like keySet()": [[41, 53]]}}}, {"text": "You want to use addPopupMenuListener which uses the following interface", "label": {"api": {"addPopupMenuListener": [[16, 35]]}}}, {"text": "As an alternative you could consider using DefaultMutableTreeNode which provides these methods for free (depthFirstEnumeration(), breadthFirstEnumeration())", "label": {"api": {"DefaultMutableTreeNode": [[43, 64]], "depthFirstEnumeration()": [[105, 127]], "breadthFirstEnumeration()": [[130, 154]]}}}, {"text": "This node implementation also allows you to attach a user object by calling setUserObject(Object)", "label": {"api": {"setUserObject(Object)": [[76, 96]]}}}, {"text": "You could use a CountDownLatch", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "See the specification for ObjectOutputStream.reset()..", "label": {"api": {"ObjectOutputStream.reset()": [[26, 51]]}}}, {"text": "You would want to use BigDecimal.compareTo() to help accomplish that", "label": {"api": {"BigDecimal.compareTo()": [[22, 43]]}}}, {"text": "Although this may not resolve your problem, i think having a look at the DateFormatter class would be very helpful for your case", "label": {"api": {"DateFormatter": [[73, 85]]}}}, {"text": "I looked at http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/Integer.html in an attempt to figure it out but I THINK my code is correct", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/Integer.html": [[12, 78]]}}}, {"text": "Use a Set (HashSet) whose size will give you what you are looking for", "label": {"api": {"HashSet": [[11, 17]]}}}, {"text": "+ operator with character constant 'G' + 'o' prints addition of charCode and string concatenation operator with \"G\" + \"o\" will prints Go", "label": {"api": {"string concatenation operator": [[77, 105]]}}}, {"text": "You will have to use the String.valueOf(char c) to convert that character back to a string", "label": {"api": {"String.valueOf(char c)": [[25, 46]]}}}, {"text": "I suggest you use a List<String> (such as ArrayList<String>) and a Scanner (construct it using new Scanner(new File(\"wordfile.txt\")), and use scanner.hasNextLine()/scanner.nextLine()) to read the words", "label": {"api": {"ArrayList<String>": [[42, 58]], "new Scanner(new File(\"wordfile.txt\"))": [[95, 131]], "scanner.hasNextLine()": [[142, 162]], "scanner.nextLine()": [[164, 181]]}}}, {"text": "If you indeed need it to be an array, go through list.toArray in the end", "label": {"api": {"list.toArray": [[49, 60]]}}}, {"text": "To read the file you can take a look at the Scanner Class, this will allow you to iterate over the contents of your text file", "label": {"api": {"Scanner Class": [[44, 56]]}}}, {"text": "Although what you want to do is possible to achieve with an array data structure, it is not advisable, using something such as an ArrayList will allow you to have a dynamic data structure which can then, if you want, be changed to an array using the toArray() method", "label": {"api": {"ArrayList": [[130, 138]], "toArray()": [[250, 258]]}}}, {"text": "The Memory MX Bean will give you all non-heap usage, of which the perm gen is a part", "label": {"api": {"Memory MX Bean": [[4, 17]]}}}, {"text": "The size of the perm gen pool itself should be available using the Memory Pool MX Bean, but be aware that the names of the pools are implementation and GC-dependent", "label": {"api": {"Memory Pool MX Bean": [[67, 85]]}}}, {"text": "The Pattern class has a pretty thorough description of the possible character classes", "label": {"api": {"Pattern class": [[4, 16]]}}}, {"text": "Note that there's the UNICODE_CHARACTER_CLASS flag that changes the behavior of the POSIX classes to conform to this section of the Unicode Standard (basically making them equivalent to their closest Unicode-aware equivalents)", "label": {"api": {"UNICODE_CHARACTER_CLASS flag": [[22, 49]]}}}, {"text": "The sender should use a BufferedOutputStream (in the middle) to make big chunks before sending (and use flush only when it's needed)", "label": {"api": {"BufferedOutputStream": [[24, 43]]}}}, {"text": "An alternative could be using BigDecimal", "label": {"api": {"BigDecimal": [[30, 39]]}}}, {"text": "Check the API for returning results of getBasicConstraints() method", "label": {"api": {"API": [[10, 12]]}}}, {"text": "The built-in no-argument Supplier interface can be used as the wrapper for the callback", "label": {"api": {"Supplier": [[25, 32]]}}}, {"text": "You should be using the Equals method for Strings", "label": {"api": {"Equals": [[24, 29]]}}}, {"text": "OutOfMemoryError is just like any other error", "label": {"api": {"OutOfMemoryError": [[0, 15]]}}}, {"text": "Of course you can also try catching OutOfMemoryError and handling it somehow", "label": {"api": {"OutOfMemoryError": [[36, 51]]}}}, {"text": "Read from the stdin, for example, using Scanner", "label": {"api": {"Scanner": [[40, 46]]}}}, {"text": "You can think of using addBatch() and executing a back of statements in one shot", "label": {"api": {"addBatch()": [[23, 32]]}}}, {"text": "Get a NumberFormat instance for a Portuguese Locale, and then parse the number with it", "label": {"api": {"NumberFormat": [[6, 17]], "Locale": [[45, 50]]}}}, {"text": "If your look at collection framework you will see the following, but Map is not in the list of interfaces", "label": {"api": {"collection framework": [[16, 35]]}}}, {"text": "While we talk about map we say it is a part of collection framework, so if Map is a part of collection framework then why it is not in the interfaces list", "label": {"api": {"collection framework": [[47, 66], [92, 111]]}}}, {"text": "You can use a SwingWorker here", "label": {"api": {"SwingWorker": [[14, 24]]}}}, {"text": "\"publish()\" should be called in \"doInBackground()\" to pass the data to \"process()\"", "label": {"api": {"publish(": [[1, 8]]}}}, {"text": "Use a JTabbedPane See How to Use Tabbed Panes for details", "label": {"api": {"JTabbedPane": [[6, 16]]}}}, {"text": "In Java EE 6 you have handy @Schedule annotation", "label": {"api": {"@Schedule annotation": [[28, 47]]}}}, {"text": "2012/02/16) and use a SortedSet", "label": {"api": {"SortedSet": [[22, 30]]}}}, {"text": "You don't need to create a 2D array - see DefaultTableModel.addColumn", "label": {"api": {"DefaultTableModel.addColumn": [[42, 68]]}}}, {"text": "Finally, note that if you use threads, you will be sharing the list in your runnable across threads (the worker thread and the main thread) and you will need to use a thread safe structure to make that possible - for example, by using a CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[237, 256]]}}}, {"text": "This is why when i design swing gui, i prefer to use first the BorderLayout and then the  MigLayout (for more complex panel)", "label": {"api": {"BorderLayout": [[63, 74]]}}}, {"text": "You might want to check the indexOf() method of ArrayList, but you have to be careful when removing from a list while iterating on it's elements", "label": {"api": {"indexOf()": [[28, 36]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html) I would assume that it would have to be something like", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html": [[0, 64]]}}}, {"text": "Better yet, if the homework allows you to use standard library, take a look at a built-in way of sorting arrays in Java", "label": {"api": {"built-in way of sorting arrays in Java": [[81, 118]]}}}, {"text": "Just use List's toArray method, and cast it appropriately", "label": {"api": {"List": [[9, 12]]}}}, {"text": "If you're using newer versions of java, use ByteBuffer objects", "label": {"api": {"ByteBuffer": [[44, 53]]}}}, {"text": "Call ByteBuffer.allocateDirect() to allocate the buffer", "label": {"api": {"ByteBuffer": [[5, 14]]}}}, {"text": "I want to be able to set the TCP socket KEEPALIVE parameters (TCP_KEEPIDLE, TCP_KEEPINTVL, and TCP_KEEPCNT) but these don't appear to be available in the Socket class", "label": {"api": {"Socket": [[154, 159]]}}}, {"text": "Based on the documentation of the SocketImpl and SocketOptions classes along with the bit about implementation details at the bottom of this page, I'm led to the conclusion that the library implementers hard coded the \"level\" argument of setsockopt to SOL_SOCKET, which makes it impossible to access options at other levels such as SOL_TCP/IPPROTO_TCP", "label": {"api": {"Socket": [[34, 39], [49, 54]], "SocketImpl": [[34, 43]], "SocketOptions": [[49, 61]], "this page": [[136, 144]]}}}, {"text": "If not, is there any way to get the raw file descriptor number so that I can pass it through JNI to a bit of C code that calls setsockopt directly since it doesn't seem to be available from FileDescriptor", "label": {"api": {"FileDescriptor": [[190, 203]]}}}, {"text": "This means that you shouldn't hard-code the separator, but use File.separator instead", "label": {"api": {"File.separator": [[63, 76]], "File": [[63, 66]]}}}, {"text": "Also, using File and not making any assumptions about your environment will help you out as well", "label": {"api": {"File": [[12, 15]]}}}, {"text": "Yes, you should be fine using FileUtils and searching for MP3 files in that manner", "label": {"api": {"File": [[30, 33]]}}}, {"text": "You could shorten the code a bit leaving out the unnecessary DataInputStream, and you might use a FileReader instead", "label": {"api": {"FileReader": [[98, 107]]}}}, {"text": "The reason why your query only returns the doctors information (and not the patient's information) is because for a OneToMany relation, FetchType by default is set to LAZY, if you specify fetch type to be EAGER, hibernate will also return patients", "label": {"api": {"for a OneToMany relation, FetchType by default is set to LAZY": [[110, 170]]}}}, {"text": "A simple start would be using a Timer to schedule the periodic job and a TimerTask to implement the business logic", "label": {"api": {"Timer": [[32, 36], [73, 77]], "TimerTask": [[73, 81]]}}}, {"text": "I'm implementing a serlvet that, using AsyncContext, can send messages back to the client asynchronously", "label": {"api": {"AsyncContext": [[39, 50]]}}}, {"text": "MessageTask is a runnable that grabs the AsyncContext that has been added to a hash map (using the session ID), writes the message, completes the context, and cancels the task on success", "label": {"api": {"AsyncContext": [[41, 52]]}}}, {"text": "If you just need to read several files concatenated into a single stream, you could also use SequenceInputStream", "label": {"api": {"SequenceInputStream": [[93, 111]]}}}, {"text": "My best suggestion would be to use a ReadWriteLock but as you specifically state that you don't want to use any locks (btw ConcurrentHashMap will probably use them internally) you could try the following", "label": {"api": {"ReadWriteLock": [[37, 49]]}}}, {"text": "Use an AtomicReference to each of your maps and when the time comes to log their contents use getAndSet to replace the old map with a brand new empty one", "label": {"api": {"AtomicReference": [[7, 21]], "getAndSet": [[94, 102]]}}}, {"text": "Yes, you can use UIComponent#getFacets() to get a mapping of all facets by their name", "label": {"api": {"UIComponent#getFacets()": [[17, 39]]}}}, {"text": "If your intent was to replace all instances of a particular type with a subtype, then you can consider using java agents", "label": {"api": {"java agents": [[109, 119]]}}}, {"text": "You just need to call HttpURLConnection.getInputStream() and read your xml data from there", "label": {"api": {"HttpURLConnection.getInputStream()": [[22, 55]]}}}, {"text": "With the information you have given here so far, I believe that to solve your problem you will need to use java.util.zip.ZipFile", "label": {"api": {"java.util.zip.ZipFile": [[107, 127]]}}}, {"text": "Components are painted with their paint method", "label": {"api": {"paint": [[15, 19], [34, 38]]}}}, {"text": "repaint is just a useful method that will call paint at some point in the near future on the Event Dispatch Thread", "label": {"api": {"paint": [[2, 6], [47, 51]]}}}, {"text": "ButtonModel.setRollover will fire a ChangeEvent, which is handled by AbstractButton in the following way", "label": {"api": {"ButtonModel.setRollover": [[0, 22]]}}}, {"text": "So repaint is called when the mouse enters a JButton", "label": {"api": {"paint": [[5, 9]]}}}, {"text": "Note that the paint() method that gets called belongs to the button's UI delegate, typically derived from BasicButtonUI", "label": {"api": {"BasicButtonUI": [[106, 118]]}}}, {"text": "Memory mapped IO and DoubleBuffers", "label": {"api": {"DoubleBuffer": [[21, 32]]}}}, {"text": "You can make your own custom LookAndFeel [tutorial] for your applications", "label": {"api": {"LookAndFeel": [[29, 39]]}}}, {"text": "In order to access an element from a List, you need to use the get method", "label": {"api": {"get": [[63, 65]]}}}, {"text": "Object has a toString() method, so everything (except primitive types) has a toString() method", "label": {"api": {"toString()": [[13, 22], [77, 86]]}}}, {"text": "Class C implements My but it also extends Object, as all objects eventually do in their inheritance tree", "label": {"api": {"Object": [[42, 47]]}}}, {"text": "The Object class does have the method toString(), along with a number of others", "label": {"api": {"Object": [[4, 9]]}}}, {"text": "According to the specification, GZIPInputStream is a subclass of InflaterInputStream", "label": {"api": {"GZIPInputStream": [[32, 46]], "InflaterInputStream": [[65, 83]], "Inflater": [[65, 72]]}}}, {"text": "InflaterInputStream has a protected Inflater inf field that is the Inflater used for the decompression work", "label": {"api": {"InflaterInputStream": [[0, 18]], "protected Inflater inf": [[26, 47]], "Inflater": [[0, 7], [36, 43], [67, 74]]}}}, {"text": "Inflater.getBytesRead should be particularly useful for your purposes", "label": {"api": {"Inflater": [[0, 7]], "Inflater.getBytesRead": [[0, 20]]}}}, {"text": "Unfortunately, GZIPInputStream does not expose inf, so probably you'll have to create your own subclass and expose the Inflater, e.g", "label": {"api": {"GZIPInputStream": [[15, 29]], "Inflater": [[119, 126]]}}}, {"text": "Just let worker thread to be daemon", "label": {"api": {"thread to be daemon": [[16, 34]]}}}, {"text": "Another approach is to interrupt() your thread when closing the main window, but that requires handling of isInterrupted() and InterruptedException", "label": {"api": {"interrupt()": [[23, 33]], "isInterrupted()": [[107, 121]]}}}, {"text": "Once you have the time in milliseconds you can use the TimeUnit enum to convert it to other time units", "label": {"api": {"TimeUnit": [[55, 62]]}}}, {"text": "The JMenuBar does not start showing JMenuItems as selected or displaying the JMenu popups until it is first clicked upon", "label": {"api": {"JMenuItem": [[36, 44]], "JMenu": [[4, 8], [36, 40], [77, 81]], "JMenuBar": [[4, 11]]}}}, {"text": "After you click somewhere in the JMenuBar, all these items respond to mouse hovers", "label": {"api": {"JMenu": [[33, 37]], "JMenuBar": [[33, 40]]}}}, {"text": "My version of java doesn't even have collections, and this documentation says that the method is not overloaded, it only takes Objects", "label": {"api": {"this documentation": [[54, 71]]}}}, {"text": "The easiest way would be to use String#replaceAll(), replacing spaces with ,", "label": {"api": {"String#replaceAll()": [[32, 50]]}}}, {"text": "Profiling means instrumenting your classes and methods, so they \"report\" whenever they are run", "label": {"api": {"instrumenting": [[16, 28]]}}}, {"text": "You can use DatatypeFactory.newInstance() to instantiate first, like so", "label": {"api": {"DatatypeFactory.newInstance()": [[12, 40]]}}}, {"text": "You can use Collections.retainAll using the ArrayLists", "label": {"api": {"Collections.retainAll": [[12, 32]]}}}, {"text": "If you want how many milliseconds two Date values differ by, that's really easy using Date.getTime", "label": {"api": {"Date.getTime": [[86, 97]]}}}, {"text": "An alternative is to use MessageFormat.format(\"Some {0}, {1}, {2}\", var1, var2, var3), which uses the .NET curly braces notation, as mentioned by @Tobias, though it requires you to import java.text.MessageFormat", "label": {"api": {"java.text.MessageFormat": [[188, 210]]}}}, {"text": "What you are looking for is MessageFormat, which uses a given format and input parameters, e.g", "label": {"api": {"MessageFormat": [[28, 40]]}}}, {"text": "And as already mentioned, String.format can still do the job using the alternate syntax, but it is less powerful in functionality and not what you requested", "label": {"api": {"String.format": [[26, 38]]}}}, {"text": "You can create your own NodeList class and implements Iterable", "label": {"api": {"Iterable": [[54, 61]]}}}, {"text": "If you want a Set<K> that is backed by a ConcurrentHashMap, you should use Collections.newSetFromMap, e.g", "label": {"api": {"Collections.newSetFromMap": [[75, 99]]}}}, {"text": "Implement a toString method", "label": {"api": {"toString": [[12, 19]]}}}, {"text": "toString is a method on Object, so every java object inherits one", "label": {"api": {"toString": [[0, 7]]}}}, {"text": "In your own classes, to get the description that you want you'll need to override the toString method, so that in contexts where a String is expected, e.g", "label": {"api": {"toString": [[86, 93]]}}}, {"text": "when you call System.out.println(myObject.toString());, your own format is used", "label": {"api": {"toString": [[42, 49]]}}}, {"text": "You can always call super.toString to include the output from the default - ClassName@HashCode - in your own output", "label": {"api": {"toString": [[26, 33]]}}}, {"text": "You are adding an undefined JPanel object to your JFrame, resulting in a NullPointerException, as is noted in the Container#add(Component) documentation", "label": {"api": {"Container#add(Component)": [[114, 137]]}}}, {"text": "If each row has two values, where the first one is the term and the second one is the definition, you could build a Map of it like this (Btw, this while loop does the exact same thing as your for loop)", "label": {"api": {"Map": [[116, 118]]}}}, {"text": "You could just use a JLabel to label your textfields", "label": {"api": {"JLabel": [[21, 26]]}}}, {"text": "As for layout, to force a separate line, you use use a Box", "label": {"api": {"Box": [[55, 57]]}}}, {"text": "As for your first question, you can use String#indexOf(int) to get the index of every 'o' in your string", "label": {"api": {"String#indexOf(int)": [[40, 58]]}}}, {"text": "As for your second question, it is possible to get all positions of a given char by making a method which uses String.indexOf(int, int), tracking the previous index so that you don't repeat searched portions of the string", "label": {"api": {"String.indexOf(int, int)": [[111, 134]]}}}, {"text": "You can add an ActionListener to your button which, upon action being performed, exits from the JVM", "label": {"api": {"ActionListener": [[15, 28]]}}}, {"text": "You might want to check the public String replaceAll(String regex, String replacement) method in String", "label": {"api": {"public String replaceAll(String regex, String replacement)": [[28, 85]]}}}, {"text": "The GregorianCalendar class inherits its get method from Calendar, which has the following side effect", "label": {"api": {"GregorianCalendar": [[4, 20]], "get": [[41, 43]]}}}, {"text": "This means that the time value and all fields are recomputed when get is called on a Calendar object", "label": {"api": {"get": [[66, 68]]}}}, {"text": "I use the javax.swing.Timer on a regular basis, and it works great for consistent animations", "label": {"api": {"javax.swing.Timer": [[10, 26]]}}}, {"text": "Usually that involves updating the state of whatever object you need and calling repaint() on the Panel involved", "label": {"api": {"repaint()": [[81, 89]]}}}, {"text": "MessageFormat.format does that", "label": {"api": {"MessageFormat.format": [[0, 19]]}}}, {"text": "You have to implement a TableCellEditor not a TableCellRenderer and set it with JTable.setCellEditor(TableCellEditor)", "label": {"api": {"JTable.setCellEditor(TableCellEditor)": [[80, 116]]}}}, {"text": "You never read from the DigestInputStream", "label": {"api": {"read from the DigestInputStream": [[10, 40]]}}}, {"text": "ConcurrentMap.replace will then do what you want (or use AtomicInteger to ease your code)", "label": {"api": {"ConcurrentMap.replace": [[0, 20]], "AtomicInteger": [[57, 69]]}}}, {"text": "If your threads will only change the values (and not add/change the keys) of your map, then you can use a standard map storing thread safe values like AtomicInteger", "label": {"api": {"AtomicInteger": [[151, 163]]}}}, {"text": "Even the simplest HashMap is threadsafe for concurrent reads, given the map is not mutated anymore", "label": {"api": {"HashMap": [[18, 24]]}}}, {"text": "See javadoc for hashCode() for more info on this", "label": {"api": {"javadoc for hashCode()": [[4, 25]]}}}, {"text": "Unless this is an exercise in implementing an event scheduler, you're better off using ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[87, 110]]}}}, {"text": "As an alternative, use BufferedImage#getSubimage() to divide the image into congruent pieces, as shown here", "label": {"api": {"BufferedImage#getSubimage()": [[23, 49]]}}}, {"text": "I'm not (too) with the Clojure syntax, but you should invoke socket.setReuseAddr(true)", "label": {"api": {"socket.setReuseAddr(true)": [[61, 85]]}}}, {"text": "No, loading properties from a File via Reader or via InputStream does not care what the name of the underlying file is (in fact there doesn't have to be an underlying File at all)", "label": {"api": {"via Reader": [[35, 44]], "via InputStream": [[49, 63]]}}}, {"text": "The only difference is that only .properties files are picked up automatically by the PropertyResourceBundle mechanism", "label": {"api": {"PropertyResourceBundle": [[86, 107]]}}}, {"text": "ArrayList doesn't have constructor with custom object", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "You should use isAssignableFrom", "label": {"api": {"isAssignableFrom": [[15, 30]]}}}, {"text": "I don't see any reason to create a new EntityManager for every transaction", "label": {"api": {"EntityManager": [[39, 51]]}}}, {"text": "You should be able to inject your EntityManager using @PersistenceContext", "label": {"api": {"EntityManager": [[34, 46]], "@PersistenceContext": [[54, 72]]}}}, {"text": "There is com.sun.security.auth.module.LdapLoginModule in JDK for this purpose", "label": {"api": {"com.sun.security.auth.module.LdapLoginModule": [[9, 52]]}}}, {"text": "First of all, here's the behavior added by Java 7's Collections.checked*", "label": {"api": {"Java 7's Collections.checked*": [[43, 71]]}}}, {"text": "Maybe you are interested in this answer or, if you classes are split over several jars you want to keep independent, the ServiceLoader mechanism might o the trick for you", "label": {"api": {"ServiceLoader mechanism": [[121, 143]]}}}, {"text": "Use a Matcher with capturing groups", "label": {"api": {"Matcher": [[6, 12]]}}}, {"text": "Or an easier way, using java.util.Scanner, with the delimiter set to ::?", "label": {"api": {"java.util.Scanner": [[24, 40]]}}}, {"text": "I would used the Scanner to read a single line of input, look into nextLine()", "label": {"api": {"nextLine()": [[67, 76]]}}}, {"text": "Then I would split the line that came back from the scanner by spaces, you can do this manually with a loop and indexOf(...) and substring(...) and store it in an array you created, or we can use the split() to have the built-in Java String functions handle that part for us", "label": {"api": {"split()": [[200, 206]]}}}, {"text": "PrintStream (class of stdout) has a write method which could be called to write a byte[] to stdout", "label": {"api": {"PrintStream": [[0, 10]]}}}, {"text": "Also, I don't know much about it, but the new JDK7 has some new NIO apis which might possibly do the job also", "label": {"api": {"new NIO apis": [[60, 71]]}}}, {"text": "Try adjusting Component.getAlignmentY that controls the positioning of component relative to the text baseline as suggested in ComponentView", "label": {"api": {"ComponentView": [[127, 139]]}}}, {"text": "Components can be added using insertComponent() method", "label": {"api": {"insertComponent()": [[30, 46]]}}}, {"text": "You can use a Pattern as the argument to Scanner.useDelimiter", "label": {"api": {"Scanner.useDelimiter": [[41, 60]]}}}, {"text": "If you're trying to perform the same operation a 1000 times, I would advise re-using the same PreparedStatement or using addBatch() and executeBatch() combo", "label": {"api": {"addBatch()": [[121, 130]], "executeBatch()": [[136, 149]]}}}, {"text": "Events are dispatched from an EventListenerList, owned by the parent JComponent, using a convention outlined in the API and discussed here", "label": {"api": {"EventListenerList": [[30, 46]], "API": [[116, 118]]}}}, {"text": "Although a chart is not itself a JComponent, it uses the same model for its own events", "label": {"api": {"same model": [[57, 66]]}}}, {"text": "Also try using AtomicLong 's addAndGet method instead of the synchronized add method", "label": {"api": {"AtomicLong": [[15, 24]]}}}, {"text": "I think this is a good example to use String.format because %n always uses the system specific line seperator", "label": {"api": {"String.format": [[38, 50]]}}}, {"text": "Why doesn't the  ConcurrentSkipListMap constructors allow us to set the initial capacity like HashMap does", "label": {"api": {"ConcurrentSkipListMap": [[17, 37]], "HashMap": [[94, 100]]}}}, {"text": "Because this data structure is backed by multiple LinkedList for whom an initial capacity constructor parameter has no meaning", "label": {"api": {"LinkedList": [[50, 59]]}}}, {"text": "If you override paintComponent, you can clear its Graphics using Graphics#clearRect", "label": {"api": {"Graphics#clearRect": [[65, 82]]}}}, {"text": "Since you seem to need a queue, why don't you use one, like ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[60, 77]]}}}, {"text": "It has a take method which will block, without consuming CPU cycles, until an item gets added to the queue", "label": {"api": {"take method": [[9, 19]]}}}, {"text": "If you don't know the bean scope beforehand and/or when the bean isn't created beforehand, then you'd need to create an utility EL function which does an Application#evaluateExpressionGet(), so that it can be used something like as follows", "label": {"api": {"Application#evaluateExpressionGet()": [[154, 188]]}}}, {"text": "If acquisition will impose a delay, use an instance of SwingWorker, as shown in the API or in this example", "label": {"api": {"SwingWorker": [[55, 65]], "API": [[84, 86]]}}}, {"text": "I would use a BufferedReader, and loop while the readline method does not return null", "label": {"api": {"BufferedReader": [[14, 27]]}}}, {"text": "I would start by looking at the javax.swing.border.Border class", "label": {"api": {"javax.swing.border.Border class": [[32, 62]]}}}, {"text": "Every Swing class which extends javax.swing.JComponent has a setBorder() method", "label": {"api": {"javax.swing.JComponent": [[32, 53]], "setBorder() method": [[61, 78]]}}}, {"text": "I strongly suggest that you familiarize yourself with the Java API documentation", "label": {"api": {"Java API documentation": [[58, 79]]}}}, {"text": "You haven't shown how you're using matcher, but I'm guessing that you're using its matches() method when what you really want is its find() method", "label": {"api": {"its matches() method": [[79, 98]], "its find() method": [[129, 145]]}}}, {"text": "A jar is just a zip file with a different extension (and a manifest), so you might as well be interested by zip libraries like zip4j or java.util.zip", "label": {"api": {"java.util.zip": [[136, 148]]}}}, {"text": "For instance, to do this with the Java SE String class, which is in the java.lang package", "label": {"api": {"String": [[42, 47]]}}}, {"text": "In Callable<V>, the parameterized type V stands for the result type of call()", "label": {"api": {"Callable<V>": [[3, 13]], "call()": [[71, 76]]}}}, {"text": "Use Process.getOutputStream() to write to the child process's input stream", "label": {"api": {"Process.getOutputStream()": [[4, 28]]}}}, {"text": "Use Process.getInputStream() to read from the child process's output stream", "label": {"api": {"Process.getInputStream()": [[4, 27]]}}}, {"text": "The exampe below shows a managed bean named ExampleManagedBean using the EJB annotation to inject a stateless session bean that implements an interface named CustomerBeanLocal", "label": {"api": {"EJB annotation": [[73, 86]]}}}, {"text": "Use SimpleDateFormat and make sure it doesn't use lenient parsing", "label": {"api": {"SimpleDateFormat": [[4, 19]], "lenient": [[50, 56]]}}}, {"text": "The MouseWheelEvent passed to MouseWheelListener.mouseWheelMoved contains a few properties that you should take into consideration beyond the time between events", "label": {"api": {"MouseWheelListener.mouseWheelMoved": [[30, 63]]}}}, {"text": "The number of clicks, as returned from MouseWheelEvent.getPreciseWheelRotation", "label": {"api": {"MouseWheelEvent.getPreciseWheelRotation": [[39, 77]]}}}, {"text": "The amount the user wants to scroll per click, as returned by MouseWheelEvent.getScrollAmount", "label": {"api": {"MouseWheelEvent.getScrollAmount": [[62, 92]]}}}, {"text": "Note that, unless MouseWheelEvent.getScrollType", "label": {"api": {"MouseWheelEvent.getScrollType": [[18, 46]]}}}, {"text": "Unless this method returns MouseWheelEvent.WHEEL_UNIT_SCROLL, MouseWheelEvent.getScrollAmount returns an undefined value", "label": {"api": {"MouseWheelEvent.getScrollAmount": [[62, 92]]}}}, {"text": "The first of these methods, MouseWheelEvent.getPreciseWheelRotation, returns the number of clicks that the user rotated the mouse, taking high-resolution mice and trackpads into account", "label": {"api": {"MouseWheelEvent.getPreciseWheelRotation": [[28, 66]]}}}, {"text": "The second of these methods, MouseWheelEvent.getScrollAmount, tells the system setting that the user's operating system uses for scroll speed", "label": {"api": {"MouseWheelEvent.getScrollAmount": [[29, 59]]}}}, {"text": "And of course, you should keep the time of the last scroll event (you can use System.currentTimeMillis() or System.nanoTime() to measure time deltas), and shorter intervals between scroll events typically mean faster scrolling", "label": {"api": {"System.currentTimeMillis()": [[78, 103]], "System.nanoTime()": [[108, 124]]}}}, {"text": "You can achieve #2 very easily, since assert throws an AssertionError", "label": {"api": {"AssertionError": [[55, 68]]}}}, {"text": "You use URL and/or URLConnection, download the file, save it somewhere (current working directory, or a temp directory, for example), then execute it using the Runtime.getRuntime().exec()", "label": {"api": {"URL": [[8, 10], [19, 21]], "URLConnection": [[19, 31]]}}}, {"text": "Try to use the getErrorOffset()", "label": {"api": {"getErrorOffset()": [[15, 30]]}}}, {"text": "A profiler performs \"instrumentation\" on all (or a subset of) the classes loaded by the profiled JVM to perform exactly what you need", "label": {"api": {"\"instrumentation\"": [[20, 36]]}}}, {"text": "You can use BigDecimal for this", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "Because if you pass in a double, you will also pass in double's inaccuracy into the new BigDecimal instance", "label": {"api": {"BigDecimal": [[88, 97]]}}}, {"text": "If you pass in a String, BigDecimal will know™ and do the right thing™", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "How about BigDecimal", "label": {"api": {"BigDecimal": [[10, 19]]}}}, {"text": "That said, the class you're looking for is DataInputStream", "label": {"api": {"DataInputStream": [[43, 57]]}}}, {"text": "(documentation for readInt())", "label": {"api": {"readInt()": [[19, 27]]}}}, {"text": "Check out the source code of HessianProxy.sendRequest() - it uses standard URLConnection to connect to server and does not handle any cookies", "label": {"api": {"URLConnection": [[75, 87]]}}}, {"text": "You can subclass ScheduledThreadPoolExecutor and override the afterExecute(Runnable,Throwable) method", "label": {"api": {"afterExecute(Runnable,Throwable)": [[62, 93]]}}}, {"text": "As far as I can see, the only guarantee provided by ConcurrentMap is", "label": {"api": {"ConcurrentMap": [[52, 64]]}}}, {"text": "Actions in a thread prior to placing an object into a ConcurrentMap as a key or value happen-before actions subsequent to the access or removal of that object from the ConcurrentMap in another thread", "label": {"api": {"ConcurrentMap": [[54, 66], [168, 180]]}}}, {"text": "Instead, I suggest just using JAXP to produce your output", "label": {"api": {"JAXP": [[30, 33]]}}}, {"text": "Use String#matches() instead", "label": {"api": {"String#matches()": [[4, 19]]}}}, {"text": "If you need to capture the numbers, use Pattern and Matcher", "label": {"api": {"Pattern": [[40, 46]], "Matcher": [[52, 58]]}}}, {"text": "() is a capturing group, meaning it will tell the regex engine to store the matched content, so that you can retrieve it later with group()", "label": {"api": {"group()": [[132, 138]]}}}, {"text": "UriInfo is the class you're looking for", "label": {"api": {"UriInfo": [[0, 6]]}}}, {"text": "You can either prevent the symlinks to be displayed by using a FileFilter and the FileUtils from Apache Commons", "label": {"api": {"FileFilter": [[63, 72]]}}}, {"text": "An other alternative is to use a custom FileSystemView, as @Andrew Thompson suggested", "label": {"api": {"FileSystemView": [[40, 53]]}}}, {"text": "You can use a Deque which allows you to add to the start or the end", "label": {"api": {"Deque": [[14, 18]]}}}, {"text": "the Formatter class (the functionality behind String.format()) has a very powerful formatting syntax (much more powerful than MessageFormat)", "label": {"api": {"Formatter": [[4, 12]]}}}, {"text": "If you can switch to java.util.Console, you could do something like this", "label": {"api": {"java.util.Console": [[21, 37]]}}}, {"text": "Instead, use a PreparedStatement and insert the value as a java.sql.Date or possibly a java.sql.Timestamp via a parameter", "label": {"api": {"PreparedStatement": [[15, 31]], "java.sql.Date": [[59, 71]], "java.sql.Timestamp": [[87, 104]]}}}, {"text": "Instead of creating the SQL by concatenating strings (which is the problem here, as Java's string representation of date is surely not understood by Postgres), use PreparedStatement and pass the date as a parameter", "label": {"api": {"PreparedStatement": [[164, 180]]}}}, {"text": "Instead, create a PreparedStatement and set the parameters on it", "label": {"api": {"PreparedStatement": [[18, 34]]}}}, {"text": "Note that the Date there is a java.sql.Date, which is a subclass of the normal java.util.Date in which the time of day is always midnight UTC; it is used to represent an actual date, not a moment in time", "label": {"api": {"java.sql.Date": [[30, 42]]}}}, {"text": "You can alternatively use a java.sql.Timestamp, which represents a moment in time", "label": {"api": {"java.sql.Timestamp": [[28, 45]]}}}, {"text": "No, HashTable is thread-safe on method level (multiple threads can call any method at any time) but there is no cross-method synchronization", "label": {"api": {"HashTable": [[4, 12]]}}}, {"text": "I chose to use a JList to represent my file paths instead of a single column table", "label": {"api": {"JList": [[17, 21]]}}}, {"text": "The only real reason that I had wanted to use the JTable was because of the appearance of the lined rows that a table has, and because of my unfamiliarity with JList", "label": {"api": {"JList": [[160, 164]]}}}, {"text": "I discovered how to edit the appearance of the JList by extending the DefaultListCellRenderer", "label": {"api": {"JList": [[47, 51]], "DefaultListCellRenderer": [[70, 92]]}}}, {"text": "Because I now knew about editing the appearance, the JList's natural resizing and scroll behavior made it a much more natural fit to my needs", "label": {"api": {"JList": [[53, 57]]}}}, {"text": "The JavaDocs for DataInputStream.read(byte[]) and InputStream(byte[]) state pretty clearly that the method will read \"some number of bytes\" up to the length of the byte array", "label": {"api": {"DataInputStream.read(byte[]) and InputStream(byte[])": [[17, 68]]}}}, {"text": "So I am writing an AnnotationProcessor and in the process method you are given a TypeElement", "label": {"api": {"TypeElement": [[81, 91]]}}}, {"text": "I need to check if the TypeElement is an interface or a class", "label": {"api": {"TypeElement": [[23, 33]]}}}, {"text": "You can use ViewDeclarationLanguage#buildView() for this", "label": {"api": {"ViewDeclarationLanguage#buildView()": [[12, 46]]}}}, {"text": "Take any actions specific to this VDL implementation to cause the argument UIViewRoot which must have been created via a call to createView(javax.faces.context.FacesContext, java.lang.String), to be populated with children", "label": {"api": {"createView(javax.faces.context.FacesContext, java.lang.String)": [[129, 190]]}}}, {"text": "You can by the way also use the ViewDeclarationLanguage#createView() directly to create the view instead of the ViewHandler#createView() shorthand", "label": {"api": {"ViewDeclarationLanguage#createView()": [[32, 67]], "ViewHandler#createView()": [[112, 135]]}}}, {"text": "JOptionPane with JOptionPane.showXXXDialog(); static methods, what else", "label": {"api": {"JOptionPane": [[0, 10], [17, 27]]}}}, {"text": "This is how Java represents characters", "label": {"api": {"Java represents characters": [[12, 37]]}}}, {"text": "Use System.out.println(\"text\") to print a new line with the text that you pass as an argument", "label": {"api": {"System.out.println(\"text\")": [[4, 29]]}}}, {"text": "If the RFID reader acts as a keyboard input device, try with key events", "label": {"api": {"key events": [[61, 70]]}}}, {"text": "Go through methods in the Scanner class", "label": {"api": {"Scanner": [[26, 32]]}}}, {"text": "For your case, the methods hasNextLine() and nextLine() will be enough if you are willing to use the String.split()", "label": {"api": {"String.split()": [[101, 114]]}}}, {"text": "I believe you are thinking about the HttpServletResponse", "label": {"api": {"HttpServletResponse": [[37, 55]]}}}, {"text": "You can take a look at the Math.round(double a) method", "label": {"api": {"Math.round(double a)": [[27, 46]]}}}, {"text": "I think a PushbackReader would work", "label": {"api": {"PushbackReader": [[10, 23]]}}}, {"text": "shutdown just says that the executor won't accept new jobs", "label": {"api": {"shutdown": [[0, 7]]}}}, {"text": "awaitTermination waits until all the tasks that have already been submitted finish what they are doing (or until the timeout is reached - which won't happen with Integer.MAX_VALUE - you might want to use a lower value)", "label": {"api": {"awaitTermination": [[0, 15]]}}}, {"text": "Instead of implementing Runnable interface implement Callable interface, to return value to parent thread", "label": {"api": {"Callable": [[53, 60]]}}}, {"text": "Also, Callable.call() throws Exception so you can directly throw it", "label": {"api": {"Callable": [[6, 13]]}}}, {"text": "You can use Callable<Void> instead of Runnable and also an ExecutorService instead of a custom thread pool", "label": {"api": {"Callable": [[12, 19]]}}}, {"text": "Callable-s call throws an exception", "label": {"api": {"Callable": [[0, 7]]}}}, {"text": "Using an ExecutorService also provides the possibility to manage your running tasks tracking the Future-s returned by submit", "label": {"api": {"submit": [[118, 123]]}}}, {"text": "You can fix that problem by setting up InitialContext and your environment correctly as per the InitialContext javadocs", "label": {"api": {"InitialContext javadocs": [[96, 118]]}}}, {"text": "Get the stacktrace and find the class name from the currect index", "label": {"api": {"stacktrace": [[8, 17]]}}}, {"text": "String.concat() accepts a String parameter", "label": {"api": {"String.concat()": [[0, 14]]}}}, {"text": "Or if you want to get a range of lines, use Arrays.copyOfRange()", "label": {"api": {"Arrays.copyOfRange()": [[44, 63]]}}}, {"text": "Importing node to target document is done via Document.importNode", "label": {"api": {"Document.importNode": [[46, 64]]}}}, {"text": "In Java the abstract version of a Reader that works with pulling Objects (instead of characters) is an Iterator", "label": {"api": {"Reader": [[34, 39]], "Iterator": [[103, 110]]}}}, {"text": "The question is there an abstract version of Appendable or Writer where I can push objects (ie an interface)", "label": {"api": {"Writer": [[59, 64]]}}}, {"text": "What Guava does provide though is sort of analagous to Python's generators thanks to its AbstractIterator", "label": {"api": {"Iterator": [[97, 104]]}}}, {"text": "The closest is Observable but it isn't used so much", "label": {"api": {"Observable": [[15, 24]]}}}, {"text": "The preparedStatement.executeUpdate() returns the number of affected rows", "label": {"api": {"preparedStatement.executeUpdate()": [[4, 36]]}}}, {"text": "This piece of code is creating memory leak issues cause of BufferedReader and InputStreamReader which I think might be happening cause of some exceptions", "label": {"api": {"BufferedReader": [[59, 72]], "InputStreamReader": [[78, 94]]}}}, {"text": "Concept is to construct array of javax.persistence.Predicate which contains only predicates we want to use", "label": {"api": {"javax.persistence.Predicate": [[33, 59]]}}}, {"text": "I want to print them and when I start to print this images (using javax.PrintService API), printed only piece of some piece of image, because Java's Print/3D classes by default use 72DPI (vs 300 DPI of my images)", "label": {"api": {"javax.PrintService": [[66, 83]]}}}, {"text": "The second one will not compile since the constructor of FileInputStream can throw a FileNotFoundException, thus you'd need an extra try-catch block, unless of course, the method itself throws it", "label": {"api": {"FileInputStream": [[57, 71]]}}}, {"text": "The Node.managed property prevents a node in a Scene from affecting the layout of other scene nodes", "label": {"api": {"Node.managed": [[4, 15]]}}}, {"text": "In Java, is there any way to determine what initial capacity was used to create a Collection", "label": {"api": {"Collection": [[82, 91]]}}}, {"text": "You can split the String at the spaces using split()", "label": {"api": {"split()": [[45, 51]]}}}, {"text": "Note, since this format is a valid part of XML Schema, you can use the DatatypeConverter.parseDateTime() method to parse this date", "label": {"api": {"DatatypeConverter.parseDateTime()": [[71, 103]]}}}, {"text": "Instead, you can write a launcher main method in your application that executes a second process with your real main method using one of the Runtime.exec implementations", "label": {"api": {"Runtime.exec": [[141, 152]]}}}, {"text": "For example, this can be changed to use Process so that you can also wait for the process to terminate in your launcher, giving you control over post-run cleanup when the game's JVM is fully terminated", "label": {"api": {"Process": [[40, 46]]}}}, {"text": "You might want to take a look at GregorianCalendar", "label": {"api": {"GregorianCalendar": [[33, 49]]}}}, {"text": "Yup, that's because Date doesn't have an add method", "label": {"api": {"Date": [[20, 23]]}}}, {"text": "It sounds like you might be thinking of the Calendar class, although then you'd want", "label": {"api": {"Calendar": [[44, 51]]}}}, {"text": "I would strongly recommend that you abandon Date and Calendar entirely though, and instead start using Joda Time, which is a much, much better date/time API", "label": {"api": {"Date": [[44, 47]], "Calendar": [[53, 60]], "Joda Time": [[103, 111]]}}}, {"text": "Check out the Queue interface", "label": {"api": {"Queue": [[14, 18]]}}}, {"text": "You could look at UIManager", "label": {"api": {"UIManager": [[18, 26]]}}}, {"text": "Here's a program that will show you the default properties that are in the UIManager", "label": {"api": {"UIManager": [[75, 83]]}}}, {"text": "Let's use an output stream and BufferedWriter as an example this time", "label": {"api": {"BufferedWriter": [[31, 44]]}}}, {"text": "Now, what if instead, we closed the BufferedWriter", "label": {"api": {"BufferedWriter": [[36, 49]]}}}, {"text": "Also note that technically, the BufferedWriter isn't the actual handle to your system resource, the FileOutputStream is, so you should be closing on the actual resource anyway", "label": {"api": {"BufferedWriter": [[32, 45]]}}}, {"text": "You can use Application#evaluateExpressionGet() to evaluate an EL expression programmatically", "label": {"api": {"Application#evaluateExpressionGet()": [[12, 46]]}}}, {"text": "Have a look at the Random class in the Java standard library as it may be of some help", "label": {"api": {"Random": [[19, 24]]}}}, {"text": "Just use out.print instead", "label": {"api": {"out.print": [[9, 17]]}}}, {"text": "Since it is a standard case of producer consumer problem, I intend to use BlockingQueues", "label": {"api": {"BlockingQueues": [[74, 87]]}}}, {"text": "LinkedBlockingQueue seems to be a good option since it does not have any size restriction on it, however I am confused reading this from the documentation", "label": {"api": {"LinkedBlockingQueue": [[0, 18]]}}}, {"text": "Does it mean LinkedBlockingQueue is not thread safe", "label": {"api": {"LinkedBlockingQueue": [[13, 31]]}}}, {"text": "Did any of you encounter any issues using LinkedBlockingQueue", "label": {"api": {"LinkedBlockingQueue": [[42, 60]]}}}, {"text": "If I were to use ArrayBlockingQueue instead, which takes size of the queue as parameter in the constructor, I could always run into capacity full related exceptions", "label": {"api": {"ArrayBlockingQueue": [[17, 34]]}}}, {"text": "In order to avoid this, I am not sure how to determine what size I should instantiate my ArrayBlockingQueue with", "label": {"api": {"ArrayBlockingQueue": [[89, 106]]}}}, {"text": "Did you have to solve a similar problem using ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[46, 63]]}}}, {"text": "I can advice you to rewrite your code using class java.util.concurrent.ThreadPoolExecutor", "label": {"api": {"java.util.concurrent.ThreadPoolExecutor": [[50, 88]]}}}, {"text": "The safe way to create generic arrays is with the use of Array.newInstance", "label": {"api": {"Array.newInstance": [[57, 73]]}}}, {"text": "Use replace() instead, which doesn't use regular expressions, since you don't need them at all", "label": {"api": {"replace()": [[4, 12]]}}}, {"text": "Use a Map<Integer, Integer> with the itemid as the key, and max(core) as its value, and in each iteration, compare the current maximum value with the new core", "label": {"api": {"Map<Integer, Integer>": [[6, 26]], "maximum": [[127, 133]]}}}, {"text": "The most basic, yet not optimal way is to use the Serializable-marker interface, see for example here", "label": {"api": {"Serializable": [[50, 61]]}}}, {"text": "What you can do is that you can interrupt the running thread by calling Thread.interrupt after some time elapsed", "label": {"api": {"Thread.interrupt": [[72, 87]]}}}, {"text": "(Do this from your main thread, on your runnable thread.) An alternative to this is to use a FutureTask whom you pass your runnable then call its get() with timeout", "label": {"api": {"FutureTask": [[93, 102]]}}}, {"text": "You can do that as tbk suggests, or you can call Arrays.copyOf, looking something like", "label": {"api": {"Arrays.copyOf": [[49, 61]]}}}, {"text": "As defined in the Character class, chars in java are UTF-16 representations of characters", "label": {"api": {"Character": [[18, 26]]}}}, {"text": "The implements Cloneable part is the one that does the trick", "label": {"api": {"Cloneable": [[15, 23]]}}}, {"text": "See also Cloneable", "label": {"api": {"Cloneable": [[9, 17]]}}}, {"text": "You can use the class java.net.URLClassLoader", "label": {"api": {"java.net.URLClassLoader": [[22, 44]]}}}, {"text": "In case you didn't know, you can use the Java MX bean to detect deadlocked threads programmatically", "label": {"api": {"Java MX bean": [[41, 52]]}}}, {"text": "You can use the Pattern and a simple loop to achieve the results that you are looking for", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "A default LinkedBlockingQueue is practically unbounded", "label": {"api": {"LinkedBlockingQueue": [[10, 28]]}}}, {"text": "You could use the .nextInt() method from the Scanner class", "label": {"api": {".nextInt()": [[18, 27]], "Scanner": [[45, 51]]}}}, {"text": "You can use the append method like this", "label": {"api": {"the append method": [[12, 28]]}}}, {"text": "Direct ByteBuffer is a common way of exchanging data between native memory and Java efficiently", "label": {"api": {"ByteBuffer": [[7, 16]]}}}, {"text": "You should use the class StringBuilder instead", "label": {"api": {"StringBuilder": [[25, 37]]}}}, {"text": "As stated in the API", "label": {"api": {"API": [[17, 19]]}}}, {"text": "java.nio.file.Files (from Java 7) methods supports extended attributes for files", "label": {"api": {"java.nio.file.Files": [[0, 18]]}}}, {"text": "This gives more flexibility to get POSIX attributes", "label": {"api": {"POSIX attributes": [[35, 50]]}}}, {"text": "With Java7 you can at least check for symbolic links", "label": {"api": {"symbolic links": [[38, 51]]}}}, {"text": "You can also check to see if the path is a regular file but I don't know how that would behave if ran against a block device or named pipe", "label": {"api": {"regular file": [[43, 54]]}}}, {"text": "The LinkedList class in Java already does this, by means of its add(index, element) method", "label": {"api": {"LinkedList": [[4, 13]], "add(index, element)": [[64, 82]]}}}, {"text": "I believe you are talking about KeyPairGenerator", "label": {"api": {"KeyPairGenerator": [[32, 47]]}}}, {"text": "Instead, you could re-use the precompiled script via Compilable interface", "label": {"api": {"Compilable": [[53, 62]]}}}, {"text": "itemSet), your ItemSet class must implement the iterable interface", "label": {"api": {"iterable": [[48, 55]]}}}, {"text": "The getUniqueItem() method in your Transaction class returns an ItemSet which does not implement the Iterable interface, so you shouldn't expect to be able to iterate over it", "label": {"api": {"Iterable": [[101, 108]]}}}, {"text": "How about the Timer class", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "You can use Robot for this, as shown in this example", "label": {"api": {"Robot": [[12, 16]]}}}, {"text": "If you keep track of the ScheduledFutures for all tasks scheduled with the executor, then yes", "label": {"api": {"ScheduledFuture": [[25, 39]]}}}, {"text": "Now, if you're going to be doing it a lot, with mutiple tasks, I'd suggest you maintain a DelayQueue", "label": {"api": {"DelayQueue": [[90, 99]]}}}, {"text": "However, you can't merely throw the ScheduledFutures in the queue without maintaining the changes caused by periodic tasks", "label": {"api": {"ScheduledFuture": [[36, 50]]}}}, {"text": "Luckily, the class ScheduledThreadPoolExecutor should handle this nicely via its decorateTask methods", "label": {"api": {"ScheduledThreadPoolExecutor": [[19, 45]], "decorateTask": [[81, 92]]}}}, {"text": "Note this means you will need to create your ownScheduledThreadPoolExecutor directly", "label": {"api": {"ScheduledThreadPoolExecutor": [[48, 74]]}}}, {"text": "A fixed thread pool as created by Executors.newFixedThreadPool will work just fine", "label": {"api": {"Executors.newFixedThreadPool": [[34, 61]]}}}, {"text": "According to JCE Javadocs, specifically the constructor of Class SecretKeySpec", "label": {"api": {"JCE Javadocs": [[13, 24]]}}}, {"text": "Note that Interface KeySpec lists all implementing classes, basically a list of validation options", "label": {"api": {"Interface KeySpec": [[10, 26]]}}}, {"text": "Java doesn't provide exactly what you want, but you could wrap the streams you're using with something like a PrintWriter and Scanner", "label": {"api": {"PrintWriter": [[110, 120]], "Scanner": [[126, 132]]}}}, {"text": "You can read from inputstream and write on ByteArrayOutputStream then use toByteArray()  method to convert it to byte array", "label": {"api": {"toByteArray() ": [[74, 87]]}}}, {"text": "it is a method of the String class", "label": {"api": {"it is a method of the String class": [[0, 33]]}}}, {"text": "Maybe you meant Character.toUpperCase", "label": {"api": {"Character.toUpperCase": [[16, 36]]}}}, {"text": "I don't see the point, though; you should really just use String.toUpperCase, so..", "label": {"api": {"String.toUpperCase": [[58, 75]]}}}, {"text": "You can use setPreferredScrollableViewportSize(), as shown here and here, although it has some of the same drawbacks mentioned here", "label": {"api": {"setPreferredScrollableViewportSize()": [[12, 47]]}}}, {"text": "Why don't you use Callables and an ExecutorService", "label": {"api": {"Callables": [[18, 26]], "ExecutorService": [[35, 49]]}}}, {"text": "If that's the case, implement your parallel computation as a Callable rather than a thread", "label": {"api": {"Callable": [[61, 68]]}}}, {"text": "Pass this collection of tasks to the invokeAll() method of an ExecutorService", "label": {"api": {"invokeAll()": [[37, 47]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html for more information", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html": [[4, 85]]}}}, {"text": "If using DefaultTableModel see the addRow methods", "label": {"api": {"addRow methods": [[35, 48]]}}}, {"text": "Else simply create a new model and call JTable.setModel(TableModel)", "label": {"api": {"JTable.setModel(TableModel)": [[40, 66]]}}}, {"text": "Read this on the oracle docs java.lang page", "label": {"api": {"java.lang": [[29, 37]]}}}, {"text": "I think you're reading CSV files so you can split with the , as parameter for your return value to be like [some],[text],[here] then you'll have access to each of the words of the entire string", "label": {"api": {"split": [[44, 48]]}}}, {"text": "If [ and ] are also a problem you can remove them by using first a substring to use just the substring you need", "label": {"api": {"substring": [[67, 75], [93, 101]]}}}, {"text": "Did you look at the indexOf function in ArrayList", "label": {"api": {"indexOf": [[20, 26]]}}}, {"text": "I have seen that there is the interface PropertyChangeSupport where you can register a PropertyChangeListener but I can not figure out how to use these in an SWT application", "label": {"api": {"PropertyChangeSupport": [[40, 60]], "PropertyChangeListener": [[87, 108]]}}}, {"text": "I assume that the class person should have a PropertyChangeSupport member variable for the changes, but I can not figure out who registers for notifications", "label": {"api": {"PropertyChangeSupport": [[45, 65]]}}}, {"text": "I know that the http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html class has a method nextByte() that processes the next token of the input as a byte", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Scanner.html": [[16, 82]]}}}, {"text": "I would rip out the code where you convert your list contents to and from a string, and replace it with ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[104, 121]]}}}, {"text": "Even if the queues implement the BlockingQueue interface, they still can be examined in non-blocking manner using Queue#peek() method", "label": {"api": {"BlockingQueue interface": [[33, 55]], "Queue#peek() method": [[114, 132]]}}}, {"text": "ArithmeticException extends RuntimeException thus it is not a checked exception", "label": {"api": {"ArithmeticException": [[0, 18]], "RuntimeException": [[28, 43]], "Exception": [[10, 18], [35, 43]]}}}, {"text": "Checked exceptions are the ones inheriting from Exception but not from RuntimeException", "label": {"api": {"RuntimeException": [[71, 86]], "Exception": [[48, 56], [78, 86]]}}}, {"text": "The Kinds of Exceptions", "label": {"api": {"Exception": [[13, 21]]}}}, {"text": "[...] checked exception classes are all subclasses of Throwable other than RuntimeException and its subclasses and Error and its subclasses", "label": {"api": {"RuntimeException": [[75, 90]], "Exception": [[82, 90]]}}}, {"text": "the ones that extend Exception are called checked and need to be handled (catching them, or throwing them) - for example, IOException", "label": {"api": {"Exception": [[21, 29], [124, 132]], "IOException": [[122, 132]]}}}, {"text": "The ones that extend from RuntimeException are called unchecked and don't need to be handled explicitly, unless you need to do something with them - for example, NullPointerException", "label": {"api": {"Exception": [[33, 41], [173, 181]], "RuntimeException": [[26, 41]], "NullPointerException": [[162, 181]]}}}, {"text": "For the code in the question, you can see that ArithmeticException extends from RuntimeException, therefore is unchecked and you don't need to explicitly handle it", "label": {"api": {"Exception": [[57, 65], [87, 95]], "RuntimeException": [[80, 95]], "ArithmeticException": [[47, 65]]}}}, {"text": "This in not an universal answer, but I faces with this problem when define session scope class without implementing Serializable interface", "label": {"api": {"Serializable": [[116, 127]]}}}, {"text": "You could use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[14, 29]]}}}, {"text": "One thing you might want to look into, however, (once you get deeper into Java), is the concept of a Map, much like a dictionary in Python", "label": {"api": {"Map": [[101, 103]]}}}, {"text": "Looking at the Java 7 SE API it seems that all methods are interrogatory in nature and there is no way to get the permissions configuration", "label": {"api": {"Java 7 SE API": [[15, 27]]}}}, {"text": "Java doesn't support associative arrays, but you could use a HashMap", "label": {"api": {"HashMap": [[61, 67]]}}}, {"text": "Make your class implement KeyListener and then call super.addKeyListener(this) in your constructor", "label": {"api": {"KeyListener": [[26, 36], [61, 71]]}}}, {"text": "Afterward, it applies a shuffle (namely Fisher-Yates, via Collections.shuffle) and begins to fill the matrix with these values", "label": {"api": {"Collections.shuffle": [[58, 76]]}}}, {"text": "No need to create a new method to compare two Strings", "label": {"api": {"String": [[46, 51]]}}}, {"text": "That's what equals() does", "label": {"api": {"equals()": [[12, 19]]}}}, {"text": "== is used to compares references, not the contents of each String object", "label": {"api": {"String": [[60, 65]]}}}, {"text": "If you are fetching data from another source the strings are dynamically allocated, hence you should use the var1.equals(var2) (and you should ALWAYS use that one when comparing two objects)", "label": {"api": {"var1.equals(var2)": [[109, 125]]}}}, {"text": "Every Component has addMouseListener(MouseListener)", "label": {"api": {"addMouseListener(MouseListener)": [[20, 50]]}}}, {"text": "File object in Java can represent either a file or a directory", "label": {"api": {"File": [[0, 3]]}}}, {"text": "You can check whether it's a file or a directory by isFile() and isDirectory()", "label": {"api": {"File": [[54, 57]], "isFile()": [[52, 59]], "isDirectory()": [[65, 77]]}}}, {"text": "Use a Calendar and get the DAY_OF_WEEK field", "label": {"api": {"Calendar": [[6, 13]], "DAY_OF_WEEK": [[27, 37]]}}}, {"text": "Or if you want the day name instead, you can use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[49, 64]]}}}, {"text": "You should use the method public T cast(Object obj) of Class<T>", "label": {"api": {"public T cast(Object obj)": [[26, 50]]}}}, {"text": "We will make use of the Properties class to read the properties in, then use MessageFormat to format the appropriate locale we want from the resultant property", "label": {"api": {"Properties": [[24, 33]], "MessageFormat": [[77, 89]]}}}, {"text": "String has a copy constructor you can use for this purpose", "label": {"api": {"copy constructor": [[13, 28]]}}}, {"text": "In order to run your code in a web browser, the pad class needs to extend Applet class (or if you use Swing - JApplet)", "label": {"api": {"JApplet": [[110, 116]]}}}, {"text": "Why is Queue an interface, but others like Stack and ArrayList are classes", "label": {"api": {"Queue": [[7, 11]], "Stack": [[43, 47]], "ArrayList": [[53, 61]]}}}, {"text": "Instead, you should use an ArrayList", "label": {"api": {"ArrayList": [[27, 35]], "List": [[32, 35]]}}}, {"text": "Either way, though, both are Lists, and thus implement get for random-access", "label": {"api": {"List": [[29, 32]], "get": [[55, 57]]}}}, {"text": "The java.util.Arrays object contains a bunch of static methods for working with arrays", "label": {"api": {"java.util.Arrays": [[4, 19]]}}}, {"text": "I think Arrays.sort would probably help you here", "label": {"api": {"Arrays.sort": [[8, 18]]}}}, {"text": "Since Strings implement the Comparable interface with an alphabetic ordering the sorted array should give you the information you need", "label": {"api": {"Comparable": [[28, 37]]}}}, {"text": "Simply serve your file data using GET and application/octect-streamusing one of the factory methods of javax.ws.rs.core.Response (part of the JAX-RS API, so you're not locked into Jersey)", "label": {"api": {"javax.ws.rs.core.Response": [[103, 127]]}}}, {"text": "If you don't have an actual File object, but an InputStream, Response.ok(entity, mediaType) should be able to handle that as well", "label": {"api": {"Response.ok(entity, mediaType)": [[61, 90]]}}}, {"text": "String.getBytes takes into account the default charset of the system", "label": {"api": {"String.getBytes": [[0, 14]]}}}, {"text": "String.getBytes eventually ends up calling this method", "label": {"api": {"String.getBytes": [[0, 14]]}}}, {"text": "ce is a CharsetEncoder", "label": {"api": {"CharsetEncoder": [[8, 21]]}}}, {"text": "There is a much larger degree of complexity involved with using a CharsetEncoder, which could account for the slower execution times you are seeing", "label": {"api": {"CharsetEncoder": [[66, 79]]}}}, {"text": "Try using String.charAt", "label": {"api": {"String.charAt": [[10, 22]]}}}, {"text": "I'd probably avoid that and just index the char[] from String.toCharArray, though", "label": {"api": {"String.toCharArray": [[55, 72]]}}}, {"text": "StringBuilder.reverse should do the work for you (likely in a more efficient way, too)", "label": {"api": {"StringBuilder.reverse": [[0, 20]]}}}, {"text": "Try the following code (using StringBuffer) - a thread-safe, mutable sequence of characters", "label": {"api": {"StringBuffer": [[30, 41]]}}}, {"text": "This then needs to be stored in some kind of row structure, I'd personally use a List", "label": {"api": {"List": [[81, 84]]}}}, {"text": "Try using List.removeAll coupled with Collections.singleton", "label": {"api": {"List.removeAll": [[10, 23]], "Collections.singleton": [[38, 58]]}}}, {"text": "The asynchronous request is simulated by using Thread.sleep()", "label": {"api": {"Thread.sleep()": [[47, 60]]}}}, {"text": "With every Request to your web application, client's IP is sent too", "label": {"api": {"Request": [[11, 17]]}}}, {"text": "So all you need to do is to have Filter over Requests", "label": {"api": {"Request": [[45, 51]], "Filter": [[33, 38]]}}}, {"text": "On important thing ist that some JDBC drivers are supporting precompilation", "label": {"api": {"precompilation": [[61, 74]]}}}, {"text": "You can use the Package class and its methods such as getImplementationVersion to get at those details at runtime", "label": {"api": {"the Package class": [[12, 28]], "getImplementationVersion": [[54, 77]]}}}, {"text": "URL takes a string argument but other constructors are available see https://docs.oracle.com/javase/7/docs/api/java/net/URL.html If you pass a string to a constructor you probably want to assign a value to the string or just use a literal string example new URL(\"google.com\") at least you will get something other than null pointer", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/net/URL.html": [[69, 127]]}}}, {"text": "In case of container managed form based authentication, the login page is under the covers opened by a RequestDispatcher#forward() and the original request URI is therefore available as a request attribute with the name as identified by RequestDispatcher#FORWARD_REQUEST_URI", "label": {"api": {"RequestDispatcher#forward()": [[103, 129]], "RequestDispatcher#FORWARD_REQUEST_URI": [[237, 273]]}}}, {"text": "Request attributes (basically, the request scope) is in JSF available by ExternalContext#getRequestMap()", "label": {"api": {"ExternalContext#getRequestMap()": [[73, 103]]}}}, {"text": "Using the ProcessBuilder API, you could alter your environment variables just before launching each process", "label": {"api": {"ProcessBuilder": [[10, 23]]}}}, {"text": "It is mentioned in the official document that there is a 'approximative' way to measure the object - the Instrumentation way, can anybody explain to me what is the 'approximately' means", "label": {"api": {"Instrumentation": [[105, 119]]}}}, {"text": "I would prefer to use ScheduledExecutorService and then you can define refresh interval in method arguments like below", "label": {"api": {"ScheduledExecutorService": [[22, 45]]}}}, {"text": "On the web side, make sure you're doing a container login, so the server is aware of the logged-in user", "label": {"api": {"container login": [[42, 56]]}}}, {"text": "If you actually want to make it 'so perfect', you should take a look at the try-catch-with-resources statement and the java.nio package (or any nio-derivated libraries)", "label": {"api": {"the java.nio package": [[115, 134]]}}}, {"text": "I'm making a treeCellRenderer for a program, and I'm looking at the documentation for getTreeCellRendererComponent", "label": {"api": {"getTreeCellRendererComponent": [[86, 113]]}}}, {"text": "Even looking at the example, DefaultTreeCellRenderer it isn't clear", "label": {"api": {"DefaultTreeCellRenderer": [[29, 51]]}}}, {"text": "Find the latest (largest) lastModified() in the directory's files, or if there are none use the directory's itself", "label": {"api": {"files": [[60, 64]]}}}, {"text": "Here is a Java 7 solution using FileTime and Path", "label": {"api": {"FileTime": [[32, 39]], "Path": [[45, 48]]}}}, {"text": "When you override equals(Object) you also need to override hashcode()", "label": {"api": {"Object": [[25, 30]]}}}, {"text": "The technical details of how hashcode() and equals(Object) should behave are specified in the Object API", "label": {"api": {"Object": [[51, 56], [94, 99]]}}}, {"text": "How about JComboBox.removeAllItems()", "label": {"api": {"JComboBox.removeAllItems()": [[10, 35]]}}}, {"text": "If you have an InetAddress, you can get the current NetworkInterface using NetworkInterface.getByInetAddress()", "label": {"api": {"NetworkInterface.getByInetAddress()": [[75, 109]]}}}, {"text": "If you want to wait until a thread finishes, use the join() function", "label": {"api": {"join()": [[53, 58]]}}}, {"text": "Just for the record (I voted for Lee Meador), DefaultTreeModel#nodeChanged(javax.swing.tree.TreeNode)  is the way to go", "label": {"api": {"DefaultTreeModel#nodeChanged(javax.swing.tree.TreeNode)": [[46, 100]]}}}, {"text": "From the Javadoc of ObjectMessage I understand that the object needs to be Serializable", "label": {"api": {"Javadoc of ObjectMessage": [[9, 32]]}}}, {"text": "Thus, to compare Strings, use String#equals()", "label": {"api": {"String#equals()": [[30, 44]]}}}, {"text": "replaceAll uses a regex, and | is a special character, which means alternation", "label": {"api": {"replaceAll": [[0, 9]]}}}, {"text": "Or better yet, just use replace(), which doesn't use a regex", "label": {"api": {"replace()": [[24, 32]]}}}, {"text": "There's no reason to use String#replaceAll() here, which treats the pattern as a regex", "label": {"api": {"String#replaceAll()": [[25, 43]]}}}, {"text": "Use String#replace() and you don't have to worry about escaping special characters in the pattern", "label": {"api": {"String#replace()": [[4, 19]], "special characters in the pattern": [[64, 96]]}}}, {"text": "In a standard HashMap, if you put another value with the same key, it replaces the first one", "label": {"api": {"HashMap": [[14, 20]]}}}, {"text": "This is a feature of HashMap that the first value with a given key is erased by the new one", "label": {"api": {"HashMap": [[21, 27]]}}}, {"text": "So \"Mexico\" is removed from the HashMap when you add \"New Mexico\"", "label": {"api": {"HashMap": [[32, 38]]}}}, {"text": "If you want to have more than one value for a given key, use a MultiMap (or simply use a HashMap<Integer, List<String>> but the put operation is a little more tedious)", "label": {"api": {"HashMap": [[89, 95]]}}}, {"text": "The wide use of this class throughout Swing suggest its value", "label": {"api": {"use": [[9, 11]]}}}, {"text": "For the latter, use only as many instances as required; I usually catch the most egregious violations in a trip through the profiler", "label": {"api": {"use": [[16, 18]]}}}, {"text": "Try to utilize a MemoryCacheImageOutputStream instead, until the bug is squashed eventually", "label": {"api": {"MemoryCacheImageOutputStream": [[17, 44]]}}}, {"text": "String internally imposes a lexicographic order via compareTo", "label": {"api": {"compareTo": [[52, 60]]}}}, {"text": "If you don't want that, consider specifying a custom Comparator e.g", "label": {"api": {"Comparator": [[53, 62]]}}}, {"text": "Attempting to port all of native Java to run in JavaScript is definitely outside the scope for the Processing.js project", "label": {"api": {"all of native Java": [[19, 36]]}}}, {"text": "Use FXCollections to create an ObservableList", "label": {"api": {"FXCollections": [[4, 16]]}}}, {"text": "It's a class that allows you to traverse the bitmap of an image (http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferedImage.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferedImage.html": [[65, 138]]}}}, {"text": "Luckily, the Java API specifies Collections.shuffle, which implements the Fisher-Yates algorithm to generate a random permutation", "label": {"api": {"Collections.shuffle": [[32, 50]]}}}, {"text": "Unfortunately, the standard Java technique via Collections.sort is a comparison sort, and thus focused on total orders -- unlike the partial order we want", "label": {"api": {"Collections.sort": [[47, 62]]}}}, {"text": "The contract of RunnableFuture is implemented by FutureTask", "label": {"api": {"FutureTask": [[49, 58]]}}}, {"text": "When you create a FutureTask, you provide either a Callable or a Runnable and a value", "label": {"api": {"FutureTask": [[18, 27]]}}}, {"text": "The run method of FutureTask looks something like", "label": {"api": {"FutureTask": [[18, 27]]}}}, {"text": "Except the actual implementation wraps the Runnable-value pair in a Callable and does some extra checks to ensure the FutureTask is in the correct state before run is invoked", "label": {"api": {"FutureTask": [[118, 127]]}}}, {"text": "You forgot to provide implementations for the other two methods of KeyListener", "label": {"api": {"other two methods": [[46, 62]]}}}, {"text": "If you don't want to do that, extend KeyAdapter instead of KeyListener", "label": {"api": {"KeyAdapter": [[37, 46]]}}}, {"text": "KeyAdapter provides empty implementations of all of KeyListener's methods so you can pick and choose which ones to implement", "label": {"api": {"KeyAdapter": [[0, 9]]}}}, {"text": "This utilizes Toolkit.getSystemClipboard", "label": {"api": {"Toolkit.getSystemClipboard": [[14, 39]]}}}, {"text": "Though, I'd really have to ask why you don't just use Robot.createScreenCapture", "label": {"api": {"Robot.createScreenCapture": [[54, 78]]}}}, {"text": "Naturally, String.concat returns a brand new String", "label": {"api": {"String.concat": [[11, 23]]}}}, {"text": "I'm not a fan of premature optimization, but I believe the logical way to achieve this is to instead use a StringBuilder as follows..", "label": {"api": {"StringBuilder": [[107, 119]]}}}, {"text": "List merely describes the contract of what it means to be a list", "label": {"api": {"List": [[0, 3]]}}}, {"text": "In particular, you have ArrayList, which internally keeps a dynamic array for storing all the elements in order", "label": {"api": {"List": [[29, 32]], "ArrayList": [[24, 32]]}}}, {"text": "You also have LinkedList, which stores elements as a doubly linked list i.e", "label": {"api": {"List": [[20, 23]], "LinkedList": [[14, 23]]}}}, {"text": "Vector is another List, much like an ArrayList in that its implementation is based on a dynamic array;  it's, however, a relic of the older versions of Java and is guaranteed to be thread-safe by being wholly synchronized", "label": {"api": {"List": [[18, 21], [42, 45]], "ArrayList": [[37, 45]], "Vector": [[0, 5]]}}}, {"text": "In practice,  new Vector<T>() is more-or-less equivalent to Collections.synchronizedList(new ArrayList<T>())", "label": {"api": {"List": [[84, 87], [98, 101]], "ArrayList": [[93, 101]], "Vector": [[18, 23]], "Collections.synchronizedList(new ArrayList<T>())": [[60, 107]]}}}, {"text": "The reason for having a List is that a list can come implemented in a number of ways", "label": {"api": {"List": [[24, 27]]}}}, {"text": "That being said, often you want to have some sort of generic behavior that can be applicable to all Lists..", "label": {"api": {"List": [[100, 103]]}}}, {"text": "You can probably execute the second Java class as a Process and read the output yourself", "label": {"api": {"Process": [[52, 58]]}}}, {"text": "ProcessBuilder has a method to redirect the error stream to the input stream (ProcessBuilder.redirectErrorStream) so you do not need a separate thread to read the streams in parallel", "label": {"api": {"ProcessBuilder.redirectErrorStream": [[78, 111]]}}}, {"text": "Use a GeneralPath or Path2D instead", "label": {"api": {"GeneralPath": [[6, 16]]}}}, {"text": "The GeneralPath class represents a geometric path constructed from straight lines, and quadratic and cubic (Bézier) curves", "label": {"api": {"GeneralPath": [[4, 14]]}}}, {"text": "Also, the add() method always returns boolean", "label": {"api": {"add() method always returns boolean": [[10, 44]]}}}, {"text": "The XmlValue annotation is used to denote one of its properties as the content of the element, while another property can be annotated as XmlAttribute", "label": {"api": {"XmlValue": [[4, 11]], "XmlAttribute": [[138, 149]]}}}, {"text": "Have you tried using Scanner", "label": {"api": {"Scanner": [[21, 27]]}}}, {"text": "The Java Scanner class has a whole bunch of methods for grabbing and parsing the next part of a string, e.g", "label": {"api": {"Scanner": [[9, 15]]}}}, {"text": "Don't use StringWriter, use PrintWriter instead", "label": {"api": {"PrintWriter": [[28, 38]]}}}, {"text": "If it is to try and replace some sort of polling then consider the BlockingQueue interface that was released in Java 5", "label": {"api": {"BlockingQueue": [[67, 79]]}}}, {"text": "Properties files are as per specification read using ISO-8859-1", "label": {"api": {"specification": [[28, 40]]}}}, {"text": "Don't use getKeyChar in combination with those VK_ constants", "label": {"api": {"getKeyChar": [[10, 19]]}}}, {"text": "Use getKeyCode instead", "label": {"api": {"getKeyCode": [[4, 13]]}}}, {"text": "getKeyChar is for printable keys only, which result in a character being printed in normal operations", "label": {"api": {"getKeyChar": [[0, 9]]}}}, {"text": "getKeyCode, on the other hand, is intended to give you the code (i.e", "label": {"api": {"getKeyCode": [[0, 9]]}}}, {"text": "Any subclass of Object can be passed into this method", "label": {"api": {"Object": [[16, 21]]}}}, {"text": "All objects are subclasses of Object, including arrays", "label": {"api": {"Object": [[30, 35]]}}}, {"text": "Once passed in, you can invoke any method defined in the Object class on it, unless you typecast it first", "label": {"api": {"Object": [[57, 62]]}}}, {"text": "You could use a timer", "label": {"api": {"timer": [[16, 20]]}}}, {"text": "Simply extend TimerTask and pass it to the Timer", "label": {"api": {"TimerTask": [[14, 22]]}}}, {"text": "Then when you go to set responsecode readLine() returns null", "label": {"api": {"readLine()": [[37, 46]]}}}, {"text": "In java.util.Timer class there's cancel() method", "label": {"api": {"java.util.Timer": [[3, 17]]}}}, {"text": "Did you look at SAXParseException", "label": {"api": {"SAXParseException": [[16, 32]]}}}, {"text": "I assume you are looking for information like the line number", "label": {"api": {"line number": [[50, 60]]}}}, {"text": "you would do this by specifying the schema on the DocumentBuilderFactory", "label": {"api": {"specifying the schema on the DocumentBuilderFactory": [[21, 71]]}}}, {"text": "You could get the Process from ProcessBuilder.start() from the first command, wait using waitFor() and then launch the second one", "label": {"api": {"ProcessBuilder.start()": [[31, 52]], "waitFor()": [[89, 97]]}}}, {"text": "To replace a string literally rather than as a regex, you can use Pattern#quote(String)", "label": {"api": {"Pattern#quote(String)": [[66, 86]]}}}, {"text": "Also, as a side note, you might find String#replace(CharSequence, CharSequence) more appropriate than replaceAll in this situation", "label": {"api": {"String#replace(CharSequence, CharSequence)": [[37, 78]]}}}, {"text": "I tried using Integer.decode(String) but that throws a NumberFormatException even though the grammar appears to be correct", "label": {"api": {"Integer.decode(String)": [[14, 35]]}}}, {"text": "Java's event system is based on the Observer pattern, except in Java Swing, everything is called a \"listener\" instead of \"observer\", and typically implements EventListener (as you can tell from the beast at the top of that link)", "label": {"api": {"EventListener": [[158, 170]]}}}, {"text": "If your listener cares about button clicks, you would add an ActionListener to the button, and JButton adds it to an internal list to be used later (specifically, it uses EventListenerList)", "label": {"api": {"EventListener": [[171, 183]]}}}, {"text": "You can use ResourceBundle.Control to obtain hierarchical list of Locales", "label": {"api": {"ResourceBundle.Control": [[12, 33]]}}}, {"text": "You could use a Stack for this purpose", "label": {"api": {"Stack": [[16, 20]]}}}, {"text": "The LIFO structure is best implemented in Java using a Deque object instead of Stack", "label": {"api": {"Deque": [[55, 59]]}}}, {"text": "To use Deque, your best bet is to use LinkedList, which implements the Deque interface", "label": {"api": {"Deque": [[7, 11], [71, 75]]}}}, {"text": "Instead, use ChartFactory.createTimeSeriesChart(), which creates a DateAxis for the domain", "label": {"api": {"Date": [[67, 70]]}}}, {"text": "If time represents milliseconds from the same epoch as a Java Date, you can use new Date(time.longValue()) to construct your dataset's RegularTimePeriod", "label": {"api": {"Date": [[62, 65], [84, 87]]}}}, {"text": "SceneBuilder outputs fxml files", "label": {"api": {"fxml": [[21, 24]]}}}, {"text": "e(fx)clipse will compile and build javafx applications - including ones which input fxml which has been output by SceneBuilder", "label": {"api": {"fxml": [[84, 87]]}}}, {"text": "The key class which ties together JavaFX applications and fxml generated by SceneBuilder is the FXMLLoader", "label": {"api": {"fxml": [[58, 61]], "FXMLLoader": [[96, 105]]}}}, {"text": "Using e(fx)clipse, try the compiling and running the basic JavaFX sample apps, especially the fxml related sample", "label": {"api": {"fxml": [[94, 97]]}}}, {"text": "The thresholds were introduced alongside the RandomAccess marker interface in Java 1.4 (all based on the legacy code for the JDK from Oracle's website)", "label": {"api": {"RandomAccess": [[45, 56]]}}}, {"text": "You should also learn to use the ExecutorService for higher efficiency", "label": {"api": {"ExecutorService": [[33, 47]]}}}, {"text": "Here's an ExecutorService version of the above", "label": {"api": {"ExecutorService": [[10, 24]]}}}, {"text": "You should use String.equals here", "label": {"api": {"String.equals": [[15, 27]]}}}, {"text": "The class DateFormat is typically used for printing and the time zone is part of the properties you can set on DateFormat", "label": {"api": {"DateFormat": [[10, 19], [111, 120]]}}}, {"text": "Typically, people use the subclass SimpleDateFormat", "label": {"api": {"DateFormat": [[41, 50]], "SimpleDateFormat": [[35, 50]]}}}, {"text": "What you need is to use PreparedStatement in Java", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "With the example that you've, the corresponding PreparedStatement would look something like this", "label": {"api": {"PreparedStatement": [[48, 64]]}}}, {"text": "Have you considered using a JSplitPane (How to Use Split Panes)", "label": {"api": {"JSplitPane": [[28, 37]]}}}, {"text": "I think you want to use @MapsId", "label": {"api": {"@MapsId": [[24, 30]]}}}, {"text": "Check out example 2 in the @OneToOne documentation", "label": {"api": {"@OneToOne": [[27, 35]]}}}, {"text": "This works since in a JSP, there's always an implicit variable called response that contains the HttpServletResponse object, and there's always an implicit variable called session that contains the HttpSession object", "label": {"api": {"HttpServletResponse": [[97, 115]], "HttpSession": [[198, 208]]}}}, {"text": "Recently I ran into codePointAt method of String in Java", "label": {"api": {"codePointAt": [[20, 30]]}}}, {"text": "Now I wonder when and how one should use codePointAt and similar methods", "label": {"api": {"codePointAt": [[41, 51]]}}}, {"text": "In order to avoid ConcurrentModificationException, i am resorting to the following", "label": {"api": {"ConcurrentModificationException": [[18, 48]]}}}, {"text": "Instead of using the time for a unique id, use UUID", "label": {"api": {"UUID": [[47, 50]]}}}, {"text": "I've done some searching and found the ServletContextListener interface which seems to do what I need", "label": {"api": {"ServletContextListener": [[39, 60]]}}}, {"text": "Why don't you model your requirement using the Timer class of the JDK", "label": {"api": {"Timer": [[47, 51]]}}}, {"text": "DataInputStream.readLine is deprecated", "label": {"api": {"readLine": [[16, 23]]}}}, {"text": "Use BufferedReader and its readLine method or Scanner and nextLine instead", "label": {"api": {"BufferedReader": [[4, 17]], "readLine": [[27, 34]], "Scanner": [[46, 52]], "nextLine": [[58, 65]]}}}, {"text": "Files.move requires Path objects", "label": {"api": {"Files.move": [[0, 9]], "Path": [[20, 23]]}}}, {"text": "That said, you can use Paths.get(str) to simply turn a String into a Path", "label": {"api": {"Path": [[23, 26], [69, 72]], "Paths.get(str)": [[23, 36]]}}}, {"text": "JToolBar is particularly well adapted to adding JButton instances each having a distinct Icon, so I would advocate using ImageIcon", "label": {"api": {"ImageIcon": [[121, 129]]}}}, {"text": "You really should be using a DocumentFilter, that's what it's design for", "label": {"api": {"DocumentFilter": [[29, 42]]}}}, {"text": "In later JREs, there is also the IntegrationService", "label": {"api": {"IntegrationService": [[33, 50]]}}}, {"text": "Instead of that, you can make use of HttpSession to store a user-specific connection object in user's session as an attribute", "label": {"api": {"HttpSession": [[37, 47]], "attribute": [[116, 124]]}}}, {"text": "Store the connection there at the first time user accesses the application, then, at each subsequent request, get the connection back, check if it is still valid and use it", "label": {"api": {"back": [[129, 132]]}}}, {"text": "This can be achieved by implementing a HttpSessionListener that checks for any connections in session and closing it in sessionDestroyed() method", "label": {"api": {"HttpSession": [[39, 49]], "HttpSessionListener": [[39, 57]]}}}, {"text": "You may want to store username/password/etc in HttpSession rather than keeping list of connections opened and assigned to a user", "label": {"api": {"HttpSession": [[47, 57]]}}}, {"text": "You can use a subclass of SortedMap, i.e", "label": {"api": {"SortedMap": [[26, 34]]}}}, {"text": "I found that this was better than using the setImageAutoSize(true) method, as that method does not scale the image smoothly at all", "label": {"api": {"setImageAutoSize(true)": [[44, 65]]}}}, {"text": "According to TrayIcon.setImageAutoSize(boolean)", "label": {"api": {"TrayIcon.setImageAutoSize(boolean)": [[13, 46]]}}}, {"text": "Once the side writing closes its OutputStream, the InputStream will deliver any bytes that have not yet been read, and then the next read() after that will return -1 to indicate end of input", "label": {"api": {"read()": [[133, 138]]}}}, {"text": "If the side writing fails to close() when its done, then the reader will block waiting for more input until the writing process closes", "label": {"api": {"close()": [[29, 35]]}}}, {"text": "The Javadoc for java.util.regex.Pattern explicitly mentions \\v in its \"list of Perl constructs not supported by this class\"", "label": {"api": {"The Javadoc for java.util.regex.Pattern": [[0, 38]]}}}, {"text": "Every time through the while loop you're creating a new PrintWriter, writing one line to it, then closing it", "label": {"api": {"PrintWriter": [[56, 66]]}}}, {"text": "You probably should only create one PrintWriter that you keep open and append to it instead", "label": {"api": {"PrintWriter": [[36, 46]]}}}, {"text": "The FileWriter class has a second constructor that takes a boolean argument to tell it to append to the end of the existing file rather than overwrite it from the start", "label": {"api": {"second constructor": [[27, 44]]}}}, {"text": "The first parameter of that JTable constructor takes an Object[][], expected to be the initial table model", "label": {"api": {"that JTable constructor": [[23, 45]]}}}, {"text": "The functionality you desire can be achieved by using Arrays.equals(int[], int[])", "label": {"api": {"Arrays.equals(int[], int[])": [[54, 80]]}}}, {"text": "Alternatively, you could use the indexOf(String str) method like so", "label": {"api": {"indexOf(String str)": [[33, 51]]}}}, {"text": "use the method URL.openStream() instead of this cast to HttpURLConnection", "label": {"api": {"URL.openStream()": [[15, 30]]}}}, {"text": "First you use a DataInputStream to read chunks of x bytes into individual byte arrays, where x is your chunk size", "label": {"api": {"DataInputStream": [[16, 30]]}}}, {"text": "I would suggest to store these byte arrays in an ArrayList", "label": {"api": {"ArrayList": [[49, 57]]}}}, {"text": "Then you create a DataOutputStream for creating the new file", "label": {"api": {"DataOutputStream": [[18, 33]]}}}, {"text": "Finally, you iterate over your ArrayList with a for loop and write the contents of the arrays to the DataOutputStream, preceded or followed by the additional data you need to add for each chunk", "label": {"api": {"ArrayList": [[31, 39]], "DataOutputStream": [[101, 116]]}}}, {"text": "Collections.emptyList() is a good example of a beneficial use of this pattern", "label": {"api": {"Collections.emptyList()": [[0, 22]]}}}, {"text": "You can use reflection to create instances of classes (see http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Class.html for further information)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Class.html": [[59, 123]]}}}, {"text": "I would use a Queue instead of a List, probably a ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[50, 70]]}}}, {"text": "You can use the platform-default line break by calling BufferedWriter.newLine()", "label": {"api": {"BufferedWriter.newLine()": [[55, 78]]}}}, {"text": "You could have found that in the API documentation for the OutOfMemoryError class", "label": {"api": {"API documentation for the OutOfMemoryError class": [[33, 80]]}}}, {"text": "The format method does this", "label": {"api": {"format": [[4, 9]]}}}, {"text": "There is no \"format\" property in java.util.Date", "label": {"api": {"java.util.Date": [[33, 46]]}}}, {"text": "As others noted, use (for example) a SimpleDateFormat to print a Date instance as into a string", "label": {"api": {"SimpleDateFormat": [[37, 52]]}}}, {"text": "For example, the java.util.Timer allows for scheduling execution at a fixed rate", "label": {"api": {"scheduling execution at a fixed rate": [[44, 79]]}}}, {"text": "See the ObjectOutputStream documentation for examples", "label": {"api": {"ObjectOutputStream documentation": [[8, 39]]}}}, {"text": "One option you have is to use an ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[33, 57]]}}}, {"text": "You can use String#substring to extract the part after the \"lab\" and then use Integer#parseInt to check it's an integer and convert it", "label": {"api": {"String#substring": [[12, 27]], "Integer#parseInt": [[78, 93]]}}}, {"text": "You can use the StringBuilder#reverse() method", "label": {"api": {"StringBuilder#reverse() method": [[16, 45]]}}}, {"text": "The point of Callable is to have your exception thrown to your calling thread, for example when you get the result of a Future to which you submitted your callable", "label": {"api": {"Callable": [[13, 20]]}}}, {"text": "Use a single-threaded Executor from Executors.newSingleThreadExecutor()", "label": {"api": {"Executor": [[22, 29], [36, 43], [61, 68]], "Executors.newSingleThreadExecutor()": [[36, 70]]}}}, {"text": "You can pass your jobs as Runnable objects to the Executor and let it do the work for you", "label": {"api": {"Executor": [[50, 57]]}}}, {"text": "\"Hello\".toLowerCase().contains(\"He\".toLowercase()); same like java by using String class contains() method", "label": {"api": {"contains()": [[89, 98]]}}}, {"text": "There is a contains method on String", "label": {"api": {"contains": [[11, 18]]}}}, {"text": "There is also a startsWith method on String", "label": {"api": {"startsWith": [[16, 25]]}}}, {"text": "Use the .addBatch() method on Statement and add each DELETE query separately and .executeBatch() them as a batch", "label": {"api": {".addBatch()": [[8, 18]], ".executeBatch()": [[81, 95]]}}}, {"text": "If using transactions, you can test the counts returned by each statement, and if anything is wrong, you can .rollback() the entire batch", "label": {"api": {".rollback()": [[109, 119]]}}}, {"text": "SQL Construction Kit on GitHub, there is an AbstractDatabase.java class that has an .executeBatch() method that you can copy and use yourself with very little modification", "label": {"api": {".executeBatch()": [[84, 98]]}}}, {"text": "List is an interface", "label": {"api": {"List": [[0, 3]]}}}, {"text": "ArrayList is one implementation of List", "label": {"api": {"List": [[5, 8], [35, 38]], "ArrayList": [[0, 8]]}}}, {"text": "When you construct a List you must choose a specific concrete type (e.g", "label": {"api": {"List": [[21, 24]]}}}, {"text": "This prevents tight coupling between your code and the specific List implementation, allowing you to more easily change to another List implementation later if you wish", "label": {"api": {"List": [[64, 67], [131, 134]]}}}, {"text": "I'm not sure it is the best solution, but you might try using  HTML EditorKit and implement a custom ParserCallback", "label": {"api": {"HTML EditorKit": [[63, 76]], "ParserCallback": [[101, 114]]}}}, {"text": "I believe you seek a ConcurrentLinkedQueue - Here's it's description, with some emphasis from me", "label": {"api": {"ConcurrentLinkedQueue": [[21, 41]]}}}, {"text": "A ConcurrentLinkedQueue is an appropriate choice when many threads will share access to a common collection", "label": {"api": {"ConcurrentLinkedQueue": [[2, 22]]}}}, {"text": "If you have a Class, you can create an array of that class with reflection", "label": {"api": {"array": [[39, 43]]}}}, {"text": "Anyway, could you use a formatter", "label": {"api": {"formatter": [[24, 32]]}}}, {"text": "If needed, you can split the input String containing the list", "label": {"api": {"split": [[19, 23]]}}}, {"text": "You can pad strings with String.format() with the %-ns format specifier", "label": {"api": {"String.format()": [[25, 39]]}}}, {"text": "Or, glancing at the api, using byteValue()", "label": {"api": {"api": [[20, 22]]}}}, {"text": "You're right, threads can run only once and it's illegal to start/run  a thread more than once", "label": {"api": {"illegal to start/run  a thread more than once": [[49, 93]]}}}, {"text": "Take a look at ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[15, 32]]}}}, {"text": "Use ByteBuffer for converting the bytes into individual variables", "label": {"api": {"ByteBuffer": [[4, 13]]}}}, {"text": "If you do decide to go with synchronizing look at using ReentrantReadWriteLock instead of the way you did it", "label": {"api": {"ReentrantReadWriteLock": [[56, 77]]}}}, {"text": "This is really simple, the String object has an endsWith method", "label": {"api": {"String": [[27, 32]], "endsWith": [[48, 55]]}}}, {"text": "You can also do this with the matches method and a fairly simple regex", "label": {"api": {"matches": [[30, 36]]}}}, {"text": "Using the character class [.,/] specifying either a period, a slash, or a comma, and a backreference, \\1 that matches whichever of the alternates were found, if any", "label": {"api": {"matches": [[110, 116]]}}}, {"text": "Of course you can use the StringTokenizer class to split the String with '.' or '/', and check if the last word is \"work\"", "label": {"api": {"StringTokenizer": [[26, 40]]}}}, {"text": "StringTokenizer can break up your string for you", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "SimpleDateFormat can handle dates if you know the format in the field will be correct", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "To that end, I would say that you construct your Double with Double.NaN as so", "label": {"api": {"Double.NaN": [[61, 70]]}}}, {"text": "SwingWorker has a method called setProgress() that you can invoke to set the value of your progress bar", "label": {"api": {"setProgress()": [[32, 44]]}}}, {"text": "Have you looked at TreeMap", "label": {"api": {"TreeMap": [[19, 25]]}}}, {"text": "You can use  Comparator .", "label": {"api": {" Comparator": [[12, 22]]}}}, {"text": "Also consider subclassing InputVerifier, as discussed in Validating Input", "label": {"api": {"InputVerifier": [[26, 38]]}}}, {"text": "With nio, You could also use a SocketChannel which is interruptible and would allow the application of the standard interrupt model of Java", "label": {"api": {"SocketChannel": [[31, 43]], "interruptible": [[54, 66]], "interrupt": [[54, 62], [116, 124]]}}}, {"text": "A call to the interrupt method of your Thread object would throw an InterruptedException which would stop even your blocking IO operation", "label": {"api": {"interrupt": [[14, 22]]}}}, {"text": "See the java.io.Serializable java docs", "label": {"api": {"java.io.Serializable java docs": [[8, 37]]}}}, {"text": "The best way to do this is combining JScrollPane like in this example", "label": {"api": {"JScrollPane": [[37, 47]]}}}, {"text": "Why not use a List (like ArrayList) instead", "label": {"api": {"List": [[14, 17], [30, 33]], "ArrayList": [[25, 33]]}}}, {"text": "You can read individual bytes from a socket by using a DataInputStream object", "label": {"api": {"DataInputStream": [[55, 69]]}}}, {"text": "Rather than subclassing or trying to cast it, can you put your right-click functionality into its own class which implements the MouseInputListener interface, and simply add an instance of your right-click handler to the JTextField objects in question", "label": {"api": {"MouseInputListener interface": [[129, 156]]}}}, {"text": "The good thing about Java is that List is an interface with different implementations (like ArrayList, LinkedList, Stack, Vector) depending on your needs", "label": {"api": {"ArrayList": [[92, 100]]}}}, {"text": "It looks like ArrayList might work for you", "label": {"api": {"ArrayList": [[14, 22]]}}}, {"text": "If you are using time manipulations you should use a Calendar Object getting an instance with the Calendar#getInstance(Timezone) static method, providing your a TimeZone object that corresponds to your timezone", "label": {"api": {"Calendar": [[53, 60], [98, 105]]}}}, {"text": "If you have to print a Date object with a defined timezone get a DateFormat object and set its timezone to one that corresponds to your liking", "label": {"api": {"DateFormat": [[65, 74]]}}}, {"text": "GZIPInputStream is for reading gzip-encoding content", "label": {"api": {"GZIPInputStream": [[0, 14]]}}}, {"text": "If your goal is to take a regular input stream and compress it in the GZIP format, then you need to write those bytes to a GZIPOutputStream", "label": {"api": {"GZIPOutputStream": [[123, 138]]}}}, {"text": "The GZIPInputStream is to be used to decompress an incoming InputStream", "label": {"api": {"GZIPInputStream": [[4, 18]], "InputStream": [[8, 18], [60, 70]]}}}, {"text": "To compress an incoming InputStream using GZIP, you basically need to write it to a GZIPOutputStream", "label": {"api": {"InputStream": [[24, 34]], "GZIPOutputStream": [[84, 99]]}}}, {"text": "You can get a new InputStream out of it if you use ByteArrayOutputStream to write gzipped content to a byte[] and ByteArrayInputStream to turn a byte[] into an InputStream", "label": {"api": {"InputStream": [[18, 28], [123, 133], [160, 170]], "ByteArrayOutputStream": [[51, 71]], "ByteArrayInputStream": [[114, 133]]}}}, {"text": "You can if necessary replace the ByteArrayOutputStream/ByteArrayInputStream by a FileOuputStream/FileInputStream on a temporary file as created by File#createTempFile(), especially if those streams can contain large data which might overflow machine's available memory when used concurrently", "label": {"api": {"InputStream": [[64, 74], [101, 111]], "ByteArrayOutputStream": [[33, 53]], "ByteArrayInputStream": [[55, 74]]}}}, {"text": "Class<T>, you can utilize Array.newInstance as follows..", "label": {"api": {"Array.newInstance": [[26, 42]]}}}, {"text": "According to the Serializable javadoc, deserialization can be controlled by implementing the following method", "label": {"api": {"the Serializable javadoc": [[13, 36]]}}}, {"text": "According to the documentation for SimpleDateFormat you should use an upper case \"H\" for hours of the format 0-23", "label": {"api": {"SimpleDateFormat": [[35, 50]]}}}, {"text": "If I were you, I would use Area", "label": {"api": {"Area": [[27, 30]]}}}, {"text": "I've verified this behaviour by creating a test MBean method that calls stop() on the connector server and sleeps for a second afterwards, and I always got a response when calling the test method from a JMX client", "label": {"api": {"stop()": [[72, 77]]}}}, {"text": "Here's a version that makes use of Java 8's Stream API", "label": {"api": {"Stream API": [[44, 53]]}}}, {"text": "Not sure if that is the question, you could use setActionCommand methods to assign an action to a button", "label": {"api": {"setActionCommand": [[48, 63]]}}}, {"text": "@kleopatra notes that SwingWorker is designed to be executed only once", "label": {"api": {"executed only once": [[52, 69]]}}}, {"text": "Your algorithm is fine, but instead of using next()", "label": {"api": {"next()": [[45, 50]]}}}, {"text": "Which will only read a single token, i.e., the first word, use nextLine(), which will read the entire line", "label": {"api": {"nextLine()": [[63, 72]]}}}, {"text": "Please refer to the Javadocs", "label": {"api": {"the Javadocs": [[16, 27]]}}}, {"text": "You can use the HttpURLConnection object to make a request to localhost", "label": {"api": {"HttpURLConnection": [[16, 32]]}}}, {"text": "URL requires a correctly formed url", "label": {"api": {"URL": [[0, 2]]}}}, {"text": "One of the best reasons for using an Iterator is that you can safely modify the collection without raising a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[109, 139]]}}}, {"text": "An IllegalThreadState exception will be thrown", "label": {"api": {"IllegalThreadState": [[3, 20]]}}}, {"text": "One way is to use a rotate instance from one of the methods of AffineTransform that accepts anchors for the X,Y co-ordinates", "label": {"api": {"the methods of AffineTransform": [[48, 77]]}}}, {"text": "If the method you use is open you could use String.replace()", "label": {"api": {"String.replace()": [[44, 59]]}}}, {"text": "as well, you could use ActionMap and KeyStroke", "label": {"api": {"ActionMap": [[23, 31]], "KeyStroke": [[37, 45]]}}}, {"text": "Given that you are using Java, you can take advantage of the Serializable interface to handle all of your serialization & deserialization needs", "label": {"api": {"Serializable": [[61, 72]]}}}, {"text": "See http://docs.oracle.com/javaee/7/api/javax/mail/internet/MimeMessage.html#setFrom() for details", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/mail/internet/MimeMessage.html#setFrom()": [[4, 85]]}}}, {"text": "You can wrap the Input/OutputStream objects that come from a Socket with other stream types, such as ObjectOutputStream / ObjectInputStream, which allow you to read/write full objects and primitive types directly to the stream, the same way you would read/write data to a file on your file system using these same stream types", "label": {"api": {"Socket": [[61, 66]], "ObjectOutputStream": [[101, 118]], "ObjectInputStream": [[122, 138]]}}}, {"text": "I would perhaps use a Map that maps each stadium name to its total revenue", "label": {"api": {"Map": [[22, 24]]}}}, {"text": "The Formatter constructor which takes a file name doesn't seem up to the job", "label": {"api": {"Formatter constructor": [[4, 24]]}}}, {"text": "I suggest you create a FileOutputStream where you can explicitely require appending", "label": {"api": {"FileOutputStream": [[23, 38]]}}}, {"text": "You can pass that stream to the Formatter constructor instead of the raw file name", "label": {"api": {"Formatter constructor": [[32, 52]]}}}, {"text": "As per the documentation of Java Graphics class is abstract so you can't instantiate it", "label": {"api": {"Graphics": [[33, 40]]}}}, {"text": "Otherwise, if you are required to only use indexOf(), look at the Java API documentation for String API to understand how it works", "label": {"api": {"Java API documentation for String API": [[66, 102]]}}}, {"text": "indexOf(int), indexOf(int, int), and indexOf(String)", "label": {"api": {"indexOf(int)": [[0, 11]], "indexOf(int, int)": [[14, 30]], "indexOf(String)": [[37, 51]]}}}, {"text": "List instances are not the same as arrays", "label": {"api": {"List": [[0, 3]]}}}, {"text": "As a side note, Java has a for-each loop that can be used on both arrays and Lists", "label": {"api": {"List": [[77, 80]]}}}, {"text": "This is why APIs often return defensive copies, unmodifiable wrappers, etc", "label": {"api": {"unmodifiable wrappers": [[48, 68]]}}}, {"text": "You may take a look at how it's done in ListView", "label": {"api": {"ListView": [[40, 47]]}}}, {"text": "items property is an ObservableList which is monitored by ListView controller which updates view accordingly", "label": {"api": {"ListView": [[58, 65]]}}}, {"text": "So users of ListView aren't aware about anything, they can simply add/remove/change elements of items", "label": {"api": {"ListView": [[12, 19]]}}}, {"text": "\"Normal\" classes class can be modified by overriding the modifyClass() method which is called just before defineClass()", "label": {"api": {"defineClass()": [[106, 118]]}}}, {"text": "getSource() returns an Object, so you need to cast it to JButton, like this", "label": {"api": {"getSource()": [[0, 10]]}}}, {"text": "Hanging on Object.wait() is a totally legal and safe situation, which may happen, for example, when some thread is waiting for a new element in a BlockingQueue", "label": {"api": {"BlockingQueue": [[146, 158]]}}}, {"text": "In fact, the Java SE SDK comes with a useful class ThreadInfo which you can inspect to learn why a thread is blocked and what it is waiting on, including the full stacktrace to the wait point, and the total time in millis spent waiting", "label": {"api": {"ThreadInfo": [[51, 60]]}}}, {"text": "Check .getErrorStream() and .getOutputStream() of Process object that you have", "label": {"api": {".getErrorStream()": [[6, 22]], ".getOutputStream()": [[28, 45]]}}}, {"text": "But if what you want is to be able to compile classes at runtime, you should look at the JavaCompiler API which has been a part of standard Java since Java SE 6", "label": {"api": {"JavaCompiler API": [[89, 104]]}}}, {"text": "For example, LinkedBlockingQueue is already synchronized in a proper way", "label": {"api": {"LinkedBlockingQueue": [[13, 31]]}}}, {"text": "Please use the Processbuilder API for this, The documentation has an example of how to use the various flags", "label": {"api": {"Processbuilder": [[15, 28]]}}}, {"text": "Just use newInstance()", "label": {"api": {"newInstance()": [[9, 21]]}}}, {"text": "You can use Class.newInstance() method and the return type of your method should be T instead of Class<T>", "label": {"api": {"Class.newInstance()": [[12, 30]]}}}, {"text": "LinkedList is not thread safe and probably this is causing un-expected results in your code", "label": {"api": {"LinkedList": [[0, 9]]}}}, {"text": "You need to use ConcurrentLinkedQueue in this case as you are trying to access a list in a Thread", "label": {"api": {"ConcurrentLinkedQueue": [[16, 36]]}}}, {"text": "Note that because of security restrictions this applet will need to be signed and granted the createRobot permission to work on the client, otherwise it will fail to initialize the Robot class", "label": {"api": {"Robot": [[100, 104], [181, 185]]}}}, {"text": "Timer.schedule(TimerTask task, long delay) only runs the TimerTask once, after the number of milliseconds in the second argument", "label": {"api": {"Timer.schedule(TimerTask task, long delay)": [[0, 41]]}}}, {"text": "To repeatedly run the TimerTask, you need to use one of the other schedule() overloads such as Timer.schedule(TimerTask task, long delay, long period), for example", "label": {"api": {"Timer.schedule(TimerTask task, long delay, long period)": [[95, 149]]}}}, {"text": "You need to use `Timer.schedule(TimerTask, long, long) to cause the task to repeat", "label": {"api": {"`Timer.schedule(TimerTask, long, long)": [[16, 53]]}}}, {"text": "String.trim() specifically only removes characters before the first character whose code exceeds \\u0020, and after the last such character", "label": {"api": {"specifically only removes": [[14, 38]]}}}, {"text": "The value you're trying to parse is larger than an Integer can hold, 231-1, which is 2147483647", "label": {"api": {"231-1": [[69, 73]]}}}, {"text": "You'd need to make it a Long (or long) instead and use Long#parseLong() to parse it", "label": {"api": {"Long#parseLong()": [[55, 70]]}}}, {"text": "You're writing into a RAF, and per its API the writeDouble method returns void", "label": {"api": {"API": [[39, 41]]}}}, {"text": "Draw the image using an AffineTransform translate instance - it accepts doubles", "label": {"api": {"AffineTransform translate instance": [[24, 57]]}}}, {"text": "Java methods called from Javascript typically need to be wrapped in an AccessController.doPrivileged(..) call, to be trusted", "label": {"api": {"AccessController.doPrivileged(..)": [[71, 103]]}}}, {"text": "Look at Collections.reverseOrder", "label": {"api": {"Collections.reverseOrder": [[8, 31]]}}}, {"text": "The single argument of Collections.reverseOrder is a Comparator and not a Collection", "label": {"api": {"Collections.reverseOrder": [[23, 46]]}}}, {"text": "Escaping/handling white spaces are better run done with ProcessBuilder", "label": {"api": {"ProcessBuilder": [[56, 69]]}}}, {"text": "You need to create a table model which returns Icon.class for its getColumnClass method", "label": {"api": {"getColumnClass": [[66, 79]]}}}, {"text": "System.nanotime() javadoc suggests", "label": {"api": {"System.nanotime()": [[0, 16]]}}}, {"text": "See the Proxy javadoc for details", "label": {"api": {"Proxy javadoc": [[8, 20]]}}}, {"text": "I'm late to the game but I wanted something similar and found use of Java 8 Optional class", "label": {"api": {"Optional": [[76, 83]]}}}, {"text": "For more complicated scenarios, like when reading is done by multiple threads often and writing is seldom, look into ReadWriteLock", "label": {"api": {"ReadWriteLock": [[117, 129]]}}}, {"text": "You should use ConcurrentHashMap instead, which is a much better/faster implementation of java.util.Map interface", "label": {"api": {"ConcurrentHashMap": [[15, 31]]}}}, {"text": "If you want to remove items that don't match from MyStrings rather than create a new ArrayList you will need to use an Iterator as this is the only safe way to modify a ArrayList while iterating over it", "label": {"api": {"an Iterator": [[116, 126]]}}}, {"text": "You can use ByteArrayInputStream which takes a byte array as an input in the constructor", "label": {"api": {"ByteArrayInputStream": [[12, 31]]}}}, {"text": "If you want to replace all occurrences of whitespace by \", \", you could use String#replaceAll", "label": {"api": {"String#replace": [[76, 89]], "String#replaceAll": [[76, 92]]}}}, {"text": "Note that \\s will match more than \" \", it will match any whitespace character, [ \\t\\n\\x0B\\f\\r]", "label": {"api": {"any": [[53, 55]]}}}, {"text": "If you want a more robust solution (that deals with multi-spaces and tabs as well) you can use a regular expression, and String.replaceAll()", "label": {"api": {"String.replaceAll()": [[121, 139]]}}}, {"text": "Use java.net.URLEncoder to encode the query parameters", "label": {"api": {"java.net.URLEncoder": [[4, 22]]}}}, {"text": "a SpinnerModel implementation creates a sequence of values, while a ComboBoxModel does not", "label": {"api": {"SpinnerModel": [[2, 13]], "ComboBoxModel": [[68, 80]]}}}, {"text": "If objects in a SpinnerModel do not have a suitable natural order, you'll need to impose one", "label": {"api": {"SpinnerModel": [[16, 27]]}}}, {"text": "If comparing threads doesn't work, you could use a thread local UUID (http://docs.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html, http://docs.oracle.com/javase/1.5.0/docs/api/java/util/UUID.html) to compare invokers", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/UUID.html": [[139, 202]]}}}, {"text": "An even better alternative is ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[30, 56]]}}}, {"text": "Use String#indexOf(int) and String#substring(int)", "label": {"api": {"String#indexOf(int)": [[4, 22]], "String#substring(int)": [[28, 48]]}}}, {"text": "What you are talking about is handled by upper-level protocols on top of TCP, like HTTP, so you need to look at other utilities like java.net.URL", "label": {"api": {"java.net.URL": [[133, 144]]}}}, {"text": "I'm working with java.io.File to handle some PDF files on an external storage", "label": {"api": {"java.io.File": [[17, 28]]}}}, {"text": "The documentation for toArray, which is declared by the Collection, explains that an ArrayStoreException may be thrown \"if the runtime type of the specified array is not a supertype of the runtime type of every element in this collection\"", "label": {"api": {"toArray": [[22, 28]]}}}, {"text": "So given our hypothetical signature with <T super E>, if I called toArray on an ArrayList<Number> and passed in an Integer[], it would still compile - and possibly fail at runtime depending on what was in the list", "label": {"api": {"toArray": [[66, 72]]}}}, {"text": "But you can provide a custom Comparator to Arrays#sort()", "label": {"api": {"you can provide a custom Comparator to Arrays#sort()": [[4, 55]]}}}, {"text": "I realise this doesn't answer your question in the way that you want, but it sounds to me like you need an IP address class rather than a String class", "label": {"api": {"IP address": [[107, 116]]}}}, {"text": "Your problem is coming from your use of Scanner, the helpful part of this page is A scanning operation may block waiting for input", "label": {"api": {"Scanner": [[40, 46]]}}}, {"text": "I saw the ScheduledExecutorService class and figured it would be perfect, but I ran into a problem", "label": {"api": {"ScheduledExecutorService": [[10, 33]]}}}, {"text": "Throwable is a class which Exception – and consequently all subclasses thereof – subclasses", "label": {"api": {"Throwable": [[0, 8]]}}}, {"text": "There's nothing stopping you from using instanceof on a Throwable", "label": {"api": {"Throwable": [[56, 64]]}}}, {"text": "You can hold them in a List and use Collections.shuffle() to shuffle the list", "label": {"api": {"List": [[23, 26]], "Collections.shuffle()": [[36, 56]]}}}, {"text": "The code needs to be wrapped in a PrivilegedAction and called using one of the AccessController methods that doPrivileged(..)", "label": {"api": {"PrivilegedAction": [[34, 49]], "AccessController methods": [[79, 102]]}}}, {"text": "As for instanceof, you could use its dynamic counterpart Class#isInstance", "label": {"api": {"Class#isInstance": [[57, 72]]}}}, {"text": "Indeed, Guava uses an ConcurrentLinkedQueue, which is unbounded", "label": {"api": {"ConcurrentLinkedQueue": [[22, 42]]}}}, {"text": "Python has zlib.crc32 and Java has a CRC32 class", "label": {"api": {"CRC32 class": [[37, 47]]}}}, {"text": "From the Java side, there is an overloaded version of String.getBytes that takes an encoding - but it takes it as a java.nio.Charset rather than a string - so, you'll want to do", "label": {"api": {"java.nio.Charset": [[116, 131]]}}}, {"text": "Python's hashlib (which is the preferred implementation of md5 and other cryptographic hashes since Python 2.5) is exactly compatible with Java's MessageDigest in this - they both give bytes, so their output should be equivalent", "label": {"api": {"MessageDigest": [[146, 158]]}}}, {"text": "Python's zlib.crc32 and Java's java.util.zip.CRC32, on the other hand, both give numeric results - but Java's is always an unsigned 64 bit number, while Python's (in Python 2) is a signed 32 bit number (in Python 3, its now an unsigned 32-bit number, so this problem goes away)", "label": {"api": {"java.util.zip.CRC32": [[31, 49]]}}}, {"text": "Have your Object implement Comparable<Object>, so..", "label": {"api": {"Comparable<Object>": [[27, 44]]}}}, {"text": "Next, try to sort your List<Object> as follows, using Collections.sort", "label": {"api": {"Collections.sort": [[54, 69]]}}}, {"text": "If you want to be able to modify day1 without having to re-sort, try using a TreeSet, i.e", "label": {"api": {"TreeSet": [[77, 83]]}}}, {"text": "by id, or by value), consider decoupling the comparison from Object and create a distinct Comparator<Object> instead", "label": {"api": {"Comparator<Object>": [[90, 107]]}}}, {"text": "Just specify the Comparator to either sort or the TreeSet constructor, depending on which you use", "label": {"api": {"TreeSet": [[50, 56]]}}}, {"text": "Your actionlistener (the JFrame itself) is not added with addActionListener", "label": {"api": {"addActionListener": [[58, 74]]}}}, {"text": "It's hard to know without seeing the full code, but I'm reasonably sure that your TextInfo class does not correctly implement equals() and hashCode()", "label": {"api": {"equals()": [[126, 133]], "hashCode()": [[139, 148]]}}}, {"text": "Having those two methods implemented is a prerequisite to being useful as a key in a HashMap", "label": {"api": {"HashMap": [[85, 91]]}}}, {"text": "If sortedMap variable contains an instance of a TreeMap then use descendingKeySet()", "label": {"api": {"descendingKeySet()": [[65, 82]]}}}, {"text": "See also the Javadoc for File(URI)", "label": {"api": {"Javadoc for File(URI)": [[13, 33]]}}}, {"text": "You should read the Javadoc on String class", "label": {"api": {"String": [[31, 36]]}}}, {"text": "Why don't you use String.split instead of writing your own solution", "label": {"api": {"String.split": [[18, 29]]}}}, {"text": "swap the readers after 100 bytes, use read(byte[] b, int off, int len)  otherwise read the data from one thread then share it", "label": {"api": {"read(byte[] b, int off, int len) ": [[38, 70]]}}}, {"text": "The ResultSetMetaData.getColumnType(int column) returns a int value specifying the column type found in java.sql.Types", "label": {"api": {"ResultSetMetaData.getColumnType(int column)": [[4, 46]], "java.sql.Types": [[104, 117]]}}}, {"text": "Check for a flag using the Preferences API (overview), if doesn't exist, it's the first start", "label": {"api": {"the Preferences API": [[23, 41]]}}}, {"text": "can be launched using Java Web Start and can access the PersistenceService", "label": {"api": {"PersistenceService": [[56, 73]]}}}, {"text": "The same API also provides the ExtensionInstallerService", "label": {"api": {"ExtensionInstallerService": [[31, 55]]}}}, {"text": "OTOH if you mean 'single instance', as mentioned by Peter, look to the (drum roll please..) SingleInstanceService ..and the demo", "label": {"api": {"SingleInstanceService": [[92, 112]]}}}, {"text": "Have you tried setSize()", "label": {"api": {"setSize()": [[15, 23]]}}}, {"text": "You could begin by reading it into a BufferedImage with ImageIO.read(file)", "label": {"api": {"BufferedImage": [[37, 49]], "ImageIO.read(file)": [[56, 73]]}}}, {"text": "The getRGB(...) methods can help you to obtain information about the individual pixels, and the corresponding setRGB(...) methods help you to change them", "label": {"api": {"getRGB(...)": [[4, 14]]}}}, {"text": "The most common way of manipulating an image in Java is using the  BufferedImage class, included in the java.awt.image.* package", "label": {"api": {"BufferedImage": [[67, 79]]}}}, {"text": "For instance, I've worked on a low level PNG coder/encoder (PNGJ) that does not use BufferedImage, but instead gives you each image line as an int[] array", "label": {"api": {"BufferedImage": [[84, 96]]}}}, {"text": "Create multiple URLClassLoader with the path set to the JarFile containing the EclipseStarter class", "label": {"api": {"URLClassLoader": [[16, 29]]}}}, {"text": "Use ExecutorService instead", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "Use the setAttribute method on HTTPServletRequest", "label": {"api": {"HTTPServletRequest": [[31, 48]]}}}, {"text": "I'm attempting to use a CriteriaQuery, but I'm finding that my jaxax.persistence.EntityManager appears to be this interface (from EJB), rather than the one I want (from JPA), so I'm unable to use createQuery(CriteriaQuery)", "label": {"api": {"the one I want": [[148, 161]]}}}, {"text": "The clone method returns an Object if not overridden", "label": {"api": {"clone method": [[4, 15]]}}}, {"text": "Does it override the clone method", "label": {"api": {"clone method": [[21, 32]]}}}, {"text": "Use Java's Proxy class", "label": {"api": {"Proxy": [[11, 15]]}}}, {"text": "You can access these values from code using ServletContext#getInitParameter(String)", "label": {"api": {"ServletContext#getInitParameter(String)": [[44, 82]]}}}, {"text": "However, Java provides some sugar that can make this easier", "label": {"api": {"sugar": [[28, 32]]}}}, {"text": "Try using a ConcurrentLinkedQueue for your list of URLs", "label": {"api": {"ConcurrentLinkedQueue": [[12, 32]]}}}, {"text": "You can use the method getDeclaredMethods() instead of the getMethods() to get only the methods declared on the class you are reflecting (not super classes)", "label": {"api": {"getDeclaredMethods()": [[23, 42]]}}}, {"text": "you could probably implement your own Servlet Filter to do this", "label": {"api": {"Filter": [[46, 51]]}}}, {"text": "in your Filter, you could wrap the existing request using HttpServletRequestWrapper and alter the method/query params as appropriate", "label": {"api": {"Filter": [[8, 13]], "HttpServletRequestWrapper": [[58, 82]]}}}, {"text": "This is probably the same pattern that you'll get from Pattern.quote", "label": {"api": {"Pattern.quote": [[55, 67]]}}}, {"text": "Java's Runtime class provides an option to add a shutdown hook that gets called when the java program is being terminated", "label": {"api": {"shutdown hook": [[49, 61]]}}}, {"text": "You write a simple thread class that has access to the test instance created in the main method above so that when the shutdown hook thread's run method is called, you delegate it to test instance's stop method", "label": {"api": {"shutdown hook": [[119, 131]]}}}, {"text": "You may want to consider placing your Test node in a pannable ScrollPane rather than implementing the panning yourself - might need to wrap it in a Group to get the appropriate behaviour", "label": {"api": {"ScrollPane": [[62, 71]]}}}, {"text": "But the code you have is simple and seems to work fine, so perhaps use of a ScrollPane is unnecessary and may even confuse things more", "label": {"api": {"ScrollPane": [[76, 85]]}}}, {"text": "There is a Canvas class in Java, which is something different from what you have, so calling your node something other than Canvas is probably a good idea", "label": {"api": {"Canvas": [[11, 16], [124, 129]]}}}, {"text": "Not to do with your question, but using a Timeline is my preferred way to handle animation rather than a Timer, though the Timer method will still work as long as you correctly use Platform.runLater as you are doing", "label": {"api": {"Timeline": [[42, 49]]}}}, {"text": "Here's a modified sample using a Timeline and .mouseTransparent() with an added frame counter so that it is clear that animation is happening", "label": {"api": {"Timeline": [[33, 40]]}}}, {"text": "String.subString(begin, end) function returns sub string", "label": {"api": {"subString": [[7, 15]]}}}, {"text": "But, if you're still curious about removing a component's children without removing the component, the answer is no, as seen in the JComponent documentation (I'm assuming you're on Java 7, if not you can easily change to the proper version of Java)", "label": {"api": {"JComponent documentation": [[132, 155]]}}}, {"text": "A good class for it is the BuffedReader", "label": {"api": {"BuffedReader": [[27, 38]]}}}, {"text": "The fastest way would probably be to just use Semaphore and a single-threaded executor", "label": {"api": {"Semaphore": [[46, 54]]}}}, {"text": "Semaphore is decently fast, much faster than using synchronized blocks", "label": {"api": {"Semaphore": [[0, 8]]}}}, {"text": "I think you can achieve that with setting BorderLayout as a LayoutManager of the container, so", "label": {"api": {"BorderLayout": [[42, 53]], "LayoutManager": [[60, 72]]}}}, {"text": "Adding swing component on BorderLayout.EAST will make it scalable vertically only", "label": {"api": {"BorderLayout": [[26, 37]], "BorderLayout.EAST": [[26, 42]]}}}, {"text": "Adding swing component on BorderLayout.WEST will make it scalable vertically only", "label": {"api": {"BorderLayout": [[26, 37]], "BorderLayout.WEST": [[26, 42]]}}}, {"text": "Adding swing component on BorderLayout.NORTH will make it scalable horizontally only", "label": {"api": {"BorderLayout": [[26, 37]], "BorderLayout.NORTH": [[26, 43]]}}}, {"text": "Adding swing component on BorderLayout.SOUTH will make it scalable horizontally only", "label": {"api": {"BorderLayout": [[26, 37]], "BorderLayout.SOUTH": [[26, 43]]}}}, {"text": "Adding swing component on BorderLayout.CENTER will make it scalable both horizontally and vertically", "label": {"api": {"BorderLayout": [[26, 37]], "BorderLayout.CENTER": [[26, 44]]}}}, {"text": "You need to use rs.next() to check if the current row is valid first", "label": {"api": {"rs.next()": [[16, 24]]}}}, {"text": "The argument to split is a regular expression, and the", "label": {"api": {"split": [[16, 20]]}}}, {"text": "I would suggest using a HashSet to remove duplicates and wrapping your char to Character", "label": {"api": {"HashSet": [[24, 30]], "Character": [[79, 87]]}}}, {"text": "Since it's nullable, then we're talking about Double (and not double)", "label": {"api": {"Double": [[46, 51]]}}}, {"text": "Instances of the wrapper type (Double) use considerably more memory than values of the primitive type (double)", "label": {"api": {"Double": [[31, 36]]}}}, {"text": "Either way, if you're so concerned with memory usage, why are you using Double at all, instead of double", "label": {"api": {"Double": [[72, 77]]}}}, {"text": "If it's just because you need a \"no value\" value, use Double.NaN", "label": {"api": {"Double": [[54, 59]], "Double.NaN": [[54, 63]]}}}, {"text": "I am not a Java programmer, but I had a short hunt around the web and it seems Java has a RandomAccessFile and you open it with the mode \"rw\"", "label": {"api": {"RandomAccessFile": [[90, 105]]}}}, {"text": "The true equivalent is to use Files.newByteChannel", "label": {"api": {"Files.newByteChannel": [[30, 49]]}}}, {"text": "You might want to take a look at the java.io package at the official docs, especially the RandomAccessFile Class and also this quick guide", "label": {"api": {"at the official docs": [[53, 72]], "RandomAccessFile Class": [[90, 111]]}}}, {"text": "The key here is to use Collections.max", "label": {"api": {"Collections.max": [[23, 37]]}}}, {"text": "To improve the complexity to O(n) I suggest you to implement the standard interface Iterator Anyway the point lies in keeping the reference to current element to be able to simply get next", "label": {"api": {"Iterator": [[84, 91]]}}}, {"text": "Specify a Comparator that ignores them..", "label": {"api": {"Comparator": [[10, 19]]}}}, {"text": "replaceAll() expects a regex as first parameter, and parantheses have special meaning there", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "use replace() instead", "label": {"api": {"replace()": [[4, 12]]}}}, {"text": "The general purpose solution is to use Pattern.quote, which takes an arbitrary string and returns a regex that matches exactly that string", "label": {"api": {"Pattern.quote": [[39, 51]]}}}, {"text": "\"match\" in Java means \"matches the whole string\"", "label": {"api": {"\"match\"": [[0, 6]]}}}, {"text": "Since your regex doesn't accept any characters after the last ] it will not \"match\" anything that has characters after the ]", "label": {"api": {"\"match\"": [[76, 82]]}}}, {"text": "You can use find to see if the string contains something that's matched by your regex (it will still have to be anchored at the beginning, since you use ^)", "label": {"api": {"find": [[12, 15]]}}}, {"text": "In other words ^\\[.*\\] will not match [Test]Hi there, but it will find [Test] within [Test]Hi there", "label": {"api": {"find": [[66, 69]]}}}, {"text": "What you're looking for is Pattern.compile(pat).matcher(str).find(), see Matcher", "label": {"api": {"Matcher": [[73, 79]]}}}, {"text": "You can do this with DecimalFormat class", "label": {"api": {"DecimalFormat": [[21, 33]]}}}, {"text": "A higher-level option is to attach to a running process using JPDA/JDI, which wraps the above call in a (Java) ModificationWatchpointEvent", "label": {"api": {"JPDA": [[62, 65]]}}}, {"text": "You can use LinkedHashMap data structure here", "label": {"api": {"LinkedHashMap": [[12, 24]]}}}, {"text": "Only the implementor knows what values should be used according to the rules for these methods", "label": {"api": {"according to the rules": [[54, 75]]}}}, {"text": "For example, MetalFileChooserUI contains a nested ApproveSelectionAction, inherited from BasicFileChooserUI, that invokes setFileFilter()", "label": {"api": {"MetalFileChooserUI": [[13, 30]]}}}, {"text": "This adds the new pattern, via a PropertyChangeEvent, to the listening MetalFileChooserUI.FilterComboBoxModel", "label": {"api": {"MetalFileChooserUI": [[71, 88]], "MetalFileChooserUI.FilterComboBoxModel": [[71, 108]]}}}, {"text": "Note that the forms of Runtime.exec(...) with a String command argument will end up using a StringTokenizer to generate the actual command tokens, which might explain the unexpected removal of newline characters", "label": {"api": {"Runtime.exec(...) with a String command argument": [[23, 70]], "StringTokenizer": [[92, 106]]}}}, {"text": "Try using a form of Runtime.exec(...) with a String array command argument so that no parsing of the string command arguments occurs", "label": {"api": {"Runtime.exec(...) with a String array command argument": [[20, 73]]}}}, {"text": "One other note that I think might be semi-relevant is deleteOnExit", "label": {"api": {"deleteOnExit": [[54, 65]]}}}, {"text": "Then, you can call getBytes() on the string if you need it as a byte array after capitalizing", "label": {"api": {"getBytes()": [[19, 28]]}}}, {"text": "Use an ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[7, 31]]}}}, {"text": "It prints 47.48000 if you use another MathContext", "label": {"api": {"MathContext": [[38, 48]]}}}, {"text": "Instead, use  ArrayList", "label": {"api": {"ArrayList": [[14, 22]]}}}, {"text": "When you initially declare your ArrayList as ArrayList<Ball>, the compiler will only let you store objects of class Ball (or its subclasses) in that list", "label": {"api": {"ArrayList": [[32, 40], [45, 53]]}}}, {"text": "MouseEvent has methods getX() and getY() that return the position relative to the source component", "label": {"api": {"MouseEvent": [[0, 9]]}}}, {"text": "Take a look at Component.getMousePosition", "label": {"api": {"Component.getMousePosition": [[15, 40]]}}}, {"text": "Try using MouseEvent.getPoint", "label": {"api": {"MouseEvent.getPoint": [[10, 28]]}}}, {"text": "There's an option to tell the parser not to use these heuristics, by setting lenient mode to false with", "label": {"api": {"lenient": [[77, 83]]}}}, {"text": "You don't need to use OpenGL specific libraries to do this, it can easily be accomplished with the Robot class, which contains a mouseMove() method - it does what it says on the tin", "label": {"api": {"mouseMove()": [[129, 139]]}}}, {"text": "Collections.reverse takes a List<?>", "label": {"api": {"Collections.reverse": [[0, 18]]}}}, {"text": "For example you can accomplish that with use of SwingWorker", "label": {"api": {"SwingWorker": [[48, 58]]}}}, {"text": "JDBC's PreparedStatement provides a facility to set null values to parameters using the setNull method", "label": {"api": {"PreparedStatement": [[7, 23]]}}}, {"text": "It would be far better to use a Map", "label": {"api": {"Map": [[32, 34]]}}}, {"text": "Maps have key-value pairs, so you could naturally store Strings and Integers in this manner", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "The same you can do with BreakIterator instead of using any external API", "label": {"api": {"BreakIterator": [[25, 37]]}}}, {"text": "If you want to parse XML based on some criteria, you can use the Java XPath API instead of DOM based parser", "label": {"api": {"Java XPath API": [[65, 78]]}}}, {"text": "A general purpose option is to use ServletContext.getRealPath to resolve the absolute filesystem path to this directory and pass it to ESAPI", "label": {"api": {"ServletContext.getRealPath": [[35, 60]]}}}, {"text": "[EDIT] When the standard says that this function should never return -1, that doesn't enforce this", "label": {"api": {"the standard says": [[12, 28]]}}}, {"text": "We all know that Set(Except their such implementation) doesn't guarantee of iteration ordering .So i tried to make sure this with below sample code", "label": {"api": {"Set": [[17, 19]]}}}, {"text": "My question is if java claims HashMap is unordered then why this records are printing in order", "label": {"api": {"HashMap": [[30, 36]]}}}, {"text": "You can read the integers directly from the file using java.util.Scanner and specify a delimiter using Scanner.useDelimiter(Pattern), where the delimiter would be a regular expression (\"[,() ]{1,}\" for example)", "label": {"api": {"java.util.Scanner": [[55, 71]], "Scanner.useDelimiter(Pattern)": [[103, 131]]}}}, {"text": "Can you rewrite your code to use JMS standard (ConnectionFactory or QueueConnectionFactory)instead of a Websphere MQ specific implementation class", "label": {"api": {"ConnectionFactory": [[47, 63], [73, 89]], "QueueConnectionFactory": [[68, 89]]}}}, {"text": "PhantomReferences may also be of interest", "label": {"api": {"PhantomReferences": [[0, 16]]}}}, {"text": "What you're probably interested in is a JTree instead", "label": {"api": {"JTree": [[40, 44]]}}}, {"text": "You can use the URL method openStream, which returns an InputStream you can use to read your file", "label": {"api": {"URL": [[16, 18]]}}}, {"text": "The URL will work for files inside and outside the JAR", "label": {"api": {"URL": [[4, 6]]}}}, {"text": "Just take care to use a valid URL", "label": {"api": {"URL": [[30, 32]]}}}, {"text": "You can setup a DefaultUncaughtExceptionHandler for your project to deal with uncaught exceptions", "label": {"api": {"setup a DefaultUncaughtExceptionHandler": [[8, 46]]}}}, {"text": "Here's the section in the javadoc for Calendar.YEAR", "label": {"api": {"Here's": [[0, 5]]}}}, {"text": "If you look at the value of YEAR, you'll see it's actually static final with a value of 1", "label": {"api": {"with a value of 1": [[72, 88]]}}}, {"text": "See the documentation for trim for more details", "label": {"api": {"documentation for trim": [[8, 29]]}}}, {"text": "A better approach would be to use Runtime.exec(String[])", "label": {"api": {"Runtime.exec(String[])": [[34, 55]]}}}, {"text": "I'm trying to make a digital signature of a file for which I'm using this tutorial from oracle", "label": {"api": {"this tutorial": [[69, 81]]}}}, {"text": "Take a look at NumberFormat and DecimalFormat", "label": {"api": {"NumberFormat": [[15, 26]], "DecimalFormat": [[32, 44]]}}}, {"text": "There's a class called NumberFormat which will handle printing numbers in a certain format and also parsing a String representing a number into an actual Number", "label": {"api": {"NumberFormat": [[23, 34]]}}}, {"text": "DecimalFormat is a concrete subclass of NumberFormat, you can use DecimalFormat to e.g", "label": {"api": {"NumberFormat": [[40, 51]], "DecimalFormat": [[0, 12], [66, 78]]}}}, {"text": "You can also use DecimalFormat for currency formatting", "label": {"api": {"DecimalFormat": [[17, 29]]}}}, {"text": "Another option besides my more general concurrency answer is to use Java's Proxy class", "label": {"api": {"Proxy": [[75, 79]]}}}, {"text": "To use Proxy, you need an interface", "label": {"api": {"Proxy": [[7, 11]]}}}, {"text": "Java's Proxy needs two things to work", "label": {"api": {"Proxy": [[7, 11]]}}}, {"text": "the interface (got that) and an InvocationHandler", "label": {"api": {"InvocationHandler": [[32, 48]]}}}, {"text": "The InvocationHandler is what will execute the methods in the background threads", "label": {"api": {"InvocationHandler": [[4, 20]]}}}, {"text": "Here's how we can create the Proxy with an instance of FooImpl", "label": {"api": {"Proxy": [[29, 33]]}}}, {"text": "Now we just have to write BackgroundInvocationHandler", "label": {"api": {"InvocationHandler": [[36, 52]]}}}, {"text": "The Proxy instance will return null for anything that returns something that's not void", "label": {"api": {"Proxy": [[4, 8]]}}}, {"text": "It has namely also a constructor taking an input stream", "label": {"api": {"constructor taking an input stream": [[21, 54]]}}}, {"text": "It accepts by the way the charset as 2nd argument, you might want to make use of it if the text file is possibly in a different character encoding than the platform default one, otherwise you might risk Mojibake", "label": {"api": {"charset as 2nd argument": [[26, 48]]}}}, {"text": "Use the socket.getInetAddress() to get an InetAddress object including the IP address then call the InetAddress.getHostAddress() to get it as a string", "label": {"api": {"socket.getInetAddress()": [[8, 30]], "InetAddress": [[18, 28], [42, 52], [100, 110]], "InetAddress.getHostAddress()": [[100, 127]]}}}]