[{"text": "Use a JProgressBar for displaying the progress of the task", "label": {"api": {"JProgressBar": [[6, 17]]}}}, {"text": "The SwingWorker offers easy access to both", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "Write your retriever task as a Callable that returns the HTML then submit these callables with the appropriate URLs to an ExecutorService", "label": {"api": {"Callable": [[31, 38]], "ExecutorService": [[122, 136]]}}}, {"text": "Your tasks could put the site contents into a BlockingQueue and let the processor thread poll in periodically to look for ready data", "label": {"api": {"BlockingQueue": [[46, 58]]}}}, {"text": "Why does public void printStackTrace(PrintStream s) in the Throwable class take a PrintWriter, instead of a Writer", "label": {"api": {"public void printStackTrace(PrintStream s)": [[9, 50]]}}}, {"text": "According to the Javadoc for Long, Long.MAX_Value is defined as 2^63 - 1", "label": {"api": {"Long.MAX_Value": [[35, 48]]}}}, {"text": "Since you are using # flag in format string, you should pass Formattable as an argument (doc)", "label": {"api": {"Formattable": [[61, 71]]}}}, {"text": "You asked for a workaround; just use StringBuilder", "label": {"api": {"StringBuilder": [[37, 49]]}}}, {"text": "Any reasons why you are not simply using String#replace", "label": {"api": {"String#replace": [[41, 54]]}}}, {"text": "To be usable with the publish() method in the way described in your question, tomcat would have to provide a Sun HTTP Server Service Provider Implementation, which it does not", "label": {"api": {"Sun HTTP Server Service Provider Implementation": [[109, 155]]}}}, {"text": "The Runtime.exec methods returns a Process on which you can call the waitFor method", "label": {"api": {"the waitFor method": [[65, 82]]}}}, {"text": "You should implement Application.stop() to detect the application shutdown event", "label": {"api": {"Application.stop()": [[21, 38]]}}}, {"text": "Correct synchronization in a multi-threaded Java program hinges on the happens-before relation, summarized in Memory Consistency Properties", "label": {"api": {"Memory Consistency Properties": [[110, 138]]}}}, {"text": "The evolution of javax.swing has been away from GUI API promises, as mentioned here, and toward more flexible concurrent programming tools", "label": {"api": {"concurrent programming tools": [[110, 137]]}}}, {"text": "framework's F.Callback, or Commons Collections4's Closure [later edit:] or Java 8+ Consumer-based interfaces", "label": {"api": {"Java 8+ Consumer": [[75, 90]]}}}, {"text": "I have a SortedMap, ordered according to the natural ordering of its keys", "label": {"api": {"SortedMap": [[9, 17]]}}}, {"text": "Can I safely cast its keySet() to a SortedSet, without risking an invalid cast exception", "label": {"api": {"SortedSet": [[36, 44]]}}}, {"text": "If the answer is \"depends on the implementation of SortedMap\", is this at a minimum safe for a TreeMap", "label": {"api": {"SortedMap": [[51, 59]], "TreeMap": [[95, 101]]}}}, {"text": "You should be separating the command from it's arguments in the call to exec(), such as", "label": {"api": {"separating the command from it's arguments in the call to exec()": [[14, 77]]}}}, {"text": "You seem to need ReferenceQueue if you want to know when an object can be garbaged, and maybe WeakReference if you want to keep pointers which don't prevent the garbage", "label": {"api": {"ReferenceQueue": [[17, 30]], "WeakReference": [[94, 106]]}}}, {"text": "I suggest you have a look at the description of the java.lang.ref package to find the best solution for your need", "label": {"api": {"java.lang.ref package": [[52, 72]]}}}, {"text": "Which is the objective of the method getDefaultValue() in class java.lang.reflect.Method ?, can someone point me out a situation where this method is useful ?", "label": {"api": {"getDefaultValue()": [[37, 53]]}}}, {"text": "You need a URLStreamHandler that handles the \"cid\" URL protocol and supplies the data from the appropriate part of the MIME message", "label": {"api": {"URLStreamHandler": [[11, 26]]}}}, {"text": "I believe you need to configure the URLStreamHandler by creating a URLStreamHandlerFactory and calling the URL.setURLStreamHandlerFactory method", "label": {"api": {"URLStreamHandler": [[36, 51], [67, 82], [114, 129]], "URLStreamHandlerFactory": [[67, 89], [114, 136]], "URL.setURLStreamHandlerFactory method": [[107, 143]]}}}, {"text": "The trick, as I remember, is that there's no way to get the default URLStreamHandlerFactory so that your version can delegate to the default version for all the other URL protocols", "label": {"api": {"URLStreamHandler": [[68, 83]], "URLStreamHandlerFactory": [[68, 90]]}}}, {"text": "I would recommend the ProcessBuilder, especially for additional arguments", "label": {"api": {"ProcessBuilder": [[22, 35]]}}}, {"text": "You're casting the result of Math.min(), which returns a double, to that of a float", "label": {"api": {"Math.min()": [[29, 38]]}}}, {"text": "If you have to use substring then you need to use the variant of indexOf that takes a start", "label": {"api": {"variant of indexOf that takes a start": [[54, 90]]}}}, {"text": "You can use a StringTokenizer", "label": {"api": {"StringTokenizer": [[14, 28]]}}}, {"text": "Or you can use the String.split method which is designed for splitting strings", "label": {"api": {"String.split": [[19, 30]]}}}, {"text": "LinkedList<E>.poll() returns either the object in the linked list, or null if the list is empty", "label": {"api": {"LinkedList<E>.poll()": [[0, 19]]}}}, {"text": "String's intern() method) instead of creating a new objects (like other serializers generally do)", "label": {"api": {"intern()": [[9, 16]]}}}, {"text": "XPath based querying seems more apt to this situation as you know the nodes you are interested in", "label": {"api": {"XPath": [[0, 4]]}}}, {"text": "I'm guessing the setImageableArea() method uses the same units, but the documentation for PageFormat is not entirely clear", "label": {"api": {"documentation for PageFormat": [[72, 99]]}}}, {"text": "You can use a ScriptEngine", "label": {"api": {"ScriptEngine": [[14, 25]]}}}, {"text": "In pure Java there is implementation from Swing look at TreeNode class For serialization to JSON you can use for example google-gson", "label": {"api": {"TreeNode class": [[56, 69]]}}}, {"text": "You're better off using Character.isDigit(char) and Character.getNumericValue(char) to test and convert a char into an integer value", "label": {"api": {"Character.isDigit(char)": [[24, 46]], "Character.getNumericValue(char)": [[52, 82]]}}}, {"text": "Look at java.util.concurrent.TimeUnit enum, you may use the units from here", "label": {"api": {"java.util.concurrent.TimeUnit": [[8, 36]]}}}, {"text": "Hibernate will only update the database if the entity belongs to the current persistence context, which you can check by using entityManager.contains(), e.g.", "label": {"api": {"entityManager.contains()": [[127, 150]]}}}, {"text": "BigInteger(int numBits, Random rnd)", "label": {"api": {"BigInteger(int numBits, Random rnd)": [[0, 34]]}}}, {"text": "I think the easier approach is letting your app accepting an extra parameter like --timeout=120s, and using this parameter to make a Timer that gracefully ends the main loop (I think you'll have some sort of control variable, a PID file or anything)", "label": {"api": {"Timer": [[133, 137]]}}}, {"text": "Obviously, when the parameter is not set, the Timer is not created at all and you'll use your normal way to tell the program to stop", "label": {"api": {"Timer": [[46, 50]]}}}, {"text": "If you also want to support queuing with your deque down the road (similar to how LinkedList implements both Deque and Queue) then you'll need to keep prev", "label": {"api": {"LinkedList": [[82, 91]]}}}, {"text": "You can read about formatting syntax here http://docs.oracle.com/javase/6/docs/api/java/util/Formatter.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Formatter.html": [[42, 106]]}}}, {"text": "use string.split(\":\") in order to get the 2 sides of the string ..", "label": {"api": {"string.split(\":\")": [[4, 20]]}}}, {"text": "You could use DatatypeConverter.parseBase64Binary()", "label": {"api": {"DatatypeConverter.parseBase64Binary()": [[14, 50]]}}}, {"text": "Reader is an abstract class, so you must instantiate an implementation of it, such as BufferedReader or InputStreamReader", "label": {"api": {"Reader": [[0, 5], [94, 99], [115, 120]], "BufferedReader": [[86, 99]], "InputStreamReader": [[104, 120]]}}}, {"text": "That being said, there is something similar for other kinds of Sets that do impose a total order --  SortedSets", "label": {"api": {"SortedSet": [[101, 109]]}}}, {"text": "There exists an analogous subSet, as well as headSet and tailSet which have similar functions", "label": {"api": {"subSet": [[26, 31]], "headSet": [[45, 51]], "tailSet": [[57, 63]]}}}, {"text": "These also exist in NavigableSet along with other methods like ceiling, floor, etc", "label": {"api": {"NavigableSet": [[20, 31]], "ceiling": [[63, 69]], "floor": [[72, 76]]}}}, {"text": "List order is essentially arbitrary, whatever the user intended, while SortedSets order using a comparison sort", "label": {"api": {"SortedSet": [[71, 79]]}}}, {"text": "You can use a LinkedHashSet and maintain the order", "label": {"api": {"LinkedHashSet": [[14, 26]]}}}, {"text": "The java compiler actually creates a StringBuilder1 and invokes the append() method", "label": {"api": {"StringBuilder": [[37, 49]]}}}, {"text": "See the asList() method", "label": {"api": {"asList()": [[8, 15]]}}}, {"text": "See the addAll() method", "label": {"api": {"addAll()": [[8, 15]]}}}, {"text": "See the Collections.sort() method or create your own Comparator and apply the sorting", "label": {"api": {"Collections.sort()": [[8, 25]], "Comparator": [[53, 62]]}}}, {"text": "e) Convert the List to an int array using the toArray(T[] t)method", "label": {"api": {"toArray(T[] t)": [[46, 59]]}}}, {"text": "It is hard to figure out what you are really asking, but the place to find implementations of the trigonometric functions like sine, cosine and tangent is the java.lang.Math class", "label": {"api": {"java.lang.Math": [[159, 172]]}}}, {"text": "Use the String.toCharArray() function", "label": {"api": {"String.toCharArray()": [[8, 27]]}}}, {"text": "In addition to checking each letter separately, you can check all letters at once (or any subset that you'd like) with regular expressions", "label": {"api": {"regular expressions": [[119, 137]]}}}, {"text": "This is somewhat buried in the docs; the javadoc of getClass() writes", "label": {"api": {"javadoc of getClass()": [[41, 61]]}}}, {"text": "A DefaultListCellRenderer is a JLabel, so you can use setIcon() with an ImageIcon", "label": {"api": {"DefaultListCellRenderer": [[2, 24]]}}}, {"text": "You probably meant to implement Comparable, not Comparator", "label": {"api": {"to implement Comparable": [[19, 41]]}}}, {"text": "That's what the Collections#sort method expects", "label": {"api": {"the Collections#sort method expects": [[12, 46]]}}}, {"text": "You should be implementing Comparable, not Comparator", "label": {"api": {"Comparable": [[27, 36]], "Comparator": [[43, 52]]}}}, {"text": "You can serialize any object via ObjectOutputStream (Note that you must add implements Serializable to your class Block)", "label": {"api": {"ObjectOutputStream": [[33, 50]]}}}, {"text": "you can use a custom comparator and use a cursor to traverse the data in descending order", "label": {"api": {"custom comparator": [[14, 30]], "cursor": [[42, 47]]}}}, {"text": "The same pattern symbols are by the way also used on Java SE's own SimpleDateFormat class", "label": {"api": {"SimpleDateFormat class": [[67, 88]]}}}, {"text": "List listens to change events from its ListModel", "label": {"api": {"ListModel": [[39, 47]]}}}, {"text": "Looking at DefaultListModel interface it should be possible, there are methods to modify it, such as addElement, removeElement, etc", "label": {"api": {"ListModel": [[18, 26]], "DefaultListModel": [[11, 26]]}}}, {"text": "Well System.currentTimeMillis() isn't in java.util - is that what you were looking for", "label": {"api": {"System.currentTimeMillis()": [[5, 30]]}}}, {"text": "I'd suggest using Either[java.lang.Throwable, A] (where Throwable still gives you access to the stack trace), and (in general) making your custom error types extend java.lang.Exception", "label": {"api": {"Throwable": [[35, 43], [56, 64]]}}}, {"text": "This is the practice used by Dispatch 0.9, for example, where Either[Throwable, A] is used to represent computations that may fail, and the custom error types look like this", "label": {"api": {"Throwable": [[69, 77]]}}}, {"text": "=> T) also returns a Validation[Throwable, T], where Validation is roughly equivalent to Either", "label": {"api": {"Throwable": [[32, 40]]}}}, {"text": "a flat array, then you can read the file with a Scanner and a simple loop", "label": {"api": {"Scanner": [[48, 54]]}}}, {"text": "Scanner uses whitespace as the default delimiter, skipping multiple whitespaces", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "You'll need to handle exceptions on Scanner.nextInt", "label": {"api": {"Scanner": [[36, 42]]}}}, {"text": "You can read the file using Scanner.nextLine() to get individual lines as String", "label": {"api": {"Scanner": [[28, 34]]}}}, {"text": "You could also use a second Scanner to tokenize each individual line in an inner loop", "label": {"api": {"Scanner": [[28, 34]]}}}, {"text": "Scanner will discard any leading whitespace for you, so you can leave off the trim", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "Now, if you want to bind a mouse listener, you can do it directly on the JTable and you can use getCellRect to find out if the click is inside a particular cell, or use columnAtPoint and rowAtPoint to find out which cell was clicked", "label": {"api": {"getCellRect": [[96, 106]], "columnAtPoint": [[169, 181]], "rowAtPoint": [[187, 196]]}}}, {"text": "Then use Character.toChars() to get the corresponding char values (usually just one, but for characters outside the BMP there will be two surrogate values)", "label": {"api": {"Character.toChars()": [[9, 27]]}}}, {"text": "Instead, take advantage of the methods on the ThreadLocalRandom class", "label": {"api": {"ThreadLocalRandom": [[46, 62]]}}}, {"text": "See Collections.newSetFromMap java docs", "label": {"api": {"Collections.newSetFromMap": [[4, 28]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/lang/SafeVarargs.html explains this in futher detail", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/SafeVarargs.html": [[0, 66]]}}}, {"text": "See the Method API for more details", "label": {"api": {"Method API": [[8, 17]]}}}, {"text": "This will call the Arrays#sort method", "label": {"api": {"the Arrays#sort method": [[15, 36]]}}}, {"text": "Your output clearly says that you pass int[] and boolean[] into your constructor, not Integer and Boolean as you say (see Class.getName() for the meaning of binary type names such as [I)", "label": {"api": {"Class.getName()": [[122, 136]]}}}, {"text": "For pre-Java 7 code, read up on the counting Semaphore in Java (and in general)", "label": {"api": {"Semaphore": [[45, 53]]}}}, {"text": "You should be able to use RandomAccessFile", "label": {"api": {"RandomAccessFile": [[26, 41]]}}}, {"text": "If you want to make your life easier, write a service class for your particular file to wrap the RandomAccessFile methods", "label": {"api": {"RandomAccessFile": [[97, 112]]}}}, {"text": "Java provides the concept of a ThreadLocal variable", "label": {"api": {"ThreadLocal": [[31, 41]]}}}, {"text": "You can use it within your Runnable like this", "label": {"api": {"Runnable": [[27, 34]]}}}, {"text": "Thereby for each thread running your Runnable only a single instance of your class SlowObject is created", "label": {"api": {"Runnable": [[37, 44]]}}}, {"text": "You need the equals method", "label": {"api": {"equals": [[13, 18]]}}}, {"text": "Note that there is also a equalsIgnoreCase method, which may be useful if the user may enter \"Hello\" instead of \"hello\"", "label": {"api": {"equals": [[26, 31]], "equalsIgnoreCase": [[26, 41]]}}}, {"text": "BigInteger would help you achieve what you want", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "You can try BigInteger from java.math", "label": {"api": {"BigInteger": [[12, 21]]}}}, {"text": "Character.isUpperCase(char c) takes in a character", "label": {"api": {"Character.isUpperCase(char c)": [[0, 28]]}}}, {"text": "You should try using StringTokenizer", "label": {"api": {"StringTokenizer": [[21, 35]]}}}, {"text": "JAX-RS is a set of interfaces and classes without real implementation that belong to javax.ws.rs.* packages (they are part of Java SE 6, by Oracle)", "label": {"api": {"javax.ws.rs.*": [[85, 97]]}}}, {"text": "I've used the Java CompletionService here, or more specifically the ExecutorCompletionService (as it uses an executor to run in parrallel)", "label": {"api": {"ExecutorCompletionService": [[68, 92]]}}}, {"text": "out for info, also http://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html could be of help", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html": [[19, 90]]}}}, {"text": "You can define your own Comparator and use Collections.sort(), passing that Comparator in", "label": {"api": {"Comparator": [[24, 33], [76, 85]], "Collections.sort()": [[43, 60]]}}}, {"text": "Alternatively your struct can implement the Comparable interface and Collections.sort() can sort using this", "label": {"api": {"Collections.sort()": [[69, 86]], "Comparable": [[44, 53]]}}}, {"text": "Use java.util.Collections.sort() with a Comparator instance", "label": {"api": {"java.util.Collections.sort()": [[4, 31]]}}}, {"text": "Use a JCheckBoxMenuItem for check boxes in a menu", "label": {"api": {"JCheckBoxMenuItem": [[6, 22]]}}}, {"text": "I'm writing a simple web browser using the JavaFX WebView", "label": {"api": {"WebView": [[50, 56]]}}}, {"text": "See the API documentation of java.awt.image.BufferedImage", "label": {"api": {"java.awt.image.BufferedImage": [[29, 56]]}}}, {"text": "You can use the getRGB(...) method in the Java  BufferedImage class", "label": {"api": {"getRGB(...)": [[16, 26]]}}}, {"text": "Your particular situation would be better done using a BlockingQueue", "label": {"api": {"BlockingQueue": [[55, 67]]}}}, {"text": "Multiple threads can put and take all at the same time, and the LinkedBlockingQueue will handle the concurrency for you", "label": {"api": {"BlockingQueue": [[70, 82]]}}}, {"text": "There is ServideLoader class for this purpose", "label": {"api": {"ServideLoader": [[9, 21]]}}}, {"text": "Have you tried using the  drawImage", "label": {"api": {"drawImage": [[26, 34]]}}}, {"text": "You could use JSplitPane.setDividerLocation(int) instead..", "label": {"api": {"JSplitPane.setDividerLocation(int)": [[14, 47]]}}}, {"text": "Use .values() to get a collection containing all the values of the hash map, and then use Collections.frequency() to count the number of objects in the collection", "label": {"api": {".values()": [[4, 12]], "Collections.frequency()": [[90, 112]]}}}, {"text": "get super class using Class.getSuperclass()", "label": {"api": {"Class.getSuperclass()": [[22, 42]]}}}, {"text": "Shuffle this list using Collections.shuffle(...)", "label": {"api": {"Collections.shuffle(...)": [[24, 47]]}}}, {"text": "The NavigableSet interface offers a number of useful methods that a normal Set does not (specifically I'm thinking about methods like headSet and tailSet for instance)", "label": {"api": {"NavigableSet": [[4, 15]], "Set": [[13, 15], [75, 77], [138, 140], [150, 152]]}}}, {"text": "However, being a Set, it does not support duplicate elements", "label": {"api": {"Set": [[17, 19]]}}}, {"text": "Also, being a SortedSet, the ordering must be consistent with equals and hashCode to avoid violating the contract of the Set interface", "label": {"api": {"Set": [[20, 22], [121, 123]], "SortedSet": [[14, 22]]}}}, {"text": "As a motivating example, consider the following code that shows why a NavigableSet is not appropriate", "label": {"api": {"NavigableSet": [[70, 81]], "Set": [[79, 81]]}}}, {"text": "Notice that element a only gets added once (of course, since this is a Set)", "label": {"api": {"Set": [[71, 73]]}}}, {"text": "You could use a TreeSet and use it's subSet method", "label": {"api": {"TreeSet": [[16, 22]], "subSet": [[37, 42]]}}}, {"text": "Alternatively, If you do not know the elements and want to return the elements between two points you can use an ArrayList constructed with the Set and use the subList method", "label": {"api": {"subList": [[160, 166]]}}}, {"text": "Your method could start with calling sameFile()", "label": {"api": {"sameFile()": [[37, 46]]}}}, {"text": "If that evaluates to true, you then call getQuery(), and split it into it's components - probably with String.split(\"\\&\")", "label": {"api": {"getQuery()": [[41, 50]], "String.split(\"\\&\")": [[103, 120]]}}}, {"text": "Have a look at JTextComponent#getSelectedText()", "label": {"api": {"JTextComponent#getSelectedText()": [[15, 46]]}}}, {"text": "Yes, use a Queue to do an iterative breadth-first search", "label": {"api": {"Queue": [[11, 15]]}}}, {"text": "Contract of List#equals", "label": {"api": {"Contract of List#equals": [[0, 22]]}}}, {"text": "You should include the time zone you're interested in in the GregorianCalendar, either by passing it to the constructor or by setting it afterwards", "label": {"api": {"the constructor": [[104, 118]], "setting it afterwards": [[126, 146]]}}}, {"text": "You can try to use Socket API from Java for this", "label": {"api": {"Socket": [[19, 24]]}}}, {"text": "You need to use the BigDecimal class", "label": {"api": {"BigDecimal": [[20, 29]]}}}, {"text": "A more obvious choice would be BitSet which is designed for this sort of thing", "label": {"api": {"BitSet": [[31, 36]]}}}, {"text": "For creating/modifying it would be more efficient to use a BitSet", "label": {"api": {"BitSet": [[59, 64]]}}}, {"text": "PaulG has commented the difference is \"impressive\" and BitSet is faster", "label": {"api": {"BitSet": [[55, 60]]}}}, {"text": "Java has a more convenient class for this, called BitSet", "label": {"api": {"BitSet": [[50, 55]]}}}, {"text": "For details about all aspects of Java regex notation, see the Javadoc for java.util.regex.Pattern", "label": {"api": {"the Javadoc for java.util.regex.Pattern": [[58, 96]]}}}, {"text": "You can use Arrays.equals() to compare the two arrays, then assert that they are equivalent", "label": {"api": {"Arrays.equals()": [[12, 26]]}}}, {"text": "Arrays.equals() checks the length and each element in the array, so you won't have to worry about iterating over each array", "label": {"api": {"Arrays.equals()": [[0, 14]]}}}, {"text": "Every other class in Java inherits from the Object class", "label": {"api": {"Object": [[44, 49]]}}}, {"text": "Is it possible to add a second, completely separate, class hierarchy in Java based around my own FastObject class", "label": {"api": {"Object": [[101, 106]]}}}, {"text": "Is the real solution to ignore Object and look at replacing java.lang.Class", "label": {"api": {"Object": [[31, 36]]}}}, {"text": "To be clear, I don't just want to edit the root Object class", "label": {"api": {"Object": [[48, 53]]}}}, {"text": "Otherwise the best solution is to put items of second array into Set and use it's efficient methods (contains) to resolve if the collection has items", "label": {"api": {"Set": [[65, 67]]}}}, {"text": "Try using File class and createNewFile", "label": {"api": {"createNewFile": [[25, 37]]}}}, {"text": "Collections#sort expects a List while you are passing an array", "label": {"api": {"Collections#sort": [[0, 15]]}}}, {"text": "The reason it's an error is that java is inferring the wrong type, but you can make it compile, without casting, by specifying the type in the call to the typed method Arrays.asList()", "label": {"api": {"Arrays.asList()": [[168, 182]]}}}, {"text": "You can use a Transformer to apply arbitrary XSLT to a document (XML or otherwise) using java", "label": {"api": {"Transformer": [[14, 24]]}}}, {"text": "String replace method is a useful tool here", "label": {"api": {"String replace method": [[0, 20]]}}}, {"text": "The correct answer is, don't use replaceAll() (which replaces regexes), use replace() which simply replaces a character", "label": {"api": {"replaceAll()": [[33, 44]], "replace()": [[76, 84]]}}}, {"text": "You can use Scanner.hasNextInt() and if not this is true, read char for char unto hasNextInt is true", "label": {"api": {"Scanner.hasNextInt()": [[12, 31]]}}}, {"text": "You can create a TreeSet with your own Comparator", "label": {"api": {"TreeSet": [[17, 23]]}}}, {"text": "StringWriter has a flush function", "label": {"api": {"flush": [[19, 23]]}}}, {"text": "What does it mean to flush a string buffer", "label": {"api": {"flush": [[21, 25]]}}}, {"text": "You can use any implementation of Map to store your animal's name as key and List of answers as value", "label": {"api": {"Map": [[34, 36]]}}}, {"text": "There are parameters, related to namespace, that can be passed to Exclusive XML Canonicalization that describe the InclusiveNamespaces PrefixList", "label": {"api": {"Exclusive XML Canonicalization": [[66, 95]]}}}, {"text": "You could try passing a ExcC14NParameterSpec to newCanonicalizationMethod() using a prefix list to see if that affects the canonicalization of the namespaces", "label": {"api": {"ExcC14NParameterSpec": [[24, 43]]}}}, {"text": "I think you can see the fact that is a new String best when using System.identityHashCode()", "label": {"api": {"System.identityHashCode()": [[66, 90]]}}}, {"text": "You can use a ScheduledExecutorService - that will only use the resources needed by your checkDate method (+ a slight overhead that won't be noticeable)", "label": {"api": {"a ScheduledExecutorService": [[12, 37]]}}}, {"text": "The problem is likely that you are using a BufferedReader instead of an InputStream", "label": {"api": {"BufferedReader": [[43, 56]]}}}, {"text": "Try switching to a BufferedInputStream instead", "label": {"api": {"BufferedInputStream": [[19, 37]]}}}, {"text": "Also you can take a look at ProcessBuilder", "label": {"api": {"ProcessBuilder": [[28, 41]]}}}, {"text": "I would define a Lock object in the class/method that initiates this task and make the Lock object available to all the classes involved, explicitly, by passing as a constructor argument", "label": {"api": {"Lock": [[17, 20], [87, 90]]}}}, {"text": "You should close your Scanner when you're done with it", "label": {"api": {"close": [[11, 15]]}}}, {"text": "You may also take a look at the Console class", "label": {"api": {"Console": [[32, 38]]}}}, {"text": "If you want to find the list of files in a directory, use File.listFiles()", "label": {"api": {"File.listFiles()": [[58, 73]]}}}, {"text": "The brief description of java.util.concurrent.LinkedBlockingQueue says it is a FIFO queue, which means if thread A adds a bunch of entries (a1, a2, ..", "label": {"api": {"java.util.concurrent.LinkedBlockingQueue": [[25, 64]]}}}, {"text": "I would generally recommend using a Scanner just because it makes everything so easy", "label": {"api": {"Scanner": [[36, 42]]}}}, {"text": "If you want to use something from java.io, you could use a BufferedReader in conjunction with an InputStreamReader", "label": {"api": {"BufferedReader": [[59, 72]], "InputStreamReader": [[97, 113]]}}}, {"text": "If for some reason you need to lock across all objects then I'd wrap your lock in a singleton and write some lock/unlock methods using a ReentrantLock", "label": {"api": {"ReentrantLock": [[137, 149]]}}}, {"text": "Or you can send the Class as a constructor argument and use that object instead of trying to get T.class", "label": {"api": {"Class": [[20, 24]]}}}, {"text": "which is also explained in the JavaDocs for Deque.iterator()", "label": {"api": {"Deque.iterator()": [[44, 59]]}}}, {"text": "Use Arrays.sort to sort your arrays", "label": {"api": {"Arrays.sort": [[4, 14]]}}}, {"text": "The class javadoc of the Action interface also contains a nice overview table of the available keys and what they affect", "label": {"api": {"class javadoc of the Action interface": [[4, 40]]}}}, {"text": "If you're relying on people having an external library in their path (instead of using the JNA JAR wrapping features), you can simply check using System.loadLibrary", "label": {"api": {"System.loadLibrary": [[146, 163]]}}}, {"text": "Using the ref package, you can be notified if an object is about to be garbaged (and act at this time) but there is no count available (and not always one handled by the VM)", "label": {"api": {"the ref package": [[6, 20]]}}}, {"text": "It only does authentication and it's just a wrapper around the Java JAAS API Krb5LoginModule", "label": {"api": {"Krb5LoginModule": [[77, 91]]}}}, {"text": "There is a MultivaluedMap interface in JAX-RS with a 'MultivaluedMapImpl' in Jersey", "label": {"api": {"MultivaluedMap": [[11, 24], [54, 67]]}}}, {"text": "In addition to the other answers, if you want to vertically stack Swing components, use the BoxLayout layout manager", "label": {"api": {"BoxLayout": [[92, 100]]}}}, {"text": "For more information, see How to Use BoxLayout", "label": {"api": {"BoxLayout": [[37, 45]]}}}, {"text": "You can use java.net.URLEncoder.encode on conjunction with your StringUtils.replaceEach", "label": {"api": {"java.net.URLEncoder.encode": [[12, 37]]}}}, {"text": "I have read the documetation at http://docs.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html, but I am not able to find the error", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html": [[32, 107]]}}}, {"text": "Once you're done writing, you should essentially call close() on your BufferedWriter object", "label": {"api": {"close()": [[54, 60]]}}}, {"text": "You can use Java lock objects and Condition objects", "label": {"api": {"lock": [[17, 20]], "Condition": [[34, 42]]}}}, {"text": "Condition class' java docs gives a very good isFull and isEmpty example too", "label": {"api": {"Condition": [[0, 8]]}}}, {"text": "Also take a look at the other ON_CLOSE values that you can pass in the setDefaultCloseOperation javadocs", "label": {"api": {"setDefaultCloseOperation": [[71, 94]]}}}, {"text": "Take a look at Thread#join()", "label": {"api": {"Thread#join()": [[15, 27]]}}}, {"text": "However, it is possible to kill a process", "label": {"api": {"process": [[34, 40]]}}}, {"text": "If you spawn each sorting algorithm in a separate process, then you can kill it forcibly", "label": {"api": {"process": [[50, 56]]}}}, {"text": "The downside is that interacting with the process is significantly harder than interacting with a thread, since you don't have shared variables", "label": {"api": {"process": [[42, 48]]}}}, {"text": "Then iterate through the classes and create the instances using either Class.newInstance (no-args constructors) or Class.getConstructor and Constructor.newInstance when there are parameters for the constructor that you have to pass", "label": {"api": {"Class.newInstance": [[71, 87]], "Class.getConstructor": [[115, 134]], "Constructor.newInstance": [[140, 162]]}}}, {"text": "For your two missing methods, the methods List.indexOf() and List.remove() will be invaluable here", "label": {"api": {"List.indexOf()": [[42, 55]], "List.remove()": [[61, 73]]}}}, {"text": "ThreadPoolExecutor is your friend", "label": {"api": {"ThreadPoolExecutor": [[0, 17]]}}}, {"text": "Sample based on the WebView documentation", "label": {"api": {"WebView documentation": [[20, 40]]}}}, {"text": "From JEditorPane Javadocs", "label": {"api": {"JEditorPane Javadocs": [[5, 24]]}}}, {"text": "clone() is protected method and to make accessible in sub-classes, override it with public access", "label": {"api": {"clone()": [[0, 6]]}}}, {"text": "My Algorithm is to use Java Zip API and create a zip file of the file to be sent,then I will divide the Zip file into 5 parts", "label": {"api": {"Java Zip API": [[23, 34]]}}}, {"text": "An even cleaner solution might be to use the built-in comparingInt() method", "label": {"api": {"comparingInt()": [[54, 67]]}}}, {"text": "use comparator or comparable interfaces", "label": {"api": {"comparable": [[18, 27]]}}}, {"text": "Better way to execute same program is using Thread#join() method", "label": {"api": {"Thread#join()": [[44, 56]]}}}, {"text": "All classes get a default equals(...) method from the ultimate parent class, Object, which if not overridden will do the very same thing as ==, as per the API", "label": {"api": {"Object": [[77, 82]], "API": [[155, 157]]}}}, {"text": "The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true)", "label": {"api": {"Object": [[28, 33]]}}}, {"text": "For more details on how String does this, please check out its API which states", "label": {"api": {"API": [[63, 65]]}}}, {"text": "Use getResourceAsStream(String name) or getResources(String name) and provide the package name and resource name separated and prefixed by '/'", "label": {"api": {"getResourceAsStream(String name)": [[4, 35]]}}}, {"text": "Inside the class which you want to access the resource from you'd do (getResourceAsStream(String name))", "label": {"api": {"getResourceAsStream(String name)": [[70, 101]]}}}, {"text": "Consider using equalsIgnoreCase(String anotherString) to compare whether the user's input is a sum, difference, product or a remainder", "label": {"api": {"equalsIgnoreCase(String anotherString)": [[15, 52]]}}}, {"text": "You can do this with an identity Transformer from a DOMSource to a StAXResult", "label": {"api": {"identity Transformer": [[24, 43]]}}}, {"text": "Then I would suggest a HashSet", "label": {"api": {"HashSet": [[23, 29]]}}}, {"text": "Note that when you use your own class to represent URIs and not the default class java.net.URI, you will have to override the int hashCode() method of your URI class to return a text-based hash of the URI string", "label": {"api": {"java.net.URI": [[82, 93]], "int hashCode()": [[126, 139]]}}}, {"text": "You could also use the Collections framework and use the replaceAll function", "label": {"api": {"replaceAll": [[57, 66]]}}}, {"text": "The replaceAll method has a similar signature to you count method", "label": {"api": {"replaceAll": [[4, 13]]}}}, {"text": "Sure, the documentation of System.exit() says that this method never returns normally", "label": {"api": {"the documentation of System.exit()": [[6, 39]]}}}, {"text": "Look into using java arraylist", "label": {"api": {"arraylist": [[21, 29]]}}}, {"text": "Typically, you would use an Executor Service and use the Executors factory", "label": {"api": {"Executor Service": [[28, 43]]}}}, {"text": "For objects, you use the equals method", "label": {"api": {"equals": [[25, 30]]}}}, {"text": "here are the links for String  the and scanner java API", "label": {"api": {"String ": [[23, 29]], "scanner": [[39, 45]]}}}, {"text": "JPanel#getVisible() isn't a method, but JPanel#isVisible() is, as inherited from Component", "label": {"api": {"JPanel#isVisible()": [[40, 57]]}}}, {"text": "Did you check AWTEvent.consume()", "label": {"api": {"AWTEvent.consume()": [[14, 31]]}}}, {"text": "The KeyEvent inherits consume method from InputEvent class", "label": {"api": {"InputEvent": [[42, 51]]}}}, {"text": "You also need to use the fully qualified name for the class when using the Class.forName method as specified in the Java API", "label": {"api": {"Java API": [[116, 123]]}}}, {"text": "To know when an instance is released, you can use weak references and a WeakHashMap to get an estimate of the number of instances still in use", "label": {"api": {"weak references": [[50, 64]], "WeakHashMap": [[72, 82]]}}}, {"text": "Generally, authentication being a cross-cutting concern, you would have extracted it to an authentication ServletFilter that is applied to all the servlets that need the user to be authenticated", "label": {"api": {"ServletFilter": [[106, 118]]}}}, {"text": "From the java doc of java.util.HashMap", "label": {"api": {"java.util.HashMap": [[21, 37]]}}}, {"text": "the ConcurrentHashMap collection could do the trick for you", "label": {"api": {"ConcurrentHashMap collection": [[4, 31]]}}}, {"text": "Because next() consumes the next token from the scanner", "label": {"api": {"next()": [[8, 13]]}}}, {"text": "Have a look at the Timer API for the details", "label": {"api": {"Timer API": [[19, 27]]}}}, {"text": "Also have a look at the TimerTask API since you would use this in conjunction with your Timer", "label": {"api": {"TimerTask API": [[24, 36]]}}}, {"text": "The charset names in Java are platform dependent, there are only 6 constants in the StandardCharsets class", "label": {"api": {"StandardCharsets": [[84, 99]]}}}, {"text": "Take a look at Swing Worker", "label": {"api": {"Swing Worker": [[15, 26]]}}}, {"text": "You'll need to implement TreeModel in a way that reflects the hierarchy of your observed directory structure", "label": {"api": {"TreeModel": [[25, 33]]}}}, {"text": "FileTreeModel is an example, and ac.Name is a simple class that parses paths for a vintage file system", "label": {"api": {"TreeModel": [[4, 12]]}}}, {"text": "The problem is that you have to represent a fixed point value, but you don't know java.math.BigDecimal and try to fake it", "label": {"api": {"java.math.BigDecimal": [[82, 101]]}}}, {"text": "Also, String.format() will take care of the current locale, or you could supply the required one via the overloaded method", "label": {"api": {"of the current locale": [[37, 57]]}}}, {"text": "You can use a HashMap<String,MyDataObject> - it will be fastest and simplest to use", "label": {"api": {"HashMap<String,MyDataObject>": [[14, 41]]}}}, {"text": "I can not find any peek or unread function in the XMLStreamReader documentation", "label": {"api": {"XMLStreamReader": [[50, 64]]}}}, {"text": "I implemented the parser without look ahead using the XMLStreamReader", "label": {"api": {"XMLStreamReader": [[54, 68]]}}}, {"text": "If that's not appropriate, you can fork/exec your script process using Runtime.exec()", "label": {"api": {"Runtime.exec()": [[71, 84]]}}}, {"text": "I've been having some problems using the JSlider class - specifically with tick labels", "label": {"api": {"JSlider": [[41, 47]]}}}, {"text": "So I'd like to know which it is - is this a bug in JSlider or the intended behaviour", "label": {"api": {"JSlider": [[51, 57]]}}}, {"text": "Use HttpURLConnection to connect through the proxy", "label": {"api": {"HttpURLConnection": [[4, 20]]}}}, {"text": "The class java.net.Socket is what you are searching for", "label": {"api": {"java.net.Socket": [[10, 24]]}}}, {"text": "For example, suppose you implement a ServletContextListener class", "label": {"api": {"ServletContextListener class": [[37, 64]]}}}, {"text": "But you should definitely keep invokeLater because it handles the threading for you", "label": {"api": {"invokeLater": [[31, 41]]}}}, {"text": "Unfortunately, even now (y2017) Java 8 Formatter doesn't support \"substring\"", "label": {"api": {"Java 8 Formatter": [[32, 47]]}}}, {"text": "You may want a CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[15, 34]]}}}, {"text": "If you want concurrent access AND consistent snapshots, you can use any of the collections in the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[98, 117]]}}}, {"text": "Your best option is to directly modify the underlying Document of the JTextArea", "label": {"api": {"Document": [[54, 61]]}}}, {"text": "Checking the API, it is supposed to be the non-numpad arrow key", "label": {"api": {"API": [[13, 15]]}}}, {"text": "Do i have a better option to solve it, but manually write the position/size of each window in Preferences", "label": {"api": {"Preferences": [[94, 104]]}}}, {"text": "You should actually be using a DocumentFilter if you want to control user input", "label": {"api": {"DocumentFilter": [[31, 44]]}}}, {"text": "A DocumentFilter allows you to intercept all the input as it happens", "label": {"api": {"DocumentFilter": [[2, 15]]}}}, {"text": "You can then use JTextField.setCaretPosition (comes from JTextComponent) to set the caret position", "label": {"api": {"JTextField.setCaretPosition": [[17, 43]]}}}, {"text": "Just pass your DocumentFilter implementation a reference to the JTextField so it can set the caret position for you", "label": {"api": {"DocumentFilter": [[15, 28]]}}}, {"text": "Here's the Java trail for DocumentFilter", "label": {"api": {"DocumentFilter": [[26, 39]]}}}, {"text": "Finally I put the default caret to NEVER_UPDATE", "label": {"api": {"NEVER_UPDATE": [[35, 46]]}}}, {"text": "Read the doc for ActionEvent", "label": {"api": {"ActionEvent": [[17, 27]]}}}, {"text": "The getClassName method of the StackTraceElement class returns with a String so you won't get a Class object unfortunately", "label": {"api": {"getClassName": [[4, 15]], "StackTraceElement": [[31, 47]]}}}, {"text": "Exception(String message, Throwable t)", "label": {"api": {"Exception(String message, Throwable t)": [[0, 37]]}}}, {"text": "Note that ScheduledExecutorService.schedule returns a ScheduledFuture", "label": {"api": {"ScheduledExecutorService.schedule": [[10, 42]], "ScheduledFuture": [[54, 68]]}}}, {"text": "You could simply use a number of Borders (How to use Borders)", "label": {"api": {"Borders": [[33, 39], [53, 59]]}}}, {"text": "GridLayout(int rows,int cols)", "label": {"api": {"GridLayout(int rows,int cols)": [[0, 28]]}}}, {"text": "Have a look at either GroupLayout or GridBagLayout", "label": {"api": {"GroupLayout": [[22, 32]], "GridBagLayout": [[37, 49]]}}}, {"text": "You can get an inputStream from the file via Class#getResourceAsStream()", "label": {"api": {"inputStream": [[15, 25]], "Class#getResourceAsStream()": [[45, 71]]}}}, {"text": "The one you want in particular is String.replace", "label": {"api": {"String.replace": [[34, 47]]}}}, {"text": "See the javadocs for Pattern to learn a bit about regular expressions, or search for one of the many tutorials available online", "label": {"api": {"Pattern": [[21, 27]]}}}, {"text": "One other remark, String.trim will remove all whitespace from the beginning and end of your string to turn \" 2.0332\" into \"2.0332\"", "label": {"api": {"String.trim": [[18, 28]]}}}, {"text": "The closest fit for what you are looking for is the IndexOutOfBoundsException", "label": {"api": {"IndexOutOfBoundsException": [[52, 76]]}}}, {"text": "You can use it as-is, or derive your own MatrixIndexOutOfBoundsException exception from it", "label": {"api": {"IndexOutOfBoundsException": [[47, 71]]}}}, {"text": "You can throw an IllegalArgumentException(String message) with the message describing that the matrix dimensions are not suitable for what are you trying to do", "label": {"api": {"IllegalArgumentException(String message)": [[17, 56]]}}}, {"text": "Checking the Java 8 Pattern API, we can find that \\D represents any non digit character", "label": {"api": {"Java 8 Pattern API": [[13, 30]]}}}, {"text": "1) Predefined class javafx.scene.control.cell.CheckBoxTableCell may be used in place of yours", "label": {"api": {"javafx.scene.control.cell.CheckBoxTableCell": [[20, 62]]}}}, {"text": "Have a look at PrintStream.format, which will allow you to print using specified widths and padding characters", "label": {"api": {"PrintStream.format": [[15, 32]]}}}, {"text": "Your case is pretty simple, look over the syntax for the format string", "label": {"api": {"syntax": [[42, 47]]}}}, {"text": "As an alternative, you could drop the StringBuilder and use a StringWriter and a PrintWriter", "label": {"api": {"StringWriter": [[62, 73]], "PrintWriter": [[81, 91]]}}}, {"text": "If you're using EJB, you could do the save of the ID in a bean of its own, and annotate it with a TransactionAttribute of REQUIRES_NEW", "label": {"api": {"TransactionAttribute": [[98, 117]], "REQUIRES_NEW": [[122, 133]]}}}, {"text": "Your comparator has to implement the java.util.Comparator interface in order to be type safe for the constructor to accept", "label": {"api": {"java.util.Comparator interface": [[37, 66]]}}}, {"text": "Take a look at the docs for Pattern", "label": {"api": {"docs for Pattern": [[19, 34]]}}}, {"text": "You can use setMargin() to set margin space between component's border and its text", "label": {"api": {"setMargin()": [[12, 22]]}}}, {"text": "Consider the following very simple example the demonstrates use of setMargin()", "label": {"api": {"setMargin()": [[67, 77]]}}}, {"text": "You find more Information about ImageIO in the API", "label": {"api": {"API": [[47, 49]]}}}, {"text": "I know this is an old thread, but in case someone is searching for an answer to this, SwingUtilities has a method called invokeAndWait(Runnable) that runs the task on AWT dispatching thread synchronously with your current thread", "label": {"api": {"SwingUtilities": [[86, 99]], "invokeAndWait(Runnable)": [[121, 143]]}}}, {"text": "The following code is taken from the JavaDoc of Condition", "label": {"api": {"JavaDoc of Condition": [[37, 56]]}}}, {"text": "You always can work with DateFormat and Calendar", "label": {"api": {"DateFormat": [[25, 34]], "Calendar": [[40, 47]]}}}, {"text": "See DateFormat, SimpleDateFormat and Calendar", "label": {"api": {"DateFormat": [[4, 13], [22, 31]], "SimpleDateFormat": [[16, 31]], "Calendar": [[37, 44]]}}}, {"text": "What you are doing there doesn't really sit right with the contract for hashCode", "label": {"api": {"contract for hashCode": [[59, 79]]}}}, {"text": "But that problem has a simple solution since JDK 7", "label": {"api": {"simple solution": [[23, 37]]}}}, {"text": "See the classes Pattern and Matcher", "label": {"api": {"Pattern": [[16, 22]], "Matcher": [[28, 34]]}}}, {"text": "Alternatively, you could use String.indexOf to search for the positions of delimeters in your string and String.substring to extract parts between the delimeter position you found", "label": {"api": {"String.indexOf": [[29, 42]], "String.substring": [[105, 120]]}}}, {"text": "SimpleDateFormat Like in this example", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Can't you use a different way, such as a CountdownLatch", "label": {"api": {"CountdownLatch": [[41, 54]]}}}, {"text": "Windows shows the hexadecimal representation of the serial number, whereas Java returns a BigInteger result from X509Certificate.getSerialNumber()", "label": {"api": {"X509Certificate.getSerialNumber()": [[113, 145]]}}}, {"text": "I would simply create a Polygon, and use its contains(Point) method", "label": {"api": {"contains(Point)": [[45, 59]]}}}, {"text": "File has lastModified() method, which you can use", "label": {"api": {"File": [[0, 3]]}}}, {"text": "In Java™ Platform, Standard Edition 8 API Specification you can find more details", "label": {"api": {"Java™ Platform, Standard Edition 8 API Specification": [[3, 54]]}}}, {"text": "Check out Semaphore", "label": {"api": {"Semaphore": [[10, 18]]}}}, {"text": "incSemaphore and decSemaphore", "label": {"api": {"Semaphore": [[3, 11], [20, 28]]}}}, {"text": "Initial value of incSemaphore should be 1 and 0 for decSemaphore", "label": {"api": {"Semaphore": [[20, 28], [55, 63]]}}}, {"text": "Put them into a Set", "label": {"api": {"Set": [[16, 18]]}}}, {"text": "Sets don't allow duplicate entries", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "Or into a Set which automatically will reject duplicates", "label": {"api": {"Set": [[10, 12]]}}}, {"text": "Override Object#toString in the Chocolate class", "label": {"api": {"Object#toString": [[9, 23]]}}}, {"text": "If you want to force the output time zone of the date format, you can do this using the setTimeZone method", "label": {"api": {"setTimeZone": [[88, 98]], "TimeZone": [[91, 98]]}}}, {"text": "Just like Locale, TimeZone has a getDefault method, if necessary", "label": {"api": {"TimeZone": [[18, 25]]}}}, {"text": "This should just involve reading lines from a FileReader and converting them to a char[]", "label": {"api": {"FileReader": [[46, 55]], "converting them to a char[]": [[61, 87]]}}}, {"text": "I'm wrapping the FileReader in a BufferedReader because it's a little bit faster, and it provides the useful readLine() method, but you could read directly from the FileReader if you wanted to", "label": {"api": {"FileReader": [[17, 26], [165, 174]], "BufferedReader": [[33, 46]], "read directly from the FileReader": [[142, 174]]}}}, {"text": "You could also use Scanner.nextLine() if you're uncomfortable with BufferedReader, but I'd advise becoming familiar with various Reader's", "label": {"api": {"BufferedReader": [[67, 80]], "Scanner.nextLine()": [[19, 36]]}}}, {"text": "As a more minor point, I would advise using a StringBuilder instead of appending Strings", "label": {"api": {"StringBuilder": [[46, 58]]}}}, {"text": "Those are subclasses of the RuntimeException", "label": {"api": {"RuntimeException": [[28, 43]]}}}, {"text": "RuntimeExceptions and its subclasses don't need to be caught", "label": {"api": {"RuntimeException": [[0, 15]]}}}, {"text": "What you are actually looking for is a Map", "label": {"api": {"Map": [[39, 41]]}}}, {"text": "Therefore you would create an instance of a Map<String, Integer> - read \"a map from String to Integer\"", "label": {"api": {"Map": [[44, 46]]}}}, {"text": "Convert the value to a String and use SimpleDateFormat to parse it to a Date object", "label": {"api": {"SimpleDateFormat": [[38, 53]], "parse": [[58, 62]]}}}, {"text": "The converse is similar, but instead of using parse, use format, and convert from the resulting String to an Integer", "label": {"api": {"parse": [[46, 50]], "format": [[57, 62]]}}}, {"text": "An alternative is to use substring and manually parse the String representation of your Integer, though I strongly advise you against this", "label": {"api": {"parse": [[48, 52]]}}}, {"text": "There is File#listFiles to get the files in a directory, and you can use File#isDirectory to check if those are files or directories, either by looping over the result or by using a FileFilter that you pass to listFiles", "label": {"api": {"File#listFiles": [[9, 22]], "File#isDirectory": [[73, 88]], "FileFilter": [[182, 191]]}}}, {"text": "On top of the other suggestions, you may also want to look at ExecutorService and Java Concurrency, as you're probably going to want to thread the downloads to make it faster", "label": {"api": {"ExecutorService": [[62, 76]]}}}, {"text": "ScheduledExecutorService might help here", "label": {"api": {"ScheduledExecutorService": [[0, 23]]}}}, {"text": "But you are not setting the layout and JPanel uses FlowLayout which is its default", "label": {"api": {"default": [[75, 81]]}}}, {"text": "You could try calling applyComponentOrientation() on the Container that has the buttons", "label": {"api": {"applyComponentOrientation()": [[22, 48]]}}}, {"text": "In Java 1.7 or later, I would use ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[34, 50]]}}}, {"text": "The reason to use ThreadLocalRandom is explained here", "label": {"api": {"ThreadLocalRandom": [[18, 34]]}}}, {"text": "Also note that the reason we +1 to the input to ThreadLocalRandom.nextInt() is to make sure the max is included in the range", "label": {"api": {"ThreadLocalRandom": [[48, 64]]}}}, {"text": "For something to be sorted, it must implement the Comparable interface, which is something which the HashMap does not", "label": {"api": {"Comparable": [[50, 59]], "HashMap": [[101, 107]]}}}, {"text": "As a result, when you try to sort your list of HashMaps your code fails", "label": {"api": {"HashMap": [[47, 53]]}}}, {"text": "If you really need to be able to compare HashMaps, you could create your own HashMap, something like so", "label": {"api": {"HashMap": [[41, 47], [77, 83]]}}}, {"text": "Take a look at FileSystemView.getSystemIcon(File)", "label": {"api": {"FileSystemView.getSystemIcon(File)": [[15, 48]]}}}, {"text": "Character class has isDigit method, which you can use as follows", "label": {"api": {"Character": [[0, 8]]}}}, {"text": "You can use ProcessBuilder class as follows", "label": {"api": {"ProcessBuilder": [[12, 25]]}}}, {"text": "You can use Runtime.exec(java.lang.String, java.lang.String[], java.io.File) where you can set the working directory", "label": {"api": {"Runtime.exec(java.lang.String, java.lang.String[], java.io.File)": [[12, 75]]}}}, {"text": "Or else you can use ProcessBuilder as follows", "label": {"api": {"ProcessBuilder": [[20, 33]]}}}, {"text": "You can set URLConnection#setConnectTimeout to minimum value in which you expect connection to happen", "label": {"api": {"URLConnection#setConnectTimeout": [[12, 42]]}}}, {"text": "So the code uses Matcher.appendReplacement and appendTail", "label": {"api": {"Matcher.appendReplacement and appendTail": [[17, 56]]}}}, {"text": "Doesn't java.util.concurrent.Semaphore already do all that", "label": {"api": {"java.util.concurrent.Semaphore": [[8, 37]]}}}, {"text": "First, basically you define the hash function of a class by overriding the hashCode() method", "label": {"api": {"hashCode() method": [[75, 91]]}}}, {"text": "If you have an answer to that, create an equals() method that compares all of the properties and returns true if they're all the same and false otherwise", "label": {"api": {"equals()": [[41, 48]]}}}, {"text": "The hashCode() method is a bit more involved, I would suggest that you do not create it yourself but let your IDE do it", "label": {"api": {"hashCode() method": [[4, 20]]}}}, {"text": "In Eclipse, you can select Source and then Generate hashCode() and equals() from the menu", "label": {"api": {"equals()": [[67, 74]]}}}, {"text": "Hashing of an object is established by overriding hashCode() method, which the developer can override", "label": {"api": {"hashCode() method": [[50, 66]]}}}, {"text": "If the equals() and hashCode() method aren't implemented, the JVM will generate hashcode implicitly for the object (for Serializable classes, a serialVersionUID is generated)", "label": {"api": {"hashCode() method": [[20, 36]]}}}, {"text": "You could use Map.entrySet() and extended for", "label": {"api": {"Map.entrySet()": [[14, 27]]}}}, {"text": "To get the object representing the current date, you can use just new Date(), to format it, use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[96, 111]]}}}, {"text": "Use AtomicReference to store your value variable", "label": {"api": {"AtomicReference": [[4, 18]]}}}, {"text": "The method returns a Class object", "label": {"api": {"Class": [[21, 25]]}}}, {"text": "These Class objects are often utilized when you're dealing with reflection", "label": {"api": {"Class": [[6, 10]]}}}, {"text": "The basic idea is to add a MouseListener to a component", "label": {"api": {"MouseListener": [[27, 39]]}}}, {"text": "What you are looking for is MimeMessag#writeTo which outputs the message as an RFC 822 format stream", "label": {"api": {"MimeMessag#writeTo": [[28, 45]]}}}, {"text": "But you can specify the port by using a version of the UnicastRemoteObject constructor", "label": {"api": {"UnicastRemoteObject": [[55, 73]]}}}, {"text": "The next step is to package each in a Runnable interface, and hand each a reference to a queuing object", "label": {"api": {"Runnable interface": [[38, 55]]}}}, {"text": "You can do this by using an InputVerifier", "label": {"api": {"InputVerifier": [[28, 40]]}}}, {"text": "Large cap Y is \"Week year\" according to javadoc", "label": {"api": {"according to javadoc": [[27, 46]]}}}, {"text": "URL.getQuery() will give the query portion as a String it is a simple regular expression match to isolate the part you want", "label": {"api": {"URL.getQuery()": [[0, 13]]}}}, {"text": "Please use equals  rather than ==", "label": {"api": {"equals": [[11, 16]]}}}, {"text": "Consider this approach (see doc here)", "label": {"api": {"doc here": [[28, 35]]}}}, {"text": "Please read the javadoc on JDialog before you try to use it", "label": {"api": {"JDialog": [[27, 33]]}}}, {"text": "After properly defining the compareTo (which is part of the Comparable<T> interface) method you should be able to sort your list using Collections.sort, or Arrays.sort if you insist on using arrays rather than lists", "label": {"api": {"Comparable<T> interface": [[60, 82]], "Collections.sort": [[135, 150]], "Arrays.sort": [[156, 166]]}}}, {"text": "The documentation for JPanel lists all these methods under the \"Method Summary\" header, specifically in the \"Methods inherited from class java.awt.Container\" section (there are multiple overloads of add which is why it is mentioned more than once there)", "label": {"api": {"documentation for JPanel": [[4, 27]]}}}, {"text": "You can use DatabaseMetaData.getTypeInfo() to retrieve a list of typenames in the database, the corresponding JDBC type and information like maximum precision, etc", "label": {"api": {"DatabaseMetaData.getTypeInfo()": [[12, 41]]}}}, {"text": "You can use Scanner#hasNextInt() for this", "label": {"api": {"Scanner#hasNextInt()": [[12, 31]]}}}, {"text": "The Scanner has a hasNextInt() function that returns true if the next token is a Integer", "label": {"api": {"hasNextInt()": [[18, 29]]}}}, {"text": "So before calling nextInt() validate if hasNextInt() is true", "label": {"api": {"hasNextInt()": [[40, 51]]}}}, {"text": "File.listFiles() is what you've got, basically - with an overload to take a FileFilter of course", "label": {"api": {"File.listFiles()": [[0, 15]]}}}, {"text": "Java 7 has a new file system API, including FileVisitor<T> which may be what you're after", "label": {"api": {"FileVisitor<T>": [[44, 57]]}}}, {"text": "You'd probably want to create a subclass of SimpleFileVisitor<T>", "label": {"api": {"FileVisitor<T>": [[50, 63]], "SimpleFileVisitor<T>": [[44, 63]]}}}, {"text": "In this implementation I'm using ArrayDeque but you can use any Queue or any List for the job", "label": {"api": {"ArrayDeque": [[33, 42]], "Queue": [[64, 68]], "List": [[77, 80]]}}}, {"text": "There are ways you can do this using the Reflection but that's best avoided", "label": {"api": {"Reflection": [[41, 50]]}}}, {"text": "You can pass an instance to a Thread in its constructor, and then just start it", "label": {"api": {"constructor": [[44, 54]]}}}, {"text": "One of the JPA ways for getting only particular columns is to ask for a Tuple object", "label": {"api": {"Tuple": [[72, 76]]}}}, {"text": "Have a look at this trail and try to put any code that does a lot of work in a SwingWorker thread", "label": {"api": {"SwingWorker": [[79, 89]]}}}, {"text": "The robot class can do this for you in java", "label": {"api": {"robot": [[4, 8]]}}}, {"text": "Specifically, I'd suggest you use the SingleThreadExecutor service", "label": {"api": {"SingleThreadExecutor": [[38, 57]]}}}, {"text": "I'd suggest you make sure to explicitly set a timeout so that you know the max time a task should take, and that you use the submit method of your executor so that you can handle any potential errors you encounter along the way", "label": {"api": {"use the submit method": [[117, 137]]}}}, {"text": "I want to know if there are available bytes to be read in a Java NIO Socket", "label": {"api": {"Java NIO": [[60, 67]], "Socket": [[69, 74]]}}}, {"text": "It is possible to do the same operation with Java NIO (using SocketChannel, Selector, Socket, etc.)", "label": {"api": {"Java NIO": [[45, 52]], "SocketChannel": [[61, 73]], "Selector": [[76, 83]], "Socket": [[61, 66], [86, 91]]}}}, {"text": "I use selectNow() method of Selector", "label": {"api": {"selectNow()": [[6, 16]], "Selector": [[28, 35]]}}}, {"text": "Given a Selector named selector that have a SocketChannel registered, I can use this method to know if the associated Socket has readable bytes", "label": {"api": {"Selector": [[8, 15]], "SocketChannel": [[44, 56]], "Socket": [[44, 49], [118, 123]]}}}, {"text": "It is the only way I have found to know if a Socket has readable bytes without reading the bytes", "label": {"api": {"Socket": [[45, 50]]}}}, {"text": "Have a look at ImageIO.read documentation for more info", "label": {"api": {"ImageIO.read documentation": [[15, 40]]}}}, {"text": "Inside this loop, call toString() on each object and accumulate the resulting strings in a StringBuilder", "label": {"api": {"StringBuilder": [[91, 103]]}}}, {"text": "Print this StringBuilder", "label": {"api": {"StringBuilder": [[11, 23]]}}}, {"text": "ExecutorService#shutdownNow() offers a way of immediate shutdown by interrupting threads but since these threads can not be interrupted it provides not additional benefit", "label": {"api": {"ExecutorService#shutdownNow()": [[0, 28]]}}}, {"text": "I can only tell you that the ObjectNotFoundException-pattern had been around since the early days of J2EE and EJB 2.0", "label": {"api": {"ObjectNotFoundException": [[29, 51]]}}}, {"text": "It was common to throw that subclass of FinderException at a time when a typical piece of business logic involved catching about 17 gazillion annoying checked exceptions just to wrap most of them in RuntimeExceptions to be able to rethrow them into Nirvana", "label": {"api": {"FinderException": [[40, 54]]}}}, {"text": "Other than that, null is no better than ObjectNotFoundException", "label": {"api": {"ObjectNotFoundException": [[40, 62]]}}}, {"text": "Once you open an input stream from the server, create the image using ImageIO.read(InputStream)", "label": {"api": {"ImageIO.read(InputStream)": [[70, 94]]}}}, {"text": "An Object cannot \"contain a series of numbers\"", "label": {"api": {"Object": [[3, 8]]}}}, {"text": "However many subclasses of Object, such as all of the Collections can \"contain a series of numbers\", and they come with a toArray() method to turn the contents of the collection into an array", "label": {"api": {"Object": [[27, 32]], "toArray()": [[122, 130]]}}}, {"text": "If you have a collection, but only have access to it as an Object, you need to cast it before you can work with it properly", "label": {"api": {"Object": [[59, 64]]}}}, {"text": "It's fairly rare in day-to-day Java to actually be working with variables cast as Object, if you are, it should be a red flag that you may be doing something wrong", "label": {"api": {"Object": [[82, 87]]}}}, {"text": "You could mark your object as @XmlAnyElement(InterfaceHandler.class) where InterfaceHandler is a DomHandler capable of translating between a DOM representation and the actual implementing classes", "label": {"api": {"@XmlAnyElement": [[30, 43]], "DomHandler": [[97, 106]]}}}, {"text": "Also have a look at the @XmlElementRef annotation", "label": {"api": {"@XmlElementRef": [[24, 37]]}}}, {"text": "The way to go is by using Collections and specifically the List interface", "label": {"api": {"List": [[59, 62]]}}}, {"text": "There are also other implementations of List, like ArrayList, LinkedList etc..", "label": {"api": {"List": [[40, 43], [56, 59], [68, 71]], "ArrayList": [[51, 59]], "LinkedList": [[62, 71]]}}}, {"text": "See ForkJoinPool and its trail, and use Google to find one of many other tutorials", "label": {"api": {"ForkJoinPool": [[4, 15]]}}}, {"text": "However, you can set the connection read timeout using setReadTimeout method", "label": {"api": {"setReadTimeout": [[55, 68]]}}}, {"text": "Similarly you can't say that Double::NEGATIVE_INFINITY equals itself, since infinity is not a number either", "label": {"api": {"Double::NEGATIVE_INFINITY": [[29, 53]]}}}, {"text": "That said, a JMenu is just a special kind of button, so perhaps you can derive your own custom menu class from that, in order to paint top level menus in a different way", "label": {"api": {"JMenu": [[13, 17]]}}}, {"text": "For the main menu bar, some platforms (Mac OS in particular) probably won't handle the custom painting code, as that menu bar is handled by native OS code", "label": {"api": {"main menu bar": [[8, 20]]}}}, {"text": "After all, a JMenuBar is just a Component", "label": {"api": {"JMenu": [[13, 17]], "JMenuBar": [[13, 20]]}}}, {"text": "Use a PreparedStatement to create your query", "label": {"api": {"PreparedStatement": [[6, 22]]}}}, {"text": "So your parameterized query for the PreparedStatement would be something like this", "label": {"api": {"PreparedStatement": [[36, 52]]}}}, {"text": "Take a look at java.text.SimpleDateFormat class, which defines the pattern codes to be used in f:convertDateTime", "label": {"api": {"java.text.SimpleDateFormat": [[15, 40]]}}}, {"text": "As by default, the container has a BorderLayout, it will add the table in the centre; you can then add a button below by using", "label": {"api": {"BorderLayout": [[35, 46]]}}}, {"text": "In Java, you can use the Pattern class", "label": {"api": {"Pattern class": [[25, 37]]}}}, {"text": "Take a look at the classes Pattern and Matcher", "label": {"api": {"Pattern": [[27, 33]], "Matcher": [[39, 45]]}}}, {"text": "Alternatively, you could work with String.indexOf and String.substr", "label": {"api": {"String.indexOf": [[35, 48]], "String.substr": [[54, 66]]}}}, {"text": "The Calendar class has built in methods for doing the conversion", "label": {"api": {"Calendar": [[4, 11]]}}}, {"text": "You can set the desired timezone with setTimeZone", "label": {"api": {"setTimeZone": [[38, 48]]}}}, {"text": "Also see the getTimeZoneOffset from the Date class", "label": {"api": {"getTimeZoneOffset": [[13, 29]]}}}, {"text": "As documented at http://docs.oracle.com/javase/1.4.2/docs/api/java/io/DataInput.html#readUTF() the calls reads a string from the stream and returns it", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/io/DataInput.html#readUTF": [[17, 91]]}}}, {"text": "Use the method isAlive from the Thread class", "label": {"api": {"Thread": [[32, 37]]}}}, {"text": "You can use an ExecutorService", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "The executor will return a Future object for each submitted thread, and then you can iterate through each Future collecting the results", "label": {"api": {"Future": [[27, 32], [106, 111]]}}}, {"text": "will complete when all the Futures have returned data (i.e", "label": {"api": {"Future": [[27, 32]]}}}, {"text": "getClass is one of Object's methods and returns the runtime class of this", "label": {"api": {"and returns the runtime class of this": [[36, 72]]}}}, {"text": "Yes, there is a method called BigDecimal.toPlainString()", "label": {"api": {"BigDecimal.toPlainString()": [[30, 55]]}}}, {"text": "You can iterate over the map to get map entries (Map.Entry) (couples of keys and values) and access the map only once", "label": {"api": {"Map.Entry": [[49, 57]]}}}, {"text": "Map.entrySet() delivers a set of Map.Entrys each one with the key and corresponding value", "label": {"api": {"Map.Entry": [[33, 41]], "Map.entrySet()": [[0, 13]]}}}, {"text": "Try with something simple like ExecutorService", "label": {"api": {"ExecutorService": [[31, 45]]}}}, {"text": "use Callable<T> to return some result, ExecutorCompletionService to wait for first result, etc", "label": {"api": {"Callable<T>": [[4, 14]], "ExecutorCompletionService": [[39, 63]]}}}, {"text": "By the way, why are you not using File.createTempFile", "label": {"api": {"File.createTempFile": [[34, 52]]}}}, {"text": "It seems you are using a Scanner, so you could use the hasNextInt method", "label": {"api": {"use the hasNextInt method": [[47, 71]]}}}, {"text": "You can't parse this string into a long, it's too great (greater than Long.MAX_VALUE), you need BigInteger", "label": {"api": {"Long.MAX_VALUE": [[70, 83]], "BigInteger": [[96, 105]]}}}, {"text": "For more information about HttpServletRequest, see the API here", "label": {"api": {"see the API here": [[47, 62]]}}}, {"text": "If the View is Observer and the Model Observable, why the Observer.update method accepts Observable in the first parameter", "label": {"api": {"Observer": [[15, 22], [58, 65]], "Observable": [[38, 47], [89, 98]]}}}, {"text": "In case of any modifications that alter array size (insert or delete) it is recommended to use java.util.List implementations", "label": {"api": {"java.util.List": [[95, 108]]}}}, {"text": "ArrayList, for example", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "Also, to copy some elements from array to array you should consider using existing methods like System.arraycopy and various copying methods from java.util.Arrays", "label": {"api": {"System.arraycopy": [[96, 111]], "java.util.Arrays": [[146, 161]]}}}, {"text": "which is attempting to create a BigInteger with radix of 37, exactly 1 more than the allowed maximum of 36", "label": {"api": {"BigInteger": [[32, 41]]}}}, {"text": "In this example you probably didn't need to set the radix or even use BigInteger, so you could simply use", "label": {"api": {"BigInteger": [[70, 79]]}}}, {"text": "The HashSet.equals method already does comparisons to make sure there are the exact same elements in each set", "label": {"api": {"HashSet.equals": [[4, 17]]}}}, {"text": "The ArrayList.equals does the same except it also checks ordering", "label": {"api": {"ArrayList.equals": [[4, 19]]}}}, {"text": "String is final and hence no type U can be an extension of String (although U can still be String)", "label": {"api": {"String": [[0, 5], [59, 64], [91, 96]]}}}, {"text": "Font#canDisplay() is fast, although not perfectly reliable", "label": {"api": {"Font#canDisplay()": [[0, 16]]}}}, {"text": "You can use a map with category as the key and an ArrayList of lists as the value", "label": {"api": {"ArrayList": [[50, 58]]}}}, {"text": "ArrayList automatically changes size as you add to it", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "Map uses put(key, value) to add elements", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "ArrayList uses add(element) or add(index, element)", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "@Eme If you want a map that is sorted by its key, it is called SortedMap", "label": {"api": {"SortedMap": [[63, 71]]}}}, {"text": "Use PriorityQueue instead of list to keep values sorted as they are added", "label": {"api": {"PriorityQueue": [[4, 16]]}}}, {"text": "How about the String.contains method", "label": {"api": {"String.contains": [[14, 28]]}}}, {"text": "This behavior can be modified with JViewport.html#setScrollMode", "label": {"api": {"JViewport.html#setScrollMode": [[35, 62]]}}}, {"text": "If you are using ComponentListener then you can use one of the methods listed in this interface, see http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/event/ComponentListener.html", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/event/ComponentListener.html": [[101, 182]]}}}, {"text": "I'd also recommend a crash course on the java.io.File API as well..", "label": {"api": {"java.io.File": [[41, 52]]}}}, {"text": "If so, you can use the String.trim method to get rid of that extra space", "label": {"api": {"trim": [[30, 33]]}}}, {"text": "trim removes all leading and trailing whitespace", "label": {"api": {"trim": [[0, 3]]}}}, {"text": "I would suggest using a StringBuilder, in case you're iterating through an array of String", "label": {"api": {"StringBuilder": [[24, 36]]}}}, {"text": "In particular you should look at the listFiles method and write FileFilter that selects directories and, of course, the files you're interested into", "label": {"api": {"listFiles method": [[37, 52]]}}}, {"text": "String has a method toCharArray that returns a newly allocated char[] of its characters", "label": {"api": {"toCharArray": [[20, 30]]}}}, {"text": "Similarly, String has a constructor that takes a char[] representing the characters of the newly created String", "label": {"api": {"has a constructor": [[18, 34]]}}}, {"text": "use String.contains() method from String API", "label": {"api": {"String API": [[34, 43]]}}}, {"text": "You can use Character.toUpperCase()", "label": {"api": {"Character.toUpperCase()": [[12, 34]]}}}, {"text": "parseFloat throws a NumberFormatException if the passed String does not contain a parseable float", "label": {"api": {"parseFloat": [[0, 9]]}}}, {"text": "Another option is to use a Scanner if you don't want to be handling exceptions", "label": {"api": {"Scanner": [[27, 33]]}}}, {"text": "Alternatively you can create the JLabel first and call JLabel#setText(String text); on its instance", "label": {"api": {"JLabel#setText(String text);": [[55, 82]]}}}, {"text": "Take a look into String.startsWith() and String.endsWith()", "label": {"api": {"String.startsWith()": [[17, 35]], "String.endsWith()": [[41, 57]]}}}, {"text": "You can also consider using regular expression in the String.matches() method", "label": {"api": {"String.matches()": [[54, 69]]}}}, {"text": "Look at the JavaDoc of DecimalFormat", "label": {"api": {"JavaDoc of DecimalFormat": [[12, 35]]}}}, {"text": "The BigInteger class is a good place to start for big ints", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "I'll have to check the documentation to see what the upper bound on BigInteger is, but it should suit your needs", "label": {"api": {"BigInteger": [[68, 77]]}}}, {"text": "Thus you must use utility method Arrays.equals()", "label": {"api": {"Arrays.equals()": [[33, 47]]}}}, {"text": "Binary search only works on sorted arrays", "label": {"api": {"sorted arrays": [[28, 40]]}}}, {"text": "You can then check each class to see if it is an interface with the Class#isInterface() method", "label": {"api": {"the Class#isInterface() method": [[64, 93]]}}}, {"text": "If you need larger numbers, consider a class such as BigInteger", "label": {"api": {"BigInteger": [[53, 62]]}}}, {"text": "This behaviour is described in the JavaDoc of trim() (bold mine)", "label": {"api": {"JavaDoc of trim()": [[35, 51]]}}}, {"text": "It is called DataInputStream and DataOutputStream", "label": {"api": {"DataInputStream": [[13, 27]], "DataOutputStream": [[33, 48]]}}}, {"text": "You could use an AdjustmentListener registered with your the vertical scrollbar in your JScrollPane and take action based on the event value", "label": {"api": {"AdjustmentListener": [[17, 34]]}}}, {"text": "I know it is a little offtopic (2 years later), but if somebody was interested, I think it can be done with setNativeMethodPrefix() method and adequate bytecode transformation", "label": {"api": {"setNativeMethodPrefix() method": [[108, 137]]}}}, {"text": "getSelectedRow() would not work with multiple selected rows (multiple selections allowed), as it will always return \"the index of the first selected row\"", "label": {"api": {"\"the index of the first selected row\"": [[116, 152]]}}}, {"text": "You need to use Statement.executeUpdate(String) for INSERT", "label": {"api": {"Statement.executeUpdate(String)": [[16, 46]]}}}, {"text": "Statement.executeQuery(String) is for SELECT", "label": {"api": {"Statement.executeQuery(String)": [[0, 29]]}}}, {"text": "LinkedList and ArrayList for example", "label": {"api": {"LinkedList": [[0, 9]], "ArrayList": [[15, 23]]}}}, {"text": "To prevent clicking a button you can use JButton.setEnabled(false)", "label": {"api": {"JButton.setEnabled(false)": [[41, 65]]}}}, {"text": "Please see the URL API for more info", "label": {"api": {"URL API": [[15, 21]]}}}, {"text": "One way is to use any of the Lock objects which has a tryLock(...) method which allows you to wait for the lock for a certain amount of time", "label": {"api": {"Lock": [[29, 32], [57, 60]]}}}, {"text": "ReentrantLock may be a good choice here", "label": {"api": {"Lock": [[9, 12]], "ReentrantLock": [[0, 12]]}}}, {"text": "You can use a Set and store the results in it (preferably SortedSet) this will eliminate duplicates and maintain a sorted order as well while traversal", "label": {"api": {"Set": [[14, 16], [64, 66]], "SortedSet": [[58, 66]]}}}, {"text": "In your case, as your MyClass class obviously has a natural order, the simplest is to let it implement the Comparable interface", "label": {"api": {"Comparable": [[107, 116]]}}}, {"text": "After that, you can use the standard sort methods of the Arrays class", "label": {"api": {"the standard sort methods of the Arrays class": [[24, 68]]}}}, {"text": "getCanonicalHostName() will attempt to resolve the FQDN", "label": {"api": {"getCanonicalHostName()": [[0, 21]]}}}, {"text": "Therefore, you would get foo.mycompany.com whereas getHostName() might just return foo", "label": {"api": {"getHostName()": [[51, 63]]}}}, {"text": "getCanonicalHostName() will always do a reverse DNS lookup, whereas getHostName() would return the stored hostname if you supplied one in the InetAddress constructor", "label": {"api": {"getCanonicalHostName()": [[0, 21]], "getHostName()": [[68, 80]]}}}, {"text": "I suspect you will be wanting to use getCanonicalHostName() if you are intending to map IP addresses to host names", "label": {"api": {"getCanonicalHostName()": [[37, 58]]}}}, {"text": "If so, you can load it straight into a Properties object by calling properties.loadFromXML", "label": {"api": {"Properties": [[39, 48]], "properties.loadFromXML": [[68, 89]]}}}, {"text": "Use UnsupportedOperationException instead of NotImplementedException", "label": {"api": {"UnsupportedOperationException": [[4, 32]]}}}, {"text": "String.split() takes a regular expression", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "If you decided to use @Async annotation (good choice) you can use Future<T> to control the task execution", "label": {"api": {"Future<T>": [[66, 74]]}}}, {"text": "Basically your method should return a Future<T> instead of void", "label": {"api": {"Future<T>": [[38, 46]]}}}, {"text": "If the corresponding entry at index N in properties list corresponds to the same index N in paramValues list you can iterate using an int counter and use List.get()", "label": {"api": {"List.get()": [[154, 163]]}}}, {"text": "-Dcobertura.use.java.nio=false the previous appears to require changing to true to be able to use file locking as your error message explained", "label": {"api": {"appears": [[44, 50]]}}}, {"text": "It appears you are using something similar to a COF(constantly open file) , the error message is referring to a file that exists, but regions of the file are locked n the drive, not the file itself simply", "label": {"api": {"appears": [[3, 9]]}}}, {"text": "You need to pass an InvocationHandler too, which is called every time you call any proxy method", "label": {"api": {"InvocationHandler": [[20, 36]]}}}, {"text": "How each type of reference works is described in the java.lang.ref package javadoc", "label": {"api": {"java.lang.ref package javadoc": [[53, 81]]}}}, {"text": "See also the FacesMessage javadoc", "label": {"api": {"the FacesMessage javadoc": [[9, 32]]}}}, {"text": "The CRC32 class allows you to calculate the checksum yourself of bytes", "label": {"api": {"CRC32": [[4, 8]]}}}, {"text": "I used the Properties to store the settings and the file was generated automatically in the surrounding folder of the Jar-File", "label": {"api": {"Properties": [[11, 20]]}}}, {"text": "And you don't get any error in your test class as you're only outputting the value that is calling the toString() method", "label": {"api": {"toString()": [[103, 112]]}}}, {"text": "You can save a BufferedImage object using write method of the javax.imageio.ImageIO class", "label": {"api": {"javax.imageio.ImageIO": [[62, 82]]}}}, {"text": "Take a look at AtomicBoolean", "label": {"api": {"AtomicBoolean": [[15, 27]]}}}, {"text": "I'm not aware of such a feature, but you might look at invoking drawString() in the renderer's drawRangeGridline() method, seen here", "label": {"api": {"drawString()": [[64, 75]]}}}, {"text": "The baseline coordinates should be near (dataArea.getMinX(), v), although I haven't tried it", "label": {"api": {"baseline": [[4, 11]]}}}, {"text": "Any time you find yourself wanting to do some work on startup in a Servlet application, use a ServletContextListener, specifically the contextInitialized(ServletContextEvent) method", "label": {"api": {"ServletContextListener": [[94, 115]]}}}, {"text": "is a meta-character that accepts \"any character\"", "label": {"api": {"meta-character": [[5, 18]]}}}, {"text": "The class java.io.StreamTokenizer may be a better fit", "label": {"api": {"java.io.StreamTokenizer": [[10, 32]]}}}, {"text": "In general, both methods work, but only as soon as the ScrollPane's skin property has been set", "label": {"api": {"ScrollPane": [[55, 64]], "skin": [[68, 71]]}}}, {"text": "In my case, skin was still null after loading my view using FXMLLoader", "label": {"api": {"skin": [[12, 15]], "FXMLLoader": [[60, 69]]}}}, {"text": "By delaying the call in case the skin property has not been initialized (using a one-shot listener) solves the problem", "label": {"api": {"skin": [[33, 36]]}}}, {"text": "Collections.reverse() can do that job for you if you put your numbers in a List of Integers", "label": {"api": {"Collections.reverse()": [[0, 20]]}}}, {"text": "It works since Arrays.asList returns a write-through proxy to the original array", "label": {"api": {"Arrays.asList": [[15, 27]]}}}, {"text": "You may be looking for browse(), which \"Launches the default browser to display a URI.\"  Alternatively, an editor pane can be used, although support is limited", "label": {"api": {"browse()": [[23, 30]]}}}, {"text": "Matcher.matches tells you if your regex matches the entire string", "label": {"api": {"Matcher.matches": [[0, 14]]}}}, {"text": "You want Matcher.find()", "label": {"api": {"Matcher.find()": [[9, 22]]}}}, {"text": "Matcher.group then allows you to retrieve the matched portion of the input string", "label": {"api": {"Matcher.group": [[0, 12]]}}}, {"text": "Use a combination of the the find and group methods method to find and use matches within the input", "label": {"api": {"find": [[29, 32], [62, 65]], "group": [[38, 42]]}}}, {"text": "Note that the Matcher.matches() method attempts to match against the entire string", "label": {"api": {"Matcher.matches() method": [[14, 37]]}}}, {"text": "You want to use Matcher.find() instead", "label": {"api": {"Matcher.find()": [[16, 29]]}}}, {"text": "Use String#lastIndexOf(int) to find where the last comma occurs, and use String#substring(int) to get the rest of the string that follows", "label": {"api": {"String#lastIndexOf(int)": [[4, 26]], "String#substring(int)": [[73, 93]]}}}, {"text": "You might want to look into using a Scanner for this (in case you don't already know about this handy class)", "label": {"api": {"Scanner": [[36, 42]]}}}, {"text": "Are you implementing java.util.List or some custom List interface you created", "label": {"api": {"java.util.List": [[21, 34]]}}}, {"text": "Your equals() method should accept Object and downcast", "label": {"api": {"equals()": [[5, 12]]}}}, {"text": "Finally typically you define equals() in terms of content, not the representation", "label": {"api": {"equals()": [[29, 36]]}}}, {"text": "Use an instance of Properties for simple string key/value pairs", "label": {"api": {"Properties": [[19, 28]]}}}, {"text": "Use Character.isDigit while iterating the string's characters and then count a number up until you have found 6 consecutive numbers or reset it if the sequence breaks", "label": {"api": {"Character.isDigit": [[4, 20]]}}}, {"text": "class name) in the persistence unit which you can access via EntityManagerFactory#getProperties()", "label": {"api": {"EntityManagerFactory#getProperties()": [[61, 96]]}}}, {"text": "You can get the factory via EntityManager#getEntityManagerFactory()", "label": {"api": {"EntityManager#getEntityManagerFactory()": [[28, 66]]}}}, {"text": "ArrayList is one of the implementation for List and yes it does implement the List interface", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "I think the data structure that you actually want is a PriorityQueue", "label": {"api": {"PriorityQueue": [[55, 67]]}}}, {"text": "Have you looked at the Javadoc for StringTokenizer", "label": {"api": {"Javadoc for StringTokenizer": [[23, 49]]}}}, {"text": "If you don't know if the next data could be an integer, you can use Scanner#hasNextInt method", "label": {"api": {"Scanner#hasNextInt": [[68, 85]]}}}, {"text": "I suggest you use an ExecutorService to manage your threads and you can submit your Runnable as a task to this pool", "label": {"api": {"ExecutorService": [[21, 35]]}}}, {"text": "Try reading the instructions", "label": {"api": {"the instructions": [[12, 27]]}}}, {"text": "You could use the String#charAt method and write", "label": {"api": {"String#charAt method": [[18, 37]]}}}, {"text": "Use String.charAt(int) to fetch character from strings.", "label": {"api": {"String.charAt(int)": [[4, 21]]}}}, {"text": "By default (?i) works only with ASCII characters - see Pattern.CASE_INSENSITIVE for details", "label": {"api": {"Pattern.CASE_INSENSITIVE": [[55, 78]]}}}, {"text": "In this example, a modeless JDialog containing a direct JOptionPane counts down to zero before closing", "label": {"api": {"direct JOptionPane": [[49, 66]]}}}, {"text": "Looks like you should try an implementation of java.util.concurrent.BlockingQueue, rather than try and write your own", "label": {"api": {"java.util.concurrent.BlockingQueue": [[47, 80]]}}}, {"text": "I suspect a LinkedBlockingQueue will work nicely for you", "label": {"api": {"LinkedBlockingQueue": [[12, 30]]}}}, {"text": "Alternatively you could use a thread safe implementation of List such a CopyOnWriteArrayList, in which case you can remove all the synchronized blocks", "label": {"api": {"CopyOnWriteArrayList": [[72, 91]]}}}, {"text": "as mentioned in another answer, you seeem to be reimplementing an ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[66, 83]]}}}, {"text": "You need to use Future.cancel() in order to cancel the thread", "label": {"api": {"Future.cancel()": [[16, 30]]}}}, {"text": "In Java 8, some information was added to the BigInteger javadoc, giving a minimum supported range and the actual limit of the current implementation", "label": {"api": {"the BigInteger javadoc": [[41, 62]]}}}, {"text": "I'm trying to understand more about Java's MessageFormat utilities, and in examples in our codebase and elsewhere I see both {0} and {0,number,integer} being used for numbers, but I'm not sure which, if either, is preferable", "label": {"api": {"MessageFormat": [[43, 55]]}}}, {"text": "If you look at Java SE API, there is no reference to EJB", "label": {"api": {"Java SE API": [[15, 25]]}}}, {"text": "But if what you want is JPA, even though the API is included within Java EE (here's the API documentation) you don't need a Java EE application server for JPA anymore (unlike the situation with EJB entity beans)", "label": {"api": {"here's the API documentation": [[77, 104]]}}}, {"text": "You can use EJBs in non Java EE application server with EJB's 3.1 Lite container - http://docs.oracle.com/javaee/6/api/javax/ejb/embeddable/EJBContainer.html", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/ejb/embeddable/EJBContainer.html": [[83, 156]]}}}, {"text": "Have a look at SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "You didn't override the method equals for Student and Instructor", "label": {"api": {"equals": [[31, 36]]}}}, {"text": "This can be done recursively by calling equals on instance variables", "label": {"api": {"equals": [[40, 45]]}}}, {"text": "Your pseudo-mappings are almost the correct solution, you just need to group two @JoinColumns in a @JoinColumns", "label": {"api": {"@JoinColumns": [[81, 92], [99, 110]]}}}, {"text": "I believe that what you are looking for is the Timer class", "label": {"api": {"Timer": [[47, 51]]}}}, {"text": "Using the String.replaceAll() method and the \"[{}]\" regular expression", "label": {"api": {"String.replaceAll() method": [[10, 35]]}}}, {"text": "You could also submit a Runnable or Callable to a ScheduledThreadPoolExecutor if you don't need the result of the second method to answer the request", "label": {"api": {"ScheduledThreadPoolExecutor": [[50, 76]]}}}, {"text": "doc.select returns an Elements object, which implements Collection<Element>", "label": {"api": {"Collection<Element>": [[56, 74]]}}}, {"text": "However, since Collection<Element> extends Iterable<Element>, you can use an enhanced for loop instead, which is easier to read", "label": {"api": {"Collection<Element>": [[15, 33]], "Iterable<Element>": [[43, 59]]}}}, {"text": "Also, I suggest you use an ExecutorService for that if you don't do so already", "label": {"api": {"ExecutorService": [[27, 41]]}}}, {"text": "It has the advantage that the visibility issues of the return values of the Callable tasks (in your case the image parts of the worker threads) are handled by the library classes", "label": {"api": {"Callable": [[76, 83]]}}}, {"text": "I'd suggest you to use NavigableMap (Implemented as TreeSet)", "label": {"api": {"NavigableMap": [[23, 34]]}}}, {"text": "Anyways, you might want to take a look at the ImageIcon Javadoc aswell", "label": {"api": {"ImageIcon": [[46, 54]]}}}, {"text": "As suggested in How to Use Buttons, JToggleButton may be a good choice for this, as the isSelected() predicate reflects the button's state", "label": {"api": {"JToggleButton": [[36, 48]]}}}, {"text": "You could set a timeout with the setConnectTimeout() method", "label": {"api": {"setConnectTimeout()": [[33, 51]]}}}, {"text": "SO_TIMEOUT does not affect close(), try setting SO_LINGER", "label": {"api": {"does not affect": [[11, 25]]}}}, {"text": "I strongly suggest you to read the String class documentation", "label": {"api": {"String class documentation": [[35, 60]]}}}, {"text": "A Java string is utf-16 encoded where each  Character takes up 2 or 4 bytes", "label": {"api": {"Java string": [[2, 12]]}}}, {"text": "Supplementary characters denotes the characters taking 4 bytes and is implemented by pairing two characters, in which case the codePointCount operation must be used instead of length", "label": {"api": {"Supplementary characters": [[0, 23]]}}}, {"text": "I think java.io.File would satisfy most of those requirements", "label": {"api": {"java.io.File": [[8, 19]]}}}, {"text": "java.util.jar will satisfy your Jar file requirements", "label": {"api": {"java.util.jar": [[0, 12]]}}}, {"text": "The String#replaceAll() does a regex matching and replacement", "label": {"api": {"String#replaceAll()": [[4, 22]]}}}, {"text": "The String#replaceAll() is the wrong tool for the purpose", "label": {"api": {"String#replaceAll()": [[4, 22]]}}}, {"text": "You should be using String#replace() instead", "label": {"api": {"String#replace()": [[20, 35]]}}}, {"text": "One thing is the maximum array size, which in Java is Integer.MAX_VALUE", "label": {"api": {"Integer.MAX_VALUE": [[54, 70]]}}}, {"text": "If that's a limit to you, then you could create your own class which wraps a list of HashMap objects or use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[110, 122]]}}}, {"text": "If what you need is to set up a very simple communication between threads, you can use BlockingQueue from java.util.concurrent to distribute your message objects", "label": {"api": {"BlockingQueue": [[87, 99]]}}}, {"text": "When you declare your HashMap as part of the constructor argument, you can provide it with both the initial capacity and the load factor", "label": {"api": {"constructor": [[45, 55]]}}}, {"text": "You need use the other version of this method that specifies your dynamic classloader", "label": {"api": {"other version of this method": [[17, 44]]}}}, {"text": "Runtime.getRuntime().exec returns a Process object that you can use to interact with the process and see what's going on", "label": {"api": {"Process": [[36, 42]]}}}, {"text": "Check Character for other methods.", "label": {"api": {"Character": [[6, 14]]}}}, {"text": "You can use the Runtime.exec methods to run commands from within Java", "label": {"api": {"Runtime.exec": [[16, 27]]}}}, {"text": "List is not a keyword, it is a type, specifically, a Java interface", "label": {"api": {"List": [[0, 3]]}}}, {"text": "The code in your example doesn't compile (unless the List1 class is defined as", "label": {"api": {"List": [[53, 56]]}}}, {"text": "class List1 implements List { ..", "label": {"api": {"List": [[6, 9], [23, 26]]}}}, {"text": "This creates an ArrayList that can hold Integers, and assigns a reference to it to the variable ls, which is declared as the type List<Integer>", "label": {"api": {"List": [[21, 24], [130, 133]]}}}, {"text": "ls could potentially hold a reference to a different type of list, such as a LinkedList, but you can guarantee that ls does point to some sort of list (unless it's null) and therefore you can use the methods specified in the List interface", "label": {"api": {"List": [[83, 86], [225, 228]]}}}, {"text": "Since all objects extend Object you can always do something like", "label": {"api": {"Object": [[25, 30]]}}}, {"text": "Though, like above, the only methods you have access to from obj are what's defined in Object, even though the object being referred to is actually an ArrayList", "label": {"api": {"List": [[156, 159]], "Object": [[87, 92]]}}}, {"text": "Here are the javadocs for AtomicReference", "label": {"api": {"javadocs for AtomicReference": [[13, 40]]}}}, {"text": "If you want true concurrent access to a collection of objects then you should look into ConcurrentHashMap and friends", "label": {"api": {"ConcurrentHashMap": [[88, 104]]}}}, {"text": "I've looked over some existing answers here on SO and I've used Future in combination with ExecutorService to set timeout with TimeUnit to method", "label": {"api": {"Future": [[64, 69]], "ExecutorService": [[91, 105]], "TimeUnit": [[127, 134]]}}}, {"text": "Notice that we are extending JFrame, thereby allowing us to utilize methods such as setDefaultCloseOperation and setVisible", "label": {"api": {"JFrame": [[29, 34]]}}}, {"text": "Then you need to implement a ChangeListener, something like", "label": {"api": {"ChangeListener": [[29, 42]]}}}, {"text": "With java.text.DateFormat, it's possible to build a date formatter with a date and a time style", "label": {"api": {"java.text.DateFormat": [[5, 24]]}}}, {"text": "You can wrap this string in a class and compile it with Java Compiler API", "label": {"api": {"Java Compiler API": [[56, 72]]}}}, {"text": "I would advice to use HashSet", "label": {"api": {"HashSet": [[22, 28]]}}}, {"text": "Starting from Java 8 you can use Stream", "label": {"api": {"Stream": [[33, 38]]}}}, {"text": "Since your numbers are separated by a specific set of characters, you can take a look at the .split(String regex) method", "label": {"api": {".split(String regex)": [[93, 112]]}}}, {"text": "The Javadoc of PriorityQueue says", "label": {"api": {"Javadoc of PriorityQueue": [[4, 27]]}}}, {"text": "You can use PriorityBlockingQueue to specify Queue to ThreadPoolExecutor", "label": {"api": {"PriorityBlockingQueue": [[12, 32]]}}}, {"text": "I guess you will not able to do that with ScheduledExecutor, because it uses DelayedWorkQueue where as newCachedThreadPool uses ThreadPoolExecutor SynchronousQueue as a work queue", "label": {"api": {"SynchronousQueue": [[147, 162]]}}}, {"text": "So you can not change implementation of ScheduledThreadPoolExecutor to act like that", "label": {"api": {"ScheduledThreadPoolExecutor": [[40, 66]]}}}, {"text": "The javadoc for Comparator states", "label": {"api": {"javadoc for Comparator": [[4, 25]]}}}, {"text": "The contract of Comparator is defined in its javadoc", "label": {"api": {"in its javadoc": [[38, 51]]}}}, {"text": "You can definitely use a Scanner to extract the information you need", "label": {"api": {"Scanner": [[25, 31]]}}}, {"text": "See the doc for more info", "label": {"api": {"the doc": [[4, 10]]}}}, {"text": "Didn't try it, but I would say implementing MouseListener's mouseClicked() method is the way to go", "label": {"api": {"MouseListener": [[44, 56]]}}}, {"text": "Since MouseListener is an interface, CellRenderer could implement this interface too, keeping all cell-behavior in one class", "label": {"api": {"MouseListener": [[6, 18]]}}}, {"text": "From the Cookie Javadoc", "label": {"api": {"Cookie Javadoc": [[9, 22]]}}}, {"text": "After the execution, you can retrieve the generated primary key from the statement with getGeneratedKeys", "label": {"api": {"getGeneratedKeys": [[88, 103]]}}}, {"text": "AWT-EventQueue-0 is your event dispatch thread, and it is indeed blocked reading from a serial port via RXTX a socket via hsqldb", "label": {"api": {"thread": [[40, 45]]}}}, {"text": "Regarding thread names", "label": {"api": {"thread": [[10, 15]]}}}, {"text": "Every thread has a name for identification purposes", "label": {"api": {"thread": [[6, 11]]}}}, {"text": "More than one thread may have the same name", "label": {"api": {"thread": [[14, 19]]}}}, {"text": "If a name is not specified when a thread is created, a new name is generated for it", "label": {"api": {"thread": [[34, 39]]}}}, {"text": "Set the font values in UIManager for the components you want to change", "label": {"api": {"UIManager": [[23, 31]]}}}, {"text": "Note that different look and feels (L&F) may have different properties for the UIManager class, so if you switch from one L&F to another, you may have issues", "label": {"api": {"UIManager": [[79, 87]]}}}, {"text": "See the documentation for setAccessible", "label": {"api": {"setAccessible": [[26, 38]]}}}, {"text": "here is an example how to do it (I used StringTokenizer)", "label": {"api": {"StringTokenizer": [[40, 54]]}}}, {"text": "Have a loot at Class.getResourceAsStream() for details", "label": {"api": {"Class.getResourceAsStream()": [[15, 41]]}}}, {"text": "If you want to use exact precision then BigDecimal is your friend", "label": {"api": {"BigDecimal": [[40, 49]]}}}, {"text": "java.lang.String supplies a method called equalsIgnoreCase", "label": {"api": {"java.lang.String": [[0, 15]]}}}, {"text": "One alternate approach you may try is to use a Canvas rather than a Path", "label": {"api": {"Canvas": [[47, 52]]}}}, {"text": "When reading or writing objects in the SceneGraph from another thread, use Platform.runLater", "label": {"api": {"Platform.runLater": [[75, 91]]}}}, {"text": "Don't call Platform.runLater too often or you will end up overloading the event handling system", "label": {"api": {"Platform.runLater": [[11, 27]]}}}, {"text": "Another possibility is to use a ByteBuffer, but that seems overkill for such a simple operation", "label": {"api": {"ByteBuffer": [[32, 41]]}}}, {"text": "The \"correct\" way to invoke the Java compiler under JDK 1.6 or above is to use the JavaCompiler interface in javax.tools, which you get from the ToolProvider (I include all the links because there's a decent amount of class/package documentation that you should read)", "label": {"api": {"JavaCompiler": [[83, 94]], "javax.tools": [[109, 119]], "ToolProvider": [[145, 156]]}}}, {"text": "This is a special form of the for loop used to iterate over arrays and any Iterable, which includes any Collection", "label": {"api": {"Iterable": [[75, 82]], "Collection": [[104, 113]]}}}, {"text": "The foreach loop can be used for iterating over the elements in an array, or over an object (typically a collection) that implements the Iterable interface", "label": {"api": {"Iterable": [[137, 144]]}}}, {"text": "See the String Formatter Conversions, there is no %l", "label": {"api": {"String Formatter Conversions": [[8, 35]]}}}, {"text": "The formatting is described in great in JavaDocs", "label": {"api": {"formatting is described in great in JavaDocs": [[4, 47]]}}}, {"text": "But if you must keep null values out of your array, you can use a dynamically resizing data structure like ArrayList, and get an array out of it using the toArray method", "label": {"api": {"toArray": [[155, 161]]}}}, {"text": "Without using ArrayList, since you're tracking how many Student objects represent failing students with the j variable, after you collect the failing student objects you could create a new array of the desired length, and then fill it with only the non-null students using a loop, or using Arrays.copyOf, or System.arraycopy", "label": {"api": {"Arrays.copyOf": [[290, 302]], "System.arraycopy": [[308, 323]]}}}, {"text": "Use Executors class to create a thread pool and submit one task per each host", "label": {"api": {"Executors": [[4, 12]]}}}, {"text": "Alternatively use CompletionService to collect results as they arrive", "label": {"api": {"CompletionService": [[18, 34]]}}}, {"text": "I suggest using Map.entrySet() to get the set of entries from your graph", "label": {"api": {"Map.entrySet()": [[16, 29]]}}}, {"text": "Then for each Map.Entry, retrieve the key and value of each one", "label": {"api": {"Map.Entry": [[14, 22]]}}}, {"text": "You're looking for BorderFactory.createDashedBorder(Paint)", "label": {"api": {"BorderFactory.createDashedBorder(Paint)": [[19, 57]]}}}, {"text": "See formatting tutorial", "label": {"api": {"tutorial": [[15, 22]]}}}, {"text": "You may want to modify this to use Character.isWhitespace instead of only checking for ' '", "label": {"api": {"Character.isWhitespace": [[35, 56]]}}}, {"text": "Maybe you need a concurrent data structure", "label": {"api": {"concurrent data structure": [[17, 41]]}}}, {"text": "Randomly choose an index and return the corresponding String in names", "label": {"api": {"Random": [[0, 5]]}}}, {"text": "There is a Random class to do get random numbers in java", "label": {"api": {"Random": [[11, 16]]}}}, {"text": "Also check nextInt method", "label": {"api": {"nextInt": [[11, 17]]}}}, {"text": "I haven't had much experience with Spring, but I would use the javax.ws.rs.core.Reponse class in Java EE", "label": {"api": {"javax.ws.rs.core.Reponse": [[63, 86]]}}}, {"text": "You should use the setString() method to set the userID", "label": {"api": {"setString()": [[19, 29]]}}}, {"text": "Take a look here how to use PreparedStatement", "label": {"api": {"PreparedStatement": [[28, 44]]}}}, {"text": "The String has constructorString(char[] value, int offset, int count) that accepts an array of char plus length (and offset)", "label": {"api": {"String(char[] value, int offset, int count)": [[26, 68]]}}}, {"text": "Yes there is use string constructor with offset and length", "label": {"api": {"constructor": [[24, 34]]}}}, {"text": "Here's Java code to create a sample KMZ file using ZipOutputStream with root KML file and an image file entry", "label": {"api": {"ZipOutputStream": [[51, 65]]}}}, {"text": "Use a TextArea instead", "label": {"api": {"TextArea": [[6, 13]]}}}, {"text": "TextArea description from it's javadoc", "label": {"api": {"TextArea": [[0, 7]]}}}, {"text": "Unlike in previous releases of JavaFX, support for single line input is not available as part of the TextArea control, however this is the sole-purpose of the TextField control", "label": {"api": {"TextArea": [[101, 108]]}}}, {"text": "If you don't like how floating-point numbers work, try something like BigDecimal instead", "label": {"api": {"BigDecimal": [[70, 79]]}}}, {"text": "As of JDK11 you can use stripLeading", "label": {"api": {"stripLeading": [[24, 35]]}}}, {"text": "In particular, the use of an ExecutorService and Future should be sufficient", "label": {"api": {"ExecutorService": [[29, 43]], "Future": [[49, 54]]}}}, {"text": "By writing an \"annotation processor\" I can turn any Java text file into an abstract syntax tree and traverse it using a custom visitor (a subclass of TreePathScanner)", "label": {"api": {"TreePathScanner": [[150, 164]]}}}, {"text": "Check out the API here", "label": {"api": {"the API": [[10, 16]]}}}, {"text": "A better option would be to use nextLine() method for reading such values", "label": {"api": {"nextLine()": [[32, 41]]}}}, {"text": "Take a look at java.util.Random's nextInt() and use that to do unique operations based on the value it returns", "label": {"api": {"java.util.Random": [[15, 30]]}}}, {"text": "You may register a custom ResourceResolver (see also this answer) and make it point to a servlet, which will return a dynamically generated (or fetched from DB) view", "label": {"api": {"ResourceResolver": [[26, 41]]}}}, {"text": "In this case, I can't see a way to solve your problem for localhost/link local testing except to filter out anything after the % sign, or use another class that works with link local addresses to parse the address", "label": {"api": {"another class": [[142, 154]]}}}, {"text": "The problem is that the class you're using (org.encuestame.utils.net.InetAddresses) clearly doesn't support IPv6", "label": {"api": {"InetAddress": [[69, 79]]}}}, {"text": "Try using the java InetAddress class that Joachim mentioned in his answer", "label": {"api": {"InetAddress": [[19, 29]]}}}, {"text": "However, the libs do supply the method deepToString for this purpose, so this may also suit your purposes", "label": {"api": {"deepToString": [[39, 50]]}}}, {"text": "force running GC with java.lang.System.gc() whenever you think that JVM should do", "label": {"api": {"java.lang.System.gc()": [[22, 42]]}}}, {"text": "This is suggested by the NIO doc itself, on the grounds of higher de/alloc cost of direct buffer", "label": {"api": {"This is suggested by the NIO doc itself": [[0, 38]]}}}, {"text": "The key bit is the compare method", "label": {"api": {"compare method": [[19, 32]]}}}, {"text": "As the JavaDoc of DatagramPacket.getData() says", "label": {"api": {"DatagramPacket.getData()": [[18, 41]]}}}, {"text": "We are using String(byte[] bytes, int offset, int length) constructor", "label": {"api": {"String(byte[] bytes, int offset, int length)": [[13, 56]]}}}, {"text": "that I was eliminating duplicates by returning 0 from the compareTo method, not by returning true from an equals implementation as one would need to do to correctly indicate a duplicate in a Set (from the definition of a Set)", "label": {"api": {"definition": [[205, 214]]}}}, {"text": "You can even supply the current working directory when executing the Process", "label": {"api": {"executing the Process": [[55, 75]]}}}, {"text": "As an alternative, you can override the method paintComponent(Graphics g) of JPanel (the contentPane) and use drawImage() on the Graphics object g as in this example", "label": {"api": {"paintComponent(Graphics g)": [[47, 72]], "JPanel": [[77, 82]], "drawImage()": [[110, 120]], "Graphics": [[62, 69], [129, 136]]}}}, {"text": "Make that dialog modal", "label": {"api": {"modal": [[17, 21]]}}}, {"text": "You can using a Collator", "label": {"api": {"Collator": [[16, 23]]}}}, {"text": "Check out SwingWorker, it is designed for this purpose", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "According to the Java API for the Math class, Math extends the Object class", "label": {"api": {"Math": [[34, 37], [46, 49]]}}}, {"text": "However, Math does not inherit Object's methods, and you also cannot construct a Math object (EDIT", "label": {"api": {"Math": [[9, 12], [81, 84]]}}}, {"text": "Math is the foremost example in my mind of this kind of static definition class (I guess you'd call it that?), but this question may also apply to classes that have a similar purpose", "label": {"api": {"Math": [[0, 3]]}}}, {"text": "Set the setLenient() method on the SimpleDateFormat to false to throw errors in such cases", "label": {"api": {"setLenient()": [[8, 19]], "SimpleDateFormat": [[35, 50]]}}}, {"text": "You would process the System.in stream and capture/process whatever the source program (dir in this case) provides", "label": {"api": {"System.in": [[22, 30]]}}}, {"text": "Instead of print use printf", "label": {"api": {"printf": [[21, 26]]}}}, {"text": "The important bit (I think) is to reduce the amount of silly code, so to \"copy\" a bean, you can make it extend Clonable, and the JVM will do the rest", "label": {"api": {"Clonable": [[111, 118]]}}}, {"text": "Your equals() method is overloading equals(Object), while it should override it", "label": {"api": {"equals(Object)": [[36, 49]]}}}, {"text": "Notice the @Override annotation - use it in the future to avoid such problems", "label": {"api": {"@Override": [[11, 19]]}}}, {"text": "In addition, the API documentation is your friend", "label": {"api": {"API documentation": [[17, 33]]}}}, {"text": "Take a look at this link", "label": {"api": {"link": [[20, 23]]}}}, {"text": "Java has a Properties class which is very useful for implementing settings like this", "label": {"api": {"Properties": [[11, 20]]}}}, {"text": "The reason it works is that a Set cannot contain duplicates", "label": {"api": {"Set": [[30, 32]]}}}, {"text": "So while adding elements to a Set, it ignores those that are duplicates", "label": {"api": {"Set": [[30, 32]]}}}, {"text": "Also you'll want to have a look at use of the Future interface and the FutureTasks class that are like Runnables only they allow you to return a result when complete", "label": {"api": {"Future": [[46, 51], [71, 76]], "FutureTasks": [[71, 81]]}}}, {"text": "If you've used a SwingWorker, then you've already used a Future interface without realizing it", "label": {"api": {"Future": [[57, 62]]}}}, {"text": "Note that there are two ways of launching a new thread on code defined in an anonymous class, as described in Thread's javadoc but your method 1 isn't among them and your method 2 is the one you should usually prefer", "label": {"api": {"as described in Thread's javadoc": [[94, 125]]}}}, {"text": "o.getClass().getDeclaredFields() will return an array of Field instances", "label": {"api": {"Field": [[24, 28], [57, 61]]}}}, {"text": "For each Field f in your array, you can access it's value with f.get(o)", "label": {"api": {"Field": [[9, 13]]}}}, {"text": "As per your error, the @Override annotation tells the Java compiler that the following method overrides a method defined in the supertype/interface", "label": {"api": {"@Override": [[23, 31]]}}}, {"text": "A Date (either as a long or a java.util.Date) represents a moment in time", "label": {"api": {"java.util.Date": [[30, 43]]}}}, {"text": "You should be able to parse it with either SimpleDateFormat using the built-in APIs, or DateTimeFormatter in Joda Time, using the pattern \"yyyy-MM-dd'T'HH:mm:ssX\" (SimpleDateFormat) or \"yyyy-MM-dd'T'HH:mm:ssZ\" (DateTimeFormatter)", "label": {"api": {"SimpleDateFormat": [[43, 58], [164, 179]]}}}, {"text": "A key entry in a keystore isn't just for a single certificate, but for a certificate chain (see KeyStore.setKeyEntry, which takes a Certificate[] chain parameter)", "label": {"api": {"KeyStore.setKeyEntry": [[96, 115]]}}}, {"text": "Have a look at the API documentation of interface java.util.Queue, which has several implementations", "label": {"api": {"java.util.Queue": [[50, 64]]}}}, {"text": "I think CountDownLatch is what you need, or possibly CyclicBarrier", "label": {"api": {"CountDownLatch": [[8, 21]], "CyclicBarrier": [[53, 65]]}}}, {"text": "You might consider switching to a JTextPane, which supports HTML markup", "label": {"api": {"JTextPane": [[34, 42]]}}}, {"text": "The doc also says", "label": {"api": {"doc also says": [[4, 16]]}}}, {"text": "I tried to sort strings using a Collator as follows", "label": {"api": {"Collator": [[32, 39]]}}}, {"text": "Does any one have an idea why Java is not taking this rule (digits after letter) into account for the time being I am using RuleBasedCollator as follows", "label": {"api": {"Collator": [[133, 140]], "RuleBasedCollator": [[124, 140]]}}}, {"text": "In particular you could check the poll() method with a desired timeout value", "label": {"api": {"poll()": [[34, 39]]}}}, {"text": "For formatting currency it's better to use NumberFormat.getCurrencyInstance() (look at http://docs.oracle.com/javase/6/docs/api/java/text/NumberFormat.html#getCurrencyInstance) and for limiting fractional part there is NumberFormat.html#setMaximumFractionDigits method", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/NumberFormat.html#getCurrencyInstance": [[87, 174]]}}}, {"text": "ArrayBlockingQueue provides constructor argument to control fairness of the queue - when set to true, it's guaranteed that threads will get elements of the queue in the same order as they called take()", "label": {"api": {"ArrayBlockingQueue": [[0, 17]]}}}, {"text": "As far as I understand, use of ArrayBlockingQueue with fair = true as a backing queue of your pool should be enough for your case", "label": {"api": {"ArrayBlockingQueue": [[31, 48]]}}}, {"text": "JTable offers a DefaultTableModel that makes this much simpler", "label": {"api": {"DefaultTableModel": [[16, 32]]}}}, {"text": "The methods include removeRow(int) where the int (row) is from JTable.getSelectedRow()", "label": {"api": {"removeRow(int)": [[20, 33]], "JTable.getSelectedRow()": [[63, 85]]}}}, {"text": "Alternatively, simply open() the spreadsheet, leveraging the user's preferred spreadsheet application", "label": {"api": {"open()": [[22, 27]]}}}, {"text": "You could use the UUID class in the JRE", "label": {"api": {"UUID": [[18, 21]]}}}, {"text": "ThreadPoolExecutor, example here", "label": {"api": {"ThreadPoolExecutor": [[0, 17]]}}}, {"text": "Use a FileWriter to write your String to a File, like so", "label": {"api": {"FileWriter": [[6, 15]]}}}, {"text": "Then use a FileReader to read it back", "label": {"api": {"FileReader": [[11, 20]]}}}, {"text": "I have some tasks executing them asynchronously with ExecutorService, which is created with this bean", "label": {"api": {"ExecutorService": [[53, 67]]}}}, {"text": "If you are on Java 7 you can use the new ProcessBuilder.redirectOutput mechanism", "label": {"api": {"ProcessBuilder.redirectOutput": [[41, 69]]}}}, {"text": "If you take a look at the JavaDoc's for the Random class you will see that you need to call specific methods, nextInt(), nextFloat(), etc", "label": {"api": {"JavaDoc's for the Random class": [[26, 55]]}}}, {"text": "Yes, it's called SimpleDateFormat, you just have to define your pattern", "label": {"api": {"SimpleDateFormat": [[17, 32]]}}}, {"text": "If you're just interested in the language, simply use Locale.getLanguage() to transform a locale into a String, and new Locale(String language) to transform the String into a Locale", "label": {"api": {"Locale.getLanguage()": [[54, 73]], "new Locale(String language)": [[116, 142]]}}}, {"text": "If you want to store the whole Locale, use Locale.toString(), and a custom method that splits on _ to transform the string into the three parts of a Locale", "label": {"api": {"Locale.toString()": [[43, 59]]}}}, {"text": "You need to explicitly terminate the Timer using timer.cancel(), e.g.", "label": {"api": {"cancel()": [[55, 62]]}}}, {"text": "The number of tasks might very well be larger than the max number of threads the executor is allowed to create so I don't think a CyclicBarrier would work", "label": {"api": {"CyclicBarrier": [[130, 142]]}}}, {"text": "Look at http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html and you will see that max only returns the max between two numbers, so likely you code is not even compiling", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html": [[8, 67]]}}}, {"text": "You can insert a custom ListSelectionModel into your table that ignores or modifies selection events involving the non-selectable rows", "label": {"api": {"ListSelectionModel": [[24, 41]]}}}, {"text": "You could use a custom TableModel implementation that wraps your real model to do the filtering", "label": {"api": {"TableModel": [[23, 32]]}}}, {"text": "Just keep notifying the TableModelListeners whenever the columns change", "label": {"api": {"TableModel": [[24, 33]]}}}, {"text": "One issue I'm seeing with your code is that you're re-using the same GridBagConstraints object for all the elements you add, which is not recommended", "label": {"api": {"GridBagConstraints": [[69, 86]]}}}, {"text": "Alternatively, use something like TableLayout - or bite the bullet and read up on the intricacies of GridBagConstraints", "label": {"api": {"GridBagConstraints": [[101, 118]]}}}, {"text": "You can use a HashMap to save the number of occurences", "label": {"api": {"HashMap": [[14, 20]]}}}, {"text": "use String#split(\"-\") and String#trim() afterwards)", "label": {"api": {"String#split(\"-\")": [[4, 20]], "String#trim()": [[26, 38]]}}}, {"text": "The Node class has a getAttributes method that should give you what you need", "label": {"api": {"getAttributes": [[21, 33]]}}}, {"text": "Have a look at ExecutorService, I guess this is all what you need", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "As suggested by Peter you can create ExecutorService using  newSingleThreadExecutor and use it to process your tasks", "label": {"api": {"ExecutorService": [[37, 51]], "newSingleThreadExecutor": [[60, 82]]}}}, {"text": "You need to use StringTokenizer or split(...) method of String class", "label": {"api": {"StringTokenizer": [[16, 30]], "split(...) method of String": [[35, 61]]}}}, {"text": "String.getBytes(String charsetName) will give you a byte-array", "label": {"api": {"String.getBytes(String charsetName)": [[0, 34]]}}}, {"text": "If I have understood your question correctly, You can use Collection.retainAll and then iterate over collection that is been retained and do what you have to do", "label": {"api": {"Collection.retainAll": [[58, 77]]}}}, {"text": "You can use the proxy pattern, implemented by the Proxy class in Java - it is designed exactly for your purpose", "label": {"api": {"Proxy": [[50, 54]]}}}, {"text": "AFAIK, you cannot use the regular Proxy mechanism for static methods, as the proxy and the proxied class must implement a common interface", "label": {"api": {"Proxy": [[34, 38]]}}}, {"text": "Configuration options for a rich client deployed using JWS are probably best stored in the PersistenceService", "label": {"api": {"PersistenceService": [[91, 108]]}}}, {"text": "Not necessarily - cf the javadoc (emphasis mine)", "label": {"api": {"the javadoc (emphasis mine)": [[21, 47]]}}}, {"text": "Did you try already to use getContentLength on the URL connection", "label": {"api": {"getContentLength": [[27, 42]]}}}, {"text": "Since you want something running every two hours, check out the Timer class", "label": {"api": {"Timer": [[64, 68]]}}}, {"text": "You can use Enumeration getResources(String name) on the class loader to achieve the same", "label": {"api": {"Enumeration getResources(String name)": [[12, 48]]}}}, {"text": "What I do is I read java source files from classpath and process them using ClassLoader", "label": {"api": {"ClassLoader": [[76, 86]]}}}, {"text": "However the problem is that hasNext() and next() methods of the Iterator object does not allow to throw IOException", "label": {"api": {"Iterator": [[64, 71]]}}}, {"text": "Next() is throwing http://docs.oracle.com/javase/7/docs/api/java/util/NoSuchElementException.html, You can write a custom Exception class, catching that exception and then throw the IOException", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/NoSuchElementException.html": [[19, 96]]}}}, {"text": "You can use clone to copy an array", "label": {"api": {"clone": [[12, 16]]}}}, {"text": "If you want the copy eight elements long regardless of the length of the original, you can use Arrays.copyOf", "label": {"api": {"Arrays.copyOf": [[95, 107]]}}}, {"text": "You can use the skip method of the FileInputStream to skip the first n bytes of your file", "label": {"api": {"skip": [[16, 19], [54, 57]]}}}, {"text": "Arrays.asList creates a List from an Array", "label": {"api": {"Arrays.asList": [[0, 12]]}}}, {"text": "As you correctly identifier arrays are static in the sense that you can't add elements to them or remove them", "label": {"api": {"add": [[74, 76]], "remove": [[98, 103]]}}}, {"text": "Lists, however, usually allow those operations", "label": {"api": {"Lists": [[0, 4]]}}}, {"text": "The List returned by Arrays.asList() does have the add/remove methods (otherwise it would not be a valid List)", "label": {"api": {"Arrays.asList()": [[21, 35]], "add": [[51, 53]], "remove": [[55, 60]]}}}, {"text": "However actually calling those methods will throw an UnsupportedOperationException exactly because you can't actually add elements to an array (for which this List is simply a view/wrapper)", "label": {"api": {"add": [[118, 120]]}}}, {"text": "set(int, E) works just fine on the List returned by Arrays.asList()", "label": {"api": {"Arrays.asList()": [[52, 66]], "set(int, E)": [[0, 10]]}}}, {"text": "However, what you can do is create a BufferedImage that flips the one pixel, and draw that entire image to the component in the paint method, using Graphics.drawImage()", "label": {"api": {"BufferedImage": [[37, 49]], "Graphics.drawImage()": [[148, 167]]}}}, {"text": "Look carefully at String.replaceAll javadoc", "label": {"api": {"String.replaceAll javadoc": [[18, 42]]}}}, {"text": "If you use the genericised HashSet then the iterator will be similarly typed, and it.next() will return the correct type", "label": {"api": {"HashSet": [[27, 33]]}}}, {"text": "That's a long way of saying that if you declare your HashSet as HashSet<Integer> then the iterator will return a (boxable) Integer", "label": {"api": {"HashSet": [[53, 59], [64, 70]]}}}, {"text": "YOu can interact with the standard input / output / error streams of another command by using a ProcessBuilder to start that command as a Process", "label": {"api": {"ProcessBuilder": [[96, 109]], "Process": [[96, 102], [138, 144]]}}}, {"text": "You don't want thread, you want a thread pool (ExecutorService)", "label": {"api": {"ExecutorService": [[47, 61]]}}}, {"text": "Submit some number of Callable<HeuristicResult> to your pool and wait on returned Future<HeuristicResult>", "label": {"api": {"Future<HeuristicResult>": [[82, 104]]}}}, {"text": "There is an Arrays.sort() method which can do the work for you", "label": {"api": {"Arrays.sort()": [[12, 24]]}}}, {"text": "If the Employee class is designed correctly with a correct implementations of equals, hashCode and toString, the match method will be as simple as", "label": {"api": {"equals": [[78, 83]], "hashCode": [[86, 93]], "toString": [[99, 106]]}}}, {"text": "If you look at the Formatter docs, this format string is requesting a string conversion (s) with a width of 251 and a flag of #", "label": {"api": {"Formatter": [[19, 27]]}}}, {"text": "In Java, one way around some of these issues includes using something like BigDecimal", "label": {"api": {"BigDecimal": [[75, 84]]}}}, {"text": "You could try adding into the channel pipeline an OrderdMemoryAwareThreadPoolExecutor (recommended) for executing the handlers or alternatively, try dispatching your handler work to a new ThreadPoolExecutor and passing a reference to the socket channel for later writing the response back to client", "label": {"api": {"ThreadPoolExecutor": [[67, 84], [188, 205]]}}}, {"text": "I haven't been able to find an API for arrays (other than this Arrays, but this just defines a bunch of static helper functions for dealing with actual arrays)", "label": {"api": {"Arrays": [[63, 68]]}}}, {"text": "to change the value, use the setAttribute() method", "label": {"api": {"setAttribute()": [[29, 42]]}}}, {"text": "from the value text node, call getParentNode() twice (once to get back to the value element & once to get back to the type element), then call setAttribute() after you do any necissary casting", "label": {"api": {"setAttribute()": [[143, 156]]}}}, {"text": "You also will not want have success with [^(div)], which according to Pattern docs will not match any of the characters d, i, v, (, or )", "label": {"api": {"Pattern docs": [[70, 81]]}}}, {"text": "Runtime.getRuntime().freeMemory() is a way to get free memory for JVM at that moment while runtime", "label": {"api": {"free memory for JVM": [[50, 68]]}}}, {"text": "Christian concludes his answer by stating that Runtime.getRuntime().freeMemory() in fact returns what may be called presumable free memory; even if a future memory allocation does not exceed the value returned by that function, if the Java Virtual Machine has not yet received the actual chunk of memory assigned by the host system, a java.lang.OutOfMemoryError may still be produced", "label": {"api": {"java.lang.OutOfMemoryError": [[335, 360]]}}}, {"text": "In addition to the other answer, I would like to note that doing that is not necessarily a good idea, since you might have a cache in your app that uses SoftReferences", "label": {"api": {"SoftReferences": [[153, 166]]}}}, {"text": "Then the people that didn't answer would be A - B, and you can do that with Collection#removeAll(Collection c)", "label": {"api": {"Collection#removeAll(Collection c)": [[76, 109]]}}}, {"text": "According to the ServletContext javadoc", "label": {"api": {"ServletContext javadoc": [[17, 38]]}}}, {"text": "As for handling exceptions in a ScheduledExecutorService - if you call Future.get(), it will throw ExecutionException if the original task threw an exception, exposing the original exception as the cause", "label": {"api": {"Future.get()": [[71, 82]], "ExecutionException": [[99, 116]]}}}, {"text": "List is an interface and therefore cannot be instantiated", "label": {"api": {"List": [[0, 3]]}}}, {"text": "ArrayList is a class that implements the List interface", "label": {"api": {"List": [[5, 8], [41, 44]], "ArrayList": [[0, 8]]}}}, {"text": "Edit Just saw that you needed a LinkedList, try this", "label": {"api": {"List": [[38, 41]], "LinkedList": [[32, 41]]}}}, {"text": "The Locale class uses ISO 3166 standard for country codes and ISO 639 for language codes", "label": {"api": {"Locale class": [[4, 15]]}}}, {"text": "I recommend to use  FileChannel and ByteBuffer which have methods to read and write floats", "label": {"api": {"FileChannel": [[20, 30]], "ByteBuffer": [[36, 45]]}}}, {"text": "Pay attention to byte order, ByteBuffer have methods to set desired order", "label": {"api": {"ByteBuffer": [[29, 38]]}}}, {"text": "There is no guarantee that getTables() method will return full data", "label": {"api": {"will return full data": [[46, 66]]}}}, {"text": "Maybe I quoted wrong methods, but I am sure you can find some in DatabaseMetaData class that will return what you need in case of excel", "label": {"api": {"DatabaseMetaData": [[65, 80]]}}}, {"text": "You can use String#replace method", "label": {"api": {"String#replace": [[12, 25]]}}}, {"text": "Or use String#split", "label": {"api": {"String#split": [[7, 18]]}}}, {"text": "Use Thread.sleep(long millis) instead, on the worker thread", "label": {"api": {"Thread.sleep(long millis)": [[4, 28]]}}}, {"text": "So if you see Collection framework before 1.5 you see ArrayList, there is no generic", "label": {"api": {"ArrayList": [[54, 62]]}}}, {"text": "You're using String.replaceAll, which takes a regular expression as its inputs, including the replacement", "label": {"api": {"String.replaceAll": [[13, 29]], "String.replace": [[13, 26]]}}}, {"text": "As documented in Match.replaceAll()", "label": {"api": {"Match.replaceAll()": [[17, 34]]}}}, {"text": "You're really just trying to do a straight replace with no regexes involved, so use String.replace instead", "label": {"api": {"String.replace": [[84, 97]]}}}, {"text": "Or by using elementAt(position)", "label": {"api": {"elementAt(position)": [[12, 30]]}}}, {"text": "You need a dynamically growing container for a set of unknown size - a List, for example", "label": {"api": {"List": [[71, 74]]}}}, {"text": "Use some variant of the BlockingQueue, either array based or linked list based", "label": {"api": {"BlockingQueue": [[24, 36]]}}}, {"text": "I tried LinkedList but I found in the documentation of addAll, that an iterator is used to append the two lists", "label": {"api": {"addAll": [[55, 60]]}}}, {"text": "addAll in ArrayList converts it to an Array and then uses a system call to copy (System.arraycopy)", "label": {"api": {"addAll": [[0, 5]], "System.arraycopy": [[81, 96]]}}}, {"text": "Have a look the Java API for more and see all the needed properties are available for you", "label": {"api": {"Java API": [[16, 23]]}}}, {"text": "But you can put JavaFX scene inside JFrame by using JFXPanel", "label": {"api": {"JFXPanel": [[52, 59]]}}}, {"text": "Use the Lock object when multiple locks have to obtained in order to avoid lock ordering deadlock", "label": {"api": {"Lock": [[8, 11]]}}}, {"text": "In this case, the method tryLock() in the Lock object will return immediately with the value false", "label": {"api": {"Lock": [[28, 31], [42, 45]]}}}, {"text": "Your likely problem is that Calendar uses a zero-based index for months", "label": {"api": {"Calendar uses a zero-based index for months": [[28, 70]]}}}, {"text": "So if you're trying to set your calendar to October, you have to use 9, not 10", "label": {"api": {"October": [[44, 50]]}}}, {"text": "Normally you should use the ServerSocket.setRuseAddress(true) to avoid this issue", "label": {"api": {"ServerSocket.setRuseAddress(true)": [[28, 60]]}}}, {"text": "The object returned by Component#getTreeLock() is used as a thread sychronization monitor", "label": {"api": {"Component#getTreeLock()": [[23, 45]]}}}, {"text": "You are using a FlowLayout, but you need to understand each layout and the rules positioning elements", "label": {"api": {"FlowLayout": [[16, 25]]}}}, {"text": "If you can use Callables instead of Runnables in your threads you could try and call someTask.cancel() to get rid of the running tasks at the time of shutdownNow() call", "label": {"api": {"someTask.cancel()": [[85, 101]]}}}, {"text": "As an alternative, consider JFormattedTextField", "label": {"api": {"JFormattedTextField": [[28, 46]]}}}, {"text": "You can implement the CellEditorListener interface, as shown in this example", "label": {"api": {"CellEditorListener": [[22, 39]]}}}, {"text": "Note that JTable itself is a CellEditorListener", "label": {"api": {"CellEditorListener": [[29, 46]], "JTable": [[10, 15]]}}}, {"text": "You should use nanoTime() to calculate elapsed time", "label": {"api": {"nanoTime()": [[15, 24]]}}}, {"text": "If yes, AffineTransform might be what you're looking for", "label": {"api": {"AffineTransform": [[8, 22]]}}}, {"text": "Your class should implements Comparable and the compareTo() method", "label": {"api": {"Comparable": [[29, 38]], "compareTo()": [[48, 58]]}}}, {"text": "If you have issues showing the value, I suggest you use DecimalFormat to format it", "label": {"api": {"DecimalFormat": [[56, 68]]}}}, {"text": "You can try setAllowsInvalid(false) on spinner's formatter", "label": {"api": {"setAllowsInvalid(false)": [[12, 34]]}}}, {"text": "To convert your string to a date, you can use SimpleDateFormat.parse(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")", "label": {"api": {"SimpleDateFormat": [[46, 61]]}}}, {"text": "With this TreeMap in hand, you can find an interval quickly by calling floorEntry on the number that you are trying to locate and checking if the returned interval key overlaps the value that you are looking for", "label": {"api": {"floorEntry": [[71, 80]]}}}, {"text": "If this is a text file, why don't you use readLine()", "label": {"api": {"readLine()": [[42, 51]]}}}, {"text": "This code from the HBox javadoc will almost do what you want, except that \"buttons themselves are different sizes based on the text contained in the button - wider text causes wider buttons\"", "label": {"api": {"HBox javadoc": [[19, 30]]}}}, {"text": "Use String.matches(), like", "label": {"api": {"String.matches()": [[4, 19]]}}}, {"text": "You can always read a String, log it, then use Double.valueOf(String) to convert it", "label": {"api": {"Double.valueOf(String)": [[47, 68]]}}}, {"text": "I would take a look at the Action API", "label": {"api": {"Action": [[27, 32]]}}}, {"text": "It allows you to define a \"Action\" and it's properties independently of the UI", "label": {"api": {"Action": [[27, 32]]}}}, {"text": "Have a look at How to use Actions for more information", "label": {"api": {"Action": [[26, 31]]}}}, {"text": "If you want case-insensitive match, just throw in one of the insensitive regex flags and you should be good", "label": {"api": {"insensitive regex flags": [[61, 83]]}}}, {"text": "Actually, Java has an interface named XMLReader", "label": {"api": {"XMLReader": [[38, 46]]}}}, {"text": "Struts does this simply by using ServletContext", "label": {"api": {"ServletContext": [[33, 46]]}}}, {"text": "Using Thread.currentThread().getStackTrace(), one can get the line number of an StackTraceElement", "label": {"api": {"StackTraceElement": [[80, 96]]}}}, {"text": "But what can I do if I only got the java.lang.reflect.Method Object", "label": {"api": {"java.lang.reflect.Method": [[36, 59]]}}}, {"text": "You should have a look at ExecutorService which has been created to achieve this kind of things", "label": {"api": {"ExecutorService": [[26, 40]]}}}, {"text": "You can create an Executor with Executors.newFixedThreadPool(10) and use it to execute each request as its own Runnable", "label": {"api": {"Executors.newFixedThreadPool(10)": [[32, 63]]}}}, {"text": "I think you should use a LinkedList under Queue interface", "label": {"api": {"LinkedList": [[25, 34]], "Queue": [[42, 46]]}}}, {"text": "For understanding me better, look at LinkedList and Queue javadocs", "label": {"api": {"LinkedList": [[37, 46]], "Queue": [[52, 56]]}}}, {"text": "I have added a shutdown hook via", "label": {"api": {"shutdown hook": [[15, 27]]}}}, {"text": "Is there a way to make the shutdown hook be called in Eclipse", "label": {"api": {"shutdown hook": [[27, 39]]}}}, {"text": "DecimalFormat has a method called setParseBigDecimal that causes parse() to return a BigDecimal", "label": {"api": {"setParseBigDecimal": [[34, 51]]}}}, {"text": "Recently I run into ConcurrentSkipListMap, which is a skip list implementation of ConcurrentNavigableMap", "label": {"api": {"ConcurrentSkipListMap": [[20, 40]]}}}, {"text": "Specifically, you can get all the current ThreadInfos From the ThreadMXBean and write the contents to your desired location", "label": {"api": {"ThreadInfos": [[42, 52]], "ThreadMXBean": [[63, 74]]}}}, {"text": "It would be better to encapsulate the conditions for accepting a directory as representing a month within a FileFilter that can be used with overloaded variants of listFiles()", "label": {"api": {"FileFilter": [[108, 117]]}}}, {"text": "I thought I could use entityManager.detach(player) to use in the other team, but this method is not available in the GAE jar (?)", "label": {"api": {"entityManager.detach(player)": [[22, 49]]}}}, {"text": "Use the Lock class in concurrent package in java", "label": {"api": {"Lock": [[8, 11]]}}}, {"text": "It has ReenterantReadWriteLock", "label": {"api": {"Lock": [[26, 29]]}}}, {"text": "You want to use the CompletionService and keep track of the submitted tasks", "label": {"api": {"CompletionService": [[20, 36]]}}}, {"text": "You should set the cipher suite on the SSLSocket (or SSLEngine) using setEnabledCipherSuites", "label": {"api": {"setEnabledCipherSuites": [[70, 91]]}}}, {"text": "LinkedHashMap maintains the order of insertion", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "You need to use #getDeclaredFields() to include private fields, #getFields() only lists the public ones", "label": {"api": {"#getDeclaredFields()": [[16, 35]], "#getFields()": [[64, 75]]}}}, {"text": "With private fields you will also run into access restriction problems, so you probably want to look into the Field#setAccessible() method as well", "label": {"api": {"Field#setAccessible()": [[110, 130]]}}}, {"text": "Use the version of exec that takes a String[]", "label": {"api": {"exec": [[19, 22]]}}}, {"text": "The former - the version of exec that takes a String[] - is passed each argument individually, and so doesn't have this problem", "label": {"api": {"exec": [[28, 31]]}}}, {"text": "LinkedList.add returns a boolean (always true)", "label": {"api": {"LinkedList.add": [[0, 13]]}}}, {"text": "JList extends JComponent, which has an extensive list of methods you could use to varying degrees", "label": {"api": {"extensive list of methods": [[39, 63]]}}}, {"text": "For example, if you just want to disable the JList from user interaction, there is setEnabled which will \"grey\" out that component", "label": {"api": {"setEnabled": [[83, 92]]}}}, {"text": "If you want to hide the JList completely, see setVisible", "label": {"api": {"setVisible": [[46, 55]]}}}, {"text": "What you can do is create a class which implements Comparator<Edge>", "label": {"api": {"Comparator": [[51, 60]]}}}, {"text": "After you have done this you can use the comparator to sort a list of Edge objects using Collections.sort()", "label": {"api": {"Collections.sort": [[89, 104]]}}}, {"text": "Here is the javadoc on Comparator and Collections.sort", "label": {"api": {"Comparator": [[23, 32]], "Collections.sort": [[38, 53]]}}}, {"text": "If you have an array instead of a list you can instead use Array.sort in the same way as Collections.sort", "label": {"api": {"Collections.sort": [[89, 104]], "Array.sort": [[59, 68]]}}}, {"text": "The JavaDoc explicitly states", "label": {"api": {"explicitly states": [[12, 28]]}}}, {"text": "Extend a JTextField with your own class and override the insertString method from the Document, like in the API docs", "label": {"api": {"API docs": [[108, 115]]}}}, {"text": "scheduleAtFixedRate instead of submit", "label": {"api": {"scheduleAtFixedRate": [[0, 18]]}}}, {"text": "HashMap is not sorted you should use a SortedMap implementation instead for example TreeMap", "label": {"api": {"TreeMap": [[84, 90]]}}}, {"text": "Then you could create your own Comparator<String> which will sort by the groups attribute of the actual Student instance but you'll need the actual map for it because TreeMap sorts by the keys, so this is a possible but not nice solution", "label": {"api": {"TreeMap": [[167, 173]], "Comparator<String>": [[31, 48]]}}}, {"text": "So with TreeMap", "label": {"api": {"TreeMap": [[8, 14]]}}}, {"text": "SSLEngine operates using ByteBuffer directly", "label": {"api": {"SSLEngine": [[0, 8]], "ByteBuffer": [[25, 34]]}}}, {"text": "To determine if you have enough data buffered use the handshake status and status", "label": {"api": {"handshake status": [[54, 69]], "status": [[64, 69], [75, 80]]}}}, {"text": "So you need to keep a queue of ByteBuffer objects", "label": {"api": {"ByteBuffer": [[31, 40]]}}}, {"text": "You keep going until you get \"Finished\" from the handshake status", "label": {"api": {"handshake status": [[49, 64]], "status": [[59, 64]]}}}, {"text": "Just use getImage()", "label": {"api": {"getImage()": [[9, 18]]}}}, {"text": "A Set does not allow duplicate entries", "label": {"api": {"Set": [[2, 4]]}}}, {"text": "The Set checks entries with .equals(), which will be true for two duplicate entries", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "Check this documentation link", "label": {"api": {"link": [[25, 28]]}}}, {"text": "ThreadPoolExecutor implementation in the java.util.concurrent can help you adjust the Thread pool size, workQueue size and other various extensibility hooks", "label": {"api": {"ThreadPoolExecutor": [[0, 17]]}}}, {"text": "You can use String#split()", "label": {"api": {"String#split()": [[12, 25]]}}}, {"text": "You can use \"@\" to split dates and then use SimpleDateFormat to convert Strings in to Date", "label": {"api": {"SimpleDateFormat": [[44, 59]]}}}, {"text": "Use a BufferedReader to read the file, read each line using readLine as strings, and put them in an ArrayList on which you call toArray at end of loop", "label": {"api": {"BufferedReader": [[6, 19]], "readLine": [[60, 67]]}}}, {"text": "If you use Java 7 it can be done in two lines thanks to the Files#readAllLines method", "label": {"api": {"the Files#readAllLines method": [[56, 84]]}}}, {"text": "If you want to write text to a file in Java, you should take a look at FileWriter instead of relying on shell-specific details such as stream redirection", "label": {"api": {"FileWriter": [[71, 80]]}}}, {"text": "That can be done by calling its paint method", "label": {"api": {"paint": [[32, 36]]}}}, {"text": "So by calling that paint method with your constructed eps graphics object, you can cause all painting instructions to go to the eps file", "label": {"api": {"paint": [[19, 23], [93, 97]]}}}, {"text": "That is what the paint(g) line in the manual refers to", "label": {"api": {"paint": [[17, 21]]}}}, {"text": "Given that your Java collection is a sequence (in Java, a List) with a particularly efficient get method, you could implement the Splitter as an iterator that calls get within the initial range from 0 to size - 1, and is split by subdividing this range", "label": {"api": {"List": [[58, 61]]}}}, {"text": "Look at the documentation for Thread.start", "label": {"api": {"Thread.start": [[30, 41]]}}}, {"text": "Each List implements the method indexOf(Object)", "label": {"api": {"indexOf(Object)": [[32, 46]]}}}, {"text": "Look at java.util.Timer method scheduleAtFixedRate()", "label": {"api": {"java.util.Timer": [[8, 22]]}}}, {"text": "Use the Java EE ServletContextListener", "label": {"api": {"ServletContextListener": [[16, 37]]}}}, {"text": "The standard doclet produces the familiar HTML output but you can write your own and tell javadoc to use that instead", "label": {"api": {"write your own": [[66, 79]]}}}, {"text": "Once you get the .next() value as a String, check if its .length() == 1, then use yourString.charAt(0)", "label": {"api": {"yourString.charAt(0)": [[82, 101]]}}}, {"text": "I think you are referring to getRgb() method of BufferedImage class", "label": {"api": {"getRgb()": [[29, 36]]}}}, {"text": "Supposing you want to modify the whole image or a big portion of it, retrieving the pixel array, and perform operations on it could be considerely faster than accessing each single pixel through method calls such as setRgb()", "label": {"api": {"setRgb()": [[216, 223]]}}}, {"text": "Any change to the visual appereance to the Swing component must be done through the assigned layout manager, in this case FlowLayout - in line 1", "label": {"api": {"FlowLayout": [[122, 131]]}}}, {"text": "To see the change you must notify the Swing components layout manager to rearrange the components - in line 2 the revalidate() method \"notifies\" the layout manager to recalculate the new positions and eventually \"notifies\" the EDT to draw it on the screen", "label": {"api": {"revalidate()": [[114, 125]]}}}, {"text": "a list iterator lets you add an element at the current position", "label": {"api": {"add an element at the current position": [[25, 62]]}}}, {"text": "What you want is a javax.servlet.ServletContextListener", "label": {"api": {"javax.servlet.ServletContextListener": [[19, 54]]}}}, {"text": "You will have to use one of the available constructors", "label": {"api": {"available constructors": [[32, 53]]}}}, {"text": "You need to disable \"back-references\" in serialization, so use ObjectOutputStream.writeUnshared", "label": {"api": {"ObjectOutputStream.writeUnshared": [[63, 94]]}}}, {"text": "It's good practice to couple this with ObjectInputStream.readUnshared in some cases -- this one included", "label": {"api": {"ObjectInputStream.readUnshared": [[39, 68]]}}}, {"text": "Since we want our desktop clients to work across platforms and since the developer cannot know exactly which directory this application is launching from, we have the  preferences API to provide a layer of abstraction above the local file system", "label": {"api": {"preferences API": [[168, 182]]}}}, {"text": "(This behaviour of next() is documented.)  Calling getText() is only giving you the text for the current event", "label": {"api": {"documented": [[29, 38]]}}}, {"text": "Try using getElementText() instead", "label": {"api": {"getElementText()": [[10, 25]]}}}, {"text": "Here's an example from the JList documentation", "label": {"api": {"JList documentation": [[27, 45]]}}}, {"text": "The obvious way to do this would be to put the data in a SortedSet, so you don't have a separate sorting step", "label": {"api": {"SortedSet": [[57, 65]]}}}, {"text": "This class should implement the Comparable interface, or if you need sorting with different criteria you can provide separate Comparators", "label": {"api": {"Comparable": [[32, 41]], "Comparators": [[126, 136]]}}}, {"text": "Please read the java 6 api documentation http://docs.oracle.com/javase/6/docs/api/java/util/Random.html#nextInt(int)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Random.html#nextInt(int": [[41, 114]]}}}, {"text": "documentation for Weblogic Startup Class", "label": {"api": {"documentation for Weblogic Startup Class": [[0, 39]]}}}, {"text": "In the Math API since Java 8, you can use", "label": {"api": {"Math API": [[7, 14]]}}}, {"text": "Maybe you use Map implementation that doesn't maintain order of elements added (most implementations don't, LinkedHashmap does)", "label": {"api": {"LinkedHashmap": [[108, 120]]}}}, {"text": "java.lang.Class is a generic type parameterized on itself, so you can use its type parameter, like this", "label": {"api": {"java.lang.Class": [[0, 14]]}}}, {"text": "Use the method Arrays.asList() from the Arrays class", "label": {"api": {"Arrays.asList()": [[15, 29]]}}}, {"text": "One option is to add a HierarchyListener to the root of your display hierarchy and do the repaint there", "label": {"api": {"HierarchyListener": [[23, 39]]}}}, {"text": "But if you can't for some reason (I guess homework?), then have a look at System.arraycopy to efficiently copy arrays", "label": {"api": {"System.arraycopy": [[74, 89]]}}}, {"text": "The default list of values should never change, as such when populating them, I use Collections.nCopies(int,T) to obtain an immutable List", "label": {"api": {"Collections.nCopies(int,T)": [[84, 109]]}}}, {"text": "If you actually were able to do toString (as Quoi points out, you cannot do from a primitive), it would make it impossible to use Formatters that expect the used Number object (Double in your case)", "label": {"api": {"Formatter": [[130, 138]]}}}, {"text": "This is the Formatter that String.format uses", "label": {"api": {"Formatter": [[12, 20]], "String.format": [[27, 39]]}}}, {"text": "Another approach is to put all the special chars in a String and use String.contains", "label": {"api": {"String.contains": [[69, 83]]}}}, {"text": "Use ClassLoader.getResourceAsStream in place of File in first two projects as below", "label": {"api": {"ClassLoader.getResourceAsStream": [[4, 34]]}}}, {"text": "If you then convert your int to a String via the Integer.toString(int i) method, you can concatenate them using the + operator and output all three of them after the loop", "label": {"api": {"Integer.toString(int i)": [[49, 71]]}}}, {"text": "You would want to make use of the List<E>.add(int idx, E element) method", "label": {"api": {"List<E>.add(int idx, E element)": [[34, 64]]}}}, {"text": "Once you created a File object that refers to the directory, you can call listFiles to get an array of all the files in the directory", "label": {"api": {"listFiles": [[74, 82]]}}}, {"text": "Alternatively, you can get only the list of files that are not directories by calling File#listFiles(FileFilter) with an appropriate file filter", "label": {"api": {"listFiles": [[91, 99]], "File#listFiles(FileFilter)": [[86, 111]]}}}, {"text": "You will have to use either the Date or the Calendar class instead for the time", "label": {"api": {"Date": [[32, 35]], "Calendar": [[44, 51]]}}}, {"text": "According to its javadocs found here, you can use the .add() function to achieve the result you're seeking", "label": {"api": {"javadocs found here": [[17, 35]]}}}, {"text": "Your Filter class will receive a ServletRequest in its doFilter method", "label": {"api": {"doFilter": [[55, 62]]}}}, {"text": "In your doFilter method, check the request for the required parameter using ServletRequest.getParameter", "label": {"api": {"doFilter": [[8, 15]]}}}, {"text": "don't pass it back into the filter chain using FilterChain.doFilter", "label": {"api": {"doFilter": [[59, 66]]}}}, {"text": "Consider Collections.sort instead", "label": {"api": {"Collections.sort": [[9, 24]]}}}, {"text": "If that still isn't sufficient, you can use BigDecimal", "label": {"api": {"BigDecimal": [[44, 53]]}}}, {"text": "You can use BufferedInputStream(InputStream in)", "label": {"api": {"BufferedInputStream(InputStream in)": [[12, 46]]}}}, {"text": "In Java, use .equals() instead of == for comparing strings", "label": {"api": {".equals()": [[13, 21]]}}}, {"text": "Also, for currencies, and other such critical data, I'd recommend BigDecimal, which stores the exact string representation, not the binary approximation", "label": {"api": {"BigDecimal": [[66, 75]]}}}, {"text": "I'm not sure how much more expensive a HashMap<Integer, T> would be", "label": {"api": {"Map<Integer, T>": [[43, 57]]}}}, {"text": "Integer.hashCode() is quite efficient, though the only really expensive operation might be copying the data into a new larger array as the number of items increases", "label": {"api": {"Integer.hashCode()": [[0, 17]]}}}, {"text": "As an alternative, you could implement your own Map<Integer, T> that does not use the hash code but the Integer itself", "label": {"api": {"Map<Integer, T>": [[48, 62]]}}}, {"text": "For each merged file (in other words for each key) sequentially read its values using PriorityQueue to maintain top 5000 values without loading all the values into memory", "label": {"api": {"PriorityQueue": [[86, 98]]}}}, {"text": "Use method waitFor() of class Process", "label": {"api": {"waitFor() of class Process": [[11, 36]]}}}, {"text": "Runtime.exec() and friends return a Process object, which has an exitValue() method that returns the exit code", "label": {"api": {"Process": [[36, 42]]}}}, {"text": "You can use the DatabaseMetaData.getTables() procedure to search the database for tables with a particular pattern", "label": {"api": {"DatabaseMetaData.getTables()": [[16, 43]]}}}, {"text": "You try taking advantage of the Scrollable interface", "label": {"api": {"Scrollable": [[32, 41]]}}}, {"text": "There is now the AutoClosable interface which Connection implements", "label": {"api": {"AutoClosable": [[17, 28]]}}}, {"text": "However, if you really needed that much control over memory, you could manage it yourself by indexing into a byte[] or even off-heap in a direct ByteBuffer", "label": {"api": {"ByteBuffer": [[145, 154]]}}}, {"text": "You can try using a Scanner", "label": {"api": {"Scanner": [[20, 26]]}}}, {"text": "Enough is to use ScheduledExecutorService.html#scheduleAtFixedRate()", "label": {"api": {"ScheduledExecutorService.html#scheduleAtFixedRate()": [[17, 67]]}}}, {"text": "Can I convert a Class attribute to appropriate Field class", "label": {"api": {"class": [[53, 57]]}}}, {"text": "First step would be using SimpleDateFormat to parse it to a fullworthy java.util.Date instance in the controller", "label": {"api": {"SimpleDateFormat": [[26, 41]], "java.util.Date": [[71, 84]]}}}, {"text": "Then you can just create a java.sql.Date around its time in the database layer", "label": {"api": {"java.sql.Date": [[27, 39]]}}}, {"text": "Unrelated to the concrete problem, please note that java.sql.Date doesn't remember the time part", "label": {"api": {"java.sql.Date": [[52, 64]]}}}, {"text": "The javadocs mention this", "label": {"api": {"mention this": [[13, 24]]}}}, {"text": "Take a look at libraries such as HTML Parser and Jericho HTML Parser or use the native HTMLEditorKit.Parser + HTMLEditorKit.ParserCallback approach suggested on this answer", "label": {"api": {"HTMLEditorKit.Parser": [[87, 106], [110, 129]], "HTMLEditorKit.ParserCallback": [[110, 137]]}}}, {"text": "To implement animation, add Runnable interface to the implements section", "label": {"api": {"Runnable": [[28, 35]]}}}, {"text": "You may want to take a look at reference or tutorial", "label": {"api": {"reference": [[31, 39]]}}}, {"text": "Use StringBuilder class", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "You do a shutdownOutput() in the client side", "label": {"api": {"shutdownOutput()": [[9, 24]]}}}, {"text": "BasicFileAttributes is defined as an interface because it specifies behavior (in this case, accessor methods for file attribute information) and there are subclasses which provide this in an implementation-defined manner", "label": {"api": {"BasicFileAttributes": [[0, 18]]}}}, {"text": "In other words, when I have a BasicFileAttributes object, I don't know if it's really a DosFileAttributes or a PosixFileAttributes under the hood, and I don't care", "label": {"api": {"BasicFileAttributes": [[30, 48]]}}}, {"text": "All I care about is that I can call any of the BasicFileAttributes methods on it and get the results I'm expecting", "label": {"api": {"BasicFileAttributes": [[47, 65]]}}}, {"text": "In this case, you can either get the basic file attributes using BasicFileAttributes.class, or you can pass in one of its subclasses and get the platform-specific information (at the risk of having to deal with an UnsupportedOperationException if you're asking for attributes that don't exist on your platform)", "label": {"api": {"BasicFileAttributes": [[65, 83]]}}}, {"text": "Why not use an ArrayList", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "See the File.list() method", "label": {"api": {"File.list()": [[8, 18]]}}}, {"text": "You can use a FileFilter", "label": {"api": {"FileFilter": [[14, 23]]}}}, {"text": "This sounds like a use for @XmlAnyAttribute", "label": {"api": {"@XmlAnyAttribute": [[27, 42]]}}}, {"text": "The argument to split is a regex, and so the full stop/dot/", "label": {"api": {"split": [[16, 20]]}}}, {"text": "To use it literally in your split, you'll need to escape it", "label": {"api": {"split": [[28, 32]]}}}, {"text": "For more about regex and which characters are special, see the docs for Pattern", "label": {"api": {"docs for Pattern": [[63, 78]]}}}, {"text": "Java has something called HashMap which may be useful for you", "label": {"api": {"HashMap": [[26, 32]]}}}, {"text": "Here is documentation for HashMap", "label": {"api": {"HashMap": [[26, 32]]}}}, {"text": "Have a look at the document for Scanner", "label": {"api": {"Scanner": [[32, 38]]}}}, {"text": "You can also utililize the method Collections.frequency if you need the frequency of only some of the elements individually", "label": {"api": {"Collections.frequency": [[34, 54]]}}}, {"text": "I'm using a  ThreadPoolExecutor to run tasks", "label": {"api": {"ThreadPoolExecutor": [[13, 30]]}}}, {"text": "The backend is a SynchronousQueue, so if the executor is already perfoming a task, it throws the RejectedExecutionException", "label": {"api": {"SynchronousQueue": [[17, 32]], "RejectedExecutionException": [[97, 122]]}}}, {"text": "Another way (for dates) is to define a SimpleDateFormat for your desired pattern", "label": {"api": {"SimpleDateFormat": [[39, 54]]}}}, {"text": "Checks to see that e is null, if it is, then it will check that the iterator's next element is null (this effectively stops the iteration operation so as to avoid a NullPointerException), otherwise", "label": {"api": {"NullPointerException": [[165, 184]]}}}, {"text": "But if you need to frequently remove the lowest item from the list, and you have a lot of items and performance is important, your best bet is a PriorityQueue", "label": {"api": {"PriorityQueue": [[145, 157]]}}}, {"text": "Use a SocketChannel to read into a direct NIO buffer, which we can dereference from JNI", "label": {"api": {"SocketChannel": [[6, 18]]}}}, {"text": "Have a look at Oracle's Introduction to Collections (and especially the ArrayList class if you need an array-like index to access elements)", "label": {"api": {"ArrayList": [[72, 80]]}}}, {"text": "Consider Arrays.copyOf if working with arrays is a constraint", "label": {"api": {"Arrays.copyOf": [[9, 21]]}}}, {"text": "Note that if you are doing this type array management often and in unpredictable ways, you may want to consider one of the Java Collection Framework classes such as ArrayList", "label": {"api": {"ArrayList": [[165, 173]]}}}, {"text": "One of the design goals of ArrayList is to administer size management, much like the JVM itself administers memory management", "label": {"api": {"ArrayList": [[27, 35]]}}}, {"text": "Take a look at List.add(), which inserts an object at a given index", "label": {"api": {"List.add()": [[15, 24]]}}}, {"text": "If you want to replace the existing item, check out List.set()", "label": {"api": {"List.set()": [[52, 61]]}}}, {"text": "I think you should take a look at LinkedList add(int, E) method which provide better performance for insertion in the middle of the list compared to ArrayList", "label": {"api": {"LinkedList add(int, E)": [[34, 55]]}}}, {"text": "1) Make a BitSet object for each row, column, and 3x3 square", "label": {"api": {"BitSet": [[10, 15]]}}}, {"text": "Maybe what you are trying to do is more complex but for listing the directory you can just use a File", "label": {"api": {"File": [[97, 100]]}}}, {"text": "This adds the JPanel to the JFrame, packs it and sets it to be visible", "label": {"api": {"packs": [[36, 40]]}}}, {"text": "Take a look at the Thread#sleep doc", "label": {"api": {"Thread#sleep": [[19, 30]]}}}, {"text": "You can do the following with Paths, Files, and StandardCharsets", "label": {"api": {"Paths": [[30, 34]], "Files": [[37, 41]], "StandardCharsets": [[48, 63]]}}}, {"text": "Copy from the API doc for System.arraycopy", "label": {"api": {"API doc for System.arraycopy": [[14, 41]]}}}, {"text": "A solution using Pattern and Matcher", "label": {"api": {"Pattern": [[17, 23]], "Matcher": [[29, 35]]}}}, {"text": "You can use named-capturing groups, too", "label": {"api": {"named-capturing groups": [[12, 33]]}}}, {"text": "If your Edge constructor takes two String arguments and one int argument then simply read two String and one int using Scanner, store them in variables and then pass them to the Edge constructor", "label": {"api": {"Scanner": [[119, 125]]}}}, {"text": "Look at the documentation of Scanner to figure out how to get inputs in a simple way", "label": {"api": {"documentation of Scanner": [[12, 35]]}}}, {"text": "Whenever you want the name of that enum instance, you should use the name() method", "label": {"api": {"name()": [[69, 74]]}}}, {"text": "See the element javadoc for more information", "label": {"api": {"element javadoc": [[8, 22]]}}}, {"text": "Yes, manually add the @XmlAttribute-Annotation or generate the classes from an XSD", "label": {"api": {"@XmlAttribute": [[22, 34]]}}}, {"text": "Have a look at the Lock interface", "label": {"api": {"Lock interface": [[19, 32]]}}}, {"text": "But you could potentially use a Java 7 WatchService to track directory additions and file changes, and use that to deal with changes that happen during and after the directory listing and sorting", "label": {"api": {"WatchService": [[39, 50]]}}}, {"text": "There no equivalent to the Java 7 WatchService in Java 6", "label": {"api": {"WatchService": [[34, 45]]}}}, {"text": "The API documentation for AudioSystem.getAudioInputStream(InputStream) explains why the provided InputStream must support the mark and reset features (these features are optional for specific InputStream implementations)", "label": {"api": {"AudioSystem.getAudioInputStream(InputStream)": [[26, 69]]}}}, {"text": "Wrap them in Swing Actions; this allows you to use them in all kinds of buttons and menus", "label": {"api": {"Swing Actions": [[13, 25]]}}}, {"text": "Use hasNextLine (documentation here) to make sure you can get the next line", "label": {"api": {"documentation here": [[17, 34]]}}}, {"text": "Use hasNextLine() to protect against this", "label": {"api": {"hasNextLine()": [[4, 16]]}}}, {"text": "I'm trying to write a method that will take a single character string and (if possible) return the virtual key code it corresponds to", "label": {"api": {"virtual key code": [[99, 114]]}}}, {"text": "What you can try to do is to create JSF SelectItem for each option like shown in here", "label": {"api": {"SelectItem": [[40, 49]]}}}, {"text": "It has a pow() method that does exactly what you want in a rather efficient way", "label": {"api": {"pow()": [[9, 13]]}}}]