[{"text": "You can get a set of entries (Set of Map.Entry) from a map, by using map.entrySet()", "label": {"api": {"Set": [[30, 32], [78, 80]], "Map.Entry": [[37, 45]], "map.entrySet()": [[69, 82]]}}}, {"text": "Just iterate over them, and check the values by getValue()", "label": {"api": {"getValue()": [[48, 57]]}}}, {"text": "Instead use  a thread pool (ExecutorService)", "label": {"api": {"ExecutorService": [[28, 42]]}}}, {"text": "The BigInteger API docs do not appear to provide any functionality as such", "label": {"api": {"BigInteger API docs": [[4, 22]]}}}, {"text": "In order to do so, you can use serialization, or if you can use  Properties in some cases", "label": {"api": {"Properties": [[65, 74]]}}}, {"text": "compareTo is provided by the Comparable interface", "label": {"api": {"Comparable": [[29, 38]]}}}, {"text": "There is no language enforced requirement that Comparable.compareTo return 0 when Object.equals returns true", "label": {"api": {"Comparable": [[47, 56]]}}}, {"text": "Encryption would typically be done using the Cipher class, and digest would be done using the MessageDigest class", "label": {"api": {"Cipher": [[45, 50]], "MessageDigest": [[94, 106]]}}}, {"text": "AtomicBoolean is a part of the standard java concurrent package", "label": {"api": {"AtomicBoolean": [[0, 12]]}}}, {"text": "Performance-wise, you should expect AtomicBoolean to perform better -- it uses a volatile boolean whereas SynchronizedBoolean uses a ReadWriteLock", "label": {"api": {"AtomicBoolean": [[36, 48]]}}}, {"text": "AtomicBoolean provides just simple set/get/compareAndSet operations", "label": {"api": {"AtomicBoolean": [[0, 12]]}}}, {"text": "You can call the setIgnoreRepaint(true) method to ignore the requests by OS", "label": {"api": {"setIgnoreRepaint(true)": [[17, 38]]}}}, {"text": "Have a set of images without text, and use AWT's Graphics2D to add the text in the necessary language (as opposed to doing so with a JLabel)", "label": {"api": {"Graphics2D": [[49, 58]]}}}, {"text": "To do this you can use Java's Normalizer class", "label": {"api": {"Normalizer": [[30, 39]]}}}, {"text": "You can use an XmlAdapter like this", "label": {"api": {"XmlAdapter": [[15, 24]]}}}, {"text": "TimeUnit#sleep is \"a convenience method that converts time arguments into the form required by the Thread.sleep method.\" So it does not do anything different than your old code", "label": {"api": {"TimeUnit#sleep": [[0, 13]]}}}, {"text": "The java StringBuilder class is a good example (the create method being tostring in this case)", "label": {"api": {"StringBuilder": [[9, 21]]}}}, {"text": "This maps to Vector.size() in DefaultTableModel", "label": {"api": {"Vector.size()": [[13, 25]]}}}, {"text": "And this maps to Vector.get(int index)", "label": {"api": {"Vector.get(int index)": [[17, 37]]}}}, {"text": "Taking a closer look at Vector.get(int index) reveals", "label": {"api": {"Vector.get(int index)": [[24, 44]]}}}, {"text": "What you need here is Session listener", "label": {"api": {"Session listener": [[22, 37]]}}}, {"text": "The built-in classes implement this method, so you can use/extend the Polygon, Ellipse2D.Double or RoundRectangle2D.Double class and have a filled polygon / ellipse / round rectangle that knows its inside", "label": {"api": {"Polygon": [[70, 76]], "Ellipse2D.Double": [[79, 94]], "RoundRectangle2D.Double": [[99, 121]]}}}, {"text": "Also, you can do the read, and try/catch an ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[44, 73]]}}}, {"text": "If you're trying to get the field values for the \"current\" instance (the instance your testMethod() method was called on), you just want to call Field.get with this as the target", "label": {"api": {"Field.get": [[145, 153]]}}}, {"text": "You can use Character.isUpperCase() to determine if the first char is upper case", "label": {"api": {"Character.isUpperCase()": [[12, 34]]}}}, {"text": "You can use Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[12, 32]]}}}, {"text": "You can use Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[12, 32]]}}}, {"text": "This is the main reason why Swing's JPasswordField's getText() method is deprecated, and why getPassword() uses character arrays", "label": {"api": {"Swing's JPasswordField's getText()": [[28, 61]], "getPassword() uses character arrays": [[93, 127]]}}}, {"text": "The Scanner.next() method returns a String, not a char, so you need to get the first character of that String using String.charAt(...) before comparing it to chars", "label": {"api": {"Scanner.next() method": [[4, 24]], "String.charAt(...)": [[116, 133]]}}}, {"text": "If you are using Java7, then you could leverage the try-with-resources construct for all those closeable objects like Socket, Connection, Statement etc., that would automatically close them once they go out of scope", "label": {"api": {"closeable": [[95, 103]]}}}, {"text": "If you're using HttpsUrlConnection, see Cookie Management and java.net.CookieManager", "label": {"api": {"java.net.CookieManager": [[62, 83]]}}}, {"text": "String implements CharSequence and thus length needs to be a method in this case since interfaces can only specify methods", "label": {"api": {"CharSequence": [[18, 29]]}}}, {"text": "As Hot Licks pointed out below, CharSequence didn't exist before Java 1.4", "label": {"api": {"CharSequence": [[32, 43]]}}}, {"text": "Although CharSequence obviously wasn't the driving reason behind this design choice (since it didn't exist), it would still make sense to choose this design with the idea that String might need to implement new interfaces in the future", "label": {"api": {"CharSequence": [[9, 20]]}}}, {"text": "You are printing the array incorrectly, use Arrays.toString() utility method", "label": {"api": {"Arrays.toString()": [[44, 60]]}}}, {"text": "In the case of HashMap, it replaces the old value with the new one", "label": {"api": {"HashMap": [[15, 21]]}}}, {"text": "In the case of HashSet, the item isn't inserted", "label": {"api": {"HashSet": [[15, 21]]}}}, {"text": "But HashMap.put will replace", "label": {"api": {"HashMap.put": [[4, 14]]}}}, {"text": "You can change the font properties in the UIManager for every component you need by calling UIManager.put(\"nameOfFontProperty\", new Font(Font.DIALOG, FONT.PLAIN, sizeInPixel));", "label": {"api": {"UIManager": [[42, 50], [92, 100]]}}}, {"text": "What I am getting at is that your code needs refactoring, and whether to use switch or enumerations or maps is something that comes second", "label": {"api": {"enumerations": [[87, 98]], "maps": [[103, 106]], "map": [[103, 105]]}}}, {"text": "You are free to use a map if you want", "label": {"api": {"map": [[22, 24]]}}}, {"text": "Or you can use enumerations", "label": {"api": {"enumerations": [[15, 26]]}}}, {"text": "You can even switch or use a map inside enumerations, which will give you good code readability as well", "label": {"api": {"enumerations": [[40, 51]], "map": [[29, 31]]}}}, {"text": "You need to profile your program to see if you need switch-based solution or enum-based one or a map-based one", "label": {"api": {"map": [[97, 99]]}}}, {"text": "But be careful with maps - they induce more overhead than other solutions, so I for one prefer to use them where I have fewer maps with many keys each, not the other way around", "label": {"api": {"maps": [[20, 23], [126, 129]], "map": [[20, 22], [126, 128]]}}}, {"text": "You can style by defining different style classes in a css stylesheet and manipulating a Node's styleclasses", "label": {"api": {"styleclasses": [[96, 107]]}}}, {"text": "This is the recommended way to use css rather than using the setStyle method", "label": {"api": {"setStyle": [[61, 68]]}}}, {"text": "There are some aspects of style which can be done in fxml or java code because they are exposed in the JavaFX API, for instance, you can set a font on a label using the setFont api or the fxml font attribute, rather than applying a font to the label using a css style -fx-font", "label": {"api": {"setFont": [[169, 175]], "-fx-font": [[268, 275]]}}}, {"text": "Also, proposed for future JavaFX versions is an object model of the CSS information so that CSS attributes on a node can be viewed and manipulated through a formal Java API in addition to the current string based setStyle and getStyleClass methods", "label": {"api": {"setStyle": [[213, 220]]}}}, {"text": "You can use the java.utils.Arrays utility class to make things cleaner/neater", "label": {"api": {"java.utils.Arrays": [[16, 32]]}}}, {"text": "Then you can use Collection.sort or Arrays.sort to re-order the family for printing", "label": {"api": {"Collection.sort": [[17, 31]], "Arrays.sort": [[36, 46]]}}}, {"text": "Contrast that with InetAddress.toString()", "label": {"api": {"InetAddress.toString()": [[19, 40]]}}}, {"text": "If the selection event only ever occurs in tandem with the focusLost() event, then you should call awaitTermination() on the ThreadPoolExecutor and then call an invokeLater() method in the selection event", "label": {"api": {"awaitTermination()": [[99, 116]]}}}, {"text": "Add the GUI to a JScrollPane before adding the scroll pane to the content-pane", "label": {"api": {"JScrollPane": [[17, 27]]}}}, {"text": "You can do this easily using String#replaceAll()", "label": {"api": {"String#replaceAll()": [[29, 47]]}}}, {"text": "The (?i) is added to make it case insensitive, and the Pattern#quote() is used to escape special regex characters in your substring", "label": {"api": {"Pattern#quote()": [[55, 69]]}}}, {"text": "Also read the documentation for Java Calendar", "label": {"api": {"Also read the documentation for Java Calendar": [[0, 44]]}}}, {"text": "Date is Comparable, so you can compare two Dates using compareTo()", "label": {"api": {"Date": [[0, 3], [43, 46]], "compareTo()": [[55, 65]]}}}, {"text": "the value 0 if the argument Date is equal to this Date; a value less than 0 if this Date is before the Date argument; and a value greater than 0 if this Date is after the Date argument", "label": {"api": {"Date": [[28, 31], [50, 53], [84, 87], [103, 106], [153, 156], [171, 174]]}}}, {"text": "You can also sort the whole Collection with Collections.sort() (O(n logn))", "label": {"api": {"Collections.sort()": [[44, 61]]}}}, {"text": "Or get the maximum with Collections.max() and the minimum with Collections.min() (both in linear time O(n))", "label": {"api": {"Collections.max()": [[24, 40]], "Collections.min()": [[63, 79]]}}}, {"text": "Why not use Collections.sort() and then take the first/last entries", "label": {"api": {"Collections.sort()": [[12, 29]]}}}, {"text": "You can either use natural ordering, or specify your own Comparator", "label": {"api": {"Comparator": [[57, 66]]}}}, {"text": "Use Java Compiler API to translate source code into bytecode", "label": {"api": {"Java Compiler API": [[4, 20]]}}}, {"text": "After that use dynamic class loading to load compiled bytecode into jvm and launch it (to get output)", "label": {"api": {"dynamic class loading": [[15, 35]]}}}, {"text": "If FastVector is deprecated you could just use Vector", "label": {"api": {"Vector": [[7, 12], [47, 52]]}}}, {"text": "This socket is \"converted\" into a SSLSocket using SSlSocketFactory.createSocket", "label": {"api": {"SSlSocketFactory.createSocket": [[50, 78]]}}}, {"text": "This is not fully documented in Android API, see original Java API for the complete javadoc", "label": {"api": {"Java API": [[58, 65]]}}}, {"text": "You can simply create com.itextpdf.text.Image from java.awt.image.BufferedImage and then render it using standard iText methods", "label": {"api": {"java.awt.image.BufferedImage": [[51, 78]]}}}, {"text": "Another solution would be to use an object like AtomicInteger", "label": {"api": {"AtomicInteger": [[48, 60]]}}}, {"text": "Just get the Iterator via iterator()", "label": {"api": {"iterator()": [[26, 35]]}}}, {"text": "You can base the implementation on the PropertyChangeSupport", "label": {"api": {"PropertyChangeSupport": [[39, 59]]}}}, {"text": "But I would have a look in java File class as a start point to try to see those directories from your app", "label": {"api": {"File class": [[32, 41]]}}}, {"text": "is the character that matches all other characters, with the possible exception of newlines (depending on whether DOTALL is enabled)", "label": {"api": {"DOTALL": [[114, 119]]}}}, {"text": "Apparently you missed File.getParentFile()", "label": {"api": {"File.getParentFile()": [[22, 41]]}}}, {"text": "From the javadocs", "label": {"api": {"the javadocs": [[5, 16]]}}}, {"text": "The Void javadoc..", "label": {"api": {"Void javadoc": [[4, 15]]}}}, {"text": "Void is a special class that is used to represent no return value", "label": {"api": {"Void": [[0, 3]]}}}, {"text": "While there is nothing special about Void per se, it can't be (and never is) instantiated, so the only possible value for it is always null", "label": {"api": {"Void": [[37, 40]]}}}, {"text": "To represent the void return type in Java reflection using Void.TYPE", "label": {"api": {"Void": [[59, 62]]}}}, {"text": "As you can see, the type was changed to Void only in JDK 7, probably because it makes more sense conceptually", "label": {"api": {"Void": [[40, 43]]}}}, {"text": "But since the interface of the method could not be changed (for compatibility reasons and because the method implements Future<?> submit(Runnable task) of the ExecutorService interface), the return type Future<?> stayed the same", "label": {"api": {"ExecutorService": [[159, 173]]}}}, {"text": "Void is the object representation of void", "label": {"api": {"Void": [[0, 3]]}}}, {"text": "Where void returns nothing from a method, Void ALWAYS returns null", "label": {"api": {"Void": [[42, 45]]}}}, {"text": "It's nice to use Void with Futures when you don't need any return values", "label": {"api": {"Void": [[17, 20]]}}}, {"text": "For a server pooling implementation, we usually use ScheduledThreadPoolExecutor to schedule the RMI call in a given time interval, for example", "label": {"api": {"ScheduledThreadPoolExecutor": [[52, 78]]}}}, {"text": "You can either use at first a SortedSet as the subSet method exists on it", "label": {"api": {"subSet": [[47, 52]]}}}, {"text": "Instead of doing this kind of thing yourself, I suggest you take a look at the Timer class, that can be used to do recurring tasks", "label": {"api": {"Timer": [[79, 83]]}}}, {"text": "Even better would be ScheduledThreadPoolExecutor, but it might be a bit complicated if you've never used executors before", "label": {"api": {"ScheduledThreadPoolExecutor": [[21, 47]]}}}, {"text": "Java Timer vs ExecutorService?", "label": {"api": {"Timer": [[5, 9]]}}}, {"text": "I would suggest using a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[24, 47]]}}}, {"text": "I highly recommend using Scanner instead", "label": {"api": {"Scanner": [[25, 31]]}}}, {"text": "A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "A Scanner will use whitespace as its default delimiter, so you should be able to simply call sc.nextInt() for each expected integer token", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "Depending on what you need you sometimes want a use a CallableStatment", "label": {"api": {"CallableStatment": [[54, 69]]}}}, {"text": "This use a TreeMap to provide the data storage, which provides provides guaranteed log(n) time cost for the containsKey, get, put and remove operations", "label": {"api": {"TreeMap": [[11, 17]]}}}, {"text": "But a JList IMO would be much nicer", "label": {"api": {"JList": [[6, 10]]}}}, {"text": "That appends a chatter name nicely to a JList", "label": {"api": {"JList": [[40, 44]]}}}, {"text": "This wouldn't have helped you in this case, but HttpURLConnection is a specialized subclass of URLConnection that makes communications with an http server a lot easier - eg direct access to error codes, etc", "label": {"api": {"HttpURLConnection": [[48, 64]]}}}, {"text": "lastIndexOf(String) will give you the last occurrence of a String, if you can read the entire file into memory at once", "label": {"api": {"lastIndexOf(String)": [[0, 18]]}}}, {"text": "You can use Calendar for simple date manipulation", "label": {"api": {"Calendar": [[12, 19]]}}}, {"text": "You need to use BigInteger", "label": {"api": {"BigInteger": [[16, 25]]}}}, {"text": "Here is javadoc for BigInteger", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "Use BigInteger class like this", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "For your second problem, JTextArea inherits from JTextComponent, where you will find the setText method", "label": {"api": {"the setText method": [[85, 102]]}}}, {"text": "If you want to get the text, you'll need to use the getText method and split the resulting string on whatever delimiters you specify", "label": {"api": {"the getText method": [[48, 65]], "split the resulting string": [[71, 96]]}}}, {"text": "A compact implementation using Java TreeMap and recursion", "label": {"api": {"TreeMap": [[36, 42]]}}}, {"text": "Use String class and its split method", "label": {"api": {"String": [[4, 9]]}}}, {"text": "Well, you can always use String.split", "label": {"api": {"String.split": [[25, 36]]}}}, {"text": "To me it sounds as you want to use a BlockingQueue", "label": {"api": {"BlockingQueue": [[37, 49]]}}}, {"text": "There are functions like System.arrayCopy that may help you here", "label": {"api": {"System.arrayCopy": [[25, 40]]}}}, {"text": "As shown here, the drawString() method requires baseline relative coordinates", "label": {"api": {"baseline relative": [[48, 64]]}}}, {"text": "You can use the Java ZipFile class to read contents of a zip file, iterate over the entries in the zip and obtaining input streams for relevant entries", "label": {"api": {"Java ZipFile": [[16, 27]]}}}, {"text": "Using the ZipOutputStream it is possible to directly put the files into a new zip file - although they are decompressed/compressed in between", "label": {"api": {"ZipOutputStream": [[10, 24]]}}}, {"text": "I've searched around and it looks like the best solution is using RescaleOp, but I just can't figure it out", "label": {"api": {"RescaleOp": [[66, 74]]}}}, {"text": "As noted in the API, the scale and offset are applied to each band as the slope and y-intercept, respectively, of a linear function", "label": {"api": {"API": [[16, 18]]}}}, {"text": "This exploits the fact that Math.random() returns uniformly distributed value in [0, 1)", "label": {"api": {"Math.random()": [[28, 40]]}}}, {"text": "You can use only indexOf and substring methods of String", "label": {"api": {"indexOf": [[17, 23]], "substring": [[29, 37]], "String": [[50, 55]]}}}, {"text": "However, String.split is the shortest solution", "label": {"api": {"String": [[9, 14]]}}}, {"text": "An instance of java.awt.image.LookupOp with a suitable LookupTable may be faster", "label": {"api": {"java.awt.image.LookupOp": [[15, 37]]}}}, {"text": "To append to the file, open it using the constructor FileWriter(File,boolean)", "label": {"api": {"FileWriter(File,boolean)": [[53, 76]]}}}, {"text": "See javadoc for Scanner, it has an example", "label": {"api": {"javadoc for Scanner": [[4, 22]]}}}, {"text": "Also, I would consider using a ProcessBuilder whenever writing code that spawns processes", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "KeyListener is not the appropriate event listener to use, it is triggered BEFORE the combobox has updated its state, better to use an ActionListener", "label": {"api": {"ActionListener": [[134, 147]]}}}, {"text": "The following code works with sorted JTables that are in single selection mode", "label": {"api": {"JTable": [[37, 42]]}}}, {"text": "This shows you WHY the program \"waitsFor()\" the external process to finish executing", "label": {"api": {"This shows you WHY": [[0, 17]]}}}, {"text": "You can use File#isDirectory method to test whether a file is a directory", "label": {"api": {"File#isDirectory": [[12, 27]]}}}, {"text": "Or, you can use File#listFiles method instead", "label": {"api": {"File#listFiles": [[16, 29]]}}}, {"text": "After all, it won't take more than a minute to process the file, will it", "label": {"api": {"take": [[20, 23]]}}}, {"text": "But if you insist on doing the checking and processing in different threads, I suggest you use one of the BlockingQueue implementations from the JDK", "label": {"api": {"BlockingQueue": [[106, 118]]}}}, {"text": "The scheduled taks would put the file or whatever object in the queue and a second thread like t1 in your code can then take and process the object", "label": {"api": {"put": [[25, 27]], "take": [[120, 123]]}}}, {"text": "In Calendar class, MONTH start from index 0", "label": {"api": {"Calendar": [[3, 10]], "MONTH": [[19, 23]]}}}, {"text": "- That's true that this is an Inconsistency in Calendar class, so I would suggest you to take a look at Joda-Time API to make your life easier while working with date-time data", "label": {"api": {"Calendar": [[47, 54]]}}}, {"text": "Your likely problem is that Calendar uses a zero-based index for months", "label": {"api": {"Calendar uses a zero-based index for months": [[28, 70]]}}}, {"text": "I need to call method hashcode() of the password", "label": {"api": {"hashcode()": [[22, 31]]}}}, {"text": "use scanner.next() default deliminator is space", "label": {"api": {"scanner.next()": [[4, 17]]}}}, {"text": "Use Scanner.nextLine to read the whole line", "label": {"api": {"Scanner.nextLine": [[4, 19]]}}}, {"text": "If you want to print the date represented by a calendar instance, as a string, you should use SimpleDateFormatter to format the date in the required format, as follows", "label": {"api": {"SimpleDateFormatter": [[94, 112]]}}}, {"text": "Based on another answer, using BigDecimal, this also works", "label": {"api": {"BigDecimal": [[31, 40]]}}}, {"text": "Or even your good old DecimalFormat will work with BigDecimal", "label": {"api": {"BigDecimal": [[51, 60]], "DecimalFormat": [[22, 34]]}}}, {"text": "You need to call ArrayList#get() method  which will return the element at the specified position in this list", "label": {"api": {"ArrayList#get()": [[17, 31]]}}}, {"text": "Try flushing the outFile before closing it", "label": {"api": {"flushing": [[4, 11]]}}}, {"text": "You can also use the alternative PrintWriter constructor that takes care of that for you", "label": {"api": {"alternative PrintWriter constructor": [[21, 55]]}}}, {"text": "In general these w3c classes use casts of item(i) to for instance Element", "label": {"api": {"Element": [[66, 72]]}}}, {"text": "See java.util.Comparator API for details", "label": {"api": {"java.util.Comparator API": [[4, 27]]}}}, {"text": "You should also take a look at the Condition interface", "label": {"api": {"Condition": [[35, 43]]}}}, {"text": "BTW, it is highly recommended to use PreparedStatement for such operations instead of forming the query like this to avoid SQL Injection attacks", "label": {"api": {"PreparedStatement": [[37, 53]]}}}, {"text": "If you know the length of each line then you can use RandomAccessFile and then skipBytes to the line you want", "label": {"api": {"RandomAccessFile": [[53, 68]], "skipBytes": [[79, 87]]}}}, {"text": "Why don't you simply use a database sequence, or a UUID", "label": {"api": {"UUID": [[51, 54]]}}}, {"text": "You can use an InputStreamReader to read single characters from the input stream (which is a byte stream)", "label": {"api": {"InputStreamReader": [[15, 31]]}}}, {"text": "If you don't want to use join(), consider CountDownLatch, which allows you to wait for a set of threads", "label": {"api": {"CountDownLatch": [[42, 55]]}}}, {"text": "Another, much more pleasant approach is ExecutorService wrapped with lightweight ExecutorCompletionService", "label": {"api": {"ExecutorService": [[40, 54]], "ExecutorCompletionService": [[81, 105]]}}}, {"text": "For example the URL constructor URL(URL, String) will create a new URL object in the context of an existing one, without you needing to worry whether the String is an absolute URL or a relative one", "label": {"api": {"URL(URL, String)": [[32, 47]]}}}, {"text": "Just to keep it simple you can go by Console.readLine()", "label": {"api": {"Console.readLine()": [[37, 54]]}}}, {"text": "You are interested in the Field class", "label": {"api": {"Field": [[26, 30]]}}}, {"text": "Interestingly, just recently I encountered a similar issue, so In order to get over this I used SwingUtilities.invokeAndWait(Runnable runnable), that's what made the SSCCE I was creating to work as expected, though if I change all calls to invokeAndWait() with invokeLater(), one can clearly see the difference between the two things", "label": {"api": {"SwingUtilities.invokeAndWait(Runnable runnable)": [[96, 142]], "invokeAndWait()": [[240, 254]], "invokeLater()": [[261, 273]]}}}, {"text": "be aware that you will only get digits from 0-8 (not a 9) when using your code", "label": {"api": {"you will only get digits from 0-8 (not a 9)": [[14, 56]]}}}, {"text": "Read javadoc for InputStream.read() carefully", "label": {"api": {"InputStream.read()": [[17, 34]]}}}, {"text": "This is exactly what java.util.concurrent.Semaphore is for", "label": {"api": {"java.util.concurrent.Semaphore": [[21, 50]]}}}, {"text": "That assumes that the generator sequence is good, but I think that's a reasonable assumption to make here, especially given the documentation for SecureRandom", "label": {"api": {"SecureRandom": [[146, 157]]}}}, {"text": "You can use for example the method split from the standard Java class String", "label": {"api": {"split": [[35, 39]], "String": [[70, 75]]}}}, {"text": "From java.util.Date is using TimeZone", "label": {"api": {"java.util.Date": [[5, 18]]}}}, {"text": "java.util.Date is timezone-independent", "label": {"api": {"java.util.Date": [[0, 13]]}}}, {"text": "Have a look at the new classes (well, not so new) in the java.util.concurrent package, especially ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[98, 124]]}}}, {"text": "Because HashMap uses equals to compare keys", "label": {"api": {"equal": [[21, 25]]}}}, {"text": "Although your 2 strings are different instances, they are equal", "label": {"api": {"equal": [[58, 62]]}}}, {"text": "Your custom objects can't be equal because they are not even of the same type", "label": {"api": {"equal": [[29, 33]]}}}, {"text": "Even if they were of the same type, unless you override the equals method inherited from Object, 2 different instances (created with new) won't be equal", "label": {"api": {"equal": [[60, 64], [147, 151]], "equals method inherited from Object": [[60, 94]]}}}, {"text": "Note that if you override equals, you also need to override hashCode to avoid unexpected behaviour", "label": {"api": {"equal": [[26, 30]]}}}, {"text": "Assuming you mean from a PrintStream, you can use printf for that", "label": {"api": {"printf": [[50, 55]]}}}, {"text": "There are static methods Float.isNaN(float) and Double.isNaN(double) that you can use", "label": {"api": {"Float.isNaN(float)": [[25, 42]], "Double.isNaN(double)": [[48, 67]]}}}, {"text": "From the Java 7 API documentation", "label": {"api": {"Java 7 API documentation": [[9, 32]]}}}, {"text": "I think you want to use Java's Map", "label": {"api": {"Java's Map": [[24, 33]]}}}, {"text": "I want to split a String at the word boundaries using Scanner", "label": {"api": {"Scanner": [[54, 60]]}}}, {"text": "If you want this for all your API methods, why not use a http://docs.oracle.com/javaee/6/api/javax/servlet/Filter.html", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/Filter.html": [[57, 117]]}}}, {"text": "According to the Javadoc for Collections.sort, it is noted that sort() uses Modified Mergesort as the sorting algorithm", "label": {"api": {"Javadoc for Collections.sort": [[17, 44]]}}}, {"text": "So calling the setText will display the corresponding text for you", "label": {"api": {"setText": [[15, 21]]}}}, {"text": "I think you want to use the newInstance() method", "label": {"api": {"newInstance() method": [[28, 47]]}}}, {"text": "Have you looked at XmlSeeAlso", "label": {"api": {"XmlSeeAlso": [[19, 28]]}}}, {"text": "A good possibility would be to use SCROLL_TAB_LAYOUT as tabLayoutPolicy", "label": {"api": {"SCROLL_TAB_LAYOUT": [[35, 51]]}}}, {"text": "DataInputStream.getLine() is deprecated -- you should just use BufferedReader.getLine()", "label": {"api": {"DataInputStream.getLine()": [[0, 24]], "BufferedReader.getLine()": [[63, 86]]}}}, {"text": "From the Date docs", "label": {"api": {"Date docs": [[9, 17]]}}}, {"text": "see ReadWrite Lock documentation", "label": {"api": {"ReadWrite Lock documentation": [[4, 31]]}}}, {"text": "Use a List<Integer> (such as an ArrayList<Integer>) if you want a collection with resizability", "label": {"api": {"List<Integer>": [[6, 18], [37, 49]], "ArrayList<Integer>": [[32, 49]]}}}, {"text": "BufferedReaeder readLine() method return String", "label": {"api": {"readLine()": [[16, 25]]}}}, {"text": "I would highly recommend you check Java Preferences or simply the java Properties class which is simpler", "label": {"api": {"Java Preferences": [[35, 50]], "Properties": [[71, 80]]}}}, {"text": "Use an ArrayList", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "If you simply want to replace , characters with newlines, you can use String.replace() like this", "label": {"api": {"String.replace()": [[70, 85]]}}}, {"text": "With ScheduledExecutorService you automatically get the timer feature", "label": {"api": {"ScheduledExecutorService": [[5, 28]]}}}, {"text": "Split the data (String.split) then iterate over it two at a time, putting the results into a HashMap", "label": {"api": {"String.split": [[16, 27]], "HashMap": [[93, 99]]}}}, {"text": "See particularly Example - Subclassing the Standard Doclet & the Doclet API", "label": {"api": {"Doclet API": [[65, 74]]}}}, {"text": "java.io.File.lastModified() should suit your needs", "label": {"api": {"java.io.File.lastModified()": [[0, 26]]}}}, {"text": "I would try using the Console.read(CharBuffer), and interrupt the thread", "label": {"api": {"Console.read(CharBuffer)": [[22, 45]]}}}, {"text": "But a Selector would maybe suit your purpose even better", "label": {"api": {"Selector": [[6, 13]]}}}, {"text": "Use System.setIn(InputStream in)", "label": {"api": {"System.setIn(InputStream in)": [[4, 31]]}}}, {"text": "You can supply any subtype of InputStream as well, so if you want to supply a specific value, you can use the StringBufferInputStream, like so", "label": {"api": {"StringBufferInputStream": [[110, 132]]}}}, {"text": "Unless I am missing something, HttpServletRequest#getQueryString should do that", "label": {"api": {"HttpServletRequest#getQueryString": [[31, 63]]}}}, {"text": "Use the JavaFX Animation Package", "label": {"api": {"JavaFX Animation Package": [[8, 31]]}}}, {"text": "Here is a fairly boring example which uses a Timeline to emulate the c++ code in your question to move a dot a pixel every 400 milliseconds", "label": {"api": {"Timeline": [[45, 52]]}}}, {"text": "The most basic one is AnimationTimer", "label": {"api": {"AnimationTimer": [[22, 35]]}}}, {"text": "Transition has an interpolate(frac) method, which gets called with values of frac between 0.0 and 1.0", "label": {"api": {"Transition": [[0, 9]]}}}, {"text": "Both Transition and Timeline extend Animation, so you can set stuff like cycle duration, whether the Transition is reversed at end, etc", "label": {"api": {"Transition": [[5, 14], [101, 110]], "Timeline": [[20, 27]]}}}, {"text": "Timeline is the most complex one", "label": {"api": {"Timeline": [[0, 7]]}}}, {"text": "You define arbitrary amount of KeyFrames (think of states) that contain wanted properties of different Nodes, and the Timeline will do all the work for you interpolating how to animate the change between the provided values", "label": {"api": {"Timeline": [[118, 125]]}}}, {"text": "For example, you can give a keyframe where x property of a Node is 0, and another where it's 100, and Timeline will do the animating for you", "label": {"api": {"Timeline": [[102, 109]]}}}, {"text": "Can I accomplish that using BlockingQueue", "label": {"api": {"BlockingQueue": [[28, 40]]}}}, {"text": "You should use it.remove() when you need to remove an element", "label": {"api": {"it.remove()": [[15, 25]]}}}, {"text": "See the following example from the PreparedStatement documentation on how you would normally replace the", "label": {"api": {"PreparedStatement documentation": [[35, 65]]}}}, {"text": "You should actually use PreparedStatement to set values in a query", "label": {"api": {"PreparedStatement": [[24, 40]]}}}, {"text": "This requires using a multiselect statement or using construct like this", "label": {"api": {"multiselect": [[22, 32]], "construct": [[53, 61]]}}}, {"text": "The Map.Entry-class, which you use to iterate over the entry-set of your Map has a getValue()-method, which returns the value to the current key", "label": {"api": {"getValue()-method": [[83, 99]]}}}, {"text": "Otherwise, if you're only interested in the values from the Map, you can also iterate over the values-collection", "label": {"api": {"values-collection": [[95, 111]]}}}, {"text": "Use a RotateTransition or Animation Timeline with KeyFrames instead", "label": {"api": {"RotateTransition": [[6, 21]]}}}, {"text": "you should use another structure than a string, for example a StringBuilder, which is especially designed to allow efficient appending for string building", "label": {"api": {"StringBuilder": [[62, 74]]}}}, {"text": "My understanding is that you get an ArrayStoreException when you try to insert an object of incompatible type", "label": {"api": {"ArrayStoreException": [[36, 54]]}}}, {"text": "Can someone explain, with an example, when will I get an ArrayStoreException and when will I get a ClassCastException", "label": {"api": {"ArrayStoreException": [[57, 75]], "ClassCastException": [[99, 116]]}}}, {"text": "Because, StringBuilder#reverse does in place reversing", "label": {"api": {"StringBuilder#reverse": [[9, 29]]}}}, {"text": "Instead, store the start and end as long values, as per Date.getTime() and compare these with System.currentTimeMillis(), to keep things clean and simple", "label": {"api": {"Date.getTime()": [[56, 69]], "System.currentTimeMillis()": [[94, 119]]}}}, {"text": "But what you should probably really do is not use a regular expression at all to just replace single characters", "label": {"api": {"just replace single characters": [[81, 110]]}}}, {"text": "Not sure if this will help, but what if you will use AtomicBoolean instead of synchronized and volatile", "label": {"api": {"AtomicBoolean": [[53, 65]]}}}, {"text": "You could do a String split(...)", "label": {"api": {"split(...)": [[22, 31]]}}}, {"text": "And then Integer parseInt(...) to get back the two integer components", "label": {"api": {"parseInt(...)": [[17, 29]]}}}, {"text": "If you want an exact solution - you should use a library that gives you exact values for decimals, such as BigDecimal", "label": {"api": {"BigDecimal": [[107, 116]]}}}, {"text": "When you call toString on a double, the format used can vary, try using DecimalFormat instead", "label": {"api": {"DecimalFormat": [[72, 84]]}}}, {"text": "Take a look at the Collections.sort(List<T> list)", "label": {"api": {"Collections.sort(List<T> list)": [[19, 48]]}}}, {"text": "Check Collections#sort method", "label": {"api": {"Collections#sort": [[6, 21]]}}}, {"text": "You can apply this method on each sublist you obtain using List#subList method", "label": {"api": {"List#subList": [[59, 70]]}}}, {"text": "The language used in the API spec for EntityTransaction would seem to indicate otherwise or perhaps something is a bit counter-intuitive in the model of demarcating a JPA entity transaction with begin() and commit()", "label": {"api": {"API spec for EntityTransaction": [[25, 54]]}}}, {"text": "If you omit the Matcher.quoteReplacement() method call, the code will fail on windows", "label": {"api": {"Matcher.quoteReplacement()": [[16, 41]]}}}, {"text": "If you are talking about a java.sql.Timestamp, it has a method called setTime", "label": {"api": {"setTime": [[70, 76]]}}}, {"text": "java.util.Date has a setTime method as well for that sort of thing", "label": {"api": {"setTime": [[21, 27]]}}}, {"text": "Just add the appropriate number of milliseconds using #getTime() and #setTime()", "label": {"api": {"#getTime()": [[54, 63]], "#setTime()": [[69, 78]]}}}, {"text": "See the javadocs for SecureRandom", "label": {"api": {"SecureRandom": [[21, 32]]}}}, {"text": "SecureRandom is more expensive than Random, but it is unlikely that this will make any difference in your use-case", "label": {"api": {"SecureRandom": [[0, 11]]}}}, {"text": "You need addHeader() instead of setHeader()", "label": {"api": {"addHeader()": [[9, 19]], "setHeader()": [[32, 42]]}}}, {"text": "The proper way, however, is to use setMaxAge() method of the Cookie class (which takes the expire time in seconds) and use addCookie() the usual way", "label": {"api": {"setMaxAge()": [[35, 45]]}}}, {"text": "This annotation does not exist in Java EE nor in JDBC at all", "label": {"api": {"Java EE": [[34, 40]], "JDBC": [[49, 52]]}}}, {"text": "Given the combination MySQL + JDBC + Java EE + Eclipse, you were likely following this tutorial and copypasting code without reading the text", "label": {"api": {"Java EE": [[37, 43]], "JDBC": [[30, 33]]}}}, {"text": "Also notice that we defined a new annotation called @JDBC", "label": {"api": {"JDBC": [[53, 56]]}}}, {"text": "See String#indexOf(String str, int fromIndex) that you need here", "label": {"api": {"String#indexOf(String str, int fromIndex)": [[4, 44]]}}}, {"text": "The Cookie class is unsuitable as the setHttpOnly() method was introduced in Servlet 3.0, but you're using Tomcat 5.5 does as being a Servlet 2.4 container not have this method in Cookie class", "label": {"api": {"setHttpOnly()": [[38, 50]]}}}, {"text": "If you'd like to transparently apply this on all cookies, then you might want to provide a custom HttpServletResponseWrapper wherein the addHeader() and setHeader() methods are accordingly been overridden to check if a Set-Cookie header is been set and if so, then add ;HttpOnly to the value when absent", "label": {"api": {"HttpServletResponseWrapper": [[98, 123]]}}}, {"text": "Then use Collections.sort() by passing comparator", "label": {"api": {"Collections.sort()": [[9, 26]]}}}, {"text": "You need to set it non-lenient before parsing", "label": {"api": {"non-lenient": [[19, 29]]}}}, {"text": "Also you could theoretically merge many regexes in a single regex, using capture groups and or operators (|), then scan the document with a single pass, and finally checking which one matched calling group()", "label": {"api": {"group()": [[200, 206]]}}}, {"text": "ConcurrentSkipListMap has a lastKey method that returns the greatest key and doesn't require iteration over the entire map", "label": {"api": {"ConcurrentSkipListMap": [[0, 20]], "lastKey": [[28, 34]]}}}, {"text": "See the deflater (sic) documentation", "label": {"api": {"deflater": [[8, 15]]}}}, {"text": "The built-in BigDecimal class doesn't provide the operations that you need (real exponentiation, or even logs)", "label": {"api": {"BigDecimal": [[13, 22]]}}}, {"text": "Instead, use BigDecimal, which is used to represent arbitrarily precise floating-point values", "label": {"api": {"BigDecimal": [[13, 22]]}}}, {"text": "Note that you will need a custom pow function to handle BigDecimal", "label": {"api": {"BigDecimal": [[56, 65]]}}}, {"text": "During standard run of the application it works fine - I'm not defining specific strategy for @GeneratedValue so it defaults to GenerationType.AUTO which, according to http://docs.oracle.com/javaee/5/api/javax/persistence/GenerationType.html#AUTO , lets the persistence provider decide which strategy to use depending on which database lies underneath, and since normally it's Oracle and Oracle's default generator strategy is GenerationType.SEQUENCE", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/persistence/GenerationType.html#AUTO": [[168, 245]]}}}, {"text": "InputMismatchException is thrown from sc.nextInt() method if the next token does not match the Integer regular expression, or is out of range", "label": {"api": {"sc.nextInt()": [[38, 49]]}}}, {"text": "If the thread is waiting for I/O, my understanding is that it's in the RUNNABLE state", "label": {"api": {"RUNNABLE": [[71, 78]]}}}, {"text": "It gets into the BLOCKED state when it tries to synchronize on an object that is locked by another thread", "label": {"api": {"BLOCKED": [[17, 23]]}}}, {"text": "It is in the WAITING state when it calls wait() (or a couple of other methods)", "label": {"api": {"WAITING": [[13, 19]]}}}, {"text": "You need to use Scanner to get input from user and add it to list", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "You're probably trying to instantiate a java.util.concurrent.locks.Lock, which is an interface", "label": {"api": {"java.util.concurrent.locks.Lock": [[40, 70]]}}}, {"text": "You'll want to instantiate an implementation, such as ReentrantLock, which is pretty much the standard way of doing \"flexible\" locks in Java, in cases where simple monitor locks aren't sufficient", "label": {"api": {"ReentrantLock": [[54, 66]]}}}, {"text": "You can also register a TableModelListener to receive a TableModelEvent that can tell your listener what has changed", "label": {"api": {"TableModelEvent": [[56, 70]]}}}, {"text": "If you are using 1.6 or above, you can use Console.readPassword() from inside your Java program to enter the password", "label": {"api": {"Console.readPassword()": [[43, 64]]}}}, {"text": "How about something like a counting Semaphore (and a configuration file to set the number of permits)", "label": {"api": {"Semaphore": [[36, 44]]}}}, {"text": "getMethod() only finds public methods", "label": {"api": {"getMethod()": [[0, 10]]}}}, {"text": "Either change the access modifier of the Caller#foo() method to public, or use getDeclaredMethod() instead", "label": {"api": {"getDeclaredMethod()": [[79, 97]]}}}, {"text": "You should use File.createTempFile()", "label": {"api": {"File.createTempFile()": [[15, 35]]}}}, {"text": "Java contains a Polygon class which has a method contains(double x, double y)", "label": {"api": {"contains(double x, double y)": [[49, 76]]}}}, {"text": "See the API for details on what to return", "label": {"api": {"the API": [[4, 10]]}}}, {"text": "You could then use the replaceAll() method to get rid of \".\"s", "label": {"api": {"replaceAll() method": [[23, 41]]}}}, {"text": "If you really want to leave your application hung while the database is down, look at Semaphore", "label": {"api": {"Semaphore": [[86, 94]]}}}, {"text": "Not sure what your use case is here, but if the substring of code are always the same length, you could use the substring() method", "label": {"api": {"substring() method": [[112, 129]]}}}, {"text": "Implementing Comparable doesn't mean that you can use < or >", "label": {"api": {"Comparable": [[13, 22]]}}}, {"text": "Implementing Comparable means that there's a compareTo() method", "label": {"api": {"Comparable": [[13, 22]], "compareTo()": [[45, 55]]}}}, {"text": "The compareTo() method will return an int that is smaller than, equal to, or bigger than 0, depending on which value is \"bigger\"", "label": {"api": {"compareTo()": [[4, 14]]}}}, {"text": "For diggesting messages in java, you could use MessageDigest", "label": {"api": {"MessageDigest": [[47, 59]]}}}, {"text": "C#, VB and VC++ can use the MD5 class, PHP has the hash function (using \"MD5\" as the first argument), in java you have MessageDigest, etc", "label": {"api": {"MessageDigest": [[119, 131]]}}}, {"text": "or take the log10 of the number and round it up", "label": {"api": {"log10 of the number": [[12, 30]]}}}, {"text": "If you have a java.awt.image.RenderedImage, you can call getData to get the rasterised data for that image", "label": {"api": {"rasterised data": [[76, 90]]}}}, {"text": "You can use GlyphVector#getOutline(), as mentioned here", "label": {"api": {"GlyphVector#getOutline()": [[12, 35]]}}}, {"text": "No, WebView does not support flash playback", "label": {"api": {"WebView": [[4, 10]]}}}, {"text": "Or, you can use HostServices.showDocument to open a browser to play the flash content, letting the browser worry about guiding the user through obtaining the appropriate plugin", "label": {"api": {"HostServices.showDocument": [[16, 40]]}}}, {"text": "You can make use of Class#getResourceAsStream to easily create a stream to a resource file", "label": {"api": {"Class#getResourceAsStream": [[20, 44]]}}}, {"text": "Calendar.YEAR, Calendar.MONTH, Calendar.DAY_OF_MONTH are int constants (just look up in the API doc)..", "label": {"api": {"API doc": [[92, 98]]}}}, {"text": "Also, you may want to look into Date", "label": {"api": {"Date": [[32, 35]]}}}, {"text": "Java 5 didn't have toHours, but Java 6 does", "label": {"api": {"toHours": [[19, 25]], "Java 6 does": [[32, 42]]}}}, {"text": "My guess is you're using a version of the TimeUnit class at runtime that doesn't include toHours", "label": {"api": {"toHours": [[89, 95]]}}}, {"text": "To restrict the maximum length of the data, you can set a custom Document for the text field that does not permit additions that break the maximum length restriction", "label": {"api": {"Document": [[65, 72]]}}}, {"text": "You should check out the BigInteger class", "label": {"api": {"BigInteger": [[25, 34]]}}}, {"text": "You can try getTableName() of ResultSetMetaData to get the name of the table to which the column belongs", "label": {"api": {"getTableName()": [[12, 25]]}}}, {"text": "Check the class HttpUrlConnection", "label": {"api": {"HttpUrlConnection": [[16, 32]]}}}, {"text": "You should go with the PreparedStatement, which protects you against SQL injection (a very easy way for malicious users to disrupt vulnerable systems)", "label": {"api": {"PreparedStatement": [[23, 39]]}}}, {"text": "One thing you can definitely do, though, is write most of the query in a private static final String constant with question marks where you want your parameters to be (?), append the other criteria you need based on the user input, and construct your PreparedStatement directly from that", "label": {"api": {"PreparedStatement": [[251, 267]]}}}, {"text": "Once you've made the PreparedStatement, you can use the various setter commands to have it fill in those ?s", "label": {"api": {"PreparedStatement": [[21, 37]]}}}, {"text": "Therefore, if you wish to enforce that the state reachable through the variable does not change, you have to declare the variable final, use an unmodifiable List (for instance with Collections.unmodifiableList), and make Synapse objects immutable", "label": {"api": {"Collections.unmodifiableList": [[181, 208]]}}}, {"text": "This may happen if your JDialog is modal", "label": {"api": {"JDialog": [[24, 30]]}}}, {"text": "If you want to do something special during a normal shutdown of the JVM, then use a shutdown hook", "label": {"api": {"shutdown hook": [[84, 96]]}}}, {"text": "Somewhere you're printing cycle objects, and since you haven't overridden cycle.toString(), it's using the default toString implementation", "label": {"api": {"default toString implementation": [[107, 137]]}}}, {"text": "I haven't ever seen a built-in function for this, only calls like Calendar.get(WEEK_OF_YEAR) or Joda's LocalDate.getWeekOfWeekyear()", "label": {"api": {"Calendar.get(WEEK_OF_YEAR)": [[66, 91]]}}}, {"text": "You can also find the version of the server using  DatabaseMetaData", "label": {"api": {"DatabaseMetaData": [[51, 66]]}}}, {"text": "Make your JDialog a modal dialog", "label": {"api": {"modal": [[20, 24]]}}}, {"text": "LinkedBlockingQueue is a good option for that and provides built-in concurrency control capabilities", "label": {"api": {"LinkedBlockingQueue": [[0, 18]]}}}, {"text": "There should probably be a call to checkRange() in getMessageBySeqNumber(), or just a Math.min() with the vector size", "label": {"api": {"Math.min()": [[86, 95]]}}}, {"text": "If I correctly understood your question, the ticket ID can be generated using the Random class API in your source code with the help of functions, and it can concatenated with a timestamp to the string variables", "label": {"api": {"Random": [[82, 87]]}}}, {"text": "What is the use of public final String[] getStringArray(String key) in ResourceBundle", "label": {"api": {"ResourceBundle": [[71, 84]]}}}, {"text": "HashMap is not a sorted or ordered Map implementation, so there isn't a \"position\" here", "label": {"api": {"HashMap": [[0, 6]], "Map": [[4, 6], [35, 37]]}}}, {"text": "LinkedHashMap is an ordered one, TreeMap is a sorted one", "label": {"api": {"HashMap": [[6, 12]], "Map": [[10, 12], [37, 39]], "LinkedHashMap": [[0, 12]], "TreeMap": [[33, 39]]}}}, {"text": "SimpleDateFormat is a very kind parser that rolls the resulting date instead of throwing an error", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "fmt.setLenient(false); is what you're looking for", "label": {"api": {"fmt.setLenient(false);": [[0, 21]]}}}, {"text": "Like Ralgha said, use an ArrayList, not an array", "label": {"api": {"ArrayList": [[25, 33]]}}}, {"text": "For your file parsing, you might want to consider the Scanner class", "label": {"api": {"Scanner": [[54, 60]]}}}, {"text": "Java documentation for println refers (through several links) to the documentation for toString", "label": {"api": {"documentation for toString": [[69, 94]]}}}, {"text": "The documentation for toString says that the number of digits printed for float or double is the number needed to uniquely distinguish the value from adjacent representable values in the same type", "label": {"api": {"documentation for toString": [[4, 29]]}}}, {"text": "While doing so, if you are using plain JDBC to insert record into orders table, you can register the order_no as an OUT parameter in your CallableStatement and get the value after the statement is executed and use to set the order_no attribute on the order_line records", "label": {"api": {"register the order_no as an OUT parameter": [[88, 128]], "CallableStatement": [[138, 154]]}}}, {"text": "Use setAutoCommit(false), then execute the first query with the option Statement.RETURN_GENERATED_KEYS (eg for PreparedStatement)", "label": {"api": {"PreparedStatement": [[111, 127]]}}}, {"text": "From the javadoc for Timer.cancel()", "label": {"api": {"Timer.cancel()": [[21, 34]]}}}, {"text": "You could use ScheduledThreadPoolExecutor.scheduleAtFixedRate instead", "label": {"api": {"ScheduledThreadPoolExecutor.scheduleAtFixedRate": [[14, 60]]}}}, {"text": "listFile will give the files within a directory", "label": {"api": {"File": [[4, 7]], "listFile": [[0, 7]]}}}, {"text": "You should implement a Comparator to sort the files based on the attributes you mentioned, and pass this as an argument to the Arrays.sort method", "label": {"api": {"Comparator": [[23, 32]], "Arrays.sort": [[127, 137]]}}}, {"text": "You could simulate ENTER being pressed using Robot class keyPress(..) and keyRelease(..) methods", "label": {"api": {"Robot": [[45, 49]]}}}, {"text": "An easy way for your socket listener to communicate the messages to your Second class is through a BlockingQueue", "label": {"api": {"BlockingQueue": [[99, 111]]}}}, {"text": "If you want unlimited messages to be queued then LinkedBlockingQueue would work", "label": {"api": {"BlockingQueue": [[55, 67]], "LinkedBlockingQueue": [[49, 67]]}}}, {"text": "If you want to throttle the messages then a bounded queue such as ArrayBlockingQueue might be more appropriate", "label": {"api": {"BlockingQueue": [[71, 83]], "ArrayBlockingQueue": [[66, 83]]}}}, {"text": "Both threads would need to share the same BlockingQueue so you will need to construct it and pass it to both threads or put a method on your Second class named something like addMessage(...) and the BlockingQueue would be inside of your Second class", "label": {"api": {"BlockingQueue": [[42, 54], [199, 211]]}}}, {"text": "If TimeZone.getAvailableIDs() contains ID in question, it's valid", "label": {"api": {"TimeZone.getAvailableIDs()": [[3, 28]]}}}, {"text": "Unfortunately TimeZone.getTimeZone() method silently discards invalid IDs and returns GMT instead", "label": {"api": {"TimeZone.getTimeZone()": [[14, 35]]}}}, {"text": "Rather than try to determine what conditions result in exact or inexact calculations consider using BigDecimal for these situations", "label": {"api": {"BigDecimal": [[100, 109]]}}}, {"text": "Just check if SimpleDateFormat#parse() doesn't throw a ParseException", "label": {"api": {"SimpleDateFormat#parse()": [[14, 37]]}}}, {"text": "Note that the setLenient(false) makes it non-lenient which thus means that overflowed values won't roll over", "label": {"api": {"setLenient(false)": [[14, 30]]}}}, {"text": "Once you have the String representation of the clipboard, you can get the bytes via String#getBytes()", "label": {"api": {"String#getBytes()": [[84, 100]]}}}, {"text": "The .add() isn't attached to fromCity, but to the method call getDestinations(fromCity)", "label": {"api": {"add()": [[5, 9]]}}}, {"text": "From the method declaration you can see that getDestinations(String fromCity) returns an ArrayList, and those have an add() method", "label": {"api": {"ArrayList": [[89, 97]], "add()": [[118, 122]]}}}, {"text": "One way could be like this, combining #lastIndexOf() with #substring()", "label": {"api": {"#lastIndexOf()": [[38, 51]], "#substring()": [[58, 69]]}}}, {"text": "I will recomend you to use the Path class from Java 7", "label": {"api": {"Path": [[31, 34]]}}}, {"text": "You could make a Servlet Filter, configure it to intercept all URLs matching your Web Services root URL (or even the root URL of the web server where the web service is deployed), have it pass the request on to the web service and then when the response arrives at the filter, if it's some kind of web service error you can change the response to whatever you want, make it redirect to some custom error page, etc", "label": {"api": {"Servlet Filter": [[17, 30]]}}}, {"text": "A HashMap is probably the Collection object you're looking for, although there are others that may be more suitable for your needs", "label": {"api": {"HashMap": [[2, 8]]}}}, {"text": "To load an Image (which is the one you want to use on  a Graphics2D object), while the ImageIcon is used in UI components, you should use ImageIO class which gives the functionality", "label": {"api": {"ImageIO": [[138, 144]]}}}, {"text": "Just use ImageIO class", "label": {"api": {"ImageIO": [[9, 15]]}}}, {"text": "java.util.Scanner  does not implement the Serializable interface", "label": {"api": {"Serializable": [[42, 53]], "Scanner": [[10, 16]]}}}, {"text": "You have to declare the field as transient in the class which contains the Scanner instance field", "label": {"api": {"Scanner": [[75, 81]]}}}, {"text": "Wrapper classes like Integer, Float,..", "label": {"api": {"Integer": [[21, 27]]}}}, {"text": "and collection classes like ArrayList, HashMap..", "label": {"api": {"ArrayList": [[28, 36]]}}}, {"text": "implement the java.io.Serializable interface", "label": {"api": {"Serializable": [[22, 33]]}}}, {"text": "The Scanner class is not meant to be Serializable from the point of view of the authors of the java specification", "label": {"api": {"Serializable": [[37, 48]], "Scanner": [[4, 10]]}}}, {"text": "From that we can decide which class to make Serializable", "label": {"api": {"Serializable": [[44, 55]]}}}, {"text": "Note that although it's not guaranteed, every implementation I've looked at uses Integer.valueOf to perform boxing operations - so you can get the same effect without the language's help", "label": {"api": {"Integer.valueOf": [[81, 95]]}}}, {"text": "If you want to remove the elements while you iterate, you would have to use Iterator, which has method Iterator#remove which you can use to remove the current element", "label": {"api": {"Iterator": [[76, 83], [103, 110]], "Iterator#remove": [[103, 117]]}}}, {"text": "Also, as others have already mentioned, you should use Object#equals method to compare the contents of your strings", "label": {"api": {"Object#equals": [[55, 67]]}}}, {"text": "Use the applyPattern method", "label": {"api": {"applyPattern": [[8, 19]]}}}, {"text": "So you could use EntityManager.getReference() (lazy load) instead of EntityManager.find()", "label": {"api": {"EntityManager.getReference()": [[17, 44]], "EntityManager.find()": [[69, 88]]}}}, {"text": "You will get a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[15, 45]]}}}, {"text": "See \"How to Avoid ConcurrentModificationException when using an Iterator\"", "label": {"api": {"ConcurrentModificationException": [[18, 48]]}}}, {"text": "The basic way to create the file would be calling the File#createNewFile method", "label": {"api": {"File#createNewFile": [[54, 71]]}}}, {"text": "You can get always get resources via ClassLoader.getResourceAsStream() (or getResource())", "label": {"api": {"ClassLoader.getResourceAsStream()": [[37, 69]]}}}, {"text": "They can also be accessed via Class.getResourceAsStream() (instead of ClassLoader)", "label": {"api": {"Class.getResourceAsStream()": [[30, 56]]}}}, {"text": "If you set nowrap true when using the Deflater (sic) constructor, then the result is raw deflate", "label": {"api": {"deflate": [[89, 95]]}}}, {"text": "To wrap a complete, terminated deflate stream to be a gzip stream, you need to prepend ten bytes", "label": {"api": {"deflate": [[31, 37]]}}}, {"text": "Note that I said a complete, terminated deflate stream", "label": {"api": {"deflate": [[40, 46]]}}}, {"text": "It takes some care to make one of those with parallel deflate tasks", "label": {"api": {"deflate": [[54, 60]]}}}, {"text": "You would need to make n-1 unterminated deflate streams and one final terminated deflate stream and concatenate those", "label": {"api": {"deflate": [[40, 46], [81, 87]]}}}, {"text": "To do that, you use deflate with the flush parameter SYNC_FLUSH", "label": {"api": {"deflate": [[20, 26]]}}}, {"text": "For better compression, you can use setDictionary on each chunk with the last 32K of the previous chunk", "label": {"api": {"setDictionary": [[36, 48]]}}}, {"text": "Create an ExecutorService instance, and use the submit() method to submit the Runnable instances for execution", "label": {"api": {"ExecutorService": [[10, 24]]}}}, {"text": "However I have found in docs for URL that", "label": {"api": {"docs for URL": [[24, 35]]}}}, {"text": "The hashCode() contract specifies that two equal strings will have the same hash code within the same JVM", "label": {"api": {"hashCode()": [[4, 13]]}}}, {"text": "On the other hand, the actual hashCode() implementation has changed from one JVM version to another and/or from one JVM vendor to another", "label": {"api": {"hashCode()": [[30, 39]]}}}, {"text": "Basically, you can rely on hashCode() being consistent within the same application, but not between different application instances", "label": {"api": {"hashCode()": [[27, 36]]}}}, {"text": "Another potential point of interest is that hashCode() as defined in Java is an int i.e", "label": {"api": {"hashCode()": [[44, 53]]}}}, {"text": "Use DefaultTableModel for your table instead of adding the data directly to the table", "label": {"api": {"DefaultTableModel": [[4, 20]]}}}, {"text": "As its name and its javadoc indicates, setText() sets the text of the text area to the given String argument", "label": {"api": {"its javadoc": [[16, 26]]}}}, {"text": "What I recommend is a custom container that would house both a HashMap and a Priority Queue", "label": {"api": {"Priority Queue": [[77, 90]]}}}, {"text": "So, extend the the Map, Collection, and Iterable interfaces and on add insert into both the HashMap and Priority Queue", "label": {"api": {"Priority Queue": [[104, 117]]}}}, {"text": "To do this, you can use the javax.xml.bind.DatatypeConverter#printBase64Binary method", "label": {"api": {"javax.xml.bind.DatatypeConverter#printBase64Binary": [[28, 77]]}}}, {"text": "Event needs to implement the Comparable<Event> interface", "label": {"api": {"the Comparable<Event> interface": [[25, 55]]}}}, {"text": "The other option is to pass a Comparator<Event> implementation to the queue when the it is constructed, to tell the queue how to compare Event instances", "label": {"api": {"Comparator<Event>": [[30, 46]]}}}, {"text": "System.getenv() is for Operating System environment variables, whereas System.getProperty() is for JVM arguments which are passed as -DpropName=value to Java application launcher (java)", "label": {"api": {"System.getenv()": [[0, 14]], "System.getProperty()": [[71, 90]]}}}, {"text": "getenv gets an environment variable", "label": {"api": {"getenv": [[0, 5]]}}}, {"text": "getProperty gets a Java property", "label": {"api": {"getProperty": [[0, 10]]}}}, {"text": "invokeAll() waits until all results are computed before it returns", "label": {"api": {"invokeAll()": [[0, 10]]}}}, {"text": "Use a loop and submit() them one by one instead, this method returns a Future with the pending result immediately", "label": {"api": {"submit()": [[15, 22]]}}}, {"text": "However, there are operations like codePointAt() which will deal with full Unicode code points..", "label": {"api": {"codePointAt()": [[35, 47]]}}}, {"text": "What you need to use is the setTimestamp(int parameterIndex,Timestamp x) method instead of the setDate() method", "label": {"api": {"setTimestamp(int parameterIndex,Timestamp x)": [[28, 71]]}}}, {"text": "String class has a method toUpperCase() and also toLowerCase(), which you can use to transform you String into upper or lower case letters and you don't need to use charAt method (in case you need to transform the specific letter)", "label": {"api": {"toUpperCase()": [[26, 38]], "toLowerCase()": [[49, 61]]}}}, {"text": "The other answer will totally work, but here is another way of doing it using Random.nextInt() if you don't want to have to do all the mathing around", "label": {"api": {"Random.nextInt()": [[78, 93]]}}}, {"text": "It uses java.util.Random, so make sure you import that if you do this", "label": {"api": {"java.util.Random": [[8, 23]]}}}, {"text": "This might be a perfect job for SwingWorker", "label": {"api": {"SwingWorker": [[32, 42]]}}}, {"text": "You can publish incremental updates, and SwingWorker will batch them to solve the performance problem", "label": {"api": {"SwingWorker": [[41, 51]]}}}, {"text": "The class javax.swing.Timer, discussed in How to Use Swing Timers, includes setCoalesce(), which \"coalesces multiple pending ActionEvent firings.\" It may an alternative way to pace your updates", "label": {"api": {"setCoalesce()": [[76, 88]]}}}, {"text": "Use String.contains() instead", "label": {"api": {"String.contains()": [[4, 20]]}}}, {"text": "I think the best approach, both in terms of efficiency and ease of writing, would be to use a Map", "label": {"api": {"Map": [[94, 96]]}}}, {"text": "Then, traverse the set of student ID's, obtaining the name and score with nameMap.get(id) and scoreMap.get(id), respectively - where each id is an element of the set of IDs, obtainable with nameMap.keySet()", "label": {"api": {"Map": [[78, 80], [99, 101], [194, 196]]}}}, {"text": "Scanner.hasNextInt() returns true if the next token is a number, returns false otherwise", "label": {"api": {"Scanner.hasNextInt()": [[0, 19]]}}}, {"text": "JWS also offers the ExtensionInstallerService that will provide a hook to invoking the DB installer", "label": {"api": {"ExtensionInstallerService": [[20, 44]]}}}, {"text": "It swallows any IOExceptions encountered by its I/O methods, and exposes a checkError() method to allow callers to see if the writer encountered any exceptions", "label": {"api": {"checkError()": [[75, 86]]}}}, {"text": "You should have to use java.util.Timer and java.util.TimerTask class", "label": {"api": {"java.util.Timer": [[23, 37], [43, 57]]}}}, {"text": "You need to use equals()", "label": {"api": {"equals": [[16, 21]]}}}, {"text": "getErrorOffset should tell you where the problem is", "label": {"api": {"getErrorOffset": [[0, 13]]}}}, {"text": "You can loop over characters and use Character.isDigit() to count digits in the string", "label": {"api": {"Character.isDigit()": [[37, 55]]}}}, {"text": "In Java, you can create a collection and use the method boolean contains(Object o)", "label": {"api": {"boolean contains(Object o)": [[56, 81]]}}}, {"text": "It sounds like the field is declared as the nullable, wrapper type Boolean instead of a boolean primitive", "label": {"api": {"nullable, wrapper type Boolean": [[44, 73]]}}}, {"text": "Arrays have static equals() methods you can use for this", "label": {"api": {"Arrays": [[0, 5]], "equals()": [[19, 26]]}}}, {"text": "This will return true if your arraylist contains exactly a, b, c and d (in the same order)", "label": {"api": {"contains exactly a, b, c and d (in the same order)": [[40, 89]]}}}, {"text": "could be NoSuchElementException", "label": {"api": {"NoSuchElementException": [[9, 30]]}}}, {"text": "You need to use BigInteger class to deal with such big numbers", "label": {"api": {"BigInteger": [[16, 25]]}}}, {"text": "The useDelimiter method has a signature that takes a Pattern object, instead of a String", "label": {"api": {"signature": [[30, 38]]}}}, {"text": "JDK7 added the @SafeVarargs annotation to note when generic varargs are genuinely safe, and applied that annotation to e.g", "label": {"api": {"@SafeVarargs annotation": [[15, 37]]}}}, {"text": "Well, if you really want to go down the reflection raod, then I suggest to have a look at the Introspector class and get the list of PropertyDescriptors from the BeanInfo", "label": {"api": {"Introspector": [[94, 105]]}}}, {"text": "look at the API for Comparable", "label": {"api": {"API": [[12, 14]]}}}, {"text": "You can make the conversion using a CertificateFactory (see examples), or perhaps BouncyCastle's PEMReader", "label": {"api": {"CertificateFactory": [[36, 53]]}}}, {"text": "Seems like you need TreeSet to achieve alphabetical order or LinkedHashSet to preserve insertion order", "label": {"api": {"TreeSet": [[20, 26]], "LinkedHashSet": [[61, 73]]}}}, {"text": "Note that your FullName must implement Comparable<FullName> in order to be used in TreeSet (or you have to provide external Comparator`)", "label": {"api": {"TreeSet": [[83, 89]]}}}, {"text": "Note that Thread.sleep(timeout) guarantees that the Thread will sleep for at least timeout ms (subject to the precision of the underlying system), but it might sleep longer", "label": {"api": {"Thread.sleep(timeout)": [[10, 30]]}}}, {"text": "There is a Thread.sleep(millis, nanos), but the precision is not very good either", "label": {"api": {"Thread.sleep(millis, nanos)": [[11, 37]]}}}, {"text": "I believe that what you want to use is Condition.awaitNanos, however I can not find any hard evidence to substantiate that this will return with high precision close to the requested time", "label": {"api": {"Condition.awaitNanos": [[39, 58]]}}}, {"text": "If you're on Java 7 you can use the new Files.move() method to perform the action you want regardless of it being a File or Folder", "label": {"api": {"Files.move()": [[40, 51]]}}}, {"text": "As MadProgrammer suggested in the comments, it would be even easier to simply use File.renameTo() which has been around much longer", "label": {"api": {"File.renameTo()": [[82, 96]]}}}, {"text": "I was unaware you can remove the window title and borders of a JFrame using the method setUndecorated()", "label": {"api": {"setUndecorated()": [[87, 102]]}}}, {"text": "Take a look at SpringLayout", "label": {"api": {"SpringLayout": [[15, 26]]}}}, {"text": "Look at the SpringLayout tutorial if you get stuck", "label": {"api": {"SpringLayout": [[12, 23]]}}}, {"text": "Try using following methods form String class", "label": {"api": {"String": [[33, 38]]}}}, {"text": "If everything works within the same class loader, you could create a singleton with AtomicLong private field", "label": {"api": {"AtomicLong": [[84, 93]]}}}, {"text": "game extends JFrame, which in turn extends java.awt.Window, so inherits its methods", "label": {"api": {"inherits its methods": [[63, 82]]}}}, {"text": "I would like to know what the purpose of the protocol parameter is in SSLContext.getInstance(String protocol)", "label": {"api": {"SSLContext.getInstance(String protocol)": [[70, 108]]}}}, {"text": "To check if the given entity is managed by the current PersistenceContext you can use the EntityManager#contains(Object entity)", "label": {"api": {"EntityManager#contains(Object entity)": [[90, 126]]}}}, {"text": "Use FileWriter will do you job", "label": {"api": {"FileWriter": [[4, 13]]}}}, {"text": "You can check if the members generated by AspectJ are synthetic", "label": {"api": {"synthetic": [[54, 62]]}}}, {"text": "The SecurityManager verifies that you have write access to the open file descriptors through the checkWrite(FileDescriptor fd) method, and similarly that you have read access through the checkRead(FileDescriptor fd) method", "label": {"api": {"checkWrite(FileDescriptor fd) method": [[97, 132]], "checkRead(FileDescriptor fd) method": [[187, 221]]}}}, {"text": "Your enhanced for loop is just syntactic sugar around using an Iterator, so you can just make that explicit and then use the iterator's remove method", "label": {"api": {"remove method": [[136, 148]]}}}, {"text": "String.split is used to break apart a string based on some particular delimiter", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "Can you use String.lastIndexOf()", "label": {"api": {"String.lastIndexOf()": [[12, 31]]}}}, {"text": "AutoCloseable (introduced in Java 7) makes it possible to use the try-with-resources idiom", "label": {"api": {"AutoCloseable": [[0, 12]], "Closeable": [[4, 12]]}}}, {"text": "Closeable is an older interface", "label": {"api": {"Closeable": [[0, 8]]}}}, {"text": "This allows not only all Closeable classes (like streams throwing IOException) to be used in try-with-resources, but also allows throwing more general checked exceptions from close()", "label": {"api": {"Closeable": [[25, 33]]}}}, {"text": "When in doubt, use AutoCloseable, users of your class will be grateful", "label": {"api": {"AutoCloseable": [[19, 31]], "Closeable": [[23, 31]]}}}, {"text": "In the code you have posted, you don't need to implement AutoCloseable", "label": {"api": {"AutoCloseable": [[57, 69]], "Closeable": [[61, 69]]}}}, {"text": "You only have to (or should) implement Closeable or AutoCloseable if you are about to implement your own PrintWriter, which handles files or any other resources which needs to be closed", "label": {"api": {"AutoCloseable": [[52, 64]], "Closeable": [[39, 47], [56, 64]]}}}, {"text": "Your current method is close; you just need to change the condition in the for-loop to check for a length of 4 using String#length() rather than equality to a key argument", "label": {"api": {"String#length()": [[117, 131]]}}}, {"text": "You can use EventObject#getSource(), which is inherited by ActionEvent", "label": {"api": {"EventObject#getSource()": [[12, 34]]}}}, {"text": "You can have a worker thread and a work queue encapsulated by an ExecutorService", "label": {"api": {"ExecutorService": [[65, 79]]}}}, {"text": "There are a couple of ways that can be accomplished, but for this reason it is often easier to use an actual object such as an ArrayList object rather than a 'primitive' array", "label": {"api": {"ArrayList": [[127, 135]], "Array": [[127, 131]]}}}, {"text": "That said, the Array class gives you some utilities", "label": {"api": {"Array": [[15, 19]]}}}, {"text": "Also note that Thread#suspend() is deprecated", "label": {"api": {"Thread#suspend()": [[15, 30]]}}}, {"text": "To load resources from within a JAR, you need to use one of the getResource() methods of a Class object, rather than loading files directly", "label": {"api": {"methods of a Class object": [[78, 102]]}}}, {"text": "Try using LexicalHandler APIs to parse CData and Comments from an XML", "label": {"api": {"LexicalHandler": [[10, 23]]}}}, {"text": "Use String.replaceAll(String regex, String replacement)", "label": {"api": {"String.replaceAll(String regex, String replacement)": [[4, 54]]}}}, {"text": "The same thing is when Server sends message - you use print instead of println but Client reads using readLine that reads until new line character, or to be more precise (BufferedReader|readLine())", "label": {"api": {"BufferedReader|readLine()": [[171, 195]]}}}, {"text": "Add an ItemListener so when the combobox is changed, the texts are updated", "label": {"api": {"ItemListener": [[7, 18]]}}}, {"text": "Oracle's Doku sais", "label": {"api": {"Oracle's Doku": [[0, 12]]}}}, {"text": "yes, that is what Maps are for..", "label": {"api": {"Map": [[18, 20]]}}}, {"text": "If you wish to keep using the Thread object directly and not using ready-to-use thread services from java.util.concurrent you should keep a references to all started thread (for example, put them in a List) and when wish to to close them, or interrupt them to stop, loop over the List", "label": {"api": {"java.util.concurrent": [[101, 120]]}}}, {"text": "You can use contains method in String class", "label": {"api": {"contains": [[12, 19]], "String": [[31, 36]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#valueOf%28java.lang.String%29 for more details", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#valueOf%28java.lang.String%29": [[4, 96]]}}}, {"text": "I looked at http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ObjectReference.html and it gives an idea that something like this could be possible", "label": {"api": {"http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ObjectReference.html": [[12, 97]]}}}, {"text": "And the the Formatter Javadoc says", "label": {"api": {"Formatter Javadoc": [[12, 28]]}}}, {"text": "Then you can get an InputStream out of it using URL#openStream()", "label": {"api": {"InputStream": [[20, 30]], "URL#openStream()": [[48, 63]]}}}, {"text": "Then you can write it to an arbitrary OutputStream the usual way", "label": {"api": {"OutputStream": [[38, 49]]}}}, {"text": "to a FileOutputStream", "label": {"api": {"OutputStream": [[9, 20]]}}}, {"text": "From the documentation of BorderLayout", "label": {"api": {"documentation of BorderLayout": [[9, 37]]}}}, {"text": "However, System.exit(1) could throw SecurityException exception, in which case clear() will be executed", "label": {"api": {"System.exit(1) could throw SecurityException exception": [[9, 62]]}}}, {"text": "Scanner#nextDouble reads the next token from the user as double", "label": {"api": {"Scanner#nextDouble": [[0, 17]]}}}, {"text": "Now this linefeed(Since this is a new line), will be regarded as input for the next Scanner.nextLine", "label": {"api": {"Scanner.nextLine": [[84, 99]]}}}, {"text": "Whereas, Scanner.nextLine reads the complete input till the newline", "label": {"api": {"Scanner.nextLine": [[9, 24]]}}}, {"text": "I think it is perfectly fine as long as you follow eqauls() and hashcode() contracts", "label": {"api": {"eqauls()": [[51, 58]], "hashcode()": [[64, 73]]}}}, {"text": "We all know that Java provide the hashCode() and equals(Object obj) method implementation in the base class java.lang.Object, and when ever required we override them in our class", "label": {"api": {"java.lang.Object": [[108, 123]]}}}, {"text": "The maximum positive value for an integer is Integer.MAX_VALUE which is 2,147,483,647", "label": {"api": {"Integer.MAX_VALUE which is 2,147,483,647": [[45, 84]]}}}, {"text": "and it should solve your problem (if all your numbers are less than Long.MAX_VALUE or 9,223,372,036,854,775,807)", "label": {"api": {"Long.MAX_VALUE or 9,223,372,036,854,775,807": [[68, 110]]}}}, {"text": "The method response.sendRedirect should automatically set the HTTP status code to 307 (Temporary Redirect, see http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletResponse.html#sendRedirect)", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletResponse.html#sendRedirect": [[111, 202]]}}}, {"text": "You could sort it whenever you add something in, but why would you do that when you can just add in everything and then call the (utility) method Arrays.sort", "label": {"api": {"Arrays.sort": [[146, 156]], "Arrays": [[146, 151]]}}}, {"text": "For common operations, take a look at Java's Arrays class - if you are doing something often, that's something you make a method for, like searching and sorting", "label": {"api": {"Arrays": [[45, 50]]}}}, {"text": "Use String#startsWith like this", "label": {"api": {"String#startsWith": [[4, 20]]}}}, {"text": "I am attempting to process an image file and return it as an Image object, however I am getting an ArrayIndexOutOfBoundsException in the following code when I call  public static BufferedImage getImageFromArray(int[] data, int columns, int rows)", "label": {"api": {"BufferedImage": [[179, 191]]}}}, {"text": "I am trying to generate an image from this data by using BufferedImage currently I am hitting a brick wall with this", "label": {"api": {"BufferedImage": [[57, 69]]}}}, {"text": "You might want to consider using a StringBuilder for this because repetitive string concatenation can hinder performance, but the idea is the same", "label": {"api": {"StringBuilder": [[35, 47]]}}}, {"text": "The trouble seems to be that paint() is called every time the component needs repainting", "label": {"api": {"paint()": [[29, 35]]}}}, {"text": "paint() methods should be written in a way that doesn't produce side effects and they shouldn't change the internal state of the applet", "label": {"api": {"paint()": [[0, 6]]}}}, {"text": "paint() must be restricted to doing just that", "label": {"api": {"paint()": [[0, 6]]}}}, {"text": "Otherwise, to read the samples, you can use AudioSystem and AudioInputStream", "label": {"api": {"AudioSystem": [[44, 54]], "AudioInputStream": [[60, 75]]}}}, {"text": "java.lang.Runtime.exec(String) parses the command line into single arguments itself and does not know anything about shell metacharacters such as using \\ to quote a space character that's supposed to go into an argument", "label": {"api": {"java.lang.Runtime.exec(String)": [[0, 29]]}}}, {"text": "Just do Thread.dumpStack(), this will print the stack trace to the console", "label": {"api": {"Thread.dumpStack()": [[8, 25]]}}}, {"text": "readLine() isn't what you're going to use (since that method doesn't exist); you'll want to use Scanner", "label": {"api": {"Scanner": [[96, 102]]}}}, {"text": "Case matters with strings, so the idea to compare them would be to equalsIgnoreCase()", "label": {"api": {"equalsIgnoreCase()": [[67, 84]]}}}, {"text": "BufferedImage has a method getSubimage", "label": {"api": {"getSubimage": [[27, 37]]}}}, {"text": "It should be possible to draw the entire mini-map to a BufferedImage, and then use getSubimage to get only the part that you need", "label": {"api": {"getSubimage": [[83, 93]]}}}, {"text": "Second, you can use the Map#remove method to free the reference of the key from memory", "label": {"api": {"Map#remove": [[24, 33]]}}}, {"text": "Look at the Javadoc for File and you will see that the constructor takes a File object as parent", "label": {"api": {"Javadoc for File": [[12, 27]]}}}, {"text": "You can use the ThreadMXBean JMX bean", "label": {"api": {"ThreadMXBean": [[16, 27]]}}}, {"text": "Extract from Set's javadoc", "label": {"api": {"Set's javadoc": [[13, 25]]}}}, {"text": "Use an ArrayList if you want a variable-size collection", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "Use an InputStream (for instance, FileInputStream) and an OutputStream (for instance, FileOutputStream), not readers and writers", "label": {"api": {"InputStream": [[7, 17], [38, 48]], "FileInputStream": [[34, 48]], "OutputStream": [[58, 69], [90, 101]], "FileOutputStream": [[86, 101]]}}}, {"text": "Alternatively if you want to work with a BitSet you can initialise it in a loop", "label": {"api": {"BitSet": [[41, 46]]}}}, {"text": "As per Javadoc, javax.xml.soap.MessageFactory create methods pre-populate SOAP message with necessary objects like envelope, body, header ensuring that message is fomed correctly", "label": {"api": {"As per Javadoc": [[0, 13]]}}}, {"text": "Also, according to the Integer API, the Integer.TYPE field (which holds int.class) is a class which only represents the primitive type", "label": {"api": {"Integer API": [[23, 33]]}}}, {"text": "As such, int.class is likely just used in the system for representation purposes, as said in the Integer API", "label": {"api": {"Integer API": [[97, 107]]}}}, {"text": "Looks like you can do it using the JOOX class and a StringReader", "label": {"api": {"StringReader": [[52, 63]]}}}, {"text": "See the DocumentBuilder API, which JOOX uses", "label": {"api": {"DocumentBuilder": [[8, 22]]}}}, {"text": "You might have to convert the StringReader to an InputSource or equivalent, but that's a relatively trivial conversion", "label": {"api": {"StringReader": [[30, 41]]}}}, {"text": "Your implementation of TableModel can use a SwingWorker that continually updates the view, as shown in this example or the API", "label": {"api": {"API": [[123, 125]]}}}, {"text": "For monitoring from within the program, take a look at the MemoryMXBean class (and related classes in the java.lang.management package)", "label": {"api": {"MemoryMXBean": [[59, 70]]}}}, {"text": "You need to use removeAll", "label": {"api": {"removeAll": [[16, 24]]}}}, {"text": "I am thinking that you may want to use RandomAccessFile, this has functions to support skip and is capable of moving backwards", "label": {"api": {"RandomAccessFile": [[39, 54]]}}}, {"text": "Read its javadoc", "label": {"api": {"its javadoc": [[5, 15]]}}}, {"text": "tldr; The problem is using ObjectInputStream (Java) which only works with data generated by ObjectOutputStream (Java)", "label": {"api": {"ObjectInputStream (Java)": [[27, 50]]}}}, {"text": "DataInputSteam (Java) is big-endian, but BinaryWriter (C#) must be converted to big-endian", "label": {"api": {"DataInputSteam (Java)": [[0, 20]]}}}, {"text": "TCP/IP Sockets, which has several status check methods as below", "label": {"api": {"TCP/IP Sockets": [[0, 13]]}}}, {"text": "You can use DatagramSocket for it in Java", "label": {"api": {"DatagramSocket": [[12, 25]]}}}, {"text": "Much more flexible is Calendar", "label": {"api": {"Calendar": [[22, 29]]}}}, {"text": "You can create a Calendar from a Date", "label": {"api": {"Calendar": [[17, 24]]}}}, {"text": "Then you can set various fields of the Calendar", "label": {"api": {"Calendar": [[39, 46]]}}}, {"text": "Either make a decision on the type based on the kind of access you need of the set, or you could try using Collections.unmodifiableSet()", "label": {"api": {"Collections.unmodifiableSet": [[107, 133]]}}}, {"text": "The easiest way to get the bean name is to lop off the get or is prefix and then pass the result into Introspector.decapitalize", "label": {"api": {"Introspector.decapitalize": [[102, 126]]}}}, {"text": "If your Java code exits with System.exit(status), you can get the status in Bash like this", "label": {"api": {"System.exit(status)": [[29, 47]]}}}, {"text": "For e.g if a web container then may be you initialize it during creation of servlet context", "label": {"api": {"servlet context": [[76, 90]]}}}, {"text": "Literals are always automatically interned, as defined by the String class", "label": {"api": {"defined by the String class": [[47, 73]]}}}, {"text": "I recently learned that there are Class representations for the primitive types in the JVM", "label": {"api": {"Class": [[34, 38]]}}}, {"text": "There is even an explicit reference to int.class in the Integer API (and likewise for each primitive type and its respective wrapper Object)", "label": {"api": {"Integer API": [[56, 66]]}}}, {"text": "In order to offer this as a download to the JSF response, you need to provide the ExternalContext#getResponseOutputStream() as someOutputStream", "label": {"api": {"ExternalContext#getResponseOutputStream()": [[82, 122]]}}}, {"text": "In the end, FacesContext#responseComplete() must be invoked to prevent JSF from performing the default navigation task (which would only corrupt the Excel file by appending some HTML output of the navigated page to the end)", "label": {"api": {"FacesContext#responseComplete()": [[12, 42]]}}}, {"text": "If you're actually using JSF 1.x, which lacks several convenience ExternalContext delegate methods, then you'd need to grab the raw HttpServletResponse by ExternalContext#getResponse() and perform the actions on it", "label": {"api": {"ExternalContext#getResponse()": [[155, 183]]}}}, {"text": "You can use String.format() with \"%02x\" for that", "label": {"api": {"String.format()": [[12, 26]]}}}, {"text": "getSubjectDN() should not be used any longer", "label": {"api": {"getSubjectDN()": [[0, 13]]}}}, {"text": "Denigrated, replaced by getSubjectX500Principal()", "label": {"api": {"getSubjectX500Principal()": [[24, 48]]}}}, {"text": "Here is the JavaDoc for getSubjectX500Principal()", "label": {"api": {"getSubjectX500Principal()": [[24, 48]]}}}, {"text": "1) You're using Collections.sort (which takes a List<E>), but trying to sort an array", "label": {"api": {"Collections.sort": [[16, 31]]}}}, {"text": "Use Arrays.sort instead", "label": {"api": {"Arrays.sort": [[4, 14]]}}}, {"text": "List.contains(...) uses equals() for its comparisons", "label": {"api": {"List.contains(...)": [[0, 17]], "equals()": [[24, 31]]}}}, {"text": "equals() doesn't require the two objects to be the same class, so you can override it like this", "label": {"api": {"equals()": [[0, 7]]}}}, {"text": "You probably want to override equals() for both, so that a.equals(b) == b.equals(a)", "label": {"api": {"equals()": [[30, 37]]}}}, {"text": "Whenever you create a new instance, put it into some type of mutable array", "label": {"api": {"mutable array": [[61, 73]]}}}, {"text": "If you look at the java.io.DataInput.readInt spec, they have code for the same thing", "label": {"api": {"java.io.DataInput.readInt spec": [[19, 48]]}}}, {"text": "You may be looking for setVisibleRowCount(), which hinges on the Scollable implementation of JList", "label": {"api": {"setVisibleRowCount()": [[23, 42]]}}}, {"text": "You use SimpleDateFormat for formatting as well as parsing", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "What is the difference between creating an object using the new keyword and creating an object using clone()", "label": {"api": {"clone()": [[101, 107]]}}}, {"text": "Derived by AbstractCollection, AbstractList was added with out of the box implementation for add(int, E) so any concrete implementation of AbstractList will have it", "label": {"api": {"AbstractList": [[31, 42], [139, 150]]}}}, {"text": "I would agree that difference is unlikely to matter, however I would use valueOf as future versions of java are likely going to cache a lot of the common numbers", "label": {"api": {"valueOf": [[73, 79]]}}}, {"text": "If you really wanted Math.round", "label": {"api": {"Math.round": [[21, 30]]}}}, {"text": "On the other hand, most of the User Interface (actually all except for hardcoded strings...) could be translated by assigning appropriate UIManager's keys to translated values..", "label": {"api": {"UIManager's": [[138, 148]]}}}, {"text": "If you are trying to restrict the number of rows the table displays by default, you can use JTable.setPreferredScrollableViewportSize()", "label": {"api": {"JTable.setPreferredScrollableViewportSize()": [[92, 134]]}}}, {"text": "classes in java.io package are designed for that", "label": {"api": {"java.io package": [[11, 25]]}}}, {"text": "i recommend you to have a look at java.io package", "label": {"api": {"java.io package": [[34, 48]]}}}, {"text": "You can use System.setIn() to mock user input", "label": {"api": {"System.setIn()": [[12, 25]]}}}, {"text": "Check out the FileWriter API", "label": {"api": {"FileWriter API": [[14, 27]]}}}, {"text": "But the main problem in your code is that the nextInt() method doesn't throw the NumberFormatException, instead it throws the InputMismatchException", "label": {"api": {"nextInt()": [[46, 54]]}}}, {"text": "The correct class is DateFormat", "label": {"api": {"DateFormat": [[21, 30]]}}}, {"text": "You may query what the offset is like this", "label": {"api": {"like this": [[33, 41]]}}}, {"text": "Since copyValueOf is a static member of String that would look like this", "label": {"api": {"copyValueOf is a static member of String": [[6, 45]]}}}, {"text": "Then it backtracks until it finds \"Tutorials\", after which it will again match any characters (except newlines)", "label": {"api": {"find": [[28, 31]]}}}, {"text": "It's better and more clear to use the find method", "label": {"api": {"find": [[38, 41]]}}}, {"text": "The find method simply finds the first \"Tutorials\" within the String, and you can remove the \"(.*)\" parts from the pattern", "label": {"api": {"find": [[4, 7], [23, 26]]}}}, {"text": "You can refer to the JFrame documentation for more detailed explanation", "label": {"api": {"JFrame documentation": [[21, 40]]}}}, {"text": "You can use a StringWriter in this way", "label": {"api": {"StringWriter": [[14, 25]]}}}, {"text": "According to the API docs, you can't use getElementText() to get the text if you are going to encounter another START_ELEMENT event inside", "label": {"api": {"the API docs": [[13, 24]]}}}, {"text": "You can use the System.out.printf() method for printing the strings and integers into fixed-width places (with alignment) using C-style format specifiers", "label": {"api": {"System.out.printf()": [[16, 34]], "C-style format specifiers": [[128, 152]]}}}, {"text": "Store the Question-instances in an ArrayList and use a Random.nextInt()-method to get a random question from your list", "label": {"api": {"Random.nextInt()": [[55, 70]]}}}, {"text": "To randomize the order in which the answers are presented, you can use the Collections.shuffle()-method", "label": {"api": {"Collections.shuffle()": [[75, 95]]}}}, {"text": "From the Javadoc of Double.longBitsToDouble", "label": {"api": {"Double.longBitsToDouble": [[20, 42]]}}}, {"text": "wrap the ArrayList in a Collections.unmodifiableList()", "label": {"api": {"Collections.unmodifiableList()": [[24, 53]]}}}, {"text": "{ is a control character for Regular Expressions, and since replaceFirst takes a string representation of a Regular Expression as its first argument, you need to escape the { so it's not treated as a control character", "label": {"api": {"replaceFirst": [[60, 71]]}}}, {"text": "The sample displays a digital clock readout in a label whose text changes each second using an Timeline", "label": {"api": {"Timeline": [[95, 102]]}}}, {"text": "Basically, what you need to do is create a class that would extend AbstractTableModel and  provide the implementation at least for the following three methods", "label": {"api": {"AbstractTableModel": [[67, 84]]}}}, {"text": "Javadoc for Boolean.compare(boolean x, boolean y)", "label": {"api": {"Javadoc for Boolean.compare(boolean x, boolean y)": [[0, 48]]}}}, {"text": "BigDecial.add() returns the sum, it does not alter it", "label": {"api": {"BigDecial.add()": [[0, 14]]}}}, {"text": "Create an empty temporary file by calling File.createTemporaryFile", "label": {"api": {"File.createTemporaryFile": [[42, 65]]}}}, {"text": "One way to ensure that is to call deleteOnExit on the temporary file object returned in the first step", "label": {"api": {"deleteOnExit": [[34, 45]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html for Date and Time Patterns", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html": [[4, 75]]}}}, {"text": "Integer.MAX_VALUE is the upper limit for indexing the internal character arrays used to store your string objects, so there isn't a way for you to have strings longer than that", "label": {"api": {"Integer.MAX_VALUE": [[0, 16]]}}}, {"text": "You could increment the max inactive interval with the sum of the current inactive time and the max inactive interval", "label": {"api": {"max inactive interval": [[24, 44], [96, 116]], "current inactive time": [[66, 86]]}}}, {"text": "However, this requires some filter which resets it back to the default max inactive interval again on every request when its value is off from the default", "label": {"api": {"max inactive interval": [[71, 91]]}}}, {"text": "On Servlet 3.0, this value is obtainable by SessionCookieConfig#getMaxAge()", "label": {"api": {"SessionCookieConfig#getMaxAge()": [[44, 74]]}}}, {"text": "It's declared in Connection which is an interface", "label": {"api": {"Connection": [[17, 26]]}}}, {"text": "It's implemented in some concrete class based on the actual connection returned by DriverManager.getConnection, which will depend on the connection URL you provide", "label": {"api": {"Connection": [[100, 109]]}}}, {"text": "see the Java Executor framework) Runnable only indicates that an object is available for threading", "label": {"api": {"Executor": [[13, 20]]}}}, {"text": "Java CharSequence is an interface", "label": {"api": {"CharSequence": [[5, 16]]}}}, {"text": "As the API says, CharSequence has been implemented in CharBuffer, Segment, String, StringBuffer, StringBuilder classes", "label": {"api": {"CharSequence": [[17, 28]]}}}, {"text": "So if you want to access or accept your API from all these classes thenCharSequence is your choice", "label": {"api": {"CharSequence": [[71, 82]]}}}, {"text": "Remember CharSequence only gives you 4 method, so if you are accepting a CharSequence object through a method, then your input manipulation ability will be limited", "label": {"api": {"CharSequence": [[9, 20], [73, 84]]}}}, {"text": "Use String.valueOf() to cast an integer value to String as", "label": {"api": {"String.valueOf()": [[4, 19]]}}}, {"text": "The DefaultCellEditor for many JTable cell types delegates to a JTextField, which binds the Delete key to the delete-next action", "label": {"api": {"DefaultCellEditor": [[4, 20]]}}}, {"text": "To preempt the default behavior, you'll have to remove the existing binding from DefaultCellEditor, as shown in How to Use Key Bindings", "label": {"api": {"DefaultCellEditor": [[81, 97]]}}}, {"text": "You can replace it with your own binding, as shown in this example; a typical DefaultCellEditor is shown here", "label": {"api": {"DefaultCellEditor": [[78, 94]]}}}, {"text": "or simply call  JComponent#setDoubleBuffered(..)", "label": {"api": {"JComponent#setDoubleBuffered(..)": [[16, 47]]}}}, {"text": "Check http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html for more details", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html": [[6, 68]]}}}, {"text": "Alternatively (as CM Kanode and screppedcola suggest in their comments) you can evaluate an expression as JavaScript, using a ScriptEngine, but this also seems like overkill", "label": {"api": {"ScriptEngine": [[126, 137]]}}}, {"text": "However, if you insist on rolling your own CSV parser, look into the java.util.StringTokenizer class", "label": {"api": {"java.util.StringTokenizer": [[69, 93]]}}}, {"text": "And looking at online javadoc (java 6) or (java 1.4), you have another option", "label": {"api": {"online javadoc (java 6)": [[15, 37]], "(java 1.4)": [[42, 51]]}}}, {"text": "If was doing this for myself the all method would just use String.split(String regex) (because it's more succinct); and then the unique method would start with the results of the all method, instead of \"manually parsing\" the words out of the line (again because it's much more succinct)", "label": {"api": {"String.split(String regex)": [[59, 84]]}}}, {"text": "There are two ways to open ZIP files in Java, using the ZipFile class, or using ZipInputStream", "label": {"api": {"ZipFile": [[56, 62]], "ZipInputStream": [[80, 93]]}}}, {"text": "As far as I remember, ZipFile reads the central directory of a zip file first - it can do this because it uses a RandomAccessFile underneath", "label": {"api": {"ZipFile": [[22, 28]]}}}, {"text": "However, ZipInputStream uses the in-line entry information, which might be better if the central directory, which I think exists at the end of the file, is missing or corrupt", "label": {"api": {"ZipInputStream": [[9, 22]]}}}, {"text": "So, it might be possible to 'repair' a ZIP file in Java by reading a ZIP file using ZipInputStream, and writing it back out to another file using a ZipOutputStream, copying entry information between them", "label": {"api": {"ZipInputStream": [[84, 97]]}}}, {"text": "You might end up getting IO exceptions reading from the last entry of the ZipInputStream if it got truncated, but it might still save the other previous entries from the file", "label": {"api": {"ZipInputStream": [[74, 87]]}}}, {"text": "BeanInfo instances are created by the JavaBean introspector (see the JRE Javadoc)", "label": {"api": {"JRE Javadoc": [[69, 79]]}}}, {"text": "Comparable is an interface that should be implemented by a class that can be sorted", "label": {"api": {"Comparabl": [[0, 8]]}}}, {"text": "To implement Comparable you simply implement a method compareTo, which compares the given object to another object", "label": {"api": {"Comparabl": [[13, 21]], "compareTo": [[54, 62]]}}}, {"text": "If you have an object named Foo that can be sorted, Foo should implement Comparable", "label": {"api": {"Comparabl": [[73, 81]]}}}, {"text": "The above is a example of a simple compareTo method", "label": {"api": {"compareTo": [[35, 43]]}}}, {"text": "Even better, you can implement a typed Comparable interface (possibly more confusing)", "label": {"api": {"Comparabl": [[39, 47]]}}}, {"text": "Take a look at intrinsic methods - these methods are known to the JIT, which uses hand rolled implementations when a method is compiled, and include heavily called methods such as String.indexOf, Integer.numberOfLeadingZeros, etc", "label": {"api": {"Integer.numberOfLeadingZeros": [[196, 223]]}}}, {"text": "You are looking for Swing or Awt in java", "label": {"api": {"Awt": [[29, 31]]}}}, {"text": "Always start with invokeLater(), use a layout manager, pack() the frame and make setVisible() last", "label": {"api": {"pack()": [[55, 60]]}}}, {"text": "In FixedQueue you have the checked exceptions", "label": {"api": {"Queue": [[8, 12]]}}}, {"text": "BTW I would make QueueFullException and QueueEmptyException extend IllegalStateException which is not a check exception, but I would still add it to the throws clause in your interface", "label": {"api": {"IllegalStateException": [[67, 87]], "Queue": [[17, 21], [40, 44]]}}}, {"text": "For comparison, you could look at the Queue and I would follow the naming and exceptions it throws as much as possible", "label": {"api": {"Queue": [[38, 42]]}}}, {"text": "This is how I would set out the interface by basing it on Queue", "label": {"api": {"Queue": [[58, 62]]}}}, {"text": "This way you can mentally, if not in code, replace Queue<Character> with CharQueue  As the documentation notes, offer is preferable to add and you might want to choose one of these depending on your requirements", "label": {"api": {"Queue": [[51, 55], [77, 81]]}}}, {"text": "You need to use Pattern.DOTALL mode", "label": {"api": {"Pattern.DOTALL": [[16, 29]]}}}, {"text": "You might be able to use a HyperlinkListener, illustrated here, in conjunction with Desktop#browse()", "label": {"api": {"Desktop#browse()": [[84, 99]]}}}, {"text": "Note the usage of FileWriter(File, boolean) and of System.out.println(tempFile.getAbsolutePath())", "label": {"api": {"FileWriter(File, boolean)": [[18, 42]], "System.out.println(tempFile.getAbsolutePath())": [[51, 96]]}}}, {"text": "Java monitors only the Process created with ProcessBuilder class or Runtime.exec() method", "label": {"api": {"Process": [[23, 29], [44, 50]], "ProcessBuilder": [[44, 57]], "Runtime.exec()": [[68, 81]]}}}, {"text": "You can add your cachedXSLT instance into ServletContext", "label": {"api": {"ServletContext": [[42, 55]]}}}, {"text": "You need to register ServletContextListener in your web XML and the contextInitialized method will be called by the container once", "label": {"api": {"ServletContext": [[21, 34]], "ServletContextListener": [[21, 42]], "contextInitialized": [[68, 85]]}}}, {"text": "So if you add your instance to the ServletContext then it will be available across all the application", "label": {"api": {"ServletContext": [[35, 48]]}}}, {"text": "To do that create a class which implements ServletContextListener", "label": {"api": {"ServletContext": [[43, 56]], "ServletContextListener": [[43, 64]]}}}, {"text": "In the contextInitialized method you can get servlet context by using as below and add the attribute", "label": {"api": {"contextInitialized": [[7, 24]]}}}, {"text": "To get ServletContext in your application depends on what framework you are using", "label": {"api": {"ServletContext": [[7, 20]]}}}, {"text": "The method you are looking for is setPreferredSize", "label": {"api": {"setPreferredSize": [[34, 49]]}}}, {"text": "I would also recommend to not setting the size of your JFrame to the fixed value (300,200) but do pack() instead", "label": {"api": {"pack()": [[98, 103]]}}}, {"text": "When using standard Java serialization, it is possible to have an object replaced on the fly in stream by, according to Serializable interface, creating a Object writeReplace() method that will be invoked during serialization", "label": {"api": {"Serializable": [[120, 131]]}}}, {"text": "I tried the Attach API, but decided against it since it is not bundled with Java SE6 and and integrating it with maven was not possible", "label": {"api": {"Attach API": [[12, 21]]}}}, {"text": "Use Class URL", "label": {"api": {"Class URL": [[4, 12]]}}}, {"text": "java.math.BigInteger always uses one sign bit in its toByteArray() method and its BigInteger(byte[]) constructor", "label": {"api": {"java.math.BigInteger": [[0, 19]], "toByteArray()": [[53, 65]], "BigInteger(byte[])": [[82, 99]]}}}, {"text": "Throw this into a FilenameFilter as follows", "label": {"api": {"FilenameFilter": [[18, 31]]}}}, {"text": "Use the AbstractAction(String name) constructor that includes the name", "label": {"api": {"AbstractAction(String name)": [[8, 34]]}}}, {"text": "This uses replaceAll() with a regex that means \"any letter not already guessed\" and replaces it with a underscore character \"_\"", "label": {"api": {"replaceAll()": [[10, 21]]}}}, {"text": "Note that Strings are immutable, and the replaceAll() method returns the modified String - it doesn't modify the String called on", "label": {"api": {"replaceAll()": [[41, 52]]}}}, {"text": "Look at the docs for the File constructor you're calling", "label": {"api": {"File constructor you're calling": [[25, 55]]}}}, {"text": "As per the javadoc for ThreadLocal", "label": {"api": {"javadoc for ThreadLocal": [[11, 33]]}}}, {"text": "I would suggest that You use the built-in filters FileFilter or FilenameFilter with the File.listFiles() method", "label": {"api": {"FileFilter": [[50, 59]], "FilenameFilter": [[64, 77]]}}}, {"text": "You could just use a HashSet<String> to maintain a collection of unique objects", "label": {"api": {"HashSet<String>": [[21, 35]]}}}, {"text": "Also have a look at ExecutorService as a means of abstracting many of the complexities associated with the lower-level abstractions like raw Thread", "label": {"api": {"ExecutorService": [[20, 34]]}}}, {"text": "The difference is you can use RuntimeMXBean from a remote JVM (see 2) to obtain its system properties", "label": {"api": {"see 2": [[63, 67]]}}}, {"text": "And, use ServletContext.getInitParameter() within the servlet", "label": {"api": {"ServletContext.getInitParameter()": [[9, 41]]}}}, {"text": "You want to use SimpleDateFormat to parse your date string to a valid Date object", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "And create a proxy with java.lang.reflect.Proxy.newProxyInstance", "label": {"api": {"java.lang.reflect.Proxy.newProxyInstance": [[24, 63]]}}}, {"text": "...if I were in NO position of bargaining about my web-services being \"i18n aware\" I would load each bundle file in a java.util.Properties object, then put all those objects in a Map and make it available in the application's context", "label": {"api": {"java.util.Properties": [[118, 137]]}}}, {"text": "It could be done with WeakHashMap and loading resource files on demand", "label": {"api": {"WeakHashMap": [[22, 32]]}}}, {"text": "The WeakHashMap will retain the files as long as they are needed, so it should not impact memory footprint much", "label": {"api": {"WeakHashMap": [[4, 14]]}}}, {"text": "The ResourceBundle you will read in this example, are actually the instances of PropertyResourceBundle class", "label": {"api": {"ResourceBundle": [[4, 17], [88, 101]], "PropertyResourceBundle": [[80, 101]]}}}, {"text": "I would suggest using a Map to store your instance for weapons that you fetch from your database", "label": {"api": {"Map": [[24, 26]]}}}, {"text": "It's good practise to use a StringBuilder to efficiently construct your string, and then call toString() on that to get your final string to return", "label": {"api": {"StringBuilder": [[28, 40]]}}}, {"text": "The best way to do this is using the ProcessBuilder class", "label": {"api": {"the ProcessBuilder class": [[33, 56]]}}}, {"text": "When I have to write a Java app for work I use the startsWith approach", "label": {"api": {"startsWith": [[51, 60]]}}}, {"text": "I think startsWith() is the best option since it makes your intention clear to anyone reading your code", "label": {"api": {"startsWith()": [[8, 19]]}}}, {"text": "It is documented behavior", "label": {"api": {"documented behavior": [[6, 24]]}}}, {"text": "Use a Callable<List<String>>, submit it to an executor, which will return a Future whose get() method will return a List<String>", "label": {"api": {"Callable<List<String>>": [[6, 27]], "get()": [[89, 93]]}}}, {"text": "Another would be to do the replacement yourself by using String.indexOf() and finding the start of the contained string", "label": {"api": {"String.indexOf()": [[57, 72]]}}}, {"text": "You could cache the reports by adding a Filter", "label": {"api": {"Filter": [[40, 45]]}}}, {"text": "The InputStream.available() method only returns an estimate of the number of bytes that can be read", "label": {"api": {"InputStream.available()": [[4, 26]]}}}, {"text": "I know if i must display the value i can use decimal format but this is inside the form,and vaadin knows it is a float,so it should handle it accordingly right", "label": {"api": {"decimal format": [[45, 58]]}}}, {"text": "All you have to do is copy the regular FileInputStream for your source file to the CipherOutputStream that's wrapping your FileOutputStream for the encrypted sink file", "label": {"api": {"CipherOutputStream": [[83, 100]]}}}, {"text": "To decrypt the file, do the same thing, but use CipherInputStream instead ofCipherOutputStream and initialize your Cipher using Cipher.DECRYPT_MODE", "label": {"api": {"CipherOutputStream": [[76, 93]]}}}, {"text": "The only stored byte[] in this system is the internal byte[] of the Cipher, which will get cleared each time enough input is entered and an encrypted block is returned by Cipher.update, or on Cipher.doFinal when the CipherOutputStream is closed", "label": {"api": {"CipherOutputStream": [[216, 233]]}}}, {"text": "This behavior can be found in the CipherOutputStream source code", "label": {"api": {"CipherOutputStream": [[34, 51]]}}}, {"text": "(Granted, this source is from the OpenJDK, but it probably does the same thing in the Sun JDK.) Also, from the CipherOutputStream javadocs", "label": {"api": {"CipherOutputStream": [[111, 128]]}}}, {"text": "I would also suggest you take a look at the regular expression documentation", "label": {"api": {"regular expression documentation": [[44, 75]]}}}, {"text": "If the string starts with your prefix and a MalformedURLException is thrown it is invalid", "label": {"api": {"MalformedURLException": [[44, 64]]}}}, {"text": "No, it does not, but the Arrays.sort method does take a Comparator", "label": {"api": {"Arrays.sort": [[25, 35]], "Comparator": [[56, 65]]}}}, {"text": "If you look in the Java API for File, there's a method called lastModified", "label": {"api": {"File": [[32, 35]]}}}, {"text": "Guava also has this as Files.simplifyPath(String)", "label": {"api": {"Path": [[37, 40]]}}}, {"text": "Your best bet, though, (if you can use JDK7) is to represent your path as a Path and use Path.normalize() to get the normalized version", "label": {"api": {"Path": [[76, 79], [89, 92]], "Path.normalize()": [[89, 104]]}}}, {"text": "Assuming JTidy prints errors and warnings to stdout, you can just temporarily change where System.out calls go", "label": {"api": {"temporarily change where System.out calls go": [[66, 109]]}}}, {"text": "There is an analogous method if you need to do this for System.err instead/as well", "label": {"api": {"an analogous method": [[9, 27]]}}}, {"text": "If you need bigger numbers, use BigInteger", "label": {"api": {"BigInteger": [[32, 41]]}}}, {"text": "Since we're going to be adding and removing these parameters, it'll be much easier to use a List that can resize itself instead of an array, like ArrayList", "label": {"api": {"ArrayList": [[146, 154]]}}}, {"text": "Note the difference between remove(Object) and remove(int)", "label": {"api": {"remove(Object)": [[28, 41]], "remove(int)": [[47, 57]]}}}, {"text": "If you use CP1256 in content-type you must use the same when creation the file with java.io.PrintStream", "label": {"api": {"java.io.PrintStream": [[84, 102]]}}}, {"text": "It's not necessary to flush and close the out variable", "label": {"api": {"It's not necessary to flush and close": [[0, 36]]}}}, {"text": "Loop through one list, then check if each element in other list using contains", "label": {"api": {"contains": [[70, 77]]}}}, {"text": "To mask the password, prefer java.io.Console.readPassword() class to Scanner", "label": {"api": {"java.io.Console.readPassword()": [[29, 58]]}}}, {"text": "I have read a statement about ArrayList", "label": {"api": {"ArrayList": [[30, 38]]}}}, {"text": "How to control/limit the tasks that are submitted to a ExecutorService", "label": {"api": {"ExecutorService": [[55, 69]]}}}, {"text": "If you have to deal with chars and not strings have a look at the getNumericValue method", "label": {"api": {"getNumericValue": [[66, 80]]}}}, {"text": "See the Set documentation", "label": {"api": {"Set documentation": [[8, 24]]}}}, {"text": "To change whether your dialog is modal or modeless, use setModalityType method", "label": {"api": {"setModalityType": [[56, 70]]}}}, {"text": "When you call setModal(true), modality type is the same as calling setModalityType(Dialog.DEFAULT_MODALITY_TYPE)", "label": {"api": {"setModalityType": [[67, 81]], "setModal(true)": [[14, 27]]}}}, {"text": "The default value is ModalityType.APPLICATION_MODAL", "label": {"api": {"ModalityType.APPLICATION_MODAL": [[21, 50]]}}}, {"text": "When you call setModal(true), modality type is set to ModalityType.MODELESS", "label": {"api": {"setModal(true)": [[14, 27]], "ModalityType.MODELESS": [[54, 74]]}}}, {"text": "On Android I'm using java.lang.Long, that could be null", "label": {"api": {"java.lang.Long": [[21, 34]]}}}, {"text": "Is there a java.lang.Long type in C#", "label": {"api": {"java.lang.Long": [[11, 24]]}}}, {"text": "If that is not possible, I use a combination of a normal HashMap and the excellent data structure CopyOnWriteArrayList, and synchronize externally", "label": {"api": {"CopyOnWriteArrayList": [[98, 117]]}}}, {"text": "Absolutely - that number is greater than than Long.MAX_VALUE (9223372036854775807)", "label": {"api": {"Long.MAX_VALUE": [[46, 59]]}}}, {"text": "Use BigInteger instead", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "If your output is buffered and you only write to it once in a while, it might take a long time for it to flush", "label": {"api": {"flush": [[105, 109]]}}}, {"text": "If you terminate the program before it flushed, and it does not close the stream properly, the buffer contents will never be flushed and the resulting file will be empty", "label": {"api": {"flush": [[39, 43], [125, 129]]}}}, {"text": "OTOH if you're always writing (the code outside the if will likely be called a lot more than the code inside) the buffer will fill more quickly, so there are better odds at least some data will be flushed", "label": {"api": {"flush": [[197, 201]]}}}, {"text": "Try explicitly calling out.flush() after the code finishes writing (in the end of the if) and see if that solves your problem", "label": {"api": {"flush": [[27, 31]]}}}, {"text": "The method Class.getDeclaredFields will get you an array of Fields representing each field of the class", "label": {"api": {"Class.getDeclaredFields": [[11, 33]]}}}, {"text": "You could loop over these and check the type returned by Field.getType", "label": {"api": {"Field.getType": [[57, 69]]}}}, {"text": "OR (preferrably), I would extended the Block from Rectangle, this way I could simply use the contains method instead..", "label": {"api": {"Rectangle": [[50, 58]]}}}, {"text": "The default composite for Graphics2D uses the AlphaComposite.SRC_OVER rule, so the result is expected", "label": {"api": {"Graphics2D": [[26, 35]]}}}, {"text": "AFAIU this could be achieved using GroupLayout", "label": {"api": {"GroupLayout": [[35, 45]]}}}, {"text": "See How to Use GroupLayout for examples (including discussion of that image)", "label": {"api": {"GroupLayout": [[15, 25]]}}}, {"text": "Take LinkedHashMap as the base class and override its removeEldestEntry method as described in the sample use of the method", "label": {"api": {"LinkedHashMap": [[5, 17]]}}}, {"text": "If not you need to look into either JAI or an SPI that supports that flavor of PNG", "label": {"api": {"SPI": [[46, 48]]}}}, {"text": "See ImageIO.write(RenderedImage,String,File) for details", "label": {"api": {"ImageIO.write(RenderedImage,String,File)": [[4, 43]]}}}, {"text": "Use SwingWorker to correctly update UI screen and to not block the UI thread", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "Look at javadoc of method AbstractTableModel#getColumnName(int) for details", "label": {"api": {"AbstractTableModel#getColumnName(int)": [[26, 62]]}}}, {"text": "To overcome this issue, use the java.util.concurrent.CopyOnWriteArrayList", "label": {"api": {"java.util.concurrent.CopyOnWriteArrayList": [[32, 72]]}}}, {"text": "You could extend the SwingWorker class or even Thread to implement the functionality you want the checkbox to control", "label": {"api": {"SwingWorker": [[21, 31]]}}}, {"text": "I would use SwingWorker for a more time consuming task that I wish to update the user on as it executes", "label": {"api": {"SwingWorker": [[12, 22]]}}}, {"text": "SwingWorker to the rescue", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "If you have the time, you can try and create a Java ME compliant version of iText, but to properly open a PDF the library must use some form of Random Access File because of the xref table at the end of the file", "label": {"api": {"Random Access File": [[144, 161]]}}}, {"text": "I checked TransferHandler but I don't know if it's the way to go", "label": {"api": {"TransferHandler": [[10, 24]]}}}, {"text": "If field is nullable simply remove the min flag (default value is 0)", "label": {"api": {"default value is 0": [[49, 66]]}}}, {"text": "If you want to see that point in time in different time zone, use GregorianCalendar", "label": {"api": {"GregorianCalendar": [[66, 82]]}}}, {"text": "You need to store your stuff in a List and then retrieve a list item by its index", "label": {"api": {"List": [[34, 37]]}}}, {"text": "There is a java class in the JDK for this, called URLEncoder", "label": {"api": {"URLEncoder": [[50, 59]]}}}, {"text": "So, basically, what you would do is to prepare your string using URLEncoder.encode(), like so", "label": {"api": {"URLEncoder": [[65, 74]]}}}, {"text": "Note that the Iterator#remove function is said to be optionnal but it is implemented by the ArrayList's iterator", "label": {"api": {"Iterator#remove": [[14, 28]]}}}, {"text": "You can use Collection::removeIf(Predicate filter) (available from Java8 onwards), here is a simple example", "label": {"api": {"Collection::removeIf(Predicate filter)": [[12, 49]]}}}, {"text": "try override close function in class FileInputStream, here is the doc for FileInputStream API, if you are using another kind of \"inputstream\", you just extend it and override the close method", "label": {"api": {"FileInputStream API": [[74, 92]]}}}, {"text": "And indeed, the InitialContext javadoc mentions the following", "label": {"api": {"InitialContext javadoc": [[16, 37]]}}}, {"text": "Styled text will is available in JavaFX 8 (included in jdk8 and jre8) via the TextFlow component", "label": {"api": {"TextFlow": [[78, 85]]}}}, {"text": "For older (now obsolete) JavaFX versions such as JavaFX 2.2, use a WebView to display styled text and an HTMLEditor to edit it", "label": {"api": {"WebView": [[67, 73]], "HTMLEditor": [[105, 114]]}}}, {"text": "Or you can place multiple Text or Label nodes in a FlowPane", "label": {"api": {"FlowPane": [[51, 58]]}}}, {"text": "You can use BigDecimal.toPlainString()", "label": {"api": {"BigDecimal.toPlainString()": [[12, 37]]}}}, {"text": "JavaDoc for Graphics", "label": {"api": {"JavaDoc for Graphics": [[0, 19]]}}}, {"text": "You cannot1, but you can use a Map<String,Event> instead, and put your variable names as the keys and the objects as the values", "label": {"api": {"Map<String,Event>": [[31, 47]]}}}, {"text": "To access the \"variables\" - you can use Map.get() and Map.put()", "label": {"api": {"Map.get()": [[40, 48]], "Map.put()": [[54, 62]]}}}, {"text": "If you want to use JDBC, I would recommend using Prepared Statements", "label": {"api": {"Prepared Statements": [[49, 67]]}}}, {"text": "Using RandomAccessFile you may call getFilePointer() to known how many bytes was read", "label": {"api": {"RandomAccessFile": [[6, 21]], "getFilePointer()": [[36, 51]]}}}, {"text": "Time consuming operation may be executed in a background thread, remember using SwingUtilities.invokeLater() to communicate between background task and GUI threads", "label": {"api": {"SwingUtilities.invokeLater()": [[80, 107]]}}}, {"text": "You can use reflection to get the Method object, and then utilize Method#getDefaultValue()", "label": {"api": {"Method#getDefaultValue()": [[66, 89]]}}}, {"text": "by using Atomics, but you will have to use something other that double as there is no AtomicDouble", "label": {"api": {"Atomics": [[9, 15]]}}}, {"text": "That's because the Class.forName() method takes the fully qualified class name as parameter", "label": {"api": {"Class.forName() method": [[19, 40]]}}}, {"text": "You should wait on a shared object and use notifyAll as in", "label": {"api": {"wait": [[11, 14]], "notifyAll": [[43, 51]]}}}, {"text": "If all you want to do is be able to access a file with a relative name to a certain directory, you can just use plain File API, like this", "label": {"api": {"File": [[118, 121]]}}}, {"text": "Check the Arrays class", "label": {"api": {"Arrays": [[10, 15]]}}}, {"text": "Why don't you put the list of houses in a SortedSet, and then create a SortedMap which maps from your postcodes to your Sorted Sets of houses", "label": {"api": {"SortedSet": [[42, 50]], "SortedMap": [[71, 79]]}}}, {"text": "You can use the TreeMap for your SortedMap implementation and the TreeSet for your SortedSet implementation", "label": {"api": {"SortedSet": [[83, 91]], "SortedMap": [[33, 41]], "TreeMap": [[16, 22]], "TreeSet": [[66, 72]]}}}, {"text": "since you want to condition your behavior on whether or not the file exists already, i would suggest an if block combined with the use of File.exists", "label": {"api": {"File.exists": [[138, 148]]}}}, {"text": "Then to draw the image, you can simply call the drawImage method from the Graphics class", "label": {"api": {"drawImage": [[48, 56]]}}}, {"text": "You can use File.exists() to see if file really exists on file system", "label": {"api": {"File.exists()": [[12, 24]]}}}, {"text": "For the server-side, you might have a servlet that generates the sound using javax.sound.sampled (for concatenating pre-recorded parts for the letters and numbers)", "label": {"api": {"javax.sound.sampled": [[77, 95]]}}}, {"text": "If you just subclassed URLClassLoader with no overriding, this is the documented behaviour you should expect", "label": {"api": {"this is the documented behaviour you should expect": [[58, 107]]}}}, {"text": "After writing several javafx.scene.control.TableView and seen the code has tedious, I have made this utility static function", "label": {"api": {"javafx.scene.control.TableView": [[22, 51]]}}}, {"text": "As a Collection you can use a TreeSet or TreeMap", "label": {"api": {"TreeSet": [[30, 36]], "TreeMap": [[41, 47]]}}}, {"text": "If you give a good implementation to your LineItem class (implement equals, hashcode and Comparable) you can optimise the memory use a lot", "label": {"api": {"Comparable": [[89, 98]]}}}, {"text": "You can add a ComponentListener to your slider that repaints it on componentResized", "label": {"api": {"ComponentListener": [[14, 30]]}}}, {"text": "You can choose the class java.io.Reader as base class overriding the abstract method int read( char[] cbuf, int off, int len) to build your own character oriented stream", "label": {"api": {"java.io.Reader": [[25, 38]], "int read( char[] cbuf, int off, int len)": [[85, 124]]}}}, {"text": "The tool for this is System.arraycopy", "label": {"api": {"System.arraycopy": [[21, 36]]}}}, {"text": "You can use the built in comparator String.CASE_INSENSITIVE_ORDER", "label": {"api": {"built in comparator": [[16, 34]]}}}, {"text": "If you use Java 7 I recommend using newBufferedReader", "label": {"api": {"newBufferedReader": [[36, 52]]}}}, {"text": "You can get it using the InetAddress class", "label": {"api": {"InetAddress": [[25, 35]]}}}, {"text": "You can see an example here, @OneToMany", "label": {"api": {"@OneToMany": [[29, 38]]}}}, {"text": "Well, the static return type of invoke is naturally Object", "label": {"api": {"invoke": [[32, 37]]}}}, {"text": "If you want to determine the dynamic type of an instance returned by the invocation, you can call getClass() on it to get the Class object representing its type", "label": {"api": {"getClass()": [[98, 107]], "Class": [[101, 105], [126, 130]]}}}, {"text": "If you need to inspect its contents, you can do further reflection using the Class (see getDeclaredFields(), etc.)", "label": {"api": {"Class": [[77, 81]], "getDeclaredFields()": [[88, 106]]}}}, {"text": "You can use a HashSet instead of an ArrayList", "label": {"api": {"HashSet": [[14, 20]]}}}, {"text": "So converting your ArrayList to a HashSet and back will remove all duplicates", "label": {"api": {"HashSet": [[34, 40]]}}}, {"text": "The downside is that the order of a HashSet is unpredictable, so when it's important to maintain the order, use a LinkedHashSet instead (which is a bit slower)", "label": {"api": {"HashSet": [[36, 42], [120, 126]], "LinkedHashSet": [[114, 126]]}}}, {"text": "The javadoc of Map writes", "label": {"api": {"javadoc of Map": [[4, 17]]}}}, {"text": "The Plus needs to be converted into the urlencoded form with the % notation", "label": {"api": {"urlencoded": [[40, 49]]}}}, {"text": "If you implements InvocationHandler, you override the following method", "label": {"api": {"InvocationHandler": [[18, 34]]}}}, {"text": "Map.remove(Object) removes a mapping based on the key", "label": {"api": {"Map.remove(Object)": [[0, 17]]}}}, {"text": "Example from the documentation of DecimalFormat", "label": {"api": {"DecimalFormat": [[34, 46]]}}}, {"text": "See the Java Pattern documentation for details", "label": {"api": {"Pattern": [[13, 19]]}}}, {"text": "If you want controls at the top of your window, and the table filling the majority of the window, then I'd suggest you try using BorderLayout instead of FlowLayout", "label": {"api": {"BorderLayout": [[129, 140]]}}}, {"text": "And add the components by specifying the location in the BorderLayout", "label": {"api": {"BorderLayout": [[57, 68]]}}}, {"text": "For the layout you're after, BorderLayout is much more appropriate", "label": {"api": {"BorderLayout": [[29, 40]]}}}, {"text": "The benefit of using BorderLayout here is that the components should be automatically resized to the size of the window, and you're explicitly stating where each component resides, so panels shouldn't not appear", "label": {"api": {"BorderLayout": [[21, 32]]}}}, {"text": "Finally, I'd also suggest using GridLayout for your controls, as it will allow you to place all your buttons in it, and they'll be the same size for consistency", "label": {"api": {"GridLayout": [[32, 41]]}}}, {"text": "For more information, read about GridLayout or BorderLayout, or just see the Java Tutorial for a Visual Guide to Layout Managers to see what alternatives you have and the best one for your situation", "label": {"api": {"GridLayout": [[33, 42]], "BorderLayout": [[47, 58]]}}}, {"text": "Yes, you can use a ZipInputStream instead", "label": {"api": {"ZipInputStream": [[19, 32]]}}}, {"text": "Now you can read the expanded content from the ZipInputStream, as you would any other InputStream", "label": {"api": {"ZipInputStream": [[47, 60]]}}}, {"text": "If you want fill list of Customer, there is this method Collections.fill(java.util.List, T) to fill list", "label": {"api": {"Collections.fill(java.util.List, T)": [[56, 90]]}}}, {"text": "I have a very specific problem about the method java.lang.Enum.values()", "label": {"api": {"java.lang.Enum": [[48, 61]]}}}, {"text": "Why don't you try Long.valueOf(String) to first parse it as a Long, and failing that parse it as a Double with Double.valueOf(String)", "label": {"api": {"Long.valueOf(String)": [[18, 37]], "Double.valueOf(String)": [[111, 132]]}}}, {"text": "Both throw a NumberFormatException if the string cannot be parsed", "label": {"api": {"NumberFormatException": [[13, 33]]}}}, {"text": "For question 1,  Phantom References can be used", "label": {"api": {"Phantom References": [[17, 34]]}}}, {"text": "Try using Class.getInterfaces() to get the interfaces implemented by a class and look for your interface in the array returned by the getInterfaces() method", "label": {"api": {"Class.getInterfaces()": [[10, 30]]}}}, {"text": "Most likely what you want is to use a Scanner to read numbers converted from the text you input", "label": {"api": {"Scanner": [[38, 44]]}}}, {"text": "You may want to have a look at Java's Tokenizer for support in extracting the tokens from the input", "label": {"api": {"Tokenizer": [[38, 46]]}}}, {"text": "By the looks of your code you have your Image packaged in your jar file, you should use getResourceAsStream(..) or getResource(..)  to extract it from the jar like so (Exception Handling omitted)", "label": {"api": {"getResourceAsStream(..)": [[88, 110]], "getResource(..)": [[115, 129]]}}}, {"text": "See the Oracle documentation for Map", "label": {"api": {"the Oracle documentation for Map": [[4, 35]]}}}, {"text": "You can use the ServiceLoader utility to do this (this is how many of the jdk services are loaded, e.g", "label": {"api": {"ServiceLoader": [[16, 28]]}}}, {"text": "Using a ScheduledThreadPoolExecutor you could schedule a runnable to run with a fixed rate, say every 10 seconds, without bothering about spawning the threads your self", "label": {"api": {"ScheduledThreadPoolExecutor": [[8, 34]]}}}, {"text": "do you use the annotations Stateful and Stateless", "label": {"api": {"Stateful": [[27, 34]], "Stateless": [[40, 48]]}}}, {"text": "From the docs for FileReader", "label": {"api": {"the docs for FileReader": [[5, 27]]}}}, {"text": "However you can use the classes Timer & TimerTask both of them included in the App-Engine JRE white list", "label": {"api": {"Timer": [[32, 36], [40, 44]], "TimerTask": [[40, 48]]}}}, {"text": "This should work, according to the java docs on Random numbers", "label": {"api": {"Random numbers": [[48, 61]]}}}, {"text": "Try using the constructor with autoflush", "label": {"api": {"constructor with autoflush": [[14, 39]]}}}, {"text": "java.lang.Appendable supports append(char) but not appendCodepoint(int)", "label": {"api": {"java.lang.Appendable": [[0, 19]]}}}, {"text": "I know there is this sync() method and flush() as well", "label": {"api": {"flush()": [[39, 45]]}}}, {"text": "You are looking for ArrayList.add() method and a for loop", "label": {"api": {"ArrayList.add()": [[20, 34]]}}}, {"text": "To later get an element you can use ArrayList.get(), and if  you need to iterate all objects you can use a for-each loop", "label": {"api": {"ArrayList.get()": [[36, 50]]}}}, {"text": "There is no such functionality but you can use a temporary file by File.createTempFile()", "label": {"api": {"File.createTempFile()": [[67, 87]]}}}, {"text": "Also use String.compareTo() over String.equals() in your compareTo method", "label": {"api": {"String.compareTo()": [[9, 26]]}}}, {"text": "typically utilities/frameworks like this load classes using the context classloader, but that is not always the case", "label": {"api": {"context classloader": [[64, 82]]}}}, {"text": "as a rule of thumb, while executing code which you know is from a nested classloader (probably because you set it up), you should set the current context classloader appropriately", "label": {"api": {"context classloader": [[146, 164]]}}}, {"text": "Rather than attempting to do so, I would recommend you take a look at java.util.concurrent.atomic.AtomicInteger", "label": {"api": {"java.util.concurrent.atomic.AtomicInteger": [[70, 110]]}}}, {"text": "I need something like ExecutorService.awaitTermination", "label": {"api": {"ExecutorService.awaitTermination": [[22, 53]]}}}, {"text": "and that's what clone does", "label": {"api": {"clone": [[16, 20]]}}}, {"text": "One thing to note here is that the start method of Thread returns void", "label": {"api": {"start": [[35, 39]]}}}, {"text": "From the docs for the set method you're calling", "label": {"api": {"set": [[22, 24]]}}}, {"text": "If this is not desired, call clear() first", "label": {"api": {"clear()": [[29, 35]]}}}, {"text": "Call clear() first, or explicitly set the millisecond value", "label": {"api": {"set": [[34, 36]], "clear()": [[5, 11]]}}}, {"text": "(Personally I'd use clear()", "label": {"api": {"clear()": [[20, 26]]}}}, {"text": "I'd also explicitly set the time zone, just to make it clearer which time you're expecting", "label": {"api": {"set": [[20, 22]]}}}, {"text": "Try using JFrame's pack method", "label": {"api": {"pack method": [[19, 29]]}}}, {"text": "You could use an ExecutorCompletionService, which handles the queing of finished future tasks", "label": {"api": {"ExecutorCompletionService": [[17, 41]]}}}, {"text": "Use the poll() method to poll for finished tasks", "label": {"api": {"poll()": [[8, 13]]}}}, {"text": "If you really know that vast amounts of your StringBuilders will be around for very long periods (which does not quite fit the concept of logging), and you really feel the need to try to persuade the JVM to save some bytes of heap space you may try and use trimToSize() after the string is built completely", "label": {"api": {"trimToSize()": [[257, 268]]}}}, {"text": "What's wrong with  equals", "label": {"api": {"equals": [[19, 24]]}}}, {"text": "See the FileWriter documentation for more infirmations", "label": {"api": {"FileWriter documentation": [[8, 31]]}}}, {"text": "You can read byte-by-byte and then shift your byte bit-by-bit", "label": {"api": {"read byte-by-byte": [[8, 24]]}}}, {"text": "This is due to NoRouteToHostException", "label": {"api": {"NoRouteToHostException": [[15, 36]]}}}, {"text": "Check How to avoid a NoRouteToHostException", "label": {"api": {"NoRouteToHostException": [[21, 42]]}}}, {"text": "Reading JavaDoc of java.util.concurrent.atomic", "label": {"api": {"JavaDoc of java.util.concurrent.atomic": [[8, 45]]}}}, {"text": "Is there a way to add a listener to an Executor", "label": {"api": {"Executor": [[39, 46]]}}}, {"text": "You could pull apart your lines with a StringTokenizer and then create a \"People\" class that implements the Comparable Interface", "label": {"api": {"StringTokenizer": [[39, 53]], "Comparable Interface": [[108, 127]]}}}, {"text": "The JavaDocs for SimpleDateFormat gives you a list of the formatting options", "label": {"api": {"JavaDocs for SimpleDateFormat": [[4, 32]]}}}, {"text": "Why not use a JFileChooser and call getSelectedFiles()", "label": {"api": {"JFileChooser": [[14, 25]], "getSelectedFiles()": [[36, 53]]}}}, {"text": "A correct solution in a Unicode world would be to use the Character.isLowercase() function and loop over the string", "label": {"api": {"Character.isLowercase()": [[58, 80]]}}}, {"text": "You can use the MouseListener interface, or it's useful abstract implementation, MouseAdapter", "label": {"api": {"MouseListener": [[16, 28]], "MouseAdapter": [[81, 92]]}}}, {"text": "Then create a timer that fires once per second, and add an ActionListener to it that updates the text of the label with the current time", "label": {"api": {"timer": [[14, 18]]}}}, {"text": "Simply create a KeyStroke and call setAccelerator(...) on the JMenuItem like so", "label": {"api": {"KeyStroke": [[16, 24]], "setAccelerator(...)": [[35, 53]]}}}, {"text": "I think what you are experiencing is explained in the API for Process", "label": {"api": {"API": [[54, 56]]}}}, {"text": "Scanner.nextInt() does not consume the newline, so you need to call nextLine() after grabbing the int to skip over it", "label": {"api": {"Scanner.nextInt()": [[0, 16]]}}}, {"text": "Why not something as simple as using Date.getTime()", "label": {"api": {"Date.getTime()": [[37, 50]]}}}, {"text": "You need to use Double.parseDouble(String); instead", "label": {"api": {"Double.parseDouble(String);": [[16, 42]]}}}, {"text": "Yes, once an object is sent over an ObjectOutputStream, re-sending it, even if modified, will only send a reference to the previously sent object, unless reset() is called on the stream", "label": {"api": {"reset()": [[154, 160]]}}}, {"text": "If you don't want reference tracking across messages, construct a new ObjectOutputStream and ObjectInputStream pair for each new message (or #reset the ObjectOutputStream and #readUnshared from the ObjectInputStream)", "label": {"api": {"#reset": [[141, 146]], "#readUnshared": [[175, 187]]}}}, {"text": "Now myScanner should read character by character", "label": {"api": {"read": [[21, 24]]}}}, {"text": "You might want to use a BufferedReader instead (if you can) - it has a read method that reads a single character", "label": {"api": {"BufferedReader": [[24, 37]], "read": [[71, 74], [88, 91]]}}}, {"text": "For instance, this will read and print the first character of your file", "label": {"api": {"read": [[24, 27]]}}}, {"text": "As you maybe able to see from Java doc for List", "label": {"api": {"Java doc for List": [[30, 46]]}}}, {"text": "If you want your data maintained sorted - I suggest using something like ConcurrentSkipListSet (Note however it is a set - thus it does not allow duplicate entrees), or maintaining a sorted List", "label": {"api": {"ConcurrentSkipListSet": [[73, 93]], "List": [[87, 90], [190, 193]]}}}, {"text": "You'll have to use reflection to invoke the method and System.currentTimeMillis() or System.nanoTime() to measure the elapsed time", "label": {"api": {"System.currentTimeMillis()": [[55, 80]], "System.nanoTime()": [[85, 101]]}}}, {"text": "use Collections.sort(yourList) to sort your ArrayList", "label": {"api": {"Collections.sort(yourList)": [[4, 29]]}}}, {"text": "Just use java.awt.Graphics.fillRect(int, int, int, int)", "label": {"api": {"java.awt.Graphics.fillRect(int, int, int, int)": [[9, 54]]}}}, {"text": "If you want a bigger range you can use java BigInteger Class", "label": {"api": {"BigInteger": [[44, 53]]}}}, {"text": "Use it as an example on how to use BigIntegers", "label": {"api": {"BigInteger": [[35, 44]]}}}, {"text": "Instead of BigInteger, you can also use the long type that vary from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (inclusive) (source)", "label": {"api": {"BigInteger": [[11, 20]]}}}, {"text": "Use BigInteger to support your number range", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "You can sort 2D arrays on their initial element using a custom Comparator", "label": {"api": {"Comparator": [[63, 72]]}}}, {"text": "In a previous program (unrelated), I was able to implement a linked list using an implementation provided with Java SE6", "label": {"api": {"implementation": [[82, 95]]}}}, {"text": "You can use a TreeMap data structure", "label": {"api": {"TreeMap data structure": [[14, 35]]}}}, {"text": "You should create DateFormat", "label": {"api": {"DateFormat": [[18, 27]]}}}, {"text": "Concurrent updates to non-synchronized HashMap can obviously cause a livelock or other data corruptions; to avoid this, one should use the concurrent version or implement a synchronization mechanism", "label": {"api": {"HashMap": [[39, 45]]}}}, {"text": "Can concurrent calls to HashMap.get() change the state of the HashMap, like rehashing", "label": {"api": {"HashMap": [[24, 30], [62, 68]], "HashMap.get()": [[24, 36]]}}}, {"text": "If get() does not change the state of the HashMap (and can't cause a livelock for another reaseon), than a single thread can create a HashMap in advance, and then many threads can read from it concurrently", "label": {"api": {"HashMap": [[42, 48], [134, 140]]}}}, {"text": "If concurrent reading isn't safe, we need ConcurrentHashMap for every multi-threaded access, regardless of type", "label": {"api": {"HashMap": [[52, 58]]}}}, {"text": "For example, a LinkedHashMap can use access order in which case get is a structural modification", "label": {"api": {"a LinkedHashMap": [[13, 27]]}}}, {"text": "According to the java.util.Scanner javadoc, Scanner.close() closes the associated stream if this stream implements the Closeable interface", "label": {"api": {"java.util.Scanner javadoc": [[17, 41]]}}}, {"text": "java.lang.System.in is an InputStream, which implements the Closeable interface", "label": {"api": {"InputStream": [[26, 36]]}}}, {"text": "Inject an Instance of your listener", "label": {"api": {"Instance": [[10, 17]]}}}, {"text": "All String literals are interned automatically, as described in the String JavaDoc", "label": {"api": {"String JavaDoc": [[68, 81]]}}}, {"text": "The one thing that happens before is the search for an UncaughtExceptionHandler according to the rules (specific Thread, ThreadGroup, all threads) but apart from this the \"normal\" cleanup procedure follows", "label": {"api": {"UncaughtExceptionHandler": [[55, 78]]}}}, {"text": "Therefore we need a resize() to set the window size which acm.program.GraphicsProgram inherits from java.applet.Applet", "label": {"api": {"java.applet.Applet": [[100, 117]]}}}, {"text": "Use the drawString() method, it can draw strings", "label": {"api": {"drawString()": [[8, 19]]}}}, {"text": "Use the function taking as second parameter a Comparator", "label": {"api": {"the function taking as second parameter a Comparator": [[4, 55]]}}}, {"text": "Note that the javadoc of Comparator contains guidelines regarding the building of comparators", "label": {"api": {"javadoc of Comparator": [[14, 34]]}}}, {"text": "Alternatively, you might also make your class implement the Comparable interface but this makes sense only if you can define a natural (obvious) order", "label": {"api": {"Comparable": [[60, 69]]}}}, {"text": "By default, it prints all elements in a collection by iterating over them (look in the implementation of AbstractCollection.toString())", "label": {"api": {"AbstractCollection.toString()": [[105, 133]]}}}, {"text": "Then you could add an item to the set when it's selected, remove it when it's deselected, and check to see if the set contains one when you need to know if it's selected", "label": {"api": {"add": [[15, 17]], "remove": [[58, 63]], "contains": [[118, 125]]}}}, {"text": "Since you don't know how many phrases you're likely to have (I suspect), I would populate an ArrayList<String> and convert it to an array using ArrayList.toArray() once you're done", "label": {"api": {"ArrayList.toArray()": [[144, 162]]}}}, {"text": "Call Window.pack() for your JDialog before showing it to make the window just big enough to fit all the components in it", "label": {"api": {"Window.pack()": [[5, 17]]}}}, {"text": "It has the method deleteCharAt(), along with many other mutator methods", "label": {"api": {"deleteCharAt()": [[18, 31]]}}}, {"text": "The java.util.zip API provides some access to zlib, though it is limited", "label": {"api": {"java.util.zip API": [[4, 20]]}}}, {"text": "You can use the Process object obtained to access the input, output, and error streams connected to the process's standard out, in, and error", "label": {"api": {"Process": [[16, 22]], "output": [[61, 66]]}}}, {"text": "This way you can send input to the child process and read its output back", "label": {"api": {"output": [[62, 67]]}}}, {"text": "The Manhattan distance is easy to implement with Math.abs(x1-x2)+Math.abs(y1-y2)", "label": {"api": {"Math.abs(x1-x2)+Math.abs(y1-y2)": [[49, 79]]}}}, {"text": "Although you can use Point2D.distance(x1,y1,x2,y2) method for the Euclidean distance, calculating it is not hard at all", "label": {"api": {"Point2D.distance(x1,y1,x2,y2)": [[21, 49]]}}}, {"text": "If you override equals, you almost always need to override hashCode", "label": {"api": {"hashCode": [[59, 66]]}}}, {"text": "As it says in the equals JavaDoc", "label": {"api": {"equals JavaDoc": [[18, 31]]}}}, {"text": "Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes", "label": {"api": {"hashCode": [[52, 59], [151, 158]]}}}, {"text": "I suppose, you could wrap your original input stream in a BufferedInputStream and use mark() to save the starting position within the stream, and reset() to return to it", "label": {"api": {"BufferedInputStream": [[58, 76]], "mark()": [[86, 91]]}}}, {"text": "Using mark() you can save a certain position and later on return to it using reset()", "label": {"api": {"mark()": [[6, 11]]}}}, {"text": "I am not sure but it looks like you are using a BufferedImage of type BufferedImage.TYPE_INT_ARGB", "label": {"api": {"BufferedImage": [[48, 60], [70, 82]]}}}, {"text": "This means that the BufferedImage is using a WritableRaster that is using a DataBuffer of type DataBufferInt", "label": {"api": {"BufferedImage": [[20, 32]]}}}, {"text": "If you can get a hold of the BufferedImage that the Canvas is using then get its WritableRaster and from there get the DataBufferInt", "label": {"api": {"BufferedImage": [[29, 41]]}}}, {"text": "This means that the pixels in the BufferedImage that the Preview has are being changed in-place without having to create another int[] of new pixels and another BufferedImage", "label": {"api": {"BufferedImage": [[34, 46], [161, 173]]}}}, {"text": "Based on this answer, I think you should be able to reassign the processe's stderr", "label": {"api": {"processe's stderr": [[65, 81]]}}}, {"text": "The matches method expects the entire string to match, not just a match to exist somewhere inside the target string", "label": {"api": {"matches method expects the entire string to match": [[4, 52]]}}}, {"text": "Another way to look for a match anywhere in the string is by using Pattern directly", "label": {"api": {"Pattern": [[67, 73]]}}}, {"text": "If you're doing this sort of thing a lot and want something \"less hacky\", I'd suggest ExecutorService#invokeAll()", "label": {"api": {"ExecutorService#invokeAll()": [[86, 112]]}}}, {"text": "The abstraction was designed to support the \"pluggable look and feel\" (L&F) architecture describe here", "label": {"api": {"\"pluggable look and feel\"": [[44, 68]]}}}, {"text": "Date.getTime provides 'number of milliseconds since January 1, 1970, 00:00:00' which is the same as Unix time * 1000", "label": {"api": {"Date.getTime": [[0, 11]]}}}, {"text": "Override the Servlet.init method of your Servlet", "label": {"api": {"Servlet.init": [[13, 24]]}}}, {"text": "I'm not sure what you are doing in getXSLOutput and why you need to read the same inputstream 100 times however to avoid EOF you can use mark(int) to mark the start of the stream in yourgetXSLOutput method and call reset at the end of the same method", "label": {"api": {"mark(int)": [[137, 145]], "reset": [[215, 219]]}}}, {"text": "I need system similar to ResourceBundles except that I will not use it for localization", "label": {"api": {"ResourceBundles": [[25, 39]]}}}, {"text": "These settings versions must be easily persisted to file system inside application .jar (alike  PropertyResourceBundle)", "label": {"api": {"PropertyResourceBundle": [[96, 117]]}}}, {"text": "Best practice would be to use PreparedStatement and input parameters for the placeholder ?", "label": {"api": {"PreparedStatement": [[30, 46]]}}}, {"text": "I believe you are looking for Platform.runLater() (See Platform)", "label": {"api": {"Platform": [[30, 37], [55, 62]]}}}, {"text": "However, you still have to think about initializing the JavaFX Toolkit by either a) extending Application with Main instead of ShowUsers or b) using a JFXPanel if you are using this from within a Swing application", "label": {"api": {"JFXPanel": [[151, 158]]}}}, {"text": "Read the String JavaDocs, especially the part about String.matches() as well as the documentation about regular expressions in Java", "label": {"api": {"String.matches()": [[52, 67]], "documentation about regular expressions in Java": [[84, 130]]}}}, {"text": "Check out URL, URLConnection, and maybe HttpURLConnection", "label": {"api": {"URL": [[10, 12], [15, 17], [44, 46]], "URLConnection": [[15, 27], [44, 56]], "HttpURLConnection": [[40, 56]]}}}, {"text": "They are in package java.net", "label": {"api": {"java.net": [[20, 27]]}}}, {"text": "String.replaceAll() receives a regular expression as first parameter", "label": {"api": {"String.replaceAll()": [[0, 18]]}}}, {"text": "You might want to try String.replace(), as you can pass a \"normal\" string to be replaced", "label": {"api": {"String.replace()": [[22, 37]]}}}, {"text": "What you can do is use a ZipInputStream to read the entry you are looking for", "label": {"api": {"ZipInputStream": [[25, 38]]}}}, {"text": "Yes, Criteria API does have have construct similar to JPQL constructor expressions", "label": {"api": {"construct": [[33, 41], [59, 67]]}}}, {"text": "Result class is set via construct method in CriteriaBuilder", "label": {"api": {"construct": [[24, 32]]}}}, {"text": "Since LinkedBlockingQueue implements BlockingQueue, this documented behavior applies to it", "label": {"api": {"documented behavior": [[57, 75]]}}}, {"text": "Since File, HashMap and Boolean all implement Serializable you can write the map to a file using an ObjectOutputStream and read it back with an ObjectInputStream", "label": {"api": {"File": [[6, 9]], "HashMap": [[12, 18]], "Boolean": [[24, 30]], "Serializable": [[46, 57]], "ObjectOutputStream": [[100, 117]], "ObjectInputStream": [[144, 160]]}}}, {"text": "If the status becomes more complex then be sure use a class that implements Serializable or if it's a custom class implement Serializable yourself", "label": {"api": {"Serializable": [[76, 87], [125, 136]]}}}, {"text": "From the Java docs on Socket, if your server is nothing, and your port is 8, you are correct", "label": {"api": {"Java docs on Socket": [[9, 27]]}}}, {"text": "You have to write your own implementation of Comparator that", "label": {"api": {"Comparator": [[45, 54]]}}}, {"text": "there is nothing in the Canvas API which automatically understands what you want the default background of the Canvas to be and can reset all other graphics attributes to that", "label": {"api": {"Canvas API": [[24, 33]]}}}, {"text": "If you really want to, you can use float, which has both a positive and negative infinity value", "label": {"api": {"has both a positive and negative infinity value": [[48, 94]]}}}, {"text": "This information can be extracted dynamically and generically via JPA metadata information (how to do that in turn depends on the JPA provider used) or just via good 'ol JDBC ResultSetMetaData class once during application's startup", "label": {"api": {"ResultSetMetaData": [[175, 191]]}}}, {"text": "Since A is null above code will throw a NullPointerException(NPE) which is a RuntimeException", "label": {"api": {"NullPointerException": [[40, 59]]}}}, {"text": "You can accomplish that using java.net.URL", "label": {"api": {"java.net.URL": [[30, 41]]}}}, {"text": "From the docs for InputMismatchException", "label": {"api": {"the docs for InputMismatchException": [[5, 39]]}}}, {"text": "or use the Pattern.DOTALL flag in the call to Pattern.compile()", "label": {"api": {"Pattern.DOTALL": [[11, 24]], "Pattern.compile()": [[46, 62]]}}}, {"text": "What you are looking for is probably the java.io.File#list(filter)", "label": {"api": {"java.io.File#list(filter)": [[41, 65]]}}}, {"text": "Instead implement  JFileChooser.setFileFilter(javax.swing.filechooser.FileFilter) for the best user experience", "label": {"api": {"JFileChooser.setFileFilter(javax.swing.filechooser.FileFilter)": [[19, 80]]}}}, {"text": "BufferedReader#read reads  single character[0 to 65535 (0x00-0xffff)] from the stream, so it is not possible to read single integer from stream", "label": {"api": {"BufferedReader#read": [[0, 18]]}}}, {"text": "That said, what you are looking for is java.lang.Process", "label": {"api": {"java.lang.Process": [[39, 55]]}}}, {"text": "You should use a DocumentFilter", "label": {"api": {"DocumentFilter": [[17, 30]]}}}, {"text": "You need to construct the path using File.separator", "label": {"api": {"File.separator": [[37, 50]]}}}, {"text": "A WeakReference is added to its ReferenceQueue supplied at the construction time when its reference is collected", "label": {"api": {"ReferenceQueue": [[32, 45]]}}}, {"text": "You could poll the ReferenceQueue whenever you access the cache, and hold a HashMap<WeakReference<CustomObject>,Long> to know which entry to remove if a reference is found in the queue", "label": {"api": {"ReferenceQueue": [[19, 32]]}}}, {"text": "Alternatively, if the cache is not frequently used, you can watch the queue in a separate thread", "label": {"api": {"watch the queue": [[60, 74]]}}}, {"text": "You can do this manually, but it's much better to use the existing utilities such as the ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[89, 106]]}}}, {"text": "The actual doSomething is run by one of the 10 threads managed by the ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[70, 87]]}}}, {"text": "You're much better off using another thread (perhaps using a TimerTask) and redrawing rectangles upon demand", "label": {"api": {"TimerTask": [[61, 69]]}}}, {"text": "I know it's pretty late, but I don't see anyone have answered with Java 8 way", "label": {"api": {"Java 8 way": [[67, 76]]}}}, {"text": "You need to first check the groupCount() and if it is more than 0, then you need to assign your variable", "label": {"api": {"groupCount()": [[28, 39]]}}}, {"text": "Use replace meyhod", "label": {"api": {"replace": [[4, 10]]}}}, {"text": "replace all - with +-", "label": {"api": {"replace": [[0, 6]]}}}, {"text": "Use split method", "label": {"api": {"split": [[4, 8]]}}}, {"text": "Now, each index value can be splitted individually", "label": {"api": {"split": [[29, 33]]}}}, {"text": "When you call Writer.write(int) you're meant to provide a Unicode value", "label": {"api": {"Writer.write(int)": [[14, 30]]}}}, {"text": "No, the String class does not contain a method for swapping characters", "label": {"api": {"String": [[8, 13]]}}}, {"text": "You may want to take a look at ResourceBundle.Control class", "label": {"api": {"ResourceBundle.Control": [[31, 52]]}}}, {"text": "Then, you need to load the resource somehow - you may want to use ClassLoader's getResourceAsStream(String) to open the InputStream for you", "label": {"api": {"ClassLoader's": [[66, 78]], "getResourceAsStream(String)": [[80, 106]]}}}, {"text": "The last step could be actually use the stream as an input to PropertyResourceBundle", "label": {"api": {"PropertyResourceBundle": [[62, 83]]}}}, {"text": "You can alternatively pass a Reader rather than InputStream, which has at least one advantage - you may actually allow properties file to be encoded in UTF-8, rather than regular ISO8859-1", "label": {"api": {"Reader": [[29, 34]]}}}, {"text": "You can use the ServletRequest.getRemoteAddr() method to verify the client or the last proxy", "label": {"api": {"ServletRequest.getRemoteAddr()": [[16, 45]]}}}, {"text": "Why not have one while loop that creates an ArrayList and then (if you need an array) extract the resultant array from that using ArrayList.toArray()", "label": {"api": {"ArrayList.toArray()": [[130, 148]]}}}, {"text": "You could use an ArrayList instead of an array and simply use", "label": {"api": {"ArrayList": [[17, 25]]}}}, {"text": "check out  JPanel#getComponent(int) to access the members that have been added to a Container(JPanel is implementing Container)", "label": {"api": {" JPanel#getComponent(int)": [[10, 34]]}}}, {"text": "Here is a simple example to show you how this can work, using the Java Date class", "label": {"api": {"Java Date class": [[66, 80]]}}}, {"text": "You can use WatchService which will tell you when new files appear in the folder", "label": {"api": {"WatchService": [[12, 23]]}}}, {"text": "Take a look at DocumentFilter", "label": {"api": {"DocumentFilter": [[15, 28]]}}}, {"text": "You can create a thread pool by using a ScheduledThreadPoolExecutor with a corePoolSize greater than 1", "label": {"api": {"ScheduledThreadPoolExecutor": [[40, 66]]}}}, {"text": "Then when you call scheduleWithFixedDelay on that thread pool, if a thread is available it will be reused", "label": {"api": {"scheduleWithFixedDelay": [[19, 40]]}}}, {"text": "Use a Set, it takes care of unique entries", "label": {"api": {"Set": [[6, 8]]}}}, {"text": "Step 1 says \"remove the best node\" - this implies the use of a Priority Queue", "label": {"api": {"Priority Queue": [[63, 76]]}}}, {"text": "The JDK includes a rudimentary HTML parser", "label": {"api": {"HTML parser": [[31, 41]]}}}, {"text": "You could try to override the JTextField's processKeyEvent method and check if 1.) the key pressed is the backspace key and 2.) the JTextField is empty", "label": {"api": {"processKeyEvent": [[43, 57]]}}}, {"text": "Just use Java's Pattern - it already implements Boyer Moore internally", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "Maybe Vehicle should implement Comparable and use Collections.sort() to sort", "label": {"api": {"Comparable": [[31, 40]]}}}, {"text": "Double.valueOf(double) returns the Wrapper type Double with value as double", "label": {"api": {"Double.valueOf(double)": [[0, 21]]}}}, {"text": "MouseAdapter only has a no-args contructor", "label": {"api": {"MouseAdapter": [[0, 11]]}}}, {"text": "You don't need to initialize the size of a List", "label": {"api": {"List": [[43, 46]]}}}, {"text": "The main reason to use a List is that its size can change", "label": {"api": {"List": [[25, 28]]}}}, {"text": "With a List you can just do this", "label": {"api": {"List": [[7, 10]]}}}, {"text": "You should use a Set", "label": {"api": {"Set": [[17, 19]]}}}, {"text": "A Set is a Collection that contains no duplicates", "label": {"api": {"Set": [[2, 4]], "Collection": [[11, 20]]}}}, {"text": "If you have a List that contains duplicates, you can get the unique entries like this", "label": {"api": {"List": [[14, 17]]}}}, {"text": "This HashSet constructor identifies duplicates by invoking the elements' equals() methods", "label": {"api": {"Set": [[9, 11]]}}}, {"text": "Make a request for the specified link using HttpURLConnection or Apache HttpComponents", "label": {"api": {"HttpURLConnection": [[44, 60]]}}}, {"text": "Use the Robot class to simply press Down arrow and Enter or something", "label": {"api": {"Robot": [[8, 12]]}}}, {"text": "If a database does not provide timezone information, then the JDBC driver should treat it as if it is in the local timezone of the JVM (see PreparedStatement.setDate(int, Date))", "label": {"api": {"PreparedStatement.setDate(int, Date)": [[140, 175]]}}}, {"text": "Java's UUID.nameUUIDFromBytes returns a Variant 3 UUID, Ben Ramsey's Ramsey\\Uuid PHP library can generate these", "label": {"api": {"UUID.nameUUIDFromBytes": [[7, 28]]}}}, {"text": "You should use the setHorizontalAlignment(...) and setVerticalAlignment(...) methods of JToggleButton (actually of AbstractButton)", "label": {"api": {"AbstractButton": [[115, 128]]}}}, {"text": "Try the Double wrapper class, which has an intValue() method", "label": {"api": {"Double": [[8, 13]]}}}, {"text": "Use BigDecimal as datatype instead of double to solve your problem", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "But take care as BigDecimal is immutable", "label": {"api": {"BigDecimal": [[17, 26]]}}}, {"text": "A call to setCatalog(String) will not affect existing statements, as specified in the JDBC API documentation", "label": {"api": {"setCatalog(String)": [[10, 27]]}}}, {"text": "Or if it's an array of (wrapper type) java.lang.Double", "label": {"api": {"(wrapper type) java.lang.Double": [[23, 53]]}}}, {"text": "Why not use a PriorityQueue with a Comparator like this", "label": {"api": {"PriorityQueue": [[14, 26]], "Comparator": [[35, 44]]}}}, {"text": "To use a Comparator", "label": {"api": {"Comparator": [[9, 18]]}}}, {"text": "If you plan on sorting numerous Lists in this way I would suggest having Chromosome implement the Comparable interface (in which case you could simply call Collections.sort(myList), without the need of specifying an explicit Comparator)", "label": {"api": {"Comparator": [[225, 234]], "Comparable": [[98, 107]]}}}, {"text": "The javadoc on EntityManager::getDelegate reads", "label": {"api": {"javadoc on EntityManager::getDelegate": [[4, 40]]}}}, {"text": "executeUpdate returns the row count of rows affected", "label": {"api": {"executeUpdate": [[0, 12]]}}}, {"text": "I use a Box with vertical orientation when GridBag feels like overkill", "label": {"api": {"Box": [[8, 10]]}}}, {"text": "Check out the Queue API", "label": {"api": {"Queue API": [[14, 22]]}}}, {"text": "You do that with ServletContext::getContext on your own ServletContext, passing the context path of the other webapp", "label": {"api": {"ServletContext::getContext": [[17, 42]]}}}, {"text": "Then, you simply do ServletContext::getRequestDispatcher as normal on the foreign context", "label": {"api": {"ServletContext::getRequestDispatcher": [[20, 55]]}}}, {"text": "Once done that, then you can use ServletContext#getContext() to obtain the other servlet context by its context path and finally use the RequestDispatcher as obtained by ServletContext#getRequestDispatcher() the usual way", "label": {"api": {"ServletContext#getContext()": [[33, 59]], "ServletContext#getRequestDispatcher()": [[170, 206]]}}}, {"text": "parseInt is a static method in Integer class", "label": {"api": {"parseInt": [[0, 7]]}}}, {"text": "Unless you care about preserving other fields than name, you should use this constructor and provide only the file name, as this", "label": {"api": {"this constructor": [[72, 87]]}}}, {"text": "Rather than attempting to find word and sentence boundaries yourself, you should use the BreakIterator class, a sentence instance", "label": {"api": {"BreakIterator": [[89, 101]], "sentence instance": [[112, 128]]}}}, {"text": "BreakIterator handles all the difficulty in detecting sentence boundaries for the specified locale too, such as a decimal point in a number not being a sentence boundary", "label": {"api": {"BreakIterator": [[0, 12]]}}}, {"text": "Servlet.destroy()'s javadoc says", "label": {"api": {"Servlet.destroy()": [[0, 16]]}}}, {"text": "Also, you may want to look at this version of indexOf that takes a fromIndex", "label": {"api": {"indexOf": [[46, 52]]}}}, {"text": "Yes, using the Pattern and Matcher classes from java.util.regex pacakge", "label": {"api": {"Pattern": [[15, 21]], "Matcher": [[27, 33]]}}}, {"text": "ServletContext.getResourceAsStream() will return null if it cannot find the file you are looking for", "label": {"api": {"ServletContext.getResourceAsStream()": [[0, 35]]}}}, {"text": "ImageIO.read() throws an IllegalArgumentExeception when the parameter is null", "label": {"api": {"ImageIO.read()": [[0, 13]]}}}, {"text": "I guess it means you should use methods like Integer#parseInt and Integer#valueOf instead of creating the object directly using a constructor", "label": {"api": {"Integer#parseInt": [[45, 60]], "Integer#valueOf": [[66, 80]]}}}, {"text": "How about Collections.unmodifiableList(List list)", "label": {"api": {"Collections.unmodifiableList(List list)": [[10, 48]]}}}, {"text": "You can however rescale a BufferedImage or Graphics object with the scale(x, y) method", "label": {"api": {"scale(x, y) method": [[68, 85]]}}}, {"text": "You need to set the month with MMM because you are using the first three letters of the month (and four M would mean the full month name)", "label": {"api": {"full month name": [[121, 135]]}}}, {"text": "Also, the timezone must be z instead of Z because you have a ISO 8601 Time zone (GMT)", "label": {"api": {"ISO 8601 Time zone": [[61, 78]]}}}, {"text": "Strings are not Iterable in Java (as opposed to in Python, for instance), but you can loop over their internal character arrays", "label": {"api": {"Iterable": [[16, 23]]}}}, {"text": "I changed the Datatype of name to StringBuilder", "label": {"api": {"StringBuilder": [[34, 46]]}}}, {"text": "Alternatively, you can format it with String.format() and specify zero fill and a minimum width for the converted string", "label": {"api": {"String.format()": [[38, 52]]}}}, {"text": "If you don't like the Math.Random you can make your own Random object", "label": {"api": {"Random": [[27, 32], [56, 61]]}}}, {"text": "If you need other types instead of int, Random will provide methods for boolean, double, float, long, byte", "label": {"api": {"Random": [[40, 45]]}}}, {"text": "You could use java.security.SecureRandom", "label": {"api": {"java.security.SecureRandom": [[14, 39]]}}}, {"text": "Decrement it each time a user logs out, and each time the HttpSession of a logged in user is destroyed (by using an HttpSessionListener)", "label": {"api": {"HttpSessionListener": [[116, 134]]}}}, {"text": "You need to turn this off using #setLenient(false) to make it reject all non-matching formats", "label": {"api": {"#setLenient(false)": [[32, 49]]}}}, {"text": "IMHO you should just shutdownNow() the pool and create a new one", "label": {"api": {"shutdownNow()": [[21, 33]]}}}, {"text": "Moreover the semantics of purge() are a bit fuzzy", "label": {"api": {"purge()": [[26, 32]]}}}, {"text": "The parent class of XYSplineRenderer is XYLineAndShapeRenderer that contains a nested State class holding the GeneralPath from which you can obtain the PathIterator", "label": {"api": {"PathIterator": [[152, 163]]}}}, {"text": "This related example examines the PathIterator of a Polygon, which contains only straight line segments", "label": {"api": {"PathIterator": [[34, 45]]}}}, {"text": "you can replace space with \"+\" or just pass the String through URLEncoder and be done with it", "label": {"api": {"URLEncoder": [[63, 72]]}}}, {"text": "To use URLEncoder see e.g", "label": {"api": {"URLEncoder": [[7, 16]]}}}, {"text": "encode with URLEncoder only parameter values, not the full URL", "label": {"api": {"URLEncoder": [[12, 21]]}}}, {"text": "If  you want to add an element at a specified index, you can use overloaded add(index, elem) method from list", "label": {"api": {"add(index, elem)": [[76, 91]]}}}]