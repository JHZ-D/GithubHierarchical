[{"text": "For a novice, should I expect same performance/smooth running/full debug support for SwingWorker", "label": {"api": {"SwingWorker": [[85, 95]]}}}, {"text": "If you don't have to use an ArrayList, I'd recommend checking out Java's Set interfaces", "label": {"api": {"Set": [[73, 75]]}}}, {"text": "A regular HashSet would likely offer you the best performance", "label": {"api": {"Set": [[14, 16]], "HashSet": [[10, 16]]}}}, {"text": "TreeSet would work if you want elements to maintain logical order", "label": {"api": {"Set": [[4, 6]], "TreeSet": [[0, 6]]}}}, {"text": "LinkedHashSet would work if you want to maintain insertion order, as if it were an ArrayList", "label": {"api": {"Set": [[10, 12]], "HashSet": [[6, 12]], "LinkedHashSet": [[0, 12]]}}}, {"text": "Just call setJMenuBar() in the MyFrame constructor", "label": {"api": {"setJMenuBar()": [[10, 22]]}}}, {"text": "isPresent(); get(); orElse(); orElseGet(); orElseThrow(); map(); filter(); flatmap()", "label": {"api": {"isPresent()": [[0, 10]], "get()": [[13, 17]], "orElse()": [[20, 27]], "orElseGet()": [[30, 40]], "orElseThrow()": [[43, 55]], "map()": [[58, 62], [79, 83]], "filter()": [[65, 72]], "flatmap()": [[75, 83]]}}}, {"text": "This method is declared in javax.swing.AbstractButton", "label": {"api": {"AbstractButton": [[39, 52]]}}}, {"text": "JRadioButton and AbstractButton", "label": {"api": {"JRadioButton": [[0, 11]], "AbstractButton": [[17, 30]]}}}, {"text": "You need to encode it yourself by escaping strings with URLEncoder and joining them with \"=\" and \"&\"", "label": {"api": {"URLEncoder": [[56, 65]]}}}, {"text": "You can leverage a Set to determine the word count", "label": {"api": {"Set": [[19, 21]]}}}, {"text": "InputStream defines the following method", "label": {"api": {"InputStream": [[0, 10]]}}}, {"text": "Use indexOf method", "label": {"api": {"indexOf": [[4, 10]]}}}, {"text": "Although, the second form can be greatly simplified, as ArrayList has a convenient copy constructor for collections", "label": {"api": {"copy constructor for collections": [[83, 114]]}}}, {"text": "You can also take a sublist of the passed-in list as well, making this a one-liner which accomplishes the same thing as the iteration piece", "label": {"api": {"take a sublist": [[13, 26]]}}}, {"text": "You should be using the Java utility classes (or at least implement the interfaces), and definitely bookmark the api", "label": {"api": {"api": [[113, 115]]}}}, {"text": "Additionally, reading through the java.net documentation didn't help much, though the ServerSocket class seems to be on the right track", "label": {"api": {"java.net": [[34, 41]]}}}, {"text": "Please try Semaphore from Java Standard API, it 's easy and less confusing", "label": {"api": {"Semaphore": [[11, 19]]}}}, {"text": "You can throw an EmptyStackException", "label": {"api": {"EmptyStackException": [[17, 35]]}}}, {"text": "If they aren't on the classpath, you need to create a URLClassLoader and use its getResource() method", "label": {"api": {"URLClassLoader": [[54, 67]]}}}, {"text": "A look at the java.awt.Color documentation would have answered your question", "label": {"api": {"java.awt.Color documentation": [[14, 41]]}}}, {"text": "The AbstractQueuedSynchronizer shows how that logic (similar to yours) is implemented around one atomic int variable", "label": {"api": {"AbstractQueuedSynchronizer": [[4, 29]]}}}, {"text": "Then form instance of [Executable] class (Method or Constructor) you can use method getParameters() to obtain array of Parameter instances", "label": {"api": {"Parameter": [[87, 95], [119, 127]]}}}, {"text": "Collections.sort method expects a collection that implements a List<T> interface", "label": {"api": {"Collections.sort method": [[0, 22]]}}}, {"text": "The checkPermission method will throw if the permission is not granted", "label": {"api": {"if the permission is not granted": [[38, 69]]}}}, {"text": "while the constructor for FilePermission will not throw if the specified permission is not granted, but only when the input is invalid", "label": {"api": {"only when the input is invalid": [[104, 133]]}}}, {"text": "Note that there is no removeAll() or similar method in the Javadocs for HttpSession", "label": {"api": {"HttpSession": [[72, 82]]}}}, {"text": "Your best bet is to get an Enumeration<String> of all attribute names with the getAttributeNames() method, then iterate over each one and manually calling removeAttribute()", "label": {"api": {"getAttributeNames()": [[79, 97]]}}}, {"text": "Call JComponent#revalidate() on parent component after changing element's visibility", "label": {"api": {"JComponent#revalidate()": [[5, 27]]}}}, {"text": "In your case, assuming that your Map can never change, then it is best to mark it as final, to ensure that it can never change, and wrap it in an unmodifiableMap to ensure that it cannot be modified", "label": {"api": {"unmodifiableMap": [[146, 160]]}}}, {"text": "Then, in Java, use Statement#execute to perform any DDL statement in JDBC", "label": {"api": {"Statement#execute": [[19, 35]]}}}, {"text": "Instead, you should use a Map<String, Type>, and use your map to refer them", "label": {"api": {"Map<String, Type>,": [[26, 43]]}}}, {"text": "Use the next() method to advance to the next record, which returns false when there are no more records", "label": {"api": {"the next() method": [[4, 20]]}}}, {"text": "Be sure to read the javadoc for Thread.interrupt() to be sure you know it actually does", "label": {"api": {"Thread.interrupt()": [[32, 49]]}}}, {"text": "The atomic reference ensures that updates to the variable are atomic", "label": {"api": {"atomic reference": [[4, 19]]}}}, {"text": "But even if you called Arrays.toString(), you'd still not get what you're looking for", "label": {"api": {"Arrays.toString()": [[23, 39]]}}}, {"text": "I would suggest reading more about how regular expressions work; there's lots of resources online to help, and a good starting point is the Java Regular Expressions lesson, and the Pattern documentation - you won't get very far until you understand what regular expressions are trying to do", "label": {"api": {"Pattern documentation": [[181, 201]]}}}, {"text": "You need to update that calling code to work with the Queue interface instead of a List", "label": {"api": {"Queue interface": [[54, 68]]}}}, {"text": "From the Java API", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "But the relevant information is more likely found in the ColorModel instance (rather than in the Raster or SampleModel instances)", "label": {"api": {"ColorModel": [[57, 66]]}}}, {"text": "The ColorModel instance is directly accessible from the BufferedImage", "label": {"api": {"ColorModel": [[4, 13]]}}}, {"text": "The order of color model components is documented in the java.awt.image.ColorModel javadoc", "label": {"api": {"java.awt.image.ColorModel javadoc": [[57, 89]]}}}, {"text": "As the API for ServletContextListener states", "label": {"api": {"states": [[38, 43]]}}}, {"text": "Since Java 7, it has quite a few options available", "label": {"api": {"quite a few options available": [[21, 49]]}}}, {"text": "My program is parsing an input string to a LocalDate object", "label": {"api": {"LocalDate": [[43, 51]]}}}, {"text": "Depending on which, I need to use a different pattern to call DateTimeFormatter.ofPattern(String pattern) with", "label": {"api": {"DateTimeFormatter": [[62, 78]]}}}, {"text": "I have looked in the docs for DateTimeFormatter but I couldn't find anything", "label": {"api": {"DateTimeFormatter": [[30, 46]]}}}, {"text": "In order to avoid using exceptions for program logic as much as possible (also not so nice performancewise) following alternative might be considered", "label": {"api": {"alternative": [[118, 128]]}}}, {"text": "Unfortunately the alternative and more intuitive method DateTimeFormater.parse() first creates a DateTimeParseException and then store the error index in this exception", "label": {"api": {"alternative": [[18, 28]], "DateTimeFormater.parse()": [[56, 79]]}}}, {"text": "To fix that, create the element using org.w3c.dom.Document.createElementNS providing the namespace of your original file", "label": {"api": {"org.w3c.dom.Document.createElementNS": [[38, 73]]}}}, {"text": "Parallel terminal operations are still done with ForkJoinTask instances outside of a ForkJoinPool context, which means every parallel stream still shares the common pool", "label": {"api": {"ForkJoinTask": [[49, 60]], "ForkJoinPool": [[85, 96]], "common pool": [[158, 168]]}}}, {"text": "The common pool worker threads pile up at the synchronized block, with only one thread able to enter at a time", "label": {"api": {"common pool": [[4, 14]]}}}, {"text": "And the result of using separate ForkJoinPool instances", "label": {"api": {"ForkJoinPool": [[33, 44]]}}}, {"text": "This is an issue with all terminal operations, not just forEach, since they all run tasks in the common pool", "label": {"api": {"common pool": [[97, 107]]}}}, {"text": "The ServletContextListener is what you want", "label": {"api": {"ServletContextListener": [[4, 25]]}}}, {"text": "Before Java8, Callable-classes were one way to execute multiple threads at one time", "label": {"api": {"Callable": [[14, 21]]}}}, {"text": "Callables can be used with Executor-classes to be executed", "label": {"api": {"Callable": [[0, 7]], "Executor": [[27, 34]]}}}, {"text": "Let's assume I am using a Fixed Thread Pool, using 3 as number of active processing tasks", "label": {"api": {"Fixed Thread Pool": [[26, 42]]}}}, {"text": "Fixed Thread Pool would start first three tasks, and as one finishes, next task is started, until all 8 tasks are finished", "label": {"api": {"Fixed Thread Pool": [[0, 16]]}}}, {"text": "You create renderer like JLabelRenderer(LogEntry log) because of, for all cells you have one instance of LogEntry, and log.getFileExtension() in getTableCellRendererComponent() returns same result for all rows", "label": {"api": {"getTableCellRendererComponent()": [[145, 175]]}}}, {"text": "In case of TableCellRenderer you need to use value parametr from getTableCellRendererComponent() method to determine extension and LogEntry instance", "label": {"api": {"getTableCellRendererComponent()": [[65, 95]]}}}, {"text": "Instead use JInternalFrame.addInternalFrameListener", "label": {"api": {"InternalFrameListener": [[30, 50]]}}}, {"text": "The InternalFrameListener interface fires dedicated methods for the opening, closing, minimizing and restoring events", "label": {"api": {"InternalFrameListener": [[4, 24]]}}}, {"text": "cipher.init(Cipher.WRAP_MODE, publicKey); needs publickey of a type with the interface Key", "label": {"api": {"Key": [[36, 38], [87, 89]]}}}, {"text": "Use the KeyFactory to create the Key you need based on KeySpec", "label": {"api": {"KeyFactory": [[8, 17]]}}}, {"text": "If you're in JSP or Facelets, it is way better to use HttpServletRequest#getContextPath", "label": {"api": {"HttpServletRequest#getContextPath": [[54, 86]]}}}, {"text": "The overloaded method was added in 2.0", "label": {"api": {"was added in 2.0": [[22, 37]]}}}, {"text": "To make this easier for the user, I'd like to enable them to ctl+v, move cursor, ctl+v, etc., and have my program pick up on the pastes and update the Clipboard automatically after every paste", "label": {"api": {"Clipboard": [[151, 159]]}}}, {"text": "But paintComponent doesn't take a second parameter, how are you passing it", "label": {"api": {"paintComponent": [[4, 17]]}}}, {"text": "To compare the contents, you can use either the equals method, or you can check if the result of calling compareTo is equal to 0", "label": {"api": {"equals method": [[48, 60]], "compareTo": [[105, 113]]}}}, {"text": "First and foremost, there is no reason to use Vector", "label": {"api": {"Vector": [[46, 51]]}}}, {"text": "Use ArrayList instead", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "The easiest way to accomplish both goals is with a Set", "label": {"api": {"Set": [[51, 53]]}}}, {"text": "Common Set implementations, notably HashSet, are explicitly unordered, meaning the order they are added in is not necessarily the order they are returned", "label": {"api": {"Set": [[7, 9], [40, 42]], "HashSet": [[36, 42]]}}}, {"text": "HashSet is arbitrary, but there are potentially predictable patterns in its implementation, such that the output of the above code could not be called \"random\"", "label": {"api": {"Set": [[4, 6]], "HashSet": [[0, 6]]}}}, {"text": "If you really want random ordering, your best bet is the Collections.shuffle() function, which takes a list and shuffles it, so that each element is approximately equally likely to be in any position in the list", "label": {"api": {"Collections.shuffle()": [[57, 77]]}}}, {"text": "Here's some example code (note we have to first put it through a HashSet to strip duplicates)", "label": {"api": {"Set": [[69, 71]], "HashSet": [[65, 71]]}}}, {"text": "By looking over the JavaDoc for X509TrustManager it looks like the way the TrustManagers work is by returning nothing on successful validation, otherwise throwing an exception", "label": {"api": {"X509TrustManager": [[32, 47]]}}}, {"text": "Look at the API docs of JFileChooser for more info", "label": {"api": {"JFileChooser": [[24, 35]]}}}, {"text": "Use the Color class to convert a string to a Color", "label": {"api": {"Color": [[8, 12], [45, 49]]}}}, {"text": "If you're using java Properties, then you can do something on the lines of this", "label": {"api": {"Properties": [[21, 30]]}}}, {"text": "Get the Set<Object> of keys using the Properties#keySet() method", "label": {"api": {"Properties": [[38, 47]]}}}, {"text": "If it does, get the value for that key using the Properties#getProperty() method and do whatever you want with the value", "label": {"api": {"Properties": [[49, 58]]}}}, {"text": "If you just want to wait for a thread to end, use Thread#join(), it seems to be the easiest way to achieve what you want", "label": {"api": {"Thread#join()": [[50, 62]]}}}, {"text": "When you have problem like that, the best thing you can do is visit the docs, see JTextField and you'll conclude that there is no such a method length() that can be applied on object of type JTextField", "label": {"api": {"JTextField": [[82, 91], [191, 200]], "length()": [[144, 151]]}}}, {"text": "But you'll notice that there exists a method called getText() that gets the text in the component, it returns a String, then you can have the known length() method for String", "label": {"api": {"getText()": [[52, 60]], "length()": [[148, 155]]}}}, {"text": "try using the Calendar class, instantiate one using the current time, and the other using the members birthday, then use the add method to figure out the age", "label": {"api": {"Calendar": [[14, 21]]}}}, {"text": "NoSuchMethodError is not derived from Exception", "label": {"api": {"NoSuchMethodError": [[0, 16]]}}}, {"text": "In Java 8, this functionality is provided via the Stream#forEach(Consumer) method in a very convenient form", "label": {"api": {"Stream#forEach(Consumer)": [[50, 73]]}}}, {"text": "In this case, exists returns false and so you call createNewFile to try to create the file, but the directory in which you're trying to create it doesn't exist, and so it throws an exception", "label": {"api": {"exists": [[14, 19]], "createNewFile": [[51, 63]]}}}, {"text": "You can use mkdirs to create the directories if necessary, like so", "label": {"api": {"mkdirs": [[12, 17]]}}}, {"text": "Why just don't use String.length()", "label": {"api": {"String.length()": [[19, 33]]}}}, {"text": "JList implements Scrollable to achieve this", "label": {"api": {"JList": [[0, 4]], "Scrollable": [[17, 26]]}}}, {"text": "You can override getScrollableUnitIncrement() to return your preferred increment for a given orientation and direction", "label": {"api": {"Scrollable": [[20, 29]]}}}, {"text": "This approach will fail if the numbers are too large to be contained in a long", "label": {"api": {"too large": [[43, 51]]}}}, {"text": "From the Javadoc for java.awt.Container.addImpl(Component comp, Object constraints, int index)", "label": {"api": {"java.awt.Container.addImpl(Component comp, Object constraints, int index)": [[21, 93]]}}}, {"text": "You could use the AM_PM field in the Calendar instance", "label": {"api": {"AM_PM": [[18, 22]]}}}, {"text": "To maintain compatibility with other devices, it's better to use HOUR (instead of HOUR_OF_DAY) in conjunction with AM_PM", "label": {"api": {"AM_PM": [[115, 119]]}}}, {"text": "Use HttpServletRequest#getContextPath to append those sources", "label": {"api": {"HttpServletRequest#getContextPath": [[4, 36]]}}}, {"text": "In case you don't want to call Collections#sort every time you add a new element, you can use List<PriorityQueue<Data>>, the PriorityQueue will sort the elements by you", "label": {"api": {"PriorityQueue": [[99, 111], [125, 137]]}}}, {"text": "Your two best choices are Joda-Time, if you aren't running Java 8, or the java.time package if you are", "label": {"api": {"java.time": [[74, 82]]}}}, {"text": "They're functionally very similar (java.time was largely based on Joda-Time)", "label": {"api": {"java.time": [[35, 43]]}}}, {"text": "One possible approach is to use the java.text.DecimalFormat class", "label": {"api": {"java.text.DecimalFormat": [[36, 58]]}}}, {"text": "You're misusing printf", "label": {"api": {"printf": [[16, 21]]}}}, {"text": "Simply use Arrays.sort() method to sort an array", "label": {"api": {"Arrays.sort()": [[11, 23]]}}}, {"text": "Here you can see that Throwable is the superclass for all Exceptions and Errors", "label": {"api": {"Throwable": [[22, 30]]}}}, {"text": "You can use addAttachment() with a DataSource or an InputStreamSource", "label": {"api": {"DataSource": [[35, 44]]}}}, {"text": "ByteArrayDataSource or ByteArrayResource)", "label": {"api": {"DataSource": [[9, 18]], "ByteArrayDataSource": [[0, 18]]}}}, {"text": "Maybe what you really need is a CopyOnWriteArrayList instead", "label": {"api": {"CopyOnWriteArrayList": [[32, 51]]}}}, {"text": "You can use ByteArrayOutputStream", "label": {"api": {"ByteArrayOutputStream": [[12, 32]]}}}, {"text": "Tue, 15 Nov 1994 08:12:31 GMT for an HttpServletRequest with a call to request.getDateHeader(\"Date\") but get the following exception", "label": {"api": {"HttpServletRequest": [[37, 54]]}}}, {"text": "You can also use Files.lines", "label": {"api": {"Files.lines": [[17, 27]]}}}, {"text": "Try using distinct(boolean) in CriteriaQuery", "label": {"api": {"distinct(boolean) in CriteriaQuery": [[10, 43]]}}}, {"text": "You have to use String.valueOf(char) to cast your char value into String", "label": {"api": {"String.valueOf(char)": [[16, 35]]}}}, {"text": "But when I try to achieve the same with Java 8 stream and transform the pattern to a predicate using Pattern.asPredicate", "label": {"api": {"Pattern.asPredicate": [[101, 119]]}}}, {"text": "Use Calendar.getWeekYear() to get year value synced with Calendar.WEEK_OF_YEAR field", "label": {"api": {"Calendar.getWeekYear()": [[4, 25]]}}}, {"text": "There is more information about Week of Year and Week Year at the GregorianCalendar doc", "label": {"api": {"GregorianCalendar": [[66, 82]]}}}, {"text": "As discussed here, two tables can share the same selection model", "label": {"api": {"selection model": [[49, 63]]}}}, {"text": "new Date().getTime() returns the number of milliseconds since January 1, 1970, 00:00:00 GMT represented by this Date object", "label": {"api": {"new Date().getTime()": [[0, 19]]}}}, {"text": "On a side node, creating a URLClassLoader without passing on Thread.currentThread().getContextClassLoader() as parent classloader in the constructor can give surprising results if the current Thread was started with a custom Classloader", "label": {"api": {"URLClassLoader": [[27, 40]]}}}, {"text": "The URLClassLoader will only know the classes from the System Classloader and the classes in the URLs provided, but not the classes from the custom Classloader", "label": {"api": {"URLClassLoader": [[4, 17]]}}}, {"text": "Then, divide your work into the appropriate number of chunks (12 in your example), create a Runnable object for each chunk of work and pass those Runnable objects to the ThreadPool's submit method", "label": {"api": {"submit": [[183, 188]]}}}, {"text": "If I use http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileLock.html, the lock is only respected on the JVM right", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileLock.html": [[9, 80]]}}}, {"text": "For more information see Class#getResoucesAsStream", "label": {"api": {"Class#getResoucesAsStream": [[25, 49]]}}}, {"text": "This is the String API for Java", "label": {"api": {"String API for Java": [[12, 30]]}}}, {"text": "You should be able to use Charset.decode(ByteBuffer) which will convert a ByteBuffer to a CharBuffer", "label": {"api": {"Charset.decode(ByteBuffer)": [[26, 51]]}}}, {"text": "Do use enums in this case, simply use Enum.valueOf() to parse your incoming string", "label": {"api": {"Enum.valueOf()": [[38, 51]]}}}, {"text": "Instead, you need to access them as resources using Class.getResourceAsStream()", "label": {"api": {"Class.getResourceAsStream()": [[52, 78]]}}}, {"text": "Here the Consumer<T> interface is broadly equivalent to the Action<T> delegate in .NET", "label": {"api": {"Consumer<T>": [[9, 19]]}}}, {"text": "The Java API is pretty much just all of the included libraries in Java", "label": {"api": {"Java API": [[4, 11]]}}}, {"text": "See the DateTimeFormatter javadoc for the details", "label": {"api": {"DateTimeFormatter javadoc": [[8, 32]]}}}, {"text": "This will work if you call Connection#prepareStatement(String sql, int resultSetType, int resultSetConcurrency) and passing", "label": {"api": {"Connection#prepareStatement(String sql, int resultSetType, int resultSetConcurrency)": [[27, 110]]}}}, {"text": "the object timeTable is a map and you are using it as an (associative) array, don't think of the keys as numbers but instead think of them as objects, any type of object could be a key; you will have to change the code and do something like the following", "label": {"api": {"map": [[26, 28]]}}}, {"text": "As per timeTable declaration the map is using a Route object as key and a List of Service as value; you are trying to put an Integer (using autoboxing) as key and a String as the value", "label": {"api": {"map": [[33, 35]]}}}, {"text": "Java now has a pretty good built-in date library, java.time bundled with Java 8", "label": {"api": {"java.time": [[50, 58]]}}}, {"text": "I suggest to you to look for the Javadoc documentation", "label": {"api": {"Javadoc documentation": [[33, 53]]}}}, {"text": "Alternatives what you have are that you use i/o API to check path existence, or introduce a between database where you will store your values", "label": {"api": {"path existence": [[61, 74]]}}}, {"text": "You can use the mouseEntered and mouseExited events from the MouseAdapter class", "label": {"api": {"mouseEntered": [[16, 27]], "mouseExited": [[33, 43]], "MouseAdapter": [[61, 72]]}}}, {"text": "You can set a timer on the mouseEntered method and check if the time spent on the object is >= the designated time in the mouseExited method and if so perform the action", "label": {"api": {"mouseEntered": [[27, 38]], "mouseExited": [[122, 132]]}}}, {"text": "For the scenario of mouse left at the same point, you can use the Timer with a delay of how many ever seconds you want and setup a handler at mouseExited to stop the timer if the pointer is exited before the designated time", "label": {"api": {"mouseExited": [[142, 152]]}}}, {"text": "File locking in Java should use the standard FileLock class", "label": {"api": {"FileLock": [[45, 52]]}}}, {"text": "If I am running a common implementation of Java (Oracles, Open JDK) on a POSIX operating system, or more specifically a GNU/Linux system, is it safe to assume that the Java FileLock class uses POSIX advisory locks", "label": {"api": {"FileLock": [[173, 180]]}}}, {"text": "Have a look at the Scanner class doc for more information", "label": {"api": {"the Scanner class doc": [[15, 35]]}}}, {"text": "The BufferedReader.lines() method returns a stream", "label": {"api": {"BufferedReader.lines()": [[4, 25]]}}}, {"text": "The javadoc of BufferedReader.lines() specifies", "label": {"api": {"BufferedReader.lines()": [[15, 36]]}}}, {"text": "If you need to do multiple actions with the data from the BufferedReader.lines() you either need to process to stream once, or you need to collect the data into temporary storage", "label": {"api": {"BufferedReader.lines()": [[58, 79]]}}}, {"text": "That's why the Arrays class has so many overloads for methods like binarySearch..", "label": {"api": {"Arrays": [[15, 20]]}}}, {"text": "Use a List, which allows growing in size dynamically", "label": {"api": {"List": [[6, 9]]}}}, {"text": "Take a look at Java Collections", "label": {"api": {"Java Collections": [[15, 30]]}}}, {"text": "Your main() method should call invokeLater and perform the GUI operations (including the look and feel parts) in a passed Runnable", "label": {"api": {"invokeLater": [[31, 41]]}}}, {"text": "As far as the sorting goes, Collections sorts should work well with that number of players", "label": {"api": {"Collections": [[28, 38]]}}}, {"text": "I would start by creating a BufferedImage object, acquiring its Graphics context, calling Graphics.drawString() to turn your token into image data, then writing the BufferedImage to disk", "label": {"api": {"BufferedImage": [[28, 40], [165, 177]], "Graphics": [[64, 71], [90, 97]]}}}, {"text": "A resource is not accessed as a file, it is better to use it as a stream", "label": {"api": {"as a stream": [[61, 71]]}}}, {"text": "Set already defines .equals(), and all implementations of Set are required to implement it the way the doc says (and, of course, it goes for .hashCode() as well)", "label": {"api": {"Set already defines .equals()": [[0, 28]]}}}, {"text": "Also, the read thread needs to pause when the queue gets too large (or use an ArrayBlockingQueue)", "label": {"api": {"ArrayBlockingQueue": [[78, 95]]}}}, {"text": "In Java 9, there will be completeOnTimeout(T value, long timeout, TimeUnit unit), which does what you want, although it does not cancel the slow supplier", "label": {"api": {"completeOnTimeout(T value, long timeout, TimeUnit unit)": [[25, 79]]}}}, {"text": "There is also a orTimeout(long timeout, TimeUnit unit), which completes exceptionally in case on a timeout", "label": {"api": {"orTimeout(long timeout, TimeUnit unit)": [[16, 53]]}}}, {"text": "EvenIterator is declared as (indirectly) implementing the Iterator<Integer> interface, so it must implement the Iterator.remove method", "label": {"api": {"the Iterator.remove method": [[108, 133]]}}}, {"text": "Rather than assigning the requests to an instance variable you would be better off adding them to one of the java.util.concurrent queue classes and consuming them from the queue in the Thread.run() method", "label": {"api": {"java.util.concurrent": [[109, 128]]}}}, {"text": "Have a look at the java.util.concurrent javadoc as there are heaps of examples in there", "label": {"api": {"java.util.concurrent": [[19, 38]]}}}, {"text": "No, the contract for Map clearly states", "label": {"api": {"contract for Map": [[8, 23]]}}}, {"text": "(thus A.charAt(C) - 'a') will help you get rid of the switch", "label": {"api": {"charAt(C)": [[8, 16]]}}}, {"text": "From the documentation for Properties.store", "label": {"api": {"documentation for Properties.store": [[9, 42]]}}}, {"text": "For more info have a look at InputStreamReader#read() that reads a single character", "label": {"api": {"InputStreamReader#read()": [[29, 52]]}}}, {"text": "To do that, you can use SimpleDateFormat to ensure both are in the same format", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "You could either try to synchronize your methods or use something like a ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[73, 89]]}}}, {"text": "Java is case sensitive, you want to use String#format (starts with lowercase f)", "label": {"api": {"String#format": [[40, 52]]}}}, {"text": "You open the ZipFile and use its entries method to get a list of ZipEntry instances", "label": {"api": {"ZipFile": [[13, 19]], "entries": [[33, 39]], "ZipEntry": [[65, 72]]}}}, {"text": "Joda-Time (unless you're on Java 8) - like money, time is a deeply tricky data structure to properly represent (as Java's long-broken Calendar and associated classes prove) and Joda-Time provides a robust and well thought out interface", "label": {"api": {"Java 8": [[28, 33]], "Calendar": [[134, 141]]}}}, {"text": "I don't have your original file to test with but you should have better luck with GZipInputStream", "label": {"api": {"GZipInputStream": [[82, 96]]}}}, {"text": "The Java Reader does not have a readline() method", "label": {"api": {"Reader": [[9, 14]]}}}, {"text": "If you want to do specific parsing of tokens you should use the Scanner", "label": {"api": {"Scanner": [[64, 70]]}}}, {"text": "Scanner has a nextLine() method to grab each line, but throws an Exception if there is no next line", "label": {"api": {"Scanner": [[0, 6]], "nextLine()": [[14, 23]]}}}, {"text": "Therefore you should use Scanner.hasNextLine() for your while condition", "label": {"api": {"Scanner": [[25, 31]], "Scanner.hasNextLine()": [[25, 45]]}}}, {"text": "The BufferedReader does have a readline() method, as used by @natsirun", "label": {"api": {"Reader": [[12, 17]]}}}, {"text": "Although for any file parsing more complicated than line reading you would prefer the Scanner", "label": {"api": {"Scanner": [[86, 92]]}}}, {"text": "And, the Javadoc for UUID goes into great detail to explain when two UUID instances are equivalent", "label": {"api": {"Javadoc for UUID": [[9, 24]]}}}, {"text": "The java.lang.String class doesn't have a .translate() method and thus your code fails to compile", "label": {"api": {"java.lang.String": [[4, 19]]}}}, {"text": "According JApplet java docs method getImage(URL url, String name) should have two parameter", "label": {"api": {"JApplet java docs": [[10, 26]]}}}, {"text": "Looking at the Java docs (Interface HostnameVerifier and Interface TrustManager), I can't tell when its best to use either (though the TrustManager seems more versatile)", "label": {"api": {"Interface HostnameVerifier": [[26, 51]], "Interface TrustManager": [[57, 78]]}}}, {"text": "In Java, you can use LinkedHashMap and LinkedHashSet", "label": {"api": {"LinkedHashMap": [[21, 33]], "LinkedHashSet": [[39, 51]]}}}, {"text": "Here is an example with LinkedHashMap, that prints the entries in the same order as they were inserted into the map", "label": {"api": {"LinkedHashMap": [[24, 36]]}}}, {"text": "But that is rather obsolete, there is the method SwingUtilities.invokeAndWait(r); which does the job of scheduling a Runnable in the EDT and waiting for its completion", "label": {"api": {"SwingUtilities.invokeAndWait(r);": [[49, 80]]}}}, {"text": "With java.util.zip no problem", "label": {"api": {"java.util.zip": [[5, 17]]}}}, {"text": "See the API", "label": {"api": {"API": [[8, 10]]}}}, {"text": "I would set up the processing requirements (all animals must move) into a DelayQueue and process the queue in a separate thread", "label": {"api": {"DelayQueue": [[74, 83]]}}}, {"text": "DelayQueue - An unbounded blocking queue of Delayed elements, in which an element can only be taken when its delay has expired", "label": {"api": {"DelayQueue": [[0, 9]]}}}, {"text": "This method is called subList and exists for both array and linked lists", "label": {"api": {"subList": [[22, 28]], "exists for both array and linked lists": [[34, 71]]}}}, {"text": "If you want to use a dynamic structure take a look to ArrayList that already handle reallocation of the array etc", "label": {"api": {"ArrayList": [[54, 62]]}}}, {"text": "Use Collections.shuffle and save yourself some trouble", "label": {"api": {"Collections.shuffle": [[4, 22]]}}}, {"text": "you may simply parse instead of Scanner", "label": {"api": {"parse": [[15, 19]]}}}, {"text": "Question 1) The JScrollPane methods setVerticalScrollBarPolicy() and setHorizontalScrollBarPolicy() will allow you to force the scrollbars to be always visible", "label": {"api": {"setVerticalScrollBarPolicy()": [[36, 63]], "setHorizontalScrollBarPolicy()": [[69, 98]]}}}, {"text": "If you are more interested in finding a simpler solution for marshalling you can try XMLEncoder or if you are comfortable with JAXP, you can pick any one implementation", "label": {"api": {"XMLEncoder": [[85, 94]]}}}, {"text": "If what you are trying to achieve is just creating a string from an array of strings, you can use Arrays.toString() method", "label": {"api": {"Arrays.toString() method": [[98, 121]]}}}, {"text": "replaceAll(String regex, String replacement)", "label": {"api": {"replaceAll(String regex, String replacement)": [[0, 43]]}}}, {"text": "If the bind fails, but the old instance is not running any more, setting SO_REUSEADDR is likely to help", "label": {"api": {"SO_REUSEADDR": [[73, 84]]}}}, {"text": "I haven't tried anything I'm about to suggest, but the first thing that comes to mind is to make use of Endpoint.setExecutor(Executor)", "label": {"api": {"Endpoint.setExecutor(Executor)": [[104, 133]]}}}, {"text": "One possibility is to create a ThreadFactory that explicitly sets the uncaught exception handler for every thread it creates", "label": {"api": {"ThreadFactory": [[31, 43]]}}}, {"text": "Guava's ThreadFactoryBuilder can help", "label": {"api": {"ThreadFactory": [[8, 20]]}}}, {"text": "Another possibility is to extend ThreadPoolExecutor and override afterExecute(Runnable, Throwable)", "label": {"api": {"ThreadPoolExecutor": [[33, 50]], "afterExecute(Runnable, Throwable)": [[65, 97]]}}}, {"text": "System.getenv(String) is the correct method; there are only \"environment variables\" - Windows applies the \"system\" environment variables to everyone's account, but they aren't differentiable at the application level", "label": {"api": {"System.getenv(String)": [[0, 20]]}}}, {"text": "I invested the issue and it came to know that there is a mismatch between format defined on Windows 7 system and locale retrieved from ServletRequest#getLocale() for Norwegian, Bokmal(Norway)", "label": {"api": {"ServletRequest#getLocale()": [[135, 160]]}}}, {"text": "I have a FileChannel object (which I need so I can apply a FileLock to the file), and I want to write to the file it references using a simple OututStream", "label": {"api": {"FileChannel": [[9, 19]], "OututStream": [[143, 153]]}}}, {"text": "How do I create an OutputStream that writes to a FileChannel", "label": {"api": {"FileChannel": [[49, 59]]}}}, {"text": "FileChannel does not have a suitable factory method", "label": {"api": {"FileChannel": [[0, 10]]}}}, {"text": "The FileOutputStream class does not have a suitable constructor", "label": {"api": {"FileOutputStream": [[4, 19]]}}}, {"text": "The Files class (of Java 7) has no suitable methods", "label": {"api": {"Files": [[4, 8]]}}}, {"text": "The Java API provides suitable factory methods in the Channels class", "label": {"api": {"Channels": [[54, 61]]}}}, {"text": "The factory method newOutputStream(WritableByteChannel) can create an OutputStream for a given FileChannel, as a FileChannel implements WritableByteChannel", "label": {"api": {"newOutputStream(WritableByteChannel)": [[19, 54]]}}}, {"text": "The setIs24HourView method of TimePicker uses the wrapper class Boolean, not the primitive type boolean", "label": {"api": {"Boolean": [[64, 70]]}}}, {"text": "Map is an interface, i.e", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "HashMap is an implementation of that interface", "label": {"api": {"Map": [[4, 6]], "HashMap": [[0, 6]]}}}, {"text": "URL.getContent() probably does not do what you think it does", "label": {"api": {"probably does not do what you think it does": [[17, 59]]}}}, {"text": "You are calling the entrySet() method, which will give you a Set<Entry<String, Integer>>, not a Set<Integer>", "label": {"api": {"the entrySet() method": [[16, 36]]}}}, {"text": "If you want the values, call the values() method, which will return a Collection<Integer>", "label": {"api": {"the values() method": [[29, 47]]}}}, {"text": "Try moving the initialization to a method annotated with @PostConstruct, or if you want to keep HEADER_BEAN_NAMES final, use constructor injection instead", "label": {"api": {"@PostConstruct": [[57, 70]]}}}, {"text": "Second, the getInt, getString etc methods on CallableStatement is used to retrieve output parameters from the stored procedure", "label": {"api": {"CallableStatement": [[45, 61]]}}}, {"text": "Here are the official docs which set out the requirements/standards", "label": {"api": {"official docs": [[13, 25]]}}}, {"text": "Since Random.nextInt(n) returns a number that is less than n, the following will work", "label": {"api": {"Random.nextInt(n)": [[6, 22]]}}}, {"text": "wait() doesn't busy-wait, but it does \"compete in the usual manner with other threads for the right to synchronize on the object\" once notified", "label": {"api": {"\"compete in the usual manner with other threads for the right to synchronize on the object\"": [[38, 128]]}}}, {"text": "I'd suggest you using Iterator, it will allow you to remove the objects while iterating over the list without throwing ConcurrentModification exception", "label": {"api": {"Iterator": [[22, 29]]}}}, {"text": "In general, Vector and Hashtable could be considered deprecated", "label": {"api": {"Vector": [[12, 17]], "Hashtable": [[23, 31]]}}}, {"text": "If you look at the online javadoc for Vector and Hashtable you'll see that they were the original implementation of ArrayList and HashMap, until the Collections framework came along, at which point they were retrofitted to implement interfaces from the Collections framework; this way, old classes that depended on those classes being there would not break", "label": {"api": {"Vector": [[38, 43]], "Hashtable": [[49, 57]]}}}, {"text": "You probably don't need a tutorial for Vector and Hashtable because their behavior is already so similar to classes you're likely to be familiar with, and because they aren't used much any more", "label": {"api": {"Vector": [[39, 44]], "Hashtable": [[50, 58]]}}}, {"text": "As for more info on List, Set, and Map, the online javadoc is a good place to start", "label": {"api": {"good": [[64, 67]], "place": [[69, 73]], "start": [[78, 82]]}}}, {"text": "As mentioned by the JavaDoc of Vector", "label": {"api": {"Vector": [[31, 36]]}}}, {"text": "Unlike the new collection implementations, Vector is synchronized", "label": {"api": {"Vector": [[43, 48]]}}}, {"text": "If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector", "label": {"api": {"Vector": [[94, 99]]}}}, {"text": "If you look at the online API, you'll see that there aren't any publicly available methods that will tell you that", "label": {"api": {"online API": [[19, 28]]}}}, {"text": "For doing so, you need to add some components to your panel, such as, JtextField or JTextArea", "label": {"api": {"JtextField or JTextArea": [[70, 92]]}}}, {"text": "I later discovered that my solution was slow, but another contestant's solution using Point instead was much faster", "label": {"api": {"Point": [[86, 90]]}}}, {"text": "I discovered that Set.contains() on a Set<List<Integer>> (where each List<Integer> is of size 2) is on average about 4.5 times slower than on a Set<Point>, regardless of whether the pair is actually contained in the set", "label": {"api": {"Point": [[148, 152]]}}}, {"text": "I thought the reason could stem from different implementations of hashCode() and additionally implemented a custom Point class that uses List.hashCode()", "label": {"api": {"Point": [[115, 119]]}}}, {"text": "From my understanding, both hashCode() and equals() should perform more or less equivalently on a Point and a List<Integer> of size 2", "label": {"api": {"Point": [[98, 102]]}}}, {"text": "What if we need to lookup tuples of more than two elements, would a custom class similar to Point always be more efficient than a list", "label": {"api": {"Point": [[92, 96]]}}}, {"text": "For relevant information refer the API Documentation", "label": {"api": {"API Documentation": [[35, 51]]}}}, {"text": "You can use the name() method instead of value()", "label": {"api": {"name() method": [[16, 28]]}}}, {"text": "Probably because you're not checking for the SecurityException that mkdirs can throw", "label": {"api": {"SecurityException that mkdirs can throw": [[45, 83]]}}}, {"text": "Scanner#next() returns a next element up to the next instance of the delimiter pattern, which is be default \"\\\\s\", so it read up the next space, not line", "label": {"api": {"Scanner#next()": [[0, 13]]}}}, {"text": "The code you've posted is safe, as the class Class is final and can't be extended and is inexorably tied to the class it represents which means you won't be able to pass it a fake class where getName() returns a custom string, furthermore you cannot have a class name which includes the punctuation necessary to use SQL injection", "label": {"api": {"Class": [[45, 49]]}}}, {"text": "Try Guava's hashCode() method or JDK7's Objects.hash()", "label": {"api": {"Objects.hash()": [[40, 53]]}}}, {"text": "Convert your String to BigInteger and increment it", "label": {"api": {"BigInteger": [[23, 32]]}}}, {"text": "You can call the getContentPane() method of a JFrame, or more generally the getComponents() method of Container (e.g., in the case of java.awt.Frame or java.awt.Dialog windows) and then set it as the content pane of a JInternalFrame", "label": {"api": {"getContentPane()": [[17, 32]], "getComponents()": [[76, 90]]}}}, {"text": "Using the replaceFirst function is one way to go", "label": {"api": {"replaceFirst": [[10, 21]]}}}, {"text": "I would use a java.util.ArrayList instead of a static array", "label": {"api": {"java.util.ArrayList": [[14, 32]]}}}, {"text": "You can use an implementation of the List interface, like ArrayList for this case", "label": {"api": {"ArrayList": [[58, 66]]}}}, {"text": "UnaryOperator<T> - this does exactly this thing", "label": {"api": {"UnaryOperator<T>": [[0, 15]]}}}, {"text": "SimpleDataFormat.parse(String) implementation use only CharSequence methods, length() and charAt(), but defined as defined", "label": {"api": {"SimpleDataFormat.parse(String)": [[0, 29]]}}}, {"text": "Seems there is DateTimeFormatter.parse(CharSequence) method in Java 8's java.time package", "label": {"api": {"DateTimeFormatter.parse(CharSequence)": [[15, 51]]}}}, {"text": "Because a Rectangle2D is a Shape, you may be looking for the AffineTransform method createTransformedShape()", "label": {"api": {"createTransformedShape()": [[84, 107]]}}}, {"text": "Here is some documentation for PrintStream, Scanner, and Stack", "label": {"api": {"PrintStream": [[31, 41]], "Scanner": [[44, 50]], "Stack": [[57, 61]]}}}, {"text": "That can be done by removing the PrintStream above and replacing it as follows", "label": {"api": {"PrintStream": [[33, 43]]}}}, {"text": "Secondly, the way you're currently declaring it uses package access, but the isCancelled method is public, so you'd have to override it with another public method", "label": {"api": {"isCancelled": [[77, 87]]}}}, {"text": "Use a Swing Action", "label": {"api": {"Action": [[12, 17]]}}}, {"text": "See How to use Actions for details on using them in buttons and menu items", "label": {"api": {"Action": [[15, 20]]}}}, {"text": "You can use DatabaseMetaData.getDatabaseProductName as this is implemented by driver vendors.It will give you all the information you need", "label": {"api": {"DatabaseMetaData.getDatabaseProductName": [[12, 50]]}}}, {"text": "Apart from that, I'd also recommend the collections are wrapped with the unmodifiable wrappers (such as Collections.unmodifiableList) and that the elements in them are immutable (but you probably already knew this)", "label": {"api": {"Collections.unmodifiableList": [[104, 131]]}}}, {"text": "The JDK does not appear specify what happens if name is null", "label": {"api": {"JDK": [[4, 6]]}}}, {"text": "The report is tracked as JDK-8136831, and has been fixed in Java 9", "label": {"api": {"JDK": [[25, 27]]}}}, {"text": "Make sure the Map field is private and whenever you return the map from your object so that others can see it make sure you wrap it in a Collections.unmodifiableMap", "label": {"api": {"Collections.unmodifiableMap": [[137, 163]]}}}, {"text": "A java List is an ordered collection of objects, this java.util.List is actually an interface (contract) that defined what a list should behave like", "label": {"api": {"List": [[7, 10], [64, 67]]}}}, {"text": "There are multiple variations (implementations) of List in the java standard JDK, while each is different from the other, they honor the contract defined in List (the ordered aspect for example)", "label": {"api": {"List": [[51, 54], [157, 160]]}}}, {"text": "LinkedList and ArrayList you mentioned are JDK implementations of List", "label": {"api": {"List": [[6, 9], [20, 23], [66, 69]], "LinkedList": [[0, 9]], "ArrayList": [[15, 23]]}}}, {"text": "The class you shared (LinkedIntList) is a custom made structure of objects, that neither part of the JDK, nor implement the java List interface", "label": {"api": {"List": [[31, 34], [129, 132]]}}}, {"text": "This Oracle tutorial explains which APIs to use and how", "label": {"api": {"tutorial": [[12, 19]]}}}, {"text": "I know I can't have repeating groups, but I figured find would work, however it does not work as I expected it to", "label": {"api": {"find": [[52, 55]]}}}, {"text": "Use Arrays.toString() (don't forget to import java.util.Arrays)", "label": {"api": {"Arrays.toString()": [[4, 20]]}}}, {"text": "Arrays don't override toString() (the method that gets called when you try to print an object), so the implementation defaults to that of Object which consists of the class name followed by the hash code", "label": {"api": {"that of Object": [[130, 143]]}}}, {"text": "Is there a way to setup the options of a single nashorn engine instance without using nashorn classes that are not part of the javax.script API", "label": {"api": {"javax.script API": [[127, 142]]}}}, {"text": "Maybe a java BitSet could be useful in that case", "label": {"api": {"BitSet": [[13, 18]]}}}, {"text": "Here's a code sample that uses BitSet of size = 1000000 with a range = 5 to do the check around each values from the first set into the second", "label": {"api": {"BitSet": [[31, 36]]}}}, {"text": "What you want to keep track of is either the KeyCode or KeyChar", "label": {"api": {"KeyCode": [[45, 51]], "KeyChar": [[56, 62]]}}}, {"text": "I am using java.sql.DatabaseMetaData#getTables per this JavaDoc", "label": {"api": {"this JavaDoc": [[51, 62]]}}}, {"text": "Yes, it should work, since javafx.util.Pair properly implements both equals and hashCode", "label": {"api": {"properly implements both equals and hashCode": [[44, 87]]}}}, {"text": "The method setBorder(Border) is provided by JComponent", "label": {"api": {"setBorder(Border)": [[11, 27]], "JComponent": [[44, 53]]}}}, {"text": "A JPanel extends JComponent so it inherits the method", "label": {"api": {"JComponent": [[17, 26]]}}}, {"text": "That code is using the AWT based Panel which does not extend JComponent", "label": {"api": {"JComponent": [[61, 70]]}}}, {"text": "instead of ; in your classpath, see File.pathSeparatorChar for more if your unsure", "label": {"api": {"File.pathSeparatorChar": [[36, 57]]}}}, {"text": "Use Math.round(float number) method http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html#round(float) if you want to round it", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html#round(float)": [[36, 108]]}}}, {"text": "Just like the Java RESTful service API's WebApplicationException, you can add a int member to your MyHttpClientException and set it on the constructor", "label": {"api": {"WebApplicationException": [[41, 63]]}}}, {"text": "You can use a CountDownLatch to wait until a certain number of threads call countDown(), at which point you can then print the running time", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "You'll need to alter your Customer class to take a CountDownLatch object so the countDown() method could be properly called, but once you do that this should work", "label": {"api": {"CountDownLatch": [[51, 64]]}}}, {"text": "You can simply use the constructor overload which takes an append parameter", "label": {"api": {"constructor overload which takes an append parameter": [[23, 74]]}}}, {"text": "Combined with the existing method SwingUtilities.windowForComponent the entire code may look like", "label": {"api": {"SwingUtilities.windowForComponent": [[34, 66]]}}}, {"text": "Note that with the Java 6 Dialog.ModalityType you can configure a Dialog to block all other application’s windows  besides the children of this dialog (APPLICATION_MODAL) or to block the dialog’s parents and their children only (DOCUMENT_MODAL)", "label": {"api": {"Dialog.ModalityType": [[26, 44]]}}}, {"text": "If needed you can always execute System.exit() to force a shut down", "label": {"api": {"System.exit()": [[33, 45]]}}}, {"text": "Looking at the ArrayList API", "label": {"api": {"ArrayList API": [[15, 27]]}}}, {"text": "I would say that this can be done by two linked lists, but found, that Java's LinkedList hides linkage from user", "label": {"api": {"LinkedList": [[78, 87]]}}}, {"text": "EntityManager checks the current persistence context (as a kind of first level cache) before going to the database", "label": {"api": {"EntityManager": [[0, 12]]}}}, {"text": "It provides the method Files.setPosixFilePermissions, which can give you precisely the file permissions you want", "label": {"api": {"Files.setPosixFilePermissions": [[23, 51]]}}}, {"text": "For some reason it throws a BufferUnderflowException in the last line", "label": {"api": {"BufferUnderflowException": [[28, 51]]}}}, {"text": "How can I write a X509TrustManager in Java that used DANE (DNS-based Authentication of Named Entities)", "label": {"api": {"X509TrustManager": [[18, 33]]}}}, {"text": "According to the TitledPane's Substructure, the title is a HBox", "label": {"api": {"TitledPane's Substructure": [[17, 41]]}}}, {"text": "To read the file from the jar, you could use JarURLConnection.getInputStream with the URL you have, or you could call ClassLoader.getResourceAsStream", "label": {"api": {"JarURLConnection.getInputStream": [[45, 75]], "ClassLoader.getResourceAsStream": [[118, 148]]}}}, {"text": "For storing the letters that have already been used consider using a HashSet", "label": {"api": {"HashSet": [[69, 75]]}}}, {"text": "HashSets will only store one copy of anything added to it", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "You're looking for the Float.intBitsToFloat method", "label": {"api": {"Float.intBitsToFloat method": [[23, 49]]}}}, {"text": "The reverse is the Float.floatToIntBits method", "label": {"api": {"Float.floatToIntBits method": [[19, 45]]}}}, {"text": "The closest thing I've found is AsynchronousByteChannel", "label": {"api": {"AsynchronousByteChannel": [[32, 54]]}}}, {"text": "Anyway, it's moot because AsynchronousByteChannel was added in Java 1.7 and is not available on Android", "label": {"api": {"AsynchronousByteChannel": [[26, 48]]}}}, {"text": "You can use a CountDownLatch to wait until a certain number of threads call countDown(), at which point the main thread can then continue", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "The Javadocs for the 2-arg overload of split state", "label": {"api": {"Javadocs for the 2-arg overload of split": [[4, 43]]}}}, {"text": "The Javadocs for the 1-arg overload of split state", "label": {"api": {"Javadocs for the 1-arg overload of split": [[4, 43]]}}}, {"text": "Have a look at Box.createHorizontalStrut(int)", "label": {"api": {"Box.createHorizontalStrut(int)": [[15, 44]]}}}, {"text": "I'm a bit late for the party but Java 1.7 added Objects#requireNonNull", "label": {"api": {"Objects#requireNonNull": [[48, 69]]}}}, {"text": "Try the setHorizontalAlignment() method", "label": {"api": {"setHorizontalAlignment()": [[8, 31]]}}}, {"text": "Your format string (String.format) needs to have a line separator", "label": {"api": {"line separator": [[51, 64]]}}}, {"text": "You should just use Color.YELLOW", "label": {"api": {"Color.YELLOW": [[20, 31]]}}}, {"text": "Like one of the many List implementations such as ArrayList", "label": {"api": {"ArrayList": [[50, 58]]}}}, {"text": "According to the javadoc, PreparedStatement inherits from Statement and the latter contains a getResultSet() method", "label": {"api": {"Statement": [[34, 42], [58, 66]]}}}, {"text": "Or you can wrap the underlying input stream into DataInputStream and just use DataInputStream.readFully() method", "label": {"api": {"DataInputStream.readFully()": [[78, 104]]}}}, {"text": "From the Scanner API", "label": {"api": {"Scanner API": [[9, 19]]}}}, {"text": "You can use javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[12, 28]]}}}, {"text": "The Timer and TimerTask are the right ones, and they will run in the background if you use them something like this", "label": {"api": {"Timer": [[4, 8], [14, 18]], "TimerTask": [[14, 22]]}}}, {"text": "One way is to use the ExecutorService", "label": {"api": {"ExecutorService": [[22, 36]]}}}, {"text": "An array out of bounds exception is thrown to indicate that an array has been accessed with an illegal index", "label": {"api": {"array out of bounds exception": [[3, 31]]}}}, {"text": "This is coming from if (generated.get(round) == 1) because previously you call generated.clear(); which removes all elements of your arraylist", "label": {"api": {"removes all elements of your arraylist": [[104, 141]]}}}, {"text": "Alternatively, you can use ProcessBuilder to give rather more explicit control of various aspects of the process you're starting", "label": {"api": {"ProcessBuilder": [[27, 40]]}}}, {"text": "To get the value of a map entry, you should use the #get method", "label": {"api": {"#get": [[52, 55]]}}}, {"text": "From the FileHandler constructor, you can specify a boolean to specify an append mode", "label": {"api": {"constructor": [[21, 31]]}}}, {"text": "In the ChartPanel class, the getToolTipText(mouseEvent) method is overridden to return the appropriate text for the tooltip, and that's it", "label": {"api": {"getToolTipText(mouseEvent)": [[29, 54]]}}}, {"text": "Swing also gives you the option to override the getToolTipLocation(mouseEvent) method, and that's probably what you need here", "label": {"api": {"getToolTipLocation(mouseEvent)": [[48, 77]]}}}, {"text": "I am testing out the new Stream API in java-8 and want to check the outcome of 10000 random coinflips", "label": {"api": {"API": [[32, 34]]}}}, {"text": "You could make this more Java 8-friendly by creating a Collector", "label": {"api": {"Collector": [[55, 63]]}}}, {"text": "The GridLayout documentation states that..", "label": {"api": {"GridLayout documentation": [[4, 27]]}}}, {"text": "1 Probably it is not exactly while adding the labels but while validating the container, but I don't know all the internal details about how and when layouts do there magic", "label": {"api": {"validating the container": [[63, 86]]}}}, {"text": "If you're using Java 7+, you can use the Files.copy method", "label": {"api": {"Files.copy": [[41, 50]]}}}, {"text": "The compare method returns an int, and its Javadocs states", "label": {"api": {"compare method": [[4, 17]]}}}, {"text": "Add all your possibilities to a static Set, and then call contains() with your input string", "label": {"api": {"Set": [[39, 41]]}}}, {"text": "The parse method's Javadocs state", "label": {"api": {"parse method": [[4, 15]]}}}, {"text": "Before call to drawRect, you can clear the old one calling to clearRect", "label": {"api": {"clearRect": [[62, 70]]}}}, {"text": "String(byte[] bytes, String charsetName)", "label": {"api": {"String(byte[] bytes, String charsetName)": [[0, 39]]}}}, {"text": "You should use Class#newInstance", "label": {"api": {"Class#newInstance": [[15, 31]]}}}, {"text": "The URLConnection you are getting is actually an HttpURLConnection", "label": {"api": {"HttpURLConnection": [[49, 65]]}}}, {"text": "To request that the HttpURLConnection be closed, you should call its disconnect() method", "label": {"api": {"HttpURLConnection": [[20, 36]], "disconnect()": [[69, 80]]}}}, {"text": "The find() method, when successful, will let the matcher yield the information you want", "label": {"api": {"find()": [[4, 9]]}}}, {"text": "group() says something similarly indicative, emphasis mine", "label": {"api": {"group()": [[0, 6]]}}}, {"text": "The cursor of ResultSet is initially positioned before the first record", "label": {"api": {"ResultSet": [[14, 22]]}}}, {"text": "It does, however, provide a getJspConfigDescriptor method to get the <jsp-config> configuration (readonly)", "label": {"api": {"getJspConfigDescriptor": [[28, 49]]}}}, {"text": "We can do slightly better in Java 8, though, using Stream#anyMatch()", "label": {"api": {"Stream#anyMatch()": [[51, 67]]}}}, {"text": "Well depending on your definition of particular string, you can use either the String.matches() function which matches your regular expression against the whole string or Matcher.find() if you want to search for a pattern somewhere within a string", "label": {"api": {"String.matches()": [[79, 94]], "Matcher.find()": [[171, 184]]}}}, {"text": "See the Pattern Javadoc for more information", "label": {"api": {"Pattern Javadoc": [[8, 22]]}}}, {"text": "Simply use Pattern.html#quote(java.lang.String)", "label": {"api": {"Pattern.html#quote(java.lang.String)": [[11, 46]]}}}, {"text": "Modify code for See method using Frame#isUndecorated() that Indicates whether this frame is undecorated", "label": {"api": {"Frame#isUndecorated()": [[33, 53]]}}}, {"text": "PrintStream#printf method is available since Java SE 5", "label": {"api": {"PrintStream#printf": [[0, 17]]}}}, {"text": "The simplest solution is probably ResultSet.getBinaryStream", "label": {"api": {"ResultSet.getBinaryStream": [[34, 58]]}}}, {"text": "But if you want information about length of data, you can also use getBlob", "label": {"api": {"getBlob": [[67, 73]]}}}, {"text": "For example, the HashMap has four constructors", "label": {"api": {"HashMap": [[17, 23]]}}}, {"text": "If you are using the Java Robot class's keyPress and keyRelease methods to script the keyboard, then you probably want KeyEvent.VK_F1 and its siblings in the KeyEvent class", "label": {"api": {"Robot": [[26, 30]], "KeyEvent.VK_F1": [[119, 132]], "KeyEvent": [[119, 126], [158, 165]]}}}, {"text": "If you look at the javadoc for FileOutputStream#write() you'll notice that it only writes out a single byte, which has the range 0-255, inclusive", "label": {"api": {"FileOutputStream#write()": [[31, 54]]}}}, {"text": "The write() method only writes a byte which has a range 0-255, so you won't get anything more than that", "label": {"api": {"write()": [[4, 10]]}}}, {"text": "Better use DataOutputStream and DataInputStream like", "label": {"api": {"DataOutputStream": [[11, 26]], "DataInputStream": [[32, 46]]}}}, {"text": "You might find the functions in the Character class helpful", "label": {"api": {"Character": [[36, 44]]}}}, {"text": "I am implementing my own FilterWriter", "label": {"api": {"FilterWriter": [[25, 36]]}}}, {"text": "Is there one write/append method of the FilterWriter, that will be called for by all the other write/append implementations", "label": {"api": {"FilterWriter": [[40, 51]]}}}, {"text": "From the Java API", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "See the javadoc of FunctionalInterface", "label": {"api": {"javadoc of FunctionalInterface": [[8, 37]]}}}, {"text": "Use GridLayout instead of FlowLayout that fits the components side by side", "label": {"api": {"GridLayout": [[4, 13]]}}}, {"text": "You can try with BoxLayout as well", "label": {"api": {"BoxLayout": [[17, 25]]}}}, {"text": "The LinkedHashSet is ordered by insertion order", "label": {"api": {"LinkedHashSet": [[4, 16]]}}}, {"text": "In cases where you are getting things in order (say from a query in a database) this maintains the order you get them and provides you with O(1) lookup into that (compared with the O(log n) for a TreeSet)", "label": {"api": {"TreeSet": [[196, 202]]}}}, {"text": "The LinkedHashSet is also particularly useful for caches (see also its kin the LinkedHashMap which provides a method for removeEldestEntry which can be used to implement an LRU cache (evicting objects to maintain only the 100 (or whatever its configured for) most recently used items)", "label": {"api": {"LinkedHashSet": [[4, 16]], "LinkedHashMap": [[79, 91]]}}}, {"text": "However, the LinkedHashSet is not a subclass of the interface NavigableSet", "label": {"api": {"LinkedHashSet": [[13, 25]], "NavigableSet": [[62, 73]]}}}, {"text": "To reverse the NavigableSet, you can get the descendingIterator() or descendingSet()", "label": {"api": {"NavigableSet": [[15, 26]]}}}, {"text": "There are two classes that implement the NavigableSet", "label": {"api": {"NavigableSet": [[41, 52]]}}}, {"text": "ConcurrentSkipListSet (which uses a skip list) and TreeSet (which uses a red black tree)", "label": {"api": {"ConcurrentSkipListSet": [[0, 20]], "TreeSet": [[51, 57]]}}}, {"text": "The requirement for a NavigableSet is that the elements have an ordering to them (as implemented by Comparable", "label": {"api": {"NavigableSet": [[22, 33]]}}}, {"text": "These include String, Date, as well as various number classes, and a whole bunch more..", "label": {"api": {"String": [[14, 19]], "Date": [[22, 25]], "whole bunch more": [[69, 84]]}}}, {"text": "It would be better if you append HttpServletRequest#contextPath to your pathin form of Expression Language", "label": {"api": {"HttpServletRequest#contextPath": [[33, 62]]}}}, {"text": "Is your set a SortedSet", "label": {"api": {"SortedSet": [[14, 22]]}}}, {"text": "If there's actually an issue with the window being invisible for too long, then you might want to do something like suggested in @TedHopp's answer, but rather than adding a delay you can just use invokeLater so that the window updates as soon as it's ready instead of always waiting 2.5 seconds", "label": {"api": {"invokeLater": [[196, 206]]}}}, {"text": "That can be accomplished with an entrySet()", "label": {"api": {"entrySet()": [[33, 42]]}}}, {"text": "A Map.Entry<K, V> is a representation of each of your map's key-value pairs, for convenient iteration", "label": {"api": {"Map.Entry<K, V>": [[2, 16]]}}}, {"text": "If you want to do an operation on all of the keys, or all of the values of your map, then this would be the object you want to get from your map (as in, a_enclavement.entrySet())", "label": {"api": {"entrySet()": [[167, 176]]}}}, {"text": "See the Javadoc for Matcher for more information", "label": {"api": {"the Javadoc for Matcher": [[4, 26]]}}}, {"text": "Set layout of the topPanel to GridBagLayout", "label": {"api": {"GridBagLayout": [[30, 42]]}}}, {"text": "Read more about How to Use GridBagLayout for more clarity and find the sample code as well", "label": {"api": {"GridBagLayout": [[27, 39]]}}}, {"text": "Please read more about the other properties of GridBagLayout", "label": {"api": {"GridBagLayout": [[47, 59]]}}}, {"text": "It is really not clear why you are encountering an error without any code, but if you use a Scanner and use the next() method, you will get whitespace ignored for free", "label": {"api": {"Scanner": [[92, 98]]}}}, {"text": "just needed to build a class design for Stack, that could use many data types", "label": {"api": {"Stack": [[40, 44]]}}}, {"text": "By the way, there already is a Stack class in Java Collections API, and you should not have any class with the same name of the Java JDK API", "label": {"api": {"Stack": [[31, 35]]}}}, {"text": "That's why in my example, the stack class is called MyStack", "label": {"api": {"Stack": [[54, 58]]}}}, {"text": "Use BigInteger for arbitrary length integers", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "Rather than call a synchronized method, you are probably better off delivering the result to a java.util.concurrent.BlockingQueue that is a member of the processing object", "label": {"api": {"java.util.concurrent.BlockingQueue": [[95, 128]], "java.util.concurrent": [[95, 114]]}}}, {"text": "Have a look at the java.util.concurrent javadoc as well", "label": {"api": {"java.util.concurrent": [[19, 38]]}}}, {"text": "To get the text in an element (and all of its descendants), use getTextContent() rather than getNodeValue()", "label": {"api": {"getTextContent()": [[64, 79]]}}}, {"text": "Once you have a \"Date\" Object you can use \"getTime\" method (http://docs.oracle.com/javase/7/docs/api/java/util/Date.html#getTime()) to get this milliseconds value, and subtract 60 seconds (make sure to work with milliseconds not seconds!), and create a new \"Date\" with that resulting value", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Date.html#getTime()": [[60, 129]]}}}, {"text": "If the client disconnects, the InputStream.read() operation returns -1 and we take that as notification that the client has \"disconnected\" and the InputStream should be closed", "label": {"api": {"InputStream.read()": [[31, 48]]}}}, {"text": "You can then test Socket.isClosed() to verify whether or not you can still write messages", "label": {"api": {"Socket.isClosed()": [[18, 34]]}}}, {"text": "If using JFrame or extending it you can use setDefaultCloseOperation() method like", "label": {"api": {"setDefaultCloseOperation()": [[44, 69]]}}}, {"text": "This relates to the new java.time API (Tutorial) introduced by Java 8", "label": {"api": {"java.time": [[24, 32]]}}}, {"text": "The API (quite reasonably) distinguishes two different forms of a month name, as defined by java.time.format.TextStyle enum", "label": {"api": {"java.time": [[92, 100]], "java.time.format.TextStyle": [[92, 117]]}}}, {"text": "I was reading through the source code of java.lang.String, specifically getBytes()", "label": {"api": {"getBytes()": [[72, 81]]}}}, {"text": "I'd like to be able to compare it with java.nio.charset.CharsetEncoder.encode(), since that class/method is referenced as an alternative in the String.getBytes() javadoc", "label": {"api": {"getBytes()": [[151, 160]], "java.nio.charset.CharsetEncoder.encode()": [[39, 78]]}}}, {"text": "The difference is that with a CharsetEncoder you can choose how to fail; this is the CodingErrorAction class", "label": {"api": {"CodingErrorAction": [[85, 101]]}}}, {"text": "You can see an example of CodingErrorAction usage at the end of this page", "label": {"api": {"CodingErrorAction": [[26, 42]]}}}, {"text": "I need to know at specific moments, weather my TableView is currently beeing edited or not", "label": {"api": {"TableView": [[47, 55]]}}}, {"text": "I used the editingCellProperty and binded a specific businesslogic to it, to get informed, whenever the table switches these modes", "label": {"api": {"editingCellProperty": [[11, 29]]}}}, {"text": "Unfortunalty the state is not always shown correctly, because I have specific cells (within the same column) which are not supposed to be edited at all, but still when clicked on a noneditable cell a TablePosition is set into the editingCellProperty, hence I get the information, that my TableView is editing, eventhough per condition its been told, that this cell is not editable and the edit mode never really starts", "label": {"api": {"TableView": [[288, 296]], "editingCellProperty": [[230, 248]]}}}, {"text": "I narrowed my problem down to the editCell Method of TableView, since it is not reacting on cell-specific editable-states", "label": {"api": {"TableView": [[53, 61]], "editCell": [[34, 41]]}}}, {"text": "Can anyone tell me the correct way to implement dynamic editable table cells within the same column, while the editingCell-State of TableView will always stay correct", "label": {"api": {"TableView": [[132, 140]]}}}, {"text": "Better yet, use the TimeUnit enum from the JDK", "label": {"api": {"TimeUnit": [[20, 27]]}}}, {"text": "Array copying is extremely fast if you use System.arrayCopy()", "label": {"api": {"System.arrayCopy()": [[43, 60]]}}}, {"text": "It doesn't have to be complicated, though; just iterate over the collection returned by Map#values()", "label": {"api": {"Map#values()": [[88, 99]]}}}, {"text": "To check file is copied to clipboard, you can use Clipboard#hasFiles() method when content of clipboard modified", "label": {"api": {"Clipboard#hasFiles()": [[50, 69]]}}}, {"text": "To check file is being read currently, you can check if the file is locked or not using implementation of FileLock abstract class", "label": {"api": {"FileLock": [[106, 113]]}}}, {"text": "It has acquiredBy() method which returns the channel currently holding the lock on file", "label": {"api": {"acquiredBy()": [[7, 18]]}}}, {"text": "When using BufferedImage, Image, Raster one may get entire arrays of pixel values, for instance BufferImage.getRGB", "label": {"api": {"BufferImage.getRGB": [[96, 113]]}}}, {"text": "Try using java.util.Objects.requireNonNull to please FindBugs", "label": {"api": {"java.util.Objects.requireNonNull": [[10, 41]]}}}, {"text": "Or you might be able to use java.util.Objects.isNull to fool FindBugs", "label": {"api": {"java.util.Objects.isNull": [[28, 51]]}}}, {"text": "The \"contains\" method (see javadoc at http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#contains(java.lang.CharSequence) accepts a \"CharSequent\" as a parameter", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#contains(java.lang.CharSequence)": [[38, 132]]}}}, {"text": "Technically speaking, the + operator in Java implies the use of a StringBuilder object when one of the operands is a string", "label": {"api": {"StringBuilder": [[66, 78]]}}}, {"text": "The Java compiler (not the JVM) translates this syntactic sugar to bytecode instructions that invoke methods of the StringBuilder object to perform the concatenation", "label": {"api": {"StringBuilder": [[116, 128]]}}}, {"text": "As mentioned in other answers to this question, the n + \"\" construct is by no means an efficient way to convert a primitive integer value to a string - using Integer#toString(int) is definitely the recommended way to do this", "label": {"api": {"Integer#toString(int)": [[158, 178]]}}}, {"text": "If you need consistent ordering, you can use LinkedHashMap (for insertion/access order)", "label": {"api": {"LinkedHashMap": [[45, 57]]}}}, {"text": "You might be looking for Collections.sort(rows,comparator), where comparator is your custom Comparator objects, that tells you \"which array is bigger\"", "label": {"api": {"Collections.sort(rows,comparator)": [[25, 57]], "Comparator": [[92, 101]]}}}, {"text": "The implementation of the Comparator is obviously dependent on the order you want", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "Based on the limited information you provide, it sounds like the application is using the Java Preferences API", "label": {"api": {"Java Preferences API": [[90, 109]]}}}, {"text": "Provide a custom Comparator for Collections#sort", "label": {"api": {"Collections#sort": [[32, 47]]}}}, {"text": "ZipOutputStream#closeEntry() closes the current entry in the zip file, and because you only have one entry it isn'y that big of a deal", "label": {"api": {"ZipOutputStream#closeEntry()": [[0, 27]]}}}, {"text": "ZipOutputStream#close() closes the file stream completely, use this when you are done adding stuff to your stream", "label": {"api": {"ZipOutputStream#close()": [[0, 22]]}}}, {"text": "The AWT Desktop#browse method will open a given URL in the current user's default browser in a cross-platform manner", "label": {"api": {"AWT Desktop#browse": [[4, 21]]}}}, {"text": "The approach is actually quite simple, JTable implements CellEditorListener, so we can override the method editingStopped(ChangeEvent) and check if we are in the last cell of the table and if so add a new row", "label": {"api": {"CellEditorListener": [[57, 74]]}}}, {"text": "To exit a JavaFX application, you should call Platform.exit(), not System.exit()", "label": {"api": {"Platform.exit()": [[46, 60]], "System.exit()": [[67, 79]]}}}, {"text": "However, I believe it is best to shutdown the JavaFX platform cleanly so that the Application lifecycle is completed", "label": {"api": {"Application lifecycle": [[82, 102]]}}}, {"text": "One of the major motivations behind the implementations of lambdas in Java 8 were classes/interfaces that were just a wrapper around one function (consider the comparator or the closeable)", "label": {"api": {"comparator": [[160, 169]], "closeable": [[178, 186]]}}}, {"text": "If you take a look at the ButtonGroup, you'll note a few methods of interest..", "label": {"api": {"ButtonGroup": [[26, 36]]}}}, {"text": "see here and In the Docs for more", "label": {"api": {"In the Docs": [[13, 23]]}}}, {"text": "System.out.println(String text); internally calls PrintWriter#println() method and it expect one argument", "label": {"api": {"PrintWriter#println()": [[50, 70]]}}}, {"text": "From PrintWriter#println javadoc, it notes that it takes a single argument", "label": {"api": {"PrintWriter#println": [[5, 23]]}}}, {"text": "You may want to check PrintWriter#printf", "label": {"api": {"PrintWriter#printf": [[22, 39]]}}}, {"text": "If you are using Java 9+, you can use ifPresentOrElse() method", "label": {"api": {"ifPresentOrElse()": [[38, 54]]}}}, {"text": "The closest thing to spawning another thread to sort in is the Arrays#parallelSort() method introduced in Java 8", "label": {"api": {"Arrays#parallelSort()": [[63, 83]]}}}, {"text": "The constructor Date(String s) is deprecated since JDK 1.1, but the principle is the same if you have to use a SimpleDateFormat or you can just write a static method in Java which will return a java.util.Date Object for the String that you pass to it", "label": {"api": {"deprecated since JDK 1.1": [[34, 57]], "SimpleDateFormat": [[111, 126]]}}}, {"text": "You can use the SimpleDateFormat class to parse the date when it is formatted in a different format, for example", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "Creating a Scanner with a String will make the Scanner read the contents of the String, as specified in Scanner(String)", "label": {"api": {"Scanner(String)": [[104, 118]]}}}, {"text": "You need to pass a File to the Scanner constructor, as noted by Scanner(File) to read the contents of the file", "label": {"api": {"Scanner(File)": [[64, 76]]}}}, {"text": "You can look at Throwable.initCause(Throwable cause) which may serve your purpose, but I believe these exceptions were coded specifically for the purpose they indicate", "label": {"api": {"Throwable.initCause(Throwable cause)": [[16, 51]]}}}, {"text": "The question you didn't ask, \"What is a reasonable way to do what I'm trying to do?\", is to use a blocking queue or some other concurrent collection for your jobs collection", "label": {"api": {"blocking queue": [[98, 111]], "some other concurrent collection": [[116, 147]]}}}, {"text": "The CDI class BeanManager has several methods which take parameters of type Annotation or Annotation...", "label": {"api": {"BeanManager": [[14, 24]], "Annotation": [[76, 85], [90, 99]]}}}, {"text": "For example BeanManager.getBeans(...)", "label": {"api": {"BeanManager": [[12, 22]], "BeanManager.getBeans(...)": [[12, 36]]}}}, {"text": "I've tried BeanManager.getBeans(MyBean.class, MyAnnotation.class), but it doesn't work that way", "label": {"api": {"BeanManager": [[11, 21]], "Annotation": [[48, 57]]}}}, {"text": "I've seen Class.isAnnotation(), but there's nothing like Class.asAnnotation() to retrieve it as an Annotation type", "label": {"api": {"Annotation": [[18, 27], [65, 74], [99, 108]]}}}, {"text": "Neither BeanManager.getBeans(MyBean.class, @MyAnnotation) worked, nor did BeanManager.getBeans(MyBean.class, (Annotation) MyAnnotation.class)", "label": {"api": {"BeanManager": [[8, 18], [74, 84]], "Annotation": [[46, 55], [110, 119], [124, 133]]}}}, {"text": "How can I retrieve my annotation class as type Annotation", "label": {"api": {"Annotation": [[47, 56]]}}}, {"text": "Each call to TargetDataLine.read(byte[]) fills only a part of array with remaining part being filled with leftovers from the previous calls, but you are encrypting and sending the whole array each time", "label": {"api": {"TargetDataLine.read(byte[])": [[13, 39]]}}}, {"text": "A call to TargetDataLine.read(byte[]) behaves similar to InputStream.read(byte[]) - it returns the actual number of bytes transferred into the byte array", "label": {"api": {"TargetDataLine.read(byte[])": [[10, 36]], "InputStream.read(byte[])": [[57, 80]]}}}, {"text": "The API docs at http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html didn't help neither", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html": [[16, 92]]}}}, {"text": "Use Collections.reverse to reverse the order of elements in a list", "label": {"api": {"Collections.reverse": [[4, 22]]}}}, {"text": "The BigInteger constructor does not understand your 0x prefix", "label": {"api": {"BigInteger constructor": [[4, 25]]}}}, {"text": "You can also use Long.decode(), which does accept a 0x prefix for decoding hex", "label": {"api": {"Long.decode()": [[17, 29]]}}}, {"text": "Be aware of a third type bundled with Java, java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[44, 61]]}}}, {"text": "The serialization methods you're using includes a magic number verification check that it uses to determine whether your data is valid or not", "label": {"api": {"magic number verification check": [[50, 80]]}}}, {"text": "As mentioned in the comments, you can use Method.getModifiers() to determine the modifiers associated with the method", "label": {"api": {"Method.getModifiers()": [[42, 62]]}}}, {"text": "You need to call addInternalFrameListener or addComponentListener on the frame to tell it about your listener", "label": {"api": {"addInternalFrameListener": [[17, 40]], "addComponentListener": [[45, 64]]}}}, {"text": "The javadoc for wait supports this, it says", "label": {"api": {"javadoc for wait": [[4, 19]]}}}, {"text": "There used to be a methods Thread.stop and Thread.suspend that did just that, and they've been deprecated because of those dangers", "label": {"api": {"Thread.stop": [[27, 37]], "Thread.suspend": [[43, 56]]}}}, {"text": "This can be done with much less effort using the DecimalFormat class", "label": {"api": {"DecimalFormat": [[49, 61]]}}}, {"text": "Let it do the rounding for you, which can be described in a pattern and choose the way of rounding by RoundingMode", "label": {"api": {"RoundingMode": [[102, 113]]}}}, {"text": "Instead, you want getParentFile()", "label": {"api": {"getParentFile()": [[18, 32]]}}}, {"text": "If the file is shared between several parts of the code you may want to use a constant monitor to synchronize against it (synchronized (MY_MONITOR_OBJECT) {...}) or use a lock (doc here)", "label": {"api": {"doc here": [[177, 184]]}}}, {"text": "See more info on the JavaDocs for Graphics", "label": {"api": {"JavaDocs for Graphics": [[21, 41]]}}}, {"text": "That said, you can probably implement the same functionality for any parser that supports deserializing into custom objects by using a custom Map class that throws an exception if a duplicate key is encountered, rather than just update the value..", "label": {"api": {"Map": [[142, 144]]}}}, {"text": "As for finding duplicate entries in the list, how about deserializing into a custom LinkedHashSet subclass that throws an exception if a duplicate entry is inserted", "label": {"api": {"LinkedHashSet": [[84, 96]]}}}, {"text": "In Java the Set interface and its implementation is the most generic way to achieve that effect, with HashSet being the most efficient if uniqueness testing is all you need", "label": {"api": {"Set interface": [[12, 24]], "HashSet": [[102, 108]]}}}, {"text": "That said, if you only have a bunch of consecutive integers to test, then a BitSet may be a more suitable alternative", "label": {"api": {"BitSet": [[76, 81]]}}}, {"text": "You are looking for a java.awt.geom.Rectangle2D.Double", "label": {"api": {"java.awt.geom.Rectangle2D.Double": [[22, 53]]}}}, {"text": "You should draw this using Graphics2D", "label": {"api": {"Graphics2D": [[27, 36]]}}}, {"text": "Here's how to convert your Graphics g into a Graphics2D object then draw the rect", "label": {"api": {"Graphics2D": [[45, 54]]}}}, {"text": "Use at Semaphore or similar to make the behviour deterministic", "label": {"api": {"Semaphore": [[7, 15]]}}}, {"text": "Try using Timer class, or Quartz scheduler if you can have external dependencies, rather than coding the scheduling and threading logic in your own application", "label": {"api": {"Timer": [[10, 14]]}}}, {"text": "If you want convert an int for example into string you can use a String Builder", "label": {"api": {"String Builder": [[65, 78]]}}}, {"text": "Use SwingWorker or Foxtrot to implement your long running Task", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "Since you want localized formatting, use the getDateInstance() and getTimeInstance() factory methods of java.text.DateFormat to get formatter objects", "label": {"api": {"getDateInstance()": [[45, 61]], "getTimeInstance()": [[67, 83]]}}}, {"text": "Instead, you should use PreparedStatement's setDate() method, passing in an instance of java.sql.Date", "label": {"api": {"setDate()": [[44, 52]]}}}, {"text": "Then just make such object implement the Comparable interface (http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html) defining your criteria of sorting", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html": [[63, 128]]}}}, {"text": "I have a recommendation for you , rather than using Thread.sleep() try looking into Java Timer class", "label": {"api": {"Timer class": [[89, 99]]}}}, {"text": "Using a SecurityManager you can control access to resources like network, file and others", "label": {"api": {"SecurityManager": [[8, 22]]}}}, {"text": "The API mentions the import at the top", "label": {"api": {"API": [[4, 6]]}}}, {"text": "There is more information on this at the Java API Specification", "label": {"api": {"Java API Specification": [[41, 62]]}}}, {"text": "You should likely implement a FilterReader that does this conversion", "label": {"api": {"FilterReader": [[30, 41]]}}}, {"text": "The equals contract also states that o1.equals(o2) should be true if o1 == o2, so this is a valid optimization", "label": {"api": {"equals contract": [[4, 18]]}}}, {"text": "Use the String.split method to split the words up into an array of words, where each element is a word", "label": {"api": {"String.split": [[8, 19]]}}}, {"text": "And you can use String.toUpperCase() to convert the string to upper case", "label": {"api": {"String.toUpperCase()": [[16, 35]]}}}, {"text": "The type you need is now java.time.LocalDate, added in Java 8", "label": {"api": {"java.time.LocalDate": [[25, 43]]}}}, {"text": "You cannot instantiate a List because is an interface (see List", "label": {"api": {"List": [[25, 28], [59, 62]]}}}, {"text": "You have to use a concrete class that implements List", "label": {"api": {"List": [[49, 52]]}}}, {"text": "For example use a ArrayList", "label": {"api": {"List": [[23, 26]]}}}, {"text": "Using a StringBuilder instead of concatting strings will give you O(n) performance, and with much better constants as well", "label": {"api": {"StringBuilder": [[8, 20]]}}}, {"text": "Note that a StringBuilder offers an efficient append() implementaiton, so you need to append elements to it, and NOT add them at the head of your StringBuilder", "label": {"api": {"StringBuilder": [[12, 24], [146, 158]], "append()": [[46, 53]]}}}, {"text": "You should also reconsider usage of indexOf() - if a characters cannot appear twice at all, consider using a Set<Chatacter> to maintain the list of 'used' characters, if it can appear twice, but not one after the other (for example \"mam\" is valid) - there is really no need for the indexOf() in the first place, just check the last character read", "label": {"api": {"Set<Chatacter>": [[109, 122]]}}}, {"text": "For instance, the javadoc for java.time.DayOfWeek would look better if the constants weren't displayed as FRIDAY, MONDAY, SATURDAY, SUNDAY, THURSDAY TUESDAY, WEDNESDAY..", "label": {"api": {"javadoc for java.time.DayOfWeek": [[18, 48]]}}}, {"text": "JButton subclasses AbstractButton, which has a method, addActionListener", "label": {"api": {"addActionListener": [[55, 71]]}}}, {"text": "Other listners can be added such as mouse listeners", "label": {"api": {"mouse listeners": [[36, 50]]}}}, {"text": "From HashMap's javadoc", "label": {"api": {"HashMap's javadoc": [[5, 21]]}}}, {"text": "A LinkedHashMap would suffice for ordering by insertion order, and a TreeMap may be used when order through a key's comparator is needed", "label": {"api": {"LinkedHashMap": [[2, 14]], "TreeMap": [[69, 75]]}}}, {"text": "But I think it's a little dirty and I wonder if there is any other standard way, using String.format or something similar", "label": {"api": {"String.format": [[87, 99]]}}}, {"text": "You can use Collections.unmodifiableList", "label": {"api": {"Collections.unmodifiableList": [[12, 39]]}}}, {"text": "Also, it's better to use Executors and ExecutorServices when creating threads or running async tasks", "label": {"api": {"Executors": [[25, 33]], "ExecutorServices": [[39, 54]]}}}, {"text": "Don't forget to enclose it in the parenthesis before downcast to int otherwise it will converted to zero always because Math.random() returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0", "label": {"api": {"Math.random()": [[120, 132]]}}}, {"text": "An alternative to type casting, you could just use Random instead", "label": {"api": {"Random": [[51, 56]]}}}, {"text": "You use the Class#getMethod() call for reflection", "label": {"api": {"Class#getMethod()": [[12, 28]]}}}, {"text": "Have you considered using HashSet", "label": {"api": {"HashSet": [[26, 32]]}}}, {"text": "A HashSet can be used to ensure unique values, then simply add the values used in the HashSet if it returns false the value already exists", "label": {"api": {"HashSet": [[2, 8], [86, 92]]}}}, {"text": "You're calling setDate, which uses a java.sql.Date", "label": {"api": {"java.sql.Date": [[37, 49]]}}}, {"text": "You should consider using setTimestamp instead, with a java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[55, 72]]}}}, {"text": "A standard DATE SQL type doesn't have any time information associated with it, so the javadocs for java.sql.Date state", "label": {"api": {"the javadocs for java.sql.Date": [[82, 111]]}}}, {"text": "You'll want to use a java.sql.Timestamp instead", "label": {"api": {"java.sql.Timestamp": [[21, 38]]}}}, {"text": "From Java SE 8 API, description of java.util.function package", "label": {"api": {"java.util.function package": [[35, 60]]}}}, {"text": "It could return false in multithreaded contexts, even with an equals implementation that fulfills the equals contract", "label": {"api": {"equals contract": [[102, 116]]}}}, {"text": "If that doesn't work, and your library can take an input stream, you can try using ClassLoader#getResourceAsStream and pass that to the appropriate constructors/methods", "label": {"api": {"ClassLoader#getResourceAsStream": [[83, 113]]}}}, {"text": "According to the api ForkJoinTask doesn't implement any Callable interface", "label": {"api": {"api": [[17, 19]]}}}, {"text": "You don't actually have an array, you have an ArrayList", "label": {"api": {"List": [[51, 54]]}}}, {"text": "An ArrayList is a resizable implementation of the List interface", "label": {"api": {"List": [[8, 11], [50, 53]]}}}, {"text": "Using asList() will give almost the equivalent of assigning \"default\" values to an array", "label": {"api": {"List": [[8, 11]], "asList()": [[6, 13]]}}}, {"text": "You should also parameterize your ArrayList(s), this basically means you are saying what that ArrayList can hold", "label": {"api": {"List": [[39, 42], [99, 102]]}}}, {"text": "Here you have an ArrayList holding two other ArrayLists", "label": {"api": {"List": [[22, 25], [50, 53]]}}}, {"text": "Also Set is more applicable in this case", "label": {"api": {"Set": [[5, 7]]}}}, {"text": "Set contains no duplicate elements and Set.contains() method works faster then List.contains()", "label": {"api": {"Set": [[0, 2], [39, 41]]}}}, {"text": "But if you want to use Set you should implement both equals() and hashCode() methods", "label": {"api": {"Set": [[23, 25]]}}}, {"text": "Arrays are Objects too, but they don't override Object's toString() method", "label": {"api": {"Object's toString() method": [[48, 73]]}}}, {"text": "Have a look here http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html for the documentation of ProcessBuilder", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html": [[17, 86]]}}}, {"text": "The getfield and putfield bytecodes use symbolic descriptors that encode the class and field name, so you could use a Java agent to add method calls before or after each load and store passing the field name, object and value being loaded/stored", "label": {"api": {"Java agent": [[118, 127]]}}}, {"text": "Based on your comment, sounds like a CyclicBarrier would fit your need exactly", "label": {"api": {"CyclicBarrier": [[37, 49]]}}}, {"text": "CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "From the javadoc for CyclicBarrier#await()", "label": {"api": {"CyclicBarrier": [[21, 33]]}}}, {"text": "Use ProcessBuilder and invoke directory(File) to set the appropriate working directory", "label": {"api": {"directory(File)": [[30, 44]]}}}, {"text": "MethodHandle is an abstraction for code invocation, not the management of state behind the code", "label": {"api": {"MethodHandle": [[0, 11]]}}}, {"text": "Thus the reasoning for thread safety is that it is reliant on the target method that is being actually executed, not the MethodHandle object itself", "label": {"api": {"MethodHandle": [[121, 132]]}}}, {"text": "Note the API documentation says the following about it", "label": {"api": {"API documentation": [[9, 25]]}}}, {"text": "If you're creating a large number of timers, you should consider using a ScheduledExecutorService instead", "label": {"api": {"a ScheduledExecutorService": [[71, 96]]}}}, {"text": "You can do it based on the ListIterator it allows you to go in both directions", "label": {"api": {"ListIterator": [[27, 38]]}}}, {"text": "What you want is try and see whether your filesystem has support for UserDefinedFileAttributeView", "label": {"api": {"UserDefinedFileAttributeView": [[69, 96]]}}}, {"text": "Or you can use ThreadLocal to obtain a value that is specific to each thread", "label": {"api": {"ThreadLocal": [[15, 25]]}}}, {"text": "The problem is that you are basically setting zeile to the same string as zutat1", "label": {"api": {"string": [[64, 69]]}}}, {"text": "You should have a look at the BufferedReader documentation and especially at the readLine method", "label": {"api": {"BufferedReader": [[30, 43]], "readLine": [[81, 88]]}}}, {"text": "You should additionally have a look at the string documentation and check whether or not matches is what you really want to use", "label": {"api": {"string": [[43, 48]]}}}, {"text": "I use PushbackInputStream to look ahead the next byte in a stream (bufferedIn which is a BufferedInputStream) because I want to mark() before some value, and later to rewind prior to it using reset()", "label": {"api": {"PushbackInputStream": [[6, 24]]}}}, {"text": "Ironically PushbackInputStream doesn't support mark/reset..", "label": {"api": {"PushbackInputStream": [[11, 29]]}}}, {"text": "Run across this very interesting but one year old presentation by Brian Goetz - in the slide linked he presents an aggregateBy() method supposedly in the Stream API, which is supposed to aggregate the elements of a list (?) to a map (given a default initial value and a method manipulating the value (for duplicate keys also) - see next slide in the presentation)", "label": {"api": {"Stream API": [[154, 163]]}}}, {"text": "Apparently there is no such method in the Stream API", "label": {"api": {"Stream API": [[42, 51]]}}}, {"text": "The aggregate operation can be done using the Collectors class", "label": {"api": {"Collectors": [[46, 55]]}}}, {"text": "I think that they removed this operation and created the Collectors class instead to have a useful class that contains a lot of reductions that you will use commonly", "label": {"api": {"Collectors": [[57, 66]]}}}, {"text": "It feels a lot like a Collector, which would offer us the ability to do this", "label": {"api": {"Collector": [[22, 30]]}}}, {"text": "Apparently JFrame.setShape has been introduced with JDK7 but was not available in JDK6", "label": {"api": {"JFrame.setShape": [[11, 25]], "JDK6": [[82, 85]]}}}, {"text": "Since none of the methods of FileUtils accept an InputStream we can't use ProgressMonitorInputStream, and I can't see any other way into that API that would give info", "label": {"api": {"ProgressMonitorInputStream": [[74, 99]]}}}, {"text": "I always see people loading an image into a JLabel", "label": {"api": {"JLabel": [[44, 49]]}}}, {"text": "Are there any advantages of using JLabel over Image", "label": {"api": {"JLabel": [[34, 39]], "Image": [[46, 50]]}}}, {"text": "And when I should use Image", "label": {"api": {"Image": [[22, 26]]}}}, {"text": "You could for instance use a Constructor Expression for the first one", "label": {"api": {"Constructor Expression": [[29, 50]]}}}, {"text": "You have use the format property of the java.util.logging.SimpleFormatter to use the logger name instead of the source classname", "label": {"api": {"format": [[17, 22]], "java.util.logging.SimpleFormatter": [[40, 72]], "logger name": [[85, 95]], "source classname": [[112, 127]]}}}, {"text": "Otherwise, you can create a custom formatter and use that extract the information you want to see in the log file", "label": {"api": {"format": [[35, 40], [72, 77]], "formatter": [[35, 43]], "information": [[70, 80]]}}}, {"text": "You need to use ObjectOutputStream.reset() whenever you need to serialize a new version of the same object", "label": {"api": {"ObjectOutputStream.reset()": [[16, 41]]}}}, {"text": "Try with InputStream#skip() that skips over and discards n bytes of data from this input stream", "label": {"api": {"InputStream#skip()": [[9, 26]]}}}, {"text": "Use File#length() that returns the length, in bytes, of the file denoted by this abstract pathname", "label": {"api": {"File#length()": [[4, 16]]}}}, {"text": "If you have FileInputStream, you can get a FileChannel, which will tell you the current position", "label": {"api": {"position": [[88, 95]]}}}, {"text": "If you have a file channel, you could map the rest of the file, which will give you access to the rest of the file as a ByteBuffer", "label": {"api": {"map": [[38, 40]]}}}, {"text": "A common approach is to use http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#Random(long), providing the current time (in milliseconds from Unix epoch) as the seed", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Random.html#Random(long)": [[28, 102]]}}}, {"text": "The documentation for KeyEvent states that VK_0 thru VK_9 are the same as ASCII '0' thru '9' and that VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A)", "label": {"api": {"KeyEvent": [[22, 29]]}}}, {"text": "Just use the Color constructor that takes an int as parameter (the alpha value is defaulted to 255)", "label": {"api": {"constructor": [[19, 29]]}}}, {"text": "For Java, the answer would be to use a FileLock, which maps to the native mechanism of the operating system", "label": {"api": {"FileLock": [[39, 46]]}}}, {"text": "Too archieve your goal you probably want to implement a ServletContextListener", "label": {"api": {"ServletContextListener": [[56, 77]]}}}, {"text": "In this ServletContextListener of yours you can start your own threads of your own liking and keep them running as you please", "label": {"api": {"ServletContextListener": [[8, 29]]}}}, {"text": "You need to register your ServletContextListener in your web.xml file so that it has some effect", "label": {"api": {"ServletContextListener": [[26, 47]]}}}, {"text": "You can use the ResultSet.absolute(int row) method to select the row you want", "label": {"api": {"ResultSet.absolute(int row)": [[16, 42]]}}}, {"text": "Another way to handle the elements multiple times is to use Stream.peek(Consumer)", "label": {"api": {"Stream.peek(Consumer)": [[60, 80]]}}}, {"text": "You can learn a lot of it by studying the documentation of the class AbstractQueuedSynchronizer", "label": {"api": {"documentation of the class AbstractQueuedSynchronizer": [[42, 94]]}}}, {"text": "To call external programms in java you need the java.lang.Runtime package", "label": {"api": {"java.lang.Runtime": [[48, 64]]}}}, {"text": "There is the method getMaxAllowedKeyLength but that may simply return Integer.MAX_VALUE instead of the maximum key size in bits", "label": {"api": {"getMaxAllowedKeyLength": [[20, 41]]}}}, {"text": "In which case you can simply use a Runnable", "label": {"api": {"Runnable": [[35, 42]]}}}, {"text": "Sometimes BigInteger.toByteArray() adds an extra zero byte to its result", "label": {"api": {"BigInteger.toByteArray()": [[10, 33]]}}}, {"text": "The documentation for java.time.temporal.Temporal contains the following note", "label": {"api": {"java.time.temporal.Temporal": [[22, 48]]}}}, {"text": "You can use a CopyOnWriteArrayList from the concurrent collections' package to automatically synchronize access", "label": {"api": {"CopyOnWriteArrayList": [[14, 33]]}}}, {"text": "Otherwise, you may want to go a bit more low-level and experiment with a ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[73, 94]]}}}, {"text": "In Java, such classes can be found inside java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[42, 61]]}}}, {"text": "For your case, you should use CopyOnWriteArrayList class instead of ArrayList", "label": {"api": {"CopyOnWriteArrayList": [[30, 49]]}}}, {"text": "It would be better using a concurrent queue like ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[49, 69]]}}}, {"text": "Now, write a Comparator that comparies Map.Entry values", "label": {"api": {"Comparator": [[13, 22]]}}}, {"text": "You are opening the same file on multiple calls without even the option of appending content", "label": {"api": {"appending content": [[75, 91]]}}}, {"text": "Look at the constants listed in the KeyEvent Javadoc, in particular the ones VK_NUMPAD0 through to VK_NUMPAD9", "label": {"api": {"KeyEvent Javadoc": [[36, 51]]}}}, {"text": "KeyEvent.getKeyLocation() returns the location of a key press", "label": {"api": {"KeyEvent.getKeyLocation()": [[0, 24]]}}}, {"text": "Although the original code generates a 128bit key (AES with KeyGenerator outputs a 128bit key, as per http://docs.oracle.com/javase/7/docs/api/javax/crypto/KeyGenerator.html), it seems to no longer work properly", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/crypto/KeyGenerator.html": [[102, 172]]}}}, {"text": "JMH uses Runtime.exec(String[]) to launch a forked VM", "label": {"api": {"Runtime.exec(String[])": [[9, 30]]}}}, {"text": "They are converted to a XML tree, which is then stored in an instance of the FaceletCache class", "label": {"api": {"FaceletCache": [[77, 88]]}}}, {"text": "You can register an ErrorHandler to deal with the error in your own way if you wish", "label": {"api": {"ErrorHandler": [[20, 31]]}}}, {"text": "The detail message is available from getMessage and usually included in toString and such", "label": {"api": {"getMessage": [[37, 46]]}}}, {"text": "For example, take a look at the declaration of the get(int index) method of the java.util.List interface", "label": {"api": {"get(int index)": [[51, 64]]}}}, {"text": "This <item> element has one child Node", "label": {"api": {"Node": [[34, 37]]}}}, {"text": "They are text nodes (Text) and they contain all the whitespace characters until the next node of a different type", "label": {"api": {"Text": [[21, 24]]}}}, {"text": "When you use a method such as getFirstChild() which returns Node, you will get the first Node whatever its type is", "label": {"api": {"Node": [[60, 63], [89, 92]]}}}, {"text": "It still might not be a document Comment nodes and Processing Instruction nodes also count as children", "label": {"api": {"Comment": [[33, 39]], "Processing Instruction": [[51, 72]]}}}, {"text": "You can do that comparing the node type which you can obtain via the getNodeType() method and the constants in the Node interface which represent node types and skip the nodes which are not elements", "label": {"api": {"Node": [[72, 75], [115, 118]], "getNodeType()": [[69, 81]]}}}, {"text": "You can also use other APIs like DOM4J or JDOM which include extra methods that return child elements, a standard XPath API where you can get a NodeList of elements as the result, or standard DOM methods such as getElementsByTagName which you can call from your context element reference and get all descendant elements from your subtree", "label": {"api": {"Node": [[144, 147]], "getElementsByTagName": [[212, 231]]}}}, {"text": "In your program, you can retrieve the Clothes element node by extracting the iterating on the getChildNodes() node list and getting the first node that has a node type matching Node.ELEMENT_NODE", "label": {"api": {"Node": [[102, 105], [177, 180]]}}}, {"text": "The class implemented is PrivilegedAction", "label": {"api": {"PrivilegedAction": [[25, 40]]}}}, {"text": "However, you should be able to use a SimpleDateFormat like so (untested)", "label": {"api": {"SimpleDateFormat": [[37, 52]]}}}, {"text": "When including characters in HTML, you need to encode them with the URLEncoder class", "label": {"api": {"URLEncoder": [[68, 77]]}}}, {"text": "One option is to implement ServletContextAware, at which point you should have ServletContext available, then you can update your @Scheduled bean - but it doesn't look like ServletContext will provide you with all the info you need", "label": {"api": {"ServletContext": [[27, 40], [79, 92], [173, 186]]}}}, {"text": "Check out the javadocs for HashSets for more information on how they work", "label": {"api": {"HashSets": [[27, 34]]}}}, {"text": "Inside a servlet, use ServletRequest#getParameter", "label": {"api": {"ServletRequest#getParameter": [[22, 48]]}}}, {"text": "You need to parse the integer first use Scanner#nextInt()", "label": {"api": {"Scanner#nextInt()": [[40, 56]]}}}, {"text": "The next method returns a String and it can't be automatically converted to an int", "label": {"api": {"next method returns a String": [[4, 31]]}}}, {"text": "Call nextInt instead", "label": {"api": {"nextInt": [[5, 11]]}}}, {"text": "I'm trying to use the new Concurrency API to inject a ManagedThreadFactory and use it per the Oracle tutorial", "label": {"api": {"ManagedThreadFactory": [[54, 73]]}}}, {"text": "You can either multiply the value by itself or you can call Math.pow(yourValue, 2) for exponentiation", "label": {"api": {"Math.pow(yourValue, 2)": [[60, 81]]}}}, {"text": "FlowLayout(int align) allows you to define justification", "label": {"api": {"FlowLayout(int align)": [[0, 20]]}}}, {"text": "No, the @Transient annotation is not needed, as your AbstractSuperEntity is neither a MappedSuperClass, nor an Entity", "label": {"api": {"MappedSuperClass": [[86, 101]], "Entity": [[66, 71], [111, 116]]}}}, {"text": "Read the documentation of Scanner", "label": {"api": {"Scanner": [[26, 32]]}}}, {"text": "The JDK commes with the java.util.logging package", "label": {"api": {"java.util.logging package": [[24, 48]]}}}, {"text": "getResource() uses the class loader mechanism to load resources so the resources must be in the classpath", "label": {"api": {"getResource()": [[0, 12]]}}}, {"text": "You should use  JPasswordField", "label": {"api": {"JPasswordField": [[16, 29]]}}}, {"text": "Use removeIf() method of Java 8 or safe Iterator#remove() for remove", "label": {"api": {"Iterator#remove()": [[40, 56]]}}}, {"text": "Try with ProcessBuilder", "label": {"api": {"ProcessBuilder": [[9, 22]]}}}, {"text": "You can pass to ProcessBuilder's constructor as many arguments as you want", "label": {"api": {"ProcessBuilder": [[16, 29]]}}}, {"text": "Examples of similar behavior are Integer which implements Comparable<Integer>", "label": {"api": {"Integer": [[33, 39], [69, 75]]}}}, {"text": "compareTo(T o); we must extend the Comparable interface", "label": {"api": {"Comparable interface": [[35, 54]]}}}, {"text": "According to the Java docs for Class#getName() it means the type of the object returned is a primitive long array", "label": {"api": {"Class#getName()": [[31, 45]]}}}, {"text": "Is there any way to use Collector or any better way", "label": {"api": {"Collector": [[24, 32]]}}}, {"text": "A better solution would likely be to call list.contains(newUab) rather than iterating over the list yourself and calling .equals", "label": {"api": {"contains": [[47, 54]]}}}, {"text": "Use (T[], int, int, java.util.Comparator), this will sort the given array (T[]) in the range specified, only the elements from the first int arg to the second int arg", "label": {"api": {"(T[], int, int, java.util.Comparator)": [[4, 40]]}}}, {"text": "DateFormat.getDateTimeInstance() can also have three arguments", "label": {"api": {"DateFormat.getDateTimeInstance()": [[0, 31]]}}}, {"text": "May be you can use URLEncoder, which encodes given string", "label": {"api": {"URLEncoder": [[19, 28]]}}}, {"text": "How about using the TreeModelListener", "label": {"api": {"TreeModelListener": [[20, 36]]}}}, {"text": "If you don't override equals, then Point will inherit equals from Object, which will simply see if it's the same exact object", "label": {"api": {"equals from Object": [[54, 71]]}}}, {"text": "There may also be an issue with case-sensitivity, so you make want to lowercase all your chars with .toLowerCase()", "label": {"api": {".toLowerCase()": [[100, 113]]}}}, {"text": "ArrayBlockingQueue have a single thread pushing items on to the queue which will be blocked while the queue is at capacity", "label": {"api": {"ArrayBlockingQueue": [[0, 17]]}}}, {"text": "Use the javax.swing.SwingWorker to run time-consuming background tasks", "label": {"api": {"javax.swing.SwingWorker": [[8, 30]]}}}, {"text": "There's getHeaderFields() but that returns the headers in the response HTTP message", "label": {"api": {"getHeaderFields()": [[8, 24]]}}}, {"text": "It seems like setRequestProperty() is setting a header, but I'm not sure", "label": {"api": {"setRequestProperty()": [[14, 33]]}}}, {"text": "All lists in java provide an implementation of get, which returns the n'th element in list", "label": {"api": {"get": [[47, 49]]}}}, {"text": "I'm having trouble to find an example of usage of JDBC 4.2 new interfaces DriverAction and SQLType", "label": {"api": {"DriverAction": [[74, 85]], "SQLType": [[91, 97]]}}}, {"text": "What about compareTo", "label": {"api": {"compareTo": [[11, 19]]}}}, {"text": "You can use compareTo but should include a null check as well if you want to be safe", "label": {"api": {"compareTo": [[12, 20]]}}}, {"text": "Note also that when multiplying BigIntegers, use the BigInteger.multiply(BigInteger val) method instead of *", "label": {"api": {"BigInteger.multiply(BigInteger val)": [[53, 87]]}}}, {"text": "using the BigInteger#multiply(...) method", "label": {"api": {"BigInteger#multiply(...) method": [[10, 40]]}}}, {"text": "Also see Comparator for more information on how it should behave", "label": {"api": {"Comparator": [[9, 18]]}}}, {"text": "In web applications, you can use a ServletContextListener which fires when your application is deployed and undeployed", "label": {"api": {"ServletContextListener": [[35, 56]]}}}, {"text": "Since you don't care about the map values, you only need to iterate over the keySet", "label": {"api": {"keySet": [[77, 82]]}}}, {"text": "A Java Web Start app can post data to the server, either using any http client library or manually with URLConnection", "label": {"api": {"URLConnection": [[104, 116]]}}}, {"text": "The Character.getNumericValue method returns an int", "label": {"api": {"Character.getNumericValue method": [[4, 35]]}}}, {"text": "You can store it in ThreadLocal", "label": {"api": {"ThreadLocal": [[20, 30]]}}}, {"text": "ObjectInputStream#read doesn't guarantee it'll read the buffer.length() number of bytes", "label": {"api": {"ObjectInputStream#read": [[0, 21]]}}}, {"text": "This can be simplified using the List.get() from the List interface", "label": {"api": {"List.get()": [[33, 42]]}}}, {"text": "SocketChannel represents a selectable Socket", "label": {"api": {"SocketChannel": [[0, 12]]}}}, {"text": "You then call select() on the Selector to determine if any of the sockets are readable; you can provide a selection time-out if necessary", "label": {"api": {"Selector": [[30, 37]]}}}, {"text": "If you can modify the application you can install your own EventQueue - http://docs.oracle.com/javase/7/docs/api/java/awt/EventQueue.html#push(java.awt.EventQueue) - processing UI events and paint requests", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/EventQueue.html#push(java.awt.EventQueue)": [[72, 162]]}}}, {"text": "What you need to do is to override the default implementation of the .toString() method in the objects you want to print out", "label": {"api": {".toString()": [[69, 79]]}}}, {"text": "If your client is pure request/response, does not issue unrelated requests separately, and you want your application thread to process responses sequentially, then you could use a SynchronousQueue to coordinate responses with allowing the main thread to continue", "label": {"api": {"SynchronousQueue": [[180, 195]]}}}, {"text": "Instead, you need to use an iterator", "label": {"api": {"iterator": [[28, 35]]}}}, {"text": "Creating a DefaultStyledDocument in a separate thread from constructing the GUI seems to be the fastest way to create a huge text area", "label": {"api": {"DefaultStyledDocument": [[11, 31]]}}}, {"text": "A DefaultStyledDocument is thread safe", "label": {"api": {"DefaultStyledDocument": [[2, 22]]}}}, {"text": "Here's the code I used to test the DefaultStyledDocument", "label": {"api": {"DefaultStyledDocument": [[35, 55]]}}}, {"text": "See comparator for examples", "label": {"api": {"comparator": [[4, 13]]}}}, {"text": "In such cases it is best do avoid local (hard) references (parameters and temporaries) and GC overhead alltogether by keeping that one, large list along with lightweight sub list views using List.subList() (wrappers, referencing the large backing list) or a plain pair of indexes", "label": {"api": {"List.subList()": [[191, 204]]}}}, {"text": "Use the JAX-RS @Path annotation", "label": {"api": {"@Path": [[15, 19]]}}}, {"text": "You can do it with @XmlAnyElement annotation", "label": {"api": {"@XmlAnyElement": [[19, 32]]}}}, {"text": "Implement the Comparable interface for Employee", "label": {"api": {"Comparable": [[14, 23]]}}}, {"text": "The trick here is to pull the relevant information (i.e., the monthly salary) up to a base class (Employee), so you can write a Comparator for it", "label": {"api": {"Comparator": [[128, 137]]}}}, {"text": "Now that all Employees expose their salary in a coherent interface, they can be sorted by implementing a Comparator", "label": {"api": {"Comparator": [[105, 114]]}}}, {"text": "Now, to put it all together, we just sort the List with our custom Comparator", "label": {"api": {"Comparator": [[67, 76]]}}}, {"text": "Its because Calender.set requires the arguments in order", "label": {"api": {"Calender.set": [[12, 23]]}}}, {"text": "All the info you should need is in the oracle docs page", "label": {"api": {"oracle docs page": [[39, 54]]}}}, {"text": "From the documentation for Pattern.split(CharSequence)", "label": {"api": {"the documentation for Pattern.split(CharSequence)": [[5, 53]]}}}, {"text": "If you can't use Lists either, I suggest trying to use Math.min, http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html, which would allow you to determine which of them is the next minimum..", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html": [[65, 124]]}}}, {"text": "The SwingWorker.setProgress() function has bounds of 0 and 100, so even though the ProgressMonitor can handle higher max values, the SwingWorker thread is ended by an  IllegalArgumentException when the value reaches 101", "label": {"api": {"SwingWorker.setProgress()": [[4, 28]]}}}, {"text": "FindBugs is right about the potential leak on exception case because setInt and setString are declared to throw 'SQLException'", "label": {"api": {"setInt": [[69, 74]], "setString": [[80, 88]]}}}, {"text": "The JVM only registers all functions inside a shared library if loaded with System.loadLibrary()", "label": {"api": {"System.loadLibrary()": [[76, 95]]}}}, {"text": "Apparently you can do this with a JPopupMenu", "label": {"api": {"JPopupMenu": [[34, 43]]}}}, {"text": "I tried with this class because I knew it had the method show(Component, x, y)", "label": {"api": {"show(Component, x, y)": [[57, 77]]}}}, {"text": "Use the read method with an array of bytes", "label": {"api": {"read": [[8, 11]]}}}, {"text": "It returns the number of bytes read from the array which isnt always the same length as your array so its important you store that number", "label": {"api": {"read": [[31, 34]]}}}, {"text": "Maybe try java.io.RandomAccessFile", "label": {"api": {"java.io.RandomAccessFile": [[10, 33]]}}}, {"text": "Your compilation issue is due to the fact that IntBinaryOperator#applyAsInt(int, int) takes two arguments", "label": {"api": {"IntBinaryOperator#applyAsInt(int, int)": [[47, 84]]}}}, {"text": "As stated in the comments and after looking at the javadoc of IntStream#reduce(int, IntBinaryOperator) , you aren't actually applying a valid reduction", "label": {"api": {"IntStream#reduce(int, IntBinaryOperator)": [[62, 101]]}}}, {"text": "The rename method documents numerous limitations, including the possibility of not being able to move between different file systems", "label": {"api": {"documents": [[18, 26]], "move": [[97, 100]]}}}, {"text": "It also points to the move method on the (new in java 7) Files utility which should be able to do the job", "label": {"api": {"move": [[22, 25]]}}}, {"text": "When we use Scanner.next() to read token there is what we call a delimiter, the default delimiter used in by Scanner is \\p{javaWhitespace}+ , you can get it by calling Scanner.delimiter(), which is any char that validate the Character.isWhitespace(char)", "label": {"api": {"Scanner.delimiter()": [[168, 186]], "Character.isWhitespace(char)": [[225, 252]]}}}, {"text": "you can use a customized delimiter for your Scanner using Scanner.useDelimiter()", "label": {"api": {"Scanner.useDelimiter()": [[58, 79]]}}}, {"text": "Use a TilePane, see the Catwhack program", "label": {"api": {"TilePane": [[6, 13]]}}}, {"text": "As you can see on the Java APIs both components are subclasses of JTextComponent, and thus inherit getText() and setText() methods", "label": {"api": {"Java APIs": [[22, 30]]}}}, {"text": "Use Thread#join() so that main thread waits for all the other threads to die before executing the last line of the main thread", "label": {"api": {"Thread#join()": [[4, 16]]}}}, {"text": "format has been a member method of String since Java 1.5", "label": {"api": {"format": [[0, 5]]}}}, {"text": "In Java 7, Deflater has added support for some compression parameters (modes", "label": {"api": {"Deflater": [[11, 18]]}}}, {"text": "Specifically, I'd wish to tell the Deflater object the following", "label": {"api": {"Deflater": [[35, 42]]}}}, {"text": "If so, you might be able to use System.nanoTime", "label": {"api": {"System.nanoTime": [[32, 46]]}}}, {"text": "charAt() returns a char value at a specific index, which is a two-byte unicode value that is, for all intensive purposes, an integer", "label": {"api": {"charAt()": [[0, 7]]}}}, {"text": "With the Deflater (sic) class", "label": {"api": {"Deflater": [[9, 16]]}}}, {"text": "It returns the current session associated with this request, or if the request does not have a session, creates one(more)", "label": {"api": {"more": [[116, 119]]}}}, {"text": "Try with DefaultTreeModel#reload() and invoke this method if you've modified the TreeNodes upon which this model depends", "label": {"api": {"DefaultTreeModel#reload()": [[9, 33]], "DefaultTreeModel": [[9, 24]]}}}, {"text": "I believe you are using DefaultTreeModel for adding and deleting the nodes from JTree as suggested by @MadProgrammer in below comments", "label": {"api": {"DefaultTreeModel": [[24, 39]]}}}, {"text": "For further information and examples that use DefaultTreeModel, see How to Use Trees in The Java Tutorial", "label": {"api": {"DefaultTreeModel": [[46, 61]]}}}, {"text": "Several of the String constructors accepts an offset+length into a byte[] - this eliminates the need to create a new trimmed array before hand", "label": {"api": {"String constructors": [[15, 33]]}}}, {"text": "Here are the standard charset names", "label": {"api": {"standard charset names": [[13, 34]]}}}, {"text": "arrayList.get(int i) method of array list can take argument >=0 and<size() So for Negative value it will generate IndexOutOfBoundsException", "label": {"api": {"arrayList.get(int i)": [[0, 19]]}}}, {"text": "If your question is actually related to Java, you probably want the official Pipe class (courtesy @kajacx)", "label": {"api": {"official Pipe class": [[68, 86]]}}}, {"text": "I suggest you to use PrintWriter instead of BufferedWriter", "label": {"api": {"PrintWriter": [[21, 31]]}}}, {"text": "you can use BufferedWriter#newLine() instead of \\n that writes a line separator", "label": {"api": {"BufferedWriter#newLine()": [[12, 35]]}}}, {"text": "Use the set method to replace the old value with a new one", "label": {"api": {"set": [[8, 10]]}}}, {"text": "If you check the real documentation, you will see the difference between Math.min(int, int) and Math.min(float, float)", "label": {"api": {"Math.min(int, int)": [[73, 90]], "Math.min(float, float)": [[96, 117]]}}}, {"text": "You can manage Resource instantiation yourself overriding Application#getSingletons", "label": {"api": {"Application#getSingletons": [[58, 82]]}}}, {"text": "Call descendingMap and iterate over the entry set from that map", "label": {"api": {"descendingMap": [[5, 17]]}}}, {"text": "You can use Integer.parseInt", "label": {"api": {"Integer.parseInt": [[12, 27]]}}}, {"text": "The remove method will remove an object from array as long as .equals returns true when comparing that object and the object we are asking to remove", "label": {"api": {"remove": [[4, 9], [23, 28], [142, 147]], ".equals": [[62, 68]]}}}, {"text": "You can also always remove just by array index", "label": {"api": {"remove": [[20, 25]], "by array index": [[32, 45]]}}}, {"text": "You can achieve this with substring method", "label": {"api": {"substring": [[26, 34]]}}}, {"text": "You need GridBagLayout in this case instead of GridLayout", "label": {"api": {"GridBagLayout": [[9, 21]]}}}, {"text": "Have a look at How to Use GridBagLayout where it is explained in details along with sample code of below snapshot", "label": {"api": {"GridBagLayout": [[26, 38]]}}}, {"text": "For such a repeating task you could also use a TimerTask", "label": {"api": {"TimerTask": [[47, 55]]}}}, {"text": "Maybe the DefaultHighlighter#setDrawsLayeredHighlights(false) will work", "label": {"api": {"DefaultHighlighter#setDrawsLayeredHighlights(false)": [[10, 60]]}}}, {"text": "The Only reason you are not seeing any interferece between the output result because StringBuffer is synchronized, StringBuilder is not", "label": {"api": {"StringBuffer": [[85, 96]], "StringBuilder": [[115, 127]]}}}, {"text": "Please note that StringBuffer and StringBuilder objects are mutable which means that the value stored in the String object can be changed", "label": {"api": {"StringBuffer": [[17, 28]], "StringBuilder": [[34, 46]]}}}, {"text": "Since StringBuffer is Synchronized, It is safer to use", "label": {"api": {"StringBuffer": [[6, 17]]}}}, {"text": "Below with the introduction of Pattern.quote the code should work", "label": {"api": {"Pattern.quote": [[31, 43]]}}}, {"text": "Anyway, for the code generation in compile time in JDK 7 you can the use the annotation processing API, which is basically a plugin API for javac that you can combine it with some sort of template engine", "label": {"api": {"the annotation processing API": [[73, 101]]}}}, {"text": "Now, that mechanism was superceded by DriverManager discovering drivers in all kinds of other ways", "label": {"api": {"DriverManager": [[38, 50]]}}}, {"text": "for insert (for all DML ) you have to use executeUpdate() method", "label": {"api": {"executeUpdate()": [[42, 56]]}}}, {"text": "The javadocs for the String class reference the .replaceAll() method, which takes the regex and the replacement string as arguments", "label": {"api": {"javadocs for the String class": [[4, 32]]}}}, {"text": "Use String#replaceAll() to match your pattern and do your replacements", "label": {"api": {"replaceAll()": [[11, 22]]}}}, {"text": "Use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "Use MultivalueMap from Oracle or Multimap from Google Guava", "label": {"api": {"MultivalueMap": [[4, 16]]}}}, {"text": "You should switch to executeQuery() This method returns a ResultSet that you will have to evaluate", "label": {"api": {"executeQuery()": [[21, 34]]}}}, {"text": "You need to use the stream filter() function, which takes a Predicate object defining your filtering criteria", "label": {"api": {"filter()": [[27, 34]], "Predicate": [[60, 68]]}}}, {"text": "java.sql.Date stores the date part of your timestamp", "label": {"api": {"java.sql.Date": [[0, 12]]}}}, {"text": "If you want/need to handle both date and time, use java.sql.Timestamp instead", "label": {"api": {"java.sql.Timestamp": [[51, 68]]}}}, {"text": "You can use this method to split string into two parts", "label": {"api": {"method": [[17, 22]]}}}, {"text": "Now, there is a magic subList method", "label": {"api": {"subList": [[22, 28]]}}}, {"text": "Don't use a Timer use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[24, 47]]}}}, {"text": "You should probably use ColorConvertOp", "label": {"api": {"ColorConvertOp": [[24, 37]]}}}, {"text": "In your HTML you should have a <FORM> element around your inputs and submit button with an action attribute, the URL that is in that attribute needs to map to a class that extends HttpServlet, it will commonly have one of two methods, doGet() for HTTP Get Requests and doPost() for HTTP Post requests", "label": {"api": {"HttpServlet": [[180, 190]]}}}, {"text": "A subclass of HttpServlet must override at least one method, usually one of these", "label": {"api": {"HttpServlet": [[14, 24]]}}}, {"text": "These methods accept two arguments the first one being a variable of type HttpServletRequest, this variable has a method called getParameter() that will let you pull out values from the request by their input name", "label": {"api": {"HttpServlet": [[74, 84]], "HttpServletRequest": [[74, 91]], "getParameter()": [[128, 141]]}}}, {"text": "For your use case you may also look at the ExecutorCompletionService executor", "label": {"api": {"ExecutorCompletionService executor": [[43, 76]]}}}, {"text": "For example have a look at java.util.List#add, 4 unchecked exceptions just there", "label": {"api": {"java.util.List#add": [[27, 44]]}}}, {"text": "You're getting an exception because the radix you're providing is greater than Character.MAX_RADIX (which is 36)", "label": {"api": {"Character.MAX_RADIX": [[79, 97]]}}}, {"text": "Or, if the status should always change to true in the near future, use a wait-barrier like CountDownLatch to react immediately to a status change", "label": {"api": {"CountDownLatch": [[91, 104]]}}}, {"text": "You need to call HttpCookie.setSecure(true)", "label": {"api": {"HttpCookie.setSecure(true)": [[17, 42]]}}}, {"text": "With the help of Lock#tryLock() (API available since Java 5), we can do it non-blocking", "label": {"api": {"Lock#tryLock()": [[17, 30]]}}}, {"text": "In your case, is System.out.print thread-safe", "label": {"api": {"print": [[28, 32]]}}}, {"text": "Now, the Javadoc for print makes no mention of thread safety", "label": {"api": {"print": [[21, 25]]}}}, {"text": "If so, then take proper precautions to prevent interleaving of print output", "label": {"api": {"print": [[63, 67]]}}}, {"text": "You can add every single item one by one or you can consider using Collections.addAll", "label": {"api": {"Collections.addAll": [[67, 84]]}}}, {"text": "Try String#matches with regex \\d\\.\\d\\.\\d", "label": {"api": {"String#matches": [[4, 17]]}}}, {"text": "or by using an Executor", "label": {"api": {"Executor": [[15, 22]]}}}, {"text": "Use a BlockingQueue where the master waits (queue.take()) for a worker to place a result (queue.put())", "label": {"api": {"BlockingQueue": [[6, 18]]}}}, {"text": "You might be interested in BitSet and its methods BitSet.valueOf() and BitSet.get()", "label": {"api": {"BitSet": [[27, 32], [50, 55], [71, 76]], "BitSet.valueOf()": [[50, 65]], "BitSet.get()": [[71, 82]]}}}, {"text": "Have a look at the substring documentation, Basically what it does is, it returns a substring of the string on which it is called, where substring from the index specified by the first parameter and the ends at the second parameter", "label": {"api": {"substring documentation": [[19, 41]]}}}, {"text": "A classic example could be the BufferedInputStream", "label": {"api": {"BufferedInputStream": [[31, 49]]}}}, {"text": "I found that on delete, the method getFrom() contains the starting index of deletion, and the method getRemovedSize() gives the number of deleted elements from that index", "label": {"api": {"getFrom()": [[35, 43]]}}}, {"text": "You can either use regular expressions or you can use String.split()", "label": {"api": {"String.split()": [[54, 67]]}}}, {"text": "Have a look at the docs of JTree.getToolTipText", "label": {"api": {"JTree.getToolTipText": [[27, 46]]}}}, {"text": "You can use String#lastIndexOf(String str), try", "label": {"api": {"String#lastIndexOf(String str)": [[12, 41]]}}}, {"text": "However there is a method you can define in a class that implements KeyListener which is public void keyPress", "label": {"api": {"public void keyPress": [[89, 108]]}}}, {"text": "However, for that you can use Collections.unmodifiableList instead", "label": {"api": {"Collections.unmodifiableList": [[30, 57]]}}}, {"text": "InputStreamReader is generally where this happens", "label": {"api": {"InputStreamReader": [[0, 16]]}}}, {"text": "Each invocation of one of an InputStreamReader's read() methods may cause one or more bytes to be read from the underlying byte-input stream", "label": {"api": {"InputStreamReader": [[29, 45]]}}}, {"text": "But InputStreamReader allows itself wiggle room to read ahead for efficiency, by some indeterminate amount", "label": {"api": {"InputStreamReader": [[4, 20]]}}}, {"text": "I would like to know if there is an existing alternative or how to implement the semantics of java.util.concurrent.locks.Lock#tryLock() before Java 5", "label": {"api": {"java.util.concurrent.locks.Lock#tryLock()": [[94, 134]]}}}, {"text": "You can use String's methods replaceAll() and split together", "label": {"api": {"replaceAll()": [[29, 40]], "split": [[46, 50]]}}}, {"text": "why can't you call Math.abs() before formatting your number", "label": {"api": {"Math.abs()": [[19, 28]]}}}, {"text": "If you really can't use absolute values with Math.abs as mentionned in other answers, you could change the minus sign in the DecimalFormatSymbols of your DecimalFormat", "label": {"api": {"DecimalFormatSymbols": [[125, 144]]}}}, {"text": "Beware that you need to set back the value into your DecimalFormatsince it returns a different instance when calling getDecimalFormatSymbols", "label": {"api": {"DecimalFormatSymbols": [[120, 139]], "getDecimalFormatSymbols": [[117, 139]]}}}, {"text": "You could also use DecimalFormat.setNegativePrefix(\"\") as kdgregory commented", "label": {"api": {"DecimalFormat.setNegativePrefix(\"\")": [[19, 53]]}}}, {"text": "I would guess that EnumSet is what you are looking for", "label": {"api": {"EnumSet": [[19, 25]]}}}, {"text": "There are some layouts, like FlowLayout, which maintain the order of components in the order of addition", "label": {"api": {"FlowLayout": [[29, 38]]}}}, {"text": "Try with this pattern (\\\\d)+|(\\\\D)+ and use Matcher#find() to find the next subsequence of the input sequence that matches the pattern", "label": {"api": {"Matcher#find()": [[44, 57]]}}}, {"text": "here is the javadoc for ScheduledThreadPoolExecutor::scheduleAtFixedRate which specifies", "label": {"api": {"javadoc for ScheduledThreadPoolExecutor::scheduleAtFixedRate": [[12, 71]]}}}, {"text": "Assuming you are using swing, you could take a look at the BorderFactory.createEmptyBorder(int top, int left, int bottom, int right) factory, such as below (taken from here)", "label": {"api": {"BorderFactory.createEmptyBorder(int top, int left, int bottom, int right)": [[59, 131]]}}}, {"text": "Using Java-8  you can do it more easily using List#replaceAll method", "label": {"api": {"List#replaceAll": [[46, 60]]}}}, {"text": "Here is the api documentation", "label": {"api": {"api documentation": [[12, 28]]}}}, {"text": "Since I assume you need a InputStream you can use ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[50, 69]]}}}, {"text": "The StandardFileManager (used by default) offers a getJavaFileObjectsFromFiles() method that provides iteration over all java files found in a given root", "label": {"api": {"StandardFileManager": [[4, 22]]}}}, {"text": "The links above will take you to the JDK sources (in case you actually want to roll your own version after modifying those sources, read this); and to the JavaDoc for StandardFileManager", "label": {"api": {"StandardFileManager": [[167, 185]]}}}, {"text": "Note that the javadoc for NoResultException states", "label": {"api": {"javadoc for NoResultException": [[14, 42]]}}}, {"text": "If you're unsure about the amount of data that will be returned, use getResultList()", "label": {"api": {"getResultList()": [[69, 83]]}}}, {"text": "It is correct that in Java, request.getParameter(\"DATA\") will look in both the query string and posted form data, while in .NET, Request.Form(\"DATA\") only looks at posted form data", "label": {"api": {"request.getParameter(\"DATA\")": [[28, 55]]}}}, {"text": "If you have no interest in how the implementation works but simple want to perform a large integer calculation, you can use Java's BigInteger data type", "label": {"api": {"BigInteger": [[131, 140]]}}}, {"text": "The thing is, they use ImageIcon", "label": {"api": {"ImageIcon": [[23, 31]]}}}, {"text": "Why won't they do directly return new ImageIcon(path, description)", "label": {"api": {"ImageIcon": [[38, 46]]}}}, {"text": "The toCharArray() method of string will return an array of char[] the length of the string", "label": {"api": {"toCharArray()": [[4, 16]]}}}, {"text": "What Window#pack() states", "label": {"api": {"Window#pack()": [[5, 17]]}}}, {"text": "Read more about GridBagConstraints.fill property", "label": {"api": {"GridBagConstraints.fill": [[16, 38]]}}}, {"text": "take a look at JLabel.getText()", "label": {"api": {"JLabel.getText()": [[15, 30]]}}}, {"text": "You can easily check if the char is a letter or not using Character#isLetter", "label": {"api": {"Character#isLetter": [[58, 75]]}}}, {"text": "3) You can use System.setIn and System.setOut to redirect input and output to your own InputStream and OutputStream", "label": {"api": {"System.setIn and System.setOut": [[15, 44]]}}}, {"text": "The Reader's close() documentation probably explains better", "label": {"api": {"Reader": [[4, 9]]}}}, {"text": "The wrappers (like InputStreamReader) usually extend this class for the interfaces without overriding the documentation", "label": {"api": {"Reader": [[30, 35]], "InputStreamReader": [[19, 35]]}}}, {"text": "In case of ObjectOutputStream the case is similar you can check the behaviour in source", "label": {"api": {"ObjectOutputStream": [[11, 28]]}}}, {"text": "You could use SimpleDateFormat, with the format \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\"", "label": {"api": {"SimpleDateFormat": [[14, 29]]}}}, {"text": "But there are also the classes StringBuffer and StringBuilder which represent a mutable string designed for being manipulated", "label": {"api": {"StringBuffer": [[31, 42]], "StringBuilder": [[48, 60]]}}}, {"text": "They even have a native replace(start, end, str) method which does exactly what you are trying to do", "label": {"api": {"replace(start, end, str)": [[24, 47]]}}}, {"text": "The main difference between these two classes is that StringBuffer is thread-safe while StringBuilder is not", "label": {"api": {"StringBuffer": [[54, 65]], "StringBuilder": [[88, 100]]}}}, {"text": "When you don't have multiple threads accessing the same string, use StringBuilder, because it generally performs faster", "label": {"api": {"StringBuilder": [[68, 80]]}}}, {"text": "I would suggest simply using RegEx to read the XML, and get the tag content that you are after", "label": {"api": {"RegEx": [[29, 33]]}}}, {"text": "Regex for xml parsing and In RegEx, I want to find everything between two XML tags just to mention 2 of them", "label": {"api": {"RegEx": [[29, 33]]}}}, {"text": "You can pass the case insensitive order comparator as the argument of one of TreeMap's constructors", "label": {"api": {"constructors": [[87, 98]]}}}, {"text": "You can use indexToLocation() method of JList, for example", "label": {"api": {"indexToLocation()": [[12, 28]]}}}, {"text": "If you are using at least Java EE 7, you can use the parsers in the javax.json package", "label": {"api": {"javax.json": [[68, 77]]}}}, {"text": "You can replace spaces and use equalsIgnoreCase", "label": {"api": {"equalsIgnoreCase": [[31, 46]]}}}, {"text": "If you want instead to check for containment, use contains and toLowerCase", "label": {"api": {"contains": [[50, 57]], "toLowerCase": [[63, 73]]}}}, {"text": "Use replace() to remove spaces, and use toLowerCase() to bring both strings to the same case, then use contains()", "label": {"api": {"replace()": [[4, 12]], "toLowerCase()": [[40, 52]], "contains()": [[103, 112]]}}}, {"text": "You're going to want to call getStackTrace() on the exception object and then use the various getter methods on the StackTraceElement objects in the array that is returned", "label": {"api": {"getStackTrace()": [[29, 43]], "StackTraceElement": [[116, 132]]}}}, {"text": "As noted in the comment, Arrays.parallelSort (from Java 8) is also an option worth considering, since it multi-threads the work (which sort doesn't do, and is certainly quite a bit of effort to do yourself ..", "label": {"api": {"Arrays.parallelSort (from Java 8)": [[25, 57]]}}}, {"text": "Use String#lastIndexOf and String#substring", "label": {"api": {"String#lastIndexOf": [[4, 21]], "String#substring": [[27, 42]]}}}, {"text": "Or use the MessageFormat class", "label": {"api": {"MessageFormat": [[11, 23]]}}}, {"text": "There's an interface called WindowListener that you should implement in your class", "label": {"api": {"WindowListener": [[28, 41]]}}}, {"text": "I would first try memory mapped files, as provided by RandomAccessFile and FileChannel in standard java library", "label": {"api": {"RandomAccessFile": [[54, 69]], "FileChannel": [[75, 85]]}}}, {"text": "Also, don't forget to close the input stream", "label": {"api": {"close": [[22, 26]]}}}, {"text": "The right way, since Java5, is the use of the ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[46, 63]]}}}, {"text": "After CXF uses an ExceptionMapper, it will send the message through the normal outgoing interceptor chain, and not the fault interceptor chain", "label": {"api": {"ExceptionMapper": [[18, 32]]}}}, {"text": "One solution might be setting a value on the CXF Message Exchange from within your ExceptionMapper, e.g", "label": {"api": {"ExceptionMapper": [[83, 97]]}}}, {"text": "You have to use AtomicInteger instead", "label": {"api": {"AtomicInteger": [[16, 28]]}}}, {"text": "Use ProcessBuilder, illustrated here, to execute the required keytool command", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "Threre are other threadpools available, for example the fixed threadpool (newFixedThreadPool), which seems to behave just as the one you use, only without the sceduling", "label": {"api": {"threadpools available": [[17, 37]]}}}, {"text": "You should load the object when the application starts by using ServletContextListener", "label": {"api": {"ServletContextListener": [[64, 85]]}}}, {"text": "Instead, use a real queue that supports concurrent work like BlockingQueue and one of its implementations in java.util.concurrent package", "label": {"api": {"BlockingQueue": [[61, 73]], "java.util.concurrent": [[109, 128]]}}}, {"text": "I recommend using LinkedBlockingQueue", "label": {"api": {"BlockingQueue": [[24, 36]], "LinkedBlockingQueue": [[18, 36]]}}}, {"text": "In case you need to share flags between your threads, it would be better using AtomicBoolean instead of manually synchronizing a primitive boolean field", "label": {"api": {"AtomicBoolean": [[79, 91]]}}}, {"text": "if you will work with concurrent process, it is better to work with classes provided by java.util.concurrent package that already support lock and synchronization out-of-the-box", "label": {"api": {"java.util.concurrent": [[88, 107]]}}}, {"text": "Only AutoCloseable classes can be used in try-with-resources construct, and java 6 BufferedReader is not (java 7 BufferedReader is)", "label": {"api": {"AutoCloseable": [[5, 17]]}}}, {"text": "If v was int[], then Arrays.stream(v) would return an IntStream which contains the sum() method you're looking for", "label": {"api": {"IntStream which contains": [[54, 77]]}}}, {"text": "Read more about Executors.newFixedThreadPool() that creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue", "label": {"api": {"Executors.newFixedThreadPool()": [[16, 45]]}}}, {"text": "Please have a look at ExecutorService to read more about it along with sample code", "label": {"api": {"ExecutorService": [[22, 36]]}}}, {"text": "The retainAll method should do the trick", "label": {"api": {"retainAll": [[4, 12]]}}}, {"text": "For an in-depth explanation, you can either read about the Java Thread class or have a look at this Java Multithreading Tutorial or, for a more technical introduction, there is the Lesson on Concurrency from the \"official\" Java tutorials", "label": {"api": {"Java Thread class": [[59, 75]]}}}, {"text": "The interface Comparable is defined with a type parameter of <T>", "label": {"api": {"The interface Comparable": [[0, 23]]}}}, {"text": "You have to use a Layout Manager to format your UI Component ,you can choose between  the Layout that will help you making a vertical alignement which are Grid Layout  or Box Layout", "label": {"api": {"Grid Layout": [[155, 165]], "Box Layout": [[171, 180]]}}}, {"text": "Simply call the DefaultTableModel#getRowCount() method to get the number of rows", "label": {"api": {"DefaultTableModel#getRowCount()": [[16, 46]]}}}, {"text": "I have a socket connection over which I wish to send XML messages, using the DOM classes (DocumentBuilder et al) to construct and parse the XML documents, and I can't figure out a good way to handle closing the connection while waiting for messages", "label": {"api": {"DocumentBuilder": [[90, 104]]}}}, {"text": "AttributeOverride::name should be the name of property inside embedded class Money", "label": {"api": {"AttributeOverride::name": [[0, 22]]}}}, {"text": "DateFormat#parse() method just convert the String to Date", "label": {"api": {"DateFormat#parse()": [[0, 17]]}}}, {"text": "It you need to print it again in specific format then use DateFormat#format() method", "label": {"api": {"DateFormat#format()": [[58, 76]]}}}, {"text": "Collection.toArray() returns Object[] regardless of the type of E", "label": {"api": {"Collection.toArray()": [[0, 19]]}}}, {"text": "The only available workaround is Collection.toArray(T[]), where you're forced to pass an array with a fixed type, which can then be either be populated or copied", "label": {"api": {"Collection.toArray(T[])": [[33, 55]]}}}, {"text": "Without going into the details, check the package javax.json", "label": {"api": {"javax.json": [[50, 59]]}}}, {"text": "I need the ulp for a given double value, but since I am developing for Codename ONE, ulp(double) is not provided", "label": {"api": {"ulp": [[11, 13], [85, 87]]}}}, {"text": "Does anyone know an efficient algorithm to compute ulp in Java", "label": {"api": {"ulp": [[51, 53]]}}}, {"text": "Check JavaDoc for nextByte method", "label": {"api": {"JavaDoc for nextByte method": [[6, 32]]}}}, {"text": "Now, let's take a look at Writer#write(String) implementation", "label": {"api": {"Writer#write(String)": [[26, 45]]}}}, {"text": "Use Java 8 and the new classes LocalDateTime and DateTimeFormatter to format to a String", "label": {"api": {"LocalDateTime": [[31, 43]], "DateTimeFormatter": [[49, 65]]}}}, {"text": "You need to pass mousePress the result of calling InputEvent.getMaskForButton, like this", "label": {"api": {"InputEvent.getMaskForButton": [[50, 76]]}}}, {"text": "Use String.split() method", "label": {"api": {"String.split()": [[4, 17]]}}}, {"text": "You have to set it to be visible, using setVisible()", "label": {"api": {"setVisible()": [[40, 51]]}}}, {"text": "I think to ensure complete concurrency, a ConcurrentHashMap should be used in any case", "label": {"api": {"ConcurrentHashMap": [[42, 58]]}}}, {"text": "ConcurrentHashMap implements ConcurrentMap", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "For concurrency, look in Java 7 Lock interface", "label": {"api": {"Lock": [[32, 35]]}}}, {"text": "Check this block about Java Lock Example and Concurrency Lock vs synchronized", "label": {"api": {"Lock": [[28, 31], [57, 60]]}}}, {"text": "Consider reading the documentation at http://docs.oracle.com/javase/7/docs/api/java/io/BufferedWriter.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/BufferedWriter.html": [[38, 105]]}}}, {"text": "Pass false to the append parameter to overwrite the file", "label": {"api": {"Pass false to the append parameter": [[0, 33]]}}}, {"text": "If you want to filter a reference array that is not an Object[] you will need to use the toArray method which takes an IntFunction to get an array of the original type as the result", "label": {"api": {"toArray": [[89, 95]]}}}, {"text": "For example, for a JTextField named textFieldName, you can get the text by saying String name = textFieldName.getText(); or you can set the text inside the text field by saying textFieldName.setText(\"This is my custom string.\");", "label": {"api": {"JTextField": [[19, 28]]}}}, {"text": "JComboBox, JTextField, etc", "label": {"api": {"JComboBox": [[0, 8]], "JTextField": [[11, 20]]}}}, {"text": "You're using a writer, and you're calling Writer.write(int)", "label": {"api": {"Writer.write(int)": [[42, 58]]}}}, {"text": "You can then use Field#getAnnotation(Class)  to get a SerializedName instance on which you can call value() to get the name", "label": {"api": {"Field#getAnnotation(Class)": [[17, 42]]}}}, {"text": "You should look into the difference between int which is a primitive type, and Integer, which is a wrapper class in Java", "label": {"api": {"Integer": [[79, 85]]}}}, {"text": "Was it really too much effort to read the Javadoc for PageContext.findAttribute()", "label": {"api": {"PageContext.findAttribute()": [[54, 80]]}}}, {"text": "HashSet) before handling them and check if they are were in the Set before (Set#add return's boolean for that reason)", "label": {"api": {"Set#add": [[76, 82]]}}}, {"text": "Collection add method is declared as", "label": {"api": {"add method": [[11, 20]]}}}, {"text": "There is a method defined in String that returns a boolean value for that purpose already", "label": {"api": {"String": [[29, 34]], "that": [[36, 39], [69, 72]]}}}, {"text": "You can review the methods of String..", "label": {"api": {"String": [[30, 35]]}}}, {"text": "I also tried using a scheduled service which runs a thread that reads messages from the message queue, concatenates them, and appends them to TextArea (textArea.appendText(stringBuilder.toString()))", "label": {"api": {"scheduled service": [[21, 37]]}}}, {"text": "If you want to extract the first instance of the substring (or are sure that there will be only one), you can use the .indexOf(String str) method", "label": {"api": {".indexOf(String str)": [[118, 137]]}}}, {"text": "If you are not required to use an array directly, then you can use a NavigableSet and the ceiling()/floor() methods to get the nearest greater/lesser elements in the set", "label": {"api": {"NavigableSet": [[69, 80]]}}}, {"text": "You have access to the underlying javax.servlet.http.HttpServletResponse via key MessageContext.SERVLET_RESPONSE in your MessageContext", "label": {"api": {"MessageContext.SERVLET_RESPONSE": [[81, 111]]}}}, {"text": "From there you should be able to set the error code and message", "label": {"api": {"error code and message": [[41, 62]]}}}, {"text": "You can also use a sortedmap, or navigablemap which has additonal functionality for filtering a range", "label": {"api": {"navigablemap": [[33, 44]]}}}, {"text": "Check out the full HashMap API here", "label": {"api": {"HashMap API here": [[19, 34]]}}}, {"text": "You can specify a limit for the split function", "label": {"api": {"split": [[32, 36]]}}}, {"text": "I also know about the different possible values of the enumerated type TransactionAttributeType", "label": {"api": {"different possible values": [[22, 46]]}}}, {"text": "If you are developing a java desktop application and use Swing, SwingWorker is a nice way to do time consuming background tasks", "label": {"api": {"SwingWorker": [[64, 74]]}}}, {"text": "ArrayList also implements  Iterable so any thing that implements Iterable can pass in the constructor", "label": {"api": {"ArrayList": [[0, 8]], "Iterable": [[27, 34], [65, 72]]}}}, {"text": "This single constructor can serve the purpose of all type of Iterable classes", "label": {"api": {"Iterable": [[61, 68]]}}}, {"text": "In Java 8 you can use a TextFlow, or use the RichTextFX third-party library", "label": {"api": {"TextFlow": [[24, 31]]}}}, {"text": "You can use Float.floatToRawIntBits to obtain an int consisting of the bits of the given float argument, and then write that via writeIntLE", "label": {"api": {"Float.floatToRawIntBits": [[12, 34]]}}}, {"text": "To read back the float, you can read an int and use Float.intBitsToFloat to obtain the float value from it", "label": {"api": {"Float.intBitsToFloat": [[52, 71]]}}}, {"text": "From the linked documentation for Float.floatToRawIntBits", "label": {"api": {"Float.floatToRawIntBits": [[34, 56]]}}}, {"text": "Another option may be just replacing the dot char by slash using String#replace(char, char)", "label": {"api": {"String#replace(char, char)": [[65, 90]]}}}, {"text": "When I was about to investigate the internal implementation of the BufferedImage class in Java, I came across the DataBuffer", "label": {"api": {"BufferedImage": [[67, 79]], "DataBuffer": [[114, 123]]}}}, {"text": "The DataBuffer is in finally used to save the blank image data, which can only be interpreted with the related ColorModel and SampleModel implementation", "label": {"api": {"DataBuffer": [[4, 13]], "ColorModel": [[111, 120]], "SampleModel": [[126, 136]]}}}, {"text": "However, I do not understand the real purpose of the DataBuffer beside of the fact, that it wraps arrays of the same type with some read and write helpers", "label": {"api": {"DataBuffer": [[53, 62]]}}}, {"text": "Since Java 7, Java provides the StandardCharsets class for getting the Charset object for a few standard character sets", "label": {"api": {"StandardCharsets": [[32, 47]]}}}, {"text": "ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16BE, and UTF-16LE", "label": {"api": {"UTF-8": [[19, 23]]}}}, {"text": "You can check the load status with ImageIcon.getImageLoadStatus()", "label": {"api": {"ImageIcon.getImageLoadStatus()": [[35, 64]]}}}, {"text": "if it returns MediaTracker.ERRORED (the error code is 4) it means you have a problem with the code that loads the image, and you won't be able to serliazie the JPanel without solving that other one issue before", "label": {"api": {"MediaTracker.ERRORED": [[14, 33]]}}}, {"text": "I think, main reason behind solution is Blocking queue's put method internally handles wait-notify protocol; which stops creation of new objects", "label": {"api": {"put": [[57, 59]]}}}, {"text": "You can look at the javadoc (http://docs.oracle.com/javase/7/docs/api/org/xml/sax/helpers/DefaultHandler.html) for more details on the situations where the methods are called, and the descriptions of the parameters", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/org/xml/sax/helpers/DefaultHandler.html": [[29, 108]]}}}, {"text": "In addition to the solution provided by @Mark Rotteveel, you can specify the exact columns you want values returned from by using Connection.prepareStatement(String, String[])", "label": {"api": {"Connection.prepareStatement(String, String[])": [[130, 174]]}}}, {"text": "In this case, if you provide the column name for you primary key, that value will be in the ResultSet returned from Statement.getGeneratedKeys", "label": {"api": {"Statement.getGeneratedKeys": [[116, 141]]}}}, {"text": "You are not adding the JTextArea nor the JTextField to the JFrame", "label": {"api": {"JTextArea": [[23, 31]], "JTextField": [[41, 50]], "JFrame": [[59, 64]]}}}, {"text": "You can do it through the method add which is inherited from Container", "label": {"api": {"Container": [[61, 69]]}}}, {"text": "Use setToolTipText with Button", "label": {"api": {"setToolTipText": [[4, 17]]}}}, {"text": "To iterate over the elements of the linked list you should use iterator() an uses its remove() method to remove elements from the list while iterating over it", "label": {"api": {"iterator()": [[63, 72]], "remove()": [[86, 93]]}}}, {"text": "Quote from the javadoc of Object.wait()", "label": {"api": {"javadoc of Object.wait()": [[15, 38]]}}}, {"text": "When you call lock.wait you \"release ownership of this monitor\"", "label": {"api": {"wait": [[19, 22]]}}}, {"text": "You might consider the method setStackTrace(), for example", "label": {"api": {"setStackTrace()": [[30, 44]]}}}, {"text": "That's precisely what the source of the ActionEvent is for", "label": {"api": {"source": [[26, 31]]}}}, {"text": "The trick here is to use Collections.shuffle(List list)", "label": {"api": {"Collections.shuffle(List list)": [[25, 54]]}}}, {"text": "Maybe the getNumericValue() method of Character is what you are after", "label": {"api": {"getNumericValue()": [[10, 26]]}}}, {"text": "Java hashCode have similar requirement (my highlight)", "label": {"api": {"hashCode": [[5, 12]]}}}, {"text": "Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified", "label": {"api": {"hashCode": [[104, 111]]}}}, {"text": "You can use the function Integer.parseInt(String) which will parse the string argument as a signed decimal integer.", "label": {"api": {"Integer.parseInt(String)": [[25, 48]]}}}, {"text": "Use Runtime to execute the Linux command mount", "label": {"api": {"Runtime": [[4, 10]]}}}, {"text": "Also, rather than define a Normalizer, you can just use the standard IntUnaryOperator functional interface (and call applyAsInt instead of normalize)", "label": {"api": {"IntUnaryOperator": [[69, 84]]}}}, {"text": "First of all, an idea is to look into BufferStrategy as a mechanism to create a more robust and performant game loop", "label": {"api": {"BufferStrategy": [[38, 51]]}}}, {"text": "It seems to me that any scenario where I instantiate a HashMap using an interface for a key-type would work contrary to the idea of the map", "label": {"api": {"HashMap": [[55, 61]]}}}, {"text": "If I put 2 objects of different MyInterface implementations into the map then they will both operate on their own hashCode() implementations and the entire underlying logic of the HashMap no longer makes sense", "label": {"api": {"HashMap": [[180, 186]]}}}, {"text": "So my question is, is there ever a proper time for using interfaces as keys in HashMaps", "label": {"api": {"HashMap": [[79, 85]]}}}, {"text": "You could set a simple timer using Thread.sleep() and then use Job.killJob() to kill the job", "label": {"api": {"Thread.sleep()": [[35, 48]]}}}, {"text": "An unescaped dot will match any character except newlines (though that can be configured using the Pattern.DOTALL flag)", "label": {"api": {"Pattern.DOTALL": [[99, 112]]}}}, {"text": "You can use the replace(CharSequence target, CharSequence replacement) method, which returns a new modified String", "label": {"api": {"replace(CharSequence target, CharSequence replacement)": [[16, 69]]}}}, {"text": "Would java.util.TreeSet help", "label": {"api": {"java.util.TreeSet": [[6, 22]]}}}, {"text": "you haven't needed to do a Class.forName since the service provider mechanism was introduced as detailed in the JavaDoc for DriverManager", "label": {"api": {"DriverManager": [[124, 136]]}}}, {"text": "Yes, this is the documented behaviour", "label": {"api": {"documented behaviour": [[17, 36]]}}}, {"text": "bitLength() is documented as", "label": {"api": {"bitLength() is documented": [[0, 24]]}}}, {"text": "Use a combination of indexOf and substring for a String", "label": {"api": {"indexOf": [[21, 27]], "substring": [[33, 41]]}}}, {"text": "Consider using FileChannel to read your data, as it is Interruptible", "label": {"api": {"FileChannel": [[15, 25]], "Interruptible": [[55, 67]]}}}, {"text": "For instance, you could modify the Servidor class so that it implements Runnable", "label": {"api": {"Runnable": [[72, 79]]}}}, {"text": "The XML file is around 160MB, right now I am sending the XML file by reading as a large String object to the CallableStatement, but its very time/space/resource consuming", "label": {"api": {"CallableStatement": [[109, 125]]}}}, {"text": "The standard JDK list/set implementations extend AbstractList and AbstractSet, respectively, which provide a \"skeletal implementation\" of the List/Set interfaces", "label": {"api": {"AbstractList": [[49, 60]], "AbstractSet": [[66, 76]]}}}, {"text": "So, just by looking at the ArrayList source, for example, you might get the impression that not all methods are implemented, but they are if you also look in AbstractList (and AbstractCollection -- see below)", "label": {"api": {"AbstractList": [[158, 169]], "AbstractCollection": [[176, 193]]}}}, {"text": "Both AbstractList and AbstractSet extend AbstractCollection which implements the Collection interface (again providing a \"skeletal implementation\")", "label": {"api": {"AbstractList": [[5, 16]], "AbstractSet": [[22, 32]], "AbstractCollection": [[41, 58]]}}}, {"text": "Try with SimpleDateFormat to format the date object as per your need", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "getDataSource() returns a javax.sql.DataSource, which as you can see the the Java API docs doesn't give you all that much to do but get a connection from it", "label": {"api": {"javax.sql.DataSource": [[26, 45]]}}}, {"text": "If you won't modify the array, you can create a copy of a range using Arrays.copyOfRange(int\\[\\] original, int from, int to)", "label": {"api": {"Arrays.copyOfRange(int\\[\\] original, int from, int to)": [[70, 123]]}}}, {"text": "Apparently, this is the expected behavior for FixedThreadPools, and I can shut it down by putting pool.shutdown() somewhere", "label": {"api": {"expected behavior": [[24, 40]]}}}, {"text": "It looks like Java 7 has some additional ExecutorServices, in particular, a ForkJoinPool that does what I want (i.e., no need to shutdown() the pool)", "label": {"api": {"ForkJoinPool": [[76, 87]]}}}, {"text": "Java 8 apparently has even more services", "label": {"api": {"even more services": [[22, 39]]}}}, {"text": "Call setTimeZone(TimeZone) before your \"parse\"", "label": {"api": {"setTimeZone(TimeZone)": [[5, 25]]}}}, {"text": "I am not sure that you understand how a CountDownLatch works", "label": {"api": {"CountDownLatch": [[40, 53]]}}}, {"text": "From the Java8 JavaDoc for CountDownLatch", "label": {"api": {"CountDownLatch": [[27, 40]]}}}, {"text": "A CountDownLatch is initialized with a given count", "label": {"api": {"CountDownLatch": [[2, 15]]}}}, {"text": "In your current code, you have a countdown of 1 for your latch (from the first line of your example new CountDownLatch(1);)", "label": {"api": {"CountDownLatch": [[104, 117]]}}}, {"text": "You can use a combination of Math.ceil and Math.floor", "label": {"api": {"Math.ceil": [[29, 37]], "Math.floor": [[43, 52]]}}}, {"text": "Look at JOptionPane.showInputDialog", "label": {"api": {"JOptionPane.showInputDialog": [[8, 34]]}}}, {"text": "Here's a link to the javadoc for that particular version of the method", "label": {"api": {"link to the javadoc": [[9, 27]]}}}, {"text": "Map#containsKey only explains that the implementation should use equals method to compare keys", "label": {"api": {"Map#containsKey": [[0, 14]]}}}, {"text": "This is noted in HashMap#containsKey implementation", "label": {"api": {"Map#containsKey": [[21, 35]]}}}, {"text": "Note that TreeMap#containsKey changes the javadoc to explain it doesn't uses equals method", "label": {"api": {"Map#containsKey": [[14, 28]], "TreeMap#containsKey": [[10, 28]]}}}, {"text": "Swing has it's SwingWorker<T, V> (link), JavaFX has Task<V> (link), Android has AsyncTask<Params, Progress, Result> (link)", "label": {"api": {"link": [[34, 37], [61, 64], [117, 120]]}}}, {"text": "Make a Comparator for each entity class and use Collections.sort() to sort the lists", "label": {"api": {"Comparator": [[7, 16]], "Collections.sort()": [[48, 65]]}}}, {"text": "Your generic base class could define an abstract getComparator() method", "label": {"api": {"Comparator": [[52, 61]]}}}, {"text": "Use Arrays.copyOf to create a new array by copying the old array", "label": {"api": {"Arrays.copyOf": [[4, 16]]}}}, {"text": "The reason you're getting NullPointerExceptions can be explained by the javadoc for Arrays#sort() (emphasis mine)", "label": {"api": {"javadoc for Arrays#sort()": [[72, 96]]}}}, {"text": "You have a List of String you can use either startsWith(String) or contains(CharSequence)", "label": {"api": {"startsWith(String)": [[45, 62]], "contains(CharSequence)": [[67, 88]]}}}, {"text": "Since you are using the parse(String) method of the DateFormat class which is extended by the SimpleDateFormat here is what the javadoc of parse method reads", "label": {"api": {"javadoc of parse method": [[128, 150]]}}}, {"text": "You need to use this constructor", "label": {"api": {"this constructor": [[16, 31]]}}}, {"text": "Use Integer.parseInt(String s, int radix) with a radix = 2 (for binary) to convert String into int and then cast the int to char, like this", "label": {"api": {"Integer.parseInt(String s, int radix)": [[4, 40]]}}}, {"text": "You can use it yourself, via Throwable#addSuppressed", "label": {"api": {"Throwable#addSuppressed": [[29, 51]]}}}, {"text": "Each then...() chaining method of the CompletableFuture class, which implements CompletionStage, accepts a an argument a CompletionStage", "label": {"api": {"CompletionStage": [[80, 94], [121, 135]]}}}, {"text": "In the Javadoc for Connection.close() they say", "label": {"api": {"Connection.close()": [[19, 36]]}}}, {"text": "If I understand this correctly Connection.close() should also release the Statement resources..", "label": {"api": {"Connection.close()": [[31, 48]]}}}, {"text": "If you have any additional methods where more than a simple get/put to the map needs to be synchronized, a ReadWriteLock is a good option to allow concurrent reads", "label": {"api": {"ReadWriteLock": [[107, 119]]}}}, {"text": "So looking at the documentation (never used Python before) it looks like the time.time() method returns seconds since the epoch, while the Java Date object wants milliseconds from the epoch in its constructor", "label": {"api": {"milliseconds from the epoch": [[162, 188]]}}}, {"text": "You can simply use retainAll", "label": {"api": {"retainAll": [[19, 27]]}}}, {"text": "This would be more efficient with sets, but even just with lists, it's simple to use retainAll", "label": {"api": {"retainAll": [[85, 93]]}}}, {"text": "Since DateTime already implements Comparable interface, I would recommend storing the data in a TreeMap instead, and you could use TreeMap#tailMap to get a subtree of the DateTime's that occurs in the desired time", "label": {"api": {"TreeMap#tailMap": [[131, 145]]}}}, {"text": "An easy fix is to replace your ArrayList with a CopyOnWriteArrayList (which is a lot slower), or to use Collections.synchronizedList()", "label": {"api": {"Collections.synchronizedList()": [[104, 133]]}}}, {"text": "it's recomanded to use ProccessBuider when managing params , check  this answer   it may help you", "label": {"api": {"ProccessBuider": [[23, 36]]}}}, {"text": "I need to execute another sorting for an array of 2 Million elements using Arrays.sort(..) method", "label": {"api": {"Arrays.sort(..)": [[75, 89]]}}}, {"text": "I've read the documentation here (http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[34, 96]]}}}, {"text": "See message selectors in Message javadoc", "label": {"api": {"Message javadoc": [[25, 39]]}}}, {"text": "There are some cases in documentation to File.renameTo() when file cannot be moved", "label": {"api": {"File.renameTo()": [[41, 55]]}}}, {"text": "Simply use Calendar class to extract the day, month, year etc", "label": {"api": {"Calendar": [[11, 18]]}}}, {"text": "Use Calendar#get() method to get the specific field from the date object", "label": {"api": {"Calendar": [[4, 11]], "Calendar#get()": [[4, 17]]}}}, {"text": "This class is available from Java 1.7 you can check it there, so you can't use it in earlier versions on Java", "label": {"api": {"you can check it there": [[38, 59]]}}}, {"text": "You should use CASCADE  in your mapping in order to automatically delete relevant records", "label": {"api": {"CASCADE": [[15, 21]]}}}, {"text": "I would suggest you to take another approach such as the String#split method with a regex (crf Alan Moore answer)", "label": {"api": {"String#split": [[57, 68]]}}}, {"text": "It is said in manual, that if child does not implement Scrollable, then JScrollPane rely on preferredSize properties of it's content", "label": {"api": {"said in manual": [[6, 19]]}}}, {"text": "Just check the Java EE API for Stereotype, which explains it", "label": {"api": {"Java EE API for Stereotype": [[15, 40]]}}}, {"text": "One example is the predefined Model annotation", "label": {"api": {"Model": [[30, 34]]}}}, {"text": "Simply use the @Named(\"myname\") annotation", "label": {"api": {"@Named(\"myname\")": [[15, 30]]}}}, {"text": "Look at OutputStreamWriter", "label": {"api": {"OutputStreamWriter": [[8, 25]]}}}, {"text": "This is hinted at in the Charset Javadoc, but not really well explained there", "label": {"api": {"Charset": [[25, 31]]}}}, {"text": "Have you tried using as", "label": {"api": {"as": [[21, 22]]}}}, {"text": "You can do this when the application starts using ServletContextListener", "label": {"api": {"ServletContextListener": [[50, 71]]}}}, {"text": "You could construct a BigDecimal and use stripTrailingZeros()", "label": {"api": {"BigDecimal": [[22, 31]], "stripTrailingZeros()": [[41, 60]]}}}, {"text": "I need an AtomicByteArray for a memory-critical application modeled after Java's AtomicIntegerArray", "label": {"api": {"AtomicIntegerArray": [[81, 98]]}}}, {"text": "My implementation wraps four bytes into an integer and uses the AtomicIntegerArray", "label": {"api": {"AtomicIntegerArray": [[64, 81]]}}}, {"text": "If you are actually parsing user input, you need to use a NumberFormat to parse the data", "label": {"api": {"NumberFormat": [[58, 69]]}}}, {"text": "As per the class hierarchies of JFrame as shown below", "label": {"api": {"Frame": [[33, 37]], "JFrame": [[32, 37]]}}}, {"text": "The method Frame#setBackground() is inherited from Frame and JFrame doesn't do override it", "label": {"api": {"Frame#setBackground()": [[11, 31]], "Frame": [[11, 15], [51, 55], [62, 66]], "JFrame": [[61, 66]]}}}, {"text": "What JFrame states", "label": {"api": {"Frame": [[6, 10]], "JFrame": [[5, 10]]}}}, {"text": "The JFrame class is slightly incompatible with Frame", "label": {"api": {"Frame": [[5, 9], [47, 51]], "JFrame": [[4, 9]]}}}, {"text": "Like all other JFC/Swing top-level containers, a JFrame contains a JRootPane as its only child", "label": {"api": {"Frame": [[50, 54]], "JFrame": [[49, 54]]}}}, {"text": "The content pane provided by the root pane should, as a rule, contain all the non-menu components displayed by the JFrame", "label": {"api": {"Frame": [[116, 120]], "JFrame": [[115, 120]]}}}, {"text": "This is different from the AWT Frame case", "label": {"api": {"Frame": [[31, 35]]}}}, {"text": "You can override default setBackground() of JFrame as shown below", "label": {"api": {"Frame": [[45, 49]], "JFrame": [[44, 49]]}}}, {"text": "Use a TreeMap instead", "label": {"api": {"TreeMap": [[6, 12]]}}}, {"text": "Through its NavigableMap interface, you can perform range operations", "label": {"api": {"NavigableMap": [[12, 23]]}}}, {"text": "As mentioned in this SO answer, getField only works for public fields, but applies to the entire class hierarchy", "label": {"api": {"getField": [[32, 39]]}}}, {"text": "getDeclaredField works for private fields, and will not inspect the class hierarchy; you can think of it as resolving the implementation of the class", "label": {"api": {"getDeclaredField": [[0, 15]]}}}, {"text": "The DefaultTableMode contains a removeRow method", "label": {"api": {"removeRow": [[32, 40]]}}}, {"text": "The official Javadoc states that it is a terminal operation that applies against all elements in the stream", "label": {"api": {"The official Javadoc": [[0, 19]]}}}, {"text": "If you want to gather the results into a single result, you want to use reduction instead", "label": {"api": {"reduction": [[72, 80]]}}}, {"text": "You probably want to use Executors.newCachedThreadPool()", "label": {"api": {"Executors.newCachedThreadPool()": [[25, 55]]}}}, {"text": "StringBufferInputStream is deprecated, because bytes and characters are not the same thing", "label": {"api": {"deprecated": [[27, 36]]}}}, {"text": "The correct classes to use for this are StringReader and StringWriter", "label": {"api": {"StringReader": [[40, 51]], "StringWriter": [[57, 68]]}}}, {"text": "If you want arbitrary precision and you are in Java, you can use BigDecimal", "label": {"api": {"BigDecimal": [[65, 74]]}}}, {"text": "If you want to start some executable from your java application ,then it's recommanded to use ProccessBuilder , where you will avoid the problem of having white space in your path , check this answer it may help you when using ProccessBuilder", "label": {"api": {"ProccessBuilder": [[94, 108], [227, 241]]}}}, {"text": "When you have to open file , browser or any GUI application from your Java program, you can use the Desktop class that invoke the default application in your OS to open the specific file , example", "label": {"api": {"Desktop": [[100, 106]]}}}, {"text": "JFrame extends Component, which is serializable", "label": {"api": {"Component": [[15, 23]]}}}]