[{"text": "In the method wsv() an ArrayList of Student instances is serialized and written to a file using a FileOutputStream", "label": {"api": {"ArrayList": [[23, 31]]}}}, {"text": "In the other method rsv() the same file is read , the same file is read (if the file exists), the content is deserialized using an ObjectInputStream, the result is casted to an ArrayList and returned", "label": {"api": {"ArrayList": [[177, 185]]}}}, {"text": "See the Javadoc of Serializable as an introduction to serialization and deserialization of objects", "label": {"api": {"Serializable": [[19, 30]]}}}, {"text": "You can use either StringBuffer or StringBuilder", "label": {"api": {"StringBuffer": [[19, 30]], "StringBuilder": [[35, 47]]}}}, {"text": "The difference is that StringBuffer is threadsafe", "label": {"api": {"StringBuffer": [[23, 34]]}}}, {"text": "If you use this only inside a method, you'll chose StringBuilder", "label": {"api": {"StringBuilder": [[51, 63]]}}}, {"text": "for strings containing a valid float number, you could use Float.valueOf in Java", "label": {"api": {"Float.valueOf": [[59, 71]]}}}, {"text": "You would need a java agent which can look at annotations on classes and methods as they are loaded and modify their bytecode to add logging", "label": {"api": {"java agent": [[17, 26]]}}}, {"text": "You can implement kind of listeners in Java extending Observable class for the objects you want to observe, and on the listeners, you implement Observer", "label": {"api": {"Observable": [[54, 63]], "Observer": [[144, 151]]}}}, {"text": "You can use PropertyChangeSupport with PropertyChangeListener or use Observer pattern", "label": {"api": {"PropertyChangeSupport": [[12, 32]], "PropertyChangeListener": [[39, 60]]}}}, {"text": "You could use a RandomAccessFile and use the method seek() to come back to first line", "label": {"api": {"RandomAccessFile": [[16, 31]], "seek()": [[52, 57]]}}}, {"text": "This can be done with a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[24, 36]]}}}, {"text": "The main thread can create the CyclicBarrier and give it a Runnable that updates the clock", "label": {"api": {"CyclicBarrier": [[31, 43]]}}}, {"text": "Pass the CyclicBarrier to each thread, which will process the current clock and then call await", "label": {"api": {"CyclicBarrier": [[9, 21]]}}}, {"text": "I made this using a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[20, 32]]}}}, {"text": "To draw a rectangle in the way you suggest you need use of the class AffineTransform", "label": {"api": {"AffineTransform": [[69, 83]]}}}, {"text": "You may use new String(char[] value)` to create String from char array", "label": {"api": {"char array": [[60, 69]]}}}, {"text": "Or, implement Callable which can return a result when it's finished executing", "label": {"api": {"Callable": [[14, 21]]}}}, {"text": "Then you can pass your tasks to ExecutorService.submit() and get back a Future to get() the result of each task's computation when it is done", "label": {"api": {"ExecutorService.submit()": [[32, 55]], "Future": [[72, 77]]}}}, {"text": "From the manual", "label": {"api": {"manual": [[9, 14]]}}}, {"text": "I have a ScheduledExecutorService, which invokes a Runnable periodically via scheduleWithFixedDelay() (could have used scheduleAtFixedRate() instead)", "label": {"api": {"ScheduledExecutorService": [[9, 32]], "Runnable": [[51, 58]], "scheduleWithFixedDelay()": [[77, 100]], "scheduleAtFixedRate()": [[119, 139]]}}}, {"text": "Apparently checked exceptions can't be thrown from a Runnable so would appreciate any guidance on how to choose from the following", "label": {"api": {"Runnable": [[53, 60]]}}}, {"text": "You can use a Callable along with the Future perhaps", "label": {"api": {"Callable": [[14, 21]], "Future": [[38, 43]]}}}, {"text": "GraphicsDevice will give you info on all screen devices", "label": {"api": {"GraphicsDevice": [[0, 13]]}}}, {"text": "Get the GraphicsConfiguration of the JApplet and then pass that to the constructor of your JFrame", "label": {"api": {"GraphicsConfiguration of the JApplet": [[8, 43]], "constructor of your JFrame": [[71, 96]]}}}, {"text": "You would also use that GraphicsConfiguration to get a bounding rectangle for centering", "label": {"api": {"bounding rectangle": [[55, 72]]}}}, {"text": "For centering one can normally use JFrame.setLocationRelativeTo(null)", "label": {"api": {"setLocationRelativeTo(null)": [[42, 68]]}}}, {"text": "I've done this type of animations before using a the PixelGrabber and MemoryImageSource combination", "label": {"api": {"PixelGrabber": [[53, 64]], "MemoryImageSource": [[70, 86]]}}}, {"text": "The rationale is outlined in the JavaDocs for RoundingMode.HALF_UP", "label": {"api": {"RoundingMode.HALF_UP": [[46, 65]]}}}, {"text": "The safest way would be to use Arrays.equals", "label": {"api": {"Arrays.equals": [[31, 43]]}}}, {"text": "LineNumberReader is your friend", "label": {"api": {"LineNumberReader": [[0, 15]]}}}, {"text": "I would advice you to use RandomAccessFile", "label": {"api": {"RandomAccessFile": [[26, 41]]}}}, {"text": "The FileReader constructor can throw a FileNotFoundException which is a checked exception", "label": {"api": {"FileReader constructor": [[4, 25]]}}}, {"text": "You can use Java's Reflection API to query an arbitrary object to see if it has a method named m1 or m2 and then invoke it", "label": {"api": {"Reflection API": [[19, 32]]}}}, {"text": "This may be a legitimate use case for the low-level access afforded to a KeyListener", "label": {"api": {"KeyListener": [[73, 83]]}}}, {"text": "You can open the html file embedding the flash file in an external browser HostServices.showDocument", "label": {"api": {"HostServices.showDocument": [[75, 99]]}}}, {"text": "According to your NPE, check http://docs.oracle.com/javase/6/docs/api/javax/tools/package-summary.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/tools/package-summary.html": [[29, 101]]}}}, {"text": "It sounds like you want a TreeSet", "label": {"api": {"TreeSet": [[26, 32]]}}}, {"text": "Use the 2 argument form of PrintWriter and specify an appropriate character set that allows Hungarian output", "label": {"api": {"PrintWriter": [[27, 37]]}}}, {"text": "I think you're looking for a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[29, 41]]}}}, {"text": "CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "You could solve this even without Wicket by simply implemeting the functionality in sessionCreated() and sessionDestroyed() in your own HttpSessionListener and then adding it like this to your web.xml", "label": {"api": {"HttpSessionListener": [[136, 154]]}}}, {"text": "You can use Scanner with \\n as delimiter, to read line by line", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "This becomes more manageable and easier to understand using the accumulateAndGet or getAndAccumulate introduced in Java 8", "label": {"api": {"accumulateAndGet": [[64, 79]], "getAndAccumulate": [[84, 99]]}}}, {"text": "if you call instrumentation.addTransformer(ClassFileTraIsformer), then you are stating that the transformer does not supports retransforms", "label": {"api": {"addTransformer(ClassFileTraIsformer)": [[28, 63]]}}}, {"text": "You need to call instrumentation.addTransformer(ClassFileTraIsformer, true) and this will make your transformer kick in", "label": {"api": {"addTransformer(ClassFileTraIsformer, true)": [[33, 74]]}}}, {"text": "Coming back to the concrete question, under the hoods, EL resolves variables by PageContext#findAttribute()", "label": {"api": {"PageContext#findAttribute()": [[80, 106]]}}}, {"text": "These are the valid constructors for the class", "label": {"api": {"valid constructors": [[14, 31]]}}}, {"text": "Considering that AttributedString deals with a single string value, passing a list to it doesn't make sense", "label": {"api": {"AttributedString": [[17, 32]]}}}, {"text": "Perhaps you want a list, ie List<AttributedString>", "label": {"api": {"AttributedString": [[33, 48]]}}}, {"text": "In which case, loop over the List<String> calling the String constructor and add to a List<AttributedString>", "label": {"api": {"AttributedString": [[91, 106]]}}}, {"text": "As per the Formatter docs, %d is a conversion for an integral value, which wouldn't work for doubles", "label": {"api": {"Formatter docs": [[11, 24]]}}}, {"text": "You'd be much better off using a Date and using an appropriate formatter for date values", "label": {"api": {"Date": [[33, 36]], "appropriate formatter": [[51, 71]]}}}, {"text": "Classes in the java.lang package do not need to be imported (the compiler acts like they are always imported)", "label": {"api": {"java.lang": [[15, 23]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/io/PrintStream.html for the difference between printing to a stream and writing to it", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/PrintStream.html": [[4, 68]]}}}, {"text": "Have you considered using System.setIn statements", "label": {"api": {"System.setIn": [[26, 37]]}}}, {"text": "Process the bytes from your ByteBuffer up to and including the '\\n', so the buffer's position is the first byte after the '\\n', then call ByteBuffer.compact()", "label": {"api": {"ByteBuffer.compact()": [[138, 157]]}}}, {"text": "That's a perfectly legal implementation", "label": {"api": {"That's a perfectly legal implementation": [[0, 38]]}}}, {"text": "Note that this can also be done more concisely using Arrays.fill", "label": {"api": {"Arrays.fill": [[53, 63]]}}}, {"text": "What is C# equivalent of PrivilegedAction and PrivilegedExceptionAction class of Java", "label": {"api": {"PrivilegedAction": [[25, 40]], "PrivilegedExceptionAction": [[46, 70]]}}}, {"text": "If you don't need a LinkedHaspMap, use a ConcurrentHashMap from the java.util.concurrent package", "label": {"api": {"ConcurrentHashMap": [[41, 57]], "java.util.concurrent": [[68, 87]]}}}, {"text": "Would be nice to have an class Garage implementing a collection of Vehicles", "label": {"api": {"collection": [[53, 62]]}}}, {"text": "Use invokeLater or invokeAndWait to move it forward", "label": {"api": {"invokeLater": [[4, 14]], "invokeAndWait": [[19, 31]]}}}, {"text": "To avoid memory trashing, it is possible to reuse the same Runnable, assigning the wanted progress to the inner field", "label": {"api": {"Runnable": [[59, 66]]}}}, {"text": "Use Collection.addAll(), and a TreeSet, to remove duplicates and keep the result sorted", "label": {"api": {"Collection.addAll()": [[4, 22]], "TreeSet": [[31, 37]]}}}, {"text": "If you do some maths, you will see that (Factorial of 13) 1932053504 * 14 is 27048749056 which is beyond int MAX_VALUE and that's why you are getting wrong result for Factorial of 14", "label": {"api": {"MAX_VALUE": [[109, 117]]}}}, {"text": "arbitrary length) then consider using the BigInteger class which provides an unlimited range", "label": {"api": {"BigInteger": [[42, 51]]}}}, {"text": "The class loader may load any class, but the access rules are enforced on instantiation", "label": {"api": {"may load any class": [[17, 34]]}}}, {"text": "Your Job implementation would then invoke Runtime.exec(...) to launch the shell task, and possibly some Process methods to interact with the task", "label": {"api": {"Runtime.exec(...)": [[42, 58]], "Process": [[104, 110]]}}}, {"text": "As you are going to launch a shell script, rather than directly invoking your shell script with Runtime.exec(...) you should invoke your shell executable  and pass your shell script as parameter", "label": {"api": {"Runtime.exec(...)": [[96, 112]]}}}, {"text": "You can use these settings for your service port", "label": {"api": {"these": [[12, 16]]}}}, {"text": "You should be able, though, to iterate over all declared methods and check on their parameter types to see if they are assignable from your given type to find all methods which are callable with your parameters", "label": {"api": {"parameter types": [[84, 98]], "assignable from": [[119, 133]]}}}, {"text": "actually is assignable from", "label": {"api": {"assignable from": [[12, 26]]}}}, {"text": "If you're simply looking to run several processes with some variable set, then ProcessBuilder allows you to set an environment for processes spawned with it", "label": {"api": {"ProcessBuilder": [[79, 92]], "set an environment": [[108, 125]]}}}, {"text": "As suggested in the comments, just use Future.isDone to check the run status", "label": {"api": {"Future.isDone": [[39, 51]]}}}, {"text": "As for the error handling, a quick glance at the API shows me that you throw two RuntimeExceptions and a ReflectiveOperationException", "label": {"api": {"glance at the API": [[35, 51]]}}}, {"text": "You seem to be under the impression that getElementsByTagName takes an XPath expression", "label": {"api": {"getElementsByTagName": [[41, 60]]}}}, {"text": "If you need to use XPath, you should look at the javax.xml.xpath package", "label": {"api": {"javax.xml.xpath": [[49, 63]]}}}, {"text": "Also keep a Timer property in the ChangeListner", "label": {"api": {"Timer": [[12, 16]]}}}, {"text": "You've created a collection which breaks the contract given by the interface", "label": {"api": {"interface": [[67, 75]]}}}, {"text": "I know that there's JavaCompiler class, but I'm asking something like Reflection.Emit of .NET platform", "label": {"api": {"JavaCompiler": [[20, 31]]}}}, {"text": "And you need to assign the values for BigIntegers and BigDecimals, their methods do nothing on their own, the instances of those classes are immutable", "label": {"api": {"BigInteger": [[38, 47]]}}}, {"text": "For integers, it's generally better to use BigInteger", "label": {"api": {"BigInteger": [[43, 52]]}}}, {"text": "Read the docs for Serializable and the serialization tutorial for a lot more detail", "label": {"api": {"Serializable": [[18, 29]]}}}, {"text": "The \"Comparison to Perl 5\" section of java.util.regex.Pattern lists many differences", "label": {"api": {"java.util.regex.Pattern": [[38, 60]]}}}, {"text": "From the javadoc for Void", "label": {"api": {"javadoc for Void": [[9, 24]]}}}, {"text": "If you need more speed for dense bitsets, you could try using the standard BitSet.toByteArray() method and then use bit-twiddling tricks to reverse the bits in the individual bytes", "label": {"api": {"BitSet.toByteArray()": [[75, 94]]}}}, {"text": "use StringTokenizer's overloaded constructor", "label": {"api": {"StringTokenizer's": [[4, 20]]}}}, {"text": "Another problem is that you seem to execute modification on Swing components out of the event dispatch thread, which is clearly forbidden by Swing's threading policy", "label": {"api": {"Swing's threading policy": [[141, 164]]}}}, {"text": "I don't think that any of the default collections supports that, because then it wouldn't fulfill the contract for Iterable anymore, which says that an iterator got to get to the end sometime", "label": {"api": {"Iterable": [[115, 122]]}}}, {"text": "Both are the same check out Pattern Reluctant quantifiers", "label": {"api": {"Pattern": [[28, 34]]}}}, {"text": "With checkboxes and lines, using some model of a cube (if it's resizable; see below) and no layout manager", "label": {"api": {"checkboxes": [[5, 14]], "lines": [[20, 24]]}}}, {"text": "Have one producer (the main thread) put all the files on a bound blocking queue (see BlockingQueue)", "label": {"api": {"BlockingQueue": [[85, 97]]}}}, {"text": "Note that the formatting of each of these sequences matters, and is documented by the Pattern class", "label": {"api": {"Pattern class": [[86, 98]]}}}, {"text": "You can use the Pattern class to test for regex matches", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "String#replace(char,char) does it and fits for one character", "label": {"api": {"String#replace(char,char)": [[0, 24]]}}}, {"text": "Specifically, something like HttpServletRequest#isUserInRole can return true for roles 'foo' and 'bar' for the same user", "label": {"api": {"HttpServletRequest#isUserInRole": [[29, 59]]}}}, {"text": "you can use substring method", "label": {"api": {"substring": [[12, 20]]}}}, {"text": "You can use the special Void type", "label": {"api": {"Void": [[24, 27]]}}}, {"text": "For this you would have to use a Matcher, and some extra code that loops on the Matcher to find all matches and then creates the array", "label": {"api": {"Matcher": [[33, 39], [80, 86]]}}}, {"text": "You are forgetting to flip the buffer before reading the data, this is why nothing in being written into audioSamples", "label": {"api": {"flip": [[22, 25]]}}}, {"text": "Number is a class type, so the primitive type operators do not apply", "label": {"api": {"Number": [[0, 5]]}}}, {"text": "One way around this would be to handle each primitive type that Number supports separately in the Add method, but I think that defeats what you're trying to accomplish", "label": {"api": {"Number": [[64, 69]]}}}, {"text": "If you look at the Java API, you can note that any subclass of Number has to override a couple of abstract methods; namely, intValue() (as well as others)", "label": {"api": {"Java API": [[19, 26]], "intValue()": [[124, 133]]}}}, {"text": "And while the behavior of the intValue() method may not return an integer representation of the Number, it most certainly does (I looked in the source code for most numbers, including the atomic ones and the math ones)", "label": {"api": {"intValue()": [[30, 39]]}}}, {"text": "The only issue will occur when unexpected behavior is returned from intValue(), which may happen with atomic numbers, user defined Numbers, or when big numbers are forced to shrink", "label": {"api": {"intValue()": [[68, 77]]}}}, {"text": "PrintWriter does not create new file if it does not exist, while FileWriter does", "label": {"api": {"PrintWriter": [[0, 10]], "FileWriter": [[65, 74]]}}}, {"text": "file.isDirectory() and file.isFile()", "label": {"api": {"file.isDirectory()": [[0, 17]], "file.isFile()": [[23, 35]]}}}, {"text": "You may need to use the constructors PrintWriter(File file, String csn) and InputStreamReader(InputStream in, Charset cs) to determine the charset", "label": {"api": {"PrintWriter": [[37, 47]], "PrintWriter(File file, String csn)": [[37, 70]], "InputStreamReader(InputStream in, Charset cs)": [[76, 120]]}}}, {"text": "Populate a DefaultTableModel, as in the following", "label": {"api": {"DefaultTableModel": [[11, 27]]}}}, {"text": "Pass an instance of this to your JTable constructor and you should be golden", "label": {"api": {"JTable": [[33, 38]]}}}, {"text": "This can be solved as an ordinary Java synchronization problem using ReentrantLock", "label": {"api": {"ReentrantLock": [[69, 81]]}}}, {"text": "You can decode it in Java using URLDecoder API", "label": {"api": {"URLDecoder": [[32, 41]]}}}, {"text": "You want to use the following add method of ArrayList, doing the following allows you to place an entry at a specified index", "label": {"api": {"add method": [[30, 39]]}}}, {"text": "The Date and Calendar classes in Java already have a good API to compare dates", "label": {"api": {"Date": [[4, 7]], "Calendar": [[13, 20]]}}}, {"text": "What you're looking for is a form of CriteriaQuery#multiselect ..", "label": {"api": {"CriteriaQuery#multiselect": [[37, 61]]}}}, {"text": "i know i can read/modify/write those using the Properties class, but im looking for a library that will let me access things like commented lines, preserve formatting and line order when writing back etc", "label": {"api": {"Properties": [[47, 56]]}}}, {"text": "Just use getResourceAsStream(String res)", "label": {"api": {"getResourceAsStream(String res)": [[9, 39]]}}}, {"text": "Field.getDeclaredAnnotations() gives you the annotations for each field", "label": {"api": {"Field.getDeclaredAnnotations()": [[0, 29]]}}}, {"text": "Make sure you're checking the up-to-date Javadoc", "label": {"api": {"up-to-date Javadoc": [[30, 47]]}}}, {"text": "Referring to SimpleDataFormat JavaDoc", "label": {"api": {"SimpleDataFormat JavaDoc": [[13, 36]]}}}, {"text": "2) You can setUncaughtExceptionHandler for every HTTP connector thread", "label": {"api": {"setUncaughtExceptionHandler": [[11, 37]]}}}, {"text": "I think you are after HTTP Servlet Filters in Java/Java EE", "label": {"api": {"Filter": [[35, 40]]}}}, {"text": "You can google HttpServlet Filter for hundreds of example implementations and one such example is provided in this article", "label": {"api": {"Filter": [[27, 32]]}}}, {"text": "You mainly have to write a class that implements the Filter interface and then add the necessary configuration (ie", "label": {"api": {"Filter": [[53, 58]]}}}, {"text": "Also HttpServletFilters is not limited to JBoss only, it's part of the Java Servlet Spec and hence available to any containers that implements the spec (Weblogic, Websphere, Tomcat, etc)", "label": {"api": {"Filter": [[16, 21]]}}}, {"text": "It does this by calling ResultSetMetaData::getColumnType and then calling TypeNames::get with the resulting type code", "label": {"api": {"ResultSetMetaData::getColumnType": [[24, 55]]}}}, {"text": "The problem is that getColumnType is returning a type code of 1111, which means 'other'), and Hibernate doesn't know what to do with that", "label": {"api": {"other": [[81, 85]]}}}, {"text": "For example, if we call skip(8) for a FileInputStream object, it will return 8 even if we are at EOF, or if the file has only 2 bytes", "label": {"api": {"FileInputStream": [[38, 52]]}}}, {"text": "A quick and dirty fix would be to add a XmlSeeAlso annotation to your response class", "label": {"api": {"XmlSeeAlso": [[40, 49]]}}}, {"text": "Don't use available() for this, it won't work reliably", "label": {"api": {"available()": [[10, 20]]}}}, {"text": "[ available() ] Returns an estimate of the number of bytes that can be read [...] It is never correct to use the return value of this method to allocate a buffer intended to hold all data in this stream", "label": {"api": {"available()": [[2, 12]]}}}, {"text": "The javadoc for Void says", "label": {"api": {"javadoc for Void": [[4, 19]]}}}, {"text": "See URLEncoder.encode(String, String)", "label": {"api": {"URLEncoder.encode(String, String)": [[4, 36]]}}}, {"text": "In the case this can be useful to you, my approach was to obtain the URL for the files inside the jar using the ClassLoader", "label": {"api": {"ClassLoader": [[112, 122]]}}}, {"text": "Keep in mind, a jar is a packaged form, so this will most likely return a zipped file (and not a simple File object)", "label": {"api": {"File": [[104, 107]]}}}, {"text": "You might have to dabble in ZipFile", "label": {"api": {"File": [[31, 34]], "ZipFile": [[28, 34]]}}}, {"text": "Point being, you can determine what you are dealing with by looking at the result URL.getProtocol()", "label": {"api": {"URL.getProtocol()": [[82, 98]]}}}, {"text": "It would also appear ImageIcon has a constructor that takes a URL", "label": {"api": {"constructor that takes a URL": [[37, 64]]}}}, {"text": "Based on the JavaDoc - jEditorPane supports the bleeding edge HTML 3.2 and CSS1 so the short answer is, you really don't want to try rendering modern web pages with it", "label": {"api": {"HTML 3.2": [[62, 69]]}}}, {"text": "If you want to look up the file name for files inside of your web application, you can use ServletContext#getRealPath", "label": {"api": {"ServletContext#getRealPath": [[91, 116]]}}}, {"text": "However, I would recommend loading your resources using the classloader with Class#getResourceAsStream", "label": {"api": {"Class#getResourceAsStream": [[77, 101]]}}}, {"text": "For example using of Timer, http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html": [[28, 90]]}}}, {"text": "The getInputStream method is described as returning the decoded InputStream", "label": {"api": {"getInputStream method": [[4, 24]]}}}, {"text": "The second method will print only your message AND the exception message (invoking throwable.toString() that returns a short description of the error), without the stacktrace", "label": {"api": {"returns a short description of the error": [[109, 148]]}}}, {"text": "When you find equals or equalsIgnoreCase is returning false when it should has return true", "label": {"api": {"equals": [[14, 19], [24, 29]], "equalsIgnoreCase": [[24, 39]]}}}, {"text": "use trim to rescue", "label": {"api": {"trim": [[4, 7]]}}}, {"text": "Although it is not explicitly specified for setTimestamp(int parameterIndex, Timestamp x) drivers have to follow the rules established by the setTimestamp(int parameterIndex, Timestamp x, Calendar cal) javadoc", "label": {"api": {"setTimestamp(int parameterIndex, Timestamp x, Calendar cal) javadoc": [[142, 208]]}}}, {"text": "Yes, see reference", "label": {"api": {"reference": [[9, 17]]}}}, {"text": "My only thought would be to implement your own Provider that could either proxy \"KeyFactory\" request to a BouncyCastle provider and the rest to another one that knows about JKS or proxy all requests to BouncyCastle with the exception of the \"KeyStore\" request", "label": {"api": {"Provider": [[47, 54]]}}}, {"text": "The Manifest APImakes it even easier", "label": {"api": {"Manifest API": [[4, 15]]}}}, {"text": "You can use Exchanger to exchange data", "label": {"api": {"Exchanger": [[12, 20]]}}}, {"text": "Another way is to implement BlockingQueue", "label": {"api": {"BlockingQueue": [[28, 40]]}}}, {"text": "Thread.sleep is a static method", "label": {"api": {"Thread.sleep": [[0, 11]]}}}, {"text": "For replacing an element in a position use the set() method", "label": {"api": {"set()": [[47, 51]]}}}, {"text": "Of course, the logic to find out which elements are duplicated in the first place is up to you; if it doesn't make sense to have duplicate numbers for your problem, better use a Set data structure (for instance", "label": {"api": {"Set": [[178, 180]]}}}, {"text": "HashSet, or LinkedHashSet if preserving insertion order when iterating is important for you) and keep adding random elements to the set until it has the desired size", "label": {"api": {"Set": [[4, 6], [22, 24]], "HashSet": [[0, 6], [18, 24]], "LinkedHashSet": [[12, 24]]}}}, {"text": "This escaping is necessary, because replaceAll() treats the first paramter as a regular expression", "label": {"api": {"replaceAll()": [[36, 47]]}}}, {"text": "But is my understanding that they are using PreparedStatements which makes validating the input for characters a bit odd", "label": {"api": {"PreparedStatement": [[44, 60]]}}}, {"text": "You can use the CommPortIdentifier.getPortIdentifiers() method to get a list of all port identifiers which are available on the local system", "label": {"api": {"CommPortIdentifier.getPortIdentifiers()": [[16, 54]]}}}, {"text": "The preserved information can be obtained at run-time with reflection API (like  getGenericParameterTypes(), getTypeParameters() & others methods)", "label": {"api": {"getGenericParameterTypes()": [[81, 106]], "getTypeParameters()": [[109, 127]]}}}, {"text": "You could avoid creating the byte array by using the RandomAccessFile class, with its read method", "label": {"api": {"RandomAccessFile": [[53, 68]], "read": [[86, 89]]}}}, {"text": "However, the more you read and write, of course increases the run-time considerably", "label": {"api": {"read": [[22, 25]]}}}, {"text": "On the other hand, if you're interested in preserving iteration order over keys and entries in the same order that the keys were inserted, then you're looking for a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[165, 177]]}}}, {"text": "If you wish to use the getName method, remember that you must set this yourself first as the field is not set by default", "label": {"api": {"getName": [[23, 29]]}}}, {"text": "If you mean that Java throws an OutOfMemoryError, you first need to understand why", "label": {"api": {"OutOfMemoryError": [[32, 47]]}}}, {"text": "The locale in question is none other than Locale.ROOT", "label": {"api": {"Locale.ROOT": [[42, 52]]}}}, {"text": "locale == Locale.ROOT on my end, and I assume that the same will be true for you", "label": {"api": {"Locale.ROOT": [[10, 20]]}}}, {"text": "Why does Locale.ROOT exist", "label": {"api": {"Locale.ROOT": [[9, 19]]}}}, {"text": "The default “JRE” locale provider’s resources for the Locale.ROOT locale are used if none of the specified locale providers support the requested locale", "label": {"api": {"Locale.ROOT": [[54, 64]]}}}, {"text": "You could use JTabbedPane and JTable for this", "label": {"api": {"JTabbedPane": [[14, 24]], "JTable": [[30, 35]]}}}, {"text": "You're also probably better off submitting a Callable to an ExecutorService (see Executors), and the ExecutorService will make the Future for you", "label": {"api": {"Executors": [[81, 89]]}}}, {"text": "In fact launching calculations in parrallel and waiting for their results is what an ExectorService's invokeAll() method does for you", "label": {"api": {"invokeAll()": [[102, 112]]}}}, {"text": "Use LinkedList.set(pos, newValue)", "label": {"api": {"LinkedList.set(pos, newValue)": [[4, 32]]}}}, {"text": "The easiest way to do that is to use a Swing Timer", "label": {"api": {"Swing Timer": [[39, 49]]}}}, {"text": "A Future's get() method will throw an ExecutionException if the computation throws an Exception", "label": {"api": {"get()": [[11, 15]], "ExecutionException": [[38, 55]]}}}, {"text": "That Exception is set as the cause of the ExecutionException", "label": {"api": {"ExecutionException": [[42, 59]]}}}, {"text": "Being Specific to your question java methods can return either primitives like int,float etc.,inbuilt Class object instances like Integer , or custom classes that you create in your java application like  \"Polica \" which you have mentioned above", "label": {"api": {"Integer": [[130, 136]]}}}, {"text": "If you want even larger numbers (that are out of range for longs as well) - you might want to have a look on BigInteger (and use it)", "label": {"api": {"BigInteger": [[109, 118]]}}}, {"text": "These details could be then hashed using the java.security.MessageDigest package and associated with your users account on the server", "label": {"api": {"java.security.MessageDigest": [[45, 71]]}}}, {"text": "Try Integer.decode(str) , assuming that the string starts with \"0x\", or prepend it yourself", "label": {"api": {"Integer.decode(str)": [[4, 22]]}}}, {"text": "First, if the File class your code uses is indeed java.io.File, and you're passing the filename to the constructor as a String rather than as a URI object, then the constructor you're calling isn't documented to throw an IllegalArgumentException in any case, so trying to catch one is pointless", "label": {"api": {"java.io.File": [[50, 61]], "the constructor you're calling": [[161, 190]]}}}, {"text": "The only File constructor that throws those is this one", "label": {"api": {"this one": [[47, 54]]}}}, {"text": "Second, the fact that File.canRead() returns false doesn't necessarily mean that the filename is invalid — it might be perfectly valid, and the file might even exist, but your program might not have the necessary permissions to read it", "label": {"api": {"File.canRead()": [[22, 35]]}}}, {"text": "Finally, as others have pointed out, I'm not sure what the \"URIException\" you're throwing actually is, unless it's a custom class you've written (there is a javax.print.URIException, but that's an interface, not a class; the only other one I could find is this one from the Apache HTTP Client), but the name, at least, seems completely inappropriate for an exception which you're using to report an invalid (or unreadable) file name", "label": {"api": {"this one": [[256, 263]], "javax.print.URIException": [[157, 180]]}}}, {"text": "I still recommend reading about GradientPaint which makes this process a lot easier and nicer", "label": {"api": {"GradientPaint": [[32, 44]]}}}, {"text": "I'm using BigDecimals with Scala's default MathContext, which has precision 34", "label": {"api": {"MathContext": [[43, 53]]}}}, {"text": "I would like (1 + z40*z40) to have precision 34 -- the precision of the MathContext in which the computations are being performed (since z40*z40 is negligibly small compared to 1)", "label": {"api": {"MathContext": [[72, 82]]}}}, {"text": "This behavior is due to a change in the handling of MathContexts between Scala 2.9.* and 2.10.*", "label": {"api": {"MathContext": [[52, 62]]}}}, {"text": "Use ProcessBuilder api which handles whitespaces better", "label": {"api": {"ProcessBuilder": [[4, 17]]}}}, {"text": "Maybe you'll find more convinient to use regular expressions", "label": {"api": {"regular expressions": [[41, 59]]}}}, {"text": "Go with BigInteger", "label": {"api": {"BigInteger": [[8, 17]]}}}, {"text": "Try using setExtendedState (int state) with MAXIMIZED_BOTH state", "label": {"api": {"setExtendedState (int state)": [[10, 37]]}}}, {"text": "For DES you can create your secret key out of a DESKeySpec", "label": {"api": {"DESKeySpec": [[48, 57]]}}}, {"text": "Method getResourceAsStream is used for loading resources from inside the JAR", "label": {"api": {"getResourceAsStream": [[7, 25]]}}}, {"text": "In Swing there is the pack() method", "label": {"api": {"pack()": [[22, 27]]}}}, {"text": "I hope they implement something like JOptionPane in JavaFX soon", "label": {"api": {"JOptionPane": [[37, 47]]}}}, {"text": "I wrote some test code that compares the speed of using the append() method of  StringBuilder eight times sequentially as a fluent interface against invoking it separately in 8 lines", "label": {"api": {"StringBuilder": [[80, 92]]}}}, {"text": "use a TexturePaint", "label": {"api": {"TexturePaint": [[6, 17]]}}}, {"text": "Most implementations will likely use a HashMap to map column names to an index, but not necessarily", "label": {"api": {"HashMap": [[39, 45]]}}}, {"text": "Also, some drivers may build the HashMap lazily which means the first row will be the slowest to access by column name", "label": {"api": {"HashMap": [[33, 39]]}}}, {"text": "JTDS, as an example, does a linear search for columns not yet in its HashMap", "label": {"api": {"HashMap": [[69, 75]]}}}, {"text": "Use a thread safe queue, such as any of the BlockingQueue implementations, and it should solve your issue", "label": {"api": {"any of the BlockingQueue implementations": [[33, 72]]}}}, {"text": "Without more information about your code, I would consider unprotected multi-threaded accesses to the HashMap object to be the prime suspect", "label": {"api": {"HashMap": [[102, 108]]}}}, {"text": "HashMap, contrary to Hashtable, is not synchronized and needs explicit locks to work in a multi-threaded environment, either directly or through the sets returned via keySet() or entrySet()", "label": {"api": {"HashMap": [[0, 6]], "Hashtable": [[21, 29]]}}}, {"text": "Failing to do that can create a lot of interesting side-effects due to the HashMap being in a inconsistent internal state", "label": {"api": {"HashMap": [[75, 81]]}}}, {"text": "var is a reference to a Scanner object that helps abstract the reading of tokenized input from a source (in this case the default input stream, System.in)", "label": {"api": {"System.in": [[144, 152]]}}}, {"text": "The call to .nextDouble() waits for a value to be inputted (e.g", "label": {"api": {".nextDouble()": [[12, 24]]}}}, {"text": "It may not hurt to read through the class documentation for Scanner to help provide some context about what a Scanner is and how it works", "label": {"api": {"class documentation for Scanner": [[36, 66]]}}}, {"text": "I have a suspicion the Java Input Method Client API may be needed", "label": {"api": {"Input Method Client API": [[28, 50]]}}}, {"text": "You should use a javax.swing.Timer to setup the delayed reaction and not put sleep() calls in the main thread", "label": {"api": {"javax.swing.Timer": [[17, 33]]}}}, {"text": "Given that you've taken the time to set up an ActionListener already, it would probably be easiest to use a javax.swing.Timer to control clearing the text", "label": {"api": {"javax.swing.Timer": [[108, 124]]}}}, {"text": "You can use a String type for a constant like '2012-12-31 12:00 am', or, Date or GregorianCalendar if you want to manipulate days/date differences in Java", "label": {"api": {"Date": [[73, 76]], "GregorianCalendar": [[81, 97]]}}}, {"text": "+1 to all suggestion to use Executor Service", "label": {"api": {"Executor Service": [[28, 43]]}}}, {"text": "getValue() returns you reference to Object, but in fact object is Location", "label": {"api": {"getValue()": [[0, 9]]}}}, {"text": "This can be inferred from the Javadoc of ObjectInputStream(InputStream in)", "label": {"api": {"ObjectInputStream(InputStream in)": [[41, 73]]}}}, {"text": "For the pros of CardLayout here is the implementation of the same thing without animation because CardLayout doesn't expose it's internal map", "label": {"api": {"CardLayout": [[16, 25], [98, 107]]}}}, {"text": "Like @HovercraftFullOfEels suggested, if you need to maintain all the workers and the pass objects you can use a Collection or a List, your code will look something like", "label": {"api": {"Collection": [[113, 122]], "List": [[129, 132]]}}}, {"text": "You can use FutureTask as follows", "label": {"api": {"FutureTask": [[12, 21]]}}}, {"text": "My advice would be changing EMA and SMA to ArrayLists and instead of using attributions, you could add the current elements to the lists", "label": {"api": {"ArrayLists": [[43, 52]]}}}, {"text": "Now String.valueOf() is not very flexible, and you will want to use something else, like NumberFormat (or DecimalFormat)", "label": {"api": {"NumberFormat": [[89, 100]]}}}, {"text": "Here is an excerpt from the official rules for Float.toString(), which are the same as for String.valueOf (float)", "label": {"api": {"official rules": [[28, 41]]}}}, {"text": "If you want to enforce unique values, use a data structure meant for such a behavior, like a Set", "label": {"api": {"Set": [[93, 95]]}}}, {"text": "TreeSet or HashSet would work perfectly", "label": {"api": {"Set": [[4, 6], [15, 17]], "TreeSet": [[0, 6]], "HashSet": [[11, 17]]}}}, {"text": "In java, it can be simply done using a list with Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[49, 69]]}}}, {"text": "Since other answers showed how to do it with Collections.shuffle() already - here is a simple implementation + example of fisher yates shuffle, that does not need to convert the original array into a list", "label": {"api": {"Collections.shuffle()": [[45, 65]]}}}, {"text": "Though if you will use the setMnemonic() method for JButton, then the JButton will gain focus and will perform it's own action associated with it, which is to draw Ovals", "label": {"api": {"setMnemonic()": [[27, 39]]}}}, {"text": "Then you can retrieve the selected Text using the #getSelectedText()", "label": {"api": {"#getSelectedText()": [[50, 67]]}}}, {"text": "JTextField.selectAll() is what you need", "label": {"api": {"JTextField.selectAll()": [[0, 21]]}}}, {"text": "But, JPA provides the Extended Persistence Context to help you implementing conversation management", "label": {"api": {"Extended Persistence Context": [[22, 49]]}}}, {"text": "Place the rotated node in a Group - that way the layoutBounds of the Group will match the boundsInParent of the rotated Node", "label": {"api": {"Group": [[28, 32], [69, 73]], "layoutBounds": [[49, 60]], "boundsInParent": [[90, 103]]}}}, {"text": "You should use Integer#parseInt(String s, int radix) with base 2 to parse the binary string and then use toHexString to get the Hex String", "label": {"api": {"Integer#parseInt(String s, int radix)": [[15, 51]]}}}, {"text": "In case you must support very large number you can use BigInteger", "label": {"api": {"BigInteger": [[55, 64]]}}}, {"text": "In your paintComponent() overridden method, cast the Graphics argument to Graphics2D, call rotate() on this Graphics2D, and draw your ellipse", "label": {"api": {"rotate()": [[91, 98]]}}}, {"text": "You can use a fixed size ExecutorService thread poll", "label": {"api": {"ExecutorService": [[25, 39]]}}}, {"text": "To convert the float, you could use String.format() with %f as the format specifier", "label": {"api": {"String.format()": [[36, 50]], "%f": [[57, 58]]}}}, {"text": "See the formatting documentation", "label": {"api": {"formatting documentation": [[8, 31]]}}}, {"text": "The indicated method returns a java.util.List which is a Collection", "label": {"api": {"The indicated method": [[0, 19]], "Collection": [[57, 66]]}}}, {"text": "In fact, if you look at the javadocs for RecursiveTask, they even point out that their simple example will perform slowly because the forking is too granular", "label": {"api": {"RecursiveTask": [[41, 53]]}}}, {"text": "To make the values into Colors", "label": {"api": {"Colors": [[24, 29]]}}}, {"text": "Alternatively, you could use the nextInt() method in the Scanner API to retrieve the numbers directly as ints, but I would take them in as Strings in order to perform further error handling where appropriate", "label": {"api": {"nextInt()": [[33, 41]]}}}, {"text": "You can use Arrays.sort()", "label": {"api": {"Arrays.sort()": [[12, 24]]}}}, {"text": "Note, that this requires the element type to either be a primitive type, or an impementation of the interface Comparable<T>, which applies for String", "label": {"api": {"Comparable<T>": [[110, 122]], "String": [[143, 148]]}}}, {"text": "Yes, Serializable is an interface", "label": {"api": {"Serializable": [[5, 16]]}}}, {"text": "The WebDriverWait until method is the method that throws the TimeoutException, not the constructor", "label": {"api": {"TimeoutException": [[61, 76]]}}}, {"text": "Also, be sure you are trying to catch the WebDriver TimeoutException , not the java.util.concurrent TimeoutException", "label": {"api": {"TimeoutException": [[52, 67], [100, 115]]}}}, {"text": "Use setIconImage(ImageIcon) for this", "label": {"api": {"setIconImage(ImageIcon)": [[4, 26]]}}}, {"text": "Use java.util.Properties to read these properties", "label": {"api": {"java.util.Properties": [[4, 23]]}}}, {"text": "For example in get() method you pass DAY_OF_WEEK to specify you want retrieve day of week field of calendar", "label": {"api": {"get()": [[15, 19]]}}}, {"text": "Trick is to override System.out using System::setOut in static initializer", "label": {"api": {"System::setOut": [[38, 51]]}}}, {"text": "You should really consider using a Map", "label": {"api": {"Map": [[35, 37]]}}}, {"text": "Consider using a Map", "label": {"api": {"Map": [[17, 19]]}}}, {"text": "If you are using the version of Runtime.exec that takes an array then there is no need to escape spaces in any of the arguments", "label": {"api": {"version of Runtime.exec that takes an array": [[21, 63]]}}}, {"text": "If you're on java7 you could take a look at shrinkwrap or implement your own FileSystemProvider", "label": {"api": {"FileSystemProvider": [[77, 94]]}}}, {"text": "Nothing in the API suggests that the method is synchronized, though I don't know what is going on inside the method", "label": {"api": {"API": [[15, 17]]}}}, {"text": "You don't have to explicitly create another variable, use Arrays.copyOf(T[] original, int newlength)", "label": {"api": {"Arrays.copyOf(T[] original, int newlength)": [[58, 99]]}}}, {"text": "If you can live with a modest runtime penalty, LinkedHashMap keeps insertion order", "label": {"api": {"LinkedHashMap": [[47, 59]]}}}, {"text": "You could form these queries and submit as Callables to an Executor service with a set number of threads", "label": {"api": {"Executor service": [[59, 74]]}}}, {"text": "According to the API for InputSteam \"The close method of InputStream does nothing.\", so since System.in is an instance of InputStream, you don't need to worry about close() being called on it", "label": {"api": {"API for InputSteam": [[17, 34]]}}}, {"text": "If you have Java 7, you can use Files.readAllLines(Path path, Charset cs), e.g", "label": {"api": {"Files.readAllLines(Path path, Charset cs)": [[32, 72]]}}}, {"text": "Where x (inclusive) and y (exclusive) indicates the line numbers that are of interest, see  List.subList(int fromIndex, int toIndex)", "label": {"api": {"List.subList(int fromIndex, int toIndex)": [[92, 131]]}}}, {"text": "Did you check clear() method of LinkedList", "label": {"api": {"clear()": [[14, 20]]}}}, {"text": "public void clear() - Removes all of the elements from this list", "label": {"api": {"clear()": [[12, 18]]}}}, {"text": "It appears that you will have to make a Thread that creates a Console class that appears to the 3rd party application as a console, before you start the 3rd party process", "label": {"api": {"Console": [[62, 68]]}}}, {"text": "Using Graphics2D is not that difficult as well, as the provide Graphics object normally is a Graphics2D object", "label": {"api": {"Graphics2D": [[6, 15], [93, 102]]}}}, {"text": "From the Date documentation", "label": {"api": {"Date documentation": [[9, 26]]}}}, {"text": "I have this class, similar to JDK's AtomicReference, and I use it mostly for legacy code", "label": {"api": {"JDK's AtomicReference": [[30, 50]]}}}, {"text": "Use a BufferedImage", "label": {"api": {"BufferedImage": [[6, 18]]}}}, {"text": "Tailor your data by that; otherwise you need to convert the data structure, working on one single BufferedImage", "label": {"api": {"BufferedImage": [[98, 110]]}}}, {"text": "Actually, the growth policy is unspecified, except that it guarantees that adding an element has a constant amortized cost", "label": {"api": {"guarantees": [[59, 68]]}}}, {"text": "I just faced the same issue and decided to map my key to an Entry", "label": {"api": {"Entry": [[60, 64]]}}}, {"text": "If you want synchronous communication between a main thread and a processing thread, you can use a SynchronousQueue", "label": {"api": {"SynchronousQueue": [[99, 114]]}}}, {"text": "A CountDownLatch is a good primitive for this", "label": {"api": {"CountDownLatch": [[2, 15]]}}}, {"text": "With Java.NIO you can do this with a class called FileLock", "label": {"api": {"FileLock": [[50, 57]]}}}, {"text": "V extends CharSequence & Map means your second type needs to extend both which String does not", "label": {"api": {"String": [[79, 84]]}}}, {"text": "You could create a wrapper class called ValidTreeType that has a Map and String property and make a Map of these", "label": {"api": {"String": [[73, 78]]}}}, {"text": "A reading of JPEG Metadata Format Specification and Usage Notes seems to suggest that this is possible by writing the image with a custom IIOMetadata", "label": {"api": {"JPEG Metadata Format Specification and Usage Notes": [[13, 62]]}}}, {"text": "That's because you can only add Component derived class intances to a JApplet (although adding JComponent derived instances is preferable if you're using a JApplet)", "label": {"api": {"Component": [[32, 40], [96, 104]], "JComponent": [[95, 104]]}}}, {"text": "If you really want to treat your point's as Components, then you can create your own custom Point class that derives from one of the JComponent existing classes (like JPanel) this is more complex though", "label": {"api": {"Component": [[44, 52], [134, 142]], "JComponent": [[133, 142]], "JPanel": [[167, 172]]}}}, {"text": "you can make both of the parsers implement XMLEventConsumer", "label": {"api": {"XMLEventConsumer": [[43, 58]]}}}, {"text": "I'm interested in writing arrays of bytes to disk using BufferedWriter.write()", "label": {"api": {"BufferedWriter.write()": [[56, 77]], "write": [[71, 75]]}}}, {"text": "Thus I started wondering why the BufferedWriter.write() method is so picky about wanting char[]", "label": {"api": {"BufferedWriter.write()": [[33, 54]], "write": [[48, 52]]}}}, {"text": "OuputStream has a write method which takes byte[]", "label": {"api": {"write": [[18, 22]]}}}, {"text": "So my question is about the framework design choice for wanting char[] in BufferedWrite.write()", "label": {"api": {"write": [[88, 92]]}}}, {"text": "According to the documentation String is represented internally as utf-16, so charAt() is giving you two code points", "label": {"api": {"String": [[31, 36]]}}}, {"text": "For example, if you call the method Integer.valueOf(myString); it may be doing something similar", "label": {"api": {"Integer.valueOf(myString);": [[36, 61]]}}}, {"text": "Just use split() to split on /, and take the second value", "label": {"api": {"split()": [[9, 15]]}}}, {"text": "String.replaceAll takes a regular expression matching pattern as its first parameter, and a regular expression replacement pattern as its second parameter - and $ has a specific meaning in regular expressions (in both matching patterns and replacement patterns, although in different senses)", "label": {"api": {"String.replaceAll": [[0, 16]], "String.replace": [[0, 13]]}}}, {"text": "Just use String.replace instead, and I suspect all your problems will go away", "label": {"api": {"String.replace": [[9, 22]]}}}, {"text": "An HashMap does not have any name nor id fields, instead it have keys and values fields", "label": {"api": {"HashMap": [[3, 9]]}}}, {"text": "Use a java.util.Map instead of an array", "label": {"api": {"java.util.Map": [[6, 18]]}}}, {"text": "In fact, some standard interfaces, such as Comparable are defined in exactly this way", "label": {"api": {"Comparable": [[43, 52]]}}}, {"text": "The easiest way is to use a RandomAccessFile", "label": {"api": {"RandomAccessFile": [[28, 43]]}}}, {"text": "You can just use Arrays.toString(s) and print the resulting String", "label": {"api": {"Arrays.toString(s)": [[17, 34]]}}}, {"text": "Use a ExecutorService to get a thread executor service, and submit Runnable tasks to it", "label": {"api": {"ExecutorService": [[6, 20]]}}}, {"text": "You can simply use the shuffle method and return the 6 first elements after shuffling", "label": {"api": {"shuffle": [[23, 29]]}}}, {"text": "The advantage of this method is that it runs in linear time (the time taken by the shuffle)", "label": {"api": {"shuffle": [[83, 89]]}}}, {"text": "Using XPath in the standard API", "label": {"api": {"XPath": [[6, 10]]}}}, {"text": "Integer.toBinaryString(int x) will do this for you", "label": {"api": {"Integer.toBinaryString(int x)": [[0, 28]]}}}, {"text": "are you looking for Integer.toBinaryString(int i)", "label": {"api": {"Integer.toBinaryString(int i)": [[20, 48]]}}}, {"text": "Note that the URL you get redirected to may also redirect you somewhere else and on and on, up to http.maxRedirects times", "label": {"api": {"http.maxRedirects": [[98, 114]]}}}, {"text": "See Frame.setState(int) for details", "label": {"api": {"Frame.setState(int)": [[4, 22]]}}}, {"text": "What I finally end up doing was to use a ConcurrentMap to check if the resource has been already requested or not", "label": {"api": {"ConcurrentMap": [[41, 53]]}}}, {"text": "As of Java 8, you can use Streams like this", "label": {"api": {"Streams": [[26, 32]]}}}, {"text": "And here you can see the more general way of testing that any list matches a given Predicate", "label": {"api": {"Predicate": [[83, 91]]}}}, {"text": "That code complies with the documentation of EventListenerList which gives a similar example", "label": {"api": {"documentation of EventListenerList": [[28, 61]]}}}, {"text": "java.awt.List is List component (like drop down list), it not a collection/datastructure", "label": {"api": {"List component": [[17, 30]]}}}, {"text": "You can't use List/Collection specific methods like iterator", "label": {"api": {"iterator": [[52, 59]]}}}, {"text": "You can also consider TreeSet, which guarantees log(n) time for basic operations (add, remove, contains)", "label": {"api": {"TreeSet": [[22, 28]]}}}, {"text": "Based on the oracle documentation at https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html it seems likely that it is an implementation of a binary heap", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html": [[37, 106]]}}}, {"text": "List elements are accessed with get", "label": {"api": {"get": [[32, 34]]}}}, {"text": "This is precisely what writeUTF is documented to do", "label": {"api": {"writeUTF": [[23, 30]]}}}, {"text": "The NumberFormatException is Thrown to indicate that the application has attempted to convert a string to one of the numeric types, but that the string does not have the appropriate format", "label": {"api": {"NumberFormatException": [[4, 24]]}}}, {"text": "Use HTML in JEditorPane and add HyperLinkListener to detect click on URLs", "label": {"api": {"JEditorPane": [[12, 22]], "HyperLinkListener": [[32, 48]]}}}, {"text": "In particular, see the documentation for this constructor", "label": {"api": {"this constructor": [[41, 56]]}}}, {"text": "Using JDBC, you can use Connection.PreparedStatement(query, int) method", "label": {"api": {"Connection.PreparedStatement(query, int)": [[24, 63]]}}}, {"text": "However, the Modifier class only appears capable of dealing with a subset of modifiers defined in the JVM spec", "label": {"api": {"Modifier": [[13, 20]]}}}, {"text": "JavaFX WebEngine has a WebHistory object which has all the API you need to completely manage the history and it should take care of not adding redirected URLs to the history for you", "label": {"api": {"WebEngine": [[7, 15]], "WebHistory": [[23, 32]]}}}, {"text": "The difficulty with that in the JavaFX WebEngine is that the http status return codes happen at the network layer and are not exposed through the WebEngine interface", "label": {"api": {"WebEngine": [[39, 47], [146, 154]]}}}, {"text": "So if you just monitor the location property of the WebEngine as you are doing, it is going to be really hard to get a high quality navigation interface", "label": {"api": {"WebEngine": [[52, 60]]}}}, {"text": "If I were to implement the same functionality again today, I would just make use of the new WebHistory functionality provided by the later JavaFX versions, rather than writing my own", "label": {"api": {"WebHistory": [[92, 101]]}}}, {"text": "In the Java API, charsets are implemented as subclasses of Charset", "label": {"api": {"Charset": [[59, 65]]}}}, {"text": "For instance, OutputStreamWriter features a constructor that takes a charset", "label": {"api": {"OutputStreamWriter": [[14, 31]]}}}, {"text": "It seems like you may not be running this code in Swing's GUI thread", "label": {"api": {"Swing's GUI thread": [[50, 67]]}}}, {"text": "The other thing that is very important is that when you update the TableModel, it has to be done according to Swing's threading policy", "label": {"api": {"Swing's threading policy": [[110, 133]]}}}, {"text": "This is a one-liner (if you count an anonymous class as one line), making use of Arrays.sort() and a suitably typed and coded Comparator", "label": {"api": {"Arrays.sort()": [[81, 93]], "Comparator": [[126, 135]]}}}, {"text": "If it is going to vary, then I suggest you to use for example ArrayList", "label": {"api": {"ArrayList": [[62, 70]]}}}, {"text": "If you want to access resources inside the classpath (or jar), use ClassLoader.getResourceAsStream - you will then wrap a Reader around the returned InputStream using InputStreamReader", "label": {"api": {"ClassLoader.getResourceAsStream": [[67, 97]], "InputStreamReader": [[167, 183]]}}}, {"text": "However, depending on the version of Java you're using, you can use Integer.compare (introduced in 1.7) and Double.compare (introduced in 1.4)", "label": {"api": {"Integer.compare": [[68, 82]], "Double.compare": [[108, 121]]}}}, {"text": "The class you want to serialize (Stock, in this case) has to implement the Serializable interface", "label": {"api": {"Serializable interface": [[75, 96]]}}}, {"text": "I'd like to use list.subList(start, end) to pull each of these types into its own list for better management on my end, but I'll still need to call library methods which expect indices within the original list, so I'll need some way to produce those from my sublists", "label": {"api": {"list.subList(start, end)": [[16, 39]]}}}, {"text": "Because the language defines an array as an Object, the compiler chose the matching  available add() method", "label": {"api": {"add()": [[95, 99]]}}}, {"text": "Then you could save the credentials in the user home directory, setting permissions so that only owner can access them (let OS to care about security)", "label": {"api": {"setting permissions": [[64, 82]]}}}, {"text": "Surely you can, read it here", "label": {"api": {"read it here": [[16, 27]]}}}, {"text": "You must probably specify a path for your cookie", "label": {"api": {"specify a path": [[18, 31]]}}}, {"text": "You're looking for a Map", "label": {"api": {"Map": [[21, 23]]}}}, {"text": "Then, simply keep a Map of your ShipTypes to properly construct your Ships", "label": {"api": {"Map": [[20, 22]]}}}, {"text": "I guess the author refers to the finalize() method, that every Object has, and that is called by the garbage collector", "label": {"api": {"finalize()": [[33, 42]]}}}, {"text": "Map.Entry has a method called getKey() , use this to get the key", "label": {"api": {"Map.Entry": [[0, 8]]}}}, {"text": "This fact is strangely documented in the description of the Thread.join, with the following sentence", "label": {"api": {"Thread.join": [[60, 70]]}}}, {"text": "BTW, I think you can use Thread.sleep() to pause a servlet, as in any normal java code", "label": {"api": {"Thread.sleep()": [[25, 38]]}}}, {"text": "However, if you need more precision, use BigDecimal", "label": {"api": {"BigDecimal": [[41, 50]]}}}, {"text": "You don't actually need a regular expression here, you can use the contains method, i.e", "label": {"api": {"contains": [[67, 74]]}}}, {"text": "As mentioned in the comments, if your received string will span multiple lines then be sure to enable the Pattern.DOTALL flag or use instead the regex \"(?s).*invalid.*\"", "label": {"api": {"Pattern.DOTALL": [[106, 119]]}}}, {"text": "I've looked over the example given in the api docs, and found some other examples", "label": {"api": {"api docs": [[42, 49]]}}}, {"text": "Check each method to see whether all the argument values are assignable to the corresponding parameter types (see Class.isAssignableFrom - you may need to handle primitives separately)", "label": {"api": {"Class.isAssignableFrom": [[114, 135]]}}}, {"text": "The DefaultTreeCellRenderer has setters, allowing to set open icon, closed icon and leaf icon", "label": {"api": {"DefaultTreeCellRenderer": [[4, 26]]}}}, {"text": "Have a look at SimpleDateFormat.parse(...) and do remember to surround with try-catch", "label": {"api": {"SimpleDateFormat.parse(...)": [[15, 41]]}}}, {"text": "You should use SimpleDateFormat.parse(String) method", "label": {"api": {"SimpleDateFormat.parse(String)": [[15, 44]]}}}, {"text": "The standard JDK class for that is SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[35, 50]]}}}, {"text": "Get the horizontal distance and the vertical difference between the center and the point, divide one by the other, and pass the result to the method Math.asin(double)", "label": {"api": {"Math.asin(double)": [[149, 165]]}}}, {"text": "When you need it in degree, you can use the method Math.toDegrees(double)", "label": {"api": {"Math.toDegrees(double)": [[51, 72]]}}}, {"text": "What you also can do is create a new array (that is bigger or smaller than your current one) using the Arrays.copyOf(int[] original, int newLength); method", "label": {"api": {"Arrays.copyOf(int[] original, int newLength);": [[103, 147]]}}}, {"text": "String.replaceAll() takes a regular expression as a parameter, and $ has a special meaning there", "label": {"api": {"regular expression": [[28, 45]]}}}, {"text": "From the Error documentation", "label": {"api": {"the Error documentation": [[5, 27]]}}}, {"text": "and the Exception documentation", "label": {"api": {"the Exception documentation": [[4, 30]]}}}, {"text": "What you may lack is a ButtonGroup (and add both JRadioButton's to that group) so that when one JRadioButton is selected the other gets automatically deselected", "label": {"api": {"ButtonGroup": [[23, 33]]}}}, {"text": "The Java SE URLConnection is insuitable for the job of retrieving a list of files from a FTP host", "label": {"api": {"URLConnection": [[12, 24]]}}}, {"text": "My students are currently forced (not by me, but by an unclear assignment) to implement clone(), equals() and hashCode() for an abstract class", "label": {"api": {"clone()": [[88, 94]], "equals()": [[97, 104]], "hashCode()": [[110, 119]]}}}, {"text": "Does it make sense to implement clone(), equals() or hashCode() for an abstract class", "label": {"api": {"clone()": [[32, 38]], "equals()": [[41, 48]], "hashCode()": [[53, 62]]}}}, {"text": "The easiest way to get started is with an ExecutorService", "label": {"api": {"ExecutorService": [[42, 56]]}}}, {"text": "You can submit individual tasks, and wait on the returned Future for a specific amount of time", "label": {"api": {"Future": [[58, 63]]}}}, {"text": "Also check out the  invokeAll method and friends", "label": {"api": {"invokeAll": [[20, 28]]}}}, {"text": "You can also try using a statement timeout, although that may be less reliable than the Executor approach if there are driver bugs or unexpected communications issues (for example, a query that executes quickly but takes a long time to transfer its results)", "label": {"api": {"statement timeout": [[25, 41]]}}}, {"text": "Call DatagramPacket.getLength() to find out how many bytes were actually received", "label": {"api": {"DatagramPacket.getLength()": [[5, 30]]}}}, {"text": "I assume you mean Thread rather than ThreadClass", "label": {"api": {"Thread": [[18, 23], [37, 42]]}}}, {"text": "When the run method of a thread returns then the thread will stop", "label": {"api": {"stop": [[61, 64]]}}}, {"text": "You should avoid calling stop if at all possible as it does not allow the thread to exit cleanly", "label": {"api": {"stop": [[25, 28]]}}}, {"text": "One useful method for creating a memory-mapped file object in Java is FileChannel.map", "label": {"api": {"FileChannel.map": [[70, 84]]}}}, {"text": "That method returns a MappedByteBuffer, which you can use to read a chunk of bytes at a particular file offset", "label": {"api": {"MappedByteBuffer": [[22, 37]]}}}, {"text": "What's the matter with Thread.State and checking for the TERMINATED state", "label": {"api": {"Thread.State": [[23, 34]], "TERMINATED": [[57, 66]]}}}, {"text": "You'd have to derive the running state (not NEW, not TERMINATED) but it strikes me as much more reliable", "label": {"api": {"TERMINATED": [[53, 62]]}}}, {"text": "If using a NavigableMap implementation, you can call subMap to get a view of the map between two keys", "label": {"api": {"subMap": [[53, 58]]}}}, {"text": "As demonstrated the \"from\" and \"to\" keys used in the call to subMap do not themselves need to be contained in the map", "label": {"api": {"subMap": [[61, 66]]}}}, {"text": "And I think I also should use Executors.newFixedThreadPool to manage a fixed-size pool of clients, and that should maybe have a ThreadFactory which  produces instances of FooClientImplThread", "label": {"api": {"Executors.newFixedThreadPool": [[30, 57]], "ThreadFactory": [[128, 140]]}}}, {"text": "And then in ConcurrentFooClientImpl.processFoo() I could wrap inputData somehow in an implementation of Callable to submit them to the pool", "label": {"api": {"Callable": [[104, 111]]}}}, {"text": "I guess they could call Thread.currentThread() and cast the result to FooClientImplThread", "label": {"api": {"Thread.currentThread()": [[24, 45]]}}}, {"text": "There's a SwingUtilities helper class for this", "label": {"api": {"SwingUtilities": [[10, 23]]}}}, {"text": "You could also look into using a background executor if you want to manage the way threads are created", "label": {"api": {"executor": [[44, 51]]}}}, {"text": "You don't need any synchronization, quoting JavaDoc of Logger", "label": {"api": {"JavaDoc of Logger": [[44, 60]]}}}, {"text": "You can use charAt function", "label": {"api": {"charAt": [[12, 17]]}}}, {"text": "To get the nth character of a string you should use charAt, the you should use the Charachter's isLetterOrDigit", "label": {"api": {"charAt": [[52, 57]], "isLetterOrDigit": [[96, 110]]}}}, {"text": "See apidoc reference", "label": {"api": {"apidoc reference": [[4, 19]]}}}, {"text": "As far as I see from the javadoc of java.util.Map and javax.persistence.metamodel.Map which does not seem to exist in the latest API, the metamodel Map seems to be a wrapper over the util Map so that we can use it to get metadata about the util Map", "label": {"api": {"java.util.Map": [[36, 48]]}}}, {"text": "I'm working on printing a series of JPanels to a Printable, the basic printing interface that supplies a Graphics object that you draw what you want printed", "label": {"api": {"Printable": [[49, 57]]}}}, {"text": "If your decimal number calculations require precision, use Java.math.BigDecimal", "label": {"api": {"Java.math.BigDecimal": [[59, 78]]}}}, {"text": "Try iterating over the list and see if one (or more) of the strings contains(word) the word you are looking for", "label": {"api": {"contains(word)": [[68, 81]]}}}, {"text": "Reader.read() returns a value that can be cast to char or -1 if no more data is available", "label": {"api": {"Reader.read()": [[0, 12]]}}}, {"text": "The supplementary range is represented using two-char sequences", "label": {"api": {"sequence": [[54, 61]]}}}, {"text": "The Character type contains methods for translating UTF-16 code units to Unicode code points", "label": {"api": {"Character": [[4, 12]]}}}, {"text": "A code point that requires two chars will satisfy the isHighSurrogate and isLowSurrogate when you pass in two sequential values from a sequence", "label": {"api": {"isHighSurrogate": [[54, 68]], "isLowSurrogate": [[74, 87]], "sequence": [[135, 142]]}}}, {"text": "The codePointAt methods can be used to extract code points from code unit sequences", "label": {"api": {"sequence": [[74, 81]], "codePointAt": [[4, 14]]}}}, {"text": "Collections.shuffle() is crucial here", "label": {"api": {"Collections.shuffle()": [[0, 20]]}}}, {"text": "One approach would be to add a custom JPanel that overrides paintComponent and calls drawImage(Image, x, y, width, height, ...)", "label": {"api": {"drawImage(Image, x, y, width, height, ...)": [[85, 126]]}}}, {"text": "For this I'm using the Map.merge method, which either associates the provided value (1L in this case) with the given key (word here) or uses the provided merge function (Long::sum) to combine an existent value with the given one", "label": {"api": {"Map.merge": [[23, 31]]}}}, {"text": "Then, words with a frequency greater than 1 are removed from the map via the Collection.removeIf method", "label": {"api": {"Collection.removeIf": [[77, 95]]}}}, {"text": "You might want to look at the Apache Commons DbUtils, which uses Class Literals as Runtime-Type Tokens and ResultSetMetaData to simplify some of the more tedious parts of JDBC", "label": {"api": {"ResultSetMetaData": [[107, 123]]}}}, {"text": "I am trying to understand SocketChannels, and NIO in general", "label": {"api": {"SocketChannels": [[26, 39]], "NIO": [[46, 48]]}}}, {"text": "I have read the also this documentation, but somehow I am not getting it..", "label": {"api": {"this documentation": [[21, 38]]}}}, {"text": "You can call Clipboard.addFlavorListener to listen for clipboard updates from the OS", "label": {"api": {"Clipboard.addFlavorListener": [[13, 39]]}}}, {"text": "See how UIComponentBase.findComponent works", "label": {"api": {"UIComponentBase.findComponent": [[8, 36]]}}}, {"text": "Override equals() (based on name and birth date) and hashCode() for TestBean class and then add all the objects to Set data structure", "label": {"api": {"Set": [[115, 117]]}}}, {"text": "Set filters duplicate objects provided you have equals() overridden correctly", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "But in general, you can use lastIndexOf method of the ArrayList", "label": {"api": {"lastIndexOf": [[28, 38]]}}}, {"text": "System.out is a PrintStream (which is why you can use such methods as println() etc on it)", "label": {"api": {"PrintStream": [[16, 26]]}}}, {"text": "What you can do is, if you see the option to redirect to a file, just create a new PrintStream to the destination file", "label": {"api": {"PrintStream": [[83, 93]]}}}, {"text": "I tried looking at http://docs.oracle.com/javase/7/docs/api/javax/swing/text/Highlighter.html but it is using positions", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/text/Highlighter.html": [[19, 92]]}}}, {"text": "You would need to use an Iterator like so", "label": {"api": {"Iterator": [[25, 32]]}}}, {"text": "That being said, you can use the remove(int index) or remove(Object obj) which are provided by the ArrayList class", "label": {"api": {"remove(int index)": [[33, 49]], "remove(Object obj)": [[54, 71]], "ArrayList": [[99, 107]]}}}, {"text": "Note however, that calling these methods while you are iterating over the loop, will cause a ConcurrentModificationException, so this will not work", "label": {"api": {"ConcurrentModificationException": [[93, 123]]}}}, {"text": "If you have more complex objects you would need to override the equals method", "label": {"api": {"equals": [[64, 69]]}}}, {"text": "Not only doing so will result in more readable code, it will also allow you to use collections such as a HashSet or other methods that rely on the equals() behavior", "label": {"api": {"HashSet": [[105, 111]]}}}, {"text": "I don't see anything like that in Guava, but how about a ForwardingQueue built around an ArrayDeque where you check the capacity on add(), offer(), etc", "label": {"api": {"ArrayDeque": [[89, 98]]}}}, {"text": "Java's ArrayBlockingQueue offers a fixed sized circular buffer", "label": {"api": {"Java's ArrayBlockingQueue": [[0, 24]]}}}, {"text": "In Java 7, all classes implementing AutoCloseable can be used with the \"try-with-resources\" construct", "label": {"api": {"AutoCloseable": [[36, 48]]}}}, {"text": "Models derived from AbstractTableModel need to call the inherited method fireTableCellUpdated on your model", "label": {"api": {"fireTableCellUpdated": [[73, 92]]}}}, {"text": "I played around a bit with ChoiceFormat but was not able to pipe it with the MessageFormat class to achieve what I want to", "label": {"api": {"ChoiceFormat": [[27, 38]], "MessageFormat": [[77, 89]]}}}, {"text": "To remove all elements of one collection that are present in another, use removeAll", "label": {"api": {"removeAll": [[74, 82]]}}}, {"text": "My problem is that I cannot find out how to get security provider associated with given SSLSocket", "label": {"api": {"SSLSocket": [[88, 96]]}}}, {"text": "There is provider accessible through SSLContext class, but I cannot get SSLContext from SSLSocket", "label": {"api": {"SSLSocket": [[88, 96]], "SSLContext": [[37, 46], [72, 81]]}}}, {"text": "The one in taglib package is a subclass of UIComponentTag which thus represents the sole JSP tag <a4j:commandButton>", "label": {"api": {"UIComponentTag": [[43, 56]], "UIComponent": [[43, 53]]}}}, {"text": "The one in component package is a subclass of UIComponent which thus represents the concrete JSF component which is associated with the JSP tag", "label": {"api": {"UIComponent": [[46, 56]]}}}, {"text": "Note that Facelets, the successor of JSP, does not require those UIComponentTag classes anymore", "label": {"api": {"UIComponentTag": [[65, 78]], "UIComponent": [[65, 75]]}}}, {"text": "You can use withDayOfMonth(int dayOfMonth) method from java8 to return first day of month", "label": {"api": {"withDayOfMonth(int dayOfMonth)": [[12, 41]]}}}, {"text": "The call to d.setVisible(true) blocks until the dialog is closed when the dialog is modal, per the Java API docs", "label": {"api": {"Java API docs": [[99, 111]]}}}, {"text": "Use a Scene constructor which specifies initial size constraints", "label": {"api": {"Scene constructor which specifies initial size constraints": [[6, 63]]}}}, {"text": "for more information, please see How to Use BoxLayout", "label": {"api": {"BoxLayout": [[44, 52]]}}}, {"text": "You should annotate it with @Entity, and choose an inheritance strategy", "label": {"api": {"inheritance strategy": [[51, 70]]}}}, {"text": "You can use Stack structure to park the data (push) that you'll need to consider later (pop)", "label": {"api": {"Stack": [[12, 16]]}}}, {"text": "Or use a BitSet (which has a convenient enough .flip() method)", "label": {"api": {"BitSet": [[9, 14]]}}}, {"text": "Make sure that UI updates are run in the Event Dispatcher Thread for instance with invokeLater or invokeAndWait", "label": {"api": {"invokeLater": [[83, 93]], "invokeAndWait": [[98, 110]]}}}, {"text": "Yes, equals() should handle null and in that case it should return false as documented in Object.equals()", "label": {"api": {"Object.equals()": [[90, 104]]}}}, {"text": "If you need to compare two possibly null references look at Objects.equals(Object, Object)", "label": {"api": {"Objects.equals(Object, Object)": [[60, 89]]}}}, {"text": "I usually rely on uncaught exception handlers to get notified of thread crashes or I implement some form of SW watchdog", "label": {"api": {"uncaught exception handlers": [[18, 44]]}}}, {"text": "As of Java 7, all reflection-related exceptions extend java.lang.ReflectiveOperationException, so you only need to catch that", "label": {"api": {"java.lang.ReflectiveOperationException": [[55, 92]]}}}, {"text": "You could use an URLClassLoader, but it would download the file every time, and would make the code more complex", "label": {"api": {"URLClassLoader": [[17, 30]]}}}, {"text": "You should preferrably be using scatter/gather type IO in this case as it would minimize number of syscalls in the application", "label": {"api": {"scatter/gather": [[32, 45]]}}}, {"text": "You may want to return the thread and call join in the test on the generated thread, which will ensure that the Thread runs until it dies, possibly with a short timeout", "label": {"api": {"join": [[43, 46]]}}}, {"text": "Consider AtomicInteger for your requests class, if multiple threads might modify requests", "label": {"api": {"AtomicInteger": [[9, 21]]}}}, {"text": "Check Math class", "label": {"api": {"Math": [[6, 9]]}}}, {"text": "Create an array of your above Strings and use java.util.Random class to generate random number for array index", "label": {"api": {"java.util.Random": [[46, 61]]}}}, {"text": "Also see the API documentation of java.util.regex.Pattern", "label": {"api": {"the API documentation of java.util.regex.Pattern": [[9, 56]]}}}, {"text": "The matcher will move to the next match on each iteration because of your call to find()", "label": {"api": {"find()": [[82, 87]]}}}, {"text": "If you really referring to the JTextComponents, then I guess what you need is setDisabledTextColor(...), something like this", "label": {"api": {"setDisabledTextColor(...)": [[78, 102]]}}}, {"text": "There is a version of marshall that takes an Writer", "label": {"api": {"version": [[11, 17]]}}}, {"text": "You can use Arrays.copyOfRange() to get the subarrays and Arrays.equals() to perform the equality check", "label": {"api": {"Arrays.copyOfRange()": [[12, 31]], "Arrays.equals()": [[58, 72]]}}}, {"text": "What type of ResultSet did you use", "label": {"api": {"ResultSet": [[13, 21]]}}}, {"text": "Try to use FORWARD_ONLY to restrict caching data by JDBC driver retrieved from DB", "label": {"api": {"FORWARD_ONLY": [[11, 22]]}}}, {"text": "If that's DataInputStream.read(), it returns -1 on error", "label": {"api": {"DataInputStream.read()": [[10, 31]]}}}, {"text": "Consider using the Arrays.toString() method to turn the byte array into an encryptable string", "label": {"api": {"Arrays.toString()": [[19, 35]]}}}, {"text": "The javadoc of Process says", "label": {"api": {"Process": [[15, 21]]}}}, {"text": "I realize this would not be a Set as it would break the Java contract for Set, but I just feel as though this problem must have been encountered previously", "label": {"api": {"Java contract for Set": [[56, 76]]}}}, {"text": "I am trying out the methods and the functionality of the class NumberFormat and I have reached to a strange result", "label": {"api": {"NumberFormat": [[63, 74]]}}}, {"text": "Instances of the class java.lang.Class represent classes and interfaces in a running Java application", "label": {"api": {"java.lang.Class": [[23, 37]]}}}, {"text": "If you just want to do it with the technology that comes within the JDK, you should look at URLConnection", "label": {"api": {"URLConnection": [[92, 104]]}}}, {"text": "If the size of the input is not known at compile time, consider using an ArrayList instead of an array", "label": {"api": {"ArrayList": [[73, 81]]}}}, {"text": "Just add the elements to the ArrayList using names.add(scan.nextLine())", "label": {"api": {"ArrayList": [[29, 37]], "names.add(scan.nextLine())": [[45, 70]]}}}, {"text": "You can use more complex synchronization mechanisms like latches, barriers or semaphores, but have a look at ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[109, 133]]}}}, {"text": "HttpURLConnection comes default with java", "label": {"api": {"HttpURLConnection": [[0, 16]]}}}, {"text": "Date(year,day, month ) constructor is deprecated", "label": {"api": {"Date(year,day, month )": [[0, 21]]}}}, {"text": "Exactly as the error message tells you, there is no printf method of PrintStreams in Java 1.4.2", "label": {"api": {"there is no printf method of PrintStreams in Java 1.4.2": [[40, 94]]}}}, {"text": "The current JavaDocs tell us that PrintStream#printf() was added in Java 1.5", "label": {"api": {"PrintStream#printf()": [[34, 53]]}}}, {"text": "Then, you can use the ImageIO API to save the image", "label": {"api": {"ImageIO": [[22, 28]]}}}, {"text": "I think Double.valueOf covers your use cases", "label": {"api": {"Double.valueOf": [[8, 21]]}}}, {"text": "But Java supports you with the Dynamic Proxy API, and its core class Proxy", "label": {"api": {"Proxy": [[39, 43], [69, 73]]}}}, {"text": "Please check out the java.util.Scanner API for more on this", "label": {"api": {"java.util.Scanner API": [[21, 41]]}}}, {"text": "You can even use a ComponentListener to listen to about which is being visible", "label": {"api": {"ComponentListener": [[19, 35]]}}}, {"text": "Transferring the data using this mechanism uses Object serialization, so the class you use to transfer the data must implement the Serializable interface, as must anything that is serialized with it", "label": {"api": {"Serializable": [[131, 142]]}}}, {"text": "If everything is not serializable, you will see a NotSerializableException during drop or copy to the clipboard", "label": {"api": {"Serializable": [[53, 64]]}}}, {"text": "Your MyObject is not Serializable, so it cannot work", "label": {"api": {"Serializable": [[21, 32]]}}}, {"text": "Arrays.fill() will fill an existing array with the same value", "label": {"api": {"Arrays.fill()": [[0, 12]]}}}, {"text": "Arrays.fill(...) is what you are looking for", "label": {"api": {"Arrays.fill(...)": [[0, 15]]}}}, {"text": "You can use WebView in your application to render specified webpage", "label": {"api": {"WebView": [[12, 18]]}}}, {"text": "I have the following code that works for creating a Proxy instance for an interface type backed by an InvocationHandler implementation, however when I use a concrete class type it doesn't work and this is well known and documented in Proxy.newProxyInstance", "label": {"api": {"Proxy.newProxyInstance": [[234, 255]]}}}, {"text": "From the Javadocs of field#setAccessible(boolean)", "label": {"api": {"field#setAccessible(boolean)": [[21, 48]]}}}, {"text": "Instead after concatinating all the strings and using \\n instead of NL, use URLEncoder to encode the string", "label": {"api": {"URLEncoder": [[76, 85]]}}}, {"text": "using a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[8, 21]]}}}, {"text": "It sounds like a classic producer/consumer pattern so I suggest you look at existing data structures for this purpose, like on of the BlockingQueue implementations", "label": {"api": {"BlockingQueue": [[134, 146]]}}}, {"text": "Assuming you're in Java Swing, what you want is FontMetrics", "label": {"api": {"FontMetrics": [[48, 58]]}}}, {"text": "Use RandomAccessFile#read and push the bytes recorded in this way into a new File object", "label": {"api": {"RandomAccessFile#read": [[4, 24]]}}}, {"text": "It depends on how you're going to write to the file, but the simplest way is to open a new FileOutputStream without specifying that you plan to append to the file (note", "label": {"api": {"FileOutputStream": [[91, 106]]}}}, {"text": "One liner using Files.write()..", "label": {"api": {"Files.write()": [[16, 28]]}}}, {"text": "Can use File.toPath() to convert from File to Path prior as well", "label": {"api": {"File.toPath()": [[8, 20]]}}}, {"text": "Because if you passed nothing to the method, you'll end up calling the List#toArray() no-argument overload", "label": {"api": {"List#toArray()": [[71, 84]]}}}, {"text": "Supplying the array calls the List#toArray(T[] a) method, which returns a <T> T[]", "label": {"api": {"List#toArray(T[] a)": [[30, 48]]}}}, {"text": "HttpServletRequest is an interface", "label": {"api": {"HttpServletRequest": [[0, 17]]}}}, {"text": "That being said you are free to use any of the methods of HttpServletRequest, without bothering about the actual implementation", "label": {"api": {"HttpServletRequest": [[58, 75]]}}}, {"text": "Does it take HttpServletRequest as an argument", "label": {"api": {"HttpServletRequest": [[13, 30]]}}}, {"text": "See this quote, from the ResultSet API", "label": {"api": {"ResultSet API": [[25, 37]]}}}, {"text": "In Java 1.5, I'm pretty sure you would use a Future to return the result", "label": {"api": {"Future": [[45, 50]]}}}, {"text": "You can list the network interfaces and maybe use isPointToPoint or perhaps something else in the NetworkInterface class to detect the modem connection", "label": {"api": {"NetworkInterface": [[98, 113]]}}}, {"text": "This primitive is called CountDownLatch", "label": {"api": {"CountDownLatch": [[25, 38]]}}}, {"text": "See the Tomcat documentation and the ClassLoader javadoc for more details", "label": {"api": {"ClassLoader javadoc": [[37, 55]]}}}, {"text": "Use DecimalFormat / NumberFormat", "label": {"api": {"DecimalFormat": [[4, 16]], "NumberFormat": [[20, 31]]}}}, {"text": "For DecimalFormat, you can pass in a formatting pattern / locale information for formatting the number", "label": {"api": {"DecimalFormat": [[4, 16]]}}}, {"text": "This link is a good tutorial on using DecimalFormat", "label": {"api": {"DecimalFormat": [[38, 50]]}}}, {"text": "Use .getClass().getComponentType() to determine the contained class and use that to create an array through newInstance", "label": {"api": {".getClass().getComponentType()": [[4, 33]]}}}, {"text": "Or create an exact copy with Arrays.copyOf()", "label": {"api": {"Arrays.copyOf()": [[29, 43]]}}}, {"text": "The canonical way to initialize data on app startup is to use a ServletContextListener", "label": {"api": {"ServletContextListener": [[64, 85]]}}}, {"text": "You're seeing this rounding behavior because the default rounding mode for DecimalFormat is HALF_EVEN", "label": {"api": {"the default rounding mode for DecimalFormat is HALF_EVEN": [[45, 100]]}}}, {"text": "Use RoundingMode.DOWN instead", "label": {"api": {"RoundingMode.DOWN": [[4, 20]]}}}, {"text": "You have to create a sql Date", "label": {"api": {"sql Date": [[21, 28]]}}}, {"text": "To parse string to date you may use the class SimpleDateFormat, e.g.", "label": {"api": {"SimpleDateFormat": [[46, 61]]}}}, {"text": "Then you may use the setDate(int, Date) method of PreparedStatement", "label": {"api": {"PreparedStatement": [[50, 66]]}}}, {"text": "A long value can hold any number up to 2^63-1, which is sufficient for many applications", "label": {"api": {"2^63-1": [[39, 44]]}}}, {"text": "All you need to do is to provide the appropriate radix parameter to the parseLong(String string, int radix) method (and the toString(Long number, int radix) method)", "label": {"api": {"parseLong(String string, int radix)": [[72, 106]], "toString(Long number, int radix)": [[124, 155]]}}}, {"text": "For a situation like this, when you really wanted to update a certain thingy from another Thread, always use EventQueue.invokeLater(...) or EvenQueue.invokeAndWait(), which can asynchronously (former)/synchronously (latter) update your request on the EDT, though care must be taken, as invokeAndWait() might can lead to deadlocks/run conditions if not used in the right sense", "label": {"api": {"EventQueue.invokeLater(...)": [[109, 135]], "EvenQueue.invokeAndWait()": [[140, 164]]}}}, {"text": "You seem to be searching for CardLayout", "label": {"api": {"CardLayout": [[29, 38]]}}}, {"text": "Read more about String.indexOf() method", "label": {"api": {"String.indexOf()": [[16, 31]]}}}, {"text": "For multithreaded applications similar to what you described, it's best to use a BlockingQueue for message passing between threads", "label": {"api": {"BlockingQueue": [[81, 93]]}}}, {"text": "For example, your packet listener thread could have a BlockingQueue that it puts messages on that the packet parser takes from", "label": {"api": {"BlockingQueue": [[54, 66]]}}}, {"text": "JTable) by using the method setModel()", "label": {"api": {"setModel()": [[28, 37]]}}}, {"text": "Try using Formatter, or one of its convenience wrappers like String.format  e.g.", "label": {"api": {"Formatter": [[10, 18]], "String.format": [[61, 73]]}}}, {"text": "By using AtomicInteger you can easily increment your frequency counter", "label": {"api": {"AtomicInteger": [[9, 21]]}}}, {"text": "The problem is that if I use the builtin monitor objects via wait() and notify()/notifyAll() then there's no mechanism for waiting for multiple objects; if I use CountDownLatch it's unclear how to compose more than one object", "label": {"api": {"CountDownLatch": [[162, 175]]}}}, {"text": "The and() case is easy to handle if I implement using CountDownLatch -- I just wait for all of them in any sequence", "label": {"api": {"CountDownLatch": [[54, 67]]}}}, {"text": "You could move every third element to a temporary list then use List#removeAll(Collection) to remove the items when you finish each loop...until the master list was empty..", "label": {"api": {"List#removeAll(Collection)": [[64, 89]]}}}, {"text": "The simplest way to store this would be to use a Map<Swap, Int> where Swap is a class that holds i1, j1, i2, j2 (and has equals and hashCode methods defined)", "label": {"api": {"Map<Swap, Int>": [[49, 62]]}}}, {"text": "I suggest using a BlockingQueue, as the take() method will block until the sum has been put onto the thread, satisfying your last requirement without having to use join()", "label": {"api": {"BlockingQueue": [[18, 30]]}}}, {"text": "You need to share a BlockingQueue between them, and you need to start both threads by instantiating a Thread and calling start()", "label": {"api": {"BlockingQueue": [[20, 32]]}}}, {"text": "Either the game loop or ServerSocket.accept() should be handled in its own Thread, while the other runs in the main thread", "label": {"api": {"Thread": [[75, 80]]}}}, {"text": "You might need to flush the buffered writer to write all the contents to file", "label": {"api": {"flush": [[18, 22]]}}}, {"text": "Take a look at the Java Robot#createScreenCapture API", "label": {"api": {"Robot#createScreenCapture": [[24, 48]]}}}, {"text": "Java Sound offers FloatControl instances for various sound line functionality, and both a MASTER_GAIN & VOLUME control type", "label": {"api": {"MASTER_GAIN": [[90, 100]], "VOLUME": [[104, 109]]}}}, {"text": "I am using VOLUME control type", "label": {"api": {"VOLUME": [[11, 16]]}}}, {"text": "Check out the classes SSLSocket, SSLServerSocket, SSLSocketFactory and SSLServerSocketFactory", "label": {"api": {"SSLSocket": [[22, 30], [50, 58]], "SSLServerSocket": [[33, 47], [71, 85]], "SSLSocketFactory": [[50, 65]], "SSLServerSocketFactory": [[71, 92]]}}}, {"text": "The String.split method will do it just fine", "label": {"api": {"String.split": [[4, 15]]}}}, {"text": "You need to extract the complete data within the required tag using XPath, and later use String.split(), to get the desired values out of the complete string", "label": {"api": {"String.split()": [[89, 102]]}}}, {"text": "StringTokenizer supports multiple delimiters that can be listed in a string as second parameter", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "The 3D objects do not exist as variables, but are added to the TransformGroup via new Sphere() for example, however the TransformGroup class does not implement Serializable interface", "label": {"api": {"Serializable": [[160, 171]]}}}, {"text": "If they actually are, then you could use a XMLEncoder to serialize them", "label": {"api": {"XMLEncoder": [[43, 52]]}}}, {"text": "But the XMLEncoder might be a reasonable first step to see whether this works at all, or if not, where it fails", "label": {"api": {"XMLEncoder": [[8, 17]]}}}, {"text": "The ImageIO class is in the javax.imageio package", "label": {"api": {"javax.imageio": [[28, 40]]}}}, {"text": "The DefaultTableModel you probably use (as you do not talk about any other) is Serializable", "label": {"api": {"DefaultTableModel": [[4, 20]]}}}, {"text": "Obtain it using JTable.getModel() and write to a file upon shutdown using ObjectOutputStream", "label": {"api": {"JTable.getModel()": [[16, 32]]}}}, {"text": "On the program startup, load it back using ObjectInputStream and set for the table", "label": {"api": {"ObjectInputStream": [[43, 59]]}}}, {"text": "If you do not know when your application will terminate, add the Window closing listener and save you table model there", "label": {"api": {"add the Window closing listener": [[57, 87]]}}}, {"text": "Serializing Java Beans to XML using XMLEncoder and XMLDecoder seems like a pretty neat approach", "label": {"api": {"XMLEncoder": [[36, 45]], "XMLDecoder": [[51, 60]]}}}, {"text": "Or should the use of XMLDecoder on untrusted documents be avoided for security reasons", "label": {"api": {"XMLDecoder": [[21, 30]]}}}, {"text": "Check out System.getProperties()", "label": {"api": {"System.getProperties()": [[10, 31]]}}}, {"text": "When you start the C++ binary from Java using a Process object (either by using a ProcessBuilder or the quick and dirty method Runtime.exec()), you can use process.getInputStream() to read the text output of the C++ binary", "label": {"api": {"Process": [[48, 54], [82, 88]], "ProcessBuilder": [[82, 95]], "Runtime.exec()": [[127, 140]], "process.getInputStream()": [[156, 179]]}}}, {"text": "Read more about java.util.Random", "label": {"api": {"java.util.Random": [[16, 31]]}}}, {"text": "Alternatively, you can use this construct for FileWriter which allows the file to be appended to", "label": {"api": {"allows the file to be appended to": [[63, 95]]}}}, {"text": "You probably want to use a Set, and more specifically a SortedSet (the basic implementation of it being a TreeSet), instead of a List", "label": {"api": {"SortedSet": [[56, 64]], "TreeSet": [[106, 112]]}}}, {"text": "This will require that your post class implement Comparable of itself, however", "label": {"api": {"Comparable": [[49, 58]]}}}, {"text": "Javadoc seems to imply that addAll is inherited from AbstractQueue where it is implemented as a sequence of adds", "label": {"api": {"AbstractQueue": [[53, 65]]}}}, {"text": "See Class.getName() for details of the class name format", "label": {"api": {"Class.getName()": [[4, 18]]}}}, {"text": "See the Javadoc for Class#getName() for examples on how to represent array types as strings", "label": {"api": {"Class#getName()": [[20, 34]]}}}, {"text": "There are old Holder classes in J2SE API, specially designed to support calls to methods with  \"returnable parameters\" (IntHolder or StringHolder, for instance)", "label": {"api": {"IntHolder": [[120, 128]], "StringHolder": [[133, 144]]}}}, {"text": "A very simple implementation with String.split()", "label": {"api": {"String.split()": [[34, 47]]}}}, {"text": "Use addAll() method", "label": {"api": {"addAll()": [[4, 11]]}}}, {"text": "You should not be ignoring the outcome of ResultSet#next()", "label": {"api": {"ResultSet#next()": [[42, 57]]}}}, {"text": "Also, to obtain the first column as an int, you should be using ResultSet#getInt(), passing the column index or column label", "label": {"api": {"ResultSet#getInt()": [[64, 81]]}}}, {"text": "To get the name of a enum variable use name()", "label": {"api": {"name()": [[39, 44]]}}}, {"text": "To get the enum from a (string) name, use valueOf()", "label": {"api": {"valueOf()": [[42, 50]]}}}, {"text": "still not thread safe, if you modify otherList from another thread, then you may want to make that otherList (and even newList) a CopyOnWriteArrayList, for instance -- or use a lock primitive, such as ReentrantReadWriteLock to serialize read/write access to whatever lists are concurrently accessed", "label": {"api": {"CopyOnWriteArrayList": [[130, 149]], "ReentrantReadWriteLock": [[201, 222]]}}}, {"text": "List.copyOf() returns an unmodifiable List containing the elements of the given Collection", "label": {"api": {"List.copyOf()": [[0, 12]]}}}, {"text": "use the for loop construct and take a look at java's Random class to generate the numbers", "label": {"api": {"Random": [[53, 58]]}}}, {"text": "You have to use Socket#shutdownOutput()", "label": {"api": {"Socket#shutdownOutput()": [[16, 38]]}}}, {"text": "Instead of using int you can use Integer (Integer javadoc) because it is a nullable Java class", "label": {"api": {"Integer javadoc": [[42, 56]]}}}, {"text": "Alternatively, if you're running Java 7+ you can specify UNICODE_CHARACTER_CLASS mode and go on using \\s", "label": {"api": {"UNICODE_CHARACTER_CLASS mode": [[57, 84]]}}}, {"text": "Simply use setDaemon() method", "label": {"api": {"setDaemon()": [[11, 21]]}}}, {"text": "Since Java 8 the Comparator interface has had a few utility default methods added that assist with deriving a comparator from a comparable", "label": {"api": {"Comparator": [[17, 26]]}}}, {"text": "To ensure that your file is readable to the public you should add read permissions to the file", "label": {"api": {"add read permissions to the file": [[62, 93]]}}}, {"text": "Use Files instead", "label": {"api": {"Files": [[4, 8]]}}}, {"text": "You need to customize the CellFactory of the ComboBox to maintain the visualization of the items in the box", "label": {"api": {"CellFactory": [[26, 36]]}}}, {"text": "If you are using JDBC, you can cancel executing query with Statement.cancel()", "label": {"api": {"Statement.cancel()": [[59, 76]]}}}, {"text": "This behaviour is explained in the javadoc of ArrayList", "label": {"api": {"javadoc of ArrayList": [[35, 54]]}}}, {"text": "I am not sure exactly what you are looking for here, but instead of implementing your own DoubleProperty from scratch (Your implementation is missing the proper handling of listeners, for instance) I would suggest to use SimpleDoubleProperty as a base", "label": {"api": {"SimpleDoubleProperty": [[221, 240]]}}}, {"text": "so instead, if you make your query into a PreparedStatement, you could then use PreparedStatement.setParameter(int, String) to insert your dynamic values instead of the placeholders and the JDBC driver will do all of your escaping for you", "label": {"api": {"PreparedStatement": [[42, 58], [80, 96]], "PreparedStatement.setParameter(int, String)": [[80, 122]]}}}, {"text": "JTable.getSelectedRows() can you help you in this case", "label": {"api": {"JTable.getSelectedRows()": [[0, 23]]}}}, {"text": "If the key (with the certificates) is stored in PKCS#12 you can use the KeyStore from Java", "label": {"api": {"KeyStore": [[72, 79]]}}}, {"text": "When using Maps and Sets, you must make sure that the classes for your values (and in the case of Map, also the keys, of course) implement adequate hashCode() and equals() methods", "label": {"api": {"hashCode()": [[148, 157]], "equals()": [[163, 170]]}}}, {"text": "Try to set the Connectiontimeout of the HttpURLConnection and try to redesign your while loop like", "label": {"api": {"Connectiontimeout": [[15, 31]]}}}, {"text": "You could use a Converter to automatically transform the input; see the Java EE 6 tutorial for more", "label": {"api": {"Converter": [[16, 24]]}}}, {"text": "Using a binary semaphore", "label": {"api": {"semaphore": [[15, 23]]}}}, {"text": "you can use Date.compareTo() method", "label": {"api": {"Date.compareTo()": [[12, 27]]}}}, {"text": "Also there is the AsyncResponse feature", "label": {"api": {"AsyncResponse": [[18, 30]]}}}, {"text": "In order to avoid reading in the whole file, which may not be possible in your case, you may want to use a RandomAccessFile instead of a standard java FileInputStream", "label": {"api": {"RandomAccessFile": [[107, 122]]}}}, {"text": "With RandomAccessFile, you can use the seek(long position) method to skip to an arbitrary place in the file and start reading there", "label": {"api": {"RandomAccessFile": [[5, 20]]}}}, {"text": "You could use a LinkedHashSet, which is a Set that iterates in insertion order", "label": {"api": {"LinkedHashSet": [[16, 28]]}}}, {"text": "Alternatively, the following regex will also match correctly (for ASCII alphabetic characters only) when passing in the CASE_INSENSITIVE", "label": {"api": {"CASE_INSENSITIVE": [[120, 135]]}}}, {"text": "EventListenerList is another way to implement the observer pattern", "label": {"api": {"EventListenerList": [[0, 16]]}}}, {"text": "You could load it into a Document object", "label": {"api": {"Document": [[25, 32]]}}}, {"text": "That would allow you to call methods reflective methods like getEnumConstants()", "label": {"api": {"getEnumConstants()": [[61, 78]]}}}, {"text": "If all you want is to parse a String to a BigDecimal, you can use the constructor that gets a string as a argument", "label": {"api": {"constructor": [[70, 80]]}}}, {"text": "The constructor takes care of the basic parsing", "label": {"api": {"constructor": [[4, 14]]}}}, {"text": "For complex parsing (involving thousands separators), you can use the methods in the DecimalFormat class with setParseBigDecimal set to true", "label": {"api": {"DecimalFormat": [[85, 97]], "setParseBigDecimal": [[110, 127]]}}}, {"text": "Depending on the Java class you use to read the PHP, use something like BufferedReader.readLine", "label": {"api": {"BufferedReader.readLine": [[72, 94]]}}}, {"text": "I have a Java web application that has functionality to fetch remote files using URL", "label": {"api": {"URL": [[81, 83]]}}}, {"text": "While I was testing the code I found out that it is possible for an anonymous user to read a local file by modifying the path of the file, /etc/passwd, to file URL schema, file:///etc/passwd, and the file will be read by URL, here is an example", "label": {"api": {"URL": [[160, 162], [221, 223]]}}}, {"text": "These classes must implement UndoableEdit  (preferably by subclassing AbstractUndoableEdit)", "label": {"api": {"UndoableEdit ": [[29, 41]], "AbstractUndoableEdit": [[70, 89]]}}}, {"text": "Then you can use these edit classes with instances of UndoManager and UndoableEditSupport", "label": {"api": {"UndoManager": [[54, 64]], "UndoableEditSupport": [[70, 88]]}}}, {"text": "You can add UndoableEdit objects directly to UndoManager (it has an addEdit method)", "label": {"api": {"UndoableEdit ": [[12, 24]], "UndoManager": [[45, 55]]}}}, {"text": "If you want to manage UndoableEditListener objects (for example to notify menu items or buttons), you can use UndoableEditSupport for that - it has the addUndoableEditListener that you are looking for", "label": {"api": {"UndoableEditSupport": [[110, 128]]}}}, {"text": "The example screenshot that you prints the text to a JTextArea, not a JPanel", "label": {"api": {"JTextArea": [[53, 61]]}}}, {"text": "If you click on the link I just gave, you should be able to find a method to print text to the JTextArea", "label": {"api": {"JTextArea": [[95, 103]]}}}, {"text": "This is my first attempt at a decent GUI for a Java app and I needed to use JLists with custom ListModels in order to represent certain structures", "label": {"api": {"JLists": [[76, 81]], "ListModels": [[95, 104]]}}}, {"text": "Logging messages made it clear that the internal structures are getting populated, but even though they are both respective ListModels for my JLists, one of them isn't working as expected", "label": {"api": {"JLists": [[142, 147]], "ListModels": [[124, 133]]}}}, {"text": "It seems that, according to the epic JDK reference, you could use a while zis.getNextEntry() != null loop to loop through the file (where zis is a ZipInputStream), then use zis.read() to read into an array, which is sent to an ArrayList or similar", "label": {"api": {"the epic JDK reference": [[28, 49]]}}}, {"text": "You can use Integer.valueOf", "label": {"api": {"Integer.valueOf": [[12, 26]]}}}, {"text": "In managed beans you have already direct access to HttpServletRequest and HttpServletResponse via ExternalContext", "label": {"api": {"ExternalContext": [[98, 112]]}}}, {"text": "Note that the ExternalContext also offers a convenient getRequestCookieMap() method which returns a mapping of all cookies so that you don't need to manually traverse the Cookie[]", "label": {"api": {"ExternalContext": [[14, 28]], "getRequestCookieMap()": [[55, 75]]}}}, {"text": "I know that you're using JSF 1.2, but if you were using JSF 2.0 or newer, then you could also have used the convenient addResponseCookie() method to add a cookie without the need to obtain the \"raw\" servlet response", "label": {"api": {"addResponseCookie()": [[119, 137]]}}}, {"text": "Use the negative lookahead / lookbehind constructs from the special constructs section of the Java Pattern documentation", "label": {"api": {"the special constructs section": [[56, 85]], "Pattern": [[99, 105]]}}}, {"text": "You can use the Pattern and a simple loop to achieve the results that you are looking for", "label": {"api": {"Pattern": [[16, 22]]}}}, {"text": "Swing has concurrency mechanisms such as SwingWorker that allow non-visual processing to be done in parallel with the Swing application", "label": {"api": {"SwingWorker": [[41, 51]]}}}, {"text": "Use the java java.net.URLEncoder#encode()", "label": {"api": {"java.net.URLEncoder#encode()": [[13, 40]]}}}, {"text": "You will have to do following code for doing JAXB Unmarshalling", "label": {"api": {"JAXB Unmarshalling": [[45, 62]]}}}, {"text": "As noted in Memory Consistency Properties", "label": {"api": {"Memory Consistency Properties": [[12, 40]]}}}, {"text": "DefaultTableModel to operate on it easily", "label": {"api": {"DefaultTableModel": [[0, 16]]}}}, {"text": "In this case, if your columns are delimitted in some unique way, the easiest way to read the data is using java Scanner", "label": {"api": {"Scanner": [[112, 118]]}}}, {"text": "To use for in you will have to convert it to an array first", "label": {"api": {"to an array": [[42, 52]]}}}, {"text": "String#matches(regex) Tells whether or not this string matches the given regular expression", "label": {"api": {"String#matches(regex)": [[0, 20]]}}}, {"text": "your string dummyMessage  doesn't match expression, as it tries to check if dummyMessage  is 3  you probably want String.contains(charseq) instead", "label": {"api": {"String.contains(charseq)": [[114, 137]]}}}, {"text": "I have some code that looks like \"Sat May 12 04:46:05 EDT 2012\" that is currently being parsed by the java.util.Date's Date(String s) constructor", "label": {"api": {"Date(String s)": [[119, 132]]}}}, {"text": "Java 6 API - AttributeOverride", "label": {"api": {"Java 6 API - AttributeOverride": [[0, 29]]}}}, {"text": "What does OMG stand for with reference to the CORBA API's", "label": {"api": {"CORBA API's": [[46, 56]]}}}, {"text": "When you call String.getBytes() (JDK documentation) you encodes characters of the given string into a sequence of bytes using the platform's default charset", "label": {"api": {"JDK documentation": [[33, 49]]}}}, {"text": "For a Swing GUI, use a JPasswordField", "label": {"api": {"JPasswordField": [[23, 36]]}}}, {"text": "In case of HTTP BASIC authentication, the username is available by HttpServletRequest#getRemoteUser()", "label": {"api": {"HttpServletRequest#getRemoteUser()": [[67, 100]]}}}, {"text": "Further, the user principal is available by HttpServletRequest#getUserPrincipal()", "label": {"api": {"HttpServletRequest#getUserPrincipal()": [[44, 80]]}}}, {"text": "Run is a special method in Thread and Runnable objects, which are used for multithreading", "label": {"api": {"Thread": [[27, 32]], "Runnable": [[38, 45]]}}}, {"text": "The program communicating with the Smart Card could be a native program built on top of PC/SC, or a Java program using the package javax.smartcardio built into Java since the JRE release (1.)6", "label": {"api": {"package javax.smartcardio": [[123, 147]]}}}, {"text": "If you mean the whacky \"ellipsis character\" (ASCII 133 … three little dots in one character), simply code that character in a string used with the contains() method", "label": {"api": {"contains()": [[147, 156]]}}}, {"text": "You can use Collections.synchronizedMap to make it thread safe", "label": {"api": {"Collections.synchronizedMap": [[12, 38]]}}}, {"text": "And use thread.join to make sure printing is done only when all threads are dead", "label": {"api": {"thread.join": [[8, 18]]}}}, {"text": "Can you use java.io.File#isDirectory() instead", "label": {"api": {"java.io.File#isDirectory()": [[12, 37]]}}}, {"text": "From the documentation of Node.getTextContent(), for a node type of ELEMENT_NODE", "label": {"api": {"documentation of Node.getTextContent()": [[9, 46]]}}}, {"text": "You can use the Observer pattern", "label": {"api": {"Observer": [[16, 23]]}}}, {"text": "Java has built-in support for this pattern in the form of the Observable and Observer classes", "label": {"api": {"Observable": [[62, 71]], "Observer": [[77, 84]]}}}, {"text": "Basically, your LayersManager would extend Observable and your LayersView would implement Observer", "label": {"api": {"Observable": [[43, 52]], "Observer": [[90, 97]]}}}, {"text": "You would then call addObserver on the LayersManager and pass in your LayersView", "label": {"api": {"Observer": [[23, 30]]}}}, {"text": "The notifyObservers method can take an object as a parameter if you want the Observer listeners to receive some data", "label": {"api": {"Observer": [[10, 17], [77, 84]]}}}, {"text": "Once notifyObservers is called, your LayersView will have the update method called", "label": {"api": {"Observer": [[11, 18]]}}}, {"text": "For that, I would propose to use XMLEncoder", "label": {"api": {"XMLEncoder": [[33, 42]]}}}, {"text": "In this case it is only necessary to call the topmost stream handler close() method -  the BufferedOutputStream's one", "label": {"api": {"close()": [[69, 75]], "BufferedOutputStream": [[91, 110]]}}}, {"text": "so, the dob.flush() in try block is commented out because the dob.close() line in the finally block flushes the stream", "label": {"api": {"close()": [[66, 72]]}}}, {"text": "The FileOutputStream constructor creates an empty file on the disk", "label": {"api": {"constructor": [[21, 31]]}}}, {"text": "A new FileDescriptor object is created to represent this file connection", "label": {"api": {"FileDescriptor": [[6, 19]]}}}, {"text": "Where a FileDescriptor is", "label": {"api": {"FileDescriptor": [[8, 21]]}}}, {"text": "For example, in the String.isEmpty() javadoc, there is a link to the String.length() method", "label": {"api": {"String.isEmpty()": [[20, 35]], "String.length()": [[69, 83]]}}}, {"text": "Note - the approach did not completely diasppear in java, for example Collection#add() returns a boolean that indicates if the operation succeeded or not", "label": {"api": {"Collection#add()": [[70, 85]]}}}, {"text": "I think the only solution is to extract the class name from the current stack-trace (see Thread.getStackTrace()), which will give it to you as a String, from which you can get a Class object using Class.forName(String), but that's much uglier than your current approach", "label": {"api": {"Thread.getStackTrace()": [[89, 110]]}}}, {"text": "The Desktop.mail() function is a utility method for launching whatever mail program may exist in the users system (if any)", "label": {"api": {"Desktop.mail()": [[4, 17]]}}}, {"text": "If you need this level of control then you should be using the JavaMail API, which does a lot of what you seem to need", "label": {"api": {"JavaMail API": [[63, 74]]}}}, {"text": "The answer to your question is in the most natural place, the javadocs for ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[75, 91]]}}}, {"text": "Use the month constants in the Calendar class to avoid this common mistake", "label": {"api": {"Calendar": [[31, 38]]}}}, {"text": "The method matches returns a boolean", "label": {"api": {"matches": [[11, 17]]}}}, {"text": "To solve your specific problem, you can use String.replaceAll, which takes a replacement regex", "label": {"api": {"String.replaceAll": [[44, 60]]}}}, {"text": "You need to iterate through the Set and split each String", "label": {"api": {"split": [[40, 44]]}}}, {"text": "You can use split method if you want", "label": {"api": {"split": [[12, 16]]}}}, {"text": "The contract on read(byte[]) is that it reads some data, and returns how many bytes have been read", "label": {"api": {"read(byte[])": [[16, 27]]}}}, {"text": "An easy way to do this is by using read(b, off, len) in a loop", "label": {"api": {"read(b, off, len)": [[35, 51]]}}}, {"text": "An alternative is to use replaceAll but with Matcher.quoteReplacement", "label": {"api": {"Matcher.quoteReplacement": [[45, 68]]}}}, {"text": "You can provide additional things for selectin in a JFileChooser if you pass a customited FileSystemView to its constructor", "label": {"api": {"JFileChooser": [[52, 63]], "FileSystemView": [[90, 103]], "its constructor": [[108, 122]]}}}, {"text": "I guess it should be possible to use jCIFS to implement a version which presents network hosts under a different root called “Network”, or something like this", "label": {"api": {"root": [[113, 116]]}}}, {"text": "If you don't want to fake the file system itself, you'll have to either create your own dialog or find the correct hooks to modify an existing JFileChooser to custmize it to your needs, either by subclassing and overriding specific methods, or by navigating the component hierarchy and replacing certain components, or by a combination of these two", "label": {"api": {"JFileChooser": [[143, 154]]}}}, {"text": "If you really only want to select computers, and won't navigate down the paths to actual files on these computers, then a file chooser is probably overkill, and a JOptionPane would probably be better suited", "label": {"api": {"JOptionPane": [[163, 173]]}}}, {"text": "You can use it to display an input dialog which shows a list of values to select from", "label": {"api": {"input dialog which shows a list of values": [[29, 69]], "input dialog": [[29, 40]]}}}, {"text": "Or if you want more control, you can create your own JList and pass that as the message argument for the input dialog", "label": {"api": {"JList": [[53, 57]], "input dialog": [[105, 116]]}}}, {"text": "What you would have to do is set your LOCALE to AR so that the resource manager will let you pull out string from values-ar/strings.xml, then get a list of Fields using reflection R.string.class.getFields()", "label": {"api": {"Field": [[156, 160], [198, 202]], "R.string.class.getFields()": [[180, 205]]}}}, {"text": "Use the method deriveFont to resize the font that you have just loaded", "label": {"api": {"deriveFont": [[15, 24]]}}}, {"text": "The API spec says", "label": {"api": {"API spec": [[4, 11]]}}}, {"text": "From the Matcher Javadoc", "label": {"api": {"Matcher Javadoc": [[9, 23]]}}}, {"text": "You can use printf which uses Formatter for padding here", "label": {"api": {"Formatter": [[30, 38]]}}}, {"text": "concat(string str) appends the string str to the end of the String object it is called on", "label": {"api": {"concat(string str)": [[0, 17]]}}}, {"text": "For error status codes like 401, use the more specific sendError()", "label": {"api": {"sendError()": [[55, 65]]}}}, {"text": "Perhaps you actually want a PriorityQueue", "label": {"api": {"PriorityQueue": [[28, 40]]}}}, {"text": "You can change the date format by specifying the a format string through the \"java.util.logging.SimpleFormatter.format\" system property or LogManager property", "label": {"api": {"java.util.logging.SimpleFormatter": [[78, 110]]}}}, {"text": "SwingWorker would be a better option here", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "I know that there is a new Method in Java7, but I was hoping to get around Java7", "label": {"api": {"Java7": [[37, 41], [75, 79]]}}}, {"text": "Check SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "parse string to date using SimpleDateFormat, convert date to desired format using again SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[27, 42], [88, 103]]}}}, {"text": "Afterwards, a good way to quickly scale your thread pools to properly fit your resources is to use one of the Executors thread pools", "label": {"api": {"Executors": [[110, 118]]}}}, {"text": "I would also suggest using Character.isDigit or a custom check rather than converting each character to a string, then parsing it and catching an exception", "label": {"api": {"Character.isDigit": [[27, 43]]}}}, {"text": "Note that Character.isDigit will return true for non-ASCII digits, which you may not want", "label": {"api": {"Character.isDigit": [[10, 26]]}}}, {"text": "See the AclFileAttributeView Javadoc", "label": {"api": {"AclFileAttributeView Javadoc": [[8, 35]]}}}, {"text": "You need to set the formatter's time zone as well before performing the format", "label": {"api": {"formatter's time zone": [[20, 40]]}}}, {"text": "Use a SwingWorker", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "SwingWorker's done() method will be invoked on the Swing UI thread", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "If you want the thread to finish before main then you can use the Thread.join method on thread to wait for it", "label": {"api": {"Thread.join": [[66, 76]]}}}, {"text": "If you need to fetch the same information regularly, you can reuse a builder and use it in combination with a ScheduledThreadPoolExecutor for example", "label": {"api": {"ScheduledThreadPoolExecutor": [[110, 136]]}}}, {"text": "IllegalAccessError is a subclass of IncompatibleClassChangeError", "label": {"api": {"IncompatibleClassChangeError": [[36, 63]]}}}, {"text": "If an IncompatibleClassChangeError is thrown while your code is executing, this typically indicates that the your code isn't running with the same classes it was compiled against", "label": {"api": {"IncompatibleClassChangeError": [[6, 33]]}}}, {"text": "Don't forget to go over the documentation for List and ArrayList, in order to better understand how they work", "label": {"api": {"List": [[46, 49], [60, 63]], "ArrayList": [[55, 63]]}}}, {"text": "Use a ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[6, 27]]}}}, {"text": "BigInteger or BigDecimal", "label": {"api": {"BigInteger": [[0, 9]], "BigDecimal": [[14, 23]]}}}, {"text": "BigInteger is capable of storing integer (i.e", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "Take a look at the Comparator or Comparable interfaces and how they are used", "label": {"api": {"Comparator": [[19, 28]], "Comparable": [[33, 42]]}}}, {"text": "You may be looking for ConvolveOp; see the articles cited here for examples", "label": {"api": {"ConvolveOp": [[23, 32]]}}}, {"text": "If you are serious about creating your own format then you should take a look through java's inbuilt xml libraries and make a format using xml, http://docs.oracle.com/javase/7/docs/api/ is a good place to start then browse to the javax.xml.* packages", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/": [[144, 184]]}}}, {"text": "And it uses a standard JDK exception, which is meant to be used in such situations", "label": {"api": {"standard JDK exception": [[14, 35]]}}}, {"text": "This behavior is explicitly documented in String.split(String regex) (emphasis mine)", "label": {"api": {"String.split(String regex)": [[42, 67]]}}}, {"text": "If you want those trailing empty strings included, you need to use String.split(String regex, int limit) with a negative value for the second parameter (limit)", "label": {"api": {"String.split(String regex, int limit)": [[67, 103]]}}}, {"text": "You can see the synchronizedList method", "label": {"api": {"synchronizedList": [[16, 31]]}}}, {"text": "In this case, you're passing the array to setPixels method, which accordingly to its javadocs doesn't explicitly check for the bounds or size of the array", "label": {"api": {"setPixels": [[42, 50]]}}}, {"text": "Since Java 7, JComboBox requires generics to describe the data which it holds", "label": {"api": {"JComboBox": [[14, 22]]}}}, {"text": "Given the constructor ImageView(Image) I would say store them as an Image", "label": {"api": {"ImageView(Image)": [[22, 37]]}}}, {"text": "ThreadLocal is not a replacement for synchronization or thread-safe object access", "label": {"api": {"ThreadLocal": [[0, 10]]}}}, {"text": "If the same object is assigned to a ThreadLocal from different threads, then the program is no more thread-safe than it was before", "label": {"api": {"ThreadLocal": [[36, 46]]}}}, {"text": "ThreadLocal acts-like a variable; that is, it \"names\" or \"refers to\" an object", "label": {"api": {"ThreadLocal": [[0, 10]]}}}, {"text": "[ThreadLocal] provides thread-local variables [.", "label": {"api": {"ThreadLocal": [[1, 11]]}}}, {"text": "That is, what ThreadLocal does is it provides get/set isolation between threads that use the same ThreadLocal object", "label": {"api": {"ThreadLocal": [[14, 24], [98, 108]]}}}, {"text": "So each thread could assign/retrieve its own different object to the ThreadLocal; but this would still require a \"clone\" or new instantiation to assign the different objects to begin with", "label": {"api": {"ThreadLocal": [[69, 79]]}}}, {"text": "Remember, an assignment (or method invocation) never creates an implicit clone/copy/duplicate of an object - and this extends to ThreadLocal", "label": {"api": {"ThreadLocal": [[129, 139]]}}}, {"text": "Use SimpleDateFormat in Java to parse your String to a java.util.Date", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Then use a PreparedStatement and set the date on that", "label": {"api": {"set the date": [[33, 44]]}}}, {"text": "For what it's worth, you may find the Files.readAllLines method easier to use", "label": {"api": {"Files.readAllLines": [[38, 55]]}}}, {"text": "You use Certificate.getEncoded() and Key.getEncoded() to get DER and do the base 64 encoding and header/footer manually, e.g", "label": {"api": {"Certificate.getEncoded()": [[8, 31]], "Key.getEncoded()": [[37, 52]]}}}, {"text": "using DatatypeConverter.printBase64Binary() or some other way", "label": {"api": {"DatatypeConverter.printBase64Binary()": [[6, 42]]}}}, {"text": "You will probably want to use the string manipulation methods in String", "label": {"api": {"String": [[65, 70]]}}}, {"text": "In particular check out String.split using", "label": {"api": {"String": [[24, 29]], "String.split": [[24, 35]]}}}, {"text": "You could also look into using more advanced regex's, see Pattern for more information", "label": {"api": {"Pattern": [[58, 64]]}}}, {"text": "You should use BitSet, however the way you are doing it is the correct way to check to see if only valid flags are set", "label": {"api": {"BitSet": [[15, 20]]}}}, {"text": "You can use BitSet.valueOf(...) to create  a BitSet from an array of bytes", "label": {"api": {"BitSet": [[12, 17], [45, 50]]}}}, {"text": "because, FileReader doesnt have readLine() method, you should use BufferedReader instead", "label": {"api": {"FileReader": [[9, 18]], "BufferedReader": [[66, 79]]}}}, {"text": "Look at the methods of the Manager API", "label": {"api": {"Manager": [[27, 33]]}}}, {"text": "Use the ordinary InputStream, and read into byte array", "label": {"api": {"InputStream": [[17, 27]]}}}, {"text": "InputStream will read all bytes as they are", "label": {"api": {"InputStream": [[0, 10]]}}}, {"text": "You can process them and later produce strings yourself later using new String(array, offset, length)", "label": {"api": {"new String(array, offset, length)": [[68, 100]]}}}, {"text": "Java has the concept of SecurityManager which enables you to fine tune what can or cannot run in your virtual machine", "label": {"api": {"SecurityManager": [[24, 38]]}}}, {"text": "It also allows you to compile code and load the resulting classes at runtime", "label": {"api": {"compile": [[22, 28]], "load": [[39, 42]]}}}, {"text": "You can then run whatever code is in those classes, provided the SecurityManager does not throw a SecurityException because the operation is not permitted", "label": {"api": {"SecurityManager": [[65, 79]]}}}, {"text": "This post shows a contrived example that compiles, loads and runs some code (provided as text source code) at runtime", "label": {"api": {"compile": [[41, 47]], "load": [[51, 54]]}}}, {"text": "This is documented in the Javadoc", "label": {"api": {"in the Javadoc": [[19, 32]]}}}, {"text": "I was reading http://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html about  intrinsic locks and semaphores, but then read some http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Semaphore.html about permits - all used with the terminology, \"release\" and \"acquire\"", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Semaphore.html": [[147, 226]]}}}, {"text": "Moreover, if you don't support null in equals, then you are breaking the contract for equals as specified in Object, which explicitly mentions that passing in null should return false", "label": {"api": {"breaking the contract for equals as specified in Object": [[60, 114]]}}}, {"text": "I made sure that the searchString does not contain /, before inserting it as literal with Pattern.quote", "label": {"api": {"Pattern.quote": [[90, 102]]}}}, {"text": "The Robot class has methods that make this fairly easy", "label": {"api": {"Robot": [[4, 8]]}}}, {"text": "Obviously it will return in same manner in witch its returning because set is.", "label": {"api": {"set": [[71, 73]]}}}, {"text": "More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element", "label": {"api": {"set": [[15, 17]]}}}, {"text": "As implied by its name, this interface models the mathematical set abstraction", "label": {"api": {"set": [[63, 65]]}}}, {"text": "If your application needs to handle write errors it is not safe as buffered data flushed on close may be lost and the error swallowed", "label": {"api": {"buffered data flushed on close": [[67, 96]]}}}, {"text": "You basically need to homebrew a servlet filter which is mapped on /* and checks if the current request URL is an extensionless one and if so, then perform a RequestDispatcher#forward() call on the URL with the file extension appended (you know, a forward does not modify the current request URL as a redirect would do)", "label": {"api": {"RequestDispatcher#forward()": [[158, 184]]}}}, {"text": "You also need a custom view handler to produce the desired extensionless URLs for JSF <h:form>, <h:link>, etc", "label": {"api": {"view handler": [[23, 34]]}}}, {"text": "I want to customize hashcode of  StackTraceElement class", "label": {"api": {" StackTraceElement class": [[32, 55]]}}}, {"text": "My problem is how to use this new customized class instead of default StackTraceElement class of JVM", "label": {"api": {" StackTraceElement class": [[69, 92]]}}}, {"text": "For many cases where you want to apply some operation to a specific range of List, you can use subList()", "label": {"api": {"use subList()": [[91, 103]]}}}, {"text": "You can do it by hand (with null checks inside setters, for example), or alternatively you can use the Optional class in Java 8 (or Optional in Google's Guava if you're not on Java 8), which offers an opinionated null-handling design pattern to help you react to unwanted nulls the moment they are introduced, rather than wait for some poor consumer to encounter them later on", "label": {"api": {"Optional": [[103, 110], [132, 139]]}}}, {"text": "Like as with every other UIInput component, the value has to be a fullworthy bean property", "label": {"api": {"UIInput": [[25, 31]]}}}, {"text": "I suggest you use a HashMap that maps a property name to its value and interactively modify that map", "label": {"api": {"HashMap": [[20, 26]]}}}, {"text": "Set actionCommand to each of the button", "label": {"api": {"actionCommand": [[4, 16]]}}}, {"text": "Keep a reverse ordered PriorityQueue of the k-1 highest value integers you have met so far", "label": {"api": {"PriorityQueue": [[23, 35]]}}}, {"text": "From the documentation on Java's  ByteBuffer Class", "label": {"api": {"ByteBuffer Class": [[34, 49]]}}}, {"text": "Use split method to get substrings then check each one starts with \"#\" or not", "label": {"api": {"split method": [[4, 15]]}}}, {"text": "The JavaDocs give an example", "label": {"api": {"The JavaDocs": [[0, 11]]}}}, {"text": "The return type of InputStream#read() is an int, where the value can be read as a byte if it falls in the range of 0-255", "label": {"api": {"InputStream#read()": [[19, 36]]}}}, {"text": "Try using dialog.requestFocus() if dialog is the newly created JDialog", "label": {"api": {"requestFocus()": [[17, 30]]}}}, {"text": "See requestFocus() or requestFocusInWindow() for more information", "label": {"api": {"requestFocus()": [[4, 17]], "requestFocusInWindow()": [[22, 43]]}}}, {"text": "Alternatively, you can also use setJMSReplyTo method to specify the Queue you want the consumer reply to when it receives the message from the producer", "label": {"api": {"setJMSReplyTo": [[32, 44]]}}}, {"text": "How about using Long.parseLong(String)", "label": {"api": {"Long.parseLong(String)": [[16, 37]]}}}, {"text": "The difference is using getDeclaredMethod(), which gets methods of all visibilities (public, protected, package/default and private) instead of getMethod(), which only gets methods with public visibility", "label": {"api": {"getDeclaredMethod()": [[24, 42]], "getMethod()": [[144, 154]]}}}, {"text": "Consider using format", "label": {"api": {"format": [[15, 20]]}}}, {"text": "When an interface has no methods, it's generally called a marker interface; Serializable is one of many examples of such an interface from the JDK", "label": {"api": {"Serializable": [[76, 87]]}}}, {"text": "Semaphore allows multiple threads to \"acquire\" a resource", "label": {"api": {"Semaphore": [[0, 8]]}}}, {"text": "A Lock is for exclusive access", "label": {"api": {"Lock": [[2, 5]]}}}, {"text": "A ThreadPoolExecutor allows you to run some code (Runnable or Callable class) using a bounded amount of threads", "label": {"api": {"ThreadPoolExecutor": [[2, 19]]}}}, {"text": "You could use a ThreadPoolExecutor deal with the request, process it and respond to the client", "label": {"api": {"ThreadPoolExecutor": [[16, 33]]}}}, {"text": "ThreadPoolExecutor could be configured to take advantage of the current CPUs", "label": {"api": {"ThreadPoolExecutor": [[0, 17]]}}}, {"text": "According to this javadoc documentation, that would cause you to get a FileAlreadyExistsException unless you specify a REPLACE_EXISTING option, which you have not done", "label": {"api": {"this javadoc documentation": [[13, 38]]}}}, {"text": "From the documentation of ServerSocket", "label": {"api": {"ServerSocket": [[26, 37]]}}}, {"text": "See the javadoc for Executors and ThreadPoolExecutor", "label": {"api": {"Executors": [[20, 28]], "ThreadPoolExecutor": [[34, 51]]}}}, {"text": "Much better would be to use ProcessBuilder to prepare the process arguments and spawn it", "label": {"api": {"ProcessBuilder": [[28, 41]]}}}, {"text": "That's because parseInt returns an int (primitive type), which matches your method's signature", "label": {"api": {"parseInt": [[15, 22]]}}}, {"text": "So arraylist cards is of size 0 and you get IllegalArgumentException exception for your method Random.nextInt(int)", "label": {"api": {"Random.nextInt(int)": [[95, 113]]}}}, {"text": "You might want to consult the documentation on java.lang.String to learn how to see if a string contains a certain substring (or how to split it up in words)..", "label": {"api": {"java.lang.String": [[47, 62]]}}}, {"text": "and look at java.lang.HashMap, also", "label": {"api": {"java.lang.HashMap": [[12, 28]]}}}, {"text": "Have a look at SimpleDateFormat for a general solution", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "Write a SimpleDateFormat to parse the first date and use format in another to have the expected output", "label": {"api": {"SimpleDateFormat": [[8, 23]], "parse": [[28, 32]], "format": [[57, 62]]}}}, {"text": "In Java does it matter whether I instantiate a ZipOutputStream first, or the BufferedOutputStream first", "label": {"api": {"ZipOutputStream": [[47, 61]], "BufferedOutputStream": [[77, 96]]}}}, {"text": "However, later in the page they say that if you have a complicated and concurrent application, look into the SwingWorker  class and know about concurrency in regards to swing", "label": {"api": {"SwingWorker": [[109, 119]]}}}, {"text": "In SwingWorker, you'll read that  there are two main concerns in multi-threaded Swing apps", "label": {"api": {"SwingWorker": [[3, 13]]}}}, {"text": "Alternatively, if the returned map won't me modified use an emptyMap()", "label": {"api": {"emptyMap()": [[60, 69]]}}}, {"text": "Look at the Java API for a java solution without a lot of dependencies", "label": {"api": {"Java API": [[12, 19]]}}}, {"text": "To my understanding, the AtomicReferenceArray class allows the individual elements to be updated atomically", "label": {"api": {"AtomicReferenceArray": [[25, 44]]}}}, {"text": "But ignoring that, and focusing solely on adding and retrieving elements, is there a reason to use one of the concurrent collections rather than an AtomicReferenceArray", "label": {"api": {"AtomicReferenceArray": [[148, 167]]}}}, {"text": "The cause was added to Throwable in JDK 1.4; it wasn't present in 1.3", "label": {"api": {"JDK 1.4": [[36, 42]], "1.3": [[66, 68]]}}}, {"text": "However, the 1.3 version of ClassNotFoundException did have a cause, because this exception can happen when a static initializer fails (actually, due to any loading problem), and debugging without knowing the cause could be extremely frustrating", "label": {"api": {"1.3": [[13, 15]]}}}, {"text": "You need to instead use nextFloat() and change the variable i to a float", "label": {"api": {"nextFloat()": [[24, 34]]}}}, {"text": "Leverage standard Java Properties class", "label": {"api": {"Properties": [[23, 32]]}}}, {"text": "Java has a standard for this, it's called Properties", "label": {"api": {"Properties": [[42, 51]]}}}, {"text": "Rectangle2D is constructed with (x,y,width,height)", "label": {"api": {"Rectangle2D": [[0, 10]]}}}, {"text": "I think you're looking for addPropertyChangeListener from Container", "label": {"api": {"addPropertyChangeListener": [[27, 51]]}}}, {"text": "Within graphics you have FontMetrics which can give you the answer using the method stringWidth, like so", "label": {"api": {"stringWidth": [[84, 94]]}}}, {"text": "RandomAccessFile seems a good fit", "label": {"api": {"RandomAccessFile": [[0, 15]]}}}, {"text": "The only advantage of RandomAccessFile is that you do not need the disk space for the temporary output file, and may get slight better performance out of the disk due to better access locality", "label": {"api": {"RandomAccessFile": [[22, 37]]}}}, {"text": "As for which implementation you should use, it seems to me that a HashMap would suffice, although if you want to keep your integer keys in order you might want to also consider a TreeMap", "label": {"api": {"HashMap": [[66, 72]], "TreeMap": [[179, 185]]}}}, {"text": "If you used a 4x3 GridLayout (one line per quarter of year) with each cell containing a nested 6x7 GridLayout(to hold the values of the days/month title I think it would work much better", "label": {"api": {"GridLayout": [[18, 27], [99, 108]]}}}, {"text": "Study it, embed it, but then totally ignore it and if you ever have a future need for expanding arrays please use ArrayList instead", "label": {"api": {"ArrayList": [[114, 122]]}}}, {"text": "The static method Long.parseLong() will throw a NumberFormatException if the string does not contain a parsable long", "label": {"api": {"Long.parseLong()": [[18, 33]]}}}, {"text": "For ease, also use JTextComponent.write(java.io.Writer)", "label": {"api": {"JTextComponent.write(java.io.Writer)": [[19, 54]]}}}, {"text": "Establish the FileWriter from the file returned (after checking it ends with .txt)", "label": {"api": {"FileWriter": [[14, 23]]}}}, {"text": "See also JSplitPane.setDividerLocation(int) & How to Use Split Panes", "label": {"api": {"JSplitPane.setDividerLocation(int)": [[9, 42]]}}}, {"text": "I read in the JavaDoc of DriverManager that every driver tries to register himself by the drivermanager, if the driver is loaded", "label": {"api": {"in the JavaDoc of DriverManager": [[7, 37]]}}}, {"text": "You cannot do it this way, because DriverManager doesn't allow you to use drivers that the calling code doesn't have access to (i.e", "label": {"api": {"DriverManager": [[35, 47]]}}}, {"text": "When the method getConnection is called, the DriverManager will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same classloader as the current applet or application", "label": {"api": {"DriverManager": [[45, 57]]}}}, {"text": "As far as I know the only possible workaround is to instantiate Driver manually instead of using DriverManager (assuming that it has a no-arg constructor)", "label": {"api": {"DriverManager": [[97, 109]]}}}, {"text": "You can do that simple with Files.size(new File(filename).toPath())", "label": {"api": {"Files.size(new File(filename).toPath())": [[28, 66]]}}}, {"text": "To fix this, find out the correct encoding and specify it in the InputStreamReader constructor", "label": {"api": {"the InputStreamReader constructor": [[61, 93]]}}}, {"text": "If you need to implements only some of the methods of KeyListener, you should use the KeyAdapter class", "label": {"api": {"KeyAdapter": [[86, 95]]}}}, {"text": "Yes, you can use object serialization to implement the load and store functions, provided you have a Spreadsheet class that implements all of your other requirements, and the Serializable interface", "label": {"api": {"Serializable": [[175, 186]]}}}, {"text": "If you use thread pool executors, the easiest way is to give a custom ThreadFactory to your thread pool where you customise the name of the thread", "label": {"api": {"a custom ThreadFactory": [[61, 82]]}}}, {"text": "For example, most factory methods in Executors offer this option (example)", "label": {"api": {"example": [[4, 10], [66, 72]]}}}, {"text": "I think it’s even in standard libraries", "label": {"api": {"standard libraries": [[21, 38]]}}}, {"text": "from @njzk2 comments if you just wanna use StringTokenizer you can use one of its overloaded constructor which takes 2 args", "label": {"api": {"overloaded constructor": [[82, 103]]}}}, {"text": "Although calling getSession() is one way to start the handshake (see introduction of the SSLSocket documentation, no such thing happens with getHandshakeSession() (as the documentation says", "label": {"api": {"SSLSocket": [[89, 97]]}}}, {"text": "I have a JTree in a JScrollPane", "label": {"api": {"JTree": [[9, 13]], "JScrollPane": [[20, 30]]}}}, {"text": "The JTree is rather long so it takes a while to drag a node from the top of the tree to the bottom", "label": {"api": {"JTree": [[4, 8]]}}}, {"text": "When dragging a node the JScrollPane scrolls, but not nearly as fast as it scrolls using the mouse wheel", "label": {"api": {"JScrollPane": [[25, 35]]}}}, {"text": "Implementing setUnitIncrement as suggested in the selected answer here makes the mouse wheel scroll speed even faster, but does not change the speed of dragging a node", "label": {"api": {"setUnitIncrement": [[13, 28]]}}}, {"text": "The same is true when implementing setBlockIncrement", "label": {"api": {"setBlockIncrement": [[35, 51]]}}}, {"text": "The speed of the scroll when dragging a node is about the same as if I were to hold the up or down arrow and traverse the JTree in that manner", "label": {"api": {"JTree": [[122, 126]]}}}, {"text": "Use the random number generator", "label": {"api": {"random number generator": [[8, 30]]}}}, {"text": "Take a look at Executors", "label": {"api": {"Executor": [[15, 22]]}}}, {"text": "java provides a built in class called Normalizer that can convert a string to a given Unicode form", "label": {"api": {"Normalizer": [[38, 47]]}}}, {"text": "You can use Math.floor() for this", "label": {"api": {"Math.floor()": [[12, 23]]}}}, {"text": "Have a look at Java's Reflection feature", "label": {"api": {"Java's Reflection feature": [[15, 39]]}}}, {"text": "This is happening because newInstance(Object...) takes varargs of Object, in other words Object[]", "label": {"api": {"newInstance(Object...)": [[26, 47]]}}}, {"text": "It is very unlikely that random number generation performance would be an issue for any use-case you came up with unless accessing a single Random instance from multiple threads (because Random is synchronized)", "label": {"api": {"Random": [[140, 145], [187, 192]]}}}, {"text": "If you want the same numbers that the Random class gives you, only faster, you could get rid of the synchronization in there", "label": {"api": {"Random": [[38, 43]]}}}, {"text": "I simply took the java.util.Random code and removed the synchronization which results in twice the performance compared to the original on my Oracle HotSpot JVM 7u9", "label": {"api": {"Random": [[28, 33]]}}}, {"text": "It is still slower than your QuickRandom, but it gives much more consistent results", "label": {"api": {"Random": [[34, 39]]}}}, {"text": "To be precise, for the same seed values and single threaded applications, it gives the same pseudo-random numbers as the original Random class would", "label": {"api": {"Random": [[130, 135]]}}}, {"text": "This code is based on the current java.util.Random in OpenJDK 7u which is licensed under GNU GPL v2", "label": {"api": {"Random": [[44, 49]]}}}, {"text": "I just discovered that you don't even have to use my code above to get an unsynchronized Random instance", "label": {"api": {"Random": [[89, 94]]}}}, {"text": "Look at Java 7's ThreadLocalRandom class", "label": {"api": {"Random": [[28, 33]], "ThreadLocalRandom": [[17, 33]]}}}, {"text": "The class is simply a local-thread-isolated Random version suitable for generating random numbers quickly", "label": {"api": {"Random": [[44, 49]]}}}, {"text": "Buffers are not thread safe and their access should be controlled by appropriate synchronisation; see the Thread Safety section in http://docs.oracle.com/javase/6/docs/api/java/nio/Buffer.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/nio/Buffer.html": [[131, 191]]}}}, {"text": "+1 to @Renjith's comment about not mixing business logic into the servlet level, but if you want to work directly with servlet's request and response objects, I suggest you take a look at servlet filters and HttpServletRequestWrapper", "label": {"api": {"HttpServletRequestWrapper": [[208, 232]]}}}, {"text": "You'd probably need to create new instances of Person at every execution of the loop, and persist each one of them, or try to detach the instance (by means of em.detach(), for instance) and reset its id", "label": {"api": {"em.detach()": [[159, 169]]}}}, {"text": "You should also familiarize yourself with the documentation, which in this case would be this String documentation", "label": {"api": {"this String documentation": [[89, 113]]}}}, {"text": "One possible way of going about it would be to run your voice recognition on a seperate thread and then, when you need to update your GUI, just make use of SwingUtilities.invokeLater(Runnable runnable) to update your GUI", "label": {"api": {"SwingUtilities.invokeLater(Runnable runnable)": [[156, 200]]}}}, {"text": "Extract from the API (http://docs.oracle.com/javase/1.4.2/docs/api/java/sql/ResultSetMetaData.html)", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/sql/ResultSetMetaData.html": [[22, 97]]}}}, {"text": "Here is one way, using a ConcurrentLinkedQueue and a ScheduledExecutorService", "label": {"api": {"ConcurrentLinkedQueue": [[25, 45]], "ScheduledExecutorService": [[53, 76]]}}}, {"text": "See Pattern Documentation for more details", "label": {"api": {"Pattern Documentation": [[4, 24]]}}}, {"text": "You have to close your BufferedWriter using close()", "label": {"api": {"close()": [[44, 50]]}}}, {"text": "In Java, there is support for regular expressions (take a look at Pattern javadoc and Matcher javadoc or on String.matches(...) javadoc), but only if that functionality is used in  the implementation", "label": {"api": {"Pattern javadoc": [[66, 80]], "Matcher javadoc": [[86, 100]], "String.matches(...) javadoc": [[108, 134]]}}}, {"text": "This follows from the general contract on equals() and hashCode()", "label": {"api": {"contract": [[30, 37]]}}}, {"text": "Right now your class is breaking that contract", "label": {"api": {"contract": [[38, 45]]}}}, {"text": "the HttpServletRequest object you have in the doGet and doPost methods on the servlet has the equivalent of PHP $_SERVER['REMOTE_USER'], it is called getRemoteUser()", "label": {"api": {"getRemoteUser()": [[150, 164]]}}}, {"text": "You should consider using ObjectOutputStream / ObjectInputStream instead", "label": {"api": {"ObjectOutputStream": [[26, 43]], "ObjectInputStream": [[47, 63]]}}}, {"text": "If you ever get stuck like this again, looking at The Docs for any Java Class will tell you exactly what you need to import with a little diagram that looks like this", "label": {"api": {"The Docs for any Java Class": [[50, 76]]}}}, {"text": "I've just discovered that you can modify the entry, via Map.Entry.setValue (and the HashMap implementation is mutable)", "label": {"api": {"Map.Entry.setValue": [[56, 73]]}}}, {"text": "You can get the InvocationHandler for a proxy using Proxy.getInvocationHandler(manager)", "label": {"api": {"InvocationHandler": [[16, 32], [61, 77]], "Proxy.getInvocationHandler(manager)": [[52, 86]]}}}, {"text": "Alas, InvocationHandler is an interface with only one invoke method and with no feature that lets you get a target class; it all depends on the implementation", "label": {"api": {"InvocationHandler": [[6, 22]]}}}, {"text": "To add insult to injury, it seems that the WeldInvocationHandler that you are probably using simply delegates the call to a org.jboss.wsf.spi.invocation.InvocationHandler that that it stores its delegate in a private field", "label": {"api": {"InvocationHandler": [[47, 63], [153, 169]]}}}, {"text": "oh wow, I totally forgot containsAll", "label": {"api": {"containsAll": [[25, 35]]}}}, {"text": "For reference, setSelectedItem() works as advertised in this example that selects L&F by name", "label": {"api": {"setSelectedItem()": [[15, 31]]}}}, {"text": "Take a look at String#split ..", "label": {"api": {"String#split": [[15, 26]]}}}, {"text": "Also, the Javadocs recommend using it to measure elapsed time", "label": {"api": {"the Javadocs": [[6, 17]]}}}, {"text": "Ok, step back and check out the docs for HttpUrlConnection", "label": {"api": {"HttpUrlConnection": [[41, 57]]}}}, {"text": "HttpUrlConnection is an abstraction on TOP of HTTP", "label": {"api": {"HttpUrlConnection": [[0, 16]]}}}, {"text": "You don't need to do the entire HTTP line manually if you use HttpUrlConnection (in fact, GET is the default, just don't set the method for a GET)", "label": {"api": {"HttpUrlConnection": [[62, 78]]}}}, {"text": "You can set \"properties\" as they are called for HttpUrlConnection with setRequestProperty", "label": {"api": {"HttpUrlConnection": [[48, 64]], "setRequestProperty": [[71, 88]]}}}, {"text": "If you want to send a string to an HTTP server manually, like you've constructed (you probably don't want to, but just in case), you just need to connect to it with a Socket and fire away (don't use a helper library such as HttpUrlConnection)", "label": {"api": {"HttpUrlConnection": [[224, 240]]}}}, {"text": "I would take a look at the Executors.newFixedThreadPool() method", "label": {"api": {"Executors.newFixedThreadPool()": [[27, 56]]}}}, {"text": "After you created your ExecutorService with this method, you only need to pass a Runnable/Callable within its submit() method, and it will execute it", "label": {"api": {"ExecutorService": [[23, 37]]}}}, {"text": "One particular enhancement, which also lends itself to limited number of requests, is something called a ThreadPool", "label": {"api": {"ThreadPool": [[105, 114]]}}}, {"text": "Your JSF listeners should implement the listeners from the JSF library", "label": {"api": {"listeners": [[9, 17], [40, 48]]}}}, {"text": "If you want to install Servlet listeners in you application, you should do so through web.xml..", "label": {"api": {"listeners": [[31, 39]]}}}, {"text": "You can use the removeItemAt(int itemIndex) method of JComboBox", "label": {"api": {"removeItemAt(int itemIndex)": [[16, 42]]}}}, {"text": "You'll want to use a List<String>", "label": {"api": {"List<String>": [[21, 32]]}}}, {"text": "While the standard java.io classes are still very popular, I would also try the new IO mechanism in java.nio (and the FileChannels)", "label": {"api": {"FileChannels": [[118, 129]]}}}, {"text": "If you look at the javadoc for the BufferedReader class, the only way to build it is to pass a reader in the constructor", "label": {"api": {"BufferedReader class": [[35, 54]]}}}, {"text": "If you check the javadoc of Class#forName, you will see that", "label": {"api": {"javadoc of Class#forName": [[17, 40]]}}}, {"text": "It had flashing problems until I strictly followed the example code at in the Java BufferStrategy documentation", "label": {"api": {"in the Java BufferStrategy documentation": [[71, 110]]}}}, {"text": "Essentially you would want to implement getSupportedOptions in your processor, access the options via processingEnv.getOptions, and pass the options on the command line with -Aname=value", "label": {"api": {"getSupportedOptions": [[40, 58]], "processingEnv.getOptions": [[102, 125]]}}}, {"text": "Supported options may also be specified via the @SupportedOptions annotation", "label": {"api": {"@SupportedOptions": [[48, 64]]}}}, {"text": "You can use JSF builtin LongConverter for this, which has a converter ID of javax.faces.Long", "label": {"api": {"LongConverter": [[24, 36]], "javax.faces.Long": [[76, 91]]}}}, {"text": "See Memory Consistency Properties for a nice summary of relevant features in java.util.concurrent", "label": {"api": {"Memory Consistency Properties": [[4, 32]]}}}, {"text": "The declaration of that method is", "label": {"api": {"that method": [[19, 29]]}}}, {"text": "In your case, you could simply delegate thread safety by using a thread safe map implementation (which would certainly scale better than your synchronized implementation)", "label": {"api": {"a thread safe map implementation": [[63, 94]]}}}, {"text": "I suggest you take a look at ConcurrentHashMap instead, it could be useful in your case", "label": {"api": {"ConcurrentHashMap": [[29, 45]]}}}, {"text": "Alternative using Path (Java 7+)", "label": {"api": {"Path": [[18, 21]]}}}, {"text": "Path#getName takes care of that issue for you", "label": {"api": {"Path": [[0, 3]]}}}, {"text": "I'd use UriBuilder to take care of all characters that need to be encoded", "label": {"api": {"UriBuilder": [[8, 17]]}}}, {"text": "You may want to look into Java's Normalizer class if you haven't already", "label": {"api": {"Normalizer": [[33, 42]]}}}, {"text": "In think SimpleDateFormat is what you need", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "If you read about SimpleDateFormat it should help you get on your way to solving this", "label": {"api": {"SimpleDateFormat": [[18, 33]]}}}, {"text": "Consider using a dynamic proxy", "label": {"api": {"dynamic proxy": [[17, 29]]}}}, {"text": "A dynamic proxy class (simply referred to as a proxy class below) is a class that implements a list of interfaces specified at runtime when the class is created, with behavior as described below", "label": {"api": {"dynamic proxy": [[2, 14]]}}}, {"text": "If you provide your own implementation of that interface (see JavaDoc), you will be informed when the image has been actually drawn", "label": {"api": {"see JavaDoc": [[58, 68]]}}}, {"text": "You may also want to look at Math.PI instead of using 3.1416 as PI", "label": {"api": {"Math.PI": [[29, 35]]}}}, {"text": "When there is selection change in the JComboBox use ItemListener", "label": {"api": {"ItemListener": [[52, 63]]}}}, {"text": "From the FileWriter javadoc", "label": {"api": {"FileWriter javadoc": [[9, 26]]}}}, {"text": "The Java char type is 16-bits long and OutputStreamWriter objects are string-oriented, not byte-oriented", "label": {"api": {"OutputStreamWriter": [[39, 56]], "OutputStream": [[39, 50]]}}}, {"text": "Depending on the output encoding of the writer, you could get e.g", "label": {"api": {"output encoding of the writer": [[17, 45]]}}}, {"text": "You would be better off using an OutputStream directly, either with a byte[] or using write(int) in a loop", "label": {"api": {"OutputStream": [[33, 44]], "write(int)": [[86, 95]]}}}, {"text": "Java 7 has incorporated support for recursive tasks via its ForkJoinPool executor", "label": {"api": {"ForkJoinPool": [[60, 71]]}}}, {"text": "I found out that CountDownLatch is almost what I need", "label": {"api": {"CountDownLatch": [[17, 30]]}}}, {"text": "Java 7 provides a synchronizer that fits this use case called Phaser", "label": {"api": {"Phaser": [[62, 67]]}}}, {"text": "It's a re-usable hybrid of a CountDownLatch and CyclicBarrier that can both increase and decrease the number of registered parties (similar to an incrementable CountDownLatch)", "label": {"api": {"register": [[112, 119]]}}}, {"text": "The basic pattern to using the phaser in this scenario is to register tasks with the phaser when created and arrive when completed", "label": {"api": {"register": [[61, 68]], "arrive": [[109, 114]]}}}, {"text": "When the number of arrived parties matches the number of registered, the phaser \"advances\" to the next phase, notifying any waiting threads of the advance when it takes place", "label": {"api": {"register": [[57, 64]], "arrive": [[19, 24]], "waiting": [[124, 130]]}}}, {"text": "Here's an example I've created of waiting for recursive task completion", "label": {"api": {"waiting": [[34, 40]]}}}, {"text": "For this you can use a tokenizer", "label": {"api": {"tokenizer": [[23, 31]]}}}, {"text": "By additionally trimming your strings, you only get the non-empty pieces", "label": {"api": {"trim": [[16, 19]]}}}, {"text": "Use JComboBox or Choice directly in the applet so you can do everything without going out", "label": {"api": {"JComboBox": [[4, 12]], "Choice": [[17, 22]]}}}, {"text": "You could let Telephone implement Comparable and if the counrycodes are equal you could calculate your price into the comparison", "label": {"api": {"Comparable": [[34, 43]]}}}, {"text": "I propose to receive all events that currently wake up your threads in one loop that could immediately convert them into Futures or Runnables and post to some ExecutorService", "label": {"api": {"Future": [[121, 126]], "ExecutorService": [[159, 173]]}}}, {"text": "The use of uppercase Y relates to week year", "label": {"api": {"week year": [[34, 42]]}}}, {"text": "A week year is in sync with a WEEK_OF_YEAR cycle", "label": {"api": {"week year": [[2, 10]]}}}, {"text": "All weeks between the first and last weeks (inclusive) have the same week year value", "label": {"api": {"week year": [[69, 77]]}}}, {"text": "Therefore, the first and last days of a week year may have different calendar year values", "label": {"api": {"week year": [[40, 48]]}}}, {"text": "The week year is 1998 for the last three days of calendar year 1997", "label": {"api": {"week year": [[4, 12]]}}}, {"text": "If, however, getFirstDayOfWeek() is SUNDAY, then week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the first three days of 1998 then are part of week 53 of 1997 and their week year is 1997", "label": {"api": {"week year": [[193, 201]]}}}, {"text": "As others have mentioned, you need to know that replaceAll returns a new string and doesn't change the current one, since strings are immutable in Java", "label": {"api": {"replaceAll": [[48, 57]]}}}, {"text": "The Date constructor expects year, month and day, in this order", "label": {"api": {"Date constructor": [[4, 19]]}}}, {"text": "The easiest way to parse numbers from a text file is with java.util.Scanner, like this", "label": {"api": {"java.util.Scanner": [[58, 74]]}}}, {"text": "According to this discussion, Promise has finally been called CompletableFuture for inclusion in Java 8, and its javadoc explains", "label": {"api": {"its javadoc": [[109, 119]]}}}, {"text": "Try using the Process.waitFor() method to pause the current thread until your process has had an opportunity to complete", "label": {"api": {"Process.waitFor()": [[14, 30]]}}}, {"text": "The documentation (link) uses the phrase \"8-bit RGBA color components\", indicating 8 bits per color channel per pixel, for a total of 4x8 bits per pixel (one for each of RGBA)", "label": {"api": {"documentation (link)": [[4, 23]]}}}, {"text": "You should use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[15, 31]]}}}, {"text": "All I could find was", "label": {"api": {"was": [[17, 19]]}}}, {"text": "Inside remote stub, you need to set a new value for the protected RemoteRef ref field", "label": {"api": {"protected RemoteRef ref": [[56, 78]]}}}, {"text": "The enclosure node doesn't have any child nodes, so getFirstChild returns null, as documented", "label": {"api": {"getFirstChild": [[52, 64]]}}}, {"text": "So it's fine to call getFirstChild() on any node, but you should then check whether the value is null before you call getNodeValue()", "label": {"api": {"getFirstChild": [[21, 33]]}}}, {"text": "In order to get a value expression, use UIComponent#getValueExpression() instead", "label": {"api": {"UIComponent#getValueExpression()": [[40, 71]]}}}, {"text": "I am not sure if this is what you are looking for, but if you want to return the class type, you can do that by writing the subclass name and appending a .class to get the class type", "label": {"api": {"class type": [[81, 90], [172, 181]]}}}, {"text": "Use a String Builder to build up your list of words like so", "label": {"api": {"String Builder": [[6, 19]]}}}, {"text": "SwingUtilities.paintComponent does it", "label": {"api": {"SwingUtilities.paintComponent": [[0, 28]]}}}, {"text": "TreeMap itself and headMap(K) date back to Java 1.2, whereas NavigableMap and headMap(K, boolean) have been introduced in Java 1.6", "label": {"api": {"TreeMap": [[0, 6]], "headMap(K)": [[19, 28]], "NavigableMap": [[61, 72]], "headMap(K, boolean)": [[78, 96]]}}}, {"text": "obtain the instance of the Graphics object from the element by using the panel.getGraphics() method", "label": {"api": {"method": [[93, 98]]}}}, {"text": "later use the graphics object to draw lines using the graphics.drawLine() method", "label": {"api": {"method": [[74, 79]]}}}, {"text": "From there you add it to a java.util.List implementation, like ArrayList", "label": {"api": {"java.util.List": [[27, 40]], "ArrayList": [[63, 71]]}}}, {"text": "Java HashSets are unordered – they do not have an ordering", "label": {"api": {"Java HashSets are unordered": [[0, 26]]}}}, {"text": "That said, HashSet inherit's AbstractSet#equals(Object) which tells us the following", "label": {"api": {"AbstractSet#equals(Object)": [[29, 54]]}}}, {"text": "You can't reliably do so, but if you can control the network between all clients and servers, and if you're willing to accept that malicious requests may feed you false information, then there are methods available like ServletRequest.getRemoteAddr() that will give you information of that sort", "label": {"api": {"ServletRequest.getRemoteAddr()": [[220, 249]]}}}, {"text": "Actually there is an interface named javax.servlet.Servlet", "label": {"api": {"javax.servlet.Servlet": [[37, 57]]}}}, {"text": "A class named GenericServlet implement the interface", "label": {"api": {"GenericServlet": [[14, 27]]}}}, {"text": "And the HTTPServlet class extends this GenericServlet", "label": {"api": {"GenericServlet": [[39, 52]]}}}, {"text": "Then in the GenericServlet, the service method called doGet and doPost", "label": {"api": {"GenericServlet": [[12, 25]]}}}, {"text": "To parse a long, use Long.parseLong, not Integer.parseInt", "label": {"api": {"Long.parseLong": [[21, 34]]}}}, {"text": "When you do that, you have to have some kind of terminating condition, or it'll go on invoking itself forever or, since you're in Java, until you run out of stack space, when you'll get a StackOverflowError", "label": {"api": {"StackOverflowError": [[188, 205]]}}}, {"text": "You should convert Calendar to Timestamp", "label": {"api": {"Timestamp": [[31, 39]]}}}, {"text": "Instead, use a BuffedReader and readLine() to read your file, ignoring any line until you get to -----BEGIN CERTIFICATE-----", "label": {"api": {"readLine()": [[32, 41]]}}}, {"text": "You can have a look at the javadoc of ScheduledExecutorService for a very similar example", "label": {"api": {"javadoc of ScheduledExecutorService": [[27, 61]]}}}, {"text": "The standard way to handle an illegal argument is to throw an IllegalArgumentException", "label": {"api": {"an IllegalArgumentException": [[59, 85]]}}}, {"text": "Use the Exception Constructor which takes a String as parameter", "label": {"api": {"Exception Constructor": [[8, 28]]}}}, {"text": "You should look at Timer and TimerTask", "label": {"api": {"Timer": [[19, 23], [29, 33]], "TimerTask": [[29, 37]]}}}, {"text": "You could use a ScheduledExecutorService, and submit a Runnable or Callable which calls your method", "label": {"api": {"ScheduledExecutorService": [[16, 39]]}}}, {"text": "I would suggest you do a shuffle and then select numbers in the order they are placed in the shuffled result", "label": {"api": {"shuffle": [[25, 31], [93, 99]]}}}, {"text": "You should override getBackgroundNonSelectionColor,getBackgroundSelectionColor and getBackground of DefaultTreeCellRenderer and return appropriate values like so", "label": {"api": {"getBackgroundNonSelectionColor": [[20, 49]], "getBackgroundSelectionColor": [[51, 77]], "getBackground": [[20, 32], [51, 63], [83, 95]]}}}, {"text": "Use SwingWorker for doing that", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "MyActionPerformer class extends SwingWorker which has done and doInBackGround", "label": {"api": {"SwingWorker": [[32, 42]]}}}, {"text": "Create a class that extends NumberConverter", "label": {"api": {"NumberConverter": [[28, 42]]}}}, {"text": "Override the getAsString method by explicitly handling your special values, and deferring to super for all others", "label": {"api": {"getAsString": [[13, 23]]}}}, {"text": "Use Class#getConstructors() to find a defined constructor, and call that instead", "label": {"api": {"Class#getConstructors()": [[4, 26]]}}}, {"text": "You can also use LinkedList#addLast() method", "label": {"api": {"LinkedList#addLast()": [[17, 36]]}}}, {"text": "This paragraph applies to maps created with the special constructor that makes the iteration order based on last access order (vs", "label": {"api": {"the special constructor": [[44, 66]]}}}, {"text": "Implementing an annotation processor is straightforward enough, but it seems like the .class files don't yet exist when the Processor is run", "label": {"api": {"annotation processor": [[16, 35]]}}}, {"text": "Start the DataCollector when the webapp is deployed (using a ServletContextListener), stop it when the webapp is destroyed (using the same listener), and make the DataCollector a singleton or store it in a servlet context attribute to be able to get it from any component of the webapp", "label": {"api": {"ServletContextListener": [[61, 82]]}}}, {"text": "However, I suspect that InterruptedException probably doesn't mean what you think it does", "label": {"api": {"InterruptedException": [[24, 43]]}}}, {"text": "How about a simple List#addAll()", "label": {"api": {"List#addAll()": [[19, 31]]}}}, {"text": "If you look at the documentation for TreeMap you'll see it says", "label": {"api": {"documentation for TreeMap": [[19, 43]]}}}, {"text": "In java this happens by calling SwingUtilities.invokeLater(Runnable run)", "label": {"api": {"SwingUtilities.invokeLater(Runnable run)": [[32, 71]]}}}, {"text": "From the docs for schedule", "label": {"api": {"the docs for schedule": [[5, 25]]}}}, {"text": "You will be better off using scheduleAtFixedRate", "label": {"api": {"scheduleAtFixedRate": [[29, 47]]}}}, {"text": "I haven't looked at the sources, but I suspect that this is close to what's in Timer.scheduleAtFixedRate", "label": {"api": {"scheduleAtFixedRate": [[85, 103]]}}}, {"text": "I would probably make use of ScheduleExecutorService.scheduleAtFixedRate which is a more modern approach than using a Timer and would allow for having multiple worker threads in case there are many tasks being scheduled", "label": {"api": {"ScheduleExecutorService.scheduleAtFixedRate": [[29, 71]]}}}, {"text": "The documentation of ObjectOutputStream says", "label": {"api": {"documentation of ObjectOutputStream": [[4, 38]]}}}, {"text": "When you want a simple key/value table, then the HashMap might be what you are looking for", "label": {"api": {"HashMap": [[49, 55]]}}}, {"text": "This example matches Strings to Strings, but you can use HashMaps to map any type to any other type", "label": {"api": {"HashMap": [[57, 63]]}}}, {"text": "Although they are both Collection, I suggest that you read the differences between a Set and a List", "label": {"api": {"Collection": [[23, 32]], "Set": [[85, 87]], "List": [[95, 98]]}}}, {"text": "May be you can look at java.lang.ProcessBuilder it might suite your need", "label": {"api": {"java.lang.ProcessBuilder": [[23, 46]]}}}, {"text": "You should call consume() on the event to show it has been handled", "label": {"api": {"consume()": [[16, 24]]}}}, {"text": "javax.swing.filechooser.FileNameExtensionFilter was introduced in Java 6, so it's no wonder you are not able to compile your code with Java 5.0", "label": {"api": {"FileNameExtensionFilter": [[24, 46]]}}}, {"text": "Take a look at CountDownLatch", "label": {"api": {"CountDownLatch": [[15, 28]]}}}, {"text": "perhaps you could use standard java.util.zip.ZipInputStream - it has a constructor for InputStream", "label": {"api": {"standard java.util.zip.ZipInputStream": [[22, 58]]}}}, {"text": "A Class is a Type but a Type isn't necessary a Class, since Class implements Type", "label": {"api": {"Class implements Type": [[60, 80]], "Type": [[13, 16], [24, 27], [77, 80]]}}}, {"text": "Basically, your myType could also be any of the implementing classes of the interfaces GenericArrayType, ParameterizedType, TypeVariable or WildcardType, since they all extend the Type interface", "label": {"api": {"GenericArrayType": [[87, 102]], "ParameterizedType": [[105, 121]], "TypeVariable": [[124, 135]], "WildcardType": [[140, 151]], "Type": [[18, 21], [99, 102], [118, 121], [124, 127], [148, 151], [180, 183]]}}}, {"text": "Try to print myType.getClass() to see the type you mean", "label": {"api": {"Type": [[15, 18]]}}}, {"text": "you'll get Class<TheSaidType>", "label": {"api": {"Type": [[24, 27]]}}}, {"text": "From the Javadoc for Type you can see it has a number of implementing types", "label": {"api": {"Type": [[21, 24]]}}}, {"text": "A workaround might be the use of AutoIT (Windows only) or the Robot class (will also work only on setups similar to yours) and type the path \"blindly\" into the dialog", "label": {"api": {"Robot": [[62, 66]]}}}, {"text": "How can I make Robot type a `:`", "label": {"api": {"Robot": [[15, 19]]}}}, {"text": "and Convert String to KeyEvents (plus there is the new and shiny KeyEvent#getExtendedKeyCodeForChar() which does similar work, but is available only from JDK7)", "label": {"api": {"KeyEvent#getExtendedKeyCodeForChar()": [[65, 100]]}}}, {"text": "Since Java Persistence 2.0 you can use Metamodel to do so", "label": {"api": {"Metamodel": [[39, 47]]}}}, {"text": "If you need an array that needs to increase in size, consider ArrayList", "label": {"api": {"ArrayList": [[62, 70]]}}}, {"text": "If the object you want to replace is only referred to via its interface, then you can use a JDK dynamic proxy in the first place, which delegates to an actual implementation", "label": {"api": {"JDK dynamic proxy": [[92, 108]]}}}, {"text": "From the documentation of String.split(String regex)", "label": {"api": {"String.split(String regex)": [[26, 51]]}}}, {"text": "So you will have to use the two argument version String.split(String regex, int limit) with a negative value", "label": {"api": {"String.split(String regex, int limit)": [[49, 85]]}}}, {"text": "In onColReorder method find your datatable by id with UIViewRoot#findComponent() method", "label": {"api": {"UIViewRoot#findComponent()": [[54, 79]]}}}, {"text": "If you have some main thread that just must receive the events from other threads (much like a server socket does), some blocking queue may be a solution", "label": {"api": {"blocking queue": [[121, 134]]}}}, {"text": "(SynchronousQueue will stall the offering thread till the main thread is ready or alternatively ArrayBlockingQueue supports a queue of the given size)", "label": {"api": {"SynchronousQueue": [[1, 16]], "ArrayBlockingQueue": [[96, 113]]}}}, {"text": "Use invokeAndWait if you need to touch interface components like labels or buttons from it", "label": {"api": {"invokeAndWait": [[4, 16]]}}}, {"text": "call paintImmediately after setting the background color", "label": {"api": {"paintImmediately": [[5, 20]]}}}, {"text": "You could use List.subList() to get a view onto the tail of the original list", "label": {"api": {"List.subList()": [[14, 27]]}}}, {"text": "The java.util.logging package is standard in Java SE", "label": {"api": {"java.util.logging package": [[4, 28]]}}}, {"text": "Its Logger includes an overloaded log method that accepts Throwable objects", "label": {"api": {"Logger": [[4, 9]], "Throwable": [[58, 66]]}}}, {"text": "See the documentation for details on the usage", "label": {"api": {"See the documentation": [[0, 20]]}}}, {"text": "When you submit a job into a thread pool, it returns a Future instance", "label": {"api": {"Future instance": [[55, 69]]}}}, {"text": "I am using Joda-time to manage the timezones on the JVM side, and need to parse that string", "label": {"api": {"Joda-time": [[11, 19]]}}}, {"text": "As you are using charAt(), I suppose that dataReceived is a String", "label": {"api": {"charAt()": [[17, 24]]}}}, {"text": "You can covnert a byte array to a string using the String(byte[]) constructor", "label": {"api": {"String(byte[])": [[51, 64]]}}}, {"text": "So, you could also use the contains() method to check if the string contains a particular substring", "label": {"api": {"contains()": [[27, 36]]}}}, {"text": "Or if you are interested in the location of the substring you can use indexOf()", "label": {"api": {"indexOf()": [[70, 78]]}}}, {"text": "But when you want to simulate a network protocol, then why not go all the way and use network sockets for interprocess communication", "label": {"api": {"network sockets": [[86, 100]]}}}, {"text": "Installing JVM shutdown hook does not appear too ugly in that case", "label": {"api": {"JVM shutdown hook": [[11, 27]]}}}]