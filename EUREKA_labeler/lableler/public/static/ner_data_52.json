[{"text": "Or then just call a tail implementation by executing a system command", "label": {"api": {"executing a system command": [[43, 68]]}}}, {"text": "If you just wanna check if the character is only alpha, then use Charcter#isDigit(char) or Charcter#isLetter before the switch starts like in below code", "label": {"api": {"Charcter#isDigit(char)": [[65, 86]], "Charcter#isLetter": [[91, 107]]}}}, {"text": "You could also take a look at the Scanner Class", "label": {"api": {"Scanner Class": [[34, 46]]}}}, {"text": "You could just use Collections#min to find the minimum value", "label": {"api": {"Collections#min": [[19, 33]]}}}, {"text": "One way to do this, without changing your code too much, is a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[62, 74]]}}}, {"text": "You should consider using something like a BlockingQueue for communication between threads, as is outlined in this question", "label": {"api": {"BlockingQueue": [[43, 55]]}}}, {"text": "Use Arrays.equals(arr1, arr2) method", "label": {"api": {"Arrays.equals(arr1, arr2": [[4, 27]]}}}, {"text": "If that is the case, you can retrieve the ip-address or hostname of the requester (or proxy) by calling getRemoteAddr() and getRemoteHost(), respectively, on the ServletRequest/HttpServletRequest object that is passed to your Servlet's methods for handling", "label": {"api": {"getRemoteAddr()": [[104, 118]], "getRemoteHost()": [[124, 138]]}}}, {"text": "Use DateTimeFormat as shown in Parse Date String to Some Java Object to parse your string into a DateTime object, and then access the members", "label": {"api": {"Date": [[4, 7], [37, 40], [97, 100]]}}}, {"text": "Alternatively you can use SimpleDateFormat in a similar manner, to parse it into a Date object", "label": {"api": {"SimpleDateFormat": [[26, 41]], "Date": [[32, 35], [83, 86]]}}}, {"text": "You could use synchronized blocks or look into Java's java.lang.management (e.g., ThreadMXBean and ThreadInfo), for timing functionality in threaded environments", "label": {"api": {"java.lang.management": [[54, 73]]}}}, {"text": "An example of this is calling Arrays.sort on an array", "label": {"api": {"Arrays.sort": [[30, 40]]}}}, {"text": "Use String.format() to pad them to four characters", "label": {"api": {"String.format()": [[4, 18]]}}}, {"text": "If it is mutable (not read-only), then you can use an Iterator", "label": {"api": {"Iterator": [[54, 61]]}}}, {"text": "By creating a copy that only contains the non-null elements, you can guarantee that you will not hit any roadblocks, but using the above Iterator will work if the List is not read-only", "label": {"api": {"Iterator": [[137, 144]]}}}, {"text": "What you shoud use is PrepearedStatement instead of Statement", "label": {"api": {"PrepearedStatement": [[22, 39]]}}}, {"text": "You should be able to get a String of length Integer.MAX_VALUE (always 2147483647 (231 - 1) by the Java specification, the maximum size of an array, which the String class uses for internal storage) or half your maximum heap size (since each character is two bytes), whichever is smaller", "label": {"api": {"Integer.MAX_VALUE": [[45, 61]]}}}, {"text": "I would recommend to design your API as a service loadable with ServiceLoader, similar to DOM API", "label": {"api": {"ServiceLoader": [[64, 76]]}}}, {"text": "There you'll find the suggestion to use Scanner.findInLine() method, which receives a regular expression as an argument", "label": {"api": {"Scanner.findInLine()": [[40, 59]]}}}, {"text": "wildcard character as pattern, you'll be able to get a String with the one next character, and using charAt(0) on it, you'll get it as a char", "label": {"api": {"charAt(0)": [[101, 109]]}}}, {"text": "Use Scanner.nextLine() method to read up to the line break (noninclusive)", "label": {"api": {"Scanner.nextLine()": [[4, 21]]}}}, {"text": "Is there a utility class in some Java library offering amenities like those of java.io.Console but compatible with Bash pipe redirection of input", "label": {"api": {"java.io.Console": [[79, 93]]}}}, {"text": "Just trim() the string (remember to check for null before invoking a method on it)", "label": {"api": {"trim()": [[5, 10]]}}}, {"text": "Try to get the path of the file from ServletContext", "label": {"api": {"ServletContext": [[37, 50]]}}}, {"text": "Get hold of all HttpSession instances in an application wide map which you manage with help of a HttpSessionListener", "label": {"api": {"HttpSession": [[16, 26], [97, 107]], "HttpSessionListener": [[97, 115]]}}}, {"text": "On every HTTP request, check with help of a Filter or ServletRequestListener if a change is required, then make the necessary change in the current session and remove/disable the change instruction", "label": {"api": {"Filter": [[44, 49]], "ServletRequestListener": [[54, 75]]}}}, {"text": "Refer this javadoc for daemon thread behavior", "label": {"api": {"javadoc for daemon thread": [[11, 35]]}}}, {"text": "It is mentioned in the LinkedHashMap Javadocs", "label": {"api": {"LinkedHashMap Javadocs": [[23, 44]]}}}, {"text": "The only obvious thing I can see is that if you're using the hashcodes to identify changes in the object, you should know that the order of methods returned by getMethods() is \"not in any particular order\", so there is no guarantee that they'll be returned in the same order in another JVM, or even from call to call", "label": {"api": {"order of methods returned by getMethods()": [[131, 171]]}}}, {"text": "You can use Arrays.copyOf(T[] original, int newLength) if you are working with Java 1.6 or newer", "label": {"api": {"Arrays.copyOf(T[] original, int newLength)": [[12, 53]]}}}, {"text": "BufferedReader, String.split(...) and HashMap are what you want", "label": {"api": {"BufferedReader": [[0, 13]], "String.split(...)": [[16, 32]], "HashMap": [[38, 44]]}}}, {"text": "You'll find more Unicode character classes the full documentation", "label": {"api": {"full documentation": [[47, 64]]}}}, {"text": "Refer to the Pattern javadocs for a partial list, and to the relevant Unicode standard", "label": {"api": {"Pattern javadocs": [[13, 28]]}}}, {"text": "You can consider using AtomicInteger to store the mode in the global store to ensure thread safety", "label": {"api": {"AtomicInteger": [[23, 35]]}}}, {"text": "The simple reason is TreeNode is not Serializable or Parcelable", "label": {"api": {"TreeNode": [[21, 28]]}}}, {"text": "Hence you need to make a custom class that extends TreeNode and impelemtn one of them in order to flatten the data", "label": {"api": {"TreeNode": [[51, 58]]}}}, {"text": "TreeNode isn't there", "label": {"api": {"TreeNode": [[0, 7]]}}}, {"text": "According to the javadoc of ThreadMXBean#setThreadAllocatedMemoryEnabled, there should be a method getThreadAllocatedBytes allowing to get memory of thread", "label": {"api": {"the javadoc of ThreadMXBean#setThreadAllocatedMemoryEnabled": [[13, 71]]}}}, {"text": "Probably one of the best of options would be to use Semaphore http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html class and give it 80 permits every minute", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html": [[62, 137]]}}}, {"text": "This can be accomplished for example by using timer class http://docs.oracle.com/javase/7/docs/api/java/util/Timer.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Timer.html": [[58, 118]]}}}, {"text": "create a placeholder class for you strings and then use CRC32 class", "label": {"api": {"CRC32 class": [[56, 66]]}}}, {"text": "You can get the original Statement from the ResultSet by using resultSetInstance.getStatement(), cast it to a PreparedStatement, whose toString() method spits out the original statement as a String", "label": {"api": {"resultSetInstance.getStatement": [[63, 92]], "PreparedStatement": [[110, 126]], "String": [[137, 142], [191, 196]]}}}, {"text": "As Louis Wasserman suggested it would be advisable to use a ConcurrentLinkedDeque for a concurrent Deque operation", "label": {"api": {"ConcurrentLinkedDeque": [[60, 80]]}}}, {"text": "Start by having a look at ProcessBuilder, it will make you life much easier...", "label": {"api": {"ProcessBuilder": [[26, 39]]}}}, {"text": "It can be basically acheived as below using ScriptEngine.eval(String) method", "label": {"api": {"ScriptEngine.eval(String)": [[44, 68]]}}}, {"text": "Alternatively to sleeping, you could schedule the moves with a Timer every x milliseconds for example", "label": {"api": {"Timer": [[63, 67]]}}}, {"text": "Note that the resolution of Timer is not very good, possibly as high as 30ms, so it might not be precise enough for you need", "label": {"api": {"Timer": [[28, 32]]}}}, {"text": "However, you can create a new String object with the desired value, using the String#substring() method (for example)", "label": {"api": {"String#substring()": [[78, 95]]}}}, {"text": "I tried loading images, I found a code and it works well, the code for loading an Image is in the constructor,  I tried to move it to a button action, and also to a filechooser", "label": {"api": {"button": [[136, 141]], "filechooser": [[165, 175]]}}}, {"text": "Maybe you should try the Scanner", "label": {"api": {"Scanner": [[25, 31]]}}}, {"text": "You are looking for JComponent.scrollRectToVisible", "label": {"api": {"JComponent.scrollRectToVisible": [[20, 49]]}}}, {"text": "From the docs of Calendar.set", "label": {"api": {"Calendar.set": [[17, 28]]}}}, {"text": "Assuming the expected output is aaa, ccc, eee, fff, xxx (all the not-common items), you can use List#removeAll, but you need to use it twice to get both the items in name but not in name2 AND the items in name2 and not in name", "label": {"api": {"List#removeAll": [[96, 109]]}}}, {"text": "A simple solution would be to just load it as a Properties, which will do exactly the parsing you're looking for", "label": {"api": {"Properties": [[48, 57]]}}}, {"text": "Otherwise, just read each line and split the string at the first \"=\"", "label": {"api": {"read each line": [[16, 29]], "split the string": [[35, 50]]}}}, {"text": "Something I would recommend that you do is add a custom UncaughtExceptionHandler that will handle uncaught exceptions like this", "label": {"api": {"UncaughtExceptionHandler": [[56, 79]]}}}, {"text": "if your web-app is a servlet, use ServletContext.getResource to get the path to your database to use in the connection string", "label": {"api": {"ServletContext.getResource": [[34, 59]]}}}, {"text": "For really simple admin/debug/monitoring interfaces, I've sometimes used the built in HTTP server in the Oracle/OpenJDK JVM", "label": {"api": {"built in HTTP server": [[77, 96]]}}}, {"text": "The Polygon object sounds like something you would like to use, but its intersects methods only take some form of a rectangular object (either corner coordinates with dimensions, or a Rectangle2D object)", "label": {"api": {"Polygon": [[4, 10]]}}}, {"text": "You might have to extend Polygon and add an intersects method that accepts a Line2D..", "label": {"api": {"Polygon": [[25, 31]]}}}, {"text": "If you don't actually have access to the creation of the threads, and you only manage the queue access, a solution could simply be to use a Semaphore object (see the docs page)", "label": {"api": {"docs page": [[166, 174]]}}}, {"text": "Before accessing the queue for item processing, a thread would first acquire a permit from the semaphore, which would block if a max_threads number of threads had already started processing items from the queue", "label": {"api": {"acquire": [[69, 75]]}}}, {"text": "After an item is processed by some thread, that thread should finally release the permit, thus allowing more threads to process other items", "label": {"api": {"release": [[70, 76]]}}}, {"text": "I have found ClassLoader.loadClass and I think I should be using this, but I haven't been able to find an example that spells out my use case and I'm not sure if it's OK to use that directly", "label": {"api": {"ClassLoader.loadClass": [[13, 33]]}}}, {"text": "The javax.xml.ws.Response is an interface", "label": {"api": {"javax.xml.ws.Response": [[4, 24]]}}}, {"text": "Use ObjectOutputStream to write and ObjectInputStream to read", "label": {"api": {"ObjectOutputStream": [[4, 21]], "ObjectInputStream": [[36, 52]]}}}, {"text": "Yes, look at the Point2D class", "label": {"api": {"Point2D": [[17, 23]]}}}, {"text": "It's true that you can get the generic arguments of a superclass using a combination of Class.getGenericSuperclass and ParameterizedType.getActualTypeArguments", "label": {"api": {"Class.getGenericSuperclass": [[88, 113]], "ParameterizedType.getActualTypeArguments": [[119, 158]]}}}, {"text": "You can use the method getParent that is provided by the Component superclass", "label": {"api": {"getParent": [[23, 31]]}}}, {"text": "For your panel that is a card, simply call panel.getParent() and it will give you the containing (parent) panel", "label": {"api": {"getParent": [[49, 57]]}}}, {"text": "You could also make this class Comparable to itself", "label": {"api": {"Comparable": [[31, 40]]}}}, {"text": "Alternatively use a TreeMap,as sansix suggests, with the key as the name and value as phNumber", "label": {"api": {"TreeMap": [[20, 26]]}}}, {"text": "Here is javadoc for Scanner", "label": {"api": {"javadoc for Scanner": [[8, 26]]}}}, {"text": "Hence the return statement will only pause in Future.get calls as much as required to complete one and then another task", "label": {"api": {"Future.get": [[46, 55]]}}}, {"text": "If you wish to have JButtons appear over your image, a better approach would be to override the paintComponent of the JPanel and use drawImage to draw the image similar to this example", "label": {"api": {"drawImage": [[133, 141]]}}}, {"text": "You can define your own ListCellRenderer giving it the visualation you like", "label": {"api": {"ListCellRenderer": [[24, 39]]}}}, {"text": "With Java 7, you can use Files.createDirectories()", "label": {"api": {"Files.createDirectories()": [[25, 49]]}}}, {"text": "For example, a handful of BitSet objects could cover the whole 32-bit integer range without you having to write any bit-handling code..", "label": {"api": {"BitSet": [[26, 31]]}}}, {"text": "These polygons must be painted with Graphics directly using drawPolygon", "label": {"api": {"drawPolygon": [[60, 70]]}}}, {"text": "This is fully doable with FontMetrics that allow to measure the dimensions of the string as printed with the given font", "label": {"api": {"FontMetrics": [[26, 36]]}}}, {"text": "Use FontMetrics to determine to compute the locations of the string fragments and then draw the string fragments and polygons in between", "label": {"api": {"FontMetrics": [[4, 14]]}}}, {"text": "I'm not sure whether anyone would actually do this in practice, but you could theoretically use reflection to automate the process (getMethods may be a good start)", "label": {"api": {"getMethods": [[132, 141]]}}}, {"text": "Anyways, if you want to reimplement the protocol above start by reading the Javadoc for the DatagramSocket class", "label": {"api": {"DatagramSocket": [[92, 105]]}}}, {"text": "It has a setSoTimeout method that can replace the timer thing in the code above, the main difference being that upon timeout receive  will throw a SocketTimeoutException, and that may complicate your program's flow a little", "label": {"api": {"setSoTimeout": [[9, 20]], "receive": [[125, 131]]}}}, {"text": "You can use exists method of java.io.File class like this", "label": {"api": {"exists": [[12, 17]], "java.io.File": [[29, 40]]}}}, {"text": "Path2D.Float, from which GeneralPath is derived, does not provide access to its inner data structures, and does not allow the kind of operation you desire", "label": {"api": {"Path2D.Float": [[0, 11]], "GeneralPath": [[25, 35]]}}}, {"text": "So unless you are prepared to reimplement GeneralPath or circumvent access restrictions, there simply is no way to achieve this", "label": {"api": {"GeneralPath": [[42, 52]]}}}, {"text": "I'd implement this using a wrapper around the PathIterator, so you can use Path2D.append to move your data to the new path", "label": {"api": {"Path2D.append": [[75, 87]]}}}, {"text": "Unique constraint over columns in collection table can be defined by using @CollectionTable with element collection", "label": {"api": {"@CollectionTable": [[75, 90]]}}}, {"text": "Use a Map implementation, keyed by Integer with value String", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "I found this example but they don't deliver the relational model, and it's not the exactly same model", "label": {"api": {"example": [[13, 19]]}}}, {"text": "More info on oracle site", "label": {"api": {"oracle site": [[13, 23]]}}}, {"text": "Notice that the max() method returns a Comparable object, that can't be compared with == with an int", "label": {"api": {"max()": [[16, 20]]}}}, {"text": "will only work if the list has at least 264 elements already (as the javadoc clearly states, should you decide to read it)", "label": {"api": {"javadoc clearly states": [[69, 90]]}}}, {"text": "You can use javax.swing.Timer to setup your timer", "label": {"api": {"javax.swing.Timer": [[12, 28]]}}}, {"text": "This behavior seems to result from the DefaultEditorKit, but I don’t see a possibility to get .getCaretPosition synchronous to .getText().length() independent of the used linebreak", "label": {"api": {"DefaultEditorKit": [[39, 54]]}}}, {"text": "Array implements Object", "label": {"api": {"Object": [[17, 22]]}}}, {"text": "Object is a class with methods a fields", "label": {"api": {"Object": [[0, 5]]}}}, {"text": "See the documentation in DataInput.readUTF for more details", "label": {"api": {"DataInput.readUTF": [[25, 41]]}}}, {"text": "You can use the ServiceLoader facility of Java to automatically load services", "label": {"api": {"ServiceLoader": [[16, 28]]}}}, {"text": "Check the documentation for ServiceLoader for more details", "label": {"api": {"ServiceLoader": [[28, 40]]}}}, {"text": "When you print value you can use BigDecimal.toPlainString() to return \"a string representation of this BigDecimal without an exponent field\"", "label": {"api": {"BigDecimal.toPlainString()": [[33, 58]]}}}, {"text": "First use XMLGregorianCalendar#toGregorianCalendar() to get a java.util.Calendar instance out of it", "label": {"api": {"XMLGregorianCalendar#toGregorianCalendar()": [[10, 51]], "java.util.Calendar": [[62, 79]]}}}, {"text": "From that step on, it's all obvious with a little help of SimpleDateFormat the usual way", "label": {"api": {"SimpleDateFormat": [[58, 73]]}}}, {"text": "To pass parameters to a process, use Runtime.getRuntime().exec(String[] command); the first position of the array is the command and the rest are the parameters", "label": {"api": {"Runtime.getRuntime().exec(String[] command)": [[37, 79]]}}}, {"text": "The ArrayList should provide the functionality that you need, if you declare it as an ArrayList<ArrayList<Integer>>", "label": {"api": {"ArrayList": [[4, 12], [86, 94], [96, 104]]}}}, {"text": "Your calls to push_back() are equivalent to calls to add()", "label": {"api": {"add()": [[53, 57]]}}}, {"text": "You will lose the array index access notation, but this can be resolved by chaining calls to get()", "label": {"api": {"get()": [[93, 97]]}}}, {"text": "I recommend having a look at the JavaDoc of Long.toString(long, int) and Long.valueof(String, int)", "label": {"api": {"Long.toString(long, int)": [[44, 67]], "Long.valueof(String, int)": [[73, 97]]}}}, {"text": "It seems you are looking for something like ExecutorService with fixed thread pool", "label": {"api": {"ExecutorService": [[44, 58]]}}}, {"text": "The Oracle docs say that the resultSet at first is pointing before the first row", "label": {"api": {"Oracle docs": [[4, 14]]}}}, {"text": "the List's equals() method will take care of the rest", "label": {"api": {"equals()": [[11, 18]]}}}, {"text": "And for the shuffling, you can use the existing Collections.shuffle() method", "label": {"api": {"Collections.shuffle()": [[48, 68]]}}}, {"text": "FWIW, Java 1.7 provides the Connection.getSchema() method", "label": {"api": {"Connection.getSchema()": [[28, 49]]}}}, {"text": "I'm guessing I'll need to get a Path object that represents this path on the classpath, but I'm not sure how to do that", "label": {"api": {"Path": [[32, 35]]}}}, {"text": "I found no code for them in KeyEvent", "label": {"api": {"KeyEvent": [[28, 35]]}}}, {"text": "The FilterChain#doFilter() call just continues the HTTP request to the destination, following exactly the same path as if you didn't use a filter in first place", "label": {"api": {"FilterChain#doFilter()": [[4, 25]]}}}, {"text": "For example, take Java's own class GridBagConstraints—it has no methods at all (if you don't count clone, which it has anyway; all Java classes inherit it from Object)", "label": {"api": {"GridBagConstraints": [[35, 52]]}}}, {"text": "And GridBagConstraints is a Java Bean in the purest sense", "label": {"api": {"GridBagConstraints": [[4, 21]]}}}, {"text": "Do you mean that you want to add methods to JRadioButton", "label": {"api": {"JRadioButton": [[44, 55]]}}}, {"text": "The typical way this is done is by extending JRadioButton, add the method and use that class everywhere", "label": {"api": {"JRadioButton": [[45, 56]]}}}, {"text": "String#split uses a regular expression", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "Effective Java Item #32 suggests using an EnumSet instead of bit fields", "label": {"api": {"EnumSet": [[42, 48]]}}}, {"text": "My scheduler can take arbitrary Runnable or Callable<V>, I will implement ScheduledExecutorService because it seems to be a good abstraction for the problem", "label": {"api": {"ScheduledExecutorService": [[74, 97]]}}}, {"text": "I won't give you the full implementation, but it'll probably wrap some standard ScheduledExecutorService with an additional synchronization for synchronized tasks", "label": {"api": {"ScheduledExecutorService": [[80, 103]]}}}, {"text": "Well, Vector has the two properties you asked for..", "label": {"api": {"Vector": [[6, 11]]}}}, {"text": "But if for whatever reason you really, really want a collection where each operation is individually synchronized, Vector will do the trick", "label": {"api": {"Vector": [[115, 120]]}}}, {"text": "Or you could use ArrayList and create a synchronized wrapper using Collections.synchronizedList", "label": {"api": {"ArrayList": [[17, 25]], "Collections.synchronizedList": [[67, 94]]}}}, {"text": "A Comparator<T> does not return the difference between two objects", "label": {"api": {"Comparator<T>": [[2, 14]]}}}, {"text": "You can do this using reflection to call window's method", "label": {"api": {"reflection": [[22, 31]]}}}, {"text": "You can hard-code them or use the reflection", "label": {"api": {"reflection": [[34, 43]]}}}, {"text": "Also, consider using memory-mapped files", "label": {"api": {"memory-mapped files": [[21, 39]]}}}, {"text": "The docs for equals() state that \"the identity of an element involves implicit state\", which in the javac implementation is actually invalidated once compilation is completed", "label": {"api": {"equals()": [[13, 20]]}}}, {"text": "This SimpleDateFormat pattern should work for your sample date", "label": {"api": {"SimpleDateFormat": [[5, 20]]}}}, {"text": "Java 8 introduces a Consumer interface which you can compose", "label": {"api": {"Consumer": [[20, 27]], "compose": [[53, 59]]}}}, {"text": "You can use a Function and set the second Argument to java.lang.Void this Function can only return null", "label": {"api": {"java.lang.Void": [[54, 67]]}}}, {"text": "Found just now in Annotation Type SuppressWarnings", "label": {"api": {"Annotation Type SuppressWarnings": [[18, 49]]}}}, {"text": "If you need to create thread unique state use ThreadLocal", "label": {"api": {"ThreadLocal": [[46, 56]]}}}, {"text": "And every time when you want to use ThreadLocal state and Aspects, think about your program design, is it right way for you", "label": {"api": {"ThreadLocal": [[36, 46]]}}}, {"text": "1) The most powerful tool in java to run process is ProcessBuilder", "label": {"api": {"ProcessBuilder": [[52, 65]], "Process": [[52, 58]]}}}, {"text": "Than using Process you are able to manipulate child process e.g", "label": {"api": {"Process": [[11, 17]]}}}, {"text": "read InputStream, destroy e.t.c", "label": {"api": {"InputStream": [[5, 15]], "destroy": [[18, 24]]}}}, {"text": "Perhaps iterate and add each entry to a StringBuilder, and separate using commas or similar", "label": {"api": {"StringBuilder": [[40, 52]]}}}, {"text": "Vector is largely deprecated these days (it's methods are synchronised by default, which is a little wasteful) and you should look at ArrayList or similar instead", "label": {"api": {"ArrayList": [[134, 142]]}}}, {"text": "Have a look at Throwable.getStackTrace()", "label": {"api": {"Throwable.getStackTrace()": [[15, 39]]}}}, {"text": "new Date(long) takes the number of milliseconds since the GMT epoch", "label": {"api": {"new Date(long)": [[0, 13]]}}}, {"text": "Calling Class.newInstance exhibits the problem mentioned in the javadoc", "label": {"api": {"Class.newInstance": [[8, 24]]}}}, {"text": "StringBuilder casting use AbstractStringBuilder#append(int) and explicit casting using String#valueOf(int) call Integer#toString(int) internaly", "label": {"api": {"String#valueOf(int)": [[87, 105]]}}}, {"text": "To quote the Pattern.split documentation", "label": {"api": {"Pattern.split documentation": [[13, 39]]}}}, {"text": "To solve your initial problem, you can use the java.util.Scanner class", "label": {"api": {"java.util.Scanner": [[47, 63]]}}}, {"text": "Indeed, the Iterator#hasNext method returns a boolean determining if the iterator will return another element with the next method", "label": {"api": {"Iterator#hasNext": [[12, 27]]}}}, {"text": "When using an Iterator, one has access to the hasNext() method which will return false when you are processing the last element", "label": {"api": {"hasNext()": [[46, 54]]}}}, {"text": "Just use the hasNext method", "label": {"api": {"hasNext": [[13, 19]]}}}, {"text": "The thing one might want to do here is to use an InputStreamReader with appropriate encoding", "label": {"api": {"InputStreamReader": [[49, 65]]}}}, {"text": "The thing is, Java assumes that an UTF-8 encoded file has no BOM, so you have to handle that case manually", "label": {"api": {"assumes that": [[19, 30]]}}}, {"text": "See the Action#isEnabled and Action#setEnabled methods", "label": {"api": {"Action#isEnabled": [[8, 23]], "Action#setEnabled": [[29, 45]]}}}, {"text": "You can either use Collections#sort and make your Catalog (Product from now on) class implement the Comparable interface", "label": {"api": {"Collections#sort": [[19, 34]]}}}, {"text": "On the other hand, if you have to stick to an array makke use of a Comparator (like with the TreeSet) and the Arrays#sort method", "label": {"api": {"Arrays#sort": [[110, 120]]}}}, {"text": "You can use ResourceBundles", "label": {"api": {"ResourceBundles": [[12, 26]]}}}, {"text": "use something like StringBuilder to construct the desired string, and then add it to your list, e.g", "label": {"api": {"StringBuilder": [[19, 31]]}}}, {"text": "Several FFmpeg wrappers, like Xuggle, which typically require you to learn a new API, because they don't implement javax.sound.sampled.spi", "label": {"api": {"javax.sound.sampled.spi": [[115, 137]]}}}, {"text": "This is a collection of libraries that implement javax.sound.sampled.spi to varying degrees (full disclosure - I wrote them)", "label": {"api": {"javax.sound.sampled.spi": [[49, 71]]}}}, {"text": "You should use BigDecimal for unlimited precision", "label": {"api": {"BigDecimal": [[15, 24]]}}}, {"text": "In any case, it seems very complicated when a static AtomicInteger would do the same thing without having to use a queue", "label": {"api": {"AtomicInteger": [[53, 65]]}}}, {"text": "Apart from the legacy Quartz library as mentioned by many others (apparently hanging in legacy J2EE era), you can also just use the standard Java SE API provided ScheduledExecutorService for that", "label": {"api": {"ScheduledExecutorService": [[162, 185]]}}}, {"text": "This needs to be initiated by a simple ServletContextListener like this", "label": {"api": {"ServletContextListener": [[39, 60]]}}}, {"text": "If you need to debug the exceptions and you want exact cause, you can use getCause() and getSuppressed() methods", "label": {"api": {"getCause()": [[74, 83]], "getSuppressed()": [[89, 103]]}}}, {"text": "You can use String.replaceAll() to accomplish this", "label": {"api": {"String.replaceAll()": [[12, 30]]}}}, {"text": "This is the signature for FileOutputStream with File as parameter", "label": {"api": {"FileOutputStream": [[26, 41]]}}}, {"text": "Besides, FileOutputStream is of IOException subclass whereas CustomException is of Exception subclass", "label": {"api": {"FileOutputStream": [[9, 24]]}}}, {"text": "So, You need format method of SimpleDateFormatter", "label": {"api": {"SimpleDateFormatter": [[30, 48]]}}}, {"text": "In this example we use BufferedReader in conjunction with InputStreamReader OR FileReader, depending on whether we are reading the .txt file as a resource or from the File System respectively", "label": {"api": {"BufferedReader": [[23, 36]], "InputStreamReader": [[58, 74]], "FileReader": [[79, 88]]}}}, {"text": "Are you trying to understand what is NullPointerException", "label": {"api": {"NullPointerException": [[37, 56]]}}}, {"text": "You can simply use the Java Logging API or some logging framework such as Log4J", "label": {"api": {"Java Logging API": [[23, 38]]}}}, {"text": "Take a look on HttpSessionListener", "label": {"api": {"HttpSessionListener": [[15, 33]]}}}, {"text": "You can create your custom exception using the originating exception as a cause", "label": {"api": {"exception as a cause": [[59, 78]]}}}, {"text": "You can do that with the SimpleDateFormat parse method", "label": {"api": {"SimpleDateFormat": [[25, 40]]}}}, {"text": "Using SimpleDateFormat is the proper method to check that the String is a valid date and it follows a given format of representation", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "SimpleDateFormat, apart from formatting a date, can also be used to parse Date from String", "label": {"api": {"SimpleDateFormat": [[0, 15]], "formatting a date": [[29, 45]]}}}, {"text": "parse(String), parse(String, ParsePosition)", "label": {"api": {"parse(String)": [[0, 12]], "parse(String, ParsePosition)": [[15, 42]]}}}, {"text": "By default, SimpleDateFormat is lenient, which means it will allow nonsensical dates such as 2013-025-234 to pass", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "Use setLenient(boolean lenient) to false will solve this problem", "label": {"api": {"setLenient(boolean lenient)": [[4, 30]]}}}, {"text": "We need to check the last position with parse(String, ParsePosition) method", "label": {"api": {"parse(String, ParsePosition)": [[40, 67]]}}}, {"text": "SimpleDateFormat will allow 2013-1-5 to pass, which I think is a reasonable leniency", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "I want to validate my JPA Entity with the @NotNull annotation", "label": {"api": {"Entity": [[26, 31]]}}}, {"text": "Here's my Entity", "label": {"api": {"Entity": [[10, 15]]}}}, {"text": "The Java 7 docs write", "label": {"api": {"Java 7 docs": [[4, 14]]}}}, {"text": "Consider instead using ThreadLocalRandom in multithreaded designs", "label": {"api": {"ThreadLocalRandom": [[23, 39]]}}}, {"text": "Furthermore, Math.abs(Long.MIN_VALUE) will still be negative, and a positive random number plus an id might cause overflow and wrap-around", "label": {"api": {"Math.abs(Long.MIN_VALUE)": [[13, 36]]}}}, {"text": "That being said, there is a UUID class in JDK which can be used off the shelf for this purpose", "label": {"api": {"UUID": [[28, 31]]}}}, {"text": "In order to start the Thread you should invoke drawingThread.start(); instead of run()", "label": {"api": {"start()": [[61, 67]]}}}, {"text": "start() will then start a new thread and call the method run() inside this thread", "label": {"api": {"start()": [[0, 6]]}}}, {"text": "Carefull, this is a non-limited Executor, see Executors.newFixedThreadPool to limit the number of Thread", "label": {"api": {"Executors.newFixedThreadPool": [[46, 73]]}}}, {"text": "In a database-independent way, you could use java.text.SimpleDateFormat", "label": {"api": {"java.text.SimpleDateFormat": [[45, 70]]}}}, {"text": "ServletContext.getRealPath(\"/WEB-INF/my.txt\") gives a File", "label": {"api": {"ServletContext.getRealPath(\"/WEB-INF/my.txt\")": [[0, 44]]}}}, {"text": "Make sure that the object you are storing in the array implements Serializable interface", "label": {"api": {"Serializable": [[66, 77]]}}}, {"text": "Use JPanels instead (background only works with opaque components, see http://docs.oracle.com/javase/7/docs/api/javax/swing/JComponent.html#setBackground%28java.awt.Color%29)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/JComponent.html#setBackground%28java.awt.Color%29": [[71, 172]]}}}, {"text": "You can use the String#split(String regex, int limit) method, to stop splitting after the column you wish to extract and get the String you want in one line of code", "label": {"api": {"String#split(String regex, int limit)": [[16, 52]]}}}, {"text": "I would suggest to use this constructor instead", "label": {"api": {"this constructor": [[23, 38]]}}}, {"text": "Just use the Date.compareTo(Date) method", "label": {"api": {"Date.compareTo(Date)": [[13, 32]]}}}, {"text": "Use the Properties class from Java standar Library, which implements Serializable", "label": {"api": {"Properties": [[8, 17]]}}}, {"text": "The replaceAll call removes all digits from the name", "label": {"api": {"replaceAll": [[4, 13]]}}}, {"text": "If you do require a synchronized Collection, you can use Collections.synchronizedList to synchronize your original List", "label": {"api": {"Collections.synchronizedList": [[57, 84]]}}}, {"text": "The method java.util.Arrays.asList(T...) returns a fixed-size list backed by the specified array", "label": {"api": {"java.util.Arrays.asList(T...)": [[11, 39]]}}}, {"text": "This implementation of List for this method (java.util.Arrays.ArrayList) don't have support for these methods", "label": {"api": {"ArrayList": [[62, 70]]}}}, {"text": "See the documentation for the java.util.AbstractList", "label": {"api": {"java.util.AbstractList": [[30, 51]]}}}, {"text": "If you know the total size of your list of words, you can init the capacitity for ArrayList, adding n elements requires O(n) time", "label": {"api": {"ArrayList": [[82, 90]]}}}, {"text": "You can tell if a column is auto-increment, using the ResultSetMetaData's isAutoIncrement method", "label": {"api": {"ResultSetMetaData": [[54, 70]]}}}, {"text": "You may consider looking at the URI class, specifically, the getHost method", "label": {"api": {"URI": [[32, 34]]}}}, {"text": "See the SimpleDateFormat documentation for more info", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "You're using YYYY in your format specifier, which is week year (See SimpleDateFormat)", "label": {"api": {"SimpleDateFormat": [[68, 83]]}}}, {"text": "You can use Arrays.sort method from Arrays class", "label": {"api": {"Arrays.sort": [[12, 22]]}}}, {"text": "You could simply use a ReentrantReadWriteLock", "label": {"api": {"ReentrantReadWriteLock": [[23, 44]]}}}, {"text": "See http://docs.oracle.com/javafx/2/api/javafx/scene/control/ListView.html#itemsProperty for further details of the list view items definition", "label": {"api": {"http://docs.oracle.com/javafx/2/api/javafx/scene/control/ListView.html#itemsProperty": [[4, 87]]}}}, {"text": "See ReentrantReadWriteLock for an example", "label": {"api": {"ReentrantReadWriteLock": [[4, 25]]}}}, {"text": "You can use a ByteArrayInputStream to wrap your existing byte array into an InputStream so that you can read from the byte array as from any other InputStream", "label": {"api": {"ByteArrayInputStream": [[14, 33]]}}}, {"text": "Take a look at the Matcher Class", "label": {"api": {"Matcher Class": [[19, 31]]}}}, {"text": "If you want decimal numbers to come out as exactly as you entered them in Java, use BigDecimal instead of float", "label": {"api": {"BigDecimal": [[84, 93]]}}}, {"text": "In addition comes the fact that tmpString.trim() in a loop might be creating copies of string", "label": {"api": {"tmpString.trim() in a loop might be creating copies of string": [[32, 92]]}}}, {"text": "You could use a Transformer and set the OutputKeys.OMIT_XML_DECLARATION property to \"yes\"", "label": {"api": {"Transformer": [[16, 26]], "OutputKeys.OMIT_XML_DECLARATION": [[40, 70]]}}}, {"text": "Use a StreamSource instead of a DOMSource to feed the String directly to the transformer, if you don't really need the Document", "label": {"api": {"StreamSource": [[6, 17]]}}}, {"text": "Use a DOMResult instead of a StreamResult if you wanted to output a Document", "label": {"api": {"DOMResult": [[6, 14]]}}}, {"text": "Look for DefaultComboBoxModel and JComboBox.setModel() method", "label": {"api": {"DefaultComboBoxModel": [[9, 28]], "JComboBox.setModel()": [[34, 53]]}}}, {"text": "It's not the best idea to work with org.w3c.dom.Node, because this class represents not only xml elements, but attributes, comments and other too", "label": {"api": {"org.w3c.dom.Node": [[36, 51]]}}}, {"text": "You should see this link, especially the part about Percentage Sizing", "label": {"api": {"link": [[20, 23]]}}}, {"text": "You're using the DefaultDesktopManager to manage your JDesktopPane", "label": {"api": {"DefaultDesktopManager": [[17, 37]], "DesktopManager": [[24, 37]]}}}, {"text": "The DefaultDesktopManager class implements the DesktopManager interface", "label": {"api": {"DefaultDesktopManager": [[4, 24]], "DesktopManager": [[11, 24], [47, 60]]}}}, {"text": "Looking at the source code for DefaultDesktopManager, the getBoundsForIconOf method is protected", "label": {"api": {"DefaultDesktopManager": [[31, 51]], "DesktopManager": [[38, 51]]}}}, {"text": "You might be able to extend DefaultDesktopManager to get the icon behavior that you want", "label": {"api": {"DefaultDesktopManager": [[28, 48]], "DesktopManager": [[35, 48]]}}}, {"text": "Otherwise, you'll have to write your own implementation of the DesktopManager interface", "label": {"api": {"DesktopManager": [[63, 76]]}}}, {"text": "You can start with Java Image-IO, read in your image and use the appropriate methods of the ImageReader class", "label": {"api": {"Java Image-IO": [[19, 31]], "ImageReader": [[92, 102]]}}}, {"text": "If you want to invoke a new process, see java.lang.Process", "label": {"api": {"java.lang.Process": [[41, 57]]}}}, {"text": "In Java, you can wrap your OutputStream with a GZIPOutputStream and your InputStream with a GZIPInputStream to compress/decompress your data on the fly using the GZIP algo", "label": {"api": {"GZIPOutputStream": [[47, 62]], "GZIPInputStream": [[92, 106]]}}}, {"text": "I know you can use Float.floatToRawIntBits() to convert to an int and Float.intBytesToFloat() to go back from the int", "label": {"api": {"Float.floatToRawIntBits()": [[19, 43]], "Float.intBytesToFloat()": [[70, 92]]}}}, {"text": "Maybe I did not get the problem, but couldn't you use Futures and Callables", "label": {"api": {"Futures and Callables": [[54, 74]]}}}, {"text": "Blocking queues were invented exactly for this purpose", "label": {"api": {"Blocking queues": [[0, 14]]}}}, {"text": "You should be able to do it by setting the Destination attribute", "label": {"api": {"Destination": [[43, 53]]}}}, {"text": "if you want to use FIFO - then use ReentrantLock with fair constructor argument set to \"true\"", "label": {"api": {"ReentrantLock": [[35, 47]]}}}, {"text": "As a side note, if you used a BlockingQueue you would not have to worry about those low level details and you could simply write", "label": {"api": {"BlockingQueue": [[30, 42]]}}}, {"text": "The most simplest way of doing this is to create a ServletContextListener class, create your datasource and put it into ServletContext so that the same instance could be retrieved from ServletContext in your project", "label": {"api": {"ServletContextListener": [[51, 72]], "ServletContext": [[51, 64], [120, 133], [185, 198]]}}}, {"text": "See my answer here how to create ServletContextListener", "label": {"api": {"ServletContextListener": [[33, 54]], "ServletContext": [[33, 46]]}}}, {"text": "To do this, you can start a number of threads at the application startup and use them when you need to run a long task", "label": {"api": {"application startup": [[53, 71]]}}}, {"text": "You just need to use StringTokenizer or String.split and iterate over the tokens to fill the map", "label": {"api": {"String.split": [[40, 51]]}}}, {"text": "I would just use java.util.concurrent.AtomicReference unless you really need the full equality check instead of a simple ==", "label": {"api": {"java.util.concurrent.AtomicReference": [[17, 52]]}}}, {"text": "compareAndSet returns a value saying whether or not the value was the expected one, so you can then conditionally execute other code", "label": {"api": {"compareAndSet": [[0, 12]]}}}, {"text": "Pass the maximum number to nextInt() instead", "label": {"api": {"nextInt()": [[27, 35]]}}}, {"text": "According to the SimpleDateFormat Javadoc, the format specifier Y is used to denote the \"Week year\"", "label": {"api": {"SimpleDateFormat Javadoc": [[17, 40]]}}}, {"text": "A Semaphore is sufficient", "label": {"api": {"Semaphore": [[2, 10]]}}}, {"text": "But, as some commenters said, a BlockingQueue is a better solution, as it means your code doesn't have to know anything about threading", "label": {"api": {"BlockingQueue": [[32, 44]]}}}, {"text": "You probably want to use a raw Java socket instead", "label": {"api": {"Java socket": [[31, 41]]}}}, {"text": "If you're using the Queue<T> interface, this is not possible", "label": {"api": {"interface": [[29, 37]]}}}, {"text": "For a linearly ordered queue, like you are talking about, you should look at the Deque<T> interface, which lets you add to and remove from either end of the queue", "label": {"api": {"interface": [[90, 98]]}}}, {"text": "Use DataInputStream to make your life easy", "label": {"api": {"DataInputStream": [[4, 18]]}}}, {"text": "You can use ProcessBuilder and get its IutputStream", "label": {"api": {"ProcessBuilder": [[12, 25]]}}}, {"text": "With FileWritter and BufferedWriter", "label": {"api": {"FileWritter": [[5, 15]], "BufferedWriter": [[21, 34]]}}}, {"text": "You can use FileWriter and StringWriter together", "label": {"api": {"FileWriter": [[12, 21]], "StringWriter": [[27, 38]]}}}, {"text": "For example, Map.Entry makes no sense outside its outer Map interface", "label": {"api": {"Map.Entry": [[13, 21]]}}}, {"text": "How can I re-configure java.util.logging in order to avoid INFO messages caused by LocalServiceTestHelper entirely", "label": {"api": {"java.util.logging": [[23, 39]], "INFO messages": [[59, 71]]}}}, {"text": "Perhaps arraycopy would have fitted better on java.util.Arrays, but that class wasn't added until Java 1.2, whereas arraycopy was there at the very beginning of Java", "label": {"api": {"java.util.Arrays": [[46, 61]]}}}, {"text": "There is a default random method in java.lang.math", "label": {"api": {"java.lang.math": [[36, 49]]}}}, {"text": "In the case of Object, the javadoc of equals is pretty clear", "label": {"api": {"javadoc of equals": [[27, 43]]}}}, {"text": "You can position your real mouse cursor over the element via the Robot class", "label": {"api": {"Robot": [[65, 69]]}}}, {"text": "You want to repeatedly call the .find() method instead (api docs)", "label": {"api": {"api docs": [[56, 63]]}}}, {"text": "But looking at the javadoc of Integer.parseInt, it doesn't say it'll throw a NPE so that's even more evidence to rule it out", "label": {"api": {"javadoc of Integer.parseInt": [[19, 45]]}}}, {"text": "You seem you be (just) asking how to create an ImageInputStream that reads from a byte array", "label": {"api": {"ImageInputStream": [[47, 62]]}}}, {"text": "The FileImageInputStream class doesn't have a constructor that allows you to read from anything but a file in the file system", "label": {"api": {"ImageInputStream": [[8, 23]]}}}, {"text": "The FileCacheImageInputStream would also be an option, but it involves providing a directory in the file system for temporary caching ..", "label": {"api": {"ImageInputStream": [[13, 28]]}}}, {"text": "Use DateFormat.setLenient(boolean) method with false argument", "label": {"api": {"DateFormat.setLenient(boolean)": [[4, 33]]}}}, {"text": "I'm not sure why you would want one (seems rather inefficient), but you could implement one yourself using CharsetDecoder", "label": {"api": {"CharsetDecoder": [[107, 120]]}}}, {"text": "Sounds like a problem for the CyclicBarrier", "label": {"api": {"CyclicBarrier": [[30, 42]]}}}, {"text": "There is a standard class called Robot", "label": {"api": {"Robot": [[33, 37]]}}}, {"text": "Collection.sort doesn't apply for a Map The Collections#sort function just receives a List and Map doesn't implement this interface", "label": {"api": {"Collections#sort": [[44, 59]]}}}, {"text": "If you need to have your Map items sorted, consider using a TreeMap instead of HashMap", "label": {"api": {"TreeMap": [[60, 66]]}}}, {"text": "Use Statement#executeUpdate for database write operations", "label": {"api": {"Statement#executeUpdate": [[4, 26]]}}}, {"text": "You could use java.util.Date", "label": {"api": {"java.util.Date": [[14, 27]]}}}, {"text": "I think that you can accomplish this with a JTable component in swing", "label": {"api": {"JTable": [[44, 49]]}}}, {"text": "equals() method as per the contract should return false when null passed as an argument", "label": {"api": {"the contract": [[23, 34]]}}}, {"text": "Reading the Javadoc for ArrayList.remove(index) finds", "label": {"api": {"Javadoc for ArrayList.remove(index)": [[12, 46]]}}}, {"text": "You're getting an InputMismatchException when typing Q but the code calls Scanner#nextInt()", "label": {"api": {"InputMismatchException": [[18, 39]]}}}, {"text": "It's basically the Scanner's way of telling you \"you asked for an int but the next token isn't one.\" You can add an additional check before the nextInt() calls, using Scanner#hasNextInt(), to verify that the next token actually is an int", "label": {"api": {"Scanner#hasNextInt()": [[167, 186]]}}}, {"text": "This is implemented as the default toString() for Object", "label": {"api": {"toString() for Object": [[35, 55]]}}}, {"text": "Consequently @ManyToOne annotation should be used", "label": {"api": {"@ManyToOne": [[13, 22]]}}}, {"text": "Perhaps you should try calling File.isDirectory() for the root object and checking its result before trying anything else", "label": {"api": {"File.isDirectory()": [[31, 48]]}}}, {"text": "What are the relative merits and demerits of annotation processing respect to bytecode generation (e.g", "label": {"api": {"annotation processing": [[45, 65]]}}}, {"text": "My personal favorite, to be honest, is using Java 7 method handles when possible - or just writing the **** getters and setters by hand", "label": {"api": {"Java 7 method handles": [[45, 65]]}}}, {"text": "Regarding increasing the size, have a look at using a MouseAdapter and updating this property in the mouseDragged method", "label": {"api": {"mouseDragged": [[101, 112]]}}}, {"text": "Use next, previous or show as appropriate to navigate between game panels", "label": {"api": {"next": [[4, 7]], "previous": [[10, 17]], "show": [[22, 25]]}}}, {"text": "My solution was to check the result of Thread.currentThread() in all methods from B so that calls coming from the worker thread will be delegated directly to the super method rather than being submitted as a new task", "label": {"api": {"Thread.currentThread()": [[39, 60]]}}}, {"text": "So now I am at the point where it's Thread.currentThread() that has become a performance issue, probably due to its being a native method that is called way too often", "label": {"api": {"Thread.currentThread()": [[36, 57]]}}}, {"text": "In addition to @Guillaume Polet's good advice, setVisibleRowCount() may be useful to you going forward", "label": {"api": {"setVisibleRowCount()": [[47, 66]]}}}, {"text": "\\s is the whitespace character regex search pattern", "label": {"api": {"whitespace character regex search pattern": [[10, 50]]}}}, {"text": "You should use SwingUtilities.invokeLater or SwingUtilities.invokeAndWait when updating the GUI from a different thread", "label": {"api": {"SwingUtilities.invokeLater": [[15, 40]], "SwingUtilities.invokeAndWait": [[45, 72]]}}}, {"text": "I would recommend adding a setPercent setter to your class which creates a Runnable to update the GUI via SwingUtilities.invokeLater", "label": {"api": {"SwingUtilities.invokeLater": [[106, 131]]}}}, {"text": "You can use SecureRandom to generate seeds for your two random number generators", "label": {"api": {"SecureRandom": [[12, 23]]}}}, {"text": "That said, notice that since Java 7, the preferred way to use PRNGs in multiple threads is ThreadLocalRandom", "label": {"api": {"ThreadLocalRandom": [[91, 107]]}}}, {"text": "The Math.max(double a, double b) and Math.min(double a, double b) should come in handy", "label": {"api": {"Math.max(double a, double b)": [[4, 31]], "Math.min(double a, double b)": [[37, 64]]}}}, {"text": "I would recommend using double and making a change in your way of getting data from the user by using the nextDouble() instead of nextByte()", "label": {"api": {"nextDouble()": [[106, 117]]}}}, {"text": "Use a ServerSocket (http://docs.oracle.com/javase/1.4.2/docs/api/java/net/ServerSocket.html) to listen on port 80", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/net/ServerSocket.html": [[20, 90]]}}}, {"text": "If it's standard input, one way to pull it is with System.in, which is an InputStream", "label": {"api": {"System.in": [[51, 59]], "InputStream": [[74, 84]]}}}, {"text": "The type of this variable can be String", "label": {"api": {"String": [[33, 38]]}}}, {"text": "I would suggest you look into using a SwingWorker object to execute the lengthy task and perform actions upon completion", "label": {"api": {"SwingWorker": [[38, 48]]}}}, {"text": "If you can use a List instead of an array, Collections provides an unmodifiable list", "label": {"api": {"Collections provides an unmodifiable list": [[43, 83]]}}}, {"text": "This would be better suited to a modal component such as a JDialog or a JOptionPane", "label": {"api": {"JDialog": [[59, 65]], "JOptionPane": [[72, 82]]}}}, {"text": "Turns out, there's an actual runtime check that can be inserted (Java 7+) Objects.requireNonNull which will throw a NullPointerException and cannot be removed with an -ea assertion", "label": {"api": {"Objects.requireNonNull": [[74, 95]]}}}, {"text": "If you can use a List<List<Integer>> instead of array, then your job would be quite easy by using Collections.max method", "label": {"api": {"Collections.max": [[98, 112]]}}}, {"text": "I know that JavaFX 2.2 provides FXCanvas for embedding new JavaFX components into existing SWT Composites", "label": {"api": {"FXCanvas": [[32, 39]]}}}, {"text": "Use the Calendar class", "label": {"api": {"Calendar": [[8, 15]]}}}, {"text": "Set it to the first date, and then check if the current day of the week is Wednesday by calling calendar.get(Calendar.DAY_OF_WEEK)", "label": {"api": {"Calendar": [[109, 116]]}}}, {"text": "Because the java exception class implements the Serializable interface", "label": {"api": {"exception class implements the Serializable interface": [[17, 69]]}}}, {"text": "Use getTextContent() instead", "label": {"api": {"getTextContent()": [[4, 19]]}}}, {"text": "Also, wrapping System.out in a PrintStream is redundant, as System.out is already a PrintStream itself", "label": {"api": {"System.out": [[15, 24], [60, 69]]}}}, {"text": "System.out is thread safe in the Sun implementation (as noted by Andre, that's technically not required by JVM implementations), so you will not be able to break output up, but that does not stop you from potentially interweaving output", "label": {"api": {"System.out": [[0, 9]]}}}, {"text": "First, take a look at DefaultTreeModel", "label": {"api": {"DefaultTreeModel": [[22, 37]]}}}, {"text": "Third, insert the text lines as nodes on the DefaultTreeModel, based on the second number", "label": {"api": {"DefaultTreeModel": [[45, 60]]}}}, {"text": "You could model this pairing association by using a Map", "label": {"api": {"Map": [[52, 54]]}}}, {"text": "Take into account that by definition of Map, you couldn't have two different Strings for a given Integer", "label": {"api": {"Map": [[40, 42]]}}}, {"text": "If you wanted to allow this, you should use a Map<Integer, List<String>> instead", "label": {"api": {"Map": [[46, 48]]}}}, {"text": "If not, use FontMetrics.stringWidth() to figure out how many pixels wide your string will be and, if it's too long, insert \"...\"  and keep dropping letters at the position where you would like until it fits", "label": {"api": {"FontMetrics.stringWidth()": [[12, 36]]}}}, {"text": "The WatchDir example uses java.nio.file package, which is only available from Java 7", "label": {"api": {"java.nio.file": [[26, 38]]}}}, {"text": "If you want some other format, you should use System.out.printf", "label": {"api": {"System.out.printf": [[46, 62]]}}}, {"text": "It's not exactly clear what you want, but the Java SDK does provide a BitSet, along with a number of useful methods for working with BitSets", "label": {"api": {"BitSet": [[70, 75], [133, 138]]}}}, {"text": "After seeing kaliatech's answer below, you could also use BitSet", "label": {"api": {"BitSet": [[58, 63]]}}}, {"text": "The solution is very similar, but the math logic is encapsulated in the BitSet object and it allows for an arbitrary number of bits so you aren't limited to only 64", "label": {"api": {"BitSet": [[72, 77]]}}}, {"text": "You can use two SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "Use ListCellRenderer to display Proveedores Name in the ComboBox", "label": {"api": {"ListCellRenderer": [[4, 19]]}}}, {"text": "You could try with a ScheduledExecutorService instead, with more than one thread if your task can take more than 1 sec to run", "label": {"api": {"ScheduledExecutorService": [[21, 44]]}}}, {"text": "Rather use SimpleDateFormat with appropriate pattern to parse the date string", "label": {"api": {"SimpleDateFormat": [[11, 26]]}}}, {"text": "On the other hand unchecked exception (aka RuntimeException) are \"not supposed to happen\", it's most of the time a programming problem", "label": {"api": {"RuntimeException": [[43, 58]]}}}, {"text": "If you want to build something yourself, look the Direct Known Subclasses of RuntimeException, it will help you to identify exceptions that can be thrown without being caught", "label": {"api": {"RuntimeException": [[77, 92]]}}}, {"text": "Arrays.equals(Object[] a1, Object[] a2)", "label": {"api": {"Arrays.equals(Object[] a1, Object[] a2)": [[0, 38]]}}}, {"text": "The Official Java API Documentation is an essential tool for any Java programmer", "label": {"api": {"Official Java API Documentation": [[4, 34]]}}}, {"text": "In particular, check out the docs for MouseListener to see what methods you need to implement", "label": {"api": {"the docs for MouseListener": [[25, 50]]}}}, {"text": "It looks like a namespace collision with java.lang.Character", "label": {"api": {"java.lang.Character": [[41, 59]]}}}, {"text": "Please read http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html for details", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[12, 83]]}}}, {"text": "You'll note in the Javadoc for String.replaceAll() that the first argument is a regular expression", "label": {"api": {"Javadoc for String.replaceAll()": [[19, 49]]}}}, {"text": "Your MBean interface must extend NotificationEmitter for doing this", "label": {"api": {"NotificationEmitter": [[33, 51]]}}}, {"text": "There is SwingUtilities.invokeAndWait", "label": {"api": {"SwingUtilities.invokeAndWait": [[9, 36]]}}}, {"text": "With java.nio.ByteBuffer you may specify the endianness you want", "label": {"api": {"java.nio.ByteBuffer": [[5, 23]]}}}, {"text": "ByteBuffer have methods to extract data as byte, char, getShort(), getInt(), long, double..", "label": {"api": {"getShort()": [[55, 64]], "getInt()": [[67, 74]]}}}, {"text": "For example, any implementation of SortedMap (e.g", "label": {"api": {"SortedMap": [[35, 43]]}}}, {"text": "TreeMap) will return the entries sorted by key order (possibly according to a custom comparator) - although that has implications on the complexity of adding and fetching entries, of course", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "Then there's LinkedHashMap which will always return entries in insertion order", "label": {"api": {"LinkedHashMap": [[13, 25]], "HashMap": [[19, 25]]}}}, {"text": "If you're talking about plain HashMap though - no, you mustn't rely on the ordering", "label": {"api": {"HashMap": [[30, 36]]}}}, {"text": "In Java bit strings are implemented by BitSet", "label": {"api": {"BitSet": [[39, 44]]}}}, {"text": "Also in this solution, only one Thread can read the value at once, so you might want replace the synchronized block with a ReadWriteLock although I doubt it will have a heavy effect on performance, given how simple the critical block is", "label": {"api": {"ReadWriteLock": [[123, 135]]}}}, {"text": "Use a MouseListener instead", "label": {"api": {"MouseListener": [[6, 18]]}}}, {"text": "This way, you'll get a MouseEvent, from which you can get the clicked point by calling MouseEvent#getPoint()", "label": {"api": {"MouseEvent": [[23, 32], [87, 96]], "MouseEvent#getPoint()": [[87, 107]]}}}, {"text": "Go for HashMap", "label": {"api": {"HashMap": [[7, 13]]}}}, {"text": "youhave to execute the query using PreparedStatement.executeQuery() which returns a ResultSet object", "label": {"api": {"PreparedStatement.executeQuery()": [[35, 66]]}}}, {"text": "Use an ArrayList instead of an array", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "That way you would just need to use ArrayList#contains(obj) method to test whether the id is already in the ArrayList or not", "label": {"api": {"ArrayList": [[36, 44], [108, 116]], "ArrayList#contains(obj)": [[36, 58]]}}}, {"text": "Or, you can just work with a HashSet, which will work faster with its HashSet#contains() method", "label": {"api": {"HashSet": [[29, 35], [70, 76]], "HashSet#contains()": [[70, 87]]}}}, {"text": "Don't use an (Array)List, use a Set", "label": {"api": {"Set": [[32, 34]]}}}, {"text": "You can use Collections.max(Collection) to find the maximum element out of any collection", "label": {"api": {"Collections.max(Collection)": [[12, 38]]}}}, {"text": "Similarly, for a HashMap, you can use the same method on its keySet() or values(), depending upon whether you want maximum key, or maximum value", "label": {"api": {"HashMap": [[17, 23]], "keySet()": [[61, 68]], "values()": [[73, 80]]}}}, {"text": "Also, if you want as such, you can use a TreeSet and TreeMap instead, that stores the elements in sorted key order", "label": {"api": {"TreeSet": [[41, 47]], "TreeMap": [[53, 59]]}}}, {"text": "you can achieve it using SimpleDateFormat, which is meant to format date and times", "label": {"api": {"SimpleDateFormat": [[25, 40]]}}}, {"text": "You're getting an ArrayIndexOutOfBoundsException because your input string is just a dot, ie \".\", which is an edge case that produces an empty array when split on dot; split(regex) removes all trailing blanks from the result, but since splitting a dot on a dot leaves only two blanks, after trailing blanks are removed you're left with an empty array", "label": {"api": {"split(regex)": [[168, 179]]}}}, {"text": "To avoid getting an ArrayIndexOutOfBoundsException for this edge case, use the overloaded version of split(regex, limit), which has a second parameter that is the size limit for the resulting array", "label": {"api": {"split(regex, limit)": [[101, 119]]}}}, {"text": "You can have a look at BigInteger class to get an idea of how you can define methods to support various operations", "label": {"api": {"BigInteger": [[23, 32]]}}}, {"text": "What you can do is define methods to represent the operations, like BigDecimal or BigInteger in the standard library do", "label": {"api": {"BigDecimal": [[68, 77]], "BigInteger": [[82, 91]]}}}, {"text": "In Java a File is an object describing a thing in the filesystem and and to alter/add to the data in the file you have to create a stream from the file", "label": {"api": {"File": [[10, 13]]}}}, {"text": "C and C++ standards don't have the equivalent of the Java File the neaerest equivalent is the Boost Filesystem library", "label": {"api": {"File": [[58, 61], [100, 103]]}}}, {"text": "But getPassword() returns char[] not String, this is because the echo is not human readable", "label": {"api": {"getPassword()": [[4, 16]]}}}, {"text": "Check out the reference", "label": {"api": {"reference": [[14, 22]]}}}, {"text": "Read the javadoc of SimpleDateFormat", "label": {"api": {"javadoc of SimpleDateFormat": [[9, 35]]}}}, {"text": "* String#matches() calls Pattern#matches(), which calls Matcher#matches(), which explains that true is returned if, and only if, the entire region sequence matches this matcher's pattern", "label": {"api": {"which explains that": [[75, 93]]}}}, {"text": "More than likely this isn't the only place you're doing this, and probably want an Executor set up to perform these tasks", "label": {"api": {"Executor": [[83, 90]]}}}, {"text": "Without knowing more about your code (especially since you're using a static method) I can't comment on how you would want to set up the Executor but the simplest example of using a Thread would be", "label": {"api": {"Executor": [[137, 144]]}}}, {"text": "Note this is far less efficient than having an Executor that is ready to run your task; it has to create a new Thread every time", "label": {"api": {"Executor": [[47, 54]]}}}, {"text": "Add the items from your list into a Set and check its size", "label": {"api": {"Set": [[36, 38]]}}}, {"text": "If it failed because of some problem in the web service and you want to wait X time before trying again then you can do either schedule for the web service to be called at a later date for that specific Message (look into ScheduledExecutorService) or do as you described and use a cron job with some database entries", "label": {"api": {"ScheduledExecutorService": [[222, 245]]}}}, {"text": "Simply use StringBuilder", "label": {"api": {"StringBuilder": [[11, 23]]}}}, {"text": "Write to a StringBuilder, then replace your sequence and only then write to a file", "label": {"api": {"StringBuilder": [[11, 23]]}}}, {"text": "In Java, you have a java.awt.Polygon", "label": {"api": {"java.awt.Polygon": [[20, 35]]}}}, {"text": "You can use two SimpleDateFormats - one to parse the input and one to produce the output", "label": {"api": {"SimpleDateFormats": [[16, 32]]}}}, {"text": "The List#contains function will use the Object#equals function of the objects in the container", "label": {"api": {"List#contains": [[4, 16]]}}}, {"text": "If you don't override both, two instances might be considered the same in a List, but not the same in a 'Hashmap'", "label": {"api": {"'Hashmap'": [[104, 112]]}}}, {"text": "One way is to Create webdriver instance as a ThreadLocal object", "label": {"api": {"ThreadLocal": [[45, 55]]}}}, {"text": "You can use simple String#replace like this", "label": {"api": {"String#replace": [[19, 32]]}}}, {"text": "Anything that implements AutoCloseable can be used as demonstrated below", "label": {"api": {"AutoCloseable": [[25, 37]]}}}, {"text": "You could use -1 as your String#split limit", "label": {"api": {"String#split": [[25, 36]]}}}, {"text": "A SortedSet is a really nice way to do this, but you can't insert duplicates, and since you want to sort by experience, and a person could've been at two jobs the same amount of time you need to use an alternate approach", "label": {"api": {"SortedSet": [[2, 10]]}}}, {"text": "That bit of trickery in Person.addJob will keep the List always sorted by the 'natural order' of Job", "label": {"api": {"'natural order'": [[78, 92]]}}}, {"text": "The java.util.concurrent package has everything you need to avoid writing your own code and re-inventing the wheel", "label": {"api": {"java.util.concurrent package": [[4, 31]]}}}, {"text": "Use a CopyOnWriteArrayList for your list implementation and it's job done", "label": {"api": {"CopyOnWriteArrayList": [[6, 25]]}}}, {"text": "Class has both an isInstance() method and an isAssignableFrom() method for checking stuff like that", "label": {"api": {"isInstance()": [[18, 29]], "isAssignableFrom()": [[45, 62]]}}}, {"text": "Use the java.nio.file package to find out why your delete operation fails", "label": {"api": {"java.nio.file": [[8, 20]]}}}, {"text": "One way to solve this is without looping or recursion is by [ab]using String.replace1", "label": {"api": {"String.replace": [[70, 83]]}}}, {"text": "Please read up the documentation of Pattern class to understand how to use matches function to check your input", "label": {"api": {"matches": [[75, 81]], "Pattern": [[36, 42]]}}}, {"text": "I haven't used TypedQuery myself, but the documentation for getSingleResult() certainly suggests this is the right approach", "label": {"api": {"documentation for getSingleResult()": [[42, 76]]}}}, {"text": "Note that you need to change the type of CacheHandler.photoCache to accommodate the wrapping FutureTasks", "label": {"api": {"Future": [[93, 98]], "FutureTask": [[93, 102]]}}}, {"text": "You could also use a ConcurrentMap for the cache, which would allow the use of putIfAbsent, a more concurrent alternative to the lock/get/check for null/put/unlock sequence", "label": {"api": {"putIfAbsent": [[79, 89]]}}}, {"text": "But instead of putting in a Photo, you put in a Future, which is essentially a placeholder for a Photo which may not (or may) be there right at that moment, but which will become available later", "label": {"api": {"Future": [[48, 53]]}}}, {"text": "The get method on Future gets the thing that a place is being held for, blocking until it arrives if necessary", "label": {"api": {"Future": [[18, 23]]}}}, {"text": "This code uses FutureTask as an implementation of Future; this takes a Callable capable of producing a Photo as a constructor argument, and calls it when its run method is called", "label": {"api": {"Future": [[15, 20], [50, 55]], "FutureTask": [[15, 24]], "Callable": [[71, 78]]}}}, {"text": "Look at the concurreny API for the thread pools and the NIO API for the IO", "label": {"api": {"concurreny API": [[12, 25]], "NIO API": [[56, 62]]}}}, {"text": "You should be using the putIfAbsent methods of ConcurrentMap", "label": {"api": {"putIfAbsent": [[24, 34]]}}}, {"text": "The constructor adds headers to the underlying stream before you start writing objects", "label": {"api": {"constructor": [[4, 14]]}}}, {"text": "Alternatively, you might want to consider managing the serialization yourself manually through Externalizable", "label": {"api": {"Externalizable": [[95, 108]]}}}, {"text": "According to the Java File API", "label": {"api": {"Java File API": [[17, 29]]}}}, {"text": "If you are using Connection pool library like c3p0 then you can safely user CachedRowSet and its implementation CachedRowSetImpl", "label": {"api": {"CachedRowSet": [[76, 87], [112, 123]], "CachedRowSetImpl": [[112, 127]]}}}, {"text": "A CachedRowSet object is a disconnected rowset, which means that it makes use of a connection to its data source only briefly", "label": {"api": {"CachedRowSet": [[2, 13]]}}}, {"text": "The rest of the time, a CachedRowSet object is disconnected, including while its data is being modified", "label": {"api": {"CachedRowSet": [[24, 35]]}}}, {"text": "You either need to escape the pipe or use it inside a character class in your split, as String#split takes a regex, and | is a meta character in regex", "label": {"api": {"String#split": [[88, 99]]}}}, {"text": "In addition to that, you should use Arrays#toString method to print your array", "label": {"api": {"Arrays#toString": [[36, 50]]}}}, {"text": "String.split() returns an array of length 1 for your third line, so that args[1] is out of bounds", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "You should also use String.isEmpty() instead of != \"\"", "label": {"api": {"String.isEmpty()": [[20, 35]]}}}, {"text": "But one is that by making String#length() a property, it can be declared in an interface instead (in this case CharSequence)", "label": {"api": {"CharSequence": [[111, 122]]}}}, {"text": "If you do not intend to modify the list anywhere else, then using Collections.unmodifiableList() to ensure (and document) this fact is probably a good idea", "label": {"api": {"Collections.unmodifiableList()": [[66, 95]]}}}, {"text": "Use Math.atan2(), and remember that the result is in radians, not in degrees", "label": {"api": {"Math.atan2()": [[4, 15]]}}}, {"text": "You can use List#contains method", "label": {"api": {"List#contains": [[12, 24]]}}}, {"text": "You can use Arrays#asList() method fot that", "label": {"api": {"Arrays#asList()": [[12, 26]]}}}, {"text": "What you want is BufferedImage.setRGB(..) -- if you are drawing pixel-by-pixel, I assume you have implemented an algorithm that will render the RGB values for each pixel (much like we did with the heat-maps)", "label": {"api": {"BufferedImage.setRGB(..)": [[17, 40]]}}}, {"text": "(1000.00) is incorrect input according to the documentation", "label": {"api": {"according to the documentation": [[29, 58]]}}}, {"text": "I think that DecimalFormat is a more appropriate tool for the job", "label": {"api": {"DecimalFormat": [[13, 25]]}}}, {"text": "one possibiltiy seems to be to use something like Quicksilver, and a Robot to send it keypresses with modifiers", "label": {"api": {"Robot": [[69, 73]]}}}, {"text": "Managed to get it working with Runtime.exec(), osascript, and AppleScript", "label": {"api": {"Runtime.exec()": [[31, 44]]}}}, {"text": "Java launches an AppleScript and passes it the application name, using osascript from the command line, via Runtime.exec()", "label": {"api": {"Runtime.exec()": [[108, 121]]}}}, {"text": "JFrame#add is an instance method that is inherited from java.awt.Container", "label": {"api": {"JFrame#add": [[0, 9]]}}}, {"text": "Class HelloFrameMenu would have to extend JFrame and the add method comes from Container and is used for adding visual components to the frame", "label": {"api": {"Container": [[79, 87]]}}}, {"text": "Instead of passing a location, you could pass an InputStream to your parseSkeleton method and change to using DocumentBuilder#parse(InputStream)", "label": {"api": {"DocumentBuilder#parse(InputStream)": [[110, 143]]}}}, {"text": "Comparator is an interface with only one method", "label": {"api": {"Comparator": [[0, 9]]}}}, {"text": "When you create a Comparator, this is the only method you need to implement", "label": {"api": {"Comparator": [[18, 27]]}}}, {"text": "Note that PersonComparator.compareTo() does nothing but return the difference of the IDs of the two Person objects", "label": {"api": {"Comparator": [[16, 25]]}}}, {"text": "Check out the documentation for Comparator for more info..", "label": {"api": {"Comparator": [[32, 41]]}}}, {"text": "an instance of an ObjectInputStream and an instance of an ObjectOutputStream) and stubbed out the methods I want to be testing in a fashion similar to the following code snippet", "label": {"api": {"ObjectInputStream": [[18, 34]], "ObjectOutputStream": [[58, 75]]}}}, {"text": "[Edit] The closest thing to \"covering the environment\" is probably some of the ScriptEngine static fields which allow Java programs to specify things like positional arguments (ARGV) and emulating the \"filename\" of what is being executed", "label": {"api": {"ScriptEngine static fields": [[79, 104]]}}}, {"text": "See the javax.script package to start learning about the Java Scripting API", "label": {"api": {"javax.script package": [[8, 27]]}}}, {"text": "The best way to do this (in Java) is using an Executor/ExecutorService and related items (http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executors.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executors.html": [[90, 165]]}}}, {"text": "Consider using Collections.shuffle(...) to randomize a list", "label": {"api": {"Collections.shuffle(...)": [[15, 38]]}}}, {"text": "Yes, use ExecutorService and submit Callable object, then wait until future.get() returns with the result", "label": {"api": {"ExecutorService": [[9, 23]], "Callable": [[36, 43]], "future.get()": [[69, 80]]}}}, {"text": "Note again that future.get() blocks until the background thread finishes executing call()", "label": {"api": {"future.get()": [[16, 27]]}}}, {"text": "setComponentZOrder() method doesn't seem to be described precisely in javadoc", "label": {"api": {"setComponentZOrder()": [[0, 19]]}}}, {"text": "Instead use StringBuilder#append(yourLine)", "label": {"api": {"StringBuilder#append(yourLine)": [[12, 41]]}}}, {"text": "in Java Audio, Clip inherits from DataLine which has a stop() method", "label": {"api": {"DataLine": [[34, 41]], "Clip": [[15, 18]]}}}, {"text": "According to the document for Clip", "label": {"api": {"Clip": [[30, 33]]}}}, {"text": "It represents a discrete moment in time and is \"intended to reflect coordinated universal time\"", "label": {"api": {"\"intended to reflect coordinated universal time\"": [[47, 94]]}}}, {"text": "You'd want to use Calendar.HOUR_OF_DAY instead of Calendar.HOUR for that, or else do some hour math", "label": {"api": {"Calendar.HOUR_OF_DAY": [[18, 37]], "Calendar.HOUR": [[18, 30], [50, 62]]}}}, {"text": "Calendar.HOUR uses 0 to represent both noon and midnight", "label": {"api": {"Calendar.HOUR": [[0, 12]]}}}, {"text": "If you used Calendar.HOUR instead of Calendar.HOUR_OF_DAY, then you'd see this instead", "label": {"api": {"Calendar.HOUR_OF_DAY": [[37, 56]], "Calendar.HOUR": [[12, 24], [37, 49]]}}}, {"text": "You can read here more detailed information about the Math class and their methods (such as public static double max(double a,double b)", "label": {"api": {"public static double max(double a,double b)": [[92, 134]]}}}, {"text": "And if you want a single String in the form of HH:mm:ss as output, you can use a SimpleDateFormat as pointed out by @zvzdhk", "label": {"api": {"SimpleDateFormat": [[81, 96]]}}}, {"text": "You need Map for that it is a collection of key,value pair", "label": {"api": {"Map": [[9, 11]]}}}, {"text": "So, you  wrap your exception in any unchecked exception like that extends RuntimeException or even RuntimeException itself", "label": {"api": {"RuntimeException": [[74, 89], [99, 114]]}}}, {"text": "In Java, we have Collections.emptyList() and Collections.EMPTY_LIST", "label": {"api": {"Collections.emptyList()": [[17, 39]], "Collections.EMPTY_LIST": [[45, 66]]}}}, {"text": "Use a Set (such as HashSet) for the book names collection, this way you don't have to check every time whether you already have the current book name", "label": {"api": {"Set": [[6, 8], [23, 25]]}}}, {"text": "You can insert elements in constant time into a HashSet, and you will have no duplicates", "label": {"api": {"Set": [[52, 54]]}}}, {"text": "I don't know what you have behind Files.createFile(path); but few important things about File API", "label": {"api": {"File API": [[89, 96]]}}}, {"text": "File.exists() must be used to check the existence of a file in the File System", "label": {"api": {"File.exists()": [[0, 12]]}}}, {"text": "The File.delete() returns a boolean telling you if the call was successful or not", "label": {"api": {"File.delete()": [[4, 16]]}}}, {"text": "The File.renameTo(anotherFile) can be used to rename a file", "label": {"api": {"File.renameTo(anotherFile)": [[4, 29]]}}}, {"text": "You can use the JavaCompiler API to compile the class and it will let you know if there are some compile errors", "label": {"api": {"JavaCompiler API": [[16, 31]]}}}, {"text": "The only really available support for raw sockets in Java standard library seems the InetAddress.isReachable() that may do ICMP ping if permitted", "label": {"api": {"InetAddress.isReachable()": [[85, 109]]}}}, {"text": "SUNDAY is a static final field in Calendar API", "label": {"api": {"SUNDAY": [[0, 5]]}}}, {"text": "and getFirstDayOfWeek() returns an int value(day of the week in int representation), thus the comparision is valid", "label": {"api": {"getFirstDayOfWeek(": [[4, 21]]}}}, {"text": "JPA does offer possibility to cascade operations (merge, persist, refresh, remove) to associated entities", "label": {"api": {"cascade": [[30, 36]]}}}, {"text": "Logic is in JPA and does not utilize database cascades", "label": {"api": {"cascade": [[46, 52]]}}}, {"text": "There is no JPA standard compliant way to do cascades with database cascades", "label": {"api": {"cascade": [[45, 51], [68, 74]]}}}, {"text": "If such a cascades are preferred, we have to fall back to Hibernate specific construct", "label": {"api": {"cascade": [[10, 16]]}}}, {"text": "See the Comparator documentation for more details", "label": {"api": {"Comparator documentation": [[8, 31]]}}}, {"text": "You can safely use ConcurrentHashMap.merge", "label": {"api": {"ConcurrentHashMap.merge": [[19, 41]]}}}, {"text": "A class which is loaded by class loader X does not equals() the very same class which is loaded by class loader Y", "label": {"api": {"equals()": [[51, 58]]}}}, {"text": "I am using the JavaFX 2.2.5 to play local audio files in my application using the Media and MediaPlayer classes", "label": {"api": {"Media": [[82, 86], [92, 96]], "MediaPlayer": [[92, 102]]}}}, {"text": "If you read the file line by line using a BufferedReader (it offers a method readLine()), you can then write the output to another file using a PrintWriter and first you write the $ character using print() and then the line you read from the BufferedReader using println()", "label": {"api": {"BufferedReader": [[42, 55], [242, 255]], "readLine()": [[77, 86]], "PrintWriter": [[144, 154]], "print()": [[198, 204]], "println()": [[263, 271]]}}}, {"text": "Try the String#charAt() method", "label": {"api": {"String#charAt()": [[8, 22]]}}}, {"text": "You're looking for charAt(i) instead of toCharArray()", "label": {"api": {"charAt(i)": [[19, 27]]}}}, {"text": "For me, I was all set to recommend you take a look at a threading solution, perhaps using ThreadPoolExecutor if you require mulitple IO-bound calls (although you'd need to be wary of clogging up db sessions)", "label": {"api": {"ThreadPoolExecutor": [[90, 107]]}}}, {"text": "For your special case, you can modify directly the backing array using the array() method", "label": {"api": {"array()": [[75, 81]]}}}, {"text": "I think you can call this version of putShort() that accepts a possition index", "label": {"api": {"putShort()": [[37, 46]]}}}, {"text": "Since you're using Jackson to parse these, I assume you must be parsing them into a List of some sort of object with an ID and name", "label": {"api": {"List": [[84, 87]]}}}, {"text": "If that is the case, simply write a standard Comparator", "label": {"api": {"Comparator": [[45, 54]]}}}, {"text": "Once we got a Java List, Collections.sort can do the sorting", "label": {"api": {"Collections.sort": [[25, 40]]}}}, {"text": "I wrote a multithreaded gameserver application which handles multiple simultaneous connections using NIO", "label": {"api": {"NIO": [[101, 103]]}}}, {"text": "You should probably use a Pattern and Matcher to loop through the matches, effectively doing a manual search and replace", "label": {"api": {"Pattern": [[26, 32]], "Matcher": [[38, 44]]}}}, {"text": "If you check EmptyStackException information you see that is 'Thrown by methods in the Stack class to indicate that the stack is empty'", "label": {"api": {"EmptyStackException": [[13, 31]]}}}, {"text": "The best you could do is something akin to http://docs.oracle.com/javase/6/docs/api/java/io/FilenameFilter.html , where you make an interface that accepts elements while iterating over it", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/FilenameFilter.html": [[43, 110]]}}}, {"text": "This is the expected behavior of the ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[37, 54]]}}}, {"text": "To borrow the idea from Pshemo's comment in another answer, throw a RuntimeException in the constructor to prevent reflection's setAccessible method in AccessibleObject from allowing instantiation", "label": {"api": {"AccessibleObject": [[152, 167]]}}}, {"text": "Use a Set", "label": {"api": {"Set": [[6, 8]]}}}, {"text": "The common implementations are HashSet and TreeSet", "label": {"api": {"Set": [[35, 37], [47, 49]], "HashSet": [[31, 37]], "TreeSet": [[43, 49]]}}}, {"text": "The latter preserves the order of items as it implements SortedSet", "label": {"api": {"Set": [[63, 65]], "SortedSet": [[57, 65]]}}}, {"text": "This is a set", "label": {"api": {"set": [[10, 12]]}}}, {"text": "The cleanest solution would be to use a java.util.EnumSet for each mask", "label": {"api": {"java.util.EnumSet": [[40, 56]]}}}, {"text": "I think if your situation is really simple and your scenario is small (and you don't need complicated regexps), you can simply use String.replaceAll or String.replace", "label": {"api": {"String.replaceAll": [[131, 147]], "String.replace": [[131, 144], [152, 165]]}}}, {"text": "use Calendar class", "label": {"api": {"Calendar class": [[4, 17]]}}}, {"text": "A good example of this from the Java API is the Map.Entry interface", "label": {"api": {"Map.Entry": [[48, 56]]}}}, {"text": "I am getting into Semaphores in Java and was reading this article http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Semaphore.html", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Semaphore.html": [[66, 145]]}}}, {"text": "Use AtomicInteger if you're worried about thread safety", "label": {"api": {"AtomicInteger": [[4, 16]]}}}, {"text": "Then use the config option described in the top level class documentation of the LogManager to attach your FileHandler with the SimpleFormatter and your FileHandler without formatting", "label": {"api": {"LogManager": [[81, 90]]}}}, {"text": "If no string literals exist in your program (and you don't ever call String.intern) then the JVM does not allocate heap memory for such", "label": {"api": {"String.intern": [[69, 81]]}}}, {"text": "From the documentation of File.list()", "label": {"api": {"File.list()": [[26, 36]]}}}, {"text": "and you should definitely use a StringBuilder for building strings", "label": {"api": {"StringBuilder": [[32, 44]]}}}, {"text": "See the documentation on the jdk documentation page", "label": {"api": {"jdk documentation": [[29, 45]]}}}, {"text": "I'd use the MemoryMXBean myself", "label": {"api": {"MemoryMXBean": [[12, 23]]}}}, {"text": "Any way I recomend you write your custom table model extends DefaultTableModel (http://docs.oracle.com/javase/1.5.0/docs/api/javax/swing/table/DefaultTableModel.html), it's more flexible", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/javax/swing/table/DefaultTableModel.html": [[80, 164]]}}}, {"text": "Use DateFormat.setCalendar(Calendar cal) to set a Calendar with GMT as its timezone, or use DateFormat.setTimeZone(TimeZone zone) with the GMT TimeZone", "label": {"api": {"DateFormat.setCalendar(Calendar cal)": [[4, 39]], "DateFormat.setTimeZone(TimeZone zone)": [[92, 128]]}}}, {"text": "You could use the standard Java SE provided DatatypeConverter#printBase64Binary() method to Base64-encode a byte array", "label": {"api": {"DatatypeConverter#printBase64Binary()": [[44, 80]]}}}, {"text": "As you're using Java 7 you can make use of the new Path class, which has a number of really cool methods, including Path.relativize", "label": {"api": {"Path.relativize": [[116, 130]]}}}, {"text": "ObjectOutputStream has some internal static caches for several types of object is being serialized, (see ObjectStreamClass) so subsequent serializations of objects of the same type are faster than the first one", "label": {"api": {"ObjectStreamClass": [[105, 121]]}}}, {"text": "This is because the File represents a abstract path, see the JavaDoc for it http://docs.oracle.com/javase/6/docs/api/java/io/File.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/io/File.html": [[76, 133]]}}}, {"text": "It's better to use a DefaultTableModel, or a TableModel that you extend, for a dynamic table", "label": {"api": {"DefaultTableModel": [[21, 37]]}}}, {"text": "You can use invokeAll which returns when all submitted tasks are done", "label": {"api": {"invokeAll": [[12, 20]]}}}, {"text": "Use Pattern.split() instead", "label": {"api": {"Pattern.split()": [[4, 18]]}}}, {"text": "You can use standard Java XMLEncoder and XMLDecoder classes", "label": {"api": {"XMLEncoder": [[26, 35]], "XMLDecoder": [[41, 50]]}}}, {"text": "Assemble the bytes into a long first, then use Double's static longBitsToDouble method", "label": {"api": {"Double's static longBitsToDouble": [[47, 78]]}}}, {"text": "You are missing the first argument, List<Inpatient> inpatientArrayListIn, exactly as the error message describes", "label": {"api": {"List": [[36, 39], [66, 69]]}}}, {"text": "Also, you are trying to use List as an array, as in", "label": {"api": {"List": [[28, 31]]}}}, {"text": "If we look at the documentation for List, the method you want is set(int index, E element), so the above would be", "label": {"api": {"List": [[36, 39]]}}}, {"text": "Have a look at the SwingWorker", "label": {"api": {"SwingWorker": [[19, 29]]}}}, {"text": "Learn to use the handy TimeUnit enum so you can do things like so", "label": {"api": {"TimeUnit": [[23, 30]]}}}, {"text": "I have to change the logging properties of the LogManager in the program", "label": {"api": {"LogManager": [[47, 56]]}}}, {"text": "I think you need to look into the ClassLoader API - you need to get an new URLClassLoader and ask it to load your .java file into the JVM", "label": {"api": {"URLClassLoader": [[75, 88]]}}}, {"text": "In particular, shutdown hooks are ran, and if configured, finalizers can actually be ran", "label": {"api": {"if configured": [[43, 55]]}}}, {"text": "mkdir relies on the parent directory already existing", "label": {"api": {"mkdir": [[0, 4]]}}}, {"text": "However, you can use mkdirs instead which creates all the intermediate directories as required", "label": {"api": {"mkdir": [[21, 25]], "mkdirs": [[21, 26]]}}}, {"text": "replaceAll takes a regular expressions as an argument, and", "label": {"api": {"replaceAll": [[0, 9]], "replace": [[0, 6]]}}}, {"text": "You can use replace instead", "label": {"api": {"replace": [[12, 18]]}}}, {"text": "The HttpServletResponse#encodeRedirectURL adds the JSESSIONID (url-rewriting) for a redirect request", "label": {"api": {"HttpServletResponse#encodeRedirectURL": [[4, 40]]}}}, {"text": "Currently I am using the JavaFX 2 Image class to load the image", "label": {"api": {"Image": [[34, 38]]}}}, {"text": "I noticed an incomprehensible thing for me in static method round() in class Math", "label": {"api": {"round()": [[60, 66]], "Math": [[77, 80]]}}}, {"text": "Use the JTextArea(int rows, int columns) constructor that specifies rows and columns, as shown here, and don't neglect to pack() the enclosing Window", "label": {"api": {"JTextArea(int rows, int columns)": [[8, 39]]}}}, {"text": "It's available the usual Properties API way", "label": {"api": {"Properties": [[25, 34]]}}}, {"text": "See, for example, java.util.concurrent.atomic.AtomicInteger", "label": {"api": {"java.util.concurrent.atomic.AtomicInteger": [[18, 58]]}}}, {"text": "ResultSet has getDate() methods that will return a Date object", "label": {"api": {"getDate() methods": [[14, 30]]}}}, {"text": "Read The tokenizer uses the default delimiter set, which is \" \\t\\n\\r\\f\"", "label": {"api": {"tokenizer": [[9, 17]]}}}, {"text": "You have to create a JFrame, and make it visible or use the java.util.Timer if you don't need windowing system at all", "label": {"api": {"java.util.Timer": [[60, 74]]}}}, {"text": "The following code shows how to use java.util.Timer", "label": {"api": {"java.util.Timer": [[36, 50]]}}}, {"text": "You can use the method Arrays.fill() to fill all fields in an array with a specific value", "label": {"api": {"Arrays.fill()": [[23, 35]]}}}, {"text": "But still in your current case, it seems you can get your results with the use of Pattern and Matcher class (Don't try to split, as it would be slightly more complex)", "label": {"api": {"Pattern": [[82, 88]], "Matcher": [[94, 100]], "split": [[122, 126]]}}}, {"text": "\"cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided.\" -http://docs.oracle.com/javase/6/docs/api/javax/crypto/Cipher.html#doFinal%28%29", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/crypto/Cipher.html#doFinal%28%29": [[261, 339]]}}}, {"text": "however, if you want a dynamic array, use a List implementing class like ArrayList which doesn't require you to provide size while creating the array", "label": {"api": {"ArrayList": [[73, 81]]}}}, {"text": "Exactly because of the predetermined constant I advise using List", "label": {"api": {"List": [[61, 64]]}}}, {"text": "While working with DecimalFormat, I was puzzled by its behavior when rounding numbers with fixed-point patterns", "label": {"api": {"DecimalFormat": [[19, 31]]}}}, {"text": "Despite this, DecimalFormat rounds the value upwards when provided with a double argument", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "I was unable to find any specification describing the proper behavior of DecimalFormat in this case", "label": {"api": {"DecimalFormat": [[73, 85]]}}}, {"text": "If you really do need to do this, you could use instrumentation to register the constructors of the classes that you're interested in which might reference Foo, and then keep a reference to the created objects somewhere", "label": {"api": {"instrumentation": [[48, 62]]}}}, {"text": "In Java, you could use a LinkedHashMap<Character,Integer> to count how many times each character appears in the string", "label": {"api": {"LinkedHashMap<Character,Integer>": [[25, 56]]}}}, {"text": "I suggest you to use System.getProperty( \"os.name\" ), System.getProperty( \"os.arch\" ) to identify the remote architecture", "label": {"api": {"System.getProperty( \"os.name\" )": [[21, 51]]}}}, {"text": "The default Charset may be useful too", "label": {"api": {"The default Charset": [[0, 18]]}}}, {"text": "As the javadoc of defaultCharset states", "label": {"api": {"javadoc of defaultCharset": [[7, 31]]}}}, {"text": "AspectJ), or directly with ASM 4 and the java.lang.instrument API", "label": {"api": {"java.lang.instrument API": [[41, 64]]}}}, {"text": "I guess the update might not be appropriate, cause DefaultTreeModel#nodeChanged(javax.swing.tree.TreeNode)  should work resp", "label": {"api": {"DefaultTreeModel#nodeChanged(javax.swing.tree.TreeNode) ": [[51, 106]]}}}, {"text": "notify wakes (any) one thread in the wait set, notifyAll wakes all threads in the waiting set", "label": {"api": {"notify": [[0, 5], [47, 52]], "notifyAll": [[47, 55]]}}}, {"text": "notifyAll should be used most of the time", "label": {"api": {"notify": [[0, 5]], "notifyAll": [[0, 8]]}}}, {"text": "If you are not sure which to use, then use notifyAll", "label": {"api": {"notify": [[43, 48]], "notifyAll": [[43, 51]]}}}, {"text": "In such a case you would use notifyAll() to wake up all waiting threads at the same time", "label": {"api": {"notify": [[29, 34]], "notifyAll": [[29, 37]]}}}, {"text": "In such a case, you would rather use notify()", "label": {"api": {"notify": [[37, 42]]}}}, {"text": "Properly implemented, you could use notifyAll() in this situation as well, but you would unnecessarily wake threads that can't do anything anyway", "label": {"api": {"notify": [[36, 41]], "notifyAll": [[36, 44]]}}}, {"text": "Javadocs on notify", "label": {"api": {"notify": [[12, 17]]}}}, {"text": "Javadocs on notifyAll", "label": {"api": {"notify": [[12, 17]], "notifyAll": [[12, 20]]}}}, {"text": "You might want to take a look at Java String Formatter it simply let you format a string in your string.xml but not changing the whole String , as other answers said, you can't change the value of a String in strings.xml from your java code", "label": {"api": {"Java String Formatter": [[33, 53]]}}}, {"text": "If it is a one-off event, you could use a CountDownLatch", "label": {"api": {"a CountDownLatch": [[40, 55]]}}}, {"text": "Since java.lang.UnsupportedClassVersionError is \"Thrown when the Java Virtual Machine attempts to read a class file and determines that the major and minor version numbers in the file are not supported.\", you ran into an issue of building the application with more recent version of Java than the one supported by the runtime environment, i.e", "label": {"api": {"java.lang.UnsupportedClassVersionError": [[6, 43]]}}}, {"text": "assert throws AssertionError which is not a subclass of Exception, but a subclass of Error", "label": {"api": {"AssertionError": [[14, 27]], "Exception": [[56, 64]], "Error": [[23, 27], [85, 89]]}}}, {"text": "The SwingWorker class also defines a done method where you can define what to do once your task finishes", "label": {"api": {"done": [[37, 40]]}}}, {"text": "PrintStream.println() explicitly makes a call to String.valueOf(), which in turn calls Object.toString(), which is overridden in your two objects", "label": {"api": {"PrintStream.println()": [[0, 20]], "String.valueOf()": [[49, 64]]}}}, {"text": "Date has a constructor that takes a long as parameter", "label": {"api": {"constructor": [[11, 21]]}}}, {"text": "It sounds like you're looking for ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[34, 51]]}}}, {"text": "Not sure what you're asking, but if you want to get an object from the queue and wait till the queue has an object to take, you can use BlockingQueue", "label": {"api": {"BlockingQueue": [[136, 148]]}}}, {"text": "I would suggest you take a look at split, trim and HashSet", "label": {"api": {"split": [[35, 39]], "trim": [[42, 45]], "HashSet": [[51, 57]]}}}, {"text": "Java also has a static factory method", "label": {"api": {"static factory method": [[16, 36]]}}}, {"text": "Once you have byte[] you can use ImageIO to write it to BufferedImage", "label": {"api": {"ImageIO": [[33, 39]]}}}, {"text": "If you want to inspect it from your program itself, use the methods of the Runtime class", "label": {"api": {"Runtime": [[75, 81]]}}}, {"text": "you can use Calendar class to do the same task", "label": {"api": {"Calendar": [[12, 19]]}}}, {"text": "Then get the file using getAsResourceStream and write stream to a temporary file", "label": {"api": {"getAsResourceStream": [[24, 42]]}}}, {"text": "For that responses, I have looked for CompletionService but I don't know how can I integrate it with Blocking queues for bi-directional communication", "label": {"api": {"Blocking queues": [[101, 115]]}}}, {"text": "What if you have a non-blocking queue in your event dispatcher thread, such as the ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[83, 103]]}}}, {"text": "The function is Thread.sleep(long)", "label": {"api": {"Thread.sleep(long)": [[16, 33]]}}}, {"text": "Using standard java.util.Arrays utility class", "label": {"api": {"java.util.Arrays": [[15, 30]]}}}, {"text": "The List interface has a toArray method that returns the generically-typed array, so you can useArrayList's implementation of that", "label": {"api": {"List interface": [[4, 17]], "useArrayList's implementation of that": [[93, 129]]}}}, {"text": "Here is the HashSet javadoc, I completed this because \"iterators are weird\", but good luck on the rest of your Project Euler", "label": {"api": {"HashSet javadoc": [[12, 26]]}}}, {"text": "BufferedInputStream is a decorator for input streams", "label": {"api": {"BufferedInputStream": [[0, 18]]}}}, {"text": "If you happen to know how BufferedInputStream is implemented, you could use reflection to examine the stream that it's decorating, but that doesn't help you in examining, say BufferedOutputStream", "label": {"api": {"BufferedInputStream": [[26, 44]]}}}, {"text": "This is the Readers-Writer pattern, you can directly in Java 5+ use the ReadersWriteLock.java possible implementations to achieve exactly that", "label": {"api": {"ReadersWriteLock.java": [[72, 92]]}}}, {"text": "This interface will be used in a dynamic proxy", "label": {"api": {"dynamic proxy": [[33, 45]]}}}, {"text": "String.matches in Java will check that the whole string matches against the regex (as if the regex has ^ at the beginning and $ at the end)", "label": {"api": {"String.matches": [[0, 13]]}}}, {"text": "You need Matcher to find some text inside a string that matches some regex", "label": {"api": {"Matcher": [[9, 15]]}}}, {"text": "JPA supports that natively using the setFirstResult() and setMaxResults() methods, which are translated to the appropriate limit clause in SQL", "label": {"api": {"setFirstResult()": [[37, 52]], "setMaxResults()": [[58, 72]]}}}, {"text": "You can make use of Math.abs() method here", "label": {"api": {"Math.abs()": [[20, 29]]}}}, {"text": "Using (?U) is equivalent to compiling the regex by calling Pattern.compile() with the UNICODE_CHARACTER_CLASS flag", "label": {"api": {"Pattern.compile()": [[59, 75]], "UNICODE_CHARACTER_CLASS": [[86, 108]]}}}, {"text": "Use Calendar#add(int field, int amount) method.You should use Calendar API in-order to manipulate date and time operations", "label": {"api": {"Calendar#add(int field, int amount)": [[4, 38]]}}}, {"text": "You have to use the ConcurrentHashMap.putIfAbsent(K key, V value) and pay attention to the return value, which tells you if the put operation was successful or not", "label": {"api": {"ConcurrentHashMap.putIfAbsent(K key, V value)": [[20, 64]]}}}, {"text": "Change HashSet for LinkedHashSet", "label": {"api": {"LinkedHashSet": [[19, 31]]}}}, {"text": "A simple way is to use java.util.Timer and java.util.TimerTask to set the timer for 5 min (or whatever duration of interest for you) and the timer task would get the process handle to kill it when the timer goes off and triggers the timer task", "label": {"api": {"java.util.Timer": [[23, 37], [43, 57]], "java.util.TimerTask": [[43, 61]]}}}, {"text": "method public static void sleep(long millis)", "label": {"api": {"public static void sleep(long millis)": [[7, 43]]}}}, {"text": "Alternatively you could use a BlockingQueue to transfer the data between threads", "label": {"api": {"BlockingQueue": [[30, 42]]}}}, {"text": "See BlockingQueue for details", "label": {"api": {"BlockingQueue": [[4, 16]]}}}, {"text": "This is a Java limitation", "label": {"api": {"limitation": [[15, 24]]}}}, {"text": "You may also want to read up on the new(ish) Lock class", "label": {"api": {"Lock": [[45, 48]]}}}, {"text": "Check BlockingQueue it does exactly what you need", "label": {"api": {"BlockingQueue": [[6, 18]]}}}, {"text": "You pass whatFind and queue to it and it takes new file from queue and checks it's content", "label": {"api": {"take": [[41, 44]]}}}, {"text": "If you want FileScan to wait until FolderScan adds something to the queue you can use take method", "label": {"api": {"take": [[86, 89]]}}}, {"text": "If data is not a readable string or is in single-byte encoding which is not \"platform's default charset\" java.lang.String(byte[]) constructor won't be able to make a readable string out of it", "label": {"api": {"java.lang.String(byte[]) constructor": [[105, 140]]}}}, {"text": "Arrays.copyOf(boolean[] original, int newLength) should help you", "label": {"api": {"Arrays.copyOf(boolean[] original, int newLength)": [[0, 47]]}}}, {"text": "NumberFormat.getInstance() is a static factory method, which can return an instance of a concrete subclass of the abstract NumberFormat class", "label": {"api": {"NumberFormat.getInstance()": [[0, 25]]}}}, {"text": "So you need to use a Servlet Filter to set the value at the start of a request and then delete it at the end, some like", "label": {"api": {"Filter": [[29, 34]]}}}, {"text": "Once you have a class that implements Filter you add it to your web.xml thus", "label": {"api": {"Filter": [[38, 43]]}}}, {"text": "I know there are wrapper methods like Collections#unmodifiableSet and its other variations like Collections#unmodifiableMap, Collections#unmodifiableList etc which makes the collection immutable provided that the client only accesses the collection through the reference returned by these methods and not directly", "label": {"api": {"Collections#unmodifiableSet": [[38, 64]], "Collections#unmodifiableMap": [[96, 122]], "Collections#unmodifiableList": [[125, 152]]}}}, {"text": "The ExecutorCompletionService has exactly this example in the javadoc", "label": {"api": {"ExecutorCompletionService": [[4, 28]]}}}, {"text": "Those records can either be stored in a HashMap or in a SQlite database", "label": {"api": {"HashMap": [[40, 46]]}}}, {"text": "This is doable with a custom ResourceHandler which returns in createResource() a Resource which in turn returns an \"unmapped\" URL on Resource#getRequestPath()", "label": {"api": {"ResourceHandler": [[29, 43]], "createResource()": [[62, 77]], "Resource": [[29, 36], [68, 75], [81, 88], [133, 140]], "Resource#getRequestPath()": [[133, 157]]}}}, {"text": "Further, you need to override isResourceRequest() to check if the URL starts with the JSF resource prefix and also the handleResourceRequest() to locate and stream the proper resource", "label": {"api": {"Resource": [[32, 39], [125, 132]], "isResourceRequest()": [[30, 48]], "handleResourceRequest()": [[119, 141]]}}}, {"text": "Extend the FacesServlet URL pattern with ResourceHandler.RESOURCE_IDENTIFIER", "label": {"api": {"ResourceHandler": [[41, 55]], "Resource": [[41, 48]]}}}, {"text": "Problem solved by using the Files.walkFileTree API", "label": {"api": {"Files.walkFileTree": [[28, 45]]}}}, {"text": "You can use a Handler subclass to process the data being logged", "label": {"api": {"Handler": [[14, 20]]}}}, {"text": "Then you can add it to your root logger via your config file or programmaticaly via the addHandler method of Logger class", "label": {"api": {"Handler": [[91, 97]]}}}, {"text": "For example you can create a Handler subclass FoobarHandler that print all logged data on the console prefixed with a \"Foobar \" text", "label": {"api": {"Handler": [[29, 35], [52, 58]]}}}, {"text": "myapp.FoobarHandler) of your Handler to the global handlers config", "label": {"api": {"Handler": [[12, 18], [29, 35]]}}}, {"text": "Use Java's built-in Random class to pick a random integer between 0 and the last index of your array", "label": {"api": {"Random": [[20, 25]]}}}, {"text": "All components supporting client behavior should implement ClientBehaviorHolder which in turn offers the addClientBehavior() method to add client behavior", "label": {"api": {"ClientBehaviorHolder": [[59, 78]], "addClientBehavior()": [[105, 123]]}}}, {"text": "A concrete client behavior implementation for ajax is the AjaxBehavior which in turn offers the addAjaxBehaviorListener() method which is exactly what you're looking for", "label": {"api": {"AjaxBehavior": [[58, 69], [99, 110]], "addAjaxBehaviorListener()": [[96, 120]]}}}, {"text": "A LinkedHashMap enables iterating over the keys (and therefore values) in insertion-order", "label": {"api": {"LinkedHashMap": [[2, 14]]}}}, {"text": "Conversely, a TreeMap lets you specify a sort order with a comparator, and ensures all items added to the map are stored in sorted order", "label": {"api": {"TreeMap": [[14, 20]]}}}, {"text": "Notice that it is a very thin wrapper around a LinkedHashMap, because that's all you need, a LinkedHashMap with extra checks to ensure Values remain unique", "label": {"api": {"LinkedHashMap": [[47, 59], [93, 105]]}}}, {"text": "You need to use StringTokenizer to extract out the exact information that you are looking for", "label": {"api": {"StringTokenizer": [[16, 30]]}}}, {"text": "I'm trying to find the definitive documentation on how to use a custom object as the key for HashMap or as the object stored in HashSet", "label": {"api": {"HashSet": [[128, 134]], "HashMap": [[93, 99]]}}}, {"text": "However, when I read the Oracle/Sun official Javadocs for HashSet and HashMap, they do not mention overriding these methods at all", "label": {"api": {"HashSet": [[58, 64]], "HashMap": [[70, 76]]}}}, {"text": "It's discussed at length in the contract for java.lang.Object", "label": {"api": {"java.lang.Object": [[45, 60]]}}}, {"text": "I'm looking for a java.util.Queue implementation or factory method that provides me with a Queue that silently discards null elements", "label": {"api": {"java.util.Queue": [[18, 32]]}}}, {"text": "java.util.LinkedList is not a solution, because it allows to queue null elements and to unqueue null elements (..", "label": {"api": {"java.util.LinkedList": [[0, 19]]}}}, {"text": "java.util.ArrayDeque is not a solution, because it throws NullPointerException when trying to add a null element", "label": {"api": {"java.util.ArrayDeque": [[0, 19]]}}}, {"text": "A better approach would be using a StringBuilder class, which lets you change the string without throwing away the whole thing", "label": {"api": {"StringBuilder": [[35, 47]]}}}, {"text": "You can read it in as a BigInteger and then return the correct int value", "label": {"api": {"BigInteger": [[24, 33]]}}}, {"text": "I am having a public API that I want to use and in this API there is a method that requires an InputEvent (because its commonly used)", "label": {"api": {"InputEvent": [[95, 104]]}}}, {"text": "I want to use this API from a code that is called via a socket connection and thus doesn't have a InputEvent", "label": {"api": {"InputEvent": [[98, 107]]}}}, {"text": "As far as I can tell I can not simply instantiate a InputEvent", "label": {"api": {"InputEvent": [[52, 61]]}}}, {"text": "Do I need to search another API that doesn't require a InputEvent", "label": {"api": {"InputEvent": [[55, 64]]}}}, {"text": "Use BigInteger, one of the constructors takes a radix", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "Have you tried the BigInteger constructor taking a string and a radix", "label": {"api": {"BigInteger constructor taking a string and a radix": [[19, 68]]}}}, {"text": "Alternatively, if by using a different identifier when calling Loader.load() you get back instances of different classes implementing the Validator interface, then you can use the Object.getClass() method to tell those classes apart", "label": {"api": {"Object.getClass()": [[180, 196]]}}}, {"text": "Store the size of the list and simply stop when you've reached this half this size (similar to what the standard API's LinkedList does)", "label": {"api": {"LinkedList": [[119, 128]]}}}, {"text": "The easier way to do that is to declare an implement a ServletContextListener, and shut down the schedler in the contextDestroyed() method", "label": {"api": {"ServletContextListener": [[55, 76]]}}}, {"text": "You can use the factory method INetAddress.getByName", "label": {"api": {"INetAddress.getByName": [[31, 51]]}}}, {"text": "This file contains a list of all classes in the jar implementing java.sql.Driver, so that the java.sqlDriverManager class can automatically load all Driver implementations using ServiceLoader", "label": {"api": {"ServiceLoader": [[178, 190]]}}}, {"text": "Use a cell factory for your cell", "label": {"api": {"cell factory": [[6, 17]]}}}, {"text": "From the factory return a TextField", "label": {"api": {"TextField": [[26, 34]]}}}, {"text": "Set the TextField to not editable", "label": {"api": {"TextField": [[8, 16]], "not editable": [[21, 32]]}}}, {"text": "Use the TextField's methods to select the text you want to highlight (might need a Platform.runLater method to do that and the field might need to be focused to allow to select the text)", "label": {"api": {"TextField": [[8, 16]], "select the text": [[31, 45], [170, 184]], "Platform.runLater": [[83, 99]]}}}, {"text": "Once the selection is complete (and really displayed), Disable mouse input and focus traversion on the TextField so that the user can't change the selection maybe also in a Platform.runLater", "label": {"api": {"TextField": [[103, 111]], "Platform.runLater": [[173, 189]], "Disable mouse input": [[55, 73]], "focus traversion": [[79, 94]]}}}, {"text": "For Java8, you can do the similar thing, but instead of a TextField, use a TextFlow and style the subtext in the text flow using css or Java APIs", "label": {"api": {"TextField": [[58, 66]]}}}, {"text": "If you just want to highlight all of the text in the cell, rather than some portion of it, then you can just use a standard Label plus css styling", "label": {"api": {"Label": [[124, 128]]}}}, {"text": "You just need to format it to String", "label": {"api": {"format": [[17, 22]]}}}, {"text": "formatter.format(date) should give you the desired result if the pattern in the SimpleDateFormat constructor is valid", "label": {"api": {"format": [[0, 5], [10, 15]]}}}, {"text": "Whatever your goal, it will be easier to scale the palette using Color.getHSBColor()", "label": {"api": {"Color.getHSBColor()": [[65, 83]]}}}, {"text": "See JTextComponent.write(Writer) for details", "label": {"api": {"JTextComponent.write(Writer)": [[4, 31]]}}}, {"text": "Why don't you use the method http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getMethod%28java.lang.String,%20java.lang.Class...%29 to directly get the method if available and let the JVM do the job efficiently for you", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getMethod%28java.lang.String,%20java.lang.Class...%29": [[29, 143]]}}}, {"text": "If you're using Java 7, you should be able to use the POSIX functionality to do this", "label": {"api": {"POSIX functionality": [[54, 72]]}}}, {"text": "You may use separate classloaders for loading different versions of the same class..", "label": {"api": {"classloaders": [[21, 32]]}}}, {"text": "but be warned that working with classloaders is a real pain", "label": {"api": {"classloaders": [[32, 43]]}}}, {"text": "You can add an KeyEvent EventHandler to any Node (in this case your WebView) with the Node.addEventHandler method, and if you handle the EventType KeyEvent.KEY_TYPED you can get the typed unicode characters with the KeyEvent.getCharacter method", "label": {"api": {"Node.addEventHandler": [[86, 105]], "KeyEvent.getCharacter": [[216, 236]]}}}, {"text": "You might want to take a look at the Collator class if you want to compare different strings ignoring locale, uppercase, lowercase, etc", "label": {"api": {"Collator": [[37, 44]]}}}, {"text": "You need to setAccesible(true) on that method", "label": {"api": {"setAccesible(true)": [[12, 29]]}}}, {"text": "Your integers are being boxed to Integers (i.e", "label": {"api": {"Integer": [[33, 39]]}}}, {"text": "Note that Integer implements Comparable", "label": {"api": {"Integer": [[10, 16]]}}}, {"text": "To convert a single character use the methods from the Character class", "label": {"api": {"Character": [[55, 63]]}}}, {"text": "Try using add(int index, E element)", "label": {"api": {"add(int index, E element)": [[10, 34]]}}}, {"text": "Recall that Graphics specifies the following", "label": {"api": {"Graphics": [[12, 19]]}}}, {"text": "If you connect a URLConnection to an https URL, it will either connect using HTTPS or produce an error as documented", "label": {"api": {"as documented": [[103, 115]]}}}, {"text": "The value returned by System.nanoTime() is specific to the running JVM", "label": {"api": {"System.nanoTime()": [[22, 38]]}}}, {"text": "Try using a Timestamp", "label": {"api": {"Timestamp": [[12, 20]]}}}, {"text": "Firstly you can research about Throwable class which is the superclass of all errors and exceptions in Java", "label": {"api": {"Throwable": [[31, 39]]}}}, {"text": "According to the Statement javadocs, the constant SUCCESS_NO_INFO is defined as -2", "label": {"api": {"Statement javadocs": [[17, 34]]}}}, {"text": "I don't know which database abstraction stuff you're using, but you should update it to use prepared statements", "label": {"api": {"prepared statements": [[92, 110]]}}}, {"text": "You probably are looking for the RandomAccessFile class", "label": {"api": {"RandomAccessFile": [[33, 48]]}}}, {"text": "The next step is to use FileChannel from NIO", "label": {"api": {"FileChannel": [[24, 34]]}}}, {"text": "Reference these formats Java Date Format Docs", "label": {"api": {"Java Date Format Docs": [[24, 44]]}}}, {"text": "If the text is displayed via JTextPane you can conveniently define a custom HighlightPainter, that draws lines above or under the text", "label": {"api": {"HighlightPainter": [[76, 91]]}}}, {"text": "I've just run into a piece of code that casts a List into a MultiKeyMap to call a method that takes a MultiKeyMap as argument", "label": {"api": {"a List": [[46, 51]]}}}, {"text": "Where myList is a List", "label": {"api": {"a List": [[16, 21]]}}}, {"text": "Java MimeMessage seems to require a Folder or Session for instantiation", "label": {"api": {"MimeMessage": [[5, 15]]}}}, {"text": "The HttpServletRequest#getQueryString() is per definition undecoded", "label": {"api": {"HttpServletRequest#getQueryString()": [[4, 38]]}}}, {"text": "I want to provide the corresponding builder (like the TranslateBuilder for the Translate transformation)", "label": {"api": {"TranslateBuilder": [[54, 69]]}}}, {"text": "As you can see in the TranslateBuilder javadoc, the builder class is annotated by @Generated(value=\"Generated by javafx.builder.processor.BuilderProcessor\")", "label": {"api": {"TranslateBuilder": [[22, 37]]}}}, {"text": "containsAll() expects a Collection and you are passing an array, thus your compiler complains", "label": {"api": {"containsAll()": [[0, 12]]}}}, {"text": "Matcher#matches auto-anchors the given pattern, which means first of all that \"^[\\\\s]+\" is exactly the same as \"[\\\\s]+\" for it", "label": {"api": {"Matcher#matches": [[0, 14]]}}}, {"text": "You can still use the contains method; A List uses the equals method to determine if the item exists in the list", "label": {"api": {"List": [[41, 44]]}}}, {"text": "Take a look at the javadoc for ThreadPoolExecutor for more details", "label": {"api": {"the javadoc for ThreadPoolExecutor": [[15, 48]]}}}, {"text": "Usually in java to implement Producer/Consumer pattern use java.util.concurrent.BlockingQueue", "label": {"api": {"java.util.concurrent.BlockingQueue": [[59, 92]]}}}, {"text": "You can then evaluate them at runtime with a ScriptEngine", "label": {"api": {"ScriptEngine": [[45, 56]]}}}, {"text": "doesn't compiled because format is not static method", "label": {"api": {"format": [[25, 30]]}}}, {"text": "According to the javadocs", "label": {"api": {"the javadocs": [[13, 24]]}}}, {"text": "TreeMap relies on the keys being sortable - not just equatable", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "Either you need to provide a Comparator<BitSet> to the TreeMap constructor, or use a different kind of map", "label": {"api": {"TreeMap": [[55, 61]]}}}, {"text": "You can then use Class.cast", "label": {"api": {"Class.cast": [[17, 26]]}}}, {"text": "JFreeChart might be a solution for bar or piecharts, but If you just need a simple stacked bar, I would indeed recommend overwriting a JLabel from the swing library", "label": {"api": {"JLabel": [[135, 140]]}}}, {"text": "I don't know the exact lookup times, but maybe you could use some implementation of the Map interface", "label": {"api": {"Map interface": [[88, 100]]}}}, {"text": "This is because Collection, which ArrayList implements, already declares a toArray() method", "label": {"api": {"Collection": [[16, 25]], "toArray()": [[75, 83]]}}}, {"text": "What about using a MappedByteBuffer", "label": {"api": {"MappedByteBuffer": [[19, 34]]}}}, {"text": "If the result of the long running task modifies a Swing component, you can use SwingWorker", "label": {"api": {"SwingWorker": [[79, 89]]}}}, {"text": "For more information, please see Worker Threads and SwingWorker", "label": {"api": {"SwingWorker": [[52, 62]]}}}, {"text": "I have a control and I need to find it's Accessible Name Property", "label": {"api": {"Accessible Name Property": [[41, 64]]}}}, {"text": "I'm betting you have a bad import for the Attributes class, should be org.xml.sax.Attributes", "label": {"api": {"org.xml.sax.Attributes": [[70, 91]]}}}, {"text": "When I start-up Tomcat, I get the above IllegalStateException because apparently there is already a Servlet mapped to / and I can only assume that is Tomcat's default Servlet", "label": {"api": {"apparently there is already a Servlet": [[70, 106]]}}}, {"text": "The javadocs for the UnsatisfiedLinkError are pretty straightforward", "label": {"api": {"UnsatisfiedLinkError": [[21, 40]]}}}, {"text": "Again, please get very familiar with the Java API as it will help prevent you from making these sorts of errors", "label": {"api": {"Java API": [[41, 48]]}}}, {"text": "The Concurrency util classes in Java are pretty well documented and in most cases give useful examples", "label": {"api": {"Concurrency util classes": [[4, 27]]}}}, {"text": "Try taking a look at Semaphores,Phasers, or A Count Down Latch for this", "label": {"api": {"Semaphores": [[21, 30]], "Phasers": [[32, 38]], "A Count Down Latch": [[44, 61]]}}}, {"text": "Though, in practice Executors or The Fork/Join Framework might be worth looking into a little more", "label": {"api": {"Executors": [[20, 28]]}}}, {"text": "The toGMTString() is deprecated, and you should instead use the DateFormat.format()-method", "label": {"api": {"toGMTString()": [[4, 16]], "DateFormat.format()": [[64, 82]]}}}, {"text": "Thus, since rollback() undoes any changes in the current transaction (as per the javadoc), it will effectively do nothing", "label": {"api": {"rollback()": [[12, 21]]}}}, {"text": "The proxy returned must be cast to an interface that is supported by the object, not the actual class of the original object, according to the javadocs for Proxy", "label": {"api": {"javadocs for Proxy": [[143, 160]]}}}, {"text": "Then you can just have the Principle injected into your method", "label": {"api": {"Principle": [[27, 35]]}}}, {"text": "The inherited setPressedIcon does not change the background Icon on the the JMenu (or indeed JMenuItem)", "label": {"api": {"setPressedIcon": [[14, 27]]}}}, {"text": "For the \"tee\" process, you should consider Apache Commons TeeOutputStream, and for conversion from output to input, you should probably look at PipedInputStream and PipedOutputStream", "label": {"api": {"PipedInputStream": [[144, 159]], "PipedOutputStream": [[165, 181]]}}}, {"text": "Why does Collection<E>.toArray() (non-parameterized method) return Object[]", "label": {"api": {"Collection<E>.toArray()": [[9, 31]]}}}, {"text": "go through StringBuilder and StringBuffer classes you will get your answer.", "label": {"api": {"StringBuilder": [[11, 23]], "StringBuffer": [[29, 40]]}}}, {"text": "BigInteger has an intValue method", "label": {"api": {"BigInteger": [[0, 9]], "intValue": [[18, 25]]}}}, {"text": "which converts BigInteger into an int primitive.arrays expect an int as its size while BigInteger is an object", "label": {"api": {"BigInteger": [[15, 24], [87, 96]]}}}, {"text": "Regarding images, they should be in the jar file, along with your .class files, and be loaded using Class.getResourceAsStream()", "label": {"api": {"Class.getResourceAsStream()": [[100, 126]]}}}, {"text": "Instead, use a List", "label": {"api": {"List": [[15, 18]]}}}, {"text": "If you need to worry about the behavior of libraries, you need to learn about and use a security policy and a SecurityManager", "label": {"api": {"SecurityManager": [[110, 124]]}}}, {"text": "One way to do this is to periodically poll each of the registered GarbageCollectionMXBean instances", "label": {"api": {"GarbageCollectionMXBean": [[66, 88]]}}}, {"text": "Prime the pump by recording the current system timestamp and the accumulated collection time so far by calling the MXBean's getCollectionTime() attribute/method", "label": {"api": {"getCollectionTime()": [[124, 142]]}}}, {"text": "ScheduledExecutorService tends to be more accurate than Swing's Timer, and it offers the benefit of running more than one thread", "label": {"api": {"ScheduledExecutorService": [[0, 23]]}}}, {"text": "Consider using setLocationByPlatform(boolean locationByPlatform)", "label": {"api": {"setLocationByPlatform(boolean locationByPlatform)": [[15, 63]]}}}, {"text": "have a look at Collections.sort()", "label": {"api": {"Collections.sort()": [[15, 32]]}}}, {"text": "You'll find this kind of pattern in ResultSet in the standard library, among other places", "label": {"api": {"ResultSet": [[36, 44]]}}}, {"text": "or with JDK 7", "label": {"api": {"JDK 7": [[8, 12]]}}}, {"text": "For example, you might dequeue an item and enqueue 0 for a right shift, and dequeue and enqueue 0 from the other end for a left shift", "label": {"api": {"dequeue": [[23, 29], [76, 82]]}}}, {"text": "You might first want to look up the queue data structure and then the double eneded queue data structure and finally implement the functions or even use an existing library to use the dequeue (stands for [d]ouble [e]nded queue) data structure", "label": {"api": {"dequeue": [[184, 190]]}}}, {"text": "You can use File.lastModified() to get the last modified time of a file/directory", "label": {"api": {"File.lastModified()": [[12, 30]]}}}, {"text": "See the Serializable contract", "label": {"api": {"Serializable contract": [[8, 28]]}}}, {"text": "I know literal strings are interned at compile time, but I don't get why it affects in the previous examples", "label": {"api": {"literal strings are interned at compile time": [[7, 50]]}}}, {"text": "An ExecutorService obtained from the Executors factory class would be a simple way of handling that", "label": {"api": {"ExecutorService": [[3, 17]], "Executors": [[37, 45]]}}}, {"text": "For instance, create an ExecutorService in your ServerClientThreadPool", "label": {"api": {"ExecutorService": [[24, 38]]}}}, {"text": "If you did need that, then it should also be a Runnable, not a Thread, and also be submitted to an ExecutorService", "label": {"api": {"ExecutorService": [[99, 113]]}}}, {"text": "Based on the apparent confusion in your code about how threading works, I'd suggest you revisit the Java \"Concurrency\" tutorial, which includes a section on Executors", "label": {"api": {"Executors": [[157, 165]]}}}, {"text": "All of the functions I have used are either on Math or Graphics2D", "label": {"api": {"Math": [[47, 50]], "Graphics2D": [[55, 64]]}}}, {"text": "Your approach is fine, but you should either use a ConcurrentMap, or synchronize on the map", "label": {"api": {"ConcurrentMap": [[51, 63]]}}}, {"text": "The first approach is better since synchronized collections are optimized in order to avoid blocking whenever it is possible", "label": {"api": {"optimized in order to avoid blocking": [[64, 99]]}}}, {"text": "FileInputStream.read() returns -1 when there are no more characters to read", "label": {"api": {"FileInputStream.read()": [[0, 21]]}}}, {"text": "Look into Arrays in the API to understand what's going on here", "label": {"api": {"Arrays": [[10, 15]]}}}, {"text": "1) One-line O(n logn) solution which utilizes Java 8 CharSequence.codePoints() stream", "label": {"api": {"CharSequence.codePoints()": [[53, 77]]}}}, {"text": "Take a look at the documentation of Object.hashCode() method and Set interface", "label": {"api": {"Object.hashCode()": [[36, 52]], "Set": [[65, 67]]}}}, {"text": "Using TreeSet< Comparable >", "label": {"api": {"Set": [[10, 12]], "TreeSet": [[6, 12]], "Comparable": [[15, 24]]}}}, {"text": "Using TreeSet< T >(comparator)", "label": {"api": {"Set": [[10, 12]], "TreeSet": [[6, 12]], "comparator": [[19, 28]]}}}, {"text": "You must use equals() on Strings", "label": {"api": {"equals() on Strings": [[13, 31]], "equals()": [[13, 20]]}}}, {"text": "Not only the JSTL code has to be converted to java source code and then compiled (which wouldn't affect runtime performance) but also there is a small overhead because of the creation of Tag instances and access to the request attributes (which are local variables in a plain Java loop)", "label": {"api": {"Tag": [[187, 189]]}}}, {"text": "You should be able to create 1 file channel per thread, and use that at offsets through the file", "label": {"api": {"file channel": [[31, 42]]}}}, {"text": "From a file channel you can get the file's size to work out your splits and set its current location", "label": {"api": {"file channel": [[7, 18]]}}}, {"text": "Obviously, if you need to use the value as a double later on, you need to convert the string to a double, for example by calling the valueOf method", "label": {"api": {"valueOf": [[133, 139]]}}}, {"text": "You can use java.text.Normalizer", "label": {"api": {"java.text.Normalizer": [[12, 31]]}}}, {"text": "Use a ProcessBuilder for better working with external processes", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "You can extract the extension checks into some helper method using class FileNameFilter", "label": {"api": {"FileNameFilter": [[73, 86]]}}}, {"text": "If you're using JPA annotations, use TypedQuery instead of Query", "label": {"api": {"TypedQuery": [[37, 46]]}}}, {"text": "The Preferences API with user preferences; most recently edited files, per file maybe timestamp + cursor position, GUI settings", "label": {"api": {"Preferences": [[4, 14]]}}}, {"text": "Myself, I always use ActionListener as swing event-handler (e.g", "label": {"api": {"ActionListener": [[21, 34]], "Action": [[21, 26]]}}}, {"text": "However, Some Swing professionals here in stackoverflow often advise to use Action rather than ActionListener", "label": {"api": {"ActionListener": [[95, 108]], "Action": [[76, 81], [95, 100]]}}}, {"text": "Executor just executes stuff you give it", "label": {"api": {"Executor": [[0, 7]]}}}, {"text": "ExecutorService adds startup, shutdown, and the ability to wait for and look at the status of jobs you've submitted for execution on top of Executor (which it extends)", "label": {"api": {"Executor": [[0, 7], [140, 147]], "ExecutorService": [[0, 14]]}}}, {"text": "Look at java.lang.System.getProperties and use \"user.dir\" i.e", "label": {"api": {"java.lang.System.getProperties": [[8, 37]]}}}, {"text": "Using @Guillaume's approach, java.awt.image.RescaleOp can be used to change the colors of an image dynamically", "label": {"api": {"java.awt.image.RescaleOp": [[29, 52]]}}}, {"text": "Usually, when implementing a cache that has the potential to be large, you want to use SoftReferences", "label": {"api": {"SoftReference": [[87, 99]]}}}, {"text": "A SoftReference holds an object but will allow that object to be garbage collected if memory becomes tight", "label": {"api": {"SoftReference": [[2, 14]]}}}, {"text": "If the object does get garbage collected, SoftReference.get() returns null", "label": {"api": {"SoftReference": [[42, 54]]}}}, {"text": "See ImageIcon, Image and BufferedImage", "label": {"api": {"ImageIcon": [[4, 12]], "Image": [[4, 8], [15, 19], [33, 37]], "BufferedImage": [[25, 37]]}}}, {"text": "So the annotation is (drumroll...) @JoinTable", "label": {"api": {"@JoinTable": [[35, 44]]}}}, {"text": "Or to replace it with an AtomicLong", "label": {"api": {"AtomicLong": [[25, 34]]}}}, {"text": "Check out the javadoc for Class and Method", "label": {"api": {"Class": [[26, 30]], "Method": [[36, 41]]}}}, {"text": "Since you really want to check assignability of the corresponding raw types, you could just use TypeToken.getRawType and then use Class.isAssignableFrom", "label": {"api": {"Class.isAssignableFrom": [[130, 151]]}}}, {"text": "with a BufferedReader), and increment the character count on each character, and the newline count on each newline character", "label": {"api": {"BufferedReader": [[7, 20]]}}}, {"text": "Is there something I can use to parse JavaDoc, such that I can operate on it through the standard Doclet interfaces at runtime", "label": {"api": {"Doclet": [[98, 103]]}}}, {"text": "Essentially, the reverse operation of a Doclet", "label": {"api": {"Doclet": [[40, 45]]}}}, {"text": "I understand that it would be impossible to write a parser for every Javadoc (since this can be an arbitrary documentation format), but I'd be curious to know if there was something like that for the Standard Doclet", "label": {"api": {"Doclet": [[209, 214]]}}}, {"text": "BigInteger.probablePrime(160, new Random()) generates a BigInteger that is almost certainly prime -- the probability that it is not a prime is less than the probability that you will get struck by lightning", "label": {"api": {"BigInteger.probablePrime(160, new Random())": [[0, 42]]}}}, {"text": "Main problem does not exist - Criteria API do have SubQuery", "label": {"api": {"SubQuery": [[51, 58]], "not": [[18, 20]], "in": [[2, 3]]}}}, {"text": "Query itself selects instances of User and uses not in construct to limit results based to subquery", "label": {"api": {"not": [[48, 50]], "in": [[21, 22], [52, 53]]}}}, {"text": "NullPointerException occures, when you use null somewhere, where you should use an object", "label": {"api": {"NullPointerException": [[0, 19]]}}}, {"text": "If this window is a subclass of java.awt.Window you can call setVisible to hide it", "label": {"api": {"java.awt.Window": [[32, 46]], "setVisible": [[61, 70]]}}}, {"text": "JFileChooser's getSelectedFile() method, returns a File object", "label": {"api": {"File": [[1, 4], [26, 29], [51, 54]]}}}, {"text": "check out the Arrays API you can do it with the Arrays.copyOf(..) method", "label": {"api": {"Arrays": [[14, 19], [48, 53]]}}}, {"text": "All you will need to do is define the equals(Object) and the hashCode() methods", "label": {"api": {"equals(Object)": [[38, 51]], "hashCode()": [[61, 70]]}}}, {"text": "lastly it sounds like the set object would also work and be exactly what you would want to use", "label": {"api": {"set": [[26, 28]]}}}, {"text": "You're going to need to look at either the context or bindings property of your jsEngine instance", "label": {"api": {"context": [[43, 49]], "bindings": [[54, 61]]}}}, {"text": "A quick comparison of javax.persistence.Persistence between Java EE 5 and Java EE 6 plainly shows that the getPersistenceUtil() method was added in 6", "label": {"api": {"Java EE 5": [[60, 68]], "Java EE 6": [[74, 82]]}}}, {"text": "If you're stuck with a Java EE 5 server/library, then you'll have to use an appropriate version of Hibernate or whatever Hibernate jar is looking for that method", "label": {"api": {"Java EE 5": [[23, 31]]}}}, {"text": "You can use System.out.printf to format your output like this", "label": {"api": {"System.out.printf": [[12, 28]]}}}, {"text": "You can use Java's buit-in System.out.printf() and take a look at the Formatter class", "label": {"api": {"Formatter": [[70, 78]]}}}, {"text": "There is a method to truncate the file (setLength) but there is not API to remove an arbitrary sequence from inside", "label": {"api": {"setLength": [[40, 48]]}}}, {"text": "It would have properties such as score, name, etc and then, you would make your Player class implement the Comparable interface so that you can specify how will the object be sorted", "label": {"api": {"Comparable": [[107, 116]]}}}, {"text": "Once you have that, you could create a List of players and use Collections.sort() to sort your Player objects", "label": {"api": {"Collections.sort()": [[63, 80]]}}}, {"text": "HashMap lookup the item bucked given its hashCode then test the inserted object and the stored ones by using equals (this is one of the reasons for requiring that a.equals(b) iff b.equals(a))", "label": {"api": {"HashMap": [[0, 6]], "hashCode": [[41, 48]]}}}, {"text": "TreeMap, on the other hand, relies on the result of the compareTo method (if the element implements Comparable or the compare method implemented by a Comparator)", "label": {"api": {"Comparable": [[100, 109]], "Comparator": [[150, 159]]}}}, {"text": "There is Double with to doubleToLongBits and doubleToLongRawBits", "label": {"api": {"Double": [[9, 14]]}}}, {"text": "The recommended practice for correct locking with exceptions in Java is the following", "label": {"api": {"recommended practice": [[4, 23]]}}}, {"text": "I'm not sure what are you trying to achieve here, but JoinTable is usually used to resolve ManyToMany relations with intermediary table", "label": {"api": {"JoinTable": [[54, 62]]}}}, {"text": "So it works the API", "label": {"api": {"API": [[16, 18]]}}}, {"text": "From the Calendar#set docs", "label": {"api": {"Calendar#set docs": [[9, 25]]}}}, {"text": "using SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "Use Arrays.toString(byte[]) to perform a more useful conversion", "label": {"api": {"Arrays.toString(byte[])": [[4, 26]]}}}, {"text": "Anyway have a look at the ArrayList Javadoc", "label": {"api": {"ArrayList Javadoc": [[26, 42]]}}}, {"text": "ThreadPoolExecutor, so you don't have the overhead of creating, destroying and recreating threads", "label": {"api": {"ThreadPoolExecutor": [[0, 17]]}}}, {"text": "JFileChooser actually extends JComponent, so you can use like any other component", "label": {"api": {"JFileChooser": [[0, 11]]}}}, {"text": "I've tried setting the type in the Client request to both \"application/x-java-serialized-object\" and MediaType.APPLICATION_OCTET_STREAM_TYPE, and it just gives the usual", "label": {"api": {"\"application/x-java-serialized-object\"": [[58, 95]]}}}, {"text": "Consider also using CardLayout#next for navigation", "label": {"api": {"CardLayout#next": [[20, 34]]}}}, {"text": "How can I format a time to appear in a JFormattedTextField in the format hh:mm, with no AM or PM after it and a proceeding 0 in the case of a single digit hour (e.g", "label": {"api": {"JFormattedTextField": [[39, 57]]}}}, {"text": "Please see Java Patterns for more details", "label": {"api": {"Patterns": [[16, 23]]}}}, {"text": "When you inherit from Observable, your class inherits all of its functionality", "label": {"api": {"Observable": [[22, 31]]}}}, {"text": "Try removing all the methods you've overridden from the Observable class", "label": {"api": {"Observable": [[56, 65]]}}}, {"text": "The URL class pretty much does this, look at the tutorial", "label": {"api": {"URL": [[4, 6]]}}}, {"text": "For example, given this URL", "label": {"api": {"URL": [[24, 26]]}}}, {"text": "You can use a PropertyChangeListener to ensure that updates in one container are propagated to another, as shown here and here", "label": {"api": {"PropertyChangeListener": [[14, 35]]}}}, {"text": "I think the best way to implement this is using a Timer and a MouseListener (as Chris Cooney mentioned)", "label": {"api": {"Timer": [[50, 54]]}}}, {"text": "Once the Timer's event activates your listener - you can turn off the boolean flag and get the actual count of clicks", "label": {"api": {"Timer": [[9, 13]]}}}, {"text": "Use RandomAccessFile class and its seek method, but write on top doesn't insert lines but overwrites them", "label": {"api": {"RandomAccessFile": [[4, 19]], "seek": [[35, 38]]}}}, {"text": "You can use Process created with ProcessBuilder.start() method and use its input and output streams", "label": {"api": {"Process": [[12, 18], [33, 39]], "ProcessBuilder.start()": [[33, 54]]}}}, {"text": "The String.indexOf(string) method returns the start index of a string (in the example, \"<html>\" and \"</html>\") in the given string (the variable html)", "label": {"api": {"String.indexOf(string)": [[4, 25]]}}}, {"text": "The String.substring(int, int) method returns the string between 2 indexes", "label": {"api": {"String.substring(int, int)": [[4, 29]]}}}, {"text": "If ordinary coding, you may be in need of atomics or perhaps synchronization", "label": {"api": {"atomics": [[42, 48]]}}}, {"text": "You can use the Arrays.sort() method in Java", "label": {"api": {"Arrays.sort() method": [[16, 35]]}}}, {"text": "Make the object implement the Comparable interface, which means writing a compare method", "label": {"api": {"Comparable": [[30, 39]]}}}, {"text": "An API similar to the string constructor that takes a byte[] strikes me as ideal", "label": {"api": {"string constructor that takes a byte[]": [[22, 59]]}}}, {"text": "I the next best thing I've found so far is to project the byte buffer as a CharBuffer and call toString()", "label": {"api": {"toString()": [[95, 104]]}}}, {"text": "What about CharsetDecoder.decode and calling toString on the returned CharBuffer", "label": {"api": {"CharsetDecoder.decode": [[11, 31]], "toString": [[45, 52]], "CharBuffer": [[70, 79]]}}}, {"text": "To have such guarantee, you must use some sort of \"thread synchronization\" mechanism, such as a Semaphore, in a way that the thread calling \"a.halt()\" signals the \"a\" thread to stops the \"while\" loop and stops (inside halt) until the \"while\" loop effectively ends and \"release\" the semaphore (so the calling thread continues its execution)", "label": {"api": {"Semaphore": [[96, 104]]}}}, {"text": "Also, see ResultSetMetaData", "label": {"api": {"ResultSetMetaData": [[10, 26]]}}}, {"text": "Format strings for method printf of a java.io.PrintStream such as System.out are defined as Java format strings", "label": {"api": {"printf": [[26, 31]], "Java format strings": [[92, 110]]}}}, {"text": "Create a custom cellfactory for your ListView and have it generate cells containing a FlowPane with different Text instances, each with different styles", "label": {"api": {"cellfactory": [[16, 26]], "ListView": [[37, 44]], "FlowPane": [[86, 93]], "Text": [[110, 113]]}}}, {"text": "In Java 8 you can you can use the TextFlow to style your text rather than a combination of different Text instances in a FlowPane", "label": {"api": {"FlowPane": [[121, 128]], "Text": [[34, 37], [101, 104]], "TextFlow": [[34, 41]]}}}, {"text": "The operation remove(Object o) is defined as removing an element e such that (o==null", "label": {"api": {"defined": [[34, 40]]}}}, {"text": "remove is defined in terms of equals)", "label": {"api": {"defined": [[10, 16]]}}}, {"text": "For instance, PrintStream defines print(Object) and print(String) if the rule of the most specific type were not enforced, print(\"bar\") could invoke print(Object) instead of print(String), which would be counterintuitive", "label": {"api": {"PrintStream": [[14, 24]]}}}, {"text": "I think Swing Workers done() method might be more what you want, and its executed on EDT", "label": {"api": {"done()": [[22, 27]]}}}, {"text": "Your problem is a general design problem when using ThreadPoolExecutor for tasks with dependencies", "label": {"api": {"ThreadPoolExecutor": [[52, 69]]}}}, {"text": "2) Use the \"direct handoff\" strategy (See ThreadPoolExecutor documentation)", "label": {"api": {"ThreadPoolExecutor": [[42, 59]]}}}, {"text": "One is to use a regular expression", "label": {"api": {"regular expression": [[16, 33]]}}}, {"text": "The regular expression is a more general solution (and a bit trickier to use, especially for novices), but the ContainsAny() method is also sufficient in this case", "label": {"api": {"regular expression": [[4, 21]]}}}, {"text": "I then went to the Java 7 SE Charset API doc and was surprised only to see a getEncoding() method but no respective setter", "label": {"api": {"Java 7 SE Charset API doc": [[19, 43]]}}}, {"text": "BufferedReader.readLine can throw an IOException in case an I/O error occurs", "label": {"api": {"BufferedReader.readLine": [[0, 22]]}}}, {"text": "You can use ExecutorService.It is extended from  Executor which provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.It is a very simple for using in a situation like you described Inter Thread Communication", "label": {"api": {"ExecutorService": [[12, 26]], "Executor": [[12, 19], [49, 56]]}}}, {"text": "I'd suggest using TreeMap, having the index as key and the delimiter as value", "label": {"api": {"TreeMap": [[18, 24]]}}}, {"text": "You could take a look at Joda time, you could also try to convert the String into a Calendar object and use the before or after methods as needed.", "label": {"api": {"Calendar": [[84, 91]]}}}, {"text": "For more help please read the Javadoc for the DateFormat and Calendar classes", "label": {"api": {"DateFormat": [[46, 55]], "Calendar": [[61, 68]]}}}, {"text": "Does it mention ConcurrentModificationException anywhere", "label": {"api": {"ConcurrentModificationException": [[16, 46]]}}}, {"text": "Now, read the JavaDoc for ConcurrentModificationException, and note the following (emphasis added)", "label": {"api": {"ConcurrentModificationException": [[26, 56]]}}}, {"text": "If you want to stick with this approach though, I think you need to override using @AttributeOverride both the property and the method like this in the subclass", "label": {"api": {"@AttributeOverride": [[83, 100]]}}}, {"text": "You could use marks in the input stream, if supported", "label": {"api": {"marks": [[14, 18]]}}}, {"text": "If you don't need the CRC value before processing the file, you could also make a subclass of FilteredInputStream that passes everything it reads to a CRC32, with some bonus methods for getting the CRC value", "label": {"api": {"FilteredInputStream": [[94, 112]]}}}, {"text": "Use CheckedInputStream to compute the CRC while reading a stream", "label": {"api": {"CheckedInputStream": [[4, 21]]}}}, {"text": "After you've found the first index, use the overloaded version of indexOf that receives the start index as a second parameter", "label": {"api": {"indexOf": [[66, 72]]}}}, {"text": "public int indexOf(int ch, int fromIndex) Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index", "label": {"api": {"indexOf": [[11, 17]]}}}, {"text": "Keep doing that until indexOf returns -1, indicating that there are no more matches to be found", "label": {"api": {"indexOf": [[22, 28]]}}}, {"text": "Here's a more-or-less complete example using SwingWorker (there may be a few try/catch blocks I've forgotten)", "label": {"api": {"SwingWorker": [[45, 55]]}}}, {"text": "As long as execShellCmd and stopProcess are only called from the event dispatch thread then no synchronization is necessary, as all accesses to the runningProcess field happen on the same thread (the point of SwingWorker is that doInBackground happens on a worker thread but done is run on the EDT)", "label": {"api": {"SwingWorker": [[209, 219]]}}}, {"text": "If a sequence of byte represents a String in certain encoding, then you can always pick those bytes out and use String(byte[] bytes, Charset charset) constructor to get back the String", "label": {"api": {"String(byte[] bytes, Charset charset)": [[112, 148]]}}}, {"text": "As per the JavaDocs, the default capacity is 11, so you could specify that for analogous behavior to the no-arg PriorityQueue constructor", "label": {"api": {"the default capacity is 11": [[21, 46]]}}}, {"text": "Look into the CharsetEncoder and CharsetDecoder classes to see how Java handles encoding/decoding", "label": {"api": {"CharsetEncoder": [[14, 27]], "CharsetDecoder": [[33, 46]]}}}, {"text": "If you don't know how many rows your query is returning, then you should use an ArrayList and its add method, which will grow past an initial size if necessary", "label": {"api": {"ArrayList": [[80, 88]]}}}, {"text": "When you write .class after a class name, it references the Class object that represents the given class (formally, it is a named class literal)", "label": {"api": {"Class": [[60, 64]]}}}, {"text": "The the type of NombreClase.class is Class<NombreClase>", "label": {"api": {"Class": [[37, 41]]}}}, {"text": "It is the same object that is returned by the getClass() method of any (direct) instance of NombreClase", "label": {"api": {"Class": [[49, 53]]}}}, {"text": "There is AccessDeniedException, but that extends IOException and is therefore a checked exception and strictly related to file access", "label": {"api": {"AccessDeniedException": [[9, 29]]}}}, {"text": "Each exception class serves a purpose, and in this case SecurityException is the class of exceptions thrown by the SecurityManager (which is part of the JRE), and AccessControlException is a sub type of SecurityException", "label": {"api": {"SecurityManager": [[115, 129]]}}}, {"text": "I think it is not correct (even though the name is pretty) to throw a SecurityException when the real cause was that an application-defined permission was not granted (as opposed to permissions enforced by the SecurityManager)", "label": {"api": {"SecurityManager": [[210, 224]]}}}, {"text": "One of the ways is with DecimalFormat in java.text", "label": {"api": {"DecimalFormat": [[24, 36]]}}}, {"text": "Here's more about the flags for printf", "label": {"api": {"more about the flags for printf": [[7, 37]]}}}, {"text": "Check out the Javadocs for the Rectangle class", "label": {"api": {"the Javadocs for the Rectangle class": [[10, 45]]}}}, {"text": "I'd like a DelayQueue of scheduled Runnables, where each Runnables should only be run after a certain point in time, specified beforehand", "label": {"api": {"DelayQueue": [[11, 20]]}}}, {"text": "Why is there no good default implementation of Delayed, that is also Runnable, for this", "label": {"api": {"Delayed": [[47, 53]]}}}, {"text": "The only subinterface of Delayed that seems reasonable is RunnableScheduledFuture, which has a whole bunch of random things that need to be implemented", "label": {"api": {"Delayed": [[25, 31]], "RunnableScheduledFuture": [[58, 80]]}}}, {"text": "Scanner.next() uses delimiters to tokenize input strings", "label": {"api": {"Scanner.next()": [[0, 13]]}}}, {"text": "If you don't set a delimiter using the Scanner.useDelimiter, the default is whitespace", "label": {"api": {"Scanner.useDelimiter": [[39, 58]]}}}, {"text": "Calendar.WEEK_OF_YEAR is a constant to be used to specify which field to return from your Calendar instance", "label": {"api": {"Calendar.WEEK_OF_YEAR": [[0, 20]]}}}, {"text": "http://docs.oracle.com/javase/7/dofucs/api/ that uses the switch statement", "label": {"api": {"http://docs.oracle.com/javase/7/dofucs/api/": [[0, 42]]}}}, {"text": "You can execute your batch using ProcessBuilder, as shown here", "label": {"api": {"ProcessBuilder": [[33, 46]]}}}, {"text": "As mentioned by TheWhiteRabbit, you can use reflection starting from the java.lang.Class class or maybe you are looking for a code parser such as antlr", "label": {"api": {"java.lang.Class": [[73, 87]]}}}, {"text": "Refer this http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html for more details regarding converting date from one format to another", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html": [[11, 82]]}}}, {"text": "You should also consider using Class.getMethods which only returns public methods anyway - but returns ones inherited from superclasses", "label": {"api": {"Class.getMethods": [[31, 46]]}}}, {"text": "It seems to me that MappedByteBuffer.isLoaded() consistently returns false on Windows", "label": {"api": {"MappedByteBuffer.isLoaded()": [[20, 46]]}}}, {"text": "You could call .connect() to actually \"Open[s] a communications link\"", "label": {"api": {".connect()": [[15, 24]]}}}, {"text": "connection.getInputStream() returns an input stream that reads from this open connection", "label": {"api": {"connection.getInputStream()": [[0, 26]]}}}, {"text": "So in Java 7 forward, the warning appears on the method itself (in your case, onException) and can be suppressed by using the @SafeVarargs annotation on the method", "label": {"api": {"@SafeVarargs": [[126, 137]]}}}, {"text": "You can in principle convert between channels and InputStream/OutputStreams using the Channels class, but there's also quite a lot to do in terms of using the SSLEngine itself", "label": {"api": {"Channels": [[86, 93]]}}}, {"text": "You should set a custom Composite for your Graphics2D, specifically AlphaComposite.Clear before drawing the rectangle", "label": {"api": {"set a custom Composite for your Graphics2D": [[11, 52]], "AlphaComposite.Clear": [[68, 87]]}}}, {"text": "As this reeks of homework, just see the documentation of Character, which had that nice function isDigit", "label": {"api": {"documentation of Character": [[40, 65]]}}}, {"text": "Try getEntries() and look up your custom attribute there", "label": {"api": {"getEntries()": [[4, 15]]}}}, {"text": "List#remove(index) returns the Object removed from the list", "label": {"api": {"List#remove(index)": [[0, 17]]}}}, {"text": "List#remove(Object) returns a boolean", "label": {"api": {"List#remove(Object)": [[0, 18]]}}}, {"text": "Use the synchronized collections if you can", "label": {"api": {"synchronized collections": [[8, 31]]}}}, {"text": "Use getFontMetrics() to find out how much space the string will take up, and then draw character by character, adding the required extra space", "label": {"api": {"getFontMetrics()": [[4, 19]]}}}, {"text": "The contract for ListIterator.add(Object) specifies that a subsequent call to next would be unaffected, and a subsequent call to previous would return the new element, that is the purpose of updating previous in the implementation of add", "label": {"api": {"ListIterator.add(Object)": [[17, 40]]}}}, {"text": "You could use System.arraycopy() to efficiently shift the elements", "label": {"api": {"System.arraycopy()": [[14, 31]]}}}, {"text": "Well if you've already got a thread reference, you can just use Thread.getState()", "label": {"api": {"Thread.getState()": [[64, 80]]}}}, {"text": "I don't have the Java lib sources handy now, but it would be interesting to look into how Socket.connect(SocketAddress endpoint,int timeout) is implemented internally - but I believe it's using select() inside, too", "label": {"api": {"Socket.connect(SocketAddress endpoint,int timeout)": [[90, 139]]}}}, {"text": "Briefly, you will need to implement a FocusTraversalPolicy subclass, and make your container use it by calling setFocusTraversalPolicy", "label": {"api": {"FocusTraversalPolicy": [[38, 57], [114, 133]], "setFocusTraversalPolicy": [[111, 133]]}}}, {"text": "The Javadoc for Vector.add(int, Object) pretty clearly states that an IndexOutOfBoundsException will be thrown if the index is less than zero or greater than or equal to the size", "label": {"api": {"Vector.add(int, Object)": [[16, 38]]}}}, {"text": "I've recently read about Java's Observable class", "label": {"api": {"Observable": [[32, 41]]}}}, {"text": "In a long treatment you may call several times setChanged() but at end, only once notifyObservers()", "label": {"api": {"setChanged()": [[47, 58]], "notifyObservers()": [[82, 98]]}}}, {"text": "If, before end, for internal reason you decide to rollback you may choose to call clearChanged()", "label": {"api": {"clearChanged()": [[82, 95]]}}}, {"text": "In the later case, notifyObservers() has no effect", "label": {"api": {"notifyObservers()": [[19, 35]]}}}, {"text": "Look at Arrays.asList", "label": {"api": {"Arrays.asList": [[8, 20]]}}}, {"text": "At a glance, it looks like you want to call getGenericSuperclass() instead of getGenericInterfaces()", "label": {"api": {"getGenericSuperclass()": [[44, 65]]}}}, {"text": "You may want to use Arrays.toString() for nicer looking output instead", "label": {"api": {"Arrays.toString()": [[20, 36]]}}}, {"text": "or use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[7, 23]], "toString()": [[14, 23]]}}}, {"text": "array is an object, hence you are calling println(Object) of PrintStream (System.out), which calls toString() on the passed object internally", "label": {"api": {"println(Object)": [[42, 56]], "PrintStream": [[61, 71]], "Object": [[50, 55]], "toString()": [[99, 108]]}}}, {"text": "The array's toString() is similar to Object's toString()", "label": {"api": {"Object": [[37, 42]], "toString()": [[12, 21], [46, 55]]}}}, {"text": "756a7c99 is the value returned from hashCode() as a hex number", "label": {"api": {"hashCode()": [[36, 45]]}}}, {"text": "Read also Class.getName() JavaDoc", "label": {"api": {"Class.getName() JavaDoc": [[10, 32]]}}}, {"text": "I dont think isEqual and hashCode are what you are looking for here necessarily, implementing the Comparable interface might be better suited", "label": {"api": {"Comparable": [[98, 107]]}}}, {"text": "It sounds like a LinkedList<E> would be entirely sufficient", "label": {"api": {"LinkedList<E>": [[17, 29]]}}}, {"text": "List#toArray() returns an Object array", "label": {"api": {"List#toArray()": [[0, 13]]}}}, {"text": "Use List#toArray(T[]) instead", "label": {"api": {"List#toArray(T[])": [[4, 20]]}}}, {"text": "Using Calendar API", "label": {"api": {"Calendar API": [[6, 17]]}}}, {"text": "Use Calendar object", "label": {"api": {"Calendar": [[4, 11]]}}}, {"text": "You'd have to get a String out of the Scanner before trying to split() it", "label": {"api": {"String": [[20, 25]], "Scanner": [[38, 44]], "split()": [[63, 69]]}}}, {"text": "You're probably looking for Scanner.next() or Scanner.nextLine()", "label": {"api": {"Scanner": [[28, 34], [46, 52]], "Scanner.next()": [[28, 41]], "Scanner.nextLine()": [[46, 63]]}}}, {"text": "If you're trying to read a whole file in, you'll need to use a loop to read a line at a time until Scanner.hasNextLine() returns false", "label": {"api": {"Scanner": [[99, 105]], "Scanner.hasNextLine()": [[99, 119]]}}}, {"text": "Alternately, you could just read the whole file into a String using commons-io FileUtils.readFileToString()", "label": {"api": {"String": [[55, 60], [99, 104]]}}}, {"text": "Java uses an established algorithm with a 48-bit seed to generate pseudorandom numbers", "label": {"api": {"Java uses an established algorithm with a 48-bit seed": [[0, 52]]}}}, {"text": "Try this with using Swing Timer and you will get it working as intended", "label": {"api": {"Swing Timer": [[20, 30]]}}}, {"text": "How to Use Swing Timers and also try using Swing workers", "label": {"api": {"Swing Timer": [[11, 21]]}}}, {"text": "If you're trying to override the clone method on Object, it needs to have the same signature (and capitalization)", "label": {"api": {"clone": [[33, 37]]}}}, {"text": "Certainly the ResultSet interface is oriented towards \"multiple rows, one row at a time\" - but not \"multiple sets of results\"", "label": {"api": {"ResultSet": [[14, 22]]}}}, {"text": "When i did this before (as detailed in this question and answer), i made the fields in the embeddable ID primitives (corresponding to the ID fields of the entities referred to), and then used @MapsId in the entity", "label": {"api": {"@MapsId": [[192, 198]]}}}, {"text": "that the fields in the entity are relationships, that the fields in the ID class are primitive, that every column is mapped exactly once (the @MapsId fields not really being mappings, but sort of aliases)", "label": {"api": {"@MapsId": [[142, 148]]}}}, {"text": "To understand what aliases are available in your file, trying looking at the strings returned from KeyStore.aliases()", "label": {"api": {"KeyStore.aliases()": [[99, 116]]}}}, {"text": "This is why, now; the suggested way is to use TimeUnit sleep method", "label": {"api": {"TimeUnit": [[46, 53]]}}}, {"text": "The most common reason of this problem is calling the UnicastRemoteObject.exportObject(Remote obj)", "label": {"api": {"exportObject(Remote obj)": [[74, 97]]}}}, {"text": "See the documentation for SimpleDateFormat for more details of the various format specifiers available", "label": {"api": {"documentation for SimpleDateFormat": [[8, 41]]}}}, {"text": "Java has all its data structures, including set, list, HashMap, defined in the Java Collections Framework", "label": {"api": {"HashMap": [[55, 61]], "Java Collections Framework": [[79, 104]]}}}, {"text": "A HashMap is essentially equivalent to a dictionary", "label": {"api": {"HashMap": [[2, 8]]}}}, {"text": "As for a tuple equivalent, look into unmodifiableList", "label": {"api": {"unmodifiableList": [[37, 52]]}}}, {"text": "One way is to use BufferedImage.getSubimage(x,y,w,h)", "label": {"api": {"BufferedImage.getSubimage(x,y,w,h)": [[18, 51]]}}}, {"text": "Never trap InterruptedException unless you really mean to", "label": {"api": {"InterruptedException": [[11, 30]]}}}, {"text": "Instead of 2D array, you can use ArrayList", "label": {"api": {"ArrayList": [[33, 41]]}}}, {"text": "In the API one of JDialog constructor is JDialog(Dialog owner, boolean modal) which means that you can create a dialog and specify the parent container as well as the modality", "label": {"api": {"API": [[7, 9]]}}}, {"text": "Use the Instrumentation Framework (java agent) to intercept the classes when they are loaded", "label": {"api": {"Instrumentation Framework": [[8, 32]]}}}, {"text": "Take a look at the methods Integer.rotateLeft, Integer.rotateRight, Integer.toBinaryString", "label": {"api": {"Integer.rotateLeft": [[27, 44]], "Integer.rotateRight": [[47, 65]], "Integer.toBinaryString": [[68, 89]]}}}, {"text": "Create a new Map, then for all entries x in map1, if map2 contains key x, put the addition of both values into the new map with key x", "label": {"api": {"new Map": [[9, 15]], "all entries": [[27, 37]], "contains key": [[58, 69]], "put": [[74, 76]]}}}, {"text": "When return value is not of interest, is there any (even irrelevant in practice) difference between AtomicInteger.getAndIncrement() and AtomicInteger.incrementAndGet() methods, when return value is ignored", "label": {"api": {"AtomicInteger.getAndIncrement()": [[100, 130]], "AtomicInteger.incrementAndGet()": [[136, 166]]}}}, {"text": "Call getValueAt(int row, int column)", "label": {"api": {"getValueAt(int row, int column)": [[5, 35]]}}}, {"text": "Use obj2.cast(obj1), which casts obj1 to the class or interface represented by obj2, returns obj1 if obj1 is assignable to the type T (note that null is assignable to any type), and throws ClassCastException otherwise", "label": {"api": {"obj2.cast(obj1)": [[4, 18]]}}}, {"text": "We are not interested in the result of the cast, because the statically known type of obj1 is already T and obj2.cast(obj1)==obj1 (if the cast succeeds)", "label": {"api": {"obj2.cast(obj1)": [[108, 122]]}}}, {"text": "ComponentListener#componentShown(ComponentEvent e) is fired whenever your Window is made visible", "label": {"api": {"ComponentListener#componentShown(ComponentEvent e)": [[0, 49]]}}}, {"text": "ServerSocket.setReuseAddress(true) prior to binding the socket", "label": {"api": {"ServerSocket.setReuseAddress(true)": [[0, 33]]}}}, {"text": "You can read and display fragments of the image using ImageReadParam from ImageIO package", "label": {"api": {"ImageReadParam": [[54, 67]]}}}, {"text": "Here is a basic example that illustrates how to read a single fragment using ImageReadParam without reading the whole image", "label": {"api": {"ImageReadParam": [[77, 90]]}}}, {"text": "A trick which is much easier than using SwingWorker is to call paintImmediately on your label after calling setVisible(true)", "label": {"api": {"paintImmediately": [[63, 78]]}}}, {"text": "You can create your own class that implements the Comparator<String> interface", "label": {"api": {"Comparator<String>": [[50, 67]]}}}, {"text": "Use subList(int fromIndex, int toIndex)", "label": {"api": {"subList(int fromIndex, int toIndex)": [[4, 38]]}}}, {"text": "Use a @PrePersist handler to initialize the field", "label": {"api": {"@PrePersist": [[6, 16]]}}}, {"text": "I need to be able to change the size of the task queue of a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[60, 77]]}}}, {"text": "Of course, the BlockingQueue doesn't support changing the size, and the ThreadPoolExecutor doesn't support changing the queue", "label": {"api": {"ThreadPoolExecutor": [[72, 89]]}}}, {"text": "So, the method I've come up with is to use ThreadPoolExecutor.shutdownNow(), which gives me back a list of the Runnables that haven't yet been executed", "label": {"api": {"ThreadPoolExecutor": [[43, 60]], "ThreadPoolExecutor.shutdownNow()": [[43, 74]]}}}, {"text": "String.split(String regex) takes a regular expression as an argument, use", "label": {"api": {"String.split(String regex)": [[0, 25]]}}}, {"text": "Sure, if you just want to work with raw XML without binding it onto POJOs, you can use javax.xml.parsers.DocumentBuilderFactory/javax.xml.parsers.DocumentBuilder to read any arbitrary XML directly into a org.w3c.dom.Document and just work with it as a document instead of as mapped data", "label": {"api": {"org.w3c.dom.Document": [[204, 223]]}}}, {"text": "Assuming that you want to extract the text between the word \"Fruits\" and the word \"Sports\" you could use a regular expression with a capturing group", "label": {"api": {"capturing group": [[133, 147]], "group": [[143, 147]]}}}, {"text": "This way, if a string matches then you still have to extract the group that contains the text that you want", "label": {"api": {"group": [[65, 69]]}}}, {"text": "Alternatively, you can use a more advanced regular expression using positive lookahead and lookbehinds", "label": {"api": {"positive lookahead and lookbehinds": [[68, 101]]}}}, {"text": "Just invoke String#matches(String regex) on string you want to check if it can be matched entirely by regex", "label": {"api": {"String#matches(String regex)": [[12, 39]]}}}, {"text": "This methodology seems brittle to me at best and I can already spot a mistake when you call invoke", "label": {"api": {"invoke": [[92, 97]]}}}, {"text": "That method takes the instance on which to invoke the method as its first argument (or null if it's a static method), but you're passing in myClass - that can't possibly be right", "label": {"api": {"invoke": [[43, 48]]}}}, {"text": "This may not be the reply to your query, but you can consider Using Random class", "label": {"api": {"Random": [[68, 73]]}}}, {"text": "Use a Pattern", "label": {"api": {"Pattern": [[6, 12]]}}}, {"text": "I am not very experienced with java.nio, but it seems Selector.selectedKeys() returns a Set, not an ArrayList", "label": {"api": {"Selector.selectedKeys()": [[54, 76]]}}}, {"text": "You need to call find() on the Matcher before you can call group() and related functions that queries about the matched text or manipulate it (start(), end(), appendReplacement(StringBuffer sb, String replacement), etc.)", "label": {"api": {"find()": [[17, 22]]}}}, {"text": "entries.sort();, you would need to call Collections.sort(List<T> list) or Collection.sort(List<T> list, Comparator<T> comparator)", "label": {"api": {"Collections.sort(List<T> list)": [[40, 69]], "Collection.sort(List<T> list, Comparator<T> comparator)": [[74, 128]]}}}, {"text": "The difference between the two is that the first one uses a default behaviour, which can be specified in the object you will be sorting by implementing the compareTo method specified by the Comparable interface while the second allows you to pass a comparator object", "label": {"api": {"Comparable": [[190, 199]]}}}, {"text": "Use DefaultTableModel.setDataVector() to add a new Vector with the new Data to the existing TableModel/JTable", "label": {"api": {"DefaultTableModel.setDataVector()": [[4, 36]]}}}, {"text": "In order to make this happen correctly, you should use a FutureTask for this by passing Callable instance to it's constructor", "label": {"api": {"FutureTask": [[57, 66]]}}}, {"text": "LinkedBlockingDeque which accepts the generic type of FutureTask", "label": {"api": {"FutureTask": [[54, 63]], "LinkedBlockingDeque": [[0, 18]]}}}, {"text": "Also you should have a map of future tasks mapped by their name or something which takes the FutureTask as a value", "label": {"api": {"FutureTask": [[93, 102]]}}}, {"text": "In terms of waiting for the results when your Thread is processed the given FutureTask already you have to immediately remove it from the futures map", "label": {"api": {"FutureTask": [[76, 85]]}}}, {"text": "if the futures map contains the task get the FutureTask from it and call futureTask.get() on it", "label": {"api": {"FutureTask": [[45, 54]]}}}, {"text": "See JTextComponent.read(Reader,Object) for almost a 'one-line solution'", "label": {"api": {"JTextComponent.read(Reader,Object)": [[4, 37]]}}}, {"text": "To compare BigInteger, use BigInteger.compareTo", "label": {"api": {"BigInteger.compareTo": [[27, 46]]}}}, {"text": "And for modulo (%), use BigInteger.mod", "label": {"api": {"BigInteger.mod": [[24, 37]]}}}, {"text": "Any List implementation has a isEmpty() method you can use", "label": {"api": {"isEmpty()": [[30, 38]]}}}, {"text": "You might want to keep the numbers as Strings, or use BigDecimal", "label": {"api": {"BigDecimal": [[54, 63]]}}}, {"text": "Internally it uses ResultSet#getObject which returns a String if the selected column is a string type, so make sure you're not selecting a numeric or date type or something (and if you are, cast or otherwise convert it to a char type in the select query)", "label": {"api": {"ResultSet#getObject": [[19, 37]]}}}, {"text": "To get rid of it, either adjust the length of the field(s) in the db table, or adjust the Size annotation itself in order to match the max size of the db field (or remove the annotation if you don't need it at all)", "label": {"api": {"Size": [[90, 93]]}}}, {"text": "Use a Semaphore", "label": {"api": {"Semaphore": [[6, 14]]}}}, {"text": "Never use more than one JFrame within a Swing application", "label": {"api": {"JFrame": [[24, 29]]}}}, {"text": "Use JDialog for extra windows instead", "label": {"api": {"JDialog": [[4, 10]]}}}, {"text": "See The Use of Multiple JFrames, Good/Bad Practice?", "label": {"api": {"JFrame": [[24, 29]]}}}, {"text": "It contains the C++ representation of the Java interface java.lang.Readable", "label": {"api": {"java.lang.Readable": [[57, 74]]}}}, {"text": "Consider using String#replace if regular expressions are not required", "label": {"api": {"String#replace": [[15, 28]]}}}, {"text": "I rolled my own Comparator<TimeZone> implementation using getRawOffset for the comparison", "label": {"api": {"getRawOffset": [[58, 69]]}}}, {"text": "I would use the BoxLayout layout manager in combination with Box", "label": {"api": {"BoxLayout": [[16, 24]], "Box": [[16, 18], [61, 63]]}}}, {"text": "For more information, please see How to Use BoxLayout", "label": {"api": {"BoxLayout": [[44, 52]], "Box": [[44, 46]]}}}, {"text": "SwingWorker encapsulates sequencing access to shared data", "label": {"api": {"SwingWorker": [[0, 10]]}}}, {"text": "The API and tutorial show the basic approach of updating a component's model using publish()/process()", "label": {"api": {"API": [[4, 6]]}}}, {"text": "In this more advanced example, a Swing Timer paces an Executor that controls a series of SwingWorker instances", "label": {"api": {"SwingWorker": [[89, 99]]}}}, {"text": "If you need each blocks in a different array, you may use Arrays.copyOfRange(original,from,to)", "label": {"api": {"Arrays.copyOfRange(original,from,to)": [[58, 93]]}}}, {"text": "you can't as HapMap/HashTable store the data in Entry for (http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Map.Entry.html) which holds key and value together", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Map.Entry.html": [[59, 127]]}}}, {"text": "Using BigDecimal in place of double would fix the problem, because 0.1 would be represented exactly", "label": {"api": {"BigDecimal": [[6, 15]]}}}, {"text": "you have to use overloaded Arrays.toString(list2); to print the string representation of your array", "label": {"api": {"Arrays.toString(list2)": [[27, 48]]}}}, {"text": "From the documentation for getConstructors() [emphasis mine]", "label": {"api": {"getConstructors()": [[27, 43]]}}}, {"text": "Your ContentPane has a BorderLayout by default, which only accepts a single element (in the default position - the center)", "label": {"api": {"BorderLayout": [[23, 34]]}}}, {"text": "OTOH if you specify constraints (using the overloaded add) then you have more control over where the element will be placed", "label": {"api": {"overloaded add": [[43, 56]]}}}, {"text": "Fastest way to implement it, is of course, replaceFirst method", "label": {"api": {"replaceFirst": [[43, 54]]}}}, {"text": "But replaceFirst method creates Pattern instance for each invoke", "label": {"api": {"replaceFirst": [[4, 15]], "Pattern": [[32, 38]]}}}, {"text": "But if all your cases look like \"@  XXXXX\" you can write a code which find first letter in the word and get substring after that", "label": {"api": {"substring": [[108, 116]]}}}, {"text": "If I were you I would use second solution with Pattern class, because it simple and fast", "label": {"api": {"Pattern": [[47, 53]]}}}, {"text": "You should also be able to accomplish a similar thing using the premain method of a Java agent", "label": {"api": {"premain method of a Java agent": [[64, 93]]}}}, {"text": "In that case, you will need valid Color objects rather than Strings, you could use", "label": {"api": {"you will need valid Color objects": [[14, 46]]}}}, {"text": "Use a ServletContextListener", "label": {"api": {"ServletContextListener": [[6, 27]]}}}, {"text": "This can be made using an URLConnection, or using a library like apache HttpCLient if you need more flexibility", "label": {"api": {"URLConnection": [[26, 38]]}}}, {"text": "Read the dictionary into a Set<String> (for example, HashSet<String>), and then use set.contains(word)", "label": {"api": {"Set<String>": [[27, 37], [57, 67]], "HashSet<String>": [[53, 67]], "set.contains(word)": [[84, 101]]}}}]