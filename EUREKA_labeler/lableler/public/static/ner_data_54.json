[{"text": "Use StringBuilder#deleteCharAt(int index)", "label": {"api": {"StringBuilder#deleteCharAt(int index)": [[4, 40]]}}}, {"text": "A simple solution is to use java.util.concurrent.locks.Lock, which will perform all the wait and notify operations required", "label": {"api": {"java.util.concurrent.locks.Lock": [[28, 58]]}}}, {"text": "You are using == to compare strings; use String#equals instead", "label": {"api": {"String#equals": [[41, 53]]}}}, {"text": "However the armed state does'nt mean that action is going to be triggered for sure , because The user may release the button while the cursor is over the JButton, or the user may move the cursor elsewhere and release.Hence isArmed returns true if the JButton is armed, else it return false", "label": {"api": {"isArmed": [[223, 229]]}}}, {"text": "The documentation for ButtonModel explains the difference", "label": {"api": {"ButtonModel": [[22, 32]]}}}, {"text": "You may use the method getComponents", "label": {"api": {"getComponents": [[23, 35]]}}}, {"text": "You can't do it with a straight array, but you can with a Set<T> by calling .contains", "label": {"api": {"Set<T>": [[58, 63]], ".contains": [[76, 84]]}}}, {"text": "For example, using a HashSet<T> makes isItemInSet an O(1) operation (on average)", "label": {"api": {"Set<T>": [[25, 30]], "HashSet<T>": [[21, 30]]}}}, {"text": "Indeed, a HashSet<T> in Java is essentially the same as a Python set() (similar underlying concept and performance characteristics) -- you will see a big improvement in speed with many calls to query, insert or delete on the set", "label": {"api": {"Set<T>": [[14, 19]], "HashSet<T>": [[10, 19]]}}}, {"text": "You may use method getSelectedItem to get the currently selected item", "label": {"api": {"getSelectedItem": [[19, 33]]}}}, {"text": "fillOval, what does x and y denote", "label": {"api": {"fillOval": [[0, 7]]}}}, {"text": "To configure the access rules I would like to mainly use the standard @RolesAllowed annotation", "label": {"api": {"@RolesAllowed annotation": [[70, 93]]}}}, {"text": "An alternative is to completely synchronize the map (like in Collections.synchronizedMap or Hashtable), but the performance of such a strategy under high contention is significantly worse - it might be good enough depending on your use case", "label": {"api": {"Collections.synchronizedMap": [[61, 87]]}}}, {"text": "Have a look at the Robot class", "label": {"api": {"Robot": [[19, 23]]}}}, {"text": "This freezes the GUI and won't let any other action to be performed on GUI.If you want to perform long tasks then You should handle all such action events in separate Worker Threads like SwingWorker or javax.swing.Timer", "label": {"api": {"SwingWorker": [[187, 197]], "javax.swing.Timer": [[202, 218]]}}}, {"text": "Consider using a StringBuilder", "label": {"api": {"StringBuilder": [[17, 29]]}}}, {"text": "This class is designed for quickly creating long strings from parts (on a single thread; see StringBuffer for a multi-threaded counterpart)", "label": {"api": {"StringBuffer": [[93, 104]]}}}, {"text": "Javadoc for PriorityBlockingQueue includes an example of this technique", "label": {"api": {"PriorityBlockingQueue": [[12, 32]]}}}, {"text": "For your tiles, one thing you could do is make a few Vectors (http://docs.oracle.com/javase/6/docs/api/java/util/Vector.html) for the tile's X positions, Y positions, and Z positions", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Vector.html": [[62, 123]]}}}, {"text": "Consider using AtomicInteger", "label": {"api": {"AtomicInteger": [[15, 27]]}}}, {"text": "You may be looking for Graphics#clearRect()", "label": {"api": {"Graphics#clearRect()": [[23, 42]]}}}, {"text": "java.awt.geom.AffineTransform may be a startup point", "label": {"api": {"java.awt.geom.AffineTransform": [[0, 28]]}}}, {"text": "I think your code could use Class.getResourceAsStream() instead (/resources/log.ascii needs to be packaged in the jar, or somewhere else on the classpath)", "label": {"api": {"Class.getResourceAsStream()": [[28, 54]]}}}, {"text": "As others have displayed,Integer.parseInt() can do this for you", "label": {"api": {"Integer.parseInt()": [[25, 42]]}}}, {"text": "However, you can mimic this using a Map that maps String identifiers to values", "label": {"api": {"Map": [[36, 38]]}}}, {"text": "Taking a look at the classes in java/util/concurrent/atomic might be useful to you", "label": {"api": {"java/util/concurrent/atomic": [[32, 58]]}}}, {"text": "Such as AtomicBoolean", "label": {"api": {"AtomicBoolean": [[8, 20]]}}}, {"text": "You can also use an instance of java.util.Scanner to read the output of the command", "label": {"api": {"java.util.Scanner": [[32, 48]]}}}, {"text": "Use BitSet (as Hunter McMillen already pointed out in a comment)", "label": {"api": {"BitSet": [[4, 9]]}}}, {"text": "You can easily get and set bits", "label": {"api": {"get": [[15, 17]], "set": [[23, 25]]}}}, {"text": "The smallest positive value of a double is Double.MIN_NORMAL", "label": {"api": {"Double.MIN_NORMAL": [[43, 59]]}}}, {"text": "So, the largest number less than 1.0 is 1.0-Double.MIN_NORMAL", "label": {"api": {"Double.MIN_NORMAL": [[44, 60]]}}}, {"text": "Double.MIN_NORMAL is equal to 2-1022, so the answer is still extremely close to 1.0", "label": {"api": {"Double.MIN_NORMAL": [[0, 16]]}}}, {"text": "You'd have to print the value of 1.0-Double.MIN_NORMAL to 308 decimal places before you could see anything but a 9", "label": {"api": {"Double.MIN_NORMAL": [[37, 53]]}}}, {"text": "I think a servlet Filter is more suitable for what you want", "label": {"api": {"Filter": [[18, 23]]}}}, {"text": "In the doFilter() method you have access to the HttpServletRequest as needed", "label": {"api": {"Filter": [[9, 14]]}}}, {"text": "Since ArithmeticException is an unchecked exception, listing it in the throws specification has no effect as far as the compiler is concerned", "label": {"api": {"ArithmeticException": [[6, 24]]}}}, {"text": "That said, ArithmeticException is probably not the right exception to be throwing when the function is called with an invalid argument", "label": {"api": {"ArithmeticException": [[11, 29]]}}}, {"text": "Using IllegalArgumentException would be more appropriate", "label": {"api": {"IllegalArgumentException": [[6, 29]]}}}, {"text": "You should use JFrame.setExtendedState", "label": {"api": {"JFrame.setExtendedState": [[15, 37]]}}}, {"text": "File.createNewFile() can throw an IOException (a checked exception) and needs to be surrounded in a try-catch block or the method you're using it in needs to be declared as throws IOException and you need to handle it upstream", "label": {"api": {"File.createNewFile()": [[0, 19]]}}}, {"text": "Which uses the File.getAbsolutePath() method to print where it expects the file to exist", "label": {"api": {"File.getAbsolutePath()": [[15, 36]]}}}, {"text": "See the String method intern()", "label": {"api": {"intern()": [[22, 29]]}}}, {"text": "You have to know the name of the character encoder and use CharsetDecoder", "label": {"api": {"CharsetDecoder": [[59, 72]]}}}, {"text": "If you are done, you can use the toArray(int[]) method to transform the List into an int[]", "label": {"api": {"toArray(int[])": [[33, 46]]}}}, {"text": "You should get familiar with System.currentTimeMillis() and Thread.sleep()", "label": {"api": {"System.currentTimeMillis()": [[29, 54]], "Thread.sleep()": [[60, 73]]}}}, {"text": "The value 2 corresponds to Calendar.MARCH", "label": {"api": {"Calendar.MARCH": [[27, 40]]}}}, {"text": "There are two ways to do it with the ByteBuffer class", "label": {"api": {"ByteBuffer": [[37, 46]]}}}, {"text": "Finally make sure you are keeping the contract between equals and hashCode or you could be in for some nasty surprises", "label": {"api": {"contract between equals and hashCode": [[38, 73]]}}}, {"text": "You can use a Set<Integer> and save lot of time since it holds unique elements", "label": {"api": {"Set<Integer>": [[14, 25]]}}}, {"text": "You can sort the array manually or use Arrays#sort", "label": {"api": {"Arrays#sort": [[39, 49]]}}}, {"text": "I'll post the Set<Integer> code", "label": {"api": {"Set<Integer>": [[14, 25]]}}}, {"text": "Note that I prefer to use LinkedHashSet as Set implementation since it maintains the order of how the elements were inserted", "label": {"api": {"LinkedHashSet": [[26, 38]]}}}, {"text": "Look at the documentation for java.util.Scanner for more information", "label": {"api": {"java.util.Scanner": [[30, 46]]}}}, {"text": "Of particular interest is the nextInt() method used in your sample code", "label": {"api": {"nextInt()": [[30, 38]]}}}, {"text": "So the println overload used is println(Object)", "label": {"api": {"println(Object)": [[32, 46]]}}}, {"text": "If you want to be defensive of nulls, you should consider using String.valueOf(Object)", "label": {"api": {"String.valueOf(Object)": [[64, 85]]}}}, {"text": "You can use java.util.Vector", "label": {"api": {"java.util.Vector": [[12, 27]]}}}, {"text": "Check API doc", "label": {"api": {"Check API doc": [[0, 12]]}}}, {"text": "Unless this is an academic exercise, convert the elements to a Set instead", "label": {"api": {"Set": [[63, 65]]}}}, {"text": "If you don't want to deal with NIO you can use http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html instead", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html": [[47, 116]]}}}, {"text": "You can retrieve the headers from a Message by calling the getHeader(java.lang.String) method", "label": {"api": {"getHeader(java.lang.String)": [[59, 85]]}}}, {"text": "Say for Example you are using RestFul Webservice then ResponseBuilder can be used like this", "label": {"api": {"ResponseBuilder": [[54, 68]]}}}, {"text": "I'm looking to use (seeded) Random objects across multiple threads, and the javadocs pointed me to ThreadLocalRandom which looks great except I can't set the seed, so I can't ensure consistency among different threads or runs", "label": {"api": {"ThreadLocalRandom": [[99, 115]]}}}, {"text": "Is there any practical reason to use ThreadLocalRandom or would it be acceptable to do something like the following", "label": {"api": {"ThreadLocalRandom": [[37, 53]]}}}, {"text": "You would want to use the .equals() method instead to check if the content of the Strings are equal", "label": {"api": {".equals()": [[26, 34]]}}}, {"text": "You could write a Comparator that compares the Result objects based on the result of getValue(), and then use [Collections.sort(java.util.List, java.util.Comparator)](http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List, java.util.Comparator)) to sort the ArrayList", "label": {"api": {"Comparator": [[18, 27], [154, 163], [266, 275]], "http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List": [[167, 253]]}}}, {"text": "hyperlink and the Desktop.mail(URI) method to invoke the right e-mail editor would be what you need then", "label": {"api": {"Desktop.mail(URI)": [[18, 34]]}}}, {"text": "In Java, call ByteBuffer.allocateDirect() to create the buffer", "label": {"api": {"ByteBuffer.allocateDirect()": [[14, 40]]}}}, {"text": "Yes, you can use the Class#cast(Object obj) method", "label": {"api": {"Class#cast(Object obj)": [[21, 42]]}}}, {"text": "You are calling signal AFTER you release the lock whereas you should call it WHILE holding the lock", "label": {"api": {"you should call it WHILE holding the lock": [[58, 98]]}}}, {"text": "You've just not looked at the documentation for the method you're calling, Date.getYear()", "label": {"api": {"Date.getYear()": [[75, 88]]}}}, {"text": "You need to use String#equals(Object)", "label": {"api": {"String#equals(Object)": [[16, 36]]}}}, {"text": "using the Comparable interface and a bounded type parameter", "label": {"api": {"Comparable": [[10, 19]]}}}, {"text": "The getRGB method expects an array of integers (int[]) in the 5th parameter, and you must have supplied a plain int, although that's not clear from your code result [x][y].pixels", "label": {"api": {"getRGB": [[4, 9]]}}}, {"text": "You can use Character.toLowerCase(char)", "label": {"api": {"Character.toLowerCase(char)": [[12, 38]]}}}, {"text": "The java.io.File API provides a method that takes a java.io.FilenameFilter and gives back a list of files and directories", "label": {"api": {"java.io.FilenameFilter": [[52, 73]]}}}, {"text": "We can use Map class for linking these properties but specific class is the best solution, I think", "label": {"api": {"Map": [[11, 13]]}}}, {"text": "The easiest way to store an ArrayList in a file is with ObjectOutputStream", "label": {"api": {"ObjectOutputStream": [[56, 73]]}}}, {"text": "To recover the arraylist you use ObjectInputStream", "label": {"api": {"ObjectInputStream": [[33, 49]]}}}, {"text": "If you want to be more specific, you can use Point and do something like this", "label": {"api": {"Point": [[45, 49]]}}}, {"text": "You should use a List for something like this, not an array", "label": {"api": {"List": [[17, 20]]}}}, {"text": "As a general rule of thumb, when you don't know how many elements you will add to an array before hand, use a List instead", "label": {"api": {"List": [[110, 113]]}}}, {"text": "Most would probably tackle this problem by using an ArrayList", "label": {"api": {"List": [[57, 60]], "ArrayList": [[52, 60]]}}}, {"text": "If you really can't use a List, then you'll probably have to use an array of some initial size (maybe 10?) and keep track of your array capacity versus how many elements you're adding, and copy the elements to a new, larger array if you run out of room (this is essentially what ArrayList does internally)", "label": {"api": {"List": [[26, 29], [284, 287]], "ArrayList": [[279, 287]]}}}, {"text": "Also note that, in the real world, you would never do it this way - you would use one of the standard classes that are made specifically for cases like this, such as ArrayList", "label": {"api": {"List": [[171, 174]], "ArrayList": [[166, 174]]}}}, {"text": "The problem is that List is an interface (it defines some methods, but doesn't implement them)", "label": {"api": {"List": [[20, 23]]}}}, {"text": "Try using a class that implements it, like ArrayList or LinkedList", "label": {"api": {"List": [[48, 51], [62, 65]], "ArrayList": [[43, 51]], "LinkedList": [[56, 65]]}}}, {"text": "The java.beans package documentation makes exactly this point, and suggests using java.beans.EventHandler instead of inner classes for listeners", "label": {"api": {"java.beans package documentation": [[4, 35]], "java.beans.EventHandler": [[82, 104]]}}}, {"text": "There are only a few standard colors available in the API - Java.Color", "label": {"api": {"Java.Color": [[60, 69]]}}}, {"text": "Have a look at JColorChooser", "label": {"api": {"JColorChooser": [[15, 27]]}}}, {"text": "You could pass Collections#unmodifiableList(yourList) in order to send an unmodifiable copy of your list", "label": {"api": {"Collections#unmodifiableList(yourList)": [[15, 52]]}}}, {"text": "Check out the Class<T> class and the Method class at the very least", "label": {"api": {"Class<T> class": [[14, 27]], "Method class": [[37, 48]]}}}, {"text": "Well, if you want a floating point number, use Double.parseDouble or new BigDecimal", "label": {"api": {"Double.parseDouble": [[47, 64]], "new BigDecimal": [[69, 82]]}}}, {"text": "If you want an integer, use String#indexOf to find the ., then use String#substring to get only the digits before the ., and continue using Integer.parseInt", "label": {"api": {"String#indexOf": [[28, 41]], "String#substring": [[67, 82]]}}}, {"text": "Or, as Mike Samuel points out in the comments below, use Double.parseDouble and then cast to int", "label": {"api": {"Double.parseDouble": [[57, 74]]}}}, {"text": "Since Java 5, we have the new java.lang.Iterable type that can be used in foreach loops as such", "label": {"api": {"java.lang.Iterable": [[30, 47]], "Iterable": [[40, 47]]}}}, {"text": "The Iterable contract does not specify whether its iterator() method can be called more than once before disposing of the Iterable", "label": {"api": {"Iterable": [[4, 11], [122, 129]], "iterator()": [[51, 60]]}}}, {"text": "I.e., it is not clear whether the following can be expected to work for all Iterables", "label": {"api": {"Iterable": [[76, 83]]}}}, {"text": "For most Iterables, this is irrelevant, as they are in fact retro-fitted Collection API types such as List, Set, which already have well-defined contracts for their iterator() methods", "label": {"api": {"Iterable": [[9, 16]], "iterator()": [[165, 174]]}}}, {"text": "Is my OneShotIterable implementation violating some contract that I'm overlooking", "label": {"api": {"Iterable": [[13, 20]]}}}, {"text": "In other words, will users of an Iterable expect it to be reusable", "label": {"api": {"Iterable": [[33, 40]]}}}, {"text": "If so, is there an \"official\" recommendation by the Java 5 expert group how to deal with such \"one shot\" Iterables (e.g", "label": {"api": {"Iterable": [[105, 112]]}}}, {"text": "It is very easy if you use a JSPlitPane", "label": {"api": {"JSPlitPane": [[29, 38]]}}}, {"text": "You could also consider using a JSplitPane which allows to resize the UI", "label": {"api": {"JSplitPane": [[32, 41]]}}}, {"text": "You can override getPreferredSize of your added JPanels to size them correctly", "label": {"api": {"getPreferredSize": [[17, 32]]}}}, {"text": "As you're on Tomcat, which is just a barebones servletcontainer, you can't use EJB's @Schedule for this which is recommended by Java EE specification", "label": {"api": {"@Schedule": [[85, 93]]}}}, {"text": "Your best bet is then the ScheduledExecutorService from Java 1.5's java.util.concurrent package", "label": {"api": {"ScheduledExecutorService": [[26, 49]]}}}, {"text": "You can trigger this with help of a ServletContextListener like follows", "label": {"api": {"ServletContextListener": [[36, 57]]}}}, {"text": "If you were actually using a real Java EE container with EJB support and all on em (like Glassfish, JBoss AS, TomEE, etc), then you could use a @Singleton EJB with a @Schedule method", "label": {"api": {"@Singleton": [[144, 153]], "@Schedule": [[166, 174]]}}}, {"text": "Note that this way you can continue transparently using container managed transactions the usual way (@PersistenceContext and so on), which isn't possible with ScheduledExecutorService — you'd have to manually obtain the entity manager and manually start/commit/end transaction, but you would by default already not have another option on a barebones servletcontainer like Tomcat anyway", "label": {"api": {"ScheduledExecutorService": [[160, 183]]}}}, {"text": "Timer is sensitive to changes in the system clock, ScheduledExecutorService isn't", "label": {"api": {"ScheduledExecutorService": [[51, 74]]}}}, {"text": "ScheduledExecutorService can be configured with any number of threads", "label": {"api": {"ScheduledExecutorService": [[0, 23]]}}}, {"text": "The method append(), from StringBuffer, appends a String to the string inside the buffer and returns the instance", "label": {"api": {"append()": [[11, 18]]}}}, {"text": "Take a look at InetAddress and the getHostAddress() method", "label": {"api": {"InetAddress": [[15, 25]], "getHostAddress()": [[35, 50]]}}}, {"text": "The typical way is to implement Comparable", "label": {"api": {"Comparable": [[32, 41]]}}}, {"text": "You may also want to set a working directory and/or environment", "label": {"api": {"working directory": [[27, 43]], "environment": [[52, 62]]}}}, {"text": "Rather than use your value of 11, try getting the ResultSetMetaData and determining the column count to confirm your columns retrieved", "label": {"api": {"ResultSetMetaData": [[50, 66]]}}}, {"text": "You might consider to switching your code to use a CountDownLatch", "label": {"api": {"CountDownLatch": [[51, 64]]}}}, {"text": "However, it could yield values of the wrapper type Byte", "label": {"api": {"Byte": [[51, 54]]}}}, {"text": "Implement Iterable, and return a Byte object instead of a byte primitive", "label": {"api": {"Iterable": [[10, 17]]}}}, {"text": "Implementing Iterable instead of Iterator allows you to loop on the object items directly, using the for-each loop", "label": {"api": {"Iterable": [[13, 20]]}}}, {"text": "Java 8 introduced primitive iterators, that allow you to avoid boxing/unboxing during iteration over int, long and double collections", "label": {"api": {"primitive iterators": [[18, 36]]}}}, {"text": "Specifically, you'll probably want to use the getResourceAsStream() method on the current thread's context ClassLoader Thread.currentThread().getContextClassLoader()", "label": {"api": {"getResourceAsStream()": [[46, 66]], "Thread.currentThread().getContextClassLoader()": [[119, 164]]}}}, {"text": "(So, Thread.currentThread().getContextClassLoader().getResourceAsStream(\"filename\") in total.) The ClassLoader will then find your resource for you (as long as you put it somewhere sane in your CLASSPATH)", "label": {"api": {"Thread.currentThread().getContextClassLoader()": [[5, 50]]}}}, {"text": "Instead of using primitives, you need to create your own object, and comparators to help you sort", "label": {"api": {"comparators": [[69, 79]]}}}, {"text": "You can write your Java object(s) to a Java Properties file", "label": {"api": {"Properties": [[44, 53]]}}}, {"text": "Assuming you are using a DefaultListModel in your JList you can use the contains method like this", "label": {"api": {"DefaultListModel": [[25, 40]], "contains": [[72, 79]]}}}, {"text": "You can use JList#getNextMatch() method the following", "label": {"api": {"JList#getNextMatch()": [[12, 31]]}}}, {"text": "You could use a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[16, 28]]}}}, {"text": "See the Double.valueOf() Javadoc for details", "label": {"api": {"Double.valueOf()": [[8, 23]]}}}, {"text": "Use Thread.interrupt() method instead of Thread.stop()", "label": {"api": {"Thread.interrupt()": [[4, 21]]}}}, {"text": "You should call validate() after the for loop as follows", "label": {"api": {"validate()": [[16, 25]]}}}, {"text": "comment the code validate() and then compile and execute it to see the effect", "label": {"api": {"validate()": [[17, 26]]}}}, {"text": "This could happen if your Employee class extends a class that is not Serializable, and the superclass does not have a zero argument constructor, as decribed in the java.io.Serializable documentation", "label": {"api": {"java.io.Serializable": [[164, 183]]}}}, {"text": "I'd like to use Arrays.toString(...) in a direct statement", "label": {"api": {"Arrays.toString(...)": [[16, 35]]}}}, {"text": "If you use an extended persistence context, entities will not become detached when leaving the original transaction, but that is a rather unusual case", "label": {"api": {"extended persistence context": [[14, 41]]}}}, {"text": "From the Javadoc for OutputStreamWriter", "label": {"api": {"Javadoc for OutputStreamWriter": [[9, 38]]}}}, {"text": "What about dispose() which is inherited from Window", "label": {"api": {"dispose()": [[11, 19]], "Window": [[45, 50]]}}}, {"text": "You could use a card String array index to manage the current position of the and use the show method to display the next \"card\"", "label": {"api": {"show": [[90, 93]]}}}, {"text": "What is the best way to instrument an arbitrary JavaFX application so I could inject code somewhere to invoke a routine in Prolog immediately after the primary Stage has been instantiated", "label": {"api": {"Stage": [[160, 164]]}}}, {"text": "(so Prolog will be able to refer to the nodes in the Scene Graph of the Stage)", "label": {"api": {"Stage": [[72, 76]], "nodes": [[40, 44]]}}}, {"text": "I think Scenic View does something similar using agents to instrument a bit an arbitrary JavaFX application that does not have any code related to Scenic View", "label": {"api": {"agents": [[49, 54]]}}}, {"text": "Random is not a good option, nothing guarantees that it won't choose an already existing number (check the Random API)", "label": {"api": {"Random API": [[107, 116]]}}}, {"text": "IllegalArgumentException usually denotes a bug, where a method receives a parameter it is not supposed to deal with", "label": {"api": {"IllegalArgumentException": [[0, 23]]}}}, {"text": "You can use Pattern.DOTALL to allow matching to be done on newline characters", "label": {"api": {"Pattern.DOTALL": [[12, 25]]}}}, {"text": "Take a look at the java.util.Comprator interface", "label": {"api": {"java.util.Comprator": [[19, 37]]}}}, {"text": "I think you can use File's getParent() method to do your desire job", "label": {"api": {"File's getParent() method": [[20, 44]]}}}, {"text": "PrintWriter have some useful print and println methods that can be convenient if you want to print Strings and lines to a File", "label": {"api": {"PrintWriter": [[0, 10]]}}}, {"text": "Working directly with FileWriter, you would have to use a more \"low level\" API", "label": {"api": {"FileWriter": [[22, 31]]}}}, {"text": "NullPointerExeption isn't an instance of NumberFormatException thus it wasnt caught", "label": {"api": {"NumberFormatException": [[41, 61]]}}}, {"text": "NumberFormatException and  NullPointerException", "label": {"api": {"NumberFormatException": [[0, 20]], "NullPointerException": [[27, 46]]}}}, {"text": "You want to use a timer object which calls a method containing this function (without the while loop)", "label": {"api": {"timer": [[18, 22]]}}}, {"text": "The Javadoc for DataOutputStream#close() states", "label": {"api": {"DataOutputStream#close()": [[16, 39]]}}}, {"text": "Plus, the Javadoc for Socket states that when you close a Sockets inputStream or outputStream, it will also close the associated socket", "label": {"api": {"Javadoc for Socket": [[10, 27]]}}}, {"text": "You need to use the getRequestURI() method", "label": {"api": {"the getRequestURI() method": [[16, 41]]}}}, {"text": "Simple way to do it is to use Condition", "label": {"api": {"Condition": [[30, 38]]}}}, {"text": "Fraction needs to implement the toString() method, as it is currently using Object.toString() which returns", "label": {"api": {"Object.toString()": [[76, 92]]}}}, {"text": "You need to override the toString() method in your class", "label": {"api": {"toString()": [[25, 34]]}}}, {"text": "As others have already pointed out, you could also just add one month, and use Calendar.getActualMaximum() to set the last day of the following month", "label": {"api": {"Calendar.getActualMaximum()": [[79, 105]]}}}, {"text": "As a ZipEntry represents a file, I guess you are looking for java.io.File", "label": {"api": {"java.io.File": [[61, 72]]}}}, {"text": "After that, you can print it using the Arrays.deepToString method", "label": {"api": {"Arrays.deepToString": [[39, 57]]}}}, {"text": "Use Collections.sort() and provide a custom Comparator to impose your desired ordering criteria", "label": {"api": {"Collections.sort()": [[4, 21]], "Comparator": [[44, 53]]}}}, {"text": "Then you will be able to store those data in single Set", "label": {"api": {"Set": [[52, 54]]}}}, {"text": "The HashMap has an internal array of Entry that when no other size is specified, defaults to 16", "label": {"api": {"Entry": [[37, 41]]}}}, {"text": "Your first approach should be to find all references to Thread.sleep and check that", "label": {"api": {"Thread.sleep": [[56, 67]]}}}, {"text": "Alternatively, use the Iterator interface instead of the for-each loop", "label": {"api": {"Iterator": [[23, 30]]}}}, {"text": "This will enable you to use Iterator.remove() to remove elements while iterating", "label": {"api": {"Iterator": [[28, 35]], "Iterator.remove()": [[28, 44]]}}}, {"text": "Use SimpleDateFormat to convert a string to a Date object and then format it", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "You can simply add a ListSelectionListener within which you could have it update the JTextField", "label": {"api": {"ListSelectionListener": [[21, 41]]}}}, {"text": "Also consider adding an optional provision to invoke Desktop#mail()", "label": {"api": {"Desktop#mail()": [[53, 66]]}}}, {"text": "There is a second version of the split() method that accepts another int parameter limit, which controls the number of times the match is to be applied, but also the behaviour of ignoring trailing blanks", "label": {"api": {"second version of the split()": [[11, 39]]}}}, {"text": "Just call getElementsByTagName and see if the returned list has any nodes (using NodeList.getLength())", "label": {"api": {"getElementsByTagName": [[10, 29]]}}}, {"text": "You know the necessary information (sample rate, duration etc.), then it's just writing them in the file using a BufferedOutputStream, for example", "label": {"api": {"BufferedOutputStream": [[113, 132]]}}}, {"text": "The ObjectOutputStream and ObjectInputStream use a very specific protocol and format that includes a serialization streamheader that the ObjectInputStream expects to be present when constructed", "label": {"api": {"ObjectOutputStream": [[4, 21]], "ObjectInputStream": [[27, 43], [137, 153]]}}}, {"text": "You simply cannot use an empty file when using ObjectInputStream", "label": {"api": {"ObjectInputStream": [[47, 63]]}}}, {"text": "So if you need it to work with an empty file, then you should not be using ObjectOutputStream and ObjectInputStream, but write your own text (or binary format) files", "label": {"api": {"ObjectOutputStream": [[75, 92]], "ObjectInputStream": [[98, 114]]}}}, {"text": "Eg with a BufferedWriter and a BufferedReader and/or Scanner", "label": {"api": {"BufferedWriter": [[10, 23]], "BufferedReader": [[31, 44]], "Scanner": [[53, 59]]}}}, {"text": "What it does is creates the text representation of the class (see http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html#toString())", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html#toString()": [[66, 142]]}}}, {"text": "You could also tackle this using a different approach by recognizing elements on the screen by their pixel colors, for that you could use the Java Robot API which provides you with access to the keyboard, mouse and video", "label": {"api": {"Robot API": [[147, 155]]}}}, {"text": "The Robot class can be used for this sort of programming", "label": {"api": {"Robot": [[4, 8]]}}}, {"text": "Assuming that the code runs in a single thread, use ThreadLocal", "label": {"api": {"ThreadLocal": [[52, 62]]}}}, {"text": "Use a system property (e.g", "label": {"api": {"system property": [[6, 20]]}}}, {"text": "Another way is to use java.util.Collections.min(collection)", "label": {"api": {"java.util.Collections.min(collection)": [[22, 58]]}}}, {"text": "I suggest the way to do this is to build a Filter", "label": {"api": {"Filter": [[43, 48]]}}}, {"text": "Your best option is to use an ExecutorService and call invokeAll()", "label": {"api": {"invokeAll()": [[55, 65]]}}}, {"text": "You can retrieve an instance by calling Executors.newFixedThreadPool()", "label": {"api": {"Executors.newFixedThreadPool()": [[40, 69]]}}}, {"text": "However, multiple workers can be avoided by using newSingleThreadScheduledExecutor instead of newScheduledThreadPool(int corePoolSize)'", "label": {"api": {"newSingleThreadScheduledExecutor": [[50, 81]]}}}, {"text": "You can use the JtextField#setToolTipText(tipText) method for that(note that JTextField extends JTextComponent which extends JComponent)", "label": {"api": {"JtextField#setToolTipText(tipText)": [[16, 49]]}}}, {"text": "So, if your file resides on the file system, rather than in your JAR file, better use the FileInputStream class", "label": {"api": {"FileInputStream": [[90, 104]]}}}, {"text": "You should also consider using a StringBuilder to create the result strings, which reduces the memory overhead", "label": {"api": {"StringBuilder": [[33, 45]]}}}, {"text": "For example here is the description of the JOptionPane.getValue()", "label": {"api": {"JOptionPane.getValue()": [[43, 64]]}}}, {"text": "UPDATE Java already have interface which work in other direction - PropertyEditor", "label": {"api": {"PropertyEditor": [[67, 80]]}}}, {"text": "I would suggest using a JTextPane instead", "label": {"api": {"JTextPane": [[24, 32]]}}}, {"text": "Use getDisplayName(daylight, style), passing in true for daylight", "label": {"api": {"getDisplayName(daylight, style)": [[4, 34]]}}}, {"text": "You can use String.replace(char, char) for this case", "label": {"api": {"String.replace(char, char)": [[12, 37]]}}}, {"text": "You can use java.text.MessageFormat that has ways to provide data format you need", "label": {"api": {"java.text.MessageFormat": [[12, 34]]}}}, {"text": "\"causes this Window to be sized to fit the preferred size and layouts of its subcomponents\"", "label": {"api": {"\"causes this Window to be sized to fit the preferred size and layouts of its subcomponents\"": [[0, 90]]}}}, {"text": "getValue doesn't take an integer argument", "label": {"api": {"getValue": [[0, 7]]}}}, {"text": "You can't take int as argument in Map.Entry#getValue()", "label": {"api": {"Map.Entry#getValue()": [[34, 53]]}}}, {"text": "You could use java.lang.Enum.ordinal() to return an int value which represents the position of the Enum constant within the definition of the Enum class for that type of object", "label": {"api": {"java.lang.Enum.ordinal()": [[14, 37]]}}}, {"text": "Using the URL constructor", "label": {"api": {"URL constructor": [[10, 24]]}}}, {"text": "You can use Future and FutureTask", "label": {"api": {"Future": [[12, 17], [23, 28]], "FutureTask": [[23, 32]]}}}, {"text": "You have constructed the ArrayList and told it to have the initial Capacity to be 10 using constructor ArrayList(int initialCapacity) , But since nothing is inside ArrayList right now , so ArrayList#size() is returning as 0", "label": {"api": {"ArrayList(int initialCapacity)": [[103, 132]], "ArrayList#size()": [[189, 204]]}}}, {"text": "According to the reference documentation of java.util.HashMap", "label": {"api": {"reference documentation of java.util.HashMap": [[17, 60]]}}}, {"text": "If you look at the JavaDoc for StringBuilder you can see it has only exited since 1.5", "label": {"api": {"JavaDoc for StringBuilder": [[19, 43]]}}}, {"text": "The closest match is System.arraycopy()", "label": {"api": {"System.arraycopy()": [[21, 38]]}}}, {"text": "The JavaDoc for it can be found here", "label": {"api": {"The JavaDoc for it can be found here": [[0, 35]]}}}, {"text": "If you want > 64-bit precision, look into java.math.BigInteger which offers arbitrarily high precision", "label": {"api": {"java.math.BigInteger": [[42, 61]]}}}, {"text": "By using String#replaceAll you can do the following", "label": {"api": {"String#replaceAll": [[9, 25]]}}}, {"text": "You can compile a regex in Java using Pattern.compile, this will result in a Pattern object", "label": {"api": {"Pattern.compile": [[38, 52]]}}}, {"text": "If you define a pattern that matches any number between ^, you could create a Matcher object that matches your pattern against your input, using Pattern.matcher()", "label": {"api": {"Pattern.matcher()": [[145, 161]]}}}, {"text": "The Matcher.group(int) method would give you access to a specific match in the given input", "label": {"api": {"Matcher.group(int)": [[4, 21]]}}}, {"text": "I haven't benchmarked it against the Java standard library one, but looking at the source I have a hard time imagining a significant performance difference", "label": {"api": {"Java standard library one": [[37, 61]]}}}, {"text": "Take a look at the definitions for hasNextLine and nextLine in the Scanner class", "label": {"api": {"hasNextLine": [[35, 45]], "nextLine": [[51, 58]]}}}, {"text": "you can use an ExecutorCompletionService to solve this problem", "label": {"api": {"ExecutorCompletionService": [[15, 39]]}}}, {"text": "Implement the data collection as a Skip List - you can do this by using the ConcurrentSkipListMap possibly", "label": {"api": {"ConcurrentSkipListMap": [[76, 96]]}}}, {"text": "According to the Java API doc - This class (ConcurrentSkipListMap) implements a concurrent variant of SkipLists providing expected average log(n) time cost for the containsKey, get, put and remove operations and their variants", "label": {"api": {"ConcurrentSkipListMap": [[44, 64]]}}}, {"text": "You can get the Files variables from the Map.Entry using .getKey()", "label": {"api": {".getKey()": [[57, 65]]}}}, {"text": "From the javadoc of getOutputStream() in Socket", "label": {"api": {"javadoc of getOutputStream() in Socket": [[9, 46]]}}}, {"text": "The good news is that you can run compiler dynamically from Java using the Java Compiler API", "label": {"api": {"Java Compiler API": [[75, 91]]}}}, {"text": "Maybe you should use ExecutorService to handle the thread pool", "label": {"api": {"ExecutorService": [[21, 35]]}}}, {"text": "From the JComponent#setBorder() API", "label": {"api": {"JComponent#setBorder()": [[9, 30]]}}}, {"text": "I have been going through documentation of IdentityHashMap", "label": {"api": {"IdentityHashMap": [[43, 57]], "HashMap": [[51, 57]]}}}, {"text": "That class has a constructor which takes expectedmaxsize", "label": {"api": {"constructor": [[17, 27]]}}}, {"text": "On exploring further I found that user is expected to pass a good value of expectedmaxsize  so that IdentityHashMap is not resized as more elements are added", "label": {"api": {"IdentityHashMap": [[100, 114]], "HashMap": [[108, 114]]}}}, {"text": "Compare this with HashMap, with its constructor accepting initialCapacity", "label": {"api": {"constructor": [[36, 46]], "HashMap": [[18, 24]]}}}, {"text": "…and another constructor which accepts loadfactor and initialcapacity", "label": {"api": {"constructor": [[13, 23]]}}}, {"text": "…and here is HashMap there is no such guideline regarding initialcapacity", "label": {"api": {"HashMap": [[13, 19]]}}}, {"text": "So clearly there is a difference in the way size of internal array is managed in HashMap and IdentityHashMap", "label": {"api": {"IdentityHashMap": [[93, 107]], "HashMap": [[81, 87], [101, 107]]}}}, {"text": "Why can't IdentityHashMap provide a constructor same as HashMap", "label": {"api": {"IdentityHashMap": [[10, 24]], "constructor": [[36, 46]], "HashMap": [[18, 24], [56, 62]]}}}, {"text": "IdentityHashMap dates from JDK 1.4, whereas HashMap dates from JDK 1.2", "label": {"api": {"IdentityHashMap": [[0, 14]], "HashMap": [[8, 14], [44, 50]]}}}, {"text": "For reference, DefaultTableModel is a general purpose example, although you'll want to use something more recent than Vector internally", "label": {"api": {"DefaultTableModel": [[15, 31]]}}}, {"text": "Then you can use Runtime class for this", "label": {"api": {"Runtime": [[17, 23]]}}}, {"text": "The solution to this problem is not simply to enclose the values in quotes though, but rather to use prepared statements", "label": {"api": {"prepared statements": [[101, 119]]}}}, {"text": "If you want to add an existing collection to a Vector, you could use this", "label": {"api": {"add": [[15, 17]]}}}, {"text": "If you want to do it one by one, you need to iterate through the items, and call Vector's 'add' method", "label": {"api": {"add": [[91, 93]]}}}, {"text": "You can also use TimeUnit", "label": {"api": {"TimeUnit": [[17, 24]]}}}, {"text": "In Java so far, I have tried playing around with things such as QuadCurve2D.Double , Cub icCurve2D.Double and also Path2D.Double (using curveTo with Path2D.Double) but to no avail - the curves which are painted aren't even close to passing through the control point specified", "label": {"api": {"QuadCurve2D.Double": [[64, 81]], "Cub icCurve2D.Double": [[85, 104]], "Path2D.Double": [[115, 127], [149, 161]]}}}, {"text": "So I decided to use RoundingMode", "label": {"api": {"RoundingMode": [[20, 31]]}}}, {"text": "Instead of String#indexOf use String#matches method like this", "label": {"api": {"String#matches": [[30, 43]]}}}, {"text": "regex java.util.regex.Pattern \\b as shown by anubhava", "label": {"api": {"java.util.regex.Pattern": [[6, 28]]}}}, {"text": "You may replace } else if (indexfound < -1) { by } else { because java.lang.indexOf() return -1 when not found >-1 otherwise, < -1 does never occurs", "label": {"api": {"java.lang.indexOf()": [[66, 84]]}}}, {"text": "Graphics2D allows to set rendering hints", "label": {"api": {"rendering hints": [[25, 39]]}}}, {"text": "Try to experiment, there are various possible options and optimal values may depend on the selected font and other details", "label": {"api": {"various possible options": [[29, 52]]}}}, {"text": "If this is a user preference / config you can use the Preferences API", "label": {"api": {"Preferences": [[54, 64]]}}}, {"text": "Socket is not declared final, Socket.getInetAddress is not final, you may override it, even it's not a good idea..", "label": {"api": {"Socket": [[0, 5], [30, 35]], "Socket.getInetAddress": [[30, 50]]}}}, {"text": "You have to provide your own SocketFactory too", "label": {"api": {"Socket": [[29, 34]], "SocketFactory": [[29, 41]]}}}, {"text": "According to the JavaDoc for Deque, add/remove first and last are already supported", "label": {"api": {"JavaDoc for Deque": [[17, 33]]}}}, {"text": "You are able to use it when your argument list is the same as in required @FunctionalInterface, e.g", "label": {"api": {"@FunctionalInterface": [[74, 93]]}}}, {"text": "Runnable or Callable", "label": {"api": {"Runnable": [[0, 7]], "Callable": [[12, 19]]}}}, {"text": "Note the call to setLenient(), which is required, otherwise invalid input \"rolls over\" to the next available valid date - for example 36-12-2012 would be parsed as 05-01-2013", "label": {"api": {"setLenient()": [[17, 28]]}}}, {"text": "to really swap element of a list you should be using the set method of the List with something like that", "label": {"api": {"set": [[57, 59]]}}}, {"text": "viewport.setViewPosition( pt ); as shown here", "label": {"api": {"setViewPosition": [[9, 23]]}}}, {"text": "With Swing, the TextComponent and the underlaying model may help, giving you the start and the end indices of the current selection", "label": {"api": {"start": [[81, 85]], "end": [[95, 97]]}}}, {"text": "Note that String.format(\"%d %s\", num, stName) results in a string of the form \"[num] [street]\"", "label": {"api": {"String.format": [[10, 22]]}}}, {"text": "I find that String.format gives greater flexibility than string concatenation if you want to make changes in the future", "label": {"api": {"String.format": [[12, 24]]}}}, {"text": "As described on http://docs.oracle.com/javase/6/docs/api/java/text/DecimalFormat.html, you need two single quotes, one after the other", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/DecimalFormat.html": [[16, 84]]}}}, {"text": "You should use a BlockingQueue such as ArrayBlockingQueue, which is", "label": {"api": {"BlockingQueue": [[17, 29], [44, 56]], "ArrayBlockingQueue": [[39, 56]]}}}, {"text": "A bounded blocking queue backed by an array", "label": {"api": {"blocking queue": [[10, 23]]}}}, {"text": "Use the key codes in KeyEvent", "label": {"api": {"KeyEvent": [[21, 28]]}}}, {"text": "Examples would be when another thread manually interupts it or the process receives a SIGINT signal", "label": {"api": {"manually interupts it": [[38, 58]]}}}, {"text": "See Javadocs for Statement Interface it is clearly mentioned that executeQuery never returns null", "label": {"api": {"Statement Interface": [[17, 35]]}}}, {"text": "It's possible using a dynamic Proxy", "label": {"api": {"Proxy": [[30, 34]]}}}, {"text": "This works by simply creating a dynamic Proxy that is cast to the target type T", "label": {"api": {"Proxy": [[40, 44]]}}}, {"text": "That proxy uses an InvocationHandler that merely delegates all method calls to the proxy to given concrete instances", "label": {"api": {"InvocationHandler": [[19, 35]]}}}, {"text": "Alternatively, one can inspect all given instances to determine the common interfaces they all implement, and pass all those to newProxyInstance()", "label": {"api": {"Proxy": [[131, 135]]}}}, {"text": "In order to avoid ConcurrentModificationException, you need to use the Iterator interface directly", "label": {"api": {"ConcurrentModificationException": [[18, 48]]}}}, {"text": "use System.arraycopy() followed by setting the last element to zero", "label": {"api": {"System.arraycopy()": [[4, 21]]}}}, {"text": "Try adding a MediaTracker, add the image to the tracker and wait for the image to be fully loaded (using waitForAll or waitForID)", "label": {"api": {"MediaTracker": [[13, 24]]}}}, {"text": "Your Date object is correct", "label": {"api": {"Date": [[5, 8]]}}}, {"text": "Date contains information about the date", "label": {"api": {"Date": [[0, 3]]}}}, {"text": "What you are looking for is Container.getFocusTraversalKeys()", "label": {"api": {"Container.getFocusTraversalKeys()": [[28, 60]]}}}, {"text": "It uses the getMessages(int, int) method which allows you to retrieve a subset of all messages in the current Folder", "label": {"api": {"getMessages(int, int)": [[12, 32]]}}}, {"text": "If you then call waitfor() on the Process your thread will wait until the installer is finished", "label": {"api": {"waitfor()": [[17, 25]]}}}, {"text": "The HttpUrlConnection class supports proxies by using the proxy-related system settings", "label": {"api": {"proxy-related system settings": [[58, 86]]}}}, {"text": "You can, however, change the default proxy selection mechanism by calling ProxySelector.setDefault() and supplying your own ProxySelector subclass", "label": {"api": {"ProxySelector.setDefault()": [[74, 99]]}}}, {"text": "By overriding the select(URL) method, you can return the desired proxy for that URL", "label": {"api": {"select(URL)": [[18, 28]]}}}, {"text": "Check GridBagConstraint here in the fill - The initial fill value use GridBagConstraints.NONE", "label": {"api": {"GridBagConstraint": [[6, 22], [70, 86]]}}}, {"text": "You can use the BufferedReader", "label": {"api": {"BufferedReader": [[16, 29]]}}}, {"text": "or the scanner", "label": {"api": {"scanner": [[7, 13]]}}}, {"text": "You could iterate over map.entrySet(), appending the keys and values to the two lists", "label": {"api": {"map.entrySet()": [[23, 36]]}}}, {"text": "Use overloaded Arrays#toString(int[]) of Arrays which takes array as an argument", "label": {"api": {"Arrays#toString(int[])": [[15, 36]]}}}, {"text": "I would make \"myClass1\", \"myClass2\", and \"myClass3\" Serializable, then wrap myClass1List, myClass2List, and myClass3List (and any other data you want to save) in another serializable class so you can use serialization/deserialization to save and restore all of the program state at once", "label": {"api": {"Serializable": [[52, 63]]}}}, {"text": "Unless myMainClass is that wrapper, in which case you need to declare that they all implement Serializable", "label": {"api": {"Serializable": [[94, 105]]}}}, {"text": "extends T> coll, Comparator<", "label": {"api": {"Comparator": [[17, 26]]}}}, {"text": "You need to create a Comparator for you object first, and supply an instance of the comparator while calling the method", "label": {"api": {"Comparator": [[21, 30]]}}}, {"text": "What you probably want to do is create a javax.swing.Timer that fires every 100 ms and the timer instructs all of the circles to move", "label": {"api": {"javax.swing.Timer": [[41, 57]]}}}, {"text": "What you can do is that, set Thread.uncaughtExceptionhandler to every thread you start", "label": {"api": {"Thread.uncaughtExceptionhandler": [[29, 59]]}}}, {"text": "If you want to get synchronized version of your Hashmap then you can use the following inbuilt method of java.util.Collections class", "label": {"api": {"java.util.Collections": [[105, 125]]}}}, {"text": "Apart from that java.util.concurrent.ConcurrentHashMap is a better option for you", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[16, 53]]}}}, {"text": "You need to use CyclicBarrier", "label": {"api": {"CyclicBarrier": [[16, 28]]}}}, {"text": "CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other", "label": {"api": {"CyclicBarrier": [[0, 12]]}}}, {"text": "Object.wait and Object.notify/All are considered pretty low-level mechanisms for synchronization; most of the time, you'll want to use higher-level constructs like those found in java.util.concurrent or its sub-packages", "label": {"api": {"java.util.concurrent": [[179, 198]]}}}, {"text": "That's valid in Java 7 where Y means \"week year\" but it's not valid in Java 6 which doesn't support Y as a format specifier - only y", "label": {"api": {"Java 7": [[16, 21]], "Java 6": [[71, 76]]}}}, {"text": "The solution is to use a swing timer", "label": {"api": {"swing timer": [[25, 35]]}}}, {"text": "As a simple option, you could use String.replaceAll() as follows", "label": {"api": {"String.replaceAll()": [[34, 52]]}}}, {"text": "You should not implement Collections.sort(); this method is built-in to Java", "label": {"api": {"built-in to Java": [[60, 75]]}}}, {"text": "Call that method without supplying a Comparator to sort by the natural order, if it's Comparable", "label": {"api": {"Comparable": [[86, 95]], "Comparator": [[37, 46]]}}}, {"text": "Else, supply a Comparator to sort the Comparator's way", "label": {"api": {"Comparator": [[15, 24], [38, 47]]}}}, {"text": "You should have the class implement Comparable and provide a compareTo method if the class has a natural ordering, as indicated in the Comparable javadocs", "label": {"api": {"Comparable": [[36, 45], [135, 144]]}}}, {"text": "You should create a class that implements Comparator when you cannot make the class of the object to sort Comparable or when you want to present an ordering that is an alternative to the natural ordering, or when you want to impose an order when there is no natural ordering", "label": {"api": {"Comparable": [[106, 115]], "Comparator": [[42, 51]]}}}, {"text": "you could have a Comparator that sorts on lastName first, and another that sorts on firstName first", "label": {"api": {"Comparator": [[17, 26]]}}}, {"text": "Use String#equals to compare string values; the == operator compares object references for equality", "label": {"api": {"String#equals": [[4, 16]]}}}, {"text": "Look in the Scanner class", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "Don't forget to import java.util.Scanner", "label": {"api": {"Scanner": [[33, 39]]}}}, {"text": "The code will basically instantiate a new Scanner object, then Print out \"Input", "label": {"api": {"Scanner": [[42, 48]]}}}, {"text": "0 to 499), and then use Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[24, 44]]}}}, {"text": "A thread is only interrupted when someone calls its interrupt() method", "label": {"api": {"interrupt()": [[52, 62]]}}}, {"text": "If you never call interrupt(), and you're not working with a library that calls interrupt() (and that's something you'd expect would be spelled out), then you don't need to be checking for interruptions", "label": {"api": {"interrupt()": [[18, 28], [80, 90]]}}}, {"text": "For example, the locking mechanism wait() normally causes the thread to wait forever for notification, but another thread can interrupt to force the waiting thread to stop waiting (usually this would be to cancel the operation)", "label": {"api": {"wait()": [[35, 40]]}}}, {"text": "Sadly that tutorial is missing some code fixes that were introduced later in the TextFieldTableCell class for the ENTER to work properly (RT-34685 - Use onAction instead of onKeyPressed and RT-28132 - Call requestFocus())", "label": {"api": {"TextFieldTableCell": [[81, 98]]}}}, {"text": "Here is a working example, it's a reduced version of the TextFieldTableCell code which also uses Node.fireEvent() to move to the next cell after the commit (mimics a KeyPressed event)", "label": {"api": {"TextFieldTableCell": [[57, 74]], "Node.fireEvent()": [[97, 112]]}}}, {"text": "The example is using the class com.sun.net.httpserver.HttpServer", "label": {"api": {"com.sun.net.httpserver.HttpServer": [[31, 63]]}}}, {"text": "Example java.lang.Math class in Java", "label": {"api": {"java.lang.Math": [[8, 21]]}}}, {"text": "As java.lang.Math has all static methods which do similar job as your class they have declared the constructor as private so that nobody can accidentally create the instance of that class", "label": {"api": {"java.lang.Math": [[3, 16]]}}}, {"text": "Just use Arrays.sort()", "label": {"api": {"Arrays.sort()": [[9, 21]]}}}, {"text": "Why don't you convert your array into a List and use the remove(Object o) method that does exactly what you describe", "label": {"api": {"List": [[40, 43]], "remove(Object o)": [[57, 72]]}}}, {"text": "Take care to have the \"temporary\" and the \"final\" directory on the same filesystem; otherwise, File.renameTo() might or might not work", "label": {"api": {"File.renameTo()": [[95, 109]]}}}, {"text": "When using Java 7, Files.move() might be of better use", "label": {"api": {"Files.move()": [[19, 30]]}}}, {"text": "You can use a ReentrantLock", "label": {"api": {"ReentrantLock": [[14, 26]]}}}, {"text": "Java has a separate locking framework which can be found in the java.util.concurrent.locks package since Java 1.5", "label": {"api": {"java.util.concurrent.locks": [[64, 89]]}}}, {"text": "The standard way of achieving your goals is the Execute Around idiom, as used by javax.swing.text.AbstractDocument.render", "label": {"api": {"javax.swing.text.AbstractDocument.render": [[81, 120]]}}}, {"text": "You could use the java.util.UUID class for that", "label": {"api": {"java.util.UUID": [[18, 31]]}}}, {"text": "SimpleDateFormat this shows small m is for minute and capital M is for month so try changing it", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "In particular, see ExceptionRequest and ExceptionEvent", "label": {"api": {"ExceptionRequest": [[19, 34]], "ExceptionEvent": [[40, 53]]}}}, {"text": "You want the Thread.UncaughtExceptionHandler", "label": {"api": {"Thread.UncaughtExceptionHandler": [[13, 43]]}}}, {"text": "The shutDown() method simply prevents additional tasks from being scheduled", "label": {"api": {"shutDown()": [[4, 13]]}}}, {"text": "Instead, you could call shutDownNow() and check for thread interruption in your Runnable", "label": {"api": {"shutDownNow()": [[24, 36]]}}}, {"text": "Here is a link to the docs", "label": {"api": {"Here is a link": [[0, 13]]}}}, {"text": "According to the API documentation, SimpleDateFormat parses two digit year fields, so that the result is \"within 80 years before and 20 years after the time the SimpleDateFormat instance is created\"", "label": {"api": {"API documentation": [[17, 33]]}}}, {"text": "mm is minutes, MM is months", "label": {"api": {"mm is minutes, MM is months": [[0, 26]]}}}, {"text": "The Java Annotation interface does not extend Serializable", "label": {"api": {"Annotation interface": [[9, 28]]}}}, {"text": "This is what API says", "label": {"api": {"API says": [[13, 20]]}}}, {"text": "You may want to replace your int counter with an AtomicInteger counter - this way you can remove the synchronized keyword from the method, and it shouldn't matter if the method is a static or instance method", "label": {"api": {"AtomicInteger": [[49, 61]]}}}, {"text": "From JspContext#findAttribute (which is the method executed when using ${something})", "label": {"api": {"JspContext#findAttribute": [[5, 28]]}}}, {"text": "I found a class called CipherInputStream, which seems to do exactly what I'm looking for", "label": {"api": {"CipherInputStream": [[23, 39]], "Cipher": [[23, 28]]}}}, {"text": "Only thing is, I need a Cipher (and Provider) to specify the encryption method, and I don't know how to do that", "label": {"api": {"Cipher": [[24, 29]], "Provider": [[36, 43]]}}}, {"text": "Is it even possible to define a custom Provider", "label": {"api": {"Provider": [[39, 46]]}}}, {"text": "Rather than storing a reference to an object, store a WeakReference to the object - this way the garbage collector will free the object if the WeakReference is the only reference that remains", "label": {"api": {"WeakReference": [[54, 66], [143, 155]]}}}, {"text": "If each object is not equal to any other object (that is, if you haven't overridden Object.equals), you could use a WeakHashMap, with the objects as keys", "label": {"api": {"WeakHashMap": [[116, 126]]}}}, {"text": "If the class does override equals, you can create a collection of WeakReferences, which you can prune at convenient times (on insert, on retrieving the list, etc.)", "label": {"api": {"WeakReference": [[66, 78]]}}}, {"text": "A WeakReference will not prevent the object it refers to from being GCed -- it'll just return null from get after that GC has happened", "label": {"api": {"WeakReference": [[2, 14]]}}}, {"text": "java.lang.String has a nice method called replaceAll", "label": {"api": {"replaceAll": [[42, 51]]}}}, {"text": "Create a class for each pipeline component that implements Runnable", "label": {"api": {"Runnable": [[59, 66]]}}}, {"text": "Give each component a ConcurrentLinkedQueue to hold the data to be processed; each component will poll this queue in an infinite loop (in its run() method), processing the data as it pulls it off", "label": {"api": {"ConcurrentLinkedQueue": [[22, 42]]}}}, {"text": "Because you are going to be spawning multiple threads each with the capability of updating a single JTextArea you will need to be mindful of the a concept called the Event Queue", "label": {"api": {"JTextArea": [[100, 108]]}}}, {"text": "You need to call findExtension.find() first, otherwise findExtension.group() returns nothing", "label": {"api": {"findExtension.find()": [[17, 36]]}}}, {"text": "Use the DecimalFormat class to specify a format with commas", "label": {"api": {"DecimalFormat": [[8, 20]]}}}, {"text": "Your Ooops class needs to implement Comparable", "label": {"api": {"Comparable": [[36, 45]]}}}, {"text": "Alternatively, you need to pass a custom Comparator to the sort method", "label": {"api": {"Comparator": [[41, 50]]}}}, {"text": "I believe your problem may be that you are not shutting down the executor after your submit the job to it", "label": {"api": {"shutting down the executor": [[47, 72]]}}}, {"text": "You can use the getDeclaredField method, which will find the field if it's declared directly on the class, whether it's public or not", "label": {"api": {"getDeclaredField": [[16, 31]]}}}, {"text": "For example, this is what java.util.EnumMap does in one of its constructor", "label": {"api": {"java.util.EnumMap": [[26, 42]]}}}, {"text": "You can use matches", "label": {"api": {"matches": [[12, 18]]}}}, {"text": "Note that \\p{Alpha} matches any letter (a-z or A-Z), and hence \\p{Alpha}+ matches any continuous string of letters", "label": {"api": {"matches": [[20, 26], [74, 80]]}}}, {"text": "See the PriorityQueue javadoc", "label": {"api": {"the PriorityQueue javadoc": [[4, 28]]}}}, {"text": "Declare an interface like Comparable (http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html": [[38, 103]]}}}, {"text": "Check out StringBuilder", "label": {"api": {"StringBuilder": [[10, 22]]}}}, {"text": "It asks to use syntax valid for SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[32, 47]]}}}, {"text": "In Java you should use the String#equals method to compare string values instead of ==", "label": {"api": {"String#equals": [[27, 39]]}}}, {"text": "Using setAttribute() again will replace the value and call the necessary lifecycle methods", "label": {"api": {"replace the value": [[32, 48]]}}}, {"text": "You can also use removeAttribute() and set an attribute with the same name again", "label": {"api": {"removeAttribute()": [[17, 33]]}}}, {"text": "This is done by System.exit(status)", "label": {"api": {"System.exit(status)": [[16, 34]]}}}, {"text": "I'll assume that all of the XML strings you want to deserialize are in a ConcurrentLinkedQueue; alternatively, you can synchronize access to whatever non-threadsafe collection you're using", "label": {"api": {"ConcurrentLinkedQueue": [[73, 93]]}}}, {"text": "Use something like a ThreadPoolExecutor to minimize thread creation overhead", "label": {"api": {"ThreadPoolExecutor": [[21, 38]]}}}, {"text": "You know, Locale class has two functions getISOLanguages and getISOCountries that return an array of String with all the ISO languages and ISO countries, respectively", "label": {"api": {"Locale": [[10, 15]], "getISOLanguages": [[41, 55]], "getISOCountries": [[61, 75]]}}}, {"text": "Arrays.binarySearch or the ApacheCommons ArrayUtils.contains)", "label": {"api": {"Arrays.binarySearch": [[0, 18]]}}}, {"text": "You equals(Object o) comparison is correct", "label": {"api": {"equals(Object o)": [[4, 19]]}}}, {"text": "Yet, you should use after(Date d) and before(Date d) for date comparison", "label": {"api": {"after(Date d)": [[20, 32]], "before(Date d)": [[38, 51]]}}}, {"text": "It would only remained locked if the code join()d with the newly created thread, thus waiting for it to finish", "label": {"api": {"join()": [[42, 47]]}}}, {"text": "As there is no join() the lock will be released after the call to start() has completed", "label": {"api": {"join()": [[15, 20]]}}}, {"text": "The best approach I can see is having a ScheduledExecutorService in your class and submit the AI task to it", "label": {"api": {"ScheduledExecutorService": [[40, 63]]}}}, {"text": "What you want is use Future and ExecutorService", "label": {"api": {"Future": [[21, 26]], "ExecutorService": [[32, 46]]}}}, {"text": "Give a look at its javadoc, but with it you can calculate things async and wait for the result using Future#get()", "label": {"api": {"Future": [[101, 106]]}}}, {"text": "I'd suggest to use BreakIterator", "label": {"api": {"BreakIterator": [[19, 31]]}}}, {"text": "ColorSpace has the following serialized fields", "label": {"api": {"has the following serialized fields": [[11, 45]]}}}, {"text": "This will throw a MissingFormatArgumentException, prematurely ending your program after the adjective part is printed", "label": {"api": {"MissingFormatArgumentException": [[18, 47]]}}}, {"text": "You could use a ThreadPoolExecutor and a class that implements Runnable", "label": {"api": {"ThreadPoolExecutor": [[16, 33]], "Runnable": [[63, 70]]}}}, {"text": "String#split returns a String array", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "Tangentially, reflection can be used to identify them at runtime using Class.isAnonymousClass()", "label": {"api": {"Class.isAnonymousClass()": [[71, 94]]}}}, {"text": "The entry point for an applet is the init method", "label": {"api": {"init": [[37, 40]]}}}, {"text": "The first way is to use the InputStream.read() method to read one byte at a time", "label": {"api": {"InputStream.read()": [[28, 45]]}}}, {"text": "The second way is what has been done in the example code, using InputStream.read(byte[]) to read many bytes at once", "label": {"api": {"InputStream.read(byte[])": [[64, 87]]}}}, {"text": "When the button is clicked call execute", "label": {"api": {"execute": [[32, 38]]}}}, {"text": "Update the JLabel when done", "label": {"api": {"done": [[23, 26]]}}}, {"text": "An instance of javax.swing.text.Element represents a part of a structured Document, the model used by JTextComponent", "label": {"api": {"javax.swing.text.Element": [[15, 38]], "Document": [[74, 81]]}}}, {"text": "Read the configuration from an inputstream using readConfiguration(is)", "label": {"api": {"readConfiguration(is)": [[49, 69]]}}}, {"text": "First I would advice to use a StringBuilder to build your query String", "label": {"api": {"StringBuilder": [[30, 42]]}}}, {"text": "Note that it's not thread safe; if you need that, use StringBuffer", "label": {"api": {"StringBuffer": [[54, 65]]}}}, {"text": "Refactoring to a StringBuilder narrows it to 15 or 16 milliseconds", "label": {"api": {"StringBuilder": [[17, 29]]}}}, {"text": "Next, you could try using String formatting", "label": {"api": {"String formatting": [[26, 42]]}}}, {"text": "Instead, use a PreparedStatement and set the placeholders", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "Either Employee has to implement Comparable, or you need to provide a comparator when creating the TreeSet", "label": {"api": {"Comparable": [[33, 42]], "provide a comparator": [[60, 79]], "TreeSet": [[99, 105]]}}}, {"text": "This is spelled out in the documentation for SortedSet", "label": {"api": {"SortedSet": [[45, 53]]}}}, {"text": "All elements inserted into a sorted set must implement the Comparable interface (or be accepted by the specified comparator)", "label": {"api": {"Comparable": [[59, 68]]}}}, {"text": "According to the documentation of Pattern \\D is \"a non-digit\"", "label": {"api": {"the documentation of Pattern": [[13, 40]]}}}, {"text": "This allows for up to 32 states if represented by an int or 64 states if represented by a long; for more states (or for easier-to-use bitwise operations), use a BitSet", "label": {"api": {"BitSet": [[161, 166]]}}}, {"text": "I think it would be a better approach to use split method of String, just because it would be shorter", "label": {"api": {"split": [[45, 49]]}}}, {"text": "Easier would be to use the split() method which returns a string array, so basically the method will look like", "label": {"api": {"split() method": [[27, 40]]}}}, {"text": "Use StringBuilder instead of StringBuffer", "label": {"api": {"StringBuilder": [[4, 16]], "StringBuffer": [[29, 40]]}}}, {"text": "Checking Javadoc for 1.7, and yes, StringBuffer is there", "label": {"api": {"StringBuffer": [[35, 46]]}}}, {"text": "I don't know if this is beneficial, but if you can replace your LinkedHashMap with a ConcurrentHashMap then you'll improve your throughput - a ConcurrentHashMap uses sharding to permit multiple simultaneous readers and writers", "label": {"api": {"ConcurrentHashMap": [[85, 101], [143, 159]]}}}, {"text": "Barring that, replace your use of the synchronized keyword with a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[66, 78]]}}}, {"text": "Font class has several deriveFont methods to create fonts with different parameters, particularly font.deriveFont(12f) will create a font with size 12", "label": {"api": {"font.deriveFont(12f)": [[98, 117]]}}}, {"text": "I found a way to do it using the java.text.BreakIterator class", "label": {"api": {"java.text.BreakIterator": [[33, 55]]}}}, {"text": "Instead of the while true with thread sleep construct, provide the media player with an onReady handler and query and process the metadata when the player tells you it is ready", "label": {"api": {"onReady": [[88, 94]]}}}, {"text": "If no cell is selected then getSelectedXXX method will return -1", "label": {"api": {"getSelectedXXX": [[28, 41]]}}}, {"text": "After getting the row and the column call getValueAt method to get the value at that position", "label": {"api": {"getValueAt": [[42, 51]]}}}, {"text": "Take a look at the events you can see by calling JPopupMenu.addPopupMenuListener()", "label": {"api": {"JPopupMenu.addPopupMenuListener()": [[49, 81]]}}}, {"text": "In particular, you can get a popupMenuWillBecomeInvisible() call", "label": {"api": {"popupMenuWillBecomeInvisible()": [[29, 58]]}}}, {"text": "And then in your inner loop, replace g.drawLine() call simply with call to repaint()", "label": {"api": {"repaint()": [[75, 83]]}}}, {"text": "If so, just add a member variable, and set it to correct value before calling repaint()", "label": {"api": {"repaint()": [[78, 86]]}}}, {"text": "Once the user has selected a File, call JFileChooser.getSelectedFile() for the details", "label": {"api": {"JFileChooser.getSelectedFile()": [[40, 69]]}}}, {"text": "A more robust way to catch all uncaught exceptions is to setup a DefaultUncaughtExceptionHandler for your project, for example, at the start of your main, you can call", "label": {"api": {"DefaultUncaughtExceptionHandler": [[65, 95]]}}}, {"text": "Instead, I recommend using executor.awaitTermination(long timeout, TimeUnit unit) or at the very least have a Thread.sleep() in the loop", "label": {"api": {"executor.awaitTermination(long timeout, TimeUnit unit)": [[27, 80]]}}}, {"text": "You can also use awaitTermination() after the shutdown instead of the while loop", "label": {"api": {"awaitTermination()": [[17, 34]]}}}, {"text": "Format specifications for printf and printf-like methods take an optional width parameter", "label": {"api": {"printf": [[26, 31], [37, 42]]}}}, {"text": "Strings are immutable, so it is sufficient to simply copy the array, for example using the Arrays.copyOf() utility method", "label": {"api": {"Arrays.copyOf()": [[91, 105]]}}}, {"text": "As far as I understand we can use java.util.Arrays.copyOf to copy a two dimensional array, but is it safe to use it for defensive copying (assuming elements are immutable)", "label": {"api": {"java.util.Arrays.copyOf": [[34, 56]]}}}, {"text": "From the documentation for Field.set", "label": {"api": {"Field.set": [[27, 35]]}}}, {"text": "Better to use a Swing Timer if the scheduled code is modifying the GUI", "label": {"api": {"Timer": [[22, 26]]}}}, {"text": "Otherwise if you are using the non-Swing Timer than you need to shut it down with cancel()", "label": {"api": {"Timer": [[41, 45]], "cancel()": [[82, 89]]}}}, {"text": "You could use JFileChooser to let users select the files and then use an FTP client, such as Apache's FTPClient to upload items on some FTP server", "label": {"api": {"JFileChooser": [[14, 25]]}}}, {"text": "Look at the API documentation for java.lang.Class", "label": {"api": {"java.lang.Class": [[34, 48]]}}}, {"text": "As the release notes linked to above state, it can be set by Security.setProperty() or via the java.security file", "label": {"api": {"Security.setProperty()": [[61, 82]]}}}, {"text": "If you do not do this, you need to re-validate the layout as indicated in the javadoc of the Container#add method", "label": {"api": {"Container#add": [[93, 105]]}}}, {"text": "Actually, run() doesn't have a return type", "label": {"api": {"run()": [[10, 14]]}}}, {"text": "If that's what you want (again, why start a Thread?), you could use Thread.join()", "label": {"api": {"Thread.join()": [[68, 80]]}}}, {"text": "The problem is in the constructor for JScrollPane", "label": {"api": {"constructor": [[22, 32]]}}}, {"text": "Have a look at the documentation for Random class", "label": {"api": {"documentation for Random class": [[19, 48]]}}}, {"text": "Per Scanner.reset() javadoc, the method only \"resets\" locale, radix and delimiter settings", "label": {"api": {"Scanner.reset() javadoc": [[4, 26]]}}}, {"text": "Print takes a HashSet that contains all Foo objects that have been traversed", "label": {"api": {"HashSet": [[14, 20]]}}}, {"text": "Double#parseDouble(str) expects a string,and you are trying to pass a character", "label": {"api": {"Double#parseDouble(str)": [[0, 22]]}}}, {"text": "You could first split the input using String.split and then parse each variable using Double.parseDouble Double.parseDouble to read them into a Double variable", "label": {"api": {"String.split": [[38, 49]], "Double.parseDouble": [[86, 103], [105, 122]]}}}, {"text": "To limit access to the file system or any other resource, make use of Java's Security Manager", "label": {"api": {"Security Manager": [[77, 92]]}}}, {"text": "From the documentation of java.util.Timer class", "label": {"api": {"documentation of java.util.Timer class": [[9, 46]]}}}, {"text": "Since array is of type int[] and not Integer[], Arrays.asList() is of no help", "label": {"api": {"Arrays.asList()": [[48, 62]]}}}, {"text": "This gives a list, but not an ArrayList", "label": {"api": {"ArrayList": [[30, 38]]}}}, {"text": "What you get is similar to an ArrayList, but is fixed-size", "label": {"api": {"ArrayList": [[30, 38]]}}}, {"text": "For anyone on a project that might be restricted from using 3rd party libraries (licensing reasons, or whatever), Java itself provides at least a portion of this capability, since Java 1.6 (or earlier?), using the javax.xml.datatype.DatatypeFactory.newDuration(String) method and Duration class", "label": {"api": {"javax.xml.datatype.DatatypeFactory.newDuration(String)": [[214, 267]], "Duration": [[252, 259], [280, 287]]}}}, {"text": "The DatatypeFactory.newDuration(String) method will parse a string in \"PnYnMnDTnHnMnS\" format", "label": {"api": {"Duration": [[23, 30]]}}}, {"text": "If you have an option to do so, I suggest that you use an ArrayList instead of a vector - a vector is slower because it synchronizes all of its methods, which is usually overkill", "label": {"api": {"ArrayList": [[58, 66]]}}}, {"text": "To get a Set with the Map entries, you just call Map#entrySet()", "label": {"api": {"Map#entrySet()": [[49, 62]]}}}, {"text": "Everytime you have hard work with Strings, use StringBuilder or StringBuffer to achieve better performance", "label": {"api": {"StringBuilder": [[47, 59]], "StringBuffer": [[64, 75]]}}}, {"text": "You can make a utility function that uses the reflection counterpart of instanceof, Class.isInstance()", "label": {"api": {"Class.isInstance()": [[84, 101]]}}}, {"text": "You need your CastleDefenders class to implement the ActionListener interface if you want it to listen to action events", "label": {"api": {"ActionListener": [[53, 66]]}}}, {"text": "A better solution if you're using multiple producers is to use a ConcurrentLinkedQueue, which is a thread-safe queue", "label": {"api": {"ConcurrentLinkedQueue": [[65, 85]]}}}, {"text": "Math.random() produces a random floating point number between 0 and 1 (not including 1)", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "The objects calling writeObject must implement the Serializable interface (reference)", "label": {"api": {"reference": [[75, 83]]}}}, {"text": "If you want to display the string array, you should use", "label": {"api": {"use": [[52, 54]]}}}, {"text": "Because when you print splitCancer you'll get the address of the array and not the content of it", "label": {"api": {"use": [[4, 6]]}}}, {"text": "You can use Collection#iterator", "label": {"api": {"Collection#iterator": [[12, 30]]}}}, {"text": "I would try using SwingWorker instead", "label": {"api": {"SwingWorker": [[18, 28]]}}}, {"text": "I recommend using a ConcurrentLinkedQueue in Bookshelf instead of a synchronized list - it's lock free (doesn't need to be synchronized) and will probably be more efficient", "label": {"api": {"ConcurrentLinkedQueue": [[20, 40]]}}}, {"text": "Take a look at the related intern() method on String", "label": {"api": {"intern()": [[27, 34]]}}}, {"text": "You are using an ObjectOutputStream which is used to send serialized Objects and must be decoded by an ObjectInputStream on the other end", "label": {"api": {"ObjectOutputStream": [[17, 34]]}}}, {"text": "You want the Arrays.deepToString method", "label": {"api": {"Arrays.deepToString": [[13, 31]]}}}, {"text": "Comparable is an interface, and as such it contains no logic", "label": {"api": {"Comparable": [[0, 9]]}}}, {"text": "A concrete class with implement Comparable must implement the .compareTo() method, as detailed here", "label": {"api": {"Comparable": [[32, 41]]}}}, {"text": "If you want a variable-size JList, you should initialize it with JList(ListModel), using a list model that allows adding new elements to the list (like DefaultListModel)", "label": {"api": {"DefaultListModel": [[152, 167]]}}}, {"text": "You should use the JarFile API and iterate over the files in it", "label": {"api": {"JarFile": [[19, 25]]}}}, {"text": "Use the FileWriter(String, boolean) constructor in order to append the input instead of rewriting the entire file", "label": {"api": {"FileWriter(String, boolean)": [[8, 34]]}}}, {"text": "I have used the binarySearch on array of BigInteger, I tested with a few numbers, seems working fine", "label": {"api": {"binarySearch": [[16, 27]]}}}, {"text": "If you have an object/reference with Type Class<com.google.googlemaps.exampleClass> (Class c) you can call getMethod to get the Method object", "label": {"api": {"getMethod": [[107, 115]]}}}, {"text": "And then you could call invoke method to invoke the method", "label": {"api": {"invoke": [[24, 29], [41, 46]]}}}, {"text": "You can use a ConcurrentSkipListSet or ConcurrentHashMap to track which PDFs have been processed (and are presumably cached) or are currently being processed", "label": {"api": {"ConcurrentSkipListSet": [[14, 34]], "ConcurrentHashMap": [[39, 55]]}}}, {"text": "Use a ConcurrentLinkedQueue for your PDF-to-image requests; when a worker thread pulls a request off of the queue it adds it to the Set/Map, if the add succeeds then the thread processes the request, if the add fails then the request was already in the container", "label": {"api": {"ConcurrentLinkedQueue": [[6, 26]]}}}, {"text": "If you however use Class objects then I would recommend implementing your own Transferable to create the DataFlavor you showed above, since the human readable string portion is completely arbitrary for non-stock flavors", "label": {"api": {"Class objects": [[19, 31]], "Transferable": [[78, 89]]}}}, {"text": "Or you can use ArrayList instead array", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "You can use Collections.min and List.indexOf", "label": {"api": {"Collections.min": [[12, 26]], "List.indexOf": [[32, 43]]}}}, {"text": "You're supposed to call the \"set\" methods of the PreparedStatement", "label": {"api": {"\"set\" methods of the PreparedStatement": [[28, 65]]}}}, {"text": "The BufferedReader class has a ready() method that returns True if \"the buffer is not empty, or if the underlying character stream is ready.\" and False otherwise", "label": {"api": {"ready()": [[31, 37]]}}}, {"text": "So the input.ready() check should result in fewer exceptions", "label": {"api": {"ready()": [[13, 19]]}}}, {"text": "You can't remove an item from a collection you're iterating over except using Iterator.remove - you'll get a ConcurrentModificationException", "label": {"api": {"Iterator.remove": [[78, 92]]}}}, {"text": "Make a new Thead instead", "label": {"api": {"Thead": [[11, 15]]}}}, {"text": "Check the CyclicBarrier ,this may help you", "label": {"api": {"CyclicBarrier": [[10, 22]]}}}, {"text": "The contract on equals() has the following among its requirements", "label": {"api": {"The contract on equals() has the following among its requirements": [[0, 64]], "requirement": [[53, 63]]}}}, {"text": "It is clear that your proposed comparison scheme would break the transitivity requirement (x equals y and y equals z, yet x doesn't equal z)", "label": {"api": {"requirement": [[78, 88]]}}}, {"text": "Furthermore, hashCode() will produce additional challenges, due to the following requirement", "label": {"api": {"requirement": [[81, 91]]}}}, {"text": "The hashCode() requirement can be sidestepped by using a TreeSet instead of HashSet", "label": {"api": {"requirement": [[15, 25]]}}}, {"text": "Method.getReturnType() and Method.getGenericReturnType()", "label": {"api": {"Method.getReturnType()": [[0, 21]], "Method.getGenericReturnType()": [[27, 55]]}}}, {"text": "You need to set the preferred size for your JPanel, otherwise the JScrollPane does not know how big is the component it needs to support with its scroll bars", "label": {"api": {"set the preferred size": [[12, 33]]}}}, {"text": "Detailed information is on this page", "label": {"api": {"this page": [[27, 35]]}}}, {"text": "You can try to bind a listener to the stages widthProperty and wait for changes that actually contain numbers", "label": {"api": {"widthProperty": [[45, 57]]}}}, {"text": "It takes either an InputStream, URL, or File, which I demonstrated above", "label": {"api": {"InputStream": [[19, 29]], "URL": [[32, 34]], "File": [[40, 43]]}}}, {"text": "You can create a class that implements either the Iterator or ListIterator interfaces and then override the hasNext() method", "label": {"api": {"Iterator": [[50, 57], [66, 73]], "ListIterator": [[62, 73]], "hasNext()": [[108, 116]]}}}, {"text": "The ServerSocket functionality can be managed in doInBackground", "label": {"api": {"doInBackground": [[49, 62]]}}}, {"text": "While Scanner#toString() does return a string, it does not give you anything related to what the user typed in", "label": {"api": {"Scanner#toString()": [[6, 23]]}}}, {"text": "Use Scanner#next() or Scanner#nextLine(), not Scanner#toString()", "label": {"api": {"Scanner#toString()": [[46, 63]], "Scanner#next()": [[4, 17]], "Scanner#nextLine()": [[22, 39]]}}}, {"text": "You want to use Scanner.next() or Scanner.nextLine() to retrieve the input from the end user", "label": {"api": {"Scanner.next()": [[16, 29]], "Scanner.nextLine()": [[34, 51]]}}}, {"text": "Because the add method you used inserts an element at specified index", "label": {"api": {"add method": [[12, 21]]}}}, {"text": "If you need to replace the value, use the set method", "label": {"api": {"set method": [[42, 51]]}}}, {"text": "The Desktop class allows a Java application to launch associated applications registered on the native desktop to handle a URI or a file", "label": {"api": {"Desktop": [[4, 10]]}}}, {"text": "Simply open your log file in append mode, like following", "label": {"api": {"append mode": [[29, 39]]}}}, {"text": "Another option is that internally the scanner uses a regular expression to retrieve a double-string and then uses Double.parseDouble to convert it to a double, so you could call Scanner#next(Pattern pattern) using the regular expression defined here except using \"nan\" instead of \"NaN\" and then call Double.parseDouble on the returned string", "label": {"api": {"defined here": [[237, 248]]}}}, {"text": "You want to use append, not setText", "label": {"api": {"use append": [[12, 21]]}}}, {"text": "To be able to compare any comparable type of object (I take your E to imply that your tokens indeed implement Comparable, since otherwise your question makes no sense,) you can use compareTo()", "label": {"api": {"Comparable": [[110, 119]], "compareTo()": [[181, 191]]}}}, {"text": "Condition#signalAll() only signals threads that are currently in Condition#await() (or its friends), i.e", "label": {"api": {"Condition#signalAll()": [[0, 20]], "Condition#await()": [[65, 81]]}}}, {"text": "Here is a version using a Semaphore that might be a little closer in intent to your original implementation", "label": {"api": {"Semaphore": [[26, 34]]}}}, {"text": "The javadoc for Math.atan(double) says that the returning value can range from -pi/2 to pi/2.So you need to compensate for that return value", "label": {"api": {"Math.atan(double)": [[16, 32]]}}}, {"text": "We also want to get rid of any white space in the string, as that can cause errors on validation - we use replaceAll(\"\\\\s\", \"\") to solve that", "label": {"api": {"replaceAll(\"\\\\s\", \"\")": [[106, 126]]}}}, {"text": "Look at Socket.getInetAddress() and Socket.getPort()", "label": {"api": {"Socket.getInetAddress()": [[8, 30]], "Socket.getPort()": [[36, 51]]}}}, {"text": "go for HashSet.It will store unique values.As from comments here, you have to override the hashcode and equals methods to provide uniqueness of every object.You can read relation between these two methods here", "label": {"api": {"HashSet": [[7, 13]]}}}, {"text": "You are looking for a Set and one of its implementations", "label": {"api": {"Set": [[22, 24]]}}}, {"text": "Use String.trim() to remove surrounding whitespace and then use String.equals() (not ==, See 15.21 Equality Operators in the Java Language Specification for full details.)", "label": {"api": {"String.trim()": [[4, 16]]}}}, {"text": "Remember that String instances are immutable so String.trim() returns a new String and it is that which must be used in the equals() check", "label": {"api": {"String.trim()": [[48, 60]]}}}, {"text": "The TableView class of JavaFX 2.2 has a generic type S, I am wondering how one can set this from FXML", "label": {"api": {"TableView": [[4, 12]]}}}, {"text": "You can use int read() method of BufferedReader which return  single character each time", "label": {"api": {"int read()": [[12, 21]]}}}, {"text": "Use a SwingWorker to split UI-update and long running tasks", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "TreeMap has a constructor where you can pass in your custom Comparator", "label": {"api": {"TreeMap has a constructor where you can pass in your custom Comparator": [[0, 69]]}}}, {"text": "To convert a byte array to a double, use a ByteBuffer, see this question for example code", "label": {"api": {"ByteBuffer": [[43, 52]]}}}, {"text": "That's because String.indexOf(char) returns the index of the first match, so startSpace and endSpace have the same value", "label": {"api": {"returns the index of the first match": [[36, 71]]}}}, {"text": "As an alternative to using the indexOf take a look at the String.split method", "label": {"api": {"String.split": [[58, 69]]}}}, {"text": "You should instead use the generic version of toArray, which should work better", "label": {"api": {"the generic version of toArray": [[23, 52]]}}}, {"text": "Since you're using a Container to add your JPanels to, you have the removeAll method available", "label": {"api": {"Container": [[21, 29]], "removeAll": [[68, 76]]}}}, {"text": "You're adding the components to your container, so I'd assume that you would need to remove all components from this Container, then add the new components, and refresh it", "label": {"api": {"Container": [[117, 125]]}}}, {"text": "From the docs of java.util.Date", "label": {"api": {"java.util.Date": [[17, 30]]}}}, {"text": "Looking at the Javadoc for currentTimeMillis(), it referes to the documentation of the Date class, which has this to say", "label": {"api": {"documentation of the Date class": [[66, 96]]}}}, {"text": "If you look at the API for Class.getResource(), you'll see that it returns null if this file doesn't exist", "label": {"api": {"getResource()": [[33, 45]]}}}, {"text": "You can implement a CallbackHandler", "label": {"api": {"CallbackHandler": [[20, 34]]}}}, {"text": "You can set a self written stream class as error stream at the very start of the program and easily put breakpoints into that class", "label": {"api": {"as error stream": [[40, 54]]}}}, {"text": "If you just want to preserve a particular ordering though, you can always use a LinkedHashMap and just insert the entries in that order", "label": {"api": {"LinkedHashMap": [[80, 92]]}}}, {"text": "That said, it seems to be a easier way to do this kind of job by using the JAVA's replaceAll method, typically for the two-letter words", "label": {"api": {"replaceAll": [[82, 91]]}}}, {"text": "Take a look at the Collections.disjoint method", "label": {"api": {"Collections.disjoint": [[19, 38]]}}}, {"text": "Like TofuBeer said, take a look at Collections.disjoint (I'd upvote his if I had any reputation...)", "label": {"api": {"Collections.disjoint": [[35, 54]]}}}, {"text": "I use Book class to provide different orientation to pages when printing PDF document", "label": {"api": {"Book": [[6, 9]]}}}, {"text": "But when I use Book class prints only first page", "label": {"api": {"Book": [[15, 18]]}}}, {"text": "But  Book#getNumberOfPages return me 4", "label": {"api": {"Book": [[5, 8]]}}}, {"text": "If you want to get a different textual representation as a string, I suggest you use toGregorianCalendar() to get a java.util.Calendar - then you can get the java.util.Date and use an appropriately constructed SimpleDateFormat to do the formatting", "label": {"api": {"toGregorianCalendar()": [[85, 105]]}}}, {"text": "A workaround without external libraries could be done with a LinkedList", "label": {"api": {"LinkedList": [[61, 70]]}}}, {"text": "then poll in a loop until the thread gets in TIMED_WAITING state", "label": {"api": {"TIMED_WAITING": [[45, 57]]}}}, {"text": "You need to call DatagramSocket.receive, and then use the length of the received data when constructing a ByteArrayInputStream", "label": {"api": {"DatagramSocket.receive": [[17, 38]]}}}, {"text": "The invokeAll method on ExecutorService can be used to automatically cancel tasks that exceed the timeout", "label": {"api": {"invokeAll": [[4, 12]]}}}, {"text": "in Perl that actually does the file processing and call that script from your Java code using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[94, 107]]}}}, {"text": "Have a look at this PrinterStateReason", "label": {"api": {"PrinterStateReason": [[20, 37]]}}}, {"text": "And also javax.print", "label": {"api": {"javax.print": [[9, 19]]}}}, {"text": "According to the documentation, weak references will be cleared when the object is garbage collected", "label": {"api": {"According to the documentation": [[0, 29]]}}}, {"text": "As said in the documenation of the FileWriter constructor the second argument specify if you want to append or not", "label": {"api": {"FileWriter constructor": [[35, 56]]}}}, {"text": "Read more on Java regex here", "label": {"api": {"Java regex here": [[13, 27]]}}}, {"text": "If not, then you should just be able to use a Semaphore with 1 permit to protect the write permission", "label": {"api": {"Semaphore": [[46, 54]]}}}, {"text": "If you still want to track how many reads are happening without the ability to prevent any, you can always count how many reads are in flight with an AtomicInteger", "label": {"api": {"AtomicInteger": [[150, 162]]}}}, {"text": "nextInt doesn't read the following new-line character, so the first nextLine (which returns the rest of the current line) will always return an empty string", "label": {"api": {"which returns the rest of the current line": [[78, 119]]}}}, {"text": "A faster way would be to insert directly at the beginning of the vector, using .add(int, E)..", "label": {"api": {".add(int, E)": [[79, 90]]}}}, {"text": "You can use the Vector#add(index, element) method", "label": {"api": {"Vector#add(index, element)": [[16, 41]]}}}, {"text": "See documentation of Comparable", "label": {"api": {"documentation of Comparable": [[4, 30]]}}}, {"text": "AbstractTableModel is an abstract implementation that provides the event plumbing and leaves just three methods that must be overridden", "label": {"api": {"three methods": [[98, 110]]}}}, {"text": "It looks like you might be using interrupt() incorrectly", "label": {"api": {"interrupt()": [[33, 43]]}}}, {"text": "After calling user.interrupt(), it's up to that thread to check that it has been interrupted by calling Thread.interrupted() and terminate itself if true", "label": {"api": {"interrupt()": [[19, 29]], "Thread.interrupted()": [[104, 123]]}}}, {"text": "Recently I used a Task in one of my programs", "label": {"api": {"Task": [[18, 21]]}}}, {"text": "Basically one can say that the code included in the Task is executed in another thread", "label": {"api": {"Task": [[52, 55]]}}}, {"text": "Use InetAddress.getByName() to create an InetAddress from a string (make sure the string is the host-name of the website)", "label": {"api": {"InetAddress.getByName()": [[4, 26]]}}}, {"text": "This can be achieved in Java using the UUID implementation", "label": {"api": {"implementation": [[44, 57]]}}}, {"text": "DataInputStream.readUTF() expects the first two bytes to be the number of bytes to read, but PrintStream.print(String) will convert the string to bytes and write them as-is", "label": {"api": {"DataInputStream.readUTF()": [[0, 24]], "PrintStream.print(String)": [[93, 117]]}}}, {"text": "DataOutputStream.writeUTF(String) will write the length like readUTF() expects", "label": {"api": {"DataOutputStream.writeUTF(String)": [[0, 32]]}}}, {"text": "Easy enough to convert though, simply by using the appropriate String ctor", "label": {"api": {"String ctor": [[63, 73]]}}}, {"text": "You can convert ArrayList to Object[] if needed using List.toArray(), ie", "label": {"api": {"List.toArray()": [[54, 67]]}}}, {"text": "Using DefaultListModel's addElement is relatively slow for models holding around 200 or more items", "label": {"api": {"addElement": [[25, 34]]}}}, {"text": "Passing in an array of Object to JList(E[] listData) is faster than adding the elements individually using a DefaultListModel as a new AbstractListModel is created based on the List elements", "label": {"api": {"JList(E[] listData)": [[33, 51]]}}}, {"text": "First, you can use Comparable Interface, which means that the method should be changed into", "label": {"api": {"Comparable": [[19, 28]]}}}, {"text": "Second, you can implement a Comparator to judge which is bigger", "label": {"api": {"Comparator": [[28, 37]]}}}, {"text": "If you don't want the object to be comparable, which means you don't want to change the existing code to let it implement Comparable, this is a better way", "label": {"api": {"Comparable": [[122, 131]]}}}, {"text": "Here is the javadoc of Comparable and Comparator", "label": {"api": {"Comparable": [[23, 32]], "Comparator": [[38, 47]]}}}, {"text": "If you use a ScheduledExecutorService then you just execute Runnable objects, rather than TimerTask objects", "label": {"api": {"ScheduledExecutorService": [[13, 36]]}}}, {"text": "That's because the argument to split() is a regex not a string", "label": {"api": {"split()": [[31, 37]]}}}, {"text": "As you can see in the summary of Java regular expression constructs, the | functions as an or construct", "label": {"api": {"summary of Java regular expression constructs": [[22, 66]]}}}, {"text": "The problem is that the split(String regex) takes a regular expression as argument", "label": {"api": {"split(String regex)": [[24, 42]]}}}, {"text": "See the API", "label": {"api": {"See the API": [[0, 10]]}}}, {"text": "Because this is intended to be a cache, you may want to store your keys and values within SoftReferences - this will allow the garbage collector to free them if you would otherwise encounter an OutOfMemoryError", "label": {"api": {"SoftReferences": [[90, 103]]}}}, {"text": "No you don't need the lock when calling ExecutorService#submit", "label": {"api": {"ExecutorService#submit": [[40, 61]]}}}, {"text": "or when calling Executor#execute", "label": {"api": {"Executor#execute": [[16, 31]]}}}, {"text": "If you want to print a document five times, I suppose you have to create a PrintRequestAttributeSet and put a Copies attribute in that with the number of copies you want to have", "label": {"api": {"PrintRequestAttributeSet": [[75, 98]], "Copies": [[110, 115]]}}}, {"text": "Supply this PrintRequestAttributeSet as the second attribute to your printJob.print(...) call and it should be fine", "label": {"api": {"PrintRequestAttributeSet": [[12, 35]]}}}, {"text": "Not to mention the memory allocation of an array for each call to toByteArray (which \"Creates a newly allocated byte array\" for each call)", "label": {"api": {"\"Creates a newly allocated byte array\"": [[85, 122]]}}}, {"text": "Then sort the Map (use Sorted Map or a Comparator to sort on the Map keys) on keys and you will get what you want", "label": {"api": {"Sorted Map": [[23, 32]], "Comparator": [[39, 48]]}}}, {"text": "Instead of storing an Array of an Array, why don't you create a custom Class that implements Comparable", "label": {"api": {"Comparable": [[93, 102]]}}}, {"text": "Use an ArrayList if possible, it will dynamically grow to fit its data", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "If you need to use an array, then you'll need to allocate a new (larger) array, and then use System.arraycopy to copy over the old array's contents", "label": {"api": {"System.arraycopy": [[93, 108]]}}}, {"text": "I believe that ImageIO.getImageReaders() expects an ImageInputStream, you can try to create one from your InputStream using createImageInputStream", "label": {"api": {"ImageIO.getImageReaders()": [[15, 39]], "createImageInputStream": [[124, 145]]}}}, {"text": "The image metadata is generally (and specifcally in IIOMetadata) understood to be additional \"miscelanous\" data (as physical resolution, timestamp) which is normally not needed to access the image data", "label": {"api": {"IIOMetadata": [[52, 62]]}}}, {"text": "Scanner is not the appropriate utility to retrieve patterns using its hasNext(Pattern pattern) method", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "Java API is the best document", "label": {"api": {"Java API": [[0, 7]]}}}, {"text": "So if you change the input to be delimited by space or any other delimiter ( other delimiters have to be set after defining the Scanner object ) , it will work", "label": {"api": {"Scanner": [[128, 134]]}}}, {"text": "Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "Use a SecureRandom, if you like, for extra safety", "label": {"api": {"SecureRandom": [[6, 17]]}}}, {"text": "API's and functions related to cryptology are present in javax.crypto, not java.security", "label": {"api": {"javax.crypto": [[57, 68]], "java.security": [[75, 87]]}}}, {"text": "You can use ZipInputStream and ZipOutputStream for example to achieve this goal", "label": {"api": {"ZipInputStream": [[12, 25]], "ZipOutputStream": [[31, 45]]}}}, {"text": "Furthermore classes related to ZipFile and ZipEntry can be of help", "label": {"api": {"ZipFile": [[31, 37]], "ZipEntry": [[43, 50]]}}}, {"text": "For reading a file that is in abc.jar, you can use ClassLoader.getResource(), but I don't think Java provides a similar facility for adding a file to a jar (for security purposes)", "label": {"api": {"ClassLoader.getResource()": [[51, 75]]}}}, {"text": "Make the url string configurable, for example via properties file, which you can easily access with the help of java Properties", "label": {"api": {"Properties": [[117, 126]]}}}, {"text": "Calling the close method of the Scanner class will also close the stream that the scanner was reading from", "label": {"api": {"close method of the Scanner class": [[12, 44]]}}}, {"text": "Set doesn't contain duplicates", "label": {"api": {"Set": [[0, 2]]}}}, {"text": "If you are using JAXB, you could use Unmarshaller.Listener.afterUnmarshal to get ahold of an object after it has been unmarshalled from XML", "label": {"api": {"Unmarshaller.Listener.afterUnmarshal": [[37, 72]]}}}, {"text": "This Listener interface is not specific to CXF, and there is a corresponding Marshaller.Listener interface", "label": {"api": {"Marshaller.Listener": [[77, 95]]}}}, {"text": "You should simply call String.replace(), which does literal replacements without using regexes", "label": {"api": {"String.replace()": [[23, 38]]}}}, {"text": "Maybe look into using a data structure that keeps its elements sorted on its own, such as a TreeSet", "label": {"api": {"TreeSet": [[92, 98]]}}}, {"text": "According to the Javadoc for newInstance(), the system property I'm setting should overrule all other methods of identifying which TransformerFactory to use, so precedence is not the issue", "label": {"api": {"the Javadoc for newInstance()": [[13, 41]]}}}, {"text": "All of the java.util.Map classes include a put(K key, V value) method that allows you to provide a key via which you can later retrieve the object", "label": {"api": {"put(K key, V value) method": [[43, 68]]}}}, {"text": "Arrays#asList creates an unmodifiable list", "label": {"api": {"Arrays#asList": [[0, 12]]}}}, {"text": "I see that the interface DataInput has a method readUTF() to read a String, but it uses UTF-8 format", "label": {"api": {"DataInput": [[25, 33]]}}}, {"text": "Look at the example given for GroupLayout (picture from the link)", "label": {"api": {"GroupLayout": [[30, 40]]}}}, {"text": "JComboBox<Object> is a JComboBox which can be filled with Objects", "label": {"api": {"JComboBox": [[0, 8], [23, 31]]}}}, {"text": "std::make_heap makes a binary heap, which is used as a priority-queue and is called PriorityQueue in Java", "label": {"api": {"PriorityQueue": [[84, 96]]}}}, {"text": "Pass the char to Character.toString(char) to convert it to a String", "label": {"api": {"Character.toString(char)": [[17, 40]]}}}, {"text": "You might also want to check the methods getReceiveBufferSize() and setReceiveBufferSize() if you're having trouble receiving packets - if the buffer size is smaller than the packet size, it's not guaranteed that you can receive the packet", "label": {"api": {"getReceiveBufferSize()": [[41, 62]], "setReceiveBufferSize()": [[68, 89]]}}}, {"text": "Use the JavaCompiler for this", "label": {"api": {"JavaCompiler": [[8, 19]]}}}, {"text": "I think the trick will be to define a custom JavaFileManager", "label": {"api": {"JavaFileManager": [[45, 59]]}}}, {"text": "Use this comparing method as the comparator for sort(List list,                           Comparator c)", "label": {"api": {"sort(List list,                           Comparator c)": [[48, 102]]}}}, {"text": "You'd be better off just delegating to Integer.compare if you're using Java 7", "label": {"api": {"Integer.compare": [[39, 53]]}}}, {"text": "9813023219 is an invalid Integer as it is greater than Integer.MAX_VALUE, which is 2147483647", "label": {"api": {"Integer.MAX_VALUE": [[55, 71]], "MAX_VALUE": [[63, 71]]}}}, {"text": "Use Long instead, who's MAX_VALUE is 9223372036854775807", "label": {"api": {"Long": [[4, 7]], "MAX_VALUE": [[24, 32]]}}}, {"text": "To capture the output (unintuitively) use Process.getInputStream() (an instance of Process is returned by Runtime.exec())", "label": {"api": {"Process.getInputStream()": [[42, 65]]}}}, {"text": "For the second error, if you take a look at the class Math,  pi() does not exist, you have to call the static variable of the class Math, so it should be", "label": {"api": {"Math": [[54, 57], [132, 135]]}}}, {"text": "As dot is \"Any character\" in regex", "label": {"api": {"regex": [[29, 33]]}}}, {"text": "String.split by default merges duplicate separators into one", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "Instead use Iterator#remove() to remove an item from List", "label": {"api": {"Iterator#remove()": [[12, 28]]}}}, {"text": "Similar to how Files.walkFileTree works with FileVisitor", "label": {"api": {"Files.walkFileTree": [[15, 32]], "FileVisitor": [[45, 55]]}}}, {"text": "If you are using Java 7, and your application is actually walking a file tree, you should use the NIO.2 API to walk the file tree", "label": {"api": {"NIO.2 API": [[98, 106]]}}}, {"text": "Here, the interface to be implemented is the FileVisitor interface declared by the core Java libraries", "label": {"api": {"FileVisitor": [[45, 55]]}}}, {"text": "To be more specific, I believe they'll either ConnectTimeoutExceptions if the connection can't be set up within your configured connection timeout, or SocketTimeoutExceptions, if it's set up but no data is received for your configured SO timeout", "label": {"api": {"SocketTimeoutExceptions": [[151, 173]]}}}, {"text": "Reading Oracle's JButton and \"How to use Radio Buttons\" documentation and tutorials, it appears that I need to apply a ButtonGroup to my JRadioButtons, which automatically groups them with a select-one-and-only-one relationship", "label": {"api": {"Oracle's JButton": [[8, 23]]}}}, {"text": "To limit the underlying query ResultSet size, the JPA Query interface provides the setMaxResults method", "label": {"api": {"setMaxResults method": [[83, 102]]}}}, {"text": "For this purpose, the JPA Query interface provides the setFirstResult method", "label": {"api": {"setFirstResult method": [[55, 75]]}}}, {"text": "Just remove it by calling PriorityQueue.remove(Object obj)", "label": {"api": {"PriorityQueue.remove(Object obj)": [[26, 57]]}}}, {"text": "And the hashCode method doesn't return the address in String, because that class has overridden hashCode", "label": {"api": {"overridden hashCode": [[85, 103]]}}}, {"text": "Additionally, the equals method has been implemented in String to compare the contents of the strings; that's why a.equals(b) returns true here", "label": {"api": {"equals": [[18, 23], [116, 121]]}}}, {"text": "Please see the \"Argument Index\" section of the Formatter javadocs for details", "label": {"api": {"Formatter": [[47, 55]]}}}, {"text": "Maybe you could use the toArray method", "label": {"api": {"toArray": [[24, 30]]}}}, {"text": "If you need to know is object already in persistence context you should use contains method of EntityManager", "label": {"api": {"contains method": [[76, 90]]}}}, {"text": "Here you can check javadoc for contains method", "label": {"api": {"contains method": [[31, 45]]}}}, {"text": "You can get the actual file system path of a web resource by using ServletContext.getRealPath() method", "label": {"api": {"ServletContext.getRealPath()": [[67, 94]]}}}, {"text": "The main problem I see is that interrupted() will reset the interrupt-flag (see linked doc), meaning the next call to interrupted() will return false unless it has been interrupted again", "label": {"api": {"interrupted()": [[31, 43], [118, 130]]}}}, {"text": "See the PrintWriter Documentation for more details", "label": {"api": {"PrintWriter Documentation": [[8, 32]]}}}, {"text": "You should use the get(int) method, e.g", "label": {"api": {"get(int)": [[19, 26]]}}}, {"text": "The first thing to note is that we are coding to a contract - specifically, the Comparable interface, which requires you to have a method compareTo that takes one parameter, call it arg, and returns an int", "label": {"api": {"Comparable": [[80, 89]]}}}, {"text": "A better way to do this would be to use Collections.shuffle()", "label": {"api": {"Collections.shuffle()": [[40, 60]]}}}, {"text": "Set the image as a custom Cursor", "label": {"api": {"Cursor": [[26, 31]]}}}, {"text": "See Toolkit.createCustomCursor(Image,Point,String) for turning the image into a cursor", "label": {"api": {"Cursor": [[24, 29]], "Toolkit.createCustomCursor(Image,Point,String)": [[4, 49]]}}}, {"text": "Map is the interface", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "HashMap is a popular implementation of \"Map\" in which the map keys (the usernames) have unique hashcodes", "label": {"api": {"Map": [[4, 6], [40, 42]], "HashMap": [[0, 6]]}}}, {"text": "Arrays#asList accepts a type array which means all elements used need to be Object types rather than primitives", "label": {"api": {"Arrays#asList": [[0, 12]]}}}, {"text": "This will allow Arrays#asList to be used to against the wrapper class", "label": {"api": {"Arrays#asList": [[16, 28]]}}}, {"text": "The key points of this are to use [Arrays.toString()][1], which produces a string like \"[10, 20, 30, 40, 50]\", then calling String.replaceAll() to strip out all the punctuation", "label": {"api": {"String.replaceAll()": [[124, 142]]}}}, {"text": "and then compare dates using Dates.compareTo()", "label": {"api": {"Dates.compareTo()": [[29, 45]]}}}, {"text": "The first restriction can be implemented with a map of AtomicBoolean", "label": {"api": {"AtomicBoolean": [[55, 67]]}}}, {"text": "The other two restrictions can be implemented with AtomicInteger, used to maintain a count of clients and per-client files; decrement when processing is complete, and increment with compare-and-set to start a new client/file", "label": {"api": {"AtomicInteger": [[51, 63]]}}}, {"text": "Perhaps it would be better if you use the contains method to check that an object is in the visitedwords", "label": {"api": {"contains": [[42, 49]]}}}, {"text": "If it's an executable .jar, then I suggest you use ProcessBuilder", "label": {"api": {"ProcessBuilder": [[51, 64]]}}}, {"text": "You do not need to check you can just use replace or replaceAll directly", "label": {"api": {"replace or replaceAll": [[42, 62]]}}}, {"text": "The similarity in id is expected as per the documentation in getID() method, which says \"When a thread is terminated, this thread ID may be reused.\" Read here for more", "label": {"api": {"Read here": [[149, 157]]}}}, {"text": "You can try to flush the buffer, like this", "label": {"api": {"flush": [[15, 19]]}}}, {"text": "Without writer.flush(), the writer waits to fill the internal buffer before writing the socket", "label": {"api": {"flush": [[15, 19]]}}}, {"text": "If you have a Collection (in your case a LinkedList) of Students and call remove(studentToRemove) on it, Java will compare each object with studentToRemove by using its equals() method", "label": {"api": {"equals()": [[169, 176]]}}}, {"text": "In your case, you haven't written an equals() method, hence the one for Object is used", "label": {"api": {"equals()": [[37, 44]]}}}, {"text": "If indeed a student is uniquely identified by its studentId (that is, two Student instances with the same studentId are always the same student) you should override the equals() metod and check for equality using that field", "label": {"api": {"equals()": [[169, 176]]}}}, {"text": "Read about equals() and hashCode()", "label": {"api": {"equals()": [[11, 18]], "hashCode()": [[24, 33]]}}}, {"text": "In Java 8 you can use Files.write() method with two arguments", "label": {"api": {"Files.write()": [[22, 34]]}}}, {"text": "See the SimpleDateFormat documentation for more details", "label": {"api": {"SimpleDateFormat documentation": [[8, 37]]}}}, {"text": "I'm not sure if I have understood your question correctly, but this method will convert an AttributeList to a map", "label": {"api": {"AttributeList": [[91, 103]]}}}, {"text": "The ServletContextListener is designed to listen on initialization and destroy of ServletContext", "label": {"api": {"ServletContextListener": [[4, 25]]}}}, {"text": "You need a ServletRequestListener instead", "label": {"api": {"ServletRequestListener": [[11, 32]]}}}, {"text": "Try Collections.shuffle(list).If usage of this method is barred for solving the problem, then one can look at the actual implementation", "label": {"api": {"Collections.shuffle(list)": [[4, 28]]}}}, {"text": "You can do this with the Class class", "label": {"api": {"Class": [[25, 29]]}}}, {"text": "You can call Class#getName on these class objects and compare them to the string representations of your interfaces / classes to see if the class in question meets your criteria", "label": {"api": {"Class": [[13, 17]]}}}, {"text": "To compare BigDecimals, use the compareTo method; BigDecimal is Comparable", "label": {"api": {"compareTo": [[32, 40]]}}}, {"text": "The compareTo method will return an integer greater than 0 if size is greater than thousand", "label": {"api": {"compareTo": [[4, 12]]}}}, {"text": "That would interpret 1000 as a rounding mode and it would result in an IllegalArgumentException", "label": {"api": {"rounding mode": [[31, 43]]}}}, {"text": "PrintWriter doesn't flush output after you use regular print (refer to documentation of PrintWriter)", "label": {"api": {"documentation of PrintWriter": [[71, 98]]}}}, {"text": "It looks like an errant DateFormat, instances of which are \"are generally not synchronized.\" If it's intermittent, rather than selective, verify correct use of  invokeLater(), and \"create separate format instances for each thread.\" See also Format", "label": {"api": {"Format": [[28, 33], [241, 246]]}}}, {"text": "The errant symbols might arise from the DateFormatSymbols or DecimalFormatSymbols used by concrete subclasses of Format", "label": {"api": {"Format": [[44, 49], [68, 73], [113, 118]]}}}, {"text": "Inspect the source code following the principles summarized in Memory Consistency Properties", "label": {"api": {"Memory Consistency Properties": [[63, 91]]}}}, {"text": "Rather than using the range-based for loop over dateWiseValues, use an Iterator explicitly so that you can instead invoke Iterator#remove()", "label": {"api": {"Iterator#remove()": [[122, 138]]}}}, {"text": "Two common concrete types implementing List are ArrayList and LinkedList", "label": {"api": {"ArrayList": [[48, 56]], "LinkedList": [[62, 71]]}}}, {"text": "Note that it's warning that you must use Iterator#remove() for mutation during iteration or you'll face a thrown ConcurrentModificationException the next time you use that same or any other iterator walking over the same underlying list", "label": {"api": {"Iterator#remove()": [[41, 57]]}}}, {"text": "Create a new URLClassLoader (the \"default\" Java classloader) and point it at wherever you saved the file", "label": {"api": {"URLClassLoader": [[13, 26]]}}}, {"text": "(Like pointing a debugger at your main app and intercepting stream reads.) The javadoc for ClassLoader provides an example of how to do this", "label": {"api": {"javadoc for ClassLoader": [[79, 101]]}}}, {"text": "There is an option to use parsePosition instead of looping", "label": {"api": {"parsePosition": [[26, 38]]}}}, {"text": "You're comparing char array Objects (returned by getPassword()) rather than than contents of the arrays themselves", "label": {"api": {"getPassword()": [[49, 61]]}}}, {"text": "You want to use `Array.equals(char[] array1, char[] array2), like so", "label": {"api": {"`Array.equals(char[] array1, char[] array2)": [[16, 58]]}}}, {"text": "If these are remote clients, then a MulticastSocket might do the trick", "label": {"api": {"MulticastSocket": [[36, 50]]}}}, {"text": "You can use CropImageFilter to crop images", "label": {"api": {"CropImageFilter": [[12, 26]]}}}, {"text": "Though deprecated, you can save yourself of all the headaches by using a  Vector", "label": {"api": {"Vector": [[74, 79]]}}}, {"text": "You can use a CopyOnWriteArrayList if iteration is a lot more frequent than modification", "label": {"api": {"CopyOnWriteArrayList": [[14, 33]]}}}, {"text": "A List would be appropriate to store arbitrary number of elements", "label": {"api": {"List": [[2, 5]]}}}, {"text": "A Map would be appropriate to store arbitrary number of objects keyed using an attribute of the object", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "If your Roster happens to contains attributes other than the Name, then you can use a Map to store your Roster objects", "label": {"api": {"Map": [[86, 88]]}}}, {"text": "addToRoster would simply put an element in the Map as map.put(roster.getName(), roster)", "label": {"api": {"Map": [[47, 49]]}}}, {"text": "instance of the class object, which is subclass of class Class", "label": {"api": {"class Class": [[51, 61]]}}}, {"text": "Your current best bet is to convert the Set to an array via Set#toArray() with help of the new EL 2.2 ability to invoke arbitrary methods", "label": {"api": {"Set#toArray()": [[60, 72]]}}}, {"text": "You can use JFileChooser to find the directory", "label": {"api": {"JFileChooser": [[12, 23]]}}}, {"text": "The method uses the specific Objects equals() method to determine if it contains that object", "label": {"api": {"equals()": [[37, 44]]}}}, {"text": "So, if you have custom objects make sure you override the equals() method, and also the hashCode() (to maintain the general contract between the methods)", "label": {"api": {"equals()": [[58, 65]], "hashCode()": [[88, 97]]}}}, {"text": "java.awt.Panel picks a default system font; javax.swing.JPanel takes is it from UIManager", "label": {"api": {"UIManager": [[80, 88]]}}}, {"text": "If you want to use an array rather than a decent, appropriate data structure, then use Arrays.binarySearch() to find the appropriate location", "label": {"api": {"Arrays.binarySearch()": [[87, 107]]}}}, {"text": "One way would be to start() the shell script via the ProcessBuilder class", "label": {"api": {"ProcessBuilder": [[53, 66]], "Process": [[53, 59]]}}}, {"text": "Once you have the Process instance, you can obtain its standard output and standard error streams via getOutputStream() and getErrorStream() respectively", "label": {"api": {"Process": [[18, 24]], "getOutputStream()": [[102, 118]], "getErrorStream()": [[124, 139]]}}}, {"text": "You'll need to do something like waitFor() the process and create thread(s) to read its output and write to your servlet's response", "label": {"api": {"waitFor()": [[33, 41]]}}}, {"text": "Assuming you set up your socket properly, use a WindowListener", "label": {"api": {"WindowListener": [[48, 61]]}}}, {"text": "Instead, you may create an array using String.split, a sample would be", "label": {"api": {"String.split": [[39, 50]]}}}, {"text": "If you're somewhat experienced with Java, you can use Collections#sort(List, Comparator) and send your List<BankAccount> accounts as first parameter and a Comparator<BankAccount> as second parameter", "label": {"api": {"Collections#sort(List, Comparator)": [[54, 87]]}}}, {"text": "It is possible to redefine existing bootstrap classes during runtime using a java agent (http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html) and ASM4 (http://asm.ow2.org/)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html": [[89, 170]]}}}, {"text": "You could use a ThreadPoolExecutor, basically creating a pool of threads according to multiple customizable rules", "label": {"api": {"ThreadPoolExecutor": [[16, 33]]}}}, {"text": "And to be sure that all threads have done their respective job before your process goes on the remaining code, you just have to call ThreadPoolExecutor's awaitTermination method preceded by an eventual ThreadPoolExecutor's shutdown method", "label": {"api": {"ThreadPoolExecutor": [[133, 150], [202, 219]]}}}, {"text": "A sample is written in the ExecutorService documentation (implemented by ThreadPoolExecutor)", "label": {"api": {"ThreadPoolExecutor": [[73, 90]], "ExecutorService documentation": [[27, 55]]}}}, {"text": "Alternatively, you can use Collections.shuffle instead of your custom shuffle method", "label": {"api": {"Collections.shuffle": [[27, 45]]}}}, {"text": "Try adding a ChangeListener to the JTabbedPane, this is only called when the object changes state", "label": {"api": {"ChangeListener": [[13, 26]]}}}, {"text": "To read from an InputStream, you can wrap it in a InputStreamReader, and then a BufferedReader, from which you can readLine", "label": {"api": {"InputStreamReader": [[50, 66]], "BufferedReader": [[80, 93]]}}}, {"text": "A quick look through the documentation on regular expression sytanx should bring up ways to tell if it contains a lower/upper case character at some point", "label": {"api": {"documentation on regular expression sytanx": [[25, 66]]}}}, {"text": "I have read the javadoc for BorderLayout and I have used it before, but I have yet to encounter this phenomenon", "label": {"api": {"javadoc for BorderLayout": [[16, 39]]}}}, {"text": "SAAJ should do the job, and it comes standard with Java as of Java 6", "label": {"api": {"SAAJ": [[0, 3]]}}}, {"text": "args is empty and you are trying to access the 1st element of the array which causes ArrayIndexOutOfBoundsException, thrown to indicate that an array has been accessed with an illegal index", "label": {"api": {"ArrayIndexOutOfBoundsException": [[85, 114]]}}}, {"text": "Then please read some tutorials and get knowledge about Iterator", "label": {"api": {"Iterator": [[56, 63]]}}}, {"text": "EOFException means you are trying to read past the end of the file", "label": {"api": {"EOFException": [[0, 11]]}}}, {"text": "My suggestion would be, put a check for is.available() and try reading the object", "label": {"api": {"is.available()": [[40, 53]]}}}, {"text": "Try String.valueOf(1); to change Integer to String", "label": {"api": {"String.valueOf(1);": [[4, 21]]}}}, {"text": "Get some inspiration in the standard java class java.io.Reader and its subclasses", "label": {"api": {"java.io.Reader": [[48, 61]]}}}, {"text": "Since you're overriding equals, you should also override the hashCode method", "label": {"api": {"hashCode": [[61, 68]]}}}, {"text": "Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes", "label": {"api": {"hashCode": [[52, 59], [151, 158]]}}}, {"text": "I don't think you can get the domain without a DNS, but you could use the getRemoteSocketAddress() method from clientSocket to get the client IP address", "label": {"api": {"getRemoteSocketAddress()": [[74, 97]]}}}, {"text": "The hasPrevious and previous methods are only defined for ListIterators (http://docs.oracle.com/javase/1.5.0/docs/api/java/util/ListIterator.html), a sub-interface of Iterator", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/ListIterator.html": [[73, 144]]}}}, {"text": "Yes, use a GridPane for your board", "label": {"api": {"GridPane": [[11, 18]]}}}, {"text": "You can use a StackPane with an ImageView layered behind your board grid squares as you mention in your question, but it's not strictly necessary", "label": {"api": {"StackPane": [[14, 22]], "ImageView": [[32, 40]]}}}, {"text": "Class.forName(String), to load and initialize the class.It uses classloader of current class", "label": {"api": {"Class.forName(String)": [[0, 20]]}}}, {"text": "ClassLoader#loadClass(String), to load class, but doesn't initialize.You can get an instance of ClassLoader and invoke loadClass() on that instance, which can be a Custom ClassLoader or System ClassLoader", "label": {"api": {"ClassLoader#loadClass(String)": [[0, 28]]}}}, {"text": "Overloaded Class.forName() , allows you to specify the classloader to use explicitly and initialize parameter to specify whether the class must be initialzed", "label": {"api": {"Class.forName() ": [[11, 26]]}}}, {"text": "and perhaps you wanted it to be a Scanner", "label": {"api": {"Scanner": [[34, 40]]}}}, {"text": "As @JonSkeet and @MarounMaroun points out, an easy way to print arrays is by using Arrays.toString() for one-dimensional arrays, or Arrays.deepToString() for multi-dimensional", "label": {"api": {"Arrays.toString()": [[83, 99]], "Arrays.deepToString()": [[132, 152]]}}}, {"text": "br.readLine() reads the entire line including the new line special character.Apart, form the solution suggested by James, you can use Scanner#nextInt()", "label": {"api": {"br.readLine()": [[0, 12]], "Scanner#nextInt()": [[134, 150]]}}}, {"text": "Collections.sort(List) and Collections.sort(List,Comparator)", "label": {"api": {"Collections.sort(List)": [[0, 21]], "Collections.sort(List,Comparator)": [[27, 59]], "Comparator": [[49, 58]]}}}, {"text": "One takes a Listand another takes a List and an instance of Comparator", "label": {"api": {"Comparator": [[60, 69]]}}}, {"text": "The single argument sort() will expect your class to have implemented Comparable and overridden the compareTo() method", "label": {"api": {"Comparable": [[70, 79]], "compareTo()": [[100, 110]]}}}, {"text": "The two argument sort() method expects an instance of Comparator, wherein you have implemented the Comparator and overridden its compare() method", "label": {"api": {"Comparator": [[54, 63], [99, 108]], "compare()": [[129, 137]]}}}, {"text": "An object should implement Comparable if that is the clear natural way to sort the class, and anyone would need to sort the class would generally want to do it that way", "label": {"api": {"Comparable": [[27, 36]]}}}, {"text": "If, however, the sorting was an unusual use case of the class or there can be multiple sort orders then a Comparator is a better option", "label": {"api": {"Comparator": [[106, 115]]}}}, {"text": "This is common behavior  and it is described in Thread#sleep javadoc", "label": {"api": {"Thread#sleep": [[48, 59]]}}}, {"text": "Based on this, there's no guarantee of Thread#sleep stoping the work of the thread by the amount of milliseconds stated in the parameter", "label": {"api": {"Thread#sleep": [[39, 50]]}}}, {"text": "Wouldn't the toArray()function be useful here", "label": {"api": {"function": [[22, 29]]}}}, {"text": "For reference, here is the Java doc on the ResultSet interface's getString method", "label": {"api": {"Java doc on the ResultSet interface's getString method": [[27, 80]]}}}, {"text": "I'm making a game in Java and enjoying the speedup that VolatileImage offers", "label": {"api": {"VolatileImage": [[56, 68]]}}}, {"text": "This method is perfect except that it won't work for VolatileImages, since their memory contents could be lost at any time", "label": {"api": {"VolatileImage": [[53, 65]]}}}, {"text": "Using VolatileImage.getSnapshot() solves this problem, since you can save the image contents between frames in case they're lost", "label": {"api": {"VolatileImage": [[6, 18]], "getSnapshot()": [[20, 32]]}}}, {"text": "Use the .contains() method directly on the ArrayList", "label": {"api": {".contains()": [[8, 18]]}}}, {"text": "You can add an enumerated field to your entity by using @Enumerated", "label": {"api": {"@Enumerated": [[56, 66]]}}}, {"text": "Instead, you can use replaceAll, which, for me, looks more suitable for this task", "label": {"api": {"replaceAll": [[21, 30]]}}}, {"text": "Use name() method", "label": {"api": {"name()": [[4, 9]]}}}, {"text": "Double is a class while double is a primitive", "label": {"api": {"Double": [[0, 5]]}}}, {"text": "You have static ArrayList<Double[]> aryList1 = new ArrayList<Double[]>(); which has Double[] and not double[]", "label": {"api": {"Double": [[26, 31], [61, 66], [84, 89]]}}}, {"text": "If you go through the code of ThreadPoolExecutor, you will see this", "label": {"api": {"ThreadPoolExecutor": [[30, 47]]}}}, {"text": "Assuming you want to sort alphabetically you should do it using the Java library method Collections.sort as the code is already written to do this", "label": {"api": {"Collections.sort": [[88, 103]]}}}, {"text": "getAnnotationsByType) which hide the implementation detail of a container annotation which contains the repeated annotations", "label": {"api": {"getAnnotationsByType": [[0, 19]]}}}, {"text": "You can use StringTokenizer for this", "label": {"api": {"StringTokenizer": [[12, 26]]}}}, {"text": "Use String.split() or  StringTokenizer to split your string", "label": {"api": {"StringTokenizer": [[23, 37]]}}}, {"text": "You can call the method reset() on your ObjectInputStream", "label": {"api": {"reset()": [[24, 30]]}}}, {"text": "Double.MAX_VALUE is the maximum value a double can represent (somewhere around 1.7*10^308)", "label": {"api": {"Double.MAX_VALUE": [[0, 15]]}}}, {"text": "To get the selected value from the JComboBox you use getSelectedItem", "label": {"api": {"getSelectedItem": [[53, 67]]}}}, {"text": "Now you can check if value equals to text1, if so, you can use removeItem to remove items from the other JComboBox", "label": {"api": {"removeItem": [[63, 72]]}}}, {"text": "You could use java.util.Timer to do that, and schdule the next TimerTask inside your TimerTask implementation", "label": {"api": {"java.util.Timer": [[14, 28]]}}}, {"text": "A modified version of your function using String#lastIndexOf", "label": {"api": {"String#lastIndexOf": [[42, 59]]}}}, {"text": "Or you can use String#split to separate by spaces and just loop through in reverse and concatenate", "label": {"api": {"String#split": [[15, 26]]}}}, {"text": "Although StringBuilder would make for a more efficient option, since it doesn't require all that string copying", "label": {"api": {"StringBuilder": [[9, 21]]}}}, {"text": "Class#isPrimitive() must be what you're looking for", "label": {"api": {"Class#isPrimitive()": [[0, 18]]}}}, {"text": "According to the documentation of java.lang.Process, that class provides a constructor that can be called without arguments", "label": {"api": {"java.lang.Process": [[34, 50]]}}}, {"text": "Scanner#nextInt() does not consume newline characters, instead passing through to the loop that reads employee names", "label": {"api": {"Scanner#nextInt()": [[0, 16]]}}}, {"text": "You can use iterators", "label": {"api": {"iterators": [[12, 20]]}}}, {"text": "What you are looking for is probably a FileChannel", "label": {"api": {"FileChannel": [[39, 49]]}}}, {"text": "From the javadoc for Long, the valueOf method improves performance by \"caching frequently requested values\"", "label": {"api": {"javadoc for Long": [[9, 24]]}}}, {"text": "You can use a PhantomReference to track when your key is GC'ed", "label": {"api": {"PhantomReference": [[14, 29]]}}}, {"text": "You use the overloaded add method that doesn't take an index to add to the end", "label": {"api": {"add": [[23, 25], [64, 66]]}}}, {"text": "The Color constructor that takes only an int creates an opaque color (with alpha 255)", "label": {"api": {"Color constructor": [[4, 20]]}}}, {"text": "To preserve the alpha component, you need to use the Color constructor that takes an int for the values and a boolean for whether it has an alpha component", "label": {"api": {"Color constructor": [[53, 69]]}}}, {"text": "You could use the skip() method to move the marker ahead for other threads to avoid duplicate line processing", "label": {"api": {"skip()": [[18, 23]]}}}, {"text": "BufferedReader may help some too, as it offers reading line by line", "label": {"api": {"BufferedReader": [[0, 13]], "line by line": [[55, 66]]}}}, {"text": "I took a look at the JProgressBar javadoc and saw no disclaimer, actually it has a warning that Swing is not threadsafe", "label": {"api": {"JProgressBar javadoc": [[21, 40]], "warning": [[83, 89]]}}}, {"text": "Use image.getColorModel().hasAlpha() to check", "label": {"api": {"hasAlpha()": [[26, 35]]}}}, {"text": "You need to create a new StringBuffer to hold the replaced string, then use appendReplacement(StringBuffer sb, String replacement) and appendTail(StringBuffer sb) methods in Matcher class to do the replacement", "label": {"api": {"appendReplacement(StringBuffer sb, String replacement)": [[76, 129]], "appendTail(StringBuffer sb)": [[135, 161]]}}}, {"text": "You just have to connect the two classes by injecting the same queue to both (a LinkedBlockingQueue e.g.)", "label": {"api": {"BlockingQueue": [[86, 98]]}}}, {"text": "You have many options to tune the behavior using other methods to add to or remove data from the BlockingQueue and/or by using another implementation like the bounded ArrayBlockingQueue", "label": {"api": {"BlockingQueue": [[97, 109], [172, 184]]}}}, {"text": "An other idea may be to use the executor framework instead of scheduled job execution", "label": {"api": {"executor": [[32, 39]]}}}, {"text": "Just create a executor in your request handler and let it run the jobs for you", "label": {"api": {"executor": [[14, 21]]}}}, {"text": "can use ProcessBuilder class to run the process as it sounds external to the JVM See http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/ProcessBuilder.html  and Executing another application from Java for how to use", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/ProcessBuilder.html": [[85, 158]]}}}, {"text": "You have a single thread on both the client and the server that reads from their respective BufferedReader, using the readLine() method, which blocks", "label": {"api": {"readLine()": [[118, 127]]}}}, {"text": "The BlockingQueue's drainTo method sounds like exactly what you're looking for given that you want threads to be able to take a bunch of sites at a time", "label": {"api": {"drainTo": [[20, 26]]}}}, {"text": "commons-io or Java 7 Files) or write code such as", "label": {"api": {"Files": [[21, 25]]}}}, {"text": "Files class offers", "label": {"api": {"Files": [[0, 4]]}}}, {"text": "You shouldn't use a try / catch block to do this - you already know how many elements are in the ArrayList so just use size() to ensure that the number is in the range", "label": {"api": {"size()": [[119, 124]]}}}, {"text": "However, if your login mechanism adds this information, the username might be available in request.getRemoteUser() or request.getUserPrincipal()", "label": {"api": {"request.getRemoteUser()": [[91, 113]], "request.getUserPrincipal()": [[118, 143]]}}}, {"text": "It's just sorted according to String.compareTo which is an ordinal lexicographic comparison", "label": {"api": {"String.compareTo": [[30, 45]]}}}, {"text": "If you want a case-insensitive comparison, you should pass a Comparator<String> to Collections.sort - for example, a Collator", "label": {"api": {"Collator": [[117, 124]]}}}, {"text": "You have to set the location of the FXML file in your loader, be sure that you are providing the correct PATH to your FXML file", "label": {"api": {"loader": [[54, 59]], "PATH": [[105, 108]]}}}, {"text": "Calendar should be used mainly for date calculations (see add() and roll()), but you are using it for parsing and formatting", "label": {"api": {"add()": [[58, 62]], "roll()": [[68, 73]]}}}, {"text": "If this is for your homework, which I suspect it is, then I suggest you take a look at the API for the String class to see what other methods are available to help find the location of one String within another", "label": {"api": {"API for the String": [[91, 108]]}}}, {"text": "But a better approach would be to use Map instead of Hashtable", "label": {"api": {"Map": [[38, 40]], "Hashtable": [[53, 61]]}}}, {"text": "I'd also suggest the Random class, which has a nextInt(int) method, which is better than (int) ((Math.random() * 6) + 1)", "label": {"api": {"the Random class": [[17, 32]]}}}, {"text": "There is such an example in the Files class documentation", "label": {"api": {"Files class documentation": [[32, 56]]}}}, {"text": "The method getResourceAsStream is returning null because it cannot find the file", "label": {"api": {"getResourceAsStream": [[11, 29]]}}}, {"text": "Make sure that the file is in the classpath; that's where getResourceAsStream searches", "label": {"api": {"getResourceAsStream": [[58, 76]]}}}, {"text": "Additionally, you may want to use a StringBuilder to build your string instead of concatenating String after String", "label": {"api": {"StringBuilder": [[36, 48]]}}}, {"text": "Salting is generally something that is done when hashing a password, not when encrypting plaintext; for example, you would use a salt when generating a key from a password using PBEKeySpec", "label": {"api": {"PBEKeySpec": [[178, 187]]}}}, {"text": "SecureRandom) or else you need to generate the IV from a counter", "label": {"api": {"SecureRandom": [[0, 11]]}}}, {"text": "indexOf is used for character checking", "label": {"api": {"indexOf": [[0, 6]]}}}, {"text": "Yes - you can use isAssignableFrom method of the Class<T> type", "label": {"api": {"isAssignableFrom": [[18, 33]]}}}, {"text": "You can use isInstance() method from Class", "label": {"api": {"isInstance()": [[12, 23]]}}}, {"text": "I'd also suggest using type.cast() method for casting obj instead of a (T) cast", "label": {"api": {"cast()": [[28, 33]]}}}, {"text": "The latter will give you a compile-time warning, while using type.cast() will not", "label": {"api": {"cast()": [[66, 71]]}}}, {"text": "Try switching to submit() instead of execute() and store a list of Future instances the Executor gives you", "label": {"api": {"submit() instead": [[17, 32]], "Future": [[67, 72]]}}}, {"text": "You have a couple options - XMLEncoder/XMLDecoder (older) or JAXB (newer), for example", "label": {"api": {"XMLEncoder": [[28, 37]], "XMLDecoder": [[39, 48]]}}}, {"text": "Set Eclipse as the default consumer for .java files and use Desktop.open(File) which.", "label": {"api": {"Desktop.open(File)": [[60, 77]]}}}, {"text": "Pass a seed on initialization with Random(long seed)", "label": {"api": {"Random(long seed)": [[35, 51]]}}}, {"text": "As the argument to String.split takes a regex argument, you need to escape the dot character (which means wildcard in regex)", "label": {"api": {"String.split": [[19, 30]]}}}, {"text": "Note that String.split takes in a regular expression, and", "label": {"api": {"String.split": [[10, 21]], "regular expression": [[34, 51]]}}}, {"text": "has special meaning in regular expression (which matches any character except for line separator), so you need to escape it", "label": {"api": {"regular expression": [[23, 40]]}}}, {"text": "at the level of regular expression once", "label": {"api": {"regular expression": [[16, 33]]}}}, {"text": "So the string to pass to String.split is \"\\\\.\"", "label": {"api": {"String.split": [[25, 36]]}}}, {"text": "The format which you're seeing when you're printing a Date instance is just its default toString() format which is clearly specified in its javadoc", "label": {"api": {"its javadoc": [[136, 146]]}}}, {"text": "If you don't want Runtime.exec() to parse and split your arguments then you might consider the variant that takes individual arguments", "label": {"api": {"the variant that takes individual arguments": [[91, 133]]}}}, {"text": "This is how Objects.hashCode() is implemented", "label": {"api": {"Objects.hashCode()": [[12, 29]]}}}, {"text": "The class to use is LinkedHashMap", "label": {"api": {"LinkedHashMap": [[20, 32]]}}}, {"text": "Yes, the LinkedHashMap has an iterable order", "label": {"api": {"LinkedHashMap": [[9, 21]]}}}, {"text": "You can use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[12, 24]]}}}, {"text": "You can't use Class#newInstance for instantiating an array", "label": {"api": {"Class#newInstance": [[14, 30]]}}}, {"text": "See Convert ArrayList to String []  and toArray", "label": {"api": {"toArray": [[40, 46]]}}}, {"text": "To get the int value of a hex-string use Integer.decode", "label": {"api": {"Integer.decode": [[41, 54]]}}}, {"text": "Use the Long.decode or Integer.decode functions depending on how big the result can be expected to be", "label": {"api": {"Long.decode": [[8, 18]], "Integer.decode": [[23, 36]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/package-summary.html Using an ExecutorService to run callables (java.util.concurrent.Callable) allows you to vary the number of threads quite easily", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/package-summary.html": [[0, 81]]}}}, {"text": "FileInputStream::read returns a byte wrapped in an int (or -1)", "label": {"api": {"FileInputStream::read": [[0, 20]]}}}, {"text": "One of Color's constructors could have been changed from 3 int's to 3 byte's instead, since their range is limited to 0-255", "label": {"api": {"Color": [[7, 11]]}}}, {"text": "How about using overloaded ArrayList constructor", "label": {"api": {"overloaded ArrayList constructor": [[16, 47]]}}}, {"text": "You can use Java 8 Stream API", "label": {"api": {"Java 8 Stream API": [[12, 28]]}}}, {"text": "Date.toString() applies its own format when converting to string", "label": {"api": {"Date.toString()": [[0, 14]]}}}, {"text": "For instance, the documentation for Thread.join says", "label": {"api": {"documentation for Thread.join": [[18, 46]]}}}, {"text": "That's fine (although not as clean as calling Random.nextInt) for the first iteration - but afterwards, customer.size() has changed (as the element has been removed) but customerlist is still the same", "label": {"api": {"Random.nextInt": [[46, 59]]}}}, {"text": "To be honest, you'd be better off just using Collections.shuffle() to shuffle the original list - that's the result you want in the end, right", "label": {"api": {"Collections.shuffle()": [[45, 65]]}}}, {"text": "If you're using Java 6 or older, use the File API instead", "label": {"api": {"File": [[41, 44]]}}}, {"text": "If you're using Java 7 or newer, use the Path API", "label": {"api": {"Path": [[41, 44]]}}}, {"text": "Otherwise, you'll have to call the specific constructor by using Class.getConstructor(), and pass it the appropriate parameters", "label": {"api": {"Class.getConstructor()": [[65, 86]]}}}, {"text": "So, to call the new Long(String) constructor for example", "label": {"api": {"new Long(String)": [[16, 31]]}}}, {"text": "The StringBuilder class (mutable strings) contains a reverse operation that switches the characters of the StringBuilder", "label": {"api": {"StringBuilder class": [[4, 22]]}}}, {"text": "Once the frame is displayed you cannot change its decoration as setUndecorated() throws IllegalComponentStateException in this case", "label": {"api": {"setUndecorated()": [[64, 79]]}}}, {"text": "The reason your UDPReceive thread is not stopping is you are using the blocking method DatagramSocket.receive() in your UDPReceive.run() while loop", "label": {"api": {"DatagramSocket.receive()": [[87, 110]]}}}, {"text": "To fix it, call socket.setSoTimeout() before your UDPReceive.run() while loop starts", "label": {"api": {"socket.setSoTimeout()": [[16, 36]]}}}, {"text": "Then catch the SocketTimeoutException that will occur if your socket times out (e.g", "label": {"api": {"SocketTimeoutException": [[15, 36]]}}}, {"text": "1)You should write two Comparator for sorting on age and name separately, and then use the Collections.sort(List,Comparator)", "label": {"api": {"Comparator": [[23, 32], [113, 122]], "Collections.sort(List,Comparator)": [[91, 123]]}}}, {"text": "Then, use Comparable for age and Comparator for name", "label": {"api": {"Comparator": [[33, 42]], "Comparable": [[10, 19]]}}}, {"text": "Take a look at java.util.concurrent.CopyOnWriteArrayList", "label": {"api": {"java.util.concurrent.CopyOnWriteArrayList": [[15, 55]]}}}, {"text": "You should instead look into a \"real\" concurrency control mechanism like a Condition (which causes the thread to sleep until awoken by another thread) or a CountDownLatch (which causes the thread to sleep until a certain number of signals have happened)", "label": {"api": {"Condition": [[75, 83]], "CountDownLatch": [[156, 169]]}}}, {"text": "Override the equals method in your class and use  Collection#equals() method to check for equality", "label": {"api": {"equals": [[13, 18], [61, 66]], "Collection#equals()": [[50, 68]]}}}, {"text": "This is by design", "label": {"api": {"by design": [[8, 16]]}}}, {"text": "UUID, SecureRandom, but I'm not sure that this classes suits my needs and I'm not sure about how to use them", "label": {"api": {"UUID": [[0, 3]], "SecureRandom": [[6, 17]]}}}, {"text": "The CopyOnWriteArrayList structure could solve your problem (java.util.concurrent)", "label": {"api": {"CopyOnWriteArrayList": [[4, 23]]}}}, {"text": "CopyOnWriteArrayLists is thread-safe because all mutative operations are implemented by creating a copy of the list", "label": {"api": {"CopyOnWriteArrayList": [[0, 19]]}}}, {"text": "If you have much more reads than writes, use CopyOnWriteArrayList, otherwise use Vector", "label": {"api": {"CopyOnWriteArrayList": [[45, 64]]}}}, {"text": "Vector introduces a small synchronization delay for each operation, when CopyOnWriteArrayList has a longer delay for write (due to copying) but no delay for reads", "label": {"api": {"CopyOnWriteArrayList": [[73, 92]]}}}, {"text": "Vector requires explicit synchronization when you are iterating it (so write operations can't be executed at the same time), CopyOnWriteArrayList doesn't", "label": {"api": {"CopyOnWriteArrayList": [[125, 144]]}}}, {"text": "I'm going to offer up ConcurrentSkipListSet, because", "label": {"api": {"ConcurrentSkipListSet": [[22, 42]]}}}, {"text": "What you want is to get a parameter value by a known parameter name, using ServletRequest#getParameter(String name)", "label": {"api": {"ServletRequest#getParameter(String name)": [[75, 114]]}}}, {"text": "Currently you are using the add method which does not affect the contents of the list", "label": {"api": {"add": [[28, 30]]}}}, {"text": "From the API docs", "label": {"api": {"API docs": [[9, 16]]}}}, {"text": "As everybody here proposed, use BigInteger to account for such cases", "label": {"api": {"BigInteger": [[32, 41]]}}}, {"text": "For example, BigInteger bi = new BigInteger(\"fffff8000261e000\", 16); will solve your problem", "label": {"api": {"BigInteger": [[13, 22], [33, 42]]}}}, {"text": "Also, new java.math.BigInteger(\"fffff8000261e000\", 16).toString() will yield 18446735277656498176 exactly", "label": {"api": {"BigInteger": [[20, 29]]}}}, {"text": "When you say StringBuffer sbuff = new StringBuffer(); this refers to your own class, not the one in the Java API, which I'm assuming you're trying to use", "label": {"api": {"the one in the Java API": [[89, 111]]}}}, {"text": "In your case you used the default Object.toString() implementation, which is not so informative..", "label": {"api": {"Object.toString()": [[34, 50]]}}}, {"text": "The first one takes only a collection as an argument, and sorts its elements according to their natural ordering", "label": {"api": {"first one": [[4, 12]]}}}, {"text": "The second one takes a collection and a Comparator as an argument, and sorts the elements according to the Comparator", "label": {"api": {"second one": [[4, 13]], "Comparator": [[40, 49], [107, 116]]}}}, {"text": "You can take this approach to write your own Comparator<Entry> instead of modifying the existing classes, and then pass this into Collections.sort", "label": {"api": {"Comparator": [[45, 54]]}}}, {"text": "You need to iterate your list and call String#trim for searching", "label": {"api": {"String#trim": [[39, 49]]}}}, {"text": "In current versions of Java, each + (concatenation) operation gets automatically compiled to a StringBuilder append() operation", "label": {"api": {"StringBuilder": [[95, 107]]}}}, {"text": "However, if it's inside a loop, it will create a new StringBuilder for each iteration, negating its effect - so you'd be better of managing the StringBuilder explicitly", "label": {"api": {"StringBuilder": [[53, 65], [144, 156]]}}}, {"text": "You are better off using lists in order to archive this as they don't have to maintain a fixed size from initialization", "label": {"api": {"lists": [[25, 29]]}}}, {"text": "getInt is overloaded, use index (an int) instead of a column name", "label": {"api": {"overloaded": [[10, 19]]}}}, {"text": "String#split uses a regular expression", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "The general solution to this is to use Pattern.quote()", "label": {"api": {"Pattern.quote()": [[39, 53]]}}}, {"text": "You can use SSL, and then add HTTP header fields in the request at the browser, (SSL encrypts headers), and pull the values out in the servlet using HTTPServletRequest.getHeader", "label": {"api": {"HTTPServletRequest.getHeader": [[149, 176]]}}}, {"text": "Use GZIPOutputStream instead, it's part of java.util (so standard) and has better compression in (AFAIK) all cases, and will definitely handle files larger than 4Gb", "label": {"api": {"GZIPOutputStream": [[4, 19]]}}}, {"text": "Bye default, the fetch strategy for @OneToMany annotations is LAZY, have you tried specifying it to EAGER like in the @oneToOne field (fetch= FetchType.EAGER)", "label": {"api": {"LAZY": [[62, 65]]}}}, {"text": "You should be using the Signature class to handle RSA signature verification", "label": {"api": {"Signature": [[24, 32]]}}}, {"text": "You can achieve this with JEditorPane", "label": {"api": {"JEditorPane": [[26, 36]]}}}, {"text": "You get an annual interest from the dialog box as a string, you can see this from the online documentation (all but one returns a String, the one that returns an Object doesn't match your function signature)", "label": {"api": {"online documentation": [[86, 105]]}}}, {"text": "Make sure to check the contents of getErrorStream", "label": {"api": {"getErrorStream": [[35, 48]]}}}, {"text": "Consider using the more convenient ProcessBuilder which uses a varargs array to build the command String", "label": {"api": {"ProcessBuilder": [[35, 48]]}}}, {"text": "As an aside, other UI systems such as WPF’s MeasureOverride, JavaFX’s prefHeight with contentBias and Android’s measure give the measure pass the available space so that they don’t have this problem", "label": {"api": {"JavaFX’s prefHeight with contentBias": [[61, 96]]}}}, {"text": "Make sure to override hashCode and equals methods to allow different Category objects to be compared", "label": {"api": {"hashCode": [[22, 29]], "equals": [[35, 40]]}}}, {"text": "Using GregorianCalendar and simpleDateFormat", "label": {"api": {"GregorianCalendar": [[6, 22]]}}}, {"text": "This is reflected by the fact that a Method can only report the formal types of its parameters, not what they are called", "label": {"api": {"Method": [[37, 42]]}}}, {"text": "If you want the key-binding removal to be more key-specific, have a look at InputMap#remove(KeyStroke)", "label": {"api": {"InputMap#remove(KeyStroke)": [[76, 101]]}}}, {"text": "Since String.split() evaluates the passed string a regular expression (Java Doc for String.split()), the back slash is treated as a RegEx", "label": {"api": {"(Java Doc for String.split())": [[70, 98]]}}}, {"text": "Backslash has a special meaning in regular expressions and cannot appear alone (Java Doc for Pattern)", "label": {"api": {"Java Doc for Pattern": [[80, 99]]}}}, {"text": "Regular expression reference", "label": {"api": {"Regular expression reference": [[0, 27]]}}}, {"text": "You can write your own implementation to keep it at a fixed size like this or write a wrapper for an existing implementation like LinkedList", "label": {"api": {"LinkedList": [[130, 139]]}}}, {"text": "Java has a Queue<E> interface link, LinkedList implements it", "label": {"api": {"link": [[30, 33]]}}}, {"text": "If you just need a few dozen, create an array of sequential numbers and shuffle them", "label": {"api": {"shuffle": [[72, 78]]}}}, {"text": "A HashSet would do fine here", "label": {"api": {"HashSet": [[2, 8]]}}}, {"text": "In your case all non-text child-nodes have a unique name, so you can get them individually by using getElementsByTagName()", "label": {"api": {"getElementsByTagName()": [[100, 121]]}}}, {"text": "Essentially, it uses the Proxy class to intercept method calls and direct them to one or other of two objects - this implements A overrides B", "label": {"api": {"Proxy": [[25, 29]]}}}, {"text": "No difference.They both behave the same", "label": {"api": {"same": [[35, 38]]}}}, {"text": "What is the difference between set(String) and setValue(String) in the SimpleStringProperty class", "label": {"api": {"SimpleStringProperty": [[71, 90]]}}}, {"text": "I know that set(String) is derived from StringPropertyBase, but this makes me even more wonder, why there additionally is setValue(String)", "label": {"api": {"StringPropertyBase": [[40, 57]]}}}, {"text": "For further information see the JDoc of MouseEvent", "label": {"api": {"JDoc": [[32, 35]]}}}, {"text": "Yes, throw everything in an ArrayList and then use the .contains(Object obj) method", "label": {"api": {"ArrayList": [[28, 36]], ".contains(Object obj)": [[55, 75]]}}}, {"text": "The MySQL driver implementation has a bug, because the JDBC specification states that the methods accepting a string should throw an SQLException when called on a PreparedStatement or CallableStatement implementation", "label": {"api": {"JDBC specification": [[55, 72]]}}}, {"text": "However, the api for both the OneToMany and ManyToOne annotation both give pretty decent examples of how to use them", "label": {"api": {"OneToMany": [[30, 38]], "ManyToOne": [[44, 52]]}}}, {"text": "From Object#equals method javadoc", "label": {"api": {"Object#equals": [[5, 17]]}}}, {"text": "From Object#hashCode method javadoc", "label": {"api": {"Object#hashCode": [[5, 19]]}}}, {"text": "You need to use ProcessBuilder to redirect", "label": {"api": {"ProcessBuilder": [[16, 29]]}}}, {"text": "Since your MySQL ENUM for DEGREE column is of 3 types, you can annotation your enum with @Enumerated as follows", "label": {"api": {"@Enumerated": [[89, 99]]}}}, {"text": "More info on EnumType", "label": {"api": {"EnumType": [[13, 20]]}}}, {"text": "You can set CharsetDecoder.replaceWith to a known string", "label": {"api": {"CharsetDecoder.replaceWith": [[12, 37]]}}}, {"text": "By default, Charset.decode will replace malformed input, but you can also specify CodingErrorAction.REPORT instead to throw an exception and reject malformed input outright", "label": {"api": {"Charset.decode": [[12, 25]], "CodingErrorAction.REPORT": [[82, 105]]}}}, {"text": "If you like them, you can use JInternalFrame", "label": {"api": {"JInternalFrame": [[30, 43]]}}}, {"text": "Using Java 8 streams", "label": {"api": {"streams": [[13, 19]]}}}, {"text": "You could add a ChangeListener to the spinner", "label": {"api": {"ChangeListener": [[16, 29]]}}}, {"text": "Use requestFocusInWindow on the JTextField after the component has been added to the JFrame", "label": {"api": {"requestFocusInWindow": [[4, 23]]}}}, {"text": "As of JDK 1.4, you should instead use the requestFocusInWindow method, which does not attempt to make the component's window focused", "label": {"api": {"requestFocusInWindow": [[42, 61]]}}}, {"text": "Check out the ConcurrentModificationException documentation for more details", "label": {"api": {"ConcurrentModificationException documentation": [[14, 58]]}}}, {"text": "Keep in mind that when you put a key-value entry in a map it replaces any existing entry with the same key", "label": {"api": {"put": [[27, 29]]}}}, {"text": "I think you confused yourself thinking that getInstance() is Reflection method", "label": {"api": {"Reflection method": [[61, 77]]}}}, {"text": "Use a loop to count the number of hit of String.indexOf(String str, int fromIndex) and exit when it returns -1", "label": {"api": {"String.indexOf(String str, int fromIndex)": [[41, 81]]}}}, {"text": "If you plan on changing elements of your GUI inside the repeatedly called function (Hi in your case) you should use javax.swing.Timer", "label": {"api": {"javax.swing.Timer": [[116, 132]]}}}, {"text": "from the java.util.UUID; package", "label": {"api": {"package": [[25, 31]]}}}, {"text": "So the logic on seeing if the package is for the correct client needs to be on the client side", "label": {"api": {"package": [[30, 36]]}}}, {"text": "The easiest way is to use JOptionPane.showInputDialog", "label": {"api": {"JOptionPane.showInputDialog": [[26, 52]]}}}, {"text": "Instead, if you want to format a date use SimpleDateFormat and call getTime() on your calendar instance to get a Date", "label": {"api": {"SimpleDateFormat": [[42, 57]]}}}, {"text": "You need to use iterator", "label": {"api": {"iterator": [[16, 23]]}}}, {"text": "Auto-boxing implicitly calls Short.valueOf, which uses cached box instances for small numbers up to 127", "label": {"api": {"Short.valueOf": [[29, 41]]}}}, {"text": "You probably \"just\" need to use the right anchor, for example in rotate", "label": {"api": {"rotate": [[65, 70]]}}}, {"text": "To make this easier, imagine that the Gun bitmap (or Shape?) has the same size as the player", "label": {"api": {"Shape": [[53, 57]]}}}, {"text": "If you superimpose the gun on the player and rotate both using the same anchor the gun will always be in the right place", "label": {"api": {"rotate": [[45, 50]]}}}, {"text": "You can change a button's action command with setActionCommand)", "label": {"api": {"setActionCommand": [[46, 61]]}}}, {"text": "You have to use the toString method", "label": {"api": {"toString": [[20, 27]]}}}, {"text": "toString is a built-in function in Java (it might need library import; if you are using Netbeans, it will suggest it)", "label": {"api": {"toString": [[0, 7]]}}}, {"text": "You're using a Scanner to read the input file char by char, but you don't use any parsing capabilities offered by Scanner", "label": {"api": {"Scanner": [[15, 21], [114, 120]]}}}, {"text": "Try using an InputStreamReader instead", "label": {"api": {"InputStreamReader": [[13, 29]]}}}, {"text": "The write() method of FileOutputStream can take a whole byte array as parameter", "label": {"api": {"FileOutputStream": [[22, 37]]}}}, {"text": "You can set the size of a button using using setPreferredSize()", "label": {"api": {"setPreferredSize()": [[45, 62]]}}}, {"text": "If this does not work then you can override the paintComponent() method on JButton", "label": {"api": {"paintComponent()": [[48, 63]]}}}, {"text": "One of the easiest ways to start with is to write your config file in Java's properties format (see http://docs.oracle.com/javase/6/docs/api/java/util/Properties.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Properties.html": [[100, 165]]}}}, {"text": "You need to either use binhex encoding like that provided by javax.xml.bind.DatatypeConverter via the parseHexBinary and printHexBinary methods or base 64 using the parseBase64Binary and printBase64Binary methods of the same object", "label": {"api": {"javax.xml.bind.DatatypeConverter": [[61, 92]]}}}, {"text": "I used next() for this since we only want one word (token), but be aware that there are other options for reading Strings", "label": {"api": {"next()": [[7, 12]]}}}, {"text": "You can find the method String.matches() in the Java documentation", "label": {"api": {"String.matches()": [[24, 39]]}}}, {"text": "Please, check Scenario 7 at JSR-135 Overview", "label": {"api": {"JSR-135 Overview": [[28, 43]]}}}, {"text": "You could use the Java UUID class", "label": {"api": {"UUID class": [[23, 32]]}}}, {"text": "Your method is private but getMethod() only returns public method.You need to use getDeclaredMethod()", "label": {"api": {"getMethod()": [[27, 37]], "getDeclaredMethod()": [[82, 100]]}}}, {"text": "getMethod() - Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object", "label": {"api": {"getMethod()": [[0, 10]]}}}, {"text": "There is very good reason what thread pool executor works with BlockingQueue (btw, you are not obliged to use LinkedBlockingQueue implementation, you can use different implementations of the BlockingQueue)", "label": {"api": {"different implementations": [[158, 182]]}}}, {"text": "In your case, you can go for PreparedStatement for avoiding SQL-Injection problem", "label": {"api": {"PreparedStatement": [[29, 45]]}}}, {"text": "Then you could use, for example, the static valueOf() method for parsing strings from input files", "label": {"api": {"valueOf()": [[44, 52]]}}}, {"text": "This example uses drawLine() to connect JInternalFrame instances in a JDesktopPane, but you can draw() any desired Shape", "label": {"api": {"Shape": [[115, 119]]}}}, {"text": "Additionally, System.arraycopy is a much faster and elegant way to copy arrays", "label": {"api": {"System.arraycopy": [[14, 29]]}}}, {"text": "Look here String#contains to know more about this method", "label": {"api": {"String#contains": [[10, 24]]}}}, {"text": "Just write you own Comparator<HashMap<String, Object>> and use this version of Collections.sort()", "label": {"api": {"Comparator<HashMap<String, Object>>": [[19, 53]], "this version": [[63, 74]]}}}, {"text": "Arrays.asList(T...) creates a fixed sized list", "label": {"api": {"Arrays.asList(T...)": [[0, 18]]}}}, {"text": "Just parse your degreeOfDiffString using Double.parseDouble(), and then check if the double is between 1.2 and 4.8 (inclusive)", "label": {"api": {"Double.parseDouble()": [[41, 60]]}}}, {"text": "If there are random things in the String, such as \"!\" or some letter, then an NumberFormatException should be thrown, which you can deal with", "label": {"api": {"NumberFormatException": [[78, 98]]}}}, {"text": "As an additional tip, you may want to use String.contains(\"end\") or String.endsWith(\"end\") instead of substring()", "label": {"api": {"String.contains(\"end\")": [[42, 63]], "String.endsWith(\"end\")": [[68, 89]]}}}, {"text": "Check if the User, Password you enter belong to a database login, usually you log this data with a separated connection so it does not dependon \"if the user/pass you enter can access your DB or not\", you can debug to see if your code to insert data is getting executed at all, and check the result of pst.executeUpdate(); to see if any updates to the database was done", "label": {"api": {"pst.executeUpdate();": [[301, 320]]}}}, {"text": "You can set the session time out as below in the ServletContextListener", "label": {"api": {"ServletContextListener": [[49, 70]]}}}, {"text": "The main reason behind the ExceptionInInitializerError is that, when the JVM come across the unexpected situation that can not be handled the JVM will throw the above error", "label": {"api": {"ExceptionInInitializerError": [[27, 53]], "Error": [[49, 53]]}}}, {"text": "ExceptionInInitializerError can be caught, though you shouldn't catch Error, it is actually impossible to recover from it, because the class in which the exception occurred is made unavailable for further use (such as instantiating the class), yielding a NoClassDefFoundError.You can refer to JLS - Detailed Initialization Procedure", "label": {"api": {"ExceptionInInitializerError": [[0, 26]], "Error": [[22, 26], [70, 74], [270, 274]]}}}, {"text": "List#contains() method uses the equals() method to evaluate if two objects are the same", "label": {"api": {"List#contains()": [[0, 14]]}}}, {"text": "You could use the File class to get the file name", "label": {"api": {"File": [[18, 21]]}}}, {"text": "Using a File object has numerous benefits, including the ability to test the file exists", "label": {"api": {"File": [[8, 11]]}}}, {"text": "I need to print small numbers (percents on histograms) but java.text.DecimalFormat do something strange", "label": {"api": {"java.text.DecimalFormat": [[59, 81]]}}}, {"text": "Seems java.text.DecimalFormat designed for formatting currency only..", "label": {"api": {"java.text.DecimalFormat": [[6, 28]]}}}, {"text": "Is it possible to get grouping in fractional part with java.text.DecimalFormat", "label": {"api": {"java.text.DecimalFormat": [[55, 77]]}}}, {"text": "You can probably use ExecutorService, by extracting new SmsConnection().doResponseRequest(sms); into Callable", "label": {"api": {"ExecutorService": [[21, 35]], "Callable": [[101, 108]]}}}, {"text": "If you want your map to be serialized in the order you inserted data into it then use a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[88, 100]]}}}, {"text": "How can I adjust this Timer code so that it executes four times and then stops", "label": {"api": {"Timer": [[22, 26]]}}}, {"text": "Try substring  and lastIndexOf method of String Class", "label": {"api": {"String Class": [[41, 52]]}}}, {"text": "Char.getNumericValue is a static method which takes the value as an argument", "label": {"api": {"Char.getNumericValue": [[0, 19]]}}}, {"text": "Talking about a http://docs.oracle.com/javase/6/docs/api/java/nio/channels/WritableByteChannel.html of course", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/nio/channels/WritableByteChannel.html": [[16, 98]]}}}, {"text": "Try wrapping it into a ThreadLocal", "label": {"api": {"ThreadLocal": [[23, 33]]}}}, {"text": "The ExecutorService simply interrupts the running tasks; it is up to the implementation of the tasks if they really cancel their endeavor", "label": {"api": {"interrupts": [[27, 36]]}}}, {"text": "The default Layout for JFrame is BorderLayout", "label": {"api": {"BorderLayout": [[33, 44]]}}}, {"text": "BorderLayout doesn't respect the setSize(..) method of components being added to them", "label": {"api": {"BorderLayout": [[0, 11]]}}}, {"text": "If you still want to give a preferred size to the component being added to JFrame you should change the layout to be FlowLayout or GridLayout or others.", "label": {"api": {"FlowLayout": [[117, 126]], "GridLayout": [[131, 140]]}}}, {"text": "and then use setPreferredSize(..) method with the component while adding it to the JFrame", "label": {"api": {"setPreferredSize(..)": [[13, 32]]}}}, {"text": "Have you tried using  System.load() instead", "label": {"api": {"System.load()": [[22, 34]]}}}, {"text": "first sort your List, then get a sublist from 0 to 499", "label": {"api": {"sort": [[6, 9]]}}}, {"text": "Keep in mind that sorting the original list modifies it in place", "label": {"api": {"sort": [[18, 21]]}}}, {"text": "If you want to preserve the original list, you should make a copy prior to sorting", "label": {"api": {"sort": [[75, 78]]}}}, {"text": "In Java, sleep is a static member function of class Thread that causes the thread that calls it to sleep", "label": {"api": {"sleep": [[9, 13], [99, 103]], "Thread": [[52, 57]]}}}, {"text": "In this context, class is part of a class literal referring to the Class object representing that class", "label": {"api": {"Class": [[67, 71]]}}}, {"text": "In this context class is not a keyword, it's a special attribute (a \"class literal\") of a class denoting its corresponding instance of Class", "label": {"api": {"Class": [[135, 139]]}}}, {"text": "For example, to obtain the Class object of String, we do this", "label": {"api": {"Class": [[27, 31]]}}}, {"text": "The value returned is the instance of Class that represents String's class (notice the use of upper and lowercase)", "label": {"api": {"Class": [[38, 42]]}}}, {"text": "Continuing with our example, this snippet returns the same instance of Class corresponding to a String", "label": {"api": {"Class": [[71, 75]]}}}, {"text": "You can use an undecorated dialog with a background image and a progress bar while loading stuffs in a SwingWorker", "label": {"api": {"SwingWorker": [[103, 113]]}}}, {"text": "An alternative is to use the SplashScreen API", "label": {"api": {"SplashScreen": [[29, 40]]}}}, {"text": "I need to create a SplashScreen programmatically and add text to it (and change it)", "label": {"api": {"SplashScreen": [[19, 30]]}}}, {"text": "Call SplashScreen.createGraphics() and paint as needed", "label": {"api": {"SplashScreen": [[5, 16]], "SplashScreen.createGraphics()": [[5, 33]]}}}, {"text": "You will find that Exception#getCause() returns null when the cause of the exception is itself, thus your e.getCause().toString() will throw a NullPointerException", "label": {"api": {"Exception#getCause()": [[19, 38]]}}}, {"text": "printStackTrace() will print out the entire Stack Trace of the exception, allowing for an easier time debugging, however to fix this error, just change your JOptionPane statement to", "label": {"api": {"printStackTrace()": [[0, 16]]}}}, {"text": "You are getting a list of all the methods on a class with getDeclaredMethods", "label": {"api": {"getDeclaredMethod": [[58, 74]]}}}, {"text": "Try using the getDeclaredMethod (singular) method, which takes as a parameter the method name and a varargs argument for the classes of the parameter types", "label": {"api": {"getDeclaredMethod": [[14, 30]]}}}, {"text": "Look into the methods of RuntimeMXBean", "label": {"api": {"RuntimeMXBean": [[25, 37]]}}}, {"text": "You are right that the SerialBlob is just a thin abstraction around a byte[], but", "label": {"api": {"SerialBlob": [[23, 32]]}}}, {"text": "If you anwsered any of the above questions with a yes, you should probably use SerialBlob", "label": {"api": {"SerialBlob": [[79, 88]]}}}, {"text": "But if you use SerialBlob, it's obvious that this is just a blob of binary data from the database / to be stored in the database", "label": {"api": {"SerialBlob": [[15, 24]]}}}, {"text": "The SerialBlob code has been tested by thousands of people around the world and it's safe to say that you won't get any bugs associated to it", "label": {"api": {"SerialBlob": [[4, 13]]}}}, {"text": "If you'll ever see a SerialBlob in anyone's project, the usage will be clear to you", "label": {"api": {"SerialBlob": [[21, 30]]}}}]