[{"text": "I would  use a Timer or else I would use the Quartz Scheduler - the former is more lightweight, while the latter is (optionally) durable (meaning that scheduled tasks will be saved to a database and reloaded when your program restarts)", "label": {"api": {"Timer": [[15, 19]]}}}, {"text": "Either TimerTask (or) ScheduledExecutorServices implementations would be best options for this task", "label": {"api": {"ScheduledExecutorServices": [[22, 46]]}}}, {"text": "Have a look at the description of Decorator on internet, and for good example have a look at how the Reader / Writer standard Java classes are implemented", "label": {"api": {"Reader": [[101, 106]]}}}, {"text": "You can use simpler API method like containsValue()", "label": {"api": {"containsValue()": [[36, 50]]}}}, {"text": "Provided you mean .scheduleAtFixedRate() (note the little s), then it is a method provided by ScheduledExecutorService", "label": {"api": {"a method provided by ScheduledExecutorService": [[73, 117]]}}}, {"text": "See this Class#forName(String, boolean, ClassLoader) API", "label": {"api": {"Class#forName(String, boolean, ClassLoader) API": [[9, 55]]}}}, {"text": "For a simple extension mechanism have a look at ServiceLoader", "label": {"api": {"ServiceLoader": [[48, 60]]}}}, {"text": "You'll need to get at the constructor using Class.getDeclaredConstructor and then supply an instance of the enclosing class as an argument", "label": {"api": {"Class.getDeclaredConstructor": [[44, 71]]}}}, {"text": "You can simply use replaceAll", "label": {"api": {"replaceAll": [[19, 28]]}}}, {"text": "Java regex reference (see \"Groups and capturing\")", "label": {"api": {"Java regex reference": [[0, 19]]}}}, {"text": "You could, however, create a temporary file using File.createTempFile", "label": {"api": {"File.createTempFile": [[50, 68]]}}}, {"text": "You should look at javax.tools package documentation too", "label": {"api": {"javax.tools package documentation": [[19, 51]]}}}, {"text": "Just use a javax.swing.Timer, and in its actionPerformed() method, get the next 10 rows to display, and replace the rows in the model of the table by those next 10 rows", "label": {"api": {"javax.swing.Timer": [[11, 27]]}}}, {"text": "Create a ComponentListener and add the logic for your desired constraints in ComponentListener.componentResized()", "label": {"api": {"ComponentListener.componentResized()": [[77, 112]]}}}, {"text": "You can use ComponentListener and override its componentResized() method", "label": {"api": {"ComponentListener": [[12, 28]], "componentResized()": [[47, 64]]}}}, {"text": "If i were to iterate over this list printing each \"number\" using either Iterable.iterator() or a standard for loop with get(i) it'd output this", "label": {"api": {"Iterable.iterator()": [[72, 90]]}}}, {"text": "You can use ScriptEngine class and use eval() function", "label": {"api": {"ScriptEngine": [[12, 23]], "eval()": [[39, 44]]}}}, {"text": "FilterInputStream is an example of the the Decorator pattern", "label": {"api": {"FilterInputStream": [[0, 16]], "InputStream": [[6, 16]]}}}, {"text": "The derived class would add additional capabilities, but still expose the basic interface of an InputStream", "label": {"api": {"InputStream": [[96, 106]]}}}, {"text": "For example, a BufferedInputStream provides buffering of an underlying input stream to make reading data faster, and a DigestInputStream computes a cryptographic hash of data as it's consumed", "label": {"api": {"InputStream": [[23, 33], [125, 135]], "BufferedInputStream": [[15, 33]], "DigestInputStream": [[119, 135]]}}}, {"text": "You would use this to add functionality to existing code that depends on the InputStream or OutputStream API", "label": {"api": {"InputStream": [[77, 87]]}}}, {"text": "Instead of modifying the data persistence library, you can modify your application so that it \"decorates\" the stream that it currently creates with a ZipOutputStream", "label": {"api": {"ZipOutputStream": [[150, 164]]}}}, {"text": "FilterInputStream and FilterOutputStream are there to ease the job of developers who wish to implement their own input/output streams", "label": {"api": {"FilterInputStream": [[0, 16]], "FilterOutputStream": [[22, 39]]}}}, {"text": "Neither FilterInputStream nor FilterOutputStream are designed for end users to use directly", "label": {"api": {"FilterInputStream": [[8, 24]], "FilterOutputStream": [[30, 47]]}}}, {"text": "Another option would be to just throw away new Objects if the queue was full; you can achieve this with offer", "label": {"api": {"offer": [[104, 108]]}}}, {"text": "It seems to work just fine in this SSCCE that uses DISPOSE_ON_CLOSE for the dialogs as well as the frame", "label": {"api": {"DISPOSE_ON_CLOSE": [[51, 66]]}}}, {"text": "uses DISPOSE_ON_CLOSE consistently and the VM fails to terminate", "label": {"api": {"DISPOSE_ON_CLOSE": [[5, 20]]}}}, {"text": "You could use an ExecutorService to do tasks on the background and then use the methods of the Future you get back to wait for the result", "label": {"api": {"ExecutorService": [[17, 31]], "Future": [[95, 100]]}}}, {"text": "If you wish to print the results as they become available (in an unspecified order), then you could use a CompletionService, and instead of having a list of results and iterating on it, you'd get your futures from the CompletionService itself through its .take() method, that blocks until a computation is finished, or .poll(), which returns a Future if there there are finished computations, or null if there are no computations finished -- this way your main thread will never block", "label": {"api": {"Future": [[344, 349]], "CompletionService": [[106, 122], [218, 234]]}}}, {"text": "The following example uses a CompletionService", "label": {"api": {"CompletionService": [[29, 45]]}}}, {"text": "You should be able to use the classes in the  java.util.zip package to do what you want", "label": {"api": {"java.util.zip": [[46, 58]]}}}, {"text": "In particular, the SOURCE retention policy is defined as", "label": {"api": {"defined": [[46, 52]]}}}, {"text": "I recommend to have a look at the JavaDoc of JFrame", "label": {"api": {"JavaDoc of JFrame": [[34, 50]]}}}, {"text": "Because if you don't use atomic, operations with variables are not atomic", "label": {"api": {"atomic": [[25, 30], [67, 72]]}}}, {"text": "If you want to match content within an input which spans more than one line, you want Pattern.DOTALL", "label": {"api": {"Pattern.DOTALL": [[86, 99]]}}}, {"text": "For instance, if they get their value from a method that's using String.valueOf(foo), where foo was null, you'll be given a String containing the text \"null\", rather than one which has a value of null, i.e the difference between", "label": {"api": {"String.valueOf(foo)": [[65, 83]]}}}, {"text": "Adding to @jonskeet's @jule's answers, you should consider using ConcurrentHashMap (http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html) which does not require locking around iteration", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentHashMap.html": [[84, 167]]}}}, {"text": "BigInteger should help you to do that calculation", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "But I am afraid you can use Math.pow() , as it may not be able to generate the big number as you desire", "label": {"api": {"Math.pow()": [[28, 37]], "Math.pow": [[28, 35]]}}}, {"text": "Math.pow will be limited by the range of double as the method signature uses double for both input and returning the output", "label": {"api": {"Math.pow": [[0, 7]]}}}, {"text": "You may have to implement your own pow method which should return a BigInteger", "label": {"api": {"BigInteger": [[68, 77]]}}}, {"text": "I just checked it and found that java.math.BigInteger.pow(int exponent) will be your friend", "label": {"api": {"BigInteger": [[43, 52]], "java.math.BigInteger.pow(int exponent)": [[33, 70]]}}}, {"text": "Look at BigInteger", "label": {"api": {"BigInteger": [[8, 17]]}}}, {"text": "There is a difference in the displayed numerals because more digits are required to distinguish a double value from its neighbors, which is required by the Java documentation", "label": {"api": {"required by the Java documentation": [[140, 173]]}}}, {"text": "There is Math#min method", "label": {"api": {"Math#min": [[9, 16]]}}}, {"text": "You have to first parse the String using the parse method from SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[63, 78]]}}}, {"text": "Then pass the Date object returned by the parse method to another SimpleDateFormat and then using the format method get the date in the format you want", "label": {"api": {"SimpleDateFormat": [[66, 81]]}}}, {"text": "Using a RandomAccessFile and keeping a pointer to each file's start byte so that each entry can be looked up using seek()", "label": {"api": {"RandomAccessFile": [[8, 23]]}}}, {"text": "The Rectangle class would be a good way to pass x, y, width, and height values to the method", "label": {"api": {"Rectangle class": [[4, 18]]}}}, {"text": "To get a human-readable toString(), you must use Arrays.toString(), like this", "label": {"api": {"Arrays.toString()": [[49, 65]]}}}, {"text": "I am not sure it would be the best approach but you can make your class implement Closeable interface", "label": {"api": {"Closeable": [[82, 90]]}}}, {"text": "When enabled, the compiler will issue an error or a warning if a local variable holds a value of type 'java.lang.AutoCloseable' (compliance >= 1.7) or a value of type 'java.io.Closeable' (compliance <= 1.6) and if flow analysis shows that the method 'close()' is not invoked locally on that value", "label": {"api": {"Closeable": [[117, 125], [176, 184]]}}}, {"text": "creating a giant Vector1 ArrayList and sorting it", "label": {"api": {"Vector": [[17, 22]], "ArrayList": [[25, 33]]}}}, {"text": "If you know by advance the placements of your ints in the array, you can create it using new int[100000] and use Arrays.fill()", "label": {"api": {"Arrays.fill()": [[113, 125]]}}}, {"text": "The solution is to use a Semaphore", "label": {"api": {"Semaphore": [[25, 33]]}}}, {"text": "This is what Executors.newFixedThreadPool() does by default", "label": {"api": {"Executors.newFixedThreadPool()": [[13, 42]]}}}, {"text": "Since your array is sorted, you can use Arrays.binarySearch()", "label": {"api": {"Arrays.binarySearch()": [[40, 60]]}}}, {"text": "If you want to be more accurate in measuring the elapsed time you must use System.nanoTime() instead of using System.currentTimeMillis()", "label": {"api": {"System.nanoTime()": [[75, 91]], "System.currentTimeMillis()": [[110, 135]]}}}, {"text": "The closest to what you're looking for is a NavigableSet, which has the following method", "label": {"api": {"following method": [[72, 87]]}}}, {"text": "Also, note that if what you need is a Map, NavigableMap has a similar method", "label": {"api": {"similar method": [[62, 75]]}}}, {"text": "You can try using a Map to store the identifier-value pairs instead", "label": {"api": {"Map": [[20, 22]]}}}, {"text": "I recently discovered that class ProcessBuilder in JDK6 does not override equals()", "label": {"api": {"ProcessBuilder": [[33, 46]]}}}, {"text": "I looked into the JDK6 source code for class ProcessBuilder, and I do not see an override for equals()", "label": {"api": {"ProcessBuilder": [[45, 58]]}}}, {"text": "You can look into java.nio.ByteBuffer which provides the methods getLong(), getDouble() and getInt()", "label": {"api": {"java.nio.ByteBuffer": [[18, 36]]}}}, {"text": "You can use an ObjectOutputStream to write objects which implement the Serializable interface", "label": {"api": {"ObjectOutputStream": [[15, 32]]}}}, {"text": "Package.getPackage only returns packages that are already known to the current class loader, and the only way to do that is by loading a class from that package", "label": {"api": {"Package.getPackage": [[0, 17]]}}}, {"text": "It's basically a wrapper for ClassLoader.getPackage", "label": {"api": {"ClassLoader.getPackage": [[29, 50]]}}}, {"text": "In that same jar, there is a set of @Providers which I would like replace with my own", "label": {"api": {"@Provider": [[36, 44]]}}}, {"text": "I was able to solve this in JBoss AS 7 by specifying the providers and resources manually in my Application class", "label": {"api": {"Application": [[96, 106]]}}}, {"text": "By default, when you do not override the getClasses() method, JBoss would automatically scan for every provider and resource", "label": {"api": {"getClasses()": [[41, 52]]}}}, {"text": "That said, you should be using prepared statements", "label": {"api": {"prepared statements": [[31, 49]]}}}, {"text": "Extend XmlFilterImpl (a SAX filter) to remove the tags from other namespaces (and everything inside those tags) before the schema validator sees them", "label": {"api": {"XmlFilterImpl": [[7, 19]]}}}, {"text": "ServletRequest.setCharacterEncoding() only affects Parameters submitted in the body of the request", "label": {"api": {"ServletRequest.setCharacterEncoding()": [[0, 36]]}}}, {"text": "ServletRequest.getParameterMap() is returning a Map filled with both - form-data from the request-body and URL-Parameters", "label": {"api": {"ServletRequest.getParameterMap()": [[0, 31]]}}}, {"text": "What I'm doing now is parsing HttpServletRequest.getQueryString() with URLEncodedUtils and overwriting every parameter in the requestParameterMap which comes from the queryString", "label": {"api": {"HttpServletRequest.getQueryString()": [[30, 64]]}}}, {"text": "Count blinks and when it is enough call stop on your timer", "label": {"api": {"stop": [[40, 43]]}}}, {"text": "Note that more generally, you can use a Formatter", "label": {"api": {"Formatter": [[40, 48]]}}}, {"text": "If you use Java 8 and if it is possible that your search returns null, you could try using the  Optional class", "label": {"api": {"Optional": [[96, 103]]}}}, {"text": "it is an Iterator, whereas it.next() is an InstallationComponentSetup", "label": {"api": {"Iterator": [[9, 16]], "it.next()": [[27, 35]]}}}, {"text": "The error results from the fact that an Iterator cannot be cast as an InstallationComponentSetup", "label": {"api": {"Iterator": [[40, 47]]}}}, {"text": "Also, you shouldn't even need to cast if you parametrize the Iterator appropriately", "label": {"api": {"Iterator": [[61, 68]]}}}, {"text": "Finally, don't compare strings with something like a == b, instead use a.equals(b)", "label": {"api": {".equals": [[72, 78]]}}}, {"text": "I've always used a FileWriter to write text to a file in Java", "label": {"api": {"FileWriter": [[19, 28]]}}}, {"text": "Apparently you can also use a BufferedOutputStream as well", "label": {"api": {"BufferedOutputStream": [[30, 49]]}}}, {"text": "I suggest you use the BufferedReader class and use the ReadLine method to extract the line from the file", "label": {"api": {"BufferedReader": [[22, 35]]}}}, {"text": "In your activity create an ArrayList or a List holding elements of type Coordinates", "label": {"api": {"ArrayList": [[27, 35]], "List": [[32, 35], [42, 45]]}}}, {"text": "Add on every button click a new element of type Coordinates to your ArrayList", "label": {"api": {"ArrayList": [[68, 76]], "List": [[73, 76]]}}}, {"text": "Later at some point where you need the coordinates just fetch them with get or remove and use the coordinates", "label": {"api": {"get": [[72, 74]], "remove": [[79, 84]]}}}, {"text": "Use Map.Entry.setValue to change the value of the mapping", "label": {"api": {"Map.Entry.setValue": [[4, 21]]}}}, {"text": "Instead what it does (by default) is to always grant access unless the ThreadGroup in question is the system thread group in which case the \"modifyThreadGroup\" permission is checked", "label": {"api": {"by default": [[22, 31]]}}}, {"text": "Since java.lang.instrument is not there then you can't use it and create javaagent", "label": {"api": {"java.lang.instrument": [[6, 25]]}}}, {"text": "For your first error, you're trying to invoke String.toCharArray on a String[]", "label": {"api": {"String.toCharArray": [[46, 63]]}}}, {"text": "For your second error, you need to import java.util.Arrays", "label": {"api": {"java.util.Arrays": [[42, 57]]}}}, {"text": "Apparently, you need to take a look at ColorConvertOp in java.awt.image", "label": {"api": {"ColorConvertOp": [[39, 52]]}}}, {"text": "However, if you want your collection to only contain unique items, why not use a Set instead", "label": {"api": {"Set": [[81, 83]]}}}, {"text": "If you still want to use a List, you can use your current approach, it just that the characteristics of a Set are that all items in a Set are unique, so a Set might make sense here", "label": {"api": {"Set": [[106, 108], [134, 136], [155, 157]]}}}, {"text": "If you're only communicating between threads and not processes then you can use a BlockingQueue or a PriorityBlockingQueue (most systems I've worked with use RabbitMQ/ActiveMQ/ZeroMQ/HornetQ to communicate between processes, and then disseminate messages between threads using a [Priority]BlockingQueue)", "label": {"api": {"BlockingQueue": [[82, 94], [109, 121], [289, 301]], "PriorityBlockingQueue": [[101, 121]]}}}, {"text": "You can use DateFormat#format(Date) to print the date or return the String representation in your desired format i.e", "label": {"api": {"DateFormat#format(Date)": [[12, 34]]}}}, {"text": "You should be using the @ManyToMany annotation when you're avoiding a join table entity", "label": {"api": {"@ManyToMany": [[24, 34]]}}}, {"text": "To access images in a jar, use Class.getResource()", "label": {"api": {"Class.getResource()": [[31, 49]]}}}, {"text": "Java has a String.format method that works similarly to this", "label": {"api": {"String.format": [[11, 23]]}}}, {"text": "This is the documentation reference that explains what all those % options can be", "label": {"api": {"documentation reference": [[12, 34]]}}}, {"text": "You can do this (using String.format)", "label": {"api": {"String.format)": [[23, 36]]}}}, {"text": "The MessageFormat class looks like what you're after", "label": {"api": {"MessageFormat": [[4, 16]]}}}, {"text": "You can also make it with BufferedReader if you want to validate user input, like this", "label": {"api": {"BufferedReader": [[26, 39]]}}}, {"text": "Well, you could start by going to the documentation and counting the number of methods there, taking care to grab any from its super interface", "label": {"api": {"its super interface": [[123, 141]]}}}, {"text": "EventListener) or one method, others define many methods", "label": {"api": {"EventListener": [[0, 12]], "others define many": [[30, 47]]}}}, {"text": "For instance, Runnable has one important method, void run(), while List has [quite a few[(http://docs.oracle.com/javase/6/docs/api/java/util/List.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/List.html": [[90, 149]]}}}, {"text": "The official MouseListener as five", "label": {"api": {"five": [[30, 33]]}}}, {"text": "Basically you want a Java/Dalvik compiler that you can invoke programmically, similar to Java's javax.tools", "label": {"api": {"javax.tools": [[96, 106]]}}}, {"text": "The primary reason is to expose the Comparator object for things like TreeMap, where Strings can be used as keys, or other objects where ordering or a different kind of equality is useful", "label": {"api": {"TreeMap": [[70, 76]]}}}, {"text": "It can't be a static method since the Comparator interface can't specify a static method and the Comparator has to be an object that implements the interface to be used in classes like TreeMap", "label": {"api": {"TreeMap": [[185, 191]]}}}, {"text": "From the Javadocs for System.out", "label": {"api": {"the Javadocs for System.out": [[5, 31]]}}}, {"text": "Note, however, that System.out can be reassigned in Java, by using System.setOut()", "label": {"api": {"System.setOut()": [[67, 81]]}}}, {"text": "You could start a ScheduledExecutorService during context initialization or with an Application Scoped Bean Post construct method", "label": {"api": {"ScheduledExecutorService": [[18, 41]]}}}, {"text": "If such functionality is required, rewrite everything using while loop together with the Stack or ArrayDeque data structure instead", "label": {"api": {"Stack": [[89, 93]], "ArrayDeque": [[98, 107]]}}}, {"text": "Normally, using asSubclass can be used in similar situations, but since T has multiple bounds, I'm not able to use it without getting a compiler warning", "label": {"api": {"asSubclass": [[16, 25]]}}}, {"text": "As contains() method uses equals() method to determine whether an element exist or not in the set", "label": {"api": {"contains()": [[3, 12]], "equals()": [[26, 33]]}}}, {"text": "From the Set.contains() documentation", "label": {"api": {"Set.contains() documentation": [[9, 36]]}}}, {"text": "If this is not desired, create a SimpleDateFormat object to represent the desired formatting, and then call SimpleDateFormat#format(row.get(\"timeStamp\")) to have your value formatted properly", "label": {"api": {"SimpleDateFormat": [[33, 48], [108, 123]]}}}, {"text": "The SimpleDateFormat class describes how to define your date and time patterns", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Make sure to create the SimpleDateFormat object only once, since it's relatively expensive to create it", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "One common exception are the collections such as List", "label": {"api": {"such as List": [[41, 52]]}}}, {"text": "I've used BigDecimal for the conversion ratio and internal calculations in order to have greater control over precision and rounding behavior", "label": {"api": {"BigDecimal": [[10, 19]]}}}, {"text": "You could try using String.format, especially if you have multiple variable that you would like to use in this fashion within a single string", "label": {"api": {"String.format": [[20, 32]]}}}, {"text": "The java.sql.Connection object contains an isValid function that will make a connection to the underlying database", "label": {"api": {"isValid": [[43, 49]]}}}, {"text": "The principle is to build a multi part MimeMessage that you return within the synchronous/asynchronous response", "label": {"api": {"MimeMessage": [[39, 49]]}}}, {"text": "You could use a TreeMap which allows you to use a custom comparator that is case insensitive", "label": {"api": {"TreeMap": [[16, 22]]}}}, {"text": "Then load the content in a Properties and loop on its entries (it extends HashTable)", "label": {"api": {"Properties": [[27, 36]], "HashTable": [[74, 82]]}}}, {"text": "java.io.ByteArrayOutputStream is a stream implementation that collects content on an internal byte array, and you can wrap it in a java.io.OutputStreamWriter to write character content to it", "label": {"api": {"java.io.ByteArrayOutputStream": [[0, 28]]}}}, {"text": "You could try using a Map to mimic this, however", "label": {"api": {"Map": [[22, 24]]}}}, {"text": "I recommend that you use String.split()", "label": {"api": {"String.split()": [[25, 38]]}}}, {"text": "For the remaining Strings, you can use a for loop to call String.split() on each of them in turn, splitting on the '\\' character", "label": {"api": {"String.split()": [[58, 71]]}}}, {"text": "Alternatively, you can get each entry of a map using entrySet", "label": {"api": {"entrySet": [[53, 60]]}}}, {"text": "The code to iterate through your entrySet looks like", "label": {"api": {"entrySet": [[33, 40]]}}}, {"text": "The equals() contract implies that x.equals(y) returns true if and only if x.getClass() == y.getClass()", "label": {"api": {"equals() contract": [[4, 20]]}}}, {"text": "Just use String.replace(String, String), not replaceAll", "label": {"api": {"String.replace(String, String)": [[9, 38]]}}}, {"text": "To ensure accurate representation of a floating point number, you can use Java's built-in BigDecimal class", "label": {"api": {"BigDecimal": [[90, 99]]}}}, {"text": "If you want more precision, you can use Java's BigDecimal", "label": {"api": {"BigDecimal": [[47, 56]]}}}, {"text": "The BigDecimal class can give you \"arbitrary-precision signed decimal numbers\", which is what you want in this case, although the instances of BigDecimal are a little more tricky to work with than literals, the class actually works quickly and can be used to do what you need fairly accurately", "label": {"api": {"BigDecimal": [[4, 13], [143, 152]]}}}, {"text": "As an alternative, I'd suggest you build an immutable key with the concatenation of the strings in the ArrayList, or use an immutable list created with Collections.unmodifiableList() or even better, only use the id column, it doesn't make any sense to use the entire row as a key", "label": {"api": {"Collections.unmodifiableList()": [[152, 181]]}}}, {"text": "Use a TreeSet (or TreeMultiset)", "label": {"api": {"TreeSet": [[6, 12]]}}}, {"text": "Java regex reference", "label": {"api": {"Java regex reference": [[0, 19]]}}}, {"text": "Why not use a thread pool, and in particular a fixed size thread pool", "label": {"api": {"fixed size thread pool": [[47, 68]]}}}, {"text": "Replace the .*s with (.*)s and use matcher.group(n)", "label": {"api": {"matcher.group(n)": [[35, 50]]}}}, {"text": "Also, since you mentioned you won't know how many .*s your regex will contain, there is a matcher.groupCount() method you can use, if the only capturing groups in your regex will indeed be (.*)s", "label": {"api": {"matcher.groupCount()": [[90, 109]], "capturing groups": [[143, 158]]}}}, {"text": "For your own enlightenment, try reading about capturing groups", "label": {"api": {"capturing groups": [[46, 61]]}}}, {"text": "If you want your input string to use this format (yyyyMMddTHH:mm:ss.SSSZ), assuming the SimpleDateFormat formatting and only allow inputs in the UTC timezone, simply check that the string ends with 00, +0000 or -0000 before passing it to the parser", "label": {"api": {"SimpleDateFormat": [[88, 103]]}}}, {"text": "I would just use a Character object to keep it simple", "label": {"api": {"Character": [[19, 27]]}}}, {"text": "In short, what you want is impossible unless your stream is seekable, but these are generally specialized streams for very specific applications and specialized I/O objects, like RandomAccessFile", "label": {"api": {"RandomAccessFile": [[179, 194]]}}}, {"text": "If you just want to read them sequentially as a single InputStream, you can construct a SequenceInputStream that concatenates any two input streams together", "label": {"api": {"SequenceInputStream": [[88, 106]]}}}, {"text": "This is because of the way List.subList() works", "label": {"api": {"List.subList()": [[27, 40]]}}}, {"text": "From the DataInputStream Javadoc", "label": {"api": {"DataInputStream Javadoc": [[9, 31]]}}}, {"text": "When writing Java program, we use setSeed in the Random class", "label": {"api": {"setSeed": [[34, 40]]}}}, {"text": "Can't we just use Random without using setSeed", "label": {"api": {"setSeed": [[39, 45]]}}}, {"text": "What is the main purpose of using setSeed", "label": {"api": {"setSeed": [[34, 40]]}}}, {"text": "You can use Matcher", "label": {"api": {"Matcher": [[12, 18]]}}}, {"text": "For more details see StringTokenizer", "label": {"api": {"StringTokenizer": [[21, 35]]}}}, {"text": "In order to have the same behaviour with arrays as with primitive types, you could use Arrays.copyOf(boolean[], int) instead", "label": {"api": {"Arrays.copyOf(boolean[], int)": [[87, 115]]}}}, {"text": "You should rather consider using a List<Character> instead", "label": {"api": {"List<Character>": [[35, 49]]}}}, {"text": "String class provides a method - String.toCharArray(), which creates a character array out of your String object", "label": {"api": {"String.toCharArray()": [[33, 52]]}}}, {"text": "Note that File.lastModified() returns 0 if the file does not exists (which might be unexpected)", "label": {"api": {"File.lastModified()": [[10, 28]]}}}, {"text": "JComboBox's addItem takes an object and then converts it to a string for display, so when you do getSelectedItem() the whole object, id and label and everything else, will be returned", "label": {"api": {"JComboBox's addItem": [[0, 18]]}}}, {"text": "In addition to flush, you need reset (in ObjectOutputStream)", "label": {"api": {"ObjectOutputStream": [[41, 58]]}}}, {"text": "You can try itemStateChanged() method of the ItemListener interface", "label": {"api": {"ItemListener": [[45, 56]]}}}, {"text": "Instead of using Vector, you can create a DefaultTableModel then set it as the model of the table, then invoke its addRow method to directly put the read line result to the table", "label": {"api": {"DefaultTableModel": [[42, 58]]}}}, {"text": "Check BigDecimal doc for more informations on each rounding available", "label": {"api": {"BigDecimal doc": [[6, 19]]}}}, {"text": "ArrayBlockingQueue is in the java.util.concurrent package because multiple threads can use the object concurrently without thread-safety problems", "label": {"api": {"java.util.concurrent": [[29, 48]]}}}, {"text": "Instead, you may wish to try using String.matches()", "label": {"api": {"String.matches()": [[35, 50]]}}}, {"text": "I believe you should try using writeInt() and readInt() to write and read int", "label": {"api": {"writeInt()": [[31, 40]], "readInt()": [[46, 54]]}}}, {"text": "Because parse() can throw a ParseException and it is a checked Exception", "label": {"api": {"parse()": [[8, 14]], "ParseException": [[28, 41]]}}}, {"text": "The parse method throws a checked exception, ParseException (it's not a RuntimeException), so it must be caught or else it's a compiler error", "label": {"api": {"parse": [[4, 8]], "ParseException": [[45, 58]]}}}, {"text": "It is always considered to be a wise practice to call Window.pack(), on the container, which causes this Window to be sized to fit the preferred size and layouts of its subcomponents", "label": {"api": {"Window.pack()": [[54, 66]]}}}, {"text": "Use long for results smaller than 2^63 or java.math.BigInteger for all possible integers which fit in your memory", "label": {"api": {"java.math.BigInteger": [[42, 61]]}}}, {"text": "Use String.matches() with the appropriate regex to test if it's all lowercase letters", "label": {"api": {"String.matches()": [[4, 19]]}}}, {"text": "An enum is a class that inherits from the Enum class with (a) a private constructor, as you mentioned; and (b) a fixed list of named, final instances", "label": {"api": {"Enum": [[42, 45]]}}}, {"text": "Each constant has a special, compiler-generated, 0-based, monotonically increasing, dense ordinal() value assigned to it", "label": {"api": {"ordinal()": [[90, 98]]}}}, {"text": "(In other words, the first has ordinal 0, then second has ordinal 1, and so on.) This allows for extremely efficient array-based data structures like EnumMap to be created", "label": {"api": {"Enum": [[150, 153]], "EnumMap": [[150, 156]]}}}, {"text": "The java class MessageDigest should be of some use", "label": {"api": {"MessageDigest": [[15, 27]]}}}, {"text": "You can just use replaceAll in conjunction with the regular expression \\p{Lower}", "label": {"api": {"replaceAll": [[17, 26]]}}}, {"text": "Try using executeUpdate instead of execute", "label": {"api": {"executeUpdate": [[10, 22]], "execute": [[10, 16], [35, 41]]}}}, {"text": "There are some strange problems with execute while doing the table UPDATE", "label": {"api": {"execute": [[37, 43]]}}}, {"text": "You can't instantiate new Map<String, Map<Integer, Integer>>() because java.util.Map is an interface (it doesn't have a constructor)", "label": {"api": {"java.util.Map": [[71, 83]]}}}, {"text": "You need to use a concrete type like java.util.HashMap", "label": {"api": {"java.util.HashMap": [[37, 53]]}}}, {"text": "Another technique (besides the one shown by @MichaelShrestha) is to put the entire range of numbers in a collection, then shuffle it and take the numbers in the shuffled order", "label": {"api": {"shuffle": [[122, 128], [161, 167]]}}}, {"text": "We can't pass the tablename directly to PreparedStatement as table name cannot be a bind variable", "label": {"api": {"PreparedStatement": [[40, 56]]}}}, {"text": "A SQL statement is precompiled and stored in a PreparedStatement object", "label": {"api": {"PreparedStatement": [[47, 63]]}}}, {"text": "If you want newlines to be matched, your regex must have the flag Pattern.DOTALL", "label": {"api": {"Pattern.DOTALL": [[66, 79]]}}}, {"text": "Therefore, this solution is even better, and does not require Pattern.DOTALL", "label": {"api": {"Pattern.DOTALL": [[62, 75]]}}}, {"text": "You can also look into concurrent collections like ConcurrentSkipList or CopyOnWriteArraySet", "label": {"api": {"ConcurrentSkipList": [[51, 68]], "CopyOnWriteArraySet": [[73, 91]]}}}, {"text": "But as @jlordo suggested, it's a better approach to have a Map that contains a String key which will represent the array's name, and the actual array as the value", "label": {"api": {"Map": [[59, 61]]}}}, {"text": "The most simple (and yet most labor intensive) approach would be to open an HttpURLConnection", "label": {"api": {"HttpURLConnection": [[76, 92]]}}}, {"text": "You can do that by calling URL.openConnection()", "label": {"api": {"URL.openConnection()": [[27, 46]]}}}, {"text": "Javas built in hashTable handles this as they compare the String entered if there are several strings that get the same id when entered", "label": {"api": {"hashTable": [[15, 23]]}}}, {"text": "The best way to store settings/preferences in java is to use the Preferences API", "label": {"api": {"Preferences API": [[65, 79]]}}}, {"text": "getDate() (which is deprecated btw) returns the day of the month, and it's returning 4 (instead of 3) because in your timezone, that epoch time is already into the next day, whereas in England (GMT) it's still day 3 of the month", "label": {"api": {"getDate()": [[0, 8]]}}}, {"text": "When you have doubts like this you should refer to the official documentation of the class", "label": {"api": {"official documentation of the class": [[55, 89]]}}}, {"text": "Refer to Conversion of Audio Format  It is similar to your issue suggesting looking at the AudioSystem API", "label": {"api": {"AudioSystem": [[91, 101]]}}}, {"text": "Try using BufferedReader and BufferedWriter instead of writing bytes one by one", "label": {"api": {"BufferedReader": [[10, 23]], "BufferedWriter": [[29, 42]]}}}, {"text": "Are you aware of what the Thread class is for", "label": {"api": {"what the Thread class is for": [[17, 44]]}}}, {"text": "Additionally, to print the array's contents properly, you'll need to call Arrays.toString", "label": {"api": {"Arrays.toString": [[74, 88]]}}}, {"text": "The most direct way to solve this problem would be to have the void methods return Void instead, which you've already called out", "label": {"api": {"Void": [[83, 86]]}}}, {"text": "You can use a java HashMap which behaves much like an associative array where you can have a key that is an Object and a value that is an Object as well", "label": {"api": {"HashMap": [[19, 25]]}}}, {"text": "Check out HashMap's", "label": {"api": {"HashMap": [[10, 16]]}}}, {"text": "There is also a size method on the HashMap which could be useful to you", "label": {"api": {"HashMap": [[35, 41]]}}}, {"text": "The getRGB method returns an int whose 4 bytes are the alpha, red, green, and blue components in that order", "label": {"api": {"getRGB": [[4, 9]]}}}, {"text": "Assuming you're using Java 7, take a look at TransferQueue", "label": {"api": {"TransferQueue": [[45, 57]]}}}, {"text": "You can use Arrays.asList and List.toArray for conversions, as necessary", "label": {"api": {"Arrays.asList": [[12, 24]], "List.toArray": [[30, 41]]}}}, {"text": "From the List.equals documentation", "label": {"api": {"List.equals": [[9, 19]]}}}, {"text": "You could use the putAll method", "label": {"api": {"putAll": [[18, 23]]}}}, {"text": "Also, since you're overriding equals method, it would be good if you override hashCode method as well, as stated in Object#equals contract", "label": {"api": {"Object#equals": [[116, 128]]}}}, {"text": "This is because TreeSet implements SortedSet interface", "label": {"api": {"SortedSet": [[35, 43]]}}}, {"text": "Refer to SortedSet javadoc (emphasis mine)", "label": {"api": {"SortedSet": [[9, 17]]}}}, {"text": "The elements are ordered using their natural ordering(i.e", "label": {"api": {"natural ordering": [[37, 52]]}}}, {"text": "Since, javax.mail.internet.MimeMessage does not implement this interface it cannot be serialized", "label": {"api": {"javax.mail.internet.MimeMessage": [[7, 37]]}}}, {"text": "This also requires the classes, whose instances shall be serialized, to implement the interface Serializable", "label": {"api": {"Serializable": [[96, 107]]}}}, {"text": "Note, that arrays automatically implement Serializable", "label": {"api": {"Serializable": [[42, 53]]}}}, {"text": "You should use DecimalFormat to print numbers in specified format", "label": {"api": {"DecimalFormat": [[15, 27]]}}}, {"text": "Also you can configure count of fraction digits using method DecimalFormat#setMaximumFractionDigits(int)", "label": {"api": {"DecimalFormat": [[61, 73]], "DecimalFormat#setMaximumFractionDigits(int)": [[61, 103]]}}}, {"text": "JPA offers AttributeOverride, so you can map it like this", "label": {"api": {"AttributeOverride": [[11, 27]]}}}, {"text": "Use a ScheduledExecutorService instead of a Timer, and use a ThreadFactory which spawns a daemon thread instead of a normal thread", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "For more information, do check the API reference http://docs.oracle.com/javase/6/docs/api/java/lang/String.html for equals() method", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[49, 110]]}}}, {"text": "The access type can be customized with the Access annotation", "label": {"api": {"Access": [[43, 48]]}}}, {"text": "You have a (swallowed) NullPointerException (NPE) in RepaintTheFrame.run(), which causes ScheduledThreadPoolExecutor.scheduleAtFixedRate() to run only once, per scheduleAtFixedRate()'s javadoc", "label": {"api": {"scheduleAtFixedRate()'s javadoc": [[161, 191]]}}}, {"text": "Try using a BigDecimal for large decimal numbers", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "See JPEG Image Metadata DTD for documentation on the metadata format, and what options you can control", "label": {"api": {"JPEG Image Metadata DTD": [[4, 26]]}}}, {"text": "You can place the labels within an array an then select a random element from it, by using the java.util.Random class", "label": {"api": {"java.util.Random": [[95, 110]]}}}, {"text": "I am pretty sure what you are looking for is Object, the \"mother of all classes\"", "label": {"api": {"Object": [[45, 50]]}}}, {"text": "Use a Map<String, Object> and every value in the map can have a different type", "label": {"api": {"Object": [[18, 23]]}}}, {"text": "For extended precision, you should use BigDecimal", "label": {"api": {"BigDecimal": [[39, 48]]}}}, {"text": "One way would be to create a Date from it and then use the Calendar class", "label": {"api": {"Date": [[29, 32]]}}}, {"text": "See also the javadoc for ByteArrayOutputStream", "label": {"api": {"javadoc for ByteArrayOutputStream": [[13, 45]]}}}, {"text": "If you want to compare the output of two programs, I suggest using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[67, 80]]}}}, {"text": "The Process object returned by ProcessBuilder.start() will give you access to the standard streams of the child processes, and you can read them at your leisure", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "This is how to add a delete key listener to your JFileChooser", "label": {"api": {"JFileChooser": [[49, 60]]}}}, {"text": "And I would utilize StringTokenizer to do something like this", "label": {"api": {"StringTokenizer": [[20, 34]]}}}, {"text": "You need to do this in a separate thread and post back to the GUI thread via runOnUiThread with a runnable to set text of your timer", "label": {"api": {"runnable": [[98, 105]]}}}, {"text": "For an immutable list, use Collections.unmodifiableList or Collections.unmodifiableCollection methods like this", "label": {"api": {"Collections.unmodifiableList": [[27, 54]], "Collections.unmodifiableCollection": [[59, 92]]}}}, {"text": "To get the entire input in the user's input line, try using the nextLine() method instead", "label": {"api": {"nextLine()": [[64, 73]]}}}, {"text": "Try this code where I use Collections.sort()", "label": {"api": {"Collections.sort()": [[26, 43]]}}}, {"text": "I'm trying to run a command in a docker container using Java's ProcessBuilder", "label": {"api": {"ProcessBuilder": [[63, 76]]}}}, {"text": "Better use a HashSet", "label": {"api": {"HashSet": [[13, 19]]}}}, {"text": "If not possible then you can use a temporary HashSet for this", "label": {"api": {"HashSet": [[45, 51]]}}}, {"text": "Try using a FileInputStream instead of a BufferedReader/Writer", "label": {"api": {"FileInputStream": [[12, 26]]}}}, {"text": "When I used a FileInputStream, I could copy a dummy log file that had over 36 MILLION lines and was almost 500MB in size in less than a few seconds", "label": {"api": {"FileInputStream": [[14, 28]]}}}, {"text": "Javadoc for Enum", "label": {"api": {"Javadoc for Enum": [[0, 15]]}}}, {"text": "Using an unsynchronized collection in an multithreaded environment will cause problems like dirty reads (inconsistent data state) and ConcurrentModificationException (mostly when one thread has modified the contents of the collection while another was iterating through it)", "label": {"api": {"ConcurrentModificationException": [[134, 164]]}}}, {"text": "I'd suggest taking a look at the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[33, 52]]}}}, {"text": "This means they do not throw the ConcurrentModificationException, and may proceed concurrently with other operations", "label": {"api": {"ConcurrentModificationException": [[33, 63]]}}}, {"text": "I was playing with BigDecimal in Java and figured out that you can use its .divide() function to make exact divisions, but this function throws an ArithmeticException if the division is not exact", "label": {"api": {"its .divide() function": [[71, 92]]}}}, {"text": "You can split() the String using a regex , like \"(?<!(^|[A-Z0-9]))(?=[A-Z0-9])|(?<!^)(?=[A-Z][a-z])\" and then append - at the end of each split", "label": {"api": {"split()": [[8, 14]]}}}, {"text": "The method getConnection() returns a object of type java.sql.Connection which implements java.lang.AutoCloseable since Java 7", "label": {"api": {"java.sql.Connection": [[52, 70]], "java.lang.AutoCloseable": [[89, 111]]}}}, {"text": "Eclipse generates this warning when it can not determine whether a resource which implements either java.io.Closeable or java.lang.AutoCloseable gets closed by all possible code paths", "label": {"api": {"java.lang.AutoCloseable": [[121, 143]]}}}, {"text": "Then hand this to your scanner", "label": {"api": {"scanner": [[23, 29]]}}}, {"text": "You should definitely try reading with BufferedReader", "label": {"api": {"BufferedReader": [[39, 52]]}}}, {"text": "BufferedReader also has a larger buffer of around 8 KB", "label": {"api": {"BufferedReader": [[0, 13]]}}}, {"text": "The short answer is that all dynamicially allocated memory (heap) is shared by all threads unless you use Java's ThreadLocal class to declare variables that are local only to the thread", "label": {"api": {"ThreadLocal class": [[113, 129]]}}}, {"text": "As sk4l mentioned there is a getThreadAllocatedBytes method of ThreadMXBean method if your JVM supports it, but keep in mind this is typically just an approximate value", "label": {"api": {"ThreadMXBean": [[63, 74]]}}}, {"text": "Can you use Collections.shuffle() in your code", "label": {"api": {"Collections.shuffle()": [[12, 32]]}}}, {"text": "Deflater.setLevel() does not work as expected for me", "label": {"api": {"Deflater.setLevel()": [[0, 18]]}}}, {"text": "You can split your string using split() method of String class, which gives you an array of String", "label": {"api": {"split()": [[32, 38]]}}}, {"text": "Use a Scanner", "label": {"api": {"Scanner": [[6, 12]]}}}, {"text": "Using split is another way to do this, as is StringTokenizer", "label": {"api": {"StringTokenizer": [[45, 59]]}}}, {"text": "Try using the getClickCount() of MouseEvent method after implementing the MouseListener or extending the MouseAdapter", "label": {"api": {"getClickCount()": [[14, 28]]}}}, {"text": "Checking the Oracle Doc for Vector class it's pretty easy to understand its usage", "label": {"api": {"Oracle Doc": [[13, 22]]}}}, {"text": "Java 7 defines this option, yet I fail to understand its usefulness.Consider this simple program, run on a recent enough Linux machine, with a Java 6 JVM", "label": {"api": {"defines this option": [[7, 25]]}}}, {"text": "Try using this constructor", "label": {"api": {"this constructor": [[10, 25]]}}}, {"text": "The Properties class extends the Hashtable class", "label": {"api": {"Properties": [[4, 13]], "Hashtable": [[33, 41]]}}}, {"text": "Incidentally, the fact that Properties extends Hashtable, instead of using Hashtable, is considered one of the many design \"mistakes\" in the JDK", "label": {"api": {"Properties": [[28, 37]], "Hashtable": [[47, 55], [75, 83]]}}}, {"text": "Using nextInt(2) is a good alternative", "label": {"api": {"nextInt(2)": [[6, 15]]}}}, {"text": "java.util.Collections.shuffle method shuffle a List with equal likelihood", "label": {"api": {"java.util.Collections.shuffle": [[0, 28]]}}}, {"text": "The thing is, you'd need to create (or adjust) an EditorKit can have new elements defined", "label": {"api": {"EditorKit": [[50, 58]]}}}, {"text": "is seen in the AppletEditorKit", "label": {"api": {"EditorKit": [[21, 29]]}}}, {"text": "System.out.println uses the standard output stream, which can be a console or something else (say you IDE's output window for example)", "label": {"api": {"the standard output stream": [[24, 49]]}}}, {"text": "The javadocs on this topic isn't bad either", "label": {"api": {"The javadocs on this topic": [[0, 25]]}}}, {"text": "Shutdown the TCP connection in the send direction triggering the normal close sequence", "label": {"api": {"Shutdown the TCP connection in the send direction": [[0, 48]]}}}, {"text": "I prefer to use java.util.List  as it's reduce a lot of codes", "label": {"api": {"java.util.List": [[16, 29]]}}}, {"text": "There are quite a few examples of this in the standard library - for example, Map.put returns the previous value associated with a key, which can be useful but is often ignored", "label": {"api": {"Map.put": [[78, 84]]}}}, {"text": "The Javadoc for the Map interface states that get should return null for any key that does not have a mapping", "label": {"api": {"get": [[46, 48]]}}}, {"text": "Note however that some Map implementations may not allow null keys, in which case map.get(null) will throw a NullPointerException", "label": {"api": {"get": [[86, 88]]}}}, {"text": "An example of this is the ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[26, 42]]}}}, {"text": "It's paintComponent not PaintComponent", "label": {"api": {"paintComponent": [[5, 18]]}}}, {"text": "Add an ActionListener to the text field", "label": {"api": {"ActionListener": [[7, 20]]}}}, {"text": "The File class is for files on a \"normal\" file system (usually local, but potentially networked) - not URLs", "label": {"api": {"File": [[4, 7]], "URL": [[103, 105]]}}}, {"text": "That's what the URL class is for", "label": {"api": {"URL": [[16, 18]]}}}, {"text": "So you can either use that (with URLConnection) or use a dedicated HTTP 3rd party library, such as the Apache HttpClient library", "label": {"api": {"URL": [[33, 35]], "URLConnection": [[33, 45]]}}}, {"text": "1 I'm sure there are some shells which allow the use of URLs as if they were local filenames, but I'm talking about a more traditional approach", "label": {"api": {"URL": [[56, 58]]}}}, {"text": "For that you can use LinkedHashSet", "label": {"api": {"LinkedHashSet": [[21, 33]]}}}, {"text": "See Image Metadata DTD for docs on what data is available and how to access it", "label": {"api": {"Image Metadata DTD": [[4, 21]]}}}, {"text": "Also take a look at the API of Math class which has similar utility methods", "label": {"api": {"API of Math class": [[24, 40]]}}}, {"text": "Use DateFormat#parse(String) for that", "label": {"api": {"DateFormat#parse(String)": [[4, 27]]}}}, {"text": "After you get the Date object out of those strings, you can compare those objects using Date#compareTo(Date) method", "label": {"api": {"Date#compareTo(Date)": [[88, 107]]}}}, {"text": "You already have the date format, use it with SimpleDateFormat and then compare the created Date objects", "label": {"api": {"SimpleDateFormat": [[46, 61]], "compare": [[72, 78]], "Date": [[52, 55], [92, 95]]}}}, {"text": "You can changed it (see the comments) to return the Date object instead", "label": {"api": {"Date": [[52, 55]]}}}, {"text": "Get the tree model and call insertNodeInto(), and not only will the node be inserted, but an event will be sent to the JTree from the tree model to inform it that a node has been inserted, and that the view must be updated accordingly", "label": {"api": {"insertNodeInto()": [[28, 43]]}}}, {"text": "Or try to take a shortcut, assume that the problem is indeed the JFileChooser (as anecdotal evidence shows) and release a custom version replacing the JFileChooser by FileDialog", "label": {"api": {"FileDialog": [[167, 176]]}}}, {"text": "You can use Collections.nCopies", "label": {"api": {"Collections.nCopies": [[12, 30]]}}}, {"text": "Then use getSelectedItem to retrieve the selected object, and do a test to see what type the object is", "label": {"api": {"getSelectedItem": [[9, 23]]}}}, {"text": "You have to set the TimeZone to your SimpleTimeFormat object by using DateFormat#setTimeZone before formatting the Date", "label": {"api": {"DateFormat#setTimeZone": [[70, 91]]}}}, {"text": "Do these classes implement Shape", "label": {"api": {"Shape": [[27, 31]]}}}, {"text": "..i just type implements Shape", "label": {"api": {"Shape": [[25, 29]]}}}, {"text": "I would tend to use a Rectangle2D or Rectangle2D.Double for the obstacle & an Ellipse2D or Ellipse2D.Double for the shot", "label": {"api": {"Rectangle2D": [[22, 32], [37, 47]], "Rectangle2D.Double": [[37, 54]], "Ellipse2D": [[78, 86], [91, 99]], "Ellipse2D.Double": [[91, 106]]}}}, {"text": "You can make any Swing Component with a Document non-editable, so you´re free to choose", "label": {"api": {"Document": [[40, 47]]}}}, {"text": "You can use an EnumMap instead of HashMap", "label": {"api": {"EnumMap": [[15, 21]]}}}, {"text": "Have you looked at the String JavaDoc", "label": {"api": {"String JavaDoc": [[23, 36]]}}}, {"text": "Check the equalsIgnoreCase from the string doc", "label": {"api": {"string": [[36, 41]]}}}, {"text": "You can write a custom method in Java to remove the Unicode space characters , using  Character.isWhitespace(char) and Character.isSpaceChar(char) methods, for your specific purpose", "label": {"api": {"Character.isWhitespace(char)": [[86, 113]], "Character.isSpaceChar(char)": [[119, 145]]}}}, {"text": "The Spring framework has a StringUtils class with a trimWhitespace(String) method which appears to be based on Character.isWhitespace(char) from the source code here", "label": {"api": {"Character.isWhitespace(char)": [[111, 138]]}}}, {"text": "Use one of the versions of File.listFiles() that accepts a FileFilter or FilenameFilter to define the matching criteria", "label": {"api": {"File.listFiles()": [[27, 42]], "FileFilter": [[59, 68]], "FilenameFilter": [[73, 86]]}}}, {"text": "See Pattern class", "label": {"api": {"Pattern": [[4, 10]]}}}, {"text": "It is working as specified in String#split() documentation", "label": {"api": {"String#split()": [[30, 43]]}}}, {"text": "If you want to store empty strings, use overloaded version - String.split(regex, limit)", "label": {"api": {"String.split(regex, limit)": [[61, 86]]}}}, {"text": "Basically, what you want to do is subclass JComponent and override paintComponent", "label": {"api": {"JComponent and override paintComponent": [[43, 80]]}}}, {"text": "The Graphics object passed to it lets you do what you need (hint)", "label": {"api": {"Graphics": [[4, 11]], "hint": [[60, 63]]}}}, {"text": "Why in the java API there is the non-concurrent TreeMap on one side and the concurrent  ConcurrentSkipListMap on one other", "label": {"api": {"TreeMap": [[48, 54]], "ConcurrentSkipListMap": [[88, 108]]}}}, {"text": "Why did not they call it ConcurrentTreeMap", "label": {"api": {"TreeMap": [[35, 41]]}}}, {"text": "Is it safe to say that a SkipListMap includes a TreeMap", "label": {"api": {"TreeMap": [[48, 54]]}}}, {"text": "Why does it not happen for the TreeMap", "label": {"api": {"TreeMap": [[31, 37]]}}}, {"text": "You may be interested to use the ArrayList#containsAll(Collection c) method", "label": {"api": {"ArrayList#containsAll(Collection c)": [[33, 67]]}}}, {"text": "In the case of doubles, the result would be Double.POSITIVE_INFINITY", "label": {"api": {"Double.POSITIVE_INFINITY": [[44, 67]]}}}, {"text": "You need to use setNull() method", "label": {"api": {"setNull()": [[16, 24]]}}}, {"text": "Based on parameter is null or not check you need to either call setNull() (or) setInt()", "label": {"api": {"setNull()": [[64, 72]]}}}, {"text": "You can use the setNull(int parameterIndex, int sqlType) method of the PreparedStatement class", "label": {"api": {"setNull(int parameterIndex, int sqlType)": [[16, 55]]}}}, {"text": "Don't use any of those and use setObject instead, let the JDBC driver to manage the null values instead of you", "label": {"api": {"setObject": [[31, 39]]}}}, {"text": "You can use a TreeMap<YourClassAsKey, Long> since TreeMap is backed by a red black BST, and use the Long value as counter", "label": {"api": {"TreeMap": [[14, 20], [50, 56]]}}}, {"text": "Yes there is a TreeMap", "label": {"api": {"TreeMap": [[15, 21]]}}}, {"text": "The NavigableMap interface (implemented by TreeMap) offers methods such as floorKey and ceilingKey", "label": {"api": {"TreeMap": [[43, 49]]}}}, {"text": "Once you read the line using BufferedReader, you can use String.split(regex) method to split the string by space (\"\\\\s\")", "label": {"api": {"String.split(regex)": [[57, 75]]}}}, {"text": "As per the Integer#parseInt() JavaDoc", "label": {"api": {"the Integer#parseInt() JavaDoc": [[7, 36]]}}}, {"text": "NumberFormatException - if the string does not contain a parsable integer", "label": {"api": {"NumberFormatException": [[0, 20]]}}}, {"text": "You basically have to create an SSLSocketFactory see here for an example", "label": {"api": {"SSLSocketFactory": [[32, 47]]}}}, {"text": "Once you've created the SSLSocketFactory you can set it when you create a Connection from the URL like so", "label": {"api": {"SSLSocketFactory": [[24, 39]]}}}, {"text": "Also fyi, you are going to want to convert your certificates into the JKS format that Java prefers in order to easily load them into the SSLSocketFactory", "label": {"api": {"SSLSocketFactory": [[137, 152]]}}}, {"text": "Do not use == to compare String values; use the equals method of the String class", "label": {"api": {"equals": [[48, 53]]}}}, {"text": "Use java.net.URI to parse strings as URIs", "label": {"api": {"java.net.URI": [[4, 15]]}}}, {"text": "You can use Arrays.sort(x) from the java.util package to sort your array", "label": {"api": {"Arrays.sort(x)": [[12, 25]]}}}, {"text": "Alternatively, if you still want the primitive userId field, use @MapsId", "label": {"api": {"@MapsId": [[65, 71]]}}}, {"text": "The solution to this immediate problem is to add a call to reset()", "label": {"api": {"reset()": [[59, 65]]}}}, {"text": "Read from the child process's output stream -- which is provided by Process.getInputStream() -- until you detect the request for a password", "label": {"api": {"Process.getInputStream()": [[68, 91]]}}}, {"text": "Ask the user for a password, preferably using JPasswordField so that the password will be hidden", "label": {"api": {"JPasswordField": [[46, 59]]}}}, {"text": "Feed the password ot the process's input stream, provided by Process.getOutputStream()", "label": {"api": {"Process.getOutputStream()": [[61, 85]]}}}, {"text": "You can also do this in pure JRE using URL.openConnection()", "label": {"api": {"URL.openConnection()": [[39, 58]]}}}, {"text": "Using only standard API, the DataInputStream class has a method called readFully that fills a byte array from the stream", "label": {"api": {"DataInputStream": [[29, 43]]}}}, {"text": "As you can read in the documentation, Window.getShape() was added in JDK 1.7 so it is not available on JDK 1.6", "label": {"api": {"the documentation, Window.getShape()": [[19, 54]]}}}, {"text": "A HashMap seems like it would suit you well", "label": {"api": {"HashMap": [[2, 8]]}}}, {"text": "If you need a thread-safe option, then go with ConcurrentHashMap", "label": {"api": {"HashMap": [[57, 63]], "ConcurrentHashMap": [[47, 63]]}}}, {"text": "\"TreeMap provides guaranteed O(log n) lookup time (and insertion etc), whereas HashMap provides O(1) lookup time if the hash code disperses keys appropriately", "label": {"api": {"HashMap": [[79, 85]]}}}, {"text": "Unless you need the entries to be sorted, I'd stick with HashMap.\" -part of Jon Skeet's answer in TreeMap or HashMap", "label": {"api": {"HashMap": [[57, 63], [109, 115]]}}}, {"text": "If you are not parsing an XML file and only want the \"offsets\" for a given word regardless of the format of the file, AND you have enough memory to store the file in a String, try using Patterns", "label": {"api": {"Patterns": [[186, 193]]}}}, {"text": "Alternatively, if you absolutely want to use regular expressions, you can use Matcher.appendReplacement (it has a nice example in the JavaDoc)", "label": {"api": {"Matcher.appendReplacement": [[78, 102]]}}}, {"text": "If you just want to block until the callbacks for the N tasks you submit have all completed, you could create a CountDownLatch with a count of N", "label": {"api": {"CountDownLatch": [[112, 125]]}}}, {"text": "There's a good example in the EventListenerList docs, and this Converter example uses its own listenerList in ConverterRangeModel", "label": {"api": {"EventListenerList": [[30, 46]]}}}, {"text": "Read the file into a byte[] using FileInputStream.read(byte[])", "label": {"api": {"FileInputStream.read(byte[])": [[34, 61]]}}}, {"text": "I am wondering how I can remove an EventListener from a ServletContext (http://docs.oracle.com/javaee/6/api/javax/servlet/ServletContext.html)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/servlet/ServletContext.html": [[72, 140]]}}}, {"text": "Timer#scheduleAtFixedRate can provide fixed rate execution", "label": {"api": {"Timer#scheduleAtFixedRate": [[0, 24]]}}}, {"text": "Why not keep it simple and construct the string built from the byte[] using the String(bytes, offset, len) constructor and avoid including the unset bytes at all", "label": {"api": {"String(bytes, offset, len)": [[80, 105]]}}}, {"text": "To support multiple sort orders using different criteria, use Comparator#compare() instead", "label": {"api": {"Comparator#compare()": [[62, 81]]}}}, {"text": "I'm currently developing a Java Agent in order to facilitate the dynamic instrumentation of new and legacy Java Applications", "label": {"api": {"Java Agent": [[27, 36]]}}}, {"text": "It occurred to me that, as far as IDE debugging is concerned, Java Agents could be perhaps considered a special case as they are required to be injected into a target JVM process in order to be ran", "label": {"api": {"Java Agent": [[62, 71]]}}}, {"text": "A cursory search for existing solutions turned up a few command line based options (i.e YourKit, JIP, etc) however many of them are ALSO Java Agents under the hood", "label": {"api": {"Java Agent": [[137, 146]]}}}, {"text": "Assuming your set contains the strings you want to remove, you can use the keySet method and map.keySet().removeAll(keySet);", "label": {"api": {"the keySet method": [[71, 87]]}}}, {"text": "Primitive Data types if you know that your numbers will be between Integer.MIN_VALUE and Integer.MAX_VALUE don't sweet, casting will work as expected", "label": {"api": {"Integer.MIN_VALUE": [[67, 83]], "Integer.MAX_VALUE": [[89, 105]]}}}, {"text": "Else, go for long or BigInteger", "label": {"api": {"BigInteger": [[21, 30]]}}}, {"text": "I guess you forgot to set setAccessible(true) on the field you're trying to access", "label": {"api": {"setAccessible(true)": [[26, 44]]}}}, {"text": "Wondering why the method drainTo is present only in the concurrent collection framework (BlockingQueue in particular) and not in the regular one", "label": {"api": {"method": [[18, 23]], "BlockingQueue": [[89, 101]]}}}, {"text": "String has no method named exists() (and even if it did it would not do what you require), which will be the cause of the errors reported by the IDE", "label": {"api": {"exists()": [[27, 34]]}}}, {"text": "Create an instance of File and invoke exists() on the File instance", "label": {"api": {"File": [[22, 25], [54, 57]], "exists()": [[38, 45]]}}}, {"text": "Then, pass this array as an argument of the Runtime#exec(String[] args) method, which will automatically execute the specified command and arguments in a separate process", "label": {"api": {"Runtime#exec(String[] args)": [[44, 70]]}}}, {"text": "The old java.awt.Font is conveniently Serializable - however somewhat annoyingly, the JavaFX font class isn't", "label": {"api": {"java.awt.Font": [[8, 20]], "JavaFX font class": [[86, 102]]}}}, {"text": "You can find out everything that is serializable by reviewing the serialized-form page of the javadoc", "label": {"api": {"serialized-form": [[66, 80]]}}}, {"text": "With that, you can see that pretty much the only things which may be serialized are the events based on an old serializable java.util.EventObject and the JFXPanel which integrates with Swing", "label": {"api": {"java.util.EventObject": [[124, 144]]}}}, {"text": "One option would be to use the deleteOnExit() method from the File class", "label": {"api": {"deleteOnExit()": [[31, 44]]}}}, {"text": "You can use Character.getNumericValue(char)", "label": {"api": {"Character.getNumericValue(char)": [[12, 42]]}}}, {"text": "This expression captures a string between two pairs of equal signs, and then takes everything until the next = or the end of string", "label": {"api": {"captures": [[16, 23]]}}}, {"text": "Before adding each time, check whether the key is already there using Map#containsKey(Object) method", "label": {"api": {"Map#containsKey(Object)": [[70, 92]]}}}, {"text": "If it is already there, get the List corresponding to that key, using Map#get(Object) method, and then add the new element in the list using List#add(E) method", "label": {"api": {"Map#get(Object)": [[70, 84]], "List#add(E)": [[141, 151]]}}}, {"text": "Incidentally, you might find String.format() useful", "label": {"api": {"String.format()": [[29, 43]]}}}, {"text": "For the syntax, see Format String Syntax", "label": {"api": {"Format String Syntax": [[20, 39]]}}}, {"text": "The use of java.util.Vector is not recommended - regardless of working with GWT or not", "label": {"api": {"is not recommended": [[28, 45]]}}}, {"text": "Why don't you use an ExecutorService instead of doing its job by hand", "label": {"api": {"ExecutorService": [[21, 35]]}}}, {"text": "To clarify what he means, he means using an ExecutorService to process the messages for the pubQueue instead of creating a thread to pull the messages and processing them manually", "label": {"api": {"ExecutorService": [[44, 58]]}}}, {"text": "Using the ExecutorService interface allows you to change the implementation, which can allow it to process more than one message at a time (asynchronous) simply by changing this", "label": {"api": {"ExecutorService": [[10, 24]]}}}, {"text": "See the Executors class for more ways of creating ExecutorService implementations", "label": {"api": {"ExecutorService": [[50, 64]], "Executors": [[8, 16]]}}}, {"text": "You can find more info about the possible methods in the API", "label": {"api": {"API": [[57, 59]]}}}, {"text": "To use a timer like swing timer or java util timer will require that your have threads in your program", "label": {"api": {"java util timer": [[35, 49]]}}}, {"text": "The ScrollBar class in JavaFX contains a property for setting the unit increment, which is what I'm after - however I can't find how to get at this ScrollBar, or set the unit increment some other way from the ScrollPane class", "label": {"api": {"ScrollBar": [[4, 12], [148, 156]], "ScrollPane": [[209, 218]]}}}, {"text": "Although a List is a subclass of Collection it is not a class; it is an interface", "label": {"api": {"List": [[11, 14]], "Collection": [[33, 42]]}}}, {"text": "On your second line, you cannot construct an object of type List", "label": {"api": {"List": [[60, 63]]}}}, {"text": "If you use an ArrayList instead (e.g.", "label": {"api": {"List": [[19, 22]], "ArrayList": [[14, 22]]}}}, {"text": "List lst =  new ArrayList();, and import java.util.ArrayList) what youa re doing should work", "label": {"api": {"List": [[0, 3], [21, 24], [56, 59]], "ArrayList": [[16, 24], [51, 59]]}}}, {"text": "There are also auxiliary methods provided by the Java Arrays class", "label": {"api": {"Arrays": [[54, 59]]}}}, {"text": "Look at the documentation of String#charAt()", "label": {"api": {"String#charAt()": [[29, 43]]}}}, {"text": "Take a look at Class.getDeclaredFields()", "label": {"api": {"Class.getDeclaredFields()": [[15, 39]], "Field": [[32, 36]]}}}, {"text": "This method gives you an array of Field objects", "label": {"api": {"Field": [[34, 38]]}}}, {"text": "Using Field.getModifiers() and the utility methods in Modifier (for example, Modifier.isStatic(...)) you can find whether a field is private, static, synchronized, etc", "label": {"api": {"Field": [[6, 10]], "Field.getModifiers()": [[6, 25]], "Modifier": [[15, 22], [54, 61], [77, 84]]}}}, {"text": "If you call DatabaseMetaData.getTables(...) and use null for the first param, catalog, it should give you all table names without narrowing the result to any catalog", "label": {"api": {"DatabaseMetaData.getTables(...)": [[12, 42]]}}}, {"text": "The ImageIcon class only directly supports reading PNG, GIF and JPEG types", "label": {"api": {"The ImageIcon class": [[0, 18]], "Image": [[4, 8]]}}}, {"text": "You need to use ImageIO to read your bitmap into a generic Image object (which is supported by ImageIcon) and then pass that to ImageIcon", "label": {"api": {"ImageIO": [[16, 22]], "Image": [[16, 20], [59, 63], [95, 99], [128, 132]]}}}, {"text": "Note that you can also use ImageIO to convert your bitmap to JPEG format", "label": {"api": {"ImageIO": [[27, 33]], "Image": [[27, 31]]}}}, {"text": "Alternatively, using take or poll(long,TimeUnit) would also stop your loop while you don't have anything to add", "label": {"api": {"take": [[21, 24]], "poll(long,TimeUnit)": [[29, 47]]}}}, {"text": "You could make use of the SE 7 DirectoryStream class", "label": {"api": {"DirectoryStream": [[31, 45]]}}}, {"text": "You can shift-left and shift-right, but only in base-10 (and even then it behaves differently from bit-shifts, because it can produce non-integer values)", "label": {"api": {"only in base-10": [[40, 54]]}}}, {"text": "I think you mean BigInteger here", "label": {"api": {"BigInteger": [[17, 26]]}}}, {"text": "BigInteger does have left and right shift operations with .shiftLeft() and .shiftRight() for multiplications/divisions by powers of two respectively, so you can use that", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "use the String.matches() method)", "label": {"api": {"String.matches()": [[8, 23]]}}}, {"text": "As the node's width is not changed by the scaling (check Node.getLayoutBounds())", "label": {"api": {"Node.getLayoutBounds()": [[57, 78]]}}}, {"text": "In the context of string formatting, % is a special character used to denote various things; %% resolves to a single literal % symbol", "label": {"api": {"string formatting": [[18, 34]]}}}, {"text": "FlushModeType (AUTO or COMMIT) by default it's set to AUTO and a flush will be done automatically by if it's set to COMMIT the persitence of the data to the underlying database will be delayed when the transaction is commited)", "label": {"api": {"FlushModeType ": [[0, 13]]}}}, {"text": "Matcher#matches() matches at the beginning of the string", "label": {"api": {"Matcher#matches()": [[0, 16]]}}}, {"text": "Alternatively, you can use Matcher#find() with just the regex for relevant part of the string", "label": {"api": {"Matcher#find()": [[27, 40]]}}}, {"text": "To fix this, you'd need to keep track of which indices have been initialized, or better yet, use an ArrayList", "label": {"api": {"ArrayList": [[100, 108]]}}}, {"text": "You can try out using javax.xml.ws.Endpoint class (http://docs.oracle.com/javaee/5/api/javax/xml/ws/Endpoint.html)", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/xml/ws/Endpoint.html": [[51, 112]]}}}, {"text": "See Scanner#nextInt() for more info", "label": {"api": {"Scanner#nextInt()": [[4, 20]]}}}, {"text": "You can use Scanner class, which provides a Scanner#nextInt() method to read the next token as int", "label": {"api": {"Scanner": [[12, 18], [44, 50]], "Scanner#nextInt()": [[44, 60]]}}}, {"text": "Now, since your integers are comma(,) separated, you need to set comma(,) as delimiter in your Scanner, which uses whitespace character as default delimiter", "label": {"api": {"Scanner": [[95, 101]]}}}, {"text": "You need to use Scanner#useDelimiter(String) method for that", "label": {"api": {"Scanner": [[16, 22]], "Scanner#useDelimiter(String)": [[16, 43]]}}}, {"text": "My guess is that you're accidentally using Java SE's MouseEvent instead of Java FX's MouseEvent", "label": {"api": {"Java SE's MouseEvent": [[43, 62]], "Java FX's MouseEvent": [[75, 94]]}}}, {"text": "You can try to use ready and read(char c) methods", "label": {"api": {"ready": [[19, 23]], "read(char c)": [[29, 40]]}}}, {"text": "The simplest way I can think of is to just output the \"data\" field's content followed by a newline (assuming data won't contain newlines of course), so that BufferedReader's readLine() method can be used", "label": {"api": {"readLine()": [[174, 183]]}}}, {"text": "With the integer pixel value for the color, you can then utilize the Color class to extract individual RGB components", "label": {"api": {"Color": [[69, 73]]}}}, {"text": "If you want to provide a way to read \"old versions\", you have to implement the readObject method", "label": {"api": {"implement the readObject method": [[65, 95]]}}}, {"text": "Use subList and pass that into the new list's constructor (or call addAll)", "label": {"api": {"subList": [[4, 10]], "addAll": [[67, 72]]}}}, {"text": "Use string.toCharArray(), something like", "label": {"api": {"string.toCharArray()": [[4, 23]]}}}, {"text": "As shown in this Oracle tutorial, the setString method takes in an integer, representing the number of the parameter and a string, representing the value", "label": {"api": {"setString": [[38, 46]]}}}, {"text": "This will open the Save As dialog in which you then need to navigate manually / using the Java's Robot class", "label": {"api": {"Robot": [[97, 101]]}}}, {"text": "You can use the frequency method", "label": {"api": {"the frequency method": [[12, 31]]}}}, {"text": "Create a color from RGB values, and make sure that R, G and B are large enough to make the overall color light", "label": {"api": {"from RGB values": [[15, 29]]}}}, {"text": "I have on my hand the Method instance of the method I want to invoke (so I can get the types of its parameters), in addition, I have the values of these parameters as Strings", "label": {"api": {"Method": [[22, 27]]}}}, {"text": "First we can convert the array to a List<Integer>, by using Arrays.asList(T...)", "label": {"api": {"Arrays.asList(T...)": [[60, 78]]}}}, {"text": "Next we can add new ints to that list by calling List.add(E)", "label": {"api": {"List.add(E)": [[49, 59]]}}}, {"text": "Finally we can convert that List back to an int[] by calling List.toArray(T[])", "label": {"api": {"List.toArray(T[])": [[61, 77]]}}}, {"text": "Take a look at the ReadWriteLock", "label": {"api": {"ReadWriteLock": [[19, 31]]}}}, {"text": "From the Socket Javadoc", "label": {"api": {"Socket Javadoc": [[9, 22]]}}}, {"text": "I'm sure you're aware that the NoSuchProviderException extends the MessagingException (http://docs.oracle.com/javaee/1.4/api/javax/mail/NoSuchProviderException.html) and as such, the error is probably always going to the MessagingException catch", "label": {"api": {"http://docs.oracle.com/javaee/1.4/api/javax/mail/NoSuchProviderException.html": [[87, 163]]}}}, {"text": "PriorityBlockingQueue is an unbounded blocking queue by its definition", "label": {"api": {"definition": [[60, 69]]}}}, {"text": "LinkedBlockingQueue is an optionally-bounded blocking queue by its definition", "label": {"api": {"definition": [[67, 76]]}}}, {"text": "Some of my colleagues suggested that it might have to do with the Security Manager, and indeed, the documentation for the PrintService class says that certain properties of a Security Manager can alter results from the method call", "label": {"api": {"documentation for the PrintService class": [[100, 139]]}}}, {"text": "What you are doing is specifically prohibited", "label": {"api": {"specifically prohibited": [[22, 44]]}}}, {"text": "Anyway you can use Arrays.copyOf to make the copy, which delegates to (the less type-safe) System.arraycopy", "label": {"api": {"Arrays.copyOf": [[19, 31]], "System.arraycopy": [[91, 106]]}}}, {"text": "HashMap is serializable, so you could just use a FileInputStream and FileOutputStream in conjunction with ObjectInputStream and ObjectOutputStream", "label": {"api": {"FileInputStream": [[49, 63]], "FileOutputStream": [[69, 84]], "ObjectInputStream": [[106, 122]], "ObjectOutputStream": [[128, 145]]}}}, {"text": "Note that if you have any files that you don't want to include, you can give listFiles() a FileFilter argument to filter them out", "label": {"api": {"FileFilter": [[91, 100]]}}}, {"text": "Use java.util.Random, providing the same seed", "label": {"api": {"java.util.Random": [[4, 19]]}}}, {"text": "If you pass it through a DigestInputStream, it'll do the MessageDigest and still be usable as an InputStream", "label": {"api": {"DigestInputStream": [[25, 41]]}}}, {"text": "User the split method that also takes a limit parameter, and pass a negative limit to ensure that you get an array with a length that matches the number of tokens actually present", "label": {"api": {"split method that also takes a limit parameter": [[9, 54]]}}}, {"text": "But if you really wanted to, you could probably roll your own with a ForkJoinPool or similar", "label": {"api": {"ForkJoinPool": [[69, 80]]}}}, {"text": "If you are implementing TransferHandler methods then in the importData method we will insert row in to the target table", "label": {"api": {"TransferHandler": [[24, 38]], "importData": [[60, 69]]}}}, {"text": "Instead of just checking dd-mm-yyyy, which would allow inputs like 99-99-9999, you could just use SimpleDateFormat to actually parse and check if it's a valid date", "label": {"api": {"SimpleDateFormat": [[98, 113]]}}}, {"text": "If the date is invalid it'll throw a ParseException, which you can then catch and handle the error appropriately", "label": {"api": {"ParseException": [[37, 50]]}}}, {"text": "List is an interface that can't be instantiated directly; try a concrete implementation, such as ArrayList", "label": {"api": {"List is an interface": [[0, 19]]}}}, {"text": "I haven't tested this specific code but I have other working examples and it should work fine according to the JPA docs", "label": {"api": {"JPA docs": [[111, 118]]}}}, {"text": "There is a StringCharacterIterator class if you prefer an iterator approach", "label": {"api": {"StringCharacterIterator": [[11, 33]]}}}, {"text": "You could then consider a TreeSet, a bit mask, or some other data structure, depending on how you query", "label": {"api": {"TreeSet": [[26, 32]]}}}, {"text": "Alternately, perhaps a RangeSet of either integers or a IP address wrapper class you write that implements Comparable would be a good solution", "label": {"api": {"Comparable": [[107, 116]]}}}, {"text": "To make it work, then, you would simply use Matcher#group(int) to retrieve the values", "label": {"api": {"Matcher#group(int)": [[44, 61]]}}}, {"text": "If you want the working directory's path, then CurrentClass.class.getProtectionDomain().getCodeSource().getLocation().getPath()", "label": {"api": {"Source": [[95, 100]]}}}, {"text": "Using Boolean#parseBoolean() alone doesn't work to validate characters because it returns false for any string that doesn't evaluate to true (ignoring the case of course)", "label": {"api": {"Boolean#parseBoolean()": [[6, 27]]}}}, {"text": "You cannot chain your method calls like inventoryMap.put(x,inventoryMap.get(x).add(s)) since add returns a boolean", "label": {"api": {"add returns a boolean": [[93, 113]]}}}, {"text": "Referencing from here http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html#rfc822timezone I found I did nothing wrong, or did I", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html#rfc822timezone": [[22, 108]]}}}, {"text": "Instead, you must use an Iterator", "label": {"api": {"Iterator": [[25, 32]]}}}, {"text": "Use Iterator#remove() to remove elements from List while iterating through the List", "label": {"api": {"Iterator#remove()": [[4, 20]]}}}, {"text": "The AppEngine Dev Server registers its own URLStreamHandlerFactory to automatically map Http(s)URLConnections onto AppEngine's URL-fetch infrastructure", "label": {"api": {"registers its own URLStreamHandlerFactory": [[25, 65]], "Http(s)URLConnections": [[88, 108]]}}}, {"text": "We are persisting a variety of enum constants in the datastore using the supplied EnumTranslatorFactory which simply stores/loads the constant using the Enum#name()", "label": {"api": {"Enum#name()": [[153, 163]]}}}, {"text": "Also you can create your pattern with Pattern.UNICODE_CASE option to get unicode support", "label": {"api": {"Pattern.UNICODE_CASE": [[38, 57]]}}}, {"text": "Look at the Pattern class to understand how to construct the regex", "label": {"api": {"Pattern": [[12, 18]]}}}, {"text": "Look at FileChannel#lock() API", "label": {"api": {"FileChannel#lock()": [[8, 25]]}}}, {"text": "Since your dlls are bundeled inside your jar file you could just try to acasses them as resources using ClassLoader#getResourceAsStream and write them as binary files any where you want on the hard drive", "label": {"api": {"ClassLoader#getResourceAsStream": [[104, 134]]}}}, {"text": "You can pass your template to the Template constructor with a StringReader", "label": {"api": {"StringReader": [[62, 73]]}}}, {"text": "Documentation about SecureRandom says it may block waiting for the system to generate more entropy (for instance, in Linux it takes random numbers from /dev/random), so if you are going to use it, maybe you will need some help from hardware", "label": {"api": {"Documentation about SecureRandom": [[0, 31]]}}}, {"text": "Just remember to decode it on the receiving end, I believe the URLDecoder class can do this for you", "label": {"api": {"URLDecoder": [[63, 72]]}}}, {"text": "Here is the JavaDoc for Matcher as a reference", "label": {"api": {"Here is the JavaDoc": [[0, 18]]}}}, {"text": "I think, a Proxy is what you are looking for", "label": {"api": {"Proxy": [[11, 15]]}}}, {"text": "Some sample code from the Proxy documentation", "label": {"api": {"Proxy": [[26, 30]]}}}, {"text": "I just saw, that the Proxy class only proxies Interfaces, but does not seem to be able to extend classes", "label": {"api": {"Proxy": [[21, 25]]}}}, {"text": "Another native (Java 8+) solution could be to pass the StringReader object to a BufferedReader and stream trough the lines", "label": {"api": {"BufferedReader": [[80, 93]], "stream": [[99, 104]]}}}, {"text": "A ChangeListener is not a ListChangeListener", "label": {"api": {"ChangeListener": [[2, 15], [30, 43]], "ListChangeListener": [[26, 43]]}}}, {"text": "ObservableList.addListener requires a ListChangeListener as it's parameter", "label": {"api": {"ChangeListener": [[42, 55]], "ListChangeListener": [[38, 55]], "ObservableList.addListener": [[0, 25]]}}}, {"text": "The JavaFX collections tutorial details how to use ListChangeListeners", "label": {"api": {"ChangeListener": [[55, 68]], "ListChangeListener": [[51, 68]]}}}, {"text": "You can check for indexOf() 0 first , if it evaluates to -1 , which means the string didn't contain a 0 ,  then try to parseLong() the string and handle the NumberFormatException", "label": {"api": {"indexOf()": [[18, 26]], "parseLong()": [[119, 129]]}}}, {"text": "If the number string is huge , you can go for BigInteger() , but I think it would be an overkill", "label": {"api": {"BigInteger()": [[46, 57]]}}}, {"text": "If you know it's the third item that you want to get, one simple approach could be using split method, like this", "label": {"api": {"split method": [[89, 100]]}}}, {"text": "The nextInt(cards.size() - 1) will generate a random index in [0,cards.size() - 1) range", "label": {"api": {"nextInt(cards.size() - 1)": [[4, 28]]}}}, {"text": "This Oracle docs will give you a better idea", "label": {"api": {"Oracle docs": [[5, 15]]}}}, {"text": "You'll need to type each Node to type Element to be able to set the text and attributes", "label": {"api": {"Element": [[38, 44]]}}}, {"text": "According to the documentation of the single-argument String.split", "label": {"api": {"the documentation of the single-argument String.split": [[13, 65]]}}}, {"text": "Just create a new BufferedImage of type TYPE_INT_RGB like so", "label": {"api": {"TYPE_INT_RGB": [[40, 51]]}}}, {"text": "You need to use push() of Stack", "label": {"api": {"push()": [[16, 21]], "Stack": [[26, 30]]}}}, {"text": "Move to HashMap instead of HashTable if you can", "label": {"api": {"HashMap": [[8, 14]]}}}, {"text": "Read When should I use a Hashtable versus a HashMap", "label": {"api": {"HashMap": [[44, 50]]}}}, {"text": "You should call the nextLine method on your Scanner object", "label": {"api": {"nextLine": [[20, 27]]}}}, {"text": "For a particle physics simulator I'd strongly consider using BigDecimal to avoid floating-point rounding errors using doubles and floats (which Vector3f and Vector3d use, respectively) messing up your calculations", "label": {"api": {"BigDecimal": [[61, 70]]}}}, {"text": "Of course, if the simulation needs to be real-time then you'll have to think of the time and space complexity implications of using BigDecimal vs double vs float but if it's to be run offline, BigDecimal's exact representation of fractional numbers is a big win for this type of application", "label": {"api": {"BigDecimal": [[132, 141], [193, 202]]}}}, {"text": "You could make it sort of work but, I suggest you use an AtomicInteger which is shared between threads", "label": {"api": {"AtomicInteger": [[57, 69]]}}}, {"text": "Just use an eagerly initialized application scoped managed bean instead", "label": {"api": {"eagerly initialized": [[12, 30]], "application scoped": [[32, 49]], "managed bean": [[51, 62]]}}}, {"text": "If you want precision, you can use BigDecimal class", "label": {"api": {"BigDecimal": [[35, 44]]}}}, {"text": "Your last call to Scanner#nextInt()", "label": {"api": {"Scanner#nextInt()": [[18, 34]]}}}, {"text": "SecretKeySpec(byte[] key, String algorithm)) and then use a KeyFactory to \"generate\" a key from it", "label": {"api": {"SecretKeySpec(byte[] key, String algorithm)": [[0, 42]]}}}, {"text": "Java doesn't have typedefs, but EnumSet.of() returns a typed EnumSet, and you shouldn't need anything more", "label": {"api": {"EnumSet": [[32, 38], [61, 67]]}}}, {"text": "See the API for details", "label": {"api": {"API": [[8, 10]]}}}, {"text": "You can sort it using Collections.sort and a custom Comparator", "label": {"api": {"Collections.sort": [[22, 37]], "Comparator": [[52, 61]]}}}, {"text": "Note that elements that have an equal value according to this Comparator won't be re-ordered", "label": {"api": {"Comparator": [[62, 71]]}}}, {"text": "Note that this is documented, with an example, in the JoinColumn javadoc, and in the Hibernate documentation", "label": {"api": {"JoinColumn javadoc": [[54, 71]]}}}, {"text": "toRadians and toDegrees", "label": {"api": {"toRadians": [[0, 8]], "toDegrees": [[14, 22]]}}}, {"text": "The Process API already has a solution for this", "label": {"api": {"Process API": [[4, 14]]}}}, {"text": "Hence , you need to use Map#get() and then List#get()", "label": {"api": {"Map#get()": [[24, 32]], "List#get()": [[43, 52]]}}}, {"text": "mm is for minute in hour", "label": {"api": {"minute in hour": [[10, 23]]}}}, {"text": "In Java 7 ProcessBuilder can do the redirection for you, so just run iperf directly rather than through cmd.exe", "label": {"api": {"ProcessBuilder": [[10, 23]]}}}, {"text": "You can also accomplish this with String.format(), like so", "label": {"api": {"String.format()": [[34, 48]]}}}, {"text": "Note that stripTrailingZeros() doesn't do very well either", "label": {"api": {"stripTrailingZeros()": [[10, 29]]}}}, {"text": "You can use DecimalFormat", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "Comparing android.graphics.Rect and java.awt.Rectangle I see some differences such as the meaning of method arguments", "label": {"api": {"java.awt.Rectangle": [[36, 53]]}}}, {"text": "regarding the access to array3, it's safe as well, because, as explained in the documentation of the concurrent package, a call to start on a thread happens-before any action in the started thread", "label": {"api": {"the documentation of the concurrent package": [[76, 118]]}}}, {"text": "Use the nextInt() to get the next integer value", "label": {"api": {"nextInt()": [[8, 16]]}}}, {"text": "Since you're question is tagged AWT, I suggest that you use a MediaTracker to load your images", "label": {"api": {"MediaTracker": [[62, 73]]}}}, {"text": "You can also try using ImageIO.read(URL) to retrieve a BufferedImage", "label": {"api": {"ImageIO.read(URL)": [[23, 39]]}}}, {"text": "To create an ImageIcon from a URL, just use the constructor ImageIcon(URL)", "label": {"api": {"ImageIcon(URL)": [[60, 73]]}}}, {"text": "You could just remove the first index and then iterate through the ArrayList and delete each object and re-assign it to a new index, but this seems very ineffecient and it seems like there should be a way but I have looked through at the JavaDoc page for the ArrayList class and do not see anything that would accomplish what I am trying to do", "label": {"api": {"JavaDoc page for the ArrayList class": [[238, 273]]}}}, {"text": "That being said, you can use System.setIn to use any InputStream as stdin", "label": {"api": {"System.setIn": [[29, 40]]}}}, {"text": "ByteArrayInputStream.close doesn't do anything, and you could create your own InputStream that cannot be closed", "label": {"api": {"ByteArrayInputStream.close": [[0, 25]]}}}, {"text": "Then java.lang.String doc", "label": {"api": {"java.lang.String doc": [[5, 24]]}}}, {"text": "Use ListIterator to add the particular row in the particular index", "label": {"api": {"ListIterator": [[4, 15]]}}}, {"text": "If you don't have repeated elements, then you could just use a sorted Map like a TreeMap instead", "label": {"api": {"TreeMap": [[81, 87]]}}}, {"text": "In Java api, they say that the AudioInputStream class has a \".close()\" method that \"Closes this audio input stream and releases any system resources associated with the stream\"", "label": {"api": {"Java api": [[3, 10]]}}}, {"text": "As per the javaee 1.4 API", "label": {"api": {"javaee 1.4 API": [[11, 24]]}}}, {"text": "Since this sounds like homework, I will not go into too much code detail, but you could read the first line, and then use the .split(\"\\\\s+\") method from the String class", "label": {"api": {".split(\"\\\\s+\")": [[126, 139]], "String": [[157, 162]]}}}, {"text": "Convert JOptionPane to a JDialog, using JOptionPane.createDialog(String title)", "label": {"api": {"JOptionPane.createDialog(String title)": [[40, 77]]}}}, {"text": "You are getting a UnavailableException for the servlet WebMail", "label": {"api": {"UnavailableException": [[18, 37]]}}}, {"text": "See Javadocs for indexOf(int, int)", "label": {"api": {"Javadocs for indexOf(int, int)": [[4, 33]]}}}, {"text": "Instead of writing your own method you can use Calender class", "label": {"api": {"Calender": [[47, 54]]}}}, {"text": "For Conversion you'll need some String utility like String.format()", "label": {"api": {"String.format()": [[52, 66]]}}}, {"text": "See paragraph 10.2.5.8 of the JPQL Language Reference", "label": {"api": {"paragraph 10.2.5.8 of the JPQL Language Reference": [[4, 52]]}}}, {"text": "I suppose you can use kerberos infrastructure using GSS-API in Java, since we do this a lot with shell scripts and so", "label": {"api": {"GSS-API": [[52, 58]]}}}, {"text": "Integer in 1.4 doesn't autobox", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "Integer in 1.7 does", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "Are you looking for @XMLTransient", "label": {"api": {"@XMLTransient": [[20, 32]]}}}, {"text": "Note that since pow is a free-standing function in C, its Java version needs to refer to it as a member of the Math class", "label": {"api": {"Math": [[111, 114]]}}}, {"text": "You can post the binary data straight to the servlet, for example by creating an ObjectOutputStream on top of a HttpUrlConnection's outputstream", "label": {"api": {"HttpUrlConnection": [[112, 128]]}}}, {"text": "The servlet handling the post can deserialize from an ObjectStream created from the HttpServletRequest's ServletInputStream", "label": {"api": {"ServletInputStream": [[105, 122]]}}}, {"text": "I suggest you to use Executors class in order to create a pool of thread", "label": {"api": {"Executors": [[21, 29]]}}}, {"text": "The pool thread can manage multiple connection like the ExecutorService javadoc shows", "label": {"api": {"ExecutorService": [[56, 70]]}}}, {"text": "I'll point you then to JWindow, but it's more rudimentary..", "label": {"api": {"JWindow": [[23, 29]]}}}, {"text": "For my example I assume you'd use a HTMLEditorKit in your JTextPane", "label": {"api": {"HTMLEditorKit": [[36, 48]], "JTextPane": [[58, 66]]}}}, {"text": "I would then parse the StyledDocument of the pane and set the textruns accordingly", "label": {"api": {"StyledDocument": [[23, 36]]}}}, {"text": "I've to admit, that I've never done something with the HTMLEditorKit and therefore I don't know how to handle the CSS.CssValues properly", "label": {"api": {"HTMLEditorKit": [[55, 67]]}}}, {"text": "There is, for instance, LinkedList which implements Deque, which has methods to be used as either a Stack or Queue", "label": {"api": {"LinkedList": [[24, 33]]}}}, {"text": "Sorry, didn't realize my queue was still an interface", "label": {"api": {"queue": [[25, 29]]}}}, {"text": "Use this queue..", "label": {"api": {"queue": [[9, 13]]}}}, {"text": "Literals are interned, as per String.intern()", "label": {"api": {"String.intern()": [[30, 44]]}}}, {"text": "String.matches(String regex) to simply validate a String", "label": {"api": {"String.matches(String regex)": [[0, 27]]}}}, {"text": "You can do that using Regular Expressions and Pattern and Matcher classes", "label": {"api": {"Pattern": [[46, 52]], "Matcher": [[58, 64]]}}}, {"text": "I suggest using Pattern.quote(regex) for your variable v since it can contain some regex meta characters", "label": {"api": {"Pattern.quote(regex)": [[16, 35]]}}}, {"text": "Use putAll() method istead of type casting like this", "label": {"api": {"putAll()": [[4, 11]]}}}, {"text": "Now, since using HttpServletResponse#sendRedirect(), a new request is created by client, so the request is actually sent from the browser, and therefore you cannot have WEB-INF in path to sendRedirect", "label": {"api": {"HttpServletResponse#sendRedirect()": [[17, 50]]}}}, {"text": "In case of RequestDispatcher, the methods - forward() and include(), doesn't ask the client to create a new request, rather they use the same request to forward to/include a different page from most probably the Servlet Controller", "label": {"api": {"RequestDispatcher": [[11, 27]], "forward()": [[44, 52]], "include()": [[58, 66]]}}}, {"text": "If you want fairness you can use ReentrantLock which provides for more functionality than synchronized block", "label": {"api": {"ReentrantLock": [[33, 45]]}}}, {"text": "This object is maintained in the String Pool (String#intern())", "label": {"api": {"(String#intern())": [[45, 61]]}}}, {"text": "Yes, using Desktop.open()", "label": {"api": {"Desktop.open()": [[11, 24]]}}}, {"text": "Try changing the .out to .err and also try catching Throwable (http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html": [[63, 127]]}}}, {"text": "When a thread throws an exception that isn't caught, Thread.UncaughtExceptionHandler will be called", "label": {"api": {"Thread.UncaughtExceptionHandler": [[53, 83]]}}}, {"text": "Because Map#put() returns a String value", "label": {"api": {"Map#put()": [[8, 16]]}}}, {"text": "You're probably getting ArrayIndexOutOfBounds exception", "label": {"api": {"ArrayIndexOutOfBounds": [[24, 44]]}}}, {"text": "I have read the API however it's not very clear to me", "label": {"api": {"API": [[16, 18]]}}}, {"text": "What I'd use there is a semaphore", "label": {"api": {"semaphore": [[24, 32]]}}}, {"text": "As stated in the Javadoc for Runtime.exec()", "label": {"api": {"Javadoc for Runtime.exec()": [[17, 42]]}}}, {"text": "Doing updates based on an identifier is asking for a Map", "label": {"api": {"Map": [[53, 55]]}}}, {"text": "Assuming that you use Java 8, it could be done using the Stream API with a Set<String> that will store the existing values", "label": {"api": {"Stream API": [[57, 66]]}}}, {"text": "The EntityManager has a method clear() that will drop all persistence context", "label": {"api": {"clear()": [[31, 37]]}}}, {"text": "You can use the List#toArray() method to transform the List to an Long[]", "label": {"api": {"List#toArray()": [[16, 29]]}}}, {"text": "Use the equals method instead", "label": {"api": {"equals": [[8, 13]]}}}, {"text": "The javadoc page for Formatter does not mention any special treatment for grouping separators when interpreting the width, it just talks about the number of characters", "label": {"api": {"Formatter": [[21, 29]]}}}, {"text": "I think you're looking for Boolean.FALSE (and Boolean.TRUE)", "label": {"api": {"Boolean.FALSE (and Boolean.TRUE)": [[27, 58]]}}}, {"text": "How about using the constant provided by the Boolean class (link to 1.3 API) instead", "label": {"api": {"constant provided by the Boolean class (link to 1.3 API)": [[20, 75]]}}}, {"text": "Therefore you can use the method Arrays.asList()", "label": {"api": {"Arrays.asList()": [[33, 47]]}}}, {"text": "Someone pointed out to me that I could use EntityManager#createQuery(String,Class<?>) instead of Query#list to accomplish the same thing but have everything genericized correctly", "label": {"api": {"EntityManager#createQuery(String,Class<?>)": [[43, 84]]}}}, {"text": "Java concatenates Strings by using a StringBuilder", "label": {"api": {"StringBuilder": [[37, 49]]}}}, {"text": "b.intern() + \"ey\" turns into something similar to  new StringBuilder(b.intern()).append(\"ey\").toString()", "label": {"api": {"StringBuilder": [[55, 67]]}}}, {"text": "Always use String#equals to compare Strings", "label": {"api": {"String#equals": [[11, 23]]}}}, {"text": "Use a Map", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "Map objects store relationships between unique \"keys\" and values", "label": {"api": {"Map": [[0, 2]]}}}, {"text": "Implementations of Map are HashMap and TreeMap, among others", "label": {"api": {"Map": [[19, 21], [31, 33], [43, 45]]}}}, {"text": "I did not take the SAX API into account; this just demonstrates how to use a Map", "label": {"api": {"Map": [[77, 79]]}}}, {"text": "I am trying to understand the usefulness of fairness property in Semaphore class", "label": {"api": {"Semaphore": [[65, 73]]}}}, {"text": "For Data Manipulation Language (DML) statement, such as INSERT, UPDATE or DELETE you can use ExecuteUpdate() which returns the number of rows updated, which can be useful when running an update statement", "label": {"api": {"ExecuteUpdate()": [[93, 107]]}}}, {"text": "The only thing in Java you can do is set the priority of the thread", "label": {"api": {"set the priority of the thread": [[37, 66]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/util/Map.html#putAll(java.util.Map) It just adds the maps, not override the content", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Map.html#putAll(java.util.Map)": [[0, 80]]}}}, {"text": "If you just want some compressed archive format, the JDK's ZipOutputStream will let you use zip compression", "label": {"api": {"ZipOutputStream": [[59, 73]]}}}, {"text": "If you specifically need gzip format, there are a number of implementstions of tar output streams out there - use one of those and pipeline it into the JDK's gzip output stream", "label": {"api": {"gzip output stream": [[158, 175]]}}}, {"text": "Use an Iterator to loop around your objects", "label": {"api": {"Iterator": [[7, 14]]}}}, {"text": "If you want to do it yourself w/o dependencies or complexities you should look into writing a Servlet Filter and/or leverage container security", "label": {"api": {"Servlet Filter": [[94, 107]]}}}, {"text": "Using a ScheduledExecutorService whould fit here", "label": {"api": {"ScheduledExecutorService": [[8, 31]]}}}, {"text": "This is because the argument to getResourceAsStream(...) is resolved relative to the classpath", "label": {"api": {"getResourceAsStream(...)": [[32, 55]]}}}, {"text": "You can use ArrayList#clear()", "label": {"api": {"ArrayList#clear()": [[12, 28]]}}}, {"text": "IndexOutOfBoundsException is thrown if the beginIndex is negative, or endIndex is larger than the length of this String object, or beginIndex is larger than endIndex", "label": {"api": {"IndexOutOfBoundsException": [[0, 24]]}}}, {"text": "The easiest approach would be to use a Timer", "label": {"api": {"Timer": [[39, 43]]}}}, {"text": "With that, you don't need the if logic; you can just use the firstTime argument when scheduling a TimerTask", "label": {"api": {"Timer": [[98, 102]], "TimerTask": [[98, 106]]}}}, {"text": "If you're using Swing, you should use a Swing Timer rather than a java.util.Timer", "label": {"api": {"Timer": [[46, 50], [76, 80]]}}}, {"text": "See How to Use Swing Timers for more info", "label": {"api": {"Timer": [[21, 25]]}}}, {"text": "A cleaner approach might be to define several TimerTasks that are scheduled to execute at different times", "label": {"api": {"Timer": [[46, 50]], "TimerTask": [[46, 54]]}}}, {"text": "YOu can use waitFor method to wait until created process stops", "label": {"api": {"waitFor": [[12, 18]], "wait": [[12, 15], [30, 33]]}}}, {"text": "processBuilderObject.wait() is a invocation of Object's wait method", "label": {"api": {"wait": [[21, 24], [56, 59]]}}}, {"text": "The javadoc of Transactional says", "label": {"api": {"javadoc of Transactional": [[4, 27]]}}}, {"text": "Check the Robot API and in particular the mouseMove(...), mousePress(...) and mouseRelease(...)", "label": {"api": {"Robot API": [[10, 18]]}}}, {"text": "I am working on a class that will have functionality similar to JTable's setDefaultRenderer method", "label": {"api": {"setDefaultRenderer": [[73, 90]]}}}, {"text": "Use JTextComponent#write to write the contents of the JTextArea instead", "label": {"api": {"JTextComponent#write": [[4, 23]]}}}, {"text": "I was debating whether there is any point in using an ExecutorService for a simple, dynamically growing list of threads of the same class, all of which are always active", "label": {"api": {"ExecutorService": [[54, 68]]}}}, {"text": "I understand that Executors.newFixedThreadPool(int) provides a thread pool that can contain any number of threads but only the number specified in the method are active at any point in time", "label": {"api": {"Executors.newFixedThreadPool(int)": [[18, 50]]}}}, {"text": "Are you looking for LinkedHashMap", "label": {"api": {"LinkedHashMap": [[20, 32]]}}}, {"text": "Look for the last / character with lastIndexOf", "label": {"api": {"lastIndexOf": [[35, 45]]}}}, {"text": "If it's found, then use substring to extract everything before it", "label": {"api": {"substring": [[24, 32]]}}}, {"text": "If you're just trying to split the string around a space, use split", "label": {"api": {"split": [[25, 29], [62, 66]]}}}, {"text": "Or you can treat runs of consecutive whitespace characters as a single delimiter, since split takes a regex", "label": {"api": {"split": [[88, 92]]}}}, {"text": "To fully understand what split is doing, take a look at the documentation in the link above, so you can modify this to split your strings however you like", "label": {"api": {"split": [[25, 29], [119, 123]]}}}, {"text": "I am curious about the time complexity of inserting an element at the beginning of a LinkedList", "label": {"api": {"LinkedList": [[85, 94]]}}}, {"text": "I understand the LinkedList itself will shift the existing elements one index to the right but, to do that, will it make as many iterations as there are existing elements in the list", "label": {"api": {"LinkedList": [[17, 26]]}}}, {"text": "Also, is the best way to insert at the beginning offerFirst", "label": {"api": {"offerFirst": [[49, 58]]}}}, {"text": "Is there a way to get something like isLocked status of a Lock", "label": {"api": {"Lock": [[39, 42], [58, 61]]}}}, {"text": "I was thinking of approaching the concurrency handling using the Locks framework, with which I am not the most familiar, hence this question", "label": {"api": {"Locks": [[65, 69]]}}}, {"text": "Should I use the ReentrantReadWriteLock instead", "label": {"api": {"ReentrantReadWriteLock": [[17, 38]]}}}, {"text": "An alternative is to use a ConcurrentLinkedDeque", "label": {"api": {"a ConcurrentLinkedDeque": [[25, 47]]}}}, {"text": "It's possible to use your approach using java.lang.Class#newInstance", "label": {"api": {"java.lang.Class#newInstance": [[41, 67]]}}}, {"text": "java.math.RoundingMode comes with HALF_EVEN mode which rounds number to nearest even neighbour in the case of equidistant, but why doesn't it come with HALF_ODD mode", "label": {"api": {"java.math.RoundingMode": [[0, 21]]}}}, {"text": "In this case I think you are better off using a BufferedImage as the paint surface and simply displaying that in a JLabel", "label": {"api": {"BufferedImage": [[48, 60]], "JLabel": [[115, 120]]}}}, {"text": "It may be a bit difficult to understand if you haven't played around with split and probably regular expression a bit already", "label": {"api": {"regular expression": [[93, 110]]}}}, {"text": "Then it's on to the regular expression", "label": {"api": {"regular expression": [[20, 37]]}}}, {"text": "I am learning about the CopyOnWriteArrayList class", "label": {"api": {"CopyOnWriteArrayList": [[24, 43]]}}}, {"text": "So if a system has high concurrency and most of the threads' actions are reading not writing, it is better to use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[114, 133]]}}}, {"text": "http://docs.oracle.com/javase/6/docs/api/java/util/Properties.html this is quite generic but you must make sure that they contain needed data", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Properties.html": [[0, 65]]}}}, {"text": "According to the Javadoc for Locale.getDefault(), you can change the default locale by using Locale.setDefault(Locale)", "label": {"api": {"Locale.getDefault()": [[29, 47]], "Locale.setDefault(Locale)": [[93, 117]]}}}, {"text": "One way to pre-fetch an image is to use MediaTracker", "label": {"api": {"MediaTracker": [[40, 51]]}}}, {"text": "From the java documentation about HashMap.put(K key, V value) method", "label": {"api": {"HashMap": [[34, 40]]}}}, {"text": "There will need to be a shared ReentrantLock between these threads, perhaps as a class variable", "label": {"api": {"ReentrantLock": [[31, 43]]}}}, {"text": "You can also use a semaphore for this", "label": {"api": {"semaphore": [[19, 27]]}}}, {"text": "The first one uses the DefaultThreadFactory which is an inner class of Executors", "label": {"api": {"DefaultThreadFactory": [[23, 42]], "Executors": [[71, 79]], "ThreadFactory": [[30, 42]]}}}, {"text": "When you define your own ThreadFactory you can influence the created Threads", "label": {"api": {"ThreadFactory": [[25, 37]]}}}, {"text": "You should use an ArrayList instead", "label": {"api": {"ArrayList": [[18, 26]]}}}, {"text": "MIME types can have any number of optional parameters (for example \"text/plain; charset=UTF-8\"), so you may want to compare using the MimeType.match method rather than just comparing the strings", "label": {"api": {"MimeType.match": [[134, 147]]}}}, {"text": "You can use ThreadLocal variable for this initialization", "label": {"api": {"ThreadLocal": [[12, 22]]}}}, {"text": "Look at Desktop.open(File) and associated methods", "label": {"api": {"Desktop.open(File)": [[8, 25]]}}}, {"text": "Read this for more information on SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[34, 49]]}}}, {"text": "And then use PreparedStatement#setTime()", "label": {"api": {"PreparedStatement#setTime()": [[13, 39]]}}}, {"text": "The combination of a decrementing for loop (from 10 to 1) and Thread.sleep should suit your needs", "label": {"api": {"Thread.sleep": [[62, 73]]}}}, {"text": "You could use Java's Logger", "label": {"api": {"Java's Logger": [[14, 26]]}}}, {"text": "If you want to do it the hard way you should keep in mind that getStackTrace() returns an array, so you'll have to process it", "label": {"api": {"getStackTrace() returns an array": [[63, 94]]}}}, {"text": "Anyway, TimerTask has an argument with which you can set the delay, see here", "label": {"api": {"see here": [[68, 75]]}}}, {"text": "This is how you can use java.util.Timer", "label": {"api": {"java.util.Timer": [[24, 38]]}}}, {"text": "Are you sure you are using a javafx.scene.shape.Rectangle", "label": {"api": {"javafx.scene.shape.Rectangle": [[29, 56]]}}}, {"text": "A javafx.scene.shape.Rectangle extends from Node so, it is a Node", "label": {"api": {"javafx.scene.shape.Rectangle": [[2, 29]]}}}, {"text": "My guess is that you are mistakenly importing and using some other rectangle type, for example java.awt.Rectangle", "label": {"api": {"java.awt.Rectangle": [[95, 112]]}}}, {"text": "You can also use BigDecimal, which supports arbitrary precision", "label": {"api": {"BigDecimal": [[17, 26]]}}}, {"text": "You have to implement the Iterable interface and you can use it in the enhanced for loop", "label": {"api": {"Iterable": [[26, 33]]}}}, {"text": "To have this functionality you can implement Iterable interface", "label": {"api": {"Iterable": [[45, 52]]}}}, {"text": "As it says in the Java Language Specification, you need to implement the Iterable interface", "label": {"api": {"Iterable interface": [[73, 90]]}}}, {"text": "It requires that you have an iterator method that returns an Iterator<T> instance", "label": {"api": {"Iterator<T> instance": [[61, 80]]}}}, {"text": "You want String.format method", "label": {"api": {"String.format": [[9, 21]]}}}, {"text": "If you want it in String pool then again call intern() method on both Strings", "label": {"api": {"intern()": [[46, 53]]}}}, {"text": "JToolBar has the methods addSeparator() & addSeparator(Dimension)", "label": {"api": {"addSeparator()": [[25, 38]], "addSeparator(Dimension)": [[42, 64]]}}}, {"text": "JMenu uses a spacing component better suited to menus, available through addSeparator()", "label": {"api": {"addSeparator()": [[73, 86]]}}}, {"text": "Class#getResource returns null if no resource with this name is found", "label": {"api": {"Class#getResource": [[0, 16]]}}}, {"text": "As for hiding the emoticon after a specified amount of time, use a swing Timer", "label": {"api": {"Timer": [[73, 77]]}}}, {"text": "Using SimpleDateFormat you can have an easier to write, read and maintain code", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "And of course you can re-use the instance of the SimpleDateFormat if you need to perform the operation more than once", "label": {"api": {"SimpleDateFormat": [[49, 64]]}}}, {"text": "java.sql.Date is A thin wrapper around a millisecond value that allows JDBC to identify this as an SQL DATE value", "label": {"api": {"java.sql.Date": [[0, 12]]}}}, {"text": "The JDBC driver will use the java.sql.Date object and format its data to an acceptable format while storing it in the DB and vice versa", "label": {"api": {"java.sql.Date": [[29, 41]]}}}, {"text": "You can use the getComponentZOrder() to get the z-index of the frames and set it using setComponentZOrder()", "label": {"api": {"getComponentZOrder()": [[16, 35]], "setComponentZOrder()": [[87, 106]]}}}, {"text": "Create a BlockingQueue for the data to work on", "label": {"api": {"BlockingQueue": [[9, 21]]}}}, {"text": "This is stated in the javadoc for Set.add", "label": {"api": {"Set.add": [[34, 40]]}}}, {"text": "A quick question about the example code in the JavaDoc for javax.swing.ListCellRenderer", "label": {"api": {"JavaDoc for javax.swing.ListCellRenderer": [[47, 86]]}}}, {"text": "Here is what the API says about it", "label": {"api": {"API": [[17, 19]]}}}, {"text": "I was wondering why Nimbus would be conflicting somehow with Virtual keys", "label": {"api": {"Virtual keys": [[61, 72]]}}}, {"text": "The way its wrote, you can try to use the Virtual keys", "label": {"api": {"Virtual keys": [[42, 53]]}}}, {"text": "Since you want to add all the elements from one collection to another, you can use Collection#addAll", "label": {"api": {"Collection#addAll": [[83, 99]]}}}, {"text": "The post also talks about using  the isReachable method - refer InetAddress documentation", "label": {"api": {"InetAddress documentation": [[64, 88]]}}}, {"text": "In Java, use the Collator class, as described in the tutorial on comparing strings", "label": {"api": {"Collator": [[17, 24]]}}}, {"text": "For normalization, see the tutorial on normalizing text", "label": {"api": {"tutorial on normalizing text": [[27, 54]]}}}, {"text": "If you prefer doing it from java code, you could use a ProcessBuilder to invoke the memcache startup/shutdown script(code example from javadoc)", "label": {"api": {"ProcessBuilder": [[55, 68]]}}}, {"text": "And you need to implement a ServletContextListener to receive servlet context lifecycle events, i.e", "label": {"api": {"ServletContextListener": [[28, 49]]}}}, {"text": "From the docs of ArrayList", "label": {"api": {"ArrayList": [[17, 25]]}}}, {"text": "You can use String.indexOf to find the location of the = and then String.substring to get your two values", "label": {"api": {"String.indexOf": [[12, 25]], "String.substring": [[66, 81]]}}}, {"text": "The API you're looking for is the Robot API", "label": {"api": {"Robot": [[34, 38]]}}}, {"text": "You can if necessary control the Facelets cache by providing a custom FaceletsCacheFactory and FaceletsCache", "label": {"api": {"FaceletsCacheFactory": [[70, 89]], "FaceletsCache": [[70, 82], [95, 107]]}}}, {"text": "The only obvious error I see in the code is that you are assigning your FileInputStream as null, and then referencing it without further initialization", "label": {"api": {"FileInputStream": [[72, 86]]}}}, {"text": "FileInputStream must be initialized with a File object, a FileDescriptor object or a String representing a File name", "label": {"api": {"FileInputStream": [[0, 14]]}}}, {"text": "Present days of week as an enum and use EnumMap class for storing lists of bought items", "label": {"api": {"EnumMap": [[40, 46]]}}}, {"text": "You can attach a shutdown hook to the JVM which gets run whenever the JVM shuts down", "label": {"api": {"shutdown hook": [[17, 29]]}}}, {"text": "Acording to String javadoc clone() from Object generates a \"shallow\" copy of the object where it is calling from", "label": {"api": {"String javadoc": [[12, 25]]}}}, {"text": "String#matches() matches the regex pattern from beginning of the string to the end", "label": {"api": {"String#matches()": [[0, 15]]}}}, {"text": "Or, use Pattern, Matcher and Matcher#find() method, to search for a particular pattern anywhere in a string", "label": {"api": {"Pattern": [[8, 14]], "Matcher": [[17, 23], [29, 35]], "Matcher#find()": [[29, 42]]}}}, {"text": "Your sAction variable is always a String, since Scanner.nextLine() returns String", "label": {"api": {"Scanner": [[48, 54]]}}}, {"text": "See also the other Scanner \"next\" methods if you'd like to fine-tune your input acceptance", "label": {"api": {"Scanner": [[19, 25]]}}}, {"text": "Say suppose the object referred to by a is a BigInteger , when you invoke a.add(b) , it returns a BigInteger object whose value is a+b , and hence you can invoke .add(c) on that object again", "label": {"api": {"BigInteger": [[45, 54], [98, 107]], "a.add(b)": [[74, 81]]}}}, {"text": "This practice is used mostly in Builder pattern, you can find this pattern in API itself in StringBuilder class", "label": {"api": {"StringBuilder": [[92, 104]]}}}, {"text": "No your understanding is wrong , a.add(b) means you are invoking method add() on object a and passing it a reference of object b", "label": {"api": {"a.add(b)": [[33, 40]]}}}, {"text": "The resultant object which the method a.add(b) returns is of the same type as a , and then in succession you call the method .add(c) on the returned object passing a reference of object c to that method", "label": {"api": {"a.add(b)": [[38, 45]]}}}, {"text": "But the webapp might have registered a database driver in DriverManager, or used some bean introspection (quite possible indirectly through a popular third party library that does reflection) that keeps bean metadata cached and therefore the classes from the webapp classloader live on after the webapp has been undeployed, still being strongly referenced from other objects not loaded by the webapp's classloader", "label": {"api": {"bean introspection": [[86, 103]]}}}, {"text": "As per the JOptoinPane API", "label": {"api": {"JOptoinPane API": [[11, 25]]}}}, {"text": "acording to ArrayList doc subList() returns a sublist that is backed by the original ArrayList, so if the original changes so does the subList, when you execute subList.clear() the sublist itself doesn't exist anymore", "label": {"api": {"ArrayList doc": [[12, 24]]}}}, {"text": "See official JavaDoc", "label": {"api": {"official JavaDoc": [[4, 19]]}}}, {"text": "You can use DatabaseMetaData.getColumns() to query the columns in a table", "label": {"api": {"DatabaseMetaData.getColumns()": [[12, 40]]}}}, {"text": "For finding primary keys, you can use DatabaseMetaData.getPrimaryKeys()", "label": {"api": {"DatabaseMetaData.getPrimaryKeys()": [[38, 70]]}}}, {"text": "Image is an abstract class", "label": {"api": {"Image": [[0, 4]]}}}, {"text": "However, You can extend the class which already implements the Image class and has all the methods already implemented in it", "label": {"api": {"Image": [[63, 67]]}}}, {"text": "For something simple like this, Scanner would probably work best", "label": {"api": {"Scanner": [[32, 38]]}}}, {"text": "You can do this fairly trivially with string operations (see StringBuilder)", "label": {"api": {"StringBuilder": [[61, 73]]}}}, {"text": "While the regex approach is certainly a valid method, I find it easier to think through when you split the words up by whitespace", "label": {"api": {"split": [[97, 101]]}}}, {"text": "This can be done with String's split method", "label": {"api": {"split": [[31, 35]]}}}, {"text": "The first pass to find the characters that are whitespace to split on, and the second pass looking through each split word for your substring", "label": {"api": {"split": [[61, 65], [112, 116]]}}}, {"text": "You can create a temp file using File.createTempFile", "label": {"api": {"File.createTempFile": [[33, 51]]}}}, {"text": "You can use java.nio.file.Files.isDirectory(Path path) to test whether your Path is a directory", "label": {"api": {"java.nio.file.Files.isDirectory(Path path)": [[12, 53]]}}}, {"text": "So when you try to access a[a.length - 1 + 1] (a[i+1] in the last iteration) you're getting ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[92, 121]]}}}, {"text": "I have noticed that in FileWriter there is a method to write a String", "label": {"api": {"FileWriter": [[23, 32]]}}}, {"text": ".write(String), whereas in FileReader there is only the possibility to read into a array of char", "label": {"api": {".write(String)": [[0, 13]], "FileReader": [[27, 36]], "the possibility to read into a array of char": [[52, 95]]}}}, {"text": "List.toArray(T[]) takes an array for Wrapper type, not primitive type", "label": {"api": {"List.toArray(T[])": [[0, 16]]}}}, {"text": "From the OutputStream.write(int) doc", "label": {"api": {"OutputStream.write(int)": [[9, 31]]}}}, {"text": "The default retention policy is RetentionPolicy.CLASS which means that, by default, annotation information is not retained at runtime", "label": {"api": {"RetentionPolicy.CLASS": [[32, 52]]}}}, {"text": "Instead, use RetentionPolicy.RUNTIME", "label": {"api": {"RetentionPolicy.RUNTIME": [[13, 35]]}}}, {"text": "...which you specify using the @Retention meta-annotation", "label": {"api": {"@Retention meta-annotation": [[31, 56]]}}}, {"text": "if you need to access both the keys and the values during the iteration, the fastest way is using the entrySet() method, as discussed here", "label": {"api": {"entrySet()": [[102, 111]]}}}, {"text": "As of Java 10 you can use one of the Map.of() overloaded methods or Map.copyOf() to create an unmodifiable Map", "label": {"api": {"unmodifiable Map": [[94, 109]]}}}, {"text": "Or, you can decorate your FileWriter with a PrintWriter and use its println() method for formatting", "label": {"api": {"FileWriter": [[26, 35]], "PrintWriter": [[44, 54]], "println()": [[68, 76]]}}}, {"text": "Instead, the first time the invokedynamic is called, it creates a Lambda function handler using the LambdaMetafactory.metafactory method, then uses this cached instance in future invocations of the Lambda", "label": {"api": {"LambdaMetafactory.metafactory method": [[100, 135]]}}}, {"text": "If you check java.sql.Timestamp JavaDoc, it is very explicit that this class extends from java.util.Date (as java.sql.Date does)", "label": {"api": {"java.sql.Timestamp JavaDoc": [[13, 38]], "java.sql.Date": [[109, 121]]}}}, {"text": "And in real world projects you must plain java.util.Date when storing the data in your database and mostly java.sql.Timestamp since it stores date and time value, while java.sql.Date just stores date value", "label": {"api": {"java.sql.Date": [[169, 181]]}}}, {"text": "On the other hand, java.util.Calendar is abstract since there are more implementations of this apart from java.util.GregorianCalendar", "label": {"api": {"GregorianCalendar": [[116, 132]]}}}, {"text": "BuddhistCalendar, JapaneseImperialCalendar and GregorianCalendar", "label": {"api": {"GregorianCalendar": [[47, 63]]}}}, {"text": "Now, why to work directly with Calendar instead of GregorianCalendar", "label": {"api": {"GregorianCalendar": [[51, 67]]}}}, {"text": "Another possible way , will be build a custom ELResolver", "label": {"api": {"ELResolver": [[46, 55]]}}}, {"text": "The Math.max() should work by selecting the highest positive value between 2 numbers provided", "label": {"api": {"Math.max()": [[4, 13]]}}}, {"text": "I don't really know why the behaviour changes between Java 6 and Java 7 (have you verified that with other compilers", "label": {"api": {"Java 6": [[54, 59]], "Java 7": [[65, 70]]}}}, {"text": "Use java.awt.Window.pack (JFrame indirectly extends Window)", "label": {"api": {"java.awt.Window.pack": [[4, 23]]}}}, {"text": "While running JavaScript in Java is straight forward enough using the javax.script API, running it with a complete DOM and handling changes to that DOM is a whole lot harder", "label": {"api": {"javax.script": [[70, 81]]}}}, {"text": "See the public String replaceAll(String regex,String replacement)", "label": {"api": {"public String replaceAll(String regex,String replacement)": [[8, 64]]}}}, {"text": "You should escape the special characters (Escaping a regex is done by \\, but in Java \\ is written as \\\\), or use String#quote", "label": {"api": {"String#quote": [[113, 124]]}}}, {"text": "Use String#replace(String search, String replace) method like this", "label": {"api": {"String#replace(String search, String replace)": [[4, 48]]}}}, {"text": "You can use the Java API method URLEncoder#encode()", "label": {"api": {"URLEncoder#encode()": [[32, 50]]}}}, {"text": "A better API for doing this is the UriBuilder", "label": {"api": {"UriBuilder": [[35, 44]]}}}, {"text": "The API says this about overflow", "label": {"api": {"API": [[4, 6]]}}}, {"text": "You can use InputStream#available() method", "label": {"api": {"InputStream#available()": [[12, 34]]}}}, {"text": "The Java Calendar class has this functionality, the getFirstDayOfWeek method", "label": {"api": {"getFirstDayOfWeek method": [[52, 75]]}}}, {"text": "Take a look at the Docs for Applet to see which methods it contains, and which ones it inherits from its parents", "label": {"api": {"Docs for Applet": [[19, 33]]}}}, {"text": "The Java Applet class provides default implementations for the init, start and paint methods (see java.applet.Applet)", "label": {"api": {"java.applet.Applet": [[98, 115]]}}}, {"text": "The ResizeMe class inherits from java.applet.Applet and thus inherits all the methods from the Applet class (for more on inheritance, see subclasses)", "label": {"api": {"java.applet.Applet": [[33, 50]]}}}, {"text": "For each \"door opened\" message, create a task with 2 minutes delay using ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[73, 96]]}}}, {"text": "You could use one or more DelayQueues to accomplish this", "label": {"api": {"DelayQueue": [[26, 35]]}}}, {"text": "You should use a SwingWorker", "label": {"api": {"SwingWorker": [[17, 27]]}}}, {"text": "I'm using the WatchService API to watch a directory, and getting ENTRY_CREATE events when a user starts copying a file into the directory", "label": {"api": {"WatchService": [[14, 25]], "ENTRY_CREATE": [[65, 76]]}}}, {"text": "For every subsequent modification, you will get an ENTRY_MODIFY event", "label": {"api": {"ENTRY_MODIFY": [[51, 62]]}}}, {"text": "When copying is completed, you will be notified with an ENTRY_MODIFY", "label": {"api": {"ENTRY_MODIFY": [[56, 67]]}}}, {"text": "I would give it a try whether opening the file as FileChannel for WRITE access throws an exception if the file is still locked for writing by another program", "label": {"api": {"opening the file as FileChannel": [[30, 60]]}}}, {"text": "No Exception needs to be fatal", "label": {"api": {"Exception": [[3, 11]]}}}, {"text": "(Errors however, are meant to be fatal", "label": {"api": {"Errors": [[1, 6]]}}}, {"text": "Don't catch them.)  All you have to do is catch the Exception somewhere, and it's not fatal", "label": {"api": {"Exception": [[52, 60]]}}}, {"text": "The getClass() method gets the Class object for the instance, getPackage() gets the Package object, and getName() returns the fully-qualified package name", "label": {"api": {"getName()": [[104, 112]]}}}, {"text": "You want an indirect method for obtaining these - for a standard Java solution try SPI, then your Base class can look them up dynamically without coupling using a ServiceLoader", "label": {"api": {"SPI": [[83, 85]], "ServiceLoader": [[163, 175]]}}}, {"text": "Create a java agent library with a Premain-Class definition in your jar manifest then add the agent to the JVM on the command line", "label": {"api": {"java agent": [[9, 18]]}}}, {"text": "The File Javadoc says that a relative file is usually resolved against the current user directory", "label": {"api": {"File Javadoc": [[4, 15]]}}}, {"text": "The date difference conversion could be handled in a better way using Java built-in class, TimeUnit", "label": {"api": {"TimeUnit": [[91, 98]]}}}, {"text": "In Java 8, you can make of DateTimeFormatter, Duration, and LocalDateTime", "label": {"api": {"DateTimeFormatter": [[27, 43]], "Duration": [[46, 53]], "LocalDateTime": [[60, 72]]}}}, {"text": "Use an AtomicReference<Map<Foo, Bar>> rather than exposing a direct (hard) reference to the map", "label": {"api": {"AtomicReference<Map<Foo, Bar>>": [[7, 36]]}}}, {"text": "Consumers of the map will use #get(), and when you're ready to swap out the map, your \"internal\" code will use #set() or #getAndSet()", "label": {"api": {"#get()": [[30, 35]], "#set()": [[111, 116]], "#getAndSet()": [[121, 132]]}}}, {"text": "You can override the equals() and hashCode() methods in your POJO and pass the List<UrlStore> to the Set", "label": {"api": {"equals()": [[21, 28]], "hashCode()": [[34, 43]], "Set": [[101, 103]]}}}, {"text": "I have used a simple HashSet here , the correct implementation of Set depends on your requirement", "label": {"api": {"HashSet": [[21, 27]], "Set": [[25, 27], [66, 68]]}}}, {"text": "You can even convert the Set back to the List", "label": {"api": {"Set": [[25, 27]]}}}, {"text": "You can use the Java BigInteger class", "label": {"api": {"BigInteger": [[21, 30]]}}}, {"text": "You can also look into the similar BigDecimal class for arbitrary precision signed decimal numbers", "label": {"api": {"BigDecimal": [[35, 44]]}}}, {"text": "Or you can call a new Thread, just like you do in the multithreaded situation, start it, and call thread.join() so that the main thread will wait for the newly started thread to finish", "label": {"api": {"thread.join()": [[98, 110]]}}}, {"text": "Points 2 and 3 are covered by Collections.unmodifiableMap", "label": {"api": {"Collections.unmodifiableMap": [[30, 56]]}}}, {"text": "You can use the SAXSource class, which has a constructor that takes an InputSource argument", "label": {"api": {"SAXSource class": [[16, 30]], "InputSource": [[71, 81]]}}}, {"text": "There's an InputSource constructor that takes a Reader argument, so you can use that constructor and use the StringReader implementation", "label": {"api": {"InputSource": [[11, 21]], "Reader": [[48, 53], [115, 120]], "StringReader": [[109, 120]]}}}, {"text": "Directly from this Scanner API", "label": {"api": {"API": [[27, 29]]}}}, {"text": "Have you seen http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html": [[14, 81]]}}}, {"text": "I suggest you remove the applyComponentOrientation() and look at setHorizontalAlignment instead", "label": {"api": {"setHorizontalAlignment": [[65, 86]]}}}, {"text": "You can use (?i) in your regex or use a Pattern and the Pattern.CASE_INSENSITIVE flag", "label": {"api": {"the Pattern.CASE_INSENSITIVE flag": [[52, 84]]}}}, {"text": "If you want to use an ordered set in Java, use one of implementations of SortedSet", "label": {"api": {"SortedSet": [[73, 81]]}}}, {"text": "I'm not sure if SOF is the best place to ask this, but something about the java URLEncoder and URLDecoder", "label": {"api": {"URLEncoder": [[80, 89]], "URLDecoder": [[95, 104]]}}}, {"text": "For URLEncoder, it has the method encode(String, String) where the second parameter is the name of the encoding to use", "label": {"api": {"URLEncoder": [[4, 13]]}}}, {"text": "But Java has the Charset class built in and you can easily access the Charset object of your favourite encoding using Java's StandardCharsets or Guava's Charsets", "label": {"api": {"Charset": [[17, 23], [70, 76], [133, 139], [153, 159]], "Java's StandardCharsets": [[118, 140]]}}}, {"text": "Without the ability to use a method like URLEncoder.encode(String, Charset), the code I write becomes really ugly because I need to store an extra String variable to store the encoding name and I have a pretty redundant try-catch statement, like so", "label": {"api": {"URLEncoder": [[41, 50]], "Charset": [[67, 73]]}}}, {"text": "The same logic applied to URLDecoder.decode(String, String)", "label": {"api": {"URLDecoder": [[26, 35]]}}}, {"text": "So therefore, I'm just wondering, why does Java not have URLEncoder.encode(String, Charset) nor URLDecoder.decode(String, Charset)", "label": {"api": {"URLEncoder": [[57, 66]], "URLDecoder": [[96, 105]], "Charset": [[83, 89], [122, 128]]}}}, {"text": "Are there any existing implementations or libraries that improve on this missing feature from URLEncoder and URLDecoder", "label": {"api": {"URLEncoder": [[94, 103]], "URLDecoder": [[109, 118]]}}}, {"text": "YourCharset.name() returns a String containing the canonical name, which you should be able to pass to decode() without fear of an exception", "label": {"api": {"YourCharset.name()": [[0, 17]]}}}, {"text": "Look into SwingWorker", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "It sounds like you just need to use getMethod instead of getDeclaredMethod", "label": {"api": {"getDeclaredMethod": [[57, 73]], "getMethod": [[36, 44]]}}}, {"text": "The whole point of getDeclaredMethod is that it only finds methods declared in the class you're calling it on", "label": {"api": {"getDeclaredMethod": [[19, 35]]}}}, {"text": "Whereas getMethod has", "label": {"api": {"getMethod": [[8, 16]]}}}, {"text": "If the method you're after isn't public, you should recurse up the class hierarchy yourself, using getDeclaredMethod or getDeclaredMethods on each class in the hierarchy", "label": {"api": {"getDeclaredMethod": [[99, 115], [120, 136]]}}}, {"text": "To elaborate further, Executors.newCachedThreadPool and Executors.newFixedThreadPool are both backed by the same thread pool implementation (at least in the open JDK) just with different parameters", "label": {"api": {"Executors.newCachedThreadPool": [[22, 50]], "Executors.newFixedThreadPool": [[56, 83]]}}}, {"text": "You ignored the return of the format method and instead returned the normal conversion to a String using String.valueOf", "label": {"api": {"format": [[30, 35]]}}}, {"text": "The format method doesn't change the number; it returns its formatted representation", "label": {"api": {"format": [[4, 9], [60, 65]]}}}, {"text": "Just return what format returns", "label": {"api": {"format": [[17, 22]]}}}, {"text": "There is now a reactive streams initiative in the works, and it looks like JDK 9 will include support for at least part of it though the Flow class", "label": {"api": {"Flow": [[137, 140]]}}}, {"text": "Read the Image into a java.awt.BufferedImage a using one of the read() methods of java.imageio.ImageIO", "label": {"api": {"java.awt.BufferedImage": [[22, 43]], "java.imageio.ImageIO": [[82, 101]]}}}, {"text": "Then you can access the color values of each pixsel using getRGB(int x, int y)", "label": {"api": {"getRGB(int x, int y)": [[58, 77]]}}}, {"text": "If you want/need to use an object, you can use the wrapper Integer", "label": {"api": {"Integer": [[59, 65]]}}}, {"text": "Unboxing is going from Integer or Wrapper to int or primitive", "label": {"api": {"Integer": [[23, 29]]}}}, {"text": "Autoboxing is going from int or primitive to Integer or Wrapper", "label": {"api": {"Integer": [[45, 51]]}}}, {"text": "In this case, Integer contains a private final int", "label": {"api": {"Integer": [[14, 20]]}}}, {"text": "You may need to use a wrapper, if for example, you wanted to use a List, which cannot hold primitives", "label": {"api": {"List": [[67, 70]]}}}, {"text": "I typically prefer to use the Scanner class to read from the input line", "label": {"api": {"Scanner": [[30, 36]]}}}, {"text": "With the Scanner class you are able to request specific types (double, int, ..., string)", "label": {"api": {"Scanner": [[9, 15]]}}}, {"text": "If you have access to the socket object(s), you can change the timeout by setting the SO_TIMEOUT socket option", "label": {"api": {"SO_TIMEOUT": [[86, 95]]}}}, {"text": "Maybe you could use the getDefaultUserName() from Authenticator to supply the user name", "label": {"api": {"getDefaultUserName()": [[24, 43]]}}}, {"text": "To discard repeated vertexes you could put your vertexes to LinkedHashMap and in your code check if vertex is in the map", "label": {"api": {"LinkedHashMap": [[60, 72]]}}}, {"text": "If two values x and y have the same openTime, then compare(x, y) and compare(y, x) will both return 1, which violates the contract of compare", "label": {"api": {"compare": [[51, 57], [69, 75], [134, 140]]}}}, {"text": "The implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y", "label": {"api": {"compare": [[37, 43], [60, 66]]}}}, {"text": "public Date(String s) is deprecated", "label": {"api": {"public Date(String s)": [[0, 20]]}}}, {"text": "I have read this API, however it's not that clear", "label": {"api": {"API": [[17, 19]]}}}, {"text": "You should use ServletContext for this", "label": {"api": {"ServletContext": [[15, 28]]}}}, {"text": "InputStream.read() returns -1 at the end of the stream", "label": {"api": {"returns -1": [[19, 28]]}}}, {"text": "I moved the initialization of the chart and the valueMarker to the initialize() method which the FXMLLoader automatically calls after the root element has been processed (see the note in the JavaFX Documentation)", "label": {"api": {"JavaFX Documentation": [[191, 210]]}}}, {"text": "For each id, you need a SerialExecutor, described in the documentation of java.util.concurrent.Executor", "label": {"api": {"java.util.concurrent.Executor": [[74, 102]]}}}, {"text": "All serial executors delegate work to a ThreadPoolExecutor with given corePoolSize", "label": {"api": {"ThreadPoolExecutor": [[40, 57]]}}}, {"text": "You can use String.replace() to remove the spaces in both strings", "label": {"api": {"String.replace()": [[12, 27]]}}}, {"text": "String#replace() method is helpful for you", "label": {"api": {"String#replace()": [[0, 15]]}}}, {"text": "Better use any implementation of List , like an ArrayList", "label": {"api": {"List": [[33, 36], [53, 56]], "ArrayList": [[48, 56]]}}}, {"text": "You need String#spilt() to split the string, something like", "label": {"api": {"String#spilt()": [[9, 22]]}}}, {"text": "Also, if you're debugging, you might want to print the return value of put() (it could give you some insight as to what's going on)", "label": {"api": {"put()": [[71, 75]]}}}, {"text": "Incidentally, the sample code you've posted doesn't need a TreeMap; if you're using the value as the key, what you really wanted was probably a Treeset", "label": {"api": {"Treeset": [[144, 150]]}}}, {"text": "If you are going to be initializing blank copies of this Map frequently, it will make more sense to have a template Map that each myMap is constructed from; either a HashMap wrapped as unmodifiable or a Guava ImmutableMap are good choices there", "label": {"api": {"is constructed from": [[136, 154]]}}}, {"text": "Use an ArrayList instead of an array", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "This way you can use the ArrayList.add() function to append to the end of your array and the ArrayList.get(int index) function to get the array entry at index index", "label": {"api": {"ArrayList": [[25, 33], [93, 101]]}}}, {"text": "If you're wanting to write values to multiple files based on different keys, simply use the keys (Strings, I would presume) to construct the file names and create the files in the usual way, e.g., with FileWriter", "label": {"api": {"FileWriter": [[202, 211]]}}}, {"text": "You haven't posted enough of the surrounding code for your question to be entirely clear, but look at the Javadocs for Map", "label": {"api": {"the Javadocs for Map": [[102, 121]]}}}, {"text": "You can access the keys of any HashMap using Map.keySet() method", "label": {"api": {"Map.keySet()": [[45, 56]]}}}, {"text": "If you want to simply change the output format, you could use .format() from SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[77, 92]]}}}, {"text": "If you wish to use a SimpleDateFormat, but actually want to change the internal format, use applyPattern()", "label": {"api": {"SimpleDateFormat": [[21, 36]]}}}, {"text": "Use String#lastIndexOf(String) with String#substring(int)", "label": {"api": {"String#lastIndexOf(String)": [[4, 29]], "String#substring(int)": [[36, 56]]}}}, {"text": "The article goes on to describe how to avoid this, but you could simplify the process by using ProcessBuilder instead of Runtime.exec() and then redirecting the ErrorStream", "label": {"api": {"ProcessBuilder": [[95, 108]]}}}, {"text": "I think you'd like to use special java simple date format for this", "label": {"api": {"java simple date format": [[34, 56]]}}}, {"text": "First of all if you construct a string in a loop, don't concatenate Strings, but us a StringBuilder as it usually performs better and doesn't trash your memory with a lot of intermediate strings", "label": {"api": {"StringBuilder": [[86, 98]]}}}, {"text": "Look at the PrintWriter or look for a library that already does what you need (eg OpenCSV)", "label": {"api": {"PrintWriter": [[12, 22]]}}}, {"text": "This is documented in the Properties documentation - in particular, look at the store() method that you're calling", "label": {"api": {"store()": [[80, 86]]}}}, {"text": "Also take a look at Properties.load() documentation", "label": {"api": {"Properties.load()": [[20, 36]]}}}, {"text": "If you're trying to find out the hostname associated with an IP address, use InetAddress#getHostName(), though that will only work if the local network has hosts registered for reverse DNS", "label": {"api": {"InetAddress#getHostName()": [[77, 101]]}}}, {"text": "One alternative is to use a CopyOnWriteArrayList which provides an iterator that iterates over the list as it was known when the iteration started, regardless of subsequent modifications", "label": {"api": {"a CopyOnWriteArrayList": [[26, 47]], "an iterator": [[64, 74]]}}}, {"text": "ArrayList is iterable, so this is a good place to use an iterator", "label": {"api": {"an iterator": [[54, 64]]}}}, {"text": "Override it and throw UnsupportedOperationexception in method body or just leave it empty", "label": {"api": {"UnsupportedOperationexception": [[22, 50]]}}}, {"text": "Throw an UnsupportedOperationException in the method", "label": {"api": {"UnsupportedOperationException": [[9, 37]]}}}, {"text": "Well, each time you want a random value, you can shuffle your collection using Collections.shuffle(List<?>)", "label": {"api": {"Collections.shuffle(List<?>)": [[79, 106]]}}}, {"text": "CountdownLatch or a Phaser (if the number of preceding tasks can change)", "label": {"api": {"CountdownLatch": [[0, 13]], "Phaser": [[20, 25]]}}}, {"text": "You should use the dotted form because according to the documentation in ClassLoader.loadClass names are supposed to be binary names", "label": {"api": {"binary names": [[120, 131]]}}}, {"text": "The JLS defines binary names in JLS 13.1, item 1", "label": {"api": {"binary names": [[16, 27]]}}}, {"text": "Java's Thread.suspend() probably (depends on the JVM but I doubt that anybody would implement it like that) won't work, but I also wouldn't recommend it", "label": {"api": {"Thread.suspend()": [[7, 22]]}}}, {"text": "If you annotate java.util.Calendar fields with @Temporal(TemporalType.DATE), then the generated SQL should be of type DATE, for example", "label": {"api": {"@Temporal(TemporalType.DATE)": [[47, 74]]}}}, {"text": "Additionally, you can specify how to generate a column's DDL with columnDefinition", "label": {"api": {"columnDefinition": [[66, 81]]}}}, {"text": "ByteBuffer can handle this", "label": {"api": {"ByteBuffer": [[0, 9]]}}}, {"text": "As of Java 5, most of the uses for one-bit bit fields are taken care of very nicely by EnumSet, which is internally implemented using a bit field (so it's extremely fast) but is type-safe, easy to read, and Iterable", "label": {"api": {"EnumSet": [[87, 93]]}}}, {"text": "One way would be you can use the ScriptEngine class and evaluate it as a javascript string using eval()", "label": {"api": {"ScriptEngine": [[33, 44]], "eval()": [[97, 102]]}}}, {"text": "You have to use ScriptEngineManager#getEngineByName(\"js\") to load the JS interpreter", "label": {"api": {"ScriptEngine": [[16, 27]], "ScriptEngineManager#getEngineByName(\"js\")": [[16, 56]]}}}, {"text": "Reference these formats Java Date Format Docs", "label": {"api": {"Java Date Format Docs": [[24, 44]]}}}, {"text": "From DateFormat#setLenient(boolean) documentation", "label": {"api": {"DateFormat#setLenient(boolean)": [[5, 34]]}}}, {"text": "To be able to filter and sort the table by my own tablerow, I added a TableRowSorter", "label": {"api": {"TableRowSorter": [[70, 83]]}}}, {"text": "But concerning TableRowSorter I suddenly wasn’t sure, if I also can or even have to use the same TableRowSorter-Instance or if I have to create a TableRowSorter for each table", "label": {"api": {"TableRowSorter": [[15, 28], [97, 110], [146, 159]]}}}, {"text": "After some digging I found out that this is because the TableRowSorter gets updated twice at each TableModelEvent, because each table (RowHeader and MainTable) notifies the TableRowSorter about tablechanges on its own", "label": {"api": {"TableRowSorter": [[56, 69], [173, 186]]}}}, {"text": "Should I add a second TableRowSorter (one for each table) and synchronize these, or should I wrap the TableModel within the RowHeaderTable and let it not fireing any Events", "label": {"api": {"TableRowSorter": [[22, 35]]}}}, {"text": "For your case, I guess the best explanation for immutable Collections.EMPTY_MAP is the following", "label": {"api": {"Collections.EMPTY_MAP": [[58, 78]], "EMPTY_MAP": [[70, 78]], "Collections": [[58, 68]]}}}, {"text": "Let's say that you decide to use the EMPTY_MAP from Collections (if it's there, why not?)", "label": {"api": {"EMPTY_MAP": [[37, 45]], "Collections": [[52, 62]]}}}, {"text": "You modify the reference EMPTY_MAP to all of your code that uses this reference (This brings us back to number 1", "label": {"api": {"EMPTY_MAP": [[25, 33]]}}}, {"text": "Remember the change in EMPTY_MAP?)", "label": {"api": {"EMPTY_MAP": [[23, 31]]}}}, {"text": "This are the main 3 reasons (that i can think of at the moment) for what you need immutable EMPTY_MAP", "label": {"api": {"EMPTY_MAP": [[92, 100]]}}}, {"text": "And a solution to your problem, you shouldn't use EMPTY_MAP, you should create one yourself", "label": {"api": {"EMPTY_MAP": [[50, 58]]}}}, {"text": "After refering to this link http://docs.oracle.com/javase/7/docs/api/java/security/AccessController.html , I figured out ,that reading,writing or even deleting can be done by wraping them up in AccessController.doPrivileged method", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/security/AccessController.html": [[28, 103]]}}}, {"text": "The method waitFor() returns an integer value which is the return code", "label": {"api": {"waitFor()": [[11, 19]]}}}, {"text": "You might have to define a custom ClassLoader", "label": {"api": {"ClassLoader": [[34, 44]]}}}, {"text": "Java Date objects (and note that java.sql.Date is a java.util.Date) don't have \"formats\"", "label": {"api": {"java.sql.Date": [[33, 45]], "java.util.Date": [[52, 65]]}}}, {"text": "Calendar also doesn't have a \"format\"", "label": {"api": {"Calendar": [[0, 7]]}}}, {"text": "Consider using SimpleDateFormat to format one of these things into a String", "label": {"api": {"SimpleDateFormat": [[15, 30]]}}}, {"text": "or if you use a Calendar object (not recommended)", "label": {"api": {"Calendar": [[16, 23]]}}}, {"text": "Here is a link to the Collections java doc online", "label": {"api": {"Collections java doc online": [[22, 48]]}}}, {"text": "Read the documentation for the String class", "label": {"api": {"String": [[31, 36]]}}}, {"text": "The order of threads acquiring the lock is random in case of synchronize", "label": {"api": {"lock": [[35, 38]]}}}, {"text": "You can use a lock to dictate the order though", "label": {"api": {"lock": [[14, 17]]}}}, {"text": "Also, in case 1 the lock is over the entire Class object in latter case its just over the lock", "label": {"api": {"lock": [[20, 23], [90, 93]]}}}, {"text": "Either by using the Class type of the object you've created and retrieve the list with all the interfaces that it implements", "label": {"api": {"Class": [[20, 24]]}}}, {"text": "Or using the Class#isAssignableFrom(Class clazz) method", "label": {"api": {"Class": [[13, 17], [36, 40]], "Class#isAssignableFrom(Class clazz)": [[13, 47]]}}}, {"text": "You should use Class#isAssignableFrom(Class<?> cls) method here", "label": {"api": {"Class#isAssignableFrom(Class<?> cls)": [[15, 50]]}}}, {"text": "So either rename your init method to start with set or just inject the field, annotate your init method with @PostConstruct annotation something like this", "label": {"api": {"@PostConstruct": [[109, 122]]}}}, {"text": "Yes, with System.identityHashCode", "label": {"api": {"System.identityHashCode": [[10, 32]]}}}, {"text": "Color has a getRGB() method that returns the color as an int", "label": {"api": {"getRGB()": [[12, 19]]}}}, {"text": "Take a look at Stage.setFullScreen", "label": {"api": {"Stage.setFullScreen": [[15, 33]]}}}, {"text": "You can use a PreparedStatement, and place a", "label": {"api": {"PreparedStatement": [[14, 30]]}}}, {"text": "Then you can supply the value with setString before executing the query", "label": {"api": {"setString": [[35, 43]]}}}, {"text": "Is there an equivalent method to Java.lang.Character.isUnicodeIdentifierStart() in .NET", "label": {"api": {"Java.lang.Character.isUnicodeIdentifierStart()": [[33, 78]]}}}, {"text": "You can use a DecimalFormat with setMinimumFractionDigits(int scale)", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "You are allowed to create your own instances of Exception", "label": {"api": {"Exception": [[48, 56]]}}}, {"text": "If you want to trigger a catch block, you need to throw the Exception from your try", "label": {"api": {"Exception": [[60, 68]]}}}, {"text": "You might also want to consider subclassing Exception to provide a little bit more information about what caused the problem", "label": {"api": {"Exception": [[44, 52]]}}}, {"text": "If you got the OutputStream from the response , you can write the contents of the OutputStream to the response which will be sent back to the browser", "label": {"api": {"OutputStream": [[15, 26], [82, 93]]}}}, {"text": "So  you can get the OutputStream from that method as", "label": {"api": {"OutputStream": [[20, 31]]}}}, {"text": "Even if you use IdentityHashCode(), which gives the non-overrided version of hashCode(), you still won't get a memory address", "label": {"api": {"IdentityHashCode()": [[16, 33]]}}}, {"text": "Sorry that I don't know any layout manager that allows components to overlap, but you can use JLayeredPane to achieve you goal", "label": {"api": {"JLayeredPane": [[94, 105]]}}}, {"text": "Add a JLayeredPane to the JFrame and then add the LShapePanels to the JLayeredPane", "label": {"api": {"JLayeredPane": [[6, 17], [70, 81]]}}}, {"text": "This uses the absolute get and put method of the ByteBuffer class and sets the position at next write position", "label": {"api": {"get": [[23, 25]], "put": [[31, 33]], "ByteBuffer": [[49, 58]], "position": [[79, 86], [102, 109]]}}}, {"text": "Note that the absolute put method is optional, which means that a class that extends the abstract class ByteBuffer may not provide an implementation for it, for example it might throw a ReadOnlyBufferException", "label": {"api": {"put": [[23, 25]], "ByteBuffer": [[104, 113]]}}}, {"text": "Whether you choose to loop till position or till limit depends on how you use the buffer, for example if you manually set the position you might want to use loop till limit", "label": {"api": {"position": [[32, 39], [126, 133]], "limit": [[49, 53], [167, 171]]}}}, {"text": "If you do not then looping till position is enough and more efficient", "label": {"api": {"position": [[32, 39]]}}}, {"text": "In java == is used to check reference equality, instead equals() and hashCode() works together as 'single concept' for object equality", "label": {"api": {"'single concept'": [[98, 113]]}}}, {"text": "If you need a Map that works with == use IdentityHashMap", "label": {"api": {"IdentityHashMap": [[41, 55]]}}}, {"text": "Are you looking for http://docs.oracle.com/javase/6/docs/api/java/util/zip/ZipInputStream.html which can extract entries in zip file without extracting it completely", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/zip/ZipInputStream.html": [[20, 93]]}}}, {"text": "Use a Map", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "A HashMap is a good choice", "label": {"api": {"Map": [[6, 8]], "HashMap": [[2, 8]]}}}, {"text": "Apart from Calendar that you have used , another simple approach would be", "label": {"api": {"Calendar": [[11, 18]]}}}, {"text": "You can use before() and after() of Calendar as well", "label": {"api": {"Calendar": [[36, 43]]}}}, {"text": "I'm not sure if this answers your question, but setSoTimeout only applies to reads on the socket after it is connected, not to establishing the connection itself", "label": {"api": {"setSoTimeout": [[48, 59]]}}}, {"text": "For that, use the socket.connect(SocketAddress address, int timout) overload.) overload", "label": {"api": {"socket.connect(SocketAddress address, int timout)": [[18, 66]]}}}, {"text": "Another approach is to use File.deleteOnExit() which marks a file for the JVM to delete upon exit", "label": {"api": {"File.deleteOnExit()": [[27, 45]]}}}, {"text": "As an alternative to @Brian Agnew's answer, why not install a ShutdownHook that clears out your cache directory", "label": {"api": {"ShutdownHook": [[62, 73]]}}}, {"text": "This line prints the result of the add function, which is a boolean (http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html#add(E))", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html#add(E)": [[69, 140]]}}}, {"text": "You probably want to implement equals() as well (the \"Bloch way\" is a good implementation)", "label": {"api": {"equals()": [[31, 38]]}}}, {"text": "To coordinate them use a CyclicBarrier", "label": {"api": {"CyclicBarrier": [[25, 37]]}}}, {"text": "To launch them all at the same time use a CountDownLatch", "label": {"api": {"CountDownLatch": [[42, 55]]}}}, {"text": "For this you may also use retainAll from the Collections API to perform a list intersecion and see if the intersection list is non-empty", "label": {"api": {"retainAll": [[26, 34]]}}}, {"text": "ClassLoader has a method, defineClass, that lets you dynamically generate a class by providing the bytecode", "label": {"api": {"defineClass": [[26, 36]]}}}, {"text": "As @mKorbel comments, the five pixel vertical space is added by the default layout of JPanel, FlowLayout", "label": {"api": {"FlowLayout": [[94, 103]]}}}, {"text": "Take a look at RandomAccessFile", "label": {"api": {"RandomAccessFile": [[15, 30]]}}}, {"text": "You can use Collections.sort(List) instead", "label": {"api": {"Collections.sort(List)": [[12, 33]]}}}, {"text": "You can use Collections.sort() (it takes an optional comparator if that's of interest)", "label": {"api": {"Collections.sort()": [[12, 29]]}}}, {"text": "Make use of a sorted collection like a TreeMap here", "label": {"api": {"TreeMap": [[39, 45]]}}}, {"text": "No dereferencing problems here since there an indexOf(int) function", "label": {"api": {"indexOf(int)": [[46, 57]]}}}, {"text": "contains would probably make for slightly more readable code, unfortunately it takes a CharSequence parameter (superclass of String), so you'd need to convert guess to String in this case", "label": {"api": {"contains": [[0, 7]]}}}, {"text": "When you read XML with a SAX Parser you implement a kind of ContentHandler (see http://docs.oracle.com/javase/7/docs/api/org/xml/sax/ContentHandler.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/org/xml/sax/ContentHandler.html": [[80, 151]]}}}, {"text": "It is syntactic sugar for using Iterator", "label": {"api": {"Iterator": [[32, 39]]}}}, {"text": "You might also like System#getProperties()", "label": {"api": {"System#getProperties()": [[20, 41]]}}}, {"text": "Class.getDeclaredFields() (http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredFields%28%29) and inspecting the resulting array of fields", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getDeclaredFields%28%29": [[27, 111]]}}}, {"text": "You should use either a Stack or a Deque or even a LinkedList", "label": {"api": {"Stack": [[24, 28]], "Deque": [[35, 39]], "LinkedList": [[51, 60]]}}}, {"text": "There is an interface called KeyListener but this only works with swing classes, and based on you're code this a console application", "label": {"api": {"swing": [[66, 70]]}}}, {"text": "You could use JNativehook which allows you to use swing events in a console application", "label": {"api": {"swing": [[50, 54]]}}}, {"text": "You should learn basic swing events before using this though", "label": {"api": {"swing": [[23, 27]]}}}, {"text": "You can place all elements in a Set, and in each iteration - delete the element from the set", "label": {"api": {"Set": [[32, 34]]}}}, {"text": "Also, the Javadoc for BufferedOutputStream says", "label": {"api": {"Javadoc for BufferedOutputStream": [[10, 41]]}}}, {"text": "SimpleDateFormat.parse (have a look at the HTML source code)", "label": {"api": {"SimpleDateFormat.parse": [[0, 21]]}}}, {"text": "It works as explained in the javadoc for Object#wait, emphasis mine", "label": {"api": {"the javadoc for Object#wait": [[25, 51]]}}}, {"text": "From the java.sql.Connection you have getMetaData() to get the DatabaseMetaData", "label": {"api": {"DatabaseMetaData": [[63, 78]]}}}, {"text": "getDatabaseMajorVersion()) to get version information, if the Driver implement this info", "label": {"api": {"getDatabaseMajorVersion()": [[0, 24]]}}}, {"text": "You can use the subList method in the List interface to divide your list", "label": {"api": {"subList": [[16, 22]]}}}, {"text": "See the Integer.parseInt(String s, int radix) method", "label": {"api": {"Integer.parseInt(String s, int radix)": [[8, 44]]}}}, {"text": "Sounds like you want a javax.swing.Timer to fire every 30 seconds", "label": {"api": {"javax.swing.Timer": [[23, 39]]}}}, {"text": "via a ScheduledExecutorService) - then fetch the information and only get the UI involved when you actually need to update the UI", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "You should not do that, but use SwingUtilities instead", "label": {"api": {"SwingUtilities": [[32, 45]]}}}, {"text": "To do this, make sure the list's model is a DefaultListModel, then you can use ((DefaultListModel)getModel()).addElement() to add an item", "label": {"api": {"DefaultListModel": [[44, 59], [81, 96]], "getModel()": [[98, 107]], "addElement()": [[110, 121]]}}}, {"text": "You could use JList's setListData() for this", "label": {"api": {"setListData()": [[22, 34]]}}}, {"text": "But bear in mind that this sets the list model to a read-only model, and you will not be able to use getModel().addElement() later", "label": {"api": {"getModel()": [[101, 110]], "addElement()": [[112, 123]]}}}, {"text": "Instead, use the Iterator.remove() method", "label": {"api": {"Iterator.remove()": [[17, 33]]}}}, {"text": "You should use setVisible(true) instead of repaint()", "label": {"api": {"setVisible(true)": [[15, 30]]}}}, {"text": "Use DriverManager  class to set up database server login connection timeout", "label": {"api": {"DriverManager ": [[4, 17]]}}}, {"text": "You can loop over the map's values()", "label": {"api": {"values()": [[28, 35]]}}}, {"text": "You can use the JavaCompiler", "label": {"api": {"JavaCompiler": [[16, 27]]}}}, {"text": "Such functionality was considered useful enough in Java for the Java community to ask for it to be added to the JDK, and it's now in JDK 7", "label": {"api": {"now in JDK 7": [[126, 137]]}}}, {"text": "So the HttpServletRequest seems like a really cool way of storing session variables and passing a session between methods", "label": {"api": {"HttpServletRequest": [[7, 24]]}}}, {"text": "However, I'm not quite sure how to test this code, as I don't really understand what the HttpServletRequest interface is", "label": {"api": {"HttpServletRequest": [[89, 106]]}}}, {"text": "HttpServletRequest is an interface, which means it can't be instantiated on its own", "label": {"api": {"HttpServletRequest": [[0, 17]]}}}, {"text": "as in, when a method takes an HttpServletRequest as a parameter, what implementing class is usually passed in", "label": {"api": {"HttpServletRequest": [[30, 47]]}}}, {"text": "Based on the answers given, HttpServletRequest is implemented differently by different servers; Ireeder pointed out, for example, that Apache even has multiple implementations", "label": {"api": {"HttpServletRequest": [[28, 45]]}}}, {"text": "(Sorry, I'm a bit new at this, so bear with me...) If val mockRequest needs to be implemented with whatever HttpServletRequest implementation is used by the server (Apache, Oracle, etc),  how does the user specify this in otherClass", "label": {"api": {"HttpServletRequest": [[108, 125]]}}}, {"text": "What they do is to wrap a Callable in a FutureTask then launch it using a thread", "label": {"api": {"Callable": [[26, 33]], "FutureTask": [[40, 49]]}}}, {"text": "Then they call FutureTask.get(long timeout, TimeUnit unit) which returns the result or throws a TimeoutException if timeout units passed and lets the thread run as long as it wants", "label": {"api": {"FutureTask": [[15, 24]]}}}, {"text": "From reading http://docs.oracle.com/javase/6/docs/api/java/util/Properties.html it doesn't seem to make mention of needing to escape any escape/control characters after the first unescaped = or", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Properties.html": [[13, 78]]}}}, {"text": "Just return System.identityHashCode(this)", "label": {"api": {"System.identityHashCode(this)": [[12, 40]]}}}, {"text": "Looking at the java enum documentaiton there is the method ordinal that will return the enum value as an int type", "label": {"api": {"java enum documentaiton": [[15, 37]]}}}, {"text": "You are using JOptionPane from Swing", "label": {"api": {"JOptionPane": [[14, 24]]}}}, {"text": "You should create MimeMultipart, MimeBodyPart, FileDataSource and DataHandler as follows", "label": {"api": {"MimeMultipart": [[18, 30]], "MimeBodyPart": [[33, 44]], "FileDataSource": [[47, 60]], "DataHandler": [[66, 76]]}}}, {"text": "Now, On MimeMessage use setContent method", "label": {"api": {"MimeMessage": [[8, 18]], "setContent": [[24, 33]]}}}, {"text": "The default initial capacity is 16, so by passing in 0 you may save a few bytes of memory if you end up not putting anything in the set", "label": {"api": {"default initial capacity is 16": [[4, 33]]}}}, {"text": "I have so far found two ways of doing it, either by using Collections.synchronizedSortedMap(new TreeMap()) or using a ConcurrentSkipListMap", "label": {"api": {"Collections.synchronizedSortedMap(new TreeMap())": [[58, 105]], "ConcurrentSkipListMap": [[118, 138]]}}}, {"text": "ConcurrentSkipListMap seems easier to use, but what other factors should I be considering", "label": {"api": {"ConcurrentSkipListMap": [[0, 20]]}}}, {"text": "Using the SurfaceView in Android I had full control of the Canvas and could draw when I wanted", "label": {"api": {"Canvas": [[59, 64]]}}}, {"text": "Should I be using for instance the Canvas from AWT or JComponent from Swing, or something else", "label": {"api": {"Canvas": [[35, 40]], "JComponent": [[54, 63]]}}}, {"text": "Arrays#asList returns a generic type", "label": {"api": {"Arrays#asList": [[0, 12]]}}}, {"text": "Arrays#asList returns List<int[]> and not List<Integer> (What you wanted - Recall that there is no such a thing List<int>)", "label": {"api": {"Arrays#asList": [[0, 12]]}}}, {"text": "You can convert the String to float or double using Float#parseFloat() and Double#parseDouble() respectively, which is what you would need in most cases", "label": {"api": {"Float#parseFloat()": [[52, 69]], "Double#parseDouble()": [[75, 94]]}}}, {"text": "Using Float#valueOf(String) and Double#valueOf(String) creates instances of wrapper classes", "label": {"api": {"Float#valueOf(String)": [[6, 26]], "Double#valueOf(String)": [[32, 53]]}}}, {"text": "When I try to get a Media objects duration through the getDuration() method, it returns that it is unknown", "label": {"api": {"Media": [[20, 24]]}}}, {"text": "Please check the Java API for ArrayList", "label": {"api": {"the Java API for ArrayList": [[13, 38]]}}}, {"text": "If you need a higher degree of control over your ExecutorService, use ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[70, 87]]}}}, {"text": "In terms of the correct class, OutputStreamWriter looks like it's doing a conversion you don't need to happen", "label": {"api": {"doing a conversion you don't need to happen": [[66, 108]]}}}, {"text": "Do you need a FileOutputStream", "label": {"api": {"FileOutputStream": [[14, 29]]}}}, {"text": "You can use ResultSet#next() method to test whether there was any result set returned", "label": {"api": {"ResultSet#next()": [[12, 27]]}}}, {"text": "You should use PreparedStatement, to save yourself from SQL Injection", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "Encode the byte arrays into base 64 using either the Apache Commons Codec or Java 8's Base64 Encoder", "label": {"api": {"Java 8's Base64 Encoder": [[77, 99]]}}}, {"text": "The other method calls are using println(Object), which prints the result of the object's toString", "label": {"api": {"println(Object)": [[33, 47]]}}}, {"text": "Arrays don't override toString, and so you see the result of the default Object.toString implementation", "label": {"api": {"Object.toString": [[73, 87]], "Arrays": [[0, 5]]}}}, {"text": "As a workaround, the Arrays utility class provides toString helper methods to get String representations of arrays", "label": {"api": {"Arrays": [[21, 26]]}}}, {"text": "You can search for the last index of , using String#lastIndexOf and then use StringBuilder#replace", "label": {"api": {"String#lastIndexOf": [[45, 62]], "StringBuilder#replace": [[77, 97]]}}}, {"text": "When you want to read the Mapentries sorted by key, you could use a Treemap", "label": {"api": {"Treemap": [[68, 74]]}}}, {"text": "According to the JMenuItem documentation, the second parameter to the two argument constructor must be an int identifying a keyboard shortcut, or an Icon", "label": {"api": {"JMenuItem": [[17, 25]]}}}, {"text": "In any case, you want to set an ActionListener on the JMenuItem to respond to the click", "label": {"api": {"JMenuItem": [[54, 62]]}}}, {"text": "There has been recent discussion on the openjfx-dev mailing list regarding adding a method to Canvas to free resources - such a feature, if implemented, would not be available until a future JavaFX release", "label": {"api": {"Canvas": [[94, 99]]}}}, {"text": "RT-32242 Canvas should clear its buffered commands on certain clearRect, fillRect calls (currently scheduled for implementation for the Java 8 release)", "label": {"api": {"Canvas": [[9, 14]]}}}, {"text": "Until that is implemented, you may need to create a new Canvas node and replace the old one with the new one", "label": {"api": {"Canvas": [[56, 61]]}}}, {"text": "Although it's not as functional as a Canvas, perhaps using a WritableImage might be sufficient for your operations and may not suffer the same memory issues you are currently encountering with Canvas", "label": {"api": {"Canvas": [[37, 42], [193, 198]], "WritableImage": [[61, 73]]}}}, {"text": "This is because internally a WritableImage is just a buffer of pixel data with no historical record, whereas a Canvas internally keeps a historical record of drawing commands", "label": {"api": {"Canvas": [[111, 116]], "WritableImage": [[29, 41]]}}}, {"text": "You're getting an NPE because you're passing null into invoke", "label": {"api": {"invoke": [[55, 60]]}}}, {"text": "Use AffineTransformOp, shown here, or Image#getScaledInstance(), shown here", "label": {"api": {"AffineTransformOp": [[4, 20]], "Image#getScaledInstance()": [[38, 62]]}}}, {"text": "Session.update() is used to update a single mapped entity; with Query.executeupdate() you can perform custom delete/update statement (written is HQL or pure SQL) and get as result the updated/deleted entities count", "label": {"api": {"Query.executeupdate()": [[64, 84]]}}}, {"text": "So System.out.println will just call the toString method on object x - and in your case it is Integer.toString()", "label": {"api": {"Integer.toString()": [[94, 111]]}}}, {"text": "Changes to a Map's keySet() are reflected in the map itself", "label": {"api": {"keySet()": [[19, 26]]}}}, {"text": "If you want to remove exact mappings (not just based on keys), you can use the same approach with the entrySet() instead", "label": {"api": {"entrySet()": [[102, 111]]}}}, {"text": "I'd use a SwingWorker for the heavy task", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "Because the docs don't explicitly mention the default MathContext of a BigDecimal, I have to assume that it is MathContext.UNLIMITED", "label": {"api": {"MathContext.UNLIMITED": [[111, 131]]}}}, {"text": "One alternative is to pass a Class instance representing X and use that to create the return array (see Array.newInstance())", "label": {"api": {"Array.newInstance()": [[104, 122]]}}}, {"text": "You can look at the documentation for clone()", "label": {"api": {"clone()": [[38, 44]]}}}]