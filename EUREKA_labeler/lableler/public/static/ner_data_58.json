[{"text": "I would suggest using ByteArrayOutputStream for holding the data and length of data", "label": {"api": {"ByteArrayOutputStream": [[22, 42]]}}}, {"text": "Set the clipping region to the visible area with Graphics.setClip(), that will prevent most rendering operations from taking effect outside that region", "label": {"api": {"Graphics.setClip()": [[49, 66]]}}}, {"text": "Isn't JPA's entity manager an example of this", "label": {"api": {"entity manager": [[12, 25]]}}}, {"text": "I would also recommend using BufferedOutputStream instead of just a FileOutputStream", "label": {"api": {"BufferedOutputStream": [[29, 48]]}}}, {"text": "Then, use SwingWorker to get back onto the UI thread, and update your textbox", "label": {"api": {"SwingWorker": [[10, 20]]}}}, {"text": "See Array.newInstance() for details", "label": {"api": {"Array.newInstance()": [[4, 22]]}}}, {"text": "I believe that according to link, a distinct process is spawned by the operating system in response to this call", "label": {"api": {"link": [[28, 31]]}}}, {"text": "By using remove(), you can effectively stop the panel", "label": {"api": {"remove()": [[9, 16]]}}}, {"text": "To obtain a similar result you should look into Comparable<T> which is meant to provide the same functionality to objects", "label": {"api": {"Comparable<T>": [[48, 60]]}}}, {"text": "From the documentation for Class.getMethod", "label": {"api": {"Class.getMethod": [[27, 41]]}}}, {"text": "From the documentation for Method.invoke", "label": {"api": {"Method.invoke": [[27, 39]]}}}, {"text": "Here is the official documentation on the Filter interface, and here is the page about HttpServletRequestWrapper", "label": {"api": {"page": [[76, 79]]}}}, {"text": "Finally, here is an good SO page about what you want to do", "label": {"api": {"page": [[28, 31]]}}}, {"text": "It is always a good option to check the javadoc, see String#split(String regex)", "label": {"api": {"String#split(String regex)": [[53, 78]]}}}, {"text": "You need to set the @CascadeType on the relationship to something including PERSIST if you want new objects persisted when their container is", "label": {"api": {"@CascadeType": [[20, 31]]}}}, {"text": "According to the method documentation, you need to supply a CharSequence to String.contains, ie", "label": {"api": {"method documentation": [[17, 36]]}}}, {"text": "Otherwise just checkout the StringBuilder methods in the doc and do what you wish", "label": {"api": {"in the doc": [[50, 59]]}}}, {"text": "This is because the design of the java compiler know that when there is a class which extends RuntimeException at that time it will not force to handle it", "label": {"api": {"RuntimeException": [[94, 109]]}}}, {"text": "In the JDK 7 build b130 the abstract Path class becomes an interface and the method was moved in the Files class", "label": {"api": {"Files class": [[101, 111]]}}}, {"text": "Here is the JavaDoc", "label": {"api": {"Here is the JavaDoc": [[0, 18]]}}}, {"text": "You can implement this as a @Singleton ejb, which can then be accessed by other apps using standard ejb invocation methods", "label": {"api": {"@Singleton": [[28, 37]]}}}, {"text": "In your doIntercept() you can retrieve the method being called from the InvocationContext and get the parameter annotations", "label": {"api": {"parameter annotations": [[102, 122]]}}}, {"text": "You can then call InvocationContext#getParameters() to get a Object[] with the values of all the parameters passed", "label": {"api": {"InvocationContext#getParameters()": [[18, 50]]}}}, {"text": "Hello You can try to use the Robot class Robot doc", "label": {"api": {"Robot doc": [[41, 49]]}}}, {"text": "If there is any chance that one of the replacement strings could contain one of those characters, you'll need to deal with it (see Matcher.quoteReplacement)", "label": {"api": {"Matcher.quoteReplacement": [[131, 154]]}}}, {"text": "Then you can simply access the elements as int[][]s via get()", "label": {"api": {"get()": [[56, 60]]}}}, {"text": "The add method you call doesn't return the Set itself, it returns a boolean", "label": {"api": {"add": [[4, 6]]}}}, {"text": "You want to learn about wait/notify", "label": {"api": {"wait/notify": [[24, 34]]}}}, {"text": "Have the parent thread instantiate an AtomicInteger and pass it to the workers", "label": {"api": {"AtomicInteger": [[38, 50]]}}}, {"text": "If you want the parent thread to block until they're all done, you could also create a CountDownLatch initialized with the threshold, and then just have each worker call countDown() while the parent thread calls await()", "label": {"api": {"CountDownLatch": [[87, 100]]}}}, {"text": "Use a ServletContextListener and start and stop the thread in contextInitialized() and contextDestroyed() methods respectively", "label": {"api": {"ServletContextListener": [[6, 27]], "Servlet": [[6, 12]]}}}, {"text": "In a Servlet or Filter start and stop the thread in the init() and destroy() methods respectively", "label": {"api": {"Servlet": [[5, 11]], "Filter": [[16, 21]]}}}, {"text": "Use an ExecutorService", "label": {"api": {"ExecutorService": [[7, 21]]}}}, {"text": "You can use Pattern and Matcher classes here", "label": {"api": {"Pattern": [[12, 18]], "Matcher": [[24, 30]]}}}, {"text": "Create a Pattern object by compiling the regex using Pattern#compile(regex)", "label": {"api": {"Pattern": [[9, 15], [53, 59]], "Pattern#compile(regex)": [[53, 74]]}}}, {"text": "Then create a Matcher object by applying that Pattern object on your string using Pattern#matcher(CharSequence)", "label": {"api": {"Pattern": [[46, 52], [82, 88]], "Matcher": [[14, 20]], "Pattern#matcher(CharSequence)": [[82, 110]]}}}, {"text": "And then use Matcher#find() method to find the pattern you are interested in", "label": {"api": {"Matcher": [[13, 19]], "Matcher#find()": [[13, 26]]}}}, {"text": "You should use a Map with String key and value instead, and use the ip as key", "label": {"api": {"Map": [[17, 19]]}}}, {"text": "See the blurb at the end of the intro section for java.net.URL", "label": {"api": {"java.net.URL": [[50, 61]]}}}, {"text": "I would suggest that you combine your targetWords into one (compiled) regular expression", "label": {"api": {"regular expression": [[70, 87]]}}}, {"text": "Don't forget to double-quote the backspaces in your regular expression string", "label": {"api": {"regular expression": [[52, 69]]}}}, {"text": "If you are not satisfied with the speed of regular expressions - although regular expression engines are usually optimized for performance - you need to roll your own high-speed multi-string search", "label": {"api": {"regular expression": [[43, 60], [74, 91]]}}}, {"text": "The issue appears to happen specifically when calling getParameter on the org.apache.catalina.connector.RequestFacade instance that gets passed into javax.servlet.Filter.doFilter", "label": {"api": {"javax.servlet.Filter.doFilter": [[149, 177]]}}}, {"text": "The documentation of ServletRequest.getParameter says", "label": {"api": {"ServletRequest.getParameter": [[21, 47]]}}}, {"text": "String.matches() only returns true if the entire string matches the pattern", "label": {"api": {"String.matches()": [[0, 15]]}}}, {"text": "Check out the Pattern API for a boatload of info about Java regular expressions", "label": {"api": {"Pattern API": [[14, 24]]}}}, {"text": "If you need to do any special processing, store more than two fields, or have any other fringe case, you should make your own class, but otherwise, Map.Entry is one of the more underutilized Java classes and is perfect for situations like these", "label": {"api": {"Map.Entry": [[148, 156]]}}}, {"text": "File class has a exists() method which allows you to achieve what you are trying", "label": {"api": {"exists()": [[17, 24]]}}}, {"text": "Based on the String in your example, you could use a SimpleDateFormat to simple parse the String back to a Date object, which is probably the easiest solution I can think of..", "label": {"api": {"SimpleDateFormat": [[53, 68]]}}}, {"text": "Once you have a Date object, you can use Calendar to extract various parts of the Date object or simple use another DateFormat to format the value..", "label": {"api": {"Calendar": [[41, 48]]}}}, {"text": "Te method Class.getResource(String) loads the named resource based on the class loader of the class instance", "label": {"api": {"Class.getResource(String)": [[10, 34]]}}}, {"text": "And you added C:\\temp\\some-directory to the classpath, you could get the URL to some-file.txt using Class.getResource(String) like this", "label": {"api": {"Class.getResource(String)": [[100, 124]]}}}, {"text": "Java SE has a scalable Timer object that, using one single thread, allows large numbers of concurrently scheduled tasks (thousands should present no problem)", "label": {"api": {"Timer": [[23, 27]]}}}, {"text": "If you use globalTime in a multi-threading  consider using a static AtomicLong, that will handle synchronization", "label": {"api": {"AtomicLong": [[68, 77]]}}}, {"text": "Simply use Collections.shuffle", "label": {"api": {"Collections.shuffle": [[11, 29]]}}}, {"text": "There's a Logger that comes with the JDK", "label": {"api": {"Logger": [[10, 15]]}}}, {"text": "A better way would be use String#replaceAll(regex, replacement) method to replace all characters except digits (As you see, the method takes a regex for replacing)", "label": {"api": {"String#replaceAll(regex, replacement)": [[26, 62]]}}}, {"text": "Have a look at ClassLoader's getResource(String name) method", "label": {"api": {"ClassLoader's getResource(String name)": [[15, 52]]}}}, {"text": "Take a look at javax.servlet.Filter", "label": {"api": {"javax.servlet.Filter": [[15, 34]]}}}, {"text": "Do calls to invokeAll and invokeAny, with timeout length and unit specified in their call, on a ThreadPoolExecutor configured with core, max, timeout, time unit, and bounded queue override the timeout settings of the executor when executing the tasks", "label": {"api": {"invokeAll": [[12, 20]], "invokeAny": [[26, 34]], "ThreadPoolExecutor": [[96, 113]]}}}, {"text": "In the case of invokeAll, this would apply when using the get method on one of the returned futures (you can specify an additional timeout on the get)", "label": {"api": {"invokeAll": [[15, 23]], "get": [[58, 60], [146, 148]]}}}, {"text": "In the case of invokeAny, it applies to the call itself", "label": {"api": {"invokeAny": [[15, 23]]}}}, {"text": "...and in the class that contains this threadPool object, I expose the submit, invokeAll, and invokeAny, and for the latter two, I do not expose timeout settings, as I am choosing to use the same ones used to construct the threadPool", "label": {"api": {"invokeAll": [[79, 87]], "invokeAny": [[94, 102]]}}}, {"text": "However, based on the fact that you are using getInputStream, I would guess you are using an HTTPURLConnection, rather than cfhttp", "label": {"api": {"InputStream": [[49, 59]]}}}, {"text": "If the request succeeds, the response is written to the input stream", "label": {"api": {"input stream": [[56, 67]]}}}, {"text": "Otherwise, it is written to the error stream (that is probably where your error \"message\" is ending up)", "label": {"api": {"error stream": [[32, 43]]}}}, {"text": "From your comments, I assume you already know how to read an InputStream and return a string", "label": {"api": {"InputStream": [[61, 71]]}}}, {"text": "Why can't I instantiate a ThreadPoolExecutor(core, max, tu, unit, new BlockingQueue<Callable>()) - why does the queue necessarily take runnable only", "label": {"api": {"ThreadPoolExecutor": [[26, 43]]}}}, {"text": "Also, would shutDownNow() return a list of callables", "label": {"api": {"shutDownNow()": [[12, 24]]}}}, {"text": "It sounds like you want a Future<T>", "label": {"api": {"Future<T>": [[26, 34]]}}}, {"text": "You can submit a collection of Callable<T>s using invokeAll, and you'll get back a collection of Future<T>s that you can get values from once they're available", "label": {"api": {"Future<T>": [[97, 105]], "invokeAll": [[50, 58]]}}}, {"text": "The reason it's superior is because you're looping via an Iterator as opposed to calling get() multiple times, as you would have to do with your first variant", "label": {"api": {"Iterator": [[58, 65]]}}}, {"text": "You could create a ServletContextListener and run a query on startup for your application", "label": {"api": {"ServletContextListener": [[19, 40]]}}}, {"text": "You are using add to insert the object at index 1, but there isn't anything in the ArrayList yet, so you can't insert it there", "label": {"api": {"add": [[14, 16]]}}}, {"text": "I'm not sure why you need to insert at that point; usually add with just one argument will append to the end of the list and that should work just fine", "label": {"api": {"add": [[59, 61]], "add with just one argument": [[59, 84]]}}}, {"text": "Implement a WindowListener and in the windowClosing() call, save information about the GUI into a Properties system, then store them into a file", "label": {"api": {"Properties": [[98, 107]]}}}, {"text": "ServletContext using a ServletContextListener", "label": {"api": {"ServletContext": [[0, 13], [23, 36]], "ServletContextListener": [[23, 44]]}}}, {"text": "Use the overloaded Integer.parseInt method that takes a second parameter for the radix", "label": {"api": {"Integer.parseInt": [[19, 34]]}}}, {"text": "Read the documentation of Scanner", "label": {"api": {"Scanner": [[26, 32]]}}}, {"text": "A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "You could use the nextLine() method to get the whole line and not \"ignore\" with any whitespace", "label": {"api": {"nextLine()": [[18, 27]]}}}, {"text": "Better you could define what is a token by using the useDelimiter method", "label": {"api": {"useDelimiter": [[53, 64]]}}}, {"text": "Yes, use either of the drawImage() implementations that let you specify the corners of the destination rectangle", "label": {"api": {"drawImage()": [[23, 33]]}}}, {"text": "I'd recommend the XMLEventReader and XMLEventWriter", "label": {"api": {"XMLEventReader": [[18, 31]], "XMLEventWriter": [[37, 50]]}}}, {"text": "What you are looking for is a MouseListener", "label": {"api": {"MouseListener": [[30, 42]]}}}, {"text": "You may also be interested in a MouseMotionListener which give you information on mouse movement", "label": {"api": {"MouseMotionListener": [[32, 50]]}}}, {"text": "MouseAdapter is an abstract class which implements MouseListener", "label": {"api": {"MouseListener": [[51, 63]]}}}, {"text": "It keeps you from having to implement all the methods required by the MouseListener interface", "label": {"api": {"MouseListener": [[70, 82]]}}}, {"text": "After speaking with you in comments below what you're looking for is a KeyListener", "label": {"api": {"KeyListener": [[71, 81]]}}}, {"text": "String#split() method takes a regex", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "You should use the modPow method instead, which does the two operations with an efficient algorithm", "label": {"api": {"modPow": [[19, 24]]}}}, {"text": "To have exact numbers use BigDecimal - http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html": [[39, 104]]}}}, {"text": "From Statement#close() javadoc", "label": {"api": {"Statement#close()": [[5, 21]]}}}, {"text": "java.lang.Class has no method theResponse, as you can see from its Javadoc", "label": {"api": {"its Javadoc": [[63, 73]]}}}, {"text": "Then, when you load your Class<?>, you can use the asSubclass() method to turn your Class<?> into a Class<", "label": {"api": {"asSubclass()": [[51, 62]]}}}, {"text": "But don't do that by hand -- instead, use the java.util.ServiceLoader class, which is designed for exactly this purpose", "label": {"api": {"java.util.ServiceLoader": [[46, 68]]}}}, {"text": "HashMap does not manatain the order of insertion of keys", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "LinkedHashMap should be used as it provides predictable iteration order which is normally the order in which keys were inserted into the map (insertion-order)", "label": {"api": {"HashMap": [[6, 12]], "LinkedHashMap": [[0, 12]]}}}, {"text": "You can use the MapEntry method to iterate over your the LinkedHashMap", "label": {"api": {"HashMap": [[63, 69]], "LinkedHashMap": [[57, 69]]}}}, {"text": "First change your banks map from HashMap to the LinkedHashMap", "label": {"api": {"HashMap": [[33, 39], [54, 60]], "LinkedHashMap": [[48, 60]]}}}, {"text": "If you just need the first element of the LinkedHashMap then you can do this", "label": {"api": {"HashMap": [[48, 54]], "LinkedHashMap": [[42, 54]]}}}, {"text": "LinkedHashMap provides a hash table/doubly linked list implementation of the Map interface", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "Use the Robot class", "label": {"api": {"Robot": [[8, 12]]}}}, {"text": "If you are asking about the BufferedReader class in general, you should start with the class reference doc, Oracle's Tutorial, and a little googling", "label": {"api": {"class reference doc": [[87, 105]]}}}, {"text": "So read the lines with BufferedReader#readLine and then just use String#substring to get the individual parts of them, and possibly String#trim to trim off whitespace", "label": {"api": {"BufferedReader#readLine": [[23, 45]], "String#substring": [[65, 80]], "String#trim": [[132, 142]]}}}, {"text": "It sounds like you're looking for a combination of BufferedReader#readLine and String#split", "label": {"api": {"BufferedReader#readLine": [[51, 73]], "String#split": [[79, 90]]}}}, {"text": "Check for MouseListener.mouseExited(MouseEvent)", "label": {"api": {"MouseListener.mouseExited(MouseEvent)": [[10, 46]]}}}, {"text": "And to your advantage, Properties file also holds the data in key value pair and it makes more sense for your requirement", "label": {"api": {"Properties": [[23, 32]]}}}, {"text": "Also using the java Properties class to read values from the file is very convenient", "label": {"api": {"Properties": [[20, 29]]}}}, {"text": "Use a SimpleDateFormat instance to format the time in your current TimeZone", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "See the Javadoc for Query for the different ways you can specify the parameters", "label": {"api": {"the Javadoc for Query": [[4, 24]]}}}, {"text": "You can allocate a direct memory buffer in Java with the ByteBuffer.allocateDirect method, or in C or C++ with the NewDirectByteBuffer JNI function", "label": {"api": {"ByteBuffer.allocateDirect": [[57, 81]]}}}, {"text": "The SynthConstants API says, \"Constants used by Synth", "label": {"api": {"SynthConstants": [[4, 17]]}}}, {"text": "What states in SynthConstants are respectively supported by each different Component", "label": {"api": {"SynthConstants": [[15, 28]]}}}, {"text": "Consider using Lists (for example ArrayList) instead", "label": {"api": {"Lists": [[15, 19]], "ArrayList": [[34, 42]]}}}, {"text": "See the java.awt.Container class for reference", "label": {"api": {"java.awt.Container": [[8, 25]]}}}, {"text": "Take a look at this reference to the compareTo()", "label": {"api": {"this reference to the compareTo()": [[15, 47]]}}}, {"text": "How do I determine the natural ordering", "label": {"api": {"natural ordering": [[23, 38]]}}}, {"text": "A TreeSet cares about the natural ordering of its elements", "label": {"api": {"natural ordering": [[26, 41]]}}}, {"text": "Use Scanner#hasNextLine() with Scanner#nextLine(), not Scanner#hasNext() with Scanner#next()", "label": {"api": {"Scanner#hasNextLine()": [[4, 24]], "Scanner#nextLine()": [[31, 48]], "Scanner#hasNext()": [[55, 71]], "Scanner#next()": [[78, 91]]}}}, {"text": "The problem seems to be that the Proxy Vole library uses the ProxySelector class, which always causes the SocketException", "label": {"api": {"ProxySelector": [[61, 73]]}}}, {"text": "It doesn't matter if I use ntp or http, as long as the ProxySelector by Vole is set, this problem occurs", "label": {"api": {"ProxySelector": [[55, 67]]}}}, {"text": "[ Link] It has methods necessary to determine visibility of a class member", "label": {"api": {"Link]": [[2, 6]]}}}, {"text": "Create a CheckedOutputStream", "label": {"api": {"CheckedOutputStream": [[9, 27]]}}}, {"text": "Once you've finished writing the file, retrieve the checksum from the CheckedOutputStream, and write it to the file", "label": {"api": {"CheckedOutputStream": [[70, 88]]}}}, {"text": "Use a CheckedInputStream when reading data back", "label": {"api": {"CheckedInputStream": [[6, 23]]}}}, {"text": "If you wissh to access records in an ordered way you will need to use a comparator or implement comparable in your Record class", "label": {"api": {"comparator": [[72, 81]], "comparable": [[96, 105]]}}}, {"text": "Long.getLong fetches a system property with the given name, and parses that to a Long", "label": {"api": {"Long.getLong": [[0, 11]]}}}, {"text": "You probably want Long.parseLong or Long.valueOf", "label": {"api": {"Long.parseLong": [[18, 31]], "Long.valueOf": [[36, 47]]}}}, {"text": "I suspect something else is going wrong before it tries to parse the value - but when you have got past that, you'll need to change from Long.getLong to Long.parseLong anyway", "label": {"api": {"Long.getLong": [[137, 148]], "Long.parseLong": [[153, 166]]}}}, {"text": "You may use Integer wrapper class instead of int as Integer class is immutable", "label": {"api": {"Integer": [[12, 18], [52, 58]]}}}, {"text": "I suggest that you do not attempt to construct the concurrency control logic by hand, but instead use a SynchronousQueue", "label": {"api": {"SynchronousQueue": [[104, 119]]}}}, {"text": "If you really must invoke psql, say if you're sourcing an SQL file that uses \\ commands, build a command with ProcessBuilder and invoke psql non-interactively in batch mode", "label": {"api": {"build a command with ProcessBuilder": [[89, 123]]}}}, {"text": "Call Color.RGBtoHSB() using the RGB components of the Color obtained from the chooser, as shown here", "label": {"api": {"Color.RGBtoHSB()": [[5, 20]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection) for further details", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection)": [[4, 125]]}}}, {"text": "As a LAST resort, you may be able to fix the problem by using JComboBox's hidePopup() method to manually close out of the JComboBox", "label": {"api": {"JComboBox's hidePopup() method": [[62, 91]]}}}, {"text": "This is determined by the @Retention policy of the annotation", "label": {"api": {"@Retention": [[26, 35]]}}}, {"text": "Look through the methods on the Processor interface for how the compiler invokes an annotation processor; the main operation takes place in the process method, which gets called every time the compiler sees an element that has a matching annotation", "label": {"api": {"the Processor interface": [[28, 50]]}}}, {"text": "As Cemafor said, if you're concerned about performance, then maybe you should use String.replaceAll() for making all replacements at once", "label": {"api": {"String.replaceAll()": [[82, 100]]}}}, {"text": "java.util.Date.getTime() returns the number of milliseconds since the start of 1970 (epoch time)", "label": {"api": {"java.util.Date.getTime()": [[0, 23]]}}}, {"text": "SQLite can deal with Unix epoch time, which is the same value, but expressed in seconds (see java.util.Date.getTime())", "label": {"api": {"java.util.Date.getTime()": [[93, 116]]}}}, {"text": "This is probably the last thing you'd want to do (not the first), but you could set the values of a text field using Java's Robot class", "label": {"api": {"Robot": [[124, 128]]}}}, {"text": "If you want it to be case-insensitive, first prepare it with Pattern.compile() using the CASE_INSENSITIVE flag", "label": {"api": {"Pattern.compile()": [[61, 77]]}}}, {"text": "The easiest way to do this is to just use a ByteArrayInputStream, which already provides all the features you are looking for (but must wrap an existing array), or to use any of the other already provided InputStream for reading data from various sources", "label": {"api": {"ByteArrayInputStream": [[44, 63]]}}}, {"text": "You could for instance use SequenceInputStream for this", "label": {"api": {"SequenceInputStream": [[27, 45]]}}}, {"text": "You can retrieve detailed information about the invalid value from the ConstraintViolation object", "label": {"api": {"ConstraintViolation": [[71, 89]]}}}, {"text": "Assuming you're using a FileWriter, you can provide true as the second parameter to the FileWriter(java.io.File, boolean) or FileWriter(java.lang.String, boolean)constructor, to indicate that you wish to append to the file, rather than overwriting", "label": {"api": {"FileWriter(java.io.File, boolean)": [[88, 120]], "FileWriter(java.lang.String, boolean)": [[125, 161]]}}}, {"text": "Override the dispose method", "label": {"api": {"dispose": [[13, 19]]}}}, {"text": "If you really want a byte array backed by memory, the DirectByteBuffer may be of use", "label": {"api": {"DirectByteBuffer": [[54, 69]]}}}, {"text": "By default, Java 8 Function does not allow to throw exception and as suggested in multiple answers there are many ways to achieve it, one way is", "label": {"api": {"Function": [[19, 26]]}}}, {"text": "It can be used as a Consumer function used in a Java collection", "label": {"api": {"Consumer": [[20, 27]]}}}, {"text": "SLaks' answer points out that object.getClass() decays to Class<", "label": {"api": {"getClass": [[37, 44]]}}}, {"text": "getClass \"returns the runtime class\" of the object it's called on", "label": {"api": {"getClass": [[0, 7]]}}}, {"text": "That tells us that casting object.getClass() to Class<T> isn't safe because Class<Integer> and Class<Number> are different objects, representing different classes - a distinction that seems very relevant to the correctness of what you're trying to do", "label": {"api": {"getClass": [[34, 41]]}}}, {"text": "The getInterfaces() method of TypeElement only returns the interfaces directly implemented by the element", "label": {"api": {"getInterfaces()": [[4, 18]]}}}, {"text": "I believe you can iterate over the returned types and use Types#isAssignable(TypeMirror t1, TypeMirror t2) to check if any of them are assignable to the interface you are looking for (in this context, a is assignable to b if a is b or b is a superinterface of a -- but for a full definition see JLS section 5.2)", "label": {"api": {"Types#isAssignable(TypeMirror t1, TypeMirror t2)": [[58, 105]]}}}, {"text": "Where processingEnv is a ProcessingEnvironment (see ThePyroEagle's comment below)", "label": {"api": {"ProcessingEnvironment": [[25, 45]]}}}, {"text": "Finally you can use String.replaceFirst to replace the string with the number you've generated", "label": {"api": {"String.replaceFirst": [[20, 38]]}}}, {"text": "If you want to zip files without usins external libraries, then classes in the package java.util.zip can do it", "label": {"api": {"java.util.zip": [[87, 99]]}}}, {"text": "If all fields are of the same type and are accessed by their field name (most of the time) you could avoid the hassle and brittleness of using reflection by utilizing a Map", "label": {"api": {"Map": [[169, 171]]}}}, {"text": "You can use Callable", "label": {"api": {"Callable": [[12, 19]]}}}, {"text": "LinkedList extends AbstractSequentialList which extends AbstractList which does override equals and hashCode - so the implementation is not inherited from Object", "label": {"api": {"LinkedList": [[0, 9]], "AbstractSequentialList": [[19, 40]], "AbstractList": [[56, 67]]}}}, {"text": "ArrayDeque, on the other hand, really doesn't inherit anything other implementation as far as I can see", "label": {"api": {"ArrayDeque": [[0, 9]]}}}, {"text": "Its direct superclass (AbstractCollection) doesn't override them", "label": {"api": {"AbstractCollection": [[23, 40]]}}}, {"text": "I don't know of the justification for ArrayDeque choosing not to implement equality, but if you want to compare two deques you could easily just convert them into lists or arrays and do it that way", "label": {"api": {"ArrayDeque": [[38, 47]]}}}, {"text": "If it is OutputStreamWriter then set encoding to \"UTF-8\" see http://docs.oracle.com/javase/7/docs/api/java/io/OutputStreamWriter.html#OutputStreamWriter(java.io.OutputStream", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/OutputStreamWriter.html#OutputStreamWriter(java.io.OutputStream": [[61, 172]]}}}, {"text": "replaceAll expects regular expressions", "label": {"api": {"replace": [[0, 6]]}}}, {"text": "Instead of trying to get the RegEx right, use replace", "label": {"api": {"replace": [[46, 52]]}}}, {"text": "The java.sql.Statement interface provides a cancel method which allows to abort a database call from another thread", "label": {"api": {"cancel": [[44, 49]]}}}, {"text": "Is there any way to achieve the cancel / abort functionality if I use Spring's StoredProcedure", "label": {"api": {"cancel": [[32, 37]]}}}, {"text": "I have searched HashMap as well as Guava's Maps without success so far", "label": {"api": {"HashMap": [[16, 22]]}}}, {"text": "Java already has Properties and Preferences, which can be used to accomplish this", "label": {"api": {"Properties": [[17, 26]], "Preferences": [[32, 42]]}}}, {"text": "You should remove an element from a List using an Iterator", "label": {"api": {"Iterator": [[50, 57]]}}}, {"text": "This should give you some hints, why you should use an Iterator", "label": {"api": {"Iterator": [[55, 62]]}}}, {"text": "You create a ordered list with @OrderBy", "label": {"api": {"@OrderBy": [[31, 38]]}}}, {"text": "Set content type to text/html and JEditorPane will start rendering the assigned text as HTML", "label": {"api": {"JEditorPane": [[34, 44]]}}}, {"text": "System.nanoTime() is the best way to get definite precision", "label": {"api": {"System.nanoTime()": [[0, 16]]}}}, {"text": "As far as optimizing the I/O goes, I would recommend using the newBufferedReader(Path path,Charset c) method of the java.nio.file.Files class", "label": {"api": {"newBufferedReader(Path path,Charset c)": [[63, 100]]}}}, {"text": "Take the date as a String from the Json then parsed it using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[61, 76]]}}}, {"text": "Use the new try-with-resources statement which would automatically close the ResultSet whether an exception occurs or not because it implements AutoCloseable", "label": {"api": {"AutoCloseable": [[144, 156]]}}}, {"text": "To concatenate the chars, you can use the empty String (\"\") at the beginning so the + operator will be for String concatenation or use a StringBuilder that can append chars as well", "label": {"api": {"StringBuilder": [[137, 149]]}}}, {"text": "Use BigInteger#longValue() method, instead of casting it to Long", "label": {"api": {"BigInteger#longValue()": [[4, 25]]}}}, {"text": "The issue you are having is that the Scanner uses delimiters to retrieve text, and your code is balking when it can't find a complete token", "label": {"api": {"Scanner": [[37, 43]]}}}, {"text": "RescaleOp offers two modes of operation on rasters having a direct color model", "label": {"api": {"RescaleOp": [[0, 8]]}}}, {"text": "RescaleOp(float scaleFactor, float offset, RenderingHints hints), illustrated here, scales all color components by the same factor and leaves the alpha channel unchanged", "label": {"api": {"RescaleOp": [[0, 8]]}}}, {"text": "RescaleOp(float[] scaleFactors, float[] offsets, RenderingHints hints), illustrated in the second example cited, requires that \"the number of sets of scaling constants must equal the number of source color components plus alpha component.\" A BufferedImage of type TYPE_INT_ARGB has three color components plus one alpha component, so the scaleFactors array must have four components", "label": {"api": {"RescaleOp": [[0, 8]]}}}, {"text": "Take a look at BigInteger for one workaround", "label": {"api": {"BigInteger": [[15, 24]]}}}, {"text": "I'm not 100% certain for menus, but I know for JTextComponents that all of the keystrokes (copy, paste, enter, move forward by words/sentences/lines, deleting, etc.) are implemented via the InputMap and ActionMap", "label": {"api": {"InputMap": [[190, 197]], "ActionMap": [[203, 211]]}}}, {"text": "JTextcomponents also use Keymaps, but I'm pretty sure those are specific to text components", "label": {"api": {"Keymap": [[25, 30]]}}}, {"text": "The pintln() is overloaded by lots of datatypes", "label": {"api": {"overloaded": [[16, 25]]}}}, {"text": "From the documentation of Files.notExists", "label": {"api": {"Files.notExists": [[26, 40]]}}}, {"text": "Java 7 provides us with the Files.notExists() method to deal with this kind of situation", "label": {"api": {"Files.notExists": [[28, 42]]}}}, {"text": "Use Field.setAccessible(true) to allow access to private fields", "label": {"api": {"Field.setAccessible(true)": [[4, 28]]}}}, {"text": "You can use setAccessible(boolean) on Field, Method, and Constructor to get access to a non-public member that the caller wouldn't normally have access to", "label": {"api": {"setAccessible(boolean)": [[12, 33]], "Field": [[38, 42]], "Method": [[45, 50]], "Constructor": [[57, 67]]}}}, {"text": "If the class follows JavaBean conventions, then you can use Introspector and BeanInfo to get PropertyDescriptor instances, which gives you access to the public read and write methods (getters and setters) of the bean", "label": {"api": {"Introspector": [[60, 71]], "BeanInfo": [[77, 84]], "PropertyDescriptor": [[93, 110]]}}}, {"text": "You can then use PropertyDescriptor.readMethod and PropertyDescriptor.writeMethod to get the Method objects that are the getter and setter respectively, then use Method.invoke on them to get and set the property value for a given object using the usual reflection APIs", "label": {"api": {"Method": [[40, 45], [75, 80], [93, 98], [162, 167]], "PropertyDescriptor": [[17, 34], [51, 68]], "PropertyDescriptor.readMethod": [[17, 45]], "PropertyDescriptor.writeMethod": [[51, 80]], "Method.invoke": [[162, 174]]}}}, {"text": "PropertyDescriptor also has some other information on it, like the property type and the property name", "label": {"api": {"PropertyDescriptor": [[0, 17]]}}}, {"text": "It also lets others override the BeanInfo that's returned by Introspector to be a custom implementation", "label": {"api": {"Introspector": [[61, 72]], "BeanInfo": [[33, 40]]}}}, {"text": "A class from Java SE", "label": {"api": {"A class from Java SE": [[0, 19]]}}}, {"text": "The java Thread class already has such a facility, called interrupts, that is useful in many scenarios, as bennihepp points out in his answer", "label": {"api": {"Thread class": [[9, 20]]}}}, {"text": "See the javadoc for the Thread class and the interrupt() and isInterrupted() methods in particular", "label": {"api": {"Thread class": [[24, 35]], "interrupt()": [[45, 55]], "isInterrupted()": [[61, 75]]}}}, {"text": "Each node has method getParentNode(), you could get node's parent node", "label": {"api": {"getParentNode()": [[21, 35]]}}}, {"text": "You can use method boolean removeAll(Collection c) of List", "label": {"api": {"boolean removeAll(Collection c)": [[19, 49]]}}}, {"text": "Instead, use preparedStatement", "label": {"api": {"preparedStatement": [[13, 29]]}}}, {"text": "You can fetch fields (but not local variables) by name using reflection (Class.getDeclaredField) but that's very rarely a useful approach", "label": {"api": {"Class.getDeclaredField": [[73, 94]]}}}, {"text": "When you are creating the EntityManagerFactory the string argument should be the name of the persistence unit", "label": {"api": {"EntityManagerFactory": [[26, 45]]}}}, {"text": "Whether this is a good pattern is debated, a good example of this in practice is Cloneable, and Serializable", "label": {"api": {"Cloneable": [[81, 89]], "Serializable": [[96, 107]]}}}, {"text": "Cloneable lets you know the class implementing it can be cloned via Object.clone, while Serializable lets you know the implementing class allows serialization", "label": {"api": {"Cloneable": [[0, 8]], "Serializable": [[88, 99]]}}}, {"text": "To change this behavior, just use ThreadPoolExecutor.allowCoreThreadTimeout(true)", "label": {"api": {"ThreadPoolExecutor.allowCoreThreadTimeout(true)": [[34, 80]]}}}, {"text": "Instead think byte position, since you can seek to that without reading the bytes between, by using a RandomAccessFile or a SeekableByteChannel", "label": {"api": {"RandomAccessFile": [[102, 117]], "SeekableByteChannel": [[124, 142]]}}}, {"text": "HashSet#remove returns a boolean if anything was removed; if you print that you will see your removal of k2 did not occur", "label": {"api": {"HashSet#remove": [[0, 13]]}}}, {"text": "Base64.Decoder and Base64.Encoder", "label": {"api": {"Base64.Decoder": [[0, 13]], "Base64.Encoder": [[19, 32]], "Base64": [[0, 5], [19, 24]]}}}, {"text": "There are also some static factory methods to construct instances of these classes which perform Base64 encoding/decoding for various flavors of Base64 in Base64 class", "label": {"api": {"Base64": [[97, 102], [145, 150], [155, 160]]}}}, {"text": "Check CyclicBarrier and CountDownLatch which can help you make the threads to wait each other, they might be helpful", "label": {"api": {"CyclicBarrier": [[6, 18]], "CountDownLatch": [[24, 37]]}}}, {"text": "I'm using mainly this document http://docs.oracle.com/javase/7/docs/api/java/security/KeyStore.html as a reference, along with some other sources", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/security/KeyStore.html": [[31, 98]]}}}, {"text": "You can address the top two bullets by using a ThreadLocal for each", "label": {"api": {"ThreadLocal": [[47, 57]]}}}, {"text": "You can visit the Javadoc of Vector#elementAt(int), that states it clearly", "label": {"api": {"Javadoc of Vector#elementAt(int)": [[18, 49]]}}}, {"text": "You should give the Class objects to the getConstructor method, like this", "label": {"api": {"Class": [[20, 24]]}}}, {"text": "For more information, refers to the documentation of the getConstructor method", "label": {"api": {"documentation of the getConstructor method": [[36, 77]]}}}, {"text": "java.util.concurrent.ArrayBlockingQueue<E>  can work for you", "label": {"api": {"java.util.concurrent.ArrayBlockingQueue<E>": [[0, 41]]}}}, {"text": "You can also use ConcurrentLinkedQueue", "label": {"api": {"ConcurrentLinkedQueue": [[17, 37]]}}}, {"text": "If you insist on using keyTyped for some reason, you won't have a key code available, but you can cover most cases by checking the character for a newline or carriage return", "label": {"api": {"you won't have a key code available": [[49, 83]]}}}, {"text": "See the SimpleDateFormat documentation for more details", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "Reading from array array is Thread-Safe Operation but if you are Modifying array than consider using class AtomicIntegerArray", "label": {"api": {"AtomicIntegerArray": [[107, 124]]}}}, {"text": "Consider populating a ConcurrendLinkedQueue and have each thread pull from it", "label": {"api": {"ConcurrendLinkedQueue": [[22, 42]]}}}, {"text": "For this can use an InputStreamReader, which can read encoded character data from a raw byte stream", "label": {"api": {"InputStreamReader": [[20, 36]]}}}, {"text": "I don't know if InputStreamReader counts", "label": {"api": {"InputStreamReader": [[16, 32]]}}}, {"text": "You'll need to convert it to a java.sql.Date by using the constructor that takes a long that a java.util.Date can supply", "label": {"api": {"constructor that takes a long": [[58, 86]]}}}, {"text": "You can use matches()", "label": {"api": {"matches()": [[12, 20]]}}}, {"text": "You can then use p.matcher(str).matches()", "label": {"api": {"matches()": [[32, 40]]}}}, {"text": "See the Pattern class for more details", "label": {"api": {"Pattern": [[8, 14]]}}}, {"text": "When comparing strings in Java, you should generally use the equals() methods to do so", "label": {"api": {"equals()": [[61, 68]]}}}, {"text": "From the File.delete docs", "label": {"api": {"File.delete docs": [[9, 24]]}}}, {"text": "Give this method (Files.delete(Path)) a shot", "label": {"api": {"this method (Files.delete(Path))": [[5, 36]]}}}, {"text": "use createTempFile() to create a temporary file in the first place", "label": {"api": {"createTempFile()": [[4, 19]]}}}, {"text": "You can use createNativeQuery to execute any arbitrary SQL on your database", "label": {"api": {"createNativeQuery": [[12, 28]]}}}, {"text": "While it is true that you can use the createNativeQuery method to execute native queries through an EntityManager; there is an alternative (arguably better) way of doing it if you are using the Spring Framework", "label": {"api": {"createNativeQuery": [[38, 54]]}}}, {"text": "You can also just call toCharArray() on the String to get a char[] with the contents copied into it already", "label": {"api": {"toCharArray()": [[23, 35]]}}}, {"text": "If your Graphics is actually a Graphics2D, you can set the KEY_INTERPOLATION rendering hint to use interpolation when scaling (it may not obey that hint)", "label": {"api": {"KEY_INTERPOLATION": [[59, 75]]}}}, {"text": "NullPointerException is, in fact, a subclass of RuntimeException", "label": {"api": {"NullPointerException": [[0, 19]]}}}, {"text": "You can download a file from a URL using URLConnection", "label": {"api": {"URLConnection": [[41, 53]]}}}, {"text": "You can have your dialog box display the choices then choose a URL depending on what button they pressed, and use the URLConnection (via .connect() and .getInputStream()) to read the data, which you can then write out to a file or do whatever you want with", "label": {"api": {"URLConnection": [[118, 130]]}}}, {"text": "Because 1.2 as double is not what you expect it to be", "label": {"api": {"is not what you expect it to be": [[22, 52]]}}}, {"text": "Use a static getter returning the Application instance from your Application subclass (as you have currently implemented it)", "label": {"api": {"Application": [[34, 44], [65, 75]]}}}, {"text": "Use the getCharacterStream method instead", "label": {"api": {"getCharacterStream": [[8, 25]]}}}, {"text": "Look at the Java KeyStore class, and how to get an instance of it with the PKCS12 keystore type", "label": {"api": {"KeyStore": [[17, 24]]}}}, {"text": "Then look at the setKeyEntry() and store()", "label": {"api": {"setKeyEntry()": [[17, 29]], "store()": [[35, 41]]}}}, {"text": "Or, if creating GUI writing code, use the setHorizontalAlignment method", "label": {"api": {"setHorizontalAlignment method": [[42, 70]]}}}, {"text": "NumberFormat supports Locales and produces formatting as per your question plus avoids using regular expressions", "label": {"api": {"NumberFormat": [[0, 11]]}}}, {"text": "Using a ServletContextListener, or a servlet that is initialized at startup, for example", "label": {"api": {"ServletContextListener": [[8, 29]]}}}, {"text": "the code that processes Booleans can put a call to Boolean.getBoolean() on top of it", "label": {"api": {"Boolean.getBoolean()": [[51, 70]]}}}, {"text": "It looks like you can get at the underlying ThreadPoolExecutor by calling getThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[44, 61], [77, 94]]}}}, {"text": "You should not use Date#getYear", "label": {"api": {"Date#getYear": [[19, 30]]}}}, {"text": "Classes themselves are not objects in the sense that there is no runtime object that is directly used in the execution of a class", "label": {"api": {"Class": [[0, 4]]}}}, {"text": "However, every class has a Class object associated with it that allows for interaction with that class, its instances, and members via reflection", "label": {"api": {"Class": [[27, 31]]}}}, {"text": "This class is actually generic in that FooClass.class is actually java.lang.Class<FooClass>, which helps out with generics as passing a Class object in can resolve generic return types and constraints at runtime", "label": {"api": {"Class": [[42, 46], [76, 80], [85, 89], [136, 140]]}}}, {"text": "I'm printing text in a dot matrix printer and i'm using swing's (JTextArea) and its print method", "label": {"api": {"JTextArea": [[65, 73]]}}}, {"text": "It takes a string (s), creates a JTextArea (ta) with the string then uses the print method on it", "label": {"api": {"JTextArea": [[33, 41]]}}}, {"text": "This is not achieved through someString.getBytes() but rather via DatatypeConverter.parseHexBinary(someString) (or any other method you prefer from Google)", "label": {"api": {"DatatypeConverter.parseHexBinary(someString)": [[66, 109]]}}}, {"text": "This could be accomplished using a ExecutorService to manage thread2's lifecycle and submitting a Callable to the ExecutorService", "label": {"api": {"submitting a Callable": [[85, 105]]}}}, {"text": "Many of the operations in the Collection interface are considered optional", "label": {"api": {"Collection": [[30, 39]]}}}, {"text": "You could write your own implementation on that and throw the UnsupportedOperationException for any action your implementation does not support", "label": {"api": {"UnsupportedOperationException": [[62, 90]]}}}, {"text": "This would be a way to get around having to extend ImmutableCollection", "label": {"api": {"Collection": [[60, 69]]}}}, {"text": "Subclassing ImmutableCollection is probably not an option, as its documentation states the following", "label": {"api": {"Collection": [[21, 30]]}}}, {"text": "Read-only view of the collection is already provided by Java with the Collections.unmodifiableCollection() method", "label": {"api": {"Collections.unmodifiableCollection()": [[70, 105]]}}}, {"text": "I suggest putting your Persons in a PriorityQueue", "label": {"api": {"PriorityQueue": [[36, 48]]}}}, {"text": "It tells the RepaintManager to render when its ready", "label": {"api": {"RepaintManager": [[13, 26]]}}}, {"text": "Use invalidate paintImmediately instead", "label": {"api": {"paintImmediately": [[15, 30]]}}}, {"text": "paintImmediately will block execution until the component has been redrawn so you can measure rendering time", "label": {"api": {"paintImmediately": [[0, 15]]}}}, {"text": "Also, look into the java.util.Random class for generating a random number", "label": {"api": {"java.util.Random": [[20, 35]]}}}, {"text": "If you need time-constant comparison, use MessageDigest.isEqual", "label": {"api": {"MessageDigest.isEqual": [[42, 62]]}}}, {"text": "If you don't need time-constant comparison, use Arrays.equals", "label": {"api": {"Arrays.equals": [[48, 60]]}}}, {"text": "To print out the contents of the byte arrays, use Arrays.toString", "label": {"api": {"Arrays.toString": [[50, 64]]}}}, {"text": "You might want to checkout JOptionPane.showOptionDialog, that will let you push in a text parameter (in array form)", "label": {"api": {"JOptionPane.showOptionDialog": [[27, 54]]}}}, {"text": "Given that you want to create the JAR through code; you can use JarOutputStream for that", "label": {"api": {"JarOutputStream": [[64, 78]]}}}, {"text": "If you are using Java 7 and you know your users are too you can also use Files.walkFileTree() with a FileVisitor that adds entries to the JAR as it visits files", "label": {"api": {"Files.walkFileTree()": [[73, 92]]}}}, {"text": "A String is an object, of type java.lang.String, which has a whole lot of useful methods for manipulating Strings", "label": {"api": {"java.lang.String": [[31, 46]]}}}, {"text": "Assuming that your per-user class isn't constructed until the TCP connection actually comes in, just use Socket#isClosed()", "label": {"api": {"Socket#isClosed()": [[105, 121]]}}}, {"text": "In the new version you can use the Iterable.forEach method to walk over a collection without using an explicit loop", "label": {"api": {"Iterable.forEach": [[35, 50]]}}}, {"text": "This is the perfect place to use java.util.Set, a construct which is designed to hold unique elements", "label": {"api": {"java.util.Set": [[33, 45]]}}}, {"text": "If you want to implement a linked list on your own, but want to save yourself the effort of implementing the full List interface, then use AbstractList as your base class", "label": {"api": {"AbstractList": [[139, 150]]}}}, {"text": "Suppose I'm using a Deflater to compress a stream of bytes, and at some intervals I have the option of feeding it with two different byte arrays (two alternative representations of the same info), so that I can choose the most compressible one", "label": {"api": {"Deflater": [[20, 27]]}}}, {"text": "nor even reimplementing the Deflater (not at least if one wants to take advantage of the internal native implementation)", "label": {"api": {"Deflater": [[28, 35]]}}}, {"text": "Since Double implements Comparable<Double>, your method can delegate to Double.compareTo", "label": {"api": {"Double.compareTo": [[72, 87]]}}}, {"text": "Alternatively, you could use the static utility method Double.compare(double, double)", "label": {"api": {"Double.compare(double, double)": [[55, 84]]}}}, {"text": "You could use a Scanner to read each line of the Java file, and then use a BufferedWriter to write (overwrite) the Java file with the necessary changes", "label": {"api": {"Scanner": [[16, 22]], "BufferedWriter": [[75, 88]]}}}, {"text": "You can use a Selector to achieve your goal", "label": {"api": {"Selector": [[14, 21]]}}}, {"text": "What you are looking for here is a format string", "label": {"api": {"format string": [[35, 47]]}}}, {"text": "A format string is used when you know what your output should look like, and only have a few \"holes\" where unknown data should be filled in", "label": {"api": {"format string": [[2, 14]]}}}, {"text": "To output your data using format strings, you would use the System.out.format(String, Object...) method", "label": {"api": {"format string": [[26, 38]], "System.out.format(String, Object...)": [[60, 95]]}}}, {"text": "However, you may wish to consider declaring them as int (or long) instead, in which case you would use %d instead of %f in the format strings", "label": {"api": {"format string": [[127, 139]]}}}, {"text": "We'll also use String.format() to handle the numerical values", "label": {"api": {"String.format()": [[15, 29]]}}}, {"text": "There's no problem with wrapping the FileInputStream in a BufferedInputStream", "label": {"api": {"BufferedInputStream": [[58, 76]]}}}, {"text": "Instead, you should wrap the FileInputStream in a BufferedInputStream with a buffer size of several hundred kilobytes", "label": {"api": {"BufferedInputStream": [[50, 68]]}}}, {"text": "That way, DataInputStream.readByte() will call BufferedInputStream.read(), which is reasonably fast (and implemented in pure Java)", "label": {"api": {"BufferedInputStream": [[47, 65]]}}}, {"text": "You can loop on the array and replace each String that appears in the input from it with empty String", "label": {"api": {"replace": [[30, 36]]}}}, {"text": "The is a method System.gc which", "label": {"api": {"System.gc": [[16, 24]]}}}, {"text": "You can use string.replace() function", "label": {"api": {".replace()": [[18, 27]]}}}, {"text": "If your requirement is to remove an element from the beginning of a collection and inserting it at the end, then you should either use a Queue<T> or a LinkedList<T>, and make an object that represents the pair of numbers its generic type argument", "label": {"api": {"Queue<T>": [[137, 144]], "LinkedList<T>": [[151, 163]]}}}, {"text": "Use request.getInputStream() to get the body as an InputStream, and parse this stream with an XML parser", "label": {"api": {"request.getInputStream()": [[4, 27]]}}}, {"text": "The problem is that you're calling DocumentBuilder.parse(String) which is meant to accept a URL as its parameter, not the actual XML", "label": {"api": {"DocumentBuilder.parse(String)": [[35, 63]]}}}, {"text": "I am considering using a BitSet But I am not sure if the memory implications", "label": {"api": {"BitSet": [[25, 30]]}}}, {"text": "I Think I had this in my initial wording of this Q but removed it when I first saw the BitSet Class", "label": {"api": {"BitSet": [[87, 92]]}}}, {"text": "Files.find function, can do the same thing in a more concise manner (practically one-liner)", "label": {"api": {"Files.find": [[0, 9]]}}}, {"text": "See documentation of SimpleDateFormat for more info", "label": {"api": {"documentation of SimpleDateFormat": [[4, 36]]}}}, {"text": "then before inserting a new entry, check whether the key already exists, using Map#containsKey() method", "label": {"api": {"Map#containsKey()": [[79, 95]]}}}, {"text": "You're looking for equalsIgnoreCase()", "label": {"api": {"equalsIgnoreCase()": [[19, 36]]}}}, {"text": "You should use equals() to compare strings", "label": {"api": {"equals()": [[15, 22]]}}}, {"text": "Additionally, if you want to take null cases into account when comparing the strings, consider using TextUtils.equals()", "label": {"api": {"equals()": [[111, 118]]}}}, {"text": "A SortedSet is perfect for this", "label": {"api": {"SortedSet": [[2, 10]]}}}, {"text": "When you cast to T, that's known as an unchecked cast because it doesn't exist at runtime", "label": {"api": {"cast": [[9, 12], [49, 52]]}}}, {"text": "Instead, other casts have been inserted by the compiler in places where instances of T are assigned back to a reified type like Integer", "label": {"api": {"cast": [[15, 18]]}}}, {"text": "The workaround is to provide Server with a Class<T> object representing the type of object to be consumed and use the cast method", "label": {"api": {"Class<T>": [[43, 50]], "cast": [[118, 121]]}}}, {"text": "readObjectType.cast(inReader.readObject()) will now fail fast when the wrong type of object has been read", "label": {"api": {"cast": [[15, 18]]}}}, {"text": "However, a better means of getting something performed on a regular basis on the GUI thread (which you need to change the attributes of GUI components) is to use a Timer (http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/Timer.html": [[171, 233]]}}}, {"text": "According to the API docs, isLetter() returns true if the character has any of the following general category types", "label": {"api": {"API docs": [[17, 24]]}}}, {"text": "A Java Thread's run() method is called by the JVM, on that thread, when the thread starts", "label": {"api": {"run()": [[16, 20]]}}}, {"text": "To give a thread something to do, you can make a subclass of Thread and override its run() method, or (preferred) you can supply a Runnable to the thread's constructor", "label": {"api": {"run()": [[85, 89]]}}}, {"text": "I was in the midst of making a subclass of Thread and overriding run, and I realized I couldn't make the method protected as I expected to because Thread.run() is public", "label": {"api": {"run()": [[154, 158]]}}}, {"text": "A thread is startable (from the current thread), but you don't run it in the same way you run() a Runnable (from the current thread); the thread runs itself (on its own thread)", "label": {"api": {"run()": [[90, 94]]}}}, {"text": "In Java, you'll want to use the getFields() function on your class (or any other class)", "label": {"api": {"getFields()": [[32, 42]]}}}, {"text": "Whichever properties you've defined in the .properties file (see API documentation to find out how to create such a file) using a Reader that can read that file, will now be accessible using the getProperty() method", "label": {"api": {"API documentation": [[65, 81]], "Reader": [[130, 135]]}}}, {"text": "I would use the JTable#setRowSelectionAllowed as it will ensure that a row can be selected", "label": {"api": {"JTable#setRowSelectionAllowed": [[16, 44]]}}}, {"text": "Hence the below line results in ClassCastException", "label": {"api": {"ClassCastException": [[32, 49]]}}}, {"text": "Because you forgot to instantiate the List", "label": {"api": {"List": [[38, 41]]}}}, {"text": "listFedespatch is a null reference and hence listFedespatch.add() will throw a NullPointerException", "label": {"api": {"NullPointerException": [[79, 98]]}}}, {"text": "I have used an ArrayList here , you can use any other implementations of List", "label": {"api": {"ArrayList": [[15, 23]], "List": [[20, 23], [73, 76]]}}}, {"text": "Depending on your performance requirements you may find using Collections.synchronizedMap(weakHashMap) the simplest option", "label": {"api": {"Collections.synchronizedMap(weakHashMap)": [[62, 101]]}}}, {"text": "Have you looked at BufferedImage", "label": {"api": {"BufferedImage": [[19, 31]]}}}, {"text": "You can do so via the Reflection package in the Field API", "label": {"api": {"Field API": [[48, 56]]}}}, {"text": "You can encode URL parameters using the URLEncoder", "label": {"api": {"URLEncoder": [[40, 49]]}}}, {"text": "Thread.sleep in a separate thread would do that", "label": {"api": {"Thread.sleep": [[0, 11]]}}}, {"text": "But if you must determine that, then call getClass() (defined by Object) to get the Class object, then compare it with Animal.class", "label": {"api": {"getClass()": [[42, 51]]}}}, {"text": "Timestamp.toString() prints to a specific format", "label": {"api": {"Timestamp.toString()": [[0, 19]]}}}, {"text": "Try trimming the result", "label": {"api": {"trimming": [[4, 11]]}}}, {"text": "Here's how you can use URLConnection to send a simple HTTP request", "label": {"api": {"URLConnection": [[23, 35]]}}}, {"text": "Alternatively, you can use a date format", "label": {"api": {"date format": [[29, 39]]}}}, {"text": "But, still, it is documented", "label": {"api": {"documented": [[18, 27]]}}}, {"text": "What is not documented - that some items may be created in class'es constant pool and injected into methods", "label": {"api": {"documented": [[12, 21]]}}}, {"text": "Once you've done that, the method you'll want to call is called containsAll", "label": {"api": {"containsAll": [[64, 74]]}}}, {"text": "It also has a containsAll method", "label": {"api": {"containsAll": [[14, 24]]}}}, {"text": "Calling readLine() on a BufferedReader will only return null on end of input", "label": {"api": {"readLine() on a BufferedReader": [[8, 37]]}}}, {"text": "Try accessing some of the functions Process provides", "label": {"api": {"Process": [[36, 42]]}}}, {"text": "I'd start with exitValue", "label": {"api": {"exitValue": [[15, 23]]}}}, {"text": "Also try InputStream and Error Stream, and read them fully", "label": {"api": {"InputStream": [[9, 19]], "Error Stream": [[25, 36]]}}}, {"text": "A NoSuchFieldException will be thrown in the event that no field exists called name", "label": {"api": {"NoSuchFieldException": [[2, 21]]}}}, {"text": "The JFrame inherits from java.awt.Component, whose add(Compontent comp) method throws an exception if passed a null argument", "label": {"api": {"throws an exception if passed a null argument": [[79, 123]]}}}, {"text": "Personally I'd probably use a ScheduledExecutorService to give more control over the threads created and concurrency between tasks, but that's a slightly different matter", "label": {"api": {"ScheduledExecutorService": [[30, 53]]}}}, {"text": "You should use the Date(long) constructor", "label": {"api": {"Date(long)": [[19, 28]]}}}, {"text": "One of the way is to use the Calendar class and its after() , equals() and before() methods", "label": {"api": {"Calendar": [[29, 36]], "after()": [[52, 58]], "equals()": [[62, 69]], "before()": [[75, 82]]}}}, {"text": "Then you are sure you'll use only the functionality of the interface List", "label": {"api": {"List": [[69, 72]]}}}, {"text": "(ArrayList implements List, so List is more flexibl)", "label": {"api": {"List": [[6, 9], [22, 25], [31, 34]]}}}, {"text": "Using this, allows you to change the ArrayList to other types in the future (like LinkedList..)", "label": {"api": {"List": [[42, 45], [88, 91]]}}}, {"text": "You want new DateFormatSymbols().getWeekdays()", "label": {"api": {"new DateFormatSymbols().getWeekdays()": [[9, 45]]}}}, {"text": "One way is to use OverlayLayout", "label": {"api": {"OverlayLayout": [[18, 30]]}}}, {"text": "createNewFile() was added in Java 1.2, which is several years after Java 1.0", "label": {"api": {"createNewFile()": [[0, 14]]}}}, {"text": "Note that when createNewFile() exists without an exception, then the requested file exists", "label": {"api": {"createNewFile()": [[15, 29]]}}}, {"text": "This is not always a good idea, since interrupt() has several side effects and may not even set the interrupt status to true depending on what's going with the thread", "label": {"api": {"several side effects and may not even set the interrupt status to true depending on what's going with the thread": [[54, 165]]}}}, {"text": "The String(byte[]) constructor converts bytes to characters using the platform default encoding, which can be anything", "label": {"api": {"String(byte[])": [[4, 17]]}}}, {"text": "Since you want to do case insensitive sorting, you can use a pre-defined static CASE_INSENSITIVE comparator defined in String class", "label": {"api": {"CASE_INSENSITIVE": [[80, 95]]}}}, {"text": "Call cancel(boolean) if the 'stop' button is activated", "label": {"api": {"cancel(boolean)": [[5, 19]]}}}, {"text": "Make RowBean implement Comparable and implement the compareTo method to pull out the value of that key and use it to decide the result of the comparison", "label": {"api": {"Comparable": [[23, 32]]}}}, {"text": "Once RowBean is a Comparable you can sort using", "label": {"api": {"Comparable": [[18, 27]]}}}, {"text": "One definition of reachability is provided by the package documentation for java.lang.ref", "label": {"api": {"java.lang.ref": [[76, 88]]}}}, {"text": "I checked System.setOut(PrintStream) but this also caries the data only after I pass request dispatcher - not good for me", "label": {"api": {"System.setOut(PrintStream)": [[10, 35]]}}}, {"text": "More recent incarnations of java have the AutoCloseable interface which you can use with the with mechanism", "label": {"api": {"AutoCloseable": [[42, 54]], "Closeable": [[46, 54]]}}}, {"text": "All Closeable objects are automatically AutoCloseable", "label": {"api": {"AutoCloseable": [[40, 52]], "Closeable": [[4, 12], [44, 52]]}}}, {"text": "Take a look at the examples of how to use threads on the JavaDoc for java.lang.Thread", "label": {"api": {"java.lang.Thread": [[69, 84]]}}}, {"text": "The API documentation for java.lang.Thread and java.lang.Runnable give more details", "label": {"api": {"java.lang.Thread": [[26, 41]], "java.lang.Runnable": [[47, 64]]}}}, {"text": "Integer.compare(int,int) was introduced in Java 1.7", "label": {"api": {"Integer.compare(int,int)": [[0, 23]]}}}, {"text": "String is a class in Java and offers you methods and is also an Object", "label": {"api": {"String": [[0, 5]]}}}, {"text": "A String-object is also immutable", "label": {"api": {"String": [[2, 7]]}}}, {"text": "Check SimpleDateFormat documentation for format options", "label": {"api": {"SimpleDateFormat documentation": [[6, 35]]}}}, {"text": "If you used TreeMap instead, the map would be ordered by key automatically", "label": {"api": {"TreeMap": [[12, 18]]}}}, {"text": "As to sorting, you should look at the Comparator interface", "label": {"api": {"Comparator": [[38, 47]]}}}, {"text": "You implement a custom subclass of Comparator that allows the builtin collection sorting algorithms to compare Employee instances such that the desired order is achieved", "label": {"api": {"Comparator": [[35, 44]]}}}, {"text": "This fulfills the Comparator contract by returning -1 if this Employee is younger than e, zero if they are the same age, and +1 if this Employee is older", "label": {"api": {"Comparator": [[18, 27]]}}}, {"text": "A better alternative is to use an ArrayList", "label": {"api": {"ArrayList": [[34, 42]]}}}, {"text": "When you add items to an ArrayList, the capacity will grow behind the scenes if needed; you don't have to worry about increasing the size", "label": {"api": {"ArrayList": [[25, 33]]}}}, {"text": "Consider using a Collection such as ArrayList which will handle everything for you", "label": {"api": {"ArrayList": [[36, 44]]}}}, {"text": "If you don't want to use lists consider using System.arrayCopy to create a new array with more elements", "label": {"api": {"System.arrayCopy": [[46, 61]]}}}, {"text": "But there's a handy createNewFile() and mkdirs() method for that", "label": {"api": {"createNewFile()": [[20, 34]], "mkdirs()": [[40, 47]]}}}, {"text": "More specifically, use mkdirs() to create the directories, but you'll want to call getParentFile() first because you don't want to create a directory called me.txt", "label": {"api": {"mkdirs()": [[23, 30]], "getParentFile()": [[83, 97]]}}}, {"text": "Then you can call the createNewFile() method to finally create your new file", "label": {"api": {"createNewFile()": [[22, 36]]}}}, {"text": "As EJP explained, it's not necessary to call createNewFile() since FileOutputStream and FileWriter will create the new file for you", "label": {"api": {"createNewFile()": [[45, 59]]}}}, {"text": "If you, for example, had the method my(); ITSELF simply call my(), then you would immediately get a StackOverflowError, but this would happen on the very first iteration of your for(;;) loop", "label": {"api": {"StackOverflowError": [[100, 117]]}}}, {"text": "Possible \"loopless\" solutions would use System.arraycopy or Arrays.copyOf, but in these solutions you cannot avoid casting your byte[] to a double[]", "label": {"api": {"System.arraycopy": [[40, 55]], "Arrays.copyOf": [[60, 72]]}}}, {"text": "In ahother hand, you can to use a constant of java.util.regex.Pattern for avoid recompiled the expression every time, something like that", "label": {"api": {"java.util.regex.Pattern": [[46, 68]]}}}, {"text": "On the server side, encode the bean value using URI percent encoding", "label": {"api": {"URI percent encoding": [[48, 67]]}}}, {"text": "You should be using a List anyway, since you don't know how many lines you are going to read beforehand", "label": {"api": {"List": [[22, 25]]}}}, {"text": "The java.util.Deque is as last-in-first-out (LIFO) stack", "label": {"api": {"java.util.Deque": [[4, 18]]}}}, {"text": "If you must tie enum values to state data, use an EnumMap", "label": {"api": {"EnumMap": [[50, 56]]}}}, {"text": "To open a file for writing without creating you can use the java.nio.file.Files class", "label": {"api": {"java.nio.file.Files": [[60, 78]]}}}, {"text": "Or you can use something like String.split", "label": {"api": {"String.split": [[30, 41]]}}}, {"text": "You use the ProcessBuilder class, or Runtime.exec", "label": {"api": {"ProcessBuilder": [[12, 25]], "Runtime.exec": [[37, 48]]}}}, {"text": "You might want to consider using .putAll() instead", "label": {"api": {".putAll()": [[33, 41]]}}}, {"text": "As the store documentation states, default properties (the ones passed in the Properties(Properties) constructor) are not written to the external file", "label": {"api": {"the store documentation states": [[3, 32]]}}}, {"text": "I suggest looking into ExecutorService", "label": {"api": {"ExecutorService": [[23, 37]]}}}, {"text": "Also, you should consider implementing (overriding) custom compare(o1, o2) if you'll need to sort the array, because the default Collections.sort(list) doesn't know how to correctly order your objects", "label": {"api": {"compare(o1, o2)": [[59, 73]], "Collections.sort(list)": [[129, 150]]}}}, {"text": "Use DataOutputStream, not ObjectOutputStream", "label": {"api": {"DataOutputStream": [[4, 19]]}}}, {"text": "DataOutputStream writes everything in Big Endian", "label": {"api": {"DataOutputStream": [[0, 15]]}}}, {"text": "You can use the Arrays.copyOfRange method", "label": {"api": {"Arrays.copyOfRange": [[16, 33]]}}}, {"text": "Pattern.quote can help you escape regex substrings if you need to build your expected string programmatically (as you do with user.home here)", "label": {"api": {"Pattern.quote": [[0, 12]]}}}, {"text": "From the documentation", "label": {"api": {"From the documentation": [[0, 21]]}}}, {"text": "flush() and close() your output streams", "label": {"api": {"flush()": [[0, 6]], "close()": [[12, 18]]}}}, {"text": "You may find the Object.clone method helpful, but keeping in mind its requirements (have to implement Cloneble and override the clone method) and limitations (only makes a shallow copy) you might as well write your copy method from scratch", "label": {"api": {"Object.clone": [[17, 28]], "Cloneble": [[102, 109]]}}}, {"text": "Or alternatively use @PostConstruct and @PreDestroy annotations if you don't want to use XML configuration", "label": {"api": {"@PostConstruct": [[21, 34]], "@PreDestroy": [[40, 50]]}}}, {"text": "That's not the case in your program, you're passing two ints to String#substring as expected, and you're not missing anything (No missing classes, brackets are OK, semicolons are as supposed), so why should the compiler care", "label": {"api": {"String#substring": [[64, 79]]}}}, {"text": "You get an Exception if the code compiled but crashed due to some Exception (like ArrayIndexOutOfBounds)", "label": {"api": {"ArrayIndexOutOfBounds": [[82, 102]]}}}, {"text": "The call to substring() is taking two int's, which is a valid invocation of the substring method", "label": {"api": {"substring method": [[80, 95]]}}}, {"text": "As per the documentation of the Thread class, a dying thread calls notifyAll on the instance which represents it", "label": {"api": {"the documentation of the Thread class": [[7, 43]]}}}, {"text": "From the Object.equals JavaDoc", "label": {"api": {"Object.equals": [[9, 21]]}}}, {"text": "before starting the calculation or exactly after generating the array you can use System#currentTimeMillis() to get the exact time and do the same exactly after completion of sorting and then find the difference", "label": {"api": {"System#currentTimeMillis()": [[82, 107]]}}}, {"text": "You can call (and store the result of) System.nanoTime() before and after the call to Arrays.sort()- the difference is the time spent in nanoseconds", "label": {"api": {"System.nanoTime()": [[39, 55]]}}}, {"text": "You need to call reset() to ..", "label": {"api": {"reset()": [[17, 23]]}}}, {"text": "You must create a custom implementation of Comparator then call", "label": {"api": {"Comparator": [[43, 52]]}}}, {"text": "You can insert a specified element at a specified position using the add method", "label": {"api": {"add method": [[69, 78]]}}}, {"text": "Method public static String toString​(int codePoint) which was added to the Character class in Java 11", "label": {"api": {"public static String toString​(int codePoint)": [[7, 51]]}}}, {"text": "Create an instance every time you need one, or if performance is a real issue, you could try using ThreadLocal to store an instance for each thread that needs one", "label": {"api": {"ThreadLocal": [[99, 109]]}}}, {"text": "Anyway, you can set the fetch size individually for each result set with ResultSet.setFetchSize()", "label": {"api": {"ResultSet.setFetchSize()": [[73, 96]]}}}, {"text": "I don't know what exactly you are using, but PrintWriter's printf methods lets you write formatted strings", "label": {"api": {"PrintWriter": [[45, 55]]}}}, {"text": "Always use DocumentBuilderFactory.newInstance, which will use (among other things) the Services API to locate the actual DocumentBuilderFactory to instantiate", "label": {"api": {"DocumentBuilderFactory.newInstance": [[11, 44]]}}}, {"text": "Use Console.readLine to read input from the console", "label": {"api": {"Console.readLine": [[4, 19]]}}}, {"text": "You can get an instance of Console using System.console", "label": {"api": {"System.console": [[41, 54]]}}}, {"text": "If System.console() returns null, that means that (from the JVM's perspective) you don't actually have a console", "label": {"api": {"System.console": [[3, 16]]}}}, {"text": "Using StringBuilder this algorithm can be made very simple", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "This is the classic purpose of a queue, and you probably want some implementation of BlockingQueue", "label": {"api": {"BlockingQueue": [[85, 97]]}}}, {"text": "If you are parsing bytes, look into using ByteBuffer as its bulk operations will be more efficient for buffering", "label": {"api": {"ByteBuffer": [[42, 51]]}}}, {"text": "The easiest approach to implementing it in Java is to use a BlockingQueue, although it's easy enough to implement your own wait/notify protocol on a basic List", "label": {"api": {"BlockingQueue": [[60, 72]]}}}, {"text": "The solution to your problem is a Queue not a List", "label": {"api": {"Queue": [[34, 38]]}}}, {"text": "In particular you will want to use the ConcurrentLinkedQueue for this application", "label": {"api": {"Queue": [[55, 59]], "ConcurrentLinkedQueue": [[39, 59]]}}}, {"text": "The enum value Response.Status.FOUND (302) was added in 2.0 (along with several other response codes missing from earlier versions)", "label": {"api": {"Response.Status.FOUND": [[15, 35]]}}}, {"text": "If you really want the trailing empty strings, then use the overloaded version of split that takes two arguments -- the second argument limit can be negative, and it tells split not to discard trailing empty strings", "label": {"api": {"split that takes two arguments": [[82, 111]]}}}, {"text": "@Banthar's helpful comment led me to the java.util.concurrent package documentation, which answers my question definitively", "label": {"api": {"java.util.concurrent package documentation": [[41, 82]]}}}, {"text": "You can use List#toArray(T[])", "label": {"api": {"List#toArray(T[])": [[12, 28]]}}}, {"text": "Right now I'm using File.listFiles() to do this, but this is extremely inefficient because", "label": {"api": {"File.listFiles()": [[20, 35]]}}}, {"text": "I also looked up the exactly how File.listFiles() in OpenJDK, but it ultimately ends up at a native function call for UNIX-based systems (line 268) and also for Windows (line 525)", "label": {"api": {"File.listFiles()": [[33, 48]]}}}, {"text": "Try to get these details from the Database Metadata", "label": {"api": {"Database Metadata": [[34, 50]]}}}, {"text": "You could use a Callable and an ExecutorService to implement the timeout behavior", "label": {"api": {"Callable": [[16, 23]], "ExecutorService": [[32, 46]]}}}, {"text": "See PreparedStatement.setInt, which takes the parameter index and value", "label": {"api": {"PreparedStatement.setInt": [[4, 27]]}}}, {"text": "For this specific case, you can use Float.intBitsToFloat (and Float.floatToIntBits for the other way; Double also has similar methods)", "label": {"api": {"Float.intBitsToFloat": [[36, 55]], "Float.floatToIntBits": [[62, 81]]}}}, {"text": "Instead of using an explicit thread, you can make use of the ExecutorService interface", "label": {"api": {"ExecutorService": [[61, 75]]}}}, {"text": "I also often use static nested classes (which are technically not inner classes) for classes which are only used in the context of another class - Map.Entry is a good example of this", "label": {"api": {"Map.Entry": [[147, 155]]}}}, {"text": "For a good example of a legitimate use for member classes, see the source code for LinkedList.ListItr", "label": {"api": {"LinkedList": [[83, 92]]}}}, {"text": "This is a private inner class whose purpose is to provide an implementation of ListIterator for a LinkedList", "label": {"api": {"ListIterator": [[79, 90]], "LinkedList": [[98, 107]]}}}, {"text": "To do this, it's useful to have access to the private data inside the LinkedList", "label": {"api": {"LinkedList": [[70, 79]]}}}, {"text": "To achieve this using only top-level classes, it would have been necessary to expose more public methods in LinkedList to allow the ListIterator to get at the underlying implementation of the LinkedList", "label": {"api": {"ListIterator": [[132, 143]], "LinkedList": [[108, 117], [192, 201]]}}}, {"text": "Instead, using an inner class allows LinkedList to keep its implementation private, as it should be", "label": {"api": {"LinkedList": [[37, 46]]}}}, {"text": "Here you can find a list of available properties", "label": {"api": {"Here you can find": [[0, 16]]}}}, {"text": "You should keep this Properties object seperate of the system properties", "label": {"api": {"Properties object": [[21, 37]]}}}, {"text": "Reference these formats Java Date Format Docs", "label": {"api": {"Java Date Format Docs": [[24, 44]]}}}, {"text": "You could use a Timer which is triggered on a mouseEntered or mouseExited", "label": {"api": {"Timer": [[16, 20]]}}}, {"text": "You could also use a FocusListener to cater for what happens when the Dialog looses focus (timer starts) or when it gains it (timer stops, no timer related event is to be fired)", "label": {"api": {"FocusListener": [[21, 33]]}}}, {"text": "Use a clock or somthing to make that it disapeers after a few secounds", "label": {"api": {"clock or somthing": [[6, 22]]}}}, {"text": "You should remove an element from a List using an Iterator", "label": {"api": {"Iterator": [[50, 57]]}}}, {"text": "This should give you some hints, why you should use an Iterator", "label": {"api": {"Iterator": [[55, 62]]}}}, {"text": "So after taking assumption of that your arraylist's object type is the wrapper class (of the primitive data types) like Integer, Double, String etc., you can use ListView instead of TableView", "label": {"api": {"ListView": [[162, 169]]}}}, {"text": "You're looking for Timer#scheduleAtFixedRate", "label": {"api": {"Timer#scheduleAtFixedRate": [[19, 43]]}}}, {"text": "Look at the Javadoc for PrintStream (the class of System.out)", "label": {"api": {"the Javadoc for PrintStream": [[8, 34]]}}}, {"text": "More info can be found on CardLayout API, A small example for help, to see it functioning", "label": {"api": {"CardLayout API": [[26, 39]]}}}, {"text": "You can use Window.toFront() to bring the current frame to front", "label": {"api": {"Window.toFront()": [[12, 27]]}}}, {"text": "There I've created the array using Array#newInstance() method, since you cannot create an array of type parameter T directly", "label": {"api": {"Array#newInstance()": [[35, 53]]}}}, {"text": "uses the List#toArray(T[]) method to convert the inner list to an array, as you already did", "label": {"api": {"List#toArray(T[])": [[9, 25]]}}}, {"text": "The object must implement Comparable", "label": {"api": {"Comparable": [[26, 35]]}}}, {"text": "In this case, implement Comparable<Child>", "label": {"api": {"Comparable": [[24, 33]]}}}, {"text": "Create your own class that implements Comparator, specifically Comparator<Child>, and pass an instance of that class as the second parameter to Collections.sort", "label": {"api": {"Comparator": [[38, 47], [63, 72]]}}}, {"text": "Then the sorting algorithm will use the Comparator to sort the collection", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "From InputMismatchException's JavaDoc", "label": {"api": {"InputMismatchException's JavaDoc": [[5, 36]]}}}, {"text": "You would need to use List#listIterator() instead of List#iterator() to initialize the loop variable (which, obviously, would have to be declared a ListIterator rather than an Iterator)", "label": {"api": {"List#listIterator()": [[22, 40]], "List#iterator()": [[53, 67]]}}}, {"text": "LinkedBlockingQueue does the job", "label": {"api": {"LinkedBlockingQueue": [[0, 18]]}}}, {"text": "If your queue is a fixed size, ArrayBlockingQueue will be more efficient", "label": {"api": {"ArrayBlockingQueue": [[31, 48]]}}}, {"text": "Maybe you can consider a Read-write lock (http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html": [[42, 140]]}}}, {"text": "The quote from the API is actually", "label": {"api": {"API": [[19, 21]]}}}, {"text": "Read the InputStream JavaDoc for more information", "label": {"api": {"InputStream JavaDoc": [[9, 27]]}}}, {"text": "In Java, reading all entries via JarInputStream looks rather tedious", "label": {"api": {"JarInputStream": [[33, 46]]}}}, {"text": "That is Connection#prepareStatement(sql)", "label": {"api": {"Connection#prepareStatement(sql)": [[8, 39]]}}}, {"text": "You can use SimpleDateFormat for this", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "Note that you should consider using something like Integer.toString(real) over real + \"\" (see Integer.toString())", "label": {"api": {"Integer.toString()": [[94, 111]]}}}, {"text": "The getClass method is described as one of the Object methods, in the Object API documentation", "label": {"api": {"Object API documentation": [[70, 93]]}}}, {"text": "The third approach uses one of the static forName methods defined the API documentation for java.lang.Class", "label": {"api": {"java.lang.Class": [[92, 106]]}}}, {"text": "The javadoc for this method makes it reasonably clear why it's deprecated, and has been for a long time, and suggests a better alternative", "label": {"api": {"javadoc for this method": [[4, 26]]}}}, {"text": "Java has a Runnable interface in the java.lang package, which is conflicting with your class", "label": {"api": {"Runnable": [[11, 18]]}}}, {"text": "Rename your class to something else (MyRunnable or something more meaningful), which will take care of the error", "label": {"api": {"Runnable": [[39, 46]]}}}, {"text": "Use a StringBuilder for string concatenation", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "CopyOnWriteArrayList may be an alternative for your queue, that may have the behaviour you want", "label": {"api": {"CopyOnWriteArrayList": [[0, 19]]}}}, {"text": "You can't reuse the same Statement object because on every new executeQuery() call any ResultSet if already open is closed implicitly", "label": {"api": {"ResultSet": [[87, 95]]}}}, {"text": "A ResultSet object is automatically closed when the Statement object that generated it is closed, re-executed, or used to retrieve the next result from a sequence of multiple results", "label": {"api": {"ResultSet": [[2, 10]]}}}, {"text": "Check out the JavaDocs for ResultSet", "label": {"api": {"ResultSet": [[27, 35]]}}}, {"text": "An easy way is to use JTextComponent.write(Writer)", "label": {"api": {"JTextComponent.write(Writer)": [[22, 49]]}}}, {"text": "For the Writer use a FileWriter", "label": {"api": {"FileWriter": [[21, 30]]}}}, {"text": "You can use the copy constructor of your collection class to make a clone of the queue, add the new item, then return the clone", "label": {"api": {"copy constructor": [[16, 31]]}}}, {"text": "For example, LinkedList has the copy constructor", "label": {"api": {"copy constructor": [[32, 47]]}}}, {"text": "currentTimeMillis() gives you the number of milliseconds that has elapsed since a fixed point in time called the Unix epoch", "label": {"api": {"currentTimeMillis()": [[0, 18]]}}}, {"text": "Furthermore, you don't need to rely on toString() for display text on GUI (toString() is not meant to be used that way, it would be problematic in case of internationalization), you can provide a ListCellRenderer instead, as shown in question JComboBox setting label and value", "label": {"api": {"ListCellRenderer": [[196, 211]]}}}, {"text": "This could be easily figured out from the Java API for JTabbedPane", "label": {"api": {"Java API for JTabbedPane": [[42, 65]]}}}, {"text": "For more details on what Java does with this, read the javadocs for exec(String) and exec(String[])", "label": {"api": {"exec(String)": [[68, 79]], "exec(String[])": [[85, 98]]}}}, {"text": "The reason for splitting the command by hand is that exec(String) won't split the command into a single command and arguments correctly", "label": {"api": {"exec(String)": [[53, 64]]}}}, {"text": "So, start using Gregorian Calendars", "label": {"api": {"Gregorian Calendars": [[16, 34]]}}}, {"text": "shutdown means the executor service takes no more incoming tasks", "label": {"api": {"shutdown": [[0, 7]]}}}, {"text": "awaitTermination  is invoked after a shutdown request", "label": {"api": {"shutdown": [[37, 44]], "awaitTermination": [[0, 15]]}}}, {"text": "Instead use Map#entrySet() to retrieve them as matched pairs", "label": {"api": {"Map#entrySet()": [[12, 25]]}}}, {"text": "Use a Map that maps characters (in this case A..D,F) to the corresponding values (4..0)", "label": {"api": {"Map": [[6, 8]]}}}, {"text": "If your program ever used the toString() for lexical sorting using natural ordering in such a way that program execution depends on it, then it would be wise to override the default toString() of the class that extended", "label": {"api": {"toString()": [[30, 39], [182, 191]]}}}, {"text": "You should in that case make the toString() method final and clearly document that it is used for ordering", "label": {"api": {"toString()": [[33, 42]]}}}, {"text": "See for instance the final method name() used for enumerations in Java", "label": {"api": {"name()": [[34, 39]]}}}, {"text": "In general it creates the same String as toString() but it is still possible to perform ordering with it even if toString() has been overridden", "label": {"api": {"toString()": [[41, 50], [113, 122]]}}}, {"text": "Finally, you need to invoke the constructor's newInstance method, passing it the instance of the outer class as the first argument", "label": {"api": {"newInstance": [[46, 56]]}}}, {"text": "Try to use the Book class which is used in this thread", "label": {"api": {"Book": [[15, 18]]}}}, {"text": "You can use Comparator which compares by length first and if the lengths are the same, use the String.compareTo()", "label": {"api": {"Comparator": [[12, 21]]}}}, {"text": "Here is how you can check write permissions on that file using File#canWrite before trying to delete that file", "label": {"api": {"File#canWrite": [[63, 75]]}}}, {"text": "If you would like to use one bit per boolean, use BitSet class instead of an array of booleans", "label": {"api": {"BitSet": [[50, 55]]}}}, {"text": "You can remove an entry using the remove method, but for something you want, you can checkout something like Guava's MultiMap", "label": {"api": {"remove method": [[34, 46]]}}}, {"text": "If you really want to remove based on a value, you'll need to iterate through the values of the Map using entrySet(), and then based on the value call the remove method using the found key", "label": {"api": {"remove method": [[155, 167]]}}}, {"text": "If so, there is FileStore which returns the type as a String", "label": {"api": {"FileStore": [[16, 24]]}}}, {"text": "However, looking at the source code itself (FileStore.java) there is a warning that the return value might be implementation specific", "label": {"api": {"FileStore": [[44, 52]]}}}, {"text": "You can by using Externalizable", "label": {"api": {"Externalizable": [[17, 30]]}}}, {"text": "You can read about the format string syntax in the documentation of Formatter", "label": {"api": {"Formatter": [[68, 76]]}}}, {"text": "I think you should rather use FutureTask with ScheduledExecutorService for this purpose", "label": {"api": {"FutureTask": [[30, 39]], "ScheduledExecutorService": [[46, 69]]}}}, {"text": "FutureTask has an isDone method to check if it is completed", "label": {"api": {"FutureTask": [[0, 9]], "isDone": [[18, 23]]}}}, {"text": "Since TimerTask implements Runnable, you can wrap your task quite easily in a FutureTask", "label": {"api": {"FutureTask": [[78, 87]]}}}, {"text": "All the toString() methods in Arrays class are static, so does this really override Object's toString() method", "label": {"api": {"toString()": [[8, 17], [93, 102]]}}}, {"text": "The static toString methods you see are totally unrelated to the standard toString method, as should be clear from their description in the javadoc", "label": {"api": {"their description in the javadoc": [[115, 146]]}}}, {"text": "Check out the API of Collections#sort(List<T>)", "label": {"api": {"Collections#sort(List<T>)": [[21, 45]]}}}, {"text": "You need to implement the Iterable interface", "label": {"api": {"Iterable interface": [[26, 43]]}}}, {"text": "Your class NumberList need to implement the Iterable interface", "label": {"api": {"Iterable": [[44, 51]]}}}, {"text": "An alternative is using Pattern", "label": {"api": {"Pattern": [[24, 30]]}}}, {"text": "Datastructure such as PriorityQueue uses the binary heap tree concepts", "label": {"api": {"PriorityQueue": [[22, 34]]}}}, {"text": "Or should it throw an out of bounds exception", "label": {"api": {"out of bounds exception": [[22, 44]]}}}, {"text": "You can use the Calendar.getActualMaximum(int) method to get the total number of weeks in the current year as follows", "label": {"api": {"Calendar.getActualMaximum(int)": [[16, 45]]}}}, {"text": "As the error says, the put signature is", "label": {"api": {"put signature is": [[23, 38]]}}}, {"text": "You need to use Arrays.toString(int[]), to create string that will contain the expected from", "label": {"api": {"Arrays.toString(int[])": [[16, 37]]}}}, {"text": "String.split considers its argument as regular expression", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "You can try using ConcurrentLinkedQueue or as John stated do a copy and modify the original in iteration", "label": {"api": {"ConcurrentLinkedQueue": [[18, 38]]}}}, {"text": "Java's .find() method returns \"true if, and only if, a subsequence of the input sequence matches this matcher's pattern\" - see the documentation", "label": {"api": {"see the documentation": [[123, 143]]}}}, {"text": "To do that you can use Runtime.exec() just to execute a command line to run that library", "label": {"api": {"Runtime.exec()": [[23, 36]]}}}, {"text": "Having multiple way to construct an object might be useful, like with the Color class, in ndj's answer, can be created in four different ways", "label": {"api": {"Color": [[74, 78]]}}}, {"text": "Each way makes sure that Color as the minimum informations to be useful, or \"work\"", "label": {"api": {"Color": [[25, 29]]}}}, {"text": "Those informations could be missing if Color only had a contructor without parameter and, for the class to \"work\", would be to call setRand the other methods..", "label": {"api": {"Color": [[39, 43]]}}}, {"text": "which don't exist in the Color class", "label": {"api": {"Color": [[25, 29]]}}}, {"text": "You can try using the BigInteger class for operations with really huge integer numbers", "label": {"api": {"BigInteger": [[22, 31]]}}}, {"text": "For operations with floating numbers, Java provides the BigDecimal class, which can be useful, as well", "label": {"api": {"BigDecimal": [[56, 65]]}}}, {"text": "It magically fulfills all the requirements of the general hashCode() contract", "label": {"api": {"the general hashCode() contract": [[46, 76]]}}}, {"text": "* except for those classes that have a defined and documented hashCode algorithm that they must implement, the prime example being String.hashCode()", "label": {"api": {"String.hashCode()": [[131, 147]]}}}, {"text": "On the other hand a work-around might be found in the IntegrationService of the JNLP API", "label": {"api": {"IntegrationService of the JNLP API": [[54, 87]]}}}, {"text": "Your code doesn't show you errors because there's no error in compile time, ClassCastException  is a runtime exception", "label": {"api": {"ClassCastException": [[76, 93]]}}}, {"text": "Use an Iterator and call remove()", "label": {"api": {"Iterator": [[7, 14]], "remove()": [[25, 32]]}}}, {"text": "Use a CountDownLatch", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "A CountDownLatch is a somewhat modified, enhanced (e.g", "label": {"api": {"CountDownLatch": [[2, 15]]}}}, {"text": "You should use a PreparedStatement and use setNull(int, int)", "label": {"api": {"setNull(int, int)": [[43, 59]]}}}, {"text": "As an alternative to Mark Rotteveel's answer, you can also use PreparedStatement.setObject(int, Object, int)", "label": {"api": {"PreparedStatement.setObject(int, Object, int)": [[63, 107]]}}}, {"text": "From the JavaDocs for String.indexOf, we know that if the string does not occur, -1 will be returned", "label": {"api": {"JavaDocs for String.indexOf": [[9, 35]]}}}, {"text": "When comparing Strings you should use .equals", "label": {"api": {".equals": [[38, 44]]}}}, {"text": "For this use case, you may wish to use .equalsIgnoreCase, which checks for equality, ignoring the case", "label": {"api": {".equals": [[39, 45]], ".equalsIgnoreCase": [[39, 55]]}}}, {"text": "Some developers prefer using the Yoda Conditions convention, which results in conditionals being written like if (\"ford\".equals(carMake))", "label": {"api": {".equals": [[120, 126]]}}}, {"text": "When used with instance methods such as .equals, it can prevent subtle NullPointerExceptions from leaking into your code", "label": {"api": {".equals": [[40, 46]]}}}, {"text": "This is based on an implementation of a sorted SkipList", "label": {"api": {"implementation": [[20, 33]]}}}, {"text": "Plus, java includes the implementation already", "label": {"api": {"implementation": [[24, 37]]}}}, {"text": "It might very well be faster to create the skiplist list from a sorted arraylist, depending on the implementation", "label": {"api": {"implementation": [[99, 112]]}}}, {"text": "Bulk additions are usually faster than one-by-one (depending on the implementation)", "label": {"api": {"implementation": [[68, 81]]}}}, {"text": "There is a ForkJoinPool(int) constructor that allows you to hint at the \"amount of parallelism\"", "label": {"api": {"ForkJoinPool(int)": [[11, 27]]}}}, {"text": "synchronizedList doesn't document that it will return something that can be cast back to the underlying list, just that it returns something that implements List<E> that is synchronized", "label": {"api": {"synchronizedList": [[0, 15]]}}}, {"text": "But in this case, you don't need to, because LinkedList#addLast is equivalent to List#add", "label": {"api": {"LinkedList#addLast": [[45, 62]], "List#add": [[51, 58], [81, 88]]}}}, {"text": "List.indexOf() will give you what you want, provided you know precisely what you're after, and provided that the equals() method for Party is well-defined", "label": {"api": {"List.indexOf()": [[0, 13]]}}}, {"text": "It's also wise to override hashCode if you override equals - the general contract for hashCode mandates that, if x.equals(y), then x.hashCode() == y.hashCode()", "label": {"api": {"x.hashCode() == y.hashCode()": [[131, 158]]}}}, {"text": "You could use a LinkedHashMap and convert it to a List or Array later (Chris has covered this nicely in the comments below)", "label": {"api": {"LinkedHashMap": [[16, 28]]}}}, {"text": "LinkedHashMap because it lets you access the elements in the order you insert them if you want to do so", "label": {"api": {"LinkedHashMap": [[0, 12]]}}}, {"text": "I would put the whole parameter in a HashMap so it is easy to get the values", "label": {"api": {"HashMap": [[37, 43]]}}}, {"text": "...and put them into your HashMap", "label": {"api": {"HashMap": [[26, 32]]}}}, {"text": "If you are downloading an ordinary file over HTTP, the method getContentLength() of URLConnection gives you the length that the file should have in the end", "label": {"api": {"getContentLength()": [[62, 79]]}}}, {"text": "My first idea were two calls to String.replaceAll(), one for tags, one for links", "label": {"api": {"String.replaceAll()": [[32, 50]]}}}, {"text": "Maybe setColumnHeaderView() is what you are looking for", "label": {"api": {"setColumnHeaderView()": [[6, 26]]}}}, {"text": "2) String#replace(char oldChar, char newChar)  replaces all occurrences of oldChar in this string with newChar", "label": {"api": {"String#replace(char oldChar, char newChar) ": [[3, 45]]}}}, {"text": "I have a situation where multiple threads will be polling a single BlockingQueue by calling take()", "label": {"api": {"BlockingQueue": [[67, 79]], "take()": [[92, 97]]}}}, {"text": "If multiple threads are waiting for the queue to receive an item, will they be given priority for taking items off the queue in the order that they made their calls to take() or will the order in which the threads take things off the queue be arbitrary", "label": {"api": {"take()": [[168, 173]]}}}, {"text": "I have written my own implementations for this kind of thing in the past, but I'm wondering if the BlockingQueue implementations in Java would do this for me", "label": {"api": {"BlockingQueue": [[99, 111]]}}}, {"text": "One way you could go about doing this is by using getLast() to grab the last element off the one of the lists and then use addFirst() on the other in order to add it to the front", "label": {"api": {"getLast()": [[50, 58]], "addFirst()": [[123, 132]]}}}, {"text": "As has been said here, however, addAll() would not be copying anything and could be used just as easily", "label": {"api": {"addAll()": [[32, 39]]}}}, {"text": "You can use 2 Comparators to achieve this", "label": {"api": {"Comparators": [[14, 24]]}}}, {"text": "You can implement two Comparators", "label": {"api": {"Comparator": [[22, 31]]}}}, {"text": "You need to specify the fully qualified class name to Class.forName(String)", "label": {"api": {"Class.forName(String)": [[54, 74]]}}}, {"text": "You should use Random#nextInt(int n) instead of your array and generate 3 random numbers", "label": {"api": {"Random#nextInt(int n)": [[15, 35]]}}}, {"text": "See the Class Javadoc here for more information", "label": {"api": {"Class Javadoc here": [[8, 25]]}}}, {"text": "You should use the multiply method inside the BigInteger class", "label": {"api": {"BigInteger": [[46, 55]]}}}, {"text": "From the WeakHashMap documentation", "label": {"api": {"WeakHashMap documentation": [[9, 33]]}}}, {"text": "Create a NamedQuery that restricts the results the way you want and use the NamedQuery instead", "label": {"api": {"NamedQuery": [[9, 18], [76, 85]]}}}, {"text": "Java will automatically call String.valueOf() on the object, which avoids a NullPointerException because it returns the String \"null\" instead", "label": {"api": {"String.valueOf()": [[29, 44]]}}}, {"text": "For instance, Java's StringBuilder is mutable, and defines several append methods which mutate the instance", "label": {"api": {"StringBuilder": [[21, 33]]}}}, {"text": "I think you could use shutdownNow method, this should Attempts to stop all actively executing tasks and halts the processing of waiting tasks according to the docs", "label": {"api": {"shutdownNow": [[22, 32]]}}}, {"text": "Assuming m is the Method instance corresponding to your method, then Modifier.isStatic(m.getModifiers()) will return true if and only if the method is static, so you can do this check before you actually call invoke", "label": {"api": {"Method": [[18, 23]], "Modifier": [[69, 76], [92, 99]]}}}, {"text": "If you don't already have the Method object, then something like Class's getMethod will be of use to you", "label": {"api": {"Method": [[30, 35], [76, 81]], "Class": [[65, 69]]}}}, {"text": "Docs on Method, Modifier, and Class", "label": {"api": {"Method": [[8, 13]], "Modifier": [[16, 23]], "Class": [[30, 34]]}}}, {"text": "I can not understand how the Synchronous Queue works", "label": {"api": {"Synchronous Queue": [[29, 45]]}}}, {"text": "Here's the formatting syntax guide for your reference", "label": {"api": {"formatting syntax guide": [[11, 33]]}}}, {"text": "The DataOutputStream is for writing primitive types", "label": {"api": {"DataOutputStream": [[4, 19]]}}}, {"text": "Apache telnet uses InputStream, which I want to read as a String (or String like data)", "label": {"api": {"read": [[48, 51]]}}}, {"text": "You can enumerate all threads in the current program via ThreadGroup, see for example this answer", "label": {"api": {"ThreadGroup": [[57, 67]]}}}, {"text": "The question comes to be whether there is some class or the like in Java to perform this task - I have gone unsuccessfully through some classes whose names suggested a possible solution, such as Runnable or Callable", "label": {"api": {"Runnable": [[195, 202]], "Callable": [[207, 214]]}}}, {"text": "More specifically, it expects a RFC 822 timezone identifier, which is usually 4 digits long", "label": {"api": {"RFC 822 timezone": [[32, 47]]}}}, {"text": "Not sure if a Vector with millions of elements is a good idea, but Vector implements List, and thus there is subList which provides a lightweight (non-copy) view of a section of the Vector", "label": {"api": {"subList": [[109, 115]]}}}, {"text": "The documentation of Thread#setDefaultUncaughtExceptionHandler explains the process", "label": {"api": {"Thread#setDefaultUncaughtExceptionHandler": [[21, 61]]}}}, {"text": "To me this looks like you want to use a JTable to layout Swing components much like using a HTML table to layout a page (which is not a good idea nowdays)", "label": {"api": {"JTable": [[40, 45]]}}}, {"text": "If this is true GridBagLayout (without using JSplitPanes) is your friend", "label": {"api": {"GridBagLayout": [[16, 28]], "JSplitPane": [[45, 54]]}}}, {"text": "If you want to have something like an Excel table you should use JTable", "label": {"api": {"JTable": [[65, 70]]}}}, {"text": "The best equivalent would probably be BigDecimal", "label": {"api": {"BigDecimal": [[38, 47]]}}}, {"text": "The HttpServletResponse.getHeaders method is almost certainly what you want to use", "label": {"api": {"HttpServletResponse.getHeaders method": [[4, 40]]}}}, {"text": "ArrayList.remove(index) removes the element from the array, not just the contents of the ArrayList, but it actually resizes your ArrayList as you remove items", "label": {"api": {"ArrayList.remove(index)": [[0, 22]]}}}, {"text": "I am trying to create a map of maps using the ConcurrentSkipListMap", "label": {"api": {"ConcurrentSkipListMap": [[46, 66]]}}}, {"text": "If I switch the definition to include a ConcurrentSkipListMap, its compiles with no problems", "label": {"api": {"ConcurrentSkipListMap": [[40, 60]]}}}, {"text": "There is also an easy way to adjust time within a week boundaries using TemporalAdjusters", "label": {"api": {"TemporalAdjusters": [[72, 88]]}}}, {"text": "You could try using the CriteriaBuilder like function instead of the CONTAINS function", "label": {"api": {"like": [[40, 43]]}}}, {"text": "There is one exception though, and that is the RuntimeException, for which you do not need to declare the throws exception part", "label": {"api": {"RuntimeException": [[47, 62]]}}}, {"text": "RuntimeException(and all of its subclasses) are called unchecked exceptions, after which you usually can not recover", "label": {"api": {"RuntimeException": [[0, 15]]}}}, {"text": "There is no single method that will do this, but you can do it quite easily if you iterate over the ArrayList and use the String.startsWith method to test whether the string starts with \"String1-\"", "label": {"api": {"String.startsWith": [[122, 138]]}}}, {"text": "Parse the XML as a Document with a DocumentBuilder", "label": {"api": {"Document": [[19, 26], [35, 42]], "DocumentBuilder": [[35, 49]]}}}, {"text": "If this is command line, then a Scanner might help", "label": {"api": {"Scanner": [[32, 38]]}}}, {"text": "XPath is probably a good start", "label": {"api": {"XPath": [[0, 4]]}}}, {"text": "There is also a Float class that you can use", "label": {"api": {"Float": [[16, 20]]}}}, {"text": "The Float object can be checked for null as its an object representation of a float data type", "label": {"api": {"Float": [[4, 8]]}}}, {"text": "A Float object is represented by a capitol F, and the float data type has a small f", "label": {"api": {"Float": [[2, 6]]}}}, {"text": "You can also pass a Float object into a method where a float data type is expected, or the other way around", "label": {"api": {"Float": [[20, 24]]}}}, {"text": "If checking for the default value doesnt work for whatever reason, this will allow you to check a Float for null", "label": {"api": {"Float": [[98, 102]]}}}, {"text": "In the component that draws the background, use the drawImage method that allows to specify a viewport, i.e, the sub-region of the full image that you want to draw (and which you call \"Window\" in your question)", "label": {"api": {"drawImage": [[52, 60]]}}}, {"text": "To be more precise, in SimpleDateFormat formats", "label": {"api": {"SimpleDateFormat": [[23, 38]]}}}, {"text": "Wed Aug contains the day and month in English so you must use an english locale with your SimpleDateFormat or the translation will fail", "label": {"api": {"SimpleDateFormat": [[90, 105]]}}}, {"text": "equals() by default compares references; and the references of two different objects (in this case t1 and t2) are unequal", "label": {"api": {"by default": [[9, 18]]}}}, {"text": "As a general rule, it's a good idea to override hashCode() whenever you override equals()", "label": {"api": {"hashCode()": [[48, 57]]}}}, {"text": "Introspection is intended for that purpose (see Introspector)", "label": {"api": {"Introspector": [[48, 59]]}}}, {"text": "You will need to inspect the method's parameter types, then adjust the arguments accordingly", "label": {"api": {"parameter types": [[38, 52]]}}}, {"text": "You can get the parameter types of a method by calling Method.html#getParameterTypes()", "label": {"api": {"Method.html#getParameterTypes()": [[55, 85]]}}}, {"text": "If you are dealing with just individual primitives, such as AtomicInteger, which has operations like compareAndSet, are great", "label": {"api": {"compareAndSet": [[101, 113]]}}}, {"text": "They are non-blocking and you can get a good deal of atomicity, and fall back to blocking locks when needed", "label": {"api": {"non-blocking": [[9, 20]]}}}, {"text": "For atomically setting accessing variables or objects, you can leverage non-blocking locks, falling back to traditional locks", "label": {"api": {"non-blocking": [[72, 83]]}}}, {"text": "Use the javax.swing.Timer with setRepeats set to false", "label": {"api": {"javax.swing.Timer": [[8, 24]], "setRepeats": [[31, 40]]}}}, {"text": "If you want to know when any existing component is added to a parent, you can add a HierarchyListener to it and listen for an event of type PARENT_CHANGED which is sent after the component is added to the parent", "label": {"api": {"PARENT_CHANGED": [[140, 153]]}}}, {"text": "If you want to know about the parent only after the component has been made visible, you can use an AncestorListener", "label": {"api": {"AncestorListener": [[100, 115]]}}}, {"text": "The   ancestorAdded(AncestorEvent) will be called every time the component is made visible", "label": {"api": {"ancestorAdded(AncestorEvent)": [[6, 33]]}}}, {"text": "For instance, an AncestorListener on a JPanel inside a JTabbedPane will get such an event every time the user selects that tab for display", "label": {"api": {"AncestorListener": [[17, 32]]}}}, {"text": "So you can use getResourceAsStream or getSystemResourceAsStream and pass the result of that to IOUtils.readLines to get a List<String> of the contents of your file", "label": {"api": {"getResourceAsStream": [[15, 33]], "getSystemResourceAsStream": [[38, 62]]}}}, {"text": "This is something that I would expect to exist in Java's InternetAddress class, but it doesn't break things down any further than the full address, which can include e.g", "label": {"api": {"InternetAddress": [[57, 71]]}}}, {"text": "When using TreeBasedTable, the implementation of rowMap() actually returns a SortedMap", "label": {"api": {"SortedMap": [[77, 85]]}}}, {"text": "From the Java SE 6 API documentation", "label": {"api": {"the Java SE 6 API documentation": [[5, 35]]}}}, {"text": "If you just want to wait for a certain length of time, Thread.sleep is the method you want", "label": {"api": {"Thread.sleep": [[55, 66]]}}}, {"text": "Because you have called a method that \"causes the current thread to wait until another thread ...\", and so isn't appropriate in the first place for a single-threaded application", "label": {"api": {"\"causes the current thread to wait until another thread ...\"": [[38, 97]]}}}, {"text": "you can use @PostConstruct annotation on some method", "label": {"api": {"@PostConstruct": [[12, 25]]}}}, {"text": "Using java.io.File imples a file system location, not a classpath entry", "label": {"api": {"java.io.File": [[6, 17]]}}}, {"text": "Encapsulate the Respnse in a FuturTask, there is a method get(long timeout, TimeUnit unit) to do that", "label": {"api": {"FuturTask": [[29, 37]], "get(long timeout, TimeUnit unit)": [[58, 89]]}}}, {"text": "You can use a JScrollPane to achieve this", "label": {"api": {"JScrollPane": [[14, 24]]}}}, {"text": "The contract for Comparable#compareTo does not require returning -1 or 1, just that the value of the returned int be negative or positive", "label": {"api": {"The contract for Comparable#compareTo": [[0, 36]]}}}, {"text": "You need to add the @Retention annotation on your annotation, setting the @Retention.value to RetentionPolicy.RUNTIME like this", "label": {"api": {"@Retention": [[20, 29], [74, 83]], "@Retention.value": [[74, 89]], "RetentionPolicy.RUNTIME": [[94, 116]]}}}, {"text": "The File class provides the exists() method, which returns true if the file exists", "label": {"api": {"exists()": [[28, 35]]}}}, {"text": "So --skipping the boring specifics-- I realized that a CallerPrincipalCallback(Subject s, Principal p) constructor is additionally available, which, when supplied with my custom Principal, causes the server to actually retain it, instead of wrapping it in or transforming it into an internal GlassFish implementation instance, as I previously thought it would", "label": {"api": {"CallerPrincipalCallback(Subject s, Principal p)": [[55, 101]]}}}, {"text": "An additional way to deal with this problem is by having the updates coming in from the updating thread go to a Queue or something similar", "label": {"api": {"Queue": [[112, 116]]}}}, {"text": "You can use System.nanoTime() in order to apply your updates using time deltas", "label": {"api": {"System.nanoTime()": [[12, 28]]}}}, {"text": "Create ByteArrayInputStream with our array and then feed it to converter", "label": {"api": {"ByteArrayInputStream": [[7, 26]]}}}, {"text": "If you're wanting to run a task periodically, use Timer#scheduleAtFixedRate", "label": {"api": {"Timer#scheduleAtFixedRate": [[50, 74]]}}}, {"text": "You are probably looking for something like waitForCardPresent(long timeout)", "label": {"api": {"waitForCardPresent(long timeout)": [[44, 75]]}}}, {"text": "Unbind the value before you try to set it", "label": {"api": {"Unbind": [[0, 5]]}}}, {"text": "These instances are created whenever you call ImageIO.createImageInputStream(stream) and the useCache flag is true (the default)", "label": {"api": {"useCache": [[93, 100]]}}}, {"text": "Throwing an exception is usually the way to go, and you should use UnsupportedOperationException", "label": {"api": {"UnsupportedOperationException": [[67, 95]]}}}, {"text": "The Java API itself does recommend this in the collections framework", "label": {"api": {"collections framework": [[47, 67]]}}}, {"text": "The \"destructive\" methods contained in this interface, that is, the methods that modify the collection on which they operate, are specified to throw UnsupportedOperationException if this collection does not support the operation", "label": {"api": {"UnsupportedOperationException": [[149, 177]]}}}, {"text": "You can also simply use Arrays.deepToString() (which uses loops internally)", "label": {"api": {"Arrays.deepToString()": [[24, 44]]}}}, {"text": "According to the URI javadoc the getPath method returns \"the decoded path component of this URI, or null if the path is undefined\" (emphasis added)", "label": {"api": {"URI javadoc": [[17, 27]]}}}, {"text": "You can sort based on the System.identityHashCode() value of each element in the list", "label": {"api": {"System.identityHashCode()": [[26, 50]]}}}, {"text": "You can implement a Comparator as follows", "label": {"api": {"Comparator": [[20, 29]]}}}, {"text": "Then, you can use Collections.sort()", "label": {"api": {"Collections.sort()": [[18, 35]]}}}, {"text": "From the notify (and notifyAll) docs", "label": {"api": {"From the notify (and notifyAll) docs": [[0, 35]]}}}, {"text": "As recommended by Marc, calling setOnCloseRequest or setOnHidden, is probably a better way to configure your EventHandler", "label": {"api": {"setOnCloseRequest": [[32, 48]], "setOnHidden": [[53, 63]]}}}, {"text": "Use a ByteArrayOutputStream and then call toString(charSet) - no need for a StringBuilder", "label": {"api": {"ByteArrayOutputStream": [[6, 26]]}}}, {"text": "You can use Scanner#hasNextInt() method for that", "label": {"api": {"Scanner#hasNextInt()": [[12, 31]]}}}, {"text": "Using Pattern.quote and putting it in square brackets seems to work", "label": {"api": {"Pattern.quote": [[6, 18]]}}}, {"text": "Try BigDecimal instead", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "You can keep the type as HttpURLConnection  instead of URLConnection", "label": {"api": {"HttpURLConnection": [[25, 41]]}}}, {"text": "String#split() takes a regex", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "valueOf takes a primitive long", "label": {"api": {"valueOf": [[0, 6]]}}}, {"text": "For literals, I'd agree that 42L is better, but if you have an int or long variable, Long.valueOf is a good way to get a Long", "label": {"api": {"valueOf": [[90, 96]]}}}, {"text": "valueOf also uses a cache of values from -128 to 127, which gives it a slight performance edge over new Long(long) for common values", "label": {"api": {"valueOf": [[0, 6]]}}}, {"text": "These two methods in  SwingWorker are confusing me at the moment, and it seems like it is very easy to use them incorrectly", "label": {"api": {"SwingWorker": [[22, 32]]}}}, {"text": "The method publish() describes the following", "label": {"api": {"publish()": [[11, 19]]}}}, {"text": "What this means to me is that while my worker thread is executing its doInBackground() method, I am able to create \"chunks\" (should these be anything specific or is this just a way to refer to message objects?), then publish them for processing on my Swing GUI", "label": {"api": {"doInBackground()": [[70, 85]]}}}, {"text": "That leads me to process()", "label": {"api": {"process()": [[17, 25]]}}}, {"text": "The publish() documentation states this", "label": {"api": {"publish()": [[4, 12]]}}}, {"text": "Who should be calling process()", "label": {"api": {"process()": [[22, 30]]}}}, {"text": "What is the workflow for process() in the context of the SwingWorker and the EDT", "label": {"api": {"SwingWorker": [[57, 67]], "process()": [[25, 33]]}}}, {"text": "The second parameter of String.substring(int, int) in Java isn't the length - it's the (exclusive) upper bound of the index", "label": {"api": {"String.substring(int, int)": [[24, 49]]}}}, {"text": "The <cookie-config> is introduced in Servlet 3.0 and not supported in older versions such as 2.5", "label": {"api": {"introduced": [[23, 32]]}}}, {"text": "For example, the following Serializable type does not provide any field metadata and its internals are written as blockdata", "label": {"api": {"Serializable": [[27, 38]]}}}, {"text": "If the API has javadoc it should provide some information as part of the serialized form documentation", "label": {"api": {"serialized form": [[73, 87]]}}}, {"text": "Using JPanel as an example, you can override its paintComponent() method", "label": {"api": {"JPanel": [[6, 11]], "paintComponent()": [[49, 64]]}}}, {"text": "String#split() method takes a String, and ',' is a character", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "Also keep in mind HashMap allows null as key, so if you set key as null, this is a valid key", "label": {"api": {"HashMap allows null as key": [[18, 43]]}}}, {"text": "The only difference between these methods is that replacePattern passes the DOTALL option and replaceAll doesn't", "label": {"api": {"DOTALL option": [[76, 88]]}}}, {"text": "First of all, these jars are intended for situations where your project has dependencies out of your control, and these dependencies make use of JUL (java.util.logging), JCL (Jakarta Commons Logging) or log4j and you would like to route all logging operations through the slf4j-api", "label": {"api": {"java.util.logging": [[150, 166]]}}}, {"text": "A handler is any class that extends java.util.logging.Handler and is meant to handle (guess what) logging messages (or records in JUL terminology)", "label": {"api": {"java.util.logging": [[36, 52]]}}}, {"text": "For tasks like that, consider using a SwingWorker", "label": {"api": {"SwingWorker": [[38, 48]]}}}, {"text": "You can find some information on how to use SwingWorker here, should you need it", "label": {"api": {"SwingWorker": [[44, 54]]}}}, {"text": "split() works with regular expressions, and", "label": {"api": {"split()": [[0, 6]], "split": [[0, 4]]}}}, {"text": "Furthermore, the reason the resulting array is empty is because split() discards trailing empty strings (you can have it keep empty strings by providing a negative second argument, however)", "label": {"api": {"split()": [[64, 70]], "split": [[64, 68]]}}}, {"text": "This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero", "label": {"api": {"split": [[53, 57]]}}}, {"text": "By contrast, contains() works with literal strings, so a", "label": {"api": {"contains()": [[13, 22]]}}}, {"text": "You are better off using Blocking Queue than reinventing the wheel", "label": {"api": {"Blocking Queue": [[25, 38]]}}}, {"text": "java.util.concurrent.ConcurrentLinkedQueue is a non-blocking, lock-free queue implementation", "label": {"api": {"java.util.concurrent.ConcurrentLinkedQueue": [[0, 41]]}}}, {"text": "This is outlined in the documentation of Formatter (see Format String Syntax)", "label": {"api": {"Formatter": [[41, 49]], "Format String Syntax": [[56, 75]]}}}, {"text": "If you don't need any particular value for the unique codes, you should know that Enum.ordinal() exists, which returns the zero-based index of the constant in the order it was defined", "label": {"api": {"Enum.ordinal()": [[82, 95]]}}}, {"text": "There is an implementation of this function suitable for when you need to deserialize into any ParameterizedType (e.g., any List), which is fromJson(JsonElement json, Type typeOfT)", "label": {"api": {"ParameterizedType": [[95, 111]], "List": [[124, 127]], "Type": [[108, 111], [167, 170]]}}}, {"text": "In your case, you just need to get the Type of a List<String> and then parse the JSON array into that Type, like this", "label": {"api": {"List": [[49, 52]], "Type": [[39, 42], [102, 105]], "String": [[54, 59]]}}}, {"text": "In your case yourJson is a JsonElement, but it could also be a String, any Reader or a JsonReader", "label": {"api": {"String": [[63, 68]], "Reader": [[75, 80], [91, 96]]}}}, {"text": "Looking at the Java documentation page for Pattern, it seems that you can use this regex to filter by any punctuation", "label": {"api": {"Pattern": [[43, 49]]}}}, {"text": "The reason you're getting NumberFormatException is laid out in the documentation", "label": {"api": {"in the documentation": [[60, 79]]}}}, {"text": "The method paint(Graphics g) is defined in java.awt.Component", "label": {"api": {"java.awt.Component": [[43, 60]]}}}, {"text": "You have to invoke Object#getClass() on b reference to get the anonymous class, where the method is declared", "label": {"api": {"Object#getClass()": [[19, 35]]}}}, {"text": "And then use Class#getDeclaredMethod() to get the private method", "label": {"api": {"Class#getDeclaredMethod()": [[13, 37]]}}}, {"text": "Use String#split()  method", "label": {"api": {"String#split()": [[4, 17]]}}}, {"text": "You can use Map#containsKey() method to check whether values in the first map is the key in the 2nd map", "label": {"api": {"Map#containsKey()": [[12, 28]]}}}, {"text": "You get that using Map#entrySet()", "label": {"api": {"Map#entrySet()": [[19, 32]]}}}, {"text": "Since the values of the first map is the key in your second, you need to use the containsKey method on the Map.Entry#getValue() method", "label": {"api": {"Map.Entry#getValue()": [[107, 126]]}}}, {"text": "You have to use the overloaded constructor - LinkedHashMap(Map) for that", "label": {"api": {"LinkedHashMap(Map)": [[45, 62]]}}}, {"text": "You can use Map#entrySet() method to iterate over each entry in map2", "label": {"api": {"Map#entrySet()": [[12, 25]]}}}, {"text": "You would then use Map.Entry#getKey() and Map.Entry#getValue() methods to get the key and value respectively for each entry", "label": {"api": {"Map.Entry#getKey()": [[19, 36]], "Map.Entry#getValue()": [[42, 61]]}}}, {"text": "You can use Map#putAll() method to merge the two maps", "label": {"api": {"Map#putAll()": [[12, 23]]}}}, {"text": "When I receive an HttpServletRequest I get ServletInputStream and read the request body with readLine line by line", "label": {"api": {"HttpServletRequest": [[18, 35]], "ServletInputStream": [[43, 60]]}}}, {"text": "You can use IntStream.iterate() to get the index", "label": {"api": {"IntStream.iterate()": [[12, 30]]}}}, {"text": "If you look at the javadoc for the Set interface, you will see (emphasis mine)", "label": {"api": {"the javadoc for the Set interface": [[15, 47]]}}}, {"text": "You can use a LinkedHashSet", "label": {"api": {"LinkedHashSet": [[14, 26]], "HashSet": [[20, 26]], "Set": [[24, 26]]}}}, {"text": "If the order of elements does not matter, you should use a normal HashSet instead", "label": {"api": {"HashSet": [[66, 72]], "Set": [[70, 72]]}}}, {"text": "In fact, if it's logical to do so, you might consider using a Set instead of a List in the first place", "label": {"api": {"Set": [[62, 64]], "List": [[79, 82]]}}}, {"text": "When they change, they should then call setChanged() and then notifyObservers()", "label": {"api": {"setChanged()": [[40, 51]], "notifyObservers()": [[62, 78]]}}}, {"text": "And just for your information, you have an Arrays#sort(Object[]) method, which does the sorting for you", "label": {"api": {"Arrays#sort(Object[])": [[43, 63]]}}}, {"text": "Split the String to extract the number - See String#split", "label": {"api": {"String#split": [[45, 56]]}}}, {"text": "Convert the first String (Here I assume that the format is fixed) using Double#parseDouble", "label": {"api": {"Double#parseDouble": [[72, 89]]}}}, {"text": "Use DecimalFormat to truncate the number", "label": {"api": {"DecimalFormat": [[4, 16]]}}}, {"text": "You can either return an IllegalArgumentException with a message saying that empty array is not allowed as the argument, or you can define your own custom error class", "label": {"api": {"IllegalArgumentException": [[25, 48]]}}}, {"text": "Method Runtime.availableProcessors() shows the number of cores", "label": {"api": {"Runtime.availableProcessors()": [[7, 35]]}}}, {"text": "The first argument to the List#set(int, E) method is the index in the list, where you want to set the value passed as 2nd argument", "label": {"api": {"List#set(int, E)": [[26, 41]]}}}, {"text": "Collections#swap method take indices for swapping", "label": {"api": {"Collections#swap": [[0, 15]]}}}, {"text": "Simply use addActionListener on your MenuItems", "label": {"api": {"addActionListener": [[11, 27]]}}}, {"text": "Here you have a complete example i really like with progressBar , see setProgress() publish() and process()", "label": {"api": {"setProgress()": [[70, 82]], "publish()": [[84, 92]], "process()": [[98, 106]]}}}, {"text": "When you use setProgress() it's a bound property you can take approach of observer pattern you can register a listener, then when this method is called gets fired and you catch and can update your progressBar and also you decouple components", "label": {"api": {"setProgress()": [[13, 25]]}}}, {"text": "As brano88 has stated, the simplest way to achieve this is by using BorderLayout", "label": {"api": {"BorderLayout": [[68, 79]]}}}, {"text": "As BorderLayout is the default layout manager for a JFrame, you do not need to explicitly set it, just use its fields out of the box", "label": {"api": {"BorderLayout": [[3, 14]]}}}, {"text": "Consider perhaps using AtomicInteger", "label": {"api": {"AtomicInteger": [[23, 35]]}}}, {"text": "I have a long-running calculation that I have split up with Java's ForkJoinTask", "label": {"api": {"Java's ForkJoinTask": [[60, 78]]}}}, {"text": "Java's FutureTask provides a template method done()", "label": {"api": {"Java's FutureTask": [[0, 16]]}}}, {"text": "I think you mean \"lock free\" programming http://en.wikipedia.org/wiki/Non-blocking_algorithm", "label": {"api": {"http://en.wikipedia.org/wiki/Non-blocking_algorithm": [[41, 91]]}}}, {"text": "For adding values or counting completion counts have a look at java.util.concurrent.atomic", "label": {"api": {"java.util.concurrent.atomic": [[63, 89]]}}}, {"text": "StringBuilder#substring(int) is declared as", "label": {"api": {"StringBuilder#substring(int)": [[0, 27]]}}}, {"text": "As simple as  using the method renameTo() in File class", "label": {"api": {"renameTo()": [[31, 40]]}}}, {"text": "For moving it", "label": {"api": {"moving it": [[4, 12]]}}}, {"text": "In practice, it means you will never get a ClassCastException when dealing with generics", "label": {"api": {"ClassCastException": [[43, 60]]}}}, {"text": "Modify Paint to implement Serializable", "label": {"api": {"Serializable": [[26, 37]]}}}, {"text": "Write your own Serializable wrapper for Paint that keeps Serializable copies of the key fields, and delegates functionality to a private transient Paint, and can re-initialize the Paint instance after deserialization", "label": {"api": {"Serializable": [[15, 26], [57, 68]]}}}, {"text": "You have to invoke either Matcher#find() or Matcher#matches() to actually get the matches", "label": {"api": {"Matcher#find()": [[26, 39]], "Matcher#matches()": [[44, 60]]}}}, {"text": "What you can do is creating another instance of the Iterator", "label": {"api": {"Iterator": [[52, 59]]}}}, {"text": "Unlike ResultSet we cannot go to the first with Iterator", "label": {"api": {"Iterator": [[48, 55]]}}}, {"text": "Open the FileOutputStream in append mode", "label": {"api": {"append mode": [[29, 39]]}}}, {"text": "I suggest using some of the built-in implementations of the Map interface", "label": {"api": {"Map": [[60, 62]]}}}, {"text": "Like, for instance, HashMap, in which the courseName will be a key and the Counse will be a corresponding value", "label": {"api": {"Map": [[24, 26]], "HashMap": [[20, 26]]}}}, {"text": "Another solution is using String.lastIndexOf and String.substring as there is no need for regex", "label": {"api": {"String.lastIndexOf": [[26, 43]], "String.substring": [[49, 64]]}}}, {"text": "http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/MultivaluedMap.html (no addAll method)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/MultivaluedMap.html": [[0, 71]]}}}, {"text": "http://docs.oracle.com/javaee/7/api/javax/ws/rs/core/MultivaluedMap.html (this one includes the addAll method)", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/ws/rs/core/MultivaluedMap.html": [[0, 71]]}}}, {"text": "The Iterable interface wasn't added until Java 5 (1.5), with the introduction of the enhanced for loop", "label": {"api": {"Iterable": [[4, 11]]}}}, {"text": "You could map the desired part to memory and then work on it using java.nio.FileChannel", "label": {"api": {"java.nio.FileChannel": [[67, 86]]}}}, {"text": "You probably want the Java Service Provider Interface", "label": {"api": {"Service Provider Interface": [[27, 52]]}}}, {"text": "The first parameter of DefaultTableModel(Vector, Vector) is meant to be the data", "label": {"api": {"DefaultTableModel(Vector, Vector)": [[23, 55]]}}}, {"text": "According to the constructor documentation you have to pass the content as first and the header data as second parameter", "label": {"api": {"the constructor documentation": [[13, 41]]}}}, {"text": "If you know you're going to be explicitly working with primitive types then use DataStreams, otherwise go with the more generic ObjectStreams which implement the DataInput interface as well as ObjectInput interface so can work with primitives as well as objects", "label": {"api": {"DataInput interface": [[162, 180]], "ObjectInput interface": [[193, 213]]}}}, {"text": "Just use the remove() method for this", "label": {"api": {"remove()": [[13, 20]]}}}, {"text": "You can use List#subList(int, int)", "label": {"api": {"List#subList(int, int)": [[12, 33]]}}}, {"text": "Yes, you can create the array using Array#newInstance() method", "label": {"api": {"Array#newInstance()": [[36, 54]]}}}, {"text": "Or use the builtin Arrays", "label": {"api": {"Arrays": [[19, 24]]}}}, {"text": "According to the java.net.URL API doc at http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#URL(java.lang.String)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#URL(java.lang.String)": [[41, 120]]}}}, {"text": "In AWT, there is a method setUndecorated()", "label": {"api": {"setUndecorated()": [[26, 41]]}}}, {"text": "File#listFiles takes a FileFilter which can be used to determine if certain files should be included or not in the listing returne by File#listFiles..", "label": {"api": {"File#listFiles": [[0, 13], [134, 147]], "FileFilter": [[23, 32]]}}}, {"text": "If you want to make the process more dynamic, you could pass a list of FileFilters to the copy method and then use  a special FileFilter to iterate over them..", "label": {"api": {"FileFilter": [[71, 80], [126, 135]]}}}, {"text": "The List.add(Object) method will put the item at the end, but List.add(int, Object) will let you specify the position", "label": {"api": {"List.add(Object)": [[4, 19]], "List.add(int, Object)": [[62, 82]]}}}, {"text": "From there you can use String#toCharArray to get an array of characters that represent the String", "label": {"api": {"String#toCharArray": [[23, 40]]}}}, {"text": "You will need to loop through this array and use Character.isUpperCase to determine the case of the given character", "label": {"api": {"Character.isUpperCase": [[49, 69]]}}}, {"text": "The documentation for the overflow states", "label": {"api": {"documentation for the overflow": [[4, 33]]}}}, {"text": "Use String.split(String regex)", "label": {"api": {"String.split(String regex)": [[4, 29]]}}}, {"text": "String#split accepts a regex", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "If you don't want to escape the special char +, you can use Pattern#quote", "label": {"api": {"Pattern#quote": [[60, 72]]}}}, {"text": "Java-8 provides java.util.Base64 class for Base64 encodings", "label": {"api": {"java.util.Base64": [[16, 31]]}}}, {"text": "I'd create a GeneralPath or a Path2D, both of which implement Shape", "label": {"api": {"GeneralPath": [[13, 23]], "Path2D": [[30, 35]]}}}, {"text": "This tutorial explains how to use GeneralPath, which is very similar to Path2D", "label": {"api": {"GeneralPath": [[34, 44]], "Path2D": [[72, 77]]}}}, {"text": "If you are parsing the XML with Java SAX (tutorial), getting the attributes is doable by utilizing the attributes object in the startElement() callback", "label": {"api": {"startElement()": [[128, 141]]}}}, {"text": "Attributes are fairly easy to manipulate - if you know the name of the attribute you want, fetching it is a matter of simply calling getValue()", "label": {"api": {"Attributes": [[0, 9]], "getValue()": [[133, 142]]}}}, {"text": "If you use HttpServletRequest.getSession(false), then a HttpSession object does not get created, if it is invalid", "label": {"api": {"HttpServletRequest.getSession(false)": [[11, 46]]}}}, {"text": "So I think if you want to use the AjaxServlet for your Java client you would need to construct a HttpServletRequest similar to the way the javascript is creating a XMLHttpRequest", "label": {"api": {"HttpServletRequest": [[97, 114]]}}}, {"text": "I was able to get at StackTraceElement objects (http://docs.oracle.com/javase/7/docs/api/java/lang/StackTraceElement.html) for each frame as returned by Thread.getStackTrace() (http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#getStackTrace%28%29), but this class doesn't expose the detail that I need", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/StackTraceElement.html": [[48, 120]], "http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#getStackTrace%28%29": [[177, 258]]}}}, {"text": "InputStream.read(byte[] b, int off, int len) will read bytes into the given byte[], up to len, and return the number of bytes actually read or -1 if the end of the stream is encountered", "label": {"api": {"InputStream.read(byte[] b, int off, int len)": [[0, 43]]}}}, {"text": "Better switch to using ProcessBuilder", "label": {"api": {"ProcessBuilder": [[23, 36]]}}}, {"text": "You can also use the subList(int fromIndex, int toIndex) to break them", "label": {"api": {"subList(int fromIndex, int toIndex)": [[21, 55]]}}}, {"text": "You can add an event filter to the scene with addEventFilter()", "label": {"api": {"addEventFilter()": [[46, 61]]}}}, {"text": "Probably this requires a BigInteger", "label": {"api": {"BigInteger": [[25, 34]]}}}, {"text": "The value that you're attempting to parse is much bigger than the biggest allowable int value (Integer.MAX_VALUE, or 2147483647), so a NumberFormatException is thrown", "label": {"api": {"Integer.MAX_VALUE": [[95, 111]]}}}, {"text": "It is bigger than the biggest allowable long also (Long.MAX_VALUE, or 9223372036854775807L), so you'll need a BigInteger to store that value", "label": {"api": {"Long.MAX_VALUE": [[51, 64]]}}}, {"text": "From BigInteger Javadocs", "label": {"api": {"BigInteger Javadocs": [[5, 23]]}}}, {"text": "I'm sure the border is merely illustrative, but note that the API authors, \"recommend that you put the component in a JPanel and set the border on the JPanel.\" In particular, the green border obscures part of the first table row", "label": {"api": {"API authors": [[62, 72]]}}}, {"text": "You can use Byte.parseByte() with a radix of 2", "label": {"api": {"Byte.parseByte()": [[12, 27]]}}}, {"text": "You can directly use System.getEnv(String) method", "label": {"api": {"System.getEnv(String)": [[21, 41]]}}}, {"text": "You should StringBuilder class instead", "label": {"api": {"StringBuilder": [[11, 23]]}}}, {"text": "You could use a SwingWorker for this", "label": {"api": {"SwingWorker": [[16, 26]]}}}, {"text": "Follow this link to see a complete example with progressBar , special attention to setProgress() publish() and process()", "label": {"api": {"setProgress()": [[83, 95]], "publish()": [[97, 105]], "process()": [[111, 119]]}}}, {"text": "You need to either use Scanner.hasNextInt() to test if the next token is an integer or catch and diagnose the exception that is thrown by Scanner.nextInt() when it can't read an int", "label": {"api": {"Scanner.hasNextInt()": [[23, 42]], "Scanner.nextInt()": [[138, 154]]}}}, {"text": "Events effecting the contents of the combo box are generated by the model", "label": {"api": {"model": [[68, 72]]}}}, {"text": "Try attaching a ListDataListener to the model itself", "label": {"api": {"model": [[40, 44]], "ListDataListener": [[16, 31]]}}}, {"text": "If you are worried about being notified when/if the model changes, you would need to attach a PropertyChangeListener to the JComboBox and monitor for the model property and update your data listeners accordingly..", "label": {"api": {"model": [[52, 56], [154, 158]]}}}, {"text": "You might consider Joda Time or Java 8, which has a type called LocalTime specifically for a time of day without a date component", "label": {"api": {"Java 8": [[32, 37]]}}}, {"text": "Example code in Joda-Time 2.7/Java 8", "label": {"api": {"Java 8": [[30, 35]]}}}, {"text": "To match the expected output, use StringBuilder and append to the string to match the ordering", "label": {"api": {"StringBuilder": [[34, 46]]}}}, {"text": "In the above example I used String.format syntax just to show another way to format your output", "label": {"api": {"String.format syntax": [[28, 47]]}}}, {"text": "You can use of Arrays#sort method to find max or min number in the array", "label": {"api": {"Arrays#sort": [[15, 25]]}}}, {"text": "But it is possible to load a class without initializing it (for example by using the three-argument Class.forName() variant)", "label": {"api": {"the three-argument Class.forName() variant": [[81, 122]]}}}, {"text": "A solution could be explore the ResultSetMetaData and iterate over all columns", "label": {"api": {"ResultSetMetaData": [[32, 48]]}}}, {"text": "You can read these resources using Class#getResource or Class#getResourceAsInputStream depending on your needs", "label": {"api": {"Class#getResource": [[35, 51], [56, 72]], "Class#getResourceAsInputStream": [[56, 85]]}}}, {"text": "You can use a StreamTokenizer", "label": {"api": {"StreamTokenizer": [[14, 28]]}}}, {"text": "According to documentation of KeyEvent, KeyPressed and KeyReleased are low-level methods", "label": {"api": {"KeyEvent": [[30, 37]]}}}, {"text": "For this I guess you need to use Apache Camel.As using camel only for this purpose is not justice as it is a integration pattern but you can use it as it will make your work easy.Define a route and it will make the WATCH OF LOOKING FILE after every 5 mins.Otherwise you need to write your own threads or work with Timer.You can find a good example of using timer here", "label": {"api": {"Timer": [[314, 318]]}}}, {"text": "Hence you will NOT get UnsupportedOperationException when you try to remove elements from the list", "label": {"api": {"UnsupportedOperationException": [[23, 51]]}}}, {"text": "The you might get NullPointerException when you try to operate on the phone object", "label": {"api": {"NullPointerException": [[18, 37]]}}}, {"text": "Consider using the Preferences API", "label": {"api": {"Preferences API": [[19, 33]]}}}, {"text": "Use a StringBuilder", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "You can use Scanner class for reading user input in console application", "label": {"api": {"Scanner": [[12, 18]]}}}, {"text": "If your application isn't distributed, then you can easily use a synchronized static method or a static ReentrantLock instance to control the synchronization", "label": {"api": {"ReentrantLock": [[104, 116]]}}}, {"text": "The algorithm is only efficient on lists implementing RandomAccess", "label": {"api": {"RandomAccess": [[54, 65]]}}}, {"text": "To prevent misuse and disappointing performance, I'm wondering how to enforce the RandomAccess restriction", "label": {"api": {"RandomAccess": [[82, 93]]}}}, {"text": "The RandomAccess interface does not extend List unfortunately, so I sort of need to make the variable be two types at once", "label": {"api": {"RandomAccess": [[4, 15]]}}}, {"text": "I could declare the method to accept ArrayList rather than List, but other list types can implement RandomAccess too (for example, the lists returned by Collections.synchronizedList and Collections.checkedList), and I don't want to block those", "label": {"api": {"RandomAccess": [[100, 111]]}}}, {"text": "AbstractMethodError is thrown when the JVM tries to invoke an abstract method (which is not allowed)", "label": {"api": {"AbstractMethodError": [[0, 18]]}}}, {"text": "Use StringTokenizer to tokenize the String into constituent words", "label": {"api": {"StringTokenizer": [[4, 18]]}}}, {"text": "You could do this by implementing JTables using java swing", "label": {"api": {"JTables": [[34, 40]]}}}, {"text": "The string representation of a PriorityQueue does not reflect anything about the order of elements within it, it is solely based on the iteration order of the queue's iterator() (this is how toString() is defined in AbstractCollection, and PriorityQueue uses this implementation as well)", "label": {"api": {"iterator()": [[167, 176]]}}}, {"text": "This is a very hard problem, and is similar in nature to the security sandbox imposed on Java applets", "label": {"api": {"security sandbox": [[61, 76]], "Java applets": [[89, 100]]}}}, {"text": "Take a look at the RequestDispatcher class and its forward() method", "label": {"api": {"RequestDispatcher": [[19, 35]]}}}, {"text": "You could also use javas inbuilt String formatting to reduce the need for manual calculation if you know how wide you want to display your columns, but it will truncate long values, e.g", "label": {"api": {"String formatting": [[33, 49]]}}}, {"text": "As per the documentation of AccessibleObject#setAccessible(boolean) method", "label": {"api": {"AccessibleObject#setAccessible(boolean)": [[28, 66]]}}}, {"text": "I think you can use KeyEvent.isXXXDown methods, for instance", "label": {"api": {"KeyEvent.isXXXDown": [[20, 37]]}}}, {"text": "You may want to try again (for educational purposes) with the DSYNC options set for when you open your FileOutputStreams using the new-to-Java7 Files.newOutputStream(...) with the DSYNC OpenOption", "label": {"api": {"Files.newOutputStream(...)": [[144, 169]], "DSYNC OpenOption": [[180, 195]]}}}, {"text": "In ahother hand, you need to use a constant of java.util.regex.Pattern for avoid recompiled the expression every time, something like that", "label": {"api": {"java.util.regex.Pattern": [[47, 69]]}}}, {"text": "In another way, use a instance of java.util.ArrayList with an initial capacity already defined, according to the number of strings that may exist, so that the list should not be required copy the elements to a new internal array", "label": {"api": {"java.util.ArrayList": [[34, 52]]}}}, {"text": "For completeness, you could also use a cached thread pool to avoid repeated creation of short-lived Threads", "label": {"api": {"cached thread pool": [[39, 56]]}}}, {"text": "When you get to Java 7, you might find that Fork-Join is a better pattern than a series of Futures", "label": {"api": {"Fork-Join": [[44, 52]]}}}, {"text": "You should use PersistenceException to catch exception .Because you are using JPA", "label": {"api": {"PersistenceException": [[15, 34]]}}}, {"text": "See the javadoc for SimpleDateFormat for more info about formatting codes", "label": {"api": {"See the javadoc for SimpleDateFormat": [[0, 35]]}}}, {"text": "Reading a socket and writing a file may be done with byte buffer or better with ByteBuffer", "label": {"api": {"ByteBuffer": [[80, 89]]}}}, {"text": "Rewriting the code using java.nio.channels may be better", "label": {"api": {"java.nio.channels": [[25, 41]]}}}, {"text": "Put your own ErrorListener on your Transformer instance using Transformer.setErrorListener, like so", "label": {"api": {"ErrorListener": [[13, 25], [77, 89]], "Transformer.setErrorListener": [[62, 89]]}}}, {"text": "You can use ConcurrentTaskScheduler, or implement something like it using DelayQueue", "label": {"api": {"DelayQueue": [[74, 83]]}}}, {"text": "You have to tell it the input/output format, you can do that based on this description (you can also find a few common examples there)", "label": {"api": {"on this description": [[67, 85]]}}}, {"text": "Use a TreeMap", "label": {"api": {"TreeMap": [[6, 12]]}}}, {"text": "You should use a TreeMap instead, if you want to sort your keys", "label": {"api": {"TreeMap": [[17, 23]]}}}, {"text": "Here, you will need to pass custom Comparator, which will compare based on value in your property file", "label": {"api": {"Comparator": [[35, 44]]}}}, {"text": "The comparator compares each key in the TreeMap based on it's index in the order string", "label": {"api": {"TreeMap": [[40, 46]]}}}, {"text": "Now just pass this comparator to the overloaded TreeMap constructor", "label": {"api": {"TreeMap": [[48, 54]], "TreeMap constructor": [[48, 66]]}}}, {"text": "Read more about Linked List in Java", "label": {"api": {"Read more about Linked List in Java": [[0, 34]]}}}, {"text": "The popup location is relative to the parent component", "label": {"api": {"relative to the parent component": [[22, 53]]}}}, {"text": "There are better alternatives like Calendar and TimerTasks, but if you want to manage with dates, you can use something like", "label": {"api": {"Calendar": [[35, 42]], "TimerTasks": [[48, 57]]}}}, {"text": "It is \"never correct to use the return value of this method to allocate a buffer intended to hold all data in this stream.\" (quote from InputStream JavaDoc)", "label": {"api": {"quote from InputStream JavaDoc": [[125, 154]]}}}, {"text": "You can also check the Arrays utility", "label": {"api": {"Arrays": [[23, 28]]}}}, {"text": "One solution is to implement the observer pattern via Observer interface and Observable class", "label": {"api": {"Observer": [[54, 61]], "Observable": [[77, 86]]}}}, {"text": "You can restrict (round) the decimal part by using BigDecimal.setScale", "label": {"api": {"BigDecimal": [[51, 60]]}}}, {"text": "Check the JavaDoc from BigDecimal for further information", "label": {"api": {"BigDecimal": [[23, 32]]}}}, {"text": "If you use a standardized RPC (Remote Procedure Call) protocol (such as SOAP or JSON-RPC), the most elegant way to handle this would be to use a Proxy with an InvocationHandler which does the request marshalling and response unmarshalling in a generic way, allowing you to cheaply create remote service proxies", "label": {"api": {"Proxy": [[145, 149]]}}}, {"text": "You need to make your object Cloneable and override clone() method for a deep copy", "label": {"api": {"Cloneable": [[29, 37]]}}}, {"text": "You can call ResultSet.getMetaData to get the ResultSet's metadata", "label": {"api": {"ResultSet.getMetaData": [[13, 33]]}}}, {"text": "That contains a ResultSetMetaData.getColumnCount method that tells you how many columns the ResultSet has", "label": {"api": {"ResultSetMetaData.getColumnCount": [[16, 47]]}}}, {"text": "Code sponsored by Arrays.toString() and Arrays.sort()", "label": {"api": {"Arrays.toString()": [[18, 34]], "Arrays.sort()": [[40, 52]]}}}, {"text": "matches any character except newline (\\n) (unless you use DOTALL mode)", "label": {"api": {"DOTALL": [[58, 63]]}}}, {"text": "Use the ordinal() method", "label": {"api": {"ordinal() method": [[8, 23]]}}}, {"text": "defaultUncaughtExceptionHandler, but it only triggers if the Thread doesn't have a uncaughtExceptionHandler set", "label": {"api": {"defaultUncaughtExceptionHandler": [[0, 30]], "uncaughtExceptionHandler": [[83, 106]]}}}, {"text": "If you want to compare whole arrays then equal() method works with different length also", "label": {"api": {"equal()": [[41, 47]]}}}, {"text": "Integer#parseInt(String str, int radix) does the job", "label": {"api": {"Integer#parseInt(String str, int radix)": [[0, 38]]}}}, {"text": "Here, ^ starts the line, the <span style=\"color:blue;\">&lt;p&gt;</span> is matched literally, we then have one or more non-line-terminator characters", "label": {"api": {"non-line-terminator characters": [[119, 148]]}}}, {"text": "See System.nanoTime(), which recommends t1 - t0 < 0, not t1 < t0 for time comparison..", "label": {"api": {"System.nanoTime()": [[4, 20]]}}}, {"text": "I prefer to use the Java Random Class", "label": {"api": {"Java Random Class": [[20, 36]]}}}, {"text": "You can consider using a TreeSet if you need ordered, sorted Set", "label": {"api": {"TreeSet": [[25, 31]]}}}, {"text": "There is also a LinkedHashSet for an ordered Set that is not sorted", "label": {"api": {"LinkedHashSet": [[16, 28]]}}}, {"text": "A HashSet as per the documentation does not guarantee any concept of order, so what you're seeing could very well change in a future update of Java", "label": {"api": {"HashSet": [[2, 8]]}}}, {"text": "However, if you're wondering why Java's (as of now) specific implementation of HashSet produces the result you're seeing", "label": {"api": {"HashSet": [[79, 85]]}}}, {"text": "it's because the Integer of value 1 hashes to a location in the internal entry table of a HashMap that comes before the location to which 2 hashes (note that a HashSet is really backed by a HashMap with arbitrary values)", "label": {"api": {"HashSet": [[160, 166]]}}}, {"text": "Iteration over a HashSet takes place by iterating over the internal entry table, which means items earlier in the table come first", "label": {"api": {"HashSet": [[17, 23]]}}}, {"text": "Just use SimpleDateFormat (click me to see all format patterns)", "label": {"api": {"click me": [[27, 34]]}}}, {"text": "One takes a single size value, and returns a single dimension array — Array.newInstance(Class<?>, int)", "label": {"api": {"Array.newInstance(Class<?>, int)": [[70, 101]]}}}, {"text": "The other takes a variable number of size values and returns a multiple dimension array — Array.newInstance(Class<?>, int...)", "label": {"api": {"Array.newInstance(Class<?>, int...)": [[90, 124]]}}}, {"text": "You can use any implementation of the List interface", "label": {"api": {"List": [[38, 41]]}}}, {"text": "Consider using Cipher#update(byte[], int, int, byte[], int) instead of doFinal() for multipart operations", "label": {"api": {"Cipher#update(byte[], int, int, byte[], int)": [[15, 58]]}}}, {"text": "If you are not using any AOP framework, you can use Java Dynamic Proxy to call class methods", "label": {"api": {"Java Dynamic Proxy": [[52, 69]]}}}, {"text": "@Target uses ElementType[], and ElementType is an enum, so you can't modify it", "label": {"api": {"@Target": [[0, 6]], "ElementType": [[13, 23], [32, 42]]}}}, {"text": "The getClass() method will return the runtime type of file, and then you can get the method for that class using Class#getMethod() method", "label": {"api": {"getClass()": [[4, 13]], "Class#getMethod()": [[113, 129]]}}}, {"text": "I would try to put the file in the jar as a resource, retrieve an inputstream to it with Class.getResourceAsStream() and write the stream to a File", "label": {"api": {"Class.getResourceAsStream()": [[89, 115]]}}}, {"text": "See Collections#sort(List<T> list)", "label": {"api": {"Collections#sort(List<T> list)": [[4, 33]]}}}, {"text": "It helps you to sort any list of T which implements Comparable", "label": {"api": {"Comparable": [[52, 61]]}}}, {"text": "If your class does not implement Comparable, you can provide a Comparator and call static void <T> sort(List<T> list, Comparator<", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "As it implements Comparable, you can sort a list like this", "label": {"api": {"Comparable": [[17, 26]]}}}, {"text": "Place the strings directly into a HashSet<String> rather than an array and iterate through the file using contains on the set to check the content", "label": {"api": {"contains": [[106, 113]]}}}, {"text": "You can use | for multiple characters (X|Y means \"Either X or Y\")", "label": {"api": {"\"Either X or Y\"": [[49, 63]]}}}, {"text": "Directly from this API", "label": {"api": {"API": [[19, 21]]}}}, {"text": "I have a PriorityBlockingQueue<Shirts> that uses a FIFO (first in first out) comparator in addition to other custom conditions", "label": {"api": {"PriorityBlockingQueue<Shirts>": [[9, 37]]}}}, {"text": "To quote from the ReentrantLock.tryLock() Javadocs", "label": {"api": {"ReentrantLock.tryLock() Javadocs": [[18, 49]]}}}, {"text": "You may have some success with isOther() in the NIO2 Files API", "label": {"api": {"isOther()": [[31, 39]]}}}, {"text": "More information on leniency can be found in the Java documentation", "label": {"api": {"in the Java documentation": [[42, 66]]}}}, {"text": "In native code (C/C++) \"accept()\" blocks - I'm not sure if this is the case in Java but you can use it to your advantage here", "label": {"api": {"lock": [[35, 38]]}}}, {"text": "I used callback functions (not sure if there is anything like this in Java) and non-blocking operations on the server side so that I didn't have to have a dedicated thread for each client", "label": {"api": {"lock": [[85, 88]]}}}, {"text": "Given that you're using threads you're going to want to lock around important data", "label": {"api": {"lock": [[56, 59]]}}}, {"text": "A precompiled Pattern can be used for greater performance", "label": {"api": {"Pattern": [[14, 20]]}}}, {"text": "1024 -> 2 KB) in the constructor for java.io.StringWriter", "label": {"api": {"java.io.StringWriter": [[37, 56]]}}}, {"text": "So I implemented my own methods to display an info/warning message using a Popup", "label": {"api": {"Popup": [[75, 79]]}}}, {"text": "Just some tweaks to show the Popup centered on the window, use CSS and hide when the user clicks on it", "label": {"api": {"Popup": [[29, 33]]}}}, {"text": "As far as modifying the BufferedImage, I would suggest looping through the width and height (representing the x and y) and get the RGB of each pixel at row,column using BufferedImage#getRGB(int, int) and modify the color and set the color at that location using BufferedImage#setRGB(int, int, int)", "label": {"api": {"BufferedImage#getRGB(int, int)": [[169, 198]], "BufferedImage#setRGB(int, int, int)": [[262, 296]]}}}, {"text": "From the Collections.shuffle documentation", "label": {"api": {"Collections.shuffle": [[9, 27]]}}}, {"text": "XAConnection comes from the latter, not from the JDBC JARs you included", "label": {"api": {"XAConnection comes from the latter": [[0, 33]]}}}, {"text": "You can annotate a field with the @Transient annotation to denote to the JPA implementation that it should not be persisted in the database", "label": {"api": {"@Transient": [[34, 43]]}}}, {"text": "Read the documentation, although this would be a bit irrelevant to your question", "label": {"api": {"Read the documentation": [[0, 21]]}}}, {"text": "You may want to see how System.out.println(java.lang.Object) behaves", "label": {"api": {"You may want to see how": [[0, 22]], "behaves": [[61, 67]]}}}, {"text": "This method calls at first String.valueOf(x) to get the printed object's string value, then behaves as though it invokes print(String) and then println()", "label": {"api": {"behaves": [[92, 98]]}}}, {"text": "If there is no reason to do it that way, use the com.google.gwt.user.client.ui.FileUpload widget on the client, and make a simple HttpServlet on the backend to accept the files", "label": {"api": {"HttpServlet": [[130, 140]]}}}, {"text": "The constructor for Byte requires a byte if you're constructing it like that, and the same is true for the constructor of Short", "label": {"api": {"Byte": [[20, 23]], "Short": [[122, 126]]}}}, {"text": "You could use System.arraycopy for this purpose too, no need for this lenghty code (the indexes might be off, and of course it would dies with improper number argument)", "label": {"api": {"System.arraycopy": [[14, 29]]}}}, {"text": "You can use Pattern.quote()", "label": {"api": {"Pattern.quote()": [[12, 26]]}}}, {"text": "Then you could either use the method Vector.contains() before inserting a new object in your vector or use a Set which is by definition a collection without duplicates", "label": {"api": {"Vector.contains()": [[37, 53]]}}}, {"text": "If your need is to clean up things, to close a log file, to send some alert, or take some other action when the Java Virtual Machine is shutting down especially if someone presses CTRL+C and shutdown the VM, or sends a kill signal in Unix/Linux, then you must look at ShutdownHook", "label": {"api": {"ShutdownHook": [[268, 279]]}}}, {"text": "Javascript is not supported in the default HTML editor kit used by the editor pane", "label": {"api": {"HTML editor kit": [[43, 57]]}}}, {"text": "For a much simpler sound, look to Toolkit.beep()", "label": {"api": {"Toolkit.beep()": [[34, 47]]}}}, {"text": "If the other programs aren't Java, but have good support for SOAP, create a WSDL (including XML schema) to represent the notification message(s), and have the tray app call Endpoint.create to listen for SOAP messages from other programs", "label": {"api": {"Endpoint.create": [[173, 187]]}}}, {"text": "In Java 6 or later you can use Arrays.copyOfRange method that takes the original array, the initial index (inclusive), and the last index (exclusive), and returns a copy of the specified range", "label": {"api": {"Arrays.copyOfRange": [[31, 48]]}}}, {"text": "You can use Arrays.copyOfRange to copy array from index to another index", "label": {"api": {"Arrays.copyOfRange": [[12, 29]]}}}, {"text": "The repaints should be triggered from a Swing based Timer, which ensures that GUI updates are called on the EDT", "label": {"api": {"Timer": [[52, 56]]}}}, {"text": "One possible solution is to split the String according to whitespaces", "label": {"api": {"split": [[28, 32]]}}}, {"text": "If you want to int value, you should use Integer#parseInt", "label": {"api": {"Integer#parseInt": [[41, 56]]}}}, {"text": "Another solution is using lastIndexOf and substring.", "label": {"api": {"lastIndexOf": [[26, 36]], "substring": [[42, 50]]}}}, {"text": "I am aware that it's possible to set the owner of a file using Files.setOwner", "label": {"api": {"Files.setOwner": [[63, 76]]}}}, {"text": "If your app is working on POSIX systems exclusively, there's PosixFileAttributeView.setGroup()", "label": {"api": {"PosixFileAttributeView.setGroup()": [[61, 93]]}}}, {"text": "You should use an appropriate List implementation if you need such behavior", "label": {"api": {"List": [[30, 33]]}}}, {"text": "If you want to access the elements by name, you can also use a Map", "label": {"api": {"Map": [[63, 65]]}}}, {"text": "As specified in List interface documentation, it will be shifted to the left", "label": {"api": {"List interface documentation": [[16, 43]]}}}, {"text": "So have a look at the Java Lock class", "label": {"api": {"Lock class": [[27, 36]]}}}, {"text": "As comments have suggested, a fixed-size ArrayList or Arrays::asList is a simple and efficient option if you can tolerate a fixed-size list", "label": {"api": {"ArrayList": [[41, 49]], "Arrays::asList": [[54, 67]]}}}, {"text": "Suppose I have one repeated task which is going to process HttpSession or HttpServletRequest or HttpServletResponse object", "label": {"api": {"HttpSession": [[59, 69]], "HttpServletRequest": [[74, 91]], "HttpServletResponse": [[96, 114]]}}}, {"text": "This processing may be abstract some data from HttpSession or set/get some attributes in HttpServletRequest/HttpServletResponse", "label": {"api": {"HttpSession": [[47, 57]], "HttpServletRequest": [[89, 106]], "HttpServletResponse": [[108, 126]]}}}, {"text": "Use URL.openConnection(Proxy) followed by URLConnection.getInputStream()", "label": {"api": {"URL.openConnection(Proxy)": [[4, 28]], "URLConnection.getInputStream()": [[42, 71]]}}}, {"text": "Check the documentation of Serializable", "label": {"api": {"Serializable": [[27, 38]]}}}, {"text": "ArrayIndexOutOfBoundsException is a RuntimeException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[0, 29]]}}}, {"text": "You cannot add/remove elements of collections while iterating on it, except if you iterate via an Iterator", "label": {"api": {"Iterator": [[98, 105]]}}}, {"text": "See Collection#iterator() to get an iterator on your Map", "label": {"api": {"Collection#iterator()": [[4, 24]]}}}, {"text": "See Iterator#remove() to see how to remove elements from a Collection while iterating on it", "label": {"api": {"Iterator": [[4, 11]], "Iterator#remove()": [[4, 20]]}}}, {"text": "The iterators returned by this class's iterator and listIterator methods are fail-fast", "label": {"api": {"Iterator": [[56, 63]]}}}, {"text": "Here, we can see that when instantiated ( with Collection#iterator() ), the iterator initializes a expectedModCount (modCount = modification count)", "label": {"api": {"Collection#iterator()": [[47, 67]]}}}, {"text": "it does not implement RandomAccess), then using an Iterator (or an enhanced for-loop, which uses an Iterator internally) instead of a traditional for-loop is usually much more efficient", "label": {"api": {"RandomAccess": [[22, 33]]}}}, {"text": "The most notable List that doesn't implement RandomAccess is the LinkedList", "label": {"api": {"RandomAccess": [[45, 56]]}}}, {"text": "In addtion, instead of creating a new ArrayList, you can use ArrayList#set()", "label": {"api": {"ArrayList#set()": [[61, 75]]}}}, {"text": "But, the methods getParent and parentProperty are final, there is no standard way to prevent a node from accessing to its parent", "label": {"api": {"getParent": [[17, 25]], "parentProperty": [[31, 44]]}}}, {"text": "As described on the documentation for InputStream, subclasses of InputStream must only implement public abstract int read(), however keep in mind it will also most probably be necessary to overwrite other methods too", "label": {"api": {"documentation for InputStream": [[20, 48]]}}}, {"text": "You can look up more details in the Java Docu for ArrayList.toArray()", "label": {"api": {"Java Docu for ArrayList.toArray()": [[36, 68]]}}}, {"text": "I am trying to make a button that, when multiple rows in a TableView are selected, all of the selected rows are removed", "label": {"api": {"TableView": [[59, 67]]}}}, {"text": "The recursive folder discovery is implemented as a Consumer @FunctionalInterface", "label": {"api": {"Consumer": [[51, 58]]}}}, {"text": "You may use the Runtime.addShutdownHook method, which can be used to add a jvm shutdown hook", "label": {"api": {"Runtime.addShutdownHook": [[16, 38]]}}}, {"text": "Are you specifying the right charset in the Scanner constructor", "label": {"api": {"Scanner constructor": [[44, 62]]}}}, {"text": "Ideally you shouldn't even be trying wait or notify when you have so many excellent libraries available in java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[107, 126]]}}}, {"text": "A better way of getting the value would be getting all the network interfaces (http://docs.oracle.com/javase/6/docs/api/java/net/NetworkInterface.html#getNetworkInterfaces()) and filtering out the ones whose IP begins with 127", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/net/NetworkInterface.html#getNetworkInterfaces()": [[79, 172]]}}}, {"text": "The copy method, maybe leaving the close to the callers, could at least call flush() in that case", "label": {"api": {"copy": [[4, 7]]}}}, {"text": "In Java 7 there already exists a copy, but needs a Path and an extra option", "label": {"api": {"copy": [[33, 36]]}}}, {"text": "If you decide to give XML a chance then you will need to call Properties#loadFromXML(InputStream) to load your XML property file", "label": {"api": {"Properties#loadFromXML(InputStream)": [[62, 96]]}}}, {"text": "You can find the full specification of Java Properties files in the Javadoc documentation for the load(java.io.Reader reader) method of the java.util.Properties class", "label": {"api": {"load(java.io.Reader reader) method of the java.util.Properties": [[98, 159]]}}}, {"text": "If you're interested in an alternative approach, you could create a Map mapping the numbers to their indexes", "label": {"api": {"Map": [[68, 70]]}}}, {"text": "It's definitely possible to extract it from Class#getGenericSuperclass() because it's not defined during runtime, but during compiletime by FooDao extends BaseDao<Foo>", "label": {"api": {"Class#getGenericSuperclass()": [[44, 71]]}}}, {"text": "You likely want matches()", "label": {"api": {"matches()": [[16, 24]]}}}, {"text": "Since this is conceptual and it's hard to nail down an exact answer, I'd recommend reading about Locks and Conditions http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Condition.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Condition.html": [[118, 199]]}}}, {"text": "Integer.parseInt(str) throws NumberFormatException if the string does not contain a parsable integer", "label": {"api": {"Integer.parseInt(str)": [[0, 20]]}}}, {"text": "For signing a hash on the client side in Java, you could use a Signature algorithm like NONEwithRSA instead of one like SHA256withRSA", "label": {"api": {"Signature": [[63, 71]]}}}, {"text": "Read the documentation of Sting#split", "label": {"api": {"Sting#split": [[26, 36]]}}}, {"text": "Use String#substring and String#indexOf", "label": {"api": {"String#substring": [[4, 19]], "String#indexOf": [[25, 38]]}}}, {"text": "You could consider using a JTextArea instead of a JTextField", "label": {"api": {"JTextArea": [[27, 35]]}}}, {"text": "The showMessageDialog method returns void when the user closes or clicks ok", "label": {"api": {"showMessageDialog": [[4, 20]]}}}, {"text": "But you can use the method JOptionPane.showOptionDialog with a single DEFAULT_OPTION for the OK button", "label": {"api": {"JOptionPane.showOptionDialog": [[27, 54]]}}}, {"text": "You can do this using the indexOf method of strings to find the next comma, then manually splitting", "label": {"api": {"indexOf": [[26, 32]]}}}, {"text": "If you want to \"translate\" the mention of A to any method call, then the closest you could get is not loadClass() but Class.forName()", "label": {"api": {"Class.forName()": [[118, 132]]}}}, {"text": "It will simply return a fully loaded (and initialized, if you don't use the three-argument version) class back to the caller", "label": {"api": {"the three-argument version": [[72, 97]]}}}, {"text": "You need ServletContext.getRealPath(String) method", "label": {"api": {"ServletContext.getRealPath(String)": [[9, 42]]}}}, {"text": "The BlockingQueue will be your \"to do\" list, where the Producer will place data (the byte[]) as it becomes available and the Consumer retrieves data(the byte[]) from the queue when it is ready to work with the data", "label": {"api": {"BlockingQueue": [[4, 16]]}}}, {"text": "You need to call hasNextInt() method on Scanner object instead of String object s", "label": {"api": {"Scanner": [[40, 46]]}}}, {"text": "From the Javadoc for @AroundIvoke", "label": {"api": {"@AroundIvoke": [[21, 32]]}}}, {"text": "Have a look at the Scanner API, and perhaps the Java Tutorial on Objects", "label": {"api": {"Scanner API": [[19, 29]]}}}, {"text": "You can use printf() -- the %f specifier works for BigDecimals too", "label": {"api": {"printf()": [[12, 19]]}}}, {"text": "One way is to use the ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[22, 48]]}}}, {"text": "This last technique should also work if using WatchService.poll(...) or WatchService.take()", "label": {"api": {"WatchService.poll(...)": [[46, 67]], "WatchService.take()": [[72, 90]]}}}, {"text": "You just have to use either the write(byte[]) or write(byte[],int,int) methods from the FileOutputStream class", "label": {"api": {"write(byte[])": [[32, 44]], "write(byte[],int,int)": [[49, 69]]}}}, {"text": "You can use File.separator to get a system-dependent file separator", "label": {"api": {"File.separator": [[12, 25]]}}}, {"text": "Then you should use Class.getResource(String name) or Class.getResourceAsStream(String name)", "label": {"api": {"Class.getResource(String name)": [[20, 49]], "Class.getResourceAsStream(String name)": [[54, 91]]}}}, {"text": "Java's split method expects a regex which describes the \"separator\" string, not the strings you want to be left over", "label": {"api": {"split": [[7, 11]]}}}, {"text": "By the same token, if a separator string does occur at the beginning or end, split will not return an empty string for either of those cases", "label": {"api": {"split": [[77, 81]]}}}, {"text": "As mentioned in another answer, the javadocs for Color may help you here", "label": {"api": {"javadocs for Color": [[36, 53]]}}}, {"text": "While luis.espinal answer, performance-wise, is better I think you should also take a look into Iterator's as they will give you greater flexibility reading back-and-forth", "label": {"api": {"Iterator's": [[96, 105]]}}}, {"text": "When you call Scanner(InputStream), that will use the platform default encoding to convert the bytes from the stream into text", "label": {"api": {"Scanner(InputStream)": [[14, 33]]}}}, {"text": "I suspect you're just looking for System.currentTimeMillis()", "label": {"api": {"System.currentTimeMillis()": [[34, 59]]}}}, {"text": "Also note that if you're trying to measure elapsed time, you should look at using System.nanoTime() instead", "label": {"api": {"System.nanoTime()": [[82, 98]]}}}, {"text": "Usa a CountDownLatch (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html) and trigger it once your checking thread has finished", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html": [[22, 102]]}}}, {"text": "One example would be a local class implementing Runnable/Callable and then being sent to an ExecutorService or ScheduledExecutorService e.g.", "label": {"api": {"Runnable": [[48, 55]], "Callable": [[57, 64]], "ExecutorService": [[92, 106], [120, 134]], "ScheduledExecutorService": [[111, 134]]}}}, {"text": "As you can see, the MailSendingRunnable will live after the method returns because the method run in MailSendingRunnable will be called later in another thread as the ExecutorService.submit(Runnable) method states", "label": {"api": {"Runnable": [[31, 38], [112, 119], [190, 197]], "ExecutorService": [[167, 181]], "ExecutorService.submit(Runnable)": [[167, 198]]}}}, {"text": "One option would be to call setFollowRedirects(false)", "label": {"api": {"setFollowRedirects(false)": [[28, 52]]}}}, {"text": "iterate over all SQLWarning to check if some settings has been changed by JDBC-ODBC Bridge driver", "label": {"api": {"SQLWarning": [[17, 26]]}}}]