[{"text": "If this is a Swing GUI then a Swing Timer (javax.swing.Timer), or if not, then a Utilities Timer (java.util.Timer) or a ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[120, 146]]}}}, {"text": "If you implement a ServletContextListener you can initialize your init class just as the server starts", "label": {"api": {"ServletContextListener": [[19, 40]]}}}, {"text": "ServletContextListener has a contextInitialized(javax.servlet.ServletContextEvent) method which gets called when the server starts, which you can override to initialize your init class", "label": {"api": {"ServletContextListener": [[0, 21]]}}}, {"text": "ServletContextListener has a contextDestroyed(javax.servlet.ServletContextEvent) which gets called when the server stops, and you can override it to close your port", "label": {"api": {"ServletContextListener": [[0, 21]]}}}, {"text": "You can use XMLInputFactory.createXMLStreamReader, passing in a StringReader to wrap your string", "label": {"api": {"XMLInputFactory.createXMLStreamReader": [[12, 48]], "StringReader": [[64, 75]]}}}, {"text": "The API states, that this method only throws a NPE, if the key is null", "label": {"api": {"API": [[4, 6]]}}}, {"text": "Use String#trim method prior to calling equals", "label": {"api": {"String#trim": [[4, 14]]}}}, {"text": "In order to insert the JLabel (Which is a Component)", "label": {"api": {"JLabel": [[23, 28]]}}}, {"text": "the java classes Uri and URLEncoder provide the necessary methods", "label": {"api": {"Uri": [[17, 19]], "URLEncoder": [[25, 34]]}}}, {"text": "The java Date object is intentionally timezone-agnostic and supposed to represent GMT times (it internally stores its value as milliseconds since January 1, 1970, 00:00:00 GMT)", "label": {"api": {"java Date object": [[4, 19]]}}}, {"text": "To convert a Date object to or from strings representing it in the timezone of the user, use a SimpleDateFormat on which you called the setTimeZone method with the users TimeZone (the static method TimeZone.getDefault() gives you the time zone of the local system)", "label": {"api": {"SimpleDateFormat": [[95, 110]], "setTimeZone": [[136, 146]], "TimeZone": [[139, 146], [170, 177], [198, 205]], "TimeZone.getDefault()": [[198, 218]]}}}, {"text": "I hope to [learn] why the setAlignmentY() is being ignored", "label": {"api": {"setAlignmentY()": [[26, 40]]}}}, {"text": "In the API, note that setAlignmentX() \"Sets the the vertical alignment,\" and setAlignmentY() \"Sets the the horizontal alignment.\" In this context, vertical means the vertical axis of a top-to-bottom layout, such as BoxLayout.Y_AXIS, while horizontal means the horizontal axis of a left-to-right layout, such as BoxLayout.X_AXIS", "label": {"api": {"setAlignmentX()": [[22, 36]], "setAlignmentY()": [[77, 91]]}}}, {"text": "In a left-to-right layout, pictured below, setAlignmentY() is used to adjust vertical positioning relative to the horizontal layout axis", "label": {"api": {"setAlignmentY()": [[43, 57]]}}}, {"text": "In a top-to-bottom layout, such as yours, setAlignmentY() simply has no effect", "label": {"api": {"setAlignmentY()": [[42, 56]]}}}, {"text": "What you are trying to do will make every Servlet have its own ApplicationContext instance", "label": {"api": {"Servlet": [[42, 48]]}}}, {"text": "The appropriate way to do this is to setup your ApplicationContext in a ServletContextListener", "label": {"api": {"Servlet": [[72, 78]], "ServletContextListener": [[72, 93]]}}}, {"text": "Now all your servlets have access to the same ApplicationContext through the ServletContext attributes", "label": {"api": {"Servlet": [[77, 83]]}}}, {"text": "When you need only the characters from your input, use a InputStreamReader for example", "label": {"api": {"InputStreamReader": [[57, 73]]}}}, {"text": "As per the Javadoc entry, the the readLine () method is deprecated, and you should use a BufferedReader instead", "label": {"api": {"Javadoc entry": [[11, 23]]}}}, {"text": "But you may create the array with the right type by changing the constructor using java.lang.reflect.Array", "label": {"api": {"java.lang.reflect.Array": [[83, 105]]}}}, {"text": "You should implement the communication using SocketChannel", "label": {"api": {"SocketChannel": [[45, 57]]}}}, {"text": "See SocketChannel for more information about it", "label": {"api": {"SocketChannel": [[4, 16]]}}}, {"text": "As channels are fairly different to streams, here is a short Tutorial on SocketChannels with a small example to start from", "label": {"api": {"SocketChannel": [[73, 85]]}}}, {"text": "Date has before and after methods", "label": {"api": {"Date": [[0, 3]], "before": [[9, 14]], "after": [[20, 24]]}}}, {"text": "If you find that you need more control, you can use DecimalFormat which has many more formatting options", "label": {"api": {"DecimalFormat": [[52, 64]]}}}, {"text": "This sounds like a job for StringTokenizer", "label": {"api": {"StringTokenizer": [[27, 41]]}}}, {"text": "You would need to use reflection this case (specially this method)", "label": {"api": {"this case": [[33, 41]], "this method": [[54, 64]]}}}, {"text": "Scanner provides an easy way to walk through the file", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "You can use a BufferedReader to do that", "label": {"api": {"BufferedReader": [[14, 27]]}}}, {"text": "In your case, it would be List<Integer>", "label": {"api": {"List": [[26, 29]]}}}, {"text": "List is an interface", "label": {"api": {"List": [[0, 3]]}}}, {"text": "You need to instantiate a class that implements it, a common option is ArrayList", "label": {"api": {"List": [[76, 79]], "ArrayList": [[71, 79]]}}}, {"text": "List / ArrayList are not in the java.lang package, so you have to import them by including the appropriate import statements at the top of your file (under the package declaration, if there is any)", "label": {"api": {"List": [[0, 3], [12, 15]], "ArrayList": [[7, 15]]}}}, {"text": "Look at using the javax.swing.text.Utilities class, especially the getRowStart(...) and getRowEnd(...) methods", "label": {"api": {"javax.swing.text.Utilities": [[18, 43]]}}}, {"text": "you can test you connection is valid or not with Connection#isValid(int timeout) returns true if the connection has not been closed and is still valid", "label": {"api": {"Connection#isValid(int timeout)": [[49, 79]]}}}, {"text": "You can catch SQLException from DriverManager.getConnection() and looks for ORA-12543", "label": {"api": {"SQLException": [[14, 25]]}}}, {"text": "Read SQLException documentation about vendor code", "label": {"api": {"SQLException": [[5, 16]]}}}, {"text": "Since split takes a regex, you can use | (OR operator)", "label": {"api": {"split": [[6, 10]]}}}, {"text": "BTW, even though the Javadoc specifies that executeQuery never returns null, using executeQuery on a statement you know is not a query is a bad practice", "label": {"api": {"executeQuery": [[44, 55], [83, 94]]}}}, {"text": "If you have a way of assigning values to elements stored in queue, which can be used for their ordering than you can use a PriorityBlockingQueue instead of the SynchronizedQueue", "label": {"api": {"PriorityBlockingQueue": [[123, 143]]}}}, {"text": "The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time", "label": {"api": {"Comparator": [[92, 101]]}}}, {"text": "For example, you can store the id of the producer in the element and have a Comparator which knows how to compare between the producer ids", "label": {"api": {"Comparator": [[76, 85]]}}}, {"text": "Now, you can use a PriorityBlockingQueue instead of your SynchronizedQueue, and implement the Comparator interface in the PriorityP class", "label": {"api": {"PriorityBlockingQueue": [[19, 39]], "Comparator": [[94, 103]]}}}, {"text": "rsData.next() changes the cursor position", "label": {"api": {"rsData.next()": [[0, 12]]}}}, {"text": "You can use RescaleOp to brighten the image prior to conversion, or pass an instance along with your image to the drawImage method that takes a BufferedImageOp as parameter", "label": {"api": {"drawImage": [[114, 122]]}}}, {"text": "There is a casting exception here saying database field is BigInteger, but object property is long", "label": {"api": {"BigInteger": [[59, 68]]}}}, {"text": "BigInteger is a special class to hold unlimited size integer values", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "Furthermore, BigInteger can not cast to long implicitly", "label": {"api": {"BigInteger": [[13, 22]]}}}, {"text": "To avoid this error database field which is BigInteger should be change to long compatible type", "label": {"api": {"BigInteger": [[44, 53]]}}}, {"text": "The better solution is using a NumberFormat to handle this", "label": {"api": {"NumberFormat": [[31, 42]]}}}, {"text": "I am trying to understand how case sensitive order should really work using Java Collator", "label": {"api": {"Java Collator": [[76, 88]]}}}, {"text": "Java does not support preprocessing operations in regular expressions", "label": {"api": {"regular expressions": [[50, 68]]}}}, {"text": "In the javadoc of java.text.SimpleDateFormat, you can read that (for the X letter)", "label": {"api": {"java.text.SimpleDateFormat": [[18, 43]]}}}, {"text": "Other than the solution posted by @McMonster, you could also make sure that your POJO's override the toString() method so that you can print a customized, and most likely, more readable string representation of your object", "label": {"api": {"toString()": [[101, 110]]}}}, {"text": "Use java.lang.Enum.valueOf(Class<T> enumType, String name)", "label": {"api": {"java.lang.Enum.valueOf(Class<T> enumType, String name)": [[4, 57]]}}}, {"text": "Note that this method throws an IllegalArgumentException for unknown values", "label": {"api": {"IllegalArgumentException": [[32, 55]]}}}, {"text": "There is before(Date) and after(Date) method in Date Class", "label": {"api": {"Date": [[16, 19], [32, 35], [48, 51]]}}}, {"text": "The List interface doesn't provide such feature and I know of no commonly available implementation providing it", "label": {"api": {"List interface": [[4, 17]]}}}, {"text": "If that's not the case, you'll need to use reflection to find the Constructor instance you need, and then invoke it with the appropriate arguments", "label": {"api": {"use reflection": [[39, 52]], "Constructor": [[66, 76]]}}}, {"text": "In your GUI class, simply instantiate LineNumberTextArea and give it the JTextArea instance to attach to", "label": {"api": {"JTextArea": [[73, 81]]}}}, {"text": "Finally add a DocumentListener for your JTextArea to update the line numbers when the document changes", "label": {"api": {"DocumentListener": [[14, 29]], "JTextArea": [[40, 48]]}}}, {"text": "On this element you can call getMethodName, getLineNumber, and the like", "label": {"api": {"the like": [[63, 70]]}}}, {"text": "You probably shouldn't be using split() here but instead a Matcher", "label": {"api": {"Matcher": [[59, 65]]}}}, {"text": "Lastly, after you fix those two, if you know that the words are going to be delimited by spaces, then you might want to look at the String.split function", "label": {"api": {"String.split": [[132, 143]]}}}, {"text": "If you know you're dealing with a NumberFormat, there's probably no good reason to", "label": {"api": {"Format": [[40, 45]]}}}, {"text": "However, if you're in the unusual situation of only knowing about Format, then you don't know what kind of value you're parsing to, and parseObject is all there is", "label": {"api": {"Format": [[66, 71]]}}}, {"text": "Personally I don't remember ever using just plain Format on its own, but I suppose if you're in the general \"parsing and formatting\" business (e.g", "label": {"api": {"Format": [[50, 55]]}}}, {"text": "Note how the MediaTracker API example waits in a background thread", "label": {"api": {"MediaTracker": [[13, 24]]}}}, {"text": "Java sockets can also be created using an InetAddress, which is the preferred method because in many cases your server won't have it's name registered with the DNS", "label": {"api": {"InetAddress": [[42, 52]]}}}, {"text": "For brevity I recommend to use Scanner class", "label": {"api": {"Scanner": [[31, 37]]}}}, {"text": "Yes, you can use the List interface and wrap inside your new class an ArrayList", "label": {"api": {"List": [[21, 24], [75, 78]], "ArrayList": [[70, 78]]}}}, {"text": "The official documentation describes the AbstractList as follows", "label": {"api": {"official documentation": [[4, 25]]}}}, {"text": "Yes, Java has a File class", "label": {"api": {"File": [[16, 19]]}}}, {"text": "You can create one by calling this constructor which takes a String", "label": {"api": {"this constructor": [[30, 45]]}}}, {"text": "The maximal value for your int variable i is 2^31-1", "label": {"api": {"2^31-1": [[45, 50]]}}}, {"text": "I think UnsupportedOperationException is the best fit", "label": {"api": {"UnsupportedOperationException": [[8, 36]]}}}, {"text": "From the java doc of the EntityManager.find() method", "label": {"api": {"EntityManager.find()": [[25, 44]]}}}, {"text": "To refresh the entity, simply call refresh(entity)", "label": {"api": {"refresh(entity)": [[35, 49]]}}}, {"text": "You can use the String#replaceAll(String regex, String replacement) method", "label": {"api": {"String#replaceAll(String regex, String replacement)": [[16, 66]]}}}, {"text": "for more details see the java docs", "label": {"api": {"the java docs": [[21, 33]]}}}, {"text": "You need to call SimpleDateFormat#setTimeZone to set specific timezones", "label": {"api": {"SimpleDateFormat#setTimeZone": [[17, 44]]}}}, {"text": "Also, have a look at the java.util.concurrent.lock package", "label": {"api": {"java.util.concurrent.lock": [[25, 49]]}}}, {"text": "Have a look at the class BigInteger", "label": {"api": {"BigInteger": [[25, 34]]}}}, {"text": "Also you can use BigInteger or BigDouble", "label": {"api": {"BigInteger": [[17, 26]], "BigDouble": [[31, 39]]}}}, {"text": "Your class must implement MouseListener inorder to use mouseClicked()", "label": {"api": {"MouseListener": [[26, 38]], "mouseClicked()": [[55, 68]]}}}, {"text": "In the official docs of Oracle you will find the right way", "label": {"api": {"docs of Oracle": [[16, 29]]}}}, {"text": "You could use a simple CountDownLatch", "label": {"api": {"CountDownLatch": [[23, 36]]}}}, {"text": "One way of going about this would be to take the integer in as a String", "label": {"api": {"String": [[65, 70]]}}}, {"text": "You can then use toCharArray() in order to grab an array of the characters - these characters can then be individually parsed into Integer by utilizing Character.getNumericValue()", "label": {"api": {"Character": [[152, 160]]}}}, {"text": "See the String and Character APIs for more details on those methods", "label": {"api": {"String": [[8, 13]], "Character": [[19, 27]]}}}, {"text": "The method List#remove(java.lang.Object) is in your case not suitable for the type boolean (autoboxed to Boolean), the type which contains() returns", "label": {"api": {"List#remove(java.lang.Object)": [[11, 39]]}}}, {"text": "Look at String.replaceAll for that", "label": {"api": {"String.replaceAll": [[8, 24]]}}}, {"text": "You can't do this reliably; some InputStreams (such as ones connected to terminals or sockets) don't support mark and reset (see markSupported)", "label": {"api": {"markSupported": [[129, 141]]}}}, {"text": "To get a guarantee, you must first call markSupported(), and it must return true", "label": {"api": {"markSupported()": [[40, 54]]}}}, {"text": "The preferred method for converting a character digit to the corresponding int value is by using the digit() method", "label": {"api": {"digit()": [[101, 107]]}}}, {"text": "Since you are using double coordinates, you can use a Rectangle.Double to do all the heavy lifting", "label": {"api": {"Rectangle.Double": [[54, 69]]}}}, {"text": "You can have the same result using Collections#unmodifiableList(..)", "label": {"api": {"Collections#unmodifiableList(..)": [[35, 66]]}}}, {"text": "The type Scanner does not have a readLine() method", "label": {"api": {"Scanner": [[9, 15]]}}}, {"text": "Did you mean to use nextLine()", "label": {"api": {"nextLine()": [[20, 29]]}}}, {"text": "Explanation in Scanner.nextLine() JavaDoc will explain what you want", "label": {"api": {"Scanner.nextLine() JavaDoc": [[15, 40]]}}}, {"text": "Now, I would be taking a peek at the KeyBoardFocusManager#getFocusOwner and back tracking it's container hierarcy when ever focusLost is called to try and determine if the component who now has focus is a child of mine..", "label": {"api": {"KeyBoardFocusManager#getFocusOwner": [[37, 70]]}}}, {"text": "The Method#invoke has the answer to your question", "label": {"api": {"Method#invoke": [[4, 16]]}}}, {"text": "You can use a List implementation like ArrayList if you don't know how many elements your array will have", "label": {"api": {"List": [[14, 17], [44, 47]], "ArrayList": [[39, 47]]}}}, {"text": "Check out the List documentation (linked above) to see what APIs are available", "label": {"api": {"List": [[14, 17]]}}}, {"text": "You can do the whole thing in one step with a TreeSet", "label": {"api": {"TreeSet": [[46, 52]]}}}, {"text": "By the way, you might want to use replace() instead, since you're not dealing with regular expressions", "label": {"api": {"replace()": [[34, 42]]}}}, {"text": "Another way would be using AtomicLong, and use incrementAndGet()", "label": {"api": {"AtomicLong": [[27, 36]]}}}, {"text": "It is also not a bad idea to take a look how some 'default' java components are designed and implemented for example take a look at http://docs.oracle.com/javase/6/docs/api/javax/swing/JOptionPane.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/swing/JOptionPane.html": [[132, 200]]}}}, {"text": "Scanner#next() method reads the next token", "label": {"api": {"Scanner#next()": [[0, 13]]}}}, {"text": "And the default delimiter of Scanner is as recognized by Character.isWhitespace", "label": {"api": {"Character.isWhitespace": [[57, 78]]}}}, {"text": "It is always good to test beforehand if the string contains a #(in this case), just use String#contains()", "label": {"api": {"String#contains()": [[88, 104]]}}}, {"text": "That Scanner is using the String constructor, not the File constructor", "label": {"api": {"String constructor": [[26, 43]]}}}, {"text": "What you need is a Set", "label": {"api": {"Set": [[19, 21]]}}}, {"text": "Java has a Set class that does that job", "label": {"api": {"Set": [[11, 13]]}}}, {"text": "the element loadOnStartup with value greater or equal to zero, 0), you need put the code in a init method or in the constructor of the servlet", "label": {"api": {"loadOnStartup": [[12, 24]]}}}, {"text": "I know that DatabaseMetadata.getColumns() allows a null catalog (the first argument)", "label": {"api": {"DatabaseMetadata.getColumns()": [[12, 40]]}}}, {"text": "Inside each process, you can handle several threads if you need some concurrency", "label": {"api": {"threads": [[44, 50]]}}}, {"text": "If you absolutely need various distinct java processes in your application, you can use ProcessBuilder and Process to start a new child process, corresponding to a new JVM instance", "label": {"api": {"ProcessBuilder": [[88, 101]], "Process": [[88, 94], [107, 113]]}}}, {"text": "Since you are only looking for more than one occurrence, you can make use String#indexOf(String) and String#lastIndexOf(String) methods", "label": {"api": {"String#indexOf(String)": [[74, 95]], "String#lastIndexOf(String)": [[101, 126]]}}}, {"text": "Use a DataInput for this type of processing", "label": {"api": {"DataInput": [[6, 14]]}}}, {"text": "I've use a RandomAccessFile but a DataInputStream is a common alternative", "label": {"api": {"DataInput": [[34, 42]], "RandomAccessFile": [[11, 26]], "DataInputStream": [[34, 48]]}}}, {"text": "Even better performance-wise, use a MappedByteBuffer", "label": {"api": {"MappedByteBuffer": [[36, 51]], "ByteBuffer": [[42, 51]]}}}, {"text": "The byte array can be accessed from the ByteBuffer using its array() method", "label": {"api": {"ByteBuffer": [[40, 49]], "array()": [[61, 67]]}}}, {"text": "Because the method setTimeInMillis(milliseconds) in the Calendar class returns void (nothing)", "label": {"api": {"Calendar class": [[56, 69]]}}}, {"text": "For example a Java FloatBuffer", "label": {"api": {"FloatBuffer": [[19, 29]]}}}, {"text": "Use java.util.Scanner instead", "label": {"api": {"java.util.Scanner": [[4, 20]]}}}, {"text": "My application uses JPA+JavaDB and when I try to persist an object that violates a constraint I get SQLIntegrityConstraintViolationException on console", "label": {"api": {"SQLIntegrityConstraintViolationException": [[100, 139]]}}}, {"text": "If I look at the documentation of persist(), there is no sign of SQLIntegrityConstraintViolationException", "label": {"api": {"SQLIntegrityConstraintViolationException": [[65, 104]], "documentation of persist()": [[17, 42]]}}}, {"text": "You can learn more about SwingWorker from here http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingWorker.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingWorker.html": [[47, 115]]}}}, {"text": "There is no get(int) method in java.util.Collection, hence your error", "label": {"api": {"java.util.Collection": [[31, 50]]}}}, {"text": "If you  need to avoid overflow by shifting left, you  want to use a BigInteger instead of a long to store your number", "label": {"api": {"BigInteger": [[68, 77]]}}}, {"text": "BigInteger has methods to support or, as well as left and right shift operations, and since BigInteger has arbitrary precision, left shift won't overflow or switch the sign of the number", "label": {"api": {"BigInteger": [[0, 9], [92, 101]]}}}, {"text": "See ImageViewer for a working example of displaying images using a Swing based Timer", "label": {"api": {"Timer": [[79, 83]]}}}, {"text": "See also How to use Swing Timers", "label": {"api": {"Timer": [[26, 30]]}}}, {"text": "It will return an instance of Console class with the valid character encoding conversion in place", "label": {"api": {"Console class": [[30, 42]]}}}, {"text": "Your best bet is to use AutoIT (Windows only) or the Robot class (will also work only on setups similar to yours) and type the path \"blindly\" into the dialog", "label": {"api": {"Robot": [[53, 57]]}}}, {"text": "How can I make Robot type a `:`", "label": {"api": {"Robot": [[15, 19]]}}}, {"text": "and Convert String to KeyEvents (plus there is the new and shiny KeyEvent#getExtendedKeyCodeForChar() which does similar work, but is available only from JDK7)", "label": {"api": {"KeyEvent#getExtendedKeyCodeForChar()": [[65, 100]]}}}, {"text": "If you are using the SAX parser you can extend the DefaultLocator class and register a Locator in setDocumentLocator method", "label": {"api": {"DefaultLocator": [[51, 64]]}}}, {"text": "Why ByteBuffer class doesn't provide method to read write boolean data type, is there any workaround", "label": {"api": {"ByteBuffer": [[4, 13]]}}}, {"text": "Java threads have an ID http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html#getId()", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html#getId()": [[24, 93]]}}}, {"text": "Use String.replace(\",\", \"\"); That replaces occurances of a comma", "label": {"api": {"String.replace(\",\", \"\");": [[4, 27]]}}}, {"text": "It is an implementation of the interface oracle.jdbc.driver.OracleResultSet", "label": {"api": {"ResultSet": [[66, 74]]}}}, {"text": "It also implements ResultSet, which defines the method next()", "label": {"api": {"ResultSet": [[19, 27]]}}}, {"text": "Here you can find an example on using ResultSet", "label": {"api": {"ResultSet": [[38, 46]]}}}, {"text": "You can use the Calendar#setTimeInMillis(long timemillis) method and the retrieve the Date by invoking the Calendar#getTime() method", "label": {"api": {"Calendar#setTimeInMillis(long timemillis)": [[16, 56]], "Calendar#getTime()": [[107, 124]]}}}, {"text": "I think that you could use bitLength() to get a log2 value, then change the base to 10", "label": {"api": {"bitLength()": [[27, 37]]}}}, {"text": "I also found this Properties object, but I can't tell if it is relevant", "label": {"api": {"Properties": [[18, 27]]}}}, {"text": "Why don't you use a Map", "label": {"api": {"Map": [[20, 22]]}}}, {"text": "If you need the statements in order, but you want to do the work in parallel, a CyclicBarrier could be used to coordinate the print statements", "label": {"api": {"CyclicBarrier": [[80, 92]]}}}, {"text": "And Java 7 has a Files.walkFileTree which comes with a couple of new classes, but is worth getting accustomed to", "label": {"api": {"Files.walkFileTree": [[17, 34]]}}}, {"text": "As shown in the HttpSession javadoc, sessions are ServletContext", "label": {"api": {"HttpSession javadoc": [[16, 34]]}}}, {"text": "ArrayList best suits in your situation I think", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "Also you should use StringBuilder when you do append", "label": {"api": {"StringBuilder": [[20, 32]]}}}, {"text": "To set pixels you would use the setRGB method", "label": {"api": {"setRGB": [[32, 37]]}}}, {"text": "Then create a class that implements Comparator<Contact> (say, ContactComparator) to compare the names", "label": {"api": {"Comparator<Contact>": [[36, 54]]}}}, {"text": "Then you will be able to sort an array of Contact objects with a particular overload of Arrays.sort", "label": {"api": {"a particular overload of Arrays.sort": [[63, 98]]}}}, {"text": "If names will be unique, consider using a SortedMap", "label": {"api": {"SortedMap": [[42, 50]]}}}, {"text": "What about the following using String#replace()", "label": {"api": {"String#replace()": [[31, 46]]}}}, {"text": "That's an error, and parse returns null", "label": {"api": {"and parse returns null": [[17, 38]]}}}, {"text": "Just use the inherited parse method without a ParsePosition", "label": {"api": {"the inherited parse method without a ParsePosition": [[9, 58]]}}}, {"text": "That is achieved by calling pack() which.", "label": {"api": {"pack()": [[28, 33]]}}}, {"text": "String.split() accepts a regex expression, so you can use", "label": {"api": {"String.split()": [[0, 13]]}}}, {"text": "I just run my first application with WebView like this", "label": {"api": {"WebView": [[37, 43]]}}}, {"text": "The details can be found in the Serializable docs", "label": {"api": {"Serializable docs": [[32, 48]]}}}, {"text": "Math.random() will return a value between 0.0 and 1.0, which when cast with (int) will always evaluates to ZERO", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "This makes a FileWriter that will append to an existing file, instead of replacing it (see http://docs.oracle.com/javase/7/docs/api/java/io/FileWriter.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/FileWriter.html": [[91, 154]]}}}, {"text": "Division of an integer by zero givesArithmeticException.So You can catch it and display the message you want", "label": {"api": {"ArithmeticException": [[36, 54]]}}}, {"text": "Why don't you simply use String#split", "label": {"api": {"String#split": [[25, 36]], "split": [[32, 36]]}}}, {"text": "split according to spaces", "label": {"api": {"split": [[0, 4]]}}}, {"text": "Viewing the API can save a lot of efforts and time", "label": {"api": {"API": [[12, 14]]}}}, {"text": "Using StringTokenizer will be more easier", "label": {"api": {"StringTokenizer": [[6, 20]]}}}, {"text": "general timezone, RFC822 or ISO8601", "label": {"api": {"general timezone, RFC822 or ISO8601": [[0, 34]]}}}, {"text": "By default the XMLGregorianCalendar#toString() method returns the date string in ISO 8601 format \"YYYY-MM-DDThh:mm:ssTZD\", For example", "label": {"api": {"XMLGregorianCalendar#toString()": [[15, 45]]}}}, {"text": "The File.renameTo(File dest) function is your friend", "label": {"api": {"File.renameTo(File dest)": [[4, 27]]}}}, {"text": "You'd be better off using a BufferedReader and readLine", "label": {"api": {"BufferedReader": [[28, 41]], "readLine": [[47, 54]]}}}, {"text": "If you really can't use BufferedReader, I would make your code significantly simpler by checking whether the current character is \\n or the end of the file, and processing the \"line so far\" if so", "label": {"api": {"BufferedReader": [[24, 37]]}}}, {"text": "And use it as caller class loader when Class.forName(String) is called", "label": {"api": {"Class.forName(String)": [[39, 59]]}}}, {"text": "Integer is an object", "label": {"api": {"Integer": [[0, 6]]}}}, {"text": "When you have an array of Integers, you actually have an array of objects", "label": {"api": {"Integer": [[26, 32]]}}}, {"text": "Use TreeSet object for that", "label": {"api": {"TreeSet": [[4, 10]]}}}, {"text": "TreeSet elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used", "label": {"api": {"TreeSet": [[0, 6]]}}}, {"text": "Isn't that what a TreeSet is for", "label": {"api": {"TreeSet": [[18, 24]]}}}, {"text": "As said in the documentation (http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#identityHashCode(java.lang.Object)), identityHashCode gives the same HashCode, wether or not the hashCode method was overriden", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#identityHashCode(java.lang.Object)": [[30, 126]]}}}, {"text": "MapMessage  Interface", "label": {"api": {"MapMessage  Interface": [[0, 20]]}}}, {"text": "QueueRequestor#request will return you the Message which in your case will be of type of MapMessage", "label": {"api": {"QueueRequestor#request": [[0, 21]]}}}, {"text": "Anyway, I think you can try to use the javax.transaction.TransactionManager.resume() to achieve what you are trying to do", "label": {"api": {"javax.transaction.TransactionManager.resume()": [[39, 83]]}}}, {"text": "An AbstractMethodError can only occur at runtime if the compiled code used to run the program is not identical to the code used to actually compile the program", "label": {"api": {"AbstractMethodError": [[3, 21]]}}}, {"text": "Java 1.4 doesn't have PrintStream.printf(), it was added in Java 1.5", "label": {"api": {"PrintStream.printf()": [[22, 41]]}}}, {"text": "@Path Identifies the URI path that a resource class or class method will serve requests for", "label": {"api": {"Path": [[1, 4]]}}}, {"text": "To run shell commands from Java code you can call one of Runtime.exec() or use ProcessBuilder", "label": {"api": {"Runtime.exec()": [[57, 70]], "ProcessBuilder": [[79, 92]]}}}, {"text": "This basically means that a ServletContextListener implementation which is registered by either a @WebListener annotation on the class or a <listener> entry in web.xml has thrown an unhandled exception inside the contextInitialized() method", "label": {"api": {"ServletContextListener": [[28, 49]]}}}, {"text": "I assume show is a List and you have to sort by name", "label": {"api": {"List": [[19, 22]]}}}, {"text": "First, make showInfo implement Comparable", "label": {"api": {"Comparable": [[31, 40]]}}}, {"text": "Then, use `Collections.sort()' on the list", "label": {"api": {"`Collections.sort()'": [[10, 29]]}}}, {"text": "Use a FadeTransition", "label": {"api": {"FadeTransition": [[6, 19]]}}}, {"text": "So, by using the String(byte[] data) constructor, you are interpreting the string with the default system encoding", "label": {"api": {"String(byte[] data)": [[17, 35]]}}}, {"text": "From Java's X509Certificate documentation, you can find this code", "label": {"api": {"X509Certificate documentation": [[12, 40]]}}}, {"text": "You can have it be an EnumSet", "label": {"api": {"EnumSet": [[22, 28]]}}}, {"text": "Youc an use Set#retainAll() method for that", "label": {"api": {"Set#retainAll()": [[12, 26]]}}}, {"text": "Using temp with some file locking is about the only way to get a relatively assured swap operation", "label": {"api": {"some file locking": [[16, 32]]}}}, {"text": "You should look at using a BigInteger", "label": {"api": {"BigInteger": [[27, 36]]}}}, {"text": "There's also another way to do this (besides createTransformedShape) which creates fewer temporary objects, if that's desirable", "label": {"api": {"createTransformedShape": [[45, 66]]}}}, {"text": "Instead of keeping a Rectangle2D for the bounding box, you can keep a Path2D and then do the transform in place, using Path2D.transform(AffineTransform)", "label": {"api": {"Path2D": [[70, 75], [119, 124]], "Path2D.transform(AffineTransform)": [[119, 151]]}}}, {"text": "The first is a compiler error, because there is no zero-argument constructor for BufferedReader", "label": {"api": {"BufferedReader": [[81, 94]]}}}, {"text": "If you want to synchronize two threads accessing the same method, use other possibilities, such as synchronized (method or statement), or stuff from the java.util.concurrent package", "label": {"api": {"java.util.concurrent": [[153, 172]]}}}, {"text": "You might want to consider using a HashMap with a String as the key and an Integer[] for the value", "label": {"api": {"HashMap": [[35, 41]]}}}, {"text": "You can parse date strings of any format using SimpleDateFormat, see the reference of its parse method", "label": {"api": {"parse": [[8, 12], [90, 94]]}}}, {"text": "The docs for Pattern has a detailed description of all the special elements that can appear in a pattern", "label": {"api": {"docs for Pattern": [[4, 19]]}}}, {"text": "If you want the items to come out in sorted order (according to alphabetical order), take a look at a priority queue", "label": {"api": {"priority queue": [[102, 115]]}}}, {"text": "You can also do this using String#replaceAll", "label": {"api": {"String#replaceAll": [[27, 43]]}}}, {"text": "I recommend learning JavaFX programming with the plain Java API before learning JavaFX programming with a scripting language", "label": {"api": {"plain Java API": [[49, 62]]}}}, {"text": "The most direct is to split it using the substring method", "label": {"api": {"substring": [[41, 49]], "split": [[22, 26]]}}}, {"text": "You can split the pet/owner strings using split", "label": {"api": {"split": [[8, 12], [42, 46]]}}}, {"text": "Are you reinventing an ExecutorService", "label": {"api": {"ExecutorService": [[23, 37]]}}}, {"text": "In particular, its awaitTermination() method", "label": {"api": {"awaitTermination()": [[19, 36]]}}}, {"text": "And yes, awaitTermination() does not busy wait ..", "label": {"api": {"awaitTermination()": [[9, 26]]}}}, {"text": "In Java, look at the ZipFile class", "label": {"api": {"ZipFile class": [[21, 33]]}}}, {"text": "I would use Java's ProcessBuilder or another class which simulates/uses a shell", "label": {"api": {"ProcessBuilder": [[19, 32]]}}}, {"text": "You have to use getResource or getResourceAsStream to access XML files", "label": {"api": {"getResource": [[16, 26], [31, 41]], "getResourceAsStream": [[31, 49]]}}}, {"text": "When reading, just read the file line by line and separate items by split(\" \") method", "label": {"api": {"split(\" \")": [[68, 77]]}}}, {"text": "Use the Arrays.sort(....) method, and give it a Comparator that has the following compare(String a, String b) method", "label": {"api": {"Arrays.sort(....)": [[8, 24]], "Comparator": [[48, 57]]}}}, {"text": "You could use java.nio.channels.FileChannel and map parts of the file to your main memory", "label": {"api": {"map": [[48, 50]]}}}, {"text": "But you would have to reload/change current mapping, depending on your view", "label": {"api": {"map": [[44, 46]]}}}, {"text": "Take a look at the javadoc of the map method", "label": {"api": {"map": [[34, 36]]}}}, {"text": "Another option would be to use a TreeMap that maps words to their frequencies", "label": {"api": {"TreeMap": [[33, 39]]}}}, {"text": "Apart from any potential threading issues in the Connection, there is only one commit() method and it commits all activity since the last commit/rollback, regardless of which object they came from", "label": {"api": {"commit()": [[79, 86]]}}}, {"text": "If you have 1000's of objects, then use a connection pool to rationalize the number of active connections to the database", "label": {"api": {"connection pool": [[42, 56]]}}}, {"text": "I don't think it's necessary to have a class and a method for this, simply call copyOf() whenever necessary and pass as a parameter any Collection of enum values", "label": {"api": {"copyOf()": [[80, 87]]}}}, {"text": "You can use System.identityHashCode(Object) method", "label": {"api": {"System.identityHashCode(Object)": [[12, 42]]}}}, {"text": "For the Object hashcode, use System.identityHashCode(Object o)", "label": {"api": {"System.identityHashCode(Object o)": [[29, 61]]}}}, {"text": "If you're trying to find out how many zero bits are at the low end of an integer, try Integer.numberOfTrailingZeros", "label": {"api": {"Integer.numberOfTrailingZeros": [[86, 114]]}}}, {"text": "The DatabaseMetaData class provides getJDBCMajorVersion and getJDBCMinorVersion which should return the JDBC version that the driver aims to implement", "label": {"api": {"DatabaseMetaData": [[4, 19]], "getJDBCMajorVersion": [[36, 54]], "getJDBCMinorVersion": [[60, 78]]}}}, {"text": "Then you can use isInstance", "label": {"api": {"isInstance": [[17, 26]]}}}, {"text": "DefaultTableModel#getValueAt(col, row), if you want to read each cell individually..", "label": {"api": {"DefaultTableModel#getValueAt(col, row)": [[0, 37]]}}}, {"text": "DefaultTableModel#getDataVector(), which returns a Vector of Vectors, where the outter is the rows and the inner are the columns, if you want to process the rows/columns in some speical way..", "label": {"api": {"DefaultTableModel#getDataVector()": [[0, 32]]}}}, {"text": "According to the SimpleDateFormat documentation, you should be able to do that by parsing a date as follows", "label": {"api": {"SimpleDateFormat": [[17, 32]]}}}, {"text": "I'll guess that you don't realize that months are zero-based in the Date and Calendar classes, so January = 0, December = 11", "label": {"api": {"months are zero-based": [[39, 59]]}}}, {"text": "Use ArrayList.size() to determine how many elements the ArrayList contains", "label": {"api": {"ArrayList.size()": [[4, 19]]}}}, {"text": "getChannel simply returns a FileChannel to the original File", "label": {"api": {"FileChannel": [[28, 38]]}}}, {"text": "FileChannel offers a way of reading, writing, mapping, and manipulating a file", "label": {"api": {"FileChannel": [[0, 10]]}}}, {"text": "It is quite a low level utility class and if you are new to Java, I would not recommend using this class but have a look at FileWriter or FileReader", "label": {"api": {"FileWriter": [[124, 133]], "FileReader": [[138, 147]]}}}, {"text": "By creating the channel,The stream will be safe for access by multiple concurrent threads", "label": {"api": {"channel": [[16, 22]]}}}, {"text": "And from FileChannel class", "label": {"api": {"FileChannel": [[9, 19]]}}}, {"text": "File channels are safe for use by multiple concurrent threads", "label": {"api": {"channel": [[5, 11]]}}}, {"text": "Only one operation that involves the channel's position or can change its file's size may be in progress at any given time; attempts to initiate a second such operation while the first is still in progress will block until the first operation completes", "label": {"api": {"channel": [[37, 43]]}}}, {"text": "The verifier is technically going to be some kind of instance of X509TrustManager", "label": {"api": {"X509TrustManager": [[65, 80]]}}}, {"text": "Are there any real world examples of when a caller might use the value returned from Collection.remove()", "label": {"api": {"Collection.remove()": [[85, 103]]}}}, {"text": "Collection.remove() returns false when the object passed to it was not found in the collection", "label": {"api": {"Collection.remove()": [[0, 18]]}}}, {"text": "You don't need to create another instance of java.net.ServerSocket", "label": {"api": {"java.net.ServerSocket": [[45, 65]]}}}, {"text": "Singly linked lists can be generated with http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html": [[42, 107]]}}}, {"text": "You may use LinkedHashSet to have no duplicates while filling", "label": {"api": {"LinkedHashSet": [[12, 24]]}}}, {"text": "According to the ObjectOutputStream javadocs, the writeOutput method is final", "label": {"api": {"ObjectOutputStream javadocs": [[17, 43]], "ObjectOutput": [[17, 28]]}}}, {"text": "Internally, Mockito actually mocks these objects by creating a Proxy, which dynamically overrides ObjectOutputStream", "label": {"api": {"Proxy": [[63, 67]], "ObjectOutput": [[98, 109]]}}}, {"text": "Though you may be able to verify against writeObjectOverride, your better bet is actually to refactor your code to use the interface ObjectOutput instead of ObjectOutputStream directly", "label": {"api": {"ObjectOutput": [[133, 144], [157, 168]]}}}, {"text": "ObjectOutputStream implements ObjectOutput, and Mockito can mock any method of an interface", "label": {"api": {"ObjectOutput": [[0, 11], [30, 41]]}}}, {"text": "This is frustrating, and it is not documented anywhere, even in JDK 8 documentation", "label": {"api": {"JDK 8 documentation": [[64, 82]]}}}, {"text": "You could instead create a custom ListCellRenderer to render the text you want for each object", "label": {"api": {"ListCellRenderer": [[34, 49]]}}}, {"text": "See the javadocs at http://docs.oracle.com/javase/6/docs/api/java/util/Random.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Random.html": [[20, 81]]}}}, {"text": "Use the DecimalFormat class (and make sure you go check out that documentation!) to format your numbers for output", "label": {"api": {"DecimalFormat": [[8, 20]]}}}, {"text": "You can also use the standard String formatting options for less complex requirements (but I prefer DecimalFormat)", "label": {"api": {"DecimalFormat": [[100, 112]], "String formatting options": [[30, 54]]}}}, {"text": "For example, Arrays.asList() returns \"a list view of the specified array\"", "label": {"api": {"Arrays.asList()": [[13, 27]]}}}, {"text": "Another example is Collections.unmodifiableList() which returns \"an unmodifiable view of the specified list\"", "label": {"api": {"Collections.unmodifiableList()": [[19, 48]]}}}, {"text": "See Scanner.hasNextLine(), you should probably use that in the loop condition", "label": {"api": {"Scanner.hasNextLine()": [[4, 24]]}}}, {"text": "There is also a Scanner.hasNext() if it works better for your needs", "label": {"api": {"Scanner.hasNext()": [[16, 32]]}}}, {"text": "The reason the scanner class does this is because scanner.next() and scanner.nextLine() return tokens, which are separated by delimiters", "label": {"api": {"scanner": [[15, 21], [50, 56], [69, 75]]}}}, {"text": "By default the delimiter is whitespace", "label": {"api": {"whitespace": [[28, 37]]}}}, {"text": "So what's happening is that when you call scanner.hasNext() or scanner.hasNextLine() is that it looks to see if there is a token after the next delimiter", "label": {"api": {"scanner": [[42, 48], [63, 69]]}}}, {"text": "When you do sc.nextDouble();, nextDouble reads only the double and skips the \\n which indicates the new line (Enter key hit by user), so it'll be read by the next nextLine()", "label": {"api": {"nextDouble": [[15, 24], [30, 39]]}}}, {"text": "Here's a link to the documentation, and don't forget to import the Arrays class, it's in the package java.util", "label": {"api": {"link": [[9, 12]]}}}, {"text": "To customise the text displayed in a JComboBox for arbitrary objects I know the correct approach is to create a custom ListCellRenderer", "label": {"api": {"ListCellRenderer": [[119, 134]]}}}, {"text": "FilterInputStream does not have a public constructor (it is protected - see the javadoc), so you can't instantiate it directly", "label": {"api": {"see the javadoc": [[72, 86]]}}}, {"text": "With Map.computeIfAbsent you can create or retrieve the inner collection for a key, and then add to it, in one tidy line", "label": {"api": {"Map.computeIfAbsent": [[5, 23]]}}}, {"text": "Use javax.swing.Timer instead of java.util.Timer", "label": {"api": {"javax.swing.Timer": [[4, 20]]}}}, {"text": "If you're not allowed to use external libraries, you can replace s.add(line) with s.add(line.intern())", "label": {"api": {"s.add(line.intern())": [[82, 101]]}}}, {"text": "Strings in Java aren't character arrays, they're Strings", "label": {"api": {"String": [[0, 5], [49, 54]]}}}, {"text": "Try using inputString.charAt(i)", "label": {"api": {"String": [[15, 20]]}}}, {"text": "String.getBytes() and String(byte[] bytes) are methods to consider", "label": {"api": {"String.getBytes()": [[0, 16]], "String(byte[] bytes)": [[22, 41]]}}}, {"text": "If this is Java-7 you are looking for a Phaser", "label": {"api": {"Phaser": [[40, 45]]}}}, {"text": "The method you need is arriveAndAwaitAdvance", "label": {"api": {"arriveAndAwaitAdvance": [[23, 43]]}}}, {"text": "In earlier versions of Java (5.1 or later) you would probably use a Semaphore", "label": {"api": {"Semaphore": [[68, 76]]}}}, {"text": "Alternatively - you could switch to using a thread pool such as an ExecutorService and Futures", "label": {"api": {"ExecutorService": [[67, 81]], "Futures": [[87, 93]]}}}, {"text": "Please note that .parse(String) might throw a ParseException", "label": {"api": {".parse(String)": [[17, 30]], "ParseException": [[46, 59]]}}}, {"text": "If your sql query is changing frequently, you should use PreparedStatement instead of creating Statement many times", "label": {"api": {"PreparedStatement": [[57, 73]]}}}, {"text": "You could use JDBC fetch size to limit the result in the result set", "label": {"api": {"JDBC fetch size": [[14, 28]]}}}, {"text": "why not use ScheduledExecutorService which is designed to schedule commands to run after a given delay, or to execute periodically", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "I've got a program with a specialized Process-type class which handles executing the processes natively on Linux", "label": {"api": {"Process": [[38, 44]]}}}, {"text": "It does not use Java's Process class at all, because it needs to do some special handling of the process", "label": {"api": {"Process": [[23, 29]]}}}, {"text": "The Scanner#hasNextInt() method doesn't move the cursor past any input", "label": {"api": {"Scanner#hasNextInt()": [[4, 23]]}}}, {"text": "You need to use Scanner#next() method inside the while loop for that", "label": {"api": {"Scanner#next()": [[16, 29]]}}}, {"text": "After reading all this, you will now understand that you want to use an ExecutorService that will handle the threads for you", "label": {"api": {"ExecutorService": [[72, 86]]}}}, {"text": "You need to use NumberFormat.getCurrencyInstance(...), and then use that to format your value", "label": {"api": {"NumberFormat.getCurrencyInstance(...)": [[16, 52]]}}}, {"text": "This type of program is actually better written using the utility classes in java.util.concurrent", "label": {"api": {"java.util.concurrent": [[77, 96]]}}}, {"text": "All you need to do is created the embedded database in ServletContextLister.contextInitialized() and shut it down in ServletContextLister.contextDestroyed", "label": {"api": {"ServletContextLister.contextInitialized()": [[55, 95]]}}}, {"text": "Use the String.equals(String otherString) function to compare strings", "label": {"api": {"String.equals(String otherString)": [[8, 40]]}}}, {"text": "The reason is that == just compares object references/primitives,where as String's .equals() method checks equality", "label": {"api": {".equals()": [[83, 91]]}}}, {"text": "Check the API for more information", "label": {"api": {"API": [[10, 12]]}}}, {"text": "You have to override getColumnName(int columnIndex)", "label": {"api": {"getColumnName(int columnIndex)": [[21, 50]]}}}, {"text": "Use a GridLayoutfor this, with just two components in a single row", "label": {"api": {"GridLayout": [[6, 15]]}}}, {"text": "If you want to create the buffer from the Java side, you have ByteBuffer.allocateDirect", "label": {"api": {"ByteBuffer.allocateDirect": [[62, 86]]}}}, {"text": "You can use BigDecimal class", "label": {"api": {"BigDecimal": [[12, 21]]}}}, {"text": "In the method setScale() you can define the precission you need", "label": {"api": {"setScale()": [[14, 23]]}}}, {"text": "I was looking at the java.lang.Object and also reading couple of questions in StackOverflow on the same topic", "label": {"api": {"java.lang.Object": [[21, 36]]}}}, {"text": "From Object#equals javadoc", "label": {"api": {"Object#equals": [[5, 17]]}}}, {"text": "You can get notified by any Swing component of layout changes by attaching a ComponentListener (http://docs.oracle.com/javase/7/docs/api/java/awt/event/ComponentListener.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/event/ComponentListener.html": [[96, 173]]}}}, {"text": "If you develop your application in JDK 8 and run it with JRE 7, you would get an UnsupportedClassVersionError", "label": {"api": {"UnsupportedClassVersionError": [[81, 108]]}}}, {"text": "If you're reading from a file, Files.readAllBytes is the way to do it", "label": {"api": {"Files.readAllBytes": [[31, 48]]}}}, {"text": "It takes advantage of the String#contains() method looking for sub sequences of the first String", "label": {"api": {"String#contains()": [[26, 42]]}}}, {"text": "java.util.Properties implements the Map interface so you can do everything that this interface offers with it", "label": {"api": {"java.util.Properties": [[0, 19]], "Map": [[36, 38]]}}}, {"text": "If you need more resolution than $0.01 (say, for intermediate calculations), then you should use BigDecimal numbers", "label": {"api": {"BigDecimal": [[97, 106]]}}}, {"text": "any() is the same thing as Collection#contains(), which is part of the standard library, and is in fact an instance method of all Collection implementations", "label": {"api": {"Collection#contains()": [[27, 47]]}}}, {"text": "If you need to delay some code you can use a PauseTransition to wait for two seconds and use its onFinished method to run the rest of your code after the wait", "label": {"api": {"PauseTransition": [[45, 59]]}}}, {"text": "If you have thousands of them you should use a ScheduledExecutorService which will pool threads rather than a Timer which will use one thread per timer", "label": {"api": {"ScheduledExecutorService": [[47, 70]]}}}, {"text": "I wanted to give credit here to @MrLore who noted that File.listFiles does exactly what I wanted", "label": {"api": {"File.listFiles": [[55, 68]]}}}, {"text": "To get the float[] array backed by the buffer just call the method array()", "label": {"api": {"array()": [[67, 73]]}}}, {"text": "KeyListener doesn't work if you paste in text, that's why you should use DocumentListener", "label": {"api": {"KeyListener": [[0, 10]]}}}, {"text": "One standard approach to this problem is to serialize your object, using either Java's Serializable facilities, or something like JSON (e.g., GSon), then stash it in the datastore", "label": {"api": {"Serializable": [[87, 98]]}}}, {"text": "For example, you have WindowsPath (WindowsFileSystem) and ZipPath (ZipFileSystem)", "label": {"api": {"FileSystem": [[42, 51], [70, 79]]}}}, {"text": "Although the path string itself might be the same, they are related to different FileSystems, so the method should return false", "label": {"api": {"FileSystem": [[81, 90]]}}}, {"text": "See System.setOut and System.setErr", "label": {"api": {"System.setOut": [[4, 16]], "System.setErr": [[22, 34]]}}}, {"text": "According to the Javadoc for FileWriter", "label": {"api": {"According to the Javadoc for FileWriter": [[0, 38]]}}}, {"text": "HashMap's keySet() method already creates the set you need, so simply", "label": {"api": {"keySet()": [[10, 17]]}}}, {"text": "I am using a RandomAccessFile in Java 6 but having some strange behavior when reading bytes", "label": {"api": {"RandomAccessFile": [[13, 28]]}}}, {"text": "If you need to break it up in to words, use StringTokenizer", "label": {"api": {"StringTokenizer": [[44, 58]]}}}, {"text": "You can then reverse the characters in the word either through the code you wrote or as PeterLawrey suggested, create a StringBuilder and call the \"reverse()\" method", "label": {"api": {"StringBuilder": [[120, 132]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html (search for 'consistent with equals')", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html": [[4, 69]]}}}, {"text": "If you can guarantee every line has the same amount of characters, you could do the above by using the LineNumberReader which has a skip() method, you can feed it the number of lines multiplied by the number of characters per line and get to where you want to go", "label": {"api": {"LineNumberReader": [[103, 118]]}}}, {"text": "Besides 'serialize (in some form) in a File', there is also the Preferences API, or for desktop applications launched using Java Web Start, the PersistenceService", "label": {"api": {"Preferences": [[64, 74]]}}}, {"text": "It throws a ConcurrentModificationException as soon as it detects change in underlying structure (list)", "label": {"api": {"ConcurrentModificationException": [[12, 42]]}}}, {"text": "Here we are using a Map (code => sum) to store the sums", "label": {"api": {"Map": [[20, 22]]}}}, {"text": "In JPA you must declare a List as @ElementCollection for it to be persisted", "label": {"api": {"@ElementCollection": [[34, 51]]}}}, {"text": "One way to do it should be to declare your List tags as @Transient (ie", "label": {"api": {"@Transient": [[56, 65]]}}}, {"text": "Both are considered obsolete - if you only need to check existence you can use a HashSet", "label": {"api": {"HashSet": [[81, 87]]}}}, {"text": "The best option for what you want to achieve is using a Set", "label": {"api": {"Set": [[56, 58]]}}}, {"text": "In this case, you need to use the UserDefinedFileAttributeView whose view-name is \"user\"", "label": {"api": {"UserDefinedFileAttributeView": [[34, 61]]}}}, {"text": "Add an ActionListener to your \"play\" button that calls the appropriate start method", "label": {"api": {"ActionListener": [[7, 20]]}}}, {"text": "Instantiate a JFrame (link)", "label": {"api": {"link": [[22, 25]]}}}, {"text": "The oracle tutorial on how to make frames (link) shows you exactly how to do that", "label": {"api": {"link": [[43, 46]]}}}, {"text": "your underlying implementation class should be a LinkedList, not an ArrayList", "label": {"api": {"LinkedList": [[49, 58]], "ArrayList": [[68, 76]]}}}, {"text": "The reason is that when you call remove on an ArrayList every element after the removed value must be shifted up (making remove(0) the very worst case!)", "label": {"api": {"ArrayList": [[46, 54]]}}}, {"text": "However this is not a problem for a LinkedList", "label": {"api": {"LinkedList": [[36, 45]]}}}, {"text": "You could use a Deque", "label": {"api": {"Deque": [[16, 20]]}}}, {"text": "First, I trust that you are already familiar with the Pattern and Matcher javadocs", "label": {"api": {"Pattern": [[54, 60]], "Matcher": [[66, 72]]}}}, {"text": "Finally, you can utilize DOTALL mode which will allow the", "label": {"api": {"DOTALL": [[25, 30]]}}}, {"text": "Since the method already returns a static instance of NumberFormat, go ahead and drop the new keyword from the declaration", "label": {"api": {"returns a static instance of NumberFormat": [[25, 65]]}}}, {"text": "From DataInputStream#readLine javadoc", "label": {"api": {"DataInputStream#readLine": [[5, 28]]}}}, {"text": "You have no advantage compared to java functions like String#substring(int, int) which are easier to read", "label": {"api": {"String#substring(int, int)": [[54, 79]]}}}, {"text": "mark marks the current position as the position reset should jump to", "label": {"api": {"mark": [[0, 3], [5, 8]]}}}, {"text": "A full regex is actually explained in the documentation of valueOf()", "label": {"api": {"valueOf()": [[59, 67]]}}}, {"text": "For viewing, consider leveraging the user's preferred browser via Desktop#browse()", "label": {"api": {"Desktop#browse()": [[66, 81]]}}}, {"text": "You can use lastIndexOf()", "label": {"api": {"lastIndexOf()": [[12, 24]]}}}, {"text": "You could load the properties file into a Properties object, then loop through the properties like so", "label": {"api": {"Properties": [[42, 51]]}}}, {"text": "How about using Collections.checkedMap", "label": {"api": {"Collections.checkedMap": [[16, 37]]}}}, {"text": "This is documented at http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/ls/LSResourceResolver.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/ls/LSResourceResolver.html": [[22, 100]]}}}, {"text": "If you wanted to bind SomeOtherInterface<Call> instead of Provider<Call>, you could still do so, but you would need to dynamically create a ParameterizedType using Guice's Types util class and use that as the input to Key#get(Type, Annotation)", "label": {"api": {"ParameterizedType": [[140, 156]]}}}, {"text": "For a little more context on creating a ParameterizedType implementation, read up at this SO answer", "label": {"api": {"ParameterizedType": [[40, 56]]}}}, {"text": "The one-argument substring method you call takes from the beginning position through the end of the string, which is not what you want", "label": {"api": {"one-argument substring method": [[4, 32]]}}}, {"text": "If it exists, then use the two-argument substring method that will extract the proper substring", "label": {"api": {"the two-argument substring method": [[23, 55]]}}}, {"text": "fourth?) everyone asking for a pared-down example of a table using your custom combobox any maybe a bit of the code from the combobox itself, but just to take a stab at it anyway...have you tried making a customized version of EditorDelegate to go with your other custom code and moving the code for showing the popup from focusGained() into your delegate's startCellEditing() method", "label": {"api": {"EditorDelegate": [[227, 240]]}}}, {"text": "You can use a StringBuilder", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "Varieties of overloaded append methods give you power to append several other types to the StringBuilder", "label": {"api": {"StringBuilder": [[91, 103]]}}}, {"text": "String.format enables you to specify a format string (\"%d:%d:%d\" this time), so if you happen to want to change it later on, you can do it easily", "label": {"api": {"String.format": [[0, 12]]}}}, {"text": "As @Pshemo noted, similar to how String.format works, there is the PrintStream.printf() method, available in this scenario as System.out.printf(String format, Object..", "label": {"api": {"String.format": [[33, 45]], "PrintStream.printf()": [[67, 86]]}}}, {"text": "How about a List or a Set", "label": {"api": {"List": [[12, 15]], "Set": [[22, 24]]}}}, {"text": "Even a Stack or a Queue would work", "label": {"api": {"Stack": [[7, 11]], "Queue": [[18, 22]]}}}, {"text": "Here is a basic example using a List", "label": {"api": {"List": [[32, 35]]}}}, {"text": "And this is how you might use a Stack", "label": {"api": {"Stack": [[32, 36]]}}}, {"text": "Perhaps the most efficient way would be to use a HashSet", "label": {"api": {"Set": [[53, 55]]}}}, {"text": "To open a url in the system's web browser you can use java.awt.Desktop.browse(URI)", "label": {"api": {"java.awt.Desktop.browse(URI)": [[54, 81]]}}}, {"text": "To load a web page within Java, I've had some success using the JavaFX WebView", "label": {"api": {"JavaFX WebView": [[64, 77]]}}}, {"text": "If the length of month is more than 3, then call the substring method", "label": {"api": {"substring method": [[53, 68]]}}}, {"text": "If you can store the bytecode you should be able to do something like what is shown in the Javadoc for ClassLoader", "label": {"api": {"ClassLoader": [[103, 113]]}}}, {"text": "You simply override the findClass(String) method", "label": {"api": {"findClass(String)": [[24, 40]]}}}, {"text": "You can try using SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[18, 33]]}}}, {"text": "then for your comparison between dates you can use before(date) or after(date) methods", "label": {"api": {"before(date)": [[51, 62]], "after(date)": [[67, 77]]}}}, {"text": "You could read the lines one by one using the Scanner#nextLine() method of Scanner and keep appending them in a StringBuffer with the \\n at the end of each line", "label": {"api": {"Scanner#nextLine()": [[46, 63]], "StringBuffer": [[112, 123]]}}}, {"text": "Once you are done reading all the lines, StringBuffer#toString() will give you your desired result", "label": {"api": {"StringBuffer": [[41, 52]], "StringBuffer#toString()": [[41, 63]]}}}, {"text": "In your case, you need to read the line and String#split(regex) it on the = symbol and take the second element of the resultant array", "label": {"api": {"String#split(regex)": [[44, 62]]}}}, {"text": "String#substring(int beginIndex, int endIndex) is what you need", "label": {"api": {"String#substring(int beginIndex, int endIndex)": [[0, 45]]}}}, {"text": "You don't wait for all your submited tasks to terminate, see the javadoc for ExecutorService.html#shutdown", "label": {"api": {"ExecutorService.html#shutdown": [[77, 105]]}}}, {"text": "The System.getenv() method returns an unmodifiable view of the environment variables", "label": {"api": {"System.getenv() method returns an unmodifiable view": [[4, 54]]}}}, {"text": "The only time you can \"set\" environment variables is when you are creating an environment for a child process, using the ProcessBuilder class or the Runtime.exec method, but even then you are not modifying your copy of the environment", "label": {"api": {"ProcessBuilder": [[121, 134]], "Runtime.exec": [[149, 160]]}}}, {"text": "From List#equals(Object o) doc", "label": {"api": {"List#equals(Object o)": [[5, 25]]}}}, {"text": "Volume changes (and for that matter, any gradual changes) are not directly supported by the Sequencer interface", "label": {"api": {"Sequencer": [[92, 100]]}}}, {"text": "You can check for the guesses in words like this by using the List#contains(Object)", "label": {"api": {"List#contains(Object)": [[62, 82]]}}}, {"text": "You can use Collection.retainAll", "label": {"api": {"Collection.retainAll": [[12, 31]]}}}, {"text": "If you do not know its names (because someone may add later more columns), you could retrieve the ResultSetMetaData http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getMetaData()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getMetaData()": [[116, 193]]}}}, {"text": "In java 6 org.json.JSONArray contains the put method and in java 7 javax.json contains the add method", "label": {"api": {"javax.json": [[67, 76]]}}}, {"text": "Use the remove method to remove key/value pairs from a Map (see the linked docs)", "label": {"api": {"remove method": [[8, 20]]}}}, {"text": "I think you would need to implement the Cloneable interface", "label": {"api": {"Cloneable": [[40, 48]]}}}, {"text": "This post shows how to clone an object in Groovy without implementing the Cloneable interface, though I have not tested it", "label": {"api": {"Cloneable": [[74, 82]]}}}, {"text": "You could also try to use the QueryTimeout for a prepared statement", "label": {"api": {"QueryTimeout": [[30, 41]]}}}, {"text": "Sample code for that is provided in the package documentation for javax.naming.event", "label": {"api": {"package documentation for javax.naming.event": [[40, 83]]}}}, {"text": "It would be even better to use the nextInt method from the java.util.Random class", "label": {"api": {"java.util.Random": [[59, 74]]}}}, {"text": "Use a long to store the sum; it has a maximum value of 9223372036854775807 and can hold the sum", "label": {"api": {"maximum value of 9223372036854775807": [[38, 73]]}}}, {"text": "BufferedReader#readLine() blocks until receive a line of text", "label": {"api": {"BufferedReader#readLine()": [[0, 24]]}}}, {"text": "What you need is to set a timeout to the underlying socket via Socket#setSoTimeout(int timeout)", "label": {"api": {"Socket#setSoTimeout(int timeout)": [[63, 94]]}}}, {"text": "I would recommend using Future", "label": {"api": {"Future": [[24, 29]]}}}, {"text": "One speedup idea is using possessive quantifiers, see them in http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html": [[62, 130]]}}}, {"text": "One approach you can take here is to perform the socket read on a separate thread, and use Thread.join(long millis) method to wait up to maximum milliseconds for it to complete", "label": {"api": {"Thread.join(long millis)": [[91, 114]]}}}, {"text": "Exactly as the error message tells you, String#split() returns a String[], which is a string array", "label": {"api": {"String#split() returns a String[]": [[40, 72]]}}}, {"text": "It will round up your number to the nearest whole value", "label": {"api": {"round up": [[8, 15]]}}}, {"text": "The easiest way is to use WeakHashMap", "label": {"api": {"WeakHashMap": [[26, 36]]}}}, {"text": "You better use the Attributes on the ServletContext at least the Tomcat's ApplicationContext uses CHM", "label": {"api": {"ServletContext": [[37, 50]]}}}, {"text": "It may happened due to mode ImageWriteParam.MODE_EXPLICIT", "label": {"api": {"ImageWriteParam.MODE_EXPLICIT": [[28, 56]]}}}, {"text": "j > 0) or use List which have dynamic size in case you don't know the input size ahead", "label": {"api": {"List": [[14, 17]]}}}, {"text": "It is an anonymous class that implements Runnable interface", "label": {"api": {"Runnable interface": [[41, 58]]}}}, {"text": "BufferedReader#readLine() returns null if it's at EOF; Scanner#nextLine() \"throws NoSuchElementException - if no line was found.\" If you want to use Scanner, your loop conditional needs to be checking cin.hasNextLine()", "label": {"api": {"BufferedReader#readLine()": [[0, 24]], "Scanner#nextLine()": [[55, 72]]}}}, {"text": "You can try to use executeUpate", "label": {"api": {"executeUpate": [[19, 30]]}}}, {"text": "You can also consider using NIO direct ByteBuffers", "label": {"api": {"ByteBuffers": [[39, 49]]}}}, {"text": "openList should be a PriorityQueue ordered by g(x) + h(x)", "label": {"api": {"PriorityQueue": [[21, 33]]}}}, {"text": "getDesktop#open only allows files to be opened from the file system", "label": {"api": {"getDesktop#open": [[0, 14]]}}}, {"text": "A possible alternative to threads is setting the SO_TIMEOUT socket option on the server socket", "label": {"api": {"the SO_TIMEOUT socket option": [[45, 72]]}}}, {"text": "Another alternative is using non-blocking IO and the Selector class", "label": {"api": {"Selector": [[53, 60]]}}}, {"text": "If you look at the Javadoc for Random, you will find that nextInt(int n) returns a value between 0 and n", "label": {"api": {"Javadoc for Random": [[19, 36]]}}}, {"text": "Just use SchemaFactory#newSchema(URL) method instead", "label": {"api": {"SchemaFactory#newSchema(URL)": [[9, 36]]}}}, {"text": "JAXB will under the covers grab the InputStream from the supplied URL by URL#openStream()", "label": {"api": {"URL#openStream()": [[73, 88]]}}}, {"text": "I have a Java ObservableList with thousands of entries that receives hundreds of updates a second backing a JavaFX TableView", "label": {"api": {"ObservableList": [[14, 27]], "TableView": [[115, 123]]}}}, {"text": "The ObservableList is backed by an ArrayList", "label": {"api": {"ObservableList": [[4, 17]], "backed by an ArrayList": [[22, 43]]}}}, {"text": "Parameter you pass in one-arg ArrayList(int) constructor is not the fixed size of the list", "label": {"api": {"ArrayList(int) constructor": [[30, 55]]}}}, {"text": "And then filling the array is pretty simple, by using Arrays#fill(Object[] a, int fromIndex, int toIndex, Object val) method", "label": {"api": {"Arrays#fill(Object[] a, int fromIndex, int toIndex, Object val)": [[54, 116]]}}}, {"text": "If you want to \"search\" lines and only print certain ones you could use contains", "label": {"api": {"contains": [[72, 79]]}}}, {"text": "Use string concatenation and Pattern.quote to ensure that any special characters inside the string are treated literally", "label": {"api": {"Pattern.quote": [[29, 41]]}}}, {"text": "In Java's AWT FocusEvent class", "label": {"api": {"Java's AWT FocusEvent class": [[3, 29]]}}}, {"text": "In JavaFX, a ChangeListener can be added to the focusedProperty as shown here, but how does one determine if the change is permanent", "label": {"api": {"ChangeListener": [[13, 26]], "focusedProperty": [[48, 62]]}}}, {"text": "Another thing you can try is the new autoRequestFocus property introduced in Java 1.7", "label": {"api": {"autoRequestFocus": [[37, 52]]}}}, {"text": "I find java's BigInteger to be the best among them all for bit manipulation", "label": {"api": {"BigInteger": [[14, 23]]}}}, {"text": "As for addition of these binary digits, you can use BigInteger.add(BigIntger)function provide by them", "label": {"api": {"BigInteger": [[52, 61]]}}}, {"text": "Java provide Collections.min(Comparables) and Collections.max(Comparables) which you can implement as follows", "label": {"api": {"Collections.min(Comparables)": [[13, 40]], "Collections.max(Comparables)": [[46, 73]]}}}, {"text": "Math.round() takes float or double as argument", "label": {"api": {"Math.round()": [[0, 11]]}}}, {"text": "You may be able to use System.setOut and/or System.setErr", "label": {"api": {"System.setOut": [[23, 35]], "System.setErr": [[44, 56]]}}}, {"text": "Since the javax.xml.ws.handler.MessageContext is too a Map<String, Object>, you can print all contents", "label": {"api": {"javax.xml.ws.handler.MessageContext": [[10, 44]]}}}, {"text": "The best way to parse that JSON object is as a Map (see Map documentation), so you just need to add an attribute to your Item class like this", "label": {"api": {"Map documentation": [[56, 72]]}}}, {"text": "You could use CountDownLatch or a CyclicBarrier", "label": {"api": {"CountDownLatch": [[14, 27]], "CyclicBarrier": [[34, 46]]}}}, {"text": "You could also use AbstractMap.SimpleEntry<K,V> directly, or provide your own anonymous implementation", "label": {"api": {"AbstractMap.SimpleEntry<K,V>": [[19, 46]]}}}, {"text": "Use a FileInputStream's read(byte[]) method", "label": {"api": {"FileInputStream": [[6, 20]], "read(byte[])": [[24, 35]]}}}, {"text": "Try java.io.File.getParentFile() method", "label": {"api": {"java.io.File.getParentFile()": [[4, 31]]}}}, {"text": "I think java.io.File.getParent() is what you are looking for", "label": {"api": {"java.io.File.getParent()": [[8, 31]]}}}, {"text": "You should be able to use PosixFileAttributeView.setGroup() with POSIX systems", "label": {"api": {"PosixFileAttributeView.setGroup()": [[26, 58]]}}}, {"text": "You can register a javascript variable in the engine, by using the ScriptEngine#put(String key, Object value) method", "label": {"api": {"ScriptEngine#put(String key, Object value)": [[67, 108]]}}}, {"text": "From version 1.6, you can theoretically use the Connection.isValid method but I am not sure if every vendor supports it", "label": {"api": {"Connection.isValid": [[48, 65]]}}}, {"text": "You need to write your own ListCellRenderer to render the persons in combo box", "label": {"api": {"ListCellRenderer": [[27, 42]]}}}, {"text": "Use overloaded version of indexOf(), which takes the starting index  (fromIndex) as 2nd parameter", "label": {"api": {"indexOf()": [[26, 34]]}}}, {"text": "If you read the SimpleDateFormat javadoc, you'll notice that mm is for minutes", "label": {"api": {"SimpleDateFormat javadoc": [[16, 39]]}}}, {"text": "You can overcome this issue by wrapping System.in in a BufferedReader and reading entire lines, or even better, use the Scanner or Console classes, or best of all according to some people, use a graphical user interface", "label": {"api": {"BufferedReader": [[55, 68]], "Scanner": [[120, 126]], "Console": [[131, 137]]}}}, {"text": "An example of using the Console class", "label": {"api": {"Console": [[24, 30]]}}}, {"text": "Use File.length() to determine the size of the file, and reject if it's too big", "label": {"api": {"File.length()": [[4, 16]]}}}, {"text": "Use Runtime.freeMemory() to see how much heap you have left", "label": {"api": {"Runtime.freeMemory()": [[4, 23]]}}}, {"text": "However, if you want additive composting you may have to implement your own custom composting function", "label": {"api": {"custom composting function": [[76, 101]]}}}, {"text": "String.split(String) takes a String as the lone parameter", "label": {"api": {"String.split(String)": [[0, 19]]}}}, {"text": "In any case, the 1-argument split() method of String accepts only a String which is in turn parsed as a regular expression", "label": {"api": {"split()": [[28, 34]]}}}, {"text": "The simplest solution might be to use GridBagLayout#getConstraints(Component) and simply loop through all the components until you find one that matches the required grid position..", "label": {"api": {"GridBagLayout#getConstraints(Component)": [[38, 76]]}}}, {"text": "If that's the case you can try to reset the stream when that is supported by the InputStream type you are using", "label": {"api": {"reset": [[34, 38]], "supported": [[64, 72]]}}}, {"text": "Instead, you should implement HttpSessionBindingListener interface", "label": {"api": {"HttpSessionBindingListener": [[30, 55]]}}}, {"text": "Ultimately, this is using Object.clone() to create the object - and that's guaranteed to create a new object of the same execution-time type as the object it's called on", "label": {"api": {"Object.clone()": [[26, 39]]}}}, {"text": "If the strings are generated at runtime, use a StringBuilder (not a StringBuffer, it's slower because of the synchronization overhead)", "label": {"api": {"StringBuilder": [[47, 59]], "StringBuffer": [[68, 79]]}}}, {"text": "You might want to have a look at  BufferedReader and BufferedWriter", "label": {"api": {"BufferedReader": [[34, 47]], "BufferedWriter": [[53, 66]]}}}, {"text": "Collections.shuffle(list); what you are looking for", "label": {"api": {"Collections.shuffle(list);": [[0, 25]]}}}, {"text": "The best way to shuffle a list is using the standard library method Collections.shuffle", "label": {"api": {"Collections.shuffle": [[68, 86]]}}}, {"text": "If you can replace ${name} and ${sitename} with {0} and {1} you could use MessageFormat", "label": {"api": {"MessageFormat": [[74, 86]]}}}, {"text": "I tried to use Java´s equals() method, because I thought it does a value comparison, because for a reference comparison the == operator exists and there is no need for equals to do the same", "label": {"api": {"equals()": [[22, 29]]}}}, {"text": "I don't know Java well, but Google gave me this link", "label": {"api": {"this link": [[43, 51]]}}}, {"text": "It's specified in the Map documentation", "label": {"api": {"Map": [[22, 24]]}}}, {"text": "The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings", "label": {"api": {"Map": [[4, 6]]}}}, {"text": "Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not", "label": {"api": {"Map": [[39, 41], [115, 117]]}}}, {"text": "That means for LinkedHashMap, all the 3 methods - values(), keySet() and entrySet(), each of them providing 3 different collection views, are guaranteed to iterate in the insertion order", "label": {"api": {"Map": [[25, 27]]}}}, {"text": "You need to use Scanner#hasNextDouble() method to test, whether there is a double value to read", "label": {"api": {"Scanner#hasNextDouble()": [[16, 38]]}}}, {"text": "You can do this using a ServletContextListener, more specifically, in the contextInitialized method", "label": {"api": {"ServletContextListener": [[24, 45]], "contextInitialized": [[74, 91]]}}}, {"text": "Note that if contextInitialized method throws any Exception, the web application won't deploy at all", "label": {"api": {"contextInitialized": [[13, 30]]}}}, {"text": "You need to manually add json properties with add method of JsonObjectBuilder", "label": {"api": {"JsonObjectBuilder": [[60, 76]]}}}, {"text": "The solution is by using DecimalFormat class", "label": {"api": {"DecimalFormat class": [[25, 43]]}}}, {"text": "Boolean.TRUE or Boolean.FLASE, constants defined in java.lang.Boolean", "label": {"api": {"java.lang.Boolean": [[52, 68]]}}}, {"text": "(Creating a Cipher Object) If no mode or padding is specified, provider-specific default values for the mode and padding scheme are used", "label": {"api": {"Cipher": [[12, 17]]}}}, {"text": "Cipher.getInstance(\"DES\") and Cipher.getInstance(\"DES/ECB/PKCS5Padding\") are equivalent statements", "label": {"api": {"Cipher": [[0, 5], [30, 35]]}}}, {"text": "Additionally, the Cipher class defines the transformation \"AES/ECB/NoPadding\" that will get you a non-padded 16 byte value for your encryptedData", "label": {"api": {"Cipher": [[18, 23]]}}}, {"text": "Here's an idea, using lastIndexOf()", "label": {"api": {"lastIndexOf()": [[22, 34]]}}}, {"text": "What about valueOf()", "label": {"api": {"valueOf()": [[11, 19]]}}}, {"text": "The key method is URL.setURLStreamHandlerFactory()", "label": {"api": {"URL.setURLStreamHandlerFactory()": [[18, 49]]}}}, {"text": "If you want to write using DataOutputStream, you must read using DataInputStream", "label": {"api": {"DataOutputStream": [[27, 42]], "DataInputStream": [[65, 79]]}}}, {"text": "Alternatively, you can read raw bytes, but then you'll have to write them as well, not use a DataOutputStream which encodes the data so that DataInputStream can decode it", "label": {"api": {"DataOutputStream": [[93, 108]], "DataInputStream": [[141, 155]]}}}, {"text": "If the steps call methods which throw InterruptedException then you can use Thread.interrupt()", "label": {"api": {"Thread.interrupt()": [[76, 93]]}}}, {"text": "If the steps cannot be interrupted this way, you should not consider relying on the deprecated Thread.stop() mechanism since it is inherently unsafe", "label": {"api": {"Thread.stop()": [[95, 107]]}}}, {"text": "You should use printf in order to format your output", "label": {"api": {"printf": [[15, 20]]}}}, {"text": "The Standard Widget Toolkit and the Abstract Window Toolkit use the native widgets of the platform that it is executed on (unlike Swing)", "label": {"api": {"Abstract Window Toolkit": [[36, 58]]}}}, {"text": "You can use ObjectOutputStream to write an object into a file", "label": {"api": {"ObjectOutputStream": [[12, 29]]}}}, {"text": "In order to listen to KeyEvents you need to use JComponent#getInputMap() and JComponent#getActionMap() methods to put the input event you want to listen and the correspondent action", "label": {"api": {"JComponent#getInputMap()": [[48, 71]], "JComponent#getActionMap()": [[77, 101]]}}}, {"text": "You can call close() method", "label": {"api": {"close()": [[13, 19]]}}}, {"text": "Java do not have destructor but finalize() is their with every object which kind of work like destructor", "label": {"api": {"finalize()": [[32, 41]]}}}, {"text": "String#split() method ignores any trailing empty string", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "If you want them to be the part of array, use the overloaded split(String, int) method, which takes a limit as 2nd argument", "label": {"api": {"split(String, int)": [[61, 78]]}}}, {"text": "In Java, I am trying to write a subclass for the abstract Reader class", "label": {"api": {"Reader": [[58, 63]]}}}, {"text": "I am trying to implement Reader's close() method", "label": {"api": {"Reader": [[25, 30]]}}}, {"text": "The subclass I intend to write, Reader2, will translate the input from the original Reader (obtained by calling ReaderObj.read()) into something else, so that calling read() on a Reader2 object will output the translated character", "label": {"api": {"Reader": [[32, 37], [84, 89], [112, 117], [179, 184]]}}}, {"text": "If all the values are relatively small and non-negative, you can probably do well with a BitSet", "label": {"api": {"BitSet": [[89, 94]]}}}, {"text": "The preferred way in this case would be to store the states in a HashMap or similar", "label": {"api": {"HashMap": [[65, 71]]}}}, {"text": "Whatever is put in DataOutputStream on one end, it'll come out in DataInputStream on the other side of the connection, regardless whether it's a server/client", "label": {"api": {"DataInputStream": [[66, 80]]}}}, {"text": "DataInputStream and DataOutputSream's API are found in the link", "label": {"api": {"DataInputStream": [[0, 14]], "DataOutputSream": [[20, 34]]}}}, {"text": "Method Process#exitValue() throws an exception if the process has not yet terminated", "label": {"api": {"Process#exitValue()": [[7, 25]]}}}, {"text": "Use Random class, and it's nextInt(int) method to generate the random number from 0 to a given integer number", "label": {"api": {"Random": [[4, 9]], "nextInt(int)": [[27, 38]]}}}, {"text": "Using the Random class allows you to specify a range", "label": {"api": {"Random": [[10, 15]]}}}, {"text": "Then adding the new element and deleting the last (keeping a Queue such as LinkedList) is constant time, unless the count at low or high drops to 0", "label": {"api": {"Queue": [[61, 65]]}}}, {"text": "You can do it by examining the call stack via Thread.getStackTrace()", "label": {"api": {"Thread.getStackTrace()": [[46, 67]]}}}, {"text": "check this article", "label": {"api": {"article": [[11, 17]]}}}, {"text": "nextDouble() doesn't handle the end of the line", "label": {"api": {"nextDouble()": [[0, 11]]}}}, {"text": "So when you call nextLine() again, it'll take as input the enter (\\n) you entered before", "label": {"api": {"nextLine()": [[17, 26]]}}}, {"text": "So it's skipping the actual input and swallows the \\n from the previous input that was missed by nextLine()", "label": {"api": {"nextLine()": [[97, 106]]}}}, {"text": "You should call another nextLine() before the real nextLine() (So it will swallow the \\n)", "label": {"api": {"nextLine()": [[24, 33], [51, 60]]}}}, {"text": "That's the reason of your StringIndexOutOfBoundsException, opStr is only a \\n at this point", "label": {"api": {"StringIndexOutOfBoundsException": [[26, 56]]}}}, {"text": "If your plugin was a Filter instead of a Servlet (maybe your framework allows filter plugins?) then you could wrap the response object in a HttpServletResponseWraper before passing the processing along, and the wrapper could save the contents to some stream in memory instead of writing it to the response stream", "label": {"api": {"Filter": [[21, 26]], "HttpServletResponseWraper": [[140, 164]]}}}, {"text": "In the constructor, you are calling setDefaultLookAndFeelDecorated(true)", "label": {"api": {"setDefaultLookAndFeelDecorated(true)": [[36, 71]]}}}, {"text": "Let your Account class override equals and hashCode methods, then use List#contains to verify if the object is already present in the list", "label": {"api": {"equals": [[32, 37]], "hashCode": [[43, 50]], "List#contains": [[70, 82]]}}}, {"text": "If you're going to use the latter, it would be better using a Set instead of a List since Sets already handle that the object should be unique in the collection", "label": {"api": {"Set": [[62, 64], [90, 92]]}}}, {"text": "From your edit, the current error is that Account class must override equals and hashCode methods", "label": {"api": {"equals": [[70, 75]], "hashCode": [[81, 88]]}}}, {"text": "If you look through the Formatter javadoc, Java does not have a flag to center the output of printf, and there is no ^ flag", "label": {"api": {"Formatter": [[24, 32]]}}}, {"text": "This method is using indexOf(int)", "label": {"api": {"indexOf(int)": [[21, 32]]}}}, {"text": "The docs for String are helpful -- read them", "label": {"api": {"String": [[13, 18]]}}}, {"text": "You can write an integer to a file as 4 bytes with java.io.RandomAccessFile.writeInt(int)", "label": {"api": {"java.io.RandomAccessFile.writeInt(int)": [[51, 88]]}}}, {"text": "If you use Affine Transforms you can do all three with matrix multiplications, and you can have a single matrix that does all three operations at once", "label": {"api": {"Affine Transforms": [[11, 27]]}}}, {"text": "If you just want to print 5 digits, consider printf", "label": {"api": {"printf": [[45, 50]]}}}, {"text": "If you really want to always store 5 digits, use String[] and split using String methods", "label": {"api": {"String": [[49, 54], [74, 79]]}}}, {"text": "The substring method of String should do what you want easily", "label": {"api": {"String": [[24, 29]]}}}, {"text": "You can use getBlue(), getGreen(), and getRed()", "label": {"api": {"getBlue()": [[12, 20]], "getGreen()": [[23, 32]], "getRed()": [[39, 46]]}}}, {"text": "And if you wish to extract the alpha channel as well, you can use getAlpha()", "label": {"api": {"getAlpha()": [[66, 75]]}}}, {"text": "insertable=false means that JPA won't include the column in the insert statement when saving the entity", "label": {"api": {"insertable=false": [[0, 15]]}}}, {"text": "Use Collections#frequency() method", "label": {"api": {"Collections#frequency()": [[4, 26]]}}}, {"text": "you could implement the interface Closable so that eclipse could warn you about not closing the instance when needed", "label": {"api": {"Closable": [[34, 41]]}}}, {"text": "At least if javax.net.ssl.X509TrustManager.getAcceptableIssuers() treats an empty array as Trust Any rather than Trust Nothing", "label": {"api": {"javax.net.ssl.X509TrustManager.getAcceptableIssuers()": [[12, 64]]}}}, {"text": "Use the HashSet.contains() method to check if your string exists - this way, you'll get the return value immediately in O(1) time instead of having to iterate over all the elements", "label": {"api": {"HashSet.contains()": [[8, 25]]}}}, {"text": "You can construct such queries like the one you described with the CriteriaBuilder", "label": {"api": {"CriteriaBuilder": [[67, 81]]}}}, {"text": "You can use the overloaded EntityManager#createNativeQuery(sql,resultClass) method for this", "label": {"api": {"EntityManager#createNativeQuery(sql,resultClass)": [[27, 74]]}}}, {"text": "You can map the columns returned by your native SQL query to your entity by using @SqlResultSetMapping", "label": {"api": {"@SqlResultSetMapping": [[82, 101]]}}}, {"text": "The way to go through is using a ListCellRenderer", "label": {"api": {"ListCellRenderer": [[33, 48]]}}}, {"text": "Get ResultSetMetaData using ResultSet#getMetaData()", "label": {"api": {"ResultSetMetaData": [[4, 20]], "ResultSet#getMetaData()": [[28, 50]]}}}, {"text": "See The API documentation of Clob", "label": {"api": {"The API documentation of Clob": [[4, 32]]}}}, {"text": "You can use a TreeMap and pass a Comparator in the constructor which keeps your entries in the desired order, then just iterate over your entrySet", "label": {"api": {"TreeMap": [[14, 20]]}}}, {"text": "the default or face=SansSerif, as specified by the FontFamilyAction class nested in StyledEditorKit", "label": {"api": {"FontFamilyAction": [[51, 66]]}}}, {"text": "You can use Arrays.fill to fill an array with values, e.g.", "label": {"api": {"Arrays.fill": [[12, 22]]}}}, {"text": "You should look at ExecutorService for a better technique for running jobs on separate threads", "label": {"api": {"ExecutorService": [[19, 33]]}}}, {"text": "You can look at the Callable construct to see how to get results back from jobs which run on other threads", "label": {"api": {"Callable": [[20, 27]]}}}, {"text": "You should look into how to use KeyAdapter in order to be able to receive input events from the keyboad, e.g", "label": {"api": {"KeyAdapter": [[32, 41]]}}}, {"text": "Use the overloaded version - String#replace(char, char) which takes characters", "label": {"api": {"String#replace(char, char)": [[29, 54]]}}}, {"text": "Use the split method that takes two parameters, the second being the split limit", "label": {"api": {"split method that takes two parameters": [[8, 45]]}}}, {"text": "In Java, Math.Random returns a pseudo-random number of the range 0 (inclusive) through 1 (exclusive)", "label": {"api": {"Math.Random": [[9, 19]]}}}, {"text": "You need to pass an Iterable to the method", "label": {"api": {"Iterable": [[20, 27]]}}}, {"text": "It looks like HashMap does not implement the Iterable interface", "label": {"api": {"Iterable": [[45, 52]]}}}, {"text": "You could either subclass Map and add the Iterable interface to your subclass, or pass in a list of your map's entries", "label": {"api": {"Iterable": [[42, 49]]}}}, {"text": "You need to pass an Iterable or one of its subtypes, e.g., List, Set, etc", "label": {"api": {"Iterable": [[20, 27]]}}}, {"text": "Note that since the parameter type is Iterable<HashMap<String, Date>>, you can only pass - List<HashMap...> or Set<HashMap...>, etc", "label": {"api": {"Iterable": [[38, 45]]}}}, {"text": "If you use LSSerializer rather than Transformer, you can use LSSerializer.setNewLine to control newlines", "label": {"api": {"LSSerializer.setNewLine": [[61, 83]]}}}, {"text": "Integer.parseInt does exactly that", "label": {"api": {"Integer.parseInt": [[0, 15]]}}}, {"text": "The solution is to use BigDecimal", "label": {"api": {"BigDecimal": [[23, 32]]}}}, {"text": "Please read javadoc for Scanner", "label": {"api": {"javadoc for Scanner": [[12, 30]]}}}, {"text": "Your SimpleDateFormat is probably using DD instead of dd", "label": {"api": {"SimpleDateFormat": [[5, 20]]}}}, {"text": "The value it returns stems from an implementation of the standard Comparable interface", "label": {"api": {"Comparable interface": [[66, 85]]}}}, {"text": "You might find it useful to read http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString()": [[33, 105]]}}}, {"text": "You can create a List and pass it to each method as parameter", "label": {"api": {"List": [[17, 20]]}}}, {"text": "You need to use a SimpleDateFormat (dd-MM-yyyy will be the format) to parse the 2 input strings to Date objects and then use the Date#before(otherDate) (or) Date#after(otherDate) to compare them", "label": {"api": {"SimpleDateFormat": [[18, 33]], "Date": [[24, 27], [99, 102], [129, 132], [146, 149], [157, 160], [173, 176]], "Date#before(otherDate)": [[129, 150]], "Date#after(otherDate)": [[157, 177]]}}}, {"text": "You can use Date.before() or Date.after() or Date.equals() for date comparison", "label": {"api": {"Date.before()": [[12, 24]], "Date.after()": [[29, 40]], "Date.equals()": [[45, 57]]}}}, {"text": "JTextField.getText() (inherited method) will return the text for you", "label": {"api": {"JTextField.getText()": [[0, 19]]}}}, {"text": "But the user can give wished format, 2 digits, 3 digits or whatever he wants", "label": {"api": {"format": [[29, 34]]}}}, {"text": "The format is the standard String.format() type of String like %02d or %5d", "label": {"api": {"format": [[4, 9], [34, 39]]}}}, {"text": "How can I find out the max value that can be represented with the given format", "label": {"api": {"format": [[72, 77]]}}}, {"text": "Secondly DateFormat#format(Date) methods takes a Date object", "label": {"api": {"DateFormat#format(Date)": [[9, 31]]}}}, {"text": "You can check using Class#isInterface() method in Class", "label": {"api": {"Class#isInterface()": [[20, 38]]}}}, {"text": "This method removes session from the Manager and fires appropriate events on the HttpSessionListener", "label": {"api": {"HttpSessionListener": [[81, 99]]}}}, {"text": "Note that the object returned \"read through\" to the original collection, so you'd need to make a copy of them (such as with ArrayList(Collection)) if you need to keep the filtered list around", "label": {"api": {"ArrayList(Collection)": [[124, 144]]}}}, {"text": "You can use the String.indexOf(String str) and String.indexOf(char ch) methods", "label": {"api": {"String.indexOf(String str)": [[16, 41]], "String.indexOf(char ch)": [[47, 69]]}}}, {"text": "So http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html can help you find relevant methods, and you can go on using StringBuilder with .append() method and ur string finding and substring methods", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html": [[3, 71]]}}}, {"text": "You can invoke from your doSomeStuffAndClose method Stateful Session Bean with implemented SessionSynchronization interface", "label": {"api": {"SessionSynchronization": [[91, 112]]}}}, {"text": "You can use ConcurrentHashMap or collections like CopyOnWriteArrayLit, but beware that those approaches might be little bit expensive and simple changers to code to eliminate reading of the same collection while in a iteration will resolve this type of issues", "label": {"api": {"ConcurrentHashMap": [[12, 28]], "CopyOnWriteArrayLit": [[50, 68]]}}}, {"text": "Future can be one of the ways to do this", "label": {"api": {"Future": [[0, 5]]}}}, {"text": "If all you need is .contains(String word) and the size is just 35 MB I would recommend a HashSet,  HashSet<String>", "label": {"api": {"HashSet": [[89, 95], [99, 105]]}}}, {"text": "You could use java.util.logging which might not have some benefits of log4j but comes with the JRE and it's more flexible than logging to the console", "label": {"api": {"java.util.logging": [[14, 30]]}}}, {"text": "If you don't want to use log4j (which you should), you can use Java's standard logger", "label": {"api": {"Java's standard logger": [[63, 84]]}}}, {"text": "According to the java-doc for ByteBuffer.wrap()", "label": {"api": {"java-doc": [[17, 24]]}}}, {"text": "And the java-doc for Buffer.flip() says", "label": {"api": {"java-doc": [[8, 15]]}}}, {"text": "I would use Character.compare(char x, char y) to compare characters", "label": {"api": {"Character.compare(char x, char y)": [[12, 44]]}}}, {"text": "Or, if I am wrong and that is not the case, you can save parameters and their values into a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[92, 104]]}}}, {"text": "It should be possible, but you'll need to write your own SocketFactory and configure JavaMail to use it", "label": {"api": {"SocketFactory": [[57, 69]]}}}, {"text": "The SocketFactory will need to make the connection through the HTTP proxy server using the HTTP CONNECT protocol command, then turn the socket over to JavaMail for use", "label": {"api": {"SocketFactory": [[4, 16]]}}}, {"text": "Since you seem to use just basic features of a JTable you don't need to roll your own table model, a DefaultTableModel will work for you, and you can overrite its isCellEditable method", "label": {"api": {"DefaultTableModel": [[101, 117]]}}}, {"text": "There is actually a structure ready-made for implementing this exact architecture, It is called an ExecutorService", "label": {"api": {"ExecutorService": [[99, 113]]}}}, {"text": "See ExecutorService for details", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "For your thread pooling issue, Java has provided an ExecutorService", "label": {"api": {"ExecutorService": [[52, 66]]}}}, {"text": "Below is an example of using an ExecutorService", "label": {"api": {"ExecutorService": [[32, 46]]}}}, {"text": "The ExecutorService provides many different types of thread pools with different behaviors", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "Additionally, if you were to follow the flyweight pattern, you can also look at how useful Future and Callable objects would be in your application architecture", "label": {"api": {"Future": [[91, 96]], "Callable": [[102, 109]]}}}, {"text": "To do something else, you'd likely have to change the default exception handler for that thread (perhaps obtained via EventQueue.invokeAndWait) or all threads", "label": {"api": {"change the default exception handler for that thread": [[43, 94]], "EventQueue.invokeAndWait": [[118, 141]], "all threads": [[147, 157]]}}}, {"text": "If you have a Long object, you can call the intValue() method to get an int", "label": {"api": {"intValue() method": [[44, 60]]}}}, {"text": "Or converting all values to strings before passing it to the function using the Object toString method", "label": {"api": {"toString": [[87, 94]]}}}, {"text": "Don't use split(), use lastIndexOf()", "label": {"api": {"lastIndexOf()": [[23, 35]]}}}, {"text": "That causes a NullPointerException", "label": {"api": {"NullPointerException": [[14, 33]]}}}, {"text": "Actually a more appropriate way to do this would be to use a Matcher with a Pattern representing a regex containing the subgroups of the social security number as capturing groups", "label": {"api": {"Matcher": [[61, 67]], "Pattern": [[76, 82]]}}}, {"text": "Try to use Executor framework which uses Callables instead of Runnables", "label": {"api": {"Callables": [[41, 49]]}}}, {"text": "To convert Strings representing hexadecimal numbers to Integer, you can use the Integer.toString(String, int); method", "label": {"api": {"Integer.toString(String, int);": [[80, 109]]}}}, {"text": "Use the equals method to compare Strings", "label": {"api": {"equals": [[8, 13]]}}}, {"text": "equals compares the actual content of the Strings", "label": {"api": {"equals": [[0, 5]]}}}, {"text": "Why not use the String#isEmpty() method", "label": {"api": {"String#isEmpty()": [[16, 31]]}}}, {"text": "The case with Integer vs int, is when you need to use Integer methods (http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html)", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Integer.html": [[71, 137]]}}}, {"text": "To get the constructor of the inner class, you can use Class#getDeclaredConstructor method", "label": {"api": {"Class#getDeclaredConstructor": [[55, 82]]}}}, {"text": "You can use an ItemListener to know which item is selected and then you can set the JComboBox editable as needed", "label": {"api": {"ItemListener": [[15, 26]]}}}, {"text": "The arrays don't override toString() method, so it invokes the Object#toString() method, which generates that kind of representation", "label": {"api": {"Object#toString()": [[63, 79]]}}}, {"text": "For arrays, the Class#getName() method uses some encoding for different element type to generate unique class name", "label": {"api": {"Class#getName()": [[16, 30]]}}}, {"text": "To get the human readable representation, you can use Arrays#toString() method", "label": {"api": {"Arrays#toString()": [[54, 70]]}}}, {"text": "You should use Arrays#toString(), which is implemented this way", "label": {"api": {"Arrays#toString()": [[15, 31]], "toString()": [[22, 31]]}}}, {"text": "In Java, each object has toString() method, the default is displaying the class name representation, then adding @ and then the hashcode", "label": {"api": {"toString()": [[25, 34]]}}}, {"text": "The BitSet class is more appropriate for representing a sequence of bits", "label": {"api": {"BitSet": [[4, 9]]}}}, {"text": "To set a bit you would use the BitSet.set method", "label": {"api": {"BitSet": [[31, 36]], "BitSet.set": [[31, 40]]}}}, {"text": "It throws AssertionError", "label": {"api": {"AssertionError": [[10, 23]]}}}, {"text": "You can use System.arraycopy()", "label": {"api": {"System.arraycopy()": [[12, 29]]}}}, {"text": "You are using InputStream#available", "label": {"api": {"InputStream#available": [[14, 34]]}}}, {"text": "String#startsWith(String) method doesn't take regex", "label": {"api": {"String#startsWith(String)": [[0, 24]]}}}, {"text": "To check the first character is digit or not, you can get the character at index 0 using String#charAt(int index) method", "label": {"api": {"String#charAt(int index)": [[89, 112]]}}}, {"text": "And then test that character is digit or not using Character#isDigit(char) method", "label": {"api": {"Character#isDigit(char)": [[51, 73]]}}}, {"text": "I think the basic answer you're looking for is in the ScrollBarUI class, but be warned; that way lies madness", "label": {"api": {"ScrollBarUI": [[54, 64]]}}}, {"text": "you will have to look into ScrollBarUI class, specially inside of following functions", "label": {"api": {"ScrollBarUI": [[27, 37]]}}}, {"text": "Documentation of NodeList.item(int index)", "label": {"api": {"Documentation of NodeList.item(int index)": [[0, 40]]}}}, {"text": "As I mentioned, I'm not much of a Java GUI programmer, and what I've learned for this comes from the tutorial How to Make Dialogs and the javadoc for JOptionPane", "label": {"api": {"javadoc for JOptionPane": [[138, 160]]}}}, {"text": "Most likely you want to add a BufferedReader around System.in, then read from that", "label": {"api": {"BufferedReader": [[30, 43]], "System.in": [[52, 60]]}}}, {"text": "A quick look at javadoc will explain the contract of the Future", "label": {"api": {"javadoc will explain": [[16, 35]]}}}, {"text": "There's no easy way to do this without a fair amount of code that uses DatabaseMetaData to interrogate the database's data dictionary", "label": {"api": {"DatabaseMetaData": [[71, 86]]}}}, {"text": "What you can do is use Character.toString(char value) instead", "label": {"api": {"Character.toString(char value)": [[23, 52]]}}}, {"text": "Math.log, Math.log10, Math.log1p", "label": {"api": {"Math.log": [[0, 7], [10, 17], [22, 29]], "Math.log10": [[10, 19]], "Math.log1p": [[22, 31]]}}}, {"text": "Take a look at GregorianCalender (http://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html": [[34, 106]]}}}, {"text": "Try java.util.Calendar for more information", "label": {"api": {"java.util.Calendar": [[4, 21]]}}}, {"text": "The component you actually need to be dealing with is the JInternalFrame which contains the JPanel you mentioned above", "label": {"api": {"JInternalFrame": [[58, 71]]}}}, {"text": "I suggest that you look at either TreeSet.floor(...) or TreeSet.lower(...)", "label": {"api": {"TreeSet.floor(...)": [[34, 51]], "TreeSet.lower(...)": [[56, 73]]}}}, {"text": "When you created the FileOutputStream instance, you would have given either File object or a String path(absolute path with file name) or a FileDescriptor object", "label": {"api": {"FileOutputStream": [[21, 36]]}}}, {"text": "Have a look at the various constructors of FileOutputStream and check which was the one you had used", "label": {"api": {"FileOutputStream": [[43, 58]]}}}, {"text": "Use equals() instead of == to compare strings", "label": {"api": {"equals()": [[4, 11]]}}}, {"text": "== checks to see whether the pointers are equal (whether they point to the same object), while equals() compares the contents of the two strings and returns a boolean representing whether or not the contents are equal", "label": {"api": {"equals()": [[95, 102]]}}}, {"text": "Please take a look at \"Group number\" section in javadoc of java.util.regex.Pattern", "label": {"api": {"java.util.regex.Pattern": [[59, 81]]}}}, {"text": "You should use req.getParameter instead of req.getAttribute and take a look on the javadoc of these 2 methods getAttribute and getParameter", "label": {"api": {"getAttribute": [[47, 58], [110, 121]], "getParameter": [[19, 30], [127, 138]]}}}, {"text": "I recommend you read the docs for ArrayList link", "label": {"api": {"link": [[44, 47]]}}}, {"text": "Implement Comparable interface, so you have to add this method to your class", "label": {"api": {"Comparable": [[10, 19]]}}}, {"text": "Then call the sort static method in Collections class and you'll get your list sorted", "label": {"api": {"sort": [[14, 17], [79, 82]]}}}, {"text": "Look at the reference for more info", "label": {"api": {"reference": [[12, 20]]}}}, {"text": "One option would be to use the localToScene(double, double) method to translate the starting x,y position of the TextField to a Point2D", "label": {"api": {"localToScene(double, double)": [[31, 58]], "Scene": [[38, 42]]}}}, {"text": "This will then give you a point that contains the starting x,y position of the TextField within the Scene", "label": {"api": {"Scene": [[100, 104]]}}}, {"text": "You can use a ContextMenu which allows you to set a graphic node in a menu item (so it can really display anything) and has show commands which position it relative to another node", "label": {"api": {"ContextMenu": [[14, 24]], "set a graphic node in a menu item": [[46, 78]], "show commands which position it relative to another node": [[124, 179]]}}}, {"text": "HashMap itself doesn't maintain insertion order - but LinkedHashMap does, so use that instead", "label": {"api": {"HashMap": [[0, 6], [60, 66]], "LinkedHashMap": [[54, 66]]}}}, {"text": "This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries", "label": {"api": {"HashMap": [[33, 39]]}}}, {"text": "It's time for a LinkedHashMap, it is meant exactly to preserve insertion order", "label": {"api": {"LinkedHashMap": [[16, 28]]}}}, {"text": "Mind that even a TreeMap exists, which allows you to keep your desired order by using Comparable interface", "label": {"api": {"TreeMap": [[17, 23]]}}}, {"text": "There is a variety of properties you can get with System.getProperty(), java.vm.name seems like what you need", "label": {"api": {"System.getProperty()": [[50, 69]]}}}, {"text": "This thread, the Event Dispatch Thread, is started when you first need it", "label": {"api": {"Thread": [[32, 37]]}}}, {"text": "A really common pattern in inter-thread communication is to use a blocking queue", "label": {"api": {"blocking queue": [[66, 79]]}}}, {"text": "The objects written to the blocking queue can be anything ; for example they can represent commands to execute", "label": {"api": {"blocking queue": [[27, 40]]}}}, {"text": "This can be done using low-level APIs (Thread) or using higher level ones (ExecutorService), both being quite easy to use", "label": {"api": {"Thread": [[39, 44]], "ExecutorService": [[75, 89]]}}}, {"text": "You can use a ReentrantLock instance around the playing of a sound", "label": {"api": {"ReentrantLock": [[14, 26]]}}}, {"text": "The methods of BufferedWriter throw an IOException", "label": {"api": {"BufferedWriter": [[15, 28]], "IOException": [[39, 49]]}}}, {"text": "So you must catch the IOException inside of actionPerformed", "label": {"api": {"IOException": [[22, 32]]}}}, {"text": "Check that you have a button defined in your FXML which triggers #addClient", "label": {"api": {"button defined in your FXML which triggers #addClient": [[22, 74]]}}}, {"text": "They are for use with the MessageFormat class", "label": {"api": {"MessageFormat class": [[26, 44]]}}}, {"text": "In order to properly use HashSet (and HashMap, for that matter), you must implement a hashCode() as per the following contract", "label": {"api": {"following contract": [[108, 125]]}}}, {"text": "If you just need something executed repeatedly and millisecond-granularity is sufficient, look at Timer or ScheduledThreadPoolExecutor", "label": {"api": {"Timer": [[98, 102]], "ScheduledThreadPoolExecutor": [[107, 133]]}}}, {"text": "Use a DecimalFormat to cut off the display after two decimals", "label": {"api": {"DecimalFormat": [[6, 18]]}}}, {"text": "You could even use a BigDecimal instead, whose precision is arbitrary", "label": {"api": {"BigDecimal": [[21, 30]]}}}, {"text": "You can just select random entries from colors, and add them into a Set until the set has four elements", "label": {"api": {"Set": [[68, 70]]}}}, {"text": "You can use the DatatypeConverter class to convert the hex-string into an array of bytes ..", "label": {"api": {"DatatypeConverter": [[16, 32]]}}}, {"text": "You called your class Math, so the built-in java.lang.Math class can't be resolved", "label": {"api": {"java.lang.Math": [[44, 57]]}}}, {"text": "As per the JavaDocs for ServerSocket, you can set a backlog as the 2nd parameter", "label": {"api": {"JavaDocs for ServerSocket": [[11, 35]]}}}, {"text": "Java - String, you'll find that it extends java.lang.Object", "label": {"api": {"Java - String": [[0, 12]]}}}, {"text": "Looking at it's javadoc http://docs.oracle.com/javase/6/docs/api/java/lang/String.html, it is confirmed", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html": [[24, 85]]}}}, {"text": "If you want to order some objects by their partial state(a few fields) you should use a Comparator", "label": {"api": {"Comparator": [[88, 97]]}}}, {"text": "Double.MIN_VALUE is the minimum positive value", "label": {"api": {"Double.MIN_VALUE": [[0, 15]]}}}, {"text": "Also the first has the advantage that the implementation of the List can change (to a LinkedList for example), without affecting the rest of the code", "label": {"api": {"LinkedList": [[86, 95]]}}}, {"text": "This is will be difficult to do with an ArrayList, not only because you will need to change ArrayList to LinkedList everywhere, but also because you may have used ArrayList specific methods", "label": {"api": {"LinkedList": [[105, 114]]}}}, {"text": "You could instead use a StringBuilder and append strings to that", "label": {"api": {"StringBuilder": [[24, 36]]}}}, {"text": "Write a custom Comparator, and pass it's instance to the sort method", "label": {"api": {"Comparator": [[15, 24]]}}}, {"text": "When you use Collections.sort(), you can pass a Comparator to implement a custom method for checking what's higher and what's lower in search order", "label": {"api": {"Collections.sort()": [[13, 30]], "Comparator": [[48, 57]]}}}, {"text": "Java 7 has introduced ConcurrentLinkedDeque and Java 6 has LinkedBlockingDeque", "label": {"api": {"ConcurrentLinkedDeque": [[22, 42]], "LinkedBlockingDeque": [[59, 77]]}}}, {"text": "If I were to use only the non-blocking methods in LinkedBlockingDeque such as addFirst() and removeFirst() does it have any difference to ConcurrentLinkedDeque", "label": {"api": {"ConcurrentLinkedDeque": [[138, 158]], "LinkedBlockingDeque": [[50, 68]]}}}, {"text": "If you disregard the blocking aspect, is there any other difference between ConcurrentLinkedDeque and LinkedBlockingDeque, apart from LinkedBlockingDeque being bounded", "label": {"api": {"ConcurrentLinkedDeque": [[76, 96]], "LinkedBlockingDeque": [[102, 120], [134, 152]]}}}, {"text": "You can try and do a ReplaceAll with a regex, it's a bit clanky but it does the job", "label": {"api": {"ReplaceAll": [[21, 30]]}}}, {"text": "Also, I would rather use ArrayList to replace Vector", "label": {"api": {"ArrayList": [[25, 33]]}}}, {"text": "Matcher.matches() wants to match the whole string", "label": {"api": {"Matcher.matches()": [[0, 16]]}}}, {"text": "If you want to match part of the string, use Matcher.find()", "label": {"api": {"Matcher.find()": [[45, 58]]}}}, {"text": "If you are generating classes from a WSDL when you build, your service class will extend javax.xml.ws.Service and therefore will inherit the getWSDLDocumentLocation method", "label": {"api": {"getWSDLDocumentLocation": [[141, 163]]}}}, {"text": "LinkedHashSet goes somewhat in the right direction but it's missing index access and bulk append", "label": {"api": {"LinkedHashSet": [[0, 12]]}}}, {"text": "First you look here String.split() and then you move onto Arrays.asList", "label": {"api": {"String.split()": [[20, 33]], "Arrays.asList": [[58, 70]]}}}, {"text": "When you do, you can split(String regex) them and convert the resulting array to a List", "label": {"api": {"split(String regex)": [[21, 39]]}}}, {"text": "You can use following String#replaceAll call to replace all numbers (followed by 0 or more spaces) by an empty string", "label": {"api": {"String#replaceAll": [[22, 38]]}}}, {"text": "Or if this is homework and you have to do by yourself see String#toLowerCase() and then String#toUpperCase() for the first character, see String#substring", "label": {"api": {"String#toLowerCase()": [[58, 77]], "String#toUpperCase()": [[88, 107]], "String#substring": [[138, 153]]}}}, {"text": "in servlet filter) and then check session timeout and invalidate the session manually (e.g", "label": {"api": {"invalidate the session manually": [[54, 84]]}}}, {"text": "A more effective way would be to use a List", "label": {"api": {"List": [[39, 42]]}}}, {"text": "Wrap your msgHistory.appendText in a Platform.runLater() call", "label": {"api": {"Platform.runLater()": [[37, 55]]}}}, {"text": "RuntimeExceptions dont have to be handled in try-catch block so they dont have to be declared as thrown and NoSuchElementException is RuntimeException because it extends it", "label": {"api": {"NoSuchElementException": [[108, 129]]}}}, {"text": "And the javadoc of Map<K, V>.keySet() says", "label": {"api": {"javadoc of Map<K, V>.keySet()": [[8, 36]]}}}, {"text": "Yet another approach is to use asynchronous I/O", "label": {"api": {"asynchronous I/O": [[31, 46]]}}}, {"text": "Completion handler  returns used buffer into tthe empty buffers queue", "label": {"api": {"Completion handler": [[0, 17]]}}}, {"text": "Using Java HashSet, checking a set of rights can be easily done in O(1) time, adding nothing to E+V complexity of the BFS algorithm (assuming number of available rights is constant)", "label": {"api": {"HashSet": [[11, 17]]}}}, {"text": "In each node you store a set of rights, and then check if all required rights are in the set (HashSet.contains(Object) is O(1))", "label": {"api": {"HashSet": [[94, 100]], "HashSet.contains(Object)": [[94, 117]]}}}, {"text": "Also, you can represent your rights as enum and use EnumSet to store the right sets", "label": {"api": {"EnumSet": [[52, 58]]}}}, {"text": "EnumSet is implemented as bit vectors and so is as fast as you can get with sets", "label": {"api": {"EnumSet": [[0, 6]]}}}, {"text": "Important is using (?m) for MULTILINE mode here that lets you use line start/end anchors for each line", "label": {"api": {"MULTILINE": [[28, 36]]}}}, {"text": "That is, unless you use the Iterator#remove method", "label": {"api": {"Iterator#remove": [[28, 42]]}}}, {"text": "You can simple get the year from Calendar instance using Calendar#get(int field) method", "label": {"api": {"Calendar#get(int field)": [[57, 79]]}}}, {"text": "here is the link", "label": {"api": {"link": [[12, 15]]}}}, {"text": "In Java 8 there's a collection called java.time in which you easily can obtain the current year from your computer's clock", "label": {"api": {"java.time": [[38, 46]]}}}, {"text": "Given that the values in your list are unique, I would suggest you to use a Set, more specifically a TreeSet, as you are anyways sorting your list", "label": {"api": {"TreeSet": [[101, 107]]}}}, {"text": "You can use the NavigableSet#floor(E) method which does exactly what you want", "label": {"api": {"NavigableSet#floor(E)": [[16, 36]]}}}, {"text": "Just you have to pass a Comparator<YourClass> to the TreeSet constructor while instantiating it", "label": {"api": {"TreeSet": [[53, 59]]}}}, {"text": "Also, you can use an AtomicInteger instead, which is better suited as atomic counter, in case of multithreaded application", "label": {"api": {"AtomicInteger": [[21, 33]]}}}, {"text": "BigInteger is immutable", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "The result of [BigIteger].mutlipy([BigInteger]) needs to be reassigned to get desired output like", "label": {"api": {"BigInteger": [[35, 44]]}}}, {"text": "Java offers the BigDecimal class", "label": {"api": {"BigDecimal": [[16, 25]]}}}, {"text": "But as Java offers a nice ready-to-use class for fixed point math (BigDecimal), you could give it a try", "label": {"api": {"BigDecimal": [[67, 76]]}}}, {"text": "You can choose from several different rounding modes and determine how many decimal places you'd like to have", "label": {"api": {"rounding modes": [[38, 51]]}}}, {"text": "Proxy classes are an interesting corner case but my best guess is that proxy class definition involves generating some byte-code at runtime that then goes through the normal class loading system in most JVMs", "label": {"api": {"Proxy classes": [[0, 12]]}}}, {"text": "I've used this website to help me understand Regular Expressions a bit more as well as JPS, but I'm unable to find the right syntax", "label": {"api": {"JPS": [[87, 89]]}}}, {"text": "IllegalArgumentException is the way to go", "label": {"api": {"IllegalArgumentException": [[0, 23]]}}}, {"text": "This situation is exactly what IllegalArgumentException was made for", "label": {"api": {"IllegalArgumentException": [[31, 54]]}}}, {"text": "By the way there is method for sending temporary (302) redirects (used also by Spring's DefaultRedirectStrategy)", "label": {"api": {"method for sending temporary (302) redirects": [[20, 63]]}}}, {"text": "In Java you can use the TreeMap or HashMap classes", "label": {"api": {"TreeMap": [[24, 30]], "HashMap": [[35, 41]]}}}, {"text": "This can be non-blocking if used correctly but is more complicated, however you need to use a Selector instead of calling accept on your own", "label": {"api": {"Selector": [[94, 101]]}}}, {"text": "You cannot remove while iterating over a List with anything other than an Iterator", "label": {"api": {"Iterator": [[74, 81]]}}}, {"text": "enhanced foreach loops then your will get the correct error if you even try to addto/deletefrom the list while iterating - you will get a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[138, 168]]}}}, {"text": "2) use an actual Iterator for the inner loop so that you can call Iterator.remove to remove the last returned element from the List", "label": {"api": {"Iterator": [[17, 24], [66, 73]]}}}, {"text": "Because that is done via the Iterator it doesn't result in an error", "label": {"api": {"Iterator": [[29, 36]]}}}, {"text": "As the API states at http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html, add() just returns a new BigInteger; it doesn't affect the BigInteger that calls it", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html": [[21, 86]]}}}, {"text": "You can keep checking the status your task using Future isDone method", "label": {"api": {"isDone": [[56, 61]]}}}, {"text": "use a hash map (http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html)", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html": [[16, 78]]}}}, {"text": "If you have one part of your code that needs to be executed repeatedly, using a Timer can solve that perfectly", "label": {"api": {"Timer": [[80, 84]]}}}, {"text": "If you have multiple and different parts of code that need to be executed with given delays, you should use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[110, 133]]}}}, {"text": "Try Integer.valueOf with a radix of 2", "label": {"api": {"Integer.valueOf": [[4, 18]]}}}, {"text": "I suggest taking a look at the Java docs at http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html, or reading your relevant course material", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[44, 106]]}}}, {"text": "Note that strbuff.charAt(9) will return you a char and to covert that to upper case you will need to call Character.toUpperCase(char) like this", "label": {"api": {"Character.toUpperCase(char)": [[106, 132]]}}}, {"text": "Use bounded ArrayBlockingQueue to avoid saturation of queues if producers work faster than consumers", "label": {"api": {"ArrayBlockingQueue": [[12, 29]]}}}, {"text": "Consider using Arrays.sort(array, comparator) if sorting is not the task itself", "label": {"api": {"Arrays.sort(array, comparator)": [[15, 44]]}}}, {"text": "Hence, Make your DVD implement Comparable with a comparison based on the director, and then use a TreeSet", "label": {"api": {"TreeSet": [[98, 104]]}}}, {"text": "There's the method String.replaceAll(String regex,String replacement) that does exactly what you want", "label": {"api": {"String.replaceAll(String regex,String replacement)": [[19, 68]]}}}, {"text": "If you use NetBeans, you can simply auto-generate the equals function (not sure about Eclipse)", "label": {"api": {"equals": [[54, 59]]}}}, {"text": "Other than that it boils down to overwriting the equals function of Object", "label": {"api": {"equals": [[49, 54]]}}}, {"text": "Math.random() isn't the best way of generating random numbers, you should use Random.nextInt() instead", "label": {"api": {"Random.nextInt()": [[78, 93]]}}}, {"text": "Just use the appropriate constructor of Scanner", "label": {"api": {"Scanner": [[40, 46]]}}}, {"text": "Then try ScheduledExecutorService, as already suggested by @BoristheSpider", "label": {"api": {"ScheduledExecutorService": [[9, 32]]}}}, {"text": "If precisely representing 4.35 is necessary, take a look at Java BigDecimal type", "label": {"api": {"BigDecimal": [[65, 74]]}}}, {"text": "To get the primitive data type you can always use charValue() method in Character class", "label": {"api": {"charValue()": [[50, 60]]}}}, {"text": "Take a look at the Future interface in the concurrent package of java", "label": {"api": {"Future": [[19, 24]]}}}, {"text": "You should use the System.in.read() for read from the standard input", "label": {"api": {"System.in.read()": [[19, 34]]}}}, {"text": "If the rules of assignment allow the use of class Arrays, this is what you can use instead of your own cut method", "label": {"api": {"Arrays": [[50, 55]]}}}, {"text": "For copying the content you could use the method System#arraycopy", "label": {"api": {"System#arraycopy": [[49, 64]]}}}, {"text": "Because BufferedReader#readLine returns \"null if the end of the stream has been reached\"", "label": {"api": {"BufferedReader#readLine": [[8, 30]]}}}, {"text": "And then there's ServletContextListener", "label": {"api": {"ServletContextListener": [[17, 38]]}}}, {"text": "You could provide a custom ButtonUI, and use that for the buttons, instead of overriding paintComponent()", "label": {"api": {"ButtonUI": [[27, 34]]}}}, {"text": "However, BasicButtonUI has a protected paintText() method that can do what you want (you don't necessarily need to call it manually", "label": {"api": {"ButtonUI": [[14, 21]], "BasicButtonUI": [[9, 21]]}}}, {"text": "So if you extend BasicButtonUI you can simply let it draw the string", "label": {"api": {"ButtonUI": [[22, 29]], "BasicButtonUI": [[17, 29]]}}}, {"text": "The setProperty(name, value) method takes supported java types and Collection of supported java types (this includes ArrayList)", "label": {"api": {"Collection": [[67, 76]]}}}, {"text": "As can be seen from the Canvas class and the JFrame class, the methods related to BufferStrategy (of the Canvas and of the JFrame) don't come from the same parent", "label": {"api": {"Canvas": [[24, 29], [105, 110]], "JFrame": [[45, 50], [123, 128]]}}}, {"text": "The createBufferStrategy of JFrame for example, is inherited by Window, which is not a parent of Canvas, while Canvas implements its own", "label": {"api": {"Canvas": [[97, 102], [111, 116]], "JFrame": [[28, 33]]}}}, {"text": "So I'm wondering whether the functionality of the two is the same, and whether my program will behave the same when replacing the createBufferStrategy/getBufferStrategy of the Canvas with the createBufferStrategy/getBufferStrategy of the Window", "label": {"api": {"Canvas": [[176, 181]]}}}, {"text": "I've decided to do this \"replace move\" because I read yesterday JPanel is no slower than Canvas here", "label": {"api": {"Canvas": [[89, 94]]}}}, {"text": "Canvas and InputMap", "label": {"api": {"Canvas": [[0, 5]]}}}, {"text": "So I basically want to add JPanel instead of Canvas now", "label": {"api": {"Canvas": [[45, 50]]}}}, {"text": "When I started coding, my first choice was Canvas because of this", "label": {"api": {"Canvas": [[43, 48]]}}}, {"text": "You need to put all 3 buttons in a ButtonGroup", "label": {"api": {"ButtonGroup": [[35, 45]]}}}, {"text": "I can tell that a class is an inner class using the Class.isMemberClass() method, but I can't see a neat way of determining whether or not the member class is static or not, which is how I would expect to figure out which constructor to call", "label": {"api": {"Class.isMemberClass()": [[52, 72]]}}}, {"text": "Just use java's String replace method", "label": {"api": {"replace": [[23, 29]]}}}, {"text": "Also the javadoc for Window.Type states it is available only since 1.7", "label": {"api": {"Window.Type": [[21, 31]]}}}, {"text": "Use ByteBuffers for caching", "label": {"api": {"ByteBuffers": [[4, 14]]}}}, {"text": "Instead of manually converting each character, you may use the java.lang.String(byte[]) constructor", "label": {"api": {"java.lang.String(byte[])": [[63, 86]]}}}, {"text": "Sounds like you could use the String constructor that takes byte[] and Charset arguments, using a Charset that's appropriate for the data you're receiving (\"IBM437\")", "label": {"api": {"that takes byte[] and Charset arguments": [[49, 87]]}}}, {"text": "I am having trouble understanding this comment from the Java serialization documentation", "label": {"api": {"Java serialization documentation": [[56, 87]]}}}, {"text": "The Double.valueOf method, which also parses Strings (it just creates a Double instead of a double) goes to lengths to specify what is allowed and won't throw a NumberFormatException", "label": {"api": {"Double.valueOf method": [[4, 24]]}}}, {"text": "You can indeed use StringBuffer (or StringBuilder if you don't care about thread safety) to temporarily hold words as you encounter them", "label": {"api": {"StringBuilder": [[36, 48]]}}}, {"text": "Arrays#fill() doesn't return the array", "label": {"api": {"Arrays#fill()": [[0, 12]]}}}, {"text": "I am having trouble understanding the Stream interface in Java 8, especially where it has to do with the Spliterator and Collector interfaces", "label": {"api": {"Stream": [[38, 43]], "Spliterator": [[105, 115]], "Collector": [[121, 129]]}}}, {"text": "My problem is that I simply can't understand Spliterator and the Collector interfaces yet, and as a result, the Stream interface is still somewhat obscure to me", "label": {"api": {"Stream": [[112, 117]], "Spliterator": [[45, 55]], "Collector": [[65, 73]]}}}, {"text": "What exactly is a Spliterator and a Collector, and how can I use them", "label": {"api": {"Spliterator": [[18, 28]], "Collector": [[36, 44]]}}}, {"text": "If I am willing to write my own Spliterator or Collector (and probably my own Stream in that process), what should I do and not do", "label": {"api": {"Stream": [[78, 83]], "Spliterator": [[32, 42]], "Collector": [[47, 55]]}}}, {"text": "Use the String#matches() method rather than Pattern.matches()", "label": {"api": {"String#matches()": [[8, 23]], "Pattern.matches()": [[44, 60]]}}}, {"text": "Pattern.matches() method takes regex as it's first argument", "label": {"api": {"Pattern.matches()": [[0, 16]]}}}, {"text": "You can use String.valueOf(char[])", "label": {"api": {"String.valueOf(char[])": [[12, 33]]}}}, {"text": "Under the hood, this calls the String(char[]) constructor", "label": {"api": {"String(char[])": [[31, 44]]}}}, {"text": "Look to javax.xml.bind.DatatypeConverter.parseBase64Binary(String) to get a byte[] of the String", "label": {"api": {"javax.xml.bind.DatatypeConverter.parseBase64Binary(String)": [[8, 65]]}}}, {"text": "Use the byte[] to construct a ByteArrayInputStream", "label": {"api": {"ByteArrayInputStream": [[30, 49]]}}}, {"text": "You can use LinkedHashSet if you need to remove duplicates and preserve an order in which you insert items", "label": {"api": {"LinkedHashSet": [[12, 24]], "HashSet": [[18, 24]]}}}, {"text": "If you don't need to preserve an insertion order, you can change set's implementaion to HashSet", "label": {"api": {"HashSet": [[88, 94]]}}}, {"text": "java.lang.String.split(String regex) takes a regular expressions as the argument", "label": {"api": {"java.lang.String.split(String regex)": [[0, 35]]}}}, {"text": "Note that when you do int numbers = keyboard.nextInt();, it  reads only the int value (and skips the \\n which is the enter key you press right after) - See Scanner#nextInt", "label": {"api": {"Scanner#nextInt": [[156, 170]]}}}, {"text": "For a more generic solution, BigInteger also has a toString function which takes in a radix (16 being hex of course)", "label": {"api": {"a toString function": [[49, 67]]}}}, {"text": "And, please use SwingUtilities.invokeLater for calling Swing/AWT functions from different threads", "label": {"api": {"SwingUtilities.invokeLater": [[16, 41]]}}}, {"text": "Otherwise if you don't have database, this looks like a job for either TreeMap or ConcurrentSkipList", "label": {"api": {"TreeMap": [[71, 77]], "ConcurrentSkipList": [[82, 99]]}}}, {"text": "Both implements the subMap(K, K), headMap(K), and tailMap(K) method from NavigableMap interface", "label": {"api": {"subMap(K, K)": [[20, 31]], "headMap(K)": [[34, 43]], "tailMap(K)": [[50, 59]], "NavigableMap interface": [[73, 94]]}}}, {"text": "You can specify a custom ordering for any SortedMap (and its subinterfaces) by implementing Comparable interface in your keys or by specifying Comparator when creating your collection", "label": {"api": {"Comparable": [[92, 101]], "Comparator": [[143, 152]]}}}, {"text": "If you don't need to have key-value mapping, you can also simply use NavigableSet and their implementations TreeSet or ConcurrentSkipListSet", "label": {"api": {"ConcurrentSkipList": [[119, 136]], "NavigableSet": [[69, 80]], "TreeSet": [[108, 114]], "ConcurrentSkipListSet": [[119, 139]]}}}, {"text": "This is similar to the standard Comparable interface", "label": {"api": {"Comparable": [[32, 41]]}}}, {"text": "I suggest this one-line solution using String#subString(int beginIndex, int endIndex)", "label": {"api": {"String#subString(int beginIndex, int endIndex)": [[39, 84]]}}}, {"text": "It seems you'll have to get familiar with the JavaCompiler API to do this", "label": {"api": {"JavaCompiler": [[46, 57]]}}}, {"text": "As a Java Programmer, you should know about equals", "label": {"api": {"equals": [[44, 49]]}}}, {"text": "I worked around it by not using getScaledInstance and instead scaling while drawing", "label": {"api": {"getScaledInstance": [[32, 48]], "scaling while drawing": [[62, 82]]}}}, {"text": "I wondering to know why this snippet of code has executed without Throwing RuntimeException(exactly ArithmethicException)", "label": {"api": {"ArithmethicException": [[100, 119]]}}}, {"text": "r.nextInt() would give you any random integer, regardless of the array being there", "label": {"api": {"r.nextInt()": [[0, 10]]}}}, {"text": "When you call private Random r = newRandom(weapons.length); you are actually seeding the RNG with 3, and not setting an upper limit of 3", "label": {"api": {"Random(weapons.length);": [[36, 58]]}}}, {"text": "For the second, you are picking a random int with a bound, namely from 0 to the length of the array(not including the upper bound)", "label": {"api": {"picking a random int with a bound": [[24, 56]]}}}, {"text": "Write your own OutputStream implementation that adds any bytes written to the text area", "label": {"api": {"OutputStream": [[15, 26]]}}}, {"text": "Then wrap it in a PrintStream and pass it to System.setOut()", "label": {"api": {"System.setOut()": [[45, 59]]}}}, {"text": "You may want to register an UncaughtExceptionHandler with the thread, in which you can do the required logging", "label": {"api": {"register an UncaughtExceptionHandler": [[16, 51]]}}}, {"text": "Looks like you want nextLine()", "label": {"api": {"nextLine()": [[20, 29]]}}}, {"text": "You can manipulate the String within Java with the help of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[59, 74]]}}}, {"text": "You should consider working with Calendar, as Date is deprecated", "label": {"api": {"Date": [[46, 49]]}}}, {"text": "Check JavaDoc of #getHeaderField - it returns just a single value", "label": {"api": {"#getHeaderField": [[17, 31]]}}}, {"text": "You need to use #getHeaderFields as that will return all headers values", "label": {"api": {"#getHeaderField": [[16, 30]], "#getHeaderFields": [[16, 31]]}}}, {"text": "You should probably implement the java.lang.Comparable interface", "label": {"api": {"java.lang.Comparable": [[34, 53]]}}}, {"text": "You should use String#split", "label": {"api": {"String#split": [[15, 26]]}}}, {"text": "I assume you already know the difference between int and Integer", "label": {"api": {"Integer": [[57, 63]]}}}, {"text": "The loops will behave the same, but using int is preferable when you don't need Integer", "label": {"api": {"Integer": [[80, 86]]}}}, {"text": "Use int when you can live without Integer", "label": {"api": {"Integer": [[34, 40]]}}}, {"text": "The only option I can see is to iterate over each element and determine the index, then use ArrayList#remove(int index)", "label": {"api": {"ArrayList#remove(int index)": [[92, 118]]}}}, {"text": "Instead you should be able to explicitly specify the column you want returned using prepareStatement(String sql, int[] columnIndexes) or prepareStatement(String sql, String[] columnNames)", "label": {"api": {"prepareStatement(String sql, int[] columnIndexes)": [[84, 132]], "prepareStatement(String sql, String[] columnNames)": [[137, 186]]}}}, {"text": "Use Thread.setDaemon(true) for the threads you create", "label": {"api": {"Thread.setDaemon(true)": [[4, 25]]}}}, {"text": "You can use regular expressions but it's also relatively simple to just loop over each string yourself and use Character.isLetter() to check each character", "label": {"api": {"Character.isLetter()": [[111, 130]]}}}, {"text": "See Pattern for more details", "label": {"api": {"Pattern": [[4, 10]]}}}, {"text": "If performance is irrelevant you could create a collection from the array and use collection max and min", "label": {"api": {"collection max": [[82, 95]]}}}, {"text": "You might want to have a look at the MappedByteBuffer and it's asFloatBuffer() methods", "label": {"api": {"MappedByteBuffer": [[37, 52]], "asFloatBuffer()": [[63, 77]]}}}, {"text": "Java's finalize method is called after the JVM determines an object is eligible for garbage collection", "label": {"api": {"finalize": [[7, 14]]}}}, {"text": "My question is whether finalize is guaranteed to be called for objects that are in fact garbage collected", "label": {"api": {"finalize": [[23, 30]]}}}, {"text": "And if the garbage is not traversed, then how do we guarantee that finalize is called for objects that become garbage", "label": {"api": {"finalize": [[67, 74]]}}}, {"text": "It seems that either a) there is no guarantee that finalize will be called for these objects that become garbage in the youngest generation, or b) there is a guarantee that finalize will be called, but objects which override finalize are somehow handled differently", "label": {"api": {"finalize": [[51, 58], [173, 180], [225, 232]]}}}, {"text": "x.getClass().getClass() will always return the class object representing java.lang.Class for any non-null value x", "label": {"api": {"java.lang.Class": [[73, 87]], "x.getClass()": [[0, 11]]}}}, {"text": "That's because x.getClass() can only return a Class object and you're asking that class object what type it is (obviously", "label": {"api": {"x.getClass()": [[15, 26]]}}}, {"text": "What you seem to want to try is not x.getClass().getClass() but x.getClass().getSuperClass()", "label": {"api": {"x.getClass()": [[36, 47], [64, 75]], "x.getClass().getSuperClass()": [[64, 91]]}}}, {"text": "It sounds like you're looking for Class.getInterfaces()", "label": {"api": {"Class.getInterfaces()": [[34, 54]]}}}, {"text": "Another way is to use the split method", "label": {"api": {"split": [[26, 30]]}}}, {"text": "I don't know why you are trying to instantiate a Map.Entry", "label": {"api": {"Map.Entry": [[49, 57]]}}}, {"text": "I guess you can simply use a TreeMap", "label": {"api": {"TreeMap": [[29, 35]]}}}, {"text": "Even though, if you want that, you can instantiate AbstractMap.SimpleEntry like this", "label": {"api": {"AbstractMap.SimpleEntry": [[51, 73]]}}}, {"text": "Note that Map.Entry is an interface", "label": {"api": {"Map.Entry": [[10, 18]]}}}, {"text": "And of course, as rightly specified in comments by @Louis, Map.Entry doesn't implement a Comparable, so you won't be able to add it to TreeSet", "label": {"api": {"Map.Entry": [[59, 67]]}}}, {"text": "You can however create your own implementation of this interface, make that implement Comparable<Map.Entry<K, V>>, and use that instead", "label": {"api": {"Map.Entry": [[97, 105]]}}}, {"text": "But as I said, you can use a TreeMap, and use its entrySet() method which will give you a Set<Map.Entry<K, V>>", "label": {"api": {"TreeMap": [[29, 35]], "Map.Entry": [[94, 102]], "entrySet()": [[50, 59]]}}}, {"text": "I very much want to use Map.computeIfAbsent but it has been too long since lambdas in undergrad", "label": {"api": {"Map.computeIfAbsent": [[24, 42]]}}}, {"text": "Since simplelogger.properties is read as a normal Java Properties file by SimpleLogger, references to environment variables are not resolved within", "label": {"api": {"Properties": [[55, 64]]}}}, {"text": "Class#getDeclaredMethods() is what you're looking for", "label": {"api": {"Class#getDeclaredMethods()": [[0, 25]]}}}, {"text": "If you'd like to print method names along with parameter information take a look at Method#getParameterTypes()", "label": {"api": {"Method#getParameterTypes()": [[84, 109]]}}}, {"text": "Running in circles in grepcode trying to find the source for how a rotated image is drawn with subpixel accuracy", "label": {"api": {"rotated image": [[67, 79]]}}}, {"text": "A rotation is rarely a mapping from integer (i,j) to integer (u,v) so at some intermediate level a sub-pixel view of the rotated image is created", "label": {"api": {"rotated image": [[121, 133]]}}}, {"text": "The guava eventbus offers a publish/subscribe messaging component, designed to simplify  the implemenation of the classic Observer pattern", "label": {"api": {"Observer": [[122, 129]]}}}, {"text": "Instead of having to explicitly register dedicated Listener or Observer instances with an event emitting object, one registers a class, which is interested in certain events with the bus", "label": {"api": {"Observer": [[63, 70]]}}}, {"text": "In any case the JDK ships with the class ArrayDeque which fulfill your requirements without being a piece o code pasted from a book", "label": {"api": {"ArrayDeque": [[41, 50]]}}}, {"text": "In such case I would consider implementing web service using Provider API (standard part of JAX-WS)", "label": {"api": {"Provider API": [[61, 72]]}}}, {"text": "Besides, String is final, so there really is no point to saying", "label": {"api": {"String is final": [[9, 23]]}}}, {"text": "Take a look at the AbstractList.html#addAll", "label": {"api": {"AbstractList.html#addAll": [[19, 42]]}}}, {"text": "ObjectInputStream expects a visible no-arg constructor for the class instance you are trying to deserialize", "label": {"api": {"ObjectInputStream": [[0, 16]]}}}, {"text": "nextInt() only consumes the integer, it doesn't consume the whitespace characters (EOL in this case)", "label": {"api": {"nextInt()": [[0, 8]]}}}, {"text": "Use two nextLine(), one to consume the EOL character, one to prompt you for input", "label": {"api": {"nextLine()": [[8, 17]]}}}, {"text": "You will need to attach a DocumentListener to your textfield", "label": {"api": {"DocumentListener": [[26, 41]]}}}, {"text": "In Java, the character | in a regular expression is an operator that matches the expressions on either side of the pipe", "label": {"api": {"operator that matches the expressions on either side of the pipe": [[55, 118]]}}}, {"text": "For example, the Set interface wants to include methods to manipulate the set, but also wants to provide for implementations that do not allow manipulation", "label": {"api": {"Set": [[17, 19]]}}}, {"text": "On the other hand, imagine an abstract base class HTTPServlet similar to the one in javax.servlet.http, but wich is only allowed to deal with GET requests", "label": {"api": {"the one in javax.servlet.http": [[73, 101]]}}}, {"text": "In Java8 you can use Optional to handle null cases properly", "label": {"api": {"Optional": [[21, 28]]}}}, {"text": "next() doesn't handle the end of the line, so when you call next() again, it'll take as input the enter (\\n) you entered before", "label": {"api": {"next()": [[0, 5], [60, 65]]}}}, {"text": "You should call nextLine() after each next() (So it will swallow the \\n from the previous one)", "label": {"api": {"next()": [[38, 43]]}}}, {"text": "But the best thing would be to use the String split method", "label": {"api": {"String split": [[39, 50]]}}}, {"text": "What you see is result of default toString implementation for Object", "label": {"api": {"default toString implementation for Object": [[26, 67]]}}}, {"text": "Then you are free to doSystem.out.println(leagueList) as List has a nice implementation of toString", "label": {"api": {"implementation of toString": [[73, 98]]}}}, {"text": "If you don't know the number of inputs (but you know what symbol will represent the end of the input), you can use a while loop and an ArrayList", "label": {"api": {"ArrayList": [[135, 143]]}}}, {"text": "where indexOf() takes as a parameter any string", "label": {"api": {"indexOf()": [[6, 14]]}}}, {"text": "In a TreeMap, both put() and remove() are O(log n), so removal followed by addition is a very good starting point", "label": {"api": {"both put() and remove() are O(log n)": [[14, 49]]}}}, {"text": "Use the Integer.parseInt method to parse a String into an int, then add the values", "label": {"api": {"Integer.parseInt method": [[8, 30]]}}}, {"text": "According to the JFileChooser documentation, it should tell it not to add the all-file-types file filter to the file filter list", "label": {"api": {"JFileChooser documentation": [[17, 42]]}}}, {"text": "Just use the already existing - Arrays.toString() method, which is overloaded for different types of primitive arrays, and Object[] array", "label": {"api": {"Arrays.toString()": [[32, 48]]}}}, {"text": "Do not reinvent the wheel, use Arrays.toString or Arrays.deepToString", "label": {"api": {"Arrays.toString": [[31, 45]], "Arrays.deepToString": [[50, 68]]}}}, {"text": "For example the Java API is fully documented using Javadocs for reading online or in an IDE", "label": {"api": {"reading online": [[64, 77]]}}}, {"text": "As much as i have understand of the three functionality you described, I think using ExectuorService would do much more than what you are currently trying to do", "label": {"api": {"ExectuorService": [[85, 99]]}}}, {"text": "n represents the parameter of the Random#nextInt(int n) method", "label": {"api": {"Random#nextInt(int n)": [[34, 54]]}}}, {"text": "As pointed out in the comments, the common implementation of Statement, StatementImpl, provides an implementation of toString() method so that you can even just print the Statement", "label": {"api": {"toString()": [[117, 126]]}}}, {"text": "You can parse the SOAP response using Java's XML XPath API", "label": {"api": {"XML XPath API": [[45, 57]]}}}, {"text": "What you really want is a Map (http://docs.oracle.com/javase/7/docs/api/java/util/Map.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Map.html": [[31, 89]]}}}, {"text": "The abstract class MidiMessage has 3 subclasses", "label": {"api": {"MidiMessage": [[19, 29]]}}}, {"text": "MetaMessage, ShortMessage, SysexMessage", "label": {"api": {"ShortMessage": [[13, 24]], "SysexMessage": [[27, 38]]}}}, {"text": "Problem is that the hashcode of a MidiMessage is never the same", "label": {"api": {"MidiMessage": [[34, 44]]}}}, {"text": "Therefore the only difference between MidiMessages is the data byte-array", "label": {"api": {"MidiMessage": [[38, 48]]}}}, {"text": "If you want to allow arbitrary inputs, read input as a String, then convert to double as needed", "label": {"api": {"convert to double": [[68, 84]]}}}, {"text": "If you use Integer.parseInt() (or Long.parseLong()), you'll still be restricted to number in the range of a 32-bit (or 64-bit) signed integer", "label": {"api": {"Integer.parseInt()": [[11, 28]], "Long.parseLong()": [[34, 49]]}}}, {"text": "Note that String.matches() must match the whole string to return true, so no need for start or end anchors ^ and $ - they are implied", "label": {"api": {"String.matches()": [[10, 25]]}}}, {"text": "Executors.newSingleThreadExecutor implements this technique", "label": {"api": {"Executors.newSingleThreadExecutor": [[0, 32]]}}}, {"text": "Use java.util.BitSet, which will pack the bits in one-eighth of the space compared to using a boolean array", "label": {"api": {"java.util.BitSet": [[4, 19]]}}}, {"text": "input.charAt(j - 1) will throw IndexOutOfBoundsException when j is 0", "label": {"api": {"IndexOutOfBoundsException": [[31, 55]]}}}, {"text": "Use LinkedHashMap instead", "label": {"api": {"LinkedHashMap": [[4, 16]]}}}, {"text": "Use System.getenv() to retrieve the CLASSPATH variable, search if your DLL exists in one of the 'lib' folder listed in the variable", "label": {"api": {"System.getenv()": [[4, 18]]}}}, {"text": "In order to get the metadata for the table I am currently using java.sql.DatabaseMetaData, but trying .getPseudoColumns just gives me nil every time", "label": {"api": {"java.sql.DatabaseMetaData": [[64, 88]], ".getPseudoColumns": [[102, 118]]}}}, {"text": "You can use SimpleDateFormat for this", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "If you look at the documentation at http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html you'll see that lower case m always means minutes, and capital M is month", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[36, 107]]}}}, {"text": "hasNext() is a method in the Scanner class, which parses a stream into tokens", "label": {"api": {"Scanner class": [[29, 41]]}}}, {"text": "The Scanner class has a hasNext() method", "label": {"api": {"Scanner class has a hasNext()": [[4, 32]]}}}, {"text": "You can do this with 2 Iterators running in parallel", "label": {"api": {"Iterators": [[23, 31]]}}}, {"text": "Use List#iterator() method to get the iterator for a list", "label": {"api": {"List#iterator()": [[4, 18]]}}}, {"text": "If you want to decode digit characters to their numeric values, you can use the Character.digit(digit, radix) method", "label": {"api": {"Character.digit(digit, radix)": [[80, 108]]}}}, {"text": "Java already provides a way to execute asynchronous tasks in the form of ExecutorService", "label": {"api": {"ExecutorService": [[73, 87]]}}}, {"text": "If you want to start a pool and re-use the Threads as they become available again, use a ExecutorService with a Thread pool", "label": {"api": {"ExecutorService": [[89, 103]]}}}, {"text": "You can get one with Executors.newFixedThreadPool(int)", "label": {"api": {"Executors.newFixedThreadPool(int)": [[21, 53]]}}}, {"text": "You can use tryLock", "label": {"api": {"tryLock": [[12, 18]]}}}, {"text": "This violates the transitivity property of the Comparator contract", "label": {"api": {"the Comparator contract": [[43, 65]]}}}, {"text": "The InputVarifier will call a function boolean shouldYieldFocus(JComponent input) on focus lose event to check whither it should lose the focus", "label": {"api": {"InputVarifier": [[4, 16]]}}}, {"text": "As JB Nizet stated in the comments, you can use containsKey(Object) to make that distinction", "label": {"api": {"containsKey(Object)": [[48, 66]]}}}, {"text": "Please visit http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/event/KeyEvent.html for keycodes", "label": {"api": {"http://docs.oracle.com/javase/1.4.2/docs/api/java/awt/event/KeyEvent.html": [[13, 85]]}}}, {"text": "You have to extend the MemoryHandler to provide custom push behavior", "label": {"api": {"push": [[55, 58]]}}}, {"text": "You can do this by setting the push level to ALL overriding the push method or by setting the push level to OFF and then manually issuing a push from the publish method", "label": {"api": {"push": [[31, 34], [64, 67], [94, 97], [140, 143]], "publish": [[154, 160]]}}}, {"text": "What you see is Object's toString()", "label": {"api": {"Object's toString()": [[16, 34]]}}}, {"text": "A common workaround is to use Arrays.toString()", "label": {"api": {"Arrays.toString()": [[30, 46]]}}}, {"text": "Console#readLine() is an instance method", "label": {"api": {"Console#readLine()": [[0, 17]]}}}, {"text": "Note that, this will thrown a NPE when run on eclipse, as System.console() will give you null", "label": {"api": {"System.console()": [[58, 73]]}}}, {"text": "The nextInt() method of the Scanner class can read an integer, and only an integer", "label": {"api": {"nextInt() method": [[4, 19]], "Scanner class": [[28, 40]]}}}, {"text": "However for your special case Java offers the NIO concept, using Selectors to enable a few threads to process all incoming requests by knowing which connection actually needs processing", "label": {"api": {"Selectors": [[65, 73]]}}}, {"text": "And Selectors + non-blocking IO will make sure of that", "label": {"api": {"Selectors": [[4, 12]]}}}, {"text": "So I decided to implement my own LocalizationBundleFactory that would load all the *.properties files with a given name using ClassLoader.getResources(String)", "label": {"api": {"ClassLoader.getResources(String)": [[126, 157]]}}}, {"text": "However, I see that date.getYear(), date.getMonth(), etc, are all deprecated, and it says to use Calendar instead", "label": {"api": {"Calendar": [[97, 104]]}}}, {"text": "In the documentation for Calendar, the only mention I see of Date is the method setTime(Date date), but the method name is ambigious, and the documentation is not clear on what calling this method would actually do", "label": {"api": {"Calendar": [[25, 32]], "setTime(Date date)": [[80, 97]]}}}, {"text": "So how can I convert a given Date object to Calendar", "label": {"api": {"Calendar": [[44, 51]]}}}, {"text": "All I want to do is load information I saved to a plain text file about the position of a JInternalFrame and set the frame to the state it was saved as", "label": {"api": {"JInternalFrame": [[90, 103]]}}}, {"text": "For some reason I'm unable to compare capture groups with strings; that is, matcher.group(\"state\") compared to the string it should be (\"min\", \"max\", or \"normal\") is not returning true, and the same goes with matcher.group(\"vis\")", "label": {"api": {"matcher.group": [[76, 88], [209, 221]]}}}, {"text": "matcher.group is supposed to return a string, is it not", "label": {"api": {"matcher.group": [[0, 12]]}}}, {"text": "As a suggestion, you may use a HashMap instead of TreeMap to enhance the performance of your method since the put and get time in HashMap are O(1) (constant time) while TreeMap's are O(log n)", "label": {"api": {"HashMap": [[31, 37], [130, 136]], "TreeMap": [[50, 56], [169, 175]]}}}, {"text": "If you read the Javadoc for setLength you’ll see that the argument must be non-negative", "label": {"api": {"Javadoc for setLength": [[16, 36]]}}}, {"text": "From InputMismatchException's JavaDoc", "label": {"api": {"InputMismatchException's": [[5, 28]]}}}, {"text": "To execute a function, the canonical way is to use a CallableStatement", "label": {"api": {"CallableStatement": [[53, 69]], "execute": [[3, 9]]}}}, {"text": "In addition, you have to specify the right output parameters type using one of the registerOutParameter methods", "label": {"api": {"registerOutParameter": [[83, 102]]}}}, {"text": "Once the call is completed (execute), you extract the output value from the statement itself", "label": {"api": {"execute": [[28, 34]]}}}, {"text": "Arrays.asList(T...) takes varargs", "label": {"api": {"Arrays.asList(T...)": [[0, 18]]}}}, {"text": "Also, since the file seems to be located on your classpath, instead of trying to construct an absolute path from the package, you should instead use getResource or  getResourceAsStream", "label": {"api": {"getResource": [[149, 159], [165, 175]], "getResourceAsStream": [[165, 183]]}}}, {"text": "Converting that value into a string is normally the job of something like SimpleDateFormat, via Calendar and Date", "label": {"api": {"SimpleDateFormat": [[74, 89]], "Calendar": [[96, 103]], "Date": [[80, 83], [109, 112]]}}}, {"text": "If you want to start with a date and get the number of milliseconds since the Unix epoch, you'd use Calendar, set the appropriate fields and then use Calendar.getTimeInMillis()", "label": {"api": {"Calendar": [[100, 107], [150, 157]]}}}, {"text": "These are in java.util", "label": {"api": {"java.util": [[13, 21]]}}}, {"text": "For instance, they are not serializable in the Java sense of the word", "label": {"api": {"sense": [[52, 56]]}}}, {"text": "Java futures (sharing threads in a small-sized thread pool)", "label": {"api": {"Java futures": [[0, 11]]}}}, {"text": "This is a code snippet from collections's SynchronizedMap", "label": {"api": {"SynchronizedMap": [[42, 56]]}}}, {"text": "To get the octal representation of a number, you need to either pass the radix to Integer.toString(int, int) method, or use Integer.toOctalString(int) method", "label": {"api": {"Integer.toString(int, int)": [[82, 107]], "Integer.toOctalString(int)": [[124, 149]]}}}, {"text": "Integer.parseInt(String, int) parses the string using the given radix", "label": {"api": {"Integer.parseInt(String, int)": [[0, 28]]}}}, {"text": "List#toArray() method without any argument returns an Object[]", "label": {"api": {"List#toArray()": [[0, 13]]}}}, {"text": "You need to use the overloaded generic version - List#toArray(T[]) passing String[][] as argument", "label": {"api": {"List#toArray(T[])": [[49, 65]]}}}, {"text": "If you need to do this often replace the list with a PriorityQueue O(1) to find the max", "label": {"api": {"PriorityQueue": [[53, 65]]}}}, {"text": "Take a look at the stream feature", "label": {"api": {"stream": [[19, 24]]}}}, {"text": "Scanner is a final class, you cannot extend it", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "As Dennis suggested, you can use the BufferedReader#Read method to read a single char", "label": {"api": {"BufferedReader#Read": [[37, 55]], "Reader": [[45, 50]]}}}, {"text": "Perhaps extend Reader and simulate a BufferedReader", "label": {"api": {"Reader": [[15, 20], [45, 50]]}}}, {"text": "Process doesn't override the default toString() method inherited from Object hence why its displaying that value", "label": {"api": {"Process": [[0, 6]], "toString()": [[37, 46]], "Object": [[70, 75]]}}}, {"text": "Instead you can use getInputStream(), which will return an InputStream object which you can convert to a string like this", "label": {"api": {"getInputStream()": [[20, 35]], "InputStream": [[23, 33], [59, 69]]}}}, {"text": "Read/convert an InputStream to a String", "label": {"api": {"InputStream": [[16, 26]]}}}, {"text": "You can use a CompletionService", "label": {"api": {"CompletionService": [[14, 30]]}}}, {"text": "It receive Future results in a queue as they become available from the executor threads", "label": {"api": {"Future": [[11, 16]]}}}, {"text": "Have a look at the Javadoc for JOptionPane, specifically the message part at the top", "label": {"api": {"Javadoc for JOptionPane": [[19, 41]]}}}, {"text": "If you want to learn about multi-threading in Java, you should definitely start making yourself familiar with the concurrent package", "label": {"api": {"concurrent package": [[114, 131]]}}}, {"text": "Future, that might be appropriate in this case", "label": {"api": {"Future": [[0, 5]]}}}, {"text": "Something like an Executor might help with this", "label": {"api": {"Executor": [[18, 25]]}}}, {"text": "Use the Double.compare(double, double) method instead of ==", "label": {"api": {"Double.compare(double, double)": [[8, 37]]}}}, {"text": "Useful might be Component.getLocationOnScreen", "label": {"api": {"Component.getLocationOnScreen": [[16, 44]]}}}, {"text": "You can use a CompletionService to receive the futures as soon as they are ready and if one of them throws an exception cancel the processing", "label": {"api": {"CompletionService": [[14, 30]]}}}, {"text": "You can use an ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[15, 39]]}}}, {"text": "If you are using Java 8 then you can do this easier with CompletableFuture and CompletableFuture.allOf, which applies the callback only after all supplied CompletableFutures are done", "label": {"api": {"CompletableFuture.allOf": [[79, 101]]}}}, {"text": "This is a very old question but I stumbled upon it and though I might add another answer that has potentially better performance using using FileChannel.transferTo or FileChannel.transferFrom", "label": {"api": {"FileChannel.transferTo": [[141, 162]], "FileChannel.transferFrom": [[167, 190]]}}}, {"text": "There is no way to do what you want using the standard Properties class", "label": {"api": {"Properties": [[55, 64]]}}}, {"text": "I suspect all you're looking for is calling flush on the PrintWriter", "label": {"api": {"flush": [[44, 48]]}}}, {"text": "If all your enemy/player classes have a single parent (class or interface), which it sounds like they do if you are making a List of them, you can use the Collections.sort(List, Comparator) and put some sort of getY method in the parent class/interface that your Comparator can make use of", "label": {"api": {"Collections.sort(List, Comparator)": [[155, 188]]}}}, {"text": "How about using String(bytes[], offset, length) constructor", "label": {"api": {"String(bytes[], offset, length)": [[16, 46]]}}}, {"text": "Note, that if E really isn't a string, you will get a ClassCastException, however if you are only doing this in circumstances that you know that E is really a string, then you will be fine", "label": {"api": {"ClassCastException": [[54, 71]]}}}, {"text": "For more info, see the package summary for java.util.regex", "label": {"api": {"java.util.regex": [[43, 57]]}}}, {"text": "Take, for instance, Collection", "label": {"api": {"Collection": [[20, 29]]}}}, {"text": "If I have an instance that is bound to the contract of Collection, then I have access to an Iterator", "label": {"api": {"Collection": [[55, 64]], "Iterator": [[92, 99]]}}}, {"text": "However, I know that the elements I'm getting back are of type List, and I want to make use of the ListIterator instead, which is more powerful", "label": {"api": {"Iterator": [[103, 110]], "ListIterator": [[99, 110]]}}}, {"text": "The problem is that Collection does not define any way for me to access a ListIterator", "label": {"api": {"Collection": [[20, 29]], "Iterator": [[78, 85]], "ListIterator": [[74, 85]]}}}, {"text": "So, I have but one option (since I can't just go and update the Collection interface needlessly)", "label": {"api": {"Collection": [[64, 73]]}}}, {"text": "Read the official documentation to better understand Strings", "label": {"api": {"official documentation": [[9, 30]]}}}, {"text": "You're getting NullPointerException because the file \"type\" doesn't exist, so folder will be null, and if you don't check if it's null, you'll get the exception when you try to do folder.something", "label": {"api": {"NullPointerException": [[15, 34]]}}}, {"text": "The proper way to do this is to create a StringBuffer object, and use Matcher#appendReplacement and Matcher#appendTail methods", "label": {"api": {"StringBuffer": [[41, 52]], "Matcher#appendReplacement": [[70, 94]], "Matcher#appendTail": [[100, 117]]}}}, {"text": "According to http://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html, the difference is that", "label": {"api": {"http://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html": [[13, 85]]}}}, {"text": "On the windows platform you can use j.l.Runtime.exec(String[]) to launch command shell running the start command", "label": {"api": {"j.l.Runtime.exec(String[])": [[36, 61]]}}}, {"text": "There is a relevant example using the GraphicsDevice class in the API documentation", "label": {"api": {"API documentation": [[66, 82]]}}}, {"text": "Why don't you just trust the boolean returned by File.renameTo(File) which indicates if the renaming worked or not", "label": {"api": {"File.renameTo(File)": [[49, 67]]}}}, {"text": "As stated in the javadoc for Socket.getInputStream()", "label": {"api": {"Socket.getInputStream()": [[29, 51]]}}}, {"text": "When you read for the first time, you don't read anymore, so hasNext() will stay always true since there will always be next element, which is.", "label": {"api": {"hasNext()": [[61, 69]]}}}, {"text": "However, as it is suggested in the comments below, to work with Swing Text Component, one should have used the Document.addDocumentListener(DocumentListener)", "label": {"api": {"Document.addDocumentListener(DocumentListener)": [[111, 156]], "Document": [[111, 118], [123, 130], [140, 147]]}}}, {"text": "A Swing text component uses a Document to represent its content", "label": {"api": {"Document": [[30, 37]]}}}, {"text": "Document events occur when the content of a document changes in any way", "label": {"api": {"Document": [[0, 7]]}}}, {"text": "Why DocumentListener is preferable", "label": {"api": {"Document": [[4, 11]]}}}, {"text": "But, DocumentListeners are notified only when a valid changes has been made to the data source", "label": {"api": {"Document": [[5, 12]]}}}, {"text": "Data entry components produce events in which a validator can listen for asynchronously, one should never modify the contents of a text component from within a DocumentListener", "label": {"api": {"Document": [[160, 167]]}}}, {"text": "If things are hanging because too many threads are being launched, then consider using Executors.newFixedThreadPool() - the computer cannot actually do more work concurrently than the number of logical cores available", "label": {"api": {"Executors.newFixedThreadPool()": [[87, 116]]}}}, {"text": "This includes (according to javadoc of Character#isWhiteSpace(char ch))", "label": {"api": {"Character#isWhiteSpace(char ch)": [[39, 69]]}}}, {"text": "Take a look at the exitValue() and methods to get the output and error streams on your Process object", "label": {"api": {"Process": [[87, 93]]}}}, {"text": "This being said, you can use Collections.sort(list, comparator) to sort your list", "label": {"api": {"Collections.sort(list, comparator)": [[29, 62]]}}}, {"text": "It's confusing, but to go from a java Key to bytes for storage use the getEncoded() method", "label": {"api": {"Key": [[38, 40]], "getEncoded()": [[71, 82]]}}}, {"text": "To go the other way, from bytes to a Key, use a KeyFactory", "label": {"api": {"Key": [[37, 39], [48, 50]], "KeyFactory": [[48, 57]]}}}, {"text": "If your key is a private key, then to go from bytes back to a private key create a PKCS8EncodedKeySpec", "label": {"api": {"Key": [[95, 97]], "PKCS8EncodedKeySpec": [[83, 101]]}}}, {"text": "To go from bytes to an RSA public key use an X509EncodedKeySpec", "label": {"api": {"Key": [[56, 58]], "X509EncodedKeySpec": [[45, 62]]}}}, {"text": "These KeySpecs are then supplied to an instance of an appropriate KeyFactory to recover the PublicKey and PrivateKey objects", "label": {"api": {"Key": [[6, 8], [66, 68], [98, 100], [113, 115]], "KeyFactory": [[66, 75]], "KeySpecs": [[6, 13]], "PublicKey": [[92, 100]], "PrivateKey": [[106, 115]]}}}, {"text": "If you want to specifically make a string, then you can use something like a StringBuilder", "label": {"api": {"StringBuilder": [[77, 89]]}}}, {"text": "First create a Scanner to read the input", "label": {"api": {"Scanner": [[15, 21]]}}}, {"text": "Finally, to use substring as your professor described", "label": {"api": {"substring": [[16, 24]]}}}, {"text": "To get a value out, call ArrayList.get()", "label": {"api": {"ArrayList.get()": [[25, 39]]}}}, {"text": "The Javadocs for DataInputStream.html#readLine explain why it's deprecated (character-set issues) and what to do instead (use BufferedReader instead of DataInputStream)", "label": {"api": {"The Javadocs for DataInputStream.html#readLine": [[0, 45]]}}}, {"text": "JavaScript visualization libraries may be integrated with JavaFX via WebView and it's associated Java<->JavaScript bridge technology", "label": {"api": {"WebView": [[69, 75]]}}}, {"text": "According to the JavaDocs for Executors.newFixedThreadPool()", "label": {"api": {"Executors.newFixedThreadPool()": [[30, 59]]}}}, {"text": "The Graphics2D class does not have a setCurve method, so I assume that somewhere your code creates a curved Shape object, and this object is drawn onto the Graphics2D", "label": {"api": {"Graphics2D": [[4, 13], [156, 165]], "Shape ": [[108, 113]]}}}, {"text": "So instead of the draw(Shape s) method just use the  fill(Shape s) method", "label": {"api": {"Shape ": [[23, 28], [58, 63]], "fill(Shape s)": [[53, 65]]}}}, {"text": "There is a class, named DefaultListModel<E>, which simplifies implementation of list models", "label": {"api": {"DefaultListModel<E>": [[24, 42]]}}}, {"text": "With DefaultListModel<E> one should override 7 methods", "label": {"api": {"DefaultListModel<E>": [[5, 23]]}}}, {"text": "You can use the find(entityClass, primaryKey) method to load your object", "label": {"api": {"find(entityClass, primaryKey)": [[16, 44]]}}}]