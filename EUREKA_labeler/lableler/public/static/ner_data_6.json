[{"text": "The methods you are looking for exist and are called Stream::peek and Stream::map", "label": {"api": {"Stream::peek": [[53, 64]], "Stream::map": [[70, 80]]}}}, {"text": "With Stream::peek, the above code might look as follows", "label": {"api": {"Stream::peek": [[5, 16]]}}}, {"text": "No, there is nothing resembling any of these, but if you have a long enough list of of objects to check against, you can put them in a list and use List.contains(Object o)", "label": {"api": {"List.contains(Object o)": [[148, 170]]}}}, {"text": "Check the size of the list first by using size(), then check for the index", "label": {"api": {"size()": [[42, 47]]}}}, {"text": "See http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html for further explanation", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html": [[4, 72]]}}}, {"text": "According to the javadocs (http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#max(java.util.Collection,%20java.util.Comparator)), it throws that exception when the Collection is empty", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#max(java.util.Collection,%20java.util.Comparator)": [[27, 143]]}}}, {"text": "The easiest example for understanding the use of a generic method is the implementation of Objects#requireNonNull which is something like this", "label": {"api": {"Objects#requireNonNull": [[91, 112]]}}}, {"text": "Another, more generic approach would be using a PriorityQueue", "label": {"api": {"PriorityQueue": [[48, 60]]}}}, {"text": "So when calling poll() you remove the smallest element, that the PriorityQueue has yet encountered", "label": {"api": {"PriorityQueue": [[65, 77]]}}}, {"text": "You could read out the content length after opening the connection (I'm sorry the code is in Scala, but you should get the idea)", "label": {"api": {"read out the content length": [[10, 36]]}}}, {"text": "Try poll(time, unit) instead", "label": {"api": {"poll(time, unit)": [[4, 19]]}}}, {"text": "Using http the application needs to access the Internet from time to time and does so using URL.openConnection(java.net.Proxy) which in effect means HttpURLConnection", "label": {"api": {"URL.openConnection(java.net.Proxy)": [[92, 125]], "HttpURLConnection": [[149, 165]]}}}, {"text": "Can HttpURLConnection pass through a proxy that requires NTLMv2 authentication ?", "label": {"api": {"HttpURLConnection": [[4, 20]]}}}, {"text": "Can HttpURLConnection pass through a proxy that uses SPNEGO-Kerberos authentication", "label": {"api": {"HttpURLConnection": [[4, 20]]}}}, {"text": "I think that isInstance(Object) is what you're looking for", "label": {"api": {"isInstance(Object)": [[13, 30]]}}}, {"text": "But in case of generics such mechanism is impossible (at least in if you are not using checked list) because of type erasure so since JVM can't stop you at runtime it stops you earlier at compilation time", "label": {"api": {"checked list": [[87, 98]]}}}, {"text": "I think the easiest solution is make snakeApplet a JFrame", "label": {"api": {"JFrame": [[51, 56]]}}}, {"text": "Simply use Iterator#remove() that is useful to remove the item while iterating the collection", "label": {"api": {"Iterator#remove()": [[11, 27]]}}}, {"text": "java.awt.Cursor has a method getSystemCustomCursor(String name)", "label": {"api": {"getSystemCustomCursor(String name)": [[29, 62]]}}}, {"text": "See Toolkit.createCustomCursor() for a simpler way to create a custom cursor", "label": {"api": {"Toolkit.createCustomCursor()": [[4, 31]]}}}, {"text": "Or you can use Cursor.getPredefinedCursor to get predefined cursors", "label": {"api": {"Cursor.getPredefinedCursor": [[15, 40]]}}}, {"text": "Simply use  JFrame's content pane as target", "label": {"api": {"JFrame's content pane": [[12, 32]]}}}, {"text": "A simple way to do this in Java is to create an anonymous class which implements Runnable", "label": {"api": {"Runnable": [[81, 88]]}}}, {"text": "Runnable is an interface which defines a single method", "label": {"api": {"Runnable": [[0, 7]]}}}, {"text": "The implementation of panelRegion would maintain a List<Runnable> with the commands it is going to execute", "label": {"api": {"Runnable": [[56, 63]]}}}, {"text": "Here's the javadoc for SimpleDateFormat", "label": {"api": {"javadoc for SimpleDateFormat": [[11, 38]]}}}, {"text": "when implementing a WindowListener, one typically extends and overrides a method of WindowAdapter so that one does not need to provide definitions for the cases where the default behavior is sufficient)", "label": {"api": {"WindowListener": [[20, 33]], "WindowAdapter": [[84, 96]]}}}, {"text": "If I was simply wanting to map a credit card abbreviation to a more descriptive name, I'd use a properties file (which of course implements Map)", "label": {"api": {"properties file": [[96, 110]]}}}, {"text": "You haven't indicated what should be returned if it doesn't fit evenly - this impl returns the not a number value - you may want to do something different", "label": {"api": {"not a number": [[95, 106]]}}}, {"text": "Collections.frequency is useful here", "label": {"api": {"Collections.frequency": [[0, 20]]}}}, {"text": "You can use Java's Random class as follows", "label": {"api": {"Random": [[19, 24]]}}}, {"text": "Note that initializing new Random objects is a slightly expensive operation, so you probably want to create it once, and then keep reusing it", "label": {"api": {"Random": [[27, 32]]}}}, {"text": "Therefore, change the second JFrame to a JDialog and use the method setModalityType() on it", "label": {"api": {"setModalityType()": [[68, 84]]}}}, {"text": "One option would be to check the mouse position before every call into Robot (or at regular intervals), to verify that it was still at whatever position it was last mouseMove'd to", "label": {"api": {"Robot": [[71, 75]]}}}, {"text": "Probably best to wrap Robot to ensure it always checks that", "label": {"api": {"Robot": [[22, 26]]}}}, {"text": "I suggest SecondLawObeyingRobot", "label": {"api": {"Robot": [[26, 30]]}}}, {"text": "Please check your application for \"rogue\" calls to DataSource#getConnection (you can use your IDE to search for method references)", "label": {"api": {"DataSource#getConnection": [[51, 74]]}}}, {"text": "Connection leaks are usually caused by obtaining a connection which is then never closed via Connection#close", "label": {"api": {"Connection#close": [[93, 108]]}}}, {"text": "Yes, there's no getBinaryStream method on Clob, because it doesn't make sense for there to be one", "label": {"api": {"Clob": [[42, 45]]}}}, {"text": "java.util.HashMap has an implementation of the put method, which has the following code inside it", "label": {"api": {"java.util.HashMap": [[0, 16]]}}}, {"text": "Since Java 8, the class java.util.concurrent.CompletableFuture is part of the standard library", "label": {"api": {"java.util.concurrent.CompletableFuture": [[24, 61]]}}}, {"text": "You need to use a RandomAccessFile if you want to insert into your file", "label": {"api": {"RandomAccessFile": [[18, 33]]}}}, {"text": "Looking and the docs for getKeyStroke(java.lang.String)", "label": {"api": {"getKeyStroke(java.lang.String)": [[25, 54]]}}}, {"text": "I recommend you put your query result into a Map (not nesseserly concurrent one) and the update with putAll method from your ConcurrentHashMap, which is thread-safe (or at least official documentation caims so)", "label": {"api": {"putAll": [[101, 106]], "official documentation": [[178, 199]]}}}, {"text": "MyModel that extends an AbstractTableModel, which has no GUI and you should use in order to separate your Model from the View and Controller that have a GUI", "label": {"api": {"AbstractTableModel": [[24, 41]]}}}, {"text": "Tomcat 6 and newer) also available by ServletContext#getContextPath()", "label": {"api": {"ServletContext#getContextPath()": [[38, 68]]}}}, {"text": "Keep in mind that Process#getInputStream() does not include standard error stream of the process", "label": {"api": {"Process#getInputStream()": [[18, 41]]}}}, {"text": "You should use Process#getErrorStream()", "label": {"api": {"Process#getErrorStream()": [[15, 38]]}}}, {"text": "But what about the new java.time package objects in Java 8, such as ZonedDateTime", "label": {"api": {"java.time package": [[23, 39]], "ZonedDateTime": [[68, 80]]}}}, {"text": "You need to create and use an XmlAdapter to handle those types", "label": {"api": {"XmlAdapter": [[30, 39]]}}}, {"text": "On a side note, you might want to just create an EnumMap to map your lists instead of doing a switch every time", "label": {"api": {"EnumMap": [[49, 55]]}}}, {"text": "This can be accomplished by getting the classloader to get a resource", "label": {"api": {"get a resource": [[55, 68]]}}}, {"text": "Use the classloader to get the resource as a stream", "label": {"api": {"resource as a stream": [[31, 50]]}}}, {"text": "The Calendar class has a method getTimeInMillis that returns the unix epoc time value for the given calendar", "label": {"api": {"method": [[25, 30]]}}}, {"text": "To change the channel of an event's message, use setMessage with a different channel parameter", "label": {"api": {"setMessage": [[49, 58]]}}}, {"text": "Try using String.format()", "label": {"api": {"String.format()": [[10, 24]]}}}, {"text": "At the moment, the date is stored in a LocalDate", "label": {"api": {"LocalDate": [[39, 47]]}}}, {"text": "How do I compare the weeks of LocalDate objects", "label": {"api": {"LocalDate": [[30, 38]]}}}, {"text": "Please, keep your comments and answers only about Java 8 java.time classes, no Joda-Time or other external libraries", "label": {"api": {"java.time": [[57, 65]]}}}, {"text": "Try comparing the year and the week in the year, using WEEK_OF_WEEK_BASED_YEAR", "label": {"api": {"WEEK_OF_WEEK_BASED_YEAR": [[55, 77]]}}}, {"text": "Iterate over utilList and invoke Field.getName on each item", "label": {"api": {"Field.getName": [[33, 45]]}}}, {"text": "From the documentation of ExecutorService.newFixedThreadPool(int nThreads)", "label": {"api": {"ExecutorService.newFixedThreadPool(int nThreads)": [[26, 73]]}}}, {"text": "Runnable is an interface, and so not an abstract class in the Java sense", "label": {"api": {"Runnable": [[0, 7]]}}}, {"text": "And in Java 8 (although Runnable doesn't do this), it's now possible to define interfaces with \"default\" implementations of methods, which makes the distinction between those interfaces and Java's normal abstract classes quite subtle", "label": {"api": {"Runnable": [[24, 31]]}}}, {"text": "(The remaining distinction relates to inheritance; you can't inherit from multiple classes in Java, but you can inherit from one class and any number of interfaces, even ones with default methods.) But again, Runnable doesn't have default methods", "label": {"api": {"Runnable": [[209, 216]]}}}, {"text": "Thread is a class that is not marked abstract, has no abstract methods, and therefore can be directly instantiated", "label": {"api": {"Thread": [[0, 5]]}}}, {"text": "It's a bit like an abstract class despite not literally being one, as Thread is mostly useful only if you subclass it and override its run method, or (and this is generally preferred) if you write a class implementing the Runnable instance and pass an instance of that into the Thread constructor", "label": {"api": {"Runnable": [[222, 229]], "Thread": [[70, 75], [278, 283]]}}}, {"text": "I'm surprised that no one suggested javax.lang.model.SourceVersion yet, because it's actually been around since Java 1.6", "label": {"api": {"javax.lang.model.SourceVersion": [[36, 65]]}}}, {"text": "Here is how to extend StreamReaderDelegate", "label": {"api": {"StreamReaderDelegate": [[22, 41]]}}}, {"text": "If the Lists can be sorted by value, then you can use Collections.binarySearch", "label": {"api": {"Collections.binarySearch": [[54, 77]]}}}, {"text": "Use LineNumberReader on an InputStreamReader", "label": {"api": {"LineNumberReader": [[4, 19]]}}}, {"text": "In that case, make its parameter a Runnable (the generic functional interface for a function which takes nothing and returns nothing)", "label": {"api": {"Runnable": [[35, 42]]}}}, {"text": "In your Java code you can then execute the script function of that Runnable with .run()", "label": {"api": {"Runnable": [[67, 74]]}}}, {"text": "Many JavaFX controls have settable event handlers (such as setOnMouseClicked) and are also customizable CSS, both of these things can be manipulated in SceneBuilder and FXML", "label": {"api": {"setOnMouseClicked": [[59, 75]]}}}, {"text": "Stock your data in a static ConcurrentLinkedQueue , and let your threads access to it", "label": {"api": {"ConcurrentLinkedQueue": [[28, 48]]}}}, {"text": "Use either RoundingMode.DOWN or RoundingMode.FLOOR", "label": {"api": {"RoundingMode.DOWN": [[11, 27]], "RoundingMode.FLOOR": [[32, 49]]}}}, {"text": "You can access the capture groups (the parts of the match inside your unescaped parentheses) using the group method on your match result", "label": {"api": {"group": [[27, 31], [103, 107]]}}}, {"text": "Note that you start counting the capture groups from 1, not 0", "label": {"api": {"group": [[41, 45]]}}}, {"text": "This is because group 0 corresponds to the entire matched string", "label": {"api": {"group": [[16, 20]]}}}, {"text": "Take a look at the CardLayout tutorial and the CardLayout API", "label": {"api": {"CardLayout API": [[47, 60]]}}}, {"text": "Since you're getting the CONNECT request over a plain socket, presumably, you're trying to upgrade that socket to an SSLSocket afterwards (which you can indeed to with SSLSocketFactory.createSocket(Socket s, String host, int port, boolean autoClose)", "label": {"api": {"SSLSocketFactory.createSocket(Socket s, String host, int port, boolean autoClose)": [[168, 248]]}}}, {"text": "How do i read this value from the ResultSet instance (rs in below code)", "label": {"api": {"ResultSet": [[34, 42]]}}}, {"text": "ResultSet seems to be referring to them all by column names", "label": {"api": {"ResultSet": [[0, 8]]}}}, {"text": "Also, checkout the Java CSS Reference Guide if you haven't already", "label": {"api": {"Java CSS Reference Guide": [[19, 42]]}}}, {"text": "If you are looking for a Queue in the FIFO-sense you may have a look at the LinkedList and only use the addFirst() and getLast() methods", "label": {"api": {"LinkedList": [[76, 85]]}}}, {"text": "From the HashMap javadoc", "label": {"api": {"HashMap javadoc": [[9, 23]]}}}, {"text": "From the javadoc for HashMap#values()", "label": {"api": {"HashMap#values()": [[21, 36]]}}}, {"text": "java.lang.IndexOutOfBoundsException is a class", "label": {"api": {"java.lang.IndexOutOfBoundsException": [[0, 34]]}}}, {"text": "I would have a look at using ExecutorService in Java for this and have the class with the functionality you want to time out implement runnable - so using Java's threading capabilities to help you out", "label": {"api": {"ExecutorService": [[29, 43]]}}}, {"text": "This code fills a series (JavaFX see here) and other code sets it in a chart which is not the problem", "label": {"api": {"see here": [[33, 40]]}}}, {"text": "Instead of creating sub-interfaces adding new methods to a base interface you can define a conventional listener interface (like, say MouseListener) having multiple call-back methods and create sub-interfaces overriding all but one method with empty default methods for the sole purpose of allowing lambda implementations of the remaining single abstract method", "label": {"api": {"MouseListener": [[134, 146]]}}}, {"text": "You should use Flush method and extract your close in the finalize() method", "label": {"api": {"Flush": [[15, 19]], "close": [[45, 49]]}}}, {"text": "Using Flush will allow you to see the result in your text file while your app write in it", "label": {"api": {"Flush": [[6, 10]]}}}, {"text": "When you stop your application, the GC will call finalize method and close the stream", "label": {"api": {"close": [[69, 73]]}}}, {"text": "For that, use the DatatypeConverter class", "label": {"api": {"DatatypeConverter": [[18, 34]]}}}, {"text": "Currently you are calling .toString(), which for a Java byte array results in a call to the Object.toString() method", "label": {"api": {"Object.toString()": [[92, 108]]}}}, {"text": "Map.replace was first declared in Java 1.8 (see the \"since", "label": {"api": {"Map.replace": [[0, 10]]}}}, {"text": "There is no method replace(K,V) for  a HashMap<K,V>, in Java 7 , you have to use JDK 8 for this", "label": {"api": {"Java 7": [[56, 61]], "JDK 8": [[81, 85]]}}}, {"text": "ThreadLocal has thread scoped objects", "label": {"api": {"ThreadLocal": [[0, 10]]}}}, {"text": "Secondly, SimpleDateFormat and DateFormats in general are not synchronized", "label": {"api": {"SimpleDateFormat": [[10, 25]]}}}, {"text": "Now, if you implement the AnnotatedElement interface, you could call the getAnnotation() method of your class to get an annotation type", "label": {"api": {"AnnotatedElement": [[26, 41]]}}}, {"text": "ProcessBuilder is the preferred replacement for the Runtime.exec methods", "label": {"api": {"ProcessBuilder": [[0, 13]]}}}, {"text": "You never advanced to the next element by calling the next() method on the iterator", "label": {"api": {"the next() method": [[50, 66]]}}}, {"text": "The ServerSocket#accept method what you need to use in order to listen for connections", "label": {"api": {"ServerSocket#accept": [[4, 22]]}}}, {"text": "You can't use < directly on two Strings, but you can use compareTo", "label": {"api": {"compareTo": [[57, 65]]}}}, {"text": "If s1 and s2 are strings, s1.compareTo(s2) returns a negative value if s1 is lexicographically less than s2, a positive value if s1 is greater, and 0 if the two strings are equal", "label": {"api": {"compareTo": [[29, 37]]}}}, {"text": "Use Scanner Class Pass your Line (String) to Scanner Constructor and use methods hasNextInt() to check and nextInt() to fetch and store it to ArrayList<Integer> by the use of loop", "label": {"api": {"Scanner": [[4, 10], [45, 51]]}}}, {"text": "To do this, you will have to get familiar with the java.util.concurrent classes", "label": {"api": {"java.util.concurrent": [[51, 70]]}}}, {"text": "Scanner#nextInt doesn't advance past the input if it fails to parse an integer, so if you keep calling it after failure, it will keep trying to parse same input again, throwing InputMismatchException", "label": {"api": {"Scanner#nextInt": [[0, 14]], "Scanner#next": [[0, 11]]}}}, {"text": "You can call Scanner#next, ignoring the string it returns, in your catch block to skip the invalid input", "label": {"api": {"Scanner#next": [[13, 24]]}}}, {"text": "When the delete button is pressed, you can have the ActionListener remove the selected row from the JTable and force the next selection in the model via setRowSelectionInterval", "label": {"api": {"setRowSelectionInterval": [[153, 175]]}}}, {"text": "You can also check out the Desktop javadocs", "label": {"api": {"Desktop javadocs": [[27, 42]]}}}, {"text": "Also check out the docs  ResourceBundle.getBundle(String, Locale, ClassLoader) for more information", "label": {"api": {"ResourceBundle.getBundle(String, Locale, ClassLoader)": [[25, 77]]}}}, {"text": "You can pass in a ResourceBundle.Control which, regardless of requested Locale, always searches only the root ResourceBundle", "label": {"api": {"ResourceBundle.Control": [[18, 39]]}}}, {"text": "You should use the method Map::computeIfAbsent to create a list lazily", "label": {"api": {"Map::computeIfAbsent": [[26, 45]]}}}, {"text": "The correct way to obtain the Implementation Version is with the Package.getImplementationVersion() method", "label": {"api": {"Package.getImplementationVersion() method": [[65, 105]]}}}, {"text": "The two argument reduce is defined as", "label": {"api": {"defined as": [[27, 36]]}}}, {"text": "The three argument reduce is defined as", "label": {"api": {"defined as": [[29, 38]]}}}, {"text": "You don't need regex , just read this line a String variable and call String.replace() method where the first param is the old String , and the second param is the new one", "label": {"api": {"String.replace()": [[70, 85]]}}}, {"text": "Try with auto flush property of PrintWriter that flush the data once new line methods are calle", "label": {"api": {"PrintWriter": [[32, 42]]}}}, {"text": "The key here is your shutdown hook needs to live long enough for other thread to clean up, you can do this by having your shutdown hook call Thread.join(long) on the other thread, with a timeout", "label": {"api": {"Thread.join(long)": [[141, 157]]}}}, {"text": "You need to pass valid SQL to the executeUpdate method in order for it to run", "label": {"api": {"executeUpdate": [[34, 46]]}}}, {"text": "You have to either concatenate their values into the SQL string that you pass to executeUpdate, or use Prepared Statements instead", "label": {"api": {"executeUpdate": [[81, 93]]}}}, {"text": "Since your already doing the progress stuff in your object just divide by the max work to get a percentage and bind it to the progress indicator's progress directly (a DoubleProperty)", "label": {"api": {"progress indicator's progress": [[126, 154]]}}}, {"text": "If you want to finish the main thread in the end after finishing all the activities by the another thread then you can use Thread.join() that waits for this thread to die", "label": {"api": {"Thread.join()": [[123, 135]]}}}, {"text": "Yes, the Class.forName method returns a Class object representing the class, not an instance of the class", "label": {"api": {"Class.forName method": [[9, 28]]}}}, {"text": "If you want to know if the class implements an interface (or a superclass), and you have the relevant Class objects, then you can use Class's isAssignableFrom method", "label": {"api": {"Class's isAssignableFrom method": [[134, 164]]}}}, {"text": "BTW, unlike the OP I do see related JUL logging output in the Google Developers Console", "label": {"api": {"JUL": [[36, 38]]}}}, {"text": "But that's not what renameTo does", "label": {"api": {"renameTo": [[20, 27]]}}}, {"text": "The javadoc for renameTo explains this", "label": {"api": {"renameTo": [[16, 23]]}}}, {"text": "Or use a HashMap, but that is probably overkill", "label": {"api": {"HashMap": [[9, 15]]}}}, {"text": "Just use the array version of exec", "label": {"api": {"array version of exec": [[13, 33]]}}}, {"text": "You can do this using the Endpoint.publish methods in Java SE", "label": {"api": {"Endpoint.publish": [[26, 41]]}}}, {"text": "As you can see, both classes must be annotated with @WebService", "label": {"api": {"@WebService": [[52, 62]]}}}, {"text": "You can have more control by placing the @WebMethod annotation on only the methods you want exposed as web services", "label": {"api": {"@WebMethod": [[41, 50]]}}}, {"text": "If what you do in your loop takes a long time and should not be executed on the JavaFX application thread, (which it probably does or you probably wouldn't have this question), then you should probably run the loop in a Task, on a different thread, updating the task's progress as the loop progresses and binding the progress bar's value to the task's progress", "label": {"api": {"Task": [[220, 223]]}}}, {"text": "Map.entry returns an unmodifiable Entry and forbids nulls", "label": {"api": {"Map.entry": [[0, 8]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "I'm assuming you are using a ProcessBuilder launch your shell script", "label": {"api": {"ProcessBuilder": [[29, 42]]}}}, {"text": "Once you build the process you can use getInputStream() which will give you the output stream from the Shell Script, then just copy the stream to where you want to go", "label": {"api": {"getInputStream()": [[39, 54]]}}}, {"text": "There also is a redirectOutput but I have limited experiences using it", "label": {"api": {"redirectOutput": [[16, 29]]}}}, {"text": "You can use a Properties class to read a .properties file", "label": {"api": {"Properties": [[14, 23]]}}}, {"text": "Take TimeUnit as an example", "label": {"api": {"TimeUnit": [[5, 12]]}}}, {"text": "Referring to instances, then, is a more grammatically natural TimeUnit.SECONDS rather than the awkward TimeUnits.SECONDS", "label": {"api": {"TimeUnit": [[62, 69], [103, 110]]}}}, {"text": "When you want the compressed JPEG data for some reason, access the File object directly with a FileInputStream", "label": {"api": {"FileInputStream": [[95, 109]]}}}, {"text": "What the compiler can check is that the type of the arguments is the one defined by the method prototype", "label": {"api": {"the method prototype": [[84, 103]]}}}, {"text": "You can see it's extremely dynamic and that you can pass sometimes an int, and sometimes somethings's else, which can be convenient, especially as some format strings are able to handle for various types", "label": {"api": {"format strings": [[152, 165]]}}}, {"text": "Read the line as a String, call the .trim() method on the line, and then use .toCharArray() to split it into chars", "label": {"api": {".trim()": [[36, 42]]}}}, {"text": "I'm writing an application in which I'm monitoring a log file from an external program using the WatchService (http://docs.oracle.com/javase/7/docs/api/java/nio/file/WatchService.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/nio/file/WatchService.html": [[111, 182]]}}}, {"text": "If you're planning to return a javax.ws.rs.core.Response object, you'll need to set the Variant so it contains an encoding of \"gzip\"", "label": {"api": {"Variant": [[88, 94]]}}}, {"text": "Ideally, you should let JAX-RS examine the Accept-Encoding header of the request and do the proper negotiation using Request.selectVariant;  see this question for details", "label": {"api": {"Variant": [[131, 137]], "Request.selectVariant": [[117, 137]]}}}, {"text": "There are many ways to do this, but rather than stuffing the entire compressed document into a new file or byte array, I would favor StreamingOutput", "label": {"api": {"StreamingOutput": [[133, 147]]}}}, {"text": "Michael points out that as of Java EE 7, you can register a WriterInterceptor to, among other things, wrap a response OutputStream in a GZIPOutputStream", "label": {"api": {"WriterInterceptor": [[60, 76]]}}}, {"text": "In this case I assume you would have to set the Content-Encoding header yourself, since WriterInterceptorContext does not use Variant", "label": {"api": {"Variant": [[126, 132]], "WriterInterceptor": [[88, 104]]}}}, {"text": "In Swing you can react to events related to showing/adding of components by adding ComponentListener or ContainerListenerto either component or container via addComponentListener() and addContainerListener() methods", "label": {"api": {"ComponentListener": [[83, 99], [161, 177]], "ContainerListener": [[104, 120], [188, 204]]}}}, {"text": "Depending on your setup, a ComponentListener might be enough", "label": {"api": {"ComponentListener": [[27, 43]]}}}, {"text": "There is a section in The Java Tutorials about ComponentListeners", "label": {"api": {"ComponentListener": [[47, 63]]}}}, {"text": "The matches() method validates the regular expression against the entire string, so you do not need the start ^ and end $ anchors", "label": {"api": {"matches()": [[4, 12]]}}}, {"text": "Since the argument is null, the default fill value is null, which means that the fill value (see SnapshotParameters.setFill) is white", "label": {"api": {"SnapshotParameters.setFill": [[97, 122]]}}}, {"text": "create your own WeakReference and use it in HashMap<key,weakObj>", "label": {"api": {"WeakReference": [[16, 28]]}}}, {"text": "If you want to select entire text then use JTextComponent#selectAll() method", "label": {"api": {"JTextComponent#selectAll()": [[43, 68]]}}}, {"text": "If you look at the JavaDoc of DefaultListModel then you will realize that it provide several methods to manipulate the item in the JList that is not possible using simple collection", "label": {"api": {"DefaultListModel": [[30, 45]]}}}, {"text": "To create a list whose items can be changed individually, set the list's model to an instance of a mutable list model class, such as an instance of DefaultListModel", "label": {"api": {"DefaultListModel": [[148, 163]]}}}, {"text": "See the API docs here", "label": {"api": {"API docs here": [[8, 20]]}}}, {"text": "If you have access to the ServletContext, you can read the file like this", "label": {"api": {"ServletContext": [[26, 39]]}}}, {"text": "If you don't have access to the ServletContext, your best bet is to move the javascript file to the classes folder inside WEB-INF, and read it through the ClassLoader", "label": {"api": {"ServletContext": [[32, 45]], "ClassLoader": [[155, 165]]}}}, {"text": "One better approach to concatenating Strings in Java is to use StringBuilder", "label": {"api": {"StringBuilder": [[63, 75]]}}}, {"text": "Here's your code adapted to use StringBuilder", "label": {"api": {"StringBuilder": [[32, 44]]}}}, {"text": "StringBuilder has a backing array as a buffer, which is expanded whenever the appended length exceeds the size of the buffer", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "In a real world situation, you could set the initial size of the StringBuilder buffer based on the size of the input, to minimise the need for expensive buffer expansions", "label": {"api": {"StringBuilder": [[65, 77]]}}}, {"text": "And an AffineTransform can transform a Shape into a new Shape with its createTransformedShape method", "label": {"api": {"createTransformedShape": [[71, 92]]}}}, {"text": "You should use Math.pow instead", "label": {"api": {"Math.pow": [[15, 22]]}}}, {"text": "See ClassLoader.loadClass() for details", "label": {"api": {"ClassLoader.loadClass()": [[4, 26]]}}}, {"text": "Trying to use Java's DelayQueue, I have to implement the Delayed interface which requires a compareTo() \"method that provides an ordering consistent with its getDelay method.\"", "label": {"api": {"\"method that provides an ordering consistent with its getDelay method.\"": [[104, 174]]}}}, {"text": "As a result, compareTo() is based on the remaining delay time while equals() is based on the payload of the queued objects, so they are not consistent, as is \"strongly recommended\" in the javadoc of Comparable", "label": {"api": {"javadoc of Comparable": [[188, 208]]}}}, {"text": "Just use the ExecutorService provided by java", "label": {"api": {"ExecutorService": [[13, 27]]}}}, {"text": "I will document equals to indicate which properties or what state constitutes equality, like URI.equals and List.equals do", "label": {"api": {"URI.equals": [[93, 102]], "List.equals": [[108, 118]]}}}, {"text": "Use Java's Calendar class", "label": {"api": {"Calendar": [[11, 18]]}}}, {"text": "You can specify the language in SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[32, 47]]}}}, {"text": "To achieve these stand-alone forms you can use Month.getDisplayName(...) (not tested)", "label": {"api": {"Month.getDisplayName(...)": [[47, 71]]}}}, {"text": "Collections#sort will work on a List<T> where T implements java.lang.Comparable", "label": {"api": {"Collections#sort": [[0, 15]], "java.lang.Comparable": [[59, 78]]}}}, {"text": "you don't need to import java.lang.Comparable interface since it belongs to java.lang package, and classes in this package are automatically added by Java compiler", "label": {"api": {"java.lang.Comparable": [[25, 44]]}}}, {"text": "You need to implement java.lang.Comparable", "label": {"api": {"java.lang.Comparable": [[22, 41]]}}}, {"text": "javax.activation.MimetypesFileTypeMap and friends is a standard library for dealing with mime types", "label": {"api": {"javax.activation.MimetypesFileTypeMap": [[0, 36]]}}}, {"text": "java.util.TimeZone can be used for getting access to available time zones", "label": {"api": {"java.util.TimeZone": [[0, 17]]}}}, {"text": "java.util.Locale can be used to access a country related information", "label": {"api": {"java.util.Locale": [[0, 15]]}}}, {"text": "The ExecutorService generates a Future that you can use to await for the computation to finish", "label": {"api": {"ExecutorService": [[4, 18]], "Future": [[32, 37]]}}}, {"text": "According to ExecutorService documentation", "label": {"api": {"ExecutorService": [[13, 27]]}}}, {"text": "Method submit extends base method Executor.execute(java.lang.Runnable) by creating and returning a Future that can be used to cancel execution and/or wait for completion", "label": {"api": {"Future": [[99, 104]]}}}, {"text": "Storing the Futures your executorService.submit method call returns and then calling Future#get() on all of your futures will ensure your Runnable will finish executing", "label": {"api": {"Future": [[12, 17], [85, 90]], "Future#get()": [[85, 96]]}}}, {"text": "According to Future#get() documentation", "label": {"api": {"Future": [[13, 18]], "Future#get()": [[13, 24]]}}}, {"text": "See http://docs.oracle.com/javaee/6/api/javax/persistence/OrderColumn.html for the info", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/OrderColumn.html": [[4, 73]]}}}, {"text": "The only way to guarantee that one particular thread executes before another is to do it yourself with an appropriate concurrency mechanism such as a CountDownLatch", "label": {"api": {"CountDownLatch": [[150, 163]]}}}, {"text": "Also see http://docs.oracle.com/javase/7/docs/api/javax/swing/text/JTextComponent.html#print() or http://docs.oracle.com/javase/tutorial/uiswing/misc/printtext.html for more information how to print text from your component", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/text/JTextComponent.html#print()": [[9, 93]]}}}, {"text": "If \"Represents integer as an array of digits\" is a suggestion and not a requirement a solution using BigInteger would look something like", "label": {"api": {"BigInteger": [[101, 110]]}}}, {"text": "Worst case, I'd store it as a String if BigInteger was not allowed", "label": {"api": {"BigInteger": [[40, 49]]}}}, {"text": "As the comments have stated, flip is probably the best choice, since it is specifically intended to be called when you have placed data in a buffer and want other code to start reading that data", "label": {"api": {"flip": [[29, 32]]}}}, {"text": "This violates the transitivity requirements of Object.equals", "label": {"api": {"Object.equals": [[47, 59]]}}}, {"text": "Don't forget that ServletRequest#getParameterMap returns a Map which contains both - query string parameters and parameters passed in the body of the request", "label": {"api": {"ServletRequest#getParameterMap": [[18, 47]]}}}, {"text": "Within the while at the start method you should use hasNextDouble instead just hasNext at its loop condition", "label": {"api": {"hasNextDouble": [[52, 64]]}}}, {"text": "Map#keySet() returns a Set not a Map, hence the ClassCastException", "label": {"api": {"Map#keySet()": [[0, 11]], "Set": [[7, 9], [23, 25]], "Map": [[0, 2], [33, 35]]}}}, {"text": "Note tha if you want to iterate over all entries of a map it is better to use Map#entrySet instead of keySet() and calling Map#get each time", "label": {"api": {"Set": [[87, 89], [105, 107]], "Map": [[78, 80], [123, 125]], "Map#entrySet": [[78, 89]]}}}, {"text": "It's possible that your code somewhere calls TimeZone.setDefault", "label": {"api": {"TimeZone.setDefault": [[45, 63]]}}}, {"text": "Consider explicitly setting time zones where needed, or intentionally using TimeZone.setDefault in your code", "label": {"api": {"TimeZone.setDefault": [[76, 94]]}}}, {"text": "Consider using a Blocking queue and removing the lock from your Runnable, like this (assuming as your example shows that the content of your list is static)", "label": {"api": {"Blocking queue": [[17, 30]]}}}, {"text": "You can try calling get(..) with an extremely short timeout", "label": {"api": {"get(..)": [[20, 26]]}}}, {"text": "Map is not a true Collection because it doesn't extend the Collection interface", "label": {"api": {"Map": [[0, 2]], "Collection": [[18, 27], [59, 68]]}}}, {"text": "Are you trying to use the method Component.setName(java.lang.String)", "label": {"api": {"Component.setName(java.lang.String)": [[33, 67]]}}}, {"text": "The @Id type can be String (http://docs.oracle.com/javaee/6/api/javax/persistence/Id.html)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/persistence/Id.html": [[28, 88]]}}}, {"text": "If you want to submit a list of tasks and wait for all to complete, use ExecutorService.invokeAll() rather than trying to track completion by a countdown latch", "label": {"api": {"ExecutorService.invokeAll()": [[72, 98]]}}}, {"text": "The ExecutorService interface provides 2 mechanisms to shutdown", "label": {"api": {"shutdown": [[55, 62]]}}}, {"text": "shutdown and shutdownNow", "label": {"api": {"shutdown": [[0, 7], [13, 20]], "shutdownNow": [[13, 23]]}}}, {"text": "You can also explore TreeSet", "label": {"api": {"TreeSet": [[21, 27]]}}}, {"text": "and MouseEvent has methods", "label": {"api": {"MouseEvent": [[4, 13]]}}}, {"text": "You should cast the result of readObject() to the needed class explicitly since the return type of readObject is Object", "label": {"api": {"readObject": [[30, 39], [99, 108]]}}}, {"text": "readObject() method returns an Object of type object", "label": {"api": {"readObject()": [[0, 11]]}}}, {"text": "Better to use Runtime.exec(..) that returns a Process object to you", "label": {"api": {"Runtime.exec": [[14, 25]], "Process": [[46, 52]]}}}, {"text": "Process has getOutputStream() method that connected to the normal input of the sub process", "label": {"api": {"Process": [[0, 6]]}}}, {"text": "Look at the method's documentation for the reason", "label": {"api": {"method's documentation": [[12, 33]]}}}, {"text": "Immediate performance benefits are gained by using NIO Channels with ByteBuffers", "label": {"api": {"ByteBuffers": [[69, 79]]}}}, {"text": "Also if you need to block on multiple things Selectors can be handy", "label": {"api": {"Selectors": [[45, 53]]}}}, {"text": "You can use EnumSet.range() method passing the required range", "label": {"api": {"EnumSet.range()": [[12, 26]]}}}, {"text": "Consider the use of EnumSet rather than a List", "label": {"api": {"EnumSet": [[20, 26]], "of": [[17, 18]]}}}, {"text": "For your specific case you could use range EnumSet.range(SomeEnum.Example_B, SomeEnum.EXAMPLE_D) or of EnumSet.of(SomeEnum.EXAMPLE_B, SomeEnum.EXAMPLE_C, SomeEnum.EXAMPLE_D)", "label": {"api": {"EnumSet": [[43, 49], [103, 109]], "range": [[37, 41], [51, 55]], "of": [[100, 101], [111, 112]]}}}, {"text": "The difference in your code is that former func receives a Class<T> (which can be Class<?>) which means the method only receives a Class type", "label": {"api": {"Class": [[59, 63], [82, 86], [131, 135]]}}}, {"text": "From Class javadoc", "label": {"api": {"Class": [[5, 9]]}}}, {"text": "Instances of the class Class represent classes and interfaces in a running Java application", "label": {"api": {"Class": [[23, 27]]}}}, {"text": "Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions", "label": {"api": {"Class": [[59, 63]]}}}, {"text": "Note that Class is metadata for your classes", "label": {"api": {"Class": [[10, 14]]}}}, {"text": "Besides UUID, you can also use BigInteger", "label": {"api": {"UUID": [[8, 11]], "BigInteger": [[31, 40]]}}}, {"text": "With BigInteger, you can get sequential IDs", "label": {"api": {"BigInteger": [[5, 14]]}}}, {"text": "That is because Integer#parseInt(String) takes a java.lang.String which is not an int", "label": {"api": {"Integer#parseInt(String)": [[16, 39]], "java.lang.String": [[49, 64]]}}}, {"text": "However, you could certainly cast the result of Math.pow to an int (with corresponding loss of precision)", "label": {"api": {"Math.pow": [[48, 55]]}}}, {"text": "Use an InputStreamReader and OutputStreamWriter both created with utf-8 as the character encoding", "label": {"api": {"InputStreamReader": [[7, 23]], "OutputStreamWriter": [[29, 46]]}}}, {"text": "If you want to read entire lines of content, you can wrap the InputStreamReader with a BufferedReader", "label": {"api": {"InputStreamReader": [[62, 78]], "BufferedReader": [[87, 100]]}}}, {"text": "Similarly, you can use a BufferedWriter or PrintWriter wrapped around the OutputStreamWriter to write out data as lines", "label": {"api": {"OutputStreamWriter": [[74, 91]], "BufferedWriter": [[25, 38]], "PrintWriter": [[43, 53]]}}}, {"text": "One way to do this is to read the InputStream into a byte[] and then call new String(byte[] bytes, String charset)", "label": {"api": {"new String(byte[] bytes, String charset)": [[74, 113]]}}}, {"text": "Looking at the documentation for NotNull under Java 7, you can see javax.validation.constraints.NotNull is a valid and documented annotation", "label": {"api": {"valid and documented annotation": [[109, 139]]}}}, {"text": "You can use Jave EE 7's NotNull just fine", "label": {"api": {"NotNull": [[24, 30]]}}}, {"text": "For more information on AlphaComposite, see Compositing Graphics from the Java2D Advanced Topics tutorial", "label": {"api": {"AlphaComposite": [[24, 37]]}}}, {"text": "Take a look at setModalityType", "label": {"api": {"setModalityType": [[15, 29]]}}}, {"text": "In using Matcher#matches you also ensure that this regex matches the whole input, not just part of it (without the need to add in beginning and end anchors -- ^$)", "label": {"api": {"Matcher#matches": [[9, 23]]}}}, {"text": "Look at   compare() method in Double class", "label": {"api": {"compare()": [[10, 18]]}}}, {"text": "Since you state the file is in the same package of the class, you should use Class#getResource that returns an URL", "label": {"api": {"Class#getResource": [[77, 93]]}}}, {"text": "Then, call URL#getFile to retrieve the String with the full path of the file", "label": {"api": {"URL#getFile": [[11, 21]]}}}, {"text": "The return value from read tells you the number of bytes which were read", "label": {"api": {"read": [[22, 25], [68, 71]]}}}, {"text": "Just because the file is larger than length does not mean that a request for length number of bytes will actually result in that many bytes being read into your byte[]", "label": {"api": {"read": [[146, 149]]}}}, {"text": "It also indicates that no data was read into your byte[]", "label": {"api": {"read": [[35, 38]]}}}, {"text": "Every array has a length, and it's specified in the JLS-10.7 that it is an int", "label": {"api": {"length": [[18, 23]]}}}, {"text": "The public final field length, which contains the number of components of the array", "label": {"api": {"length": [[23, 28]]}}}, {"text": "length may be positive or zero", "label": {"api": {"length": [[0, 5]]}}}, {"text": "Basically I want to get up to constructor and method summary http://docs.oracle.com/javase/6/docs/api/javax/xml/parsers/SAXParser.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/javax/xml/parsers/SAXParser.html": [[61, 133]]}}}, {"text": "I am not familiar with Spring interceptors, but I believe the logic behind it will be pretty the same as the standard Java EE javax.interceptor.AroundInvoke", "label": {"api": {"javax.interceptor.AroundInvoke": [[126, 155]]}}}, {"text": "In Java, every class inherits from Object, and toString() is part of the Object's contract", "label": {"api": {"Object": [[35, 40], [73, 78]], "toString()": [[47, 56]]}}}, {"text": "Thus, any Java object has a toString() method", "label": {"api": {"toString()": [[28, 37]]}}}, {"text": "Additionally, since toString() is non-final, any class can choose to provide its own implementation of the method", "label": {"api": {"toString()": [[20, 29]]}}}, {"text": "using a PreparedStatement protects against SQL injection attacks as described here", "label": {"api": {"PreparedStatement": [[8, 24]]}}}, {"text": "you haven't needed to load the driver with a Class.forName since the service provider mechanism was introduced", "label": {"api": {"Class.forName": [[45, 57]]}}}, {"text": "it's considerably more efficient to 'get' from a ResultSet by index", "label": {"api": {"ResultSet": [[49, 57]]}}}, {"text": "the validation aimed for user input validation as opposed to coding errors via assertions where failing the condition would lead to an IllegalArgumentException e.g", "label": {"api": {"IllegalArgumentException": [[135, 158]]}}}, {"text": "Use  http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html to control threads", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html": [[5, 86]]}}}, {"text": "JLabel) and in your overridden class you implement Cloneable where you set the parameters you need (text, bounds, whatever) then call your function like this", "label": {"api": {"Cloneable": [[51, 59]]}}}, {"text": "If you go down that road, be sure to read the Documentation of Cloneable", "label": {"api": {"Cloneable": [[63, 71]]}}}, {"text": "For both building and parsing your byte[], you really need to consider the byte order", "label": {"api": {"byte order": [[75, 84]]}}}, {"text": "Try Generic Superclass", "label": {"api": {"Generic Superclass": [[4, 21]]}}}, {"text": "I need to use stack to create a list storing objects, and I try to look up in API, however, I have no idea which is the syntax I should refer to", "label": {"api": {"API": [[78, 80]]}}}, {"text": "You can use a GridPane to lay out the data like a table", "label": {"api": {"GridPane": [[14, 21]]}}}, {"text": "Use something to run a Runnable after a specified delay, such as ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[65, 88]]}}}, {"text": "Use the Matcher class to match and extract your substring between those delimiters", "label": {"api": {"Matcher": [[8, 14]]}}}, {"text": "Classic application use case for regular expression", "label": {"api": {"regular expression": [[33, 50]]}}}, {"text": "Instead, use a PreparedStatement and use", "label": {"api": {"PreparedStatement": [[15, 31]]}}}, {"text": "For your example, it seems that you want to use Math.rint()", "label": {"api": {"Math.rint()": [[48, 58]]}}}, {"text": "If you want to prioritize the data collection part, just run it on a different Worker thread(Task), which will run parallel to the JavaFX thread, and once the data collection is completed, use the runLater to update it back to the UI", "label": {"api": {"Task": [[93, 96]]}}}, {"text": "As the name implies, getTimeInMillis() will return the number of milliseconds from the epoch", "label": {"api": {"getTimeInMillis()": [[21, 37]]}}}, {"text": "There is an ASCII character class for matching code points in the ASCII set", "label": {"api": {"ASCII character class": [[12, 32]]}}}, {"text": "Firstly, your SSLContext context instance variable is never initialised, so it is null", "label": {"api": {"SSLContext": [[14, 23]]}}}, {"text": "Secondly, even if it's not null (for example, you can create a new instance with context = SSLContext.getInstance(\"TLS\"), see SSLContext section of the Java Cryptography Architecture Standard Algorithm Name Documentation as indicated in the SSLContext API doc), you still need to initialise the SSLContext via its init method", "label": {"api": {"SSLContext": [[91, 100], [126, 135], [241, 250], [295, 304]], "init method": [[314, 324]]}}}, {"text": "You just have to read the definition of Set", "label": {"api": {"Set": [[40, 42]]}}}, {"text": "Class.getEnumConstants() is what you need", "label": {"api": {"Class.getEnumConstants()": [[0, 23]]}}}, {"text": "This uses Normalizer to decompose a string", "label": {"api": {"Normalizer": [[10, 19]]}}}, {"text": "Only after a Normalizer.normalize a comparison with String.equals indeed indicates Unicode text equality", "label": {"api": {"Normalizer": [[13, 22]]}}}, {"text": "Also, base64 encoding in PHP matches the URL and Filename safe base64 encoder in Java https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html#url", "label": {"api": {"https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html#url": [[86, 152]]}}}, {"text": "For this, you need a PersistenceDelegate", "label": {"api": {"PersistenceDelegate": [[21, 39]]}}}, {"text": "There is no specific panel with a table layout, but you can use a regular JPanel and give it a GridLayout", "label": {"api": {"GridLayout": [[95, 104]]}}}, {"text": "Accessing a List from multiple threads requires a synchronized List wrapper", "label": {"api": {"synchronized List wrapper": [[50, 74]]}}}, {"text": "If the images are inside your .jar file, you can access them using the getResource method of Class or ClassLoader", "label": {"api": {"Class": [[93, 97], [102, 106]], "ClassLoader": [[102, 112]]}}}, {"text": "If you are deploying the image outside of your .jar file, and placing it in the same directory as the .jar file on the web server, you can create a URL relative to the applet's location", "label": {"api": {"the applet's location": [[164, 184]]}}}, {"text": "You might want to play with http://docs.oracle.com/javaee/5/api/javax/xml/bind/annotation/XmlElement.html annotation on the elements of your generated classes", "label": {"api": {"http://docs.oracle.com/javaee/5/api/javax/xml/bind/annotation/XmlElement.html": [[28, 104]]}}}, {"text": "The intValue() method will only keep the lowest 32 bits that will fit in an int, discarding information if necessary", "label": {"api": {"intValue()": [[4, 13]]}}}, {"text": "The intValueExact() method will throw an exception in this case rather than give you a different value", "label": {"api": {"intValueExact()": [[4, 18]]}}}, {"text": "Create a custom Preloader and in the start method of the preloader, set the title of the preloader stage", "label": {"api": {"start": [[37, 41]], "set the title": [[68, 80]]}}}, {"text": "In Java 7 and 8, surely you should just use Integer.compare", "label": {"api": {"Integer.compare": [[44, 58]]}}}, {"text": "SimpleDateFormat docs should help you understand more about the patterns available", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Although you have solved your problem, I suggest taking a look at Scanner class", "label": {"api": {"Scanner": [[66, 72]]}}}, {"text": "Type checks are rather done at runtime by the JVM where an ArrayStoreException is thrown in case a value is attempted to be stored in an incompatible array", "label": {"api": {"ArrayStoreException": [[59, 77]]}}}, {"text": "This seemed especially important as generics introduced a more complex type system component than array types such that runtime errors similar to the ArrayStoreException would surely have become more common if Sun had decided differently", "label": {"api": {"ArrayStoreException": [[150, 168]]}}}, {"text": "You can read the hashCode documentation", "label": {"api": {"hashCode documentation": [[17, 38]]}}}, {"text": "Use a filter and get the ip from the request", "label": {"api": {"request": [[37, 43]]}}}, {"text": "However in case the request comes from behind a firewall, you'll get the firewall's ip", "label": {"api": {"request": [[20, 26]]}}}, {"text": "Use a java.sql.Timestamp (which again goes down to nanoseconds, if you need it to) on the Java side", "label": {"api": {"java.sql.Timestamp": [[6, 23]]}}}, {"text": "Looking at the API for System.setProperties might be helpful", "label": {"api": {"System.setProperties": [[23, 42]]}}}, {"text": "To prevent problems, not only Unicode code points above U+007F (0x7f) are multi-byte encoded (whith high bits of bytes set), but also U+0000 in Java's UTF-8, DataOutputSream", "label": {"api": {"Java's UTF-8, DataOutputSream": [[144, 172]]}}}, {"text": "When you read from an InputStream, it will tell you how many bytes were read", "label": {"api": {"read": [[9, 12], [72, 75]]}}}, {"text": "The length of the byte[] itself is mostly irrelevant (other than defining the max number of bytes which could be read in a single call)", "label": {"api": {"read": [[113, 116]]}}}, {"text": "Pay attention to the return value from read and use that when creating a String", "label": {"api": {"read": [[39, 42]]}}}, {"text": "Additionally, if all of your data is text, consider using an InputStreamReader, perhaps in combination with a BufferedReader", "label": {"api": {"InputStreamReader": [[61, 77]], "BufferedReader": [[110, 123]]}}}, {"text": "You can use a scheduled executor with fixed thread pool size, that sleeps at random time and initially starts at random time", "label": {"api": {"scheduled executor": [[14, 31]]}}}, {"text": "In the first case System.out.println(buf); you are calling a method specific for a char[]", "label": {"api": {"method": [[61, 66]]}}}, {"text": "The documentation is at http://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html": [[24, 87]]}}}, {"text": "assertEquals with throw an AssertionError when the condition is not met", "label": {"api": {"AssertionError": [[27, 40]]}}}, {"text": "See the type hierarchy diagram below to understand why catch (Exception e) won't catch an AssertionError", "label": {"api": {"AssertionError": [[90, 103]]}}}, {"text": "You are getting an IndexOutOfBoundsException in an AsyncTask", "label": {"api": {"IndexOutOfBoundsException": [[19, 43]]}}}, {"text": "Your example only shows your activity so I cannot find what and where you have to change your AsyncTask, but you can view this some what related question to see another example of IndexOutOfBoundsException", "label": {"api": {"IndexOutOfBoundsException": [[180, 204]]}}}, {"text": "Arrays.fill() is a standard API method that assigns the given value to every element of the given array", "label": {"api": {"standard API method": [[19, 37]]}}}, {"text": "You can have a simple getter that return a numeric value based on your String value and simply return the difference of both numeric values in your compare() method (remember that compare() should return 0 if the two objects are equals, see Comparable javadoc", "label": {"api": {"Comparable": [[241, 250]]}}}, {"text": "As a sanity check, I performed a BufferedReader readLine() and it works fine", "label": {"api": {"BufferedReader readLine()": [[33, 57]]}}}, {"text": "In both cases, line 324 int n = readBytes(); reads the entire file into the buffer hitting the continue and coming back around to line 316 CoderResult cr = decoder.decode(bb, cb, eof); At this point cr is wrapping a MalformedInputException which gets consumed by Scanner catch (IOException ioe)", "label": {"api": {"MalformedInputException": [[216, 238]]}}}, {"text": "As stated in their javadoc (http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html and http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html), StringBuffer and StringBuilder provider the same set of operations", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html": [[28, 95]], "http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html": [[101, 169]]}}}, {"text": "After the conn.connect() call, add a call to getHeaderFields() and print out the contents of the map", "label": {"api": {"getHeaderFields()": [[45, 61]]}}}, {"text": "If you want to find the pattern regardless of delimiters use, String#findInLine", "label": {"api": {"String#findInLine": [[62, 78]]}}}, {"text": "Most part of the keys and special characters are present in the KeyEvent class", "label": {"api": {"KeyEvent": [[64, 71]]}}}, {"text": "But here's version using String.split()", "label": {"api": {"String.split()": [[25, 38]]}}}, {"text": "At runtime, you'd have to do the check yourself with reflection, Class#getAnnotation(Class)", "label": {"api": {"Class#getAnnotation(Class)": [[65, 90]]}}}, {"text": "There are concurrency classes for this in the javafx.concurrent package, such as Task and Worker which essentially wrap a Runnable for you", "label": {"api": {"Task": [[81, 84]], "Worker": [[90, 95]]}}}, {"text": "Use Platform#runLater(Runnable) to execute these in the right context", "label": {"api": {"Platform#runLater(Runnable)": [[4, 30]]}}}, {"text": "Could you stash the value into a Formattable and use Formattable#formatTo to generate the desired output", "label": {"api": {"Formattable#formatTo": [[53, 72]]}}}, {"text": "Even if you add a DecimalFormatSymbolsProvider class, it must still return a char value from DecimalFormatSymbols.html#getDecimalSeparator()", "label": {"api": {"DecimalFormatSymbols.html#getDecimalSeparator()": [[93, 139]]}}}, {"text": "You could check to see if a common hostname (such as google) is resolvable through dns to an ip address", "label": {"api": {"resolvable": [[64, 73]]}}}, {"text": "Once that address has been resolved, you can check to see if it is reachable", "label": {"api": {"reachable": [[67, 75]]}}}, {"text": "and the method String#replaceAll(String regex, String replacement)", "label": {"api": {"String#replaceAll(String regex, String replacement)": [[15, 65]]}}}, {"text": "Another option might be to make Players implement Iterable<Hand>, which means you can directly loop over a Players instance in a for-each loop", "label": {"api": {"Iterable<Hand>": [[50, 63]]}}}, {"text": "If you have a traditional jse environment, you can register a shutdown hook", "label": {"api": {"register a shutdown hook": [[51, 74]]}}}, {"text": "If you are in a servlet container, you can use a ServletContextListener to be told when the context is destroyed", "label": {"api": {"context is destroyed": [[92, 111]]}}}, {"text": "If we are talking about reading and writing so few lines you can use java's class RandomAccessFile which fits exactly to your needs, but by experience i can tell that if you need to deal with a considerable amount of data IO, this is very inefficient", "label": {"api": {"RandomAccessFile": [[82, 97]]}}}, {"text": "Here's a tutorial on how to use RandomAccessFile", "label": {"api": {"RandomAccessFile": [[32, 47]]}}}, {"text": "runtime.exec actually executes a process", "label": {"api": {"runtime.exec": [[0, 11]]}}}, {"text": "To show your processing screen for a certain amount of time you need to use an animation and show your reporting screen once the animation has finished", "label": {"api": {"animation": [[79, 87], [129, 137]]}}}, {"text": "If you go this route, the code should look similar to the above, except you would be using the Task class and the setOnSucceeded method", "label": {"api": {"Task class": [[95, 104]], "setOnSucceeded method": [[114, 134]]}}}, {"text": "Your question is actually about the concurrencyLevel", "label": {"api": {"concurrencyLevel": [[36, 51]]}}}, {"text": "concurrencyLevel - the estimated number of concurrently updating threads", "label": {"api": {"concurrencyLevel": [[0, 15]]}}}, {"text": "Therefore if you know that only one thread will access your map, setting the concurrencyLevel to 1 will only create 1 segment in the map, thus making it more memory-efficient", "label": {"api": {"concurrencyLevel": [[77, 92]]}}}, {"text": "You can use java.util.Scanner class in order to read your file", "label": {"api": {"java.util.Scanner": [[12, 28]]}}}, {"text": "contains checks if the given element can be found in the list", "label": {"api": {"contains": [[0, 7]]}}}, {"text": "Try equals (or containsAll) instead", "label": {"api": {"contains": [[15, 22]], "equals": [[4, 9]], "containsAll": [[15, 25]]}}}, {"text": "Use Base64 encoding to send response data to your client", "label": {"api": {"Base64 encoding": [[4, 18]]}}}, {"text": "You could use Class#isInstance", "label": {"api": {"Class#isInstance": [[14, 29]]}}}, {"text": "The shuffle() method returns void, so you don't need a return value", "label": {"api": {"shuffle()": [[4, 12]]}}}, {"text": "You can use some of the other methods to get it in hours", "label": {"api": {"hours": [[51, 55]]}}}, {"text": "Is there an equivalent in Java 8's java.time API", "label": {"api": {"Java 8's java.time API": [[26, 47]]}}}, {"text": "You can partially do this with something like AsynchronousFileChannel", "label": {"api": {"AsynchronousFileChannel": [[46, 68]]}}}, {"text": "This helps in that you don't have to wait for the file to read, once the file has been read the JDK will call the complete method of the provided CompletionHandler(write your own to suit the needs listed)", "label": {"api": {"CompletionHandler": [[146, 162]]}}}, {"text": "This is mentioned briefly in the spec for System.loadLibrary", "label": {"api": {"System.loadLibrary": [[42, 59]]}}}, {"text": "Basically, if you call System.loadLibrary(\"foo\"), the system looks for the function JNI_OnLoad_foo in the running executable image, and if it's found, it assumes that the library is statically linked, and its native methods are searched for within the running image", "label": {"api": {"System.loadLibrary": [[23, 40]]}}}, {"text": "Many implementations of ExecutorService manage a thread pool", "label": {"api": {"ExecutorService": [[24, 38]]}}}, {"text": "Your instance has several threads in the WAITING state, perhaps as a result of invoking LockSupport.park()", "label": {"api": {"WAITING": [[41, 47]]}}}, {"text": "The API illustrates a common shutdown approach, which you can tailor to your use", "label": {"api": {"API": [[4, 6]]}}}, {"text": "Use ScheduledExecutorService to schedule a command to run after a given period of time", "label": {"api": {"ScheduledExecutorService": [[4, 27]]}}}, {"text": "You can then write a method to log a message and hook it up to the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[67, 90]]}}}, {"text": "However, Method 2 runs the risk of getting a StackOverflowError if the tree is large", "label": {"api": {"StackOverflowError": [[45, 62]]}}}, {"text": "When no row is selected, getSelectedRow() returns -1", "label": {"api": {"getSelectedRow()": [[25, 40]]}}}, {"text": "In Java 7 you can use class Segment for representation", "label": {"api": {"Segment": [[28, 34]]}}}, {"text": "You could also use the CharSequence as attribute for methods", "label": {"api": {"CharSequence": [[23, 34]]}}}, {"text": "If you are modifying the same arrayList (specially removes values) while reading it better to use CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[98, 117]]}}}, {"text": "Stack extends Vector, which is synchronized", "label": {"api": {"Vector": [[14, 19]]}}}, {"text": "It's recommended to use ArrayDeque in place of Stack, and ArrayList in place of Vector", "label": {"api": {"Vector": [[80, 85]]}}}, {"text": "Just keep in mind that String.charAt() returns a char not an int", "label": {"api": {"String.charAt()": [[23, 37]]}}}, {"text": "As per ServletRequest documentation, it is mentioned that", "label": {"api": {"ServletRequest": [[7, 20]]}}}, {"text": "That means ServletRequest object is used to transfer client side information to server methods", "label": {"api": {"ServletRequest": [[11, 24]]}}}, {"text": "I am using the Document method createPosition to add Positions to an array", "label": {"api": {"createPosition": [[31, 44]]}}}, {"text": "quote() will escape reserved; regular expression characters like so", "label": {"api": {"quote()": [[0, 6]]}}}, {"text": "This is easiest with built-in functions and implementations, like Set", "label": {"api": {"Set": [[66, 68]]}}}, {"text": "There are Set implementations, like HashSet, which give you constant-time performance for looking up values and inserting them", "label": {"api": {"Set": [[10, 12], [40, 42]]}}}, {"text": "Your Data object might need to have member fields of type http://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html if I am reading your question correctly", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html": [[58, 124]]}}}, {"text": "You can do this much much shorter using replaceAll()", "label": {"api": {"replaceAll()": [[40, 51]]}}}, {"text": "You either need to convert the local character set to UTF-16 in native code and then use NewString, or pass arrays of byte[] into your Java code and then use the String constructor that takes a charset argument", "label": {"api": {"String constructor that takes a charset": [[162, 200]]}}}, {"text": "Construct new instance providing image byte array and necessary headers like content length and mime type then return it from your method", "label": {"api": {"method": [[131, 136]]}}}, {"text": "Image bytes can be obtained using classloader getResourceAsStream method", "label": {"api": {"method": [[66, 71]]}}}, {"text": "In the generic class Class<T> the method getConstructors() has a return type with unknown generic type parameter instead of T", "label": {"api": {"Class<T>": [[21, 28]], "getConstructors()": [[41, 57]]}}}, {"text": "Second, there is a reason File has a File, String constructor, this code should read", "label": {"api": {"File, String": [[37, 48]]}}}, {"text": "An alternative which does essentially the same thing, using Java 8 new getOrDefault method", "label": {"api": {"Java 8 new getOrDefault method": [[60, 89]]}}}, {"text": "A more elegant way would be to place each group of numbers in an ArrayList and then check if the Random number is contained in the array with the contains() method", "label": {"api": {"ArrayList": [[65, 73]], "contains()": [[146, 155]]}}}, {"text": "From the Java Javadoc for getParameter(String name), emphasis mine", "label": {"api": {"getParameter(String name)": [[26, 50]]}}}, {"text": "When interacting with a database, you need to provide a Calendar for both setting into a PreparedStatement and getting from a ResultSet", "label": {"api": {"setting": [[74, 80]], "getting": [[111, 117]]}}}, {"text": "To learn more about how is this default toString implementation generating that String, you can refer to the javadoc entry for Object#toString", "label": {"api": {"the javadoc entry for Object#toString": [[105, 141]]}}}, {"text": "Only the CSS attributes which are defined in the JavaFX CSS reference guide are valid in JavaFX - you can't use CSS attributes designed for HTML such as background-color", "label": {"api": {"JavaFX CSS reference guide": [[49, 74]]}}}, {"text": "I know there is a technically better solution to use a StringBuffer and the insert method for that class, or even regex, but I'll show you a different algorithmic approach using String#substring", "label": {"api": {"StringBuffer": [[55, 66]], "insert": [[76, 81]], "String#substring": [[178, 193]]}}}, {"text": "You can use SimpleDateFormat to format and parse any date string", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "Since you have not highlited it, the most straightforward way to ge a String literal out from an Array is to use the Arrays#toString method from java.util package", "label": {"api": {"Arrays#toString": [[117, 131]]}}}, {"text": "Is there any relationship between JavaBean and BeanInfo", "label": {"api": {"BeanInfo": [[47, 54]]}}}, {"text": "I read various posts/questions and about Java Bean it is mentioned a bean is a regular class which adheres to some rule (private data members, getters() , setters(), implements Serializabe interface...)", "label": {"api": {"Serializabe": [[177, 187]]}}}, {"text": "I was going through book \"Java Complete reference, 8th Edition\" and came across BeanInfo, in chapter on \"Java Beans\"", "label": {"api": {"BeanInfo": [[80, 87]]}}}, {"text": "What relation a Java Bean has with BeanInfo", "label": {"api": {"BeanInfo": [[35, 42]]}}}, {"text": "The Java collections API has a sort method that sorts a list in-place", "label": {"api": {"sort": [[31, 34], [48, 51]]}}}, {"text": "Is there such a method that doesn't change the given list but returns a sorted one", "label": {"api": {"sort": [[72, 75]]}}}, {"text": "Try with UUID as", "label": {"api": {"UUID": [[9, 12]]}}}, {"text": "You can create a ThreadPoolExecutor with a PriorityBlockingQueue", "label": {"api": {"create a ThreadPoolExecutor": [[8, 34]], "a PriorityBlockingQueue": [[41, 63]]}}}, {"text": "For advanced locking mechanisms, please see the Lock interface", "label": {"api": {"Lock interface": [[48, 61]]}}}, {"text": "A HashSet can perform a contains check in constant time, making it very suitable for this purpose", "label": {"api": {"HashSet": [[2, 8]]}}}, {"text": "JTextField inherits off off java.awt.Component which has a method http://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#addKeyListener-java.awt.event.KeyListener- where you can register a listener and process what key is being pressed", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#addKeyListener-java.awt.event.KeyListener-": [[66, 172]]}}}, {"text": "Check out StringBuilder", "label": {"api": {"StringBuilder": [[10, 22]]}}}, {"text": "The difference between your code and your book is that Comparable is defined like this", "label": {"api": {"defined": [[69, 75]]}}}, {"text": "You can easily convert one into the other using java.utils.Arrays", "label": {"api": {"java.utils.Arrays": [[48, 64]]}}}, {"text": "Instead I'd like to use java.awt.Image#getScaledInstance with Image.SCALE_SMOOTH (or the JavaFX equivalent), which generates an image of much higher quality", "label": {"api": {"java.awt.Image#getScaledInstance": [[24, 55]], "Image.SCALE_SMOOTH": [[62, 79]]}}}, {"text": "While you can't use a java.awt.Image in place of a javafx.scene.image.Image, using this javafx.scene.image.Image constructor", "label": {"api": {"this javafx.scene.image.Image constructor": [[83, 123]]}}}, {"text": "If you're just writing a single String, you have the option of using Files.write, which allows you to forego the use of a Writer altogether", "label": {"api": {"Files.write": [[69, 79]]}}}, {"text": "If you really care about precision, may be you want to use java.math.BigDecimal", "label": {"api": {"java.math.BigDecimal": [[59, 78]]}}}, {"text": "You should use Runtime.exec(String[] comand) something like this", "label": {"api": {"Runtime.exec(String[] comand)": [[15, 43]]}}}, {"text": "The Joda-Time library, and the new java.time package in Java 8, use ISO 8601 extensively", "label": {"api": {"java.time package": [[35, 51]]}}}, {"text": "Take in mind that the InitialContext instance is not synchronized, therefore, caching can be dangerous if the same instance is accessed by concurrent threads", "label": {"api": {"InitialContext": [[22, 35]]}}}, {"text": "you have to put files used in you code inside the WebContent and try with ServletContext which point to the root folder of the your web application", "label": {"api": {"ServletContext": [[74, 87]]}}}, {"text": "PI is declared to be static in the java Math class", "label": {"api": {"Math": [[40, 43]]}}}, {"text": "I think you've misunderstood the purpose of setFirstDayOfWeek", "label": {"api": {"setFirstDayOfWeek": [[44, 60]]}}}, {"text": "See What's new in Java 8 and @since in java.util.function.Consumer", "label": {"api": {"java.util.function.Consumer": [[39, 65]]}}}, {"text": "Check out the Comparable interface", "label": {"api": {"Comparable": [[14, 23]]}}}, {"text": "Create a FixedThreadPool with only one thread and submit tasks to it", "label": {"api": {"FixedThreadPool": [[9, 23]]}}}, {"text": "(The String type does for example not offer such a method, other than implied by your question.') The rational is probably the fact that these primitive types are common for properties that are handed over as a system property", "label": {"api": {"not offer such a method": [[34, 56]]}}}, {"text": "\"MM\" is for the month in year, \"mm\" is for the minutes in hour (see http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[68, 139]]}}}, {"text": "Yes, the \"Java(TM) EE 7 Specification APIs\" supports encoding and decoding with uuencode", "label": {"api": {"Java(TM) EE 7 Specification APIs": [[10, 41]]}}}, {"text": "As kdgregory informed me, http://docs.oracle.com/javase/7/docs/api/index-files/index-7.html exists", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/index-files/index-7.html": [[26, 90]]}}}, {"text": "a ProcessBuilder is used to execute a command in the background of a SwingWorker, while the command's output is displayed in a suitable component", "label": {"api": {"ProcessBuilder": [[2, 15]]}}}, {"text": "Consider using the new (Java 8) StringJoiner", "label": {"api": {"StringJoiner": [[32, 43]]}}}, {"text": "As said Greg, replace FileReader with InputStreamReader and try to give your native language as a charset in constructor", "label": {"api": {"InputStreamReader": [[38, 54]]}}}, {"text": "String implements the CharSequence interface, which defines a length() method, so String has to have that method", "label": {"api": {"CharSequence": [[22, 33]]}}}, {"text": "IntStream has a mapToObj method for this", "label": {"api": {"IntStream": [[0, 8]]}}}, {"text": "While Socket class itself implements AutoCloseable interface, array of Sockets - does not", "label": {"api": {"AutoCloseable": [[37, 49]]}}}, {"text": "When you output a Date by calling toString() (which is what System.out.println(\"Data type is Date    = \" + gmt); does) you will get that Date according to the system time zone, because that is what Date.toString() returns", "label": {"api": {"Date.toString()": [[198, 212]]}}}, {"text": "You need to close your streams when done", "label": {"api": {"close": [[12, 16]]}}}, {"text": "close flushes the stream first", "label": {"api": {"close": [[0, 4]]}}}, {"text": "This will happen if you did not implement the getChildren and isLeaf method or implemented isLeaf incorrectly", "label": {"api": {"isLeaf": [[62, 67], [91, 96]]}}}, {"text": "The isLeaf method tells the JTree UI to draw or not draw the folder icon", "label": {"api": {"isLeaf": [[4, 9]]}}}, {"text": "Also make sure setAsksAllowsChildren() is set the the correct value for your needs and getChildCount() returns the correct value for each node", "label": {"api": {"setAsksAllowsChildren()": [[15, 37]], "getChildCount()": [[87, 101]]}}}, {"text": "The ContainerRequestContext class provides a rich API to get request-specific information, such as the request URI, headers, entity, cookies or request-scoped properties", "label": {"api": {"ContainerRequestContext": [[4, 26]]}}}, {"text": "The way to go is inject the HttpServletRequest in your filter", "label": {"api": {"HttpServletRequest": [[28, 45]]}}}, {"text": "And then extract the client IP address using ServletRequest#getRemoteAddr()", "label": {"api": {"ServletRequest#getRemoteAddr()": [[45, 74]]}}}, {"text": "You can write a ServletContextListener that uses a ScheduledExecutorService (or Timer) to start your process in the contextInitialized method and stops it in the contextDestroyed method", "label": {"api": {"ServletContextListener": [[16, 37]]}}}, {"text": "If you are actually wanting to iterate over all the columns to get type information, you need to get the column count and use that", "label": {"api": {"column count": [[105, 116]]}}}, {"text": "If the user types in a value which is not an integer, the cast will fail and throw a NumberFormatException", "label": {"api": {"NumberFormatException": [[85, 105]]}}}, {"text": "If hou have an array of ints, use IntBuffer class and wrap your int[] into an IntBuffer instance", "label": {"api": {"IntBuffer": [[34, 42], [78, 86]]}}}, {"text": "Give your IntBuffer object as an argument to write() method of your SocketChannel", "label": {"api": {"IntBuffer": [[10, 18]]}}}, {"text": "For implementing lambda expressions, javac creates an INVOKEDYNAMIC instruction which delegates the invocation to the LambdaMetafactory's bootstrap method", "label": {"api": {"LambdaMetafactory": [[118, 134]]}}}, {"text": "After all, I found a way of getting hold of a lambda expression's class file that is rather reliable (but of course still relies on implementation details.) For an experimental implementation, I am now using a Java agent which allows for the retransformation of classes but which is itself implemented as a no-op, I am only interested in the binary array that is handed as an argument", "label": {"api": {"Java agent": [[210, 219]]}}}, {"text": "After getting hold of an Instrumentation instance via the registered Java agent, one registers a ClassFileTransformer which is then notified over the binary representation once one retransforms lambdaInstance.getClass()", "label": {"api": {"Java agent": [[69, 78]]}}}, {"text": "As the comment already says, DefaultTableModel#setRowCount is the way to go", "label": {"api": {"DefaultTableModel#setRowCount": [[29, 57]]}}}, {"text": "Try StringTokenizer, it's unlikely to be much better but it's worth a go", "label": {"api": {"StringTokenizer": [[4, 18]]}}}, {"text": "Use a raw regex Matcher and build your list manually", "label": {"api": {"Matcher": [[16, 22]]}}}, {"text": "For example, I wanted an exception something along the lines of \"Already exists\" and I found the exception \"EntityExistsException.\" The name was great, but it seems it was intended for the EntityManager", "label": {"api": {"EntityExistsException": [[108, 128]]}}}, {"text": "TextFieldTableCell provides a static forTableColumn(...) method that takes a StringConverter<T> and returns a Callback which can be used as a cellFactory for a TableColumn<S,T>", "label": {"api": {"forTableColumn(...)": [[37, 55]]}}}, {"text": "Take, for example, a look at the java.lang.String class", "label": {"api": {"java.lang.String": [[33, 48]]}}}, {"text": "Adding an element at index 1 is therefore impossible, as stated in the docs", "label": {"api": {"stated in the docs": [[57, 74]]}}}, {"text": "If you want to start a random number generator with some seed, or generate a new number between 0 and some ceiling, look into java.util.Random instead", "label": {"api": {"java.util.Random": [[126, 141]]}}}, {"text": "Another alternative is to create a BufferedImage and set the rgb value for each pixel directly", "label": {"api": {"set": [[53, 55]]}}}, {"text": "Shuffle the ArrayList", "label": {"api": {"Shuffle": [[0, 6]]}}}, {"text": "From Object documentation", "label": {"api": {"Object": [[5, 10]]}}}, {"text": "The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true)", "label": {"api": {"Object": [[28, 33]]}}}, {"text": "I wrote a backup program using Deflater and SHA-1 to store files and a hash value", "label": {"api": {"Deflater": [[31, 38]]}}}, {"text": "I see that Java's Deflater uses zlib", "label": {"api": {"Deflater": [[18, 25]]}}}, {"text": "If I explicit set the Deflater's level, could I expect to always get the same series of bytes regardless of platform and JRE version", "label": {"api": {"Deflater": [[22, 29]]}}}, {"text": "I could just use Collections.synchronizedMap to make it thread safe, but I would like to avoid that since it implies tons of synchronizations everywhere which might have a significant performance impact", "label": {"api": {"Collections.synchronizedMap": [[17, 43]]}}}, {"text": "I was looking into using a WeakHashMap instead to address the second issue, since it allows its entries to be garbage collected once the keys are no longer in use, but I came across two potential issues with that as well", "label": {"api": {"WeakHashMap": [[27, 37]]}}}, {"text": "If it does need to manage concurrency somehow, I would prefer it to do so via the classes in java.util.concurrent.atomic", "label": {"api": {"java.util.concurrent.atomic": [[93, 119]]}}}, {"text": "As suggested by @JBNizet and @SotiriosDelimanolis, ThreadLocal might do the trick", "label": {"api": {"ThreadLocal": [[51, 61]]}}}, {"text": "The Java API documentation for ByteBuffer.arrayOffset states", "label": {"api": {"ByteBuffer.arrayOffset": [[31, 52]]}}}, {"text": "Does anyone know how to change the result of a call to the ByteBuffer.arrayOffset() method", "label": {"api": {"ByteBuffer.arrayOffset": [[59, 80]]}}}, {"text": "Never use double but rather use BigDecimal when representing money in Java", "label": {"api": {"BigDecimal": [[32, 41]]}}}, {"text": "This declares an array of Class objects references", "label": {"api": {"Class": [[26, 30]]}}}, {"text": "Just use String's built-in compareTo method", "label": {"api": {"compareTo": [[27, 35]]}}}, {"text": "substring(int), and substring(int, int)", "label": {"api": {"substring(int)": [[0, 13]], "substring(int, int)": [[20, 38]]}}}, {"text": "split(String) split(String, int)", "label": {"api": {"split(String)": [[0, 12]], "split(String, int)": [[14, 31]]}}}, {"text": "In this case using String.split is probably your best bet", "label": {"api": {"String.split": [[19, 30]]}}}, {"text": "String.split will divide your string into an array based upon a delimiter that you pass in", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "Try using JTextArea#write(Writer) instead..", "label": {"api": {"JTextArea#write(Writer)": [[10, 32]]}}}, {"text": "PerspectiveTransform can only be applied to a canvas as a whole and not to elements inside a Canvas", "label": {"api": {"PerspectiveTransform": [[0, 19]], "Canvas": [[93, 98]]}}}, {"text": "The PerspectiveTransform effect works on a node", "label": {"api": {"PerspectiveTransform": [[4, 23]]}}}, {"text": "The canvas allows you to set an affine transform which will be applied to subsequent drawing instructions for the canvas, but a perspective transform is a non-affine transform, so that won't help you", "label": {"api": {"set an affine transform": [[25, 47]]}}}, {"text": "Use a true 3D surface and co-ordinates instead of the faux 3D provided by PerspectiveTransform, then JavaFX will take care of performing the correct perspective transform calculations for you", "label": {"api": {"PerspectiveTransform": [[74, 93]]}}}, {"text": "If you are interested in porting code from a AWT/Swing Graphics2D to a JavaFX GraphicsContext, the following question may be useful", "label": {"api": {"Graphics2D": [[55, 64]], "GraphicsContext": [[78, 92]]}}}, {"text": "Interoperability between Graphics2D and GraphicsContext", "label": {"api": {"Graphics2D": [[25, 34]], "GraphicsContext": [[40, 54]]}}}, {"text": "Just reading the javadoc of AudioSystem give me an idea", "label": {"api": {"AudioSystem": [[28, 38]]}}}, {"text": "You should read the documentation of List and Map (respective HashMap) to see how to use them", "label": {"api": {"List": [[37, 40]], "Map": [[46, 48], [66, 68]], "HashMap": [[62, 68]]}}}, {"text": "Since your List contains Map you'll have to get a Map using the List operations and then get the elements from that Map using the Map operations", "label": {"api": {"List": [[11, 14], [64, 67]], "Map": [[25, 27], [50, 52], [116, 118], [130, 132]]}}}, {"text": "You could use the URL class, which will also give you validation to ensure your url is correct", "label": {"api": {"URL": [[18, 20]]}}}, {"text": "The constructor will throw an exception if the URL is not valid", "label": {"api": {"URL": [[47, 49]]}}}, {"text": "Consider NumberFormat class from standard java library", "label": {"api": {"NumberFormat": [[9, 20]]}}}, {"text": "you can iterate over components in your panel using getComponents()", "label": {"api": {"getComponents()": [[52, 66]]}}}, {"text": "Since AbstractBasic does not implement Serializable, its fields will not be serialized when CustomBolt is serialized", "label": {"api": {"will not be serialized": [[64, 85]]}}}, {"text": "You can spawn external processes in Java using the System class (http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html": [[65, 127]]}}}, {"text": "With the Process object you can access the input / output / error stream of the external command (see http://docs.oracle.com/javase/7/docs/api/java/lang/Process.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Process.html": [[102, 164]]}}}, {"text": "Look into the ExecutorService for a canonical way of pooling threads in Java", "label": {"api": {"ExecutorService": [[14, 28]]}}}, {"text": "Look into Java's ForkJoinPool", "label": {"api": {"ForkJoinPool": [[17, 28]]}}}, {"text": "If you need to store an IPv6 address in Java, you should use the java.net.Inet6Address class", "label": {"api": {"java.net.Inet6Address class": [[65, 91]]}}}, {"text": "In order to eliminate the need to write a custom Pointer class, I would simply use AtomicReference", "label": {"api": {"AtomicReference": [[83, 97]]}}}, {"text": "A good way to parallelize a lot of small tasks is to wrap the processing of each task with a FutureTask and then pass each task to a ThreadPoolExecutor to run them", "label": {"api": {"FutureTask": [[93, 102]], "ThreadPoolExecutor": [[133, 150]]}}}, {"text": "To avoid creating and destroying too many threads, the ScheduledThreadPoolExecutor will only create as many threads as you specified and execute the futures one after another", "label": {"api": {"ThreadPoolExecutor": [[64, 81]]}}}, {"text": "Check out the JComponent and JFrame classes at http://docs.oracle.com/javase/7/docs/api/ for more information", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/": [[47, 87]]}}}, {"text": "The standard way is to use the JComboBox.setPrototypeDisplayValue() method; ideally you'd pass in the longest item so that the combobox can set a good default width", "label": {"api": {"JComboBox.setPrototypeDisplayValue()": [[31, 66]]}}}, {"text": "Here's the API documentation of the class Socket from Java 5", "label": {"api": {"Java 5": [[54, 59]]}}}, {"text": "I found the answer deep inside the JDK8 javadocs", "label": {"api": {"deep inside the JDK8 javadocs": [[19, 47]]}}}, {"text": "http://docs.oracle.com/javase/8/docs/api/ and the source attachment is \"javafx-src.zip\" in the JDK", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/": [[0, 40]]}}}, {"text": "Also, even if the source files are missing, why is Eclipse still unable to find the javadocs, since http://docs.oracle.com/javase/8/docs/api/ is set as the javadoc location", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/": [[100, 140]]}}}, {"text": "You should use a Rectangle for a hitbox", "label": {"api": {"Rectangle": [[17, 25]]}}}, {"text": "If you would prefer to use a ellipse for your cirlces though you can use a Ellipse2D", "label": {"api": {"Ellipse2D": [[75, 83]]}}}, {"text": "Although if you do this you will have to use a Rectangle2D", "label": {"api": {"Rectangle": [[47, 55]], "Rectangle2D": [[47, 57]]}}}, {"text": "If you choose to use an Ellipse2D then you must declare it like this", "label": {"api": {"Ellipse2D": [[24, 32]]}}}, {"text": "I strongly advise you to read the Javadoc on Scanner to see which methods advance the Scanner instance and which do not", "label": {"api": {"Javadoc on Scanner": [[34, 51]]}}}, {"text": "Method indexOf return the first position in string s that contains the string you pass in the method", "label": {"api": {"indexOf": [[7, 13]]}}}, {"text": "I am using ClassLoader#getResourceAsStream(String filename) to read a properties file in the same directory where my jar file is", "label": {"api": {"ClassLoader#getResourceAsStream(String filename)": [[11, 58]]}}}, {"text": "java.sql.Connection interface has constants for the different isolation levels that you can compare the number against or that you can use to set the right isolation level, if required", "label": {"api": {"java.sql.Connection": [[0, 18]]}}}, {"text": "JDK 1.5 Properties load method only gets InputStream while JDK 1.6+ load method also gets also Reader", "label": {"api": {"load": [[19, 22], [68, 71]]}}}, {"text": "When a string with Unicode characters is loaded to a properties object on JDK 1.6+ with load(reader), there is no problem", "label": {"api": {"load": [[41, 44], [88, 91]]}}}, {"text": "But on JDK 1.5 there is only load(InputStream) method; when loaded to properties unicode characters are not correctly loaded", "label": {"api": {"load": [[29, 32], [60, 63], [118, 121]]}}}, {"text": "How can I load following example string with unicode characters to properties object", "label": {"api": {"load": [[10, 13]]}}}, {"text": "HashSet not grantee the insertion order", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "you can use TreeSet or LinkHashSet if you are concern about the insertion order", "label": {"api": {"HashSet": [[27, 33]], "TreeSet": [[12, 18]], "LinkHashSet": [[23, 33]]}}}, {"text": "With that said you can use Java Sockets to communicate between these two", "label": {"api": {"Socket": [[32, 37]]}}}, {"text": "You need to Implement ServerSocket for Application 2 and Socket for Applilcation 1", "label": {"api": {"ServerSocket": [[22, 33]], "Socket": [[28, 33], [57, 62]]}}}, {"text": "Note that as Collections.unmodifiableList does only provide a view, the caller will still see any other changes that are made via addToCarList and removeFromCarList (which I'd rename to addCar and removeCar, probably)", "label": {"api": {"Collections.unmodifiableList": [[13, 40]]}}}, {"text": "You could use the Scanner class", "label": {"api": {"Scanner": [[18, 24]]}}}, {"text": "I know there are questions relating to java.util.Date and Joda-Time", "label": {"api": {"java.util.Date": [[39, 52]]}}}, {"text": "But after some digging, I couldn't find a thread about the differences between the java.time API (new in Java 8, defined by JSR 310) and Joda-Time", "label": {"api": {"java.time API": [[83, 95]]}}}, {"text": "I have heard that Java 8’s java.time API is much cleaner and can do much more than Joda-Time", "label": {"api": {"java.time API": [[27, 39]]}}}, {"text": "since the function Integer::intValue is fully compatible with ToIntFunction since it takes an Integer and it returns an int", "label": {"api": {"Integer::intValue": [[19, 35]], "ToIntFunction": [[62, 74]]}}}, {"text": "I was also looking for an equivalent of Function::identity, i hoped to write an equivalent of your bar method", "label": {"api": {"Function::identity": [[40, 57]]}}}, {"text": "An alternate way to transform that would be using Stream.flatMapToInt and IntStream.of as", "label": {"api": {"Stream.flatMapToInt": [[50, 68]], "IntStream.of": [[74, 85]]}}}, {"text": "I would throw the IllegalStateException, because you are missing the parameter", "label": {"api": {"IllegalStateException": [[18, 38]]}}}, {"text": "In case the value of parameter would be invalid, then i would throw an IllegalArgumentException", "label": {"api": {"IllegalArgumentException": [[71, 94]]}}}, {"text": "IllegalStateException - Signals that a method has been invoked at an illegal or inappropriate time", "label": {"api": {"IllegalStateException": [[0, 20]]}}}, {"text": "IllegalArgumentException - Thrown to indicate that a method has been passed an illegal or inappropriate argument", "label": {"api": {"IllegalArgumentException": [[0, 23]]}}}, {"text": "Change the format of the SimpleFormatter using the system property", "label": {"api": {"SimpleFormatter": [[25, 39]], "format": [[11, 16]]}}}, {"text": "or in the logging.properties", "label": {"api": {"logging.properties": [[10, 27]]}}}, {"text": "All of these properties are documented in the format method", "label": {"api": {"format": [[46, 51]]}}}, {"text": "Change ComboBox to ComboBox<Integer> and ComboBox<String>", "label": {"api": {"ComboBox": [[7, 14], [19, 26], [41, 48]]}}}, {"text": "Similarly, the TableColumn fields should be TableColumn<Resultat, Integer> and TableColumn<Resultat, String> respectively", "label": {"api": {"TableColumn": [[15, 25], [44, 54], [79, 89]]}}}, {"text": "The documentation for ComboBox and TableColumn has more information", "label": {"api": {"ComboBox": [[22, 29]], "TableColumn": [[35, 45]]}}}, {"text": "Since the entity that will consume the webservice uses Windows as their operating system of choice, the solution to this problem is to change the new line in the Linux environment from LF only to CRLF when the method is called, we can do this by using java.lang.System.setProperty(String key, String value) method for the \"line.separator\" property then return it back to its original status at the end of the method", "label": {"api": {"java.lang.System.setProperty(String key, String value)": [[252, 305]]}}}, {"text": "The phrase \"Data dealt with is 16-bit Unicode characters\" refers to the fact that a Reader or Writer only reads or writes char values (or ints which hold char values)", "label": {"api": {"Reader": [[84, 89]], "Writer": [[94, 99]]}}}, {"text": "Encoding is not a consideration when code uses a Reader or Writer, because it only works with char values", "label": {"api": {"Reader": [[49, 54]], "Writer": [[59, 64]]}}}, {"text": "Encoding only matters when, as you have stated, you are creating a Reader or Writer that wraps an InputStream or OutputStream—specifically, when creating an InputStreamReader or OutputStreamWriter", "label": {"api": {"Reader": [[67, 72], [168, 173]], "Writer": [[77, 82], [190, 195]]}}}, {"text": "If you can use Java 8, the Math.nextDown function appears to be exactly what you're looking for", "label": {"api": {"Math.nextDown": [[27, 39]]}}}, {"text": "If you can't use Java 8, the relevant line from the source of Math.nextDown is", "label": {"api": {"Math.nextDown": [[62, 74]]}}}, {"text": "I guess that the substring method should be enough for your purpose, something like", "label": {"api": {"substring": [[17, 25]]}}}, {"text": "You may look into the use of an AtomicInteger instead of using an enum or a mutable object to wrap a value", "label": {"api": {"AtomicInteger": [[32, 44]]}}}, {"text": "As all AtomicInteger objects are mutable, this does what you will need", "label": {"api": {"AtomicInteger": [[7, 19]]}}}, {"text": "Are you perhaps looking for the behavior EnumMap provides, the ability to map enums to different values", "label": {"api": {"EnumMap": [[41, 47]]}}}, {"text": "An alternative would be to use a ThreadLocal, this lets you specify a unique value per-thread (under the covers, it's essentially a map, like above), so that multiple threads don't interrupt each other", "label": {"api": {"ThreadLocal": [[33, 43]]}}}, {"text": "Just use Collections.shuffle() to shuffle the list itself", "label": {"api": {"Collections.shuffle()": [[9, 29]]}}}, {"text": "Create FileInputStream instance for your file", "label": {"api": {"FileInputStream": [[7, 21]]}}}, {"text": "valueOf calls a constructor, which in the source code has the following javadocs (taken from offical javadocs API)", "label": {"api": {"offical javadocs API": [[93, 112]]}}}, {"text": "The default level for the ConsoleHandler is INFO", "label": {"api": {"ConsoleHandler": [[26, 39]]}}}, {"text": "The default level for the logger is inherited from its parent", "label": {"api": {"logger": [[26, 31]]}}}, {"text": "By default, the root logger is usually set to INFO", "label": {"api": {"logger": [[21, 26]]}}}, {"text": "Change the log level of the ConsoleHandler to ALL and change the level of the logger to FINE", "label": {"api": {"ConsoleHandler": [[28, 41]], "logger": [[78, 83]]}}}, {"text": "What's the main difference between scheduleAtFixedRate and scheduleWithFixedDelay methods of ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[93, 116]]}}}, {"text": "I figured I should use a JPA Converter and to convert to and from java.sql.Struct (or maybe oracle.sql.STRUCT)", "label": {"api": {"Converter": [[29, 37]]}}}, {"text": "To cancel previous task you can cancel the ScheduledFuture using cancel(boolean)", "label": {"api": {"cancel(boolean)": [[65, 79]]}}}, {"text": "If you want to be able to input an entire sentence, use nextLine()", "label": {"api": {"nextLine()": [[56, 65]]}}}, {"text": "If you want a generic solution you can use a map, which maps from a key (in your case W, S, E.", "label": {"api": {"map": [[45, 47], [56, 58]]}}}, {"text": "When you do a get, you can take an argument key and simply retrieve the value of the key", "label": {"api": {"get": [[14, 16]]}}}, {"text": "This functionality does already exist in map, called put and get", "label": {"api": {"map": [[41, 43]], "put": [[53, 55]], "get": [[61, 63]]}}}, {"text": "Use PrintWriter instead", "label": {"api": {"PrintWriter": [[4, 14]]}}}, {"text": "You can use thread.interrupt() to interrupt the thread", "label": {"api": {"interrupt": [[19, 27], [34, 42]]}}}, {"text": "But as soon as I learned to use a Semaphore, I never looked back", "label": {"api": {"Semaphore": [[34, 42]]}}}, {"text": "Hopefully, the example below will give you some insight into the benefits of using a Semaphore", "label": {"api": {"Semaphore": [[85, 93]]}}}, {"text": "There is also a lot more useful stuff in the java.util.concurrent package that can be of great help", "label": {"api": {"java.util.concurrent": [[45, 64]]}}}, {"text": "It uses String.indexOf(String, int), keeps track of the current index, and increments the occurance-count", "label": {"api": {"String.indexOf(String, int)": [[8, 34]]}}}, {"text": "Decorate your LinkedList using Collections#synchronizedList instead", "label": {"api": {"Collections#synchronizedList": [[31, 58]]}}}, {"text": "A Set would provide that function", "label": {"api": {"Set": [[2, 4]]}}}, {"text": "I am opening the file as an input stream and then reading all of its contents into a BufferReader (http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html": [[99, 166]]}}}, {"text": "I don't think you can turn this into a Stream without writing your own Spliterator, but, I don't know why you would want to", "label": {"api": {"Spliterator": [[71, 81]]}}}, {"text": "What about Pattern.splitAsStream", "label": {"api": {"Pattern.splitAsStream": [[11, 31]]}}}, {"text": "Foo should be annotated with @XmlRootElement if you are using Jettison", "label": {"api": {"@XmlRootElement": [[29, 43]]}}}, {"text": "The Collection and Collections APIs are incredibly rich in Java 8, and in most cases you'd be better off using a vanilla Collection subclass instead of building your own Stream interface", "label": {"api": {"Collection": [[4, 13], [19, 28], [121, 130]], "Collections": [[19, 29]]}}}, {"text": "You cannot directly know when the thread is stopped, the closest thing you have is Thread#isAlive method but it may return false when the run method in the thread has finished but the thread may not be stopped since the JVM cannot guarantee it", "label": {"api": {"Thread": [[83, 88]]}}}, {"text": "But if your DispatcherThread class implements Runnable interface then you can write the clean up at the bottom of the run method", "label": {"api": {"Thread": [[22, 27]]}}}, {"text": "By the way, Thread suffix is not a good name for a class that technically is not a thread (because it doesn't extend from Thread)", "label": {"api": {"Thread": [[12, 17], [122, 127]]}}}, {"text": "Just use String#toCharArray", "label": {"api": {"String#toCharArray": [[9, 26]]}}}, {"text": "For JPA's OneToMany, by default no operations are Cascaded", "label": {"api": {"Cascaded": [[50, 57]]}}}, {"text": "To translate a character to it's proper number, you can use a map, where the key is a character, and the value is the digit (in string form) that it represents", "label": {"api": {"map": [[62, 64]]}}}, {"text": "use the Array.sort method on your array, and then use the indexes", "label": {"api": {"the Array.sort": [[4, 17]]}}}, {"text": "I am trying to override PutAll in order to loop through the  pairs and call put on them, since I am using a custom HashMap object", "label": {"api": {"HashMap": [[115, 121]]}}}, {"text": "Use indexOf(String str, int fromIndex)) in a loop", "label": {"api": {"indexOf(String str, int fromIndex))": [[4, 38]]}}}, {"text": "The fastest-possible way to find substrings in Java is to use String.indexOf()", "label": {"api": {"String.indexOf()": [[62, 77]]}}}, {"text": "For extra speed, ditch the regex and work with the Character class, checking a combination of the many properties it provides (like isAlphabetic, etc.) for before and after", "label": {"api": {"Character class": [[51, 65]]}}}, {"text": "Have a look at the patterns here for more info", "label": {"api": {"patterns here": [[19, 31]]}}}, {"text": "Read about nextInt and nextLine in the Java docs", "label": {"api": {"the Java docs": [[35, 47]]}}}, {"text": "See the Stream usage page in the Java 8 javadoc and look for \"methods..", "label": {"api": {"Stream usage page": [[8, 24]]}}}, {"text": "If you want to draw independently of the presentation / rendering, you can draw on a BufferedImage for example", "label": {"api": {"BufferedImage": [[85, 97]]}}}, {"text": "You can acquire a Graphics object associated with the BufferedImage with its getGraphics() and createGraphics() methods", "label": {"api": {"BufferedImage": [[54, 66]]}}}, {"text": "If you have Java 7 can use FileSystem.getPathMatcher", "label": {"api": {"FileSystem.getPathMatcher": [[27, 51]]}}}, {"text": "FileSystem#getPathMatcher(String) is an abstract method, you cannot use it directly", "label": {"api": {"FileSystem#getPathMatcher(String)": [[0, 32]]}}}, {"text": "The invalidate method does the following (from API)", "label": {"api": {"API": [[47, 49]]}}}, {"text": "java.util.Map is an interface, not a class, and can not be instantiated with new", "label": {"api": {"java.util.Map": [[0, 12]]}}}, {"text": "You can see how semaphores work in Wikipedia and the class in Java in the oracle documentation", "label": {"api": {"the oracle documentation": [[70, 93]]}}}, {"text": "From the ComponentEvent you can get the Component being resized", "label": {"api": {"get the Component": [[32, 48]]}}}, {"text": "You can refer to the documentation here", "label": {"api": {"documentation here": [[21, 38]]}}}, {"text": "So, Java is breaking up your command into parts", "label": {"api": {"Java is breaking up your command into parts": [[4, 46]]}}}, {"text": "Maybe you could use a HttpServlet", "label": {"api": {"HttpServlet": [[22, 32]]}}}, {"text": "Have you looked into File#mkdirs", "label": {"api": {"File#mkdirs": [[21, 31]]}}}, {"text": "DocumentBuilderFactory should be namespace aware", "label": {"api": {"be namespace aware": [[30, 47]]}}}, {"text": "You probably want to load it from a file", "label": {"api": {"load it from a file": [[21, 39]]}}}, {"text": "What is returned in getPixels()", "label": {"api": {"getPixels()": [[20, 30]]}}}, {"text": "See the Formatter class docs to learn more about how to format output in Java", "label": {"api": {"Formatter": [[8, 16]]}}}, {"text": "Use a ThreadPoolExecutor with a SynchronousQueue (copied from this answer)", "label": {"api": {"ThreadPoolExecutor": [[6, 23]], "SynchronousQueue": [[32, 47]]}}}, {"text": "This can be an ArrayList or any other data structure that preserves order", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "Based on the documentation for Semaphor, this should be achievable using only acquire() and release() around the critical section", "label": {"api": {"Semaphor": [[31, 38]]}}}, {"text": "Also, you should be able to put the semaphor in the current class, no need for a separate class to contain the Semaphor", "label": {"api": {"Semaphor": [[111, 118]]}}}, {"text": "If we read the documentation of the Exception, it states (bold emphasis of mine)", "label": {"api": {"documentation of the Exception": [[15, 44]]}}}, {"text": "You can create a comparator that compares values that are Comparable", "label": {"api": {"Comparable": [[58, 67]]}}}, {"text": "You can sort the arrays in place using java.util.Arrays utility class", "label": {"api": {"java.util.Arrays": [[39, 54]]}}}, {"text": "If you don't set the compliance as shown above, you will get an UnsupportedClassVersionError", "label": {"api": {"UnsupportedClassVersionError": [[64, 91]]}}}, {"text": "The minimum change is to use setTimeInMillis using System.currentTimeMillis rather than setTime", "label": {"api": {"setTimeInMillis": [[29, 43]], "System.currentTimeMillis": [[51, 74]]}}}, {"text": "So, this is not meant to be a simple sleep, since other components are running in the meanwhile", "label": {"api": {"sleep": [[37, 41]]}}}, {"text": "That being the case, this thread should sleep — either for a period of time, or until it's woken up by something else", "label": {"api": {"sleep": [[40, 44]]}}}, {"text": "So it should be possible to get the difference (in milliseconds, via getTimeInMillis) between stop and now, and sleep rather than busy-waiting", "label": {"api": {"getTimeInMillis": [[69, 83]], "sleep": [[112, 116]]}}}, {"text": "You can use a static AtomicInteger, like this", "label": {"api": {"AtomicInteger": [[21, 33]]}}}, {"text": "An easy way to calculate the number of digits of a decimal number is to use the log base 10", "label": {"api": {"log base 10": [[80, 90]]}}}, {"text": "From the Integer.valueOf javadocs", "label": {"api": {"Integer.valueOf javadocs": [[9, 32]]}}}, {"text": "If that isn't what you want, then you should use Thread.join() on the other thread", "label": {"api": {"Thread.join()": [[49, 61]]}}}, {"text": "The only place where you can set the initial capacity of an ArrayList is when creating the specific instance using ArrayList(int)", "label": {"api": {"ArrayList(int)": [[115, 128]]}}}, {"text": "One of the possible solutions would be to re-design your data access layer and use ResultSet (http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html), which is available in any Java platform that I can think of", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html": [[94, 157]]}}}, {"text": "The invoke method takes two parameters", "label": {"api": {"invoke method": [[4, 16]]}}}, {"text": "PriorityQueue has a constructor that supports overriding its default Comparator", "label": {"api": {"that supports overriding its default Comparator": [[32, 78]]}}}, {"text": "Use the Deque interface", "label": {"api": {"Deque interface": [[8, 22]]}}}, {"text": "For this specific use case, it should be sufficient to just maintain an Iterator or an index into the collection and reference this object each time the function is called", "label": {"api": {"Iterator": [[72, 79]]}}}, {"text": "This can be achieved most easily with StringBuilder", "label": {"api": {"StringBuilder": [[38, 50]]}}}, {"text": "This is why, if you look at APIs like java.util.Arrays, you'll see a lot of methods that are repeated for byte[], char[], double[], float[], int[], long[], short[], and Object[]", "label": {"api": {"java.util.Arrays": [[38, 53]]}}}, {"text": "I take it that sendTokenSock is a java.net.DatagramSocket", "label": {"api": {"java.net.DatagramSocket": [[34, 56]]}}}, {"text": "sendTokenSock.setSoTimeout(0); will set an infinite timeout as setSoTimeout documentation for Java SE 7 explains", "label": {"api": {"setSoTimeout documentation for Java SE 7": [[63, 102]]}}}, {"text": "See the relevant section of JPQL reference", "label": {"api": {"JPQL reference": [[28, 41]]}}}, {"text": "As far as I am aware this class is not marked as @javax.persistence.Entity but does implement Serializable but as it stands I cannot directly persist this class", "label": {"api": {"@javax.persistence.Entity": [[49, 73]]}}}, {"text": "In the IDE, getResource() will return the following two forms of absolute path (get from java 1.7 API) and you get the image", "label": {"api": {"getResource": [[12, 22]]}}}, {"text": "Also you may find the Java Compiler API quite helpful", "label": {"api": {"the Java Compiler API": [[18, 38]]}}}, {"text": "If the cached thread pool does not start hundreds of threads (see getLargestPoolSize), then by all means, use the cached thread pool", "label": {"api": {"getLargestPoolSize": [[66, 83]]}}}, {"text": "do you use an unbounded task queue or a bounded task queue with a CallerRunsPolicy for example", "label": {"api": {"CallerRunsPolicy": [[66, 81]]}}}, {"text": "there is also the ForkJoinPool which is suitable for tasks that start sub-tasks", "label": {"api": {"ForkJoinPool": [[18, 29]]}}}, {"text": "Consider DateFormat class to convert string to a java.util.Date instance", "label": {"api": {"DateFormat": [[9, 18]]}}}, {"text": "java.sql.Timestamp can be constructed with long date representation, which can be get from java.util.Date class instance via getTime() method", "label": {"api": {"java.sql.Timestamp": [[0, 17]]}}}, {"text": "Runtime.exec will not launch the command through a shell, whereas this is required as you use a pipe", "label": {"api": {"Runtime.exec": [[0, 11]]}}}, {"text": "I you need to wait for completion before continuing execution, use Process.waitFor", "label": {"api": {"Process.waitFor": [[67, 81]]}}}, {"text": "One possibility would be to pass Function<String, ?> objects to addOption, e.g.", "label": {"api": {"Function<String, ?>": [[33, 51]]}}}, {"text": "String#split() method returns String[]", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "To get the enum values from a Class object, you can use Class.getEnumConstants()", "label": {"api": {"Class.getEnumConstants()": [[56, 79]]}}}, {"text": "javax.ws.rs.Consumes annotation is probably what you need", "label": {"api": {"javax.ws.rs.Consumes": [[0, 19]]}}}, {"text": "Actually, it is nowadays obsolete; you should use Map instead", "label": {"api": {"obsolete": [[25, 32]], "Map": [[50, 52]]}}}, {"text": "If you use Map, you will have to change your other code also", "label": {"api": {"Map": [[11, 13]]}}}, {"text": "But, in your situation, the best choice, I think, is CardLayout", "label": {"api": {"CardLayout": [[53, 62]]}}}, {"text": "There is an official example for CardLayout", "label": {"api": {"CardLayout": [[33, 42]]}}}, {"text": "When you need both huge numbers and arithmetics which are precise to the last digit, you should use the classes BigInteger or BigDecimal (depending on whether or not you want decimal places)", "label": {"api": {"BigInteger": [[112, 121]], "BigDecimal": [[126, 135]]}}}, {"text": "That's why we have the Comparator interface", "label": {"api": {"Comparator": [[23, 32]]}}}, {"text": "Instead of embedding the comparison criteria in the class, you can write a Comparator to make the relevant comparison for any given situation", "label": {"api": {"Comparator": [[75, 84]]}}}, {"text": "Use the DatagramSocket constructor which takes the local inet address to bind to", "label": {"api": {"constructor": [[23, 33]]}}}, {"text": "You could use the Java 8 Streams methods for iterating over the elements of a Collection", "label": {"api": {"Streams": [[25, 31]]}}}, {"text": "For example - Stream forEach", "label": {"api": {"Stream forEach": [[14, 27]]}}}, {"text": "Or you can do it without a Stream", "label": {"api": {"without a Stream": [[17, 32]]}}}, {"text": "Swing provides this loop for you by continually executing Runnable blocks of code that have been posted to the EventQueue", "label": {"api": {"EventQueue": [[111, 120]]}}}, {"text": "Don't reinitialize Random on every invocation and you could use SecureRandom if you want more \"secure\" randomness", "label": {"api": {"SecureRandom": [[64, 75]]}}}, {"text": "Click for the documentation of the ScheduledExecutorService", "label": {"api": {"Click for the documentation of the ScheduledExecutorService": [[0, 58]]}}}, {"text": "Best practice is to use a java.lang.Timer (not a javax.swing.Timer) to run the task", "label": {"api": {"java.lang.Timer": [[26, 40]]}}}, {"text": "getTime() and setTime(long) could help you convert between Date object and a timestamp", "label": {"api": {"getTime()": [[0, 8]], "setTime(long)": [[14, 26]], "Date": [[59, 62]]}}}, {"text": "That's basically the third example in the API documentation for java.util.stream.Collectors", "label": {"api": {"java.util.stream.Collectors": [[64, 90]]}}}, {"text": "From the Java docs", "label": {"api": {"the Java docs": [[5, 17]]}}}, {"text": "Operations on that map are not synchronized (if they aren't backed by a synchronized implementation of a map)", "label": {"api": {"synchronized implementation": [[72, 98]]}}}, {"text": "A pretty straight-forward way to do this would be with a Socket (PHP) that connects to another Socket (Java \"ServerSocket\")", "label": {"api": {"Socket (Java \"ServerSocket\")": [[95, 122]]}}}, {"text": "See ActionListener.actionPerformed for the javadoc", "label": {"api": {"ActionListener.actionPerformed": [[4, 33]]}}}, {"text": ".put() returns the previous value associated with key, or null if there was no mapping for key", "label": {"api": {".put()": [[0, 5]]}}}, {"text": "You may want to add a context listner so that you get notifyed about the start of the web application and where you can start your thread", "label": {"api": {"context listner": [[22, 36]]}}}, {"text": "If you are using Java-8, you can use the method ConcurrentHashMap::merge instead of reading and updating the value in two steps", "label": {"api": {"ConcurrentHashMap::merge": [[48, 71]]}}}, {"text": "You can also use InetAddress.isReachable() which tries multiple methods to test if the host specifiied by InetAddress is reachable", "label": {"api": {"InetAddress.isReachable()": [[17, 41]]}}}, {"text": "Considering the definition of new Socket(String, int), this could establish a server presence on any arbitrary port (e.g", "label": {"api": {"new Socket(String, int)": [[30, 52]]}}}, {"text": "On most platforms, the default logical font family specified by each component's UI delegate has the required glyphs for supported locales", "label": {"api": {"font family": [[39, 49]]}}}, {"text": "No need to use regexes here, like replaceFirst() does", "label": {"api": {"replaceFirst()": [[34, 47]]}}}, {"text": "Use replace() instead", "label": {"api": {"replace()": [[4, 12]]}}}, {"text": "A SimpleDateFormat can't format a GregorianCalendar; it can format a Date, so convert it to a Date first", "label": {"api": {"SimpleDateFormat": [[2, 17]]}}}, {"text": "Why is the non-validating DocumentBuilder in the SSCCE below trying to read the DTD file", "label": {"api": {"DocumentBuilder": [[26, 40]]}}}, {"text": "You are trying to read/write strings using ObjectInputStream and ObjectOutputStream", "label": {"api": {"ObjectInputStream": [[43, 59]], "ObjectOutputStream": [[65, 82]]}}}, {"text": "If you want to be able to use a telnet client, consider using BufferedReader#readLine and BufferedWriter for reading/writing strings", "label": {"api": {"BufferedReader#readLine": [[62, 84]], "BufferedWriter": [[90, 103]]}}}, {"text": "At the ImageReader class itself you have a handy method named 'isRandomAccessEasy' that will return true if the storage format of the given image places no inherent impediment on random access to pixels (verbatim from official docs)", "label": {"api": {"official docs": [[218, 230]]}}}, {"text": "An instance of java.awt.TexturePaint provides a convenient way to tile a BufferedImage", "label": {"api": {"java.awt.TexturePaint": [[15, 35]]}}}, {"text": "You could also just use Java URLs, which is more barebones", "label": {"api": {"Java URLs": [[24, 32]]}}}, {"text": "you could make Person implement Comparable<Person> to define the \"natural\" sort order of Person instances", "label": {"api": {"Comparable<Person>": [[32, 49]]}}}, {"text": "You can then pass your ArrayList to Collections.sort() and sort it", "label": {"api": {"Collections.sort()": [[36, 53]]}}}, {"text": "In that case, you can use the overload of Collections.sort() that takes a Comparator", "label": {"api": {"Collections.sort()": [[42, 59]], "overload": [[30, 37]], "Comparator": [[74, 83]]}}}, {"text": "You will need to define a class that implements Comparator<Person> and pass an instance of that class into Collections.sort()", "label": {"api": {"Collections.sort()": [[107, 124]], "Comparator": [[48, 57]]}}}, {"text": "Make sure your class Person implements Comparable", "label": {"api": {"Comparable": [[39, 48]]}}}, {"text": "When reading the javadoc for SimpleDateFormat and looking at your provided timestamp I notice you are also providing milliseconds", "label": {"api": {"SimpleDateFormat": [[29, 44]]}}}, {"text": "Or you can use Callable interface provided with Java to return value from a thread", "label": {"api": {"Callable": [[15, 22]]}}}, {"text": "Use the Desktop API with the URI constructor that will quote legal characters", "label": {"api": {"Desktop": [[8, 14]], "URI": [[29, 31]]}}}, {"text": "The only limitation is that there is an upper limit to the length of the URI that the O/S can handle", "label": {"api": {"URI": [[73, 75]]}}}, {"text": "After some (re)searching, I believe the scheduleWithFixedDelay method of ScheduledExecutorService implements exactly this", "label": {"api": {"scheduleWithFixedDelay": [[40, 61]], "ScheduledExecutorService": [[73, 96]]}}}, {"text": "Or, if your program is interactive, use getOutputStream() to get an output stream to which write the password", "label": {"api": {"getOutputStream()": [[40, 56]]}}}, {"text": "No, as you can see in the Javadocs, @Override has SOURCE retention and only works as a compile time safeguard", "label": {"api": {"see in the Javadocs": [[15, 33]], "SOURCE": [[50, 55]]}}}, {"text": "Use the Vector.size method", "label": {"api": {"Vector.size": [[8, 18]]}}}, {"text": "Java's BitSet is in memory and it has no compression in it", "label": {"api": {"BitSet": [[7, 12]]}}}, {"text": "I have also looked at JavaEWAH, which is a variant of the Java BitSet class, using run-length encoding (RLE) compression", "label": {"api": {"BitSet": [[63, 68]]}}}, {"text": "I've tried to send some unicode string in a foreign language to the SOAPMessage.writeTo() but it didn't escape it", "label": {"api": {"SOAPMessage.writeTo()": [[68, 88]]}}}, {"text": "You cannot, by default, read a TIFF file into a buffered image using ImageIO", "label": {"api": {"ImageIO": [[69, 75]]}}}, {"text": "Calling ImageIO.getReaderFileSuffixes() will return an array of the supported file formats which should at least include JPEG, PNG, BMP, WBMP and GIF", "label": {"api": {"ImageIO": [[8, 14]]}}}, {"text": "For example, http://docs.oracle.com/javase/7/docs/api/java/util/Map.html#get(java.lang.Object) will return null, when no entry with specified key is in the map", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Map.html#get(java.lang.Object)": [[13, 93]]}}}, {"text": "Note that your findUserByName method is basically reinventing the Map.get method, which returns null if the specified key isn't found", "label": {"api": {"Map.get": [[66, 72]]}}}, {"text": "Class#getResource treats the path you pass to it as relative to the class's package, so in your case it is looking for src\\main\\resources\\view\\img\\plus.png", "label": {"api": {"Class#getResource": [[0, 16]]}}}, {"text": "Try using a concurrent implementation of a Stack such as ConcurrentLinkedDeque which implements the Deque interface", "label": {"api": {"ConcurrentLinkedDeque": [[57, 77]], "Deque": [[73, 77], [100, 104]]}}}, {"text": "This interface [Deque] should be used in preference to the legacy Stack class", "label": {"api": {"Deque": [[16, 20]]}}}, {"text": "Maybe you can use Container#setFocusTraversalKeys(...) method", "label": {"api": {"Container#setFocusTraversalKeys(...)": [[18, 53]]}}}, {"text": "You should first call ResultSet#next before attempting to retrieve any data", "label": {"api": {"ResultSet#next": [[22, 35]]}}}, {"text": "You are correct in that the TableView control does not have a String setter method that directly manipulates the text shown when the table is empty", "label": {"api": {"TableView": [[28, 36]]}}}, {"text": "What you will want to do instead is use the TableView's placeholder property which can be set to any object of type Node", "label": {"api": {"TableView": [[44, 52]], "placeholder property": [[56, 75]], "Node": [[116, 119]]}}}, {"text": "The argument of Math.tan() has to be in radians", "label": {"api": {"Math.tan()": [[16, 25]]}}}, {"text": "Why not simply use Date#compareTo() for the comparison since java.util.Date implements the Comparable interface", "label": {"api": {"Date#compareTo()": [[19, 34]]}}}, {"text": "JavaDoc to WebTarget.queryParam() should give you an answer to your problem", "label": {"api": {"WebTarget.queryParam()": [[11, 32]]}}}, {"text": "From the documentation of HashSet", "label": {"api": {"documentation of HashSet": [[9, 32]]}}}, {"text": "Either way, your URL object has this information and you can inquire about it with its getPort() method", "label": {"api": {"getPort()": [[87, 95]]}}}, {"text": "I suggest using the Java Reflection API, more specifically the Class.getSuperClass() method", "label": {"api": {"Class.getSuperClass()": [[63, 83]]}}}, {"text": "split expects a regular expression, and since | is a special character in regular expressions, you have to escape it", "label": {"api": {"split": [[0, 4]]}}}, {"text": "Have a look at BlockingQueue classes and producer/consumer patterns", "label": {"api": {"BlockingQueue": [[15, 27]]}}}, {"text": "You can use Java's BlockingQueue", "label": {"api": {"BlockingQueue": [[19, 31]]}}}, {"text": "It can still grow past that limit, as per the JavaDocs at  http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ArrayList(int)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html#ArrayList(int)": [[59, 138]]}}}, {"text": "Perhaps you should read API documentation for ArrayList first", "label": {"api": {"API documentation for ArrayList": [[24, 54]]}}}, {"text": "Calling get() on the task in setOnSucceeded will be safe as, by the time the succeeded callback is invoked, the task has already completed, so it won't block at all and shouldn't show any exceptions at that time", "label": {"api": {"get()": [[8, 12]]}}}, {"text": "I think calling getValue() is preferred though as its semantics seem simpler", "label": {"api": {"getValue()": [[16, 25]]}}}, {"text": "Long.parseLong(s, radix) has an overridden implementation that also allows you to specify a radix, e.g", "label": {"api": {"Long.parseLong(s, radix)": [[0, 23]]}}}, {"text": "In contrast, the Long.decode(s) allows you to specify a decodable string", "label": {"api": {"Long.decode(s)": [[17, 30]]}}}, {"text": "Polymorphism, using Object, Object overrides a raw-type in Comparator", "label": {"api": {"Comparator": [[59, 68]]}}}, {"text": "It uses String.indexOf(String, int) to iterate through the string without creating any new objects (beyond the index and counter)", "label": {"api": {"String.indexOf(String, int)": [[8, 34]]}}}, {"text": "If you are really wanting a regex solution, you could try something like the following, which uses a case insensitive pattern to match each keyword", "label": {"api": {"case insensitive": [[101, 116]]}}}, {"text": "There is a wrapper class Float (note the capital) that can be null", "label": {"api": {"Float": [[25, 29]]}}}, {"text": "Also NaN is a member of Float not of float", "label": {"api": {"Float": [[24, 28]], "NaN": [[5, 7]]}}}, {"text": "Have a look at the documentation of Float", "label": {"api": {"Float": [[36, 40]], "documentation of Float": [[19, 40]]}}}, {"text": "Java EE 7 supports cron jobs through the @Schedule annotation", "label": {"api": {"@Schedule": [[41, 49]]}}}, {"text": "Instead, you might consider redirecting System.out to a separate stream using System.setOut, System.setErr and print the captured data just before exiting the program", "label": {"api": {"System.setOut": [[78, 90]]}}}, {"text": "you should use overloaded List#toArray(T[]) method", "label": {"api": {"List#toArray(T[])": [[26, 42]]}}}, {"text": "Also note that the parameter is milliseconds, not seconds", "label": {"api": {"parameter is milliseconds, not seconds": [[19, 56]]}}}, {"text": "The items could be an enum and then use something like an EnumSet to keep track of what you have in your inventory", "label": {"api": {"EnumSet": [[58, 64]], "Set": [[62, 64]]}}}, {"text": "Or an List of Strings (ArrayList or LinkedList), or Set of Strings (HashSet, TreeSet)", "label": {"api": {"List": [[6, 9], [28, 31], [42, 45]], "Set": [[52, 54], [72, 74], [81, 83]]}}}, {"text": "This has nothing to do with Selenium, this is purely a Java String manipulation problem", "label": {"api": {"Java String": [[55, 65]]}}}, {"text": "You can convert String to int with Integer.parseInt(String), and you can convert int to String with String.valueOf(int)", "label": {"api": {"Integer.parseInt(String)": [[35, 58]], "String.valueOf(int)": [[100, 118]]}}}, {"text": "You can get value in a string and parse value using ParseInt function", "label": {"api": {"ParseInt": [[52, 59]]}}}, {"text": "Should call the flush() of FileOutputStream before close of stream", "label": {"api": {"flush()": [[16, 22]]}}}, {"text": "From Java docs for ArrayList", "label": {"api": {"Java docs for ArrayList": [[5, 27]]}}}, {"text": "I was wondering if there are any good Java libraries for manipulating netmasks, subnets, etc", "label": {"api": {"net": [[70, 72], [83, 85]]}}}, {"text": "As far as I can tell, Java's net package and Guava's net package don't include these capabilities", "label": {"api": {"net": [[29, 31], [53, 55]]}}}, {"text": "In Python, I've been using netaddr and I've been wondering if there's anything similarly powerful in Java", "label": {"api": {"net": [[27, 29]]}}}, {"text": "That is indicated by the exception http://docs.oracle.com/javase/7/docs/api/java/lang/ArrayIndexOutOfBoundsException.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/ArrayIndexOutOfBoundsException.html": [[35, 120]]}}}, {"text": "It seems you'd want to use a CountDownLatch, not a CyclicBarrier here", "label": {"api": {"CountDownLatch": [[29, 42]]}}}, {"text": "The Long.parseLong(String s, int radix) documentation says", "label": {"api": {"Long.parseLong(String s, int radix)": [[4, 38]]}}}, {"text": "As you can see in the Javadoc of ObservableSet, there is no such method", "label": {"api": {"ObservableSet": [[33, 45]]}}}, {"text": "In fact, the method ObservableList::setAll is just a convenient \"shortcut\"", "label": {"api": {"ObservableList::setAll": [[20, 41]]}}}, {"text": "The common implementation ModifiableObservableListBase in JavaFX does a clear then an addAll", "label": {"api": {"ModifiableObservableListBase": [[26, 53]]}}}, {"text": "The main advantage of having a setAll shortcut is that only one \"big\" change event (ListChangeListener.Change) is sent to the listeners", "label": {"api": {"change event (ListChangeListener.Change)": [[70, 109]]}}}, {"text": "In fact, you might want to extend com.sun.javafx.collections.ObservableSetWrapper with your own setAll but there will be no performance benefit since the event SetChangeListener.Change is an elementary change", "label": {"api": {"ObservableSet": [[61, 73]], "SetChangeListener.Change": [[160, 183]]}}}, {"text": "Note that findFirst() will return an Optional object, and get() will throw an exception if there is no such element", "label": {"api": {"Optional": [[37, 44]]}}}, {"text": "Quote from How to Use the Focus Subsystem (The Java™ Tutorials > Creating a GUI With JFC/Swing > Using Other Swing Features) (suggested by @alex2410(link to @camickr post) and @mKorbel)", "label": {"api": {"Focus Subsystem": [[26, 40]]}}}, {"text": "If you want more details, see the specification for the Focus Subsystem", "label": {"api": {"Focus Subsystem": [[56, 70]]}}}, {"text": "I believe you are looking for int Integer.sum(int, int) and similar methods, which are indeed provided by the API", "label": {"api": {"int Integer.sum(int, int)": [[30, 54]]}}}, {"text": "If you want to know what method's you could call to perform standard operator functions, you can do a instanceof check to the comparable interface for the greater/less than or equals operators(http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html": [[193, 258]]}}}, {"text": "try String.replace function that replace any sequence character", "label": {"api": {"String.replace": [[4, 17]]}}}, {"text": "Instead of hard-coding an absolute path, you can use relative paths or use a JFileChooser in Swing to open a file chooser that will let the user select a file for input and/or for output", "label": {"api": {"JFileChooser": [[77, 88]]}}}, {"text": "Your interface is pretty similar to Comparable, (Are you sure Comparable isn't what your looking for?) so maybe you should add a generic to it", "label": {"api": {"Comparable": [[36, 45], [62, 71]]}}}, {"text": "You can use a TreeSet", "label": {"api": {"TreeSet": [[14, 20]]}}}, {"text": "If you want to preserve iteration order, use a LinkedHashMap instead", "label": {"api": {"LinkedHashMap": [[47, 59]]}}}, {"text": "Another idea, depending on where and how you use this, would be Double.parseDouble() and catch the NumberFormatException", "label": {"api": {"Double.parseDouble()": [[64, 83]], "NumberFormatException": [[99, 119]]}}}, {"text": "But you can use the String#matches(String) function to test if a string matches a given pattern", "label": {"api": {"String#matches(String)": [[20, 41]]}}}, {"text": "Alternatively, you can use a FromTerm", "label": {"api": {"FromTerm": [[29, 36]]}}}, {"text": "the function replace return a String", "label": {"api": {"replace": [[13, 19]]}}}, {"text": "The rules for searching are explained in the javadoc of ClassLoader#getResource(String) and the javadoc of Class#getResource(String)", "label": {"api": {"ClassLoader#getResource(String)": [[56, 86]], "Class#getResource(String)": [[107, 131]]}}}, {"text": "Per the KeyEventDispatcher API", "label": {"api": {"KeyEventDispatcher API": [[8, 29]]}}}, {"text": "Technically, an Enum class is a constant class with more definitions, but an advantage to an Enum class is some pre-defined functions that you would have to define in your own constant class", "label": {"api": {"some pre-defined functions": [[107, 132]]}}}, {"text": "You can use String#replaceAll()", "label": {"api": {"String#replaceAll()": [[12, 30]]}}}, {"text": "You need the (?s) flag too (DOTALL mode) to make", "label": {"api": {"DOTALL": [[28, 33]]}}}, {"text": "While Vector is neither obsolete nor deprecated, it is a legacy of the original DefaultTableModel; later, it \"was retrofitted to implement the List interface.\"  Vector is synchronized, but using it correctly for this feature effectively relies on an implementation detail", "label": {"api": {"Vector": [[6, 11], [161, 166]], "List": [[143, 146]]}}}, {"text": "Instead, rely on the Memory Consistency Properties of classes whose methods provide a happens-before relation", "label": {"api": {"Memory Consistency Properties": [[21, 49]]}}}, {"text": "For example, SwingWorker, which implements Future<T> and RunnableFuture<T>, is particularly convenient for reliably updating a table's model on the event dispatch thread", "label": {"api": {"SwingWorker": [[13, 23]]}}}, {"text": "ConcurrentLinkedQueue) intended to simplify exactly this approach", "label": {"api": {"ConcurrentLinkedQueue": [[0, 20]]}}}, {"text": "System.out is a PrintStream and the documentation for PrintStream.printf links to the format stream syntax which has a table of all of the conversions", "label": {"api": {"System.out": [[0, 9]], "PrintStream": [[16, 26], [54, 64]], "PrintStream.printf": [[54, 71]], "format stream syntax": [[86, 105]]}}}, {"text": "You forget to close the BufferedWriter br, this is why the String is not getting written in the file", "label": {"api": {"close": [[14, 18]]}}}, {"text": "You can use a Proxy object to adapt any object at run time to make it appear as if it implements an interface", "label": {"api": {"Proxy": [[14, 18]]}}}, {"text": "Essentially, a Proxy object can be used to wrap an object by intercepting all method calls to the object and redirecting them dynamically", "label": {"api": {"Proxy": [[15, 19]]}}}, {"text": "ImageIO.read() takes InputStream as a parameter so there is no meaning of casting it to ImageInputStream", "label": {"api": {"ImageIO.read()": [[0, 13]], "ImageInputStream": [[88, 103]]}}}, {"text": "Secondly you can not cast an InputStreamReader object to ImageInputStream because ImageInputStream has nothing to do with InputStreamReader which you thought of", "label": {"api": {"ImageInputStream": [[57, 72], [82, 97]]}}}, {"text": "Moreover getResourceAsStream() returns InputStream", "label": {"api": {"getResourceAsStream()": [[9, 29]]}}}, {"text": "The ImageIO class has a utility method to read an InputStream and create a BufferedImage", "label": {"api": {"read": [[42, 45]], "create": [[66, 71]]}}}, {"text": "There is also a utility method to create an ImageInputStream from an InputStream", "label": {"api": {"create": [[34, 39]]}}}, {"text": "But you can also get ALL fields using the http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getDeclaredFields() method to receive an Array of its fields", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getDeclaredFields()": [[42, 122]]}}}, {"text": "What you are looking for is a Map", "label": {"api": {"Map": [[30, 32]]}}}, {"text": "The concat method is more like + than +=", "label": {"api": {"concat method": [[4, 16]]}}}, {"text": "You could call setRolloverIcon with the result of getIcon", "label": {"api": {"setRolloverIcon": [[15, 29]], "getIcon": [[50, 56]]}}}, {"text": "Class PrintStream (which is what System.out is) has a dedicated method overload println(char[]) which prints the characters of a char array", "label": {"api": {"println(char[])": [[80, 94]]}}}, {"text": "It has no special overloads for other arrays, so when you pass an int[] the called method is println(Object)", "label": {"api": {"println(Object)": [[93, 107]]}}}, {"text": "The toString() method for all arrays is simply the default one inherited from class Object, which displays their class name and default hashcode, which is why it's not so informative", "label": {"api": {"from class Object": [[73, 89]]}}}, {"text": "You can use Arrays.toString(int[]) to get a string representation of your int array's contents", "label": {"api": {"Arrays.toString(int[])": [[12, 33]]}}}, {"text": "You can't instantiate a TreeNode with new because TreeNode is an interface", "label": {"api": {"interface": [[65, 73]]}}}, {"text": "where SomeClass is a class that implements the TreeNode interface", "label": {"api": {"interface": [[56, 64]]}}}, {"text": "Now, store your data in a HashSet", "label": {"api": {"HashSet": [[26, 32]]}}}, {"text": "Once an element is added, check if it already exists using the contains() method, and if it's not - add it to the set", "label": {"api": {"contains()": [[63, 72]]}}}, {"text": "Firstly, I would store the keys in a SortedMap", "label": {"api": {"SortedMap": [[37, 45]]}}}, {"text": "Then, use Random.nextInt(int) to pick a random key", "label": {"api": {"Random.nextInt(int)": [[10, 28]]}}}, {"text": "Then do SortedMap.subMap(int, int) to get the entry in the position you need", "label": {"api": {"SortedMap": [[8, 16]], "SortedMap.subMap(int, int)": [[8, 33]]}}}, {"text": "java.util.concurrent.ConcurrentHashMap has a putIfAbsent method that might help", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[0, 37]], "putIfAbsent": [[45, 55]]}}}, {"text": "There is an overhead to using putIfAbsent on the \"not absent\" execution path if the value to be set in the absent case has a significant construction cost, but if the construction cost is cheap or can be amortised over many calls then this might be useful", "label": {"api": {"putIfAbsent": [[30, 40]]}}}, {"text": "I think what you want is a JLabelJLabels display some text that is defined by you", "label": {"api": {"JLabel": [[27, 32], [33, 38]]}}}, {"text": "Check the response of the JFileChooser", "label": {"api": {"JFileChooser": [[26, 37]]}}}, {"text": "You can check for CANCEL_OPTION as well", "label": {"api": {"CANCEL_OPTION": [[18, 30]]}}}, {"text": "For information about using JFileChooser, see How to Use File Choosers, a section in The Java Tutorial", "label": {"api": {"JFileChooser": [[28, 39]]}}}, {"text": "Consider using a ReadWriteLock to guard access to your search map", "label": {"api": {"ReadWriteLock": [[17, 29]]}}}, {"text": "The default IIORegistry instance did report the category ImageReaderSpi when I made a call to ServiceRegistry.getCategories(), but when I attempt to acquire the image reader service provider interface in the code above, I receive a null reference", "label": {"api": {"ServiceRegistry.getCategories()": [[94, 124]]}}}, {"text": "This is likely a hint that I'm not going about this the right way, and my plan to query ImageReaderWriterSpi.getFormatNames() has been foiled", "label": {"api": {"ImageReaderWriterSpi.getFormatNames()": [[88, 124]]}}}, {"text": "Could you be looking for a BigInteger created from a byte[]", "label": {"api": {"created": [[38, 44]]}}}, {"text": "There are a couple methods in javax.sound.sampled.spi That I think would help", "label": {"api": {"javax.sound.sampled.spi": [[30, 52]]}}}, {"text": "The first is getAudioStream() in AudioFileReader", "label": {"api": {"getAudioStream()": [[13, 28]]}}}, {"text": "The one I see as most handy for your purpose is read() which returns the next byte in the stream", "label": {"api": {"read()": [[48, 53]]}}}, {"text": "See the reference for more info..", "label": {"api": {"the reference": [[4, 16]]}}}, {"text": "You can use a DataOutputStream to read different values", "label": {"api": {"DataOutputStream": [[14, 29]]}}}, {"text": "If you don't do this for educational reasons, I would recommend ZipOutputStream to create zip files", "label": {"api": {"ZipOutputStream": [[64, 78]]}}}, {"text": "The setBorder() API recommends that you add the border to the enclosing container", "label": {"api": {"setBorder()": [[4, 14]]}}}, {"text": "The JMenu class has methods that its API will show that allow you to easily get the JMenuItems", "label": {"api": {"its API": [[33, 39]]}}}, {"text": "Use JMenuBar#getMenu() and JMenu#getMenuComponent() methods to get the desired output", "label": {"api": {"JMenuBar#getMenu()": [[4, 21]], "JMenu#getMenuComponent()": [[27, 50]]}}}, {"text": "You cannot use getResourceAsStream on locations that are not within the JVM classpath", "label": {"api": {"getResourceAsStream": [[15, 33]]}}}, {"text": "Use ArrayList for dynamic array", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "For loading and saving text in/from a JTextComponent, see read(Reader,Object) & write(Writer)", "label": {"api": {"read(Reader,Object)": [[58, 76]], "write(Writer)": [[80, 92]]}}}, {"text": "For detecting changes to a JTextField add an action listener (that will typically fire when the user presses the enter key), or a DocumentListener", "label": {"api": {"add an action listener": [[38, 59]], "a DocumentListener": [[128, 145]]}}}, {"text": "The experienced behaviour might depend on the Java version and vendor that was used to run the application, because since the general contract of Object.hashcode() is violated, the result is implementation dependent", "label": {"api": {"Object.hashcode()": [[146, 162]]}}}, {"text": "So if you do not override Object.hashcode() it will be indeterministic if 2 different objects produce default hashcodes which may or may not determine the same bucket", "label": {"api": {"Object.hashcode()": [[26, 42]]}}}, {"text": "Read the javadoc of Object.hashcode() for the contract that you must not violate", "label": {"api": {"Object.hashcode()": [[20, 36]]}}}, {"text": "PriorityQueue is a generic class, thus your inherited class must also be generic, try this", "label": {"api": {"PriorityQueue": [[0, 12]]}}}, {"text": "FileReader does not support the mark operation", "label": {"api": {"FileReader": [[0, 9]], "Reader": [[4, 9]]}}}, {"text": "You can determine this by reading the JavaDoc linked and seeing it doesn't override it or markSupported() inherited from Reader", "label": {"api": {"Reader": [[121, 126]]}}}, {"text": "If you want a servlet, and no XML to map it, you simply need to use the WebServlet annotation of the standard servlet API", "label": {"api": {"WebServlet annotation": [[72, 92]]}}}, {"text": "Try with SimpleDateFormat class for parsing", "label": {"api": {"SimpleDateFormat": [[9, 24]]}}}, {"text": "BigInteger supports arbitrary precision (limited only by the amount of memory available to the JVM)", "label": {"api": {"supports arbitrary precision": [[11, 38]]}}}, {"text": "You should probably also use java.sql.Statement's query timeout", "label": {"api": {"java.sql.Statement's query timeout": [[29, 62]]}}}, {"text": "After hours of search I finally realized that java.sql.ResultSet is not Serializable neither there's a way to do that", "label": {"api": {"java.sql.ResultSet": [[46, 63]]}}}, {"text": "I tried to uses the implementations of RowSet like CachedRowSetImpl that are Serializable but they increase the response time, most probably because they iterate the ResultSet", "label": {"api": {"RowSet": [[39, 44], [57, 62]], "CachedRowSetImpl": [[51, 66]]}}}, {"text": "If you call http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#next() the ResultSet will get the data from the underlying (JDBC) connection to the database", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#next()": [[12, 82]]}}}, {"text": "The reason why you need to call the trailing getAsDouble() method is because the max() method returns an OptionalDouble, because Java needs a way of handling the possibility that the rain array may be empty", "label": {"api": {"OptionalDouble": [[105, 118]]}}}, {"text": "String.getBytes() in Java doesn't guarantee the character set used", "label": {"api": {"String.getBytes()": [[0, 16]]}}}, {"text": "Use String.getBytes(String) instead to always be sure that you get the encoding you want", "label": {"api": {"String.getBytes(String)": [[4, 26]]}}}, {"text": "Use your Server A as http REST endpoint, and use some http client library on Client B like Unirest, and ScheduledExecutorService with scheduleAtFixedRate method to fetch data every 10 seconds", "label": {"api": {"ScheduledExecutorService": [[104, 127]]}}}, {"text": "You can use String#matches(regex) method with .*?b.b.* regex pattern to match the text", "label": {"api": {"String#matches(regex)": [[12, 32]]}}}, {"text": "See the Javadocs for Cell for details", "label": {"api": {"Javadocs for Cell": [[8, 24]]}}}, {"text": "Of course, if you want to you can also use the internal DatatypeConverter.parseHexBinary() method, but it is in a rather unrelated XML package in javax", "label": {"api": {"DatatypeConverter.parseHexBinary()": [[56, 89]]}}}, {"text": "Simple way would be the Event class to have a source element much like the Swing event classes, ex http://docs.oracle.com/javase/7/docs/api/java/util/EventObject.html#getSource()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/EventObject.html#getSource()": [[99, 177]]}}}, {"text": "In the complete JavaFX CSS Reference Guide (http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html), there is clear documentation on every property I have seen so far EXCEPT -fx-base, and it seems that it isn't in the reference guide at all", "label": {"api": {"http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html": [[44, 120]]}}}, {"text": "-fx-base is a looked-up color - not really a property - defined in the default modena.css stylesheet", "label": {"api": {"looked-up color": [[14, 28]]}}}, {"text": "The default stylesheet uses looked-up colors extensively", "label": {"api": {"looked-up color": [[28, 42]]}}}, {"text": "To my knowledge, there's currently no official documentation on which looked-up colors are defined and how they are used", "label": {"api": {"looked-up color": [[70, 84]]}}}, {"text": "java.time.LocalDate is more appropriate", "label": {"api": {"java.time.LocalDate": [[0, 18]]}}}, {"text": "The following are from the HashSet manual (http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html": [[43, 105]]}}}, {"text": "See the java.util.stream package documentation in the section on \"Non-interference\"", "label": {"api": {"java.util.stream": [[8, 23]]}}}, {"text": "Using Thread.sleep is not inherently bad", "label": {"api": {"Thread.sleep": [[6, 17]]}}}, {"text": "Thread.sleep is bad when it is incorrectly used", "label": {"api": {"Thread.sleep": [[0, 11]]}}}, {"text": "The sleep time of Thread.sleep is not guaranteed", "label": {"api": {"Thread.sleep": [[18, 29]]}}}, {"text": "One of your options is to use getRealPath", "label": {"api": {"getRealPath": [[30, 40]]}}}, {"text": "If I encode a class with java.beans.XMLEncoder (Java 1.6) like the following", "label": {"api": {"java.beans.XMLEncoder": [[25, 45]]}}}, {"text": "You need to implement the Comparable interface and overwite the compareTo method", "label": {"api": {"Comparable": [[26, 35]], "compareTo": [[64, 72]]}}}, {"text": "You can use the Field#getType() method which will return you the Class<?> of the field", "label": {"api": {"Field#getType()": [[16, 30]]}}}, {"text": "You can just use a Map data structure and add level number as key and the number of stars as the value", "label": {"api": {"Map": [[19, 21]]}}}, {"text": "By implementing compareTo you define how instances can be naturally compared to each other", "label": {"api": {"naturally compared to each other": [[58, 89]]}}}, {"text": "When you want to return more than one result, you need to return an array (String[]) or a Collection like an ArrayList, for example", "label": {"api": {"ArrayList": [[109, 117]]}}}, {"text": "You should rather use ServletContext#getRealPath(...) to determine the file system path of your web application", "label": {"api": {"ServletContext#getRealPath(...)": [[22, 52]]}}}, {"text": "If you want to be sure, that the destination is a writable directory, and you just want to upload files into a temporary directory for processing, consider using the web application's private temp directory", "label": {"api": {"web application's private temp directory": [[166, 205]]}}}, {"text": "You can add a listener on the hover property of a node to switch lighting off by setting the node effect to null and to switch it on by setting the node effect to you lighting", "label": {"api": {"hover property": [[30, 43]]}}}, {"text": "There is example code in the JavaFX javadoc on Lighting, which I've just reproduced here", "label": {"api": {"javadoc on Lighting": [[36, 54]]}}}, {"text": "For an example of a class that has similar functionality look at the Collections class", "label": {"api": {"Collections": [[69, 79]]}}}, {"text": "Add JTextPane inside JScrollPane to fit as per its content", "label": {"api": {"JScrollPane": [[21, 31]]}}}, {"text": "Try the Integer.parseInt(java.lang.String) method", "label": {"api": {"Integer.parseInt(java.lang.String)": [[8, 41]]}}}, {"text": "When the session is destroyed, remove it from the map", "label": {"api": {"destroyed": [[20, 28]]}}}, {"text": "Now given a userId, you can retrieve the session from the map, and invalidate it", "label": {"api": {"invalidate": [[67, 76]]}}}, {"text": "The javadoc for NetworkInterface.getInetAddresses() says it's a Convenience method to return an Enumeration with all or a subset of the InetAddresses bound to this network interface", "label": {"api": {"javadoc for NetworkInterface.getInetAddresses()": [[4, 50]]}}}, {"text": "To find the method that takes a Calendar, then if you don't find a method with the exact Class match, catch the NoSuchMethodException and try again with the class's superclass, which you can get from the Class object with the getSuperclass() method, until you have failed to find the method even with Object", "label": {"api": {"getSuperclass() method": [[226, 247]]}}}, {"text": "Look at ObjectOutputStream and Serializable to get started", "label": {"api": {"ObjectOutputStream": [[8, 25]], "Serializable": [[31, 42]]}}}, {"text": "The Java Doc (http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html) says", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[14, 85]]}}}, {"text": "scanner.nextInt() reads only the int value, the '\\n' (the enter you press right after you type the int) is consumed in scanner.nextLine()", "label": {"api": {"scanner.nextInt()": [[0, 16]], "scanner.nextLine()": [[119, 136]]}}}, {"text": "To fix this add scanner.nextLine() right after scanner.nextInt() so it'll consume that '\\n'", "label": {"api": {"scanner.nextInt()": [[47, 63]], "scanner.nextLine()": [[16, 33]]}}}, {"text": "If you use a BufferedWriter, it does what its name suggests", "label": {"api": {"BufferedWriter": [[13, 26]]}}}, {"text": "Simply use an BufferedReader as it provides an readLine method", "label": {"api": {"BufferedReader": [[14, 27]]}}}, {"text": "In addition you could use org.xml.sax.Locator to identify the line number and throw an exception when you encounter line 800 to stop parsing", "label": {"api": {"org.xml.sax.Locator": [[26, 44]]}}}, {"text": "The JVM will automatically exit as soon as there are no more non-daemon threads running", "label": {"api": {"as soon as there are no more non-daemon threads running": [[32, 86]]}}}, {"text": "If you don't call setDaemon(true) before launching the thread, the JVM will automatically exit when your Thread is done", "label": {"api": {"setDaemon(true)": [[18, 32]]}}}, {"text": "You can parse the hex into a number using Long.valueOf()", "label": {"api": {"Long.valueOf()": [[42, 55]]}}}, {"text": "Average your two values (rounding as needed) and then going to back to hex using  Long.toString() padding out to two digits", "label": {"api": {"Long.toString()": [[82, 96]]}}}, {"text": "in your code, if cursor.getString(int num) returns null, then Integer.parseInt(String str) will throw NumberFormatException", "label": {"api": {"Integer.parseInt(String str)": [[62, 89]]}}}, {"text": "You can use a Supplier and constructor reference", "label": {"api": {"Supplier": [[14, 21]]}}}, {"text": "The Function type could be used for a one-argument constructor like Template1(File)", "label": {"api": {"Function": [[4, 11]]}}}, {"text": "The Java 8 API provides a number of standard functional interfaces in the java.util.function package though these typically don't extend beyond two arguments", "label": {"api": {"java.util.function": [[74, 91]]}}}, {"text": "You can see the explanation in the javadoc for subList()", "label": {"api": {"subList()": [[47, 55]]}}}, {"text": "More sophisticated solutions would involve classes from the java.util.concurrent.locks package", "label": {"api": {"java.util.concurrent.locks": [[60, 85]]}}}, {"text": "Only thing you can do is to register HttpUpgradeHandler (see HttpServletRequest#upgrade)and then implement WebSocket protocol on top of that", "label": {"api": {"HttpUpgradeHandler": [[37, 54]], "HttpServletRequest#upgrade": [[61, 86]]}}}, {"text": "I have used a method waitFor of Process class, to execute some UNIX command", "label": {"api": {"waitFor": [[21, 27]]}}}, {"text": "The command is executing successfully but it is returning 2, that according to convention means abnormal termination", "label": {"api": {"abnormal termination": [[96, 115]]}}}, {"text": "So I tried to find the source code for waitFor method, I came to know that it is a native method and defined in ProcessImpl class", "label": {"api": {"waitFor": [[39, 45]]}}}, {"text": "But I did not found the file that provide me the native implementation of waitFor method", "label": {"api": {"waitFor": [[74, 80]]}}}, {"text": "You might try the isWindowTranslucencySupported() function to see for yourself whether your system supports transparency", "label": {"api": {"isWindowTranslucencySupported()": [[18, 48]]}}}, {"text": "You can try using synchronizedList(List list), or if it's a good fit you could try using a CopyOnWriteArrayList", "label": {"api": {"synchronizedList(List list)": [[18, 44]], "CopyOnWriteArrayList": [[91, 110]]}}}, {"text": "It sounds like what you really want is a BlockingQueue", "label": {"api": {"BlockingQueue": [[41, 53]]}}}, {"text": "ArrayBlockingQueue is probably a good choice", "label": {"api": {"BlockingQueue": [[5, 17]], "ArrayBlockingQueue": [[0, 17]]}}}, {"text": "If you need an unbounded queue and don't care about extra memory utilization (relative to ArrayBlockingQueue), LinkedBlockingQueue also works", "label": {"api": {"BlockingQueue": [[95, 107], [117, 129]], "ArrayBlockingQueue": [[90, 107]], "LinkedBlockingQueue": [[111, 129]]}}}, {"text": "The behavior of those pushes and pops can differ (what happens when you try to push to a full queue, or pop from an empty one?), and the JavaDocs for the BlockingQueue interface have a table that shows all of these behaviors nicely", "label": {"api": {"BlockingQueue": [[154, 166]]}}}, {"text": "This is less efficient and takes more code than a BlockingQueue, though, so there's no reason to do it", "label": {"api": {"BlockingQueue": [[50, 62]]}}}, {"text": "This conflicts with the general requirement for streams for non-interference, and often in practice means that you will get a ConcurrentModificationException when using streams pipelines with containers that remove objects in the underlying container", "label": {"api": {"non-interference": [[60, 75]]}}}, {"text": "There may be optimizations to resequence the blocks while in the queue (perhaps with a PriorityBlockingQueue) but do it the simple way first", "label": {"api": {"PriorityBlockingQueue": [[87, 107]]}}}, {"text": "But to make the class available in your code, you still need to use ClassLoader#defineClass", "label": {"api": {"ClassLoader#defineClass": [[68, 90]]}}}, {"text": "They use the Instrumentation API to instrument the Container/Server class loaders, that way they can dynamically monitor and control the loading process", "label": {"api": {"Instrumentation API": [[13, 31]]}}}, {"text": "Java 7 introduced the MethodHandle class for dynamically executing a method of a given class", "label": {"api": {"MethodHandle": [[22, 33]]}}}, {"text": "Java's regex implementation does not require String objects - you are expected to pass a CharSequence", "label": {"api": {"CharSequence": [[89, 100]]}}}, {"text": "If you would rather not create a String from a char[] array, you could wrap an array in your own implementation of the CharSequence interface", "label": {"api": {"CharSequence": [[119, 130]]}}}, {"text": "You can use CharBuffer.wrap(char[]) to access the char array as a CharSequence", "label": {"api": {"CharBuffer.wrap(char[])": [[12, 34]]}}}, {"text": "This is documented in RowSetProvider.newFactory()", "label": {"api": {"RowSetProvider.newFactory()": [[22, 48]]}}}, {"text": "If there are multiple implementations on the classpath and you want to specify which implementation to load, then you can use newFactory(String factoryClassName, ClassLoader cl)", "label": {"api": {"newFactory(String factoryClassName, ClassLoader cl)": [[126, 176]]}}}, {"text": "You can use DecimalFormat", "label": {"api": {"DecimalFormat": [[12, 24]]}}}, {"text": "Have a look at String.format()", "label": {"api": {"String.format()": [[15, 29]]}}}, {"text": "The general idea is that you provide a format string and give the actual values", "label": {"api": {"format string": [[39, 51]]}}}, {"text": "In every iteration the Iterator procedes by 1 step", "label": {"api": {"Iterator": [[23, 30]]}}}, {"text": "The MemoryMXBean has all the memory data available", "label": {"api": {"MemoryMXBean": [[4, 15]]}}}, {"text": "The documentation for RandomAccessFile.writeBytes(String) says (emphasis added)", "label": {"api": {"RandomAccessFile.writeBytes(String)": [[22, 56]]}}}, {"text": "You could use Charset.encode(CharBuffer) to produce a ByteBuffer holding the encoded bytes, then write those bytes to the file", "label": {"api": {"Charset.encode(CharBuffer)": [[14, 39]]}}}, {"text": "Java provides a generic collection called IdentityHashMap<K,V>, which breaks Liskov substitution principle - the \"L\" in SOLID by intentionally violating Map<K,V>'s contract", "label": {"api": {"IdentityHashMap<K,V>": [[42, 61]]}}}, {"text": "Here is a note from the documentation of the IdentityHashMap<K,V> class", "label": {"api": {"IdentityHashMap<K,V>": [[45, 64]]}}}, {"text": "Use JMenuBar#getMenu() and JMenu#getMenuComponent() methods to get all the JMenu and JMenuItem", "label": {"api": {"JMenuBar#getMenu()": [[4, 21]], "JMenu#getMenuComponent()": [[27, 50]]}}}, {"text": "Note also, I would investigate Writers for writing strings, and watch your character encoding", "label": {"api": {"Writers": [[31, 37]]}}}, {"text": "In Java 8, you could use Optional", "label": {"api": {"Optional": [[25, 32]]}}}, {"text": "Map.Entry contains getKey() and getValue() methods to access key and value from Map Entry", "label": {"api": {"Map.Entry": [[0, 8]]}}}, {"text": "Look at classes Timer and TimerTask", "label": {"api": {"Timer": [[16, 20], [26, 30]], "TimerTask": [[26, 34]]}}}, {"text": "You can use Timer or ScheduledExecutorService to repeat a task at an interval", "label": {"api": {"Timer": [[12, 16]], "ScheduledExecutorService": [[21, 44]]}}}, {"text": "The standard out PrintStream can be replaced with System.setOut()", "label": {"api": {"System.setOut()": [[50, 64]]}}}, {"text": "You'll want to look into either the built-in HttpURLConnection class in Java or the Apache HttpComponents library which has a nicer API", "label": {"api": {"HttpURLConnection": [[45, 61]]}}}, {"text": "HttpURLConnection is very verbose", "label": {"api": {"HttpURLConnection": [[0, 16]]}}}, {"text": "Look here for a great answer of how to use HttpURLConnection", "label": {"api": {"HttpURLConnection": [[43, 59]]}}}, {"text": "Note also that you have to use String#equals instead of just == for comparing Strings", "label": {"api": {"String#equals": [[31, 43]]}}}, {"text": "Java is using java.util.zip.Deflater", "label": {"api": {"java.util.zip.Deflater": [[14, 35]]}}}, {"text": "The getClass() method is a method in Object that returns the Class object for the instance", "label": {"api": {"getClass() method is a method in Object": [[4, 42]]}}}, {"text": "However, the getSuperclass() method, defined in Class, returns the Class object for the superclass of the class, not of the Class returned by getClass()", "label": {"api": {"getSuperclass() method, defined in Class": [[13, 52]]}}}, {"text": "To get PlayerDeathEvent, call getName() instead", "label": {"api": {"getName()": [[30, 38]]}}}, {"text": "In this example I accumulate the list into a LinkedList", "label": {"api": {"LinkedList": [[45, 54]]}}}, {"text": "The LinkedList implements Deque (Double ended queue) which allows me to append the items in a last-in-first-out (LIFO) order", "label": {"api": {"LinkedList": [[4, 13]], "Deque": [[26, 30]]}}}, {"text": "I perform the accumulation in the collect method using LinkedList::addFirst which places the items read off the stream at the head of the list", "label": {"api": {"LinkedList": [[55, 64]]}}}, {"text": "You can read the JDI documentation, and take a look at the Java instrument class (which is used to configure a class-transformer) in particular", "label": {"api": {"JDI documentation": [[17, 33]], "Java instrument class": [[59, 79]]}}}, {"text": "Basically, what the second example you copied is showing is how to dump an object to an arbitrary java.io.Writer object (though they use a StringWriter as this will not write anything to disk)", "label": {"api": {"java.io.Writer": [[98, 111]], "StringWriter": [[139, 150]]}}}, {"text": "If you want to modify this example to write to a particular file, you can do so by making use of a FileWriter, like so", "label": {"api": {"FileWriter": [[99, 108]]}}}, {"text": "Note that it is not normally necessary to create the file yourself before opening the FileWriter as the FileWriter will handle that for you", "label": {"api": {"FileWriter": [[86, 95], [104, 113]]}}}, {"text": "I don't think that is a good practice and I would only use Swing library classes not to show GUI components but to use some classes to store special objects such as ImageIcon to store icons", "label": {"api": {"ImageIcon": [[165, 173]]}}}, {"text": "If you only aims to set a few variables used by your java code, java Properties are probably better suited", "label": {"api": {"Properties": [[69, 78]]}}}, {"text": "To align in a FlowLayout you need to change its alignment field through FlowLayout.setAligment(int) (docs), you can also do this in the constructor, so If we change the pan declaration to", "label": {"api": {"(docs)": [[100, 105]]}}}, {"text": "According to the Oracle documentation, you need to register the observers with the Observable object and then call the notifyObservers method of the Observable object", "label": {"api": {"Oracle documentation": [[17, 36]]}}}, {"text": "You can use a ThreadPoolExecutor (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html) initialized with a set number of threads when it is created", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html": [[34, 118]]}}}, {"text": "Look for the MessageDigest class, and pick your algorithm (SHA1, MD5, SHA256, etc.)", "label": {"api": {"MessageDigest": [[13, 25]]}}}, {"text": "I'd suggest that you to revisit String.hashCode()", "label": {"api": {"String.hashCode": [[32, 46]]}}}, {"text": "The exact hash is specified; see the String.hashCode javadoc specification", "label": {"api": {"String.hashCode": [[37, 51]]}}}, {"text": "String.hashCode() should be considerably faster, and the storage required for the hash values should be considerably smaller, than a cryptographic hash", "label": {"api": {"String.hashCode": [[0, 14]]}}}, {"text": "If by subJFrame you mean a window that is directly contained within the other (a JInternalFrame) then yes", "label": {"api": {"JInternalFrame": [[81, 94]]}}}, {"text": "You can set the minimum width of a column by specifying a set of ColumnConstraints objects on the GridPane", "label": {"api": {"GridPane": [[98, 105]], "ColumnConstraints": [[65, 81]]}}}, {"text": "See the Javadocs for GridPane and ColumnConstraints to see other properties that can be controlled this way", "label": {"api": {"GridPane": [[21, 28]], "ColumnConstraints": [[34, 50]]}}}, {"text": "See the documentation for the java.io.File class to see what methods are available", "label": {"api": {"documentation for the java.io.File class": [[8, 47]]}}}, {"text": "Yes it is possible, with Swing it is called a JMenuBar", "label": {"api": {"JMenuBar": [[46, 53]]}}}, {"text": "The only thing that's changed is that the Integer class now contains some methods that will treat a 32-bit integer(s) as an unsigned 32-bit integer", "label": {"api": {"Integer": [[42, 48]]}}}, {"text": "See compareUnsigned, divideUnsigned, parseUnsignedInt, and several others in the javadoc for Integer", "label": {"api": {"Integer": [[93, 99]]}}}, {"text": "The javadoc for the method public E set(int index, E element) in java.​util.​List states", "label": {"api": {"public E set(int index, E element)": [[27, 60]], "java.​util.​List": [[65, 80]]}}}, {"text": "Also please note that when working with factorials (or really big numbers in general) you are best off using BigInteger for your calculations, as BigIntegers cannot overflow like an int or a long", "label": {"api": {"BigInteger": [[109, 118], [146, 155]]}}}, {"text": "Here's the description of the ClassNotFoundException for  ObjectInputStream.readObject", "label": {"api": {"ObjectInputStream.readObject": [[58, 85]]}}}, {"text": "I looked at JLatexMath, mentioned in your referenced answer, and it can genereate a BufferedImage", "label": {"api": {"Image": [[92, 96]]}}}, {"text": "With SwingFXUtils you can convert it to a JavaFX Image and use it in your application", "label": {"api": {"SwingFXUtils": [[5, 16]], "Image": [[49, 53]]}}}, {"text": "This cannot be done with an ArrayList, this could be done with a TreeSet and a custom Comparator implementation which is able to accurately compare the int[] objects", "label": {"api": {"TreeSet": [[65, 71]], "Comparator": [[86, 95]]}}}, {"text": "The reason for Comparable<Players> is that Comparable itself is defined as taking a generic type T", "label": {"api": {"is defined as taking a generic type T": [[61, 97]]}}}, {"text": "The function to convert from float to raw integer and back are java.lang.Float.floatToIntBits and java.lang.Float.intBitsToFloat", "label": {"api": {"java.lang.Float.floatToIntBits": [[63, 92]], "java.lang.Float.intBitsToFloat": [[98, 127]]}}}, {"text": "Here the conversion functions are java.lang.Double.doubleToLongBits and java.lang.Double.longBitsToDouble", "label": {"api": {"java.lang.Double.doubleToLongBits": [[34, 66]], "java.lang.Double.longBitsToDouble": [[72, 104]]}}}, {"text": "Another option is to use SwingWorker, but that's not always appropriate as it requires that the code that \"knows\" it needs to use the UI thread is the code that sets up the background thread", "label": {"api": {"SwingWorker": [[25, 35]]}}}, {"text": "Files::readAllLines method my solution is very huge", "label": {"api": {"Files::readAllLines": [[0, 18]]}}}, {"text": "How I can to do the same action but use Collector to present data in collection of entities some like following", "label": {"api": {"Collector": [[40, 48]]}}}, {"text": "The following code throws a java.util.ConcurrentModificationException, as expected", "label": {"api": {"java.util.ConcurrentModificationException": [[28, 68]]}}}, {"text": "why does the second piece of code NOT throw the java.util.ConcurrentModificationException", "label": {"api": {"java.util.ConcurrentModificationException": [[48, 88]]}}}, {"text": "The easiest, though least efficient, way to do this is to wrap the set with Collections.synchronizedSortedSet() before using it, i.e.", "label": {"api": {"Collections.synchronizedSortedSet()": [[76, 110]]}}}, {"text": "Another alternative is to use an explicitly thread-safe SortedSet, namely ConcurrentSkipListSet", "label": {"api": {"ConcurrentSkipListSet": [[74, 94]]}}}, {"text": "When is a ConcurrentSkipListSet useful", "label": {"api": {"ConcurrentSkipListSet": [[10, 30]]}}}, {"text": "It is more common in Java now to use String formatting instead of decimal format", "label": {"api": {"String formatting": [[37, 53]]}}}, {"text": "Istead, use the Event.getSource() to determine the source object", "label": {"api": {"Event.getSource()": [[16, 32]]}}}, {"text": "You will also need an event-listener for your OK-button, in which you can call", "label": {"api": {"list": [[28, 31]]}}}, {"text": "this will only ADD parameters to your list, removal (via un-ticking the boxes) also needs to be handled ..", "label": {"api": {"list": [[38, 41]]}}}, {"text": "Consider using a list instead of one single string ..", "label": {"api": {"list": [[17, 20]]}}}, {"text": "Use Calendar.HOUR_OF_DAY that is used for the 24-hour clock", "label": {"api": {"Calendar.HOUR_OF_DAY": [[4, 23]]}}}, {"text": "There is a retainAll method on Set that will do the job of the intersection", "label": {"api": {"retainAll": [[11, 19]]}}}, {"text": "There is an addAll method on Collection that will do the job of union", "label": {"api": {"addAll": [[12, 17]]}}}, {"text": "The String.matches method performs a regular expression match", "label": {"api": {"String.matches": [[4, 17]]}}}, {"text": "Standard SE API provide only method replaceAll() that convert value to same type..", "label": {"api": {"replaceAll()": [[36, 47]]}}}, {"text": "On JDK 8, parallel streams are by default executed within the common fork-join pool, which is documented on the ForkJoinPool javadoc page", "label": {"api": {"ForkJoinPool": [[112, 123]]}}}, {"text": "This page documents a system property java.util.concurrent.ForkJoinPool.common.parallelism that you can set to control the number of threads (amount of parallelism) in the common pool", "label": {"api": {"ForkJoinPool": [[59, 70]]}}}, {"text": "And the java.lang.Object class has the method toString() in it", "label": {"api": {"toString()": [[46, 55]]}}}, {"text": "When you print the object, it prints the return of that method, toString()", "label": {"api": {"toString()": [[64, 73]]}}}, {"text": "What your instructor wants you to do is override that toString() method that is automatically inherited so that you may customize what happens when you print out the object", "label": {"api": {"toString()": [[54, 63]]}}}, {"text": "Normally the toString() method (if not overridden) prints this", "label": {"api": {"toString()": [[13, 22]]}}}, {"text": "Using a Pattern/Matcher seems to be more in line with what you're trying to do", "label": {"api": {"Pattern": [[8, 14]], "Matcher": [[16, 22]]}}}, {"text": "If your RenderedImage is a BufferedImage, you can simply use the getSubImage() method", "label": {"api": {"BufferedImage": [[27, 39]]}}}, {"text": "If your RenderedImage is not a BufferedImage, you have to do it the \"harder\" way", "label": {"api": {"BufferedImage": [[31, 43]]}}}, {"text": "From the JavaDoc of Object.hashCode()", "label": {"api": {"Object.hashCode()": [[20, 36]]}}}, {"text": "Theses are the possible locations for an annotiation (from javadoc @Target", "label": {"api": {"javadoc @Target": [[59, 73]]}}}, {"text": "Use a KeyListener", "label": {"api": {"KeyListener": [[6, 16]]}}}, {"text": "First make a Component, give it the focus, and add a KeyListener", "label": {"api": {"KeyListener": [[53, 63]], "Component": [[13, 21]]}}}, {"text": "So you can probably use retainAll method to get the intersection", "label": {"api": {"retainAll": [[24, 32]]}}}, {"text": "String.replaceFirst does not replace the string in-place, but returns a replaced string", "label": {"api": {"String.replaceFirst": [[0, 18]]}}}, {"text": "Use a ConcurrentHashMap<Integer, MyClass> to store your data", "label": {"api": {"ConcurrentHashMap<Integer, MyClass>": [[6, 40]]}}}, {"text": "For more information on charsets, see StandartCharsets class reference", "label": {"api": {"StandartCharsets class reference": [[38, 69]]}}}, {"text": "What is the quickest implementation of java.util.Map for a very small number of entries (under 15 elements or so)", "label": {"api": {"java.util.Map": [[39, 51]]}}}, {"text": "You have both DeflaterInputStream and DeflaterOutputStream however ZipInputStream is only for files inside a Zip file already", "label": {"api": {"ZipInputStream": [[67, 80]]}}}, {"text": "If sounds like you want to use a TreeMap, where the key is the bottom of the range, and the value is the Range object", "label": {"api": {"TreeMap": [[33, 39]]}}}]