[{"text": "This can be done by attaching a shutdown hook", "label": {"api": {"shutdown hook": [[32, 44]]}}}, {"text": "Use an Iterator and call Iterator.remove() instead", "label": {"api": {"Iterator.remove()": [[25, 41]]}}}, {"text": "Have you tried to use method setCursor on your Custome Cell", "label": {"api": {"setCursor": [[29, 37]]}}}, {"text": "I thought about using a CountDownLatch or an ArrayBlockingQueue, but they don't seem appropriate", "label": {"api": {"CountDownLatch": [[24, 37]], "ArrayBlockingQueue": [[45, 62]]}}}, {"text": "If it's not, use Semaphore", "label": {"api": {"Semaphore": [[17, 25]]}}}, {"text": "You can use DataInputStream and DataOutputStream stream decorators to frame the message for you with readUTF() and writeUTF(String)", "label": {"api": {"DataInputStream": [[12, 26]], "DataOutputStream": [[32, 47]]}}}, {"text": "A better approach would be to use Desktop.browse, which specifically launches the URL in the default browser", "label": {"api": {"Desktop.browse": [[34, 47]]}}}, {"text": "Call the values() method on each map; you can iterate through the returned Collection of values", "label": {"api": {"values() method": [[9, 23]]}}}, {"text": "Consider using a CountDownLatch", "label": {"api": {"CountDownLatch": [[17, 30]]}}}, {"text": "InterruptibleChannels reacts on the interrupt call, but not \"old fashioned\" socket streams", "label": {"api": {"InterruptibleChannel": [[0, 19]]}}}, {"text": "The best way is probably to use a HashSet, but Player doesn't override hashCode, so HashMap<int, Player> will work, using Player's entityId", "label": {"api": {"HashMap<int, Player>": [[84, 103]]}}}, {"text": "You have defined your own EmptyStackException, but Java supplies java.util.EmptyStackException, and its only constructor takes no arguments, which means your code that you think uses your own EmptyStackException actually is using java.util.EmptyStackException", "label": {"api": {"its only constructor takes no arguments": [[100, 138]]}}}, {"text": "You can concatenate the two strings together; the overloaded println methods take at most one parameter", "label": {"api": {"println methods": [[61, 75]]}}}, {"text": "More information about how to use String.format can be found in the documentation about Formatter", "label": {"api": {"documentation about Formatter": [[68, 96]]}}}, {"text": "Yes use JFromattedTextFeild with a MaskFormatter class", "label": {"api": {"JFromattedTextFeild": [[8, 26]], "MaskFormatter": [[35, 47]]}}}, {"text": "MaskFormatter has a setPlaceholderCharacter('_') function to help you with", "label": {"api": {"MaskFormatter": [[0, 12]]}}}, {"text": "You may also need to use the InputVerifier to verify user input's validity", "label": {"api": {"InputVerifier": [[29, 41]]}}}, {"text": "JFormattedTextFeild's documentation has example to show how to use an InputVerifier with it", "label": {"api": {"InputVerifier": [[70, 82]]}}}, {"text": "So read the data into a byte[] from the C class as a resource and use the ImageIcon(byte[]) constructor to create the image", "label": {"api": {"as a resource": [[48, 60]], "ImageIcon(byte[])": [[74, 90]]}}}, {"text": "Alternatively you may use an intermediate image which could be read by using an URL to a resource to create the icon", "label": {"api": {"intermediate image": [[29, 46]], "using an URL to a resource": [[71, 96]]}}}, {"text": "I'd recommend using java.io.DataOutputStream with an underlying java.io.FileOutputStream", "label": {"api": {"java.io.DataOutputStream": [[20, 43]], "java.io.FileOutputStream": [[64, 87]]}}}, {"text": "Take a look at the various implementations of the  java.util.concurrent.ExecutorService interface", "label": {"api": {"java.util.concurrent.ExecutorService": [[51, 86]]}}}, {"text": "You can use String#replaceAll", "label": {"api": {"String#replaceAll": [[12, 28]]}}}, {"text": "Use a CategoryAxis instead of a NumberAxis (or follow the tickLabelFormatter solution in Sergey's answer)", "label": {"api": {"CategoryAxis": [[6, 17]], "NumberAxis": [[32, 41]]}}}, {"text": "With HttpUrlConnection, call HttpUrlConnection.setFollowRedirects(false) - note that this a static method that affects all future connection attempts", "label": {"api": {"HttpUrlConnection.setFollowRedirects(false)": [[29, 71]]}}}, {"text": "I imagined something in the java.nio.file.attribute package would do it -- hell it's a complex enough package, but I can't find this attribute", "label": {"api": {"java.nio.file.attribute": [[28, 50]]}}}, {"text": "I tried Files.readAttributes which allows dynamically retrieving all attributes from a particular \"attribute view\"", "label": {"api": {"Files.readAttributes": [[8, 27]]}}}, {"text": "Use replace(), not replaceAll()", "label": {"api": {"replace()": [[4, 12]], "replaceAll()": [[19, 30]]}}}, {"text": "replaceAll() uses regex for its target, and your search term is an impossible to match regex", "label": {"api": {"replaceAll()": [[0, 11]]}}}, {"text": "replace() replaces (all occurrences of) plain text", "label": {"api": {"replace()": [[0, 8]]}}}, {"text": "Use a RandomAccessFile and store the current position you are reading", "label": {"api": {"RandomAccessFile": [[6, 21]]}}}, {"text": "Make a request for the specified link using HttpURLConnection or Apache HttpComponents", "label": {"api": {"HttpURLConnection": [[44, 60]]}}}, {"text": "Use the Robot class to simply press Down arrow and Enter or something", "label": {"api": {"Robot": [[8, 12]]}}}, {"text": "I managed to change the language with the Locale and the RessourceBundle", "label": {"api": {"Locale": [[42, 47]], "RessourceBundle": [[57, 71]]}}}, {"text": "Or you can use StringTokenizer", "label": {"api": {"StringTokenizer": [[15, 29]]}}}, {"text": "In Swing there is interface TreeModel with default implementation Supposed to be used in JTree and generally not written the best way (like no generics), but can do the job", "label": {"api": {"TreeModel": [[28, 36]], "default implementation": [[43, 64]]}}}, {"text": "TextAreas cannot have different styles applied to different text strings within the TextArea", "label": {"api": {"TextArea": [[0, 7], [84, 91]]}}}, {"text": "I would store the contents of both arrays in a Set (one each), as Sets are optimized for this kind of operation (look at the add/addAll, remove/removeAll, retainAll methods)", "label": {"api": {"Set": [[47, 49], [66, 68]]}}}, {"text": "Read the Java Tutorial bit about Sets for further reference", "label": {"api": {"Set": [[33, 35]]}}}, {"text": "However, in the common use of Java's String.split, trailing empty strings are discarded", "label": {"api": {"trailing empty strings are discarded": [[51, 86]]}}}, {"text": "Using the example on http://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferStrategy.html I made up this frame example", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferStrategy.html": [[21, 95]]}}}, {"text": "Use ArrayList instead primitive array", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "If you really know what are you doing and want to have String[], you have to copy all the elements into the new array with System.arraycopy()", "label": {"api": {"System.arraycopy()": [[123, 140]]}}}, {"text": "If the first 2 chars are \"99\", you can use the startsWith() method for this, then it is the number you need", "label": {"api": {"startsWith()": [[47, 58]]}}}, {"text": "Per split()'s javadoc, split() does the equivalent of Pattern.compile(), which you can optimize away if you're in a tight loop", "label": {"api": {"split()'s javadoc": [[4, 20]]}}}, {"text": "Try the indexOf method instead", "label": {"api": {"indexOf": [[8, 14]]}}}, {"text": "If you look at the method String#charAt(int index), you'll see that it takes in an int parameter", "label": {"api": {"String#charAt(int index)": [[26, 49]]}}}, {"text": "You need to use the indexOf() for this", "label": {"api": {"indexOf()": [[20, 28]]}}}, {"text": "Collections.binarySearch method is used to search for an exact match, and not a match based on some substring or some method", "label": {"api": {"Collections.binarySearch": [[0, 23]]}}}, {"text": "http://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html > Validate..", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html": [[0, 73]]}}}, {"text": "You don't need to use anchors with Matcher#matches() method", "label": {"api": {"Matcher#matches()": [[35, 51]]}}}, {"text": "Also here you can directly use String#matches() method", "label": {"api": {"String#matches()": [[31, 46]]}}}, {"text": "These methods will be plain wrappers for Connection#setAutoCommit Connection#close and Connection#rollback respectively", "label": {"api": {"Connection#setAutoCommit": [[41, 64]], "Connection#close": [[66, 81]], "Connection#rollback": [[87, 105]]}}}, {"text": "As you want to remove some chars (the () and +), the safest approach is standard regex matching with Pattern and Matcher classes", "label": {"api": {"Pattern": [[101, 107]], "Matcher": [[113, 119]]}}}, {"text": "The nextInt method can be used to read the values for feet and weight", "label": {"api": {"nextInt": [[4, 10]]}}}, {"text": "Since you are using JTextPane, you should use SimpleAttributeSet", "label": {"api": {"SimpleAttributeSet": [[46, 63]]}}}, {"text": "Search the JTextArea API for setFont", "label": {"api": {"JTextArea API": [[11, 23]]}}}, {"text": "And writeUTF writes a 2-byte length prefix, so the total length is supposed to be 18", "label": {"api": {"writeUTF": [[4, 11]]}}}, {"text": "Fortunately, there are implementations of the List interface that do this behind-the-scenes for you already, the most common of which is ArrayList", "label": {"api": {"ArrayList": [[137, 145]]}}}, {"text": "As the name suggests, an ArrayList wraps an array, offering ways to add/remove elements via methods like add() and remove() (see the afore-linked documentation)", "label": {"api": {"ArrayList": [[25, 33]]}}}, {"text": "One simple way is to use Float.NaN", "label": {"api": {"Float.NaN": [[25, 33]]}}}, {"text": "You can do the same with Double.NaN", "label": {"api": {"Double.NaN": [[25, 34]]}}}, {"text": "You should probably use java.math.BigInteger to store the factorial", "label": {"api": {"java.math.BigInteger": [[24, 43]]}}}, {"text": "Compile-time constant expressions of type String are always \"interned\" so as to share unique instances, using the method String#intern()", "label": {"api": {"String#intern()": [[121, 135]]}}}, {"text": "So, if you really need to compare two String using == or != make sure you call String.intern() method before making comparison", "label": {"api": {"String.intern()": [[79, 93]]}}}, {"text": "So it means if you call String.intern() you can compare two strings using == operator", "label": {"api": {"String.intern()": [[24, 38]]}}}, {"text": "But here String.intern() is not necessary because in Java final String are internally interned", "label": {"api": {"String.intern()": [[9, 23]]}}}, {"text": "You can find more information String comparision using == operator and Javadoc for String.intern() method", "label": {"api": {"String.intern()": [[83, 97]]}}}, {"text": "As this is probably about money, I'd suggest using BigDecimal", "label": {"api": {"BigDecimal": [[51, 60]]}}}, {"text": "It is not an error, it's all about precision for floating point numbers(float, double).If you want more accurate results, use BigDecimal", "label": {"api": {"BigDecimal": [[126, 135]]}}}, {"text": "Easier solutions would be rounding(Math.round function) and formatting(NumberFormat)", "label": {"api": {"Math.round": [[35, 44]], "NumberFormat": [[71, 82]]}}}, {"text": "The Thread class constructor requires Runnable object (any class implementing Runnable interface) as a parameter", "label": {"api": {"Thread class": [[4, 15]], "Runnable object": [[38, 52]]}}}, {"text": "Later on you can use Lists (dynamic arrays), if you want to save an undefined number of values", "label": {"api": {"Lists": [[21, 25]]}}}, {"text": "The javadoc for Thread.setDaemon(boolean) says", "label": {"api": {"Thread.setDaemon(boolean)": [[16, 40]]}}}, {"text": "You can try setting your own uncaught Exception handler, however I strongly advise against it", "label": {"api": {"setting your own uncaught Exception handler": [[12, 54]]}}}, {"text": "To prevent setting the default menu again, the code below stores the property of whether a text box has already been initialized or not using JComponent.putClientProperty", "label": {"api": {"JComponent.putClientProperty": [[142, 169]]}}}, {"text": "The page at http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html lists all the characters which have a special meaning in regular expressions", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html": [[12, 80]]}}}, {"text": "The Pattern class lists the use of Regular Expression in Java", "label": {"api": {"Pattern": [[4, 10]]}}}, {"text": "Put the contents of your fake CSV in a String, then create a instance of StringReader on it and pass that to your method", "label": {"api": {"StringReader": [[73, 84]]}}}, {"text": "I'd use printf instead of println", "label": {"api": {"printf": [[8, 13]]}}}, {"text": "If you want to understand how it works, you can read up on Java's Format String Syntax", "label": {"api": {"Java's Format String Syntax": [[59, 85]]}}}, {"text": "With List you can use Collections' method unmodifiableList to convert a given list into a version you can savely expose to the outside", "label": {"api": {"Collections": [[22, 32]], "unmodifiableList": [[42, 57]]}}}, {"text": "I want to add a section similar to the area that begins with \"Linked list implementation of the List interface...\" in the  LinkedList class (http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html) above the Field Summary", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html": [[141, 206]]}}}, {"text": "Depending on the degree of complexity of your file a simple String.replace() or String.replaceAll() might do", "label": {"api": {"String.replace()": [[60, 75]], "String.replaceAll()": [[80, 98]]}}}, {"text": "If you know that the numbers are likely to be large, use BigInteger instead", "label": {"api": {"BigInteger": [[57, 66]]}}}, {"text": "This is guaranteed not to overflow, and then you can either check whether the result is too large to fit into an int or long, or you can just use the BigInteger value directly", "label": {"api": {"BigInteger": [[150, 159]]}}}, {"text": "BigInteger is an arbitrary-precision class, so it's going to be slower than using a direct primitive value (which can probably be stored in a processor register), so figure out whether you're realistically going to be overflowing a long (an int times an int will always fit in a long), and choose BigInteger if your domain really requires it", "label": {"api": {"BigInteger": [[0, 9], [297, 306]]}}}, {"text": "I/O like the operations that are waiting for any monitor are not interruptible that is the reason that the InterruptedException rutine is not needed by those cases, but according to Java 7 Documentation  the I/O classes that belong to nio package can respond to any attempt to be interruted throwing one of the stream Interruption exception one of this is ClosedByInterruptionException and it parent class AsynchronousCloseException", "label": {"api": {"ClosedByInterruptionException": [[356, 384]], "AsynchronousCloseException": [[406, 431]]}}}, {"text": "But in case that you want to close the excution thead, instead of closing the stream, you could consider make use of FutureTask that provide the way to cancel", "label": {"api": {"FutureTask": [[117, 126]]}}}, {"text": "For this case where you want that each Thread has its own Connection, you need to use ThreadLocal, since each request spawn its own Thread", "label": {"api": {"ThreadLocal": [[86, 96]]}}}, {"text": "You just need to make sure to close the connection at the end of the request, this is achieved using a Filter", "label": {"api": {"Filter": [[103, 108]]}}}, {"text": "The filter should be before any other Filter to ensure that the connection is closed at the end of the request", "label": {"api": {"Filter": [[38, 43]]}}}, {"text": "The JButton constructor takes a String, Icon, or Action", "label": {"api": {"JButton": [[4, 10]]}}}, {"text": "Make your Student class a subclass of JButton", "label": {"api": {"JButton": [[38, 44]]}}}, {"text": "I know about some related Java 7 functionalities, however, they do not allow to move all contents of a folder to somewhere else if it is not empty, which is a requirement in my case", "label": {"api": {"related Java 7 functionalities": [[18, 47]]}}}, {"text": "Use Map's remove method, which takes a key as an argument", "label": {"api": {"Map's remove method": [[4, 22]]}}}, {"text": "The reflection interface can be found in the reflection package", "label": {"api": {"reflection package": [[45, 62]]}}}, {"text": "Generally one would access the interface by using a Class instance", "label": {"api": {"Class": [[52, 56]]}}}, {"text": "A more robust approach would be to split thesis on whitespace, strip off punctuation from each of the resulting words, add them all to a Set, and then see if the Set#contains any of your pronouns", "label": {"api": {"Set": [[137, 139], [162, 164]]}}}, {"text": "If you use TreeSet, you can tell the collection to ignore case and treat \"We\" and \"we\" the same", "label": {"api": {"Set": [[15, 17]]}}}, {"text": "You can use a different constructor of String that lets you specify the array along with the start point and number of characters to use", "label": {"api": {"String": [[39, 44]]}}}, {"text": "I want to get all the annotations of the current method, for that I need method instance so that I can get annotation from method", "label": {"api": {"get annotation from method": [[103, 128]]}}}, {"text": "Check the methods of the Object class", "label": {"api": {"the Object class": [[21, 36]]}}}, {"text": "On Windows, build the Path of the directory as described for Paths.get", "label": {"api": {"Paths.get": [[61, 69]]}}}, {"text": "You can use the StringBuffer to reverse() a string", "label": {"api": {"reverse()": [[32, 40]]}}}, {"text": "However, It is even better to use java.swing.Action which is itself an action listener that provides not only action-event handling, but also centralized handling of the state of action-event-firing components such as tool bar buttons, menu items, common buttons, and text fields", "label": {"api": {"java.swing.Action": [[34, 50]]}}}, {"text": "You can use the String javax.xml.bind.DatatypeConverter.printHexBinary(byte[])", "label": {"api": {"String javax.xml.bind.DatatypeConverter.printHexBinary(byte[])": [[16, 77]]}}}, {"text": "You have to use the SimpleDateFormat#format(Date date) method, which returns the date formatted in the desired way", "label": {"api": {"SimpleDateFormat#format(Date date)": [[20, 53]]}}}, {"text": "To adjust the height, set a different font size", "label": {"api": {"set a different font": [[22, 41]]}}}, {"text": "To adjust the width, specify the number of columns during construction", "label": {"api": {"construction": [[58, 69]]}}}, {"text": "Another option available under Java 7 is SecondaryLoop", "label": {"api": {"SecondaryLoop": [[41, 53]]}}}, {"text": "Take a look at Hidden Java 7 Features – SecondaryLoop for a detailed explanation & example", "label": {"api": {"SecondaryLoop": [[40, 52]]}}}, {"text": "System#console may return null in certain environments", "label": {"api": {"System#console": [[0, 13]]}}}, {"text": "This is the documented behaviour", "label": {"api": {"documented": [[12, 21]]}}}, {"text": "Check out the ArrayList javadoc", "label": {"api": {"ArrayList": [[14, 22]]}}}, {"text": "Check with scanner.hasNextInt() before calling nextInt()", "label": {"api": {"scanner.hasNextInt()": [[11, 30]]}}}, {"text": "On a unix system, the best bet is to use Runtime.exec()", "label": {"api": {"Runtime.exec()": [[41, 54]]}}}, {"text": "If they're not important, then  either remove the spaces from correctline or place calls to trim() to make whitespace at the beginning or end not matter", "label": {"api": {"trim()": [[92, 97]]}}}, {"text": "Per the docs for hasNext(), \"This method may block while waiting for input to scan.\" I'd guess you're running a Scanner on some kind of input that never ends (like maybe System.in?)", "label": {"api": {"the docs for hasNext()": [[4, 25]]}}}, {"text": "The two-argument form String.substring(begin, end) is what you need to chop out a single character", "label": {"api": {"two-argument form": [[4, 20]]}}}, {"text": "You should use fixed-delay execution instead, which starts the next task based on the previous task's completion time instead of its start time", "label": {"api": {"fixed-delay execution": [[15, 35]]}}}, {"text": "You can't modify an existing schedule, but you can cancel() the TimerTask that's executing, and reschedule it for the new period", "label": {"api": {"cancel()": [[51, 58]]}}}, {"text": "In Java 8 and later, we could simply use the java.time classes", "label": {"api": {"java.time": [[45, 53]]}}}, {"text": "The reason they did this in Java was to allow methods like Arrays.equals(Object[], Object[]) to work back before they added generics to Java", "label": {"api": {"Arrays.equals(Object[], Object[])": [[59, 91]]}}}, {"text": "In nextInt(), NoSuchElementFoundException occurs when the input is exhausted", "label": {"api": {"nextInt(),": [[3, 12]]}}}, {"text": "In this particular case, even better would probably be to use the standard JDBC interface DataSource instead of your own connection factory class", "label": {"api": {"DataSource": [[90, 99]]}}}, {"text": "You could wrap the stream in a PushbackInputStream, read one byte to see if there is content, then push back the byte if there is", "label": {"api": {"PushbackInputStream": [[31, 49]]}}}, {"text": "As long as you then use the same instance of PushbackInputStream when you process the file content, that byte will then be part of the stream", "label": {"api": {"PushbackInputStream": [[45, 63]]}}}, {"text": "You could use the split method to split the string at the first occurrence of a space followed by a digit", "label": {"api": {"split": [[18, 22], [34, 38]]}}}, {"text": "Seems you need to call UIManager.addAuxiliaryLookAndFeel(LookAndFeel)1 before trying to use it", "label": {"api": {"UIManager.addAuxiliaryLookAndFeel(LookAndFeel)": [[23, 68]]}}}, {"text": "Check the DatagramChannel.receive() method", "label": {"api": {"DatagramChannel.receive()": [[10, 34]]}}}, {"text": "You're trying to use Java.util.Timer", "label": {"api": {"Java.util.Timer": [[21, 35]]}}}, {"text": "Use Java.swing.Timer instead, or work with TimerTask", "label": {"api": {"Java.swing.Timer": [[4, 19]], "TimerTask": [[43, 51]]}}}, {"text": "Your ObjectA has to implement the java.io.Serializable interface", "label": {"api": {"java.io.Serializable": [[34, 53]]}}}, {"text": "Implementing java.io.Externalizable is valid, as well", "label": {"api": {"java.io.Externalizable": [[13, 34]]}}}, {"text": "The difference is that java.io.Serializable is known as marker interface (e.g", "label": {"api": {"java.io.Serializable": [[23, 42]]}}}, {"text": "the interface doesn't provide methods for implementing), while java.io.Externalizable forces you to implement two methods and so provides the necessary means for implementing a custom serialization mechanism", "label": {"api": {"java.io.Externalizable": [[63, 84]]}}}, {"text": "group throws an IllegalStateException if not preceded by either matches or find", "label": {"api": {"group": [[0, 4]], "matches": [[64, 70]]}}}, {"text": "Invoke matches prior to calling group so that the expression matches the complete String", "label": {"api": {"group": [[32, 36]], "matches": [[7, 13], [61, 67]]}}}, {"text": "Creating an instance of FileOutputStream(file, append) and wrapping it with PrintWriter should work", "label": {"api": {"FileOutputStream(file, append)": [[24, 53]]}}}, {"text": "I suggest that instead of using a HashSet, you should use a sorted data structure, such as a java.util.TreeSet", "label": {"api": {"java.util.TreeSet": [[93, 109]]}}}, {"text": "Set#add() returns a boolean value indicating if the set was changed as a result of calling it with the given parameter (returns false if the set already contained the value), but most of the time the returned value is ignored as in the snippet", "label": {"api": {"Set#add()": [[0, 8]]}}}, {"text": "Store how much was read into a variable (InputStream.read returns a useful number) and specify that to the appropriate OutputStream.write overload to only write a portion (that which contains the useful data) of the array", "label": {"api": {"InputStream.read": [[41, 56]], "OutputStream.write": [[119, 136]]}}}, {"text": "Try with Scanner", "label": {"api": {"Scanner": [[9, 15]]}}}, {"text": "nextDouble and nextInt only read the double or int values, respectively, but will ignore the invisible \"\\n\" at the end of each line", "label": {"api": {"nextDouble": [[0, 9]], "nextInt": [[15, 21]]}}}, {"text": "While invoking that method an ArrayIndexOutOfBoundsException was thrown (SAStoSeP.java:56)", "label": {"api": {"ArrayIndexOutOfBoundsException": [[30, 59]]}}}, {"text": "From the Method javadoc", "label": {"api": {"Method": [[9, 14]]}}}, {"text": "In Java, each object has toString() method, the default is displaying the class name representation, then adding @ and then the hashcode", "label": {"api": {"toString()": [[25, 34]]}}}, {"text": "You should use Arrays#toString(), which is implemented this way", "label": {"api": {"toString()": [[22, 31]], "Arrays#toString()": [[15, 31]]}}}, {"text": "IMO this type of problem is a great place to use the ExecutorService.invokeAny() method", "label": {"api": {"ExecutorService.invokeAny()": [[53, 79]]}}}, {"text": "This code uses the Callable interface (instead of the Runnable interface) so that a value can be returned", "label": {"api": {"Callable": [[19, 26]], "Runnable": [[54, 61]]}}}, {"text": "Using this method, there is no need to use lower level threads, or other classes like Semaphores, CountDownLatches, FutureTasks, etc", "label": {"api": {"Semaphores": [[86, 95]], "CountDownLatches": [[98, 113]], "FutureTasks": [[116, 126]]}}}, {"text": "void sort(List<T> list), it sorts given list", "label": {"api": {"void sort(List<T> list)": [[0, 22]]}}}, {"text": "There is a class called ThreadLocal for this", "label": {"api": {"ThreadLocal": [[24, 34]]}}}, {"text": "You will find that BufferedReader.readLine() is as fast as you need", "label": {"api": {"BufferedReader.readLine()": [[19, 43]]}}}, {"text": "you can next use readLine() to read from bf", "label": {"api": {"readLine()": [[17, 26]]}}}, {"text": "If you have Guava around, you could try combining Joiner with Collections.nCopies", "label": {"api": {"Collections.nCopies": [[62, 80]]}}}, {"text": "Try taking a look at SimpleDateFormats - That would be your best bet and easiest way of doing it", "label": {"api": {"SimpleDateFormats": [[21, 37]]}}}, {"text": "In this context xPath will return a org.w3c.dom.Node, which is expected (I hope)", "label": {"api": {"org.w3c.dom.Node": [[36, 51]]}}}, {"text": "When you read int value using nextInt, it reads only the int value, it skips the new line character", "label": {"api": {"nextInt": [[30, 36]]}}}, {"text": "The latter will be read in the next nextLine causing it to skip the \"real\" input", "label": {"api": {"nextLine": [[36, 43]]}}}, {"text": "You can fix this by adding another nextLine before the \"real\" nextLine, it'll swallow the '\\n' that you don't want to read", "label": {"api": {"nextLine": [[35, 42], [62, 69]]}}}, {"text": "Assumed that you are finally using Runtime.exec() inside your exec() method, you can use the waitFor() method of the Process object which is returned from Runtime.exec() to wait until the execution has finished", "label": {"api": {"Runtime.exec()": [[35, 48], [155, 168]], "waitFor()": [[93, 101]], "Process": [[117, 123]]}}}, {"text": "The return value from waitFor() is the exit code of the sub process", "label": {"api": {"waitFor()": [[22, 30]]}}}, {"text": "If you actually need to read output from the sub process which the sub process is writing to its stderr or stdout channel, you need to use Process.getInputStream() (Note", "label": {"api": {"Process": [[139, 145]]}}}, {"text": "not getOutputStream()) and Process.getErrorStream() and read the sub processes output from these streams", "label": {"api": {"Process": [[27, 33]]}}}, {"text": "Then, check the return values from the stream's read() methods to check if the sub process has terminated (or at least closed its output streams) instead of using waitFor()", "label": {"api": {"waitFor()": [[163, 171]]}}}, {"text": "Alternatively, you might want to check the ProcessBuilder class", "label": {"api": {"Process": [[43, 49]], "ProcessBuilder": [[43, 56]]}}}, {"text": "Map the file to the memory and use MemoryMappedBuffer", "label": {"api": {"Map the file": [[0, 11]], "MemoryMappedBuffer": [[35, 52]]}}}, {"text": "As you're using BufferedWriter, it may not write to file at the end of loop", "label": {"api": {"BufferedWriter": [[16, 29]]}}}, {"text": "BufferedWriter uses 8192 as default size to write to file, which means it will not write to file unless your data size cached by the writer is up to 8192", "label": {"api": {"BufferedWriter": [[0, 13]]}}}, {"text": "Next this javaagent must be activated with JVM flag, and then everything just works", "label": {"api": {"javaagent": [[10, 18]]}}}, {"text": "See the doc here and a sorting tutorial here", "label": {"api": {"the doc here": [[4, 15]]}}}, {"text": "Since the string contains 0x, use Integer.decode(String nm)", "label": {"api": {"Integer.decode(String nm)": [[34, 58]]}}}, {"text": "LinkedList class implements both Deque and Queue interface", "label": {"api": {"LinkedList": [[0, 9]], "Deque": [[33, 37]], "Queue": [[43, 47]]}}}, {"text": "It inherits add(E) method from Queue, and addLast(E) method from Deque", "label": {"api": {"Deque": [[65, 69]], "Queue": [[31, 35]], "add(E)": [[12, 17]], "addLast(E)": [[42, 51]]}}}, {"text": "The Javadoc of the LinkageError (http://docs.oracle.com/javase/6/docs/api/java/lang/LinkageError.html) is pretty self-explaining", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/LinkageError.html": [[33, 100]]}}}, {"text": "You should escape special characters in dynamic strings using Pattern.quote", "label": {"api": {"Pattern.quote": [[62, 74]]}}}, {"text": "Try checking out java2s and Oracle tutorial for a bit more info", "label": {"api": {"Oracle tutorial": [[28, 42]]}}}, {"text": "The DatabaseMetaData API, part of the JDBC spec, is the way to do this in Java", "label": {"api": {"DatabaseMetaData": [[4, 19]]}}}, {"text": "If you need a volatile access to an array you can use AtomicIntegerArray", "label": {"api": {"AtomicIntegerArray": [[54, 71]]}}}, {"text": "Class::getResourceAsStream loads resources from the classpath; in a web application, that means files inside WEB-INF/classes, or inside one of the JAR files inside WEB-INF/lib", "label": {"api": {"Class::getResourceAsStream": [[0, 25]]}}}, {"text": "You can load web resources using ServletContext::getResourceAsStream", "label": {"api": {"ServletContext::getResourceAsStream": [[33, 67]]}}}, {"text": "Try using a HashMap<String, Integer> (see HashMap) where the integer is a counter incremented every time you encounter a new ID", "label": {"api": {"HashMap": [[12, 18], [42, 48]]}}}, {"text": "Since you've additionally stated that you want to preserve ordering, then the LinkedHashMap is perfect", "label": {"api": {"HashMap": [[84, 90]], "LinkedHashMap": [[78, 90]]}}}, {"text": "You have used the ArrayList constructor that determines its initial capacity, not its initial size", "label": {"api": {"ArrayList constructor that determines its initial capacity": [[18, 75]]}}}, {"text": "The list has a capacity of 4, but nothing has been added yet, so its size is still 0", "label": {"api": {"add": [[51, 53]]}}}, {"text": "Also, don't use set to add to the list", "label": {"api": {"add": [[23, 25]]}}}, {"text": "That method replaces an element that is already there", "label": {"api": {"replaces an element that is already there": [[12, 52]]}}}, {"text": "You must add to the list first (or use the other overloaded add method)", "label": {"api": {"add": [[9, 11], [60, 62]]}}}, {"text": "You can convert the Date to a long with the getTime() method (milliseconds since epoch) and back, and a long is 8 bytes", "label": {"api": {"getTime() method": [[44, 59]], "and back": [[88, 95]]}}}, {"text": "You are looking for Collections.nCopies(int, T)", "label": {"api": {"Collections.nCopies(int, T)": [[20, 46]]}}}, {"text": "The constructor Scanner(String) accepts a String to read from, not a file name", "label": {"api": {"Scanner(String)": [[16, 30]]}}}, {"text": "Instead, use the constructor that accepts a File source, Scanner(File)", "label": {"api": {"Scanner(File)": [[57, 69]]}}}, {"text": "Instead, create a CountDownLatch with a count of 1, countDown() it in the callback, then await() it in your calling code", "label": {"api": {"CountDownLatch": [[18, 31]]}}}, {"text": "Hm, probably I didn't understand your question but why not to use toCharArray() method", "label": {"api": {"toCharArray()": [[66, 78]]}}}, {"text": "Of course, if you just want to break the string into a character array, you can just use String#toCharArray() method", "label": {"api": {"String#toCharArray()": [[89, 108]]}}}, {"text": "See JFrame.setDefaultCloseOperation This is probably the easiest solution, but it's not robust, as it's not easy to access the stored people from the rest of your application", "label": {"api": {"JFrame.setDefaultCloseOperation": [[4, 34]]}}}, {"text": "or, since you just want a single element ArrayList, you can use Collections.singletonList that avoids the creation of temporary varargs array", "label": {"api": {"Collections.singletonList": [[64, 88]]}}}, {"text": "When dealing with binary data (MP3 files) you should use InputStream and OutputStream and not Readers/Writers", "label": {"api": {"InputStream": [[57, 67]], "OutputStream": [[73, 84]]}}}, {"text": "As per the Java documentation, I should syncronize access to this map whenever multiple threads may concurrently interact with it", "label": {"api": {"the Java documentation": [[7, 28]]}}}, {"text": "@SLaks's recommendation to use ConcurrentHashMap would work as long as you don't require one read from the Map to the next operate on the same data", "label": {"api": {"ConcurrentHashMap": [[31, 47]]}}}, {"text": "can fail as the ConcurrentHashMap can change between the two function calls", "label": {"api": {"ConcurrentHashMap": [[16, 32]]}}}, {"text": "If you require such guarantees, you should use a ReadWriteLock, as you can keep the Map locked for the duration of the reads/writes", "label": {"api": {"ReadWriteLock": [[49, 61]]}}}, {"text": "(in this case, instance can be any implementation of Map<>, it doesn't have to be a ConcurrentHashMap)", "label": {"api": {"ConcurrentHashMap": [[84, 100]]}}}, {"text": "You can also do the same thing with MessageFormat, which you might or might not find easier to use", "label": {"api": {"MessageFormat": [[36, 48]]}}}, {"text": "Read JavaDoc of JLabel", "label": {"api": {"JavaDoc of JLabel": [[5, 21]]}}}, {"text": "You can use a Java Calendar and SimpleDateFormat to do the job", "label": {"api": {"Java Calendar": [[14, 26]], "SimpleDateFormat": [[32, 47]]}}}, {"text": "You can only use nextBoolean() when the token is literally \"true\" or \"false\"", "label": {"api": {"token is literally \"true\" or \"false\"": [[40, 75]]}}}, {"text": "You either need to prompt for the literal values \"true\" or \"false\" or else read the y/n response as a String and convert to a boolean yourself, like", "label": {"api": {"read the y/n response as a String": [[75, 107]]}}}, {"text": "Arrays.asList(T...) method takes variable arguments of some type T with no upper bounds", "label": {"api": {"Arrays.asList(T...)": [[0, 18]]}}}, {"text": "JAXB can handle collections, but a map is not a collection per se", "label": {"api": {"collections": [[16, 26]], "map": [[35, 37]]}}}, {"text": "And the entry set, which would be the most reasonable representation of a map as a collection, has two problems", "label": {"api": {"map": [[74, 76]], "entry set": [[8, 16]]}}}, {"text": "its element type is the interface Map.Entry, and it does not support modification via the add method", "label": {"api": {"Map.Entry": [[34, 42]], "add": [[90, 92]]}}}, {"text": "The former problem can be circumvented via an adapter, but the latter makes relying on the JAXB handling of collections rather problematic", "label": {"api": {"collections": [[108, 118]]}}}, {"text": "Buf if you don't want to write your own collection, then I suggest you use an XmlAdapter to create an alternate representation of the whole Properties object", "label": {"api": {"XmlAdapter": [[78, 87]], "Properties": [[140, 149]]}}}, {"text": "If you want to, you can design it in such a way that it models the XML scheme used by Properties.storeToXML and Properties.loadFromXML", "label": {"api": {"Properties": [[86, 95], [112, 121]], "Properties.storeToXML": [[86, 106]], "Properties.loadFromXML": [[112, 133]]}}}, {"text": "I've also written a small executable demo snippet which uses this to serialize a class like the one you describe, with an id in addition to a properties member", "label": {"api": {"add": [[128, 130]]}}}, {"text": "Note that the whole Properties field is serialized as a single <properties> element, which in turn contains an arbitrary number of <entry> elements", "label": {"api": {"Properties": [[20, 29]]}}}, {"text": "Use String.valueOf method", "label": {"api": {"String.valueOf": [[4, 17]]}}}, {"text": "Use Collections.synchronizedList() method instead", "label": {"api": {"Collections.synchronizedList()": [[4, 33]]}}}, {"text": "Construct Set from your list - \"A collection that contains no duplicate elements\"", "label": {"api": {"Set": [[10, 12]]}}}, {"text": "If you want to preserve order, use LinkedHashSet instead", "label": {"api": {"Set": [[45, 47]], "LinkedHashSet": [[35, 47]]}}}, {"text": "Use an instance of java.util.LinkedHashSet", "label": {"api": {"java.util.LinkedHashSet": [[19, 41]]}}}, {"text": "A for-each loop is possible for Classes that implement Iterable", "label": {"api": {"Iterable": [[55, 62]]}}}, {"text": "There are however lists that are well capable of being able to be modified during traversal, mostly the concurrent lists in the concurrent package", "label": {"api": {"concurrent package": [[128, 145]]}}}, {"text": "You can't accurately do that without using ResultSetMetaData class to get the column type", "label": {"api": {"ResultSetMetaData": [[43, 59]]}}}, {"text": "You're not calling Matcher#find or Matcher#matches command in your code", "label": {"api": {"Matcher#find": [[19, 30]], "Matcher#matches": [[35, 49]]}}}, {"text": "The parameter provided to setLocation must not be null", "label": {"api": {"setLocation": [[26, 36]]}}}, {"text": "From the documentation for addShutdownHook", "label": {"api": {"addShutdownHook": [[27, 41]]}}}, {"text": "If the exception extend RuntimeException, you don't have to write throws in the method name, but it's highly recommended since it's clearer and it'll be mentioned in the documentation of the method", "label": {"api": {"extend RuntimeException": [[17, 39]]}}}, {"text": "(Note that the default toString method some of the OWL API classes might show the IRI of the thing, so simply printing an  individual or class might look the same as printing its IRI as a string.)  getTypes returns a set of OWLClassExpressions, and once you've got one of those, you could use asOWLClass to get the corresponding class, and then use getSuperClasses to walk up your class hierarchy", "label": {"api": {"toString": [[23, 30]]}}}, {"text": "You need to use the other constructor BigDecimal(String val) to get the exact precision", "label": {"api": {"BigDecimal(String val)": [[38, 59]]}}}, {"text": "This is String equals api, so it should look something like", "label": {"api": {"String": [[8, 13]]}}}, {"text": "You can easily do it with the equals() method", "label": {"api": {"equals()": [[30, 37]]}}}, {"text": "Using PosixFileAttributeView we are getting only posix permissions which does not contain any extra acl entries other than basic posix permissions", "label": {"api": {"PosixFileAttributeView": [[6, 27]]}}}, {"text": "Use Java's SimpleDateFormat class to format the returned Date as a String in the format of your choice", "label": {"api": {"SimpleDateFormat class": [[11, 32]]}}}, {"text": "Set#add(E) methods adds an element into the Set only if it doesn't exists (this is tested on the basis of equals and hashCode, that is why you need to override them)", "label": {"api": {"Set#add(E)": [[0, 9]]}}}, {"text": "PrintStream has a method that accepts a char[]", "label": {"api": {"PrintStream": [[0, 10]], "method": [[18, 23]]}}}, {"text": "To do this it first has to convert charArray to a String using the Object#toString method(JLS 5.1.11)", "label": {"api": {"method": [[83, 88]], "Object#toString": [[67, 81]]}}}, {"text": "invokes the PrintStream#println(char[]) method", "label": {"api": {"PrintStream#println(char[])": [[12, 38]]}}}, {"text": "And then the method PrintStream#println(String) is invoked", "label": {"api": {"PrintStream#println(String)": [[20, 46]]}}}, {"text": "Look into the Object#toString() method to see how it forms the string for the array", "label": {"api": {"Object#toString()": [[14, 30]]}}}, {"text": "There is a lot of useful methods in Scanner, so I'd advise taking a look at the docs", "label": {"api": {"taking a look at the docs": [[59, 83]]}}}, {"text": "Take a look at the classes that implement the Shape interface", "label": {"api": {"Shape": [[46, 50]]}}}, {"text": "I'm looking for an existing Java Set implementation that throws an exception when the add method is called with an object that is already in the set", "label": {"api": {"add": [[86, 88]]}}}, {"text": "See Object#toString() for details on the Object's toString() method", "label": {"api": {"Object#toString()": [[4, 20]]}}}, {"text": "To map a relationship where there is a collection at both ends, like the parent-child relationship, you want @ManyToMany", "label": {"api": {"@ManyToMany": [[109, 119]]}}}, {"text": "With @ManyToMany, you can have @JoinTable only on one side, and you need mappedBy only on the other side", "label": {"api": {"@ManyToMany": [[5, 15]]}}}, {"text": "From the docs, it says that it only supports servlet, JSP file, or HTML file", "label": {"api": {"servlet, JSP file, or HTML file": [[45, 75]]}}}, {"text": "Launch /bin/sh as a separate process using Runtime.exec", "label": {"api": {"Runtime.exec": [[43, 54]]}}}, {"text": "See Package java.util.concurrent.atomic for", "label": {"api": {"Package java.util.concurrent.atomic": [[4, 38]]}}}, {"text": "Before Java 7, I guess there wasn't any format to parse ISO 8601 format timezone with colon in between", "label": {"api": {"ISO 8601 format timezone": [[56, 79]]}}}, {"text": "However, from Java 7 onwards, you have an option for parsing ISO 8601 format timezone using X instead of Z", "label": {"api": {"ISO 8601 format timezone": [[61, 84]]}}}, {"text": "See javadoc for SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "The Time Zone should have this format, for example something like -0800", "label": {"api": {"format": [[31, 36]]}}}, {"text": "currentTimeMillis is actually the number of milliseconds since January 1, 1970 (source)", "label": {"api": {"source": [[80, 85]]}}}, {"text": "See the discussion in http://docs.oracle.com/javase/6/docs/api/java/util/Date.html for more details", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/util/Date.html": [[22, 81]]}}}, {"text": "Math.round(double) returns a long, hence the narrowing cast", "label": {"api": {"Math.round(double)": [[0, 17]]}}}, {"text": "You can read from the process's output stream using Process.getOutputStream() and respond to the process using it's input stream (Process.getInputStream())", "label": {"api": {"Process.getOutputStream()": [[52, 76]], "Process.getInputStream()": [[130, 153]]}}}, {"text": "You can use the above pattern directly with String#matches(String) method", "label": {"api": {"String#matches(String)": [[44, 65]]}}}, {"text": "Or, if you are building Pattern and Matcher objects, then just use the following pattern with Matcher#find() method", "label": {"api": {"Matcher#find()": [[94, 107]]}}}, {"text": "Use a ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[6, 30]]}}}, {"text": "The class you want is FontMetrics, which you can get from your Graphics2D object", "label": {"api": {"FontMetrics": [[22, 32]]}}}, {"text": "Once you've got the FontMetrics object, you can use methods like charsWidth, getHeight, and getAscent to determine the appropriate width and height of your string (depending on what you mean by 'height,' see the explanation on page 73 here to understand some of the basics about font sizing) in pixels", "label": {"api": {"FontMetrics": [[20, 30]]}}}, {"text": "You can use the String#split(String regex) method", "label": {"api": {"String#split(String regex)": [[16, 41]]}}}, {"text": "I think you can do this with an @IdClass", "label": {"api": {"@IdClass": [[32, 39]]}}}, {"text": "You can call setTimeZone() to set the time zone of your choosing for anything in Quartz that inherits BaseCalendar", "label": {"api": {"TimeZone": [[16, 23]]}}}, {"text": "Java's TimeZone class has a getDefault() which should aid in determining OS timezone programmatically", "label": {"api": {"TimeZone": [[7, 14]], "getDefault()": [[28, 39]]}}}, {"text": "You may use longBitsToDouble and intBitsToFloat to convert an long (64 bits) or an int(32 bits)", "label": {"api": {"longBitsToDouble": [[12, 27]], "intBitsToFloat": [[33, 46]]}}}, {"text": "You can use Class::asSubclass to cast your Class<?> to a more refined type, then propagate that type through the constructor to the new instance", "label": {"api": {"Class::asSubclass": [[12, 28]]}}}, {"text": "This might be a bug in Jersey, as the accepted way to handle exceptions doesn't work for WebApplicationException", "label": {"api": {"WebApplicationException": [[89, 111]]}}}, {"text": "You can create an ExceptionMapper that catches RuntimeException and then test if the exception is an instance of WebApplicationException", "label": {"api": {"ExceptionMapper": [[18, 32]], "RuntimeException": [[47, 62]], "WebApplicationException": [[113, 135]]}}}, {"text": "Map interface is implemented by HashMap and LinkedHashMap classes so you'll most likely want to use it instead of more specific types", "label": {"api": {"Map": [[0, 2], [36, 38], [54, 56]], "HashMap": [[32, 38], [50, 56]], "LinkedHashMap": [[44, 56]]}}}, {"text": "See the documentation on the Character class for how to tell if you've got one of those situations -- it has to do with the numeric range that the character code is in)", "label": {"api": {"Character class": [[29, 43]]}}}, {"text": "Stack is a class in Java, but Queue is an interface, so you can't instantiate it", "label": {"api": {"Stack": [[0, 4]], "Queue": [[30, 34]]}}}, {"text": "Queue is an interface and can not be instanciated", "label": {"api": {"Queue is an interface": [[0, 20]]}}}, {"text": "You could use a LinkedList", "label": {"api": {"LinkedList": [[16, 25]]}}}, {"text": "or one of the listened", "label": {"api": {"listened": [[14, 21]]}}}, {"text": "Direct method handles are defined as the handles produced by ldc of a CONSTANT_MethodHandle constant or the find* and unreflect* methods in MethodHandles.Lookup, with no further transformations (no bound arguments etc.)", "label": {"api": {"are defined": [[22, 32]]}}}, {"text": "Call MethodHandles.reflectAs, passing the expected class (Method, Constructor or Field) and the handle to crack", "label": {"api": {"MethodHandles.reflectAs": [[5, 27]]}}}, {"text": "Obtain a MethodHandles.Lookup \"equivalent to that which created the target method handle, or which has enough access permissions to recreate an equivalent method handle\" (per the MethodHandleInfo docs), then call Lookup.revealDirect passing the handle to crack to get a MethodHandleInfo, then call MethodHandleInfo.reflectAs passing the expected class (Method, Constructor or Field) and the Lookup", "label": {"api": {"Lookup.revealDirect": [[213, 231]], "MethodHandleInfo.reflectAs": [[298, 323]]}}}, {"text": "To maintain security, this pathway treats caller-sensitive methods specially by checking against the lookup class", "label": {"api": {"caller-sensitive methods": [[42, 65]]}}}, {"text": "If you're positive that you're going to be writing exactly the same number of bytes, you can use a RandomAccessFile to accomplish this (available since Java 1.0)", "label": {"api": {"RandomAccessFile": [[99, 114]]}}}, {"text": "For reference, here's the Javadocs that explain all format symbols for SimpleDateFormat", "label": {"api": {"Javadocs that explain all format symbols for SimpleDateFormat": [[26, 86]]}}}, {"text": "Use the split method to return an array, with each element containing a piece of input", "label": {"api": {"split method": [[8, 19]]}}}, {"text": "Then you can parse each piece into an int using Integer.parseInt", "label": {"api": {"Integer.parseInt": [[48, 63]]}}}, {"text": "The application has a \"TimeLine\" attached to it that will print a statement on the console", "label": {"api": {"TimeLine": [[23, 30]]}}}, {"text": "For a clean solution to your problem, use the ExecutorCompletionService to wait until all tasks are finished", "label": {"api": {"ExecutorCompletionService": [[46, 70]]}}}, {"text": "If you want one prompt, no matter how many tokens/words you enter, then read the whole line with nextLine", "label": {"api": {"nextLine": [[97, 104]]}}}, {"text": "From the JavaDoc of Map", "label": {"api": {"Map": [[20, 22]]}}}, {"text": "From the JavaDoc of Collection", "label": {"api": {"Collection": [[20, 29]]}}}, {"text": "Map does not extend Collection, nor does Collection extend Map", "label": {"api": {"Map": [[0, 2], [59, 61]], "Collection": [[20, 29], [41, 50]]}}}, {"text": "That said, both interfaces are part of the Java Collection Framework", "label": {"api": {"Collection": [[48, 57]]}}}, {"text": "If you're trying to just pause for a second, Object.wait() is the wrong method", "label": {"api": {"Object.wait()": [[45, 57]]}}}, {"text": "You want Thread.sleep() instead", "label": {"api": {"Thread.sleep()": [[9, 22]]}}}, {"text": "Hibernate Session.close() closes the underlying connection; and http://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html#close%28%29 states that the behavior when a transaction is open is implementation-defined (i.e", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html#close%28%29": [[64, 140]]}}}, {"text": "An easy and efficient Collection Type IMO is the ArrayList though this is not restrictive", "label": {"api": {"ArrayList": [[49, 57]]}}}, {"text": "You can add Objects in an ArrayList like this", "label": {"api": {"ArrayList": [[26, 34]]}}}, {"text": "If you're using bean paradigm you can use the Introspector class", "label": {"api": {"Introspector": [[46, 57]]}}}, {"text": "If you want to read up on this have a look at Oracle's documentation on ClassLoaders or OSGI", "label": {"api": {"ClassLoaders": [[72, 83]]}}}, {"text": "You can use file's exists method to determine if the directory is sharing folder", "label": {"api": {"exists": [[19, 24]]}}}, {"text": "You can also use the set method", "label": {"api": {"set": [[21, 23]]}}}, {"text": "When sorting natural language texts, it's recommended to use a Collator and CollationKeys", "label": {"api": {"Collator": [[63, 70]], "CollationKeys": [[76, 88]]}}}, {"text": "The String.compareTo method mentioned by other answers will compare Strings based on the Unicode value of each character in the strings, which might not be what you want/ expect, depending on your input Strings and locale", "label": {"api": {"String.compareTo": [[4, 19]]}}}, {"text": "Shuffle the list then iterate over it", "label": {"api": {"Shuffle": [[0, 6]]}}}, {"text": "Check http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadLocalRandom.html for further details", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadLocalRandom.html": [[6, 89]]}}}, {"text": "All of this is documented in detail on the javadocs for the KeyEvent page", "label": {"api": {"KeyEvent": [[60, 67]]}}}, {"text": "Take a look at String#split method, this will help you to separate authors by asterisk", "label": {"api": {"String#split": [[15, 26]]}}}, {"text": "Make it easy to visit your site using the browse() method provided by java.awt.Desktop", "label": {"api": {"java.awt.Desktop": [[70, 85]]}}}, {"text": "That is the expected behavior according to the Java API", "label": {"api": {"Java API": [[47, 54]]}}}, {"text": "How can I influence the behaviour by using the ApplicationException annotation", "label": {"api": {"ApplicationException": [[47, 66]]}}}, {"text": "You are mistaking finalizers (implementations of the Object.finalize() method) for finally blocks", "label": {"api": {"Object.finalize()": [[53, 69]]}}}, {"text": "It's always better to use a HashSet when you don't want to store duplicates", "label": {"api": {"HashSet": [[28, 34]]}}}, {"text": "Then use HashSet#contains() method to check if element is already there", "label": {"api": {"HashSet": [[9, 15]], "HashSet#contains()": [[9, 26]]}}}, {"text": "If ordering is important, then use LinkedHashSet", "label": {"api": {"HashSet": [[41, 47]], "LinkedHashSet": [[35, 47]]}}}, {"text": "For comparing String, use String#equals(Object) method", "label": {"api": {"String#equals(Object)": [[26, 46]]}}}, {"text": "To avoid you should use an Set instead of an array and loop until size = 10", "label": {"api": {"Set": [[27, 29]]}}}, {"text": "Try using a DocumentListener with your text Field", "label": {"api": {"DocumentListener": [[12, 27]]}}}, {"text": "I am writing a sample code snippets to demonstrate, how adding DocumentListener to your fNameTF and lNameTF text fields will resolve your problem", "label": {"api": {"DocumentListener": [[63, 78]]}}}, {"text": "Add a DocumentListener to your lNameTf.getDocument() the same way", "label": {"api": {"DocumentListener": [[6, 21]]}}}, {"text": "How to use DocumentListener", "label": {"api": {"DocumentListener": [[11, 26]]}}}, {"text": "You can use Math.pow()", "label": {"api": {"Math.pow()": [[12, 21]]}}}, {"text": "It looks like by default this is not the case, but you can pass an instance of ResourceBundle.Control to ResourceBundle.getBundle to use a custom subclass of ResourceBundle that would expose a setKey method that lets you set the keys", "label": {"api": {"ResourceBundle.Control": [[79, 100]]}}}, {"text": "The Javadocs for the Pattern class has lots of details about special characters in regular expressions", "label": {"api": {"Javadocs for the Pattern class": [[4, 33]]}}}, {"text": "But you will then need to use either the StringTokenizer class or the split(String regex) method in the String class, or the Regular Expression API's Pattern & Matcher classes (which the String.split(String regex) class uses under the hood)", "label": {"api": {"StringTokenizer": [[41, 55]], "String": [[41, 46], [76, 81], [104, 109], [187, 192], [200, 205]], "Pattern": [[150, 156]], "Matcher": [[160, 166]]}}}, {"text": "You can directly do this using String#replace method", "label": {"api": {"String#replace": [[31, 44]]}}}, {"text": "I think that a TreeSet is a good fit for this", "label": {"api": {"TreeSet": [[15, 21]]}}}, {"text": "This constructor will let you pass in a Comparator", "label": {"api": {"This constructor": [[0, 15]]}}}, {"text": "immutable classes is the -- highly questionable --\"hashcode\" method on Object", "label": {"api": {"Object": [[71, 76]]}}}, {"text": "If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result", "label": {"api": {"Object": [[49, 54]]}}}, {"text": "It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results", "label": {"api": {"Object": [[85, 90]]}}}, {"text": "\"123\"), you can use toCharArray() instead", "label": {"api": {"toCharArray()": [[20, 32]]}}}, {"text": "If you want to ensure that each character is a digit, you can use Character.isDigit()", "label": {"api": {"Character.isDigit()": [[66, 84]]}}}, {"text": "Use Integer.compare() to compare the values, as opposed to subtracting them", "label": {"api": {"Integer.compare()": [[4, 20]]}}}, {"text": "Use String.format and %.2f", "label": {"api": {"String.format": [[4, 16]]}}}, {"text": "Javadocs for Date", "label": {"api": {"Javadocs for Date": [[0, 16]]}}}, {"text": "Timestamp has nanosecond precision", "label": {"api": {"nanosecond": [[14, 23]]}}}, {"text": "Both java.sql.Date and java.util.Date have only millisecond precision", "label": {"api": {"java.sql.Date": [[5, 17]], "java.util.Date": [[23, 36]]}}}, {"text": "Please check the JavaDoc of compare", "label": {"api": {"compare": [[28, 34]]}}}, {"text": "Arrays.sort can easily sort it, or any portion of it", "label": {"api": {"Arrays.sort": [[0, 10]], "or any portion of it": [[32, 51]]}}}, {"text": "Otherwise, a binary search could be more performant", "label": {"api": {"binary search": [[13, 25]]}}}, {"text": "Once you sort the list, binarySearch in Collections will do the trick", "label": {"api": {"binarySearch": [[24, 35]]}}}, {"text": "If you want to read a whole line, you should use the method nextLine of your Scanner", "label": {"api": {"Scanner": [[77, 83]]}}}, {"text": "If you expect the user to input several values, you will have to read accordingly from that Scanner (so you will also have to read the newline from the answer of the first question you are asking the user)", "label": {"api": {"Scanner": [[92, 98]]}}}, {"text": "Here is the doc for the class Scanner", "label": {"api": {"Scanner": [[30, 36]]}}}, {"text": "Better your StringBuffer orStringBuilder", "label": {"api": {"StringBuffer": [[12, 23]], "StringBuilder": [[27, 39]]}}}, {"text": "The nextDouble() method is not static and it does not take any arguments", "label": {"api": {"nextDouble()": [[4, 15]]}}}, {"text": "Every object implicitly has an equals from Object (as every object is a sub-type of Object) - and since it's a virtual method, standard Java polymorphism takes over", "label": {"api": {"equals from Object": [[31, 48]]}}}, {"text": "Now, Comparator#equals imposes an additional restriction, which is why it is specified as part of the interface", "label": {"api": {"Comparator#equals": [[5, 21]]}}}, {"text": "You access it using the Class.getResource method", "label": {"api": {"Class.getResource": [[24, 40]]}}}, {"text": "Why not just use lastIndexOf", "label": {"api": {"lastIndexOf": [[17, 27]]}}}, {"text": "Since Java-8 you can write @RayHulha's solution even more concisely by using lambda expression (for creating a new Iterable) and default method (for Iterator.remove)", "label": {"api": {"Iterable": [[115, 122]], "Iterator.remove": [[149, 163]]}}}, {"text": "Then, cleverly use the ArrayList methods that you will find in the Java API", "label": {"api": {"Java API": [[67, 74]]}}}, {"text": "Store all of the File objects in a List<File> and sort them using a custom Comparator so that they are ordered by \"lastModified\"", "label": {"api": {"Comparator": [[75, 84]]}}}, {"text": "The SwingWorker API documentation also has an example", "label": {"api": {"SwingWorker API documentation": [[4, 32]]}}}, {"text": "If you want to ensure that only one button press is processed at a time, you could use a thread pool with a single thread (see SingleThreadExecutor)", "label": {"api": {"SingleThreadExecutor": [[127, 146]]}}}, {"text": "This seems to be an issue with ObjectOutputStream, which (according to the Serialization FAQ and this site) keeps a cache of all objects written to it so that repeated objects can be optimized into cache references", "label": {"api": {"ObjectOutputStream": [[31, 48]]}}}, {"text": "This can be implemented using ThreadLocal", "label": {"api": {"ThreadLocal": [[30, 40]]}}}, {"text": "Examples how to use ThreadLocal can be found easily—e.g", "label": {"api": {"ThreadLocal": [[20, 30]]}}}, {"text": "We are exploiting the fact that Set#add returns a boolean indicating whether the element being added is already present in the set", "label": {"api": {"Set#add": [[32, 38]]}}}, {"text": "Then you just need to handle the clipboard", "label": {"api": {"clipboard": [[33, 41]]}}}, {"text": "I use the isSymbolicLink(Path) method", "label": {"api": {"isSymbolicLink(Path)": [[10, 29]]}}}, {"text": "Check out java.util.Collections.sort(List list, Comparator c)..", "label": {"api": {"java.util.Collections.sort(List list, Comparator c)": [[10, 60]], "Comparator": [[48, 57]]}}}, {"text": "all you need to do is write a Comparator that compares two of your Arrays and the rest is a piece of cake", "label": {"api": {"Comparator": [[30, 39]]}}}, {"text": "You can use HttpServletRequest.getRequestURL and HttpServletRequest.getRequestURI", "label": {"api": {"HttpServletRequest.getRequestURL": [[12, 43]], "HttpServletRequest.getRequestURI": [[49, 80]]}}}, {"text": "As KepaniHaole said, you should use a LinkedHashSet if you want to preserve order", "label": {"api": {"LinkedHashSet": [[38, 50]]}}}, {"text": "Like normal casting, Class's cast method does not change the actual type of the object", "label": {"api": {"Class's cast method": [[21, 39]]}}}, {"text": "The cast actually works, because Thread implements Runnable, otherwise a ClassCastException would have been thrown", "label": {"api": {"Thread implements Runnable": [[33, 58]]}}}, {"text": "But if what you want is to for a Java program to run a program, and you want it to pass in additional environment variables, then yes, that's possible, by using java.lang.ProcessBuilder's environment() method", "label": {"api": {"java.lang.ProcessBuilder's environment() method": [[161, 207]]}}}, {"text": "You are in the right path, but you need to use zero-width matcher groups so that they don't get swallowed, so something like", "label": {"api": {"zero-width": [[47, 56]]}}}, {"text": "Using Matcher makes the procedural code more verbose, but it has the added advantage of making the regex easier to understand", "label": {"api": {"Matcher": [[6, 12]]}}}, {"text": "In SearchGame method use isBeforeFirst() method to check if you have any data at all", "label": {"api": {"isBeforeFirst()": [[25, 39]]}}}, {"text": "If you want to use transaction synchronization then you are expected to use TransactionSynchronizationRegistry", "label": {"api": {"Synchronization": [[87, 101]]}}}, {"text": "Or in case add JTA Synchronization with usage of TransactionManager", "label": {"api": {"Synchronization": [[19, 33]], "TransactionManager": [[49, 66]]}}}, {"text": "Or even better, use a class like SimpleDateFormat to try to parse the string to a date", "label": {"api": {"SimpleDateFormat": [[33, 48]]}}}, {"text": "Use Integer.toString(int i, int radix)", "label": {"api": {"Integer.toString(int i, int radix)": [[4, 37]]}}}, {"text": "The reverse can be done with Integer.parseInt(String s, int radix)", "label": {"api": {"Integer.parseInt(String s, int radix)": [[29, 65]]}}}, {"text": "The JAVA DOC of fireTableStructureChanged clearly states that", "label": {"api": {"fireTableStructureChanged": [[16, 40]]}}}, {"text": "with JTable.setModel(model) call  or upon receiving the event fired by fireTableStructureChanged function call,  if autoCreateColumnsFromModel is set(true) JTable will discards any table columns that it had and reallocates default columns in the order they appear in the model", "label": {"api": {"fireTableStructureChanged": [[71, 95]]}}}, {"text": "Instead of removing fireTableStructureChanged() call, i think  setting autoCreateColumnsFromModel flag to false is sufficient", "label": {"api": {"fireTableStructureChanged": [[20, 44]]}}}, {"text": "So you should sort your itemList (with a Comparator) with Item 2 first", "label": {"api": {"Comparator": [[41, 50]]}}}, {"text": "Why you do not use a BufferedReader class in Java", "label": {"api": {"BufferedReader": [[21, 34]]}}}, {"text": "It maybe a better option here to use the LineNumberReader class for counting and reading the lines of text", "label": {"api": {"LineNumberReader": [[41, 56]]}}}, {"text": "From LineNumberReader for readLine method", "label": {"api": {"LineNumberReader": [[5, 20]]}}}, {"text": "This means that when you call the getLineNumber method of the LineNumberReader class, it will return the current line number that has been incremented by the readLine method", "label": {"api": {"LineNumberReader": [[62, 77]]}}}, {"text": "I'm writing my own logging Handler for Java and I'd like to insert the line number of the log message to my output", "label": {"api": {"Handler": [[27, 33]]}}}, {"text": "I searched the interface of LogRecord but could not find out in which line the message was logged", "label": {"api": {"LogRecord": [[28, 36]]}}}, {"text": "If no thread handoff is occurring in your handler or upstream you can create a new Throwable().getStackTrace() and use the java.lang.StackTraceElement API to get the line number", "label": {"api": {"Throwable().getStackTrace()": [[83, 109]], "java.lang.StackTraceElement": [[123, 149]]}}}, {"text": "I've got 2 versions here for you, first using ArrayList and then just with arrays", "label": {"api": {"ArrayList": [[46, 54]]}}}, {"text": "For this, you have to use the ExecutorService interface", "label": {"api": {"ExecutorService": [[30, 44]]}}}, {"text": "If you want to retrieve your values like variable may be you can use HashMap", "label": {"api": {"HashMap": [[69, 75]]}}}, {"text": "It makes use a of the method Character#isWhitespace to check whether a character is white space or not and a StringBuilder to build the result", "label": {"api": {"Character#isWhitespace": [[29, 50]], "StringBuilder": [[109, 121]]}}}, {"text": "If you want to have a method to just count the white spaces in a string you can loop over the entire string, check each character using Character#isWhitespace and increment a variable if it return true", "label": {"api": {"Character#isWhitespace": [[136, 157]]}}}, {"text": "See Pattern documentation for capturing groups and this tutorial to get how quantifiers work", "label": {"api": {"Pattern documentation": [[4, 24]]}}}, {"text": "Within Java 1.6, there's the NavigableSet interface", "label": {"api": {"NavigableSet": [[29, 40]]}}}, {"text": "So, you've got your collection in this NavigableSet now", "label": {"api": {"NavigableSet": [[39, 50]]}}}, {"text": "You now have two methods - floor and ceiling which return the element that is lower than or greater respectively to the argument, or equal if there is one and null if there is no such element", "label": {"api": {"floor": [[27, 31]], "ceiling": [[37, 43]]}}}, {"text": "We can modify our GridBagLayout by supplying it with GridBagConstraints once you've learned how to modify your GridBagLayout using GridBagConstraints your problem will be extremely simple to solve", "label": {"api": {"GridBagConstraints": [[53, 70], [131, 148]]}}}, {"text": "Howabout getLocation, which returns the coordinate of a component on its parent component, or getLocationOnScreen, which returns the coordinate of the component on the display", "label": {"api": {"getLocation": [[9, 19], [94, 104]], "getLocationOnScreen": [[94, 112]]}}}, {"text": "Usually either the parent component (like a JPanel on which the JButton is sitting) or a location on the screen (such as getLocation would return for a JFrame)", "label": {"api": {"getLocation": [[121, 131]]}}}, {"text": "Could be other things of course, so the best thing you can do, is printing the message and see what caused the exception", "label": {"api": {"printing the message": [[66, 85]]}}}, {"text": "If you want to copy specify elements for you array, you can use Arrays.copyOfRange", "label": {"api": {"Arrays.copyOfRange": [[64, 81]]}}}, {"text": "Just beware of ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[15, 44]]}}}, {"text": "Better yet I would suggest use an List witch can grow automatically, it has also the ability to access elements using (zero-based) index", "label": {"api": {"List": [[34, 37]]}}}, {"text": "You should be careful in case classes is empty as you might get ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[64, 93]]}}}, {"text": "Use Pattern.quote to treat the * like the String * and not the Regex * (that have a special meaning)", "label": {"api": {"Pattern.quote": [[4, 16]]}}}, {"text": "Simply cut up the BufferedImage into separate images using getSubimage(x,y,w,h)", "label": {"api": {"getSubimage(x,y,w,h)": [[59, 78]]}}}, {"text": "For lack of a better way to implement logging for uncaught JAX-RS exceptions, using a catch-all ExceptionMapper as in Other Ideas", "label": {"api": {"ExceptionMapper": [[96, 110]]}}}, {"text": "Just use String#hashCode() method with a null check", "label": {"api": {"String#hashCode()": [[9, 25]]}}}, {"text": "double is a primitive type, but you can use the Java Double class to help", "label": {"api": {"Double": [[53, 58]]}}}, {"text": "As the comments have said, you want to use a Map, of which HashMap is an implementation", "label": {"api": {"HashMap": [[59, 65]]}}}, {"text": "Oh, and to make your code work if you did that, use Long#parseLong(String) to convert a String to a long", "label": {"api": {"Long#parseLong(String)": [[52, 73]]}}}, {"text": "The AWT based SplashScreen does not provide that functionality", "label": {"api": {"SplashScreen": [[14, 25]]}}}, {"text": "However it does offer createGraphics() over which we can paint anything we want", "label": {"api": {"createGraphics()": [[22, 37]]}}}, {"text": "The FileWriter API", "label": {"api": {"FileWriter API": [[4, 17]]}}}, {"text": "Just use the result and place it into a Date using the SimpleDateFormat", "label": {"api": {"Date": [[40, 43], [61, 64]], "SimpleDateFormat": [[55, 70]]}}}, {"text": "As of Java 8 you can use methods like Optional.isPresent and Optional.orElse to handle null in getter chains", "label": {"api": {"Optional.isPresent": [[38, 55]], "Optional.orElse": [[61, 75]]}}}, {"text": "Assuming list is an instance of java.util.List, you're getting this exception because either menuinfo.position is lower than zero or greater than the number of elements in list", "label": {"api": {"java.util.List": [[32, 45]]}}}, {"text": "Use the DatabaseMetaData object to query information, eg getTables(...)", "label": {"api": {"getTables(...)": [[57, 70]]}}}, {"text": "You need to set the RoundingMode for the formatter by setting it using the setRoundingMode() method, as by default, it does not round the value", "label": {"api": {"RoundingMode": [[20, 31], [78, 89]], "setRoundingMode()": [[75, 91]]}}}, {"text": "There are many RoundingModes available", "label": {"api": {"RoundingMode": [[15, 26]]}}}, {"text": "See also http://docs.oracle.com/javase/7/docs/api/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format": [[9, 125]]}}}, {"text": "I also looked at BitSet but this time it seems slightly too low-level, as it only works at the single bit level (although I could potentially use this as a start point for building something with the above sort of API)", "label": {"api": {"BitSet": [[17, 22]]}}}, {"text": "In such cases you can use Thread.UncaughtExceptionHandler to get the exceptions", "label": {"api": {"Thread.UncaughtExceptionHandler": [[26, 56]]}}}, {"text": "It's far easier when trying to match the first four digits, which can be isolated easily using String#substring", "label": {"api": {"String#substring": [[95, 110]]}}}, {"text": "This can then be parsed as an int using Integer#parseInt, or simply compared to another String (if the prefix were a String as well)", "label": {"api": {"Integer#parseInt": [[40, 55]]}}}, {"text": "You can call System.out.flush(); before the exception line", "label": {"api": {"System.out.flush();": [[13, 31]]}}}, {"text": "As of Java 7, there are static methods on Objects that makes implementing hashCode and equals easier", "label": {"api": {"Objects": [[42, 48]]}}}, {"text": "You could have your classes implement the Serializable interface, and then send that over a bytestream", "label": {"api": {"Serializable interface": [[42, 63]]}}}, {"text": "you could use String.format() instead", "label": {"api": {"String.format()": [[14, 28]]}}}, {"text": "Try using getSymbol() from the Currency class", "label": {"api": {"Currency": [[31, 38]]}}}, {"text": "In this case it would probably be simpler to iterate through the file using nextLine then using substring and  toCharArray to create the array", "label": {"api": {"substring": [[96, 104]], "toCharArray": [[111, 121]]}}}, {"text": "I'd suggest poking around some of the static utility classes like Arrays and Collections sooner than later", "label": {"api": {"Arrays": [[66, 71]], "Collections": [[77, 87]]}}}, {"text": "You will also need to switch to DESede/CBC/PKCS5Padding and pass an IVParameterSpec object to your Cipher.init call, specifying the IV value sent from your Java Script code", "label": {"api": {"IVParameterSpec": [[68, 82]]}}}, {"text": "You can do it either using Node.js or Rhino or using ScriptEngine included in the JDK", "label": {"api": {"ScriptEngine": [[53, 64]]}}}, {"text": "You need to use the doubleValue() method to get the double value from a BigDecimal object", "label": {"api": {"doubleValue()": [[20, 32]]}}}, {"text": "Use doubleValue method present in BigDecimal class", "label": {"api": {"doubleValue": [[4, 14]], "BigDecimal": [[34, 43]]}}}, {"text": "Converts this BigDecimal to a double", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "You can convert BigDecimal to double using .doubleValue()", "label": {"api": {".doubleValue()": [[43, 56]]}}}, {"text": "Use clone() -- it is designed for exactly this purpose", "label": {"api": {"clone()": [[4, 10]]}}}, {"text": "There are several ways to make clone() work for your classes", "label": {"api": {"clone()": [[31, 37]]}}}, {"text": "The easiest is to make Fruit implement Cloneable", "label": {"api": {"Cloneable": [[39, 47]]}}}, {"text": "next doesn't consume the end of line, so it'll be consumed in the next nextLine", "label": {"api": {"next": [[0, 3], [66, 69], [71, 74]], "nextLine": [[71, 78]]}}}, {"text": "For example, when you write Y as the second input, you are actually writing Y and pressing enter, which is the '\\n' character, the next will read the Y and the '\\n' will be the input for the nextLine causing it so skip the \"real\" input you wanted", "label": {"api": {"next": [[131, 134], [191, 194]], "nextLine": [[191, 198]]}}}, {"text": "One solution is to change next to nextLine", "label": {"api": {"next": [[26, 29], [34, 37]], "nextLine": [[34, 41]]}}}, {"text": "I would synchronize list at initialization as Oracle says", "label": {"api": {"Oracle says": [[46, 56]]}}}, {"text": "Seems, you use DefaultTableModel, in this case I recommend you to write your own  TableCellEditor for editing your custom column", "label": {"api": {"TableCellEditor": [[82, 96]]}}}, {"text": "the unmarshal callback methods (afterUnmarshal in my case) annotated in my binding classes are never called when I unmarshal my objects from a DOM document instance", "label": {"api": {"unmarshal callback methods": [[4, 29]]}}}, {"text": "The problem seems to be in the org.eclipse.persistence.oxm.XMLUnmarshaller instance used by the Binder", "label": {"api": {"org.eclipse.persistence.oxm.XMLUnmarshaller": [[31, 73]]}}}, {"text": "Looking through the semaphore documentation http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html I'm not seeing just that but I'm not familiar with all the terminology", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html": [[44, 119]]}}}, {"text": "For example CountDownLatch can wait while all load threads finished their works", "label": {"api": {"CountDownLatch": [[12, 25]]}}}, {"text": "String.split() and Integer.parseInt() are your friends", "label": {"api": {"String.split()": [[0, 13]], "Integer.parseInt()": [[19, 36]]}}}, {"text": "You can have a DocumentListener", "label": {"api": {"DocumentListener": [[15, 30]]}}}, {"text": "You should read up on the javadoc on java.awt.Graphics to find out how to draw other stuff, maybe image sprites or lines for the direction or something", "label": {"api": {"java.awt.Graphics": [[37, 53]]}}}, {"text": "Since you don't want to use drawString() directly, java.awt.font.TextLayout is probably the best option for rendering text", "label": {"api": {"java.awt.font.TextLayout": [[51, 74]]}}}, {"text": "Try a SynchronousQueue instead of your own Buffers class", "label": {"api": {"SynchronousQueue": [[6, 21]]}}}, {"text": "There is HttpURLConnection.setFixedLengthStreamingMode(long) method", "label": {"api": {"HttpURLConnection.setFixedLengthStreamingMode(long)": [[9, 59]]}}}, {"text": "See Hashtable javadoc and the section about generics in the oracle java documentation for more details", "label": {"api": {"Hashtable javadoc": [[4, 20]]}}}, {"text": "Try creating the ByteBuffer with ByteBuffer.allocateDirect and then use byteBuffer.put(..) if you want to set any initial data", "label": {"api": {"ByteBuffer.allocateDirect": [[33, 57]]}}}, {"text": "You need to initialize job array before trying to access it, now it's like writing null.start, which of course causes NullPointerException", "label": {"api": {"NullPointerException": [[118, 137]]}}}, {"text": "See the Proxy documentation", "label": {"api": {"the Proxy documentation": [[4, 26]]}}}, {"text": "Read the Process javadoc and ProcessBuilder javadoc on how to set it up, and start it", "label": {"api": {"Process javadoc": [[9, 23]], "ProcessBuilder javadoc": [[29, 50]]}}}, {"text": "If you want to copy the array, you can use Arrays#copyOf", "label": {"api": {"Arrays#copyOf": [[43, 55]]}}}, {"text": "That prefix should only be used in conjunction with a Spring ResourceLoader, but not with a standard Java classloader", "label": {"api": {"classloader": [[106, 116]]}}}, {"text": "Use System.out.printf to format your text to be displayed on the console", "label": {"api": {"System.out.printf": [[4, 20]]}}}, {"text": "From the Java API", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "HttpPost is likely a POST request, aka the doPost(request,response) method, not the doGet(request,response) method", "label": {"api": {"doPost(request,response)": [[43, 66]], "doGet(request,response)": [[84, 106]]}}}, {"text": "System.gc() is a hint to help notify the garbage collector when a good time to garbage collect might be", "label": {"api": {"System.gc()": [[0, 10]]}}}, {"text": "Every call to the readLine() method consumes the next line of input", "label": {"api": {"the readLine() method": [[14, 34]]}}}, {"text": "You can use SequenceInputStream for concatenation of FileInputStreams", "label": {"api": {"SequenceInputStream": [[12, 30]]}}}, {"text": "To see all log files File.listFiles(FileFilter) can be used", "label": {"api": {"File.listFiles(FileFilter)": [[21, 46]]}}}, {"text": "You can call getSource on the ActionEvent to find out the source of the event", "label": {"api": {"getSource": [[13, 21]], "ActionEvent": [[30, 40]]}}}, {"text": "Call frame.setDefaultCloseOperation(DISPOSE_ON_CLOSE) when constructing the frame", "label": {"api": {"frame.setDefaultCloseOperation(DISPOSE_ON_CLOSE)": [[5, 52]]}}}, {"text": "In the actionPerformed method, call frame.dispose() & the JVM should end as long as there are no other non-daemon threads running", "label": {"api": {"frame.dispose()": [[36, 50]]}}}, {"text": "Your Comparator would call split to separate the semester and year", "label": {"api": {"Comparator": [[5, 14]]}}}, {"text": "In this case, the desired order is the natural (alphabetical) order, so you can use the Arrays.sort(Object\\[\\]) method", "label": {"api": {"Arrays.sort(Object\\[\\])": [[88, 110]]}}}, {"text": "If the desired order does not match the natural order, you can implement a Comparator and use the Arrays.sort(String\\[\\], Comparator<String>) method", "label": {"api": {"Comparator": [[75, 84], [122, 131]], "Arrays.sort(String\\[\\], Comparator<String>)": [[98, 140]]}}}, {"text": "An example for the Comparator implementation (just to show how it could work)", "label": {"api": {"Comparator": [[19, 28]]}}}, {"text": "Perhaps, if the dat avalues are Comparable you can use the compareTo(...) method", "label": {"api": {"compareTo(...)": [[59, 72]]}}}, {"text": "You'd better create a java.util.Random object and reuse it", "label": {"api": {"java.util.Random": [[22, 37]]}}}, {"text": "The usual approach would be to use a Map to accumulate frequencies", "label": {"api": {"Map": [[37, 39]]}}}, {"text": "Implementing the approach with try-catch would entail catching an ArrayIndexOutOfBoundsException, which is an unchecked exception (i.e", "label": {"api": {"ArrayIndexOutOfBoundsException": [[66, 95]]}}}, {"text": "a subclass of RuntimeException)", "label": {"api": {"RuntimeException": [[14, 29]]}}}, {"text": "Use System.identityHashCode(..) for this kind of research", "label": {"api": {"System.identityHashCode(..)": [[4, 30]]}}}, {"text": "If you check the JMenuItem API, you will see that it is possible to fire an event for key pressed ( with fireMenuKeyPressed(MenuKeyEvent event))", "label": {"api": {"JMenuItem": [[17, 25]]}}}, {"text": "To do this yourself, first split the string manually and then pass it to Runtime#exec", "label": {"api": {"Runtime#exec": [[73, 84]]}}}, {"text": "From the JavaDoc of WatchService", "label": {"api": {"the JavaDoc of WatchService": [[5, 31]]}}}, {"text": "You are only calling watcher.take() once", "label": {"api": {"watcher.take()": [[21, 34]]}}}, {"text": "To watch for further events, you must call watchKey.reset() after consuming the WatchEvents", "label": {"api": {"watchKey.reset()": [[43, 58]]}}}, {"text": "For native metadata format, see GIF metadata, for standard (format neutral) metadata format, see standard metadata", "label": {"api": {"GIF metadata": [[32, 43]], "standard metadata": [[97, 113]]}}}, {"text": "You must annotate the field with @Lob", "label": {"api": {"@Lob": [[33, 36]]}}}, {"text": "And how this object is printed is solely handled by its class' toString method, which prints the date in this format", "label": {"api": {"toString": [[63, 70]]}}}, {"text": "If you wish to print this object in a format of your choice you should use a DateFormat", "label": {"api": {"DateFormat": [[77, 86]]}}}, {"text": "To get output for a specific timezone you have to explicitly tell it to the DateFormat object (see below)", "label": {"api": {"DateFormat": [[76, 85]]}}}, {"text": "You have for example URLEncoder in the JDK", "label": {"api": {"URLEncoder": [[21, 30]]}}}, {"text": "I was thinking about something like the Servlet#destroy method", "label": {"api": {"Servlet#destroy": [[40, 54]]}}}, {"text": "I start several bash script processes using the Process class in Java", "label": {"api": {"Process": [[48, 54]]}}}, {"text": "You can use EnumSet to group various enums without creating a separate Enum class", "label": {"api": {"EnumSet": [[12, 18]], "Enum": [[12, 15], [71, 74]]}}}, {"text": "array[width][height][2]) or you can use a 2D array and store Point (http://docs.oracle.com/javase/7/docs/api/java/awt/Point.html) objects in it", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/Point.html": [[68, 127]]}}}, {"text": "For updating your panel from code try to use SwingWorker, it can update UI and continue background process", "label": {"api": {"SwingWorker": [[45, 55]]}}}, {"text": "Or you can try to use Executors for background search process and updating UI", "label": {"api": {"Executors": [[22, 30]]}}}, {"text": "Rather than putting the username and password in the URL, you could register an Authenticator that is able to provide the credentials when required", "label": {"api": {"Authenticator": [[80, 92]]}}}, {"text": "Array is  Object, and as you know, each object has toString method", "label": {"api": {"toString": [[51, 58]]}}}, {"text": "The default toString displays the class name representation, then adds @ and then the hashcode", "label": {"api": {"toString": [[12, 19]]}}}, {"text": "Most likely the class Transaction834 doesn't specify the XmlRootElement annotation (probably because it's a top-level type rather than an anonymous type)", "label": {"api": {"XmlRootElement": [[57, 70]]}}}, {"text": "Perhaps if you are unsure of the length of your task, you should make your progress bar indeterminate", "label": {"api": {"indeterminate": [[88, 100]]}}}, {"text": "If you want something analogous to C++'s std::vector, I would start by looking at the various classes that implement the List interface (http://docs.oracle.com/javase/7/docs/api/java/util/List.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/List.html": [[137, 196]]}}}, {"text": "Probably the most commonly-used List is ArrayList, which has all the normal operations you would expect - add, get, size, iterator, etc", "label": {"api": {"ArrayList": [[40, 48]]}}}, {"text": "Alternatively there is LinkedList, which is useful in its own way, depending on what exactly you're trying to achieve", "label": {"api": {"LinkedList": [[23, 32]]}}}, {"text": "The problem is that the ObjectInputStream.readObject() method is defined to return an Object, so you cannot assign its return value to a variable declared of type Vector", "label": {"api": {"ObjectInputStream.readObject()": [[24, 53]]}}}, {"text": "We need more info to conclusively answer, but check out the documentation for next()", "label": {"api": {"the documentation for next()": [[56, 83]]}}}, {"text": "Take a look at String.split()", "label": {"api": {"String.split()": [[15, 28]]}}}, {"text": "You can use the NIO charset classes Charset, CharsetEncoder, and CharsetDecoder with the java.io classes OutputStreamWriter and InputStreamReader", "label": {"api": {"OutputStreamWriter": [[105, 122]], "InputStreamReader": [[128, 144]]}}}, {"text": "I'm constructing a nice Javafx XYChart (constructed, I should say) and everything is going great, I found all the help I could possibly want for the most part with the help of the Oracle CSS styling guide and made a nice looking graph (which I would post if i had 10 reputation >_> )", "label": {"api": {"Oracle CSS styling guide": [[180, 203]]}}}, {"text": "The Random class's nextDouble method doesn't accept any arguments, so the second call will not compile", "label": {"api": {"Random class's nextDouble method": [[4, 35]]}}}, {"text": "It is a method call with parameters (900 - 1) + 1) + 1 and nextDouble() doesn't accept any parameter hence your error", "label": {"api": {"nextDouble()": [[59, 70]]}}}, {"text": "You can use any Set implementation, but because all toInstance bindings are implicitly singletons, you can reduce some risk of modification if you use Guava's ImmutableSet or at least Collections.unmodifiableSet", "label": {"api": {"Collections.unmodifiableSet": [[184, 210]]}}}, {"text": "add(E) function of a collection returns boolean", "label": {"api": {"add(E)": [[0, 5]]}}}, {"text": "Try to use FocusListener on your JComboBox", "label": {"api": {"FocusListener": [[11, 23]]}}}, {"text": "You can use Thread.join() to basically block one thread until another thread terminates", "label": {"api": {"Thread.join()": [[12, 24]]}}}, {"text": "via a CountDownLatch)", "label": {"api": {"CountDownLatch": [[6, 19]]}}}, {"text": "In Java SE 7 you could use CountDownLatch", "label": {"api": {"CountDownLatch": [[27, 40]]}}}, {"text": "Good thing that comes with using of CountDownLatch is that you can initialize it with certain number of required countdowns, so you can wait for a set of threads", "label": {"api": {"CountDownLatch": [[36, 49]]}}}, {"text": "Also, another approach is CyclicBarrier", "label": {"api": {"CyclicBarrier": [[26, 38]]}}}, {"text": "If you really want to remove items while printing the LinkedList, you should use an Iterator", "label": {"api": {"LinkedList": [[54, 63]], "Iterator": [[84, 91]]}}}, {"text": "Look at http://docs.oracle.com/javase/7/docs/api/java/lang/String.html and http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html  and post again if you need more help", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[8, 69]], "http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html": [[75, 137]]}}}, {"text": "Use Iterator instead of looping", "label": {"api": {"Iterator": [[4, 11]]}}}, {"text": "java.lang.Integer, a reference type, is a wrapper around the primitive int", "label": {"api": {"java.lang.Integer": [[0, 16]]}}}, {"text": "If you have the URL of the download the only thing you need is to perform a client request against that URL", "label": {"api": {"URL": [[16, 18], [104, 106]]}}}, {"text": "First thing you should try to be sure that the URL you have is the one that will give you the expected results is try to paste it in a new browser window and verify that the download starts", "label": {"api": {"URL": [[47, 49]]}}}, {"text": "Then, if you want to perform that download through Java you can do very easily using the URL and URLConnection (HttpURLConnection in this case) classes", "label": {"api": {"URL": [[89, 91], [97, 99], [116, 118]], "URLConnection": [[97, 109], [116, 128]], "HttpURLConnection": [[112, 128]]}}}, {"text": "If the \"TEXT\" string is an unique placeholder for your replacement, you could simply use String replace method, in this way", "label": {"api": {"replace": [[55, 61], [96, 102]]}}}, {"text": "If you take a look to MetalLookAndFeel class there are several static methods but nothing like", "label": {"api": {"MetalLookAndFeel": [[22, 37]]}}}, {"text": "Anyway your best chance is harcoding the names since the only thing you can certainly do to determine if a class is a theme for Metal look and feel is asking if it's an instance of MetalTheme but that gives you almost nothing to achieve your target", "label": {"api": {"MetalTheme": [[181, 190]]}}}, {"text": "By default, next uses whitespaces as word delimiters so any addresses containing these characters will cause the input to be passed through to the next Scanner input statement, namely nextInt in this case", "label": {"api": {"next": [[12, 15], [147, 150], [184, 187]]}}}, {"text": "Therefore use nextLine which reads the entire line input", "label": {"api": {"next": [[14, 17]]}}}, {"text": "Javadoc here  I'm guessing maybe this is a windows share", "label": {"api": {"Javadoc here": [[0, 11]]}}}, {"text": "Set a timeout value with setReadTimeout", "label": {"api": {"setReadTimeout": [[25, 38]]}}}, {"text": "using DefaultTableModel with JTable you should be able to use model.removeRow(int row) function to remove A row from JTable", "label": {"api": {"DefaultTableModel": [[6, 22]]}}}, {"text": "jav.util.Properties has propertyNames()", "label": {"api": {"propertyNames()": [[24, 38]]}}}, {"text": "There is also stringPropertyNames()", "label": {"api": {"stringPropertyNames()": [[14, 34]]}}}, {"text": "ResourceBundle is what I've used previously for properties files", "label": {"api": {"ResourceBundle": [[0, 13]]}}}, {"text": "If you check out the API you should be able to find how to create a ResourceBundle for you file", "label": {"api": {"ResourceBundle": [[68, 81]]}}}, {"text": "See the Applet.getCodeBase() & getDocumentBase() methods", "label": {"api": {"Applet.getCodeBase()": [[8, 27]], "getDocumentBase()": [[31, 47]]}}}, {"text": "For updating UI from your code try to use SwingWorker, it can update UI while background process running", "label": {"api": {"SwingWorker": [[42, 52]]}}}, {"text": "Or you can try to use Executors for background process and updating UI from EDT", "label": {"api": {"Executors": [[22, 30]]}}}, {"text": "Java has the Preferences API to help when you need to store data", "label": {"api": {"Preferences API": [[13, 27]]}}}, {"text": "The under-workings of the Preferences API is as mysterious as JWS, thus they are really a perfect fit", "label": {"api": {"Preferences API": [[26, 40]]}}}, {"text": "For updating UI from your code try to use SwingWorker, it can update UI while background process running", "label": {"api": {"SwingWorker": [[42, 52]]}}}, {"text": "Or you can try to use Executors for background process and updating UI from EDT", "label": {"api": {"Executors": [[22, 30]]}}}, {"text": "You might want to consider the finalize() method that is available on java.lang.Object", "label": {"api": {"finalize()": [[31, 40]]}}}, {"text": "In general, it is best to avoid finalizers because the JVM doesn't guarantee that finalize() is ever called on any object, however when there is a need to clean up native (usually non-Java) resources, a finalizer can be useful", "label": {"api": {"finalize()": [[82, 91]]}}}, {"text": "Or pass an instance of CompareByValue as parameter to the sort() method", "label": {"api": {"sort()": [[58, 63]]}}}, {"text": "Because KeyListener is only an interface, you can test it by simply calling the method you want to test", "label": {"api": {"KeyListener": [[8, 18]]}}}, {"text": "The one iffy part is the KeyEvent that gets passed in", "label": {"api": {"KeyEvent": [[25, 32]]}}}, {"text": "That will make it very easy to create a KeyEvent for your needs", "label": {"api": {"KeyEvent": [[40, 47]]}}}, {"text": "Put as little code as possible in the KeyListener implementation", "label": {"api": {"KeyListener": [[38, 48]]}}}, {"text": "Only extract what you need from the KeyEvent and pass it into your class with game logic in it", "label": {"api": {"KeyEvent": [[36, 43]]}}}, {"text": "Now you don't even need to test the KeyListener anymore/much, you just test the method that it calls", "label": {"api": {"KeyListener": [[36, 46]]}}}, {"text": "My first hunch would be NaN is being introduced in Math.pow as has a huge list of conditions that will make it return NaN - see what the actual input values are", "label": {"api": {"Math.pow": [[51, 58]]}}}, {"text": "As a side note, a String in java is NOT a char[] - it's a String object", "label": {"api": {"String": [[18, 23], [58, 63]]}}}, {"text": "This can take MANY forms, I recommend checking out the RandomaccessFile api to see exactly what methods are available, and what form you data has to be in to write it", "label": {"api": {"RandomaccessFile api": [[55, 74]]}}}, {"text": "However, since you already have a Class<T> parameter in your constructor, you can use it to get the appropriate constructor using Class#getConstructor method", "label": {"api": {"Class#getConstructor": [[130, 149]]}}}, {"text": "And then instantiate the object using Constructor#newInstance method passing appropriate argument", "label": {"api": {"Constructor#newInstance": [[38, 60]]}}}, {"text": "String has indexOf(String) which will allow you to find \"See also > \", and substring(int, int) with which you can extract the first and last part, by computing the indices", "label": {"api": {"indexOf(String)": [[11, 25]], "substring(int, int)": [[75, 93]]}}}, {"text": "I would recommend checking out some alternative data structures such as an ArrayList (http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html) which will monitor size on its own so that you don't have to worry about space constraints", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html": [[86, 150]]}}}, {"text": "If for some reason you do need to resize your array, you want to use the Arrays.copyOf method (http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html) to create a secondary array that is resized to your need and then populate it with the values from the first array", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html": [[95, 156]]}}}, {"text": "If you want to use internal JDK classes, use java.util.Date", "label": {"api": {"java.util.Date": [[45, 58]]}}}, {"text": "You can use BigInteger.pow() to take a large exponent", "label": {"api": {"BigInteger.pow()": [[12, 27]]}}}, {"text": "However, you can then use BigInteger.modPow(BigInteger exponent, BigInteger m) to raise a BigInteger to another BigInteger as a power, module a third BigInteger", "label": {"api": {"BigInteger.modPow(BigInteger exponent, BigInteger m)": [[26, 77]]}}}, {"text": "Integer.MAX_VALUE is 2147483647", "label": {"api": {"Integer.MAX_VALUE is 2147483647": [[0, 30]]}}}, {"text": "Long.MAX_VALUE is 9223372036854775807, a little over 9 quintillion", "label": {"api": {"Long.MAX_VALUE is 9223372036854775807": [[0, 36]]}}}, {"text": "If you need more, look into using BigInteger", "label": {"api": {"BigInteger": [[34, 43]]}}}, {"text": "I suspect that the problem is that your equals method is not overriding Object's equals method, which takes an Object as a parameter", "label": {"api": {"Object's equals method": [[72, 93]]}}}, {"text": "In this case, the equals method in Object is not overridden, so when HashSet (eventually) calls it, it calls Object's equals method, which compares references to see if they are the same", "label": {"api": {"Object's equals method": [[109, 130]]}}}, {"text": "You could create a Proxy and retry in the handler invoke method", "label": {"api": {"Proxy": [[19, 23]], "handler": [[42, 48]]}}}, {"text": "Your answer is in the Matcher#appendReplacement documentation", "label": {"api": {"Matcher#appendReplacement": [[22, 46]]}}}, {"text": "Since Java 9 Matcher.replaceAll", "label": {"api": {"Matcher.replaceAll": [[13, 30]]}}}, {"text": "On the oracle docs there is a quote confirming some of my guesses", "label": {"api": {"oracle docs": [[7, 17]]}}}, {"text": "You could do string to Method", "label": {"api": {"Method": [[23, 28]]}}}, {"text": "Also, by default, String.split() does not return trailing empty fields, this sounds like it's what you want for this assignment, but check out http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#split%28java.lang.String,%20int%29 for more information on your other options here", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#split%28java.lang.String,%20int%29": [[143, 239]]}}}, {"text": "read() returns charcode of the first input symbol", "label": {"api": {"read()": [[0, 5]]}}}, {"text": "You can use String.format method", "label": {"api": {"String.format": [[12, 24]]}}}, {"text": "Use a CyclicBarrier, or a Phaser if you need multiple stages with different numbers of threads in each one", "label": {"api": {"CyclicBarrier": [[6, 18]], "Phaser": [[26, 31]]}}}, {"text": "In your case, switching to using Math.cbrt will probably yield a good enough answer", "label": {"api": {"Math.cbrt": [[33, 41]]}}}, {"text": "CopyOnWriteArrayList is a mutable yet threadsafe list because it duplicates the internal array on updates", "label": {"api": {"CopyOnWriteArrayList": [[0, 19]]}}}, {"text": "ConcurrentHashMap implements similar ideas on a much more complicated structure", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "AWTEventMulticaster achieves similar goals, but duplicates the absolute minimum", "label": {"api": {"AWTEventMulticaster": [[0, 18]]}}}, {"text": "See the javax.tools api", "label": {"api": {"See the javax.tools api": [[0, 22]]}}}, {"text": "I think you're looking for JTabbedPane.html.setSelectedIndex(int)", "label": {"api": {"JTabbedPane.html.setSelectedIndex(int)": [[27, 64]]}}}, {"text": "The easiest way would be to use an ExecutorService and submit your tasks as a Runnable or Callable", "label": {"api": {"ExecutorService": [[35, 49]]}}}, {"text": "If all what you want is to add 5 minutes to the time, you can use SimpleDateFormat and Calendar", "label": {"api": {"SimpleDateFormat": [[66, 81]], "Calendar": [[87, 94]]}}}, {"text": "You could use a RandomAccessFile to reset the position of the reader", "label": {"api": {"RandomAccessFile": [[16, 31]]}}}, {"text": "You are building a BigDecimal object by using the constructor which takes a double", "label": {"api": {"the constructor which takes a double": [[46, 81]]}}}, {"text": "Try using another constructor which takes a String for example", "label": {"api": {"another constructor": [[10, 28]]}}}, {"text": "Use the sort method that takes a Comparator", "label": {"api": {"the sort method that takes a Comparator": [[4, 42]]}}}, {"text": "Have your Balloons class implement Comparable and just use the normal sort", "label": {"api": {"Comparable": [[35, 44]], "use the normal sort": [[55, 73]]}}}, {"text": "Just make sure that the isCellEditable() method of the table model of the table returns false", "label": {"api": {"isCellEditable() method of the table model": [[24, 65]]}}}, {"text": "For more info, check the documentation at http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(T[], java.util.Comparator)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(T[], java.util.Comparator)": [[42, 135]]}}}, {"text": "Hence, unless you're doing anything daft in between I suggest that based on the XMLGregorianCalendar docs you set the timezone to 0 (UTC)", "label": {"api": {"based on the XMLGregorianCalendar docs": [[67, 104]]}}}, {"text": "You can call isArray() on the Class<T> object of the field's type", "label": {"api": {"isArray()": [[13, 21]]}}}, {"text": "To get the type of the element, call getComponentType method", "label": {"api": {"getComponentType": [[37, 52]]}}}, {"text": "Looking at the documentation of the CSS class, we see that it lists all of the CSS properties it supports", "label": {"api": {"documentation of the CSS class": [[15, 44]]}}}, {"text": "You can use PhantomReference - it is a way how to track objects eligible for being reclaimed without the performance penalty of finalization", "label": {"api": {"PhantomReference": [[12, 27]]}}}, {"text": "You could use the Number class for example", "label": {"api": {"Number": [[18, 23]]}}}, {"text": "For this reason, BigInteger provides a modPow(BigInteger, BigInteger) method which appears to do what you want", "label": {"api": {"modPow(BigInteger, BigInteger)": [[39, 68]]}}}, {"text": "Check out java.math.BigDecimal", "label": {"api": {"java.math.BigDecimal": [[10, 29]]}}}, {"text": "Use String.equals instead", "label": {"api": {"String.equals": [[4, 16]]}}}, {"text": "See javadoc for CipherOutputStream", "label": {"api": {"javadoc for CipherOutputStream": [[4, 33]]}}}, {"text": "As describe in the API, you should write", "label": {"api": {"API": [[19, 21]]}}}, {"text": "Consider using java.io.File.separator if you ever display the path to the user", "label": {"api": {"java.io.File.separator": [[15, 36]]}}}, {"text": "You can make use of StackTraceElement", "label": {"api": {"StackTraceElement": [[20, 36]]}}}, {"text": "Order of elements in StackTraceElement array", "label": {"api": {"StackTraceElement": [[21, 37]]}}}, {"text": "InputStreamReader class does not have readLine method", "label": {"api": {"InputStreamReader": [[0, 16]]}}}, {"text": "Scanner is a better alternative to collect user inputs", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "As you may see in InputStreamReader javadoc, there's no readLine method", "label": {"api": {"InputStreamReader": [[18, 34]]}}}, {"text": "Maybe you want to use the readLine method from your BufferedReader read variable since BufferedReader has this method", "label": {"api": {"BufferedReader": [[52, 65], [87, 100]]}}}, {"text": "If you want to have completely immutable collection I would work with List that is declared as final and then create a new separate List, populate it and then use method public static  List unmodifiableList(List list) to assig it to your final list", "label": {"api": {"public static  List unmodifiableList(List list)": [[170, 216]]}}}, {"text": "It's important to know and understand that the <f:convertNumber> tag uses DecimalFormat under the covers", "label": {"api": {"DecimalFormat": [[74, 86]]}}}, {"text": "You can find all pattern characters in its javadoc", "label": {"api": {"its javadoc": [[39, 49]]}}}, {"text": "It seems that you expected that the DecimalFormat pattern characters , and", "label": {"api": {"DecimalFormat": [[36, 48]]}}}, {"text": "Basically, the pattern character , tells DecimalFormat to print the \"grouping separator\" as specified by the given locale and, equivalently, the pattern character", "label": {"api": {"DecimalFormat": [[41, 53]]}}}, {"text": "tells DecimalFormat to print the \"decimal separator\" as specified by the given locale", "label": {"api": {"DecimalFormat": [[6, 18]]}}}, {"text": "Again, see the DecimalFormat javadoc as linked before", "label": {"api": {"DecimalFormat": [[15, 27]]}}}, {"text": "The compareAndSet operation is going to fail (and return false) if the original volatile value has been changed concurrently after the read, forcing the code to continue with the loop", "label": {"api": {"compareAndSet": [[4, 16]]}}}, {"text": "Implement a Comparator<Product> and use Collections.sort(List<T>, Comparator<T>) to sort the List according to a custom comparison criteria", "label": {"api": {"Comparator<Product>": [[12, 30]], "Collections.sort(List<T>, Comparator<T>)": [[40, 79]]}}}, {"text": "Or iterate to filter it while adding only Products to an ordered data structure such as a TreeSet<Product>, providing your own Comparator<Product>", "label": {"api": {"Comparator<Product>": [[127, 145]]}}}, {"text": "This is implicitly allowed by the JDBC specification, because it says", "label": {"api": {"says": [[65, 68]]}}}, {"text": "Other solutions are explicitly specifying the column names or the column positions you want returned using the alternate methods accepting a String[] or int[] (although I am not 100% sure how the PostgreSQL driver handles that)", "label": {"api": {"String[]": [[141, 148]], "int[]": [[153, 157]]}}}, {"text": "Use a StrackTraceElement", "label": {"api": {"StrackTraceElement": [[6, 23]]}}}, {"text": "When comparing Strings, you should use the String#equals() method, not the == operator", "label": {"api": {"String#equals()": [[43, 57]]}}}, {"text": "You could first create a Calendar for the timestamps, and add() dateFrom by 45 days", "label": {"api": {"add()": [[58, 62]]}}}, {"text": "Then you can use the before() method to check if dateFrom is before dateTo", "label": {"api": {"before()": [[21, 28]]}}}, {"text": "Look into the AffineTransform class, which provides easy to use methods for various tranformations, including rotation", "label": {"api": {"AffineTransform": [[14, 28]]}}}, {"text": "Then construct a Point2D using your (x, y) values and apply the AffineTransform to get a new Point2D that is rotated", "label": {"api": {"AffineTransform": [[64, 78]], "Point2D": [[17, 23], [93, 99]]}}}, {"text": "You can apply the AffineTransform on a Graphics2D object to cut down on similar/duplicate code", "label": {"api": {"AffineTransform": [[18, 32]]}}}, {"text": "You might also consider using a JFileChooser to select the file if you want the user to choose the PDF during runtime", "label": {"api": {"JFileChooser": [[32, 43]]}}}, {"text": "To let this be called by your buttons, simply add an ActionListener for both your site and forum button as such", "label": {"api": {"ActionListener": [[53, 66]]}}}, {"text": "I haven't used this type but it seems from the HttpExchange doc that attributes are not request parameters", "label": {"api": {"HttpExchange doc": [[47, 62]]}}}, {"text": "The information is likely accessible via the getQueryString() method", "label": {"api": {"getQueryString()": [[45, 60]]}}}, {"text": "You can implement an error listener using Connection.setExceptionListener(ExceptionListener)", "label": {"api": {"Connection.setExceptionListener(ExceptionListener)": [[42, 91]]}}}, {"text": "You want to use Scanner", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "Arrays don't override toString(), so you're seeing the implementation in Object", "label": {"api": {"implementation in Object": [[55, 78]]}}}, {"text": "Use Arrays.toString(byte[]) to get a string representation which actually looks reasonable - although you may find a hex conversion easier to read", "label": {"api": {"Arrays.toString(byte[])": [[4, 26]]}}}, {"text": "The asSubclass method returns a Class<", "label": {"api": {"The asSubclass method": [[0, 20]]}}}, {"text": "Since split() accepts a regex as argument, you can directly do this", "label": {"api": {"split()": [[6, 12]]}}}, {"text": "You could use a BufferedReader which includes the convenient readLine() method and wont load the entire contents of the file into memory e.g", "label": {"api": {"BufferedReader": [[16, 29]], "readLine()": [[61, 70]]}}}, {"text": "Although not the ideal solution, you can still set a preferred size in pixels and retain scrolling capabilities if you use a JTextPane instance instead of a JTextArea one", "label": {"api": {"JTextPane": [[125, 133]]}}}, {"text": "Plus, JTextPane automatically wraps lines and does so at word boundaries (which is what you seem to be after)", "label": {"api": {"JTextPane": [[6, 14]]}}}, {"text": "When a string is interned, all references to the interned string share the same payload, so the extra memory per additional instance of an interned string is the size of a reference (i.e", "label": {"api": {"interned": [[17, 24], [49, 56], [139, 146]]}}}, {"text": "To do easy comparisons, your nodes should implement Comparable", "label": {"api": {"Comparable": [[52, 61]]}}}, {"text": "To leave the old ArrayList alone, copy the existing ArrayList and assign it to tmp", "label": {"api": {"copy the existing ArrayList": [[34, 60]]}}}, {"text": "To copy arrays, you could use the System.arraycopy(...) method (System API)", "label": {"api": {"System API": [[64, 73]]}}}, {"text": "The problem is that the format method takes a numeric value, not a String", "label": {"api": {"format": [[24, 29]]}}}, {"text": "The javadoc of the Scanner constructor you're using says", "label": {"api": {"javadoc of the Scanner constructor": [[4, 37]]}}}, {"text": "Use ImageIcon for button with tick image", "label": {"api": {"ImageIcon": [[4, 12]]}}}, {"text": "See BigInteger for a class from the JDK that works like this", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "For example TableModel is an interface meant to provide access to a table's data, AbstractTableModel is an abstract class that provides implementations for some simple accounting methods in the interface, and DefaultTableModel is a concrete class that uses, as data storage, an ArrayList", "label": {"api": {"TableModel": [[12, 21], [90, 99], [216, 225]], "AbstractTableModel": [[82, 99]], "DefaultTableModel": [[209, 225]]}}}, {"text": "From the code snippet you have given I'd guess the currentTime.toString() and dateTwo.toString() are in different formats, the first is the number of milliseconds since epoch and the second is in the \"dow mon dd hh:mm:ss zzz yyyy\" format which probably makes no sense in a Lucene range query", "label": {"api": {"dow mon dd hh:mm:ss zzz yyyy": [[201, 228]]}}}, {"text": "See this link as a reference about it", "label": {"api": {"this link": [[4, 12]]}}}, {"text": "Because the default ArrayList has no ArrayList(E[] array) constructor", "label": {"api": {"ArrayList": [[20, 28], [37, 45]]}}}, {"text": "Because the List returned by Arrays.asList() is backed by the given array", "label": {"api": {"Arrays.asList()": [[29, 43]]}}}, {"text": "If you want to schedule something to run every minute, I would have a look at the ScheduledThreadPoolExecutor class, or simply a Timer", "label": {"api": {"ScheduledThreadPoolExecutor": [[82, 108]], "Timer": [[129, 133]]}}}, {"text": "You can simply provide the encoding in the String constructor", "label": {"api": {"the String constructor": [[39, 60]]}}}, {"text": "If you're using Java 6 or earlier, you'll need to use the Guava field Charsets.ISO_8859_1 instead of StandardCharsets.ISO_8859_1 (which was only introduced in Java 7)", "label": {"api": {"StandardCharsets.ISO_8859_1": [[101, 127]]}}}, {"text": "To imitate this, you can put all the numbers from min to max in a data structure like LinkedList or ArrayDeque where you can easily add/remove items from both ends, then you'd print the contents in order, and shift the first entry to the end", "label": {"api": {"LinkedList": [[86, 95]], "ArrayDeque": [[100, 109]]}}}, {"text": "Calendar.getTime() returns a java Date instance which represents the number of milliseconds from the epoch January 1, 1970, 00:00:00 GMT", "label": {"api": {"Date": [[34, 37]]}}}, {"text": "Calling toString() on a Date instance will print the date based on the timezone configured on the server", "label": {"api": {"Date": [[24, 27]]}}}, {"text": "Is there a particular reason you're not just using Scanner", "label": {"api": {"Scanner": [[51, 57]]}}}, {"text": "As discussed in the info for embedded-resource, you can use getResource() to obtain a URL for each file", "label": {"api": {"getResource()": [[60, 72]]}}}, {"text": "For a non-vendor specific solution, since JAX-RS 2.0 you can use ResourceInfo", "label": {"api": {"ResourceInfo": [[65, 76]]}}}, {"text": "You want to use both StandardOpenOption.TRUNCATE_EXISTING and StandardOpenOption.CREATE options together", "label": {"api": {"StandardOpenOption.TRUNCATE_EXISTING": [[21, 56]]}}}, {"text": "The doGet() method is the right place to put your code in", "label": {"api": {"doGet()": [[4, 10]]}}}, {"text": "The response is the HttpServletResponse passed to your doGet() method", "label": {"api": {"doGet()": [[55, 61]]}}}, {"text": "And in your doGet() method you check the URL parameter from the HttpServletRequest", "label": {"api": {"doGet()": [[12, 18]]}}}, {"text": "Take a look at the Color class", "label": {"api": {"Color": [[19, 23]]}}}, {"text": "Keeping this in mind, doInBackground() method runs in another different thread that's not the EDT which is ok", "label": {"api": {"doInBackground()": [[22, 37]]}}}, {"text": "Add a JLabel to this panel before executing your SwingWorker and update its text using publish() and process() methods instead", "label": {"api": {"publish()": [[87, 95]], "process()": [[101, 109]]}}}, {"text": "Both process() and done() methods take place in the EDT so it's safe make GUI updates there", "label": {"api": {"process()": [[5, 13]], "done()": [[19, 24]]}}}, {"text": "chunks) is used inside doInBackground() to send data to process(List<V> chunks) to process them in the GUI thread", "label": {"api": {"doInBackground()": [[23, 38]], "process(List<V> chunks)": [[56, 78]]}}}, {"text": "You can use in.nextLine (http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine()) or use [BufferedReader](http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html) instead, and you can call the readLine() method", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#nextLine()": [[25, 98]], "http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html": [[125, 192]]}}}, {"text": "An alternative is not to synchronize, but to replace the datatype for count with an AtomicInteger", "label": {"api": {"AtomicInteger": [[84, 96]]}}}, {"text": "One is to call iterator()", "label": {"api": {"iterator()": [[15, 24]]}}}, {"text": "Then call next() on the Iterator", "label": {"api": {"Iterator": [[24, 31]]}}}, {"text": "Alternatively, you can call toArray then an element from that array (bound by the size of it)", "label": {"api": {"toArray": [[28, 34]]}}}, {"text": "You can use the skip() and available() methods to discard the data before the next read()", "label": {"api": {"skip()": [[16, 21]], "available()": [[27, 37]]}}}, {"text": "PInputEvent.getSourceSwingEvent() returns the underlying swing event - InputEvent, from that getSource() should give you the source, ie", "label": {"api": {"InputEvent": [[1, 10], [71, 80]]}}}, {"text": "To find what you're looking for you may have a custom designated extension of PInputEventListener that can hold a reference to a node that registers it", "label": {"api": {"InputEvent": [[79, 88]]}}}, {"text": "But we have Collection.iterator(), that's exactly what you're looking for", "label": {"api": {"Collection.iterator()": [[12, 32]]}}}, {"text": "The remove(int) method often trips people up because it is overloaded and can take either a primitive int for indexing or an Integer object for items within the list", "label": {"api": {"remove(int)": [[4, 14]]}}}, {"text": "If you are expecting output to be written as the program is running, you may not see it because Formatter buffers the output", "label": {"api": {"buffers the output": [[106, 123]]}}}, {"text": "You must close() the file when you are done with it (x.close()) so that any remaining buffered data is written (this does not happen automatically, even on program exit)", "label": {"api": {"close()": [[9, 15], [55, 61]]}}}, {"text": "Also if you want the output to actually be written immediately, flush() it as soon as you write a line (x.flush())", "label": {"api": {"flush()": [[64, 70], [106, 112]]}}}, {"text": "Take a look at the java.lang.instrument package", "label": {"api": {"java.lang.instrument": [[19, 38]]}}}, {"text": "You could write a Java agent that registers a ClassFileTransformer", "label": {"api": {"ClassFileTransformer": [[46, 65]]}}}, {"text": "There's also potential for modifying class files after they have already been loaded, but this can be a bit hit-and-miss as you have to make sure not to change signatures, etc", "label": {"api": {"modifying class files after they have already been loaded": [[27, 83]]}}}, {"text": "You can convert your array into a List (using Arrays's asList method) and check the conditions through contains() method", "label": {"api": {"Arrays's asList": [[46, 60]]}}}, {"text": "It's also possible to use Collections's disjoint method, to check whether two collections have elements in common or not", "label": {"api": {"Collections's disjoint": [[26, 47]]}}}, {"text": "If you really want short delays, then 'yielding' for a moment may be enough", "label": {"api": {"'yielding'": [[38, 47]]}}}, {"text": "Other forms of Thread.sleep(...) may sleep for longer, or shorter, than you request...", "label": {"api": {"Thread.sleep(...)": [[15, 31]]}}}, {"text": "You can get the smaller and larger inputs by using the Math.min() and Math.max functions...", "label": {"api": {"Math.min()": [[55, 64]], "Math.max": [[70, 77]]}}}, {"text": "Java actually has a facility called SealedObject for encrypting a serialized instance", "label": {"api": {"SealedObject": [[36, 47]]}}}, {"text": "I think the key difference between what you are doing and what SealedObject does is that it does the decrypting in a second phase, not in the initial deserialization", "label": {"api": {"SealedObject": [[63, 74]]}}}, {"text": "For example, you can access a character directly without the use of split(\"\") by using String.charAt()", "label": {"api": {"String.charAt()": [[87, 101]]}}}, {"text": "You can also directly convert a String to a char[] by using String.toCharArray()", "label": {"api": {"String.toCharArray()": [[60, 79]]}}}, {"text": "You can also quite easily use a regular expression without all these String arrays and splitting, see String.matches(), for example", "label": {"api": {"String.matches()": [[102, 117]]}}}, {"text": "'Q' is not a number and so nextInt(), as documented, throws an InputMismatchException", "label": {"api": {"as documented": [[38, 50]]}}}, {"text": "Even better, if you could use a Collection such as a List, you wouldn't even need to write an iteration, you'd just use Collection.contains", "label": {"api": {"Collection.contains": [[120, 138]]}}}, {"text": "ArrayIndexOutOfBoundsException  because may be your array size is less", "label": {"api": {"ArrayIndexOutOfBoundsException ": [[0, 30]]}}}, {"text": "Find the index of = using the indexOf(char) method", "label": {"api": {"indexOf(char)": [[30, 42]]}}}, {"text": "Find the last index of | char using lastIndexOf(char) method", "label": {"api": {"lastIndexOf(char)": [[36, 52]]}}}, {"text": "From this index, extract a substring from the actual string using substring(startIndex, endIndex) method(from the last index of | to the next 13 characters)", "label": {"api": {"substring(startIndex, endIndex)": [[66, 96]]}}}, {"text": "If index of = is not equal to -1, then extract a substring from the actual string using substring(startIndex, endIndex) method(from the index of = to the next 13 characters)", "label": {"api": {"substring(startIndex, endIndex)": [[88, 118]]}}}, {"text": "LinkedList also provides add method, which both the classes(ArrayList and LinkedList) overrides from List interface", "label": {"api": {"add": [[25, 27]], "List": [[6, 9], [65, 68], [80, 83], [101, 104]]}}}, {"text": "Note the usage of List instead of LinkedList for reference", "label": {"api": {"List": [[18, 21], [40, 43]]}}}, {"text": "HashMaps use Object.hashCode() to create the hash", "label": {"api": {"Object.hashCode()": [[13, 29]]}}}, {"text": "Take a look at http://docs.oracle.com/javase/7/docs/api/java/awt/event/MouseAdapter.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/event/MouseAdapter.html": [[15, 87]]}}}, {"text": "Class.forName takes the fully-qualified name, as document", "label": {"api": {"Class.forName": [[0, 12]]}}}, {"text": "You can do it by using the setIcon() method", "label": {"api": {"setIcon()": [[27, 35]]}}}, {"text": "If the elements are Comparable and you want them sorted in order based on this you could use the TreeSet (if you don't have any duplicates) or use Collections.sort(list)", "label": {"api": {"Collections.sort(list)": [[147, 168]]}}}, {"text": "If you need a different order you will need to implement a Comparator", "label": {"api": {"Comparator": [[59, 68]]}}}, {"text": "Now you can use Collections.sort to sort the list with this comparator", "label": {"api": {"Collections.sort": [[16, 31]]}}}, {"text": "The Java3D graphics library has a Vector3d class, and that has a cross method", "label": {"api": {"Vector3d": [[34, 41]]}}}, {"text": "Instead, try Integer.valueof()", "label": {"api": {"Integer.valueof()": [[13, 29]]}}}, {"text": "I would suggest using JFileChooser", "label": {"api": {"JFileChooser": [[22, 33]]}}}, {"text": "Then retrieve the selected file as a File object using the getSelectedFile() method", "label": {"api": {"getSelectedFile()": [[59, 75]]}}}, {"text": "That may be possible, but it is much easier to use a JFileChooser", "label": {"api": {"JFileChooser": [[53, 64]]}}}, {"text": "I recommend googling JFileChooser as there are tons of examples (including in the API)", "label": {"api": {"JFileChooser": [[21, 32]]}}}, {"text": "If this \"Stack\" class is java.util.Stack, or is a another class supporting generics, you can save yourself some trouble by telling the compiler that this stack is restricted to strings when you declare it", "label": {"api": {"java.util.Stack": [[25, 39]]}}}, {"text": "ResultSetMetaData can tell you about a ResultSet (and hence a table)", "label": {"api": {"ResultSetMetaData": [[0, 16]]}}}, {"text": "Convert them into a List using Arrays.asList and use contains", "label": {"api": {"Arrays.asList": [[31, 43]]}}}, {"text": "Check by using List.contains(Object o) (documentation) if the input is one of the values", "label": {"api": {"(documentation)": [[39, 53]]}}}, {"text": "From the Javadoc for BigDecimal", "label": {"api": {"the Javadoc for BigDecimal": [[5, 30]]}}}, {"text": "You can do this for example by having a limiting Semaphore that threads wait on before they submit their requests", "label": {"api": {"Semaphore": [[49, 57]]}}}, {"text": "Most components in JavaFX are Nodes, which can be related to each other hierarchically", "label": {"api": {"Nodes": [[30, 34]]}}}, {"text": "Then you can sort using custom Comparators", "label": {"api": {"Comparator": [[31, 40]]}}}, {"text": "If you don't want to repeat code, you can create a factory method that returns an instance of Comparator that sorts based on the specified attribute", "label": {"api": {"Comparator": [[94, 103]]}}}, {"text": "You can use the String(char[], int, int) constructor", "label": {"api": {"String(char[], int, int)": [[16, 39]]}}}, {"text": "Use a StringBuilder with a for-loop in conjuction with String.format() instead to greatly reduce the length", "label": {"api": {"String.format()": [[55, 69]]}}}, {"text": "However, using System.console().readPassword() or System.console().readPassword(String fmt, Object..", "label": {"api": {"System.console().readPassword()": [[15, 45]]}}}, {"text": "Either you need to implement the interface Comparable on your object to compare what you want;  or you can write a Comparator, instantiate and call it, passing both objects you want to compare", "label": {"api": {"Comparable": [[43, 52]], "Comparator": [[115, 124]]}}}, {"text": "The actual ConcurrentHashMap object is \"thread safe\" insofar as the guarantees it makes", "label": {"api": {"ConcurrentHashMap": [[11, 27]]}}}, {"text": "See the documentation for Thread", "label": {"api": {"Thread": [[26, 31]]}}}, {"text": "In particular, Thread.currentThread().getStackTrace() retrieves information about the trace, and Thread.dumpStack() prints the current stack trace", "label": {"api": {"Thread": [[15, 20], [29, 34], [97, 102]]}}}, {"text": "Thread.sleep()) support interruption by throwing InterruptedException whenever another thread interrupts it with threadToBeInterrupted.interrupt() method", "label": {"api": {"Thread.sleep()": [[0, 13]], "InterruptedException": [[49, 68]], "threadToBeInterrupted.interrupt()": [[113, 145]]}}}, {"text": "You can check the interruption status periodically (in case of no blocking calls) by either the instance method Thread.currentThread().isInterrupted() or the static method Thread.interrupted()", "label": {"api": {"Thread.currentThread().isInterrupted()": [[112, 149]], "Thread.interrupted()": [[172, 191]]}}}, {"text": "You cannot override toString for array, use Arrays#toString instead", "label": {"api": {"Arrays#toString": [[44, 58]]}}}, {"text": "So replaceAll will see \\\\ as \\, which is not what you want", "label": {"api": {"replaceAll": [[3, 12]], "replace": [[3, 9]]}}}, {"text": "Instead, you can use replace that accepts String and not a regex", "label": {"api": {"replace": [[21, 27]]}}}, {"text": "You can get an enum from a string with Enum.valueOf()", "label": {"api": {"Enum.valueOf()": [[39, 52]]}}}, {"text": "Take care here, the other answers fail to mention that Enum.valueOf() will throw an IllegalArgumentException if passed an string which isn't a valid member of the enum", "label": {"api": {"Enum.valueOf()": [[55, 68]]}}}, {"text": "For that purposes you can write your own TableCellEditor or use DefaultTableCellEditor", "label": {"api": {"TableCellEditor": [[41, 55], [71, 85]]}}}, {"text": "Instead of that use ActionListener it uses for button actions", "label": {"api": {"ActionListener": [[20, 33]]}}}, {"text": "getFontMetrics is a method on JComponent which gives you a FontMetrics object that has a getHeight() method", "label": {"api": {"method on JComponent": [[20, 39]], "getHeight() method": [[89, 106]]}}}, {"text": "Read the introduction to the FontMetrics class for everything you never wanted to know about ascent and descent", "label": {"api": {"FontMetrics class": [[29, 45]]}}}, {"text": "I am new to using the Pattern class in Java, and cant seem to find an example of how to use the or function when creating a pattern", "label": {"api": {"Pattern": [[22, 28]]}}}, {"text": "See the documentation for Formatter for more information about the format codes you can pass to System.out.printf()", "label": {"api": {"Formatter": [[26, 34]]}}}, {"text": "You can simply throw a RuntimeException", "label": {"api": {"RuntimeException": [[23, 38]]}}}, {"text": "Java agents might use the Instrumentation API which provides the lowlevel feature of class instrumentation but no direct profiling capability", "label": {"api": {"Instrumentation": [[26, 40]]}}}, {"text": "You can implement it via the ThreadMXBean which allows you to get stack traces of all running threads", "label": {"api": {"ThreadMXBean": [[29, 40]]}}}, {"text": "In fact, even a Thread.getAllStackTraces() would do but the ThreadMXBean provides more detailed information about the threads", "label": {"api": {"ThreadMXBean": [[60, 71]]}}}, {"text": "The Instrumentation API is provided to Java agents only but in case you want to go into the Instrumentation direction, here is a program which demonstrates how to connect to its own JVM and load itself as a Java agent", "label": {"api": {"Instrumentation": [[4, 18], [92, 106]]}}}, {"text": "(Stricly speaking this is void.class, not Void.class, but the compiler coerces void.class to Void.TYPE.) It is also used in several other places as shown in the Use page in its Javadoc", "label": {"api": {"Use page in its Javadoc": [[161, 183]]}}}, {"text": "From the Oracle Documentation", "label": {"api": {"Oracle Documentation": [[9, 28]]}}}, {"text": "From the documentation of Object#clone()", "label": {"api": {"the documentation of Object#clone()": [[5, 39]]}}}, {"text": "But the documentation of java.util.Arrays doesn't indicate that Arrays implements Cloneable", "label": {"api": {"the documentation of java.util.Arrays": [[4, 40]]}}}, {"text": "I think you are getting the FileNotFoundException because the file /var/log/idm/vendavo/vendavo.xml is not present in the directory", "label": {"api": {"FileNotFoundException": [[28, 48]]}}}, {"text": "Earlier there was a way to obtain it using ServletContext.getServlet(), which is deprecated now", "label": {"api": {"ServletContext.getServlet()": [[43, 69]]}}}, {"text": "The default layout manager is a BorderLayout (see JFrame overview), set it to null to allow for absolute positioning", "label": {"api": {"BorderLayout": [[32, 43]], "JFrame overview": [[50, 64]]}}}, {"text": "I would use a ChoiceFormat for the custom output and a DateFormat for the rest", "label": {"api": {"ChoiceFormat": [[14, 25]]}}}, {"text": "This can be combined quite elegantly using a MessageFormat", "label": {"api": {"MessageFormat": [[45, 57]]}}}, {"text": "For reference on split function check Oracle java documentation link", "label": {"api": {"Oracle java documentation": [[38, 62]]}}}, {"text": "If you need this sorted, try the ConcurrentSkipListMap", "label": {"api": {"ConcurrentSkipListMap": [[33, 53]]}}}, {"text": "No, you can't really place images inside a single Text node in JavaFX 2", "label": {"api": {"Text": [[50, 53]]}}}, {"text": "What you can do is use a FlowPane with different Text and ImageView instances", "label": {"api": {"Text": [[49, 52]], "FlowPane": [[25, 32]]}}}, {"text": "Javafx Text multi-word colorization", "label": {"api": {"Text": [[7, 10]]}}}, {"text": "I know you aren't interested in Java 8, but in case others are, in Java 8 you can you can use the TextFlow to style text rather than using a combination of different Text instances in a FlowPane", "label": {"api": {"Text": [[98, 101], [166, 169]], "FlowPane": [[186, 193]]}}}, {"text": "TextFlow is more elegant as it will handle wrapping at word breaks automatically for you, whereas, with a FlowPane you will need to create a new Text node for every word to get smooth word wrapping of a paragraph", "label": {"api": {"Text": [[0, 3], [145, 148]], "FlowPane": [[106, 113]]}}}, {"text": "ArrayList class does not implement java.lang.Comparable interface and the TreeMap is expecting the key to implement comparable interface", "label": {"api": {"TreeMap": [[74, 80]]}}}, {"text": "As we cannot go modify ArrayList, you can use external comparator to make ArrayList work as a key to the TreeMap", "label": {"api": {"TreeMap": [[105, 111]], "comparator": [[55, 64]]}}}, {"text": "ArrayLists don't implement Comparable, so you need to use an unsorted map, like HashMap, or tell the TreeMap how to sort your ArrayLists by using this constructor", "label": {"api": {"ArrayLists": [[0, 9], [126, 135]], "Comparable": [[27, 36]], "HashMap": [[80, 86]], "TreeMap": [[101, 107]], "this constructor": [[146, 161]]}}}, {"text": "According to Oracle docs, Date.toString should return a string with the format yyyy-mm-dd, but instead I'm receiving strings like", "label": {"api": {"According to Oracle docs": [[0, 23]]}}}, {"text": "SimpleDateFormat will help you", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Another way is that Collection subclases hold the type (class) they are containing just like CheckedCollections do and use it on toArray method so you don't have to give any parameter", "label": {"api": {"CheckedCollections": [[93, 110]]}}}, {"text": "For the receiver to be able to handle what it gets, there is the RMIClassLoader", "label": {"api": {"RMIClassLoader": [[65, 78]]}}}, {"text": "Here is an implementation in pure Java using the Proxy class", "label": {"api": {"Proxy": [[49, 53]]}}}, {"text": "You can use exists in the Java code, if that's what you're using to check with", "label": {"api": {"exists": [[12, 17]]}}}, {"text": "The ActionEvent has a source, which will be the JButton that is firing the event", "label": {"api": {"ActionEvent": [[4, 14]], "source": [[22, 27]]}}}, {"text": "You need to call em.createQuery", "label": {"api": {"em.createQuery": [[17, 30]]}}}, {"text": "A perspective transfrom is included with the JAI (\"Java Advanced Imaging\") API but I'm not sure what's the official source for it after Oracle bought Sun", "label": {"api": {"perspective transfrom": [[2, 22]]}}}, {"text": "JLabel inherits GetSize from Component which should return a Dimension for your use", "label": {"api": {"GetSize": [[16, 22]]}}}, {"text": "Double.doubleToLongBits and Double.longBitsToDouble should do the trick if it's a double", "label": {"api": {"Double.doubleToLongBits": [[0, 22]], "Double.longBitsToDouble": [[28, 50]]}}}, {"text": "You have declared list is an array, and as such it has no member iterator() and less an inner class", "label": {"api": {"iterator": [[65, 72]]}}}, {"text": "iterator to make an instance of", "label": {"api": {"iterator": [[0, 7]]}}}, {"text": "You could implement your iterator index based where hasNext() returns index < actIndex and next() returns list[itIndex] and throws a NoSuchElementException if it was called after hasNext() returned false", "label": {"api": {"iterator": [[25, 32]]}}}, {"text": "An MXBean, or more specifically, OpenTypes, allow you to supply a definition of a \"complex\" class broken down into its constituent components defined in supported standard types", "label": {"api": {"OpenType": [[33, 40]]}}}, {"text": "You can look at the implementations in the java.util.concurrent package, there are several options", "label": {"api": {"java.util.concurrent": [[43, 62]]}}}, {"text": "I would recommend using a ConcurrentHashMap with dummy values", "label": {"api": {"ConcurrentHashMap": [[26, 42]]}}}, {"text": "The reason for the recommendation is that the ConcurrentHashMap has synchronized key groups so if you have a good hashing algorithm (and String does) you can actually get a massive amount of concurrent throughput", "label": {"api": {"ConcurrentHashMap": [[46, 62]]}}}, {"text": "Refer to this comment, or use Arrays.deepEquals in the same manner", "label": {"api": {"Arrays.deepEquals": [[30, 46]]}}}, {"text": "Now, data types are different mpz_t and BigInteger, so which native data type should be used", "label": {"api": {"BigInteger": [[40, 49]]}}}, {"text": "Read the blurb on HashMap to see why, which specifies that HashMap guarantees no ordering of the entries", "label": {"api": {"HashMap": [[18, 24], [59, 65]]}}}, {"text": "It would be possible to use HashMap for this but I don't recommend it because you might have to make extra steps somewhere", "label": {"api": {"HashMap": [[28, 34]]}}}, {"text": "Either way, the documentation for Formatter will provide the best starting point", "label": {"api": {"documentation for Formatter": [[16, 42]]}}}, {"text": "The classic answer is a Binary Search Tree or a binary search algorithm, like Collections.binarySearch(), which allows you to search in O(log n) time", "label": {"api": {"Collections.binarySearch()": [[78, 103]]}}}, {"text": "From PreparedStatement#setString javadoc (emphasis mine)", "label": {"api": {"PreparedStatement#setString": [[5, 31]]}}}, {"text": "You need to use SimpleDateFormat.parse() to convert String to Date", "label": {"api": {"SimpleDateFormat.parse()": [[16, 39]]}}}, {"text": "Use SimpleDateFormat#parse() instead; you cannot directly cast a String instance into a Date", "label": {"api": {"SimpleDateFormat#parse()": [[4, 27]]}}}, {"text": "You can use an array of 3 Points", "label": {"api": {"Point": [[26, 30]]}}}, {"text": "A Point is a Java class that holds an x and y value", "label": {"api": {"Point": [[2, 6]]}}}, {"text": "Your 3 Points shaded red in the illustration would be", "label": {"api": {"Point": [[7, 11]]}}}, {"text": "Check out the SpinnerDateModel documentation, for more details", "label": {"api": {"SpinnerDateModel": [[14, 29]]}}}, {"text": "Either use ConcurrentHashMap or make the public method synchronized (which makes more sense since you've got a race condition also on creating the HashMap)", "label": {"api": {"ConcurrentHashMap": [[11, 27]]}}}, {"text": "Use a TitledPane (or a set of TitledPane's in a VBox with a computed preferred size) instead of an Accordion", "label": {"api": {"TitledPane": [[6, 15], [30, 39]], "Accordion": [[99, 107]]}}}, {"text": "I could not explain to you why the TitledPane's work in this case but the Accordion does not", "label": {"api": {"TitledPane": [[35, 44]], "Accordion": [[74, 82]]}}}, {"text": "Also, the method should be called \"compareTo\", lowercase \"c\", to match the interface method name", "label": {"api": {"the interface method name": [[71, 95]]}}}, {"text": "If you want to actually change the character in your String in addition to printing out the incremented characters, then you can use setCharAt() from StringBuilder, ie", "label": {"api": {"StringBuilder": [[150, 162]]}}}, {"text": "I think you want Float.floatToIntBits()", "label": {"api": {"Float.floatToIntBits()": [[17, 38]]}}}, {"text": "A type of map", "label": {"api": {"map": [[10, 12]]}}}, {"text": "If you need to iterate the map by insertion order, there is a LinkedHashMap", "label": {"api": {"map": [[27, 29]]}}}, {"text": "If you need to iterate the map by ascending or descending key values, there are sorted maps", "label": {"api": {"map": [[27, 29], [87, 89]], "sorted maps": [[80, 90]]}}}, {"text": "If the map will be shared by multiple threads a concurrent map will be useful", "label": {"api": {"map": [[7, 9], [59, 61]], "concurrent map": [[48, 61]]}}}, {"text": "If there will be billions of items in the list and you don't mind hemorraghing data (say this is a caching algorithm), a WeakHashMap is for you", "label": {"api": {"WeakHashMap": [[121, 131]]}}}, {"text": "The ArrayList is initialized with a capacity of 9 but the list is empty", "label": {"api": {"initialized with a capacity": [[17, 43]]}}}, {"text": "By default, the workQueue is a BlockingQueue, its take() method will block the current thread indefinitely until a task becomes available", "label": {"api": {"BlockingQueue": [[31, 43]]}}}, {"text": "Convert your staffid int value to String using String.valueOf method and compare it with line using equals method", "label": {"api": {"String.valueOf": [[47, 60]]}}}, {"text": "You should read the doc", "label": {"api": {"read": [[11, 14]]}}}, {"text": "the method read() returns -1 if the end of the file is reached", "label": {"api": {"read": [[11, 14]]}}}, {"text": "You can also pass in your SecureRandom into the other shuffle method", "label": {"api": {"other shuffle method": [[48, 67]]}}}, {"text": "Consider setting the JTextPane's inputVerifier to an instance of your own subclass of InputVerifier", "label": {"api": {"inputVerifier": [[33, 45]], "InputVerifier": [[86, 98]]}}}, {"text": "This has the advantage that you can set some controls (such as a \"Cancel\" button) to refrain from triggering it, using setVerifyInputWhenFocusTarget", "label": {"api": {"setVerifyInputWhenFocusTarget": [[119, 147]]}}}, {"text": "Perhaps the most commonly used example of this is the Map.Entry<K,V> interface", "label": {"api": {"Map.Entry<K,V>": [[54, 67]]}}}, {"text": "Finally you're in good neighborhood with Java's List specification of List.get(int) when raising IndexOutOfBoundsException in such cases", "label": {"api": {"List.get(int)": [[70, 82]]}}}, {"text": "If you use an ExecutorService with only 1 Thread, you can use invokeAll on a list of Callables", "label": {"api": {"invokeAll": [[62, 70]]}}}, {"text": "By replacing System.out using System.setOut it's possible, in theory, to catch a print statement when it happens", "label": {"api": {"System.setOut": [[30, 42]]}}}, {"text": "(1) class PrintStream has many printing methods for different data types and there isn't a good single method to override", "label": {"api": {"PrintStream": [[10, 20]]}}}, {"text": "In the same ActionListener, start a Swing Timer to change the color back to Color.BLUE, again using the setBackground(...) method", "label": {"api": {"Swing Timer": [[36, 46]]}}}, {"text": "Link to Swing Timer Tutorial", "label": {"api": {"Swing Timer": [[8, 18]]}}}, {"text": "For example using FileWriter(String fileName, boolean append) and passing true as second parameter", "label": {"api": {"FileWriter(String fileName, boolean append)": [[18, 60]]}}}, {"text": "Don't read the whole file at once - open a FileInputStream and call the read() method to get one byte at a time", "label": {"api": {"FileInputStream": [[43, 57]], "read()": [[72, 77]]}}}, {"text": "A lazy solution would be to implement Cloneable and clone() your object before sending - but unless you're on a thoroughly ancient JDK, you'll want to call writeUnshared() instead, as it will write a \"fresh\" copy of your object rather than a reference to a previous version", "label": {"api": {"writeUnshared()": [[156, 170]]}}}, {"text": "You did not bother to read the javaDoc for getNumericalValue(), so I'll add the link, and tell you that the numerical value for both A and a are supposed to be 10", "label": {"api": {"read the javaDoc for getNumericalValue()": [[22, 61]]}}}, {"text": "Why don't you simply use remove, indexOf and min", "label": {"api": {"remove": [[25, 30]], "indexOf": [[33, 39]], "min": [[45, 47]]}}}, {"text": "Do it twice if you want to remove the two smallest items", "label": {"api": {"remove": [[27, 32]]}}}, {"text": "Java has a built-in Properties class that implements Map and can read and write the data format you describe (see that class's load() and store() methods)", "label": {"api": {"Properties": [[20, 29]], "load()": [[127, 132]], "store()": [[138, 144]]}}}, {"text": "There's nothing in there to implement your \"fall back to a higher-level key\" feature, so you'll need to write a method that looks in the Properties instance for data under the desired key, and keeps trying successively shorter versions of the same key if it finds nothing", "label": {"api": {"Properties": [[137, 146]]}}}, {"text": "You could use the MessageFormat class for that, but a far easier and less verbose way would to just use this code", "label": {"api": {"MessageFormat": [[18, 30]]}}}, {"text": "Java's String#replaceAll takes a regex string as argument", "label": {"api": {"String#replaceAll": [[7, 23]]}}}, {"text": "Thus if you want to create a new, standalone document you will need to create one with a DocumentBuilder and http://docs.oracle.com/javase/7/docs/api/javax/xml/parsers/DocumentBuilder.html#newDocument%28%29 and then you can importNode or adoptNode what you selected with XPath in your input document and finally appendChild", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/xml/parsers/DocumentBuilder.html#newDocument%28%29": [[109, 205]]}}}, {"text": "see Java documentation of clone() for details", "label": {"api": {"Java documentation of clone()": [[4, 32]]}}}, {"text": "In Java, each object has toString() method, the default is displaying the class name representation, then adding @ and then the hashcode", "label": {"api": {"toString()": [[25, 34]]}}}, {"text": "You should use Arrays#toString(), which is implemented this way", "label": {"api": {"toString()": [[22, 31]], "Arrays#toString()": [[15, 31]]}}}, {"text": "Use an ExecutorService", "label": {"api": {"ExecutorService": [[7, 21]]}}}, {"text": "The ExecutorService is a thread pool - it has a number of Threads that take tasks as they come", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "There are classes in the java.util.concurrent package that might be able to help you if used correctly, such as priority queues", "label": {"api": {"java.util.concurrent": [[25, 44]]}}}, {"text": "Have a look at java.util.ArrayList", "label": {"api": {"java.util.ArrayList": [[15, 33]]}}}, {"text": "I suggest you look at the String.intern() method which details how Strings are pooled", "label": {"api": {"String.intern()": [[26, 40]]}}}, {"text": "Nevertheless I found the question intriguing enough to give it a thought and came up with the following (dirty) code that fulfills your requirement using a Phaser for synchronization", "label": {"api": {"Phaser": [[156, 161]]}}}, {"text": "Then, you can use Collections.sort() (and then Collections.reverse()) to ensure that the first three entries are your highest three values", "label": {"api": {"Collections.sort()": [[18, 35]]}}}, {"text": "First of all, note that you are using Collections.sort, which is above O(n) complexity", "label": {"api": {"Collections.sort": [[38, 53]]}}}, {"text": "Instead of Collections.sort which is above O(N) complexity use a Hash Set unless you have a constraint on the space complexity", "label": {"api": {"Collections.sort": [[11, 26]], "Hash Set": [[65, 72]]}}}, {"text": "It works with GridBagConstraints (read about it parametrs)", "label": {"api": {"read about it parametrs": [[34, 56]]}}}, {"text": "You could do search whether there are 3 consecutive code points that are in the same Unicode block", "label": {"api": {"Unicode block": [[85, 97]]}}}, {"text": "The Servlet container keeps a map (YMMV) of HttpSession objects and these identifiers", "label": {"api": {"HttpSession": [[44, 54]]}}}, {"text": "When a client first makes a request, the server creates an HttpSession object with a unique identifier and stores it in its map", "label": {"api": {"HttpSession": [[59, 69]]}}}, {"text": "The Servlet API makes that a little simpler for you with the HttpServletResponse#addCookie(Cookie) method but you could do it yourself with the HttpServletResponse#addHeader(String, String) method", "label": {"api": {"HttpServletResponse#addCookie(Cookie)": [[61, 97]], "HttpServletResponse#addHeader(String, String)": [[144, 188]]}}}, {"text": "When the Servlet container receives the request, it extracts the Cookie header value and tries to retrieve an HttpSession object from its map by using the key in the JSESSIONID cookie", "label": {"api": {"HttpSession": [[110, 120]]}}}, {"text": "This HttpSession object is then attached to the HttpServletRequest object that the Servlet container creates and passes to your Servlet", "label": {"api": {"HttpSession": [[5, 15]], "HttpServletRequest": [[48, 65]]}}}, {"text": "You can use the setAttribute(String, Object) and getAttribute(String) methods to manage state", "label": {"api": {"setAttribute(String, Object)": [[16, 43]], "getAttribute(String)": [[49, 68]]}}}, {"text": "The problem with your code is that SUN's provider implementation of CertStore.getCertificates() returns HashSet", "label": {"api": {"HashSet": [[104, 110]]}}}, {"text": "And HashSet makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time", "label": {"api": {"HashSet": [[4, 10]]}}}, {"text": "Class.cast will throw a ClassCastException if instance is not a T (so your earlier check may not be needed)", "label": {"api": {"Class.cast": [[0, 9]]}}}, {"text": "Also, synchronization can be used on individual statements rather than whole methods, and there are other locks too", "label": {"api": {"other locks": [[100, 110]]}}}, {"text": "This is possible using semaphores", "label": {"api": {"semaphores": [[23, 32]]}}}, {"text": "The Date(String) constructor only parses strings in the documented format", "label": {"api": {"the documented format": [[52, 72]]}}}, {"text": "There is no reason to go with StringBuffer", "label": {"api": {"StringBuffer": [[30, 41]]}}}, {"text": "Below statement is copied from StringBuffer Doc", "label": {"api": {"StringBuffer": [[31, 42]]}}}, {"text": "ServletContext- defines a set of methods that a servlet uses to communicate with its servlet container", "label": {"api": {"ServletContext": [[0, 13]]}}}, {"text": "Make your ComponentInitializator class as Servlet than try to access ServletContext", "label": {"api": {"ServletContext": [[69, 82]]}}}, {"text": "One way to ensure fairness is to use a ReentrantLock initialized with true (fair scheduling)", "label": {"api": {"ReentrantLock": [[39, 51]]}}}, {"text": "What you want is System.getEnv(...)", "label": {"api": {"System.getEnv(...)": [[17, 34]]}}}, {"text": "The normal approach is to split the string by the delimiting character (;) and insert the elements into a sorted set (e.g., TreeSet)", "label": {"api": {"TreeSet": [[124, 130]]}}}, {"text": "Since you need to sort numerically, you have to implement a Comparator and pass an instance to the TreeSet constructor", "label": {"api": {"TreeSet": [[99, 105]], "Comparator": [[60, 69]]}}}, {"text": "It returns a list with a fixed size, backed by the original array (as documented)", "label": {"api": {"documented": [[70, 79]]}}}, {"text": "Arrays.asList() will give you back a fixed size list, and that is why your add is failing", "label": {"api": {"Arrays.asList()": [[0, 14]]}}}, {"text": "The String pool only contains String literals and String compile-time constants, or Strings that have explicitely been added to the pool by calling String.intern()", "label": {"api": {"String.intern()": [[148, 162]]}}}, {"text": "Use a ListIterator", "label": {"api": {"ListIterator": [[6, 17]]}}}, {"text": "A ListIterator is able to iterate in both directions", "label": {"api": {"ListIterator": [[2, 13]]}}}, {"text": "try ListIterator instead of Iterator", "label": {"api": {"ListIterator": [[4, 15]]}}}, {"text": "ListIterator has previous() method to access the previous element in the list", "label": {"api": {"ListIterator": [[0, 11]], "previous()": [[17, 26]]}}}, {"text": "If this thread has a ConcurrentBlockingQueue, other threads can add their part into this queue instead of the file, then proceed with whatever they were doing, while the write-thread is the only one who has access to the file ever", "label": {"api": {"ConcurrentBlockingQueue": [[21, 43]]}}}, {"text": "Therefore no write issues can arise, and the thread safety is completely handles in the ConcurrentBlockingQueue", "label": {"api": {"ConcurrentBlockingQueue": [[88, 110]]}}}, {"text": "See Object.toString() and Object.hashCode() for further information", "label": {"api": {"Object.toString()": [[4, 20]], "Object.hashCode()": [[26, 42]]}}}, {"text": "I followed the instructions on documetary and created the Array like suggested there", "label": {"api": {"documetary": [[31, 40]]}}}, {"text": "You should use either the Android specific AsyncTask class or ordinary Thread for web-related communications, also for Database communications, but in your case the latter comprises of the first", "label": {"api": {"Thread": [[71, 76]]}}}, {"text": "The obvious exceptions to this rule are toString methods of the StringBuilder and the StringBuffer classes, because these two methods simply make an immutable string from the mutable content of the corresponding object", "label": {"api": {"StringBuilder": [[64, 76]], "StringBuffer": [[86, 97]]}}}, {"text": "From the docs of a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[19, 31]]}}}, {"text": "1) Double.valueOf(String) - This will return a double value given a String - or throw an Exception if the String can't be mapped to a double", "label": {"api": {"Double.valueOf(String)": [[3, 24]]}}}, {"text": "The javadoc is available in this link", "label": {"api": {"in this link": [[25, 36]]}}}, {"text": "You can use a CountDownLatch to let both threads wait before entering the loop compensating the thread startup overhead to have them run as synchronous as possible", "label": {"api": {"CountDownLatch": [[14, 27]]}}}, {"text": "You can search StackOverflow for related questions on Platform.runLater, Task, Service and JavaFX concurrency topics as well as review the Oracle documentation on concurrency in JavaFX and the Task javadoc to gain a better understanding of how all this stuff works and what your options are", "label": {"api": {"Task javadoc": [[193, 204]]}}}, {"text": "I thought about Future, would that be a solution", "label": {"api": {"Future": [[16, 21]]}}}, {"text": "That said - have you considered a ForkJoinPool", "label": {"api": {"ForkJoinPool": [[34, 45]]}}}, {"text": "The Javadoc for InputStream.read() says \"these bytes will be stored in elements b[off] through b[off+k-1], leaving elements b[off+k] through b[off+len-1] unaffected.\" It's not reiterated for Reader.read() but it clearly should be", "label": {"api": {"Javadoc for InputStream.read()": [[4, 33]]}}}, {"text": "In case you wonders why you didn't got a compilation error here, it's because Map#get() takes an Object instead of K for the reasons mentioned here", "label": {"api": {"Map#get()": [[78, 86]]}}}, {"text": "The Java EE 5 version of Entity Manager doesn't have a detach method, but I need this exact functionality", "label": {"api": {"The Java EE 5 version of Entity Manager": [[0, 38]]}}}, {"text": "If the L&F supports window decorations, you can use setWindowDecorationStyle()", "label": {"api": {"setWindowDecorationStyle()": [[52, 77]]}}}, {"text": "Second, the addCookie(Cookie) method exist specifically to make your life easier, use it", "label": {"api": {"addCookie(Cookie)": [[12, 28]]}}}, {"text": "Assuming that you want to add all values from the sets in the map your approach to do it is to use addAll method", "label": {"api": {"addAll": [[99, 104]]}}}, {"text": "you are returning this.getClass().getName(), which returns the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String", "label": {"api": {"this.getClass().getName()": [[18, 42]]}}}, {"text": "Convert to to ArrayList", "label": {"api": {"ArrayList": [[14, 22]], "Convert": [[0, 6]]}}}, {"text": "add all at index 0", "label": {"api": {"add": [[0, 2]]}}}, {"text": "Convert it back to array", "label": {"api": {"Convert": [[0, 6]]}}}, {"text": "Do it using reflection by checking the stack trace, see Thread#getStackTrace", "label": {"api": {"Thread#getStackTrace": [[56, 75]]}}}, {"text": "Go through the API and see what methods are useful for your needs", "label": {"api": {"API": [[15, 17]]}}}, {"text": "You can improve on simple array searching using Arrays.sort and Arrays.binarySearch", "label": {"api": {"Arrays.sort": [[48, 58]], "Arrays.binarySearch": [[64, 82]]}}}, {"text": "To get the correct time/ date use the get(int field) method of the Calendar class", "label": {"api": {"get(int field)": [[38, 51]]}}}, {"text": "Read tutorial about ActionListener, and read oracle docs", "label": {"api": {"oracle docs": [[45, 55]]}}}, {"text": "Both FileChannel and SocketChannel implement ByteChannel which is what declares their read(ByteBuffer) method, so that's the type your getInputChannel() should return", "label": {"api": {"ByteChannel": [[45, 55]]}}}, {"text": "Edit Or if you only ever read from the channel, return a ReadableByteChannel as Darkhogg says", "label": {"api": {"ByteChannel": [[65, 75]], "ReadableByteChannel": [[57, 75]]}}}, {"text": "You can get the milliseconds between them by converting the calendars to Date (Calendar has such a method to do this)", "label": {"api": {"Date": [[73, 76]]}}}, {"text": "You should override accept in the interface FilenameFilter and make sure that the parameter name has only numeric chars", "label": {"api": {"accept": [[20, 25]], "FilenameFilter": [[44, 57]]}}}, {"text": "You can check this by using matches", "label": {"api": {"matches": [[28, 34]]}}}, {"text": "The split method takes a regular expression as an argument, and + has special meaning within regular expressions", "label": {"api": {"split method": [[4, 15]]}}}, {"text": "You should use BufferedImage.getRGB(startX, startY, w, h, rgbArray, offset, scansize) unless you really want to play around with the loops and extra arrays", "label": {"api": {"BufferedImage.getRGB(startX, startY, w, h, rgbArray, offset, scansize)": [[15, 84]]}}}, {"text": "That ability has been deprecated for a long time now, due to its unsafety", "label": {"api": {"deprecated": [[22, 31]]}}}, {"text": "The Java SE API Documentation is useful too", "label": {"api": {"Java SE API Documentation": [[4, 28]]}}}, {"text": "If you're looking for a built-in mechanism, than a custom Service Provider is probably your answer (available since Java 1.6)", "label": {"api": {"Service Provider": [[58, 73]]}}}, {"text": "I looked at the HttpCookie docs, but this appears to be about reading a cookie from an existing cookie string", "label": {"api": {"HttpCookie docs": [[16, 30]]}}}, {"text": "You need an ignorableWhitespace() callback", "label": {"api": {"ignorableWhitespace()": [[12, 32]]}}}, {"text": "See the setDictionary method", "label": {"api": {"setDictionary": [[8, 20]]}}}, {"text": "Use KeyEvent.isMetaDown() instead", "label": {"api": {"KeyEvent.isMetaDown()": [[4, 24]]}}}, {"text": "ThreadLocalRandom has released with Jdk 1.7", "label": {"api": {"ThreadLocalRandom": [[0, 16]]}}}, {"text": "No, PrintStream.printf() was not removed", "label": {"api": {"PrintStream.printf()": [[4, 23]]}}}, {"text": "I use PriorityBlockingQueue", "label": {"api": {"PriorityBlockingQueue": [[6, 26]]}}}, {"text": "First if you want to execute something at a fixed rate, use the ScheduledThreadPoolExecutor.scheduleAtFixedRate(...) function", "label": {"api": {"ScheduledThreadPoolExecutor.scheduleAtFixedRate(...)": [[64, 115]]}}}, {"text": "You can ensure that the imageQueue does not overflow with images to render if the CPU is too slow by limiting the size of this queue, see the constructor of LinkedBlockingQueue", "label": {"api": {"constructor of LinkedBlockingQueue": [[142, 175]]}}}, {"text": "However the standard way of doing this in java is to implment the Colneable interface and override the clone method", "label": {"api": {"Colneable": [[66, 74]], "clone": [[103, 107]]}}}, {"text": "The result of keySet() does not support adding elements to it", "label": {"api": {"keySet()": [[14, 21]]}}}, {"text": "Use the List#toArray(T[]) method to create an array from the list, and pass it", "label": {"api": {"List#toArray(T[])": [[8, 24]]}}}, {"text": "You are really asking how to serialize an Element to a string - use either a Transformer or DOMImplementationLS", "label": {"api": {"Element": [[42, 48]]}}}, {"text": "The NodeList type has no toString() contract and the implementation does not override the default Object.toString()", "label": {"api": {"NodeList": [[4, 11]]}}}, {"text": "You need to iterate over the nodes and serialize each Element as above", "label": {"api": {"Element": [[54, 60]]}}}, {"text": "examine DefaultTreeCellEditor and it's method isCellEditable(EventObject arg0)", "label": {"api": {"DefaultTreeCellEditor": [[8, 28]]}}}, {"text": "Use Collections.max and not sorting", "label": {"api": {"Collections.max": [[4, 18]]}}}, {"text": "Finally, you might want to replace the entire loop with a single call to System.arraycopy()", "label": {"api": {"System.arraycopy()": [[73, 90]]}}}, {"text": "Another solution might be to put a JPanel between your JFrame and your ScrollPane that uses a BorderLayout, and put the scrollpane in the BorderLayout.NORTH of that panel", "label": {"api": {"BorderLayout": [[94, 105], [138, 149]]}}}, {"text": "Components in BorderLayout.NORTH get resized horizontally, but they do not get resized vertically", "label": {"api": {"BorderLayout": [[14, 25]]}}}, {"text": "use, TreeMap<K, V>", "label": {"api": {"TreeMap<K, V>": [[5, 17]]}}}, {"text": "You can use MessageFormat class", "label": {"api": {"MessageFormat": [[12, 24]]}}}, {"text": "I suspect the problem is that you are trying to allocate a List, which is an abstract class", "label": {"api": {"List": [[59, 62]]}}}, {"text": "You should be allocating a LinkedList or an ArrayList, or something of that sort", "label": {"api": {"List": [[33, 36], [49, 52]], "LinkedList": [[27, 36]], "ArrayList": [[44, 52]]}}}, {"text": "You need to use System.out.printf() and passing the appropriate flags for the width, see here for the syntax for formatting", "label": {"api": {"System.out.printf()": [[16, 34]]}}}, {"text": "To answer your question, A webpage viewed using the web-browser may not be same, as the same webpage is downloaded using a URLConnection", "label": {"api": {"URLConnection": [[123, 135]]}}}, {"text": "in simple terms, when you request a URL using a URLConnection you are recieving raw data, however when you request the same URL using a browser's addressbar you get processed (by javascript/browser plugins) webpage", "label": {"api": {"URLConnection": [[48, 60]]}}}, {"text": "URLConnection/JSoup will allow you to set request headers as required, but you may still get the different response due to points 2 & 3", "label": {"api": {"URLConnection": [[0, 12]]}}}, {"text": "I usually prefer to use Comparator with Collections.sort(List,Comparator) instead of implementing Comparable", "label": {"api": {"Comparator": [[24, 33], [62, 71]], "Collections.sort(List,Comparator)": [[40, 72]]}}}, {"text": "please refer to http://docs.oracle.com/javase/1.3/docs/api/java/lang/Character.html if it helps", "label": {"api": {"http://docs.oracle.com/javase/1.3/docs/api/java/lang/Character.html": [[16, 82]]}}}, {"text": "Java API docs are always your friend", "label": {"api": {"Java API docs": [[0, 12]]}}}, {"text": "The Files class introduced in Java 7 has methods for handling links and symlinks but only as optional operations", "label": {"api": {"Files": [[4, 8]]}}}, {"text": "Classes like FileSystem or FileStore do not seem to contain anything in that regard (or I overlooked it)", "label": {"api": {"FileSystem": [[13, 22]], "FileStore": [[27, 35]]}}}, {"text": "Your test class didn't override equals, so it inherits the method from Object", "label": {"api": {"the method from Object": [[55, 76]]}}}, {"text": "According to the format syntax, the width should be specified", "label": {"api": {"format syntax": [[17, 29]]}}}, {"text": "Use the string's length method", "label": {"api": {"length method": [[17, 29]]}}}, {"text": "You run your time consuming method off of the JavaFX application thread (in a Task)", "label": {"api": {"Task": [[78, 81]]}}}, {"text": "Tasks have special APIs in them which allow for easy provision of messages for status which can be displayed in a bound label", "label": {"api": {"Task": [[0, 3]]}}}, {"text": "You can read Oracle's online API about ImageIcon", "label": {"api": {"ImageIcon": [[39, 47]]}}}, {"text": "Use the stmt.getXYZ(column) methods directly (from CallableStatement, e.g", "label": {"api": {"CallableStatement": [[51, 67]]}}}, {"text": "For why the the NPE exception is generated, see Statement.getResultSet", "label": {"api": {"Statement.getResultSet": [[48, 69]]}}}, {"text": "If so, you need to use the Java API for file attributes, precisely UserDefinedFileAttributeView", "label": {"api": {"UserDefinedFileAttributeView": [[67, 94]]}}}, {"text": "You can also call FileStore.supportsFileAttributeView() to check if your file system supports it", "label": {"api": {"FileStore.supportsFileAttributeView()": [[18, 54]]}}}, {"text": "Read more about using of JFileChooser and its methods", "label": {"api": {"its methods": [[42, 52]]}}}, {"text": "This could be based on meta information, like the Service Loader pattern that is available in the JDK", "label": {"api": {"Service Loader": [[50, 63]]}}}, {"text": "Check the TimeZone.setDefault javadoc", "label": {"api": {"TimeZone.setDefault": [[10, 28]]}}}, {"text": "Performance pointy of view StringBuilder appending is better than String concatenation, but StringBuilder doesn't provide thread safety", "label": {"api": {"StringBuilder": [[27, 39], [92, 104]], "String": [[27, 32], [66, 71], [92, 97]]}}}, {"text": "If you need thread safety use StringBuffer", "label": {"api": {"String": [[30, 35]], "StringBuffer": [[30, 41]]}}}, {"text": "You can just use String#getChars() or String#toCharArray()", "label": {"api": {"String#getChars()": [[17, 33]], "String#toCharArray()": [[38, 57]]}}}, {"text": "The getContentPane()-Method returns a Container, and the Documentation of the Container class states that there is a function named isAncestorOf(Component c) to check wether it is an ancestor of the given Component", "label": {"api": {"Documentation of the Container class": [[57, 92]]}}}, {"text": "Your class needs to extend the java.applet.Applet class", "label": {"api": {"java.applet.Applet": [[31, 48]]}}}, {"text": "Simply add extends Applet to the class definition (and also, of course, import java.applet.Applet)", "label": {"api": {"java.applet.Applet": [[79, 96]]}}}, {"text": "The BLOCKED state documentation says", "label": {"api": {"BLOCKED state documentation": [[4, 30]]}}}, {"text": "canWrite() is a permissions test (i.e", "label": {"api": {"canWrite()": [[0, 9]]}}}, {"text": "A quick way to check if a File is locked is trying to modify the file's name with renameTo and seeing whether you are successful", "label": {"api": {"renameTo": [[82, 89]]}}}, {"text": "In the case that the file rename succeeds, renameTo will returned true and locked will be false", "label": {"api": {"renameTo": [[43, 50]]}}}, {"text": "In Java, you can call the Hashtable#values method to get all the values within that hashtable", "label": {"api": {"Hashtable#values": [[26, 41]]}}}, {"text": "Refer enter link description here", "label": {"api": {"enter link description here": [[6, 32]]}}}, {"text": "I found the following code in transform method of class PerspectiveTransform in JAI library", "label": {"api": {"PerspectiveTransform": [[56, 75]]}}}, {"text": "String literals - or, more generally, strings that are the values of constant expressions (§15.28) - are \"interned\" so as to share unique instances, using the method String.intern", "label": {"api": {"String.intern": [[166, 178]]}}}, {"text": "Try replacing the Z time zone designation with SSS for milliseconds", "label": {"api": {"SSS for milliseconds": [[47, 66]]}}}, {"text": "You must use the one-argument add method to append to the end of the list, or supply 0 as the index in the two-argument add method, so that there is something in the list", "label": {"api": {"the one-argument add method": [[13, 39]], "the two-argument add method": [[103, 129]]}}}, {"text": "rather than calling nextInt(), you could call hasNextInt(), and check if the scanner is looking at an integer or not", "label": {"api": {"hasNextInt()": [[46, 57]]}}}, {"text": "First of all, you should not use the constructor Date(String), as it's deprecated", "label": {"api": {"Date(String)": [[49, 60]]}}}, {"text": "You might want to check out the Scrollable interface too, which allows fine-tuning of scrolling behaviour", "label": {"api": {"Scrollable": [[32, 41]]}}}, {"text": "Take a look at http://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#readObject()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#readObject()": [[15, 98]]}}}, {"text": "It sounds like perhaps you want a Map<String,Double> instead", "label": {"api": {"Map": [[34, 36]]}}}, {"text": "See, for example, HashMap", "label": {"api": {"HashMap": [[18, 24]], "Map": [[22, 24]]}}}, {"text": "See generic Map documentation for links to other types of maps in the JDK", "label": {"api": {"Map": [[12, 14]]}}}, {"text": "See also ConcurrentHashMap if a finer synchronization granularity is desired and/or acceptable", "label": {"api": {"HashMap": [[19, 25]], "Map": [[23, 25]], "ConcurrentHashMap": [[9, 25]]}}}, {"text": "One example is the Predicate interface which has only one abstract method (test) while providing default methods for negating a Predicate or combining it with another Predicate", "label": {"api": {"the Predicate interface": [[15, 37]]}}}]