[{"text": "Call fireTableCellUpdated() at the end of setValueAt() method", "label": {"api": {"fireTableCellUpdated()": [[5, 26]]}}}, {"text": "An alternative would be registering a HttpSessionListener and counting and storing them your self", "label": {"api": {"HttpSessionListener": [[38, 56]]}}}, {"text": "To do this properly, you need to use a ScheduledThreadPoolExecutor and use the function schedule like this", "label": {"api": {"schedule": [[88, 95]]}}}, {"text": "Depending on the OS and the background tasks, it could be 60 seconds, 62 seconds or 3 hours, while the scheduler above actually uses the correct OS implementation for scheduling and is therefore much more accurate", "label": {"api": {"schedule": [[103, 110]]}}}, {"text": "In addition this scheduler allows several other flexible ways to schedule tasks like at a fixed rate or fixed delay", "label": {"api": {"schedule": [[17, 24], [65, 72]]}}}, {"text": "ScheduledThreadPoolExecutor has this ability, but it's quite heavyweight", "label": {"api": {"ScheduledThreadPoolExecutor": [[0, 26]]}}}, {"text": "The method DatagramSocket.receive(DatagramPacket)  blocks until a packet is received", "label": {"api": {"DatagramSocket.receive(DatagramPacket)": [[11, 48]]}}}, {"text": "You can specfiy a timeout using DatagramSocket.setSoTimeout(int), if you want to periodically log whether a packet is received or not, or to check if your Thread is still running", "label": {"api": {"DatagramSocket.setSoTimeout(int)": [[32, 63]]}}}, {"text": "I was reading Oracles documentation on ThreadPoolExecutor and in particular about the queuing in case there are more requests than Threads available", "label": {"api": {"ThreadPoolExecutor": [[39, 56]]}}}, {"text": "Or you can have your class implement the Comparable interface and then Collections.sort(myList) would sort it according the compareTo method of that interface", "label": {"api": {"Comparable interface": [[41, 60]]}}}, {"text": "Now we know that Comparator is a Functional Interface", "label": {"api": {"Comparator": [[17, 26]], "Functional Interface": [[33, 52]]}}}, {"text": "A Functional Interface is the one with exactly one abstract method (though it may contain one or more default or static methods)", "label": {"api": {"Functional Interface": [[2, 21]]}}}, {"text": "Java nio package was designed to allow this", "label": {"api": {"Java nio package": [[0, 15]]}}}, {"text": "Because \"Each action in a thread happens-before every action in that thread that comes later in the program's order,\" one approach would be to let updateFile() invoke delete() when it is finished updating the file", "label": {"api": {"happens-before": [[33, 46]]}}}, {"text": "Look at method removeUpdate", "label": {"api": {"removeUpdate": [[15, 26]]}}}, {"text": "However, in your situation you do not need casting at all - you can go directly to byte, like this", "label": {"api": {"you can go directly to byte": [[60, 86]]}}}, {"text": "The above is possible because Float is a subclass of java.lang.Number, which provides the byteValue() method", "label": {"api": {"java.lang.Number": [[53, 68]]}}}, {"text": "The way to load webapp resources is to use the ServletContext.getResourceAsStream() method", "label": {"api": {"ServletContext.getResourceAsStream()": [[47, 82]]}}}, {"text": "Just browsing throw the reflection javadoc, I was not able to detect a way", "label": {"api": {"reflection javadoc": [[24, 41]]}}}, {"text": "The threads in the pool will exist until it is explicitly shutdown", "label": {"api": {"shutdown": [[58, 65]]}}}, {"text": "This page lists special symbols in Java regular expressions", "label": {"api": {"This page": [[0, 8]]}}}, {"text": "To do what you want, you can use a regular expression with String#replaceAll", "label": {"api": {"String#replaceAll": [[59, 75]]}}}, {"text": "What would cause a BackingStoreException exactly, and of all the methods in the Preferences API, why does this method (and not all of the others) require it to be caught", "label": {"api": {"Preferences API": [[80, 94]]}}}, {"text": "Reading this paragraph from the Preferences API docs does not help me much", "label": {"api": {"Preferences API": [[32, 46]]}}}, {"text": "From its javadoc (emphasis mine)", "label": {"api": {"its javadoc": [[5, 15]]}}}, {"text": "You need to have the actual instance of the object to pass in to the set method, not the Class object itself", "label": {"api": {"pass in to the set method": [[54, 78]]}}}, {"text": "Java has a ScriptEngine system that allows you to run/evaluate statements in a different language", "label": {"api": {"ScriptEngine": [[11, 22]]}}}, {"text": "Install your own X509KeyManager into the SSLContext, with your desired implementation of the chooseClientAlias() method", "label": {"api": {"chooseClientAlias()": [[93, 111]]}}}, {"text": "Why not use Vector instead", "label": {"api": {"Vector": [[12, 17]]}}}, {"text": "In Java, always use the equals method to check whether two strings have the same value", "label": {"api": {"equals": [[24, 29]]}}}, {"text": "Again, it's a lot simpler to call delete()", "label": {"api": {"delete()": [[34, 41]]}}}, {"text": "use string.matches(regex) function", "label": {"api": {"string.matches(regex)": [[4, 24]]}}}, {"text": "Check the Pattern class documentation for more details about this expression", "label": {"api": {"Pattern class documentation": [[10, 36]]}}}, {"text": "As Kronion said, the Polygon class does indeed accept an array of X coordinates, and an array of Y coordinates", "label": {"api": {"Polygon": [[21, 27]]}}}, {"text": "If that doesn't make any sense, examine the Polygon class source code", "label": {"api": {"Polygon": [[44, 50]]}}}, {"text": "I would make those methods synchronized, or replace the Map with a ConcurrentMap", "label": {"api": {"ConcurrentMap": [[67, 79]]}}}, {"text": "The second option would be to replace the Map with a Hashtable", "label": {"api": {"Hashtable": [[53, 61]]}}}, {"text": "De-normalizing the output of Random.nextGaussian() to your needs should be straightforward", "label": {"api": {"Random.nextGaussian()": [[29, 49]]}}}, {"text": "I don't want the image to be distorted, so I call setPreserveRatio(true)", "label": {"api": {"setPreserveRatio(true)": [[50, 71]]}}}, {"text": "Use JTextComponent.read(Reader,Object)1 (& forget the loop)", "label": {"api": {"JTextComponent.read(Reader,Object)": [[4, 37]]}}}, {"text": "You're looking for Normalizer", "label": {"api": {"Normalizer": [[19, 28]]}}}, {"text": "There is no equivalent to the Normalizer's functionality in SQL, and while some RDBMS system might offer one, SQLite certainly does not", "label": {"api": {"Normalizer": [[30, 39]]}}}, {"text": "I wrote a producer/consumer based program using Java's BlockingQueue", "label": {"api": {"BlockingQueue": [[55, 67]]}}}, {"text": "The best-practice system is to use a count-down latch", "label": {"api": {"count-down latch": [[37, 52]]}}}, {"text": "I think you're looking for Runtime.addShutdownHook", "label": {"api": {"Runtime.addShutdownHook": [[27, 49]]}}}, {"text": "I think you will find http://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html useful", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html": [[22, 94]]}}}, {"text": "Instead of directly using \\ or /, try adding a separator after it using File.seperator", "label": {"api": {"File.seperator": [[72, 85]]}}}, {"text": "If you want the type info use the ResultSetMetaData from the ResultSet.getMetaData() call", "label": {"api": {"ResultSetMetaData": [[34, 50]], "ResultSet.getMetaData()": [[61, 83]]}}}, {"text": "The annotation ManagedProperty, as explained in the linked javadoc, should be used  to inject a JSF bean annotated with ManagedBean", "label": {"api": {"ManagedProperty": [[15, 29]]}}}, {"text": "Take a look at the java.util.Random class", "label": {"api": {"java.util.Random class": [[19, 40]]}}}, {"text": "Then just construct a new String with this char array (using the constructor String(char[] value)) and you'll get your word", "label": {"api": {"String(char[] value)": [[77, 96]]}}}, {"text": "The default JTree constructor \"Returns a JTree with a sample model.\" To get the sample model, the constructor invokes the protected method getDefaultTreeModel(), which returns a sample model that is \"Used primarily for beanbuilders to show something interesting.\" The values you see are contained in the source", "label": {"api": {"JTree": [[12, 16], [41, 45]]}}}, {"text": "You need to use a FileInputStream and the load method", "label": {"api": {"load method": [[42, 52]]}}}, {"text": "First of all, don't use nextLine after nextInt, since the latter doesn't consume the \\n char, and it'll be swallowed in the nextLine, making it skipping the real input you wanted to insert", "label": {"api": {"nextLine": [[24, 31], [124, 131]], "nextInt": [[39, 45]]}}}, {"text": "Add another nextLine right after nextInt to consume the \\n", "label": {"api": {"nextLine": [[12, 19]], "nextInt": [[33, 39]]}}}, {"text": "The  java.util.Properties Class extends the java.util.HashTable Class, so has a keys() method", "label": {"api": {"java.util.Properties": [[5, 24]]}}}, {"text": "Instead of that, simply call setJMenuBar method from your JFrame instance", "label": {"api": {"setJMenuBar": [[29, 39]]}}}, {"text": "I would suggest A blockig queue", "label": {"api": {"A blockig queue": [[16, 30]]}}}, {"text": "You can use Arrays.#asList(T...) to construct a new ArrayList containing the elements in the messageList array", "label": {"api": {"Arrays.#asList(T...)": [[12, 31]]}}}, {"text": "List elements must be adressed via List#get instead", "label": {"api": {"List#get": [[35, 42]]}}}, {"text": "What you might be looking for is the Servlet API's ServletContainerInitializer or Spring's WebApplicationInitializer to perform Java configuration", "label": {"api": {"ServletContainerInitializer": [[51, 77]]}}}, {"text": "In either of these, you will have access to the ServletContext where you can add context parameters and listeners", "label": {"api": {"ServletContext": [[48, 61]], "add context parameters": [[77, 98]], "listeners": [[104, 112]]}}}, {"text": "As other answers say, println is printing hashcode of the array", "label": {"api": {"hashcode": [[42, 49]]}}}, {"text": "If you want to see array's contents, you can iterate over every element and print it OR you can use Arrays.toString() methods", "label": {"api": {"Arrays.toString()": [[100, 116]], "Arrays": [[100, 105]]}}}, {"text": "If you have multidimensional arrays, use Arrays.deepToString()", "label": {"api": {"Arrays.deepToString()": [[41, 61]], "Arrays": [[41, 46]]}}}, {"text": "Explore Arrays class for more such utility methods", "label": {"api": {"Arrays": [[8, 13]]}}}, {"text": "My problem is that ResultSet lacks a lot of functionality that I want (for instance a getRow() method that would return the whole row or a getNumberOfRows() method that would tell me how many rows are in the ResultSet)", "label": {"api": {"ResultSet": [[19, 27], [208, 216]]}}}, {"text": "No offense to anyone who loves the ResultSet class", "label": {"api": {"ResultSet": [[35, 43]]}}}, {"text": "In Java 7 I can use Integer.compare, but when I try to use it in Java 6 it gives me the error", "label": {"api": {"Integer.compare": [[20, 34]]}}}, {"text": "I'm sure there are more elegant solutions, but a simple one would be to use split() function", "label": {"api": {"split()": [[76, 82]]}}}, {"text": "System.out.printf(\"%.4f\", value) or String.format()", "label": {"api": {"System.out.printf(\"%.4f\", value)": [[0, 31]], "String.format()": [[36, 50]]}}}, {"text": "If you are merely trying to generate a number in [0, 10000), you can use Random.nextInt(int) with a range specified, or simply cast the value to an int as above (optionally rounding)", "label": {"api": {"Random.nextInt(int)": [[73, 91]]}}}, {"text": "Use Scanner#nextLine(), or any of its \"cousins\", to suit your needs in your program", "label": {"api": {"Scanner#nextLine()": [[4, 21]]}}}, {"text": "Recall the signature for parseInt()", "label": {"api": {"parseInt()": [[25, 34]]}}}, {"text": "If you really think contention is going to be an issue, this is a case for a java.util.concurrent.locks.ReadWriteLock", "label": {"api": {"java.util.concurrent.locks.ReadWriteLock": [[77, 116]]}}}, {"text": "You can avoid resizing arrays by first counting how many array elements the result is going to have, creating the result array, and then scan the array from the beginning again for the next position of \"userX\", and calling arrayCopy to copy the elements into the sub-arrays of the output array", "label": {"api": {"arrayCopy": [[223, 231]]}}}, {"text": "I would suggest you use a Scanner (for an example) and then loop over each character (in each token) and throw your Exception if your criteria are met (e.g", "label": {"api": {"Scanner": [[26, 32]]}}}, {"text": "look at Character.isDigit) or just write your own method to test against acceptable characters (e.g", "label": {"api": {"Character.isDigit": [[8, 24]]}}}, {"text": "Wrap the input stream in a DataInputStream and then use the readInt() and readFully() methods to get the size and bytes of data out", "label": {"api": {"DataInputStream": [[27, 41]], "readFully()": [[74, 84]]}}}, {"text": "Use a java.util.concurrent.CyclicBarrier", "label": {"api": {"java.util.concurrent.CyclicBarrier": [[6, 39]]}}}, {"text": "You should probably use the Collection.contains method (or write something similar for your Array) from a Set because they prevent duplicates", "label": {"api": {"Collection.contains": [[28, 46]], "Set": [[106, 108]]}}}, {"text": "A SortedSet (e.g", "label": {"api": {"Set": [[8, 10]], "SortedSet": [[2, 10]]}}}, {"text": "TreeSet) does have performance optimizations for some use cases", "label": {"api": {"Set": [[4, 6]], "TreeSet": [[0, 6]]}}}, {"text": "itr.next(); Returns an Object in your case", "label": {"api": {"itr.next();": [[0, 10]]}}}, {"text": "Sounds like an ideal job for CountDownLatch", "label": {"api": {"CountDownLatch": [[29, 42]]}}}, {"text": "When all 10 threads have finished, the CountDownLatch will let the original thread run, and it can perform the cleanup", "label": {"api": {"CountDownLatch": [[39, 52]]}}}, {"text": "And fire up an ExecutorService with 10 fixed threads to run the tasks", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "If each thread terminates after it is finished, you could just use the join() statement", "label": {"api": {"join()": [[71, 76]]}}}, {"text": "The other answers all have their merits and are very useful in practice, the join() is however the most basic of the constructs", "label": {"api": {"join()": [[77, 82]]}}}, {"text": "TreeMap accepts a custom comparator also", "label": {"api": {"TreeMap accepts a custom comparator": [[0, 34]]}}}, {"text": "Java provides an interface named HyperlinkListener", "label": {"api": {"HyperlinkListener": [[33, 49]]}}}, {"text": "With HyperlinkListener you can detect which link is being triggered", "label": {"api": {"HyperlinkListener": [[5, 21]]}}}, {"text": "Use an EnumMap to store your precipitationMonths array instead", "label": {"api": {"EnumMap": [[7, 13]]}}}, {"text": "You can use a Map<String, PersonDetails>", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "Have you tried BlockingQueue yet.It will ease your asynchronous task and is based on producer consumer approach , where consumer will do your task asynchronously", "label": {"api": {"BlockingQueue": [[15, 27]]}}}, {"text": "Class Date has constructor Date(long date)", "label": {"api": {"has constructor": [[11, 25]]}}}, {"text": "Here are the docs for the Comparable interface, which String implements", "label": {"api": {"Here are the docs": [[0, 16]]}}}, {"text": "The Integer class however provides an useful function Integer.toBinaryString(int) to convert the given integer to binary String", "label": {"api": {"Integer.toBinaryString(int)": [[54, 80]]}}}, {"text": "Behind the scenes, Java will transform any += instruction into a code that uses StringBuilder", "label": {"api": {"StringBuilder": [[80, 92]]}}}, {"text": "The easiest and the shortest is to cast the node to org.w3c.dom.Element and then invoke setAttribute on it", "label": {"api": {"org.w3c.dom.Element": [[52, 70]], "setAttribute": [[88, 99]]}}}, {"text": "However, if the need strikes you, you can use Java 8 Optional and lambdas to put this kind of logic into a single statement", "label": {"api": {"Optional": [[53, 60]]}}}, {"text": "The way to get rid of leading and trailing whitespace is to use trim(); e.g", "label": {"api": {"trim()": [[64, 69]]}}}, {"text": "Use a Calendar instance", "label": {"api": {"Calendar": [[6, 13]]}}}, {"text": "You should use the logging framework like log4j or Java logging API", "label": {"api": {"Java logging API": [[51, 66]]}}}, {"text": "Compare with the compareTo method on String", "label": {"api": {"compareTo method on String": [[17, 42]]}}}, {"text": "You may try MessageFormat class", "label": {"api": {"MessageFormat": [[12, 24]]}}}, {"text": "Executors.newCachedThreadPool() uses Executors.defaultThreadFactory() for its ThreadFactory", "label": {"api": {"Executors.defaultThreadFactory()": [[37, 68]], "Thread": [[19, 24], [54, 59], [78, 83]]}}}, {"text": "defaultThreadFactory's javadocs say that \"each new thread is created as a non-daemon thread\" (emphasis added)", "label": {"api": {"Thread": [[7, 12]]}}}, {"text": "So, the threads created for the newCachedThreadPool are non-daemon", "label": {"api": {"Thread": [[41, 46]]}}}, {"text": "The reason the app finishes at all is that each thread created within the newCachedThreadPool times out and closes itself after some time of inactivity", "label": {"api": {"Thread": [[83, 88]]}}}, {"text": "You can (and should) close the ExecutorService down manually via shutdown or shutdownNow", "label": {"api": {"shutdown": [[65, 72], [77, 84]]}}}, {"text": "See also the JavaDoc for Thread, which talks about daemon-ness", "label": {"api": {"Thread": [[25, 30]]}}}, {"text": "In your People class you need to implement an equals method", "label": {"api": {"equals": [[46, 51]]}}}, {"text": "Basically you need to implement object equality by using Java's equals and hashcode in the Object class", "label": {"api": {"equals": [[64, 69]], "hashcode": [[75, 82]]}}}, {"text": "You could use a dynamic array such as an ArrayList, which grows in size automatically, to store the matched words (instead of vowel)", "label": {"api": {"ArrayList": [[41, 49]]}}}, {"text": "See the JavaDoc on Comparator for more information", "label": {"api": {"JavaDoc on Comparator": [[8, 28]]}}}, {"text": "You can see this clearly in the getResource javadoc", "label": {"api": {"getResource javadoc": [[32, 50]]}}}, {"text": "The getClass method is defined on Object (so it's available for all reference types) and looks up the object's type at runtime", "label": {"api": {"getClass": [[4, 11]]}}}, {"text": "This what I said check out Component", "label": {"api": {"Component": [[27, 35]]}}}, {"text": "As you can see on documentation, the function uses a class called Random(), wich uses a 48-bit seed, and generate a uniform distribution", "label": {"api": {"Random()": [[66, 73]]}}}, {"text": "Date is largely deprecated, you want Calendar", "label": {"api": {"Calendar": [[37, 44]]}}}, {"text": "It is explained in the javadoc for Class.getResourceAsStream", "label": {"api": {"Class.getResourceAsStream": [[35, 59]]}}}, {"text": "This will generate 10 random integers between 10 and 100, perform the count of even and odd and finally display the counts", "label": {"api": {"random integers": [[22, 36]]}}}, {"text": "Since Java 7 use the utility functions class Files", "label": {"api": {"Files": [[45, 49]]}}}, {"text": "Since Java 7, you can use the Files utility class, with the new Path class", "label": {"api": {"Files": [[30, 34]], "Path": [[64, 67]]}}}, {"text": "You need to use the get() method to get the element at a particular index from an ArrayList", "label": {"api": {"get()": [[20, 24]]}}}, {"text": "What you are searching for is a ListIterator which would allow you to iterate backwards in a list", "label": {"api": {"ListIterator": [[32, 43]]}}}, {"text": "an ArrayList or a LinkedList which provide a ListIterator and thus, backwards iteration", "label": {"api": {"ListIterator": [[45, 56]]}}}, {"text": "You could use the ListIterator for this, by doing something like this", "label": {"api": {"ListIterator": [[18, 29]]}}}, {"text": "Get a ListIterator from the last index, so that you can traverse backwards having a counter(which I've not shown) to iterator till the no", "label": {"api": {"ListIterator": [[6, 17]]}}}, {"text": "They are there to request special features for java agents using the instrumentation feature of the JVM", "label": {"api": {"instrumentation": [[69, 83]]}}}, {"text": "Agents can register ClassFileTransformers which are called one after another to apply transformations to the byte code before the class will be initialized", "label": {"api": {"ClassFileTransformers": [[20, 40]]}}}, {"text": "In this case an agent may invoke Instrumentation.retransformClasses specifying which classes to retransform but no bytecode", "label": {"api": {"Instrumentation.retransformClasses": [[33, 66]]}}}, {"text": "Instead the JVM will call all registered retransforming capable ClassFileTransformers providing the actual bytecode (or the result of the previous transformer for a chained transformer)", "label": {"api": {"ClassFileTransformers": [[64, 84]]}}}, {"text": "Setting a native method prefix is even more special; it might be usefull when instrumenting native methods", "label": {"api": {"Setting a native method prefix": [[0, 29]]}}}, {"text": "With a single Iterator and Set.contains(Object)", "label": {"api": {"Set.contains(Object)": [[27, 46]]}}}, {"text": "You can use a SimpleDateFormat to format a date as per your requirements", "label": {"api": {"SimpleDateFormat": [[14, 29]]}}}, {"text": "Java 7 has brand new API for woring with file system - WatcherService can be used to see changes on FS", "label": {"api": {"WatcherService can be used to see changes on FS": [[55, 101]]}}}, {"text": "Nowadays, you can declare and map a servlet using the @WebServlet annotation, and the  name attribute of this annotation is optional", "label": {"api": {"@WebServlet": [[54, 64]]}}}, {"text": "You should annotate fields you want to exclude from response with @XmlTransient", "label": {"api": {"@XmlTransient": [[66, 78]]}}}, {"text": "In Java 8, a variety of convenient utilities are provided to build efficient Spliterators from arrays", "label": {"api": {"convenient utilities": [[24, 43]]}}}, {"text": "Clearly Spliterators are allowed to have attached comparators; they have a getComparator() method and a SORTED property", "label": {"api": {"getComparator()": [[75, 89]], "SORTED": [[104, 109]]}}}, {"text": "How are library authors supposed to build SORTED Spliterators", "label": {"api": {"SORTED": [[42, 47]]}}}, {"text": "Assuming you're working on an image with an Alpha RGB BufferedImage you should use getAlpha()", "label": {"api": {"BufferedImage": [[54, 66]], "getAlpha()": [[83, 92]]}}}, {"text": "Take a look at the JavaDoc for Class.getDeclaredMethods()", "label": {"api": {"JavaDoc for Class.getDeclaredMethods()": [[19, 56]]}}}, {"text": "You will have to use Math.pow", "label": {"api": {"Math.pow": [[21, 28]]}}}, {"text": "You are implementing the raw version of Comparable, whose compareTo method takes an Object", "label": {"api": {"Comparable": [[40, 49]]}}}, {"text": "Implement the generic version of Comparable instead", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "The MessageFormat documentation states that rules for quotes are somewhat confusing, and then goes on to provide only a single example that only uses double-quotes", "label": {"api": {"MessageFormat documentation": [[4, 30]]}}}, {"text": "Finally, the formatting of a message for output requires that apostrophes be doubled because apostrophe is the escape character for Java MessageFormat", "label": {"api": {"Java MessageFormat": [[132, 149]]}}}, {"text": "You can use a Calendar", "label": {"api": {"Calendar": [[14, 21]]}}}, {"text": "KeyAdapter is in java.awt.event", "label": {"api": {"KeyAdapter is in java.awt.event": [[0, 30]]}}}, {"text": "To correctly testing for equality in Strings use String.equals or String.equalsIgnoreCase for a case insensitive equality test", "label": {"api": {"String.equals": [[49, 61], [66, 78]], "String.equalsIgnoreCase": [[66, 88]]}}}, {"text": "Look into the printf method instead, which understands formatting patterns", "label": {"api": {"the printf method": [[10, 26]]}}}, {"text": "Use the Arrays.toString method, suited for converting arrays to strings", "label": {"api": {"Arrays.toString method": [[8, 29]]}}}, {"text": "You can try using Arrays.asList()", "label": {"api": {"Arrays.asList()": [[18, 32]]}}}, {"text": "Second, use equals to compare String values, not the == (or in this case !=) operators", "label": {"api": {"equals": [[12, 17]]}}}, {"text": "Or an alternative is to make a temporary List and use contains, which might be clearer for longer lists of things to test", "label": {"api": {"make a temporary List": [[24, 44]], "contains": [[54, 61]]}}}, {"text": "Please refer to GenericEntity", "label": {"api": {"GenericEntity": [[16, 28]]}}}, {"text": "It seems that you tried to use a Integer but you reached the max value that is 2^31, for   7708166193 you should use Long instead", "label": {"api": {"Integer": [[33, 39]], "Long": [[117, 120]]}}}, {"text": "You want to use the compareAndSet(...) method", "label": {"api": {"compareAndSet(...)": [[20, 37]]}}}, {"text": "Luckily, the AtomicReference class has the getAndUpdate(...) method which merely invokes compareAndSet(...) in a loop", "label": {"api": {"getAndUpdate(...)": [[43, 59]]}}}, {"text": "You might also want to take a look at the CompletableFuture class", "label": {"api": {"CompletableFuture": [[42, 58]]}}}, {"text": "You can keep the movie titles in a TreeMap", "label": {"api": {"TreeMap": [[35, 41]]}}}, {"text": "A TreeMap is implemented using a Red-Black tree, which is a self-balancing binary search tree", "label": {"api": {"TreeMap": [[2, 8]]}}}, {"text": "Maintain a TreeMap (say, allMovies) with movie titles as keys and the actual movie object (on which you are callinggetCopies()) as values", "label": {"api": {"TreeMap": [[11, 17]]}}}, {"text": "The TRUE and FALSE instances are the instances returned by Boolean.valueOf()", "label": {"api": {"Boolean.valueOf()": [[59, 75]]}}}, {"text": "The TRUE and FALSE static instances help performance a bit, and the javadocs recommend using Boolean.valueOf() as opposed to new Boolean(...) for that reason", "label": {"api": {"Boolean.valueOf()": [[93, 109]]}}}, {"text": "I am trying to implement an OrderedMapEntry list with custom MapEntries - as I need a custom solution with Vectors I cannot use a TreeMap(http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html": [[138, 200]]}}}, {"text": "The size of Arrays cannot be changed so either you would need to use an ArrayList instead like Rohit Jain says as these can be expanded and shortened when you add and remove items", "label": {"api": {"ArrayList": [[72, 80]]}}}, {"text": "So yes, use an ArrayList", "label": {"api": {"ArrayList": [[15, 23]]}}}, {"text": "The default implementation (see URLClassLoader) already does the right thing", "label": {"api": {"URLClassLoader": [[32, 45]]}}}, {"text": "HashSet#contains method can't serve your requirement, it implicitly call equals method", "label": {"api": {"HashSet#contains": [[0, 15]]}}}, {"text": "I guess com.sun.tools.javac.Main.compile ends up by calling an external Process", "label": {"api": {"Process": [[72, 78]]}}}, {"text": "The documentation for System can be useful, particularly setErr and setOut", "label": {"api": {"System": [[22, 27]], "setErr": [[57, 62]], "setOut": [[68, 73]]}}}, {"text": "Or instead of doing System.setOut & System.setErr you write a class ABC with public static printstreams like System", "label": {"api": {"System": [[20, 25], [36, 41], [109, 114]], "setErr": [[43, 48]], "setOut": [[27, 32]], "printstreams": [[91, 102]]}}}, {"text": "When you call the ABC.out.print or ABC.err.print methods, the class adds the timestamp then directs it to System.out & System.err respectively", "label": {"api": {"System": [[106, 111], [119, 124]]}}}, {"text": "Split the array according to whitespaces", "label": {"api": {"Split": [[0, 4]]}}}, {"text": "Thread provides .isInterrupted(), but as said here", "label": {"api": {".isInterrupted()": [[16, 31]]}}}, {"text": "“By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so.” So I can’t tell from .isInterrupted() either", "label": {"api": {".isInterrupted()": [[137, 152]]}}}, {"text": "Date.getTime() returns milliseconds", "label": {"api": {"Date.getTime()": [[0, 13]]}}}, {"text": "You want to use the isInstance method of the Class class", "label": {"api": {"isInstance": [[20, 29]], "Class": [[45, 49]]}}}, {"text": "See File official documentation", "label": {"api": {"File": [[4, 7]]}}}, {"text": "If you check the Javadoc for the HttpServletRequest class, this \"can interfere with the execution\" of the getParameter method", "label": {"api": {"\"can interfere with the execution\" of the getParameter method": [[64, 124]]}}}, {"text": "Note that if you don’t need a lookup regarding equal instances in the sense of the equals method but want to look up the instances you can use a IdentityHashMap", "label": {"api": {"IdentityHashMap": [[145, 159]]}}}, {"text": "As you can see this custom fault exception extends Exception and not SOAPFaultException", "label": {"api": {"SOAPFaultException": [[69, 86]]}}}, {"text": "Hovewer I need to get SOAP fault's faultcode which could be retrieved only from SOAPFaultException using getFaultCode method", "label": {"api": {"SOAPFaultException": [[80, 97]], "getFaultCode": [[105, 116]]}}}, {"text": "Could you tell me how can I reach SOAPFaultException or SOAP fault's faultcode in place where I catch above mentioned custom fault exception", "label": {"api": {"SOAPFaultException": [[34, 51]]}}}, {"text": "You could implement a JAX-WS handler and add it to your client web service reference", "label": {"api": {"handler": [[29, 35]]}}}, {"text": "Assign your new fault handler to your web service ref", "label": {"api": {"handler": [[22, 28]]}}}, {"text": "Number itself is abstract class", "label": {"api": {"Number": [[0, 5]]}}}, {"text": "Integer is child class of Number", "label": {"api": {"Number": [[26, 31]], "Integer": [[0, 6]]}}}, {"text": "May be, in your case it's enough to check whether object's instanse is Integer or not", "label": {"api": {"Integer": [[71, 77]]}}}, {"text": "Collections.replaceAll(List<T> list, T oldVal, T newVal) function it will replace all of the occurrence of oldVal to newVal", "label": {"api": {"Collections.replaceAll(List<T> list, T oldVal, T newVal)": [[0, 55]]}}}, {"text": "Another one is ArrayList.set(index, E elm) function", "label": {"api": {"ArrayList.set(index, E elm)": [[15, 41]]}}}, {"text": "You can however, go getPath() on your URL Object which will just return your path like", "label": {"api": {"getPath()": [[20, 28]], "URL": [[38, 40]]}}}, {"text": "to the start and replace the .jar within the getPath() with .jar", "label": {"api": {"getPath()": [[45, 53]]}}}, {"text": "Also you are using the method matches and I doubt you have a list of regular expressions so you probably want to be using the method equals instead", "label": {"api": {"matches": [[30, 36]], "equals": [[133, 138]]}}}, {"text": "You want to use a DataInputStream", "label": {"api": {"DataInputStream": [[18, 32]]}}}, {"text": "The parameterless List#toArray() method creates an Object[] internally, which you cannot cast to Foo[]", "label": {"api": {"List#toArray()": [[18, 31]]}}}, {"text": "To overcome this issue, a generic method List#toArray(T[]) is there, in which you can pass the actual array, that will be filled by the elements of the ArrayList", "label": {"api": {"List#toArray(T[])": [[41, 57]]}}}, {"text": "I do not see an API call for the console in the webstart API", "label": {"api": {"API": [[16, 18], [57, 59]]}}}, {"text": "Watch out for the format pattern where, unlike PHP, M is month in year and m is minute in hour", "label": {"api": {"format pattern": [[18, 31]]}}}, {"text": "The split method returns an array, not an ArrayList", "label": {"api": {"split method": [[4, 15]]}}}, {"text": "So, cutting through all these random implementation-specific behaviours, you can probably figure out if it's a directory by first trying to access the resource with a trailing / (which is what URLClassLoaders expect for directories anyway)", "label": {"api": {"which is what URLClassLoaders expect for directories anyway": [[179, 237]]}}}, {"text": "You need to use the modPow method of the BigInteger class", "label": {"api": {"BigInteger class": [[41, 56]]}}}, {"text": "Well, as R is not documented to mean anything but the documentation clearly says all other formatting characters \"...from 'A' to 'Z' and from 'a' to 'z' are reserved...\", all bets are off about what you'll get if you use R in the formatting string", "label": {"api": {"not documented to mean anything": [[14, 44]]}}}, {"text": "No, these non-affine transforms are not supported by the JavaFX 2.2 Transform class, nor are they supported by the JavaFX 8 Transform class", "label": {"api": {"JavaFX 2.2 Transform": [[57, 76]]}}}, {"text": "You can apply a PerspectiveTransform to 2D nodes", "label": {"api": {"PerspectiveTransform": [[16, 35]]}}}, {"text": "However, the math still holds and you can apply it to JavaFX through either a PerspectiveTransform or by modifying the points in a TriangleMesh using a custom matrix definition", "label": {"api": {"PerspectiveTransform": [[78, 97]]}}}, {"text": "Note, a limitation of PerspectiveTransform is picking (mouse selection) doesn't work", "label": {"api": {"PerspectiveTransform": [[22, 41]]}}}, {"text": "The View class directly inherits from JFrame", "label": {"api": {"JFrame": [[38, 43]]}}}, {"text": "As I just learnt, all GUI-related stuff should be wrapped in a SwingUtilities.invokeLater or something similar", "label": {"api": {"SwingUtilities.invokeLater": [[63, 88]]}}}, {"text": "Look at CountDownLatch and CyclicBarrier", "label": {"api": {"CountDownLatch": [[8, 21]], "CyclicBarrier": [[27, 39]]}}}, {"text": "The Java concurrent package should have all the tools you need, including a CyclicBarrier and a Phaser (reusable barrier)", "label": {"api": {"concurrent package": [[9, 26]]}}}, {"text": "Okay, maybe with something like this http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Field.html it could be possible", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Field.html": [[37, 105]]}}}, {"text": "You sign with a PRIVATE key and verify the signature with a corresponding PUBLIC key", "label": {"api": {"verify": [[32, 37]]}}}, {"text": "The client just sends the client public key to the server so the server can verify the signature", "label": {"api": {"verify": [[76, 81]]}}}, {"text": "See Java String for more details", "label": {"api": {"Java String": [[4, 14]]}}}, {"text": "Use the Java Signature class (specifically the verify method) to check the signature", "label": {"api": {"Java Signature": [[8, 21]], "verify": [[47, 52]]}}}, {"text": "The best way I know of to handle this condition (using a primitive column type and a JDBC ResultSet) is with the wasNull method on ResultSet", "label": {"api": {"wasNull": [[113, 119]]}}}, {"text": "Use List.remove(Object) instead of List.remove(int)", "label": {"api": {"List.remove(Object)": [[4, 22]]}}}, {"text": "Since Java uses by default Java Logging, add the following code", "label": {"api": {"Java Logging": [[27, 38]]}}}, {"text": "Take a look at KeyStroke#getKeyStroke(int, int, boolean), which will allow you to define a key stroke for a key release rather then key press", "label": {"api": {"KeyStroke#getKeyStroke(int, int, boolean)": [[15, 55]]}}}, {"text": "Use Collections.sort(java.util.List, java.util.Comparator) which takes an additional Comparator argument", "label": {"api": {"Collections.sort(java.util.List, java.util.Comparator)": [[4, 57]], "Comparator": [[47, 56], [85, 94]]}}}, {"text": "You're getting the error because toArray() returns Object[] and this cannot be cast down to String[]", "label": {"api": {"toArray()": [[33, 41]]}}}, {"text": "You need to mention the type of array, else by default, toArray() would return an array of Object which can't be simply casted to String[]", "label": {"api": {"toArray()": [[56, 64]]}}}, {"text": "If you specify the type, the overloaded toArray(T[]) would be called, returning the type of array mentioned as the parameter", "label": {"api": {"toArray(T[])": [[40, 51]]}}}, {"text": "An object's hash code is typically calculated from its internal address (ref http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode%28%29) so if you're re-running the program with an identical state, the address of the object in memory is likely to be the same each time", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode%28%29": [[77, 153]]}}}, {"text": "If your DER files are in PKCS#8 format, you can use the Java KeyFactory and do something like this", "label": {"api": {"KeyFactory": [[61, 70]]}}}, {"text": "I'm sure there is a more elegant solution than this, but you could create several KeyFactory objects (one for each possible algorithm) and try to generatePrivate() on each one until you do not get an InvalidKeySpecException", "label": {"api": {"KeyFactory": [[82, 91]]}}}, {"text": "You can use the Semaphore class, with a fairness setting set to true and a count of 1", "label": {"api": {"Semaphore": [[16, 24]]}}}, {"text": "If so then I'd suggest you don't use MouseListener on the JSpinner but attach a FocusListener to the spinner's editor instead", "label": {"api": {"FocusListener": [[80, 92]]}}}, {"text": "So why cant I use Collections.sort", "label": {"api": {"Collections.sort": [[18, 33]]}}}, {"text": "Collections.sort Isn't double a comparable datatype", "label": {"api": {"Collections.sort": [[0, 15]]}}}, {"text": "You can use java.util.Scanner for input", "label": {"api": {"java.util.Scanner": [[12, 28]]}}}, {"text": "System.in is an InputStream", "label": {"api": {"InputStream": [[16, 26]]}}}, {"text": "You use Scanner's readline method to get an input String, and the String returned has a toCharArray() method", "label": {"api": {"readline": [[18, 25]]}}}, {"text": "Use rather one of the Executors and limit the number of threads in this way", "label": {"api": {"Executors": [[22, 30]]}}}, {"text": "Otherwise, if this is a properties file, you could always use the Properties.load method", "label": {"api": {"Properties.load": [[66, 80]]}}}, {"text": "It will fail for the same reason 2147483648 (one more than Integer.MAX_VALUE) will fail for Integer.parseInt", "label": {"api": {"Integer.parseInt": [[92, 107]]}}}, {"text": "Scanner.nextInt(int radix) matches a regular expression to see if it could be an int, then it passes it to Integer.parseInt for parsing", "label": {"api": {"Scanner.nextInt(int radix)": [[0, 25]], "Integer.parseInt": [[107, 122]]}}}, {"text": "If the next token matches the Integer regular expression defined above then the token is converted into an int value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Integer.parseInt with the specified radix", "label": {"api": {"Integer.parseInt": [[417, 432]]}}}, {"text": "Integer.parseInt will throw a NumberFormatException if it can't be represented as an int", "label": {"api": {"Integer.parseInt": [[0, 15]]}}}, {"text": "Consider using a List instead of an array", "label": {"api": {"List": [[17, 20]]}}}, {"text": "For easier and less error-prone threading concepts, you should use the concurrent package, which has ready-made tools available for most problems out there", "label": {"api": {"concurrent package": [[71, 88]]}}}, {"text": "Nowadays you might prefer using one of the implementations of Lock", "label": {"api": {"Lock": [[62, 65]]}}}, {"text": "Consider using a ReentrantReadWriteLock instead which will give you the benefit of having a practically unlimited amount of concurrent readers", "label": {"api": {"ReentrantReadWriteLock": [[17, 38]]}}}, {"text": "Here is a version of your class using a ReentrantReadWriteLock that will allow concurrent readers (also, write locks can \"degrade\" to read locks, not the other way around though)", "label": {"api": {"ReentrantReadWriteLock": [[40, 61]]}}}, {"text": "In my test below, why is Aa.class.getClasses() returning [] not [A.class]", "label": {"api": {"Aa.class.getClasses()": [[25, 45]]}}}, {"text": "What you want is Class.getInterfaces()", "label": {"api": {"Class.getInterfaces()": [[17, 37]]}}}, {"text": "If you're reading the image from a hdd it maybe would help to read it by using a BufferedInputStream", "label": {"api": {"BufferedInputStream": [[81, 99]]}}}, {"text": "You can disable the disk caching (at the cost of using more memory) with ImageIO.setUseCache(false)", "label": {"api": {"ImageIO.setUseCache(false)": [[73, 98]]}}}, {"text": "It's also possible to set the cache directory to a specific path using ImageIO.setCacheDirectory(cacheDirectory), if you have a faster disk/ramdisk or similar to store your temp files", "label": {"api": {"ImageIO.setCacheDirectory(cacheDirectory)": [[71, 111]]}}}, {"text": "But you map the association with @PrimaryKeyJoinColumn, which means", "label": {"api": {"@PrimaryKeyJoinColumn": [[33, 53]]}}}, {"text": "This appears to be a feature of the DefaultMenuLayout, seen here", "label": {"api": {"DefaultMenuLayout": [[36, 52]]}}}, {"text": "In Java 7, use the invokeWithArguments method", "label": {"api": {"invokeWithArguments": [[19, 37]]}}}, {"text": "For java.util.logging you would use isLoggable", "label": {"api": {"isLoggable": [[36, 45]]}}}, {"text": "Otherwise without arrays, use lastIndexOf", "label": {"api": {"lastIndexOf": [[30, 40]]}}}, {"text": "The newcaseid var is a org.w3c.dom.Node, and can not be used directly in Expression language", "label": {"api": {"org.w3c.dom.Node": [[23, 38]]}}}, {"text": "(this is basically what @MadProgrammer suggested, except that equals is used in the defintion, and hashCode is just optional for possible implementations)", "label": {"api": {"equals is used in the defintion, and hashCode is just optional for possible implementations": [[62, 152]]}}}, {"text": "Replace the call of an instance method compareTo with the call of static compare method, like this", "label": {"api": {"static compare method": [[66, 86]]}}}, {"text": "You can check the format of the date by using a SimpleDateFormat like this, because using regex for validating date formats is a very bad practice, IMHO", "label": {"api": {"SimpleDateFormat": [[48, 63]]}}}, {"text": "Fore more information you may look at http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html and  http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html in particular", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html": [[38, 114]], "http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html": [[121, 206]]}}}, {"text": "I wanted to use DataOutputStream#writeBytes, but was running into errors", "label": {"api": {"DataOutputStream#writeBytes": [[16, 42]]}}}, {"text": "You may look into the writeUTF(String s) method, which, retains the information in the high-order byte as well as the length of the string", "label": {"api": {"writeUTF(String s)": [[22, 39]]}}}, {"text": "StringTokenizer will help here", "label": {"api": {"StringTokenizer": [[0, 14]]}}}, {"text": "Use a HashMap, then assign each line to a key in the HashMap", "label": {"api": {"HashMap": [[6, 12], [53, 59]]}}}, {"text": "The HashMap will retain only the latest assigned value, so you can decide if you want to reassign it or not depending on its date", "label": {"api": {"HashMap": [[4, 10]]}}}, {"text": "If you need to preserve the original order of the lines, you can use a LinkedHashMap which preserves insertion order", "label": {"api": {"HashMap": [[77, 83]], "LinkedHashMap": [[71, 83]]}}}, {"text": "You can use a Comparator to sort the list according to their race duration and also use for-each loop in Java", "label": {"api": {"Comparator": [[14, 23]]}}}, {"text": "Then I would create a class that implements Comparator<Participant> (perhaps ParticipantComparator) (Comparator javadocs) that knows how to compare Participants based on the results of the call to getTimeOfLastCheckPoint()", "label": {"api": {"Comparator javadocs": [[101, 119]]}}}, {"text": "It is also possible to redirect the STDOUT with System.setOut(), with log4j, etc..", "label": {"api": {"System.setOut()": [[48, 62]]}}}, {"text": "See the <c:url> and <c:param> JSP tags, and the URLEncoder class, for example", "label": {"api": {"URLEncoder": [[48, 57]]}}}, {"text": "See URLEncoder for details", "label": {"api": {"URLEncoder": [[4, 13]]}}}, {"text": "If you want the ArrayLists to store per-client info and access it by client ID, I suggest just using a java.util.concurrent.ConcurrentHashMap with the client ID as key, as that is very straightforward to implement", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[103, 140]]}}}, {"text": "You've seen the results of Object's toString() method; arrays are objects too", "label": {"api": {"Object's toString() method": [[27, 52]]}}}, {"text": "Instead, you can use a FileWriter", "label": {"api": {"FileWriter": [[23, 32]]}}}, {"text": "new FileWriter(\"timeWorked.dat\", true), which opens the file for appending", "label": {"api": {"FileWriter": [[4, 13]]}}}, {"text": "Math.random() returns a double in the range [0-1), which is not what you want", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "You can create a new Random() object and call its nextInt(max) method in order to get a uniformly random number between 0 and max (not including max)", "label": {"api": {"nextInt(max)": [[50, 61]]}}}, {"text": "Scanner#next reads the next token from the input string based on whatever delimiter you have set for your Scanner object when you create it", "label": {"api": {"Scanner#next": [[0, 11]]}}}, {"text": "You have to do it by using RandomAccessFile.Instances of this class support both reading and writing to a random access file", "label": {"api": {"RandomAccessFile": [[27, 42]]}}}, {"text": "Please have a look at the JList API for more details on this as well as an example", "label": {"api": {"JList API": [[26, 34]]}}}, {"text": "You can also use Character#forDigit in the form of Character.forDigit(i, 10) which either returns the above expression ('0' + digit), an alphabetical character if the digit is > 9 ('a' + digit - 10) or a null character if the digit is outside the radix", "label": {"api": {"Character#forDigit": [[17, 34]]}}}, {"text": "An ArithmeticException is a RuntimeException, so it doesn't need to be declared in a throws clause or caught by a catch block", "label": {"api": {"ArithmeticException": [[3, 21]]}}}, {"text": "From the Java 7 ExecutorService#invokeAll javadoc", "label": {"api": {"Java 7 ExecutorService#invokeAll javadoc": [[9, 48]]}}}, {"text": "There is a WebView (based on the WebKit) in JavaFX 2 in which you can pass a Java object to JavaScript an call methods on it", "label": {"api": {"WebView": [[11, 17]]}}}, {"text": "Also, you will need to call matcher.find()", "label": {"api": {"matcher.find()": [[28, 41]]}}}, {"text": "The <%= %> tag in JSP acts as if it calls String.valueOf() with the expression in the tag as the parameter, and writes the returned value to the output", "label": {"api": {"String.valueOf()": [[42, 57]]}}}, {"text": "See Charset class for different charset information", "label": {"api": {"Charset": [[4, 10]]}}}, {"text": "Loop through String[] array, parsing each String (e.g., Integer.parseInt) into an int and then filling in the equivalent slot in your int[] array", "label": {"api": {"Integer.parseInt": [[56, 71]]}}}, {"text": "Ad 1) To 'clean' the data of a ThreadLocal, simply call ThreadLocal#remove()", "label": {"api": {"ThreadLocal#remove()": [[56, 75]]}}}, {"text": "Just check the ArrayList Javadoc", "label": {"api": {"ArrayList Javadoc": [[15, 31]]}}}, {"text": "Use Runtime#addShutdownHook() to add a shutdown hook to the current runtime", "label": {"api": {"Runtime#addShutdownHook()": [[4, 28]]}}}, {"text": "There is a SimpleDateFormat class for it - try this", "label": {"api": {"SimpleDateFormat": [[11, 26]]}}}, {"text": "However, the TimeUnit.DAYS.convert function loses precision since milliseconds are converted to days (see the linked doc for more info)", "label": {"api": {"TimeUnit.DAYS.convert": [[13, 33]]}}}, {"text": "The easiest solution I can think of is to use String.split", "label": {"api": {"String.split": [[46, 57]]}}}, {"text": "I suggest you use Timer.html#scheduleAtFixedRate to make sure your iterations have equal duration, putting your code inside a TimerTask", "label": {"api": {"Timer.html#scheduleAtFixedRate": [[18, 47]]}}}, {"text": "In Java 7 you can also use the X pattern to match an ISO8601 timezone, which includes the special Z (UTC) value", "label": {"api": {"Java 7": [[3, 8]]}}}, {"text": "It uses these format specifiers", "label": {"api": {"these format specifiers": [[8, 30]]}}}, {"text": "Usually, IllegalStateException is used to indicate that \"a method has been invoked at an illegal or inappropriate time.\" However, this doesn't look like a particularly typical use of it", "label": {"api": {"IllegalStateException": [[9, 29]]}}}, {"text": "However, you may consider, for performance reasons, using a HashMap instead of reflection, or just making your own class that stores the coordinates for the object", "label": {"api": {"HashMap": [[60, 66]]}}}, {"text": "Check out this question, especially the answer which uses Proxy class", "label": {"api": {"Proxy": [[58, 62]]}}}, {"text": "You can use the Arrays.fill(int[] a, int val) method from java.util.Arrays, which fills array a with value val", "label": {"api": {"Arrays.fill(int[] a, int val)": [[16, 44]]}}}, {"text": "JavaDoc for Clipboard", "label": {"api": {"JavaDoc for Clipboard": [[0, 20]]}}}, {"text": "In this case, try using BorderLayout or BoxLayout", "label": {"api": {"BorderLayout": [[24, 35]], "BoxLayout": [[40, 48]]}}}, {"text": "Try to use getScreensForRectangle with the x, y, width and height of your window", "label": {"api": {"getScreensForRectangle": [[11, 32]]}}}, {"text": "The key part of this solution is the passed in Instance (see http://docs.oracle.com/javaee/6/api/javax/enterprise/inject/Instance.html)", "label": {"api": {"http://docs.oracle.com/javaee/6/api/javax/enterprise/inject/Instance.html": [[61, 133]]}}}, {"text": "The Javadoc for BufferedReader's readLine method (http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html#readLine()) says", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html#readLine()": [[50, 128]]}}}, {"text": "newCachedThreadPool() V/s newFixedThreadPool suggests that perhaps you should be looking at ExecutorService.newCachedThreadPool()", "label": {"api": {"ExecutorService.newCachedThreadPool()": [[92, 128]]}}}, {"text": "Check if you \"override\" all methods of DocumentFilter in the way you need", "label": {"api": {"DocumentFilter": [[39, 52]]}}}, {"text": "At least in the method replace(...) I noticed that you missed the int length parameter", "label": {"api": {"replace(...)": [[23, 34]]}}}, {"text": "To create truly (practical) unique keys use UUID.randomUUID(), whith this you don't have to worry about keys", "label": {"api": {"UUID.randomUUID()": [[44, 60]]}}}, {"text": "I'm not sure what you're asking but I think you're looking for the removeAll() method", "label": {"api": {"removeAll()": [[67, 77]]}}}, {"text": "Two things I note, you probably want a space between getEmployeeID() and Limit 1; Also, assuming you're not running with autoCommit enabled, you need to call Connection.commit()", "label": {"api": {"autoCommit": [[121, 130]], "Connection.commit()": [[158, 176]]}}}, {"text": "Use a scale instance of an AffineTransform for this", "label": {"api": {"scale instance of an AffineTransform": [[6, 41]]}}}, {"text": "The DefaultTableModel works in most cases", "label": {"api": {"DefaultTableModel": [[4, 20]]}}}, {"text": "Based on the error message you've now provided, the problem is that Arrays is a class in the java.util package, and you haven't imported the class or qualified access to it", "label": {"api": {"Arrays": [[68, 73]]}}}, {"text": "The Java classes Graphics and Graphics2D should contain most of what Zelle's graphics contains", "label": {"api": {"Graphics": [[17, 24], [30, 37]], "Graphics2D": [[30, 39]]}}}, {"text": "The last method in the code, the paintComponent method, is where you use the Graphics methods", "label": {"api": {"Graphics": [[77, 84]]}}}, {"text": "The documentation for CharsetEncoder.encode says", "label": {"api": {"documentation for CharsetEncoder.encode": [[4, 42]]}}}, {"text": "The buffer's position will be zero and its limit will follow the last byte written", "label": {"api": {"limit": [[43, 47]]}}}, {"text": "You should only be looking at the bytes up to the ByteBuffer's limit", "label": {"api": {"limit": [[63, 67]]}}}, {"text": "That's because the Integer#parseInt(String) method takes in a String and not a char", "label": {"api": {"Integer#parseInt(String)": [[19, 42]]}}}, {"text": "To get the numeric value from a char, use the Character#getNumericValue(char)", "label": {"api": {"Character#getNumericValue(char)": [[46, 76]]}}}, {"text": "You might want to read up on ClassLoader", "label": {"api": {"ClassLoader": [[29, 39]]}}}, {"text": "And you could also use ClassLoader.defineClass() and then Class.newInstance()", "label": {"api": {"ClassLoader": [[23, 33]], "ClassLoader.defineClass()": [[23, 47]], "Class.newInstance()": [[58, 76]]}}}, {"text": "Look at their example NetworkClassLoader", "label": {"api": {"ClassLoader": [[29, 39]]}}}, {"text": "From the Javadoc of Thread", "label": {"api": {"Thread": [[20, 25]]}}}, {"text": "Threads with higher priority are executed in preference to threads with lower priority", "label": {"api": {"Thread": [[0, 5]]}}}, {"text": "When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon", "label": {"api": {"Thread": [[47, 52]]}}}, {"text": "On executing Thread t=new Thread() or t.start()", "label": {"api": {"Thread": [[13, 18], [26, 31]]}}}, {"text": "From the source code of Thread", "label": {"api": {"Thread": [[24, 29]]}}}, {"text": "You can read the Thread source code for more information about the Thread class", "label": {"api": {"Thread": [[17, 22], [67, 72]]}}}, {"text": "Use Set instead of List", "label": {"api": {"Set": [[4, 6]]}}}, {"text": "Don't use nextLine after nextInt, as nextInt doesn't consume \\n and it'll be consumed in nextLine causing it to \"skip\" your actual input", "label": {"api": {"nextLine": [[10, 17], [89, 96]], "nextInt": [[25, 31], [37, 43]]}}}, {"text": "One solution is to add additional nextLine after nextInt to \"swallow\" the \\n that wasn't read via nextInt", "label": {"api": {"nextLine": [[34, 41]], "nextInt": [[49, 55], [98, 104]]}}}, {"text": "So what's happening now in your code is that when you ask for the int input, the user types for example 12 and hit enter (\\n), the int value will be read, but when you reach n[i] = scan.nextLine(); again, the \\n is waiting to be read.", "label": {"api": {"nextLine": [[186, 193]]}}}, {"text": "You can use the HotSpotDiagnosticMXBean for creating a heap dump programmatically", "label": {"api": {"HotSpotDiagnosticMXBean": [[16, 38]]}}}, {"text": "If you create a Filter by extending Filter, you can do", "label": {"api": {"Filter": [[16, 21], [36, 41]]}}}, {"text": "Per the javadoc of scheduleAtFixedRate", "label": {"api": {"scheduleAtFixedRate": [[19, 37]]}}}, {"text": "scheduleAtFixedRate by definition takes a single Runnable instance", "label": {"api": {"scheduleAtFixedRate": [[0, 18]]}}}, {"text": "You just need to directly assign the resultant String[] to it which is returned from the String#split() method", "label": {"api": {"String#split()": [[89, 102]]}}}, {"text": "Make use of the File.mkdirs() function", "label": {"api": {"File.mkdirs()": [[16, 28]]}}}, {"text": "Note that the Collections API provides frequency-counting methods that would allow you to avoid doing the mapping yourself", "label": {"api": {"Collections API": [[14, 28]]}}}, {"text": "There's no actual casting here - just an implicit conversion from Stack<Integer> to Iterable<Integer> because Stack<E> implements Iterable<E> (implicitly, by extending Vector<E>, which extends AbstractList<E>, which extends AbstractCollection<E>, which implements Collection<E>, which extends Iterable<E>)", "label": {"api": {"Stack<E>": [[110, 117]]}}}, {"text": "Lists have a second iterator (ListIterator, which can be fetched with .listIterator()) that can be used to make changes while iterating", "label": {"api": {"ListIterator": [[30, 41]], ".listIterator()": [[70, 84]]}}}, {"text": "CopyOnWriteArrayList is guaranteed to not throw ConcurrentModificationException from its iterators, as it's thread-safe and changes make a new copy..", "label": {"api": {"CopyOnWriteArrayList": [[0, 19]]}}}, {"text": "it has a method that is perfect for your purposes - nextDouble() reads the next double, and returns it back to you", "label": {"api": {"nextDouble()": [[52, 63]]}}}, {"text": "The elements in your List need to implement the Serializable interface, also all the elements in that class", "label": {"api": {"Serializable": [[48, 59]]}}}, {"text": "The reason your LinkedList and Stack objects are equal is because they both implement the List interface, and the definition of List.equals is that two lists are equal if they have the same size, and contain the same objects in the same order", "label": {"api": {"List.equals": [[128, 138]]}}}, {"text": "I believe you're looking for IdentityHashMap", "label": {"api": {"IdentityHashMap": [[29, 43]]}}}, {"text": "Likewise, for the hash code it uses System.identityHashCode instead of any overridden Object.hashCode()", "label": {"api": {"System.identityHashCode": [[36, 58]]}}}, {"text": "For instance if you want to check if a String is a valid integer you can use Integer.parseInt", "label": {"api": {"Integer.parseInt": [[77, 92]]}}}, {"text": "You can use printf instead of println, with C-style format strings", "label": {"api": {"printf": [[12, 17]]}}}, {"text": "You have to catch NumberFormatException, look at the Double#parseDouble in the docs", "label": {"api": {"Double#parseDouble": [[53, 70]]}}}, {"text": "To create a secure key, use a KeyGenerator that is based on a properly seeded cryptographic random number generator; providers will choose their own RNG if you don't specify one", "label": {"api": {"KeyGenerator": [[30, 41]]}}}, {"text": "If you want, you can instantiate your own SecureRandom instance, using your preferred algorithm and provider, and pass it to the key generator via an overload of the init() method", "label": {"api": {"init()": [[166, 171]]}}}, {"text": "Instead of using EventListener, you should use ChangeListener", "label": {"api": {"EventListener": [[17, 29]], "ChangeListener": [[47, 60]]}}}, {"text": "The de-sugaring process uses the Integer.valueOf(int) method to make the conversion from int to Integer", "label": {"api": {"Integer.valueOf(int)": [[33, 52]]}}}, {"text": "java.awt.geom.Ellipse2D and the corresponding Ellipse2D.Double and Ellipse2D.Float (Ellipse2D source code)", "label": {"api": {"java.awt.geom.Ellipse2D": [[0, 22]], "Ellipse2D.Double": [[46, 61]], "Ellipse2D.Float": [[67, 81]]}}}, {"text": "In gui application it is better to use Timer, also you may use ScheduledThreadPoolExecutor", "label": {"api": {"Timer": [[39, 43]], "ScheduledThreadPoolExecutor": [[63, 89]]}}}, {"text": "As you can't invoke ATW/Swing directly from another thread, you should wrap any call to Swing into SwingUtilities.invokeLater() method", "label": {"api": {"SwingUtilities.invokeLater()": [[99, 126]]}}}, {"text": "and call it from Timer and from button click listener", "label": {"api": {"Timer": [[17, 21]]}}}, {"text": "You can use the Integer#toString(intVal, radix) method for this", "label": {"api": {"Integer#toString(intVal, radix)": [[16, 46]]}}}, {"text": "Or you can even use Integer#toHexString(intVal) to directly convert it to a Hexadecimal string if that's the only requirement", "label": {"api": {"Integer#toHexString(intVal)": [[20, 46]]}}}, {"text": "Use String#contains, no need for regex here", "label": {"api": {"String#contains": [[4, 18]]}}}, {"text": "So the commit left auto-generated \"not supported\" code for interfaces like CallableStatement or PreparedStatement", "label": {"api": {"CallableStatement": [[75, 91]], "PreparedStatement": [[96, 112]]}}}, {"text": "add the HivePreparedStatement implementation based on current HIVE supported data-type some of the methods were fleshed out, see the commit", "label": {"api": {"PreparedStatement": [[12, 28]]}}}, {"text": "The specific issue I encountered was that creating a ScheduledExecutorService through Executors.html#newScheduledThreadPool(int), scheduling a future and then cancelling that future will not terminate the underlying Executor as the default RemoveOnCancelPolicy is to wait for the cancelled future to be scheduled before terminating", "label": {"api": {"Executors.html#newScheduledThreadPool(int)": [[86, 127]], "RemoveOnCancelPolicy": [[240, 259]]}}}, {"text": "Maybe you are looking for Pattern#quote", "label": {"api": {"Pattern#quote": [[26, 38]]}}}, {"text": "You can also use Matcher#quoteReplacement to escape special characters in a String that is intended to be used as replacement", "label": {"api": {"Matcher#quoteReplacement": [[17, 40]]}}}, {"text": "If not not then just use a simple List and use its get(index) method", "label": {"api": {"List": [[34, 37]]}}}, {"text": "If Yes then you could use a Map implmentation - such as LinkedHashMap -  that preserves the insert/put order", "label": {"api": {"Map": [[28, 30], [66, 68]], "LinkedHashMap": [[56, 68]]}}}, {"text": "Then you can call values() of that map and iterate over it using enhanced for-loop, or probably also create a List and passing it the collection reurned if you need index access", "label": {"api": {"List": [[110, 113]], "values()": [[18, 25]]}}}, {"text": "If you are looking to get a your objects according to an index - what you are really looking for is an ArrayList - which allows access by index, and is basically a dynamic array", "label": {"api": {"ArrayList": [[103, 111]]}}}, {"text": "If you want to objects \"attached\" to the same index, you can use 2 ArrayLists (one for each type of object) - or use a Pair (from apache commons) as an element in the arraylist", "label": {"api": {"ArrayList": [[67, 75]], "Pair": [[119, 122]]}}}, {"text": "Tomcat uses a custom ClassLoader", "label": {"api": {"ClassLoader": [[21, 31]]}}}, {"text": "You can make your own too but URLClassLoader satisfy the requisites of most developers", "label": {"api": {"ClassLoader": [[33, 43]], "URLClassLoader": [[30, 43]]}}}, {"text": "To move the sliders call SwingUtilities.invokeLater()", "label": {"api": {"SwingUtilities.invokeLater()": [[25, 52]]}}}, {"text": "A simple approach for your current lists would be Java's SortedSet, which is an interface so you'll end up using a TreeSet", "label": {"api": {"SortedSet": [[57, 65]], "TreeSet": [[115, 121]]}}}, {"text": "Create a Comparable object to store your time and value, or create a Comparator for the SortedSet", "label": {"api": {"SortedSet": [[88, 96]]}}}, {"text": "The return type of get() method is Object", "label": {"api": {"get() method": [[19, 30]]}}}, {"text": "You can simply use java.util.concurrent.FutureTask, which is basically a Runnable wrapping a Callable which also implements the Future interface", "label": {"api": {"java.util.concurrent.FutureTask": [[19, 49]]}}}, {"text": "As documented in SimpleDateFormat it produces Z (instead of +00:00) if time zone offset is 0 (UTC)", "label": {"api": {"SimpleDateFormat": [[17, 32]]}}}, {"text": "It maintains its keys sorted, and has methods returning a \"submap\" containing all the entries between two key values", "label": {"api": {"methods returning a \"submap\"": [[38, 65]]}}}, {"text": "Supply a limit parameter in the two-arg overload of split, to stop at 2 fields", "label": {"api": {"two-arg overload of split": [[32, 56]]}}}, {"text": "But try using the Executors which has already implementation of such functionality", "label": {"api": {"Executors": [[18, 26]]}}}, {"text": "You could use Arrays.sort()", "label": {"api": {"Arrays.sort()": [[14, 26]]}}}, {"text": "Use GregorianCalendar which extends Calendar", "label": {"api": {"GregorianCalendar": [[4, 20]], "Calendar": [[13, 20], [36, 43]]}}}, {"text": "A good way to do this (within your restrictions) is to use the String.indexOf overload that takes a fromIndex, and a method to do something like that, but for operators", "label": {"api": {"String.indexOf overload": [[63, 85]]}}}, {"text": "You can use String.trim() or replace (e.g", "label": {"api": {"String.trim()": [[12, 24]]}}}, {"text": "What you can do is then advance the scanner to the next line by use of the Scanner#nextLine() method", "label": {"api": {"Scanner#nextLine()": [[75, 92]]}}}, {"text": "In Java available() is unreliable (read the Javadoc)...", "label": {"api": {"(read the Javadoc)": [[34, 51]]}}}, {"text": "You can use the Pattern.quote method to get the pattern string that would match your string literal", "label": {"api": {"Pattern.quote": [[16, 28]]}}}, {"text": "You need to use a SimpleDateFormat to parse your String to a date and then use that date", "label": {"api": {"SimpleDateFormat": [[18, 33]]}}}, {"text": "Throwable has the method printStackTrace() which prints a nicely formated stack trace", "label": {"api": {"Throwable": [[0, 8]], "printStackTrace()": [[25, 41]]}}}, {"text": "Is there some function which does the same for an array of StackTraceElement which can for example be obtained by calling getAllStackTraces()", "label": {"api": {"StackTraceElement": [[59, 75]], "getAllStackTraces()": [[122, 140]]}}}, {"text": "You can get all the keys using the keySet() method and create a new ArrayList with that", "label": {"api": {"keySet()": [[35, 42]]}}}, {"text": "You can use LinkedHashMap which will store your keys in order of insertion.You can retrieve them by calling keySet()", "label": {"api": {"keySet()": [[108, 115]]}}}, {"text": "A LinkedHashMap does have a position, since it has a predictable iteration order", "label": {"api": {"LinkedHashMap": [[2, 14]]}}}, {"text": "But the option is to use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[25, 37]]}}}, {"text": "However, As a warning, it has a constructor LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) which will create a linked hash map whose order of iteration is the order in which its entries were last accessed", "label": {"api": {"LinkedHashMap": [[44, 56]]}}}, {"text": "It's the PipedInputStream", "label": {"api": {"PipedInputStream": [[9, 24]]}}}, {"text": "You'll need to have one thread write to the PipedOutputStream, and pass the PipedInputStream to the object that will be reading in another thread", "label": {"api": {"PipedInputStream": [[76, 91]]}}}, {"text": "This Question might have been answered here quite often but I could not find an answer specific to my question, I as well tried to go through http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html and infer something but to no avail", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html": [[142, 213]]}}}, {"text": "I also advise you to read about Formatter", "label": {"api": {"Formatter": [[32, 40]]}}}, {"text": "The method mode should return a HashSet that contains the duplicates and not an int", "label": {"api": {"HashSet": [[32, 38]]}}}, {"text": "Although typically it is not needed, it's possible the code you are looking at also has a custom ServletContextAttributeListener which listens for these removals of context attributes and performs some action accordingly", "label": {"api": {"ServletContextAttributeListener": [[97, 127]]}}}, {"text": "always try the JavaDoc RandomAccessFile", "label": {"api": {"RandomAccessFile": [[23, 38]]}}}, {"text": "The correct way to read characters from System.in is to use an InputStreamReader (or a Scanner if that provides the right functionality)", "label": {"api": {"InputStreamReader": [[63, 79]], "Scanner": [[87, 93]]}}}, {"text": "If you would rather have an unmodifiable list without making a copy, you could use Collections.unmodifiableList", "label": {"api": {"Collections.unmodifiableList": [[83, 110]]}}}, {"text": "No, it's not a collection in that it does not implement the Collection<E> interface", "label": {"api": {"Collection<E>": [[60, 72]]}}}, {"text": "Conceptually, it is an immutable sequence of characters (and implements the CharSequence interface)", "label": {"api": {"CharSequence": [[76, 87]]}}}, {"text": "If you want/need to run a process when deploying you application, you must define a ServletContextListener", "label": {"api": {"ServletContextListener": [[84, 105]]}}}, {"text": "But from your requirement details, seems that you need a HttpSessionListener to start trackign each user session start", "label": {"api": {"HttpSessionListener": [[57, 75]]}}}, {"text": "And probably you may check changes in session attributes as well, so use a HttpSessionBindingListener to accomplish this", "label": {"api": {"HttpSessionBindingListener": [[75, 100]]}}}, {"text": "substring returns a String object, but needs an int argument, so your statement is equivalent to", "label": {"api": {"substring": [[0, 8]]}}}, {"text": "To impose reverse ordering, you can make use of Collections.reverseOrder() method", "label": {"api": {"Collections.reverseOrder()": [[48, 73]]}}}, {"text": "You could use System.arrayCopy", "label": {"api": {"System.arrayCopy": [[14, 29]]}}}, {"text": "I believe Matcher#pattern() should work for you", "label": {"api": {"Matcher#pattern()": [[10, 26]]}}}, {"text": "Arrays.sort() will work just fine", "label": {"api": {"Arrays.sort()": [[0, 12]]}}}, {"text": "Check the API docs for more information", "label": {"api": {"API docs": [[10, 17]]}}}, {"text": "You can also look into using PreparedStatement", "label": {"api": {"PreparedStatement": [[29, 45]]}}}, {"text": "In Java, producer/consumer problems are often solved by using a BlockingQueue", "label": {"api": {"BlockingQueue": [[64, 76]]}}}, {"text": "You can use the LineNumberReader", "label": {"api": {"LineNumberReader": [[16, 31]]}}}, {"text": "Unless you have a very good reason to do it, you might want to stick to a HashMap (or other Map)", "label": {"api": {"HashMap": [[74, 80]]}}}, {"text": "Instead, either establish an URL to the image and use that for ImageIO, or alternately use the URL in the Applet.getImage(URL) method", "label": {"api": {"Applet.getImage(URL)": [[106, 125]]}}}, {"text": "You can use SimpleDateFormat's parse method to parse your date, and then use the format method to output it in the format that you prefer", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "The JavaDoc has to say for Thread.join(long)", "label": {"api": {"Thread.join(long)": [[27, 43]]}}}, {"text": "And this is the description for Thread.isAlive()", "label": {"api": {"Thread.isAlive()": [[32, 47]]}}}, {"text": "It would be smarter to use a NIO Selector instead of 100 threads", "label": {"api": {"Selector": [[33, 40]]}}}, {"text": "If you want to replace a simple String rather than a pattern, you can use String.replace instead of String.replaceAll", "label": {"api": {"String.replace": [[74, 87], [100, 113]]}}}, {"text": "Next, you can use the List#get(index) method to get the element at a particular index", "label": {"api": {"List#get(index)": [[22, 36]]}}}, {"text": "You did not show your POJO class which contains OvertimeRates property so I can only guess that this is the Map", "label": {"api": {"Map": [[108, 110]]}}}, {"text": "Could you change it to EnumMap", "label": {"api": {"Map": [[27, 29]], "EnumMap": [[23, 29]]}}}, {"text": "Extend a DefaultListCellRenderer instead", "label": {"api": {"DefaultListCellRenderer": [[9, 31]]}}}, {"text": "But the algorithm for calculating a default serialVersionUID used a hash code over all class members, even synthetic ones", "label": {"api": {"serialVersionUID": [[44, 59]]}}}, {"text": "As a consequence, compiling with javac or the first Eclipse versions created classes with incompatible serialVersionUIDs", "label": {"api": {"serialVersionUID": [[103, 118]]}}}, {"text": "Today, Eclipse uses the same name schema for synthetic members as javac and issues a warning about missing explicit serialVersionUIDs in Serializable classes by default", "label": {"api": {"serialVersionUID": [[116, 131]]}}}, {"text": "Check this url", "label": {"api": {"url": [[11, 13]]}}}, {"text": "The method DataOutputStream.writeBytes method is not suitable for any character encoding", "label": {"api": {"DataOutputStream.writeBytes": [[11, 37]]}}}, {"text": "You can use the split() function like this", "label": {"api": {"split()": [[16, 22]]}}}, {"text": "For you game you might want to consider using a ScheduledExecutorService, which allows you to schedule a Runnable to run at a fixed rate", "label": {"api": {"ScheduledExecutorService": [[48, 71]]}}}, {"text": "When you put your component in a JScrollPane, your component may implement the Scrollable interface to adjust the scrollpane’s behaviour", "label": {"api": {"JScrollPane": [[33, 43]], "Scrollable": [[79, 88]]}}}, {"text": "By doing this you can implement the method getScrollableTracksViewportWidth() to return true so your component will always have the available width and be scrollable in vertical direction only", "label": {"api": {"Scrollable": [[46, 55]], "getScrollableTracksViewportWidth()": [[43, 76]]}}}, {"text": "Create a Pattern object for your regex (this is reusable), then call the matcher() method to run it against your string", "label": {"api": {"Pattern object": [[9, 22]]}}}, {"text": "For each animal type, create a panel with specialized input components, and place all three panels in a separate JPanel that uses a CardLayout", "label": {"api": {"CardLayout": [[132, 141]]}}}, {"text": "CardLayout displays one and only one of its children at any given time;  each child is identified by a String identifier of your choosing, which you must specify when you add the child", "label": {"api": {"CardLayout": [[0, 9]]}}}, {"text": "This is better than adding components dynamically, because CardLayout will always make sure a container's preferred size is large enough to accommodate all of the children, so the dialog won't shuffle things around when you change which components are visible", "label": {"api": {"CardLayout": [[59, 68]]}}}, {"text": "You can use java.util.concurrent.CountDownLatch, which is exactly what you need", "label": {"api": {"java.util.concurrent.CountDownLatch": [[12, 46]]}}}, {"text": "Also you might want to have a look at java.util.concurrent.CyclicBarrier, which is similiar but allows reuse after waiting threads are released", "label": {"api": {"java.util.concurrent.CyclicBarrier": [[38, 71]]}}}, {"text": "If you call that repeatedly, a Phaser would be the best solution as it combines the CountDownLatch and CyclicBarrier in an easy and reusable way", "label": {"api": {"Phaser": [[31, 36]]}}}, {"text": "For a one-time use the CyclicBarrier is enough (with a minor performance increase over the Phaser)", "label": {"api": {"Phaser": [[91, 96]]}}}, {"text": "For that purposes you can use TableColumnModelListener which has columnMoved(TableColumnModelEvent arg0)", "label": {"api": {"columnMoved(TableColumnModelEvent arg0)": [[65, 103]]}}}, {"text": "The resulting list coming from Arrays#asList() is defined to be fixed size", "label": {"api": {"to be fixed size": [[58, 73]]}}}, {"text": "Look and see if java.awt.FileDialog has the option(s) you want", "label": {"api": {"java.awt.FileDialog": [[16, 34]]}}}, {"text": "Write a custom Comparator and supply that to the appropriate sort overload along with the data", "label": {"api": {"Comparator": [[15, 24]], "sort": [[61, 64]]}}}, {"text": "However, I would recommend a separate Person/Name type, instead of String arrays, as it will make data easier to keep track of and it could implement Comparable (which would eliminate/replace the need of a Comparator)", "label": {"api": {"Comparator": [[206, 215]], "Comparable": [[150, 159]]}}}, {"text": "If you don't want to use any third party library, and you restrict yourself to Integer values, you can use Java Integer.decode", "label": {"api": {"Integer.decode": [[112, 125]]}}}, {"text": "I have read already the javadoc on the Class.forName method but I do not really understand how to use it in the real word", "label": {"api": {"Class.forName": [[39, 51]]}}}, {"text": "Instead, you can use \"/\" (as far as I remember, it should be replaced by JVM to suitable separator) or, even better, File.separator", "label": {"api": {"File.separator": [[117, 130]]}}}, {"text": "You should be using ServletContext#getResource() instead, or its JSF counterpart ExternalContext#getResource() — as indicated by your question history, you're using JSF", "label": {"api": {"ServletContext#getResource()": [[20, 47]], "ExternalContext#getResource()": [[81, 109]]}}}, {"text": "Have the actionPerformed of the Timer create a SwingWorker for the actual work", "label": {"api": {"SwingWorker": [[47, 57]]}}}, {"text": "That way you can also get at an exception on close separately from an exception in the main body, using Throwable.getSuppressed", "label": {"api": {"Throwable.getSuppressed": [[104, 126]]}}}, {"text": "The method Shape.intersects() can be used to determine if a shape intersects with any rectangle", "label": {"api": {"Shape.intersects()": [[11, 28]]}}}, {"text": "If you're using Java 7+, then you can use the Files#readAllLines() to do this task for you, instead of you writing a for or a while loop yourself to read the file line-by-line", "label": {"api": {"Files#readAllLines()": [[46, 65]]}}}, {"text": "You may want to look at StringBuilder", "label": {"api": {"StringBuilder": [[24, 36]]}}}, {"text": "Find, then read the SimpleDateFormat API Page (JSE 6.0 SimpleDateFormat Page)", "label": {"api": {"JSE 6.0 SimpleDateFormat Page": [[47, 75]]}}}]