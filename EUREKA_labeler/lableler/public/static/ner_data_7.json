[{"text": "This sounds like a good use-case for a ListIterator", "label": {"api": {"ListIterator": [[39, 50]]}}}, {"text": "Instead of HttpServletOutputStream (for binary data), use PrintWriter getWriter of ServletResponse that can send character string to client", "label": {"api": {"getWriter": [[70, 78]]}}}, {"text": "As an update, I had a look at the JCPP preprocessor and got it working by just wrapping it in a Reader using the CppReader that is included in said preprocessor", "label": {"api": {"Reader": [[96, 101], [116, 121]]}}}, {"text": "You're getting a class loader, but then try to load the image from the file system using a FileDataSource object", "label": {"api": {"FileDataSource": [[91, 104]]}}}, {"text": "Change it to a URLDataSource and load the image from the URL that you obtain from the class loader", "label": {"api": {"URLDataSource": [[15, 27]]}}}, {"text": "UndoManager class keeps an internal collection of UndoableEdit objects", "label": {"api": {"UndoManager": [[0, 10]], "UndoableEdit": [[50, 61]]}}}, {"text": "The internal implementation of UndoManager#redo() and UndoManager#redoTo(UndoableEdit edit) looks like this", "label": {"api": {"UndoManager": [[31, 41], [54, 64]], "UndoableEdit": [[73, 84]], "UndoManager#redo()": [[31, 48]], "UndoManager#redoTo(UndoableEdit edit)": [[54, 90]]}}}, {"text": "You'll need Range (and the awesome RangeSet and RangeMap) from Guava, and LocalDate from Joda-Time (or LocalDate in java.time package in Java 8)", "label": {"api": {"LocalDate": [[74, 82], [103, 111]], "java.time package": [[116, 132]]}}}, {"text": "Please not I'm using DatatypeConverter for Base64 decoding", "label": {"api": {"DatatypeConverter": [[21, 37]]}}}, {"text": "As suggested by @trashgod use Swing Timer that is more suitable for swing application to perform a task once, after a delay or to perform a task repeatedly", "label": {"api": {"Swing Timer": [[30, 40]]}}}, {"text": "In many, if not most, of the classes I've written that implement ActionListener, I don't use the parameter to ActionPerformed at all, because the particular implementation doesn't need it", "label": {"api": {"ActionListener": [[65, 78]]}}}, {"text": "In Java regular expressions, characters enclosed in square brackets [] are called a character class", "label": {"api": {"Java regular expressions": [[3, 26]]}}}, {"text": "Or better a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "Although an easier workaround may be to have the Java code generate an appropriate Proxy instance that takes a handler that delegates to your JNI code", "label": {"api": {"Proxy": [[83, 87]]}}}, {"text": "Well, I didn't see this on Stack Overflow, so I thought I would ask, and I didn't know if InputStreamReader would work..", "label": {"api": {"Reader": [[101, 106]]}}}, {"text": "So, if you ever want to read text that has a bunch of newline characters, you have to use InputStreamReader", "label": {"api": {"Reader": [[101, 106]]}}}, {"text": "This is a class implements Reader (which implements readable and closeable and has a method (read(chBuf)) that allows you to read an input stream to the buffer characters (an array), chBuf", "label": {"api": {"Reader": [[27, 32]]}}}, {"text": "You can iterate over this (whatever type it is) if this also implements Iterable<T>", "label": {"api": {"Iterable<T>": [[72, 82]]}}}, {"text": "If you set text/html content type, by default the returned Document will be an instance of HTMLDocument which you can use to add new elements for new chat messages", "label": {"api": {"HTMLDocument": [[91, 102]]}}}, {"text": "The java.util.Logger system just like many other logging systems is hierarchical", "label": {"api": {"java.util.Logger": [[4, 19]]}}}, {"text": "Read more about it in the javadoc of java.util.Logger", "label": {"api": {"java.util.Logger": [[37, 52]]}}}, {"text": "One of the options is to use @XmlElementRef annotation", "label": {"api": {"@XmlElementRef": [[29, 42]]}}}, {"text": "You can test for System.exit by installing your own SecurityManager, implementing the method checkExit for the duration of the test", "label": {"api": {"SecurityManager": [[52, 66]]}}}, {"text": "Or if you don't wan't to pull in an entire library like Guava or Commons-IO, you can just extend the GZIPOutputStream and obtain the data from the associated Deflater like so", "label": {"api": {"GZIPOutputStream": [[101, 116]], "Deflater": [[158, 165]]}}}, {"text": "Use Comparator to compare objects", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "You can read back the array using the ByteBuffer.getFloat() method", "label": {"api": {"ByteBuffer.getFloat()": [[38, 58]]}}}, {"text": "And further from JPEG Metadata Format Specification and Usage Notes", "label": {"api": {"JPEG Metadata Format Specification and Usage Notes": [[17, 66]]}}}, {"text": "See the Image Metadata DTD for documentation on the metadata structure", "label": {"api": {"Image Metadata DTD": [[8, 25]]}}}, {"text": "LinkedHashSet.add is inherited from HashSet.add", "label": {"api": {"HashSet.add": [[6, 16], [36, 46]]}}}, {"text": "The docs link to Oracle state", "label": {"api": {"link to Oracle": [[9, 22]]}}}, {"text": "You can write a byte array or an InputStream to a file with the java.nio.file.Files class (since Java 1.7)", "label": {"api": {"java.nio.file.Files": [[64, 82]]}}}, {"text": "If you want to read user input from keyboard you should use Console", "label": {"api": {"Console": [[60, 66]]}}}, {"text": "The java String class has a contains method which returns a boolean", "label": {"api": {"java String class": [[4, 20]]}}}, {"text": "Also, you can always call trimToSize() if you wanted to recoup space from a ArrayList that has dramatically shrunk", "label": {"api": {"trimToSize()": [[26, 37]]}}}, {"text": "I think you want a SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[19, 34]]}}}, {"text": "To go through all the files in a directory, use a DirectoryStream", "label": {"api": {"DirectoryStream": [[50, 64]]}}}, {"text": "You can use the getThreadInfo method of the ThreadMXBean MBean", "label": {"api": {"getThreadInfo": [[16, 28]], "ThreadMXBean": [[44, 55]], "ThreadInfo": [[19, 28]]}}}, {"text": "It allows you to pass a thread ID and it will return a ThreadInfo datatype which contains the stack trace, thread state, etc", "label": {"api": {"ThreadInfo": [[55, 64]]}}}, {"text": "Convert the Date String to java.util.Date object using SimpleDateFormat and compare those date objects with Date#after or Date#before methods", "label": {"api": {"SimpleDateFormat": [[55, 70]], "Date#after": [[108, 117]], "Date#before": [[122, 132]]}}}, {"text": "In java 8 - using new Java Time API, parse date String using  DateTimeFormat and get LocalDate object and compare them", "label": {"api": {"Java Time API": [[22, 34]]}}}, {"text": "You can use TextAttributes to obtain a font", "label": {"api": {"TextAttributes": [[12, 25]]}}}, {"text": "Use a BufferedOutputStream", "label": {"api": {"BufferedOutputStream": [[6, 25]]}}}, {"text": "What you want to do is is handle an onMouseClicked event to your circle", "label": {"api": {"onMouseClicked": [[36, 49]]}}}, {"text": "Use GridBagConstraints#fill property that is used when the component's display area is larger than the component's requested size", "label": {"api": {"GridBagConstraints#fill": [[4, 26]]}}}, {"text": "A somewhat better option would be passing username and password as environment variables", "label": {"api": {"environment variables": [[67, 87]]}}}, {"text": "I strongly suspect your class extends from JFrame which you are adding your table to", "label": {"api": {"JFrame": [[43, 48]]}}}, {"text": "If this is the case please take a look to this question with the same problem and Extends JFrame vs", "label": {"api": {"JFrame": [[90, 95]]}}}, {"text": "Add a JTextComponent field variable and a setter for it", "label": {"api": {"JTextComponent": [[6, 19]]}}}, {"text": "JTextComponent is the base class for JTextField, JTextArea, etc ..", "label": {"api": {"JTextComponent": [[0, 13]]}}}, {"text": "For that, have a look at JTextComponent", "label": {"api": {"JTextComponent": [[25, 38]]}}}, {"text": "You can use the LinkedHashMap to do precisely that, quoting the Javadoc", "label": {"api": {"LinkedHashMap": [[16, 28]]}}}, {"text": "for thread safe-ness you can wrap it using Collections.synchronizedmap()", "label": {"api": {"Collections.synchronizedmap()": [[43, 71]]}}}, {"text": "The term utility function was used by Joshua Bloch in the book Effective Java to describe the methods on classes such as Arrays, Objects and Math", "label": {"api": {"Arrays": [[121, 126]], "Objects": [[129, 135]], "Math": [[141, 144]]}}}, {"text": "Look at http://docs.oracle.com/javase/7/docs/api/java/io/DataOutputStream.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/DataOutputStream.html": [[8, 77]]}}}, {"text": "Also, if you don't want to open the files with other application, another efficient solution is to use an http://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html that will serialize an entire object without having to convert it manually", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html": [[106, 177]]}}}, {"text": "Another option (for smaller files) is to utilize Files.readAllBytes() and Files.write()", "label": {"api": {"Files.readAllBytes()": [[49, 68]], "Files.write()": [[74, 86]]}}}, {"text": "Here is a demonstration of the technique using ThreadGroup", "label": {"api": {"ThreadGroup": [[47, 57]]}}}, {"text": "Note that you must ensure that the Thread-1 is actually started by the time you enumerate the ThreadGroup, thus joining the callSendMailThread is absolutely necessary", "label": {"api": {"ThreadGroup": [[94, 104]]}}}, {"text": "Also note that the quirky behaviour of ThreadGroup.enumerate() must be accounted for, by retrying to enumerate all the items several times", "label": {"api": {"ThreadGroup": [[39, 49]]}}}, {"text": "Java 8 has a base 64 class included", "label": {"api": {"base 64 class": [[13, 25]]}}}, {"text": "In this case you probably want to extend ArrayList", "label": {"api": {"ArrayList": [[41, 49]]}}}, {"text": "You can use a file as @VD' said, but you might want to use something called Preferences", "label": {"api": {"Preferences": [[76, 86]]}}}, {"text": "If the latter, use Preferences", "label": {"api": {"Preferences": [[19, 29]]}}}, {"text": "To decompress it, pass it through a GZIPInputStream", "label": {"api": {"GZIPInputStream": [[36, 50]]}}}, {"text": "Another alternative that may be helpful down the line is to use an ArrayList<Contact> instead of a c-style array (Contact[])", "label": {"api": {"ArrayList<Contact>": [[67, 84]]}}}, {"text": "This class might add more handling complexity than it's worth, but it includes a lot of useful extra methods, including an int indexOf(<T> object) where <T> is the type you specified in your declaration (i.e., Contact for ArrayList<Contact> contacts)", "label": {"api": {"ArrayList<Contact>": [[222, 239]]}}}, {"text": "Might as well use a Semaphore or, in this case, a CountDownLatch", "label": {"api": {"Semaphore": [[20, 28]], "CountDownLatch": [[50, 63]]}}}, {"text": "Looking at the source code for Semaphore, wait and notify barely scratch the surface", "label": {"api": {"Semaphore": [[31, 39]]}}}, {"text": "Using a CountDownLatch makes code easier to read", "label": {"api": {"CountDownLatch": [[8, 21]]}}}, {"text": "HashMap isn't working correctly because you modify values that affect the results of equals and hashCode", "label": {"api": {"equals": [[85, 90]], "hashCode": [[96, 103]]}}}, {"text": "Also - this isn't an answer to the question, but you should read the contracts of equals and hashCode", "label": {"api": {"equals": [[82, 87]], "hashCode": [[93, 100]]}}}, {"text": "If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result", "label": {"api": {"equals": [[42, 47]], "hashCode": [[82, 89]]}}}, {"text": "What issues / pitfalls must be considered when overriding equals and hashCode", "label": {"api": {"equals": [[58, 63]], "hashCode": [[69, 76]]}}}, {"text": "Sounds like you what you're wanting to do is invoke the setVisible on the Swing UI thread, you can do this with invokeAndWait or invokeLater", "label": {"api": {"invokeAndWait": [[112, 124]], "invokeLater": [[129, 139]]}}}, {"text": "First, it is not recommended to use clone() in Java since clone is broken", "label": {"api": {"clone()": [[36, 42]]}}}, {"text": "Another option is java.lang.Math#pow, but that works on floating point numbers", "label": {"api": {"java.lang.Math#pow": [[18, 35]]}}}, {"text": "You can also do it programmatically in java using a ScheduledThreadPoolExecutor", "label": {"api": {"ScheduledThreadPoolExecutor": [[52, 78]]}}}, {"text": "Is there a way to fill an array using java 8 Supplier", "label": {"api": {"Supplier": [[45, 52]]}}}, {"text": "You do not need to invoke the javac.exe, instead take a look at javax.tools.ToolProvider.getSystemJavaCompiler() ToolProvider Javadoc", "label": {"api": {"ToolProvider Javadoc": [[113, 132]]}}}, {"text": "If you output the Date object directly, its toString function is called implicitly, giving you a string in the format dow mon dd hh:mm:ss zzz yyyy, which may or may not be what you want", "label": {"api": {"toString": [[44, 51]]}}}, {"text": "The method used in that code, getDateInstance, gives you a formatter that uses a format based on the current locale", "label": {"api": {"getDateInstance": [[30, 44]]}}}, {"text": "Use Character.forDigit method", "label": {"api": {"Character.forDigit": [[4, 21]]}}}, {"text": "Use a Map<String, City> instead of List<City>, use the City#name as the key in your map", "label": {"api": {"Map<String, City>": [[6, 22]]}}}, {"text": "You can store the user information in ThreadLocal", "label": {"api": {"ThreadLocal": [[38, 48]]}}}, {"text": "One of the ways to do that is to create a ServletFilter which will save the user info to ThreadLocal and remove it (very important!)  when request processing is done", "label": {"api": {"ThreadLocal": [[89, 99]]}}}, {"text": "All the methods that need user info then would read it from ThreadLocal variable", "label": {"api": {"ThreadLocal": [[60, 70]]}}}, {"text": "From the javadoc of TreeSet", "label": {"api": {"javadoc of TreeSet": [[9, 26]]}}}, {"text": "Also note the getOutputSize(int inputLength) and the getBlockSize() methods of Cipher", "label": {"api": {"getOutputSize(int inputLength)": [[14, 43]], "getBlockSize()": [[53, 66]], "Cipher": [[79, 84]]}}}, {"text": "Use PriorityQueue#addAll method after creating the instance of your queue", "label": {"api": {"PriorityQueue#addAll": [[4, 23]]}}}, {"text": "The method init() of Thread isn't in the Java documentation", "label": {"api": {"Thread": [[21, 26]]}}}, {"text": "Neither is addUnstarted() of ThreadGroup", "label": {"api": {"Thread": [[29, 34]], "ThreadGroup": [[29, 39]]}}}, {"text": "replaceAll uses regular expressions, and bracket have a particular meaning in regular expressions", "label": {"api": {"replaceAll": [[0, 9]], "replace": [[0, 6]]}}}, {"text": "Just use replace instead, which doesn't use regex", "label": {"api": {"replace": [[9, 15]]}}}, {"text": "spliterator() creates a Spliterator over the elements described by this Iterable", "label": {"api": {"Spliterator": [[24, 34]]}}}, {"text": "A Spliterator is used for  traversing and partitioning elements of a source (which can be, for example, a Collection)", "label": {"api": {"Spliterator": [[2, 12]]}}}, {"text": "It is used in Java 8 to create parallel Streams of objects, which would allow you to perform operations on the items of your Iterable in parallel", "label": {"api": {"Stream": [[40, 45]]}}}, {"text": "forEach(Consumer action) performs an action (by calling the accept method of the Consumer which is passed to it) on all the elements of the Iterable", "label": {"api": {"Consumer": [[8, 15], [81, 88]]}}}, {"text": "Of course you can read all of this in the JavaDoc of Iterable", "label": {"api": {"JavaDoc of Iterable": [[42, 60]]}}}, {"text": "You could just use String.format like this", "label": {"api": {"String.format": [[19, 31]]}}}, {"text": "The asynchronous ones return java.util.concurrent.Future", "label": {"api": {"java.util.concurrent.Future": [[29, 55]]}}}, {"text": "There was a question here about dealing with Java Futures in Scala here How do I wrap a java.util.concurrent.Future in an Akka Future?", "label": {"api": {"java.util.concurrent.Future": [[88, 114]]}}}, {"text": "It is possible to set an SSLSocketFactory on an HttpsUrlConnection", "label": {"api": {"set": [[18, 20]], "SSLSocketFactory": [[25, 40]]}}}, {"text": "HashMap makes no guarantee of order but TreeMap does", "label": {"api": {"HashMap": [[0, 6]], "TreeMap": [[40, 46]]}}}, {"text": "If order matters, you need to look at a SortedMap (ordered by Comparator) or a LinkedHashMap (ordered by insert order)", "label": {"api": {"SortedMap": [[40, 48]], "LinkedHashMap": [[79, 91]]}}}, {"text": "The Property.getProperty method returns only a String typed object", "label": {"api": {"Property.getProperty": [[4, 23]]}}}, {"text": "Using a Map would allow you to store your accounts using their IDs as the key.Then you could check if an account already exists with a particular id using Map.containsKey()", "label": {"api": {"Map": [[8, 10], [155, 157]]}}}, {"text": "And plain Java Strings", "label": {"api": {"plain Java Strings": [[4, 21]]}}}, {"text": "You use ArrayList#indexOf....", "label": {"api": {"ArrayList#indexOf": [[8, 24]]}}}, {"text": "Well, you need to import PrintWriter itself", "label": {"api": {"PrintWriter": [[25, 35]]}}}, {"text": "PrintWriter can throw some exceptions which you'll need to handle", "label": {"api": {"PrintWriter": [[0, 10]]}}}, {"text": "You could use a CountDownLatch from the java.util.concurrent package", "label": {"api": {"CountDownLatch": [[16, 29]]}}}, {"text": "You can use an ExecutorCompletionService", "label": {"api": {"ExecutorCompletionService": [[15, 39]]}}}, {"text": "You can use SimpleDateFormat to convert it into desired output", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "JSpinner.getValue returns Object and you are just printing value returned by default Date#toString()", "label": {"api": {"JSpinner.getValue": [[0, 16]]}}}, {"text": "Use a StringBuilder to construct a new string with the modified properties, by iterating the characters, and for each character c, and 1 and c to the builder", "label": {"api": {"StringBuilder": [[6, 18]]}}}, {"text": "Per the ThreadPoolExecutor doc (Java ThreadPoolExecutor), if I create an executor service like so", "label": {"api": {"Java ThreadPoolExecutor": [[32, 54]]}}}, {"text": "With Java 8 you can use Files.lines", "label": {"api": {"Files.lines": [[24, 34]]}}}, {"text": "I'm trying to implement Cipher, using the protected constructor of that class", "label": {"api": {"Cipher": [[24, 29]], "protected constructor of that class": [[42, 76]]}}}, {"text": "I've supplied all arguments, even my own CipherSpi, so why does it throw this exception", "label": {"api": {"Cipher": [[41, 46]]}}}, {"text": "this functionality already exists, so you don't need to rewrite it", "label": {"api": {"already exists": [[19, 32]]}}}, {"text": "Stack, which extends Vector, has every method synchronized", "label": {"api": {"Stack": [[0, 4]], "Vector": [[21, 26]]}}}, {"text": "Queue is an interface", "label": {"api": {"Queue": [[0, 4]]}}}, {"text": "For example, an ArrayBlockingQueue is thread safe, but a LinkedList is not", "label": {"api": {"Queue": [[29, 33]], "ArrayBlockingQueue": [[16, 33]], "LinkedList": [[57, 66]]}}}, {"text": "A BlockingQueue gives you that", "label": {"api": {"BlockingQueue": [[2, 14]]}}}, {"text": "the Formatter class as mentioned in the comment or the MessageFormat class, you can better control how the output looks like", "label": {"api": {"Formatter class": [[4, 18]], "MessageFormat class": [[55, 73]]}}}, {"text": "In Java 1.7 one may use java.util.PriorityQueue", "label": {"api": {"java.util.PriorityQueue": [[24, 46]]}}}, {"text": "I will direct you to the File Javadoc", "label": {"api": {"File": [[25, 28]]}}}, {"text": "For me, the problem was associated with using the JDK's ToolProvider to get an instance of JavaCompiler", "label": {"api": {"ToolProvider": [[56, 67]], "JavaCompiler": [[91, 102]]}}}, {"text": "The ToolProvider ends up using a different classloader to load the com.sun.tools.javac.api.JavacTool class", "label": {"api": {"ToolProvider": [[4, 15]]}}}, {"text": "The solution that worked for me (at least so far) was instead of using the getSystemJavaCompiler method to provide an instance of JavaCompiler", "label": {"api": {"JavaCompiler": [[84, 95], [130, 141]]}}}, {"text": "Replace your list with a CopyOnWriteArrayList, don't \"synchronize\" it and you'll be good to go", "label": {"api": {"CopyOnWriteArrayList": [[25, 44]]}}}, {"text": "The ExecutorService is the way to go", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "It provides you an interface (Future) to the state of the underlying thread, the ability to detect exceptions and return a value from the completed thread", "label": {"api": {"Future": [[30, 35]]}}}, {"text": "Here is a simple example of how to use ExecutorSerivce and the Future interface", "label": {"api": {"Future": [[63, 68]]}}}, {"text": "As shown in this example, DefaultCellEditor handles this for you", "label": {"api": {"DefaultCellEditor": [[26, 42]]}}}, {"text": "DefaultCellEditor works by overriding setValue() in the nested EditorDelegate", "label": {"api": {"DefaultCellEditor": [[0, 16]], "EditorDelegate": [[63, 76]]}}}, {"text": "If you are using Java 7 or newer you should investigate the java.nio.file package", "label": {"api": {"java.nio.file": [[60, 72]]}}}, {"text": "In particular, java.nio.file.attribute.FileTime may solve your problem", "label": {"api": {"java.nio.file": [[15, 27]], "java.nio.file.attribute.FileTime": [[15, 46]]}}}, {"text": "sendRedirect() in HttpServletResponse do change the url as well", "label": {"api": {"sendRedirect()": [[0, 13]]}}}, {"text": "The   javadoc for the set method of Fieldclass clearly states that ExceptionInInitializerError may occur if the initialization provoked by this method fails", "label": {"api": {"Field": [[36, 40]]}}}, {"text": "I was wondering that Classes get lazily initialized when they are referenced or when we use Class.forName(\"binary name\",true,ClassLoader) .if initialization of class does not fail,then class variables have been initialized according to the value assigned in the declaration or as in static constructor.Once a field has been initliazed ,can it explicity throw ExceptionInInitializerError when called by the Field's class set method?", "label": {"api": {"Field": [[406, 410]]}}}, {"text": "fix your URLs or go to the real URL by using HttpServletRequest#getContextPath", "label": {"api": {"HttpServletRequest#getContextPath": [[45, 77]]}}}, {"text": "Use a BorderPane with the Table as Center element and the header and footer element as Top and Bottom element, respectively", "label": {"api": {"BorderPane": [[6, 15]]}}}, {"text": "First of all, I would recommend to take a look at how to use JPanels and other GUI components in Swing", "label": {"api": {"JPanel": [[61, 66]]}}}, {"text": "You could use a JPanel to be added to the contentPane of your JFrame", "label": {"api": {"JPanel": [[16, 21]]}}}, {"text": "If you want the score label to appear or disappear, add/ remove it from the JPanel that you added to the JFrame", "label": {"api": {"JPanel": [[76, 81]]}}}, {"text": "Then, since you reset the text of the label, you should call repaint() on the JPanel", "label": {"api": {"JPanel": [[78, 83]]}}}, {"text": "If you choose to add/ remove the JLabel instead of just changing its text you should also call revalidate() on the JPanel", "label": {"api": {"JPanel": [[115, 120]]}}}, {"text": "You could also declare and initialize the JPanel and JLabel in the showScore() method, making it more local", "label": {"api": {"JPanel": [[42, 47]]}}}, {"text": "But then you would also need to call pack() on the JFrame and clear the previous JPanel from it every time you call the function", "label": {"api": {"JPanel": [[81, 86]]}}}, {"text": "If you want to do using custom tag then try with BodyTagSupport that implements BodyTag interface", "label": {"api": {"BodyTagSupport": [[49, 62]], "BodyTag": [[49, 55], [80, 86]]}}}, {"text": "Use a FileOutputStream", "label": {"api": {"FileOutputStream": [[6, 21]]}}}, {"text": "Similarly you can read FileInputStream for reading from a binary file", "label": {"api": {"FileInputStream": [[23, 37]]}}}, {"text": "You should be able to use any OutputStream to do this, because they all have a write method that takes a byte", "label": {"api": {"OutputStream": [[30, 41]]}}}, {"text": "For example, you could use a FileOutputStream", "label": {"api": {"OutputStream": [[33, 44]], "FileOutputStream": [[29, 44]]}}}, {"text": "Similarly, you can use an InputStream's read method for reading bytes", "label": {"api": {"InputStream": [[26, 36]]}}}, {"text": "Because you have a constant instead of a literal being passed to split, I would run it through Pattern.quote before passing to split, so that it's interpreted literally", "label": {"api": {"Pattern.quote": [[95, 107]]}}}, {"text": "You can use addAll", "label": {"api": {"addAll": [[12, 17]]}}}, {"text": "Alternately, you can use clone", "label": {"api": {"clone": [[25, 29]]}}}, {"text": "I suggest you use PreparedStatement and bind the parameter, currently you are vulnerable to SQL Injection attacks", "label": {"api": {"PreparedStatement": [[18, 34]], "bind": [[40, 43]]}}}, {"text": "write() in Writer class is not static and you are trying to use it as static", "label": {"api": {"Writer": [[11, 16]]}}}, {"text": "write() in Writer class does not have a method to take variable number of arguments", "label": {"api": {"Writer": [[11, 16]]}}}, {"text": "You have created instance of FileWriter (output) and you should use it to write the data", "label": {"api": {"Writer": [[33, 38]], "FileWriter": [[29, 38]]}}}, {"text": "Note that input is a File and this implies that File#canRead() is returning false for your image", "label": {"api": {"File#canRead()": [[48, 61]]}}}, {"text": "Looking at the documentation for File#canRead(), we see that it", "label": {"api": {"File#canRead()": [[33, 46]]}}}, {"text": "Use File#length() which returns the length of the file", "label": {"api": {"File#length()": [[4, 16]]}}}, {"text": "You can read this informathion from RuntimeMXBean", "label": {"api": {"RuntimeMXBean": [[36, 48]]}}}, {"text": "You'll need to resample the image by a factor of 300 / 72d using AffineTransform, as shown here", "label": {"api": {"AffineTransform": [[65, 79]]}}}, {"text": "As you are interpolating, specify the higher quality AffineTransformOp.TYPE_BICUBIC for interpolationType, even though it's slower", "label": {"api": {"AffineTransform": [[53, 67]]}}}, {"text": "Here, the type of s is Serializable, and you pass in a String and an ArrayList<Integer>", "label": {"api": {"String": [[55, 60]], "ArrayList": [[69, 77]]}}}, {"text": "Both String and ArrayList are Serializable, with no other relation, so the inferred type for T is Serializable", "label": {"api": {"String": [[5, 10]], "ArrayList": [[16, 24]]}}}, {"text": "You can just use a normal Map<String, List<String>> type, for example", "label": {"api": {"Map<String, List<String>>": [[26, 50]]}}}, {"text": "Use LinkedList#listIterator instead", "label": {"api": {"LinkedList#listIterator": [[4, 26]]}}}, {"text": "You can use flatMap to flatten the internal lists (after converting them to Streams) into a single Stream, and then collect the result into a list", "label": {"api": {"flatMap": [[12, 18]]}}}, {"text": "Because a List is Iterable, this code calls the forEach method (Java 8 feature), which is inherited from Iterable", "label": {"api": {"the forEach method": [[44, 61]]}}}, {"text": "For the Consumer, this code passes in a method reference (Java 8 feature) to the pre-Java 8 method List.addAll to add the inner list elements sequentially", "label": {"api": {"List.addAll": [[99, 109]]}}}, {"text": "The implementation details for Math are not specified", "label": {"api": {"Math": [[31, 34]]}}}, {"text": "By default many of the Math methods simply call the equivalent method in StrictMath for their implementation", "label": {"api": {"Math": [[23, 26], [79, 82]], "StrictMath": [[73, 82]]}}}, {"text": "Code generators are encouraged to use platform-specific native libraries or microprocessor instructions, where available, to provide higher-performance implementations of Math methods", "label": {"api": {"Math": [[171, 174]]}}}, {"text": "In other words, different JVMs can implement Math.sin differently", "label": {"api": {"Math": [[45, 48]]}}}, {"text": "But StrictMath is more formalized", "label": {"api": {"Math": [[10, 13]], "StrictMath": [[4, 13]]}}}, {"text": "These algorithms are available from the well-known network library netlib as the package \"Freely Distributable Math Library,\" fdlibm", "label": {"api": {"Math": [[111, 114]]}}}, {"text": "Just use List.removeAll() to do all the heavy lifting", "label": {"api": {"List.removeAll()": [[9, 24]]}}}, {"text": "Try this code using String#indexOf() function to get index of .com and substring according to it", "label": {"api": {"String#indexOf()": [[20, 35]]}}}, {"text": "According to the API, the .split(...) method in the String class splits strings around the regex given as an argument", "label": {"api": {"API": [[17, 19]]}}}, {"text": "If you look at the examples the API gives, it removes the characters that match when splitting the string", "label": {"api": {"API": [[32, 34]]}}}, {"text": "ConcurrentSkipListMap is a concurrent, sorted, key-value map", "label": {"api": {"ConcurrentSkipListMap": [[0, 20]]}}}, {"text": "ConcurrentHashMap is a concurrent unsorted key-value", "label": {"api": {"ConcurrentHashMap": [[0, 16]]}}}, {"text": "Create a ClientRequestFilter to perform the basic authentication", "label": {"api": {"ClientRequestFilter": [[9, 27]], "Client": [[9, 14]]}}}, {"text": "And register it in your Client", "label": {"api": {"Client": [[24, 29]]}}}, {"text": "The solution above uses the Java 8 Base64.Encoder to perform the Base64 encoding", "label": {"api": {"Base64.Encoder": [[35, 48]]}}}, {"text": "If you dont know the length of the message you will need to read each byte reperesentation into a String buffer and use Byte#parseByte(buffer, 16) to make a signed byte [-127, 127] out of it", "label": {"api": {"Byte#parseByte(buffer, 16)": [[120, 145]]}}}, {"text": "If you know the length of the whole String that the client is sending you could read it all and then String#split(regex) it using a delimiter whicht seems to be in your case \\x", "label": {"api": {"String#split(regex)": [[101, 119]]}}}, {"text": "and again make use of Byte#parseByte(buffer, 16) to convert", "label": {"api": {"Byte#parseByte(buffer, 16)": [[22, 47]]}}}, {"text": "If you need unsigned values [0, 255] then you have to go with Integer.html#parseInt(buffer, 16)", "label": {"api": {"Integer.html#parseInt(buffer, 16)": [[62, 94]]}}}, {"text": "Have a look at NumberFormat", "label": {"api": {"NumberFormat": [[15, 26]]}}}, {"text": "As explained in the 1.7 documentation it returns value 0 if d1 is numerically equal to d2", "label": {"api": {"1.7 documentation": [[20, 36]]}}}, {"text": "Another more clunky way would be to use a specialized DateTimeFormatterBuilder using the method parseDefaulting() for the missing time and offset (not tested)", "label": {"api": {"parseDefaulting()": [[96, 112]]}}}, {"text": "Finally, in order to get the component's id in the managed bean, you can invoke the UIComponent#getClientId() method", "label": {"api": {"UIComponent#getClientId()": [[84, 108]]}}}, {"text": "You can open it in all three operating systems using the Java Desktop API", "label": {"api": {"Java Desktop API": [[57, 72]]}}}, {"text": "Javadoc 6 versus Javadoc 7", "label": {"api": {"Javadoc 6": [[0, 8]], "Javadoc 7": [[17, 25]]}}}, {"text": "Sure, you can use Properties class for that", "label": {"api": {"Properties": [[18, 27]]}}}, {"text": "If you don't mind converting everything to double, you can use Number.doubleValue()", "label": {"api": {"Number.doubleValue()": [[63, 82]]}}}, {"text": "Otherwise the char is being converted to an int to define initial capacity", "label": {"api": {"to define initial capacity": [[48, 73]]}}}, {"text": "It has a BufferedImage and extends JComponent, overriding the paintComponent() method)", "label": {"api": {"BufferedImage": [[9, 21]], "paintComponent()": [[62, 77]]}}}, {"text": "There is a timeout setting for read() operations, but I could not find one for write operations", "label": {"api": {"timeout setting for read() operations": [[11, 47]]}}}, {"text": "The replaceAll string method should be able to help you", "label": {"api": {"replaceAll": [[4, 13]]}}}, {"text": "You could easily loop .replaceAll over an array of tokens ([\"+\", \"-\", \"*\", ...]) that you want to split up", "label": {"api": {"replaceAll": [[23, 32]]}}}, {"text": "JPA 2.1 introduced type converters", "label": {"api": {"type converters": [[19, 33]]}}}, {"text": "The natural way to represent the mana cost of an MtG spell is as a mapping from mana types to (non-negative) integers; in Java terms, a Map<ManaType, int>, where ManaType would most reasonably be an enum", "label": {"api": {"Map<ManaType, int>": [[136, 153]]}}}, {"text": "From the DatePicker docs getValue() returns a LocalDate", "label": {"api": {"DatePicker docs": [[9, 23]]}}}, {"text": "If you meant \"DatePicker\" to be the JavaFX DatePicker class that returns a java.time.LocalDate object, then you need to make your comparison with another java.time.LocalDate object", "label": {"api": {"DatePicker": [[14, 23], [43, 52]], "java.time.LocalDate": [[75, 93], [154, 172]]}}}, {"text": "You can use File.mkdir() or File.mkdirs() to create a directory", "label": {"api": {"File.mkdir()": [[12, 23]], "File.mkdirs()": [[28, 40]]}}}, {"text": "Also, since I see that you use \"\\\\\" in your question, I would suggest using File.separator for a portable path separator string", "label": {"api": {"File.separator": [[76, 89]]}}}, {"text": "You can create all parent directories by using File.mkdirs()", "label": {"api": {"File.mkdirs()": [[47, 59]]}}}, {"text": "File.mkdirs() - Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories", "label": {"api": {"File.mkdirs()": [[0, 12]]}}}, {"text": "Starting from Java 7, you can use the java.nio.file.Files & java.nio.file.Paths classes", "label": {"api": {"java.nio.file.Files": [[38, 56]], "java.nio.file.Paths": [[60, 78]]}}}, {"text": "Take a look at Container#add(Component, Object)", "label": {"api": {"Container#add(Component, Object)": [[15, 46]]}}}, {"text": "This implements Closable", "label": {"api": {"Closable": [[16, 23]]}}}, {"text": "If anything, you might want to try setSoTimeout() instead", "label": {"api": {"setSoTimeout()": [[35, 48]]}}}, {"text": "Also StringBuilder is a better choice for string manipulations", "label": {"api": {"StringBuilder": [[5, 17]]}}}, {"text": "But may be you can use the setUndecorated() method to remove the title bar and window edges", "label": {"api": {"setUndecorated()": [[27, 42]]}}}, {"text": "The run method can use streams to handle input and output", "label": {"api": {"run": [[4, 6]]}}}, {"text": "Use an OutputStream for out and read from it when run is finished", "label": {"api": {"run": [[50, 52]]}}}, {"text": "executeBatch() method returns an array (int[]) of update counts containing one element for each command in the batch", "label": {"api": {"executeBatch": [[0, 11]]}}}, {"text": "For more detail about the content of the this array, you can look at the Javadoc of executeBatch", "label": {"api": {"executeBatch": [[84, 95]]}}}, {"text": "If I were to do it again, I might use the ArrayDeque class", "label": {"api": {"ArrayDeque class": [[42, 57]]}}}, {"text": "You should check the javadoc for parse method", "label": {"api": {"parse": [[33, 37]]}}}, {"text": "It is possible to do this using java.lang.instrument", "label": {"api": {"java.lang.instrument": [[32, 51]]}}}, {"text": "A project called \"loosejar\" by Kyrill Alyoshin uses java.lang.instrument to do what I think you are trying to do here, exposing its results via JMX so you can see them as the app is running using jconsole or jvisualvm", "label": {"api": {"java.lang.instrument": [[52, 71]]}}}, {"text": "java.net.URI can only parse URLs that conform to RFC 2396", "label": {"api": {"java.net.URI": [[0, 11]]}}}, {"text": "For this, java.net.IDN is useful", "label": {"api": {"java.net.IDN": [[10, 21]]}}}, {"text": "For more information, I suggest you read the Javadoc for ResultSet", "label": {"api": {"Javadoc for ResultSet": [[45, 65]]}}}, {"text": "The Apache Commons library has a utility you can use, and it's built in to Java 8", "label": {"api": {"Java 8": [[75, 80]]}}}, {"text": "If you want it to be stored in your String Pool memory, you should use the intern() method", "label": {"api": {"intern()": [[75, 82]]}}}, {"text": "Replace your nextInt() call with next()", "label": {"api": {"nextInt()": [[13, 21]], "next()": [[33, 38]]}}}, {"text": "I know there is a set of predefined functional interfaces in java.util.function such as Function<T,R> but I didn't find one with no arguments and not producing a result", "label": {"api": {"java.util.function": [[61, 78]]}}}, {"text": "From Arrays.asList javadocs", "label": {"api": {"Arrays.asList javadocs": [[5, 26]]}}}, {"text": "Swing UI delegates for text components typically specify the same font as used for logical font families", "label": {"api": {"logical font families": [[83, 103]]}}}, {"text": "Here is the link to setProperty(String property, Object value) documentation", "label": {"api": {"link": [[12, 15]]}}}, {"text": "From the stack trace it appears that this was caught by the Thread.UncaughtExceptionHandler", "label": {"api": {"Thread.UncaughtExceptionHandler": [[60, 90]]}}}, {"text": "Then use the Thread.setDefaultUncaughtExceptionHandler to install it", "label": {"api": {"Thread.setDefaultUncaughtExceptionHandler": [[13, 53]]}}}, {"text": "After reading the documentation I don't see a good way to make the dialog modal while using showDialog()", "label": {"api": {"showDialog()": [[92, 103]]}}}, {"text": "If you modify the list, there will be a ConcurrentModificationException thrown", "label": {"api": {"ConcurrentModificationException": [[40, 70]]}}}, {"text": "I've never had need to do this sort of thing, but you might have some luck using a CountDownLatch or CyclicBarrier from your various threads", "label": {"api": {"CountDownLatch": [[83, 96]], "CyclicBarrier": [[101, 113]]}}}, {"text": "You can parse integer from string using Integer.parseInt(String)", "label": {"api": {"Integer.parseInt(String)": [[40, 63]]}}}, {"text": "Threading and concurrency is a the start of a pretty deep rabbit hole, but something like a ThreadPoolExecutor with a single thread would probably work", "label": {"api": {"ThreadPoolExecutor": [[92, 109]]}}}, {"text": "I want to use LocalDate to format in next 05 may 1988", "label": {"api": {"LocalDate": [[14, 22]]}}}, {"text": "The System.out.println() will invoke the ArrayList's toString method, which will invoke the toString() method of AbstractCollection class", "label": {"api": {"AbstractCollection": [[113, 130]]}}}, {"text": "JTextArea inherits the most useful write(Writer) and read(Reader, Object) methods which should make this all rather simple..", "label": {"api": {"write(Writer)": [[35, 47]], "read(Reader, Object)": [[53, 72]]}}}, {"text": "Try using the Response.getEntity() method, which returns an InputStream", "label": {"api": {"Response.getEntity()": [[14, 33]], "InputStream": [[60, 70]]}}}, {"text": "Then, to convert your InputStream to a String, check this question", "label": {"api": {"InputStream": [[22, 32]]}}}, {"text": "If you really need to map the JSON String to a Java entity, that consider calling directly the Response.readEntity()", "label": {"api": {"Response.readEntity()": [[95, 115]]}}}, {"text": "Note that, if you consume the InputStream, you will probably have to process the input stream on your own", "label": {"api": {"InputStream": [[30, 40]]}}}, {"text": "(which you should read) for JTable.", "label": {"api": {"JTable": [[28, 33]]}}}, {"text": "Coordinate conversions will be necessary when using the row based methods of JTable with the underlying TableModel", "label": {"api": {"JTable": [[77, 82]]}}}, {"text": "All of JTables row based methods are in terms of the RowSorter, which is not necessarily the same as that of the underlying TableModel", "label": {"api": {"JTable": [[7, 12]]}}}, {"text": "For example, the selection is always in terms of JTable so that when using RowSorter you will need to convert using convertRowIndexToView or convertRowIndexToModel", "label": {"api": {"JTable": [[49, 54]]}}}, {"text": "Here's my implementation using Java 8 IntStream to simplify the sum process..", "label": {"api": {"IntStream": [[38, 46]]}}}, {"text": "What you are looking for is a ReadWriteLock", "label": {"api": {"ReadWriteLock": [[30, 42]]}}}, {"text": "Using the standard Java JSON Stream APIs, this will produce the java.util.Map you want", "label": {"api": {"Java JSON Stream APIs": [[19, 39]], "java.util.Map": [[64, 76]]}}}, {"text": "You should use a global Random instance for performance reasons, instead of initializing one each time - see also API", "label": {"api": {"API": [[114, 116]]}}}, {"text": "for multi-threaded applications, you should use a ThreadLocalRandom instead, in the form of ThreadLocalRandom.current().next..", "label": {"api": {"ThreadLocalRandom": [[50, 66], [92, 108]]}}}, {"text": "for cryptographically secure random numbers, use a SecureRandom instead", "label": {"api": {"SecureRandom": [[51, 62]]}}}, {"text": "It can be OGNL, JSON or any other code using BeanInfo to access properties and call a getter method", "label": {"api": {"BeanInfo": [[45, 52]]}}}, {"text": "Java 7 introduced a Files class which has createDirectories method, but that too doesn't satisfy your requirement", "label": {"api": {"Files": [[20, 24]]}}}, {"text": "If you were trying to multiply the value by a power of 10 (as your initial question suggested), there's a much simpler way of doing this, using movePointRight", "label": {"api": {"movePointRight": [[144, 157]]}}}, {"text": "No, the standard java libraries don't provide you with a useful http client other than URLConnection", "label": {"api": {"URLConnection": [[87, 99]]}}}, {"text": "Yes, the list keeps a pointer to the tail, as you can read in the class JavaDoc", "label": {"api": {"class JavaDoc": [[66, 78]]}}}, {"text": "Create a JSpinner that has a custom DefaultFormatter and a SpinnerModel to which the JSpinner does not listen", "label": {"api": {"JSpinner": [[9, 16], [85, 92]]}}}, {"text": "Check out http://docs.oracle.com/javase/7/docs/api/java/lang/CharSequence.html if you would like to read more into it", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/CharSequence.html": [[10, 77]]}}}, {"text": "Calendar#roll will just roll (increase/decrease) the value of the field you specify and won't update the other fields in the Calendar", "label": {"api": {"Calendar#roll": [[0, 12]]}}}, {"text": "Use Calendar#get instead", "label": {"api": {"Calendar#get": [[4, 15]]}}}, {"text": "Use the DecimalFormat class to format doubles", "label": {"api": {"DecimalFormat": [[8, 20]]}}}, {"text": "If you are doing such anonymous work, I would recommend a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[58, 75]]}}}, {"text": "Otherwise, if you want to continue doing it the way you are doing right now, you should use Thread#interrupt(), or use a boolean value outside of the anonymous Thread and change that to stop execution", "label": {"api": {"Thread#interrupt()": [[92, 109]]}}}, {"text": "I believe I am looking for a FileAttribute that I can pass to createFile", "label": {"api": {"FileAttribute": [[29, 41]], "createFile": [[62, 71]]}}}, {"text": "You can only get the exit-code (which should be non-zero if there was a abnormal termination) or read the standard output and (especially) standard error streams", "label": {"api": {"exit-code": [[21, 29]]}}}, {"text": "See \"Memory Consitency Properties\" in the Package description", "label": {"api": {"\"Memory Consitency Properties\"": [[4, 33]]}}}, {"text": "Have you tried DataInputStream", "label": {"api": {"DataInputStream": [[15, 29]]}}}, {"text": "I would also point out, that unless this is an academic exercise, the Arrays utility class in the Java API has many different sort() methods for exactly this reason, including one for int[]", "label": {"api": {"Arrays": [[70, 75]], "one for int[]": [[176, 188]]}}}, {"text": "The details of Component.repaint() are", "label": {"api": {"Component.repaint()": [[15, 33]]}}}, {"text": "Note that in JDK document's words rewind() and clear() looks alike for \"cleaning\" the ByteBuffer", "label": {"api": {"rewind()": [[34, 41]], "clear()": [[47, 53]], "ByteBuffer": [[86, 95]]}}}, {"text": "Actually the old data exists, furthermore rewind() should be used before channel-write or get operation and clear() corresponds to channel-read or put operation", "label": {"api": {"rewind()": [[42, 49]], "clear()": [[108, 114]]}}}, {"text": "Anyway, you should use exec(String[] cmdarray, String[] envp, File dir) or ProcessBuilder instead of the plain string based exec", "label": {"api": {"exec(String[] cmdarray, String[] envp, File dir)": [[23, 70]], "ProcessBuilder": [[75, 88]]}}}, {"text": "Use System.lineSeparator() instead of \\n", "label": {"api": {"System.lineSeparator()": [[4, 25]]}}}, {"text": "What is the difference between functions nextXXX() - such as like nextInt(), nextFloat() and nextBytes() - and generateSeed(int numBytes)", "label": {"api": {"nextBytes()": [[93, 103]]}}}, {"text": "byte[] in the SecureRandom class of Java", "label": {"api": {"SecureRandom class": [[14, 31]]}}}, {"text": "0x30A0) to a char, you could use Character.toChars()", "label": {"api": {"Character.toChars()": [[33, 51]]}}}, {"text": "I have already read standard documentation and this question on SO...but couldn't find proper solution in the context of threads", "label": {"api": {"standard documentation": [[20, 41]]}}}, {"text": "The convention between equals() and hashCode() mandates this", "label": {"api": {"convention": [[4, 13]]}}}, {"text": "Well, asides from the discussion how usefull the informative annotation @FunctionalInterface is (and I am happy Java 8 does not require it for lambdas)", "label": {"api": {"@FunctionalInterface": [[72, 91]]}}}, {"text": "It is explicitly described as the natural ordering and does not take the two this/that arguments", "label": {"api": {"explicitly described": [[6, 25]]}}}, {"text": "Comparator<T>, and for that a lambda implementing it is a very natural choice", "label": {"api": {"Comparator<T>": [[0, 12]]}}}, {"text": "Would I possibly use the System.getProperty() method", "label": {"api": {"System.getProperty()": [[25, 44]]}}}, {"text": "The set returned from FXCollections.unmodifiableObservableSet() work in mysterious ways", "label": {"api": {"FXCollections.unmodifiableObservableSet()": [[22, 62]]}}}, {"text": "You might think you add a listener to the backing set, but in reality, the listeners you add go straight to the wrapper, which has registered himself as a weak listener (WeakSetChangeListener) of the backing set", "label": {"api": {"WeakSetChangeListener": [[170, 190]]}}}, {"text": "String.replaceAll does not modify the string in-place", "label": {"api": {"String.replaceAll": [[0, 16]]}}}, {"text": "And the String.replaceAll accepts two parameters", "label": {"api": {"String.replaceAll": [[8, 24]]}}}, {"text": "That is why I always recommend to choose Regex Pattern matching over other searches", "label": {"api": {"Regex Pattern": [[41, 53]]}}}, {"text": "You're calling Writer.write(int)", "label": {"api": {"Writer.write(int)": [[15, 31]]}}}, {"text": "The -0500 at the end isn't milliseconds (the S format character), it's an ISO-8601 timezone indicator (the X format character, in current versions of Java; note that it was added relatively recently, in Java 7)", "label": {"api": {"X format character": [[107, 124]]}}}, {"text": "However, from the documentation of Jersey client API, I didn't find how to enclose the following data in DELETE request", "label": {"api": {"Jersey client API": [[35, 51]]}}}, {"text": "From the Jersey client API, the SyncInvoker class doesn't support a delete method with entity body as its argument", "label": {"api": {"Jersey client API": [[9, 25]], "SyncInvoker": [[32, 42]]}}}, {"text": "I think the easiest solution would be to use a StringBuilder", "label": {"api": {"StringBuilder": [[47, 59]]}}}, {"text": "I think the dot is considered as the regex pattern meaning \"any character\" so your split method returns an empty array", "label": {"api": {"regex": [[37, 41]]}}}, {"text": "I am creating a zip file using ZipOutputStream", "label": {"api": {"ZipOutputStream": [[31, 45]]}}}, {"text": "Using synchronized keyword is an implicit equivalent to using a ReentrantLock, as the javadoc shows it in an example", "label": {"api": {"ReentrantLock": [[64, 76]]}}}, {"text": "If you use toArray(String[][]::new) instead of toArray() it will return a String[][] instead of an Object[] and you wont need to cast it at all (if you assign it to a String[][])", "label": {"api": {"toArray(String[][]::new)": [[11, 34]]}}}, {"text": "Or you can use the URI class instead of URL, URI does not throw MalformedURLException like the URL class", "label": {"api": {"URI": [[19, 21], [45, 47]]}}}, {"text": "Although new URI() may also throw URISyntaxException if you use backslash in location for example", "label": {"api": {"URI": [[13, 15], [34, 36]]}}}, {"text": "Use Process.waitFor, but add /wait to your command to make then new process wait for the batch process to stop", "label": {"api": {"Process.waitFor": [[4, 18]]}}}, {"text": "Files.move() does not guarantee atomic move", "label": {"api": {"Files.move()": [[0, 11]]}}}, {"text": "Try using nextInt() from Random", "label": {"api": {"nextInt()": [[10, 18]]}}}, {"text": "This will create a random int which you can wrap in  Integer.toString(int i)", "label": {"api": {"Integer.toString(int i)": [[53, 75]]}}}, {"text": "A suggestion would be to keep the PrintWriter channel in a session variable, and have an altogether different service responsible of scheduling and writing out messages, for instance by scheduling an Executor per user/printwriter in a ScheduledExecutorService, that sends some messages and then terminates the the executor, keeping the PrintWriter open until it somehow times out", "label": {"api": {"ScheduledExecutorService": [[235, 258]]}}}, {"text": "You can use Collections.sort, which takes a comparator in argument", "label": {"api": {"Collections.sort": [[12, 27]]}}}, {"text": "In any event, you would replace any of these lookup references with instance variables marked up with @EJB", "label": {"api": {"@EJB": [[102, 105]]}}}, {"text": "Class EOFException and you will probably figure out that the stream you're reading is empty", "label": {"api": {"Class EOFException": [[0, 17]]}}}, {"text": "I'm tempted to think that the HashSet.contains(Object) method performs in constant time", "label": {"api": {"HashSet.contains(Object)": [[30, 53]]}}}, {"text": "You can use the class javax.xml.bind.DatatypeConverter (since Java SE 6 update 3)", "label": {"api": {"javax.xml.bind.DatatypeConverter": [[22, 53]]}}}, {"text": "The closest equivalent would be the XMLStreamWriter class in the StAX API", "label": {"api": {"XMLStreamWriter": [[36, 50]]}}}, {"text": "For more information on what that means, check out the documentation on the validate method", "label": {"api": {"validate": [[76, 83]]}}}, {"text": "The documentation for Connection states that it extends AutoCloseable", "label": {"api": {"documentation for Connection": [[4, 31]]}}}, {"text": "The documentation for AutoCloseable states that a class extends it when it is a \"A resource that must be closed when it is no longer needed.\"  It offers a Close method, and your friend should use it", "label": {"api": {"documentation for AutoCloseable": [[4, 34]]}}}, {"text": "The Proc class is roughly equivalent to the interfaces in the java.util.function package", "label": {"api": {"java.util.function": [[62, 79]]}}}, {"text": "Basically you want to invoke SchemaFactory.newSchema(Source) in some way to generate the schema you can use for validation", "label": {"api": {"SchemaFactory.newSchema(Source)": [[29, 59]]}}}, {"text": "Therefore probably the most convenient way is to create a DOMSource", "label": {"api": {"DOMSource": [[58, 66]]}}}, {"text": "This source can furthermore be generated using a new Document where you can probably use importNode to copy the previously extracted sub-tree into the new \"schema\"", "label": {"api": {"Document": [[53, 60]], "importNode": [[89, 98]]}}}, {"text": "It would be better if you use Statement#getMaxRows instead and let your JDBC driver manages this (if supported)", "label": {"api": {"Statement#getMaxRows": [[30, 49]]}}}, {"text": "Do not use getBounds() as it gives the component location relative to its parent", "label": {"api": {"getBounds()": [[11, 21]]}}}, {"text": "Those Java resource usage examples could be written like the example you give where r is initially set to null, but if they used the Java 7 try-with-resources syntax (Assuming Resource implements AutoCloseable)", "label": {"api": {"AutoCloseable": [[196, 208]]}}}, {"text": "From the docs", "label": {"api": {"From the docs": [[0, 12]]}}}, {"text": "if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[171, 201]]}}}, {"text": "Where you handle the action of pressing quit, you could call System.exit(int) (assuming you have nothing to clean up or save off that isn't being done in a shutdown hook)", "label": {"api": {"System.exit(int)": [[61, 76]], "shutdown hook": [[156, 168]]}}}, {"text": "What you should probably do is look into the @JoinTable annotation, which would allow you to definitively specify different tables should be used for your Like and Dislike features", "label": {"api": {"@JoinTable": [[45, 54]]}}}, {"text": "Putting different types of Objects into an array will throw an ArrayStoreException, while putting different types of objects into an ArrayList works", "label": {"api": {"ArrayStoreException": [[63, 81]], "ArrayList": [[133, 141]]}}}, {"text": "As far as I know, the ArrayList is built on top of an array, so why does it work there", "label": {"api": {"ArrayList": [[22, 30]]}}}, {"text": "with the mouse, you can use the getModifiersEx() method of MouseEvent", "label": {"api": {"getModifiersEx()": [[32, 47]]}}}, {"text": "You could therefore create an immutable list of Long objects to store the long values obtained from calling Date.getTime(), and construct new date objects on the fly using the Date(long date) constructor when retrieving from the list", "label": {"api": {"Date.getTime()": [[108, 121]], "Date(long date)": [[176, 190]]}}}, {"text": "Based on your comment, it sounds like your ArraySet is only implementing the Set interface", "label": {"api": {"interface": [[81, 89]]}}}, {"text": "In terms of doing the actual parallelism, one very useful construct in Java is the ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[83, 100]]}}}, {"text": "BufferedWriter#write(int) takes the int but writes a char", "label": {"api": {"BufferedWriter#write(int)": [[0, 24]]}}}, {"text": "Among others, Java has the BigDecimal class, and C# has the decimal type", "label": {"api": {"BigDecimal": [[27, 36]]}}}, {"text": "Use the Java Agent API to replace (wrap) the byte-code of the default Object class", "label": {"api": {"Java Agent API": [[8, 21]]}}}, {"text": "The Java Agent API might cost you about 10% of your run-time performance", "label": {"api": {"Java Agent API": [[4, 17]]}}}, {"text": "If you require a lazy singleton in a multi-classloader environment, use the ServiceLoader", "label": {"api": {"ServiceLoader": [[76, 88]]}}}, {"text": "The operation you are performing is called Mutable reduction", "label": {"api": {"Mutable reduction": [[43, 59]]}}}, {"text": "However, when all three functions are implemented by a dedicated class it might be useful to implement these functions inside a class implementing Collector for easier reuse", "label": {"api": {"Collector": [[147, 155]]}}}, {"text": "Use SimpleDateFormat for this", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "The easiest way I have found is by invoking evictAll() method from EntityManagerFactory's cache after a bulk operation", "label": {"api": {"evictAll()": [[44, 53]], "EntityManagerFactory": [[67, 86]]}}}, {"text": "You could use a HashSet, which doesn't allow duplicate elements, to store the answers", "label": {"api": {"HashSet": [[16, 22]]}}}, {"text": "If you package the processor in the same jar as the annotation and register the processor as a service, it will be exucted automagically when compiling an annotated class (must be in a different jar)", "label": {"api": {"service": [[95, 101]]}}}, {"text": "Take a look at ComponentListener", "label": {"api": {"ComponentListener": [[15, 31]]}}}, {"text": "Add a ComponentListener to your JFrame and handle the events", "label": {"api": {"ComponentListener": [[6, 22]]}}}, {"text": "Reading The official Javadoc for KeyEvent, it seems that it is a better practice to use Key Typed events rather than Key Pressed or Key Released events, because they are higher-level", "label": {"api": {"The official Javadoc for KeyEvent": [[8, 40]]}}}, {"text": "For your reference, this is how the Java documentation describes the matter", "label": {"api": {"the Java documentation": [[32, 53]]}}}, {"text": "If you want to use data constructed on the fly, you could use a ByteArrayInputStream, e.g.", "label": {"api": {"ByteArrayInputStream": [[64, 83]]}}}, {"text": "Moreover, mkdir() doesn't necessarily create the directory", "label": {"api": {"mkdir()": [[10, 16]]}}}, {"text": "Consider using the java.util.prefs.Preferences API for this purpose", "label": {"api": {"java.util.prefs.Preferences": [[19, 45]]}}}, {"text": "Use InputStream.read() as I already stated in commentary", "label": {"api": {"InputStream.read()": [[4, 21]]}}}, {"text": "You should instead be using a version of String.split in order to produce your array3", "label": {"api": {"String.split": [[41, 52]]}}}, {"text": "If you want to pass primitive type to your method , then you have to write a method for each primitive type , there is no way to do it with just one method , and i think that if is there a way,then we would find it in some example in  the Java API ,but if we check for example Arrays , there is Arrays.copyOf method for each primitive", "label": {"api": {"Arrays": [[277, 282], [295, 300]], "Arrays.copyOf": [[295, 307]]}}}, {"text": "You can then call Future#get() to block the current thread and wait for either the task to complete or for an exception to be thrown (which completes (fails) the task)", "label": {"api": {"Future#get()": [[18, 29]]}}}, {"text": "The calculated preferred size for your components, including the JTextArea(10,80), will be correct for the platform's Look & Feel after you add the text area to the frame's BorderLayout.CENTER and pack() the enclosing Window", "label": {"api": {"pack()": [[197, 202]]}}}, {"text": "x.clone().equals(x) It will return false", "label": {"api": {"equals": [[10, 15]]}}}, {"text": "We need override equals & hashcode.Because of the following reason we need to do", "label": {"api": {"equals": [[17, 22]]}}}, {"text": "2) If equals & hashcode methods are not overridden, Super class Object#equals will be invoked", "label": {"api": {"equals": [[6, 11], [71, 76]]}}}, {"text": "X x1 = x x1.equals(x)  return true", "label": {"api": {"equals": [[12, 17]]}}}, {"text": "2) So even override equals & hashcode methods are not overridden, it will check the memory location and will return true", "label": {"api": {"equals": [[20, 25]]}}}, {"text": "Assuming you are using DefaultTableModel as table model, this should be enough", "label": {"api": {"DefaultTableModel": [[23, 39]], "TableModel": [[30, 39]]}}}, {"text": "If you are using a custom TableModel, the process is almost the same, there won't be great differences", "label": {"api": {"TableModel": [[26, 35]]}}}, {"text": "For e.g., Java 8 defines many ready-to-use functional interfaces in java.util.function package", "label": {"api": {"java.util.function": [[68, 85]]}}}, {"text": "Equivalent one for your use-case would be java.util.function.Function<T, R>", "label": {"api": {"java.util.function": [[42, 59]], "java.util.function.Function<T, R>": [[42, 74]]}}}, {"text": "For boolean return value, you can directly use Predicate though", "label": {"api": {"Predicate": [[47, 55]]}}}, {"text": "You will most likely get a java.lang.VerifyError", "label": {"api": {"java.lang.VerifyError": [[27, 47]]}}}, {"text": "They will get you an ArrayIndexOutOfBoundsException at runtime", "label": {"api": {"ArrayIndexOutOfBoundsException": [[21, 50]]}}}, {"text": "Indeed, as documented, the constructor of ObjectInputStream blocks until it has received the serialization stream header", "label": {"api": {"as documented": [[8, 20]]}}}, {"text": "Use Scanner.nextInt instead of manually parsing the String", "label": {"api": {"Scanner.nextInt": [[4, 18]]}}}, {"text": "It will cause an IllegalMonitorStateException", "label": {"api": {"IllegalMonitorStateException": [[17, 44]]}}}, {"text": "Also if by \"codes using wait method on threads\" you mean code where a Thread object is used as a lock, that's another thing to avoid doing, see the API documentation for Thread#join", "label": {"api": {"API documentation for Thread#join": [[148, 180]]}}}, {"text": "A solution is to first send the length of the file in the first 4 bytes using something like DataOutputStream/DataInputStream, and then have the client send exactly that many bytes and the server read exactly that many bytes before moving on", "label": {"api": {"DataOutputStream": [[93, 108]], "DataInputStream": [[110, 124]]}}}, {"text": "With String.format %d and its variants, we can easily format primitive integers and longs", "label": {"api": {"String.format": [[5, 17]]}}}, {"text": "You could also use a StringBuilder for temp as it is more efficient for building Strings in Java", "label": {"api": {"StringBuilder": [[21, 33]]}}}, {"text": "try SimpleDateFormat first", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "Calendar.DAY_OF_MONTH is a constant value, which points at the day of the month field", "label": {"api": {"Calendar.DAY_OF_MONTH": [[0, 20]], "constant value": [[27, 40]]}}}, {"text": "HashSet internally uses Hashmap", "label": {"api": {"HashSet": [[0, 6]]}}}, {"text": "If you want insertion order you will use LinkedHashMap", "label": {"api": {"LinkedHashMap": [[41, 53]]}}}, {"text": "PKCS11 not found is thrown in the follow invocation KeyStore ks = KeyStore.getInstance(\"PKCS11\"); because your smartcard is not plugged or if it's plugged maybe there is some problem with the provider (both problems thrown the same exception), so try to pass the provider explicitly to the instance using getInstance(String,Provider)", "label": {"api": {"getInstance(String,Provider)": [[305, 332]]}}}, {"text": "What's wrong with contains", "label": {"api": {"contains": [[18, 25]]}}}, {"text": "However, I suggest that you use the Condition libraries from Lock#newCondition()", "label": {"api": {"Condition": [[36, 44], [69, 77]], "Lock#newCondition()": [[61, 79]]}}}, {"text": "replace() wasn't added until java 8, but you can use put instead to do the same thing", "label": {"api": {"replace()": [[0, 8]]}}}, {"text": "From official documentation", "label": {"api": {"From official documentation": [[0, 26]]}}}, {"text": "If you just want to replace a certain string with another one, use replace() instead of replaceAll()", "label": {"api": {"replace()": [[67, 75]]}}}, {"text": "This will come handy as, since for a correct implementation, your background thread has to schedule the UI manipulation via EventQueue.invokeLater or SwingUtilities.invokeLater, you will need a Runnable anyway", "label": {"api": {"EventQueue.invokeLater": [[124, 145]], "SwingUtilities.invokeLater": [[150, 175]]}}}, {"text": "Alternatively you can implement the entire background activity using a SwingWorker", "label": {"api": {"SwingWorker": [[71, 81]]}}}, {"text": "If you happen to use Java 7 or prior, use Integer#compare", "label": {"api": {"Integer#compare": [[42, 56]]}}}, {"text": "Otherwise, compare the int variables manually (code adapted from Integer#compare source, there's no need to reinvent the wheel)", "label": {"api": {"Integer#compare": [[65, 79]]}}}, {"text": "You could use java.nio.file.Path if you're using Java 7+", "label": {"api": {"java.nio.file.Path": [[14, 31]]}}}, {"text": "Javadocs for the Lock interface reinterates what I posted", "label": {"api": {"Lock": [[17, 20]]}}}, {"text": "Another solution is to use a WeakHashMap", "label": {"api": {"WeakHashMap": [[29, 39]]}}}, {"text": "To clarify why the 'when' is an issue with WeakHashMap, is that WeakHashMap can cleanup dangling entries whenever it wants", "label": {"api": {"WeakHashMap": [[43, 53], [64, 74]]}}}, {"text": "Well that's why WeakHashMap exists", "label": {"api": {"WeakHashMap": [[16, 26]]}}}, {"text": "Just use WeakHashMap, and it will clean itself up", "label": {"api": {"WeakHashMap": [[9, 19]]}}}, {"text": "In WeakHashMap it's the keys that are weakly held onto which is fine but the value is a hard reference", "label": {"api": {"WeakHashMap": [[3, 13]]}}}, {"text": "In order to minimize the number of conversions you have to make, you could read in the price directly as a double instead of as a string using Scanner's nextDouble() method instead of nextLine()", "label": {"api": {"nextDouble()": [[153, 164]]}}}, {"text": "I've checked the API doc and it just supports operations in a heap", "label": {"api": {"API doc": [[17, 23]]}}}, {"text": "LockSupport can disable the scheduling of a thread for a specified number of nanoseconds", "label": {"api": {"LockSupport": [[0, 10]]}}}, {"text": "If you can ensure that the number will always be only one character and that it will come first, substring (see http://docs.oracle.com/javase/7/docs/api/java/lang/String.html) will get you what you want", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[112, 173]]}}}, {"text": "The reason it's there is because of how indexOf works", "label": {"api": {"how indexOf works": [[36, 52]]}}}, {"text": "From setSoTimeout(int timeout)", "label": {"api": {"setSoTimeout(int timeout)": [[5, 29]]}}}, {"text": "I'd suggest altering the signature of the JAX-RS-annotated method to return a javax.ws.rs.core.Response object", "label": {"api": {"javax.ws.rs.core.Response": [[78, 102]]}}}, {"text": "What you'd probably want to use here is the double datatype, but I'd also suggest looking into BigDecimals for further reference", "label": {"api": {"BigDecimals": [[95, 105]]}}}, {"text": "Just invoke Class#newInstance() method", "label": {"api": {"Class#newInstance()": [[12, 30]]}}}, {"text": "According to the documentation, the constructor for Media can only take a string, not a Stream", "label": {"api": {"According to the documentation": [[0, 29]]}}}, {"text": "documentation for a JAR URL is at http://docs.oracle.com/javase/6/docs/api/java/net/JarURLConnection.html", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/net/JarURLConnection.html": [[34, 104]]}}}, {"text": "Here's the documentation for Window.pack", "label": {"api": {"Window.pack": [[29, 39]]}}}, {"text": "pack changes the size of your JFrame to the smallest possible size that will still hold all the elements you've put in it", "label": {"api": {"pack": [[0, 3]], "JFrame": [[30, 35]]}}}, {"text": "The only portable way to get a synthesizer is MidiSystem.getSynthesizer(), which gives you nothing but the default synthesizer, which outputs to some default audio device", "label": {"api": {"MidiSystem.getSynthesizer()": [[46, 72]]}}}, {"text": "The synthesizer has a fixed latency, which you can obtain with Synthesizer.getLatency()", "label": {"api": {"Synthesizer.getLatency()": [[63, 86]]}}}, {"text": "The usual way to provide a customized ordering for a type in Java is by implementing the Comparator interface", "label": {"api": {"Comparator": [[89, 98]]}}}, {"text": "To provide several orderings for a class Foo, for example, you'd write several classes that all implement Comparator<Foo> and define the compare(Foo, Foo) method differently in each one", "label": {"api": {"Comparator": [[106, 115]]}}}, {"text": "Your algorithm can take an argument of type Comparator<Foo>, and the caller can pass an instance of one of those implementations", "label": {"api": {"Comparator": [[44, 53]]}}}, {"text": "You can also implement Comparator in an enum and implement compare separately for each enumeration value", "label": {"api": {"Comparator": [[23, 32]]}}}, {"text": "The SwingWorker API outlines a suitable approach", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "You can just use a ComponentListener for the panel(s)", "label": {"api": {"ComponentListener": [[19, 35]]}}}, {"text": "This won't be (considerably) faster, but using a HashSet will definitely be more elegant", "label": {"api": {"HashSet": [[49, 55]]}}}, {"text": "A LinkedList is a possible implementation of Queue that would work", "label": {"api": {"LinkedList": [[2, 11]]}}}, {"text": "Use table.convertRowIndexToModel(row) to get the actual row number", "label": {"api": {"table.convertRowIndexToModel(row)": [[4, 36]]}}}, {"text": "However, Java-8-time can parse such times but never set", "label": {"api": {"parse such times": [[25, 40]]}}}, {"text": "Instead, I would reccomend using a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[35, 48]]}}}, {"text": "getClass() returns an instance of java.lang.Class which represents the type of the object it was called on", "label": {"api": {"java.lang.Class": [[34, 48]]}}}, {"text": "Class.forName(String) is a static method in java.lang.Class which returns an instance of java.lang.Class which fully qualified name was passed as a parameter", "label": {"api": {"java.lang.Class": [[44, 58], [89, 103]]}}}, {"text": "Use System.nanoTime instead", "label": {"api": {"System.nanoTime": [[4, 18]]}}}, {"text": "A JCheckBox isn't the appropriate type of component to use for what you are trying to achieve", "label": {"api": {"JCheckBox": [[2, 10]]}}}, {"text": "A JComboBox seems more appropriate", "label": {"api": {"JComboBox": [[2, 10]]}}}, {"text": "You could store all of the possible toppings (or if you want make the combo box editable so the user can enter what they want) in the model and have a JButton that adds the topping to the total cost", "label": {"api": {"JButton": [[151, 157]]}}}, {"text": "However, regarding your original question, there is Thread.join()", "label": {"api": {"Thread.join()": [[52, 64]]}}}, {"text": "As the Documentation on new Scanner(java.io.InputStream) states", "label": {"api": {"new Scanner(java.io.InputStream)": [[24, 55]]}}}, {"text": "Try calling Toolkit#sync (Toolkit.getDefaultToolkit().sync()) , which sometimes removes the issue", "label": {"api": {"Toolkit#sync": [[12, 23]]}}}, {"text": "The documentation for getOutputStream says", "label": {"api": {"getOutputStream": [[22, 36]]}}}, {"text": "Every JComponent (including the subclass JButton) has a getX and getY already", "label": {"api": {"getX and getY already": [[56, 76]]}}}, {"text": "You could look at Java.NIO which can provide much quicker block moves in the case of files or sockets", "label": {"api": {"Java.NIO": [[18, 25]]}}}, {"text": "In Java, you can use the BigDecimal class for decimal calculations", "label": {"api": {"BigDecimal": [[25, 34]]}}}, {"text": "To check if a file exists at the given path or not you can simply use the File.exists method", "label": {"api": {"File.exists": [[74, 84]]}}}, {"text": "Please also see the File.isFile method and/or the File.isDirectory method to verify the nature of the targeted File object", "label": {"api": {"File.isFile": [[20, 30]], "File.isDirectory": [[50, 65]]}}}, {"text": "Although IntStream.of(int...) seems to work it is more likely that you are expected to use Arrays.stream(int[])", "label": {"api": {"IntStream.of(int...)": [[9, 28]], "Arrays.stream(int[])": [[91, 110]]}}}, {"text": "Mark using Deprecated annotation", "label": {"api": {"Deprecated": [[11, 20]]}}}, {"text": "FacesServlet doesn't extend from HttpServlet class containing a.o", "label": {"api": {"FacesServlet": [[0, 11]], "HttpServlet": [[33, 43]], "Servlet": [[5, 11], [37, 43]]}}}, {"text": "It just implements Servlet interface which offers the base service() method", "label": {"api": {"Servlet": [[19, 25]], "service()": [[59, 67]]}}}, {"text": "Portlets doesn't use HttpServlet, but PortletServlet which shares the common Servlet interface", "label": {"api": {"HttpServlet": [[21, 31]], "Servlet": [[25, 31], [45, 51], [77, 83]]}}}, {"text": "String.replace() compiles a literal regex", "label": {"api": {"String.replace()": [[0, 15]]}}}, {"text": "You ought to use String.replaceAll() or String.replaceFirst()", "label": {"api": {"String.replaceAll()": [[17, 35]], "String.replaceFirst()": [[40, 60]]}}}, {"text": "You cannot add anything to this fixed-length list", "label": {"api": {"fixed-length list": [[32, 48]]}}}, {"text": "Could you guys help me figuring out QuadCurveTo's 4 parameters , I tried to find some information on QuadCurveTo, but it's hard to understand without a picture", "label": {"api": {"QuadCurveTo": [[36, 46], [101, 111]]}}}, {"text": "You can find those coordinates on this new QuadCurveTo(150.0f, 60.0f, 100.0f, 20.0f) line, and below is the sample picture of Quadratic Bezier", "label": {"api": {"QuadCurveTo": [[43, 53]]}}}, {"text": "While you can use an internal loop to copy the individual bytes (as suggested in the other answer), I think it would be more efficient to use System.arraycopy", "label": {"api": {"System.arraycopy": [[142, 157]]}}}, {"text": "The Date class isn't deprecated - just many of its constructors/methods are", "label": {"api": {"Date": [[4, 7]]}}}, {"text": "Personally I'd still use either SimpleDateFormat or better yet java.time or Joda Time, but if you really really don't want to do that, this might be good enough", "label": {"api": {"Date": [[38, 41]]}}}, {"text": "According to the javadocs Collections.sort is guaranteed to be stable - the relative ordering of items that compare as equal does not change as a result of the sorting", "label": {"api": {"According to the javadocs": [[0, 24]]}}}, {"text": "On a side note, you comparator is the same as String.CASE_INSENSITIVE_ORDER", "label": {"api": {"String.CASE_INSENSITIVE_ORDER": [[46, 74]]}}}, {"text": "Map.get returns the generic type V, even when you define V to be @NonNull, which then violates the API since null must be an allowable return value", "label": {"api": {"Map.get": [[0, 6]]}}}, {"text": "Until then, the only workarounds are to check with Map.containsKey before getting a value instead of checking the value afterwards for null, or just avoid using @NonNull on map value types", "label": {"api": {"Map.containsKey": [[51, 65]]}}}, {"text": "You can examine the property name of the PropertyChangeEvent to tell changes of progress and state apart", "label": {"api": {"property name": [[20, 32]]}}}, {"text": "What you can do is to call System.gc() to tell the garbage collector that you want it to perform a collection", "label": {"api": {"System.gc()": [[27, 37]]}}}, {"text": "I don't know if that's better (personally I don't like to involve floating point operations), but you could send it through Math#signum", "label": {"api": {"Math#signum": [[124, 134]]}}}, {"text": "Either read both the output and the error streams, in separate threads, or use the ProcessBuilder to create the Process, and merge the output streams before you do so, with redirectErrorStream()", "label": {"api": {"redirectErrorStream()": [[173, 193]]}}}, {"text": "How about using JOptionPane.showInternalXXXDialog(...)", "label": {"api": {"JOptionPane.showInternalXXXDialog(...)": [[16, 53]]}}}, {"text": "If you combine the atomic variable with a waiting queue, you end up what Lock (or any other AQS based concurrency tool) provides", "label": {"api": {"AQS": [[92, 94]]}}}, {"text": "Create a filter which stores the mapping of username as key and corresponding session id in some map (You can also use database for this); In case you use map, make sure you use ConcurrentHashMap", "label": {"api": {"ConcurrentHashMap": [[178, 194]]}}}, {"text": "You can limit the number of pending tasks, by creating a custom ThreadPoolExecutor using this constructor as follows", "label": {"api": {"this constructor": [[89, 104]]}}}, {"text": "The documentation of Serializable gives part of the answer", "label": {"api": {"Serializable": [[21, 32]]}}}, {"text": "Since java 7 it is not needed to read byte by byte, there are two utility function in Files", "label": {"api": {"Files": [[86, 90]]}}}, {"text": "The documentation of Key gives some more details", "label": {"api": {"documentation of Key": [[4, 23]]}}}, {"text": "If you need a Map and you do not need a SortedMap, HashMap is almost always the right choice", "label": {"api": {"HashMap": [[51, 57]]}}}, {"text": "Note that one of the constructors of HashMap has an argument telling it the initial size of the map", "label": {"api": {"HashMap": [[37, 43]], "one of the constructors": [[10, 32]]}}}, {"text": "The constructor will use that to allocate a reasonable amount of memory for the map, which is helpful if the size of your map is likely to be smaller than the default size (which is 16)", "label": {"api": {"which is 16": [[173, 183]]}}}, {"text": "If you are using EJB 3.1 and Java EE 6 or greater, the notation @Asynchronous on a method makes it run in a separate thread and takes care of managing resources, etc", "label": {"api": {"@Asynchronous": [[64, 76]]}}}, {"text": "If you want something more exact, you should use the BigDecimal class, which is an arbitrary precision decimal number", "label": {"api": {"BigDecimal": [[53, 62]]}}}, {"text": "You can set the number of places a BigDecimal stores by setting its scale using one of its setScale functions, which can also be used to set which rounding mode it uses when you do math operations on it", "label": {"api": {"BigDecimal": [[35, 44]], "setScale": [[91, 98]]}}}, {"text": "Be aware that BigDecimal is an object type, so you need to use its methods to do math operations with it (.add, .subtract, .multiply, .divide)", "label": {"api": {"BigDecimal": [[14, 23]]}}}, {"text": "BigDecimal has constructors for creating a BigDecimal from a double, long, or int", "label": {"api": {"BigDecimal": [[0, 9], [43, 52]]}}}, {"text": "According to API the ceiling  should return number greater then or equal to the given element or null, in the code below why ceiling of -12 is -12", "label": {"api": {"API": [[13, 15]]}}}, {"text": "If you are using Java 8, you should consider the LongAdder class in java.util.concurrent.atomic", "label": {"api": {"LongAdder": [[49, 57]]}}}, {"text": "For example DefaultTableModel has many methods useful for your task", "label": {"api": {"DefaultTableModel": [[12, 28]]}}}, {"text": "DefaultTableModel is also good an may be sufficient", "label": {"api": {"DefaultTableModel": [[0, 16]]}}}, {"text": "Use Arrays.equals(byte[] b1, byte[] b2) instead of equals", "label": {"api": {"Arrays.equals(byte[] b1, byte[] b2)": [[4, 38]]}}}, {"text": "Also see the Graphics API for other drawXxx and fillXxx methods", "label": {"api": {"Graphics API": [[13, 24]]}}}, {"text": "Use a Timer in mouseEntered()", "label": {"api": {"Timer": [[6, 10]]}}}, {"text": "Use JFrame#setShape to alter the shape of the main window, for example..", "label": {"api": {"JFrame#setShape": [[4, 18]]}}}, {"text": "I suggest you look at Java's NIO package, specifically the classes and methods used in the below examples", "label": {"api": {"NIO package": [[29, 39]]}}}, {"text": "Another solution is to use Java Sockets to communicate back and forth between processes", "label": {"api": {"Sockets": [[32, 38]]}}}, {"text": "Consider using the BreakIterator", "label": {"api": {"BreakIterator": [[19, 31]]}}}, {"text": "Also consider the ICU4J version of BreakIterator if required", "label": {"api": {"BreakIterator": [[35, 47]]}}}, {"text": "After many search I go with HashSet", "label": {"api": {"HashSet": [[28, 34]]}}}, {"text": "Also, String#concat(String) doesn't change the state of String, as specified in the documentation, it creates a new String, making sure that String is immutable, and keeping A immutable as well", "label": {"api": {"String#concat(String)": [[6, 26]]}}}, {"text": "You can use the copy Method of the Collection class if you just want a new collection of the same values as in the original one", "label": {"api": {"copy Method": [[16, 26]]}}}, {"text": "At this stage I only have the Application class, Subject class (HashMap of student and Integer mark), and Student", "label": {"api": {"HashMap": [[64, 70]]}}}, {"text": "A good and simple solution could be the scanner", "label": {"api": {"scanner": [[40, 46]]}}}, {"text": "You can use valueOf() to try to get your String value as an Enum member", "label": {"api": {"valueOf()": [[12, 20]]}}}, {"text": "You can create the keyRegex manually or by StringBuilder from the enum names", "label": {"api": {"StringBuilder": [[43, 55]]}}}, {"text": "If you have to insert an element at the front, a Queue is definitely not the solution", "label": {"api": {"Queue": [[49, 53]]}}}, {"text": "Go for a double ended queue", "label": {"api": {"double ended queue": [[9, 26]]}}}, {"text": "From the documentation read(byte[] b)", "label": {"api": {"read(byte[] b)": [[23, 36]]}}}, {"text": "Maybe you should add a connection timeout by yourself by invoking DriverManager#setLoginTimeout(...) before to try to connect", "label": {"api": {"DriverManager#setLoginTimeout(...)": [[66, 99]]}}}, {"text": "In the same spirit, notice there is Statement#setQueryTimeout(...) that can be called on any kind of SQL statement (be them PreparedStatement or CallableStatement)", "label": {"api": {"Statement#setQueryTimeout(...)": [[36, 65]]}}}, {"text": "As stated in this answer, JComponent#getInputMap() is a convenience method for JComponent#getInputMap(WHEN_FOCUSED)", "label": {"api": {"JComponent#getInputMap()": [[26, 49]], "JComponent#getInputMap(WHEN_FOCUSED)": [[79, 114]]}}}, {"text": "Something like a LineNumberReader or a BufferedReader should help you manage this", "label": {"api": {"LineNumberReader": [[17, 32]], "BufferedReader": [[39, 52]]}}}, {"text": "You must use a ProcessBuilder in order to acomplish that", "label": {"api": {"ProcessBuilder": [[15, 28]]}}}, {"text": "Assuming you actually mean a Unix 'shell script', and not specifically a Microsoft 'batch file', you'd be better off using the ProcessBuilder class, as it provides greater flexibility than Runtime's exec() method", "label": {"api": {"ProcessBuilder": [[127, 140]]}}}, {"text": "To use ProcessBuilder to run a script in its own directory, set the builder's directory to the same directory that you're using to point to the script, like so", "label": {"api": {"ProcessBuilder": [[7, 20]]}}}, {"text": "It is a property of the “Modified UTF-8” encoding to store surrogate pairs (or even unpaired chars of that range) like individual characters", "label": {"api": {"“Modified UTF-8”": [[24, 39]]}}}, {"text": "And it’s an error if a decoder claiming to use standard UTF-8 uses “Modified UTF-8”", "label": {"api": {"“Modified UTF-8”": [[67, 82]]}}}, {"text": "You can reliably read such data using a method that is specified to use “Modified UTF-8”", "label": {"api": {"“Modified UTF-8”": [[72, 87]]}}}, {"text": "If you want to go down the Java-only road my suggestion is to combine an existing proxy servlet with an off-the-shelf servlet Filter that handles the authentication", "label": {"api": {"servlet Filter": [[118, 131]]}}}, {"text": "Why don't you use an ExecutorService", "label": {"api": {"ExecutorService": [[21, 35]]}}}, {"text": "The call to matcher.group(1) gives you the text matching the capturing group (.*?)", "label": {"api": {"capturing group": [[61, 75]]}}}, {"text": "Instead, use javax.swing.Timer (not to be confused with java.util.Timer)", "label": {"api": {"javax.swing.Timer": [[13, 29]]}}}, {"text": "Use SwingWorker for all operations taking any non-negligible time", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "You can also run another class in the separate process, using ProcessBuilder API", "label": {"api": {"ProcessBuilder API": [[62, 79]]}}}, {"text": "TreeMap is one of the classes that implement the Map interface", "label": {"api": {"TreeMap": [[0, 6]], "Map": [[4, 6], [49, 51]]}}}, {"text": "Therefore you can assign an instance of TreeMap to a variable whose type is Map", "label": {"api": {"TreeMap": [[40, 46]], "Map": [[44, 46], [76, 78]]}}}, {"text": "charCounter.get(x) + 1) searches the char x in the Map", "label": {"api": {"Map": [[51, 53]]}}}, {"text": "If it's found it gets its current value from the Map and increases it by one", "label": {"api": {"Map": [[49, 51]]}}}, {"text": "This means this Map counts how many times each character appears in the input String", "label": {"api": {"Map": [[16, 18]]}}}, {"text": "If you are looking to randomize anything in Java, a good place to start is the Random class", "label": {"api": {"Random": [[79, 84]]}}}, {"text": "A lexicographical descending order is the order you'll get if you treat the numbers of the input list as Strings and sort them in descending order", "label": {"api": {"String": [[105, 110]]}}}, {"text": "Converts the int array to String array", "label": {"api": {"String": [[26, 31]]}}}, {"text": "Uses Arrays.sort() to sort the array into ascending order, according to the Comparable natural ordering (which for String, compares two strings lexicographically)", "label": {"api": {"Arrays.sort()": [[5, 17]], "Comparable": [[76, 85]], "String": [[115, 120]]}}}, {"text": "depending on your platform since it is the char separating the directory from the file", "label": {"api": {"the directory from the file": [[59, 85]]}}}, {"text": "However TreeSet is backed by TreeMap and that uses TreeEntry for entries, and one entry will take total 32B of memory, plus having 2 trees will result into 64B of memory per element", "label": {"api": {"TreeSet": [[8, 14]], "TreeMap": [[29, 35]]}}}, {"text": "You need to call the paintAll method after setting the new isStringToBePainted's value", "label": {"api": {"paintAll": [[21, 28]]}}}, {"text": "While Arrays.copyOfRange can be used to slice an Array (and can be applied to the end as well), it cannot be used for a \"backward\" or \"stepped\" slice", "label": {"api": {"Arrays.copyOfRange": [[6, 23]]}}}, {"text": "When you copy an array using System.arraycopy, a shallow copy is performed", "label": {"api": {"System.arraycopy": [[29, 44]]}}}, {"text": "You're printing out the DateFormat object -- don't do that", "label": {"api": {"DateFormat": [[24, 33]]}}}, {"text": "You need to use that DateFormat object to parse a String to a Date or format the date to a String and then print the String returned", "label": {"api": {"DateFormat": [[21, 30]]}}}, {"text": "Please look at the API for DateFormat and SimpleDateFormat to learn about the parse and format methods", "label": {"api": {"DateFormat": [[27, 36], [48, 57]], "SimpleDateFormat": [[42, 57]]}}}, {"text": "You would need two SimpleDateFormat objects", "label": {"api": {"DateFormat": [[25, 34]], "SimpleDateFormat": [[19, 34]]}}}, {"text": "And the other SimpleDateFormat would be used to format the Date into a String of the second type", "label": {"api": {"DateFormat": [[20, 29]], "SimpleDateFormat": [[14, 29]]}}}, {"text": "You should never try to print the DateFormat object itself as that makes no sense", "label": {"api": {"DateFormat": [[34, 43]]}}}, {"text": "Keep in mind that the MXBean attributes should not return values of types not defined in javax.management.openmbean.OpenType.ALLOWED_CLASSNAMES_LIST, otherwise you will get a NonCompliant exception", "label": {"api": {"javax.management.openmbean.OpenType.ALLOWED_CLASSNAMES_LIST": [[89, 147]]}}}, {"text": "scheduleAtFixedRate and scheduleWithFixedDelay", "label": {"api": {"scheduleAtFixedRate": [[0, 18]], "scheduleWithFixedDelay": [[24, 45]]}}}, {"text": "Array.equals() is the most efficient method afaik", "label": {"api": {"Array.equals()": [[0, 13]]}}}, {"text": "List.contains(Object) is broken with lists of arrays, so why don't you use lists of lists", "label": {"api": {"List.contains(Object)": [[0, 20]]}}}, {"text": "You can use substring() and indexOf() methods to extract the specific part of the request you are looking for, and replace() to replace them", "label": {"api": {"substring()": [[12, 22]], "indexOf()": [[28, 36]], "replace()": [[115, 123]]}}}, {"text": "See the documentation here", "label": {"api": {"See the documentation here": [[0, 25]]}}}, {"text": "See the JAXB documentation for more details", "label": {"api": {"JAXB documentation": [[8, 25]]}}}, {"text": "One option is to do your work using a SwingWorker", "label": {"api": {"SwingWorker": [[38, 48]]}}}, {"text": "Can somebody explain the rationale behind the naming of Instant.getEpochSecond vs", "label": {"api": {"Instant.getEpochSecond": [[56, 77]]}}}, {"text": "I would suggest using a Stack instead of a list", "label": {"api": {"Stack": [[24, 28]]}}}, {"text": "Here's another example with a Stack", "label": {"api": {"Stack": [[30, 34]]}}}, {"text": "Current Oracle Java has built in support for access to PC/SC smartcard readers using the Java SmartcardIO API", "label": {"api": {"Java SmartcardIO API": [[89, 108]]}}}, {"text": "If you're looking at comparing dates, isBefore / isAfter in java.util.Date class is useful", "label": {"api": {"java.util.Date": [[60, 73]]}}}, {"text": "java.util.Calendar is what I usually use for date manipulation / comparison in my own code", "label": {"api": {"java.util.Calendar": [[0, 17]]}}}, {"text": "The Java APIs state that java.util.Date is deprecated in favour of it", "label": {"api": {"java.util.Date": [[25, 38]]}}}, {"text": "You can pass in a java.util.Date using setTime", "label": {"api": {"java.util.Date": [[18, 31]]}}}, {"text": "java.util.Calendar also has locales and timezones", "label": {"api": {"java.util.Calendar": [[0, 17]]}}}, {"text": "I just realized, however, that at least for spliterators, you can get an acceptable default implementation by calling Arrays.spliterator(array)", "label": {"api": {"Arrays.spliterator(array)": [[118, 142]]}}}, {"text": "If the set of fields names may differ between objects, a HashMap<String, String> would do for string keys and string values", "label": {"api": {"HashMap<String, String>": [[57, 79]]}}}, {"text": "To make an array whose length may change, use an ArrayList<Foo> where Foo is the class of objects you want the list to contain", "label": {"api": {"ArrayList<Foo>": [[49, 62]]}}}, {"text": "More about nesting panels in the BoxLayout documentation (http://docs.oracle.com/javase/7/docs/api/javax/swing/BoxLayout.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/BoxLayout.html": [[58, 124]]}}}, {"text": "The documentation for DirectoryStream says", "label": {"api": {"documentation for DirectoryStream": [[4, 36]]}}}, {"text": "You can use ScheduledExecutorService introduced in Java 5, which suits your purpose and uses ThreadPool as well", "label": {"api": {"ScheduledExecutorService": [[12, 35]]}}}, {"text": "Also, ScheduledExecutorService is preferred over Timer [StackOverFlow Discussion On Timer Vs ScheduledExecutorService]", "label": {"api": {"ScheduledExecutorService": [[6, 29], [93, 116]]}}}, {"text": "You can use TreeMap or ConcurrentSkipListMap", "label": {"api": {"TreeMap": [[12, 18]], "ConcurrentSkipListMap": [[23, 43]]}}}, {"text": "That is a concrete implementation where the only restriction thrown upon the key is to implement the Comparable interface", "label": {"api": {"Comparable": [[101, 110]]}}}, {"text": "A wildcard is used in order to indicate that any implementation of Comparable<T> is supported", "label": {"api": {"Comparable": [[67, 76]]}}}, {"text": "Notice that Comparable<T> interface is generic itself", "label": {"api": {"Comparable": [[12, 21]]}}}, {"text": "Override the isOptimizedDrawingEnabled method of the parent panel and have it return false", "label": {"api": {"isOptimizedDrawingEnabled": [[13, 37]]}}}, {"text": "Scanner swallows errors", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "Check for them using the ioException method", "label": {"api": {"ioException": [[25, 35]]}}}, {"text": "As the oracle docs describe, there are options named http.nonProxyHosts and ftp.nonProxyHosts to set proxy exclusions for HTTP and FTP, but there is no specific setting for SOCKS proxies", "label": {"api": {"oracle docs": [[7, 17]]}}}, {"text": "the Collections.shuffle method", "label": {"api": {"Collections.shuffle": [[4, 22]]}}}, {"text": "Best is to use a TreeSet", "label": {"api": {"TreeSet": [[17, 23]]}}}, {"text": "Then use the java.awt.Desktop.mail(URI) method to launch email client", "label": {"api": {"java.awt.Desktop.mail(URI)": [[13, 38]]}}}, {"text": "Then open that file with java.awt.Desktop.open to launch the email client", "label": {"api": {"java.awt.Desktop.open": [[25, 45]]}}}, {"text": "This can be noticed by the implementation of String(String) constructor", "label": {"api": {"String(String)": [[45, 58]]}}}, {"text": "See for example usages of HeadlessException for a list of methods and classes that has this limitation", "label": {"api": {"usages of HeadlessException": [[16, 42]]}}}, {"text": "Have a look at ExecutorService as well", "label": {"api": {"ExecutorService": [[15, 29]]}}}, {"text": "Class of the current instance indicates the instance of java.lang.Class whose type is T", "label": {"api": {"java.lang.Class": [[56, 70]]}}}, {"text": "Even if the class in consideration has static method, It is always an instance of java.lang.Class", "label": {"api": {"java.lang.Class": [[82, 96]]}}}, {"text": "You can get related explanation in Java Documentation for java.lang.Class", "label": {"api": {"java.lang.Class": [[58, 72]]}}}, {"text": "You never call your test method from your implementation of actionPerformed()", "label": {"api": {"actionPerformed()": [[60, 76]]}}}, {"text": "It is actually using an algorithm specified in the Java List API that combines the element hashcodes in a predictable way; see this javadoc", "label": {"api": {"this javadoc": [[127, 138]]}}}, {"text": "You need to use the constructor Color(int, boolean) to supply the alpha value for your color", "label": {"api": {"Color(int, boolean)": [[32, 50]]}}}, {"text": "The constructor you are using changes the alpha value to 255", "label": {"api": {"constructor you are using": [[4, 28]]}}}, {"text": "Now since Java's inner (non-static) classes are loaded by class loaders just like every other class, why can't we have static initializers for them", "label": {"api": {"class loaders": [[58, 70]]}}}, {"text": "In your example, you are actually interrupting the sleep as JDK doc mentions", "label": {"api": {"JDK doc": [[60, 66]]}}}, {"text": "In Java-8 (new time library JSR-310 in package java.time) an acceptable solution using specialized methods in TemporalAdjusters is possible, but since you operate on Android, this is not the way to go", "label": {"api": {"TemporalAdjusters": [[110, 126]]}}}, {"text": "ArrayList implements the Collection interface and therefore supports the Collection.addAll() method", "label": {"api": {"ArrayList": [[0, 8]], "Collection interface": [[25, 44]], "Collection.addAll() method": [[73, 98]]}}}, {"text": "Incidentally, ArrayList also has a generic copy constructor that probably just calls addAll() on its own", "label": {"api": {"ArrayList": [[14, 22]], "generic copy constructor": [[35, 58]]}}}, {"text": "Whether you're trying to compare or subtract isn't clear, but Java's BigInteger class has both operations", "label": {"api": {"BigInteger": [[69, 78]]}}}, {"text": "If you need to subtract the numbers I'd definitely use BigInteger, but if all you need to do is compare them you could write your own method", "label": {"api": {"BigInteger": [[55, 64]]}}}, {"text": "The String charAt and toCharArray methods give you two different ways to implement this approach", "label": {"api": {"charAt": [[11, 16]], "toCharArray": [[22, 32]]}}}, {"text": "The differences between the types of drag gesture are detailed in the Javadocs for MouseEvent, but basically this allows mouse events to be delivered to nodes other than the node that originated the drag while the drag is in process", "label": {"api": {"Javadocs for MouseEvent": [[70, 92]]}}}, {"text": "color.getRGB() does not return a value from 0..255, it returns an integer composited of your red, green and blue values, including the Alpha value", "label": {"api": {"color.getRGB()": [[0, 13]]}}}, {"text": "You should use a Collator, which orders strings using locale-sensitive rules", "label": {"api": {"Collator": [[17, 24]]}}}, {"text": "For collections of simple types, the annotation to use is @ElementCollection", "label": {"api": {"@ElementCollection": [[58, 75]]}}}, {"text": "Each Swing JComponent has ComponentUI that is responsible for displaying a component", "label": {"api": {"ComponentUI": [[26, 36]], "UI": [[35, 36]]}}}, {"text": "While JComponent has a paint method, only user derived classes use it directly - \"standard\" implementations very often just call the paint method of the attached UI instead", "label": {"api": {"UI": [[162, 163]]}}}, {"text": "This allows to plug-in various look and feel implementations very easily - a different look and feel just provides different ComponentUI's", "label": {"api": {"ComponentUI": [[125, 135]], "UI": [[134, 135]]}}}, {"text": "Very clearly component is the \"model\" and the UI is the \"view\"", "label": {"api": {"UI": [[46, 47]]}}}, {"text": "For instance, its TextView seems just painting drawables when a similar JLabel has UI", "label": {"api": {"UI": [[83, 84]]}}}, {"text": "There is no tree at all, and TableLayout is a that is called GridLayout in Swing, not similar to JTable", "label": {"api": {"GridLayout": [[61, 70]]}}}, {"text": "Containers and layout manages are also quite similar between Swing and Android, the main differences being that Swing has much more possible implementations of its LayoutManager to choose from than Androids ViewGroup (classes like DatePicker, while derived from ViewGroup, are not general purpose layout managers)", "label": {"api": {"LayoutManager": [[164, 176]]}}}, {"text": "In general, Swing seems more optimized for the large, complex GUI that shows up on a large screen when Android is better suited for small screens with just a few visible components, large enough to be operated with fingers without stylus", "label": {"api": {"UI": [[63, 64]]}}}, {"text": "You can use an InputStreamReader (http://docs.oracle.com/javase/7/docs/api/java/io/InputStreamReader.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/InputStreamReader.html": [[34, 104]]}}}, {"text": "The problem is that java.nio.file.Path has no method named newOutputStream()", "label": {"api": {"java.nio.file.Path": [[20, 37]]}}}, {"text": "Just use ExecutorService and create poll of n threads using Executors.newFixedThreadPool(int) factory method", "label": {"api": {"ExecutorService": [[9, 23]], "Executors.newFixedThreadPool(int)": [[60, 92]]}}}, {"text": "In order to shuffle a Collection simply use Collections.shuffle like so", "label": {"api": {"Collections.shuffle": [[44, 62]]}}}, {"text": "Consider using java.lang.instrument and ASM to achieve your goal", "label": {"api": {"java.lang.instrument": [[15, 34]]}}}, {"text": "As of JDK version 1.1, replaced by Calendar.get(Calendar.MINUTE)", "label": {"api": {"Calendar": [[35, 42], [48, 55]]}}}, {"text": "For Java 7 or below, use a SimpleDateFormat for parsing and formatting", "label": {"api": {"SimpleDateFormat": [[27, 42]]}}}, {"text": "Since Java 8, you can use DateTimeFormatter", "label": {"api": {"DateTimeFormatter": [[26, 42]]}}}, {"text": "You are concurrently modifying a list you are iterating over, in a way that fails to trigger a ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[95, 125]]}}}, {"text": "You can do a very simple shuffling of elements using the Collections#shuffle(list) method", "label": {"api": {"Collections#shuffle(list)": [[57, 81]]}}}, {"text": "But if you want to specify your own source for the randomness, you can do so by using this overloaded Collections#shuffle(list, random) method", "label": {"api": {"Collections#shuffle(list, random)": [[102, 134]]}}}, {"text": "You could achieve that by adding each filename you add to an efficient data structure such as a HashSet and check if the name is already there", "label": {"api": {"add": [[26, 28], [51, 53]]}}}, {"text": "The add method, which returns true if the element was not already in the Set, and false otherwise", "label": {"api": {"add": [[4, 6]]}}}, {"text": "4) The Formatter.format method is not used properly", "label": {"api": {"Formatter.format": [[7, 22]]}}}, {"text": "You could also use the classes in the java.util.jar package to work with jar files", "label": {"api": {"java.util.jar package": [[38, 58]]}}}, {"text": "In particular, it will have to load the keys from your KeyStore instance with the right password for each alias (see getKey(String alias, char[] password))", "label": {"api": {"getKey(String alias, char[] password)": [[117, 153]]}}}, {"text": "Here is a Java 8 one liner", "label": {"api": {"Java 8 one liner": [[10, 25]]}}}, {"text": "Fairness locking in Java can easily be accomplished by using a ReentrantLock with a fairness parameter set to true", "label": {"api": {"ReentrantLock": [[63, 75]]}}}, {"text": "How about using encoding your binary data into a Base64 String when sending it through Cloud Endpoints", "label": {"api": {"into a Base64 String": [[42, 61]]}}}, {"text": "Setting values should not create any problems (only operations that resize array are problematic), but if you'll change your mind and would like to remove some domains you'll have to rewrite the whole loop statement (or you'll forget and something bad will happen)", "label": {"api": {"Setting values should not create any problems": [[0, 44]]}}}, {"text": "Also note that Java has a built in class for storing double precision points in its java.awt.geom.Point2D.Double class", "label": {"api": {"java.awt.geom.Point2D.Double": [[84, 111]]}}}, {"text": "Since the configuration is loaded when the application starts and is only for read at runtime, I would wrap the list with Collections.unmodifiableList and make the beans immutable", "label": {"api": {"Collections.unmodifiableList": [[122, 149]]}}}, {"text": "matches will return true only if user inputs a sequence of digits and dots", "label": {"api": {"matches": [[0, 6]]}}}, {"text": "public boolean matches(String regex)", "label": {"api": {"matches": [[15, 21]]}}}, {"text": "Tells whether or not this string matches the given regular expression", "label": {"api": {"matches": [[33, 39]]}}}, {"text": "You could write your own Comparator based on the index in the array", "label": {"api": {"Comparator": [[25, 34]]}}}, {"text": "List#contains() method do what you want", "label": {"api": {"List#contains()": [[0, 14]]}}}, {"text": "It is impossible to intercept events by adding a simple component as a layer in terms of JLayeredPane", "label": {"api": {"JLayer": [[89, 94]]}}}, {"text": "Thankfully there was a component added in Java 7 which does the complicated trick for you, JLayer, not to confuse with JLayeredPane", "label": {"api": {"JLayer": [[91, 96], [119, 124]]}}}, {"text": "First is a little mistake when you instatiate your SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[51, 66]]}}}, {"text": "Moreover, even Java 8.0 has the same serial version UID for HashMap and also Java 5.0 (and even 1.4), which means you can read/write HashMaps with Java 1.4-5-6-7-8 without any problems", "label": {"api": {"same serial version UID for HashMap": [[32, 66]], "Java 5.0": [[77, 84]]}}}, {"text": "getDeclaredFields() (or any other method of java.lang.Class for that matter) returns the compile-time data that's available for the class - it cannot return data based on a specific instance you're using", "label": {"api": {"java.lang.Class": [[44, 58]]}}}, {"text": "The best solution is using DocumentFilter", "label": {"api": {"DocumentFilter": [[27, 40]]}}}, {"text": "If you look at the Javadoc for compare() you can find out how it is expected to work", "label": {"api": {"compare()": [[31, 39]]}}}, {"text": "ServletContext#getRealPath() converts relative paths within your application to file system paths", "label": {"api": {"ServletContext#getRealPath()": [[0, 27]]}}}, {"text": "You can avoid this by using SwingWorker or executing your loop on another thread", "label": {"api": {"SwingWorker": [[28, 38]]}}}, {"text": "The ServletRequest#setCharacterEncoding(String) method only sets the encoding used for the body of the request", "label": {"api": {"ServletRequest#setCharacterEncoding(String)": [[4, 46]]}}}, {"text": "You can use IntStream.range", "label": {"api": {"IntStream.range": [[12, 26]]}}}, {"text": "Assuming that you are using a Collection of custom Objects (let's say Person objects), you can simply use the Collections API with different Comparator", "label": {"api": {"Collection": [[30, 39], [110, 119]], "Collections": [[110, 120]], "Comparator": [[141, 150]]}}}, {"text": "To get the max or min aged person, use Collections", "label": {"api": {"Collection": [[39, 48]], "Collections": [[39, 49]]}}}, {"text": "You can use another comparator (say SalaryComparator) that works like AgeComparator but considers salary", "label": {"api": {"Comparator": [[42, 51], [73, 82]]}}}, {"text": "A very simple approach uses JTextField's constructor", "label": {"api": {"JTextField's constructor": [[28, 51]]}}}, {"text": "Alternatively, you can use String.valueOf(int) note that the Javadoc refers to Integer.toString(int, int) where the second int is the radix", "label": {"api": {"String.valueOf(int)": [[27, 45]], "Integer.toString(int, int)": [[79, 104]]}}}, {"text": "The Comparator should return a negative integer if o1 < o2", "label": {"api": {"Comparator": [[4, 13]]}}}, {"text": "There doesn't appear to be an annotation in the core Java language that would do this (no obvious candidates in the \"All Known Implementing Classes\" list in the javadoc for java.lang.Annotation)", "label": {"api": {"javadoc for java.lang.Annotation": [[161, 192]]}}}, {"text": "Here is the document for String charAt", "label": {"api": {"the document for String charAt": [[8, 37]]}}}, {"text": "You can read a char from a specific index with charAt(int index) but you can not modify it", "label": {"api": {"charAt(int index)": [[47, 63]]}}}, {"text": "Use NumberFormat, setting explicitly the Locale you want to use", "label": {"api": {"NumberFormat": [[4, 15]], "Locale": [[41, 46]]}}}, {"text": "That’s as easy as passing an int value (the limit) to the LinkedBlockingQueue’s constructor", "label": {"api": {"LinkedBlockingQueue’s constructor": [[58, 90]]}}}, {"text": "Note that you can also use an ArrayBlockingQueue then as a LinkedBlockingQueue does not provide an advantage for bounded queue usage", "label": {"api": {"ArrayBlockingQueue": [[30, 47]]}}}, {"text": "The only thing left to do is to provide an appropriate RejectedExecutionHandler to the executor", "label": {"api": {"RejectedExecutionHandler": [[55, 78]]}}}, {"text": "CallerRunsPolicy would be sufficient to avoid that the caller creates more new jobs while the threads are all busy and the queue is full", "label": {"api": {"CallerRunsPolicy": [[0, 15]]}}}, {"text": "Read you first file line by line (you can use a Scanner for that)", "label": {"api": {"Scanner": [[48, 54]]}}}, {"text": "For each line, write it to the output file (you can use a PrintWriter for that)", "label": {"api": {"PrintWriter": [[58, 68]]}}}, {"text": "Also store the line in a HashSet", "label": {"api": {"HashSet": [[25, 31]]}}}, {"text": "For each line, check if the line is in the HashSet", "label": {"api": {"HashSet": [[43, 49]]}}}, {"text": "Example, Java 7 introduced <T> T Objects.requireNotNull(T obj) method, which internally does", "label": {"api": {"<T> T Objects.requireNotNull(T obj)": [[27, 61]]}}}, {"text": "A Map is a key-value pair, i.e., a value is associated to a key", "label": {"api": {"Map": [[2, 4]]}}}, {"text": "Consider using PrintWriter instead and specify character encodings as well (to be safe)", "label": {"api": {"PrintWriter": [[15, 25]]}}}, {"text": "A Collection is - a collection of data", "label": {"api": {"Collection": [[2, 11]]}}}, {"text": "Any collection is (or should be) Iterable, that means that you can iterate through all the elements of a collection (for example, in a loop)", "label": {"api": {"Iterable": [[33, 40]]}}}, {"text": "A List is obviously a collection as well, since a list is a collection of data", "label": {"api": {"List": [[2, 5]]}}}, {"text": "That's why the List interface extends the Collection interface", "label": {"api": {"Collection": [[42, 51]], "List": [[15, 18]]}}}, {"text": "However, since there are lots of ways to implement a List, List is merely an interface rather than a class", "label": {"api": {"List": [[53, 56], [59, 62]]}}}, {"text": "ArrayList implements a list by wrapping an array", "label": {"api": {"List": [[5, 8]], "ArrayList": [[0, 8]]}}}, {"text": "Another example would be LinkedList, which stores data by linking the elements to each other", "label": {"api": {"List": [[31, 34]], "LinkedList": [[25, 34]]}}}, {"text": "Usually, you will only store one type of Object inside a specific collection, which is why the Collection interface (and all of its subinterfaces like List) take a type parameter", "label": {"api": {"Collection": [[95, 104]], "List": [[151, 154]]}}}, {"text": "The type of this variable is List<String>, which means", "label": {"api": {"List": [[29, 32]]}}}, {"text": "Obviously, you have to choose an implementation, and you chose \"ArrayList\"", "label": {"api": {"List": [[69, 72]], "ArrayList": [[64, 72]]}}}, {"text": "Since you are calling ArrayList's constructor, you need empty parenthesis (so you call the constructor that doesn't take any arguments)", "label": {"api": {"List": [[27, 30]], "ArrayList": [[22, 30]]}}}, {"text": "Now, you could fill the list of strings you created above with data (strings) and do the same with removeList, and then \"subtract\" removeList from list by calling", "label": {"api": {"List": [[105, 108], [137, 140]]}}}, {"text": "If you simply need to read files from that folder, have a look at the Class.getRessourceAsStream(String) method", "label": {"api": {"Class.getRessourceAsStream(String)": [[70, 103]]}}}, {"text": "You can use a Timer", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "The try-with-resources is used to close the Scanner, and the file, when you're done reading it", "label": {"api": {"Scanner": [[44, 50]]}}}, {"text": "Scanner is a class that can read various thing, and among all, it can read Long", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "I tried beforeExecute etc, but that only gives me another object (a FutureTask), not the Client object I'm looking for", "label": {"api": {"beforeExecute": [[8, 20]]}}}, {"text": "Which one is used can for example be checked via the DecimalFormatSymbols class", "label": {"api": {"DecimalFormatSymbols": [[53, 72]]}}}, {"text": "You can use SimpleDateFormat to parse that", "label": {"api": {"SimpleDateFormat": [[12, 27]], "parse": [[32, 36]]}}}, {"text": "If you need to then convert it back to a string in another format, you can use another instance with the relevant format and its format method", "label": {"api": {"format": [[59, 64], [114, 119], [129, 134]]}}}, {"text": "If you have to use an array as your key, use a List instead, easily achievable by using Arrays#asList", "label": {"api": {"Arrays#asList": [[88, 100]]}}}, {"text": "From the SimpleFormatter docs you have to test for the following conditions", "label": {"api": {"SimpleFormatter": [[9, 23]]}}}, {"text": "You also need to check if GlassFish replaced your SimpleFormatter with the 'com.sun.enterprise.server.logging.UniformLogFormatter'", "label": {"api": {"SimpleFormatter": [[50, 64]]}}}, {"text": "You are looking for JOptionPane", "label": {"api": {"JOptionPane": [[20, 30]]}}}, {"text": "JOptionPane actually blocks, so you can loop", "label": {"api": {"JOptionPane": [[0, 10]]}}}, {"text": "First and foremost, it is possible the library is actually giving you more information than you think, by including with the generic IOException the underlying cause via Throwable.getCause()", "label": {"api": {"Throwable.getCause()": [[170, 189]]}}}, {"text": "It's an UnmodifiableMap", "label": {"api": {"UnmodifiableMap": [[8, 22]]}}}, {"text": "The first thing you do is convert that single String into an array of Strings by using the String#split() method, like this", "label": {"api": {"String#split()": [[91, 104]]}}}, {"text": "Each time you add a number, you have to parse it to a byte from a String, using the Byte#parseByte(String s) method", "label": {"api": {"Byte#parseByte(String s)": [[84, 107]]}}}, {"text": "It is important to use the BigDecimal constructor that takes a String", "label": {"api": {"BigDecimal": [[27, 36]]}}}, {"text": "By the way, all of this is just an implementation detail, you should not rely on it as it can change, and use it.remove() to remove an element from the list while you are iterating", "label": {"api": {"it.remove()": [[110, 120]]}}}, {"text": "You can use a Semaphore, as follows", "label": {"api": {"Semaphore": [[14, 22]]}}}, {"text": "Both the getBytes method and String constructor you used are documented as having unspecified behaviour when given characters/bytes are not valid as part of the specified character encoding", "label": {"api": {"documented": [[61, 70]]}}}, {"text": "I have faced some problems with removing node from JSF TreeModel tree", "label": {"api": {"TreeModel": [[55, 63]]}}}, {"text": "Is it possible to somehow remove node from TreeModel object", "label": {"api": {"TreeModel": [[43, 51]]}}}, {"text": "If you are using something before Java 8, you can use the Calendar class, specifically the overloaded getInstance method that takes a TimeZone as a parameter or the getInstance method that takes a TimeZone and a locale as a parameter", "label": {"api": {"Calendar class": [[58, 71]], "getInstance method that takes a TimeZone as a parameter": [[102, 156]], "getInstance method that takes a TimeZone and a locale as a parameter": [[165, 232]]}}}, {"text": "Java 8 provides a new date/time package that you could use", "label": {"api": {"a new date/time package": [[16, 38]]}}}, {"text": "Unfortunately, I'm not as familiar with this interface, but I would look at the Clock class and the Instant class", "label": {"api": {"Clock class": [[80, 90]], "Instant class": [[100, 112]]}}}, {"text": "Beware of the difference between the direct use of  InputStreamReader/OutputStreamWriter and their subclasses and the Reader/Writer factory methods of Files", "label": {"api": {" InputStreamReader": [[51, 68]], "OutputStreamWriter": [[70, 87]], "factory methods of Files": [[132, 155]]}}}, {"text": "Now, you can use the Character class to check what kind of characters you have", "label": {"api": {"Character": [[21, 29]]}}}, {"text": "From the API", "label": {"api": {"API": [[9, 11]]}}}, {"text": "I am attempting to use createFile with a FileAttribute derived from \"rw-rw-rw-\"", "label": {"api": {"createFile": [[23, 32]]}}}, {"text": "I believe what you're asking for is the method JTable.setSelectionMode(int), using as parameter ListSelectionModel.SINGLE_INTERVAL_SELECTION or possibly ListSelectionModel.MULTIPLE_INTERVAL_SELECTION, to enable the selection of multiple contiguous rows", "label": {"api": {"JTable.setSelectionMode(int)": [[47, 74]], "ListSelectionModel.SINGLE_INTERVAL_SELECTION": [[96, 139]], "ListSelectionModel.MULTIPLE_INTERVAL_SELECTION": [[153, 198]]}}}, {"text": "Just use the copy() method", "label": {"api": {"copy()": [[13, 18]]}}}, {"text": "There is a Scanner constructor that takes a String, but it just reads from the String directly", "label": {"api": {"Scanner constructor that takes a String": [[11, 49]]}}}, {"text": "You should create a File from your filename and pass the File to another Scanner constructor that takes a File", "label": {"api": {"Scanner constructor that takes a File": [[73, 109]]}}}, {"text": "If you use ProcessBuilder instead you can use directory to set you cwd instead", "label": {"api": {"directory": [[46, 54]]}}}, {"text": "LocalDateTime is a date-time without a time-zone", "label": {"api": {"LocalDateTime": [[0, 12]]}}}, {"text": "You specified the time zone offset format symbol in the format, however, LocalDateTime doesn't have such information", "label": {"api": {"LocalDateTime": [[73, 85]]}}}, {"text": "If you want time-zone information, you should use ZonedDateTime", "label": {"api": {"ZonedDateTime": [[50, 62]]}}}, {"text": "You can watch out all supported fields of such a type by look-up on the method isSupported(TemporalField).", "label": {"api": {"isSupported(TemporalField).": [[79, 105]]}}}, {"text": "With the help of set we can easily implement it", "label": {"api": {"set": [[17, 19]]}}}, {"text": "Yes, but it is not part of JTable but RowSorter", "label": {"api": {"RowSorter": [[38, 46]]}}}, {"text": "You can add a RowSorterListener", "label": {"api": {"RowSorter": [[14, 22]]}}}, {"text": "You can use the method ResultSetMetaData.getColumnClassName(int)", "label": {"api": {"ResultSetMetaData.getColumnClassName(int)": [[23, 63]]}}}, {"text": "You can also code it out as demonstrated by the answer of Daniel Scott, although then I would opt to use ResultSetMetaData.getColumnType(int) instead, that way you can switch using the constants of java.sql.Types or (Java 8) java.sql.JDBCType", "label": {"api": {"ResultSetMetaData.getColumnType(int)": [[105, 140]], "java.sql.Types": [[198, 211]], "java.sql.JDBCType": [[225, 241]]}}}, {"text": "First, for performance you should use StringBuilder (not StringBuffer)", "label": {"api": {"StringBuilder": [[38, 50]], "StringBuffer": [[57, 68]]}}}, {"text": "StringBuilder is more efficient because (unlike StringBuffer) not every method is synchronized", "label": {"api": {"StringBuilder": [[0, 12]], "StringBuffer": [[48, 59]]}}}, {"text": "What you want is a WindowStateListener", "label": {"api": {"WindowStateListener": [[19, 37]]}}}, {"text": "If by \"triggers full-screen\" you mean a true full-screen window, a ComponentListener may work, though I have not tried it", "label": {"api": {"full-screen window": [[45, 62]]}}}, {"text": "Since a true full-screen window can only occur if your code calls GraphicsDevice.setFullScreenWindow, you would probably want to add your code right after that call", "label": {"api": {"full-screen window": [[13, 30]]}}}, {"text": "A PriorityQueue is what is called a binary heap", "label": {"api": {"PriorityQueue": [[2, 14]]}}}, {"text": "This is the reason why a PriorityQueue manages to have such good performance, as it is not doing any more sorting than it needs at any time", "label": {"api": {"PriorityQueue": [[25, 37]]}}}, {"text": "As you can see in the PriorityQueue javadoc", "label": {"api": {"PriorityQueue javadoc": [[22, 42]]}}}, {"text": "Use java's BigDecimal instead", "label": {"api": {"BigDecimal": [[11, 20]]}}}, {"text": "To quote the documentation on BigDecimal", "label": {"api": {"BigDecimal": [[30, 39]]}}}, {"text": "A BigDecimal consists of an arbitrary precision integer unscaled value and a 32-bit integer scale", "label": {"api": {"BigDecimal": [[2, 11]]}}}, {"text": "Note that this example uses MathContext.DECIMAL64 as a way to pass a precision and rounding mode to the divide method", "label": {"api": {"MathContext.DECIMAL64": [[28, 48]], "divide": [[104, 109]]}}}, {"text": "You can tweak the precision and RoundingMode by constructing a MathContext object if needed", "label": {"api": {"RoundingMode": [[32, 43]], "constructing a MathContext object": [[48, 80]]}}}, {"text": "It is always best to pass a MathContext parameter in the divide method for arbitrary calculations", "label": {"api": {"divide": [[57, 62]]}}}, {"text": "The divide(BigDecimal divisor) method will throw an ArithmeticException if the exact quotient does not have a terminating decimal expansion", "label": {"api": {"BigDecimal": [[11, 20]], "divide": [[4, 9]], "divide(BigDecimal divisor)": [[4, 29]]}}}, {"text": "You do not need a ResultSet object for it - ResultSetMetaData would be enough", "label": {"api": {"ResultSetMetaData": [[44, 60]]}}}, {"text": "If this isn't too late and you are using 1.7+ and you don't wan't to pull in an entire library like Guava or Commons-IO, you can just extend the GZIPOutputStream and obtain the data from the associated Deflater like so", "label": {"api": {"GZIPOutputStream": [[145, 160]], "Deflater": [[202, 209]]}}}, {"text": "If you want to be able to color different words, you need to use a JTextPane or a JEditorPane", "label": {"api": {"JTextPane": [[67, 75]], "JEditorPane": [[82, 92]]}}}, {"text": "The @WebServlet annotation does not have an asyncTimeout element", "label": {"api": {"@WebServlet": [[4, 14]]}}}, {"text": "Yes, the HttpServletRequest has a getMethod() that returns a String value representing the HTTP method", "label": {"api": {"getMethod()": [[34, 44]]}}}, {"text": "You can use a ArrayList which is created empty with no specific size and you can add (-> add(Object o) or remove (-> remove(int index)) anytime you want", "label": {"api": {"ArrayList": [[14, 22]]}}}, {"text": "In DOM, an element name is retrieved using Node.getNodeName()", "label": {"api": {"Node.getNodeName()": [[43, 60]]}}}, {"text": "Why not use readAllBytes instead", "label": {"api": {"readAllBytes": [[12, 23]]}}}, {"text": "also, is there a way to set FocusTraversalPolicy for JComponent", "label": {"api": {"FocusTraversalPolicy": [[28, 47]]}}}, {"text": "As you absolutely need to use ArrayList class to store your polynomials you can use its add(int index, E Element) method as follows", "label": {"api": {"method": [[114, 119]]}}}, {"text": "Locale.getDefault() just gives you the default Locale, as explained in the JavaDoc (http://docs.oracle.com/javase/7/docs/api/java/util/Locale.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Locale.html": [[84, 145]]}}}, {"text": "You're printing the result of the toString method of the Recordset object, which appears to print out the object's name and hashcode", "label": {"api": {"toString method": [[34, 48]]}}}, {"text": "The documentation for Java's recordset looks confusing, you might be better off searching for examples", "label": {"api": {"documentation for Java's recordset": [[4, 37]]}}}, {"text": "another way to spread the load even more would be to use \"schedule with fixed delay\" and put a short, random pause in every execution (e.g", "label": {"api": {"\"schedule with fixed delay\"": [[57, 83]]}}}, {"text": "See the documentation for ResultSet for further information", "label": {"api": {"documentation for ResultSet": [[8, 34]]}}}, {"text": "indexOf returns the index of the first occurence of the given element", "label": {"api": {"indexOf": [[0, 6]]}}}, {"text": "Call destroy in the process", "label": {"api": {"destroy": [[5, 11]]}}}, {"text": "Java SE 7", "label": {"api": {"Java SE 7": [[0, 8]]}}}, {"text": "Java SE 8", "label": {"api": {"Java SE 8": [[0, 8]]}}}, {"text": "You can take advantage of SwingWorkers Future heritage and use isCancelled and cancel functionality..", "label": {"api": {"Future": [[39, 44]]}}}, {"text": "either run your application jar with fork=\"false\" or use a GUI dialog to get the input, for instance using JOptionPane, instead of getting input from System.in", "label": {"api": {"JOptionPane": [[107, 117]]}}}, {"text": "Your are getting this error because Random.nextInt(0) will throw an exception", "label": {"api": {"Random.nextInt(0)": [[36, 52]]}}}, {"text": "To convert from the view index to the model index, use convertRowIndexToModel()", "label": {"api": {"convertRowIndexToModel()": [[55, 78]]}}}, {"text": "you can use new WatchService for this purpose", "label": {"api": {"WatchService": [[16, 27]]}}}, {"text": "The easiest would be using Scanner class", "label": {"api": {"Scanner": [[27, 33]]}}}, {"text": "Refer to the documentation of ProcessBuilder to find out how to achieve that", "label": {"api": {"ProcessBuilder": [[30, 43]]}}}, {"text": "You will want to check the JLabel API for there you'll find the correct constructor, one with an Icon, a String and an int for horizontal alignment", "label": {"api": {"JLabel API": [[27, 36]]}}}, {"text": "While you can solve this by using the regex suggested by @avinashraj, I want to suggest a better solution using String#startsWith, you don't really need regex here", "label": {"api": {"String#startsWith": [[112, 128]]}}}, {"text": "getName() is a method of the Class class, not the Object class", "label": {"api": {"getName()": [[0, 8]]}}}, {"text": "Object has a getClass() method that returns a Class instance", "label": {"api": {"getClass()": [[13, 22]]}}}, {"text": "t.getClass() returns an instance of Class<test>, which has the method getName()", "label": {"api": {"getClass()": [[2, 11]], "getName()": [[70, 78]]}}}, {"text": "This allows you to call t.getClass().getName()", "label": {"api": {"getClass()": [[26, 35]], "getName()": [[37, 45]]}}}, {"text": "If you're using Java 8, you can leverage streams", "label": {"api": {"streams": [[41, 47]]}}}, {"text": "To preserve insertion order when iterating use a LinkedHashMap instead of a HashMap, and to go in reverse do this", "label": {"api": {"LinkedHashMap": [[49, 61]]}}}, {"text": "I've seen others claim that the default is UTF-16BE, citing the Charset API documentation, but my interpretation of said documentation is that it applies to interpretation of a UTF-16 input stream without a BOM, and says nothing about the required behavior (if any) of OutputStreamWriter using UTF-16 in the absence of a specified endianness", "label": {"api": {"Charset API documentation": [[64, 88]]}}}, {"text": "It would be better to use a Scanner", "label": {"api": {"Scanner": [[28, 34]]}}}, {"text": "Scanner.next() reads in the whole line (the default delimiter is the newline char(s))", "label": {"api": {"Scanner": [[0, 6]]}}}, {"text": "To learn more check Java Pattern", "label": {"api": {"Java Pattern": [[20, 31]]}}}, {"text": "Code compiled by Eclipse checks to see if a suppressed exception equals itself before invoking Throwable.addSuppressed", "label": {"api": {"Throwable.addSuppressed": [[95, 117]]}}}, {"text": "Well the hasNext will return true as long as there is more input in the file, so the condition would be while (input.hasNext())", "label": {"api": {"hasNext": [[9, 15], [117, 123]]}}}, {"text": "That's how you use the hasNext() method to continue reading the file while there is input left", "label": {"api": {"hasNext": [[23, 29]]}}}, {"text": ".split(..) is exactly what you're looking for, assuming there is always at least one space between each string you want to split", "label": {"api": {".split(..)": [[0, 9]]}}}, {"text": "To launch an external process from your java code consider ProcessBuilder class", "label": {"api": {"ProcessBuilder": [[59, 72]]}}}, {"text": "The most crude way is to use Runtime.exec(String) which executes a command as if it were entered into the operating systems command shell", "label": {"api": {"Runtime.exec(String)": [[29, 48]]}}}, {"text": "It returns a Process object which allows you to retrieve the output of the process you start and gives you some control over the process", "label": {"api": {"Process": [[13, 19]]}}}, {"text": "A more sophisticated but also more verbose way is to use the class ProcessBuilder", "label": {"api": {"Process": [[67, 73]], "ProcessBuilder": [[67, 80]]}}}, {"text": "It includes Object.hashCode()", "label": {"api": {"hashCode()": [[19, 28]]}}}, {"text": "The Javadoc of hashCode() states", "label": {"api": {"hashCode()": [[15, 24]]}}}, {"text": "The key is that hashCode() will be different for distinct objects", "label": {"api": {"hashCode()": [[16, 25]]}}}, {"text": "Open your file in append mode, So that it won't override", "label": {"api": {"append mode": [[18, 28]]}}}, {"text": "If you need to store more values in the component and/or not just Strings, take a look at the putClientProperty() and getClientProperty() methods", "label": {"api": {"putClientProperty()": [[94, 112]], "getClientProperty()": [[118, 136]]}}}, {"text": "You can use the org.w3c.dom API (which is part of the core java libraries)", "label": {"api": {"org.w3c.dom": [[16, 26]]}}}, {"text": "The call you make to Class.getResource(String) looks on the classpath for the resource (unless you've done something funky with the class-loaders) and therefore will never find an absolute path", "label": {"api": {"Class.getResource(String)": [[21, 45]]}}}, {"text": "If you want to load a file from an absolute path, just create an java.io.FileInputStream using that path like this", "label": {"api": {"java.io.FileInputStream": [[65, 87]]}}}, {"text": "Another option is to use a JSpinner.NumberEditor(JSpinner spinner, String decimalFormatPattern)", "label": {"api": {"JSpinner.NumberEditor(JSpinner spinner, String decimalFormatPattern)": [[27, 94]]}}}, {"text": "Just see the docs of add() method in TreeSet", "label": {"api": {"add()": [[21, 25]]}}}, {"text": "You can use Collections.removeIf (I'm assuming you are using JDK 8)", "label": {"api": {"Collections.removeIf": [[12, 31]]}}}, {"text": "To change the working directory for your exec() call, use the three argument method", "label": {"api": {"three argument method": [[62, 82]]}}}, {"text": "java.text.DecimalFormat is the way to go", "label": {"api": {"java.text.DecimalFormat": [[0, 22]]}}}, {"text": "As referred to from this thread, approaches such as recursion and balancing groups cannot apply here, as the regular expression constructs are not present in Java Pattern", "label": {"api": {"Java Pattern": [[158, 169]]}}}, {"text": "From the Java API", "label": {"api": {"Java API": [[9, 16]]}}}, {"text": "Use a TreeMap", "label": {"api": {"TreeMap": [[6, 12]]}}}, {"text": "For a better approach at measuring the size of an object in Java, take a look at the Java Object Layout utility, or use the Instrumentation.getObjectSize(...) method from a Java agent", "label": {"api": {"Instrumentation.getObjectSize(...) method": [[124, 164]]}}}, {"text": "nextInt will NOT consume the following newline character, so the next call to nextLine will be the sole newline character ('\\n') left in the input", "label": {"api": {"nextInt": [[0, 6]], "nextLine": [[78, 85]]}}}, {"text": "Make a call to nextLine before the loop to discard it", "label": {"api": {"nextLine": [[15, 22]]}}}, {"text": "Using Java ScriptEngine you can embed different scripting languages in your application, including BeanShell which is based on Java", "label": {"api": {"ScriptEngine": [[11, 22]]}}}, {"text": "You could use a synchronized set to store blocked hosts", "label": {"api": {"synchronized set": [[16, 31]]}}}, {"text": "Perhaps a better match would be ParseException", "label": {"api": {"ParseException": [[32, 45]]}}}, {"text": "Another solution is using String#split", "label": {"api": {"String#split": [[26, 37]]}}}, {"text": "I managed to solve this by downcasting the BaseEntity root into new roots that correspond to the subclass types with CriteriaBuilder.treat() like this", "label": {"api": {"CriteriaBuilder.treat()": [[117, 139]]}}}, {"text": "You need addAll", "label": {"api": {"add": [[9, 11]], "addAll": [[9, 14]]}}}, {"text": "add treats the argument as a single element to be added to the list", "label": {"api": {"add": [[0, 2], [50, 52]]}}}, {"text": "addAll expects a Collection of elements to be added to the list", "label": {"api": {"add": [[0, 2], [46, 48]], "addAll": [[0, 5]]}}}, {"text": "BTW, if you defined your list as List<String> word_list = new ArrayList<String>();, the compiler would have prevented you from calling add with a List as an argument", "label": {"api": {"add": [[135, 137]]}}}, {"text": "If you use getResourceAsStream(), then you can extract the file from your JAR and place it somewhere that PowerPoint can access", "label": {"api": {"getResourceAsStream()": [[11, 31]]}}}, {"text": "while collect is a terminal operation", "label": {"api": {"terminal operation": [[19, 36]]}}}, {"text": "The descendingIterator() method of java.util.TreeSet yields elements from greatest to least, so you can just step it however many times, inserting the elements into a collection", "label": {"api": {"descendingIterator() method of java.util.TreeSet": [[4, 51]]}}}, {"text": "You need to use Array.equals or Array.deepEquals to do the comparison", "label": {"api": {"Array.equals": [[16, 27]]}}}, {"text": "Try using a PrintWriter like this", "label": {"api": {"PrintWriter": [[12, 22]]}}}, {"text": "If you need a few write access and a lot of read access, then I would suggest CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[78, 97]]}}}, {"text": "For simple types, you can use Atomic variables, se Concurrency package JavaDoc", "label": {"api": {"Concurrency package JavaDoc": [[51, 77]]}}}, {"text": "In the Java core library, there's java.util.UUID.nameUUIDFromBytes(byte[])", "label": {"api": {"java.util.UUID.nameUUIDFromBytes(byte[])": [[34, 73]]}}}, {"text": "ZoneRules contains the functionality you are intrested in", "label": {"api": {"ZoneRules": [[0, 8]]}}}, {"text": "Create an ActionListener and register it at the first two ComboBox instances by calling addActionListener()", "label": {"api": {"ActionListener": [[10, 23], [91, 104]], "addActionListener()": [[88, 106]]}}}, {"text": "Initially set a DefaultComboBoxModel", "label": {"api": {"DefaultComboBoxModel": [[16, 35]]}}}, {"text": "In the action listener call getModel() and add/remove whatever you want", "label": {"api": {"getModel()": [[28, 37]]}}}, {"text": "Or just create a new DefaultComboBoxModel every time and set it", "label": {"api": {"DefaultComboBoxModel": [[21, 40]]}}}, {"text": "Using Collections.sort is the best way to do it", "label": {"api": {"Collections.sort": [[6, 21]]}}}, {"text": "Here is how you can do it using a custom Comparator", "label": {"api": {"Comparator": [[41, 50]]}}}, {"text": "And here is how to do it implementing the Comparable interface", "label": {"api": {"Comparable": [[42, 51]]}}}, {"text": "Alternatively, once Timeimplements Comparable, you can use a TreeSet instead of an ArrayList, in order to sort your Times as they are added to the set", "label": {"api": {"Comparable": [[35, 44]], "TreeSet": [[61, 67]]}}}, {"text": "The Hibernate method TypeInfo.extractTypeInfo uses jdbc DatabaseMetaData to query the data types from database", "label": {"api": {"DatabaseMetaData": [[56, 71]]}}}, {"text": "You can find more info on the required format in the javadoc of Date.parse() because the constructor calls this to parse the String parameter", "label": {"api": {"Date.parse()": [[64, 75]]}}}, {"text": "You can use a Scanner for this job", "label": {"api": {"Scanner": [[14, 20]]}}}, {"text": "The key point is the regex specified as delimiter", "label": {"api": {"regex": [[21, 25]]}}}, {"text": "The pattern used above will match what BufferedReader.readLine() matches for a line break, that is, a '\\n', '\\r' followed by '\\n', or a lone '\\r'", "label": {"api": {"BufferedReader.readLine()": [[39, 63]]}}}, {"text": "But it uses “zero width lookbehind” to match the position after the line break rather than the line break itself so the line break becomes part of the token returned by Scanner.next()", "label": {"api": {"Scanner": [[169, 175]]}}}, {"text": "Take a look at Objects.equals(Object a, Object b)", "label": {"api": {"Objects.equals(Object a, Object b)": [[15, 48]]}}}, {"text": "See this page for more information on proxy properties", "label": {"api": {"this page": [[4, 12]]}}}, {"text": "You could use java.util.regex.Pattern.qoute()", "label": {"api": {"java.util.regex.Pattern.qoute()": [[14, 44]]}}}, {"text": "Upgrade to Java 8 where SecretKey and RSAPrivateKey implements Destroyable", "label": {"api": {"SecretKey": [[24, 32]], "RSAPrivateKey": [[38, 50]], "Destroyable": [[63, 73]]}}}, {"text": "where MyAESKey implements both SecretKey and Destroyable", "label": {"api": {"SecretKey": [[31, 39]], "Destroyable": [[45, 55]]}}}, {"text": "You could of course use a similar approach with your own MyDestroyable interface for Java 7 and below", "label": {"api": {"Destroyable": [[59, 69]]}}}, {"text": "Use Calendar#add() method where first argument is DATE and second value is either 1 or -1 based on next or previous day", "label": {"api": {"Calendar#add()": [[4, 17]]}}}, {"text": "Awt's Dimension class can do a lot of things, converting between different numeric types and etc", "label": {"api": {"Dimension class": [[6, 20]]}}}, {"text": "Can I get a performance hit, if I stick with the Dimension class all along instead of using my custom Pair  class", "label": {"api": {"Dimension class": [[49, 63]]}}}, {"text": "If you look at the Consumer<T> interface, the accept method (which is what your method reference would effectively be using) isn't declared to throw any checked exceptions - therefore you can't use a method reference which is declared to throw a checked exception", "label": {"api": {"Consumer<T>": [[19, 29]]}}}, {"text": "Arrays are objects too in Java, but they don't override Object's toString() method", "label": {"api": {"Object's toString() method": [[56, 81]]}}}, {"text": "The output is not the hashed output, but the result of Object's toString() method", "label": {"api": {"Object's toString() method": [[55, 80]]}}}, {"text": "According to the ZipFile docs, you need to pass in a File object or a file path; an InputStream isn't supported", "label": {"api": {"ZipFile docs": [[17, 28]]}}}, {"text": "If you read the file line-by-line with BufferedReader#readLine() or Scanner#nextLine(), all you need to do is add \\G to the beginning of your regex", "label": {"api": {"BufferedReader#readLine()": [[39, 63]], "Scanner#nextLine()": [[68, 85]]}}}, {"text": "Use ConcurrentHashMap, if you are looking for a synchronization", "label": {"api": {"ConcurrentHashMap": [[4, 20]]}}}, {"text": "Take a look at  and TableModel.isCellEditable(int rowIndex, int columnIndex)", "label": {"api": {"TableModel.isCellEditable(int rowIndex, int columnIndex)": [[20, 75]]}}}, {"text": "There is a JTable.isCellEditable(int row, int column) too which calls the model's isCellEditable() method", "label": {"api": {"JTable.isCellEditable(int row, int column)": [[11, 52]]}}}, {"text": "Use the class Executors to do it", "label": {"api": {"Executors": [[14, 22]]}}}, {"text": "Use SwingWorker to load images", "label": {"api": {"SwingWorker": [[4, 14]]}}}, {"text": "You can combine both and use Executors in doInBackground() method", "label": {"api": {"Executors": [[29, 37]]}}}, {"text": "I´m wondering if there is a way to connect a Combo Box to an underlying String in the model", "label": {"api": {"String": [[72, 77]]}}}, {"text": "So I have a String in the Model and a Combo on my View", "label": {"api": {"String": [[12, 17]]}}}, {"text": "I tried to use the fireIndexedPropertyChangeMethod which didn't worked either", "label": {"api": {"fireIndexedPropertyChangeMethod": [[19, 49]]}}}, {"text": "Use the Random.nextInt(int) method for it", "label": {"api": {"Random.nextInt(int)": [[8, 26]]}}}, {"text": "Use the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[8, 31]]}}}, {"text": "I'd first try javax.ImageIO as your system may have a provider for the JPEG2000 format", "label": {"api": {"javax.ImageIO": [[14, 26]]}}}, {"text": "LocalDate.ofEpochDay() expects day count as its argument, and you're passing second count (which is what you get when dividing millisecond count by 1000)", "label": {"api": {"LocalDate.ofEpochDay()": [[0, 21]]}}}, {"text": "This is documented behaviour", "label": {"api": {"documented behaviour": [[8, 27]]}}}, {"text": "Use the Object.clone() function", "label": {"api": {"Object.clone()": [[8, 21]]}}}, {"text": "However, java.util.prefs.Preferences may be useful for exactly what you're asking", "label": {"api": {"java.util.prefs.Preferences": [[9, 35]]}}}, {"text": "Your second snippet uses ByteBuffer.array(), which just returns the array backing the ByteBuffer", "label": {"api": {"ByteBuffer.array()": [[25, 42]]}}}, {"text": "If you use ObjectOutputStream to write stuff, you should use ObjectInputStream to read it", "label": {"api": {"ObjectInputStream": [[61, 77]]}}}, {"text": "You could use a Scanner and a single Pattern which matches either kind of token", "label": {"api": {"Scanner": [[16, 22]]}}}, {"text": "The API documentation says (my emphasis)", "label": {"api": {"API documentation": [[4, 20]]}}}, {"text": "That method is defined in the interface SortedMap, so you need to use a map that implements that interface", "label": {"api": {"SortedMap": [[40, 48]]}}}, {"text": "The likely concurrent candidate is ConcurrentSkipListMap", "label": {"api": {"ConcurrentSkipListMap": [[35, 55]]}}}, {"text": "I am going to go with a NavigableMap as the floorKey function is exactly what I need", "label": {"api": {"NavigableMap": [[24, 35]]}}}, {"text": "You can make use of a NavigableMap (like TreeMap) which has very useful methods exactly for this purpose", "label": {"api": {"NavigableMap": [[22, 33]], "very useful methods": [[60, 78]]}}}, {"text": "1) Implement the Comaparable interface in your Book class", "label": {"api": {"Comaparable": [[17, 27]]}}}, {"text": "2) Then do the sorting using Arrays.sort(obect[]) method", "label": {"api": {"Arrays.sort(obect[])": [[29, 48]]}}}, {"text": "If you want to sort on different properties of Book class then you can use Comparator, for example", "label": {"api": {"Comparator": [[75, 84]]}}}, {"text": "Is there a letter for the milliseconds since 1970 in SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[53, 68]]}}}, {"text": "Admittedly, I haven't tested this, but I would think it should be possible to create java.net.SocketImplFactory which creates SocketImpls that raise appropriate exceptions when eg", "label": {"api": {"java.net.SocketImplFactory": [[85, 110]]}}}, {"text": "Regardless, for your use case, you likely want to be using a HashSet, and just store the values in there", "label": {"api": {"using a HashSet": [[53, 67]]}}}, {"text": "First, the whole point of any pool is to hold an expensive resource, in this case a javax.sql.Connection, so that it may be reused in the future avoiding the cost of creating that resource again", "label": {"api": {"javax.sql.Connection": [[84, 103]]}}}, {"text": "As the JDBC API is well defined connection pools typically implement javax.sql.DataSource allowing connection pools to be switched in and out as needed", "label": {"api": {"javax.sql.DataSource": [[69, 88]]}}}, {"text": "Given this javax.sql.Connection.close() should be used to return the connection to the pool", "label": {"api": {"javax.sql.Connection": [[11, 30]], "javax.sql.Connection.close()": [[11, 38]]}}}, {"text": "Instead, you would usually use a RequestDispatcher to include() it", "label": {"api": {"RequestDispatcher": [[33, 49]], "include()": [[54, 62]]}}}, {"text": "You could use Java's String-format", "label": {"api": {"Java's String-format": [[14, 33]]}}}, {"text": "you are calling the method setConstraints(...) and passing in 0 for rowSpan and colSpan", "label": {"api": {"setConstraints(...)": [[27, 45]]}}}, {"text": "See the Javadoc for Comparable for instructions on defining the interface", "label": {"api": {"Javadoc for Comparable": [[8, 29]]}}}, {"text": "Read about DecimalFormat", "label": {"api": {"DecimalFormat": [[11, 23]]}}}, {"text": "Your fields are private - which is a good thing, but it doesn't play well with Class.getFields (emphasis mine)", "label": {"api": {"Class.getFields": [[79, 93]]}}}, {"text": "You should use Class.getDeclaredFields instead", "label": {"api": {"Class.getDeclaredFields": [[15, 37]]}}}, {"text": "It's behaving exactly as documented - you're not getting \"a random number\", you're getting Long.MAX_VALUE", "label": {"api": {"documented": [[25, 34]]}}}, {"text": "You essentially need a limited-capacity circular buffer - ArrayDeque would be much closer", "label": {"api": {"ArrayDeque": [[58, 67]]}}}, {"text": "Secondly you can simply override, the getPreferredSize() of the said JPanel, in order for it to give, some size that you feel like will work for your use case", "label": {"api": {"getPreferredSize()": [[38, 55]]}}}, {"text": "For a one-to-many join, the join column mentioned in the JoinColumn annotation is in the other table", "label": {"api": {"JoinColumn annotation": [[57, 77]]}}}, {"text": "Java 8's enhancements to the Map interface allow us to implement this method in a slightly more elegant way, with the annoying if block in the middle", "label": {"api": {"Map": [[29, 31]]}}}, {"text": "Add WindowListener to listen the close event of your JFrame", "label": {"api": {"WindowListener": [[4, 17]]}}}, {"text": "Just use a DefaultListModel", "label": {"api": {"DefaultListModel": [[11, 26]]}}}, {"text": "Just call join on the thread", "label": {"api": {"join": [[10, 13]]}}}, {"text": "The join call waits for the thread to terminate before returning", "label": {"api": {"join": [[4, 7]]}}}, {"text": "It's also good practice to use @Override annotation if our method overrides another method or implements abstract method declaration (note", "label": {"api": {"@Override": [[31, 39]]}}}, {"text": "Use the ArrayList addAll method", "label": {"api": {"ArrayList addAll": [[8, 23]]}}}, {"text": "I was reading this question, where @SuppressWarnings annotation is used on class level", "label": {"api": {"@SuppressWarnings": [[35, 51]]}}}, {"text": "Suppose I have multiple classes in my application, so is there a way that I can use @SuppressWarnings on application level", "label": {"api": {"@SuppressWarnings": [[84, 100]]}}}, {"text": "As applying @SuppressWarnings on every class is redundant for me", "label": {"api": {"@SuppressWarnings": [[12, 28]]}}}, {"text": "Use the isInstance or isAssignableFrom method of Class depending on your needs", "label": {"api": {"isInstance": [[8, 17]], "isAssignableFrom": [[22, 37]]}}}, {"text": "isInstance docs excerpt", "label": {"api": {"isInstance": [[0, 9]]}}}, {"text": "isAssignableFrom docs excerpt", "label": {"api": {"isAssignableFrom": [[0, 15]]}}}, {"text": "Group does not have a -fx-background-color property", "label": {"api": {"Group does not have a -fx-background-color property": [[0, 50]]}}}, {"text": "that property is defined in Region", "label": {"api": {"Region": [[28, 33]]}}}, {"text": "So you need your root element to be some subclass of Region, such as Pane", "label": {"api": {"Region": [[53, 58]]}}}, {"text": "Math.random() returns a random double value between 0 (inclusive) and 1 (exclusive)", "label": {"api": {"Math.random()": [[0, 12]]}}}, {"text": "From the notify() documentation", "label": {"api": {"notify() documentation": [[9, 30]]}}}, {"text": "And notifyAll() documentation", "label": {"api": {"notifyAll() documentation": [[4, 28]]}}}, {"text": "Below is the documentation of @Deprecated annotation", "label": {"api": {"@Deprecated": [[30, 40]]}}}, {"text": "@Deprecated (a marker annotation) is for the programmer to indicate that this method/ field/ package..", "label": {"api": {"@Deprecated": [[0, 10]]}}}, {"text": "visitFile is only called when visiting files, not directories", "label": {"api": {"visitFile": [[0, 8]]}}}, {"text": "You should instead add another function that overrides preVisitDirectory or postVisitDirectory (depending on whether you want the operation to happen before you visit all the files in the sub-directory or after), and place the directory-specific logic there", "label": {"api": {"preVisitDirectory": [[55, 71]], "postVisitDirectory": [[76, 93]]}}}, {"text": "From Collectors.toMap(...) javadoc", "label": {"api": {"Collectors.toMap(...) javadoc": [[5, 33]]}}}, {"text": "Using dateOfItem.toString() uses its own output format", "label": {"api": {"output format": [[41, 53]]}}}, {"text": "Matcher#matches() attempts to match the entire String", "label": {"api": {"Matcher#matches()": [[0, 16]]}}}, {"text": "What you want is find() and possibly group() to get the result", "label": {"api": {"find()": [[17, 22]], "group()": [[37, 43]]}}}, {"text": "If you get the root element and call root.getElementsByTagName(\"figure\") it should return a NodeList with the elements in the order in which they appear in the document", "label": {"api": {"root.getElementsByTagName(\"figure\")": [[37, 71]]}}}, {"text": "Character.getNumericValue does work here, hypothetically", "label": {"api": {"Character.getNumericValue": [[0, 24]]}}}, {"text": "Method String.ReplaceAll receives regex as first argument", "label": {"api": {"ReplaceAll": [[14, 23]]}}}, {"text": "Use Double.doubleToLongBits() or Double.doubleToRawLongBits()", "label": {"api": {"Double.doubleToLongBits()": [[4, 28]], "Double.doubleToRawLongBits()": [[33, 60]]}}}, {"text": "First, get the bits as long, using Double.doubleToLongBits() or Double.doubleToRawLongBits()", "label": {"api": {"Double.doubleToLongBits()": [[35, 59]], "Double.doubleToRawLongBits()": [[64, 91]]}}}, {"text": "The cleanest solution is to store the names in an ArrayList rather than an array of strings, shuffle the list, and iterate through in pairs to create matches", "label": {"api": {"shuffle": [[93, 99]]}}}, {"text": "I would suggest you use an List<String> of words", "label": {"api": {"List<String>": [[27, 38]]}}}, {"text": "Then, because you want to change the GUI with a welcome message, you should use a SwingWorker, a class designed to perform GUI-interaction tasks in a background thread", "label": {"api": {"SwingWorker": [[82, 92]]}}}, {"text": "Worker Threads and SwingWorker", "label": {"api": {"SwingWorker": [[19, 29]]}}}, {"text": "Most likely your peek and size methods are not called", "label": {"api": {"peek": [[17, 20]]}}}, {"text": "LinkedList peek method does not take any param but your method does", "label": {"api": {"peek": [[11, 14]]}}}, {"text": "You might want to take a look to JEditorPane (quote from javadocs", "label": {"api": {"JEditorPane": [[33, 43]]}}}, {"text": "@anibhava already mentioned your problem, I want to suggest another solution, you can simply remove the white spaces and cut the string using String#substring", "label": {"api": {"String#substring": [[142, 157]]}}}, {"text": "If you look at the documentation for InputStreamReader, you will see that it provides two read() methods", "label": {"api": {"documentation for InputStreamReader": [[19, 53]]}}}, {"text": "The placement of tabs is determined by the JTabbedPane UI delegate, typically based on BasicTabbedPaneUI", "label": {"api": {"BasicTabbedPaneUI": [[87, 103]]}}}, {"text": "Have a look at the Robot Class therefore", "label": {"api": {"Robot": [[19, 23]]}}}, {"text": "The method createScreenCapture should exactly do what you are looking for", "label": {"api": {"createScreenCapture": [[11, 29]]}}}, {"text": "If you have a task that must run after scheduled delay and return the result, I would suggest to use Callable instead of the TimeTask and ScheduledExecutorService instead of Timer", "label": {"api": {"Callable": [[101, 108]]}}}, {"text": "Since Serializable is an interface, only another interface can extend it", "label": {"api": {"Serializable": [[6, 17]]}}}, {"text": "The Process object has methods destroy() (which kills the process) and waitFor() (which waits for it to exit)", "label": {"api": {"Process": [[4, 10]]}}}, {"text": "In Java 8 it also has isAlive() and destroyForcibly() methods", "label": {"api": {"isAlive() and destroyForcibly() methods": [[22, 60]]}}}, {"text": "OK, after poking around on the net to find source code for ProcessImpl in various JREs, it looks like on Windows ProcessImpl has a field handle which presumably is the Win32 handle returned by CreateProcess, and on Linux UNIXProcess has a field pid which appears to be the process ID", "label": {"api": {"Process": [[59, 65], [113, 119], [199, 205], [225, 231]]}}}, {"text": "You need to use the setNull() method to specify your user-defined type", "label": {"api": {"the setNull() method": [[16, 35]]}}}, {"text": "You should really use setNull() for your varchar2 example as well, but can use the simpler version, as", "label": {"api": {"the simpler version": [[79, 97]]}}}, {"text": "A Runnable isn't a thread", "label": {"api": {"Runnable": [[2, 9]]}}}, {"text": "Essentially, Runnable is exactly the Task interface you suggest", "label": {"api": {"Runnable": [[13, 20]]}}}, {"text": "The method Arrays.asList(<T>...A) returns a List representation of A", "label": {"api": {"Arrays.asList(<T>...A)": [[11, 32]], "List": [[20, 23], [44, 47]]}}}, {"text": "The returned object here is a List backed by an array, but is not an ArrayList object", "label": {"api": {"List": [[30, 33], [74, 77]], "ArrayList": [[69, 77]]}}}, {"text": "I'm looking for the differences between the object Arrays.asList() returns and an ArrayList object-- a quick source to tell these without diving into the code", "label": {"api": {"List": [[60, 63], [87, 90]], "Arrays.asList()": [[51, 65]], "ArrayList": [[82, 90]]}}}, {"text": "If you only need to do comparison based on equality (equals method) then you can use the remove(Object o) method of a BlockingQueue to remove the object", "label": {"api": {"remove(Object o)": [[89, 104]]}}}, {"text": "ArrayBlockingQueue and LinkedBlockingQueue both have iterators that support remove, and in fact the implementation of ArrayBlockingQueue.remove(Object o) simply calls and uses its own iterator and iterator.remove", "label": {"api": {"remove(Object o)": [[137, 152]]}}}, {"text": "From the docs for fillRect() (with my empasis)", "label": {"api": {"fillRect()": [[18, 27]]}}}, {"text": "I actually used the Calendar class to figure this out", "label": {"api": {"Calendar": [[20, 27]]}}}, {"text": "The Oracle docs for String.hashCode specify a fixed formula for calculation the hash", "label": {"api": {"Oracle docs for String.hashCode": [[4, 34]]}}}, {"text": "Incindentally, in Java 8 there is a Long.hashCode(long) static method that does just that", "label": {"api": {"Long.hashCode(long)": [[36, 54]]}}}, {"text": "Note that there is already a convenience class containing some ready-to-use bootstrap methods for dynamic constants", "label": {"api": {"convenience class": [[29, 45]]}}}, {"text": "Here is Java 8 solution implemented by Date & Time API", "label": {"api": {"Date & Time API": [[39, 53]]}}}, {"text": "Look at the central Files class", "label": {"api": {"Files": [[20, 24]]}}}, {"text": "You probably want to use DatabaseMetaData.getSQLKeywords()", "label": {"api": {"DatabaseMetaData.getSQLKeywords()": [[25, 57]]}}}, {"text": "ResultSet.getString() will return a String object and ResultSet.getInt() returns an int value", "label": {"api": {"ResultSet.getInt()": [[54, 71]]}}}, {"text": "ResultSet.getInt() will only work if the underlying SQL datatype is a number and it fits into an int", "label": {"api": {"ResultSet.getInt()": [[0, 17]]}}}, {"text": "null values are not really a concern because the javadoc of ResultSet.getInt() states that the value 0 is returned if the data is SQL NULL (altough this may not be what you want)", "label": {"api": {"ResultSet.getInt()": [[60, 77]]}}}, {"text": "For reference, see MouseListener interface and MouseAdapter class", "label": {"api": {"MouseListener interface": [[19, 41]], "MouseAdapter class": [[47, 64]]}}}, {"text": "You may use String#endsWith", "label": {"api": {"String#endsWith": [[12, 26]]}}}, {"text": "The API documentation for java.sql.Clob says", "label": {"api": {"API documentation for java.sql.Clob": [[4, 38]]}}}, {"text": "If you want to intercept the HTTP request you need to use a Servlet Filter", "label": {"api": {"Filter": [[68, 73]]}}}, {"text": "In order to replace the URL you have to get the Dispatcher for the new URL, and then dispatch the request again with the forward() method", "label": {"api": {"get the Dispatcher": [[40, 57]], "forward()": [[121, 129]]}}}, {"text": "The way around this is to wrap the request and have a proxy object that handles this, by extending HttpServletRequestWrapper", "label": {"api": {"HttpServletRequestWrapper": [[99, 123]], "HttpServletRequest": [[99, 116]]}}}, {"text": "It already implements the HttpServletRequest so you shouldn't have any issues using it wherever you are interacting with the original servlet request", "label": {"api": {"HttpServletRequest": [[26, 43]]}}}, {"text": "You can simply extend it and add your own method like addHeader() and keep an internal Map or something of the extra artificial headers you are adding", "label": {"api": {"Map": [[87, 89]]}}}, {"text": "Then you have to just override getHeaderNames() and getHeader() to also combine the original headers with your own extra ones", "label": {"api": {"getHeaderNames()": [[31, 46]], "getHeader()": [[52, 62]]}}}, {"text": "The last thing you will need to do is wrap your original servletRequest in your new wrappedServletRequest in your Filter", "label": {"api": {"Filter": [[114, 119]]}}}, {"text": "So something like this (where WrappedServletRequest is your new implementation that extends HttpServletRequestWrapper)", "label": {"api": {"HttpServletRequestWrapper": [[92, 116]], "HttpServletRequest": [[92, 109]]}}}, {"text": "Remember to add your <filter> and <filter-mapping> of your Filter in your web.xml for it to work", "label": {"api": {"Filter": [[59, 64]]}}}, {"text": "You should use System.nanoTime() instead", "label": {"api": {"System.nanoTime()": [[15, 31]]}}}, {"text": "This code will use a Scanner to read one word, and then skip the rest of the line by reading the line and not storing it", "label": {"api": {"Scanner": [[21, 27]]}}}, {"text": "According to this javadoc Applet you may use start() and stop() to start or stop the game main loop", "label": {"api": {"Applet": [[26, 31]]}}}, {"text": "Applet run the main loop called by start()", "label": {"api": {"Applet": [[0, 5]]}}}, {"text": "You will find more detail in the Applet Javadoc", "label": {"api": {"Applet": [[33, 38]]}}}, {"text": "To alter this behavior, implement your own ErrorHandler and register it with your validator", "label": {"api": {"ErrorHandler": [[43, 54]]}}}, {"text": "Don't reinvent the wheel - Double can already do this for you", "label": {"api": {"Double": [[27, 32]]}}}, {"text": "What you can do, however, is use a ArrayList, e.g", "label": {"api": {"ArrayList": [[35, 43]]}}}, {"text": "The Class<T> class has a cast method which can cast any object to its own type T", "label": {"api": {"cast": [[25, 28], [47, 50]]}}}, {"text": "Obviously it will throw a ClassCastException if the object cannot be cast to that type", "label": {"api": {"cast": [[69, 72]]}}}, {"text": "It is syntactic sugar for iteration over objects that implement Iterable, which in turn creates an Iterator", "label": {"api": {"Iterable": [[64, 71]]}}}, {"text": "The javadoc for FileSystems.getDefault() says I need to set a system property, but when I try to do that I get a NoSuchMethodException", "label": {"api": {"FileSystems.getDefault()": [[16, 39]]}}}, {"text": "The javadoc of FileSystems.getDefault() states that", "label": {"api": {"FileSystems.getDefault()": [[15, 38]]}}}, {"text": "My domain Objects are enhanced using lombok, which generates the java.beans @ConstructorProperties annotation for the constructors of immutable objects", "label": {"api": {"@ConstructorProperties": [[76, 97]]}}}, {"text": "So check first that your window manager supports transparent windows (with GraphicsDevice#isWindowTranslucencySupported())", "label": {"api": {"GraphicsDevice#isWindowTranslucencySupported()": [[75, 120]]}}}, {"text": "You can use java.net.HttpURLConnection to send SOAP messages", "label": {"api": {"java.net.HttpURLConnection": [[12, 37]]}}}, {"text": "From the JavaDoc for InputStream", "label": {"api": {"JavaDoc for InputStream": [[9, 31]]}}}, {"text": "Also, when you want to make sure at compile time that some references belong to a specific class, as used in Collections#checkedXxx", "label": {"api": {"Collections#checkedXxx": [[109, 130]]}}}, {"text": "For further reference, see the Formatter javadocs, which gives more detail about how to format your strings and pass in variables", "label": {"api": {"Formatter javadocs": [[31, 48]]}}}, {"text": "Preferences makes a best effort to persist updated values", "label": {"api": {"Preferences": [[0, 10]]}}}, {"text": "You also need to set up a WatchService on the local filesystem to receive notification of file creation", "label": {"api": {"WatchService": [[26, 37]]}}}, {"text": "The getBytes() method doesn't do what you think it does", "label": {"api": {"getBytes() method": [[4, 20]]}}}, {"text": "If you're using Swing, you can use SwingUtilities.invokeLater(Runnable) or SwingUtilities.invokeAndWait(Runnable) to execute a Runnable on the event thread", "label": {"api": {"SwingUtilities.invokeLater(Runnable)": [[35, 70]], "SwingUtilities.invokeAndWait(Runnable)": [[75, 112]]}}}, {"text": "Add a ChangeListener and set your label there", "label": {"api": {"Add a ChangeListener": [[0, 19]]}}}, {"text": "I would personally sort my hand, then count the incidences of each card", "label": {"api": {"sort": [[19, 22]]}}}, {"text": "I'd again sort my hand", "label": {"api": {"sort": [[10, 13]]}}}, {"text": "Java already implements this in Integer class through the static factory method Integer#valueOf method and the internal IntegerCache class that holds by default Integers from -128 til 127", "label": {"api": {"Integer": [[32, 38], [80, 86], [120, 126], [161, 167]], "Integer#valueOf": [[80, 94]]}}}, {"text": "There is a SceneProperty you can monitor to see if the scene attached to a window changes", "label": {"api": {"SceneProperty": [[11, 23]]}}}]