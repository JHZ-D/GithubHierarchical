[{"text": "The Scanner has a method to check if the next token is an integer", "label": {"api": {"Scanner": [[4, 10]]}}}, {"text": "Scanner#next() will always return the next token, which will just be \"Somewhat\"", "label": {"api": {"Scanner#next()": [[0, 13]]}}}, {"text": "Use keyboard.nextLine() instead", "label": {"api": {"keyboard.nextLine()": [[4, 22]]}}}, {"text": "You can create a BigDecimal out of an integer using the BigDecimal(int) constructor, as in new BigDecimal(1) or BigDecimal.ONE (thanks, Herp Derpington)", "label": {"api": {"the BigDecimal(int) constructor": [[52, 82]]}}}, {"text": "divide, in particular, offers a number of method overloads that allow you to choose the way that the number is rounded or scaledâ€”which is one of its advantages over the built-in floating-point division; if you encounter trouble, you may want to specify ROUND_TO_EVEN, which best matches the IEEE 754 behavior in the Java Language spec", "label": {"api": {"ROUND_TO_EVEN": [[253, 265]]}}}, {"text": "If you look at a class that implements Comparable, you'll see that it actually (should) implement Comparable<T>, where T is the class itself", "label": {"api": {"Comparable": [[39, 48], [98, 107]]}}}, {"text": "It makes sense if you think about the type paramter passed to the Comparable interface and how it's used in the compareTo() method", "label": {"api": {"Comparable": [[66, 75]], "compareTo()": [[112, 122]]}}}, {"text": "As PM 77-1 has eloquently pointed out, the super keyword allows for either the class, T, or one of its parents to implement Comparable", "label": {"api": {"Comparable": [[124, 133]]}}}, {"text": "super T> is more obvious in the overloaded version of Collections.sort() that takes a Comparator<", "label": {"api": {"the overloaded version of Collections.sort()": [[28, 71]]}}}, {"text": "The code I am using to test (which was originally obtained from http://docs.oracle.com/javase/8/javafx/api/javafx/application/Application.html) will be updated according to the edits above", "label": {"api": {"http://docs.oracle.com/javase/8/javafx/api/javafx/application/Application.html": [[64, 141]]}}}, {"text": "Say you had a PreparedStatement like", "label": {"api": {"PreparedStatement": [[14, 30]]}}}, {"text": "where Postgresql.DEFAULT is a special placeholder instance, since there doesn't seem to be a setDefault() method for PreparedStatement", "label": {"api": {"PreparedStatement": [[117, 133]]}}}, {"text": "You can also use filter() in java-8", "label": {"api": {"filter()": [[17, 24]]}}}, {"text": "For the \"icons\" panel you could use a JToolBar", "label": {"api": {"JToolBar": [[38, 45]]}}}, {"text": "As an alternative you could use a JTabbedPane and the tab placement to be on the left like this", "label": {"api": {"JTabbedPane": [[34, 44]]}}}, {"text": "Use setUserData and getUserData to store and retrieve custom values in Nodes", "label": {"api": {"setUserData": [[4, 14]], "getUserData": [[20, 30]]}}}, {"text": "The parameter type of getConstructor() is Class<?>..., which employs the varargs syntax, which is syntactic sugar that automatically converts a list of elements of any size (including zero) to an array", "label": {"api": {"getConstructor()": [[22, 37]]}}}, {"text": "The current standard is Java's Non-blocking IO framework which abstracts each network connection in form of a Channel and groups them under a Selector which finds out which channels are currently ready to receive data or which just received data which can be retrieved by your code", "label": {"api": {"Channel": [[110, 116]], "Selector": [[142, 149]]}}}, {"text": "Try to use a JFormattedTextField  with the corresponding NumberFormat", "label": {"api": {"NumberFormat": [[57, 68]]}}}, {"text": "If you like to read up on it to get a better understanding here is a link NullPointerException Documentation, also it would help to post some of your code", "label": {"api": {"NullPointerException Documentation": [[74, 107]]}}}, {"text": "To truly synchronise between two threads you could use the same mechanism but use a SynchronousQueue instead", "label": {"api": {"SynchronousQueue": [[84, 99]]}}}, {"text": "However, it doesn't match the entire input, so you can't use matches()", "label": {"api": {"matches()": [[61, 69]]}}}, {"text": "Change it to find(), which only tries to find a matching subsequence", "label": {"api": {"find()": [[13, 18]]}}}, {"text": "Instead you should use a Pattern and a Matcher", "label": {"api": {"Pattern": [[25, 31]], "Matcher": [[39, 45]]}}}, {"text": "I have a class that implements Serializable", "label": {"api": {"Serializable": [[31, 42]]}}}, {"text": "Consider a Name class that is Serializable", "label": {"api": {"Serializable": [[30, 41]]}}}, {"text": "I want to add that this would be a lot easier if you would use Collections (for example an ArrayList), I highly recommend using them instead of Arrays if performance is not a huge factor", "label": {"api": {"ArrayList": [[91, 99]]}}}, {"text": "A static instance of NumberFormat will be shared by all instances of your TableCellRenderer", "label": {"api": {"NumberFormat": [[21, 32]]}}}, {"text": "Swing is not thread safe nor are the formatters, NumberFormat and DateFormat, for example", "label": {"api": {"NumberFormat": [[49, 60]], "DateFormat": [[66, 75]]}}}, {"text": "Runtime.exec does not execute the given command in a shell, so redirection via < and > will not work as you expect", "label": {"api": {"Runtime.exec": [[0, 11]]}}}, {"text": "Use the getOutputStream and getInputStream methods of the Process object returned by exec instead", "label": {"api": {"getOutputStream": [[8, 22]], "getInputStream": [[28, 41]]}}}, {"text": "getOutputStream returns the standard input stream of the subprocess (which is of type java.io.OutputStream) while getInputStream returns the standard output stream of the subprocess (which is of type java.io.InputStream)", "label": {"api": {"getOutputStream": [[0, 14]], "getInputStream": [[114, 127]]}}}, {"text": "The method getDeclaringClass() of Enum class is looking up first whether the enum value is an enum value, i.e., it's super is Enum", "label": {"api": {"Enum": [[34, 37], [126, 129]]}}}, {"text": "How can an instance that the getDeclaringClass() method runs on can NOT be an instanceof the Enum class", "label": {"api": {"Enum": [[93, 96]]}}}, {"text": "An enum type can not be extended, so the only super-class of an enum class is Enum", "label": {"api": {"Enum": [[78, 81]]}}}, {"text": "Dirs is a sub-class of Enum", "label": {"api": {"Enum": [[23, 26]]}}}, {"text": "The source code of getDeclaringClass() suggests that there can be cases that NORTH here can have a superclass other than Enum", "label": {"api": {"Enum": [[121, 124]]}}}, {"text": "Simply use Random.ints which returns an IntStream", "label": {"api": {"Random.ints": [[11, 21]], "IntStream": [[40, 48]]}}}, {"text": "The equals() method on ZonedDateTime requires that all component parts of the object are equal", "label": {"api": {"method": [[13, 18]]}}}, {"text": "Since a ZoneOffset is not equal to a ZoneRegion (even though both are subclasses of ZoneId), the method returns false", "label": {"api": {"method": [[97, 102]]}}}, {"text": "The isEqual method only compares the instant on the time-line, which may or may not be what you want", "label": {"api": {"method": [[12, 17]]}}}, {"text": "You can also use the timeLineOrder() method to compare two ZoneDateTime only using the time-line", "label": {"api": {"method": [[37, 42]]}}}, {"text": "One thing that might be of use to you is ObjectReference.disableCollection(), which signals the debugged JVM to never collect that object", "label": {"api": {"ObjectReference.disableCollection()": [[41, 75]]}}}, {"text": "When you supply a specific, hard-coded seed, to the one-arg Random constructor, the random numbers that will be generated will always be the same, every time you run the program", "label": {"api": {"one-arg Random constructor": [[52, 77]], "Random constructor": [[60, 77]]}}}, {"text": "However, when you don't supply a seed, then the Random constructor will choose a seed for you, based on System.nanoTime", "label": {"api": {"Random constructor": [[48, 65]]}}}, {"text": "Using an ArrayList instead of arrays would be the easiest way to accomplish exactly what you are trying to do", "label": {"api": {"ArrayList": [[9, 17]]}}}, {"text": "Have a look at the MessageFormat class", "label": {"api": {"MessageFormat": [[19, 31]]}}}, {"text": "Closing a ByteArrayOutputStream has no effect", "label": {"api": {"ByteArrayOutputStream": [[10, 30]]}}}, {"text": "And that is true now for Streams where the documentation makes clear", "label": {"api": {"documentation makes clear": [[43, 67]]}}}, {"text": "If you want to print it in hex, I propose to use String.format()", "label": {"api": {"String.format()": [[49, 63]]}}}, {"text": "The first is there is no Collection.get method", "label": {"api": {"is no Collection.get method": [[19, 45]]}}}, {"text": "Instead of taking a Collection<Double>, take a List<Double> instead (an ArrayList conforms to List)", "label": {"api": {"a List<Double>": [[45, 58]]}}}, {"text": "I don't think javac would allow \"...\".getBytes() + String as it is a byte[] + String", "label": {"api": {"getBytes()": [[38, 47]]}}}, {"text": "either use a PrintStream over your Stream", "label": {"api": {"PrintStream": [[13, 23]]}}}, {"text": "I use getBytes(Charset) and not getBytes(), but that depends on your process (eg", "label": {"api": {"getBytes(Charset)": [[6, 22]], "getBytes()": [[32, 41]]}}}, {"text": "You must however remember that Java String are Unicode sequence and thus, getBytes() might use Windows cp1252 (default on Windows)", "label": {"api": {"getBytes()": [[74, 83]]}}}, {"text": "I did not check in the PrintStream source code, but if it use getBytes() without a Charset, then use you should use a OutputStreamWriter with appropriate charset", "label": {"api": {"PrintStream": [[23, 33]], "getBytes()": [[62, 71]], "OutputStreamWriter": [[118, 135]]}}}, {"text": "Use Arrays.hashCode(int[]) to get a hash code based on the array contents", "label": {"api": {"Arrays.hashCode(int[])": [[4, 25]]}}}, {"text": "If you want to see the values being set at the sessions you can use HttpSessionAttributeListener objects to receive events when the code sets some value to the session or removes it", "label": {"api": {"HttpSessionAttributeListener": [[68, 95]]}}}, {"text": "You don't say, but my guess is that your code is not compiling because class Solocomparator does not actually implement the methods required by the Comparator interface", "label": {"api": {"Comparator": [[148, 157]]}}}, {"text": "You seem to be confusing Comparator with Comparable", "label": {"api": {"Comparator": [[25, 34]], "Comparable": [[41, 50]]}}}, {"text": "A Comparator compares two objects that are distinct from the comparator", "label": {"api": {"Comparator": [[2, 11]]}}}, {"text": "A Comparable object, on the other hand, is one that knows how to compare itself to another object of the same type", "label": {"api": {"Comparable": [[2, 11]]}}}, {"text": "This is what you've written, so you probably want your class to implement Comparable<Solocomparator>, not Comparator<Solocomparator>", "label": {"api": {"Comparator": [[106, 115]], "Comparable": [[74, 83]]}}}, {"text": "If you want to implement a Comparator<Solocomparator>, then remove the comparison code from Solocomparator and put it in a separate class", "label": {"api": {"Comparator": [[27, 36]]}}}, {"text": "Here is Java 8 solution by java.time", "label": {"api": {"java.time": [[27, 35]]}}}, {"text": "See the API documentation", "label": {"api": {"API documentation": [[8, 24]]}}}, {"text": "We have to just use class Integer (Integer javadoc)", "label": {"api": {"Integer javadoc": [[35, 49]]}}}, {"text": "The method you're looking for is Character.digit(char ch, int radix)", "label": {"api": {"Character.digit(char ch, int radix)": [[33, 67]]}}}, {"text": "Use File#listFiles(FilenameFilter) instead of File#listFiles()", "label": {"api": {"File#listFiles(FilenameFilter)": [[4, 33]]}}}, {"text": "The sub-interface SortedMap defines that all keys must be naturally ordered and adds new methods like subMap to access value ranges", "label": {"api": {"SortedMap": [[18, 26]], "subMap": [[102, 107]]}}}, {"text": "The sub-sub-interface NavigableMap adds even more", "label": {"api": {"NavigableMap": [[22, 33]]}}}, {"text": "The most prominent implementation in Java's standard library of SortedMap is TreeMap", "label": {"api": {"SortedMap": [[64, 72]], "TreeMap": [[77, 83]]}}}, {"text": "I used BufferedReader because he will take care about line separators, but you can also use #split method, and write the resulting tokens", "label": {"api": {"#split": [[92, 97]]}}}, {"text": "Well, to understand the concept of Serializable Class and its serialVersionUID, best place would be reading its complete java doc(java.io.Serializable), which explains with proper example", "label": {"api": {"java.io.Serializable": [[130, 149]]}}}, {"text": "The problem is that Integer.parseInt without a radix will interpret the string as a decimal number, not binary", "label": {"api": {"Integer.parseInt": [[20, 35]]}}}, {"text": "Pass in a radix of 2 (binary) to Integer.parseInt", "label": {"api": {"Integer.parseInt": [[33, 48]]}}}, {"text": "Converting to String in any radix use BigInteger.toString(int radix)", "label": {"api": {"BigInteger.toString(int radix)": [[38, 67]]}}}, {"text": "For parsing use new BigInteger(String s, int radix)", "label": {"api": {"new BigInteger(String s, int radix)": [[16, 50]]}}}, {"text": "You can use one of the classes which is designed to read in a line at a time, such as BufferedReader", "label": {"api": {"BufferedReader": [[86, 99]]}}}, {"text": "Right now, i'm using theTime.split(\":\"), theTime is a String holding \"11:34\" here, parsing the integers on each side and doing the calculation", "label": {"api": {"Time": [[24, 27], [44, 47]]}}}, {"text": "I saw Time but what I'm doing right now seemed more direct", "label": {"api": {"Time": [[6, 9]]}}}, {"text": "Nothing in Systems either", "label": {"api": {"Systems": [[11, 17]]}}}, {"text": "You can use SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "You should probably have a look at how MouseEvent is defined in Swing", "label": {"api": {"MouseEvent": [[39, 48]]}}}, {"text": "Use a PreparedStatement", "label": {"api": {"PreparedStatement": [[6, 22]]}}}, {"text": "In order to specify the namespace prefix, you can add the @XmlSchema annotation to a package-info.java file like this", "label": {"api": {"@XmlSchema": [[58, 67]]}}}, {"text": "I'm not sure what you're asking, but it kind of sounds like you're describing Arrays.copyOf or Arrays.copyOfRange", "label": {"api": {"Arrays.copyOf": [[78, 90], [95, 107]], "Arrays.copyOfRange": [[95, 112]]}}}, {"text": "For example, look at Arrays.copyOfRange", "label": {"api": {"Arrays.copyOfRange": [[21, 38]]}}}, {"text": "The closest thing is probably the CachedRowSet", "label": {"api": {"CachedRowSet": [[34, 45]]}}}, {"text": "Use Arrays.copyOfRange to get an array without the first element (front) as follows", "label": {"api": {"Arrays.copyOfRange": [[4, 21]]}}}, {"text": "You need to use mkdirs() instead, it will create all parent directories", "label": {"api": {"mkdirs()": [[16, 23]]}}}, {"text": "You could use a mutex and a condition variable, called Lock and Condition in Java (or you could use Java's wait and notify too, together with synchronized)", "label": {"api": {"Lock": [[55, 58]], "Condition": [[64, 72]]}}}, {"text": "But this is a bit more code, potentially a bit less efficient (especially if all waiters are woken up instead of just one), and also Java Condition does not provide a way to have fair queuing, while Semaphore has the fairness boolean property, so waiters are served in order", "label": {"api": {"Condition": [[138, 146]]}}}, {"text": "Then a really much worse alternative would be to have just a Lock or a synchronized block, then in a loop check if item is available and take it if possible, otherwise (optionally) sleep a bit, then try again", "label": {"api": {"Lock": [[61, 64]]}}}, {"text": "For example you can use File.listFiles(FileFilter filter) in the model", "label": {"api": {"File.listFiles(FileFilter filter)": [[24, 56]]}}}, {"text": "Otherwise if you are using Java 8 take a look at IntStream.rangeClosed", "label": {"api": {"IntStream.rangeClosed": [[49, 69]]}}}, {"text": "You could let the Scanner use \"D\" as the delimiter", "label": {"api": {"the Scanner use \"D\" as the delimiter": [[14, 49]]}}}, {"text": "Looking at the documentation for InetAddress, I don't see any public constructors", "label": {"api": {"the documentation for InetAddress": [[11, 43]]}}}, {"text": "You could have your TaskManager.newRepeatingTask accept a Consumer<UUID>", "label": {"api": {"Consumer": [[58, 65]]}}}, {"text": "The Elements object implements List<Element> and therefore has an Iterator<Element>", "label": {"api": {"List": [[31, 34]]}}}, {"text": "You can think of the Elements object that jsoup provides as effectively the equivalent to a List containing Element objects", "label": {"api": {"List": [[92, 95]]}}}, {"text": "I recommend go reading the documentation on Scanners", "label": {"api": {"Scanners": [[44, 51]]}}}, {"text": "The IllegalStateException is a good candidate", "label": {"api": {"IllegalStateException": [[4, 24]]}}}, {"text": "If your stuff, something and otherStuff are all related to your method arguments, you could also use IllegalArgumentException, like", "label": {"api": {"IllegalArgumentException": [[101, 124]]}}}, {"text": "You can use String.substring(int, int) with String.indexOf(String)", "label": {"api": {"String.substring(int, int)": [[12, 37]], "String.indexOf(String)": [[44, 65]]}}}, {"text": "It sounds like you are looking for the @OneToOne annotation, which also has the ability to specify if the relationship is optional", "label": {"api": {"@OneToOne annotation": [[39, 58]], "optional": [[122, 129]]}}}, {"text": "This class supports converting a String into a color with the method decode", "label": {"api": {"decode": [[69, 74]]}}}, {"text": "One approach would be to use a ThreadPoolExecutor with a core size of 1, a starting maximum pool size of 4, then adjust the maximum pool size dynamically, based on memory and CPU usage", "label": {"api": {"ThreadPoolExecutor": [[31, 48]], "core size": [[57, 65]], "maximum pool size": [[84, 100], [124, 140]]}}}, {"text": "...And the reason for that is because you're using Scanner#next(), which will only ever consume up until the next whitespace value", "label": {"api": {"up until the next whitespace value": [[96, 129]]}}}, {"text": "Do include any other content in current response you can use RequestDispatcher as show below", "label": {"api": {"RequestDispatcher": [[61, 77]]}}}, {"text": "JavaDoc of identityHashCode() Says", "label": {"api": {"identityHashCode()": [[11, 28]]}}}, {"text": "If you have overridden hashCode() method in your class, then calling identityHashCode() will invoke default hashCode() method, not your overridden method", "label": {"api": {"identityHashCode()": [[69, 86]]}}}, {"text": "writing the code in the natural way would throw a NullPointerException exception if the input is null hence the condition should be written more defensive like", "label": {"api": {"NullPointerException": [[50, 69]]}}}, {"text": "You can use @XmlElements or @XmlElementRefs", "label": {"api": {"@XmlElements": [[12, 23]], "@XmlElementRefs": [[28, 42]]}}}, {"text": "Since your subsequent line involves invoking the Time constructor, you don't need to scale the time to days by dividing with 24 * 60 * 60 * 1000 as you have done", "label": {"api": {"Time constructor": [[49, 64]]}}}, {"text": "Use a DecimalFormat object to format your number", "label": {"api": {"DecimalFormat": [[6, 18]]}}}, {"text": "As such, you need to invoke matcher.find() again within that context to be able to invoke matcher.group(), otherwise it will throw an IllegalStateException - see API", "label": {"api": {"API": [[162, 164]]}}}, {"text": "Also, this approach uses HttpHeaders to get the request headers (in which the user ID and token are stored)", "label": {"api": {"HttpHeaders": [[25, 35]]}}}, {"text": "This can be achieved using the javax.management.DescriptorKey", "label": {"api": {"javax.management.DescriptorKey": [[31, 60]]}}}, {"text": "For example, using a code sample that I adapted for this, using a standard mbean", "label": {"api": {"standard mbean": [[66, 79]]}}}, {"text": "Likely you are extending JFrame which means that the class will inherit the methods from JFrame", "label": {"api": {"JFrame": [[25, 30], [89, 94]]}}}, {"text": "In the above example, there is no need to use frame.getContentPane() because you are inheriting the methods of JFrame", "label": {"api": {"JFrame": [[111, 116]]}}}, {"text": "Alternatively, in most cases you should actually be instantiating a new JFrame as an instance variable unless you are actually adding new functionality to the JFrame class", "label": {"api": {"JFrame": [[72, 77], [159, 164]]}}}, {"text": "Use sc.next() for a token, or sc.nextLine() for a full line", "label": {"api": {"sc.next()": [[4, 12]], "sc.nextLine()": [[30, 42]]}}}, {"text": "Use a HashSet", "label": {"api": {"HashSet": [[6, 12]]}}}, {"text": "To set a child of GridPane aligned to center, you need to set the Halignment and Valignment of the child node", "label": {"api": {"Halignment": [[66, 75]], "Valignment": [[81, 90]]}}}, {"text": "Instead of adding a halignment / valignment to the node, you can create a ColumnConstraints or a RowConstraints and add them to the GridPane", "label": {"api": {"ColumnConstraints": [[74, 90]], "RowConstraints": [[97, 110]]}}}, {"text": "You can similarly add RowConstraints as well", "label": {"api": {"RowConstraints": [[22, 35]]}}}, {"text": "From Java API, indexOf returns -1 if the given character is not found within the string", "label": {"api": {"Java API": [[5, 12]]}}}, {"text": "This approach (except for using firePropertyChange on a custom property) is covered in the SwingWorker class documentation, as PrimeNumbersTask", "label": {"api": {"firePropertyChange": [[32, 49]], "SwingWorker class documentation": [[91, 121]]}}}, {"text": "You should use a scheduled executor", "label": {"api": {"scheduled executor": [[17, 34]]}}}, {"text": "You can run a task at fixed rate using ScheduledExecutorService and stop it on some action (here by reading System.in)", "label": {"api": {"ScheduledExecutorService": [[39, 62]]}}}, {"text": "Read the Java doc for Rectangle (http://docs.oracle.com/javase/7/docs/api/java/awt/Rectangle.html#equals(java.lang.Object) )", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/awt/Rectangle.html#equals(java.lang.Object)": [[33, 121]]}}}, {"text": "The javadoc for Class.isInstance(Object obj) gives the definition of assignment compatible", "label": {"api": {"Class.isInstance(Object obj)": [[16, 43]]}}}, {"text": "To run a task after some time, you should use a Timer, which is a \"A facility for threads to schedule tasks for future execution in a background thread", "label": {"api": {"Timer": [[48, 52]]}}}, {"text": "Use a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "If you cannot use Java 8 for some reason, use anonymous implementations of Runnable instead of Lambda expressions", "label": {"api": {"Runnable": [[75, 82]]}}}, {"text": "However note that you can achieve finer and more precise column alignment by using a format string", "label": {"api": {"format string": [[85, 97]]}}}, {"text": "The documentation for the PrintWriter.print(int) method says", "label": {"api": {"PrintWriter.print(int)": [[26, 47]]}}}, {"text": "The documented behaviour makes no sense if the PrintWriter delegates to another Writer (as created by the constructor PrintWriter(Writer))", "label": {"api": {"PrintWriter(Writer)": [[118, 136]]}}}, {"text": "The claimed behaviour would be surprising for the case of a PrinterWriter that was constructed using a named character encoding (using the constructor PrintWriter(File, String))", "label": {"api": {"PrintWriter(File, String)": [[151, 175]]}}}, {"text": "Define a class with your common fields and mark it as @Embeddable", "label": {"api": {"@Embeddable": [[54, 64]]}}}, {"text": "In the containing Entity, add a reference to the \"embeddable\" class, and mark the reference as @Embedded or @EmbeddedId, whatever applies", "label": {"api": {"@Embedded": [[95, 103], [108, 116]], "@EmbeddedId": [[108, 118]]}}}, {"text": "When applicable, mark the reference with additional @AttributeOverrides or @AssociationOverrides to customize the mapping", "label": {"api": {"@AttributeOverrides": [[52, 70]], "@AssociationOverrides": [[75, 95]]}}}, {"text": "The main problem I see with @MappedSuperclass (the approach used in your linked post) is that you can only have a superclass per entity", "label": {"api": {"@MappedSuperclass": [[28, 44]]}}}, {"text": "Embedding gives you the flexibility to combine as many @Embeddables as you want", "label": {"api": {"@Embeddable": [[55, 65]]}}}, {"text": "In the end, if you know your model is simple, @MappedSuperclass will do the trick", "label": {"api": {"@MappedSuperclass": [[46, 62]]}}}, {"text": "If you have a complex model you can benefit from @Embeddable and @Embedded", "label": {"api": {"@Embeddable": [[49, 59]], "@Embedded": [[65, 73]]}}}, {"text": "On my application, when a user is merged, the profiles are updated on database", "label": {"api": {"merged": [[34, 39]]}}}, {"text": "However, when a profile is merged, the users are not updated", "label": {"api": {"merged": [[27, 32]]}}}, {"text": "I am using a ThreadPoolExecutor along with a custom ThreadFactory and Thread to handle a series of tasks", "label": {"api": {"ThreadPoolExecutor": [[13, 30]]}}}, {"text": "My issue is that once the ThreadPoolExecutor decides to reduce its pool size and terminates a thread I need to do some cleanup of that Communicator object", "label": {"api": {"ThreadPoolExecutor": [[26, 43]]}}}, {"text": "What is the best way to handle cleaning up a Thread when a ThreadPoolExecutor decides to terminate it", "label": {"api": {"ThreadPoolExecutor": [[59, 76]]}}}, {"text": "This method is synchronized so you get the overhead of parallelising your tasks + the overhead of contention but no parallel processing", "label": {"api": {"synchronized": [[15, 26]]}}}, {"text": "If you try with a ThreadLocalRandom instead you should see a performance improvement", "label": {"api": {"a ThreadLocalRandom": [[16, 34]]}}}, {"text": "When I was working with CDI, I could use the @Produces annotation to create a producer method to be called to choose which bean that implemented an interface would be injected by the @Inject annotation", "label": {"api": {"@Produces": [[45, 53]]}}}, {"text": "What I need to use to achieve the same result I had with the @Produces annotation in CDI when I use the @Autowired annotation", "label": {"api": {"@Produces": [[61, 69]]}}}, {"text": "Please take a look at this example using an ExecutorService and Callable tasks organized according to your given tree structure", "label": {"api": {"ExecutorService": [[44, 58]], "Callable": [[64, 71]]}}}, {"text": "However, if the task structure is not static or not known in advance, you might want to implement your own task tree structure (with CallableNode objects for example) and use an ExecutorService to go through that tree and execute the tasks according to its structure", "label": {"api": {"ExecutorService": [[178, 192]], "Callable": [[133, 140]]}}}, {"text": "It's converting the int to an Integer, which is an object", "label": {"api": {"Integer": [[30, 36]]}}}, {"text": "I am thinking of using TreeSet", "label": {"api": {"TreeSet": [[23, 29]]}}}, {"text": "I can use headSet, but I need to know N+1 th element", "label": {"api": {"headSet": [[10, 16]]}}}, {"text": "Maybe you can do it with Comparator#comparingDouble", "label": {"api": {"Comparator#comparingDouble": [[25, 50]]}}}, {"text": "Note that there is also the java.awt.Color class that can be instantiated with the int returned by getRGB and provides getRed, getGreen and getBlue methods if you don't want to do the bit manipulations yourself", "label": {"api": {"java.awt.Color": [[28, 41]]}}}, {"text": "You simply add an ActionListener to the button", "label": {"api": {"ActionListener": [[18, 31]]}}}, {"text": "Your best bet in the standard library is the Desktop class", "label": {"api": {"Desktop": [[45, 51]]}}}, {"text": "You can check if this is supported with the Desktop.isSupported(Desktop.Action.MAIL) call", "label": {"api": {"Desktop": [[44, 50], [64, 70]]}}}, {"text": "Instead you can use the DateFormat.parse(String source, ParsePosition pos) to validate", "label": {"api": {"DateFormat.parse(String source, ParsePosition pos)": [[24, 73]]}}}, {"text": "From the documentation of SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[26, 41]]}}}, {"text": "If SimpleDateFormat had been stateless, or written to have its state to be thread safe then yes static final would have been enough to be thread safe", "label": {"api": {"SimpleDateFormat": [[3, 18]]}}}, {"text": "Otherwise creating a new instance of SimpleDateFormat per thread is recommended, either create a new instance as required or use ThreadLocal or a similar mechanism", "label": {"api": {"SimpleDateFormat": [[37, 52]]}}}, {"text": "Class SimpleDateFormat is not synchronized", "label": {"api": {"SimpleDateFormat": [[6, 21]]}}}, {"text": "If you want to safely reuse instances of SimpleDateFormat, consider using ThreadLocal to conveniently allow a separate instance to be using for each thread, which would allow you to remove synchronization", "label": {"api": {"ThreadLocal": [[74, 84]]}}}, {"text": "Use Math.round() on 1.35 etc and then use the result to look up the entry in the map", "label": {"api": {"Math.round()": [[4, 15]]}}}, {"text": "This only works if the map contains keys for all possible integers can Math.round() can return on your data", "label": {"api": {"Math.round()": [[71, 82]]}}}, {"text": "In that case you could use TreeMap and ceilingEntry()/floorEntry()", "label": {"api": {"TreeMap": [[27, 33]], "ceilingEntry()": [[39, 52]], "floorEntry()": [[54, 65]]}}}, {"text": "A HashSet (and HashMap) offers O(1) complexity", "label": {"api": {"HashMap": [[15, 21]]}}}, {"text": "You can read more about the concept of capacity and load factor in the Javadoc of HashMap", "label": {"api": {"HashMap": [[82, 88]]}}}, {"text": "Currently, if nothing has been entered into the Text Field and the focusLost Event is triggered, I reset focus to the Text Field", "label": {"api": {"focusLost": [[67, 75]]}}}, {"text": "If a file CAN be absent in a directory while opening it (checked FileNotFoundException), you COULD use this approach", "label": {"api": {"FileNotFoundException": [[65, 85]]}}}, {"text": "You can use the substring (Java 7) or substring (Java 8)  method in Java", "label": {"api": {"substring (Java 7)": [[16, 33]], "substring (Java 8)": [[38, 55]]}}}, {"text": "API of Component", "label": {"api": {"API of Component": [[0, 15]]}}}, {"text": "How about using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[16, 31]]}}}, {"text": "See SimpleDateFormat documentation for more details", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "If you want to store values without duplicates use a Set - a HashSet for example", "label": {"api": {"HashSet": [[61, 67]]}}}, {"text": "Just split all items, construct a Command object for each of those and send them to an ExecutorService#invokeAll", "label": {"api": {"ExecutorService#invokeAll": [[87, 111]]}}}, {"text": "Use the returned List to iterate and call Future#get() to make sure the original thread waits after all batch jobs to complete", "label": {"api": {"Future#get()": [[42, 53]]}}}, {"text": "Use java NumberFormat class", "label": {"api": {"NumberFormat": [[9, 20]]}}}, {"text": "You can also get the NumberFormat instance according to your Locale by", "label": {"api": {"NumberFormat": [[21, 32]]}}}, {"text": "I was just seeing the difference between a HashMap and HashTable", "label": {"api": {"HashTable": [[55, 63]], "HashMap": [[43, 49]], "Map": [[47, 49]]}}}, {"text": "Other than the obvious synchronized and unsynchronized difference, I noticed that HashTable extends the Dictionary class while HashMap implements Map", "label": {"api": {"HashTable": [[82, 90]], "HashMap": [[127, 133]], "Map": [[131, 133], [146, 148]]}}}, {"text": "Another option is to use ScheduledExecutorService and call ScheduledExecutorService.schedule(Callable<V> callable, long delay, TimeUnit unit)", "label": {"api": {"ScheduledExecutorService": [[25, 48], [59, 82]]}}}, {"text": "Unable to offer a code example right now but you may find a DelayQueue useful", "label": {"api": {"DelayQueue": [[60, 69]]}}}, {"text": "Essentially - you could create a DelayQueue and post a delayed item into it", "label": {"api": {"DelayQueue": [[33, 42]]}}}, {"text": "An example using built in TimeUnit", "label": {"api": {"TimeUnit": [[26, 33]]}}}, {"text": "This works well with getDeclaredFields() with an isolated set of classes", "label": {"api": {"getDeclaredFields()": [[21, 39]]}}}, {"text": "System.in represents the standard input, which means it's normally read from the keyboard", "label": {"api": {"System.in": [[0, 8]]}}}, {"text": "By the ways you can use Collections.indexOfSubList to find the window position", "label": {"api": {"Collections.indexOfSubList": [[24, 49]]}}}, {"text": "The Java-8-solution can take into account the local definition of a week using the value of a date-picker", "label": {"api": {"date-picker": [[94, 104]]}}}, {"text": "Look up the documentation of Integer.parseInt(String)", "label": {"api": {"Integer.parseInt(String)": [[29, 52]]}}}, {"text": "You should use a List instead of an array, because you don't know a priori the length for them", "label": {"api": {"List": [[17, 20]]}}}, {"text": "A List allows you to dinamically add an element as soon as you got it, so you should \"put the array\" under the user input", "label": {"api": {"List": [[2, 5]]}}}, {"text": "To print the array content you just need to iterate over the ArrayList", "label": {"api": {"List": [[66, 69]]}}}, {"text": "Read more about the Thread Class and also check out some useful examples", "label": {"api": {"Thread Class": [[20, 31]]}}}, {"text": "Since your class extends Exception, it's a checked exception", "label": {"api": {"Exception": [[25, 33]]}}}, {"text": "If you want to create an unchecked exception, you should extend RuntimeException", "label": {"api": {"Exception": [[71, 79]], "RuntimeException": [[64, 79]]}}}, {"text": "I think in your case you can use just an AtomicInteger that is shared between your tasks", "label": {"api": {"AtomicInteger": [[41, 53]]}}}, {"text": "The first one works because the number 4250120140405520712 (19 digits) is less than the maximum possible long value, Long.MAX_VALUE, 9223372036854775807L", "label": {"api": {"Long.MAX_VALUE": [[117, 130]]}}}, {"text": "Since you want to replace only one character, you should use StringBuilder#setCharAt", "label": {"api": {"StringBuilder#setCharAt": [[61, 83]]}}}, {"text": "If you \"really\" want to know when a table is sorted, you could attach a RowSorterListener to the TableRowSorter used by the table", "label": {"api": {"RowSorterListener": [[72, 88]]}}}, {"text": "You could also use the TableRowSorter#getSortKeys to see which columns are included in the sort..", "label": {"api": {"TableRowSorter#getSortKeys": [[23, 48]]}}}, {"text": "The toString() for PriorityQueue returns the elements in the order they are returned by its Iterator", "label": {"api": {"toString()": [[4, 13]]}}}, {"text": "If you read the Javadoc for PriorityQueue#iterator() you see the following", "label": {"api": {"PriorityQueue#iterator()": [[28, 51]]}}}, {"text": "If you're just trying to check whether any value matches the predict, you can use anyMatch", "label": {"api": {"anyMatch": [[82, 89]]}}}, {"text": "Instead, use a BufferedReader to read System.in; the readLine() method should be able to detect the line ending", "label": {"api": {"BufferedReader": [[15, 28]]}}}, {"text": "How accept() works", "label": {"api": {"accept()": [[4, 11]]}}}, {"text": "Use Callable instead of a Runnable, it will return a Future that you can use to retrieve the value once it is done", "label": {"api": {"Callable": [[4, 11]], "Runnable": [[26, 33]]}}}, {"text": "pass an AtomicInteger and use the set method to set value", "label": {"api": {"AtomicInteger": [[8, 20]]}}}, {"text": "If no row was matched, it then throws a StaleObjectStateException (when using Hibernate API) or an OptimisticLockException (when using JPA)", "label": {"api": {"OptimisticLockException": [[99, 121]]}}}, {"text": "However this is not efficient so I opted to use a WeakReference and double-checked locking to load the data only once", "label": {"api": {"WeakReference": [[50, 62]]}}}, {"text": "Java strings also have a lastIndexOf method which you can use", "label": {"api": {"lastIndexOf": [[25, 35]]}}}, {"text": "I guess you are after the subjectAltName field to retrieve UPN of the user", "label": {"api": {"subjectAltName": [[26, 39]]}}}, {"text": "Use Collections.sort with a custom Comparator<T>", "label": {"api": {"Comparator<T>": [[35, 47]]}}}, {"text": "Another way of coding this would be implementing the Comparable<T> interface in the interval class", "label": {"api": {"Comparable<T>": [[53, 65]]}}}, {"text": "When using a BitSet with the enum", "label": {"api": {"BitSet": [[13, 18]]}}}, {"text": "However you can better use EnumSet which is as efficient too", "label": {"api": {"EnumSet": [[27, 33]]}}}, {"text": "You can create a PriorityQueue that relies on a class's \"natural ordering\"", "label": {"api": {"create a PriorityQueue": [[8, 29]], "natural ordering": [[57, 72]]}}}, {"text": "Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering", "label": {"api": {"natural ordering": [[107, 122]]}}}, {"text": "That links to Comparable", "label": {"api": {"Comparable": [[14, 23]]}}}, {"text": "Make your Node class implement Comparable<Node>", "label": {"api": {"Comparable": [[31, 40]]}}}, {"text": "As suggested in the comments, UnsupportedOperationException might be a better choice", "label": {"api": {"UnsupportedOperationException": [[30, 58]]}}}, {"text": "There is the IllegalStateException just for that", "label": {"api": {"IllegalStateException": [[13, 33]]}}}, {"text": "As @ikh answered, your array should be a Runnable[]", "label": {"api": {"Runnable": [[41, 48]]}}}, {"text": "Runnable is an interface that defines a run() method", "label": {"api": {"Runnable": [[0, 7]]}}}, {"text": "You could use the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[18, 41]]}}}, {"text": "Then, you have to use Array#deepToString, which will get the deep nested values out of the array in a printable and representable fashion", "label": {"api": {"Array#deepToString": [[22, 39]]}}}, {"text": "For full details, take a look at the Java Documentation on wait() for an Object", "label": {"api": {"Java Documentation on wait() for an Object": [[37, 78]]}}}, {"text": "The RowFilter API actually has a small bit of very useful example code that could help you", "label": {"api": {"RowFilter API": [[4, 16]]}}}, {"text": "Use size instead of capacity, if you want to see how many items are in the stack right now", "label": {"api": {"size": [[4, 7]], "capacity": [[20, 27]]}}}, {"text": "See the Formatter documentation for details", "label": {"api": {"Formatter documentation": [[8, 30]]}}}, {"text": "Then use the PortableRemoteObject.narrow() method to cast it to your remote bean", "label": {"api": {"PortableRemoteObject.narrow()": [[13, 41]]}}}, {"text": "The best way to do this is to read the file as bytes, and then configure a specific CharsetDecoder to remove the bytes you do not want to capture", "label": {"api": {"CharsetDecoder": [[84, 97]]}}}, {"text": "Here is the document", "label": {"api": {"document": [[12, 19]]}}}, {"text": "http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html < Use this for reference", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html": [[0, 62]]}}}, {"text": "The default constructor will use a random seed", "label": {"api": {"default constructor": [[4, 22]]}}}, {"text": "When the class is asked for a random number the seed is updated", "label": {"api": {"the seed is updated": [[44, 62]]}}}, {"text": "If you need a better distribution that is also harder to predict you can use SecureRandom", "label": {"api": {"SecureRandom": [[77, 88]]}}}, {"text": "You could use the FileHandler constructor that allows you to specify the rotation, limit, and append options", "label": {"api": {"FileHandler": [[18, 28]]}}}, {"text": "The FileHandler can rotate for a number of reasons that are out of your control", "label": {"api": {"FileHandler": [[4, 14]]}}}, {"text": "If you don't want to deal with file rotation you could open a FileOutputStream and wrap that with a StreamHandler", "label": {"api": {"FileOutputStream": [[62, 77]], "StreamHandler": [[100, 112]]}}}, {"text": "you can reuse one of the interfaces available in Java class library, such as Runnable", "label": {"api": {"Runnable": [[77, 84]]}}}, {"text": "Runnable would be a good choice for you but if you need something more specific you can extend it or create your own interface", "label": {"api": {"Runnable": [[0, 7]]}}}, {"text": "I think you are looking for the Method Graphics.translate()", "label": {"api": {"Graphics.translate()": [[39, 58]]}}}, {"text": "The docs say it works the same as the instanceOf keyword", "label": {"api": {"docs say it works the same as the instanceOf": [[4, 47]]}}}, {"text": "I'd use a map", "label": {"api": {"map": [[10, 12]]}}}, {"text": "Use SimpleDateFormat to convert to Date to compare", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "According to the Inherited type class reference, You can't inherit annotations to implementing classes", "label": {"api": {"Inherited type class reference": [[17, 46]]}}}, {"text": "If it implements Comparable, you can use its compareTo method (given an expression of the appropriate type)", "label": {"api": {"compareTo": [[45, 53]]}}}, {"text": "One uses a Thread, the other uses an Activity", "label": {"api": {"Thread": [[11, 16]]}}}, {"text": "The other class which implements a Thread is this", "label": {"api": {"Thread": [[35, 40]]}}}, {"text": "How can I make sure my Thread calls the Activity", "label": {"api": {"Thread": [[23, 28]]}}}, {"text": "Look at orphanRemoval option", "label": {"api": {"orphanRemoval": [[8, 20]]}}}, {"text": "Here is complete explication about CascadeType.REMOVE and orphanRemoval", "label": {"api": {"orphanRemoval": [[58, 70]]}}}, {"text": "You can use ArrayList which support remove or add function, which actually is an resizable array", "label": {"api": {"ArrayList": [[12, 20]]}}}, {"text": "From the Matcher documentation", "label": {"api": {"Matcher documentation": [[9, 29]]}}}, {"text": "If you want to sort a List you can use Collections.sort(List, Comparator) or the Collections.sort(List) method", "label": {"api": {"Collections.sort(List, Comparator)": [[39, 72]]}}}, {"text": "With Java 7 there is a WatchService provided which can take care of the Producer problem even though it is a pain to work with", "label": {"api": {"WatchService": [[23, 34]]}}}, {"text": "Create a Future through taskThread and call get() on it", "label": {"api": {"Future": [[9, 14]], "get()": [[44, 48]]}}}, {"text": "It will block until the Future is completed", "label": {"api": {"Future": [[24, 29]]}}}, {"text": "You may want to use a TreeMap, which is ordered internally (http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html": [[60, 122]]}}}, {"text": "You can use Graphics.drawImage to do what you want - set (x,y) to be negative to shift left/up or positive to shift right/down", "label": {"api": {"Graphics.drawImage": [[12, 29]]}}}, {"text": "Swing's JFileChooser provides the setAccessory method to extend the file chooser by any Swing component, e.g", "label": {"api": {"setAccessory": [[34, 45]], "FileChooser": [[9, 19]]}}}, {"text": "Is there any similar possibility in JavaFX's FileChooser and DirectoryChooser", "label": {"api": {"FileChooser": [[45, 55]], "DirectoryChooser": [[61, 76]]}}}, {"text": "If you really want a process to be killed after 5 minutes - use a Process that can be destroyed", "label": {"api": {"Process": [[66, 72]], "destroyed": [[86, 94]]}}}, {"text": "However, this may leave files in a corrupted state, if the child Process was in the middle of I/O", "label": {"api": {"Process": [[65, 71]]}}}, {"text": "One way to defend against that situation is to make the Process the client of a database that can roll back in-progress transactions", "label": {"api": {"Process": [[56, 62]]}}}, {"text": "From official Java documentation", "label": {"api": {"official Java documentation": [[5, 31]]}}}, {"text": "This is the time to go through the official Java documentation for String, and find out the methods that you can use", "label": {"api": {"official Java documentation": [[35, 61]], "Java documentation for String": [[44, 72]]}}}, {"text": "To avoid the error, you can keep it as a String or you can use a BigInteger", "label": {"api": {"BigInteger": [[65, 74]]}}}, {"text": "To avoid the UnsupportedEncodingException, use the constructor that accepts a Charset object and just pass in the standard UTF-8", "label": {"api": {"UTF-8": [[123, 127]]}}}, {"text": "To fix this problem, you could use BigDecimal or even a String data type", "label": {"api": {"BigDecimal": [[35, 44]]}}}, {"text": "If you use BigDecimal, simply rewrite your algorithm using the methods of BigDecimal", "label": {"api": {"BigDecimal": [[11, 20], [74, 83]]}}}, {"text": "To keep the full information you could store the raw bits in a textual form, using Double.doubleToRawLongBits and on the way back longBitsToDouble", "label": {"api": {"Double.doubleToRawLongBits": [[83, 108]]}}}, {"text": "Java also has way of doing this with Collections.max , you can simply do", "label": {"api": {"Collections.max": [[37, 51]]}}}, {"text": "If you're looking for a bit more robust data model on the Java side and want to hide the columns in the JTable, you can use removeColumn from JTable", "label": {"api": {"removeColumn": [[124, 135]]}}}, {"text": "Using Shape for drawn objects instead of specifying their parameters during painting", "label": {"api": {"Shape": [[6, 10]]}}}, {"text": "Swing components automatically implement double buffering (see JComponent's setDoubleBuffered and isDoubleBuffered)", "label": {"api": {"JComponent": [[63, 72]]}}}, {"text": "You should call remove() in iterator which takes no arguments", "label": {"api": {"iterator": [[28, 35]]}}}, {"text": "Yes iterator is the way to remove object while iterating", "label": {"api": {"iterator": [[4, 11]]}}}, {"text": "Try to configure the proxy data in a Proxy class and open the connection with proxy", "label": {"api": {"Proxy": [[37, 41]]}}}, {"text": "I don't think you want \"newFile.toString()\" try using java.io.File.getAbsolutePath()", "label": {"api": {"java.io.File.getAbsolutePath()": [[54, 83]]}}}, {"text": "And the javadoc for Calendar.getInstance(Locale)` says", "label": {"api": {"Calendar.getInstance(Locale)` says": [[20, 53]]}}}, {"text": "Alternatively, if you are using the WebApplicationInitializer to configure the ServletContext, you can do the following", "label": {"api": {"ServletContext": [[79, 92]]}}}, {"text": "Answer to question in comment - Bearing in mind I have never done this before, but from looking at the docs for ServletContext and FilterRegistration, I would suggest trying this to get the filter mapped to a specific URL", "label": {"api": {"ServletContext": [[112, 125]], "FilterRegistration": [[131, 148]]}}}, {"text": "There is a setDefaultCloseOperation method in JFrame, but it never appear in the popup window", "label": {"api": {"setDefaultCloseOperation": [[11, 34]]}}}, {"text": "It's quite possible - you just call getClass()", "label": {"api": {"getClass()": [[36, 45]]}}}, {"text": "Use String#replace(CharSequence, CharSequence) instead of String#replaceAll()", "label": {"api": {"String#replace(CharSequence, CharSequence)": [[4, 45]]}}}, {"text": "The latter interprets its arguments differently because it's a regex find-and-replace", "label": {"api": {"interprets its arguments differently": [[11, 46]]}}}, {"text": "You can create object of PreparedStatement and that  object can then be used to efficiently execute your insert statement multiple times", "label": {"api": {"PreparedStatement": [[25, 41]]}}}, {"text": "Why not just schedule your processing method for 5 minutes from now via ScheduledExecutorService or your favorite scheduling mechanism, and save the event in a HashMap<User, Event> member variable", "label": {"api": {"ScheduledExecutorService": [[72, 95]]}}}, {"text": "A simple solution is keeping track of the pending actions in a concurrent structure and use a ScheduledExecutorService to execute them", "label": {"api": {"ScheduledExecutorService": [[94, 117]]}}}, {"text": "I am using custom model in my JTree", "label": {"api": {"JTree": [[30, 34]]}}}, {"text": "Note that I have custom model and can't call nodeChanged, I should emulate it", "label": {"api": {"nodeChanged": [[45, 55]]}}}, {"text": "And, by the way, you can have a look at EventListenerList for a proper collection of event listeners", "label": {"api": {"EventListenerList": [[40, 56]]}}}, {"text": "Alternatives to achieving similar functionality can also be obtained by bytecode instrumentation (see cglib or javassist) or maybe even with proxies", "label": {"api": {"proxies": [[141, 147]]}}}, {"text": "you can split the command on regex (for e.g", "label": {"api": {"split": [[8, 12]]}}}, {"text": "Use the Normalizer class to convert to a decomposed form and then encode", "label": {"api": {"the Normalizer class": [[4, 23]]}}}, {"text": "Well you can use Iterable.forEach", "label": {"api": {"Iterable.forEach": [[17, 32]]}}}, {"text": "Use a ScheduledExecutorService that returns a ScheduledFuture that can be cancelled", "label": {"api": {"ScheduledExecutorService": [[6, 29]], "ScheduledFuture": [[46, 60]]}}}, {"text": "You can control the size of the JScrollPane by using things like setVisibleRowCount and appropriate cell renderers ..", "label": {"api": {"setVisibleRowCount": [[65, 82]]}}}, {"text": "The least you can do is to embed this JMap into a JavaFX application using SwingNode", "label": {"api": {"SwingNode": [[75, 83]]}}}, {"text": "You must import a android.content.pm.Signature and not a java.security.Signature", "label": {"api": {"java.security.Signature": [[57, 79]]}}}, {"text": "I haven't tested this yet, but looking at the API documentation of WeekFields and LocalDate.get, you should do something like", "label": {"api": {"WeekFields": [[67, 76]], "LocalDate.get": [[82, 94]]}}}, {"text": "First of all I would put your download/write code in a separate class that implements Runnable then execute it with an ExecutorService", "label": {"api": {"ExecutorService": [[119, 133]]}}}, {"text": "And the documentation for @Path (http://docs.oracle.com/javaee/7/api/javax/ws/rs/Path.html) says", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/ws/rs/Path.html": [[33, 89]]}}}, {"text": "You can also use SimpleDateFomrat to parse the string into date", "label": {"api": {"SimpleDateFomrat": [[17, 32]]}}}, {"text": "You can make a Set holding the English words, and then for each combination of letters, check whether the combination is a member of the Set", "label": {"api": {"Set": [[15, 17], [137, 139]]}}}, {"text": "Checking membership in a HashSet is fast, and there are fewer short combinations than English words so this is faster than looping through all English words", "label": {"api": {"Set": [[29, 31]]}}}, {"text": "From the docs of java.util.Formatter", "label": {"api": {"java.util.Formatter": [[17, 35]]}}}, {"text": "I have a java.net.SocketTimeoutException; is this from a connection timeout or a socket timeout", "label": {"api": {"java.net.SocketTimeoutException": [[9, 39]], "TimeoutException": [[24, 39]]}}}, {"text": "The direct parent classes for SocketTimeoutException are InterruptedIoException and IOException; the former has only the SocketTimeoutException for a subclass, but the IOException has many subclasses", "label": {"api": {"TimeoutException": [[36, 51], [127, 142]], "InterruptedIoException": [[57, 78]], "IOException": [[84, 94], [168, 178]]}}}, {"text": "It only declares that it can throw an IOException, which is really very broad", "label": {"api": {"IOException": [[38, 48]]}}}, {"text": "If you know the exact number of your threads you can use CountDownLatch from java.util.concurrent", "label": {"api": {"CountDownLatch": [[57, 70]]}}}, {"text": "The method Character.toChars(int) will give you the UTF-16 series of code units corresponding to that code point", "label": {"api": {"Character.toChars(int)": [[11, 32]]}}}, {"text": "It seems like I should be able to that with the java.nio.file relativize method, I'm just not sure how", "label": {"api": {"java.nio.file relativize": [[48, 71]]}}}, {"text": "For example using System.nanoTime() is not necessarily going to work according to the oracle java doc", "label": {"api": {"oracle java doc": [[86, 100]]}}}, {"text": "With HashMap there are overloaded constructors with extra settings", "label": {"api": {"HashMap": [[5, 11]]}}}, {"text": "Constructs an empty HashMap with the specified initial capacity and load factor", "label": {"api": {"HashMap": [[20, 26]]}}}, {"text": "For a specific key class used with a HashMap, having a good hashCode can help too", "label": {"api": {"HashMap": [[37, 43]]}}}, {"text": "Then getColumns can be used to receive a ResultSet of miscellaneous information", "label": {"api": {"getColumns": [[5, 14]]}}}, {"text": "The one-arg overload of String.split will discard all empty trailing empty tokens", "label": {"api": {"one-arg overload of String.split": [[4, 35]]}}}, {"text": "To get 12, you must use the two-arg overload of String.split, with a negative limit (or a limit of at least 12), which doesn't discard trailing empty tokens", "label": {"api": {"two-arg overload of String.split": [[28, 59]]}}}, {"text": "the Character.getNumericValue(a); method returns an int", "label": {"api": {"Character.getNumericValue(a);": [[4, 32]]}}}, {"text": "See the Java 7 Oracle document link", "label": {"api": {"link": [[31, 34]]}}}, {"text": "If you're certain that the token will be at least one character long, you can take the first character of the String with String#charAt like so", "label": {"api": {"String#charAt": [[122, 134]]}}}, {"text": "You can use Object.clone() method to clone the object", "label": {"api": {"Object.clone()": [[12, 25]]}}}, {"text": "Mark your field with @Transient annotation or", "label": {"api": {"@Transient": [[21, 30]]}}}, {"text": "It is actually not that big using a ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[36, 59]]}}}, {"text": "EventQueue manages a single GUI thread because it must rely on the host platform's GUI resources, which are also single-threaded", "label": {"api": {"EventQueue": [[0, 9]]}}}, {"text": "One thing you can try is passing that single String to the exec(String) method instead of passing an array of Strings", "label": {"api": {"exec(String)": [[59, 70]]}}}, {"text": "As Durandal pointed out, Arrays.copyOfRange requires a start index and end index, but you are passing the message's byte count as the final argument", "label": {"api": {"Arrays.copyOfRange": [[25, 42]]}}}, {"text": "This means that if the third message happened to start at index 2000 and end at index 2050, you would be calling Arrays.copyOfRange(i, 2000, 50), which should throw an exception", "label": {"api": {"Arrays.copyOfRange": [[113, 130]]}}}, {"text": "The ByteBuffer class is well suited to what you are trying to do", "label": {"api": {"ByteBuffer": [[4, 13]]}}}, {"text": "It maintains its own position (index) and you can read a two-byte value using its getShort method", "label": {"api": {"position": [[21, 28]], "getShort": [[82, 89]]}}}, {"text": "If you tried to close the Connection object the results are implementation-dependent", "label": {"api": {"close the Connection object": [[16, 42]]}}}, {"text": "The least complex to present West and East together with no Center is a GridLayout with 1 row and 2 columns", "label": {"api": {"GridLayout": [[72, 81]]}}}, {"text": "If you have a North and South you still want to include, you can then place the GridLayout from above into the 2nd row of a 1 column x 3 row GridLayout", "label": {"api": {"GridLayout": [[80, 89], [141, 150]]}}}, {"text": "If you want more complexity and flexibility, you can use a GridBagLayout, which is akin to a super GridLayout", "label": {"api": {"GridLayout": [[99, 108]]}}}, {"text": "It would be much faster to use a StringBuilder to add all the characters, and then produce the final string just once with toString()", "label": {"api": {"StringBuilder": [[33, 45]], "toString()": [[123, 132]]}}}, {"text": "+ for String is implemented using StringBuilder (or StringBuffer) behind the scenes (see http://docs.oracle.com/javase/7/docs/api/java/lang/String.html or http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.18.1)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/String.html": [[89, 150]]}}}, {"text": "You can read more about that in java.util.stream package documentation - see Non-interference, Stateless behaviors and Side-effects sections", "label": {"api": {"java.util.stream package documentation": [[32, 69]]}}}, {"text": "All of the List<T> methods that change the list are listed as optional", "label": {"api": {"List<T>": [[11, 17]]}}}, {"text": "Also, the JDK documentation (http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.htmls states", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.htmls": [[29, 94]]}}}, {"text": "Since the floor number is an int, instead of reinventing the wheel, you should just use java.lang.Integer.compare(int, int)", "label": {"api": {"java.lang.Integer.compare(int, int)": [[88, 122]]}}}, {"text": "In order to avoid the last day of the month or last month of the year you could use GregorianCalendar#roll(..)", "label": {"api": {"GregorianCalendar#roll(..)": [[84, 109]]}}}, {"text": "I would convert them to a List and use retainAll to find the matches", "label": {"api": {"retainAll": [[39, 47]]}}}, {"text": "retainAll will not care that it is in b twice", "label": {"api": {"retainAll": [[0, 8]]}}}, {"text": "Future#get() is a blocking call", "label": {"api": {"Future#get()": [[0, 11]]}}}, {"text": "If you want to have a more predictable behavior, have a look at setPrototypeCellValue", "label": {"api": {"setPrototypeCellValue": [[64, 84]]}}}, {"text": "I would instead suggest a HashMap which allows you to associate your Strings with the Integers they map to", "label": {"api": {"HashMap": [[26, 32]]}}}, {"text": "For that, you will need to use the java.math.BigDecimal class instead", "label": {"api": {"BigDecimal": [[45, 54]]}}}, {"text": "Numbers and Strings covers BigDecimal and other useful classes provided by the Java platform", "label": {"api": {"BigDecimal": [[27, 36]]}}}, {"text": "Use BigDecimal, it also have the rounding functionalities that you're looking for", "label": {"api": {"BigDecimal": [[4, 13]]}}}, {"text": "You can create a BigInteger using the constructor that takes a String and an int radix", "label": {"api": {"constructor that takes a String and an int radix": [[38, 85]]}}}, {"text": "If you have Java 8, you can use Long.parseUnsignedLong, which will allow you to parse all 64 bits, even if the bit that would normally put it over Long.MAX_VALUE is set", "label": {"api": {"Long.parseUnsignedLong": [[32, 53]]}}}, {"text": "You should use a ProcessBuilder, and then use redirectErrorStream()", "label": {"api": {"ProcessBuilder": [[17, 30]], "redirectErrorStream()": [[46, 66]]}}}, {"text": "However, the overloaded setScale method that takes a RoudingMode is preferred", "label": {"api": {"overloaded setScale method that takes a RoudingMode is preferred": [[13, 76]]}}}, {"text": "Here is the document", "label": {"api": {"the document": [[8, 19]]}}}, {"text": "But, if you're using Java 8 you can get a performance boost with the new StampedLock that lets you avoid the read lock", "label": {"api": {"StampedLock": [[73, 83]]}}}, {"text": "Collections.toArray() is your friend", "label": {"api": {"Collections.toArray()": [[0, 20]]}}}, {"text": "Or you could use the Arrays.fill method", "label": {"api": {"Arrays.fill": [[21, 31]]}}}, {"text": "This will always return false, because ResultSet is never equal to a String", "label": {"api": {"ResultSet": [[39, 47]]}}}, {"text": "What you want to do is check if the ResultSet is empty", "label": {"api": {"ResultSet": [[36, 44]]}}}, {"text": "I suggest you to use Java's java.util.UUID class for generating new id's, because incremental id is vulnerable to hacks", "label": {"api": {"java.util.UUID": [[28, 41]]}}}, {"text": "And the Child decides to throw a, say SocketException", "label": {"api": {"SocketException": [[38, 52]]}}}, {"text": "I, correctly, try and catch FileNotFoundException from the call parent.doStuff but this will not catch the SocketException", "label": {"api": {"SocketException": [[107, 121]]}}}, {"text": "If I specifically try and catch SocketException this will result in a compiler error as SocketException is not declared as thrown from Parent.doStuff", "label": {"api": {"SocketException": [[32, 46], [88, 102]]}}}, {"text": "Matcher.matches returns true only when the pattern matches the whole string", "label": {"api": {"Matcher.matches": [[0, 14]]}}}, {"text": "By using Matcher.find, you don't need to modify the pattern", "label": {"api": {"Matcher.find": [[9, 20]]}}}, {"text": "InputStream.read() retruns the next byte of data, which is a number between 0 and 255", "label": {"api": {"InputStream.read()": [[0, 17]]}}}, {"text": "You can do a lot with reflection and Field#setAccessible() if you really wanted to, but this utterly defeats the purpose", "label": {"api": {"Field#setAccessible()": [[37, 57]]}}}, {"text": "Insertions into a list by default are not synchronized, thus not thread safe", "label": {"api": {"are not synchronized": [[34, 53]]}}}, {"text": "TreeMap has a tail map", "label": {"api": {"TreeMap": [[0, 6]]}}}, {"text": "You could have a Timer thread that prints out these messages and shuts down the listening program", "label": {"api": {"Timer": [[17, 21]]}}}, {"text": "Use a ScheduledExecutorService to execute concurrent actions in the future", "label": {"api": {"ScheduledExecutorService": [[6, 29]]}}}, {"text": "When you have a string that has multiple numbers separated by variable number of whitespace characters, you can use Scanner to do the reading", "label": {"api": {"Scanner": [[116, 122]]}}}, {"text": "The Integers i and j are constructed (via auto boxing) from integer literals from the range â€“128 to 127 and thus are guaranteed to be pooled by the JVM so the same object (see flyweight pattern) is used for them", "label": {"api": {"Integer": [[4, 10]]}}}, {"text": "For the Doubles a and b on the other hand, no such pooling guarantee exists and, in your case, you got two different objects that did not compare identical", "label": {"api": {"Double": [[8, 13]]}}}, {"text": "If you would like to perform precise operations on decimal values Java, use BigDecimal type instead of `double", "label": {"api": {"BigDecimal": [[76, 85]]}}}, {"text": "The problem is the (byte) cast before the result is checked for -1, which is an out-of-band sentinel value used by InputStream.read to indicate EOF", "label": {"api": {"InputStream.read": [[115, 130]]}}}, {"text": "using buffered streams and read(byte[]) are two easy ways to make it much faster", "label": {"api": {"read(byte[])": [[27, 38]]}}}, {"text": "To get an ID uniquely identifying a point in time (with the precision of milliseconds), consider Calendar.getTimeInMillis()", "label": {"api": {"Calendar.getTimeInMillis()": [[97, 122]]}}}, {"text": "If you want native queries you should use NamedNativeQuery instead", "label": {"api": {"NamedNativeQuery": [[42, 57]]}}}, {"text": "There is actually a small example of how to do this in the documentation for the ExecutorService", "label": {"api": {"a small example": [[18, 32]]}}}, {"text": "See the doc about String for more informations", "label": {"api": {"the doc about String": [[4, 23]]}}}, {"text": "The String#replaceAll method replaces using regex", "label": {"api": {"String#replaceAll": [[4, 20]], "String#replace": [[4, 17]]}}}, {"text": "If you want to replace the literal [ character, you should use the String#replace method", "label": {"api": {"String#replace": [[67, 80]]}}}, {"text": "I think you should consider using a collection that can grow or shrink, ArrayList for example", "label": {"api": {"ArrayList": [[72, 80]]}}}, {"text": "If you're on Java 8, then the new java.time package of Java date/time classes are much better", "label": {"api": {"java.time package": [[34, 50]]}}}, {"text": "ServerSocket Docs Says:The maximum queue length for incoming connection indications (a request to connect) is set to 50", "label": {"api": {"ServerSocket Docs Says:": [[0, 22]]}}}, {"text": "You could also use a LinkedHashSet instead of a primitive array", "label": {"api": {"LinkedHashSet": [[21, 33]]}}}, {"text": "But some types will confuse older class file parsers as they use new features, notably AnnotatedElement, which now has default methods, and Map.Entry, an interface which now has static methods", "label": {"api": {"AnnotatedElement": [[87, 102]], "Map.Entry": [[140, 148]]}}}, {"text": "You'll have to dynamically retrieve it through Class#getMethod(..) (or other appropriate methods)", "label": {"api": {"Class#getMethod(..)": [[47, 65]]}}}, {"text": "You may want to if your input is already a string and it might be long, but if you've already got a long, you can use BigInteger.valueOf", "label": {"api": {"BigInteger.valueOf": [[118, 135]]}}}, {"text": "From your description, it sounds like a BorderPane might be best for the overall layout (i.e", "label": {"api": {"BorderPane": [[40, 49]]}}}, {"text": "Alternatively you could use a GridPane as you suggested, with appropriate ColumnConstraints and RowConstraints applied to size the cells in the pane", "label": {"api": {"GridPane": [[30, 37]], "ColumnConstraints": [[74, 90]], "RowConstraints": [[96, 109]]}}}, {"text": "The only Collector.of method that can match the number of arguments you supplied is", "label": {"api": {"Collector.of": [[9, 20]]}}}, {"text": "The remainder of the error message is irrelevant, since the other Collector.of method expects an additional argument, and therefore is not relevant to your code", "label": {"api": {"Collector.of": [[66, 77]]}}}, {"text": "Instead of exec(String, String[]) you want to call exec(String[])", "label": {"api": {"exec(String, String[])": [[11, 32]], "exec(String[])": [[51, 64]]}}}, {"text": "Save yourself a lot of trouble and use ArrayList", "label": {"api": {"ArrayList": [[39, 47]]}}}, {"text": "That way you can simply remove an element at an index, there's no need then to manually manage elements in a primitive array", "label": {"api": {"remove": [[24, 29]]}}}, {"text": "Use an ArrayList instead and delete items using its remove method", "label": {"api": {"ArrayList": [[7, 15]], "remove": [[52, 57]]}}}, {"text": "The ending index in the 2-arg substring method is exclusive", "label": {"api": {"2-arg substring method": [[24, 45]]}}}, {"text": "Note that the parameter type of Map#get() method is just Object anyway, so from a look-up perspective there's no value in having separate maps (the type of the key is only relevant for put())", "label": {"api": {"Map#get()": [[32, 40]], "put()": [[185, 189]]}}}, {"text": "Or use the javafx.concurrent.ScheduledService class", "label": {"api": {"javafx.concurrent.ScheduledService": [[11, 44]], "ScheduledService": [[29, 44]]}}}, {"text": "Refer to the Javadocs for Task and ScheduledService for lots more examples", "label": {"api": {"Javadocs for Task": [[13, 29]], "ScheduledService": [[35, 50]]}}}, {"text": "Look at String.matches() and regular expressions", "label": {"api": {"String.matches()": [[8, 23]], "regular expressions": [[29, 47]]}}}, {"text": "You can set the text that is displayed when entering full-screen with the Stage.setFullScreenExitHint(String value) method", "label": {"api": {"Stage.setFullScreenExitHint(String value)": [[74, 114]]}}}, {"text": "The Robot class is used to generate native system input events", "label": {"api": {"Robot": [[4, 8]]}}}, {"text": "You can't lock your OS and continue to use Robot to input text into your JTextArea", "label": {"api": {"Robot": [[43, 47]]}}}, {"text": "I don't know your code (because you haven't posted any), but if the Robot is in the same Java program than your JTextArea, then you should absolutely not use Robot to write text into the text area, instead use the JTextArea's methods to do that (e.g", "label": {"api": {"Robot": [[68, 72], [158, 162]]}}}, {"text": "As stated in the javadoc of ConcurrentModificationException", "label": {"api": {"ConcurrentModificationException": [[28, 58]]}}}, {"text": "Iterators that do this are known as fail-fast iterators, as they fail quickly and cleanly, rather that risking arbitrary, non-deterministic behavior at an undetermined time in the future", "label": {"api": {"iterator": [[46, 53]]}}}, {"text": "As you are using a foreach you are actually using an iterator to navigate over the elements of the collection", "label": {"api": {"iterator": [[53, 60]]}}}, {"text": "Typically the implementations of Iterator are throwing the mentioned exception if you are modifying the underlying collection after the creation of the iterator - in your case, the iterator is creator on the first iteration over the collection", "label": {"api": {"iterator": [[152, 159], [181, 188]]}}}, {"text": "The concept of spring security is based on ServletFilter as you included page is not intercepted by spring security it doestnt prevent its access", "label": {"api": {"ServletFilter": [[43, 55]]}}}, {"text": "If you use a BufferedReader you can use the readLine() function to read the contents of the file as a String", "label": {"api": {"BufferedReader": [[13, 26]]}}}, {"text": "Here, read more about things to note with String.replace or the function definition itself", "label": {"api": {"function definition": [[64, 82]]}}}, {"text": "Note that it is overloaded with a char variant, so you can do two kinds of things with a similar function call", "label": {"api": {"char variant": [[34, 45]]}}}, {"text": "From the documentation for Matcher, matches", "label": {"api": {"documentation for Matcher": [[9, 33]]}}}, {"text": "Also note that the Function interface that you have defined already exists in the JDK (its method is apply instead of run) and the InputGenerator also exists and is called IntFunction", "label": {"api": {"already exists in the JDK": [[60, 84]], "is called IntFunction": [[162, 182]]}}}, {"text": "Again in A.substring(X, Y).equals(AL[1]), since you are trying to match each and every character of the string A, then why not convert it into char[] using toCharArray()", "label": {"api": {"toCharArray()": [[156, 168]]}}}, {"text": "When building a SQL time stamp by specifying only the milliseconds in the constructor, which time zone will be used", "label": {"api": {"constructor": [[74, 84]]}}}, {"text": "You could write a Comparator overriding the compare method to compare the letters short-value ( just cast to short ) in a for-loop for each letters limited by Math.min(o1.length, o2.length)", "label": {"api": {"Comparator": [[18, 27]]}}}, {"text": "One of the best ways to use a BlockingQueue", "label": {"api": {"BlockingQueue": [[30, 42]]}}}, {"text": "Yes, the only way would be to create a new Color object, at least to my knowledge", "label": {"api": {"Color": [[43, 47]]}}}, {"text": "There are no setter() methods in the Color class", "label": {"api": {"Color": [[37, 41]]}}}, {"text": "Optional::empty is defined as returning me an Optional<T>", "label": {"api": {"Optional::empty": [[0, 14]]}}}, {"text": "As proposed by NoDataFound in the comment, if you do not want to add an Id, an Embeddable/Embedded tandem could be the solution", "label": {"api": {"Embeddable": [[79, 88]], "Embedded": [[90, 97]]}}}, {"text": "Using a Filer and StandardLocation helps with portability of the processor and avoids having to worry about the development environment's directory structure", "label": {"api": {"Filer": [[8, 12]], "StandardLocation": [[18, 33]]}}}, {"text": "Or, I suggest using a growable array such as ArrayList, which supports appending new elements with ArrayList#add", "label": {"api": {"ArrayList": [[45, 53], [99, 107]], "ArrayList#add": [[99, 111]]}}}, {"text": "You could use ScriptEngine to evaluate a PhantomJS script inside Java; see here for details", "label": {"api": {"ScriptEngine": [[14, 25]]}}}, {"text": "For example if using SimpleDateFormat, you can use its setTimeZone() method", "label": {"api": {"SimpleDateFormat": [[21, 36]], "setTimeZone()": [[55, 67]]}}}, {"text": "ImageIO can provide you an ImageReader for Tiff, and then you can use readTile", "label": {"api": {"readTile": [[70, 77]]}}}, {"text": "ImageIcon java Docs and Swing tutorial", "label": {"api": {"ImageIcon java Docs": [[0, 18]]}}}, {"text": "Read it into a buffer or invent some bounded input stream and give it to the getInstance factory method of X509Certificate", "label": {"api": {"getInstance": [[77, 87]]}}}, {"text": "In the documentation for Java's Runtime class it states", "label": {"api": {"documentation for Java's Runtime class": [[7, 44]]}}}, {"text": "Perhaps a CountDownLatch", "label": {"api": {"CountDownLatch": [[10, 23]]}}}, {"text": "Read request#getRealPathfor its documentation", "label": {"api": {"request#getRealPath": [[5, 23]]}}}, {"text": "If the source file is not an html file, don't try to display it in an HTMLEditor, use a TextArea or something like that instead", "label": {"api": {"HTMLEditor": [[70, 79]], "TextArea": [[88, 95]]}}}, {"text": "What it does is mark the loaded text as pre-formatted, by surrounding it with <pre> tags, that way any whitespace and new lines in the input text is preserved in the HTMLEditor display", "label": {"api": {"HTMLEditor": [[166, 175]]}}}, {"text": "The problem is your use of Scanner.next()", "label": {"api": {"Scanner.next()": [[27, 40]]}}}, {"text": "You can use the ResultSetMetaData.getColumnCount() method retrieved from the ResultSet metadata instance", "label": {"api": {"ResultSetMetaData.getColumnCount()": [[16, 49]]}}}, {"text": "The most basic thing you can do is create an interface for the method or use an existing interface like Runnable", "label": {"api": {"Runnable": [[104, 111]]}}}, {"text": "After retrieving the map by searching using the letter A, use putAll to copy all entries to the map", "label": {"api": {"putAll": [[62, 67]]}}}, {"text": "The method you're looking for is putAll", "label": {"api": {"putAll": [[33, 38]]}}}, {"text": "Any time you are looking to do fixed-interval opetations in Java you should be investigating the ScheduledExecutorService", "label": {"api": {"ScheduledExecutorService": [[97, 120]]}}}, {"text": "One solution would be to replace your custom-built date arithmetic with the java.util classes Date and Calendar, unless there's a reason not to use them (such as this being a date calculation exercise), since those utility classes are standard and well-tested", "label": {"api": {"Date": [[94, 97]], "Calendar": [[103, 110]]}}}, {"text": "For consistency with the Calendar class, I'd recommend a (year, month, date) format instead of your (date, month, year)", "label": {"api": {"Calendar": [[25, 32]]}}}, {"text": "So, to look at your test cases, using your Date(date, month, year) format, on the assumption that you're not allowed to use java.util", "label": {"api": {"Date": [[43, 46]]}}}, {"text": "This adds three days to Date(31, 11, 2013)", "label": {"api": {"Date": [[24, 27]]}}}, {"text": "This adds three days to Date(28, 2, 2016), a leap year", "label": {"api": {"Date": [[24, 27]]}}}, {"text": "This adds two days to Date(29, 2, 2014), a common year", "label": {"api": {"Date": [[22, 25]]}}}, {"text": "Maybe using that other existing standard class, Calendar could help you", "label": {"api": {"Calendar": [[48, 55]]}}}, {"text": "Not that it's much less of a catastrophe, but as you haven't learned about Joda-Time or the new java.time package in Java 8 (defined by JSR 310, inspired by Joda-Time) there aren't many sensible options left in standard, pre-8 Java", "label": {"api": {"java.time package": [[96, 112]]}}}, {"text": "Have a look at Soumyarup Dasguptaâ€™s answer to another question for a not overly fast but easy way to find the number of days between two Calendar instances just using its add method and a simple loop", "label": {"api": {"Calendar": [[137, 144]], "add method": [[171, 180]]}}}, {"text": "Calendar has a set method to manipulate individual fields - and the corresponding get method as well, using these features and getting some inspiration from the linked code should get you started", "label": {"api": {"Calendar": [[0, 7]], "set method to manipulate individual fields": [[15, 56]], "get method": [[82, 91]]}}}, {"text": "Convert the ArrayList to a HashSet", "label": {"api": {"HashSet": [[27, 33]]}}}, {"text": "I heard of an idea with a Socket, but I don't get how that would work", "label": {"api": {"Socket": [[26, 31]]}}}, {"text": "I would gladly like an API, but I would also like clarification on the way to sniff traffic with a Socket", "label": {"api": {"Socket": [[99, 104]]}}}, {"text": "BigInteger can parse it and store it, and do bitwise operations", "label": {"api": {"BigInteger": [[0, 9]]}}}, {"text": "If you want to write to multiple points in a file, you should really consider using RandomAccessFile, which was designed for this purpose", "label": {"api": {"RandomAccessFile": [[84, 99]]}}}, {"text": "You should also use the same RandomAccessFile instance for all writes instead of creating one separately every time you update the header or the contents", "label": {"api": {"RandomAccessFile": [[29, 44]]}}}, {"text": "I tried using the getParameterAnnotations but it not works", "label": {"api": {"getParameterAnnotations": [[18, 40]]}}}, {"text": "You're calling Runtime.exec(String) which delegates to Runtime.exec(String[], String[], File) in two steps, result in nulls for second and third parameters", "label": {"api": {"Runtime.exec(String)": [[15, 34]], "Runtime.exec(String[], String[], File)": [[55, 92]]}}}, {"text": "If I write(byte[]) to an OutputStream obtained from Socket.getOutputStream() on a non-blocking Socket backed by a Channel, and write() throws IllegalBlockingModeException, is it guaranteed that all the byte-array is written or none of it is", "label": {"api": {"write(byte[]) to an OutputStream": [[5, 36]], "from Socket.getOutputStream()": [[47, 75]], "IllegalBlockingModeException": [[142, 169]]}}}, {"text": "You use a Path to register a file located by that Path to a WatchService", "label": {"api": {"register": [[18, 25]]}}}, {"text": "If an event occurs, it will be enqueued in the WatchService and you can retrieve it with take()", "label": {"api": {"take()": [[89, 94]]}}}, {"text": "take() has no idea about the actual Path", "label": {"api": {"take()": [[0, 5]]}}}, {"text": "Yes, a WatchService will only report events for those Paths registered with it", "label": {"api": {"register": [[60, 67]]}}}, {"text": "You can use the WatchKey returned by the register method to compare against the WatchKey returned by take()", "label": {"api": {"register": [[41, 48]], "take()": [[101, 106]]}}}, {"text": "It is by default created with an initial capacity of 10 (regardless of available RAM)", "label": {"api": {"initial capacity of 10": [[33, 54]]}}}, {"text": "Additionally, unless you have multiple threads accessing your StringBuffer, you might want to consider replacing it with a StringBuilder", "label": {"api": {"StringBuilder": [[123, 135]]}}}, {"text": "A common solution would be to dump the data in to a properties file, and then load it with the standard Properties.load(...) method", "label": {"api": {"Properties.load(...)": [[104, 123]]}}}, {"text": "You are using DAY_OF_WEEK which is 6 for FRIDAYand MONTH starts from 0 not 1 so you have to add 1 in it.You can use DAY_OF_MONTH instead of DAY_OF_WEEK", "label": {"api": {"DAY_OF_WEEK": [[14, 24], [140, 150]], "MONTH": [[51, 55], [123, 127]], "DAY_OF_MONTH": [[116, 127]]}}}, {"text": "You should add content to the content pane of the frame which you can get by calling JFrame.getContentPane()", "label": {"api": {"JFrame.getContentPane()": [[85, 107]]}}}, {"text": "This is possible because Thread has a constructor accepting a Runnable instance, and Runnable is a functional interface (an interface that only defines a single function), and so you can create an instance implementing that interface simply by using a lambda and then pass that into the Thread constructor", "label": {"api": {"Runnable": [[62, 69], [85, 92]]}}}, {"text": "If you can't retrieve any data in the second servlet, it's probably because you're calling something like request.getParameter() /getParameterValues()/getParameterMap() somewhere", "label": {"api": {"request.getParameter()": [[106, 127]]}}}, {"text": "Withing a Javadoc of it you can find a very nice example that will suits your needs", "label": {"api": {"Withing a Javadoc of it": [[0, 22]]}}}, {"text": "As explained in the Pattern Javadocs", "label": {"api": {"the Pattern Javadocs": [[16, 35]]}}}, {"text": "Use the URI class", "label": {"api": {"URI": [[8, 10]]}}}, {"text": "Create a new URI with your existing String to \"break it up\" to parts, and instantiate another one to assemble the modified url", "label": {"api": {"URI": [[13, 15]]}}}, {"text": "You can use regExp with method #replaceAll other than that you can first use trim to remove leading and trailing spaces", "label": {"api": {"#replaceAll": [[31, 41]]}}}, {"text": "You can set the default close operation to DO_NOTHING_ON_CLOSE and ask the user for a confirmation instead", "label": {"api": {"DO_NOTHING_ON_CLOSE": [[43, 61]]}}}, {"text": "Note the use of the putIfAbsent() atomic operation", "label": {"api": {"putIfAbsent()": [[20, 32]]}}}, {"text": "As the StringTokenizer docs explains, you must use the hasMoreTokens method to loop instead of comparing next() to null", "label": {"api": {"StringTokenizer": [[7, 21]]}}}, {"text": "See what the doc says about HttpSession#setMaxInactiveInterval(int)", "label": {"api": {"HttpSession#setMaxInactiveInterval(int)": [[28, 66]]}}}, {"text": "You may want to think about using the GridBagLayout to achieve this design, as it has better controls for anchoring where you want your buttons to show up", "label": {"api": {"GridBagLayout": [[38, 50]]}}}, {"text": "You can actually do your cell padding in the GridBagConstraints, or you can think about using Border(s)", "label": {"api": {"Border(s)": [[94, 102]]}}}, {"text": "The Character.getNumericValue method will attempt to convert the char to an int by applying the character's numeric meaning", "label": {"api": {"Character.getNumericValue method": [[4, 35]]}}}, {"text": "If you want a mutable class like Integer, you could use AtomicInteger instead", "label": {"api": {"AtomicInteger": [[56, 68]]}}}, {"text": "Another way in addition to Elliott Frisch's way is to check for positive or negative infinity using the constants in the Double class", "label": {"api": {"Double": [[121, 126]]}}}, {"text": "A practical solution would be to use NIO2 AsynchronousSocketChannels to perform asynchronous read operations with a callback that you can specify as a CompletionHandler", "label": {"api": {"AsynchronousSocketChannel": [[42, 66]], "CompletionHandler": [[151, 167]]}}}, {"text": "Java 8 lambdas and Map.forEach make bkail's answer more concise", "label": {"api": {"Map.forEach": [[19, 29]]}}}, {"text": "If double is of enough precision for your application, you can look at formatting it as per specification with for instance DecimalFormat", "label": {"api": {"DecimalFormat": [[124, 136]]}}}, {"text": "If double is not of sufficient precision you can look at using BigInteger", "label": {"api": {"BigInteger": [[63, 72]]}}}, {"text": "This is easy to do, add the mouse listener to the table and use columnAtPoint and rowAtPoint to determine what has been clicked", "label": {"api": {"columnAtPoint": [[64, 76]]}}}, {"text": "If you want a table cell to look like a button, set a renderer that uses JButton", "label": {"api": {"set a renderer": [[48, 61]]}}}, {"text": "It is quite clear, HTMLDocument.Iterator is different from java.util.Iterator and is not a generic class", "label": {"api": {"HTMLDocument.Iterator": [[19, 39]], "java.util.Iterator": [[59, 76]]}}}, {"text": "It seems that the class you really want to use is java.util.Iterator", "label": {"api": {"java.util.Iterator": [[50, 67]]}}}, {"text": "javadoc for String", "label": {"api": {"javadoc for String": [[0, 17]]}}}, {"text": "Javadoc page for Scanner", "label": {"api": {"Javadoc page for Scanner": [[0, 23]]}}}, {"text": "a LinkedBlockingQueue or a ConcurrentLinkedQueue, where multiple threads write their messages to the queue and a single thread reads from the queue and writes the messages to a file", "label": {"api": {"LinkedBlockingQueue": [[2, 20]], "ConcurrentLinkedQueue": [[27, 47]]}}}, {"text": "With a BlockingQueue the logging thread can call take or poll(timeout, TimeUnit) on the queue, causing the thread to sleep until a messages becomes available; with a ConcurrentLinkedQueue you can have the logging thread sleep for, say, ten seconds, then wake up, flush the queue to the file, and go back to sleep for another ten seconds", "label": {"api": {"ConcurrentLinkedQueue": [[166, 186]]}}}, {"text": "As a consequence, if you don't pass a copy (using your method, or one of the Arrays.copyOf() methods) then changes to the original reference will modify your Object's reference", "label": {"api": {"Arrays.copyOf()": [[77, 91]]}}}, {"text": "Integer.parseInt(String, radix) is not limited to any specific radix, and can handle anything between Character.MIN_RADIX (i.e., 2) and Character.MAX_RADIX (i.e., 36)", "label": {"api": {"Integer.parseInt(String, radix)": [[0, 30]], "Character.MIN_RADIX": [[102, 120]], "Character.MAX_RADIX": [[136, 154]]}}}, {"text": "See the Executors tutorial and ScheduledExecutorService class in particular", "label": {"api": {"ScheduledExecutorService": [[31, 54]]}}}, {"text": "When you need to synchronize such an operation, you can always use a CopyOnWWriteArrayList, or synchronize your access explicitly", "label": {"api": {"CopyOnWWriteArrayList": [[69, 89]]}}}, {"text": "Just look at Future which has a couple and others in that package", "label": {"api": {"Future which has a couple": [[13, 37]]}}}, {"text": "A Formatter (or similar, like System.out.printf) can convert a result back into hex easily enough", "label": {"api": {"Formatter": [[2, 10]]}}}, {"text": "If you construct a java.io.InputStreamReader, you can specify the input text charset such as \"UTF-16\"", "label": {"api": {"construct": [[7, 15]], "charset": [[77, 83]]}}}, {"text": "You can statically partition the pages among your workers as JB Nizet suggests in the comments; another option would be to place all pages in a ConcurrentLinkedQueue and have the workers poll the queue for pages to parse, terminating when the queue is empty (poll returns null)", "label": {"api": {"ConcurrentLinkedQueue": [[144, 164]]}}}, {"text": "You can use a ThreadPoolExecutor", "label": {"api": {"ThreadPoolExecutor": [[14, 31]]}}}, {"text": "If you already have the data in a String, pass this String variable as the constructor of your Scanner", "label": {"api": {"Scanner": [[95, 101]]}}}, {"text": "If you're worried about the formatting of your dates, the java.sql.Date toString() method, the one that's called when you println it,  always formats the date to be yyyy-mm-dd", "label": {"api": {"always": [[135, 140]]}}}, {"text": "See the SimpleDateFormat page for detail", "label": {"api": {"SimpleDateFormat": [[8, 23]]}}}, {"text": "What you want to do is subclassing AbstractTableModel, and overwrite the setValueAt() method", "label": {"api": {"AbstractTableModel": [[35, 52]], "setValueAt()": [[73, 84]]}}}, {"text": "Use a ProcessBuilder instead", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "http://docs.oracle.com/javaee/7/api/javax/servlet/ServletResponse.html#setContentLengthLong(long) Now I can't manage to mek it work", "label": {"api": {"http://docs.oracle.com/javaee/7/api/javax/servlet/ServletResponse.html#setContentLengthLong(long)": [[0, 96]]}}}, {"text": "That's the contract of the start() method", "label": {"api": {"start()": [[27, 33]]}}}, {"text": "A better way would be to use proper synchronization primitives to signal the condition", "label": {"api": {"synchronization primitives": [[36, 61]]}}}, {"text": "java.awt.PageAttributes has a method called setMediaToDefault() which should do just that", "label": {"api": {"java.awt.PageAttributes": [[0, 22]], "setMediaToDefault()": [[44, 62]]}}}, {"text": "The most standard way is to just collect them at the end", "label": {"api": {"collect them": [[33, 44]]}}}, {"text": "Quote from the documentation of signalAll()", "label": {"api": {"documentation of signalAll()": [[15, 42]]}}}, {"text": "Quote from the documentation of ReentrantLock.newCondition()", "label": {"api": {"documentation of ReentrantLock.newCondition()": [[15, 59]]}}}, {"text": "Alright, you really want to use a Map", "label": {"api": {"Map": [[34, 36]]}}}, {"text": "They can be classified in two different sub interfaces - those that implement SortedMap NavigableMap (use Navigable Map, it is the replacement for SortedMap with Java 1.6) and those that don't", "label": {"api": {"Map": [[84, 86], [97, 99], [116, 118], [153, 155]], "NavigableMap": [[88, 99]]}}}, {"text": "If you want things to be stored and returned in order (and be able to do things with the ordering of the keys), then you want a NavigableMap", "label": {"api": {"Map": [[137, 139]], "NavigableMap": [[128, 139]]}}}, {"text": "However, a NavigableMap can only store sortable keys", "label": {"api": {"Map": [[20, 22]], "NavigableMap": [[11, 22]]}}}, {"text": "If the key isn't sortable, it doesn't make sense to store it in a NavigableMap", "label": {"api": {"Map": [[75, 77]], "NavigableMap": [[66, 77]]}}}, {"text": "The classic implementation of the NavigableMap is the TreeMap though I like the ConcurrentSkipListMap because of some particular properties (it's a tad bit faster in some cases and I can reason about it more easily)", "label": {"api": {"Map": [[43, 45], [58, 60], [98, 100]], "NavigableMap": [[34, 45]], "TreeMap": [[54, 60]], "ConcurrentSkipListMap": [[80, 100]]}}}, {"text": "Otherwise, you're likely looking at the speed for random access of the HashMap", "label": {"api": {"Map": [[75, 77]], "HashMap": [[71, 77]]}}}, {"text": "The HashMap doesn't store things in a given order - it just sticks them whoever the hash function says to put them", "label": {"api": {"Map": [[8, 10]], "HashMap": [[4, 10]]}}}, {"text": "There's a variation of the HashMap which is the subclass LinkedHashMap", "label": {"api": {"Map": [[31, 33], [67, 69]], "HashMap": [[27, 33], [63, 69]], "LinkedHashMap": [[57, 69]]}}}, {"text": "Not only does it have the fast lookup of the HashMap, but it also stores a linked list along side the HashMap", "label": {"api": {"Map": [[49, 51], [106, 108]], "HashMap": [[45, 51], [102, 108]]}}}, {"text": "There are some tricks you can play with the LinkedHashMap that allow you to remove the oldest element from the list", "label": {"api": {"Map": [[54, 56]], "HashMap": [[50, 56]], "LinkedHashMap": [[44, 56]]}}}, {"text": "In general though, you want either a HashMap or a TreeMap depending on how you want to get the data out of the Map", "label": {"api": {"Map": [[41, 43], [54, 56], [111, 113]], "TreeMap": [[50, 56]], "HashMap": [[37, 43]]}}}, {"text": "Dobb's a read - the concept of a Map is called may things in different languages (hash, dictionary, finite maps, lookup tables, and so on)", "label": {"api": {"Map": [[33, 35]]}}}, {"text": "Understanding the concepts behind the Map can make things easier to decide which one to use and how to use it", "label": {"api": {"Map": [[38, 40]]}}}, {"text": "You can use the MethodHandles type in your InvocationHandler", "label": {"api": {"MethodHandles": [[16, 28]]}}}, {"text": "If you look at the ActionEvent Documentation Page you see that every action event is constructed with an Object source", "label": {"api": {"ActionEvent Documentation Page": [[19, 48]]}}}, {"text": "You can define your own Comparator which will behave opposite as default one", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "Please try JPanel.updateUI and let me know if that helps", "label": {"api": {"JPanel.updateUI": [[11, 25]]}}}, {"text": "In addition, invoke super.paintComponent() to avoid this kind of rendering artifact", "label": {"api": {"artifact": [[75, 82]]}}}, {"text": "As you can see, in order to unbox the Integer it tries to invoke Integer#intValue() method on null reference, and therefore it throws NullPointerException", "label": {"api": {"Integer#intValue()": [[65, 82]]}}}, {"text": "Define a custom Comparator and use Collections.sort", "label": {"api": {"Collections.sort": [[35, 50]]}}}, {"text": "You can add the characters to an array and use Arrays.binarySearch() to determine if the character is in the array", "label": {"api": {"Arrays.binarySearch()": [[47, 67]]}}}, {"text": "You should also take a look on XMLEncoder http://docs.oracle.com/javase/7/docs/api/java/beans/XMLEncoder.html, maybe it could help you", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/beans/XMLEncoder.html": [[42, 108]]}}}, {"text": "Annotations are not inherited from interfaces, this is by design and is a Java and not a spring related thing", "label": {"api": {"not inherited": [[16, 28]]}}}, {"text": "I would either take a look at the constructor argument of File and name it after that, e.g", "label": {"api": {"constructor argument of File": [[34, 61]]}}}, {"text": "You can use SimpleDateFormat to parse or format the date as dd/MM/yyyy", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "If using JDK 8 is an option for you, check out java.util.Base64  and the nested class, java.util.Base64.Encoder", "label": {"api": {"java.util.Base64": [[47, 62], [87, 102]], "java.util.Base64.Encoder": [[87, 110]]}}}, {"text": "The way to do this is with a DocumentFilter", "label": {"api": {"DocumentFilter": [[29, 42]]}}}, {"text": "However it allows you to insert a DocumentFilter between the UI (where rich text content is edited) and the underlying model (the content)", "label": {"api": {"DocumentFilter": [[34, 47]]}}}, {"text": "As I say, this is a pretty hard piece of coding, and the Document/DocumentFilter structure has a lot of complexity that your particular application doesn't need", "label": {"api": {"DocumentFilter": [[66, 79]]}}}, {"text": "The Arraylist.remove() method for ArrayLists of type Integer defaults to the remove that takes an index", "label": {"api": {"index": [[98, 102]]}}}, {"text": "It would be potentially possible to model/test some of this using WeakReference, if I have time I'll try to revisit this answer with some example code / analysis", "label": {"api": {"WeakReference": [[66, 78]]}}}, {"text": "See the documentation for Formatter documentation for more information", "label": {"api": {"Formatter": [[26, 34]]}}}, {"text": "You should take a look at SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[26, 41]]}}}, {"text": "Finally, you could just use Collection.contains", "label": {"api": {"Collection.contains": [[28, 46]]}}}, {"text": "Use the JDK's URLEncoder to ensure that the id you get from the database is converted to a URI-friendly format (Note that if your data contains characters that cannot be printed in xml and have no percent encoding, you'll need to manually handle them)", "label": {"api": {"URLEncoder": [[14, 23]]}}}, {"text": "Is it acceptable to use types from the java.io and java.nio packages to access the file system and manipulate files in EJB", "label": {"api": {"java.io": [[39, 45]], "java.nio": [[51, 58]]}}}, {"text": "When you're loading your images using getClass().getResource(), the JVM in fact uses your CLASSPATH to load the resource (you should take a close look at Class#getResource(...))", "label": {"api": {"Class#getResource(...)": [[154, 175]]}}}, {"text": "The http response status code can be changed by using the HttpServletResponse.sendError(int) method, e.g", "label": {"api": {"HttpServletResponse.sendError(int)": [[58, 91]]}}}, {"text": "Consider the Pane#getChildren method", "label": {"api": {"Pane#getChildren": [[13, 28]]}}}, {"text": "You can do this with substrings and concatenation", "label": {"api": {"substrings": [[21, 30]]}}}, {"text": "For insert, update, and delete statements, you should use the executeUpdate() method", "label": {"api": {"executeUpdate() method": [[62, 83]]}}}, {"text": "When you don't override equals, your PC objects inherits the equals method from Object, which performs the same thing as == -- comparing object references to see if they are the same object", "label": {"api": {"equals method from Object": [[61, 85]]}}}, {"text": "One example is using a ScheduledThreadPoolExecutor for tasks that are executed periodically or have a timeout, and use another ThreadPoolExecutor for everything else", "label": {"api": {"ScheduledThreadPoolExecutor": [[23, 49]]}}}, {"text": "You can either keep the stream open or use the append mode by specifying true after the file (name)", "label": {"api": {"append mode": [[47, 57]]}}}, {"text": "Insert a six-party cyclic barrier at the start of the thread function and see them race (possibly even losing some i increments since i++ is not guaranteed to be atomic)", "label": {"api": {"cyclic barrier": [[19, 32]]}}}, {"text": "This code could have used BitSet instead, though the iteration would become much more complicated (you'd essentially end up emulating a binary increment)", "label": {"api": {"BitSet": [[26, 31]]}}}, {"text": "As of Java 7, reading the whole of a file really easy - just use Files.readAllBytes(path)", "label": {"api": {"Files.readAllBytes(path)": [[65, 88]]}}}, {"text": "If you need to do this more manually, you should use a FileInputStream - your code so far allocates an array, but doesn't read anything from the file", "label": {"api": {"FileInputStream": [[55, 69]]}}}, {"text": "To read just a portion of a file, you should look at using RandomAccessFile, which allows you to seek to wherever you want", "label": {"api": {"RandomAccessFile": [[59, 74]]}}}, {"text": "I read the Oracle documentation on the Scanner class and came across this", "label": {"api": {"Oracle documentation on the Scanner class": [[11, 51]]}}}, {"text": "I would suggest using a HashMap instead", "label": {"api": {"HashMap": [[24, 30]]}}}, {"text": "HashMaps contain a set of keys and values instead of one value like array lists", "label": {"api": {"HashMap": [[0, 6]]}}}, {"text": "HashMap, however, does not have a containsAll method, but you can get a set of the keys(ingredients) and then call Set.containsAll", "label": {"api": {"HashMap": [[0, 6]], "Set.containsAll": [[115, 129]]}}}, {"text": "The next() method in the Scanner returns the next token, tokenized by a delimieter which is by default whitespace", "label": {"api": {"Scanner": [[25, 31]]}}}, {"text": "A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace", "label": {"api": {"Scanner": [[2, 8]]}}}, {"text": "And at compile time it will pick the method PrintStream.print(String), not PrintStream.print(int) or PrintStream.print(Object), both of which would succeed", "label": {"api": {"PrintStream.print(String)": [[44, 68]], "PrintStream.print(int)": [[75, 96]], "PrintStream.print(Object)": [[101, 125]]}}}, {"text": "You can use HttpUrlConnection to read a chunked response", "label": {"api": {"HttpUrlConnection": [[12, 28]]}}}, {"text": "FileWriter you just open your File with FileWriter(File file, boolean append=true) and call close() when your done", "label": {"api": {"FileWriter": [[0, 9], [40, 49]]}}}, {"text": "Use @Column.columnDefinition to customize the DB type of this column", "label": {"api": {"@Column.columnDefinition": [[4, 27]]}}}, {"text": "Create a Comparator<YourClass> instance with the following compare() method", "label": {"api": {"Comparator<YourClass> instance": [[9, 38]]}}}, {"text": "This implementation uses the java.util.Random PRNG and should work fine for your needs", "label": {"api": {"java.util.Random": [[29, 44]]}}}, {"text": "However, here is a fire&forget comparison of the implementation above against the Collections#shuffle method", "label": {"api": {"Collections#shuffle": [[82, 100]]}}}, {"text": "1 See java.lang.invoke end of chapter \"timing of linkage\", courtesy of @Holger", "label": {"api": {"java.lang.invoke end of chapter \"timing of linkage\"": [[6, 56]]}}}, {"text": "The basic idea would be to loop over every String in your List, and for each of these take the first character (Look at the docs for String for this) and then print it in your usual way (I'd guess at System.out.println())", "label": {"api": {"the docs for String": [[120, 138]]}}}, {"text": "An easy way to see what's happening is to 'inherit' the STDOUT/STDERR streams using a ProcessBuilder", "label": {"api": {"using a ProcessBuilder": [[78, 99]]}}}, {"text": "See ZipFile and JarFile for details", "label": {"api": {"ZipFile": [[4, 10]], "JarFile": [[16, 22]]}}}, {"text": "3.0.5 contains ALG_EC_PACE_GM", "label": {"api": {"ALG_EC_PACE_GM": [[15, 28]]}}}, {"text": "The WeakHashMap API specifies that \"if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() method, the iterator will throw a ConcurrentModificationException.\"â€  Verify that you are using the iterator, as shown here", "label": {"api": {"WeakHashMap": [[4, 14]]}}}, {"text": "You can update the GUI on the event dispatch thread using EventQueue.invokeLater(), as shown here", "label": {"api": {"EventQueue.invokeLater()": [[58, 81]]}}}, {"text": "You are using contains, which determines if the argument exists as a value in the Hashtable, not as a key", "label": {"api": {"contains": [[14, 21]]}}}, {"text": "Use containsKey instead, which determines if the argument exists as a key", "label": {"api": {"contains": [[4, 11]], "containsKey": [[4, 14]]}}}, {"text": "The value 1200L is converted to a Long instance via auto-boxing using the method Long.valueOf which is allowed, but not required to cache frequently requested values", "label": {"api": {"Long.valueOf": [[81, 92]]}}}, {"text": "java.util.Stack is a subclass of java.util.Vector which was a Thread-safe precursor to ArrayList", "label": {"api": {"java.util.Stack": [[0, 14]]}}}, {"text": "The replaceAll method uses regular expressions, and the $ character is a metacharacter in a regular expression that represents the end of the string", "label": {"api": {"replaceAll": [[4, 13]], "regular expressions": [[27, 45]], "replace": [[4, 10]]}}}, {"text": "However, the replace method also replaces all instances of the target string with the replacement string, and uses an ordinary string, not a regular expression", "label": {"api": {"replace": [[13, 19], [33, 39], [86, 92]]}}}, {"text": "If you're looking for a string, you can use Math.log10 to find the right index into an array", "label": {"api": {"Math.log10": [[44, 53]]}}}, {"text": "Java's BufferStrategy is a more complex solution that can use hardware features for page flipping", "label": {"api": {"BufferStrategy": [[7, 20]]}}}, {"text": "Although it's not mentioned in the Java documentation for the Object class, all classes derived from Object have a public static Class<T> class member that stores the runtime type of said object", "label": {"api": {"Object": [[62, 67], [101, 106]]}}}, {"text": "A random IV should be generated for each encrypted message using SecureRandom.getBytes()", "label": {"api": {"SecureRandom.getBytes()": [[65, 87]]}}}, {"text": "You could consider using a List of Strings", "label": {"api": {"List": [[27, 30]]}}}, {"text": "I would have a LinkedBlockingQueue on each client-side thread", "label": {"api": {"LinkedBlockingQueue": [[15, 33]]}}}, {"text": "The LinkedBlockingQueue will manage the locking and synchronization for you", "label": {"api": {"LinkedBlockingQueue": [[4, 22]]}}}, {"text": "which is shorter, and honors the compareTo requirement that sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) for all x and y", "label": {"api": {"the compareTo requirement": [[29, 53]]}}}, {"text": "StringBuilder is standard to use", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "The BufferedImage class doesn't seem to provide that in any obvious fashion, so you need to calculate or fetch that otherwise", "label": {"api": {"BufferedImage class": [[4, 22]]}}}, {"text": "You are printing the object which calls the default toString() implementation of Discount (inherited from Object)", "label": {"api": {"toString()": [[52, 61]]}}}, {"text": "You can overwrite toString() in Discount to get a custom representation but I guess you just want to remove this System.out statement there", "label": {"api": {"toString()": [[18, 27]]}}}, {"text": "Unless I'm missing something, you would first use Integer.parseInt(String) to parse the int from the String", "label": {"api": {"Integer.parseInt(String)": [[50, 73]]}}}, {"text": "CopyOnWriteArrayList in particular", "label": {"api": {"CopyOnWriteArrayList": [[0, 19]]}}}, {"text": "Every Base64 ASCII character holds 6 bits information (26 = 64), so 4 Base64 characters hold 3 bytes information", "label": {"api": {"Base64": [[6, 11], [70, 75]]}}}, {"text": "You have 16 bytes, so one byte remains at the end, needing 2 Base64 characters, and to make the group up to 4 chars, two padding =s are added", "label": {"api": {"Base64": [[61, 66]]}}}, {"text": "with JavaSE 8 came a class Base64 to replace several older class around", "label": {"api": {"Base64": [[27, 32]]}}}, {"text": "Base64 has several fields of application, with various little changes", "label": {"api": {"Base64": [[0, 5]]}}}, {"text": "Java 8's Base64 even has an option for a non-compatible URL and file name safeversion, where + and / are replaced", "label": {"api": {"Base64": [[9, 14]]}}}, {"text": "Instead use Collections (do not use arrays if not absolutely needed), for example ArrayList", "label": {"api": {"ArrayList": [[82, 90]]}}}, {"text": "You can use a BlockingQueue, for example ArrayBlockingQueue, you can initialize these to a certain size, so the number of items queued will never exceed a certain number, as per this example", "label": {"api": {"ArrayBlockingQueue": [[41, 58]]}}}, {"text": "There are many new APIs you can take advantage of, such as TextFieldTableCell", "label": {"api": {"TextFieldTableCell": [[59, 76]]}}}, {"text": "You can't do that because ArrayList does not implement Queue", "label": {"api": {"ArrayList": [[26, 34]], "Queue": [[55, 59]]}}}, {"text": "You could use a LinkedList instead", "label": {"api": {"LinkedList": [[16, 25]]}}}, {"text": "PriorityQueue has a constructor which does this for you", "label": {"api": {"PriorityQueue has a constructor": [[0, 30]]}}}, {"text": "You can use the doubleValue() method on both numbers and then compare the double values", "label": {"api": {"doubleValue()": [[16, 28]]}}}, {"text": "The CSS documentation for TitledPane appears to be wrong", "label": {"api": {"CSS documentation for TitledPane": [[4, 35]]}}}, {"text": "You can use the setProperty(String key, String value) to change the values at runtime", "label": {"api": {"setProperty(String key, String value)": [[16, 52]]}}}, {"text": "Wrap it with a BufferedReader and start reading the data from it", "label": {"api": {"BufferedReader": [[15, 28]]}}}, {"text": "Use the parse method of the SimpleDateFormat class with an appropriate pattern for your input string", "label": {"api": {"SimpleDateFormat": [[28, 43]]}}}, {"text": "If you want to convert back into a string with another format, use the format method of another  SimpleDateFormat object", "label": {"api": {"SimpleDateFormat": [[97, 112]]}}}, {"text": "Because you aren't overriding equals, Key inherits equals from Object, which only determines if the two objects are the same object, not whether their contents are equal", "label": {"api": {"equals from Object": [[51, 68]]}}}, {"text": "Because the exception is a checked exception and needs to be declared or enclosed Ã¬n a try/catch block", "label": {"api": {"checked exception": [[27, 43]]}}}, {"text": "If teamName is of type String String's compareTo(...) is invoked", "label": {"api": {"compareTo(...)": [[39, 52]]}}}, {"text": "The two basic things (not specific to Eclipse) that are used there are XStream and java.io.ObjectOutputStream", "label": {"api": {"java.io.ObjectOutputStream": [[83, 108]]}}}, {"text": "NumberFormatException error from the parseInt function when the string is in the wrong format", "label": {"api": {"NumberFormatException": [[0, 20]]}}}, {"text": "This is typically done with a system.out.println(insertStringVariableHere)", "label": {"api": {"system.out.println": [[30, 47]]}}}, {"text": "You can also use the Object class for the type of the list, but then you need to be careful when you get objects out of the list as they are going to be of type Object and casting will be required based on the type of each object", "label": {"api": {"Object": [[21, 26], [161, 166]]}}}, {"text": "If ordering of the elements doesn't matter, I would go for HashSets, and do it as follows", "label": {"api": {"HashSets": [[59, 66]]}}}, {"text": "Note that the removeAll method does modify set b, so if that's not what you want, you would need to make a copy first", "label": {"api": {"removeAll": [[14, 22]]}}}, {"text": "If you enter a non-valid double, such as \"thisisastringnotanumber\", an InputMismatchException is thrown", "label": {"api": {"InputMismatchException is thrown": [[71, 102]]}}}, {"text": "#replaceAll does not change the actual String it just returns new String which contains the changes", "label": {"api": {"#replaceAll": [[0, 10]]}}}, {"text": "You could use a PrintWriter create and write to the file", "label": {"api": {"PrintWriter": [[16, 26]]}}}, {"text": "Since you probably do not know the number of grades in advance, this is a good use case for the ArrayList", "label": {"api": {"ArrayList": [[96, 104]]}}}, {"text": "The ArrayList class has a couple of toArray methods, if you require a \"simple\" array later", "label": {"api": {"ArrayList": [[4, 12]]}}}, {"text": "You should probably implement the Comparable interface in your Age class", "label": {"api": {"Comparable": [[34, 43]]}}}, {"text": "When your class implements the Comparable interface you can use the Arrays.sort() method from the platform", "label": {"api": {"Comparable": [[31, 40]], "Arrays.sort()": [[68, 80]]}}}, {"text": "see also Class.forName(String) and Method.invoke(Object, Object...) and this tutorial on reflection API", "label": {"api": {"Class.forName(String)": [[9, 29]], "Method.invoke(Object, Object...)": [[35, 66]]}}}, {"text": "You can use Collections.nCopies", "label": {"api": {"Collections.nCopies": [[12, 30]]}}}, {"text": "Thus I'll mostly address the ManagedExecutorService, but most of what I say is applicable to WorkManager as well", "label": {"api": {"ManagedExecutorService": [[29, 50]]}}}, {"text": "The difference between using ManagedExecutorService / WorkManager and creating your own threads is that the application server manages the underlying threads", "label": {"api": {"ManagedExecutorService": [[29, 50]]}}}, {"text": "This means the threads you use with this API, and more generally via the javax.enterprise.concurrent.* classes, whether implicitly in the case of asynchronous task submission with a ManagedExecutorService, or explicitly vith a  ManagedThreadFactory, will have a guaranteed consistency with the services provided by the application server, in particular transactions management, security, resources management etc", "label": {"api": {"ManagedExecutorService": [[182, 203]], "ManagedThreadFactory": [[228, 247]]}}}, {"text": "There are constructors in Thread take take Runnable as parameter", "label": {"api": {"constructors": [[10, 21]], "Thread": [[26, 31]], "Runnable": [[43, 50]]}}}, {"text": "As Thread implements Runnable, it's quite obvious that it will work", "label": {"api": {"Thread": [[3, 8]], "Runnable": [[21, 28]]}}}, {"text": "Note that Arrays.sort(double[]) is O(n log n)", "label": {"api": {"Arrays.sort(double[])": [[10, 30]]}}}, {"text": "Use a JPasswordField instead of a JTextField", "label": {"api": {"JPasswordField": [[6, 19]]}}}, {"text": "In ButtonTabComponent, note how the component is given a FlowLayout having FlowLayout.LEFT alignment", "label": {"api": {"FlowLayout": [[57, 66], [75, 84]]}}}, {"text": "In case you need more control, you could also look into the NumberFormat and DecmialFormat", "label": {"api": {"NumberFormat": [[60, 71]], "DecmialFormat": [[77, 89]]}}}, {"text": "You want to use Rectangle.contains", "label": {"api": {"Rectangle.contains": [[16, 33]]}}}, {"text": "I think the method you're looking for is Rectangle2D.createUnion", "label": {"api": {"Rectangle2D.createUnion": [[41, 63]]}}}, {"text": "Using the java.util.Timer", "label": {"api": {"java.util.Timer": [[10, 24]]}}}, {"text": "You can use a URLClassLoader, which takes a List of URLs in its constructor", "label": {"api": {"URLClassLoader": [[14, 27]]}}}, {"text": "You can then load the class by invoking the loadClass method on the URLClassLoader instance to get the Class<?> object for the class that you are after", "label": {"api": {"URLClassLoader": [[68, 81]], "loadClass": [[44, 52]]}}}, {"text": "I have not tried, but the URLClassLoader does also have a getResourceAsStream method", "label": {"api": {"URLClassLoader": [[26, 39]], "getResourceAsStream": [[58, 76]]}}}, {"text": "It's part of the Java EE Specification", "label": {"api": {"Java EE Specification": [[17, 37]]}}}, {"text": "you can get those values using request#getParameter in your doPost() method", "label": {"api": {"request#getParameter": [[31, 50]]}}}, {"text": "From the documentation of Comparator.compare() method (emphasis mine)", "label": {"api": {"Comparator.compare()": [[26, 45]]}}}, {"text": "This can be changed by extending TableCell class to commit editing on focus change, like in this TableView tutorial", "label": {"api": {"TableCell": [[33, 41]]}}}, {"text": "Then, you need to call JFrame.setLocation to move your JFrame, like this", "label": {"api": {"JFrame.setLocation": [[23, 40]]}}}, {"text": "If the JList's cell renderer returns JLabels (which it will by default, or if you have set the renderer to a DefaultListCellRenderer), you can use SwingUtilities.layoutCompoundLabel to determine the bounds of the text", "label": {"api": {"SwingUtilities.layoutCompoundLabel": [[147, 180]]}}}, {"text": "If you're searching for a word, you shouldn't be using .replaceAll() but .find()", "label": {"api": {".replaceAll()": [[55, 67]]}}}, {"text": "This is because Future.get() waits until the task computation completes", "label": {"api": {"Future.get() waits until the task computation completes": [[16, 70]]}}}, {"text": "A Java program can dynamically compile and load automatically-generated classes (see JavaCompiler), but I don't think that it is what a machine-learning program would do", "label": {"api": {"JavaCompiler": [[85, 96]]}}}, {"text": "isBeforeFirst() returns true if the next call to next() will put the cursor on the first row of the ResultSet", "label": {"api": {"isBeforeFirst()": [[0, 14]]}}}, {"text": "In other words, any successful query that has data, once executed, will produce a ResultSet with isBeforeFirst() returning true", "label": {"api": {"isBeforeFirst()": [[97, 111]]}}}, {"text": "You can use a combination of @XmlElementRef and JAXBElement to produce dynamic element names", "label": {"api": {"@XmlElementRef": [[29, 42]], "JAXBElement": [[48, 58]]}}}, {"text": "Make Characteristic a subclass of JAXBElement and override the getName() method to return the name based on the characteristic property", "label": {"api": {"JAXBElement": [[34, 44]]}}}, {"text": "Annotate characteristics with @XmlElementRef", "label": {"api": {"@XmlElementRef": [[30, 43]]}}}, {"text": "It has a characteristics property which is annotated with @XmlElementRef", "label": {"api": {"@XmlElementRef": [[58, 71]]}}}, {"text": "This means that the contents should be either JAXBElements or @XmlRootElement-annotated class instances", "label": {"api": {"JAXBElement": [[46, 56]]}}}, {"text": "Recall, the characteristics property must contain either @XmlRootElement-annotated class instances or JAXBElements", "label": {"api": {"JAXBElement": [[102, 112]]}}}, {"text": "But JAXBElement is dynamic", "label": {"api": {"JAXBElement": [[4, 14]]}}}, {"text": "You can subclass JAXBElement and override the getName() method", "label": {"api": {"JAXBElement": [[17, 27]]}}}, {"text": "And then totalTable.getPrintable for printing", "label": {"api": {"totalTable.getPrintable": [[9, 31]]}}}, {"text": "Set#add(Object) returns true when the object was added successfully and false otherwise", "label": {"api": {"Set#add(Object)": [[0, 14]]}}}, {"text": "Believe you need a CallableStatement (which by the way is a subclass of PreparedStatement) and that you need to use 'registerOutParameter'", "label": {"api": {"CallableStatement": [[19, 35]], "PreparedStatement": [[72, 88]]}}}, {"text": "Then, of course, you have to handle all the issues around concurrency, which involves things like the synchronized keyword, various things (perhaps) from java.util.concurrent and its child packages, etc", "label": {"api": {"java.util.concurrent": [[154, 173]]}}}, {"text": "When interacting with the data of the table, we want to use the TableModel of the table", "label": {"api": {"TableModel": [[64, 73]]}}}, {"text": "The TableModel is what actually holds the data, and allows us to easily manipulate the data in the table", "label": {"api": {"TableModel": [[4, 13]]}}}, {"text": "You can either implement your own AbstractTableModel or use the DefaultTableModel, which already provides an implementation, that comes equipped with method for adding row and other goodies", "label": {"api": {"TableModel": [[42, 51], [71, 80]], "AbstractTableModel": [[34, 51]], "DefaultTableModel": [[64, 80]]}}}, {"text": "With DefaultTableModel, you can simply call the method addRow(Object[])  or addRow(Vector) to add a row dynamically at runtime", "label": {"api": {"TableModel": [[12, 21]], "DefaultTableModel": [[5, 21]], "addRow(Object[])": [[55, 70]], "addRow(Vector)": [[76, 89]]}}}, {"text": "The DefaultTableModel implementation will fire the necessary updates to call for a repainting of the table", "label": {"api": {"TableModel": [[11, 20]], "DefaultTableModel": [[4, 20]]}}}, {"text": "See the DefaultTableModel API for other useful methods and constructors", "label": {"api": {"TableModel": [[15, 24]], "DefaultTableModel": [[8, 24]], "DefaultTableModel API": [[8, 28]]}}}, {"text": "prices and quantity aren't arrays, they are ArrayLists", "label": {"api": {"ArrayList": [[44, 52]]}}}, {"text": "In Java <= 7, java.util.Date is designed for this purpose", "label": {"api": {"java.util.Date": [[14, 27]]}}}, {"text": "In Java >= 8, java.time.Instant is designed for this purpose", "label": {"api": {"java.time.Instant": [[14, 30]]}}}, {"text": "In Java you can get the milliseconds since the UNIX Epoch with System.currentTimeMillis() which returns a long, so there's no reason to consider something else", "label": {"api": {"System.currentTimeMillis()": [[63, 88]]}}}, {"text": "Another, possibly more useful solution might be to implement Comparable, which would let you see if a team is less than, equal to, or greater than another team", "label": {"api": {"Comparable": [[61, 70]]}}}, {"text": "Another way would be to use Map#computeIfAbsent like this to create and add a new list of the type you want to the map and then add the item to the list when it is returned", "label": {"api": {"Map#computeIfAbsent": [[28, 46]]}}}, {"text": "Assuming these methods are public, then in Java 8, you should be able to use a functional interface (in this trivial example it would be a java.util.function.IntSupplier) and pass a reference to these methods as a lambda expression", "label": {"api": {"java.util.function.IntSupplier": [[139, 168]]}}}, {"text": "You can use Map#replaceAll if you are using Java 8+", "label": {"api": {"Map#replaceAll": [[12, 25]]}}}, {"text": "From the link above the default implementation of Map#replaceAll is equivalent to", "label": {"api": {"Map#replaceAll": [[50, 63]]}}}, {"text": "From JavaDoc of Class.getDeclaredMethods()", "label": {"api": {"JavaDoc of Class.getDeclaredMethods()": [[5, 41]]}}}, {"text": "#open method finds the specified default app to open the specified file but in .file type there is no default app to open the file.You can only specify manually to open it in specific app.So if you set the default application that should open the .file and you have to set the default application and choose default program to open the file and than run the program", "label": {"api": {"#open": [[0, 4]]}}}, {"text": "Yes, use http://docs.oracle.com/javase/7/docs/api/java/io/File.html#getCanonicalPath()", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/File.html#getCanonicalPath()": [[9, 85]]}}}, {"text": "That means you either have to redirect stdout while starting the process or you have to read the output in a loop in the parent process", "label": {"api": {"redirect stdout": [[30, 44]]}}}, {"text": "You need to implement a Comparator", "label": {"api": {"Comparator": [[24, 33]]}}}, {"text": "Then, you can use it in conjuction with Collections.sort(List)", "label": {"api": {"Collections.sort(List)": [[40, 61]]}}}, {"text": "You should rather look into DecimalFormat if you intend to output the same string regardless of the operating system's current locale", "label": {"api": {"DecimalFormat": [[28, 40]]}}}, {"text": "By creating a formatting string such as \"$#,##0\" and passing an instance of DecimalFormatSymbols where you set the grouping character to '.' you will achieve your intended output without hacks", "label": {"api": {"DecimalFormat": [[76, 88]], "DecimalFormatSymbols": [[76, 95]]}}}, {"text": "Class#valueOf needs a String parameter", "label": {"api": {"Class#valueOf": [[0, 12]]}}}, {"text": "You could use DecimalFormat, check the link for further information on formatting patterns", "label": {"api": {"DecimalFormat": [[14, 26]]}}}, {"text": "You can set it to eg a StringInputStream right before invoking of main (System.setIn())", "label": {"api": {"System.setIn()": [[72, 85]]}}}, {"text": "The key is that the Graphics2D#rotate() executes the following calls", "label": {"api": {"Graphics2D#rotate()": [[20, 38]]}}}, {"text": "See for instance ArrayBlockingQueue(int capacity)", "label": {"api": {"ArrayBlockingQueue(int capacity)": [[17, 48]]}}}, {"text": "I would look into the ScheduledExecutorService and have it periodically execute a Runnable", "label": {"api": {"ScheduledExecutorService": [[22, 45]]}}}, {"text": "One of these points is \"starting a thread\" and submitting to an executor carries the same guarantees as starting a thread (see the \"memory consistency effects\" in the javadocs)", "label": {"api": {"\"memory consistency effects\"": [[131, 158]]}}}, {"text": "Formatter will truncate the size of the file to 0", "label": {"api": {"Formatter": [[0, 8]]}}}, {"text": "Use PrintWriter instead", "label": {"api": {"PrintWriter": [[4, 14]]}}}, {"text": "Then you can use the PrintWriter's printf to do the same thing", "label": {"api": {"PrintWriter": [[21, 31]], "PrintWriter's printf": [[21, 40]]}}}, {"text": "Perhaps calling Window's getOwnedWindows() is what you're looking for, and all class that derive from Window will have this method, including JFrame and JDialog", "label": {"api": {"Window": [[16, 21], [33, 38], [102, 107]]}}}, {"text": "So donâ€™t modify System.out, instead change the output in the context of your scripting engine engine.getContext().setWriter(stringWriter)", "label": {"api": {"getContext()": [[101, 112]], "setWriter(": [[114, 123]]}}}, {"text": "You can use SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "You need to investigate javax.xml.bind.annotation.XmlIDREF and friends", "label": {"api": {"javax.xml.bind.annotation.XmlIDREF": [[24, 57]]}}}, {"text": "See the direct known subclasses of Exception and RuntimeException", "label": {"api": {"Exception": [[35, 43], [56, 64]], "RuntimeException": [[49, 64]]}}}, {"text": "Some Exceptions also have many specialized subclasses, for example look at the direct subclasses of IllegalArgumentException or IllegalStateException", "label": {"api": {"Exception": [[5, 13], [115, 123], [140, 148]], "IllegalArgumentException": [[100, 123]], "IllegalStateException": [[128, 148]]}}}, {"text": "For example if your method takes a parameter which cannot be null, use NullPointerException", "label": {"api": {"Exception": [[82, 90]], "NullPointerException": [[71, 90]]}}}, {"text": "If the parameter has a valid range and you don't accept other values, use IllegalArgumentException", "label": {"api": {"Exception": [[89, 97]], "IllegalArgumentException": [[74, 97]]}}}, {"text": "Create a custom Exception if there is no existing one in the standard library (or in the libraries you use) for its purpose or if the Exception you want to throw should be differentiable from the Exceptions that may be thrown by the code and methods you call from your method", "label": {"api": {"Exception": [[16, 24], [134, 142], [196, 204]]}}}, {"text": "Use Combination of subString() and indexOf() functions", "label": {"api": {"subString()": [[19, 29]], "indexOf()": [[35, 43]]}}}, {"text": "Use an EnumMap - it was intended for just this case", "label": {"api": {"EnumMap": [[7, 13]]}}}, {"text": "From the Javadocs", "label": {"api": {"the Javadocs": [[5, 16]]}}}, {"text": "If you want a cast to be checked at execution time, you'll need the relevant Class object, at which point you can use Class.cast to check it", "label": {"api": {"Class.cast": [[118, 127]]}}}, {"text": "All JDBC database drivers must implement the setObject() setter which seems to be a sort of guessing function for the SQL data type", "label": {"api": {"setObject()": [[45, 55]]}}}, {"text": "Yes, you need to set cell value factory for every column in the table, that's for sure", "label": {"api": {"cell value factory": [[21, 38]]}}}, {"text": "From your fxml file is obvious that you need to add cell value factory for every column, something like in the following example, just replace firstName with property name from your data model bean", "label": {"api": {"cell value factory": [[52, 69]]}}}, {"text": "There are further alternatives with package name-based context path as well", "label": {"api": {"context path": [[55, 66]]}}}, {"text": "However String.format with using placeholders like %s works as a good substitute", "label": {"api": {"String.format": [[8, 20]]}}}, {"text": "In practical terms, you can start with an empty Stack object and add the first node to it using Stack.push()", "label": {"api": {"Stack": [[48, 52], [96, 100]]}}}, {"text": "Then you can do a while !Stack.empty()", "label": {"api": {"Stack": [[25, 29]]}}}, {"text": "Use a DocumentFilter like they show in Implementing a Document Filter", "label": {"api": {"DocumentFilter": [[6, 19]]}}}, {"text": "Using the FilterBypass, you can get a reference to the text area's PlainDocument, and you can check the number of lines returned by the root element", "label": {"api": {"PlainDocument": [[67, 79]]}}}, {"text": "You can use a couple of SimpleDateFormats - one to parse the string you got, and one to reformat it", "label": {"api": {"SimpleDateFormat": [[24, 39]]}}}, {"text": "Java typically takes a date as either some string to be parsed, or a long number of milliseconds since the epoch, or, in the case of java.time.LocalDate, it can take the number of days since the epoch", "label": {"api": {"java.time.LocalDate": [[133, 151]]}}}, {"text": "I have used a DateTimeFormatter to format the date (there is a predefined formatter for the format you specified named ISO_LOCAL_TIME), but that is the same as the default format for LocalDate, so you can just call its toString() method", "label": {"api": {"DateTimeFormatter": [[14, 30]]}}}, {"text": "If you want to format it differently, just create a DateTimeFormatter with the desired format", "label": {"api": {"DateTimeFormatter": [[52, 68]]}}}, {"text": "Instead, you want to call the executeQuery() (no arguments) method", "label": {"api": {"executeQuery() (no arguments) method": [[30, 65]]}}}, {"text": "As mentioned in comments, I read from a simple Datagram Channel", "label": {"api": {"Datagram Channel": [[47, 62]]}}}, {"text": "You can use the static method Pattern.matches", "label": {"api": {"Pattern.matches": [[30, 44]]}}}, {"text": "The API documentation for ResultSet.next says", "label": {"api": {"API documentation for ResultSet.next": [[4, 39]]}}}, {"text": "You can extend any class dynamically using a Proxy so essentially yes - if the anonymous calss implements an interface", "label": {"api": {"Proxy": [[45, 49]]}}}, {"text": "Check out the documentation on the Scanner class for more information", "label": {"api": {"documentation on the Scanner": [[14, 41]]}}}, {"text": "You could use replaceAll and replace, as follows", "label": {"api": {"replaceAll": [[14, 23]], "replace": [[14, 20], [29, 35]]}}}, {"text": "The replaceAll method searches the string for a match to the regex given in the first argument, and replaces each match with the text in the second argument", "label": {"api": {"replaceAll": [[4, 13]], "replace": [[4, 10], [100, 106]]}}}, {"text": "We search for slashes at the start of the string (^/) or the end of the string (/$), and replace them with nothing", "label": {"api": {"replace": [[89, 95]]}}}, {"text": "Then, we replace all remaining slashes with underscores using replace", "label": {"api": {"replace": [[9, 15], [62, 68]]}}}, {"text": "Use a SwingWorker to handle these operations", "label": {"api": {"SwingWorker": [[6, 16]]}}}, {"text": "The simple fix is to use hand.clear() although other solutions include iterating through the indices backwards or always \"popping\" the end", "label": {"api": {"hand.clear()": [[25, 36]]}}}, {"text": "java.util.List does have a suitable add() method and your code does compile in Ideone", "label": {"api": {"suitable add() method": [[27, 47]]}}}, {"text": "toString on byte arrays always works as Object.toString", "label": {"api": {"Object.toString": [[40, 54]]}}}, {"text": "Arrays.toString returns a string based on the array's contents", "label": {"api": {"Arrays.toString": [[0, 14]]}}}, {"text": "The map is empty as expected But, i thought Iterator#hasNext would return false, but instead it returned true and Iterator#next threw a ConcurrentModificationException", "label": {"api": {"Iterator#hasNext": [[44, 59]], "Iterator#next": [[114, 126]]}}}, {"text": "java.math.BigInteger is for \"Immutable arbitrary-precision integers\" - should fit your needs perfectly", "label": {"api": {"java.math.BigInteger": [[0, 19]]}}}, {"text": "Or use a proper layout manager which allows you to add many components to the Container like GridLayout or use Containers like Box", "label": {"api": {"GridLayout": [[93, 102]], "Box": [[127, 129]]}}}, {"text": "You can use String#replaceAll() in Java", "label": {"api": {"String#replaceAll()": [[12, 30]]}}}, {"text": "You could use Object's getClass method and you'll get the implementing class", "label": {"api": {"getClass": [[23, 30]]}}}, {"text": "You may use a SortedMap to store the frequency as Key and number as the Value", "label": {"api": {"SortedMap": [[14, 22]]}}}, {"text": "Catch SQLExceptoin then use SQLException.getSQLState() and compare it to see if it's what you want", "label": {"api": {"SQLException.getSQLState()": [[28, 53]]}}}, {"text": "Just adding this for completions sake, if anyone is using Java 8, you have access to the Stream API", "label": {"api": {"Stream API": [[89, 98]]}}}, {"text": "You'll get a NotSerializableException if you attempt to serialize the wrapper class (without making that field transient)", "label": {"api": {"NotSerializableException": [[13, 36]]}}}, {"text": "HttpServletRequest#login is only available in Servlet spec 3.0 or greater", "label": {"api": {"HttpServletRequest#login": [[0, 23]]}}}, {"text": "Or use the Joiner class from Guava, or StringJoiner from Java 8, both of which are designed for this sort of thing", "label": {"api": {"StringJoiner": [[39, 50]]}}}, {"text": "contains method use the method equals(e) and when you use equals on array it's the same thing as using == hence you check for reference equality, not content", "label": {"api": {"contains": [[0, 7]], "equals(e)": [[31, 39]]}}}, {"text": "To check if two arrays are equals you have to use Arrays.equals(array1, array2) or Arrays.deepEquals(nestedArray1, nestedArray2) for nested arrays", "label": {"api": {"Arrays.equals": [[50, 62]], "Arrays.deepEquals": [[83, 99]]}}}, {"text": "If you want common settings for the entire system, check out systemNodeForPackage", "label": {"api": {"systemNodeForPackage": [[61, 80]]}}}, {"text": "For this case, a List<String> will suffice", "label": {"api": {"List<String>": [[17, 28]]}}}, {"text": "Don't use remove by index - use remove by reference", "label": {"api": {"remove by index": [[10, 24]], "remove by reference": [[32, 50]]}}}, {"text": "If you are using any Object, then override the equals() method, for equality check", "label": {"api": {"Object": [[21, 26]], "equals()": [[47, 54]]}}}, {"text": "If you want to compare them, then implement the Comparable interface, or create a Comparator for them", "label": {"api": {"Comparable": [[48, 57]], "Comparator": [[82, 91]]}}}, {"text": "matches() tells whether or not the entire string matches the given regular expression", "label": {"api": {"matches()": [[0, 8]]}}}, {"text": "I want to send a text file selected from FileChooser to a server (written in PHP) using HTTP POST method", "label": {"api": {"FileChooser": [[41, 51]]}}}, {"text": "Thread.UncaughtExceptionHandler was added in Java 1.5", "label": {"api": {"Thread.UncaughtExceptionHandler": [[0, 30]]}}}, {"text": "You can use a StringBuilder", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "use a PropertyChangeSupport object", "label": {"api": {"PropertyChangeSupport": [[6, 26]]}}}, {"text": "You should use the URLEncoder class to encode text which you plan to append to urls, like this", "label": {"api": {"URLEncoder": [[19, 28]]}}}, {"text": "URLEncoder properly escapes all special characters, you can safely append encoded to URL strings", "label": {"api": {"URLEncoder": [[0, 9]]}}}, {"text": "What are their reasons against doing so (in Java 8 it is still not deprecated)", "label": {"api": {"still not deprecated": [[57, 76]]}}}, {"text": "To make this easy, I suggest that you use an ArrayList instead", "label": {"api": {"ArrayList": [[45, 53]]}}}, {"text": "The JavaDoc for ResultSet#getBinaryStream() states that it returns null for the column containing SQL NULL", "label": {"api": {"ResultSet#getBinaryStream()": [[16, 42]]}}}, {"text": "Even though the JavaDoc for the ResultSet#getBlob() omits to mention the same, it looks to me that the test rows do not contain any data in the blob column, i.e", "label": {"api": {"ResultSet#getBlob()": [[32, 50]]}}}, {"text": "Use LinkedHashSet instead if you need to preserve the order", "label": {"api": {"LinkedHashSet": [[4, 16]]}}}, {"text": "However LinkedHashSet maintains an additional linked list so needs more resources", "label": {"api": {"LinkedHashSet": [[8, 20]]}}}, {"text": "Try Collections.sort() instead of Arrays.sort()", "label": {"api": {"Collections.sort()": [[4, 21]]}}}, {"text": "See this page which gives an example of how to extract a zip file entirely with Java code; to delete a file, use Files.delete()", "label": {"api": {"Files.delete()": [[113, 126]]}}}, {"text": "We are serializing and deserializing Data with java XMLEncoder and XMLDecoder", "label": {"api": {"XMLEncoder": [[52, 61]], "XMLDecoder": [[67, 76]]}}}, {"text": "You can read an object like in the example provided in the javadoc of XMLDecoder", "label": {"api": {"XMLDecoder": [[70, 79]]}}}, {"text": "I was wondering if there is a way to validate the contents provided to XMLDecoder (in the example above the file content of \"Test.xml\") in advance so the XMLDecoder can properly work with it", "label": {"api": {"XMLDecoder": [[71, 80], [154, 163]]}}}, {"text": "Or is there a \"XMLEncoder\" dtd or xsd of some sort", "label": {"api": {"XMLEncoder": [[15, 24]]}}}, {"text": "And JarClassLoader should call the appropriate super constructor of ClassLoader", "label": {"api": {"the appropriate super constructor of ClassLoader": [[31, 78]]}}}, {"text": "Don't use the same Connection in your application", "label": {"api": {"Connection": [[19, 28]]}}}, {"text": "Then, call MyClass.getConnection(\"jdbc:mysql://localhost:3306/\") or whatever the connection string is, and it will return one Connection that you could use for all classes", "label": {"api": {"Connection": [[22, 31], [126, 135]]}}}, {"text": "This is done in a jsp or a servlet by calling HttpServletResponse#sendRedirect", "label": {"api": {"HttpServletResponse#sendRedirect": [[46, 77]]}}}, {"text": "Instead of storing all your Data instances in an array, you can consider storing them in a HashMap, assuming you are working with Java", "label": {"api": {"HashMap": [[91, 97]]}}}, {"text": "Have you considered alternative formats such as the preferences API which might be more portable (i.e", "label": {"api": {"preferences API": [[52, 66]]}}}, {"text": "Java 8's java.time or Joda-Time)", "label": {"api": {"java.time": [[9, 17]]}}}, {"text": "In case you want a bounded queue which will sleep until there is capacity free you can use the ArrayBlockingQueue", "label": {"api": {"ArrayBlockingQueue": [[95, 112]]}}}, {"text": "Internally it will use a Condition to wait for capacity", "label": {"api": {"Condition": [[25, 33]]}}}, {"text": "Try use ready data structure Blocking queue", "label": {"api": {"Blocking queue": [[29, 42]]}}}, {"text": "Use Matcher's group so you can get the patterns that actually matched", "label": {"api": {"Matcher": [[4, 10]]}}}, {"text": "In Matcher, the matches inside parenthesis will be captured and can be retrieved via the group() method", "label": {"api": {"Matcher": [[3, 9]]}}}, {"text": "See also Pattern", "label": {"api": {"Pattern": [[9, 15]]}}}, {"text": "Instead, I suggest you use a ResourceBundle (or even Properties)", "label": {"api": {"ResourceBundle": [[29, 42]]}}}, {"text": "You can use Calender for this", "label": {"api": {"Calender": [[12, 19]]}}}, {"text": "A BufferedInputStream is used to read bytes", "label": {"api": {"BufferedInputStream": [[2, 20]]}}}, {"text": "BufferedReader also has a readLine() method which reads a whole line, use that", "label": {"api": {"BufferedReader": [[0, 13]], "readLine()": [[26, 35]]}}}, {"text": "Potentially, if you don't want to go in Arvind's way (which I think it's a good idea actually), you can format your Date using SimpleDateFormat", "label": {"api": {"SimpleDateFormat": [[127, 142]]}}}, {"text": "You should also consider using a PreparedStatement instead of building the statement using String concatenation", "label": {"api": {"PreparedStatement": [[33, 49]]}}}, {"text": "Alternatively, you could look into using one of the concurrent Collections like the CopyOnWriteArrayList for example or the ConcurrentHashMap, depending on your needs", "label": {"api": {"CopyOnWriteArrayList": [[84, 103]], "ConcurrentHashMap": [[124, 140]]}}}, {"text": "In this very case, the recommandation would be to use the interface from which this method is defined, as specified in the JavaDoc of LinkedList", "label": {"api": {"LinkedList": [[134, 143]]}}}, {"text": "removeFirst comes from the interface Deque and this is the interface you should probably be using rather than working  directly with the implementation", "label": {"api": {"Deque": [[37, 41]]}}}, {"text": "You've probably imported Swings ListModel accidentally which is an interface", "label": {"api": {"ListModel": [[32, 40]]}}}, {"text": "Import org.apache.wicket.model.util.ListModel ensuring that the wicket-core jar file is on the classpath", "label": {"api": {"ListModel": [[36, 44]]}}}, {"text": "As per Process javadoc", "label": {"api": {"Process javadoc": [[7, 21]]}}}, {"text": "If we carefully read the waitFor() documentation", "label": {"api": {"waitFor() documentation": [[25, 47]]}}}, {"text": "If you implement a TableModel, you will be able to exactly determine how data is added and which data types are displayed in your table", "label": {"api": {"TableModel": [[19, 28]]}}}, {"text": "I do not really understand your code but it seems that what your a looking for is a Semaphore", "label": {"api": {"Semaphore": [[84, 92]]}}}, {"text": "You need a FocusListener for it, like this", "label": {"api": {"FocusListener": [[11, 23]]}}}, {"text": "Try the javax.activation.URLDataSource or the javax.activation.FileDataSource instead", "label": {"api": {"javax.activation.URLDataSource": [[8, 37]], "javax.activation.FileDataSource": [[46, 76]], "DataSource": [[28, 37], [67, 76]]}}}, {"text": "Otherwise, you can create your own DataSource adapter class to directly return the given InputStream", "label": {"api": {"DataSource": [[35, 44]]}}}, {"text": "There is no HashSet#get function, there is no HashSet#KeySet function, there is no HashMap#contains function so I recommend you read through the HashSet documentation at http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html and HashMap documentation http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html before going any further", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html": [[170, 232]], "http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html": [[260, 322]]}}}, {"text": "Make your class Implement Comparable", "label": {"api": {"Comparable": [[26, 35]]}}}, {"text": "You can use the applyPattern method to supply a new pattern", "label": {"api": {"applyPattern method": [[16, 34]]}}}, {"text": "Java 8's DateTimeFormatter class has a method, ofPattern(String pattern), that lets you define a format from a string of A-z, a-z letters", "label": {"api": {"DateTimeFormatter": [[9, 25]]}}}, {"text": "Each field is documented in a \"field\" class, such as ChronoField, WeekFields or IsoFields", "label": {"api": {"ChronoField": [[53, 63]], "WeekFields": [[66, 75]]}}}, {"text": "The \"year-of-era\" field is documented in ChronoField", "label": {"api": {"ChronoField": [[41, 51]]}}}, {"text": "The \"week-based-year\" field is documented in WeekFields", "label": {"api": {"WeekFields": [[45, 54]]}}}, {"text": "You can see the official documentation for what you can do this with, but this is the class you will need specifically", "label": {"api": {"the official documentation": [[12, 37]]}}}, {"text": "I've tried replacing every instantiation of HashSet with Collections.synchronizedSet(new HashSet<>());, as recommended in Oracle's HashSet documentation", "label": {"api": {"Oracle's HashSet documentation": [[122, 151]]}}}, {"text": "The functionality you are looking for is (more or less) provided in the Bindings class by the createIntegerBinding method", "label": {"api": {"Bindings": [[72, 79]], "createIntegerBinding method": [[94, 120]]}}}, {"text": "and also (for the specific example you use) by the IntegerExpression class", "label": {"api": {"IntegerExpression": [[51, 67]]}}}, {"text": "In order to implement Runnable you need to override the run() method (unless your class is abstract, which opens another discussion)", "label": {"api": {"Runnable": [[22, 29]]}}}, {"text": "From the Runnable API", "label": {"api": {"Runnable": [[9, 16]]}}}, {"text": "The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread", "label": {"api": {"Runnable": [[4, 11]]}}}, {"text": "Using multiple canvas instances (one for each layer), is the recommended way to create a multi-layered canvas (using an immediate draw API)", "label": {"api": {"canvas": [[15, 20], [103, 108]]}}}, {"text": "This approach to generating a layered canvas system is documented and demonstrated in the Oracle JavaFX tutorials", "label": {"api": {"canvas": [[38, 43]]}}}, {"text": "Your other option, might be to not use a canvas at all, but instead use the JavaFX scene graph (retained draw API), placing the scene graph nodes to be layered inside of Panes (one Pane per layer) and placing all of the layer panes inside a StackPane", "label": {"api": {"canvas": [[41, 46]], "Panes": [[170, 174]], "StackPane": [[241, 249]]}}}, {"text": "You can convert the resultant StackPane to an image at anytime by invoking the node snapshot API on the StackPane", "label": {"api": {"StackPane": [[30, 38], [104, 112]], "snapshot": [[84, 91]]}}}, {"text": "Yes, calling the canvas API immediate draw is a little bit of a misnomer", "label": {"api": {"canvas": [[17, 22]]}}}, {"text": "As far as I understand the implementation design, when you issue drawing commands to a canvas, the commands will usually be placed in a buffer and the buffer flushed to an image texture when the first rendering pulse for the canvas occurs", "label": {"api": {"canvas": [[87, 92], [225, 230]]}}}, {"text": "If you do issue further canvas drawing commands on a subsequent pulse, those additional commands will be buffered then flushed at the rendering stage of the next pulse", "label": {"api": {"canvas": [[24, 29]]}}}, {"text": "For example, if you issue 1 million drawing commands for the canvas in a single pulse, then you will see a pause as those commands are buffered and then rendered, but you won't see the screen gradually update one million times, just a single update", "label": {"api": {"canvas": [[61, 66]]}}}, {"text": "You have to issue an extremely large number of drawing commands to the canvas to see such behaviour", "label": {"api": {"canvas": [[71, 76]]}}}, {"text": "If you had to deal with a simple case like that, where the pattern of locking/unlocking was limited to a narrow scope like this, you probably don't want to use the more complicated Lock class and probably should just be using the synchronized keyword, instead", "label": {"api": {"Lock": [[181, 184]]}}}, {"text": "That being said, if for some reason you needed this with the more complicated Lock object, it should be relatively straight-forward to create a wrapper around Lock that implements the AutoCloseable interface to be able to do just that", "label": {"api": {"Lock": [[78, 81], [159, 162]], "AutoCloseable": [[184, 196]]}}}, {"text": "That being said, the Lock class is typically used for very complicated locking scenarios where this wouldn't be particularly useful", "label": {"api": {"Lock": [[21, 24]]}}}, {"text": "For example, Lock objects may be locked in one function in a class and later unlocked in another function (e.g", "label": {"api": {"Lock": [[13, 16]]}}}, {"text": "locking a row in a database in response to an incoming remote procedure call, and then unlocking that row in response to a later RPC), and thus having such a wrapper or making a Lock AutoCloseable, itself, would be of limited use for the way it is actually used", "label": {"api": {"Lock": [[178, 181]], "AutoCloseable": [[183, 195]]}}}, {"text": "From here looks like the Java Formatter class is what you want", "label": {"api": {"Formatter": [[30, 38]]}}}, {"text": "I don't understand why TreeSet isn't removing the first element here", "label": {"api": {"TreeSet": [[23, 29]]}}}, {"text": "The size of the my TreeSet is supposed to stay bounded, but appears to grow without bound", "label": {"api": {"TreeSet": [[19, 25]]}}}, {"text": "newGroups is a TreeSet<TeamGroup> object which is initialized (with no elements) before the double for loop (the variables group and team are from the two for-each loops)", "label": {"api": {"TreeSet": [[15, 21]]}}}, {"text": "You see that although the if statement is clearly being entered, the size of the TreeSet<TeamGroup> teamGroups isn't being decremented", "label": {"api": {"TreeSet": [[81, 87]]}}}, {"text": "It would seem to me that the only way for this to happen is if the remove call doesn't remove anything--but how can it not remove something from a call to first() which should definitely be an element in the TreeSet", "label": {"api": {"TreeSet": [[208, 214]]}}}, {"text": "JOptionPane.showInputDialog returns an Object, which can't be cast to a double", "label": {"api": {"JOptionPane.showInputDialog": [[0, 26]]}}}, {"text": "Use getTextContent method instead of getNodeValue", "label": {"api": {"Node": [[40, 43]]}}}, {"text": "See documentation on Node class", "label": {"api": {"Node": [[21, 24]]}}}, {"text": "File.listFiles() may return null if it's used on an object is not a directory, or can't be accessed", "label": {"api": {"File.listFiles()": [[0, 15]]}}}, {"text": "Introduction to FXML has example how to build custom components with <fx:root>", "label": {"api": {"Introduction to FXML": [[0, 19]]}}}, {"text": "You can write your custom Comparator", "label": {"api": {"Comparator": [[26, 35]]}}}, {"text": "And then use it with Collections.sort", "label": {"api": {"Collections.sort": [[21, 36]]}}}, {"text": "Your mistake was on the keyboard.next() call", "label": {"api": {"keyboard.next()": [[24, 38]]}}}, {"text": "You want to use keyboard.nextLine() instead, as that reads a whole line (which is what your input is in this case)", "label": {"api": {"keyboard.nextLine()": [[16, 34]]}}}, {"text": "As you haven't posted code i suggest you to check into Comparable class and method compareTo and how to use it for custom classes", "label": {"api": {"Comparable class": [[55, 70]]}}}, {"text": "If you look at the Javadoc for the Serializable interface, it explains how that field is used to make sure the serialized version and what the JVM wants to create from the serialized object are the same", "label": {"api": {"Javadoc for the Serializable interface": [[19, 56]]}}}, {"text": "Set the read timeout on the connection", "label": {"api": {"read timeout": [[8, 19]]}}}, {"text": "Use an actual URI constructor instead of hand-rolling your own", "label": {"api": {"an actual URI constructor": [[4, 28]]}}}, {"text": "Since Version 8 Java has the concept of value-based classes", "label": {"api": {"value-based classes": [[40, 58]]}}}, {"text": "About the existing value-based classes", "label": {"api": {"value-based classes": [[19, 37]]}}}, {"text": "Because future JVM implementations might not use object headers and reference pointers for value-based classes, some of the limitations are clear", "label": {"api": {"value-based classes": [[91, 109]]}}}, {"text": "The easiest way would be to store the strings in an List, and use the Collections.sort method in the Java standard Library", "label": {"api": {"Collections.sort": [[70, 85]]}}}, {"text": "Check the documentation of Class instead", "label": {"api": {"Class": [[27, 31]]}}}, {"text": "You can also use the isInstance method, which is pretty much the exact equivalent of the instanceof operator(with the arguments swapped)", "label": {"api": {"isInstance method": [[21, 37]]}}}, {"text": "I need help rewriting a function so that System.arraycopy() does what the function does", "label": {"api": {"System.arraycopy()": [[41, 58]]}}}, {"text": "Like Petar wrote, indexOf returns -1 when no occurence is found in a String", "label": {"api": {"indexOf": [[18, 24]]}}}, {"text": "Also to simplify your code you should consider using split()", "label": {"api": {"split()": [[53, 59]]}}}, {"text": "However, implementations should declare more specific types thrown (if any)", "label": {"api": {"implementations should declare more specific types thrown": [[9, 65]]}}}, {"text": "For example, when closing a BufferedOutputStream with unflushed data, the buffered stream has two options; ignoring the unwritten data and close, or writing it to the stream, which can cause exceptions to be thrown", "label": {"api": {"BufferedOutputStream": [[28, 47]]}}}, {"text": "The fastest way I know is using the StringTokenizer", "label": {"api": {"StringTokenizer": [[36, 50]]}}}, {"text": "As you can see here that StringTokenizer is faster than using Pattern or split(...) method", "label": {"api": {"StringTokenizer": [[25, 39]]}}}, {"text": "Thread.State RUNNABLE javadoc says", "label": {"api": {"Thread.State RUNNABLE javadoc": [[0, 28]]}}}, {"text": "If your final result does not depend on the order of occurrences of the buckets in the source file, it is strongly recommended that either your collector reports itself to be UNORDERED or you insert an unordered() in the streamâ€™s method chains before the collect", "label": {"api": {"UNORDERED": [[175, 183]], "unordered()": [[202, 212]]}}}, {"text": "In Java class String method charAt() there is an exception thrown at one case", "label": {"api": {"String method charAt()": [[14, 35]]}}}, {"text": "Please refer this String API and read about the valueOf methods", "label": {"api": {"String": [[18, 23]]}}}, {"text": "Try to validate the NaN in android, use Double.isNaN(a/b)", "label": {"api": {"Double.isNaN(a/b)": [[40, 56]]}}}, {"text": "Use Statement#getMoreResults and Statement#getResultSet methods", "label": {"api": {"Statement#getMoreResults": [[4, 27]], "Statement#getResultSet": [[33, 54]]}}}, {"text": "Given the following time stamp generated by java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[44, 61]]}}}, {"text": "Other options for the pattern (the \"0.##E0\" part) can be found in the DecimalFormat documentation", "label": {"api": {"DecimalFormat": [[70, 82]]}}}, {"text": "Use the isEmpty() method instead", "label": {"api": {"isEmpty()": [[8, 16]]}}}, {"text": "javax.servlet.ServletContext.getResourceAsStream(...) exists for this purpose", "label": {"api": {"javax.servlet.ServletContext.getResourceAsStream(...)": [[0, 52]]}}}, {"text": "Have a look at the BlockingQueue interface and the classes that implement it", "label": {"api": {"BlockingQueue": [[19, 31]]}}}, {"text": "Note that even if you use Executors#newFixedThreadPool(2), you will have a thread pool with 2 threads, but this doesn't guarantee that each task is executed in a different thread", "label": {"api": {"Executors#newFixedThreadPool(2)": [[26, 56]]}}}, {"text": "You can create them by using Executors#newSingleThreadExecutor (but this is very cumbersome)", "label": {"api": {"Executors#newSingleThreadExecutor": [[29, 61]]}}}, {"text": "You might want to use  Map collection which is useful to store key value pairs where Id is your key and value is your name", "label": {"api": {"Map": [[23, 25]]}}}, {"text": "The javadocs for ConcurrentHashMap's impelementation of it state", "label": {"api": {"ConcurrentHashMap's impelementation of it": [[17, 57]]}}}, {"text": "The nextInt() method doesn't read the whole line (with carriage return and line feed), thus when you reread the nextInt() you get an empty string, that's why your if doesn't execute the code in it", "label": {"api": {"nextInt()": [[4, 12], [112, 120]]}}}, {"text": "Otherwise you can do a nextInt() and then a nextLine() to consume the \\n", "label": {"api": {"nextInt()": [[23, 31]]}}}, {"text": "You should consider using the java.nio.file package", "label": {"api": {"java.nio.file": [[30, 42]]}}}, {"text": "Used the very handy function Path#resolveSibling() as second argument for Files#move()", "label": {"api": {"Path#resolveSibling()": [[29, 49]], "Files#move()": [[74, 85]]}}}, {"text": "Path#resolveSibling() takes the directory path of the Path object it is called on, and swaps the last part (the actual file name) for the supplied argument (the new, modified file name in this case)", "label": {"api": {"Path#resolveSibling()": [[0, 20]]}}}, {"text": "Using this behavior as second argument for Files#move() will result in a move where the source directory and the target directory are the same, thus it only renames the file", "label": {"api": {"Files#move()": [[43, 54]]}}}, {"text": "You should not use the DataInputStream unless you intentionally want to read primitive Java data types (see http://docs.oracle.com/javase/7/docs/api/java/io/DataInputStream.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/DataInputStream.html": [[108, 176]]}}}, {"text": "With AffineTransformOp class", "label": {"api": {"AffineTransformOp": [[5, 21]]}}}, {"text": "The Stack class is already generic, but in order make the transfer method generic, you have to do", "label": {"api": {"Stack": [[4, 8]]}}}, {"text": "As a side note, JavaÂ 8â€™s Map.computeIfAbsent will behave more like you expected by returning the computed value if no previous mapping existed", "label": {"api": {"Map.computeIfAbsent": [[25, 43]]}}}, {"text": "Without seeing the class or method we're trying to retrieve, but looking at the exception cause you provided, I don't believe Class#getMethod is throwing the ClassNotFoundException", "label": {"api": {"Class#getMethod": [[126, 140]]}}}, {"text": "Anonymous loggers are not listed but, the default settings are inherited from the root logger", "label": {"api": {"Anonymous loggers": [[0, 16]]}}}, {"text": "It is also equivalent to the return value of ResultSetMetaData.isNullable(int)", "label": {"api": {"ResultSetMetaData.isNullable(int)": [[45, 77]]}}}, {"text": "If you have Java 7 or later and would like to remain specific about the exceptions that you catch, you could use ReflectiveOperationException, the base class of ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException, and NoSuchMethodException", "label": {"api": {"ReflectiveOperationException": [[113, 140]]}}}, {"text": "Classes that extend Callable are usually executed via an ExecutorService which is a separate thread itself, thus it executes in the background", "label": {"api": {"ExecutorService": [[57, 71]]}}}, {"text": "You may want to take a look at the Runnable interface or Thread if you'd like to run a separate thread to execute in the background that does not return a value", "label": {"api": {"Runnable": [[35, 42]], "Thread": [[57, 62]]}}}, {"text": "When an object implementing interface Runnable is used to create a thread, starting the thread causes the object's run method to be called in that separately executing thread", "label": {"api": {"Runnable": [[38, 45]]}}}, {"text": "If you need to return some data at the end of execution I highly recommend an ExecutorService but you could probably also get away with using a FutureTask though I have less experience with that class", "label": {"api": {"ExecutorService": [[78, 92]], "FutureTask": [[144, 153]]}}}, {"text": "Here, the method reference pred::evaluate at a place, where a java.util.function.Predicate is expected, will create such a java util Predicate whose test method will delegate to the evaluate method of the existing apache commons Predicate instance", "label": {"api": {"java.util.function.Predicate": [[62, 89]]}}}, {"text": "As this answer explains, invokeLater executes the run body inside the application's primary Thread", "label": {"api": {"Thread": [[92, 97]]}}}, {"text": "Since your UI is also operating in this Thread, you'll need to use another method", "label": {"api": {"Thread": [[40, 45]]}}}, {"text": "You'll want to put that infinite loop in a Thread and call start explicitly so it won't block your UI", "label": {"api": {"Thread": [[43, 48]]}}}, {"text": "Then, you can start up the Thread when your \"Open Connection\" button is pressed with", "label": {"api": {"Thread": [[27, 32]]}}}, {"text": "Without explicitly creating a new Thread, your application will only have one Thread to work with", "label": {"api": {"Thread": [[34, 39], [78, 83]]}}}, {"text": "This Thread will be shared between the UI and any other work that you need to perform", "label": {"api": {"Thread": [[5, 10]]}}}, {"text": "So, when you have a bit of work (like your while(true)) that hogs your only Thread, your UI will freeze until it is given control again", "label": {"api": {"Thread": [[76, 81]]}}}, {"text": "So, by creating a new Thread, you are allowing the UI to maintain control and not freeze", "label": {"api": {"Thread": [[22, 27]]}}}, {"text": "to take programmatic control of updates through the DownloadService", "label": {"api": {"DownloadService": [[52, 66]]}}}, {"text": "DownloadService service allows an application to control how its own resources are cached, to determine which of its resources are currently cached, to force resources to be cached, and to remove resources from the cache", "label": {"api": {"DownloadService": [[0, 14]]}}}, {"text": "I have created then my own table model extending from AbstractTableModel in order to work directly with Customer class", "label": {"api": {"AbstractTableModel": [[54, 71]]}}}, {"text": "DefaultComboBoxModel, DefaultListModel) we can use Generics in order to create a flexible and reusable table model, also providing an API to work with user-defined POJO's", "label": {"api": {"DefaultComboBoxModel": [[0, 19]], "DefaultListModel": [[22, 37]]}}}, {"text": "And why is this syntax not in the api, which you can read at this link", "label": {"api": {"at this link": [[58, 69]]}}}, {"text": "If you want to use FileReader, you can do it as", "label": {"api": {"FileReader": [[19, 28]]}}}, {"text": "Always use Pattern.quote if you want to match a string as it is passed in", "label": {"api": {"Pattern.quote": [[11, 23]]}}}, {"text": "Matcher.replaceAll is a high level function which resets the Matcher (start the match all over again), and search for all the matches and perform the replacement", "label": {"api": {"Matcher.replaceAll": [[0, 17]]}}}, {"text": "Given the complete vagueness of the question, I would suggest using java.awt.Rectangle#contains which has several flavours to make life easier for you...", "label": {"api": {"java.awt.Rectangle#contains": [[68, 94]]}}}, {"text": "Use JTextArea APIs", "label": {"api": {"JTextArea": [[4, 12]]}}}, {"text": "http://docs.oracle.com/javase/8/docs/api and the Java Tutorials here", "label": {"api": {"http://docs.oracle.com/javase/8/docs/api": [[0, 39]]}}}, {"text": "You can use Arrays#deepToString()", "label": {"api": {"Arrays#deepToString()": [[12, 32]]}}}, {"text": "Try looking at BufferedReader documentation as well as numerous posts on this site regarding proper methods to perform file IO operations", "label": {"api": {"BufferedReader": [[15, 28]]}}}, {"text": "You will need to read each row in your file(BufferedReader has methods for this), parse the string (Look at the String documentation, specifically split or substring/indexOf methods) into category and grade, and then populate your array", "label": {"api": {"BufferedReader": [[44, 57]], "String": [[112, 117]]}}}, {"text": "If this is just binary data, 4 bytes for a 32-bit integer etc, then you probably want DataInputStream instead - but you should validate that your data is big-endian, which is what DataInputStream will handle it", "label": {"api": {"DataInputStream": [[86, 100], [180, 194]]}}}, {"text": "Otherwise you can use Thread's join() method to ensure all threads are completed before continuing", "label": {"api": {"join()": [[31, 36]]}}}, {"text": "Scanner.hasNext() just tests if there are more tokens but does not read or discard the next token if there are more", "label": {"api": {"Scanner.hasNext()": [[0, 16]]}}}, {"text": "String.split only returns the parts of the String that were not matched", "label": {"api": {"String.split": [[0, 11]]}}}, {"text": "the Pattern and Matcher classes, or write your own String tokenization class yourself", "label": {"api": {"Pattern": [[4, 10]], "Matcher": [[16, 22]]}}}, {"text": "Make a Stack<Integer> to store the index of the current node", "label": {"api": {"Stack<Integer>": [[7, 20]]}}}, {"text": "According to the JavaDoc for the Set interface, a set is not allowed to contain duplicate identical elements (as defined by equals and hashcode)", "label": {"api": {"JavaDoc for the Set interface": [[17, 45]]}}}, {"text": "Please use StringBuilder instead", "label": {"api": {"StringBuilder": [[11, 23]]}}}, {"text": "It uses the string.substring(start, end) method", "label": {"api": {"string.substring(start, end)": [[12, 39]]}}}, {"text": "What you should use here is a StringBuilder", "label": {"api": {"StringBuilder": [[30, 42]]}}}, {"text": "Use Java 8's StringJoiner in combination with the stream API", "label": {"api": {"StringJoiner": [[13, 24]]}}}, {"text": "It is working, you have a LinkedList<String> so when you call LinkedList#get(int) you get a String", "label": {"api": {"LinkedList#get(int)": [[62, 80]]}}}, {"text": "See javadocs for WebServiceRef annotation", "label": {"api": {"javadocs for WebServiceRef annotation": [[4, 40]]}}}, {"text": "Use Consumer<Runnable> instead", "label": {"api": {"Consumer<Runnable>": [[4, 21]]}}}, {"text": "FileWriter has an optional boolean in the constructor, which declares if it should be appended or not", "label": {"api": {"constructor": [[42, 52]]}}}, {"text": "Then you just have to create your EntityManagerFactory via Persistence#createEntityManagerFactory(String)", "label": {"api": {"Persistence#createEntityManagerFactory(String)": [[59, 104]]}}}, {"text": "See Collision detection with complex shapes & replace the small moving ball with the mouse position and tweak the collision code for an Area and a Point using Area.contains(Point2D)", "label": {"api": {"Area.contains(Point2D)": [[159, 180]]}}}, {"text": "If you call paintImmediately on the JProgressBar, then you can update it while your code is running on the event dispatch thread", "label": {"api": {"paintImmediately": [[12, 27]]}}}, {"text": "If the user must wait anyway, and blocking the GUI is not a problem, then the (much simpler) paintImmediately is fine", "label": {"api": {"paintImmediately": [[93, 108]]}}}, {"text": "Then convert array to list with Arrays.asList and find minimum with Collections.min", "label": {"api": {"Arrays.asList": [[32, 44]], "Collections.min": [[68, 82]]}}}, {"text": "You have on the other hand a specificationn, ist is the ServletRequest Interface, and it provides you with an InputStream, and this ist great", "label": {"api": {"ServletRequest": [[56, 69]]}}}, {"text": "If you want to change the url in the browser, you have to perform a redirect", "label": {"api": {"perform a redirect": [[58, 75]]}}}, {"text": "The equivalent method is Object#toString(), although this gives a useless unreadable jumble unless overriden", "label": {"api": {"Object#toString()": [[25, 41]]}}}, {"text": "Although somewhat opinion-based, the usual exception to throw when an object is not the expected type is ClassCastException, and this approach is used fairly widely in the JDK", "label": {"api": {"ClassCastException": [[105, 122]]}}}, {"text": "If the object was passed as a parameter, you can use IllegalArgumentException, also with a message", "label": {"api": {"IllegalArgumentException": [[53, 76]]}}}, {"text": "You can change it using Scanner#useLocale", "label": {"api": {"Scanner#useLocale": [[24, 40]]}}}, {"text": "See http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html For a list of the different input streams", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html": [[4, 68]]}}}, {"text": "To make life easier, you can use AbstractCollection.toString() for lists, or Arrays.toString(int[]) for arrays (beware of the extra brackets)", "label": {"api": {"AbstractCollection.toString()": [[33, 61]], "Arrays.toString(int[])": [[77, 98]]}}}, {"text": "In Java 8, yes", "label": {"api": {"yes": [[11, 13]]}}}, {"text": "Before Java 8, no", "label": {"api": {"no": [[15, 16]]}}}, {"text": "If you can reformulate your problem in terms of task-executor then consider using a SingleThreadExecutor", "label": {"api": {"SingleThreadExecutor": [[84, 103]]}}}, {"text": "If you need something more exotic - either a concurrent queue or even wait()/notify()", "label": {"api": {"a concurrent queue": [[43, 60]]}}}, {"text": "Please note that System.nanoTime() returns the time in nanoseconds which passed since an arbitrary point in time, not necessarily the beginning of your program", "label": {"api": {"System.nanoTime()": [[17, 33]]}}}, {"text": "System.currentTimeMillis() will give you the absolute time in milliseconds since the Unix epoch (Jan 1, 1970)", "label": {"api": {"System.currentTimeMillis()": [[0, 25]]}}}, {"text": "Call the values() method on the Map, which will return a Collection view of teh values that is suitable for iteration in JXLS", "label": {"api": {"values() method on the Map": [[9, 34]]}}}, {"text": "Here is more performant solution using java.nio.ByteBuffer.wrap() that avoids intermediate copy operations", "label": {"api": {"java.nio.ByteBuffer.wrap()": [[39, 64]]}}}, {"text": "The NavigableSet.lower(E) Javadoc says it returns the greatest element in this set strictly less than the given element, or null if there is no such element", "label": {"api": {"NavigableSet.lower(E)": [[4, 24]]}}}, {"text": "After changing line 47 from line = inputFile.nextLine(); to line = inputFile2.nextLine(); (as suggested by user1598503), you now get a NoSuchElementException on line 53", "label": {"api": {"NoSuchElementException": [[135, 156]]}}}, {"text": "The Java docs explain quite clearly why the NoSuchElementException gets thrown", "label": {"api": {"NoSuchElementException": [[44, 65]], "The Java docs explain quite clearly why": [[0, 38]]}}}, {"text": "If you have to use a box layout look at the glue and rigidArea methods in Box", "label": {"api": {"Box": [[74, 76]]}}}, {"text": "If you want to avoid regex, then the Character class can help", "label": {"api": {"Character": [[37, 45]]}}}, {"text": "They have specified that the component you have updating must be passed into updateComponentTreeUI() method", "label": {"api": {"updateComponentTreeUI()": [[77, 99]]}}}, {"text": "The resolution can be read from the Sequence", "label": {"api": {"Sequence": [[36, 43]]}}}]