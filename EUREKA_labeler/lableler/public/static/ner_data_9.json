[{"text": "You can search on here for how to read the file; there are many questions on that in Java, but the relevant classes are FileReader and BufferedReader", "label": {"api": {"FileReader": [[120, 129]], "BufferedReader": [[135, 148]]}}}, {"text": "You can find the first space on the line with indexOf(' ') and, if it is at offset 7 (the eighth character), get the first seven characters with substring(0, 7)", "label": {"api": {"indexOf(' ')": [[46, 57]], "substring(0, 7)": [[145, 159]]}}}, {"text": "Usually, you create an inner class that implements Iterator interface and that's what you return in iterator method", "label": {"api": {"Iterator": [[51, 58]]}}}, {"text": "Java more often uses the StringBuilder class to construct a string before making an immutable String out of it", "label": {"api": {"StringBuilder class": [[25, 43]]}}}, {"text": "There is the javax.script for this", "label": {"api": {"javax.script": [[13, 24]]}}}, {"text": "Something to note that makes this answer differ from the other answers is that I did indeed implement both a Filter and a HttpServletResponseWrapper because I wanted to trap all corner cases, including where the response is committed prior to the filter receiving the response", "label": {"api": {"committed": [[224, 232]]}}}, {"text": "This commit can happen in various places such as client code calling HttpServletResponse#sendError, frameworks, etc", "label": {"api": {"HttpServletResponse#sendError": [[69, 97]]}}}, {"text": "Depending on what you are trying to represent, you can use a class, like SQLWarning from the java.sql package", "label": {"api": {"SQLWarning": [[73, 82]], "java.sql": [[93, 100]]}}}, {"text": "When you have a java.sql.Statement and call executeQuery you get a java.sql.ResultSet and you can then call getWarnings on the result set directly, or even on the statement itself", "label": {"api": {"java.sql": [[16, 23], [67, 74]]}}}, {"text": "LinkedList class implements Java´s clonable interface", "label": {"api": {"LinkedList": [[0, 9]], "Java´s clonable interface": [[28, 52]]}}}, {"text": "You need to cast the reference type to LinkedList´s in order to be able to use (\"view\") its methods/attributes not included in Object class definition", "label": {"api": {"LinkedList": [[39, 48]]}}}, {"text": "cells still having the preferred size determined by the combo box cell renderer", "label": {"api": {"combo box cell renderer": [[56, 78]]}}}, {"text": "Set a preferred width using setPrototypeDisplayValue(...) method", "label": {"api": {"setPrototypeDisplayValue(...)": [[28, 56]]}}}, {"text": "Set a cell renderer and set the cell height inside getListCellRendererComponent(...) method implementation", "label": {"api": {"getListCellRendererComponent(...)": [[51, 83]]}}}, {"text": "IMHO it would be better don't mess with combo box height at all and just play with setPrototypeDisplayValue(...) to set a preferred width in a PLaF safe way", "label": {"api": {"setPrototypeDisplayValue(...)": [[83, 111]]}}}, {"text": "You can use a Map to store multiple records with different keys, example", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "I've found that clearRect should paint a transparent color", "label": {"api": {"clearRect": [[16, 24]]}}}, {"text": "It is not clearly documented but I tested it and setRGB appears to accept an ARGB value", "label": {"api": {"setRGB": [[49, 54]]}}}, {"text": "The JavaDoc of ConvolveOp contains some information about how the alpha component is treated during a convolution", "label": {"api": {"ConvolveOp": [[15, 24]]}}}, {"text": "You could use BigInteger.pow() to calculate each exponential term", "label": {"api": {"BigInteger.pow()": [[14, 29]]}}}, {"text": "The specific problem in your code is that you're doing all of the calculating of the exponents in Math.pow, which only works with doubles", "label": {"api": {"Math.pow": [[98, 105]]}}}, {"text": "Quoting the docs for Math.pow (emphasis mine)", "label": {"api": {"Math.pow": [[21, 28]]}}}, {"text": "The largest number that can be represented with a double is roughly ~10308, so by the time you got 150 terms in, none of those Math.pow(i,i) calls would've returned the correct value", "label": {"api": {"Math.pow": [[127, 134]]}}}, {"text": "Use double for variables and use nextDouble to capture double values", "label": {"api": {"nextDouble": [[33, 42]]}}}, {"text": "The hashCode() of Object returns something like an address, but String overrides hashCode()", "label": {"api": {"hashCode()": [[4, 13], [81, 90]]}}}, {"text": "You can use, for instance, Character.toCodePoint()", "label": {"api": {"Character.toCodePoint()": [[27, 49]]}}}, {"text": "Note that the reverse operation is Character.toChars()", "label": {"api": {"Character.toChars()": [[35, 53]]}}}, {"text": "I think you may be looking for Thread#getName and Thread#setName", "label": {"api": {"Thread#getName": [[31, 44]], "Thread#setName": [[50, 63]]}}}, {"text": "Thread.currentThread returns a reference to the currently-executing thread", "label": {"api": {"Thread.currentThread": [[0, 19]]}}}, {"text": "I've been having some issues with a ConvolveOp that can be fixed by setting the imageType of the BufferedImage I'm working with to TYPE_INT_ARGB_PRE (see related SO answer here)", "label": {"api": {"ConvolveOp": [[36, 45]], "BufferedImage": [[97, 109]], "TYPE_INT_ARGB_PRE": [[131, 147]]}}}, {"text": "Which drawing operations are affected by changing the imageType of a BufferedImage from TYPE_INT_ARGB to TYPE_INT_ARGB_PRE", "label": {"api": {"BufferedImage": [[69, 81]], "TYPE_INT_ARGB_PRE": [[105, 121]]}}}, {"text": "Is it just BufferedImageOps", "label": {"api": {"BufferedImage": [[11, 23]], "BufferedImageOps": [[11, 26]]}}}, {"text": "Or does it affect any of the draw commands on the image's Graphics object or the way the image is rendered if it is drawn onto a different Graphics object", "label": {"api": {"Graphics": [[58, 65], [139, 146]]}}}, {"text": "As others have already said, JFormattedTextField is the best way to do this", "label": {"api": {"JFormattedTextField": [[29, 47]]}}}, {"text": "A dedicated function, Math.hypot exists, which calculates √(x² + y²)", "label": {"api": {"Math.hypot": [[22, 31]]}}}, {"text": "To use this, one needs to implement the interface ForkJoinPool.ManagedBlocker such that the potentially-blocking method that the task wants to execute is called from within the block method of this interface", "label": {"api": {"ForkJoinPool.ManagedBlocker": [[50, 76]]}}}, {"text": "Then the task may not call the blocking method directly, but instead needs to call the static method ForkJoinPool.managedBlock(ManagedBlocker)", "label": {"api": {"ForkJoinPool.managedBlock(ManagedBlocker)": [[101, 141]]}}}, {"text": "The only place I have found in the Java API (for Java 7) that actually uses managed blocking is the class Phaser", "label": {"api": {"Phaser": [[106, 111]]}}}, {"text": "(This class is a synchronization barrier like mutexes and latches, but more flexible and powerful.) So synchronizing with a Phaser inside a ForkJoinPool task should use managed blocking and can avoid starvation deadlocks (but ForkJoinTask.join() is still preferable because it uses work stealing instead of managed blocking)", "label": {"api": {"Phaser": [[124, 129]]}}}, {"text": "A shorter solution would be to use String.format or System.out.printf to format the output", "label": {"api": {"String.format": [[35, 47]]}}}, {"text": "Use an ArrayList", "label": {"api": {"ArrayList": [[7, 15]]}}}, {"text": "ArrayLists are Lists with a backing array of the same type", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "ArrayLists follow a certain resize strategy(See also here", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "See this answer or the Method.invoke() javadoc for details", "label": {"api": {"Method.invoke() javadoc": [[23, 45]]}}}, {"text": "I'd like to subclass CompletableFuture to override the default Executor", "label": {"api": {"CompletableFuture": [[21, 37]]}}}, {"text": "That is, if a user invokes a method without specifying an Executor, I want my own Executor to get used instead of the one normally used by CompletableFuture", "label": {"api": {"CompletableFuture": [[139, 155]]}}}, {"text": "How am I supposed to implement static methods like CompletableFuture.supplyAsync() in the subclass if the underlying implementation depends on methods like internalComplete() which is package-private", "label": {"api": {"CompletableFuture": [[51, 67]]}}}, {"text": "How is one supposed to subclass CompletableFuture", "label": {"api": {"CompletableFuture": [[32, 48]]}}}, {"text": "CompletableFuture.supplyAsync(..., executor).thenApplyAsync(..., executor).thenApplyAsync(..., executor)", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "I'd like the custom CompletableFuture implementation to use the first executor throughout all follow-up calls", "label": {"api": {"CompletableFuture": [[20, 36]]}}}, {"text": "As a note, there are other List implementations that are designed for concurrent access situations, such as CopyOnWriteArrayList", "label": {"api": {"CopyOnWriteArrayList": [[108, 127]]}}}, {"text": "Instead of a PrintWriter, use a FileWriter with the append flag set to true", "label": {"api": {"FileWriter": [[32, 41]], "PrintWriter": [[13, 23]]}}}, {"text": "Creating the PrintWriter as you're doing, will truncate the existing file to zero size, so all previous output will be erased", "label": {"api": {"PrintWriter": [[13, 23]]}}}, {"text": "Using the FileWriter in append mode will append output to the existing file", "label": {"api": {"FileWriter": [[10, 19]]}}}, {"text": "Alternatively, you could move the creation of the PrintWriter outside of the loop, thus preventing it from being created multiple times and truncating the file", "label": {"api": {"PrintWriter": [[50, 60]]}}}, {"text": "For further inquiry you want to have a look at the CharsetEncoder and CharsetDecoder classes", "label": {"api": {"CharsetEncoder": [[51, 64]], "CharsetDecoder": [[70, 83]]}}}, {"text": "With regards to how implementations of the JDBC API are registered with the java.sql.DriverManager,  what used to happen was that your code would need to explicitly load the class(es) implementing java.sql.Driver; the act of loading the class caused it to be registered with the java.sql.DriverManager", "label": {"api": {"java.sql.DriverManager": [[76, 97], [279, 300]], "java.sql.Driver": [[76, 90], [197, 211], [279, 293]]}}}, {"text": "One or more implementations of java.sql.Driver are registered with the java.sql.DriverManager", "label": {"api": {"java.sql.DriverManager": [[71, 92]], "java.sql.Driver": [[31, 45], [71, 85]]}}}, {"text": "If you then look at the source code for java.sql.DriverManager.getConnection(String) you will see that it simply loops through the registered drivers until it finds one that accepts the connection url at which point the java.sql.DriverManager calls the java.sql.Driver.connect(String, Properties) method, returning a specific implementation of java.sql.Connection", "label": {"api": {"java.sql.DriverManager": [[40, 61], [220, 241]], "java.sql.Driver": [[40, 54], [220, 234], [253, 267]], "java.sql.DriverManager.getConnection(String)": [[40, 83]], "java.sql.Driver.connect(String, Properties)": [[253, 295]], "java.sql.Connection": [[344, 362]]}}}, {"text": "When using Java 8 you could make use of the Pair class", "label": {"api": {"Pair": [[44, 47]]}}}, {"text": "Using the new LongStream from Java 8 instead of the Range class doesn't helped me", "label": {"api": {"LongStream": [[14, 23]]}}}, {"text": "You should add a WindowListener or a WindowStateListener to your frame instance", "label": {"api": {"WindowListener": [[17, 30]], "WindowStateListener": [[37, 55]]}}}, {"text": "Example for a WindowStateListener", "label": {"api": {"WindowStateListener": [[14, 32]]}}}, {"text": "You are looking for a thread pool or - in Java terms - for an Executor", "label": {"api": {"Executor": [[62, 69]]}}}, {"text": "The method anExecutor should return a new Executor instance", "label": {"api": {"Executor": [[13, 20], [42, 49]]}}}, {"text": "Set the append parameter of FileWriter to true", "label": {"api": {"FileWriter": [[28, 37]]}}}, {"text": "If you do not want to change this, you can set the FileWriter to append mode by using FileWriter(String, boolean)", "label": {"api": {"FileWriter(String, boolean)": [[86, 112]]}}}, {"text": "You can use SimpleDateFormat for this", "label": {"api": {"SimpleDateFormat": [[12, 27]]}}}, {"text": "Alternatively, roll your own with simple division, modulo, and String.format", "label": {"api": {"String.format": [[63, 75]]}}}, {"text": "Is there a simple method to check if an element is contained in an iterable or iterator, analogous to the Collection.contains(Object o) method", "label": {"api": {"Collection.contains(Object o)": [[106, 134]]}}}, {"text": "Your are formatting the dates you get from widgets using SimpleDateFormat, but you only use a date pattern as a format string; for date and time string format supported by mysql, use", "label": {"api": {"SimpleDateFormat": [[57, 72]]}}}, {"text": "I mean what is the relationship between for-each and the Iterable interface in java", "label": {"api": {"Iterable": [[57, 64]]}}}, {"text": "The words you used Implementing Iterator interface allows an object to be the target of the “foreach” statement sound like you already read the Java Doc - Interface Iterable", "label": {"api": {"Java Doc - Interface Iterable": [[144, 172]]}}}, {"text": "The way you call the method, Stringbuilder.append(int) will be called", "label": {"api": {"Stringbuilder.append(int)": [[29, 53]]}}}, {"text": "I know that in Java one can use ThreadMXBean to get CPU utilization of any thread", "label": {"api": {"ThreadMXBean": [[32, 43]]}}}, {"text": "You can use SimpleDateFormat.setTimeZone(TimeZone) to set the same timezone and it should work", "label": {"api": {"SimpleDateFormat.setTimeZone(TimeZone)": [[12, 49]]}}}, {"text": "You can also create a char[] from a String by using String#toCharArray", "label": {"api": {"String#toCharArray": [[52, 69]]}}}, {"text": "Array (an Array of what?) from the Metadata API without trying to infer from row values", "label": {"api": {"Array": [[0, 4], [10, 14]], "Metadata": [[35, 42]]}}}, {"text": "All your diagnostics will be stored in a DiagnosticsCollector that you can even implement yourself (you don't have to, though)", "label": {"api": {"DiagnosticsCollector": [[41, 60]]}}}, {"text": "What you want to read about is the JavaCompiler utility", "label": {"api": {"JavaCompiler": [[35, 46]]}}}, {"text": "You can also define a \"looked-up-color\" for the border color; this will make it much easier to change the color at runtime", "label": {"api": {"\"looked-up-color\"": [[22, 38]]}}}, {"text": "Use a linkedHashMap to ensure order and keep their index on a seperate map implementation", "label": {"api": {"linkedHashMap": [[6, 18]]}}}, {"text": "An easy way to do that would be to use the stock implementation but change the multiplier from 31 to some other prime number", "label": {"api": {"change the multiplier from 31": [[68, 96]]}}}, {"text": "Just use String.replace instead of complicating things", "label": {"api": {"String.replace": [[9, 22]]}}}, {"text": "Use an implementation of Map", "label": {"api": {"Map": [[25, 27]]}}}, {"text": "This approach will also let you dispense with the array because your Map is acting as a means of both storage and retrieval", "label": {"api": {"Map": [[69, 71]]}}}, {"text": "Convert to a java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[13, 30]]}}}, {"text": "the \"wrapper\" option is actually quite elegant because it has a dedicated class for logger (SRP) and it allows you to switch implementations (log4j, apache-commons-logging, java.util.logging etc) \"under the hood\" without coupling the rest of the code to that implementation", "label": {"api": {"java.util.logging": [[173, 189]]}}}, {"text": "#getHour method is deprecated so don't use it,you can use #SimpleDateFormat instead", "label": {"api": {"#getHour": [[0, 7]], "#SimpleDateFormat": [[58, 74]]}}}, {"text": "If you have your ZipInputStream, just use Channels.newChannel to convert it to a Channel then proceed as you wish", "label": {"api": {"Channels.newChannel": [[42, 60]]}}}, {"text": "And since Java 7 you can use FileChannel.open to open a FileChannel without the detour via FileInputStream", "label": {"api": {"FileChannel.open": [[29, 44]]}}}, {"text": "That's what sets are for", "label": {"api": {"sets": [[12, 15]]}}}, {"text": "The ExecutorService will immedietly start all tasks that are handed over to him", "label": {"api": {"ExecutorService": [[4, 18]]}}}, {"text": "ExecutorService#shutdown will cause the ExecutorServiceto stop accepting new tasks and finish the work (start all previous supplied tasks that aren't started till now)", "label": {"api": {"ExecutorService": [[0, 14], [40, 54]], "ExecutorService#shutdown": [[0, 23]]}}}, {"text": "The arguments for ExecutorService#awaitTermination are the timeout, the amount of time this call will block before it forcefully returns", "label": {"api": {"ExecutorService": [[18, 32]], "ExecutorService#awaitTermination": [[18, 49]]}}}, {"text": "Here an attempt using a java.util.Set for storing the generated numbers and using the Scanner constructor, which takes a File as argument", "label": {"api": {"java.util.Set": [[24, 36]], "Scanner": [[86, 92]]}}}, {"text": "For each new document, you can clear the existing text by passing null or an empty string to setText()", "label": {"api": {"setText()": [[93, 101]]}}}, {"text": "From the documentation of Collections.binarySearch()", "label": {"api": {"Collections.binarySearch()": [[26, 51]]}}}, {"text": "I guess what you are looking for is WritableRaster which helps to write to the image read", "label": {"api": {"WritableRaster": [[36, 49]]}}}, {"text": "I think the fastest way would be using System.arrayCopy() which is native method", "label": {"api": {"System.arrayCopy()": [[39, 56]]}}}, {"text": "Another way is copying with System.arraycopy", "label": {"api": {"System.arraycopy": [[28, 43]]}}}, {"text": "You can you use classes from javax.crypto to perform encryption and decryption", "label": {"api": {"javax.crypto": [[29, 40]]}}}, {"text": "setSectionPaint allows any implementation of the interface java.awt.Paint to be passed", "label": {"api": {"java.awt.Paint": [[59, 72]]}}}, {"text": "Color is one class that implements Paint, but there are others, such as TexturePaint", "label": {"api": {"TexturePaint": [[72, 83]]}}}, {"text": "This code will create a TexturePaint like the blue line pattern in your example", "label": {"api": {"TexturePaint": [[24, 35]]}}}, {"text": "See Node.setDisabled() (RadioButton extends Node)", "label": {"api": {"Node.setDisabled()": [[4, 21]]}}}, {"text": "For advanced threaded execution see Executors and ExecutorService", "label": {"api": {"Executors": [[36, 44]], "ExecutorService": [[50, 64]]}}}, {"text": "If you want to remove spaces around commas, call String.trim() on the result tokens", "label": {"api": {"String.trim()": [[49, 61]]}}}, {"text": "The merge method that was added to Map in Java 8 is effective for building such a map", "label": {"api": {"merge": [[4, 8]]}}}, {"text": "even though Introduction to fxml  says that it \"creates an instance of an observable array list, populated with three string values\"", "label": {"api": {"Introduction to fxml": [[12, 31]]}}}, {"text": "Given a java.net.URI object, I need to either", "label": {"api": {"java.net.URI": [[8, 19]]}}}, {"text": "Have a look at the docs for Class and Method", "label": {"api": {"Class": [[28, 32]], "Method": [[38, 43]]}}}, {"text": "Use reflection to call the predicate (controll in your example), and then newInstance to instantiate a class and call the other method", "label": {"api": {"newInstance": [[74, 84]]}}}, {"text": "First, the File class has a toURI() method, so the preferred way to get a URL pointing to a file is", "label": {"api": {"toURI()": [[28, 34]]}}}, {"text": "That failing, this method will invoke findResource(String) to find the resource", "label": {"api": {"findResource(String)": [[38, 57]]}}}, {"text": "You're comparing the language's \"enhanced-for\" loop with the Iterable.forEach() method", "label": {"api": {"Iterable.forEach()": [[61, 78]]}}}, {"text": "Note that the big speed advantage occurs because Iterable.forEach() ends up having a specialized implementation in ArrayList.forEach()", "label": {"api": {"Iterable.forEach()": [[49, 66]]}}}, {"text": "I wouldn't use this as justification for blindly replacing all enhanced-for loops with calls to Iterable.forEach()", "label": {"api": {"Iterable.forEach()": [[96, 113]]}}}, {"text": "Another approach is to use HashSet, see other answers", "label": {"api": {"HashSet": [[27, 33]]}}}, {"text": "Now, in theory this can also be done with a Control which can be obtained from Line#getControl; however, I've found TargetDataLine does not support this", "label": {"api": {"Control": [[44, 50], [87, 93]], "Line#getControl": [[79, 93]]}}}, {"text": "I did find that SourceDataLine supports MASTER_GAIN so if you are playing the recording back you can use the output", "label": {"api": {"MASTER_GAIN": [[40, 50]]}}}, {"text": "To convert an array into a String you can use java.util.Arrays.toString", "label": {"api": {"java.util.Arrays.toString": [[46, 70]]}}}, {"text": "If this is not homework, go read up on Calendar and Date objects", "label": {"api": {"Calendar": [[39, 46]], "Date": [[52, 55]]}}}, {"text": "Seems like you are looking ArrayList which is a dynamic array in Java", "label": {"api": {"ArrayList": [[27, 35]]}}}, {"text": "You could use KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow() which will, obviously, return the window which current contains the component with the current keyboard focus..", "label": {"api": {"KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow()": [[14, 85]]}}}, {"text": "If you use Set, it will be much more cleaner and readable", "label": {"api": {"Set": [[11, 13]]}}}, {"text": "Related to the actual means of using mmap in a Java program, I think this is the class and method to do so", "label": {"api": {"this is the class and method to do so": [[69, 105]]}}}, {"text": "You need to define your class as Comparable", "label": {"api": {"Comparable": [[33, 42]]}}}, {"text": "You could use the format() function using the SimpleDateFormat syntax", "label": {"api": {"SimpleDateFormat syntax": [[46, 68]]}}}, {"text": "This is a common problem, and it happens because the nextInt method doesn't read the newline character of your input, so when you issue the command nextLine, the Scanner finds the newline character and gives you that as a line", "label": {"api": {"nextInt": [[53, 59]], "nextLine": [[148, 155]]}}}, {"text": "Another way would be to always use nextLine wrapped into a Integer.parseInt", "label": {"api": {"nextLine": [[35, 42]]}}}, {"text": "Why not just Scanner.next()", "label": {"api": {"Scanner.next()": [[13, 26]]}}}, {"text": "I would not use Scanner.next() because this will read only the next token and not the full line", "label": {"api": {"Scanner.next()": [[16, 29]]}}}, {"text": "To sort two words, use String.compareTo()", "label": {"api": {"String.compareTo()": [[23, 40]]}}}, {"text": "You may find it easier to add them to a list, then sort that list using Collections.sort()", "label": {"api": {"Collections.sort()": [[72, 89]]}}}, {"text": "To see if a string contains a specific character, use String.indexOf('z') and test whether the return value is -1, which would indicate no match", "label": {"api": {"String.indexOf('z')": [[54, 72]]}}}, {"text": "If both the keys and the values implement equals() correctly, you can simply use Map.equals()", "label": {"api": {"Map.equals()": [[81, 92]]}}}, {"text": "Your task is, basically, to implement the resolveEntity method", "label": {"api": {"resolveEntity": [[42, 54]]}}}, {"text": "You will need to use the Pattern & Matcher API for regex support", "label": {"api": {"Pattern": [[25, 31]], "Matcher": [[35, 41]]}}}, {"text": "Due to the lack of inline-regex, pattern modifiers are done separately with flags", "label": {"api": {"flags": [[76, 80]]}}}, {"text": "Applying step 1 (remove prepended / and appended /) and step 2 (replace /i with Pattern.CASE_INSENSITIVE) you would get something like", "label": {"api": {"Pattern": [[80, 86]]}}}, {"text": "You need to call the validate method on the frame object after adding subcomponents to it", "label": {"api": {"validate": [[21, 28]]}}}, {"text": "The validate method is used to cause a container to lay out its subcomponents again", "label": {"api": {"validate": [[4, 11]]}}}, {"text": "See javax.xml.bind.DataTypeConverter.parseBase64Binary to go from base64 to bytes", "label": {"api": {"javax.xml.bind.DataTypeConverter.parseBase64Binary": [[4, 53]]}}}, {"text": "(quoted from API)", "label": {"api": {"API": [[13, 15]]}}}, {"text": "For example - public byte[] getHardwareAddress() throws SocketException", "label": {"api": {"public byte[] getHardwareAddress() throws SocketException": [[14, 70]], "SocketException": [[56, 70]]}}}, {"text": "The method returns the mac address of a network interface, but how is it related to sockets and ends up throwing SocketException", "label": {"api": {"SocketException": [[113, 127]]}}}, {"text": "You load the class using Class.forName, which will give you a Class instance for it", "label": {"api": {"Class.forName": [[25, 37]]}}}, {"text": "You get a Method instance for the method using Class#getMethod, passing in an array of appropriate Class instances to identify the signature,  or Class#getMethods and looking through the resulting array", "label": {"api": {"Class#getMethod": [[47, 61], [146, 160]], "Class#getMethods": [[146, 161]]}}}, {"text": "You call the method using Method#invoke", "label": {"api": {"Method#invoke": [[26, 38]]}}}, {"text": "You'll find lots of information about doing this in the Class class documentation and the java.lang.Reflection package documentation", "label": {"api": {"Class class documentation": [[56, 80]], "java.lang.Reflection package documentation": [[90, 131]]}}}, {"text": "The documentation says", "label": {"api": {"The documentation says": [[0, 21]]}}}, {"text": "Is it possible that an Enum like TimeUnit be passed as an argument to a method", "label": {"api": {"TimeUnit": [[33, 40]]}}}, {"text": "For example one of the signatures of Future#get is", "label": {"api": {"Future#get": [[37, 46]]}}}, {"text": "To convert a String into a Date and vice versa you should use SimpleDateFormat class", "label": {"api": {"SimpleDateFormat": [[62, 77]]}}}, {"text": "The SimpleDateFormat class allows you to parse a String into a java.util.Date object", "label": {"api": {"SimpleDateFormat": [[4, 19]]}}}, {"text": "The documentation for the SimpleDateFormat class has tons on information on how to set it up to parse different formats", "label": {"api": {"SimpleDateFormat": [[26, 41]]}}}, {"text": "If it is Long object then You can use longValue == null or you can use  Objects.isNull(longValue) method in Java 8", "label": {"api": {"Objects": [[72, 78]]}}}, {"text": "Please check Objects for more info", "label": {"api": {"Objects": [[13, 19]]}}}, {"text": "A list should implement the RandomAccess interface when the List#get(int) method has a constant asymptotic running time", "label": {"api": {"RandomAccess": [[28, 39]], "List#get(int)": [[60, 72]]}}}, {"text": "A LinkedList does not offer RandomAccess", "label": {"api": {"RandomAccess": [[28, 39]]}}}, {"text": "Here's a link to the Scanner API section which will show you all methods/constructors and such that are available to the Scanner object", "label": {"api": {"Scanner API": [[21, 31]]}}}, {"text": "If you also want error checking in factorial(), the clearest way to do that would probably be to throw a IllegalArgumentException when an invalid input is given", "label": {"api": {"IllegalArgumentException": [[105, 128]]}}}, {"text": "Use StringBuilder class for what you are doing", "label": {"api": {"StringBuilder": [[4, 16]]}}}, {"text": "You may also just actually use a Java LinkedList", "label": {"api": {"LinkedList": [[38, 47]]}}}, {"text": "You may also try reading the actual source code in Java for the remove method for LinkedList", "label": {"api": {"LinkedList": [[82, 91]]}}}, {"text": "I also want to point out you're not \"using classes like lists.\" You're just implementing a LinkedList, and choosing to call your class Example, instead of List or LinkedList or SinglyLinkedList", "label": {"api": {"LinkedList": [[91, 100], [163, 172], [183, 192]]}}}, {"text": "Or, easier still, use String.replace", "label": {"api": {"String.replace": [[22, 35]]}}}, {"text": "You should use the OutputStream from the response instead of the Writer", "label": {"api": {"OutputStream from the response": [[19, 48]]}}}, {"text": "Also you may wish to set the MIME type correctly for the response", "label": {"api": {"set the MIME type correctly": [[21, 47]]}}}, {"text": "You can have your class implement the Comparable interface, which is acceptable when your objects have a natural ordering that you're relying on (for example, alphabetical ordering for strings)", "label": {"api": {"Comparable": [[38, 47]]}}}, {"text": "The standard alternative is to instantiate a Comparator for your class, and specify the comparison rule in a compare method", "label": {"api": {"Comparator": [[45, 54]]}}}, {"text": "Once you have your Comparator defined, sorting is as simple as invoking the Collections.sort method, opting for the method signature which takes a List and a specified Comparator", "label": {"api": {"Comparator": [[19, 28], [168, 177]], "Collections.sort": [[76, 91]]}}}, {"text": "However, starting with Java 8 there is a feature that allows to introspect a direct MethodHandle, Lookup.revealDirect", "label": {"api": {"Lookup.revealDirect": [[98, 116]]}}}, {"text": "For handles for which this operation succeeds, you can use the information in the returned MethodHandleInfo to find out whether two handles point to the same method", "label": {"api": {"MethodHandleInfo": [[91, 106]]}}}, {"text": "connection.start() starts a new thread, but that thread is probably a daemon thread, so it ends when the program ends", "label": {"api": {"daemon": [[70, 75]]}}}, {"text": "You can achieve this using a threshold and Timer", "label": {"api": {"Timer": [[43, 47]]}}}, {"text": "System.identityHashCode() and reference equality)", "label": {"api": {"System.identityHashCode()": [[0, 24]]}}}, {"text": "See the javadoc of Object for more details, the contract for both is explained at length", "label": {"api": {"javadoc of Object": [[8, 24]]}}}, {"text": "The method Scanner#nextLine() consumes and returns the input till the next line break", "label": {"api": {"Scanner#nextLine()": [[11, 28]]}}}, {"text": "By creating a UniqueConstraint on the combination of the foreign key and the token", "label": {"api": {"UniqueConstraint": [[14, 29]]}}}, {"text": "Note that there is this method to set \"absolute\" file permissions", "label": {"api": {"this method": [[19, 29]]}}}, {"text": "Also you create JTextArea with empty constructor, use JTextArea(int rows, int cols) to specify count of rows and columns", "label": {"api": {"JTextArea(int rows, int cols)": [[54, 82]]}}}, {"text": "I have read the to generating probability using Random class", "label": {"api": {"Random": [[48, 53]]}}}, {"text": "First port of call would be the Collection.removeAll method", "label": {"api": {"Collection.removeAll": [[32, 51]]}}}, {"text": "If you are limited to use standard java features, i would suggest you further reading about the SAXParser class of standard JDK", "label": {"api": {"SAXParser": [[96, 104]]}}}, {"text": "But it is usually not advisable to call any method on a closed object, as according to the usual semantic, calling close on an object should relinquishing any underlying resources", "label": {"api": {"usual semantic": [[91, 104]]}}}, {"text": "Try with Arrays class from http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html": [[27, 88]]}}}, {"text": "I suggest you use maps, which will make your code more readable and outsources implementation details (like performance)", "label": {"api": {"maps": [[18, 21]]}}}, {"text": "I think it is best that you use AutoCloseable for the things that need to get closed", "label": {"api": {"AutoCloseable": [[32, 44]]}}}, {"text": "An AutoCloseable object will take care to call its close method", "label": {"api": {"AutoCloseable": [[3, 15]]}}}, {"text": "In Java, can a java.util.HashMap<Key, Value> overflow silently, so content is deleted without me receiving an exception or some other notification", "label": {"api": {"java.util.HashMap<Key, Value>": [[15, 43]]}}}, {"text": "The method can throw all kinds of exceptions though (see the api-docs)", "label": {"api": {"api-docs": [[61, 68]]}}}, {"text": "The File delete method returns true or false based on whether you're allowed to delete a file or not", "label": {"api": {"delete": [[9, 14], [80, 85]]}}}, {"text": "This is different from the Files.delete method which throws an IOException if it can't delete a file", "label": {"api": {"delete": [[33, 38], [87, 92]], "Files.delete": [[27, 38]]}}}, {"text": "Since you're not checking this return value, you don't know if the file has been deleted or not", "label": {"api": {"delete": [[81, 86]]}}}, {"text": "Hence you can still read/write a deleted file", "label": {"api": {"delete": [[33, 38]]}}}, {"text": "On the other hand, Windows enforces mandatory file locking and will simply refuse to delete the file", "label": {"api": {"delete": [[85, 90]]}}}, {"text": "Make sure you spell the method name correct or referring to the correct method (check out the docs)", "label": {"api": {"check out the docs": [[80, 97]]}}}, {"text": "You could read all your names into a Map where the key is the name and the gender is the value", "label": {"api": {"Map": [[37, 39]]}}}, {"text": "To resolve the gender just do something like genderMap.get(name)", "label": {"api": {"Map": [[51, 53]]}}}, {"text": "There is a way to get R[] array by using overloaded toArray(IntFunction<A[]> generator) method", "label": {"api": {"toArray(IntFunction<A[]> generator)": [[52, 86]]}}}, {"text": "Standard JDK already provides Collections.frequency(Collection<?> c, Object o) that does exactly this", "label": {"api": {"Standard JDK": [[0, 11]]}}}, {"text": "You could use the Scanner nextLine() method to read in an entire line of input from the user at once, but then you'd have to tokenize that line and convert each token to the correct data type", "label": {"api": {"nextLine()": [[26, 35]]}}}, {"text": "One could use the ConcurrentLinkedQueue, as suggested in an earlier question, but a single queue makes things tricky for segregating the input per label", "label": {"api": {"ConcurrentLinkedQueue": [[18, 38]]}}}, {"text": "You claim that ArrayList.subList() does iterations, which is simply not true", "label": {"api": {"ArrayList.subList()": [[15, 33]]}}}, {"text": "If you are seeing performance problems, it is almost certainly not due to ArrayList.subList()", "label": {"api": {"ArrayList.subList()": [[74, 92]]}}}, {"text": "HashSet.add(E e) leaves the set unchanged if it already contains the specified element", "label": {"api": {"HashSet.add(E e)": [[0, 15]]}}}, {"text": "If you want to see if the file name is valid, use f.exists()", "label": {"api": {"f.exists()": [[50, 59]]}}}, {"text": "You're calling DataOutput.write(int) on the DataOutputStream, which is documented as", "label": {"api": {"DataOutput.write(int)": [[15, 35]]}}}, {"text": "I suspect you really want writeInt", "label": {"api": {"writeInt": [[26, 33]]}}}, {"text": "Assuming you have so way of getting the internal representation (e.g., let's assume your method is called asArray(), you can use java.util.Arrays.equals(int[], int[]))", "label": {"api": {"java.util.Arrays.equals(int[], int[])": [[129, 165]]}}}, {"text": "See javax.tools to learn how to use this API", "label": {"api": {"javax.tools": [[4, 14]]}}}, {"text": "Try using CharsetEncoder to reveal possible encoding exceptions", "label": {"api": {"CharsetEncoder": [[10, 23]]}}}, {"text": "Even better, if you checkout the javadoc, you will see that there's a Number(BigDecimal bigDecimal) constructor", "label": {"api": {"Number(BigDecimal bigDecimal)": [[70, 98]]}}}, {"text": "Calling collect with the three arguments on a Stream is equivalent to use Collector.of", "label": {"api": {"collect with the three arguments": [[8, 39]], "Collector.of": [[74, 85]]}}}, {"text": "For better parallel performance, it’s worth studying the optional Characteristics you can provide", "label": {"api": {"Characteristics": [[66, 80]]}}}, {"text": "And using groupingByConcurrent instead of groupingBy may also improve parallel performance", "label": {"api": {"groupingByConcurrent": [[10, 29]]}}}, {"text": "String#split() and the length property of arrays are the tools to use here", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "For your example, your Math class should have a method were you perform the multiplication of two integers, and it should receive these integers as parameters", "label": {"api": {"Math": [[23, 26]]}}}, {"text": "Yes, there is a built-in Math class in Java", "label": {"api": {"Math": [[25, 28]]}}}, {"text": "You may also use listIterator for O(n) insertions", "label": {"api": {"listIterator": [[17, 28]]}}}, {"text": "The other issue is if running == false your thread just burns CPU in a tight loop, and you probably would want to use object monitors or a Condition to actually wait idly for the flag to become true again", "label": {"api": {"Condition": [[139, 147]]}}}, {"text": "I would suggest simply creating a Timer for this", "label": {"api": {"Timer": [[34, 38]]}}}, {"text": "Each Timer implicitly gets its own thread, which is what you are trying to accomplish", "label": {"api": {"Timer": [[5, 9]]}}}, {"text": "Then create a TimerTask (FacebookTask below is this) that performs your task and from your main control class, no explicit threads necessary, something like", "label": {"api": {"Timer": [[14, 18]]}}}, {"text": "You could also use a scheduled executor service as fge mentions in comments", "label": {"api": {"scheduled executor service": [[21, 46]]}}}, {"text": "While the Jdbc documentation recommends the use of int executeUpdate(String sql) for executing DDL statements", "label": {"api": {"Jdbc documentation": [[10, 27]]}}}, {"text": "A simple way using Scanner", "label": {"api": {"Scanner": [[19, 25]]}}}, {"text": "I think the easiest test is to use the StringBuilder.reverse() to construct the reverse of the input", "label": {"api": {"StringBuilder.reverse()": [[39, 61]]}}}, {"text": "EDIT @Makoto rightly points to Collections.reverse(), which makes the above code even more simple", "label": {"api": {"Collections.reverse()": [[31, 51]]}}}, {"text": "There's an alternative to do that with Lists, which are really easy to manipulate", "label": {"api": {"List": [[39, 42]]}}}, {"text": "You can add your Strings to a List and then create a JSON from it", "label": {"api": {"List": [[30, 33]], "String": [[17, 22]]}}}, {"text": "In Java 8, what's the difference between Stream.map() and Stream.flatMap() methods", "label": {"api": {"Stream.map()": [[41, 52]], "Stream.flatMap()": [[58, 73]]}}}, {"text": "Add scan.next() when input exception triggered so as to clear it with next()", "label": {"api": {"next()": [[9, 14], [70, 75]]}}}, {"text": "Change the if statement to contain return, or change the if statement to contain System.exit(0)", "label": {"api": {"System.exit(0)": [[81, 94]]}}}, {"text": "The Javadoc for java.util.Scanner notes that", "label": {"api": {"java.util.Scanner": [[16, 32]]}}}, {"text": "Here is an example of a presumably immutable class with a public final field of the mutable Date class", "label": {"api": {"Date": [[92, 95]]}}}, {"text": "Simply use the NullCipher which extends Cipher", "label": {"api": {"NullCipher": [[15, 24]]}}}, {"text": "Specify the same encoding in the constructor of InputStreamReader", "label": {"api": {"InputStreamReader": [[48, 64]]}}}, {"text": "If you don't explicitly specify the encoding, quoting from the javadoc of the constructor that doesn't take the encoding", "label": {"api": {"javadoc of the constructor that doesn't take the encoding": [[63, 119]]}}}, {"text": "Creates an InputStreamReader that uses the default charset", "label": {"api": {"InputStreamReader": [[11, 27]]}}}, {"text": "You can get this by URLConnection.getContentEncoding()", "label": {"api": {"URLConnection.getContentEncoding()": [[20, 53]]}}}, {"text": "You could use File.toURI() to generate a properly escaped URI string", "label": {"api": {"File.toURI()": [[14, 25]]}}}, {"text": "See the Media(String) documentation", "label": {"api": {"Media(String)": [[8, 20]]}}}, {"text": "You can easily replace the transformed instance of a Person by using the method set of interface List (that means every List implementation like ArrayList or LinkedList supports that)", "label": {"api": {"set": [[80, 82]]}}}, {"text": "Mind that the usage of set is only necessary if the method transform returns a new instance of Person", "label": {"api": {"set": [[23, 25]]}}}, {"text": "If you want your buttons to have a \"selected\" state, and want a collection of those grouped together so that only one is selected, then consider using ToggleButtons instead", "label": {"api": {"ToggleButtons": [[151, 163]]}}}, {"text": "You can put the toggle buttons into a ToggleGroup and register a listener with the toggle group's selectedToggle property", "label": {"api": {"ToggleGroup": [[38, 48]]}}}, {"text": "If you just want the input shuffled, why not use the built in Collection.shuffle method", "label": {"api": {"Collection.shuffle": [[62, 79]]}}}, {"text": "See the docs for InputMap for details", "label": {"api": {"docs for InputMap": [[8, 24]]}}}, {"text": "His example uses a @Singleton EJB and your's is @Stateless", "label": {"api": {"@Singleton": [[19, 28]]}}}, {"text": "If you want to maintain state in the EJB then you must use a @Stateful session bean", "label": {"api": {"@Stateful": [[61, 69]]}}}, {"text": "You can use a Map for your problem", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "AudioClip belongs to the applet API", "label": {"api": {"AudioClip": [[0, 8]], "Clip": [[5, 8]]}}}, {"text": "Clip belongs to javax.sound.sampled", "label": {"api": {"Clip": [[0, 3]]}}}, {"text": "It can be obtained from AudioSystem and there is an official tutorial here", "label": {"api": {"AudioSystem": [[24, 34]]}}}, {"text": "You can do this using Files.walkFileTree, but if you do that in your ActionListener (or any method called from your ActionListener), your application will be frozen while the files are being changed", "label": {"api": {"Files.walkFileTree": [[22, 39]]}}}, {"text": "There are many ways to do that, but SwingWorker seems to be easiest for many people", "label": {"api": {"SwingWorker": [[36, 46]]}}}, {"text": "You could even go a step farther and count the files before changing any of them, then use a ProgressMonitor instead of a JOptionPane", "label": {"api": {"ProgressMonitor": [[93, 107]]}}}, {"text": "There is no nextString() method in Scanner class", "label": {"api": {"Scanner": [[35, 41]]}}}, {"text": "Change the type from Statement to PreparedStatement", "label": {"api": {"PreparedStatement": [[34, 50]]}}}, {"text": "Create the PreparedStatement by using Connection#prepareStatement rather than using Connection.createStatement", "label": {"api": {"PreparedStatement": [[11, 27]]}}}, {"text": "Set the parameters in your PreparedStatement by using setXxx methods", "label": {"api": {"PreparedStatement": [[27, 43]]}}}, {"text": "An example is covered in PreparedStatement javadoc", "label": {"api": {"PreparedStatement": [[25, 41]]}}}, {"text": "But action context is ThreadLocal, so it can't be shared in multi-threaded environment", "label": {"api": {"ThreadLocal": [[22, 32]]}}}, {"text": "Use the setSelected() method of JInternalFrame; a complete example is cited here", "label": {"api": {"setSelected()": [[8, 20]], "JInternalFrame": [[32, 45]]}}}, {"text": "You can use an executor to update that periodically", "label": {"api": {"executor": [[15, 22]]}}}, {"text": "The constructor new ArrayList<Sprite>(numOfFiles) does not create an ArrayList of size numOfFiles", "label": {"api": {"new ArrayList<Sprite>(numOfFiles)": [[16, 48]]}}}, {"text": "Better it would be to use Date and the use the format function of SimpleDateFormat", "label": {"api": {"Date": [[26, 29], [72, 75]]}}}, {"text": "If you are going to be piecing together a string in increments (say, in a loop), it's more efficient to use a StringBuilder and create the string at the end with a call to it's toString() method", "label": {"api": {"StringBuilder": [[110, 122]]}}}, {"text": "One way of dealing with references which might be null is to construct an Optional via Optional.ofNullable(…)", "label": {"api": {"Optional.ofNullable(…)": [[87, 108]]}}}, {"text": "While forEach is suitable for a simple action, even the short detour via Optional makes it complex enough to benefit from the Stream API", "label": {"api": {"forEach": [[6, 12]]}}}, {"text": "like for Stream.findAny, but when processing collections, there are usually better alternatives", "label": {"api": {"Stream.findAny": [[9, 22]]}}}, {"text": "Thread.sleep() is declared like this", "label": {"api": {"Thread.sleep()": [[0, 13]], "Thread": [[0, 5]]}}}, {"text": "It may throw InterruptedException which directly extends java.lang.Exception so you have to catch it or declare to throw it", "label": {"api": {"InterruptedException": [[13, 32]], "java.lang.Exception": [[57, 75]]}}}, {"text": "And why is Thread.sleep() declared this way", "label": {"api": {"Thread.sleep()": [[11, 24]], "Thread": [[11, 16]]}}}, {"text": "Because if a Thread is sleeping, the thread may be interrupted e.g", "label": {"api": {"Thread": [[13, 18]]}}}, {"text": "with Thread.interrupt() by another thread in which case the sleeping thread (the sleep() method) will throw an instance of this InterruptedException", "label": {"api": {"InterruptedException": [[128, 147]], "Thread": [[5, 10]], "Thread.interrupt()": [[5, 22]]}}}, {"text": "If it's a normal list, you should consider changing it to CopyOnWriteArrayList or any other Thread-Safe list, it should fix the problem", "label": {"api": {"CopyOnWriteArrayList": [[58, 77]]}}}, {"text": "If you look at its Javadoc, you'll see", "label": {"api": {"its Javadoc": [[15, 25]]}}}, {"text": "From the documentation of StringTokenizer", "label": {"api": {"documentation of StringTokenizer": [[9, 40]]}}}, {"text": "StringBuilder has a replace method that takes a start and end index", "label": {"api": {"replace": [[20, 26]]}}}, {"text": "The replace method on String only take existing characters to replace", "label": {"api": {"replace": [[4, 10], [62, 68]]}}}, {"text": "It is using the Java implementation of the ZLIB algorithm, and the command written to the output file is /Filter /FlateDecode, as per the PDF 1.3 reference (page 54 referred to the document)", "label": {"api": {"ZLIB algorithm": [[43, 56]]}}}, {"text": "You probably need to utilize a few of the helper methods that enum provides..", "label": {"api": {"enum": [[62, 65]]}}}, {"text": "Make sure that you're using LocalDateTime class, not LocalDate", "label": {"api": {"LocalDateTime": [[28, 40]]}}}, {"text": "Assuming getCreateDate() returns an instance of java.util.Date, you can clean up the code a bit", "label": {"api": {"java.util.Date": [[48, 61]]}}}, {"text": "The compareTo's method's contract specifies that it throws a NullPointerException if a date is compared to null (like any Comparable class should do), so you'll have to handle those directly", "label": {"api": {"compareTo": [[4, 12]]}}}, {"text": "I do not know of a standard Java implementation and/or datastructure for this pattern (maybe the PriorityQueue?), but there should be at least a couple of implementations available (let us know if you find a good one)", "label": {"api": {"PriorityQueue": [[97, 109]]}}}, {"text": "This is what a CyclicBarrier is for", "label": {"api": {"CyclicBarrier": [[15, 27]]}}}, {"text": "But in Java 1.6 the compiler has an API build in the JDK, through it you can access the results of the Java parser", "label": {"api": {"results of the Java parser": [[88, 113]]}}}, {"text": "As one of the commentors already mentioned you can use BigDecimal", "label": {"api": {"BigDecimal": [[55, 64]]}}}, {"text": "HashMap has a convenient method called entrySet(), which lets you access a collection of key-value pairs", "label": {"api": {"entrySet()": [[39, 48]]}}}, {"text": "When using Java 8 you can make use of the Stream API like follows", "label": {"api": {"Stream API": [[42, 51]]}}}, {"text": "As you can see (http://docs.oracle.com/javase/7/docs/api/javax/swing/table/DefaultTableModel.html) DefaultTableModel implements Serializable interface (http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html)", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/javax/swing/table/DefaultTableModel.html": [[16, 96]], "http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html": [[152, 217]]}}}, {"text": "I am getting time from database in Java class in java.sql.Time format (16:12:00)", "label": {"api": {"java.sql.Time": [[49, 61]]}}}, {"text": "As can be seen in Object.toString() documentation, the default is to print the name of the class, an @ character and the hash of the specific object", "label": {"api": {"Object.toString()": [[18, 34]]}}}, {"text": "s-j results in -31, and the Math.abs overload that takes an int is called, and 31 is returned", "label": {"api": {"Math.abs overload that takes an int": [[28, 62]]}}}, {"text": "Use [String.replaceAll()](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String, java.lang.String)) method to remove or replace a specific character in a string by using", "label": {"api": {"http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String": [[26, 115]]}}}, {"text": "Use String.trim() method to remove whitespaces (spaces, new lines etc.) from the beginning and end of the string", "label": {"api": {"String.trim()": [[4, 16]]}}}, {"text": "Set your new thread to be a daemon if this is not the behavior you desire", "label": {"api": {"Set your new thread to be a daemon": [[0, 33]]}}}, {"text": "You may want to consider using a Timer or a ScheduledExecutorService for your updates instead of creating a new Thread as it will generally be easier to manage", "label": {"api": {"Timer": [[33, 37]]}}}, {"text": "However, with a Timer or, even better, a ScheduledExecutorServices, you can simplify your code a bit", "label": {"api": {"Timer": [[16, 20]], "ScheduledExecutorServices": [[41, 65]]}}}, {"text": "You are getting an unchecked cast warning because clone returns an Object, not a LinkedList<String>", "label": {"api": {"clone returns an Object": [[50, 72]]}}}, {"text": "The compiler just sees that clone returns an Object, so casting to a generic LinkedList<String> will cause this warning", "label": {"api": {"clone returns an Object": [[28, 50]]}}}, {"text": "You can however just create a new LinkedList by using the constructor that takes a Collection as its argument", "label": {"api": {"the constructor that takes a Collection": [[54, 92]]}}}, {"text": "It creates a Stream<List<String>> from your list of lists, then from that uses map to replace each of the lists with an array of strings which results in a Stream<String[]>, then finally calls toArray(with a generator function, instead of the no-parameter version) on that to produce the String[][]", "label": {"api": {"map": [[79, 81]], "toArray": [[193, 199]]}}}, {"text": "The documentation for orElseThrow states that it takes a Supplier as a parameter", "label": {"api": {"orElseThrow": [[22, 32]]}}}, {"text": "Therefore, orElseThrow() is not applicable to that argument type", "label": {"api": {"orElseThrow": [[11, 21]]}}}, {"text": "If you're using threads directly, check out CountDownLatch", "label": {"api": {"CountDownLatch": [[44, 57]]}}}, {"text": "Depending on how complex your workflow is, you may prefer the Phaser", "label": {"api": {"Phaser": [[62, 67]]}}}, {"text": "If you disable a JButton with setEnabled(false), its registered ActionListeners will not be called when you click on the button", "label": {"api": {"ActionListener": [[64, 77]]}}}, {"text": "However if you added a MouseListener to it with addMouseListener() method, even if the button is disabled, the registered MouseListener will still be called", "label": {"api": {"MouseListener": [[23, 35], [51, 63], [122, 134]]}}}, {"text": "You should register an ActionListener to do the job that is required when the button is pressed/clicked", "label": {"api": {"ActionListener": [[23, 36]]}}}, {"text": "That way if you disable the button, the ActionListener will not be called if the button is clicked", "label": {"api": {"ActionListener": [[40, 53]]}}}, {"text": "TreeCellRenderer is responsible to render the nodes of the tree which can be set using JTree.setCellRenderer()", "label": {"api": {"TreeCellRenderer": [[0, 15]], "JTree.setCellRenderer()": [[87, 109]]}}}, {"text": "The renderer's getTreeCellRendererComponent() returns a Component which will be used to paint the node", "label": {"api": {"TreeCellRenderer": [[18, 33]], "getTreeCellRendererComponent()": [[15, 44]], "Component": [[34, 42], [56, 64]]}}}, {"text": "The parameters of the getTreeCellRendererComponent() are", "label": {"api": {"TreeCellRenderer": [[25, 40]], "getTreeCellRendererComponent()": [[22, 51]], "Component": [[41, 49]]}}}, {"text": "Passing different values to these parameters may result in the returned Component having different Font and/or Color", "label": {"api": {"Component": [[72, 80]]}}}, {"text": "Here is the relevant part of the Javadoc", "label": {"api": {"relevant part of the Javadoc": [[12, 39]]}}}, {"text": "StringBuilder is backed by a char array", "label": {"api": {"StringBuilder": [[0, 12]]}}}, {"text": "Thus, you can call indexOf() and replace() on the StringBuilder", "label": {"api": {"StringBuilder": [[50, 62]]}}}, {"text": "A StringTokenizer uses a set of delimiter characters, not a delimiting string as you obviously assume", "label": {"api": {"StringTokenizer": [[2, 16]]}}}, {"text": "If you want to split the string by a delimiting string, you must use String.split which takes a regular expression", "label": {"api": {"String.split": [[69, 80]]}}}, {"text": "If kbReader is a Scanner remember that nextInt() and nextDouble() need a nextLine() in order to get rid of the \\n", "label": {"api": {"Scanner": [[17, 23]]}}}, {"text": "Java's Stream API is the closest thing to .NET's LINQ, in the sense that it allows you to query/manipulate collections in a functional style", "label": {"api": {"Stream API": [[7, 16]]}}}, {"text": "Otherwise you can change the logger level for the JavaMail loggers", "label": {"api": {"logger level": [[29, 40]]}}}, {"text": "for other ways to change the logger level", "label": {"api": {"logger level": [[29, 40]]}}}, {"text": "Instead you can use AtomicInteger which is mutable", "label": {"api": {"AtomicInteger": [[20, 32]]}}}, {"text": "You can use a CharsetDecoder retrieved from your favorite Charset with Charset#newDecoder()", "label": {"api": {"CharsetDecoder": [[14, 27]], "Charset": [[14, 20], [58, 64], [71, 77]], "Charset#newDecoder()": [[71, 90]]}}}, {"text": "This returns a CharBuffer from which you can get char values", "label": {"api": {"CharBuffer": [[15, 24]], "get char values": [[45, 59]]}}}, {"text": "Either set the database as part of the jdbc connection string, like jdbc:google:mysql://your-project-id:your-instance-name/YOUR_DATABASE_NAME, or switch to it with Connection.setCatalog()", "label": {"api": {"Connection.setCatalog()": [[164, 186]]}}}, {"text": "You can \"avoid\" the closure coercion to ActionListener doing button.actionPerformed = closure, i.e.", "label": {"api": {"ActionListener": [[40, 53]]}}}, {"text": "The mathematical result for this subtraction is larger than the largest possible Float value, Float.MAX_VALUE", "label": {"api": {"Float.MAX_VALUE": [[94, 108]]}}}, {"text": "There are two remove methods for ArrayList", "label": {"api": {"two remove methods for ArrayList": [[10, 41]]}}}, {"text": "The argument you're using is actually List#remove(Object)", "label": {"api": {"List#remove(Object)": [[38, 56]]}}}, {"text": "You can use a regex with the String.split(String regex) method", "label": {"api": {"String.split(String regex)": [[29, 54]]}}}, {"text": "Copied from the Java API Docs", "label": {"api": {"Java API Docs": [[16, 28]]}}}, {"text": "Or you can use max to enforce the lower bound more succinctly", "label": {"api": {"max": [[15, 17]]}}}, {"text": "In Java 8, you could use the Stream API", "label": {"api": {"Stream API": [[29, 38]]}}}, {"text": "But if you then switch to a parallel stream, it could be significantly faster on large arrays", "label": {"api": {"parallel stream": [[28, 42]]}}}, {"text": "A parallel stream allows the array scanning to be parcelled out to multiple threads, scanning the array using parallel CPUs or cores", "label": {"api": {"parallel stream": [[2, 16]]}}}, {"text": "String#split() is what you are looking for", "label": {"api": {"String#split()": [[0, 13]]}}}, {"text": "You can obtain a Properties instance of the JVM properties using System.getProperties(); how would you go about using Java 8 code to print all properties to the console", "label": {"api": {"System.getProperties()": [[65, 86]]}}}, {"text": "Stream#map performs a 1:1 conversion from elements of one type to elements of another", "label": {"api": {"Stream#map": [[0, 9]]}}}, {"text": "The Properties class in Java is a historical artifact; nowadays, it has been retrofitted to obey the Map interface, but since this class predates Map itself, therefore the collections API and generics, it implements Map<Object, Object>", "label": {"api": {"Properties": [[4, 13]]}}}, {"text": "You can however use a Properties instance to either load from a given resource, or write to a given resource", "label": {"api": {"Properties": [[22, 31]]}}}, {"text": "has there ever been any use case of a \"serializable\" Properties instance where either keys or values are not Strings", "label": {"api": {"Properties": [[53, 62]]}}}, {"text": "Try the Arrays.sort() method that takes a custom Comparator (source", "label": {"api": {"Arrays.sort()": [[8, 20]]}}}, {"text": "You could try the get(int index) method of the Vector class which Stack extends, assuming you don't want to pop the elements from your stack while you print them", "label": {"api": {"get(int index)": [[18, 31]]}}}, {"text": "Finally, I suggest you use the List interface and read about Autoboxing and Unboxing", "label": {"api": {"List": [[31, 34]]}}}, {"text": "I need to prioritize queued okhttp async requests; what's the recommended way of doing this; passing a custom ExecutorService to the Dispatcher", "label": {"api": {"ExecutorService": [[110, 124]]}}}, {"text": "It'd be nice to prioritize the requests before they're executed by the ExecutorService, but it looks like there's no way to customize Dispatcher's internal readyCalls Deque, and Dispatcher itself is final (and OkHttpClient.setDispatcher() only takes a Dispatcher, i.e", "label": {"api": {"ExecutorService": [[71, 85]]}}}, {"text": "If you just want to split a string using a or A as a delimiter, you might as well do", "label": {"api": {"split": [[20, 24]]}}}, {"text": "If it absolutely has to be implemented using a recursive method, instead of processing the string character by character, you could use indexOf to find the position of the next a or A", "label": {"api": {"indexOf": [[136, 142]]}}}, {"text": "If you pass a parameter to nextInt, it's interpreted as the radix of the entered integer", "label": {"api": {"nextInt": [[27, 33]]}}}, {"text": "Also BufferedImage.getRGB() returns the pixel data quoting from the javadoc", "label": {"api": {"BufferedImage.getRGB()": [[5, 26]]}}}, {"text": "I recommend you check if there is an int with Scanner.hasNextInt() before you call Scanner.nextInt()", "label": {"api": {"Scanner.hasNextInt()": [[46, 65]], "Scanner.nextInt()": [[83, 99]]}}}, {"text": "Use List, in your case ArrayList will be fine", "label": {"api": {"List": [[4, 7], [28, 31]], "ArrayList": [[23, 31]]}}}, {"text": "Integer.decode(String nm) is designed exactly for your needs", "label": {"api": {"Integer.decode(String nm)": [[0, 24]]}}}, {"text": "You can directly acces an element at a specific index with the List.get(int) method", "label": {"api": {"List.get(int)": [[63, 75]]}}}, {"text": "Double.parseDouble will convert string to double", "label": {"api": {"Double.parseDouble": [[0, 17]]}}}, {"text": "The Semaphore class uses an atomically-updated int to keep track of the permits, so it wouldn't incur much extra overhead", "label": {"api": {"Semaphore": [[4, 12]]}}}, {"text": "You can use AtomicInteger so that you don't have to synchronize/lock a regular int and sacrifice the benefit of using ConcurrentHashMap", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "Java provides a more convenient way for preventing value changes", "label": {"api": {"preventing value changes": [[40, 63]]}}}, {"text": "The value returned from TimeZone.getDefault() is determined by", "label": {"api": {"value returned from": [[4, 22]]}}}, {"text": "Customize your ComboBoxModel (particularly the getElementAt(int) method)so that it consults the domain object in question", "label": {"api": {"ComboBoxModel": [[15, 27]]}}}, {"text": "You might want to extend DefaultComboBoxModel instead of implementing the interface from scratch", "label": {"api": {"ComboBoxModel": [[32, 44]]}}}, {"text": "You can use Sets retainAll property & the use removeAll", "label": {"api": {"retainAll": [[17, 25]], "removeAll": [[46, 54]]}}}, {"text": "Various containers (such as Tomcat) and libraries (such as C3P0) provide additional metrics, in addition to the slew of beans the JVM provides", "label": {"api": {"the slew of beans the JVM provides": [[108, 141]]}}}, {"text": "These expose such things as memory usage (one of the more popular)", "label": {"api": {"memory usage": [[28, 39]]}}}, {"text": "I will make the assumption that tekst1, tekst2 and tekst3 are Strings, as this is not shown in the provided code", "label": {"api": {"String": [[62, 67]]}}}, {"text": "Now, there are various methods from the String class that you can use to achieve your goal", "label": {"api": {"String": [[40, 45]]}}}, {"text": "You can use  String concatenation to combine the words", "label": {"api": {"String": [[13, 18]]}}}, {"text": "Use the String methods toLowerCase and substring to get all the letters except the first in lower case", "label": {"api": {"String": [[8, 13]], "toLowerCase": [[23, 33]], "substring": [[39, 47]]}}}, {"text": "Use the String method charAt to get the first letter", "label": {"api": {"String": [[8, 13]], "charAt": [[22, 27]]}}}, {"text": "I would just use List.set", "label": {"api": {"List.set": [[17, 24]]}}}, {"text": "Direct access seems not possible because keySet returns a set that does not support the indexed access", "label": {"api": {"keySet": [[41, 46]]}}}, {"text": "Execute the code in an ExecutorService", "label": {"api": {"ExecutorService": [[23, 37]]}}}, {"text": "You can use a StringBuilder to append the new Strings", "label": {"api": {"StringBuilder": [[14, 26]]}}}, {"text": "java.awt.Rectangle is part of AWT and is designed for representing discrete areas in images (and on the screen)", "label": {"api": {"java.awt.Rectangle": [[0, 17]]}}}, {"text": "The intersects() method does what you want, and the rectangles you have given do not intersect", "label": {"api": {"intersects()": [[4, 15]]}}}, {"text": "The coordinates of a java.awt.Rectangle are essentially the centers of pixels, the dimensions are the count", "label": {"api": {"java.awt.Rectangle": [[21, 38]]}}}, {"text": "newSingleThreadExecutor takes a ThreadFactory as an argument", "label": {"api": {"newSingleThreadExecutor": [[0, 22]], "ThreadFactory": [[32, 44]]}}}, {"text": "ThreadFactory defines a single method newThread that takes a Runnable as an argument and returns a Thread", "label": {"api": {"ThreadFactory": [[0, 12]]}}}, {"text": "Except that since the lambda is immediately passed as an argument to a method that accepts a ThreadFactory, the compiler is able to infer that the type of r must be Runnable", "label": {"api": {"ThreadFactory": [[93, 105]]}}}, {"text": "I would like to point out that it might be more appropriate to use the built-in IntFunction in this case", "label": {"api": {"IntFunction": [[80, 90]]}}}, {"text": "IntFunction is a part of the standard API for functional interfaces which defines a range of good to have interfaces, mostly related to Java primitives", "label": {"api": {"IntFunction": [[0, 10]], "standard API for functional interfaces": [[29, 66]]}}}, {"text": "Class.getDeclaredFields() returns the fields in the order of declaration", "label": {"api": {"Class.getDeclaredFields()": [[0, 24]]}}}, {"text": "Please refer the  Oracle documentation for the set method", "label": {"api": {"Oracle documentation": [[18, 37]]}}}, {"text": "Here is the API javadoc for BigDecimal#add", "label": {"api": {"BigDecimal#add": [[28, 41]]}}}, {"text": "once you have modified your audio stream, you can use AudioSystem.getAudioInputStream(java.io.InputStream), to perform your step 4, like this", "label": {"api": {"AudioSystem.getAudioInputStream(java.io.InputStream)": [[54, 105]]}}}, {"text": "Finally, you will need the Clip interface to play the sound", "label": {"api": {"Clip": [[27, 30]]}}}, {"text": "Since the Field you are using as a sort key is determined at run time, your best option here is to use the version of Collections.sort that takes a Comparator", "label": {"api": {"Collections.sort": [[118, 133]], "Comparator": [[148, 157]]}}}, {"text": "Then you can create a Comparator that, given a Field, compares two Music objects based on the value of that field, and use that to sort the list, e.g.", "label": {"api": {"Comparator": [[22, 31]]}}}, {"text": "You can add ascending as a field to your MusicFieldComparator in a similar way, and negate what compare() returns based on ascending vs", "label": {"api": {"Comparator": [[51, 60]]}}}, {"text": "parseInt is a static method declared in the Integer class", "label": {"api": {"parseInt": [[0, 7]]}}}, {"text": "Many predefined Collectors might seem redundant since they represent operations that are directly accessible on a Stream", "label": {"api": {"Collectors": [[16, 25]]}}}, {"text": "However, they make sense when you start to compose Collectors", "label": {"api": {"Collectors": [[51, 60]]}}}, {"text": "You can, however, reduce the overhead of String construction by calling Matcher.start(int group) and check if the index returned is non-negative (larger or equal to 0)", "label": {"api": {"Matcher.start(int group)": [[72, 95]]}}}, {"text": "And compared with Matcher.start(int group), also Oracle's implementation version 8-b123", "label": {"api": {"Matcher.start(int group)": [[18, 41]]}}}, {"text": "You can use Field.getType().isPrimitive() to find out if a field is of a primitive type (int, bool, &c.)", "label": {"api": {"Field.getType().isPrimitive()": [[12, 40]]}}}, {"text": "Like Simple or build in HTTPServer class in java", "label": {"api": {"HTTPServer": [[24, 33]]}}}, {"text": "What I wonder, is the Java implementation of LinkedList good for this", "label": {"api": {"LinkedList": [[45, 54]]}}}, {"text": "For traversal backwards and forwards I would probably use an ArrayList as it implements RandomAccess", "label": {"api": {"ArrayList": [[61, 69]], "RandomAccess": [[88, 99]]}}}, {"text": "You can use Math.round to get a correctly rounded value, or BigDecimal for a choice of 8 different rounding modes", "label": {"api": {"Math.round": [[12, 21]], "BigDecimal": [[60, 69]]}}}, {"text": "From the docs", "label": {"api": {"From the docs": [[0, 12]]}}}, {"text": "You can use a Map where you map each character to its set of occurences", "label": {"api": {"Map": [[14, 16]]}}}, {"text": "With Java 9, we now have the option (pun intended) of using the Optional::stream method, so we can instead write", "label": {"api": {"Optional::stream": [[64, 79]]}}}, {"text": "use getSession() on your SSLSocket (or SSLEngine) to get the current SSLSession, then use getCipherSuite()", "label": {"api": {"getCipherSuite()": [[90, 105]]}}}, {"text": "(Note that getSession() will have the side effect of initiating a handshake if this hasn't already been done another way, see introduction of SSLSocket documentation)", "label": {"api": {"introduction of SSLSocket documentation": [[126, 164]]}}}, {"text": "Use a WatchService to monitor your directories", "label": {"api": {"WatchService": [[6, 17]]}}}, {"text": "If you really need O(1) space, you could sort the array using Arrays.sort(int\\[\\]) (whose implementation in Java 7 onward uses a Dual-Pivot Quicksort, which is an in-place - ie O(1) - algorithm) then add this code", "label": {"api": {"Arrays.sort(int\\[\\])": [[62, 81]]}}}, {"text": "Most nice object for this purpose it's a LinkedHashMap", "label": {"api": {"LinkedHashMap": [[41, 53]]}}}, {"text": "You haven't overridden toString(), so what you see is the String returned from the inherited toString() method from Object", "label": {"api": {"the inherited toString() method from Object": [[79, 121]]}}}, {"text": "Since Java 8 you can even obtain a Stream of all lines in a file using Files.lines()", "label": {"api": {"Files.lines()": [[71, 83]]}}}, {"text": "You can rotate() the image around an anchor point, also seen here in a Graphics2D context", "label": {"api": {"rotate()": [[8, 15]]}}}, {"text": "The method concatenates translate(), rotate() and translate() operations, also seen here as explicit transformations", "label": {"api": {"rotate()": [[37, 44]]}}}, {"text": "Once you filter() the image, use one of the ImageIO.write() methods to save the resulting RenderedImage, for example", "label": {"api": {"filter()": [[9, 16]], "ImageIO.write()": [[44, 58]], "RenderedImage": [[90, 102]]}}}, {"text": "java.util.Queue doesn't have such method", "label": {"api": {"java.util.Queue": [[0, 14]]}}}, {"text": "Instead, it has offer method to add data", "label": {"api": {"offer": [[16, 20]]}}}, {"text": "If you don't want duplicate, use a collection that implements the Set  interface (http://docs.oracle.com/javase/7/docs/api/java/util/Set.html) instead of an array list", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/util/Set.html": [[82, 140]]}}}, {"text": "This is clearly stated at javadoc of ArrayList#add(int, E)", "label": {"api": {"ArrayList#add(int, E)": [[37, 57]]}}}, {"text": "Use RandomAccessFile.seek() to position to where you want to read from and RandomAccessFile.readFully() to read a full byte array", "label": {"api": {"RandomAccessFile.seek()": [[4, 26]], "RandomAccessFile.readFully()": [[75, 102]]}}}, {"text": "Also you can use the RandomAccessFile.read(byte[] b, int off, int len) method too, but the offset and length corresponds to the offset in the array where to start storing the read bytes, and length specifies how many bytes to read from the file", "label": {"api": {"RandomAccessFile.read(byte[] b, int off, int len)": [[21, 69]]}}}, {"text": "When creating a String from a byte array, quoting from the javadoc of String(byte[] bytes)", "label": {"api": {"String(byte[] bytes)": [[70, 89]]}}}, {"text": "You can try something like this, using Matcher#appendReplacement and Matcher#appendTail", "label": {"api": {"Matcher#appendReplacement": [[39, 63]], "Matcher#appendTail": [[69, 86]]}}}, {"text": "Quoting from java.util.Scanner API", "label": {"api": {"API": [[31, 33]]}}}, {"text": "An alternative way using Collections.reverse()", "label": {"api": {"Collections.reverse()": [[25, 45]]}}}, {"text": "List implements Iterable which contains forEach", "label": {"api": {"Iterable": [[16, 23]], "forEach": [[40, 46]]}}}, {"text": "When in doubt, check the documentation (see \"Methods inherited from interface java.lang.Iterable\" section)", "label": {"api": {"Iterable": [[88, 95]], "check the documentation": [[15, 37]]}}}, {"text": "use ArrayList.indexOf()  to get get index of object", "label": {"api": {"ArrayList.indexOf()": [[4, 22]]}}}, {"text": "In your main method, just use BufferedWriter's newLine() method, like that", "label": {"api": {"newLine()": [[47, 55]]}}}, {"text": "Class.forName creates an instance of a java.lang.Class corresponding to the given name", "label": {"api": {"java.lang.Class": [[39, 53]]}}}, {"text": "Older JDBC drivers used to use these static block to register themselves to the java.sql.DriverManager so they can later be used to connect to the database", "label": {"api": {"java.sql.DriverManager": [[80, 101]]}}}, {"text": "According to the documentation (http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#forName(java.lang.String))", "label": {"api": {"http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#forName(java.lang.String)": [[32, 118]]}}}, {"text": "Java supports the Locales shown in this link", "label": {"api": {"Locale": [[18, 23]]}}}, {"text": "Another effect is that you won't be able to use API from Hashtable like Hashtable#elements since the wrapped collection is now strictly a Map instance", "label": {"api": {"Hashtable#elements": [[72, 89]]}}}, {"text": "See java.lang.thread for pre-defined priorities", "label": {"api": {"java.lang.thread": [[4, 19]]}}}, {"text": "See the Date class for more details", "label": {"api": {"Date class": [[8, 17]]}}}, {"text": "After you save it to somewhere, you can use java.awt.Desktop to open it, which will use the default program for that file type", "label": {"api": {"java.awt.Desktop": [[44, 59]]}}}, {"text": "Character.isUpperCase() does accept things based off of other languages", "label": {"api": {"Character.isUpperCase()": [[0, 22]]}}}, {"text": "If you want to print one or more part of string which matches your regex you need to use Matcher.find method first to let regex engine localize this matching substring", "label": {"api": {"Matcher.find": [[89, 100]]}}}, {"text": "As opposed to a java.util.concurrent.ConcurrentHashMap, the second level cache could be saved to the disk (meaning you always get a copy of the disk-based saved data), and so it must be consistent with both an in-memory and a disk-based 2nd level caching implementation", "label": {"api": {"java.util.concurrent.ConcurrentHashMap": [[16, 53]]}}}, {"text": "If Compiler.LOADER remains unbound and RT.USE_CONTEXT_CLASSLOADER evaluates to true, you can set the context loader of your thread to your custom class loader", "label": {"api": {"context loader": [[101, 114]]}}}, {"text": "Unless your connection is in autocommit mode* you should call commit() on it before calling close()", "label": {"api": {"commit()": [[62, 69]]}}}, {"text": "If you want LSB, you'll have to go through a ByteBuffer (and set its byte order; big endian by default)", "label": {"api": {"set its byte order": [[61, 78]]}}}, {"text": "Note that there is also Float.floatToRawIntBits()", "label": {"api": {"Float.floatToRawIntBits()": [[24, 48]]}}}, {"text": "Normally, you would use a Comparable to achieve this", "label": {"api": {"Comparable": [[26, 35]]}}}, {"text": "The Comparable interface defines a compareTo() function, which you can implement to achieve whatever comparison logic you require", "label": {"api": {"Comparable": [[4, 13]]}}}, {"text": "you misunderstand how ArrayLists do work and you really should read the Javadoc", "label": {"api": {"read the Javadoc": [[63, 78]]}}}, {"text": "To avoid precision loss, use BigDecimal instead (see Javadoc)", "label": {"api": {"see Javadoc": [[49, 59]]}}}, {"text": "I know that in the Random class, for example the nextInt method, already give me something like that", "label": {"api": {"Random": [[19, 24]]}}}, {"text": "First define a SwingWorker", "label": {"api": {"SwingWorker": [[15, 25]]}}}, {"text": "Here is how to use the Random class to pick an element from an array", "label": {"api": {"Random": [[23, 28]]}}}, {"text": "JavaDoc of class String", "label": {"api": {"JavaDoc of class String": [[0, 22]]}}}, {"text": "read again the javadoc for String.split() and compare with what you have in Employee", "label": {"api": {"String.split()": [[27, 40]]}}}, {"text": "As JB points out, one clue to underlying cause of the inconsistency might be that Integer.parseInt was in the JDK from the beginning, but Double.parseDouble was added in 1.2", "label": {"api": {"Integer.parseInt": [[82, 97]], "Double.parseDouble": [[138, 155]]}}}, {"text": "But in this case you might be better of using a HashMap which assigns a value (in your case a product) to a key (in your case its name)", "label": {"api": {"HashMap": [[48, 54]]}}}, {"text": "If you want to have more flexibility with rounding values,you can use the BigDecimal class and RoundingMode", "label": {"api": {"BigDecimal": [[74, 83]], "RoundingMode": [[95, 106]]}}}, {"text": "Or you can go with the Math.round() method and make a small helper function like", "label": {"api": {"Math.round()": [[23, 34]]}}}, {"text": "The Collections.max method expects an argument which implements Collection", "label": {"api": {"Collections.max": [[4, 18]], "Collection": [[4, 13], [64, 73]]}}}, {"text": "The easiest way would probably be to extend AbstractCollection and add these methods", "label": {"api": {"Collection": [[52, 61]]}}}, {"text": "You can, for instance, provide a custom Comparator to your method", "label": {"api": {"Comparator": [[40, 49]]}}}, {"text": "Another approach is to make your list only keep Comparable items", "label": {"api": {"Comparable": [[48, 57]]}}}, {"text": "Second approach is less verbose, as Integer is Comparable (i.e", "label": {"api": {"Comparable": [[47, 56]]}}}, {"text": "implements Comparable for you already), so you won't need to change any other code", "label": {"api": {"Comparable": [[11, 20]]}}}, {"text": "because JOptionPane.showInputDialog() returns a String, regardless of what you actually want the user to input", "label": {"api": {"returns a String": [[38, 53]]}}}, {"text": "I need to check if a given date falls in the current month, and I wrote the following code, but the IDE reminded me that the getMonth() and getYear() methods are obsolete", "label": {"api": {"getMonth()": [[125, 134]], "getYear()": [[140, 148]]}}}, {"text": "Why not use JavaCompiler interface", "label": {"api": {"JavaCompiler": [[12, 23]]}}}, {"text": "You can use File.listFiles(FilenameFilter)", "label": {"api": {"File.listFiles(FilenameFilter)": [[12, 41]]}}}, {"text": "Because length() is defined in CharSequence interface, which is implemented by String", "label": {"api": {"CharSequence": [[31, 42]]}}}, {"text": "In many methods, you may rely only on CharSequence interface instead of a real String, then you can use an instance of CharBuffer, Segment, String, StringBuffer or StringBuilder in the call site", "label": {"api": {"CharSequence": [[38, 49]]}}}, {"text": "The easiest way to zoom everything is to scale the Graphics2D object at the beginning of the paint method, but before it save the old AffineTransform and reset it at the end", "label": {"api": {"scale": [[41, 45]]}}}, {"text": "As you are writing a JavaFX application, you should probably use the built-in JavaFX AudioClip API rather than AWT based API", "label": {"api": {"AudioClip": [[85, 93]]}}}, {"text": "See the JavaFX media Javadoc for a description of supported audio formats", "label": {"api": {"JavaFX media Javadoc": [[8, 27]]}}}, {"text": "Create a DateTimeFormatter with the pattern you specified (the syntax you gave for the pattern is exactly correct; the docs go into lots of detail on the pattern syntax)", "label": {"api": {"DateTimeFormatter": [[9, 25]]}}}, {"text": "if you really need to do \"this..\" you can maybe use JEditorPane.", "label": {"api": {"JEditorPane": [[52, 62]]}}}, {"text": "I am confused in visualizing the functionality of the rewind() and flip() of the Buffer class", "label": {"api": {"Buffer": [[81, 86]]}}}, {"text": "To get the result that you want, use BigInteger which preserves the actual value of 2^1000", "label": {"api": {"BigInteger": [[37, 46]]}}}, {"text": "And, despite it’s name, ClassLoader.getSystemClassLoader() will return the application loader which will be the one which resolves classes using the supplied user CLASSPATH", "label": {"api": {"ClassLoader.getSystemClassLoader()": [[24, 57]]}}}, {"text": "So from a class contained in bootstrap.jar (which will be loaded by the extension loader when placed in jre/lib/ext) you can use ClassLoader.getSystemClassLoader() .loadClass(\"class.within.your.classpath\") to load the class from system.jar", "label": {"api": {"ClassLoader.getSystemClassLoader()": [[129, 162]]}}}, {"text": "As a side note, in this typical setup, the expression ClassLoader.getSystemClassLoader().getParent()==MyClass.class.getClassLoader() will evaluate to true if MyClass has been loader by the extension loader", "label": {"api": {"ClassLoader.getSystemClassLoader()": [[54, 87]]}}}, {"text": "You can supply you're own images for radio button, see JRadioButton#setIcon, JRadioButton#setSelectedIcon and How to Use Buttons, Check Boxes, and Radio Buttons for more details..", "label": {"api": {"JRadioButton#setIcon": [[55, 74]], "JRadioButton#setSelectedIcon": [[77, 104]]}}}, {"text": "Instead take a look at the ObservableValue interface", "label": {"api": {"ObservableValue": [[27, 41]]}}}, {"text": "The javadoc page of ObservableValue lists all the JavaFX built-in classes that implement this interface (the list is quite looooong)", "label": {"api": {"ObservableValue": [[20, 34]]}}}, {"text": "Use String Tokenizer then loop and compare all tokens produced", "label": {"api": {"String Tokenizer": [[4, 19]]}}}, {"text": "As per this documentation, scaleX is the contribution of the initial X coordinate before transform to the final X coordinate after transform", "label": {"api": {"this documentation": [[7, 24]]}}}, {"text": "Every aplication has it's own login mechanism and primary purpose of the Robot API is for automated testing of Java platform implementations", "label": {"api": {"Robot API": [[73, 81]]}}}, {"text": "If it does not belong to any of the two packages (maybe even a third class loader's qux package), neither method is visible and an IllegalAccessError is thrown", "label": {"api": {"IllegalAccessError": [[131, 148]]}}}, {"text": "I'm well aware that Nimbus is a Synth L&F so it uses Painters for just about anything", "label": {"api": {"Painter": [[53, 59]]}}}, {"text": "I bet I could override some Painter in UIManager but I don't want to redo a Painter from scratch", "label": {"api": {"Painter": [[28, 34], [76, 82]]}}}, {"text": "The Painters in Nimbus are quite advanced, they use gradients and what have you", "label": {"api": {"Painter": [[4, 10]]}}}, {"text": "What you should have is the SOAPMessageContext, from which you can easily get the SOAPMessage", "label": {"api": {"SOAPMessageContext": [[28, 45]]}}}, {"text": "If you don't want / can't manipulate the query to order the enums while fetching, remember that all enums implement the Comparable interface", "label": {"api": {"Comparable interface": [[120, 139]]}}}, {"text": "The setProgress() API notes", "label": {"api": {"setProgress()": [[4, 16]]}}}, {"text": "To achieve the same result, using the default ProgressMonitor class was the best option", "label": {"api": {"ProgressMonitor": [[46, 60]]}}}, {"text": "I have passed the ProgressMonitor to the SwingWorker through its constructor", "label": {"api": {"ProgressMonitor": [[18, 32]]}}}, {"text": "SimpleDateFormat inherits it from DateFormat", "label": {"api": {"inherits it from DateFormat": [[17, 43]]}}}, {"text": "You should call Scanner.hasNextInt() before calling Scanner.nextInt()", "label": {"api": {"Scanner.hasNextInt()": [[16, 35]], "Scanner.nextInt()": [[52, 68]]}}}, {"text": "Likewise with Scanner.hasNext() and Scanner.next()", "label": {"api": {"Scanner.hasNext()": [[14, 30]], "Scanner.next()": [[36, 49]]}}}, {"text": "Now have a look at the documentation for Object..", "label": {"api": {"documentation for Object": [[23, 46]]}}}, {"text": "You can use a JFileChooser to handle the open dialog", "label": {"api": {"JFileChooser": [[14, 25]]}}}, {"text": "Why should File.createNewFile() not be used for file locking", "label": {"api": {"File.createNewFile()": [[11, 30]]}}}, {"text": "Now I'm a bit confused about the Javadoc of createNewFile()", "label": {"api": {"Javadoc of createNewFile()": [[33, 58]]}}}, {"text": "The FileLock facility should be used instead", "label": {"api": {"FileLock": [[4, 11]]}}}, {"text": "This forum post from December 2007 indicates there are \"significant platform differences\" according to the Javadoc of File.delete() (although I cannot find such a statement since at least Java SE 1.4.2)", "label": {"api": {"File.delete()": [[118, 130]]}}}, {"text": "Integer.parseInt(String s) will try to parse an int number form the String parameter passed to it", "label": {"api": {"Integer.parseInt(String s)": [[0, 25]]}}}, {"text": "If you do not have any control about the query you might want to befriend java.util.regex and parse for something like", "label": {"api": {"java.util.regex": [[74, 88]]}}}, {"text": "This is actually an old-style grep regex but a regex with the same function is possible for java.util.regex", "label": {"api": {"java.util.regex": [[92, 106]]}}}, {"text": "If you are uncertain how to correctly use a class, or if an instance is behaving in a way you do not understand, then your first recourse should be to read the class's documentation", "label": {"api": {"the class's documentation": [[156, 180]]}}}, {"text": "You're getting a List returned by Arrays.asList, but it's just a wrapper around an array, so you can't add anything to it", "label": {"api": {"Arrays.asList": [[34, 46]]}}}, {"text": "If you already have JavaMail for pulling javax.mail.MimeMessages off some datastore, you can simply call it's getInputSream() method to access the raw content and ignore the fact that getContent() will conveniently provide a MimeMultiPart object", "label": {"api": {"getInputSream()": [[110, 124]]}}}, {"text": "The Stream.generate() method takes a Supplier that knows how to produce a value and generates an infinite stream of those values (each value is obtained by calling the supplier again, so they are all different, unlike Collections.nCopies())", "label": {"api": {"Stream.generate()": [[4, 20]], "Supplier": [[37, 44]]}}}, {"text": "I was playing around with JavaFX's Tooltip", "label": {"api": {"JavaFX's Tooltip": [[26, 41]]}}}, {"text": "The JavaFX CSS Reference has no information about delay time and a runtime-evaluation of getCssMetaData() did not help either", "label": {"api": {"JavaFX CSS Reference": [[4, 23]]}}}, {"text": "You're going to need to use some transformations, personally I like AffineTransform's", "label": {"api": {"AffineTransform": [[68, 82]]}}}, {"text": "As per the java.util.Formatter API", "label": {"api": {"java.util.Formatter API": [[11, 33]]}}}, {"text": "There are interesting questions and answers regarding Java's InterruptedException, for example The Cause of InterruptedException and Handling InterruptedException in Java", "label": {"api": {"InterruptedException": [[61, 80], [108, 127], [142, 161]]}}}, {"text": "However, none of them tells me about the possible sources of InterruptedException", "label": {"api": {"InterruptedException": [[61, 80]]}}}, {"text": "Does pressing CTRL-C on the command line produce an InterruptedException", "label": {"api": {"InterruptedException": [[52, 71]]}}}, {"text": "According to the docs for EnhancedPatternLayout, the value in the second set of braces following %d is a string to be passed internally to TimeZone.getTimeZone(String), which states the string should be", "label": {"api": {"TimeZone.getTimeZone(String)": [[139, 166]]}}}, {"text": "If you want to do this by yourself, have a look at TextFlow", "label": {"api": {"TextFlow": [[51, 58]]}}}, {"text": "The TextFlow uses the text and the font of each Text node inside of it plus it own width and text alignment to determine the location for each child", "label": {"api": {"TextFlow": [[4, 11]]}}}, {"text": "To get the ip-address from the user use the HttpServletRequest and call the getRemoteAddr() method", "label": {"api": {"HttpServletRequest": [[44, 61]], "getRemoteAddr()": [[76, 90]]}}}, {"text": "To get access to the HttpServletRequest simply add it to the method as an argument", "label": {"api": {"HttpServletRequest": [[21, 38]]}}}, {"text": "You probably will have to implement java.io.Serializable in both your Car and CarMaker classes as well", "label": {"api": {"java.io.Serializable": [[36, 55]]}}}, {"text": "String#split takes a regex,", "label": {"api": {"String#split": [[0, 11]]}}}, {"text": "Calendar.YEAR is just an int which is defined in Constant Field Values, see the docs", "label": {"api": {"Constant Field Values": [[49, 69]]}}}, {"text": "Take a look at the docs Calendar#set to better understand what it does", "label": {"api": {"docs Calendar#set": [[19, 35]]}}}, {"text": "Read the docs", "label": {"api": {"Read the docs": [[0, 12]]}}}, {"text": "public abstract <T> T readEntity(Class<T> entityType) - Read the message entity input stream as an instance of specified Java type using a MessageBodyReader that supports mapping the message entity stream onto the requested type", "label": {"api": {"public abstract <T> T readEntity(Class<T> entityType)": [[0, 52]]}}}, {"text": "Just like BufferedWriter#close() or FilterOutputStream.#close() , if all of buffered Stream/Writer  will call its flush() when we call close() and if we (the dev and the dev who will review the code) all  know the that,  do we really still need this", "label": {"api": {"BufferedWriter#close()": [[10, 31]], "FilterOutputStream.#close()": [[36, 62]]}}}, {"text": "Additionally, as documented", "label": {"api": {"documented": [[17, 26]]}}}, {"text": "Iterator.remove() returns nothing - it is declared as void", "label": {"api": {"Iterator.remove()": [[0, 16]]}}}, {"text": "Consider changing the use of BufferedOutputStream and PrintWriter for FileWriter, which will take your file as an argument to the constructor", "label": {"api": {"FileWriter": [[70, 79]]}}}, {"text": "Just set the Locale", "label": {"api": {"Locale": [[13, 18]]}}}, {"text": "To highlight the part \"Hello world!\" you could use JTextPane with stylesheets (look for HtmlEditorKit#setStyleSheet) like this", "label": {"api": {"JTextPane with stylesheets (look for HtmlEditorKit#setStyleSheet)": [[51, 115]]}}}, {"text": "See also the String javadoc for many more useful utility methods", "label": {"api": {"String javadoc": [[13, 26]]}}}, {"text": "Use guava's Joiner or java 8 StringJoiner", "label": {"api": {"java 8": [[22, 27]]}}}, {"text": "By default, when an exception is thrown inside an EJB method the EJB container will wrap it with an EJBException", "label": {"api": {"EJBException": [[100, 111]]}}}, {"text": "You can, however, annotate your EJB method with ApplicationException, which will tell the EJB container to throw the application exception directly", "label": {"api": {"ApplicationException": [[48, 67]]}}}, {"text": "You may use java.util.Scanner which can scan an InputStream", "label": {"api": {"java.util.Scanner": [[12, 28]]}}}, {"text": "The way you had it you would have reached a state where you would have got ConcurrentModificationException read more on that", "label": {"api": {"ConcurrentModificationException": [[75, 105]]}}}, {"text": "You can do it manually or use System.arraycopy() to suit your needs", "label": {"api": {"System.arraycopy()": [[30, 47]]}}}, {"text": "Remember to always call clearParameters() before reusing it", "label": {"api": {"clearParameters()": [[24, 40]]}}}, {"text": "From the code it looks very much like what you tried to do is join() the background threads", "label": {"api": {"join()": [[62, 67]]}}}, {"text": "is the only other valid option, as documented", "label": {"api": {"documented": [[35, 44]]}}}, {"text": "Use Calendar to do this", "label": {"api": {"Calendar": [[4, 11]]}}}, {"text": "Referring to Oracle NoClassDefFoundError Documentation", "label": {"api": {"Oracle NoClassDefFoundError Documentation": [[13, 53]]}}}, {"text": "If you are sure that you'll be able to add up your values, you may want to look at the Number interface which offers a intValue() function", "label": {"api": {"Number": [[87, 92]]}}}, {"text": "When deploying your application you'll need to target both servers or create a cluster (also very easy), add both machines to it and give the cluster name as the target", "label": {"api": {"very easy": [[93, 101]]}}}, {"text": "Don't use System.out.println but some smarter way of writing the output(BufferedWriter?)", "label": {"api": {"BufferedWriter": [[72, 85]]}}}, {"text": "JContainer offers a public method named setFont(), so you can call it from any place in your program, where you have a reference to the label object (the Lives' constructor is a valid place though)", "label": {"api": {"public method named setFont()": [[20, 48]]}}}, {"text": "The key here is to understand that the time-zone identifier and the \"short name\" of that identifier are two different elements", "label": {"api": {"\"short name\"": [[68, 79]]}}}, {"text": "Instead use BufferedImage#createGraphics(), as shown here", "label": {"api": {"BufferedImage#createGraphics()": [[12, 41]]}}}, {"text": "wait,notify, etc., as they have an entirely different semantics", "label": {"api": {"wait": [[0, 3]]}}}, {"text": "For what you want to achieve, you have to call TimeUnit.MINUTES.sleep(2)", "label": {"api": {"TimeUnit.MINUTES.sleep(2)": [[47, 71]]}}}, {"text": "I suggest that you use a StringBuilder to concatenate the substrings, otherwise you're going to generate a lot of garbage strings", "label": {"api": {"StringBuilder": [[25, 37]]}}}, {"text": "You might also be able to replace the state array with a StringBuilder, using StringBuilder#replace in place of the int/short/byte increment operations", "label": {"api": {"StringBuilder": [[57, 69], [78, 90]]}}}, {"text": "To let instances of your class be sorted, make your class implement the Comparable interface", "label": {"api": {"Comparable": [[72, 81]]}}}, {"text": "I want to sort an ArrayList of objects on a specific field using a given RuleBasedCollator", "label": {"api": {"RuleBasedCollator": [[73, 89]]}}}, {"text": "Anyway, my guess is that you're looking for a mechanism just like the ServiceLoader facility", "label": {"api": {"ServiceLoader": [[70, 82]]}}}, {"text": "I believe you should be specifying the full path to the bat file, and you can use ProcessBuilder.directory(File) to set this process builder's working directory", "label": {"api": {"ProcessBuilder.directory(File)": [[82, 111]]}}}, {"text": "Subprocesses subsequently started by this object's start() method will use this as their working directory", "label": {"api": {"start()": [[51, 57]]}}}, {"text": "register a listener with the showing property", "label": {"api": {"showing property": [[29, 44]]}}}, {"text": "You don't necessarily need to keep track of the index, since you can perfectly well remove the object itself without knowing the index", "label": {"api": {"remove the object itself": [[84, 107]]}}}, {"text": "Well, you could find out the index by calling indexOf on the first list", "label": {"api": {"indexOf": [[46, 52]]}}}, {"text": "Outside the BMP however, two chars are required for a single code point (one for the leading surrogate, another for the trailing surrogate); from what I can see, apart from a dedicated grammar engine, I don't see a way for Java regexes (as defined by java.util.regex.Pattern) to define \"character classes\" for such code points, since there is no String literal for code points outside the BMP", "label": {"api": {"java.util.regex.Pattern": [[251, 273]]}}}, {"text": "Some of the components within JSF/PrimeFaces implement the NamingContainer inerface", "label": {"api": {"NamingContainer": [[59, 73]]}}}, {"text": "I've come to the conclusion that in my particular situation I do not need the addition of any references other than the normal strong references and my already used WeakHashMap collections", "label": {"api": {"WeakHashMap": [[165, 175]]}}}, {"text": "You need to escape % sign in format string", "label": {"api": {"format string": [[29, 41]]}}}, {"text": "The official tutorial isn't really that obvious about it, but a look at the official documentation shows the details", "label": {"api": {"official documentation": [[76, 97]]}}}, {"text": "Integer.parseInt will not convert an invalid input to an integer", "label": {"api": {"Integer.parseInt": [[0, 15]]}}}, {"text": "If you want to check that your input is a valid number, you need to catch NumberFormatException", "label": {"api": {"NumberFormatException": [[74, 94]]}}}, {"text": "Have a look at the TreeItem and the TreeModificationEvent docs", "label": {"api": {"TreeItem": [[19, 26]], "TreeModificationEvent": [[36, 56]]}}}, {"text": "You can add a listener to the root node for the childrenModificationEvent", "label": {"api": {"childrenModificationEvent": [[48, 72]]}}}, {"text": "Any time a node is added or removed below your root node you will get the TreeModificationEvent where you can retrieve the added and deleted nodes", "label": {"api": {"TreeModificationEvent": [[74, 94]]}}}, {"text": "Your code looks good anyways I've used AsynchronousFileChannel from new non-blocking IO", "label": {"api": {"AsynchronousFileChannel": [[39, 61]], "FileChannel": [[51, 61]]}}}, {"text": "The implementation uses MappedByteBuffer through  FileChannel", "label": {"api": {"MappedByteBuffer": [[24, 39]], "FileChannel": [[50, 60]]}}}, {"text": "The issue is that the contract for these methods is defined a little vaguely but, specifically, it is defined by 'the number of sample frames captured by, or rendered from, the line since it was opened'", "label": {"api": {"these methods": [[35, 47]]}}}, {"text": "IMO this is a good use case for combining Action and setClientProperty(key, value) / getClientProperty(key) in order to anonymize the action itself as much as possible", "label": {"api": {"setClientProperty(key, value)": [[53, 81]], "getClientProperty(key)": [[85, 106]]}}}, {"text": "There is good support for .properties files in Java (ResourceBundle) and in frameworks like Spring", "label": {"api": {"ResourceBundle": [[53, 66]]}}}, {"text": "The vanilla ResourceBundle just loads the properties once, the Spring helper offers configurable caching and reloading (this helps with the performance aspect which you mentioned)", "label": {"api": {"ResourceBundle": [[12, 25]]}}}, {"text": "I would strongly recommend you to not use Timer but TimeLine instead", "label": {"api": {"TimeLine": [[52, 59]]}}}, {"text": "This can be done with a plain array or something more complex like a Map<K,V>, and probably using a ConcurrentHashMap<K, V>", "label": {"api": {"Map<K,V>": [[69, 76]], "ConcurrentHashMap<K, V>": [[100, 122]]}}}, {"text": "If you're working in a web application, then you may use ServletContext as cache since it's elements are shared across all the application, but be careful since your classes should not directly access to this class, instead access to it from a Servlet or another technology that helps you access to it", "label": {"api": {"ServletContext": [[57, 70]]}}}, {"text": "java.sql.ResultSet does not have a method getChars", "label": {"api": {"java.sql.ResultSet": [[0, 17]]}}}, {"text": "See Class.getDeclaredMethod(), as in", "label": {"api": {"Class.getDeclaredMethod()": [[4, 28]]}}}, {"text": "To parse the date, use a SimpleDateFormatter", "label": {"api": {"SimpleDateFormatter": [[25, 43]]}}}, {"text": "Note that if you create a Scanner from System.in, it has methods for getting whole-line input and other things that make it much easier to use than processing individual bytes", "label": {"api": {"Scanner": [[26, 32]]}}}, {"text": "matches tries to match the entire input against the pattern (as it says in the documentation), and of course manifest isn't an exact match for ni but is an exact match for .*ni.*", "label": {"api": {"matches": [[0, 6]]}}}, {"text": "But if you use find, for instance, it'll search for the pattern somewhere within the input", "label": {"api": {"find": [[15, 18]]}}}, {"text": "There's also lookingAt, which tries to match the pattern at the \"current\" position within the input", "label": {"api": {"lookingAt": [[13, 21]]}}}, {"text": "if you are reading from a Reader it returns an int which is the char or -1 if at the end of input", "label": {"api": {"Reader": [[26, 31]]}}}, {"text": ".properties files are loaded by ResourceBundle into a HashSet, which does not preserve order", "label": {"api": {"ResourceBundle": [[32, 45]], "HashSet": [[54, 60]]}}}, {"text": "The Enumeration object that you receive is just an iterator over the set", "label": {"api": {"Enumeration": [[4, 14]]}}}, {"text": "I looked into the ListResourceBundle class and unfortunately it too returns an Enumeration object over a set that does not maintain order", "label": {"api": {"ResourceBundle": [[22, 35]], "Enumeration": [[79, 89]], "ListResourceBundle": [[18, 35]]}}}, {"text": ".properties will be loaded using InputStream in PropertyResourceBundle and stored in an instance of Properties that is internally represented by a Hashtable which too does not maintain order", "label": {"api": {"ResourceBundle": [[56, 69]], "InputStream": [[33, 43]], "PropertyResourceBundle": [[48, 69]], "Properties": [[100, 109]], "Hashtable": [[147, 155]]}}}, {"text": "Object.notifyAll() throws IllegalMonitorStateException - if the current thread is not the owner of this object's monitor", "label": {"api": {"Object.notifyAll()": [[0, 17]]}}}, {"text": "Parameters can be fetched as follows", "label": {"api": {"Parameters": [[0, 9]]}}}, {"text": "If you have other than key=value parameters, check hte alternatives from Parameters", "label": {"api": {"Parameters": [[73, 82]]}}}, {"text": "You should extend HttpServlet and implement doGet(), doPost(), doPut() etc instead of GenericServlet", "label": {"api": {"HttpServlet": [[18, 28]]}}}, {"text": "Look at HttpServlet", "label": {"api": {"HttpServlet": [[8, 18]]}}}, {"text": "If you want to block across multiple queues, then one option is to use java's Lock and Condition objects and then use the signal method", "label": {"api": {"Lock and Condition objects and then use the signal method": [[78, 134]]}}}, {"text": "According to the Swing tutorial and the documentation for JComponent.setToolTipText, passing null to setToolTipText will turn off the tooltip, so you can do this", "label": {"api": {"the documentation for JComponent.setToolTipText": [[36, 82]]}}}, {"text": "One way to do this is for your Special class to implement SQLData", "label": {"api": {"SQLData": [[58, 64]]}}}, {"text": "You would also need to add the type to the database connection's type map", "label": {"api": {"database connection's type map": [[43, 72]]}}}, {"text": "In the the official Java documentation, Float.SIZE is defined as", "label": {"api": {"official Java documentation": [[11, 37]]}}}, {"text": "You can replace your 2D array with a java.util.HashMap", "label": {"api": {"java.util.HashMap": [[37, 53]]}}}, {"text": "From the documentation on HttpURLConnection#getResponseCode() method", "label": {"api": {"HttpURLConnection#getResponseCode()": [[26, 60]]}}}, {"text": "This can easily be done by the Random class", "label": {"api": {"Random class": [[31, 42]]}}}, {"text": "For further information of what the code exactly does, I would recommend you again, to take a look at the Random class, I find it very useful in many cases", "label": {"api": {"Random class": [[106, 117]]}}}, {"text": "You could do this by using a JFormattedTextField", "label": {"api": {"JFormattedTextField": [[29, 47]]}}}, {"text": "you pass it a formatter (which extends AbstractFormatter), and the formatter will allow you to restrict and modify how things are displayed in your field", "label": {"api": {"AbstractFormatter": [[39, 55]]}}}, {"text": "In this case, you could use the pre-made formatter NumberFormatter", "label": {"api": {"NumberFormatter": [[51, 65]]}}}, {"text": "There already exists a class (BitSet) in the standard library to help you do this, you should use that instead of a boolean array", "label": {"api": {"BitSet": [[30, 35]]}}}, {"text": "You could use compute (Java 8+)", "label": {"api": {"compute": [[14, 20]]}}}, {"text": "The value you are getting is the object's value, based on the default toString() implementation", "label": {"api": {"implementation": [[81, 94]]}}}, {"text": "Collections.reverse will do it for you", "label": {"api": {"Collections.reverse": [[0, 18]]}}}, {"text": "You can use replaceAll if you are using Java 8+", "label": {"api": {"replaceAll": [[12, 21]]}}}, {"text": "Please have a look at the Formatter API as it will show you that this class has no hasNext() method, and your Java compiler is correctly telling you the same thing", "label": {"api": {"Formatter API": [[26, 38]]}}}, {"text": "Similarly, the Scanner API will show you that it in fact has the method you need", "label": {"api": {"Scanner API": [[15, 25]]}}}, {"text": "Java doc of indexOf()", "label": {"api": {"indexOf()": [[12, 20]]}}}, {"text": "I would definitely recommend that you use the LinkedList class from the java.util package instead of implementing your own", "label": {"api": {"LinkedList": [[46, 55]]}}}, {"text": "If you use Java's LinkedList, then it will have the method T get(int index) which will return the element at the specified index", "label": {"api": {"LinkedList": [[18, 27]]}}}, {"text": "This does not require a LinkedList specifically", "label": {"api": {"LinkedList": [[24, 33]]}}}, {"text": "All of the required methods are defined in the List Interface, which the LinkedList class of course implements", "label": {"api": {"LinkedList": [[73, 82]], "List Interface": [[47, 60]]}}}, {"text": "If you must use your own LinkedList implementation, then you should also implement the List interface", "label": {"api": {"LinkedList": [[25, 34]]}}}, {"text": "You can save yourself from all this trouble if you use InetAddress.getByName(String) instead", "label": {"api": {"InetAddress.getByName(String)": [[55, 83]]}}}, {"text": "Arrays (or Collections) on the other hand is not an object", "label": {"api": {"Arrays": [[0, 5]], "Collections": [[11, 21]]}}}, {"text": "Arrays is a class which features only static utility methods that can perform convenient operations on arrays", "label": {"api": {"Arrays": [[0, 5]]}}}, {"text": "The lambda expression is a definition for the body of Predicate<Person>#test, which will take a Person as a parameter", "label": {"api": {"Predicate<Person>#test": [[54, 75]]}}}, {"text": "Since Predicate<T> is a functional interface with the method test(T t), we know that the type of p is T (and not Predicate<T>)", "label": {"api": {"test(T t)": [[61, 69]]}}}, {"text": "You can use FileChannel truncate", "label": {"api": {"FileChannel truncate": [[12, 31]]}}}, {"text": "This is a follow-up to this answer in an attempt to save few lines with the @XmlElementWrapper", "label": {"api": {"@XmlElementWrapper": [[76, 93]]}}}, {"text": "Elliot's answer is of course correct, but for completeness' sake it's worth noting that if you don't want to print the value immediately, but instead hold the String for some other usage, you could use the DecimalFormat class", "label": {"api": {"DecimalFormat": [[206, 218]]}}}, {"text": "For example java.io.Serializable", "label": {"api": {"java.io.Serializable": [[12, 31]]}}}, {"text": "That is not valid unless you use the iterator itself to add the new Item to the list", "label": {"api": {"use the iterator itself": [[29, 51]]}}}, {"text": "A server should be able to read chunk from request body without blocking every time a client writes and flushes that chunk like Servlet 3.1's ServletInputStream#setReadListener", "label": {"api": {"ServletInputStream#setReadListener": [[142, 175]]}}}, {"text": "A server should be able to write and flush chunk multiple times to response body without blocking like Servlet 3.0's HttpServletRequest#startAsync", "label": {"api": {"HttpServletRequest#startAsync": [[117, 145]]}}}, {"text": "They extend the Enum parent", "label": {"api": {"parent": [[21, 26]]}}}, {"text": "If A is using the result of B, then maybe you can consider a BlockingQueue", "label": {"api": {"BlockingQueue": [[61, 73]]}}}, {"text": "Fortunately, starting with Java 8, you can use .codePoints() (reminder", "label": {"api": {".codePoints()": [[47, 59]]}}}, {"text": "You can use Double.toString(double)", "label": {"api": {"Double.toString(double)": [[12, 34]]}}}, {"text": "See JScrollPanel JavaDoc for further information", "label": {"api": {"JScrollPanel JavaDoc": [[4, 23]]}}}, {"text": "I think JavaFX's ImageView allows this", "label": {"api": {"JavaFX's ImageView": [[8, 25]]}}}, {"text": "On the other hand, System.out.print(Character.toChars(i)) calls a specific implementation of print for character arrays, see the documentation of PrintStream", "label": {"api": {"the documentation of PrintStream": [[125, 156]]}}}, {"text": "You can marshal it to a StringWriter and grab its string", "label": {"api": {"StringWriter": [[24, 35]]}}}, {"text": "A convenient option is to use javax.xml.bind.JAXB", "label": {"api": {"javax.xml.bind.JAXB": [[30, 48]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/util/Timer.html - schedule the task to run e.g", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/Timer.html": [[0, 61]]}}}, {"text": "FXMLLoader.getNamespace() can be used, this is a map of named components", "label": {"api": {"FXMLLoader.getNamespace()": [[0, 24]]}}}, {"text": "Work through the tutorial for more details, and have a look at the Introduction to FXML documentation", "label": {"api": {"Introduction to FXML documentation": [[67, 100]]}}}, {"text": "The amplitude of white noise is random and normally distributed so you can use Random.nextGaussian() to generate random z-scores", "label": {"api": {"Random.nextGaussian()": [[79, 99]]}}}, {"text": "As suggested in the comment by Louis, one way to handle it in Java 8 is to simply cast uint64_t to jlong in the C++ side, then use the set of unsigned operation provided by Java 8 such as Long.compareUnsigned() to do the necessary operation", "label": {"api": {"Long.compareUnsigned()": [[188, 209]]}}}, {"text": "However, the easiest choice here is to use FlowLayout", "label": {"api": {"FlowLayout": [[43, 52]]}}}, {"text": "You also should use JFrame's pack() method, which, according to Oracle", "label": {"api": {"pack()": [[29, 34]]}}}, {"text": "The BigInteger constructor takes a String argument, not an int", "label": {"api": {"BigInteger": [[4, 13]]}}}, {"text": "Iinteger isn't a valid type, I think you wanted ArrayList<Integer> a which uses java.lang.Integer", "label": {"api": {"java.lang.Integer": [[80, 96]]}}}, {"text": "You can use AtomicInteger to do just that", "label": {"api": {"AtomicInteger": [[12, 24]]}}}, {"text": "The documentation for a StringBuffer can be found at this Java page", "label": {"api": {"this Java page": [[53, 66]]}}}, {"text": "Likewise, scanner documentation is also available", "label": {"api": {"scanner documentation": [[10, 30]]}}}, {"text": "If you want true selection functionality, you should consider using a ComboBox", "label": {"api": {"ComboBox": [[70, 77]]}}}, {"text": "CompletableFuture is very handy", "label": {"api": {"CompletableFuture": [[0, 16]]}}}, {"text": "See ClassLoader JavaDoc", "label": {"api": {"ClassLoader JavaDoc": [[4, 22]]}}}, {"text": "You have to use the toArray(T a[])-method defined in the Collection interface, passing an empty Integer[] to the method", "label": {"api": {"Collection interface": [[57, 76]]}}}, {"text": "Assuming that it's a very simple grammar I'd start by running a Scanner over the file and observe what it finds and how I might tweak it to get something that does what I want", "label": {"api": {"Scanner": [[64, 70]]}}}, {"text": "You can use the java.util.Calendar class", "label": {"api": {"java.util.Calendar": [[16, 33]]}}}, {"text": "You have to call waitFor() on the Process return by exec()", "label": {"api": {"waitFor()": [[17, 25]]}}}, {"text": "So you'll be using things like ProcessBuilder, java.io.InputStreamReader, etc, possibly alongside remote shell tools like JSCH", "label": {"api": {"ProcessBuilder": [[31, 44]]}}}, {"text": "Java has only fixed sized arrays; dynamically growing \"arrays\" are realized with List", "label": {"api": {"List": [[81, 84]]}}}, {"text": "Combine Desktop#browse(), mentioned here, with Robot#createScreenCapture(), illustrated here and here", "label": {"api": {"Desktop#browse()": [[8, 23]], "Robot#createScreenCapture()": [[47, 73]]}}}, {"text": "Have you read the JavaDoc of Long.valueOf(String)", "label": {"api": {"Long.valueOf(String)": [[29, 48]]}}}, {"text": "You will find NumberFormatException", "label": {"api": {"NumberFormatException": [[14, 34]]}}}, {"text": "The Enum base class java.lang.Enum has a static factory method valueOf(Class, String) for constructing an arbitrary enum instance", "label": {"api": {"java.lang.Enum": [[20, 33]]}}}, {"text": "If you don't need contains you can just use Enum#valueOf", "label": {"api": {"Enum#valueOf": [[44, 55]]}}}, {"text": "If you can override toString (because you can also use Enum#name) then you don't need an interface", "label": {"api": {"Enum#name": [[55, 63]]}}}, {"text": "Your column in database is of type DATE & you are mapping it to type TemporalType.TIMESTAMP which means you are actually mapping it to java.sql.Timestamp", "label": {"api": {"TemporalType.TIMESTAMP": [[69, 90]], "java.sql.Timestamp": [[135, 152]]}}}, {"text": "It is recommended that, if you have column with TIMESTAMP data type then for successful mapping in your entity class you have to map that attribute to java.sql.Timestamp", "label": {"api": {"java.sql.Timestamp": [[151, 168]]}}}, {"text": "On the other side, if your database column is of type DATE, TIME or DATETIME then you can map it to java.util.Date, java.sql.Date or java.util.Calendar", "label": {"api": {"java.util.Date": [[100, 113]], "java.sql.Date": [[116, 128]], "java.util.Calendar": [[133, 150]]}}}, {"text": "But, java.util.Date stores date & time", "label": {"api": {"java.util.Date": [[5, 18]]}}}, {"text": "You can use split to return an array of Strings, then use a StringBuilder to build your return string", "label": {"api": {"split": [[12, 16]]}}}, {"text": "Look at Long.hashCode() implementation and you'll see why << 32 is the turning point", "label": {"api": {"Long.hashCode()": [[8, 22]]}}}, {"text": "According to the docs, there's five fonts (font families actually) that all Java distributions must support", "label": {"api": {"According to the docs,": [[0, 21]]}}}, {"text": "ExecutorService#shutdown will not do anything to currently running tasks", "label": {"api": {"ExecutorService#shutdown": [[0, 23]]}}}, {"text": "ExecutorService#shutdownNow will be a bit more aggressive in that it sends interrupt() to running Threads (but it is still up to the running application code how to deal with that)", "label": {"api": {"ExecutorService#shutdown": [[0, 23]], "ExecutorService#shutdownNow": [[0, 26]]}}}, {"text": "See Java Format String syntax", "label": {"api": {"Java Format String syntax": [[4, 28]]}}}, {"text": "I think DefaultTreeModel#setAsksAllowsChildren(boolean) is what you are looking for", "label": {"api": {"DefaultTreeModel#setAsksAllowsChildren(boolean)": [[8, 54]]}}}, {"text": "The Javadoc for deleteOnExit says", "label": {"api": {"Javadoc for deleteOnExit": [[4, 27]]}}}, {"text": "Instead of accessing it in constructor, you do it in method annotated with @PostConstruct which is fired when bean is fully initialized", "label": {"api": {"@PostConstruct": [[75, 88]]}}}, {"text": "Visit the String API to fuel your creative fire", "label": {"api": {"String API": [[10, 19]]}}}, {"text": "You can use the Field#get(Object obj) method to get the value of the field represented by the Field you are working with, on the specified object obj", "label": {"api": {"Field#get(Object obj)": [[16, 36]]}}}, {"text": "You can use the Integer.toBinaryString() method, which will give you a string representation of the integer argument as an unsigned integer in base 2", "label": {"api": {"Integer.toBinaryString()": [[16, 39]]}}}, {"text": "It might even be enough to use build in HTTPServer", "label": {"api": {"HTTPServer": [[40, 49]]}}}, {"text": "Please read the specs", "label": {"api": {"specs": [[16, 20]]}}}, {"text": "Use BigDecimal.compareTo(val) to compare if your Number is bigger, smaller or equal", "label": {"api": {"BigDecimal.compareTo(val)": [[4, 28]]}}}, {"text": "Here is simple example with help of viewToModel() and getLineOfOffset() methods", "label": {"api": {"viewToModel()": [[36, 48]], "getLineOfOffset()": [[54, 70]]}}}, {"text": "fx-text-background-color is a looked-up color that is defined as a ladder, as follows", "label": {"api": {"looked-up color": [[30, 44]]}}}, {"text": "Now this overrides the looked-up color value for the table cell, and since the graphic inside the cell doesn't override that value itself, it inherits it from the cell", "label": {"api": {"looked-up color": [[23, 37]]}}}, {"text": "If you want to store everything in lowercase use String#toLowerCase, in uppercase use String#toUpperCase", "label": {"api": {"String#toLowerCase": [[49, 66]], "String#toUpperCase": [[86, 103]]}}}, {"text": "Then when you have to actually treat it, you may use out of the bow methods, like String#equalsIgnoreCase(java.lang.String)", "label": {"api": {"String#equalsIgnoreCase(java.lang.String)": [[82, 122]]}}}, {"text": "List all delimiters in StringTokenizer, or drop this parameter for the default", "label": {"api": {"StringTokenizer": [[23, 37]]}}}, {"text": "Do it without StringTokenizer, using String.split", "label": {"api": {"StringTokenizer": [[14, 28]]}}}, {"text": "If I can encounter with an exception in a method, check if the exception can be described by any of the subclasses of Exception or, if possible, a subclass of RuntimeException", "label": {"api": {"Exception": [[118, 126], [166, 174]], "RuntimeException": [[159, 174]]}}}, {"text": "The javadocs provide enough info about the basic classes that extend from both Exception and RuntimeException and each exception class could also have more subclasses that weren't listed before e.g", "label": {"api": {"Exception": [[79, 87], [100, 108]], "RuntimeException": [[93, 108]]}}}, {"text": "If there's no subclass of Exception or RuntimeException or any, create a custom exception class or reuse one previously created but with a distinct message", "label": {"api": {"Exception": [[26, 34], [46, 54]], "RuntimeException": [[39, 54]]}}}, {"text": "Usually, I tend to create these classes extending from RuntimeException to avoid clients of the method using try-catch blocks", "label": {"api": {"Exception": [[62, 70]], "RuntimeException": [[55, 70]]}}}, {"text": "If there's the need to handle the exception in the client of this method, then it should extend from Exception", "label": {"api": {"Exception": [[101, 109]]}}}, {"text": "ElementNotFoundException, probably for not finding a specific kind of input e.g", "label": {"api": {"Exception": [[15, 23]]}}}, {"text": "BillGenerationException, generated when there's a problem after collecting the necessary data to generate the bill and in the exact process of generate the bill", "label": {"api": {"Exception": [[14, 22]]}}}, {"text": "You would be better off looking at the ScheduledExecutorService for this sort of application", "label": {"api": {"ScheduledExecutorService": [[39, 62]]}}}, {"text": "trim the line before splitting it", "label": {"api": {"trim": [[0, 3]]}}}, {"text": "You can use Arrays.copyOfRange()", "label": {"api": {"Arrays.copyOfRange()": [[12, 31]]}}}, {"text": "I'm getting to know Java 8 Stream API and I am unsure how to signal to a consumer of a stream that the stream is completed", "label": {"api": {"Java 8 Stream API": [[20, 36]]}}}, {"text": "How about using a HttpURLConnection and sending bytes instead of strings", "label": {"api": {"HttpURLConnection": [[18, 34]]}}}, {"text": "If you want logical calendar days, use DAYS.between() method from java.time.temporal.ChronoUnit", "label": {"api": {"DAYS.between()": [[39, 52]], "java.time.temporal.ChronoUnit": [[66, 94]]}}}, {"text": "If you want literal 24 hour days, (a duration), you can use the Duration class instead", "label": {"api": {"Duration": [[64, 71]]}}}, {"text": "For example, if you wanted to count the total number of tails seen by all threads, that counter would need to be declared as volatile, or be accessed only in synchronized blocks, or be of a special type like AtomicInteger", "label": {"api": {"AtomicInteger": [[208, 220]]}}}, {"text": "We can determine its exact value with the help of Math#ulp", "label": {"api": {"Math#ulp": [[50, 57]]}}}, {"text": "If you are using swing, I would recommend JWindow if you want to customize border, maximize, minimize, close buttons of the window of your application", "label": {"api": {"JWindow": [[42, 48]]}}}, {"text": "Use a java.util.Timer with its scheduleAtFixedRate() method", "label": {"api": {"java.util.Timer": [[6, 20]], "scheduleAtFixedRate()": [[31, 51]]}}}, {"text": "You need to iterate over the list of files in the folder containing the logs, filtering out any files that are outside of the given date-time range; this sounds exactly like a job for the FileFilter API as another answerer too pointed out", "label": {"api": {"FileFilter": [[188, 197]]}}}, {"text": "If you are familiar with Regular Expressions you could reuse Apache Commons' RegexFileFilter, but then you would have two problems", "label": {"api": {"FileFilter": [[82, 91]]}}}, {"text": "The order of addresses returned by java.net.InetAddress.getAllByName is undefined", "label": {"api": {"java.net.InetAddress.getAllByName": [[35, 67]]}}}, {"text": "If this is a problem, you should use a container such as ArrayList instead", "label": {"api": {"ArrayList": [[57, 65]]}}}, {"text": "ArrayList will automatically resize when needed", "label": {"api": {"ArrayList": [[0, 8]]}}}, {"text": "It could be a plain Class, or it could be any of the subinterfaces (e.g", "label": {"api": {"subinterfaces": [[53, 65]]}}}, {"text": "See String API for details", "label": {"api": {"String API": [[4, 13]]}}}, {"text": "When an interface hierarchy requires bridge methods but provides no defaults, the compiler has to generate code using LambdaMetafactory.altMetafactory rather than LambdaMetafactory.metafactory specifying every bridge method that is required", "label": {"api": {"LambdaMetafactory.altMetafactory": [[118, 149]], "LambdaMetafactory.metafactory": [[163, 191]]}}}, {"text": "If I understood your intentions correctly, this is a use case for Future", "label": {"api": {"Future": [[66, 71]]}}}, {"text": "Main thing is that your constructor is throwing FileNotFoundException (look here - https://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html#print%28char%29), which you have to catch (because it is checked)", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html#print%28char%29": [[83, 164]]}}}, {"text": "You could always create a servlet/jsp form or webservice deployed with the application to get the logger and set the level", "label": {"api": {"get the logger": [[90, 103]], "set the level": [[109, 121]]}}}, {"text": "You can supply a KeyStore object to the SslConfigurator, however, and that is more flexible than specifying a path, as it can be initialized from any input source, including a resource in a jar", "label": {"api": {"KeyStore": [[17, 24]]}}}, {"text": "You have called the executeUpdate(String) method, which is inherited from Statement and does not execute your prepared statement with placeholder variables, which explains why you get the", "label": {"api": {"executeUpdate(String)": [[20, 40]]}}}, {"text": "Call executeUpdate() instead, which is defined in PreparedStatement and does what you intended", "label": {"api": {"executeUpdate()": [[5, 19]]}}}, {"text": "The FileOutputStream API shows that the append param will..", "label": {"api": {"FileOutputStream API": [[4, 23]]}}}, {"text": "Instead of picking random elements, shuffle the array once and then iterate over the result", "label": {"api": {"shuffle": [[36, 42]]}}}, {"text": "It uses Class.cast() which avoids the warning, and also cleans up the generics bit (skipping the unneeded wildcard and specifying that it extends component)", "label": {"api": {"Class.cast()": [[8, 19]]}}}, {"text": "Make Node implement Comparable<Node>, so that the elements can be inserted according to their natural ordering", "label": {"api": {"natural ordering": [[94, 109]]}}}, {"text": "Use a custom Comparator<Node> and supply a compare method there, with an initial capacity", "label": {"api": {"custom Comparator<Node>": [[6, 28]]}}}, {"text": "So, you can remove that -1 or get rid of that substring and use contains instead", "label": {"api": {"contains": [[64, 71]]}}}, {"text": "So, after your edit use contains instead of substring you only have one error left (the last one I cuurently see )", "label": {"api": {"contains": [[24, 31]]}}}, {"text": "A CopyOnWriteArrayList avoid the disadvantages of a synchronized list but I'm not sure that setting the list to the new value is atomic", "label": {"api": {"CopyOnWriteArrayList": [[2, 21]]}}}, {"text": "Do I need to use a ReadWriteLock for achieve a thread-safe set", "label": {"api": {"ReadWriteLock": [[19, 31]]}}}, {"text": "If you want to ensure that reference is updated atomically you can use AtomicReference (or in your case enough to mark this reference as volatile), however if your goal is that updater thread should wait until all reading threads finish iterating over old list before updating the reference then ReadWriteLock is the way to go", "label": {"api": {"AtomicReference": [[71, 85]]}}}, {"text": "Your assumption is correct, the JRE-specific implementation receives the target method as a MethodHandle which has no information about generic types", "label": {"api": {"MethodHandle": [[92, 103]]}}}, {"text": "Since LambdaMetafactory explicitly requires a direct method handle, a method reference which encapsulates such a type cast cannot be passed as a MethodHandle to the factory", "label": {"api": {"MethodHandle": [[145, 156]], "LambdaMetafactory": [[6, 22]]}}}, {"text": "First solution would be to change the LambdaMetafactory to trust the MethodHandle if the receiver type is an interface and insert the required type cast by itself in the generated lambda class instead of rejecting it", "label": {"api": {"MethodHandle": [[69, 80]], "LambdaMetafactory": [[38, 54]]}}}, {"text": "Use a ListIterator, which allows you to make changes to the list through which you are iterating", "label": {"api": {"ListIterator": [[6, 17]]}}}, {"text": "There is more flexible way to deal with methods - MethodHandle class from java.lang.invoke package", "label": {"api": {"MethodHandle": [[50, 61]]}}}, {"text": "See https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html for examples", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html": [[4, 85]]}}}, {"text": "You should probably use an executor service or anything similar", "label": {"api": {"executor service": [[27, 42]]}}}, {"text": "set() overwrites the element at the given position", "label": {"api": {"set()": [[0, 4]]}}}, {"text": "But the parameter you are passing doesn't set the size but the initial capacity, meaning the initial size of the underlying array, which can be used before it has to be resized", "label": {"api": {"initial capacity": [[63, 78]]}}}, {"text": "If i understand your question correct, you should use the NIO Package", "label": {"api": {"NIO Package": [[58, 68]]}}}, {"text": "I used an IllegalArgumentException for this very purpose", "label": {"api": {"IllegalArgumentException": [[10, 33]]}}}, {"text": "Therefore, the Java process needs only read stdin, and in Java, this is System.in", "label": {"api": {"System.in": [[72, 80]]}}}, {"text": "As to using the find command, it's fine, really; but if you use Java 7+ you might consider using a FileVisitor instead and Files.walkFileTree()", "label": {"api": {"FileVisitor": [[99, 109]], "Files.walkFileTree()": [[123, 142]]}}}, {"text": "If you just need the time part of your Date object and you can't use Java 8 and don't want to use any third party framework, then use Calendar", "label": {"api": {"Calendar": [[134, 141]]}}}, {"text": "If you use the CharBuffer returned by mBuf.asCharBuffer(), that buffer's remaining() method will give you the number you expect", "label": {"api": {"mBuf.asCharBuffer()": [[38, 56]]}}}, {"text": "A CuncurrentHashMap per the Javadoc, provides A hash table supporting full concurrency of retrievals and adjustable expected concurrency for updates", "label": {"api": {"CuncurrentHashMap": [[2, 18]]}}}, {"text": "(Note the spec says only 1 method may be annotated in this manner", "label": {"api": {"spec": [[10, 13]]}}}, {"text": "This allows forces the construction of the subclass, frees the implementors from remembering the addListener() call, while still allows them to perform class-specific initialization", "label": {"api": {"spec": [[158, 161]]}}}, {"text": "The snapshot method is used to take a snapshot of the node and then ImageIO utilities are used to save the snapshot to disk", "label": {"api": {"snapshot": [[4, 11], [38, 45], [107, 114]], "ImageIO": [[68, 74]]}}}, {"text": "The method you are looking for is String.length()", "label": {"api": {"String.length()": [[34, 48]]}}}, {"text": "To apply the agent, put either class in a jar file and put it onto the agent path", "label": {"api": {"jar file and put it onto the agent path": [[42, 80]]}}}, {"text": "Another option is to take a look at using a ExecutorService", "label": {"api": {"ExecutorService": [[44, 58]]}}}, {"text": "Here is a simple example of how to use an ExecutorService", "label": {"api": {"ExecutorService": [[42, 56]]}}}, {"text": "GSON's toJson function takes a type argument which checks the Type when reflecting the object", "label": {"api": {"Type": [[62, 65]]}}}, {"text": "However, the only way I can find to obtain the Type is through an ugly set of coding contortions", "label": {"api": {"Type": [[47, 50]]}}}, {"text": "Is there a way of initializing the Type without referencing internal class variables", "label": {"api": {"Type": [[35, 38]]}}}, {"text": "java.io.Console has a method for reading passwords with output disabled", "label": {"api": {"java.io.Console": [[0, 14]]}}}, {"text": "However, the Comparable class documentation also states the following", "label": {"api": {"documentation also states the following": [[30, 68]]}}}, {"text": "It has  remainder method which does exactly what you want", "label": {"api": {"remainder": [[8, 16]]}}}, {"text": "You could return an OptionalDouble, which makes it obvious to the caller that they need to handle the case of the result not being found", "label": {"api": {"OptionalDouble": [[20, 33]]}}}, {"text": "Look at ArrayIndexOutOfBoundsException", "label": {"api": {"ArrayIndexOutOfBoundsException": [[8, 37]]}}}, {"text": "You're using Statement#executeQuery(String sql) which is inherited from Statement interface", "label": {"api": {"Statement#executeQuery(String sql)": [[13, 46]]}}}, {"text": "You should use PreparedStatement#executeQuery", "label": {"api": {"PreparedStatement#executeQuery": [[15, 44]]}}}, {"text": "SimpleDateFormat is not thread safe", "label": {"api": {"SimpleDateFormat": [[0, 15]]}}}, {"text": "Also Java has it's own general-purpose implementation of linked list", "label": {"api": {"linked list": [[57, 67]]}}}, {"text": "From the javadocs of Matcher#group()", "label": {"api": {"Matcher#group()": [[21, 35]]}}}, {"text": "As correctly mentioned by Pavel Horal the parameter is retrieved by ServletRequest#getParameter and is already decoded", "label": {"api": {"ServletRequest#getParameter": [[68, 94]]}}}, {"text": "One way would be to inject a HttpServletRequest and use  HttpServletRequest#getQueryString() which does not decode the values", "label": {"api": {"HttpServletRequest#getQueryString()": [[57, 91]]}}}, {"text": "Ironically, the c needs to be in uppercase for the toUpperCase method", "label": {"api": {"the toUpperCase method": [[47, 68]]}}}, {"text": "Set#add(E) returns true, if the element was added to the Set successfully, or false otherwise", "label": {"api": {"Set#add(E)": [[0, 9]]}}}, {"text": "IllegalArgumentException would be a good choice", "label": {"api": {"IllegalArgumentException": [[0, 23]]}}}, {"text": "To create a custom JSeparator, you can override the paint() method of BasicSeparatorUI, discussed here, and draw the line using a dashed Stroke, illustrated here", "label": {"api": {"JSeparator": [[19, 28]], "BasicSeparatorUI": [[70, 85]]}}}, {"text": "If you simply have the path to the jar, you can easily convert it to a File", "label": {"api": {"File": [[71, 74]]}}}, {"text": "getPassword returns a char array for a good reason - to prevent any lookup of the String due to the difficulty in erasing String content in memory", "label": {"api": {"getPassword": [[0, 10]]}}}, {"text": "In most Pane subclasses, if a Node is managed, then the parent pane of the node will manage its layoutX and layoutY properties", "label": {"api": {"managed": [[38, 44]]}}}, {"text": "Transformations (including the translation defined by translateX and translateY) are applied to nodes after the layout calculations (whether the node is managed by its parent or not)", "label": {"api": {"managed": [[153, 159]]}}}, {"text": "Another way is to manipulate the layoutX and layoutY properties (by setting them directly or by calling relocate), and make sure the node is not managed by its parent", "label": {"api": {"managed": [[145, 151]]}}}, {"text": "You can make the node unmanaged setManaged(false) on the node, or by putting it in a Pane instead of one of the subclasses (Pane does not manage layout of its child nodes)", "label": {"api": {"managed": [[24, 30]]}}}, {"text": "According to the PropertyValueFactory documentation, if you pass in a property name of \"xyz\", the property value factory will first look for a method xyzProperty() belonging to the object in the table row", "label": {"api": {"PropertyValueFactory documentation": [[17, 50]]}}}, {"text": "However, as stated in the PropertyValueFactory documentation, the properties in this case would not be \"live\"", "label": {"api": {"PropertyValueFactory documentation": [[26, 59]]}}}, {"text": "You need to wrap your code in AccessController.doPrivileged, like", "label": {"api": {"AccessController.doPrivileged": [[30, 58]]}}}, {"text": "If you don't need to use openCSV, you could use an implementation around RandomAccessFile", "label": {"api": {"RandomAccessFile": [[73, 88]]}}}, {"text": "Visit the String API to see all methods that can serve your needs", "label": {"api": {"String API": [[10, 19]]}}}, {"text": "If the pattern is fixed, you can easily write a method that splits the String and assign the second, third and fourth variables in a loop", "label": {"api": {"split": [[60, 64]]}}}, {"text": "Perhaps it's not the easiest to use, but for the description that you gave I would go with the Java Graphics API, you can easily find examples on how to use it", "label": {"api": {"Java Graphics API": [[95, 111]]}}}, {"text": "For more info, see docs for Collections.sort() & Comparator", "label": {"api": {"Collections.sort()": [[28, 45]], "Comparator": [[49, 58]]}}}, {"text": "So one possible solution to this problem is using correct line separators for your platform in toString method (use System.lineSeparator() as suggested by Julian Ladisch)", "label": {"api": {"System.lineSeparator()": [[116, 137]]}}}, {"text": "I don't see any opposite to the setFullScreenWindow method on the GraphicsDevice class", "label": {"api": {"GraphicsDevice": [[66, 79]]}}}, {"text": "The Arrays#toString method creates a more readable result", "label": {"api": {"Arrays#toString": [[4, 18]]}}}, {"text": "pstmtJ.executeUpdate(sql); → You're sending the original SQL string, since that is calling Statement.executeUpdate(String)", "label": {"api": {"Statement.executeUpdate(String)": [[91, 121]]}}}, {"text": "Use pstmtJ.executeUpdate(); instead (PreparedStatement.executeUpdate()) to execute the prepared statement", "label": {"api": {"PreparedStatement.executeUpdate()": [[37, 69]]}}}, {"text": "The way I understand your question, you can use a LineListener", "label": {"api": {"LineListener": [[50, 61]]}}}, {"text": "No, Math.random() will never return 1", "label": {"api": {"Math.random()": [[4, 16]]}}}, {"text": "First, the API does offer a subList() method", "label": {"api": {"subList()": [[28, 36]]}}}, {"text": "If the lists are immutable or are not modified, you can simply use the subList() method directly", "label": {"api": {"subList()": [[71, 79]]}}}, {"text": "If you need multiple views into the same list to allow concurrent modifications, you will need to use a concurrent list instead", "label": {"api": {"concurrent list": [[104, 118]]}}}, {"text": "When working with List objects, to retrieve the ith element, you have to invoke the List.get(int index) method", "label": {"api": {"List.get(int index)": [[84, 102]]}}}, {"text": "I would recommend having a look at the Pagination control", "label": {"api": {"Pagination": [[39, 48]]}}}, {"text": "check this out Frame and this Applet and look up in the left to see the tree of inheritance", "label": {"api": {"Frame": [[15, 19]], "Applet": [[30, 35]]}}}, {"text": "Both inherit from Container but Frame inherits from Window(from AWT) and Applet inherits from Panel(AWT)", "label": {"api": {"Frame": [[32, 36]], "Applet": [[73, 78]]}}}, {"text": "I am not an expert, still a student but I'm pretty sure that Frame and Applet does not inherit from one another", "label": {"api": {"Frame": [[61, 65]], "Applet": [[71, 76]]}}}, {"text": "From my knowledge a Frame is just a window on a machine(PC) with auto drawn buttons for Minimize,Maximize,Close  and a Content Pane where you put your stuff(TextFields etc...)", "label": {"api": {"Frame": [[20, 24]]}}}, {"text": "An Applet I know that works like a Frame but within a browser", "label": {"api": {"Frame": [[35, 39]], "Applet": [[3, 8]]}}}, {"text": "As mentioned in the comments, note that you're not overriding the correct equals method", "label": {"api": {"equals": [[74, 79]]}}}, {"text": "When the application reaches assert (initialBalance > 0);, if initialBalance is less than 0 and assertions are enabled, a java.lang.AssertionError will be thrown", "label": {"api": {"java.lang.AssertionError": [[122, 145]]}}}, {"text": "It would be wiser to throw a java.lang.IllegalArgumentException as follows", "label": {"api": {"java.lang.IllegalArgumentException": [[29, 62]]}}}, {"text": "If a DateFormatSymbols has been set explicitly with constructor SimpleDateFormat(String, DateFormatSymbols) or method setDateFormatSymbols(DateFormatSymbols), the month names given by the DateFormatSymbols are used", "label": {"api": {"SimpleDateFormat": [[64, 79]]}}}, {"text": "Point@15db9742 is the \"default\" output behavior of Object#toString()", "label": {"api": {"Object#toString()": [[51, 67]]}}}, {"text": "Enum already has a compareTo", "label": {"api": {"compareTo": [[19, 27]]}}}, {"text": "So although you can use the default compareTo of Values to compare cards of the same color, you still need to determine the actual value of a card within a turn", "label": {"api": {"compareTo": [[36, 44]]}}}, {"text": "You certainly should not create a compareTo within the card class", "label": {"api": {"compareTo": [[34, 42]]}}}, {"text": "For card games, compareTo should be used with care, and should not be made dynamic", "label": {"api": {"compareTo": [[16, 24]]}}}, {"text": "Remember, compareTo is for comparisons within a set of elements with a natural order", "label": {"api": {"compareTo": [[10, 18]]}}}, {"text": "to pass around matrix segments for pipelining) then I prefer to use something like a BlockingQueue", "label": {"api": {"BlockingQueue": [[85, 97]]}}}, {"text": "Method2 blocks with take until Method1 sends it a matrix segment to work on, then when Method2 is finished with the matrix segment it will send it on to Method3 via another BlockingQueue, then calls take again on the queue it shares with Method1", "label": {"api": {"BlockingQueue": [[173, 185]]}}}, {"text": "I'm using the Runnable interface, but as MadProgrammer said in the comments you can use Callable instead", "label": {"api": {"Runnable": [[14, 21]], "Callable": [[88, 95]]}}}, {"text": "The ExecutorService is responsible for assigning the Runnables to threads", "label": {"api": {"Runnable": [[53, 60]], "ExecutorService": [[4, 18]]}}}, {"text": "Per the documentation for SimpleDateFormat, HH:mm:ss a will always produce a time format in 24-hour notation, since H is geared to output 24-hour time values", "label": {"api": {"SimpleDateFormat": [[26, 41]]}}}, {"text": "Even if you are using your own buttons, you could still adapt the pattern used by swing's JButton", "label": {"api": {"JButton": [[90, 96]]}}}, {"text": "With JButton you have a separate ActionListener class to execute the action (or multiple actions if you add more listeners)", "label": {"api": {"JButton": [[5, 11]]}}}, {"text": "You can use the java.util.Scanner class to read the user's input, and then use either the if..else if.", "label": {"api": {"java.util.Scanner": [[16, 32]]}}}, {"text": "You can use URLConnection to call the servlet from your java client", "label": {"api": {"URLConnection": [[12, 24]]}}}, {"text": "There are three methods named wait defined in class Object", "label": {"api": {"Object": [[52, 57]]}}}, {"text": "Because there are three overloaded versions of the wait method, see the API documentation of class java.lang.Object", "label": {"api": {"java.lang.Object": [[99, 114]]}}}, {"text": "java.lang.Object indeed has three wait methods - one which takes no arguments, one which takes a long, and one which takes a long and an int", "label": {"api": {"java.lang.Object": [[0, 15]]}}}, {"text": "Take a look at the Scanner Class methods for more information", "label": {"api": {"the Scanner Class methods": [[15, 39]]}}}, {"text": "The @Cacheable annotation (JPA 2.0) at the entity level is standard", "label": {"api": {"@Cacheable": [[4, 13]]}}}, {"text": "this is the approach chosen by the JDK, see for example the javadoc of LocalDate", "label": {"api": {"javadoc of LocalDate": [[60, 79]]}}}, {"text": "For example, in a Person class you might have an ID property that uniquely identifies a Person, so the hashCode() of Person can simply be the hash of that ID", "label": {"api": {"hashCode": [[103, 110]]}}}, {"text": "In addition, the hashCode() is related to the implementation of equals", "label": {"api": {"hashCode": [[17, 24]]}}}, {"text": "If two objects are equal, they must have the same hashCode (the opposite doesn't have to be true - two non equal objects may still have the same hashCode)", "label": {"api": {"hashCode": [[50, 57], [145, 152]]}}}, {"text": "Therefore, if equality is determined by a single property (such as a unique ID), the hashCode method must also use only that single property", "label": {"api": {"hashCode": [[85, 92]]}}}, {"text": "This can be seen in the JavaDoc of hashCode", "label": {"api": {"hashCode": [[35, 42]]}}}, {"text": "The general contract of hashCode is", "label": {"api": {"hashCode": [[24, 31]]}}}, {"text": "Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified", "label": {"api": {"hashCode": [[104, 111]]}}}, {"text": "If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result", "label": {"api": {"hashCode": [[82, 89]]}}}, {"text": "It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results", "label": {"api": {"hashCode": [[118, 125]]}}}, {"text": "As noted in the documentation of Object, your equals() and hashCode() need to incorporate the same properties, be sure to verify that", "label": {"api": {"Object": [[33, 38]]}}}, {"text": "The only requirement the contract places upon you is that equal objects must return the same hash code", "label": {"api": {"requirement the contract places upon you": [[9, 48]]}}}, {"text": "If you know characteristics or the size of C you could construct an optimized Spliterator but that would indeed interfere with a future evolution of class C and therefore used with care", "label": {"api": {"construct an optimized Spliterator": [[55, 88]]}}}, {"text": "As shown here, you can get an InputStream from the Blob and pass it to ImageIO.read()", "label": {"api": {"ImageIO.read()": [[71, 84]]}}}, {"text": "You haven't shown the code that starts the threads, but it sounds like maybe you're assuming Runnables are Threads", "label": {"api": {"Runnable": [[93, 100]], "Thread": [[107, 112]]}}}, {"text": "A Runnable is just that", "label": {"api": {"Runnable": [[2, 9]]}}}, {"text": "a thing you can run by calling its run() method", "label": {"api": {"run()": [[35, 39]]}}}, {"text": "You create a separate thread which will run the Runnable by calling new Thread(r)", "label": {"api": {"Runnable": [[48, 55]], "Thread": [[72, 77]], "new Thread(r)": [[68, 80]]}}}, {"text": "Replacing the line r.run(); in the above example with", "label": {"api": {"run()": [[21, 25]]}}}, {"text": "make certain you are calling start() on your Thread objects, and not run()", "label": {"api": {"Thread": [[45, 50]], "start()": [[29, 35]], "run()": [[69, 73]]}}}, {"text": "Although Thread objects have a public run() method, this is a historical mistake in Java; you should never call it, because that just runs the code on the current thread without starting a new one", "label": {"api": {"Thread": [[9, 14]], "run()": [[38, 42]]}}}, {"text": "You can use a ServletContextListener to listen for a contextDestroyed event", "label": {"api": {"ServletContextListener": [[14, 35]]}}}, {"text": "The bigger problem is it doesn't work because the list returned by Arrays.asList is backed by the underlying array, and so it has a fixed size", "label": {"api": {"Arrays.asList": [[67, 79]]}}}, {"text": "You can use subList instead of remove to get it working", "label": {"api": {"subList": [[12, 18]]}}}, {"text": "This means that the resulting list actually consists of two list objects (the asList and its subList), which may or may not bother you", "label": {"api": {"subList": [[93, 99]]}}}, {"text": "You can check ProcessBuilder to run system commands", "label": {"api": {"ProcessBuilder": [[14, 27]]}}}, {"text": "As @thatotherguy points out in comments, the Hibernate implementation of AbstractUUIDGenerator and UUIDHexGenerator is pretty far away from being RFC-4122 compliant", "label": {"api": {"UUID": [[81, 84], [99, 102]]}}}, {"text": "That aside, taking its implementation for what it is, the root cause of your issue here boils down to UUIDHexGenerators use of InetAddress.getLocalHost() (via AbstractUUIDGenerator) to come up with a \"unique\" value", "label": {"api": {"InetAddress.getLocalHost()": [[127, 152]], "UUID": [[102, 105], [167, 170]]}}}, {"text": "Still, you will not be using proper UUIDs (same caveat as last part of the next point)", "label": {"api": {"UUID": [[36, 39]]}}}, {"text": "If Hibernate's algorithm is insufficient, you can define a custom IdentifierGenerator and provide a better UUID generation algorithm more suitable for your task", "label": {"api": {"UUID": [[107, 110]]}}}, {"text": "I would base this off of Java's built-in UUID, which is compliant", "label": {"api": {"UUID": [[41, 44]]}}}, {"text": "However, you could probably \"hack\" it by extending UUIDHexGenerator and overriding protected int getIP() to return an accurate IP address", "label": {"api": {"UUID": [[51, 54]]}}}, {"text": "This is a hack because of AbstractUUIDGenerators implementation (your getIP() would no longer return the value of its IP instance field) and because it still wouldn't be a proper UUID", "label": {"api": {"UUID": [[34, 37], [179, 182]]}}}, {"text": "Instead of using a generator, specify manual ID assignment, and generate the UUIDs yourself", "label": {"api": {"UUID": [[77, 80]]}}}, {"text": "Again, Java's UUID can work for you here", "label": {"api": {"UUID": [[14, 17]]}}}, {"text": "There is a newer UUID generator strategy, \"uuid2\", which uses UUIDGenerator", "label": {"api": {"UUID": [[17, 20], [62, 65]]}}}, {"text": "I have not used this strategy before and cannot speak for it; however, as Andrew Stein observed in the comments below, an inspection of the source shows that it provides a strategy built around Java's UUID, making it likely to be a good bet, and certainly better than the older AbstractUUIDGenerator-derived variants", "label": {"api": {"UUID": [[201, 204], [286, 289]]}}}, {"text": "Option 1 is the simplest quick fix if it works for you, but could have maintenance / deployment issues and, again, doesn't really generate well-formed UUIDs", "label": {"api": {"UUID": [[151, 154]]}}}, {"text": "In the long run, option 2 using UUID (or option 4 with the appropriate strategy) is probably the most correct", "label": {"api": {"UUID": [[32, 35]]}}}, {"text": "There is an article describing various UUID assignment strategies for Hibernate, which may contain some more helpful insights and examples", "label": {"api": {"UUID": [[39, 42]]}}}, {"text": "You can use Collections#reverse on a List which reverses its elements", "label": {"api": {"Collections#reverse": [[12, 30]]}}}, {"text": "You loose the options of #equalsIgnoreCase() though", "label": {"api": {"#equalsIgnoreCase()": [[25, 43]]}}}, {"text": "Another option is to use a ConcurrentMap, which offers the putIfAbsent() method", "label": {"api": {"putIfAbsent() method": [[59, 78]]}}}, {"text": "If you need some particular definition of equality besides one defined by the supertype, you should write a class structure that will properly do this for you", "label": {"api": {"the supertype": [[74, 86]]}}}, {"text": "Arrays are objects too, but they don't override Object's toString() method, which is responsible for the output [[C@36d98810", "label": {"api": {"Object's toString() method": [[48, 73]]}}}, {"text": "Because it's a multi-dimensional array, you should call Arrays.deepToString to output the contents of the entire array", "label": {"api": {"Arrays.deepToString": [[56, 74]]}}}, {"text": "I would suggest getting a Buffered Reader, using its readLine() method to read one line outside of the loop (the first line) into a string and concatenating that with your <h1> and </h1>", "label": {"api": {"Buffered Reader": [[26, 40]]}}}, {"text": "I won't explain the whole concept but Java provides these things in the java.util.concurrent.Semaphore class", "label": {"api": {"java.util.concurrent.Semaphore": [[72, 101]]}}}, {"text": "From the LogRecord.getSourceMethodName documentation", "label": {"api": {"LogRecord.getSourceMethodName": [[9, 37]]}}}, {"text": "You can create and install a filter on the AsynchFileHandler to force compute the method and class names before a the thread hand off", "label": {"api": {"install a filter": [[19, 34]]}}}, {"text": "Even the MemoryHandler included with the JDK gets this wrong", "label": {"api": {"MemoryHandler": [[9, 21]]}}}, {"text": "You can use java.util.Collections.nCopies, which, well, makes N copies of the object passed to it", "label": {"api": {"java.util.Collections.nCopies": [[12, 40]]}}}, {"text": "You can use this syntax on any array type, or class that implements Iterable", "label": {"api": {"Iterable": [[68, 75]]}}}, {"text": "names) because the type of the variable on the left side of the colon must be assignable from the Iterable's generic type", "label": {"api": {"Iterable": [[98, 105]]}}}, {"text": "An ArrayList<String> implements Iterable<String>, so the variable to the left of the colon must be assignable from String, which int is not", "label": {"api": {"Iterable": [[32, 39]]}}}, {"text": "You can simplify the code a little by making use of Arrays#copyOf (which allows the copy to be one element longer than the original)", "label": {"api": {"Arrays#copyOf": [[52, 64]]}}}, {"text": "The ListView has a cell rendering mechanism that is similar to that used for TableColumns (but is simpler as you don't have to worry about multiple columns)", "label": {"api": {"cell rendering mechanism": [[19, 42]]}}}, {"text": "I've tried http://www.doublecloud.org/2014/04/java-8-new-features-nashorn-javascript-engine/ , https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/api.html , and How to instantiate a Java class in JavaScript using Nashorn", "label": {"api": {"https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/api.html": [[95, 175]]}}}, {"text": "You have problems with JList model, you create it with DefaultListModel, but then you use dropZone.setListData(directyName.toArray()); which recreate model, because of you get Exception at next line DefaultListModel model = (DefaultListModel) list.getModel();", "label": {"api": {"dropZone.setListData(directyName.toArray());": [[90, 133]]}}}, {"text": "As you don't use regexps, you don't need replaceAll(),  and you can use replace() instead", "label": {"api": {"replaceAll()": [[41, 52]], "replace()": [[72, 80]]}}}, {"text": "Create a custom Comparator<String> to sort strings based on their length", "label": {"api": {"Comparator<String>": [[16, 33]]}}}, {"text": "Get the shortest string from your list by using your custom comparator with the Collections.min() method", "label": {"api": {"Collections.min()": [[80, 96]]}}}, {"text": "The DAY_OF_WEEK field in class Calendar uses int", "label": {"api": {"DAY_OF_WEEK": [[4, 14]], "Calendar": [[31, 38]]}}}, {"text": "One way would be to use the Java Debug Interface  to capture function arguments, this, and locals for all the functions in the stacktrace", "label": {"api": {"Java Debug Interface ": [[28, 48]], "function arguments": [[61, 78]], "locals": [[91, 96]], "stacktrace": [[127, 136]]}}}, {"text": "Otherwise, you could use instrumentation agents to modify the byte codes of methods to capture the information for use in your exception handler", "label": {"api": {"instrumentation agents": [[25, 46]]}}}, {"text": "Probably you are looking for ConcurrentLinkedQueue, this will store the items based on the FiFo (first in first out) order", "label": {"api": {"ConcurrentLinkedQueue": [[29, 49]]}}}, {"text": "If you don't want to keep polling for data, then you can also resort to classes implementing the BlockingQueue interface, this offers functions that wait until data is available", "label": {"api": {"BlockingQueue": [[97, 109]]}}}, {"text": "If you are on java 8, use built-in base64 codec", "label": {"api": {"base64 codec": [[35, 46]]}}}, {"text": "As the JavaDoc of reduce says, reduce is equivalent to", "label": {"api": {"reduce": [[18, 23], [31, 36]]}}}, {"text": "more), Files.lines(Path path), and Stream.toArray()", "label": {"api": {"Files.lines(Path path)": [[7, 28]], "Stream.toArray()": [[35, 50]]}}}, {"text": "You can use HttpSessionActivationListener and implement your cleanup logic in sessionWillPassivate method", "label": {"api": {"HttpSessionActivationListener": [[12, 40]]}}}, {"text": "If you are returning XML and your object is annotated with JAXB annotations, you can use @XmlTransient annotation to achieve the same result", "label": {"api": {"@XmlTransient": [[89, 101]]}}}, {"text": "You can use the sort method from Arrays class using a Comparator", "label": {"api": {"sort": [[16, 19]], "Comparator": [[54, 63]]}}}, {"text": "You might notice if you have a quick look at the Collecion javadoc that collections are supposed to implement a toArray method", "label": {"api": {"Collecion javadoc": [[49, 65]]}}}, {"text": "You could use #setPrefWidth method from TreeTableColumn class to set preferred width for columns", "label": {"api": {"#setPrefWidth": [[14, 26]]}}}, {"text": "Alternatively, you could change your adapter to one backed by a list instead of a cursor, and implement a Comparator to sort the data", "label": {"api": {"Comparator": [[106, 115]]}}}, {"text": "See Object#getClass in the API", "label": {"api": {"Object#getClass": [[4, 18]]}}}, {"text": "Just use the java.util.Queue interface", "label": {"api": {"java.util.Queue": [[13, 27]]}}}, {"text": "You could use something like ColorStringParser from JSAP", "label": {"api": {"Color": [[29, 33]]}}}, {"text": "You could use reflection creatively to look up the static fields of Color by name", "label": {"api": {"Color": [[68, 72]]}}}, {"text": "The simplest, really, is to probably just roll your own with a Map<String,Color> or Map<String,Integer>; converting strings to lowercase as needed to provide case-insensitivity if desired", "label": {"api": {"Color": [[74, 78]]}}}, {"text": "You can get it from Session, and you can get Session from EntityManager", "label": {"api": {"from Session": [[15, 26]]}}}, {"text": "https://docs.oracle.com/javase/7/docs/api/java/awt/GridLayout.html for more information about gridlayout can be found here", "label": {"api": {"https://docs.oracle.com/javase/7/docs/api/java/awt/GridLayout.html": [[0, 65]]}}}, {"text": "You did not specify any requirements (except speed of calculation), but take a look at java.util.Arrays#hashCode", "label": {"api": {"java.util.Arrays#hashCode": [[87, 111]]}}}, {"text": "You can use non-editable JTextArea instead", "label": {"api": {"JTextArea": [[25, 33]]}}}, {"text": "Furthermore, as Oliver mentioned, a similar method exists with System.out.printf(), only the syntax of the format string is different", "label": {"api": {"System.out.printf()": [[63, 81]], "syntax of the format string": [[93, 119]]}}}, {"text": "Try checking Thread.isInterrupted() in the main loop of your Daemon class", "label": {"api": {"Thread.isInterrupted()": [[13, 34]]}}}, {"text": "Opposed to that the naked EntityManager#persist() throws an exception if invoked with already existing entity", "label": {"api": {"EntityManager#persist()": [[26, 48]]}}}, {"text": "In both cases the custom behavior would include a new persist() method delegating to EntityManager#persist()", "label": {"api": {"EntityManager#persist()": [[85, 107]]}}}, {"text": "In java 8+ you can also use Comparator.thenComparing to combine 2 comparators", "label": {"api": {"Comparator.thenComparing": [[28, 51]]}}}, {"text": "Use Integer.parseInt(String s)", "label": {"api": {"Integer.parseInt(String s)": [[4, 29]]}}}, {"text": "Runtime.getRuntime().addShutdownHook() should run even on ^C", "label": {"api": {"Runtime.getRuntime().addShutdownHook()": [[0, 37]]}}}, {"text": "One final thing here is that you are likely to encounter and IndexOutOfBoundsException in your second loop because you are going until i < n, but you declare each array to be of size \"10\"", "label": {"api": {"IndexOutOfBoundsException": [[61, 85]]}}}, {"text": "See Calendar#DAY_OF_WEEK and Constant Field Values, Calendar#WEDNESDAY, it's plain out there in the documentation", "label": {"api": {"Calendar#DAY_OF_WEEK": [[4, 23]], "Constant Field Values, Calendar#WEDNESDAY": [[29, 69]]}}}, {"text": "It seems like LLL doesn't exist ; if you want the format for months, it's MMM instead", "label": {"api": {"It seems like": [[0, 12]]}}}, {"text": "It’s easy to convert a BufferedReader into a stream for each line, just use the method BufferedReader.lines() made exactly for this purpose", "label": {"api": {"BufferedReader.lines()": [[87, 108]]}}}, {"text": "Of course, you can simply use Files.lines, skipping the BufferedReader part entirely, unless you need a specially configured CharSetDecoder", "label": {"api": {"Files.lines": [[30, 40]]}}}, {"text": "The usual way of creating custom Streams is to implement Spliterator and create a Stream using the method StreamSupport.stream", "label": {"api": {"Spliterator": [[57, 67]], "StreamSupport.stream": [[106, 125]]}}}, {"text": "The foreach loop only works on Iterable objects", "label": {"api": {"Iterable": [[31, 38]]}}}, {"text": "These are basically classes that implement Iterable", "label": {"api": {"Iterable": [[43, 50]]}}}, {"text": "The Iterable interface requires the Iterator<T> iterator() method", "label": {"api": {"Iterable": [[4, 11]], "Iterator<T> iterator()": [[36, 57]]}}}, {"text": "You will no longer be able to access like a File, but instead will need to use Class#getResource, passing it the path from the top of the source tree to where the file is stored", "label": {"api": {"Class#getResource": [[79, 95]]}}}, {"text": "I recently came across FileChannel, I am a big fan of RandomAccessFile", "label": {"api": {"FileChannel": [[23, 33]], "RandomAccessFile": [[54, 69]]}}}, {"text": "But I am wondering why would I pick FileChannel over RandomAccessFile for reading from a file and writing that content to another", "label": {"api": {"FileChannel": [[36, 46]], "RandomAccessFile": [[53, 68]]}}}, {"text": "I dont want to use locking of FileChannel for any purpose as I believe that could be one of the reasons why filechannel can be used", "label": {"api": {"FileChannel": [[30, 40]]}}}, {"text": "Arrays.toString should give you more useful output", "label": {"api": {"Arrays.toString": [[0, 14]]}}}, {"text": "Or better yet, you could use Arrays.deepToString to print the entire \"parent\" array", "label": {"api": {"Arrays.deepToString": [[29, 47]]}}}, {"text": "If you want to do background jobs that take some time in Swing, you should use SwingWorker (Oracle's tutorial, although not really that helpful..", "label": {"api": {"SwingWorker": [[79, 89]]}}}, {"text": "For that we would use a JSeparator", "label": {"api": {"JSeparator": [[24, 33]]}}}, {"text": "The only thing I have managed to find is BMPImageWriteParam but I have no idea whatsoever how to use that", "label": {"api": {"BMPImageWriteParam": [[41, 58]]}}}, {"text": "If you want to save an image using custom parameters, you have to use an ImageWriter to which you can pass custom parameters to write the output file", "label": {"api": {"ImageWriter": [[73, 83]]}}}, {"text": "You can get the params from an ImageWriter using its getDefaultWriteParam() method where you can set the compression type", "label": {"api": {"ImageWriter": [[31, 41]], "getDefaultWriteParam()": [[53, 74]]}}}, {"text": "You don't even have to cast it to BMPImageWriteParam because setting the compression type is available via the ImageWriter super interface", "label": {"api": {"ImageWriter": [[111, 121]], "BMPImageWriteParam": [[34, 51]]}}}, {"text": "Note that in order to use a custom compression type, you have to set the compression mode to ImageWriteParam.MODE_EXPLICIT", "label": {"api": {"ImageWriteParam.MODE_EXPLICIT": [[93, 121]]}}}, {"text": "Note that BI_RLE8 compression is not available for all types of BufferedImages", "label": {"api": {"BufferedImage": [[64, 76]]}}}, {"text": "For exmaple BI_RLE8 compression is supported for BufferedImage.TYPE_BYTE_INDEXED and BufferedImage.TYPE_BYTE_GRAY but it is not supported for BufferedImage.TYPE_3BYTE_BGR in which case an IOException will be thrown by the ImageWriter.write() method (which is actually BMPImageWriter.write())", "label": {"api": {"ImageWriter": [[222, 232], [271, 281]], "BufferedImage": [[49, 61], [85, 97], [142, 154]]}}}, {"text": "You can simply get the user input from the components you passed to showOptionDialog() after it has returned", "label": {"api": {"showOptionDialog()": [[68, 85]]}}}, {"text": "the 4th parameter of showOptionDialog() is the option type so it should be YES_NO_OPTION and not DEFAULT_OPTION", "label": {"api": {"showOptionDialog()": [[21, 38]]}}}, {"text": "Take a look at BufferedReader, this should have what you need", "label": {"api": {"BufferedReader": [[15, 28]]}}}, {"text": "That is not weired, but the default implementation of the toString() method", "label": {"api": {"toString()": [[58, 67]]}}}, {"text": "See the API documentation of java.text.SimpleDateFormat", "label": {"api": {"java.text.SimpleDateFormat": [[29, 54]]}}}, {"text": "See as an example Math#max", "label": {"api": {"Math#max": [[18, 25]]}}}, {"text": "Now look at PrintStream#println", "label": {"api": {"PrintStream#println": [[12, 30]]}}}, {"text": "If the third party library has properly configured its manifest, you can use Package.isCompatibleWith(String) (preferred) or Package.getSpecificationVersion() (less desirable)", "label": {"api": {"Package.isCompatibleWith(String)": [[77, 108]], "Package.getSpecificationVersion()": [[125, 157]]}}}, {"text": "The following example demonstrates a custom dialog that validates the user's input each time the text changes using a KeyListener", "label": {"api": {"KeyListener": [[118, 128]]}}}, {"text": "A CharSequence is an interface; it happens that String implements it", "label": {"api": {"CharSequence": [[2, 13]]}}}, {"text": "This means that for instance, when you call .charAt() on a String, what is really called is the implementation of String for this method of CharSequence", "label": {"api": {"CharSequence": [[140, 151]]}}}, {"text": "As you can see from the javadoc of CharSequence, not many classes in the JDK actually implement this interface", "label": {"api": {"CharSequence": [[35, 46]]}}}, {"text": "As to why two constructors, StringBuffer dates back to Java 1.0 and CharSequence appears in 1.4 only; however, this is also the case that StringBuilder (which you should use, really, instead of StringBuffer) has two constructors (one with a CharSequence as an argument, another with a String as an argument), so there are probably optimizations implied when a String is passed as an argument", "label": {"api": {"CharSequence": [[68, 79], [241, 252]], "StringBuilder": [[138, 150]]}}}, {"text": "As an example of a CharSequence implementation which is not in the JDK, you can for example see one of my projects", "label": {"api": {"CharSequence": [[19, 30]]}}}, {"text": "Note that among other things, generating a Matcher from a Pattern uses a CharSequence and not a String as an argument; and since String implements CharSequence, well, passing a String as an argument works", "label": {"api": {"CharSequence": [[73, 84], [147, 158]], "uses a CharSequence and not a String as an argument": [[66, 116]]}}}, {"text": "There are two types of constructor for TreeSets - ones where you specify an explicit Comparator, and ones where you do not", "label": {"api": {"Comparator": [[85, 94]]}}}, {"text": "Since you can't make ArrayLists implement Comparable, you need to provide your own Comparator when you're constructing the TreeSet to assign to coords", "label": {"api": {"Comparator": [[83, 92]], "when you're constructing the TreeSet": [[94, 129]]}}}, {"text": "Yes, this is what System.inheritedChannel() is for", "label": {"api": {"System.inheritedChannel()": [[18, 42]]}}}, {"text": "package) that the given class is in unless you give it an absolute path (see the API documentation); If it can't find the resource on the classpath in this namespace, it returns null", "label": {"api": {"the API documentation": [[77, 97]]}}}, {"text": "You should be able to change the JVM's copy using Reflection", "label": {"api": {"Reflection": [[50, 59]]}}}, {"text": "I'm using the DataInputStream class to read data on the server side, which requires special encoding to create \"Blocks\" of networked data, as-well as some customized encoding for primitive data-types, and a custom encoding for UTF data-types", "label": {"api": {"DataInputStream": [[14, 28]]}}}, {"text": "You should be able to retrieve the timezone, the GMT offset and the different local current times using the Timezone class and the GregorianCalendar class like this", "label": {"api": {"Timezone": [[108, 115]], "GregorianCalendar": [[131, 147]]}}}, {"text": "Accroding to https://docs.oracle.com/javafx/2/api/javafx/animation/Animation.html#play()", "label": {"api": {"https://docs.oracle.com/javafx/2/api/javafx/animation/Animation.html#play()": [[13, 87]]}}}, {"text": "Then you just use TreeMap.headMap()", "label": {"api": {"TreeMap.headMap()": [[18, 34]]}}}, {"text": "The SECONDS constant, along with the other time constants, come from the ChronoUnit enum", "label": {"api": {"ChronoUnit enum": [[73, 87]]}}}, {"text": "It's a value from the ChronoUnit enum, implementing TemporalUnit - your code can be written as", "label": {"api": {"ChronoUnit": [[22, 31]], "TemporalUnit": [[52, 63]]}}}, {"text": "Presumably you're using it without explicitly specifying ChronoUnit due to a staic import", "label": {"api": {"ChronoUnit": [[57, 66]]}}}, {"text": "One way is to override the HttpServlet.service method and call the methods as desired", "label": {"api": {"HttpServlet.service": [[27, 45]]}}}, {"text": "Use a ProcessBuilder", "label": {"api": {"ProcessBuilder": [[6, 19]]}}}, {"text": "I think you need to create a new process on your os, the sole way of creating a new process in java is the Runtime.exec", "label": {"api": {"Runtime.exec": [[107, 118]]}}}, {"text": "Vectors have been deprecated for ages", "label": {"api": {"Vector": [[0, 5]]}}}, {"text": "Unless you particularly need it's thread safety, just use an ArrayList - it'll be faster", "label": {"api": {"ArrayList": [[61, 69]]}}}, {"text": "And even if you do require your collection to be thread safe, there are better choices in modern JDKs, such as the CopyOnWriteArrayList", "label": {"api": {"ArrayList": [[126, 134]], "CopyOnWriteArrayList": [[115, 134]]}}}, {"text": "Instead of coding for a fixed number width, use a split call", "label": {"api": {"split": [[50, 54]]}}}, {"text": "for loop to iterate the array and String.contains to see if items contain your search term", "label": {"api": {"String.contains": [[34, 48]]}}}, {"text": "The default format of date display by the JSpinner is locale-dependent, but you can customize the date formatting by explicitly setting a JSpinner.DateEditor instance with your desired format as the spinner's editor component", "label": {"api": {"JSpinner.DateEditor": [[138, 156]], "the spinner's editor component": [[195, 224]]}}}, {"text": "As suggested by the authors of setBorder(), add the border proposed by @mprabhat to the button's surrounding container", "label": {"api": {"setBorder()": [[31, 41]]}}}, {"text": "The way to go at it is to use Class.getEnumConstants()", "label": {"api": {"Class.getEnumConstants()": [[30, 53]]}}}, {"text": "The proper way to interrupt a call to DatagramSocket.receive() is to close the socket, and receive() will then throw a SocketException", "label": {"api": {"throw a SocketException": [[111, 133]]}}}, {"text": "There is a method setMouseTransparent which you can use on the front layer", "label": {"api": {"setMouseTransparent": [[18, 36]]}}}, {"text": "If you have a look at the documentation for Method, you'll see that it has no methods for altering its state, beyond setAccessible(), which doesn't help you", "label": {"api": {"Method": [[44, 49]]}}}]